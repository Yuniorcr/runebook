<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="rails">
    <body>
      <group id="rails">
        <trans-unit id="41605890c3eea5d388ea84f23ae720211a781c79" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Firm#clients&lt;/code&gt; is called, it will in turn call &lt;code&gt;MyApplication::Business::Client.find_all_by_firm_id(firm.id)&lt;/code&gt;. If you want to associate with a class in another module scope, this can be done by specifying the complete class name.</source>
          <target state="translated">때 &lt;code&gt;Firm#clients&lt;/code&gt; 호출, 그것은 것입니다 차례 통화에서 &lt;code&gt;MyApplication::Business::Client.find_all_by_firm_id(firm.id)&lt;/code&gt; . 다른 모듈 범위의 클래스와 연관 시키려면 전체 클래스 이름을 지정하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ecb5ad115aab997cdcdad384c9aa0f0d2155d59a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;cache_classes&lt;/code&gt; is true (in &lt;code&gt;production&lt;/code&gt;, by default), the Reloader is only a pass-through to the Executor.</source>
          <target state="translated">때 &lt;code&gt;cache_classes&lt;/code&gt; 가 (에 사실 &lt;code&gt;production&lt;/code&gt; 기본적으로)에 장전 만 집행 인에 통과입니다.</target>
        </trans-unit>
        <trans-unit id="de9ecae7d4aedf350a48e00d3f786b9eae87dbb4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;config.cache_classes&lt;/code&gt; is false Rails is able to reload autoloaded constants.</source>
          <target state="translated">때 &lt;code&gt;config.cache_classes&lt;/code&gt; 이 거짓 레일입니다 재 장전 자동으로 적재 상수 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d5ac98cde8a9c7b5ad55e445c81a57c693b787b5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;instance_eval&lt;/code&gt; is called using a string argument, the singleton class of the receiver is pushed to the nesting of the eval'ed code. When &lt;code&gt;class_eval&lt;/code&gt; or &lt;code&gt;module_eval&lt;/code&gt; is called using a string argument, the receiver is pushed to the nesting of the eval'ed code.</source>
          <target state="translated">때 &lt;code&gt;instance_eval&lt;/code&gt; 는 문자열 인수를 사용하여 호출되고, 수신기의 싱글 톤 클래스는 eval'ed 코드의 중첩에 푸시됩니다. 때 &lt;code&gt;class_eval&lt;/code&gt; 또는 &lt;code&gt;module_eval&lt;/code&gt; 는 문자열 인수를 사용하여 호출되면, 수신기는 eval'ed 코드의 중첩에 푸시됩니다.</target>
        </trans-unit>
        <trans-unit id="d604f2ba57c7f4ab3e3d2e92c260b23aa55646b8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;params[:token]&lt;/code&gt; is one of: &lt;code&gt;[nil]&lt;/code&gt;, &lt;code&gt;[nil, nil, ...]&lt;/code&gt; or &lt;code&gt;['foo', nil]&lt;/code&gt; it will bypass the test for &lt;code&gt;nil&lt;/code&gt;, but &lt;code&gt;IS NULL&lt;/code&gt; or &lt;code&gt;IN ('foo', NULL)&lt;/code&gt; where clauses still will be added to the SQL query.</source>
          <target state="translated">경우 &lt;code&gt;params[:token]&lt;/code&gt; 중 하나이다 : &lt;code&gt;[nil]&lt;/code&gt; , &lt;code&gt;[nil, nil, ...]&lt;/code&gt; 또는 &lt;code&gt;['foo', nil]&lt;/code&gt; 는 대 시험 우회 &lt;code&gt;nil&lt;/code&gt; 하지만 &lt;code&gt;IS NULL&lt;/code&gt; 또는 &lt;code&gt;IN ('foo', NULL)&lt;/code&gt; where 절은 여전히 ​​SQL 쿼리에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2a6fc1e5b3e599bcf86d8000d184dc66fd92c8f3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;post&lt;/code&gt; is a new, unsaved &lt;a href=&quot;../activerecord/base&quot;&gt;ActiveRecord::Base&lt;/a&gt; instance, the resulting HTML is:</source>
          <target state="translated">때 &lt;code&gt;post&lt;/code&gt; 새로운 저장되지 않은 것입니다 &lt;a href=&quot;../activerecord/base&quot;&gt;액티브 :: 자료&lt;/a&gt; 인스턴스가, 결과 HTML은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="68ed8553a98f4495cbdea9061fec5d6841574b6c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;post&lt;/code&gt; is a persisted &lt;a href=&quot;../activerecord/base&quot;&gt;ActiveRecord::Base&lt;/a&gt; instance, the resulting HTML is:</source>
          <target state="translated">때 &lt;code&gt;post&lt;/code&gt; A가 유지됩니다 &lt;a href=&quot;../activerecord/base&quot;&gt;액티브 :: 자료&lt;/a&gt; 인스턴스를 생성 된 HTML은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="42064b8ffcf21cb5045f2193a0984deeb4ccfddf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;require APP_PATH&lt;/code&gt; is executed, &lt;code&gt;config/application.rb&lt;/code&gt; is loaded (recall that &lt;code&gt;APP_PATH&lt;/code&gt; is defined in &lt;code&gt;bin/rails&lt;/code&gt;). This file exists in your application and it's free for you to change based on your needs.</source>
          <target state="translated">경우 &lt;code&gt;require APP_PATH&lt;/code&gt; 실행되고, &lt;code&gt;config/application.rb&lt;/code&gt; (리콜로드 &lt;code&gt;APP_PATH&lt;/code&gt; 가 정의되어 &lt;code&gt;bin/rails&lt;/code&gt; ). 이 파일은 응용 프로그램에 존재하며 필요에 따라 자유롭게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa838158cc71c78374e57b1723bece69410843eb" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;not&lt;/strong&gt; to use transactional tests:</source>
          <target state="translated">때 &lt;strong&gt;하지&lt;/strong&gt; 트랜잭션 테스트를 사용합니다 :</target>
        </trans-unit>
        <trans-unit id="d7b1bda2a58d174ea810859d51cd678ae4e0f051" translate="yes" xml:space="preserve">
          <source>When Constants aren't Missed</source>
          <target state="translated">상수가 누락되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="b987e3f67db3099102472ac50072723653dc5969" translate="yes" xml:space="preserve">
          <source>When Does Validation Happen?</source>
          <target state="translated">유효성 검사는 언제 발생합니까?</target>
        </trans-unit>
        <trans-unit id="1133542f262fa103eb88b9fe1c69121d20a64a09" translate="yes" xml:space="preserve">
          <source>When Helpers aren't Enough</source>
          <target state="translated">도우미가 충분하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="11eee985b0136d59e745e36c37d356e920c9bbcf" translate="yes" xml:space="preserve">
          <source>When Rails looks for a view to render, it will first look in the &lt;code&gt;app/views&lt;/code&gt; directory of the application. If it cannot find the view there, it will check in the &lt;code&gt;app/views&lt;/code&gt; directories of all engines that have this directory.</source>
          <target state="translated">Rails가 렌더링 할 뷰를 찾으면 먼저 &lt;code&gt;app/views&lt;/code&gt; 의 app / views 디렉토리를 찾습니다 . 뷰를 찾을 수 없으면 이 디렉토리가있는 모든 엔진 의 &lt;code&gt;app/views&lt;/code&gt; 디렉토리를 체크인합니다 .</target>
        </trans-unit>
        <trans-unit id="c7d3853f40dac2c4fa5ae322fed6fa24ff33482a" translate="yes" xml:space="preserve">
          <source>When Rails renders a view as a response, it does so by combining the view with the current layout, using the rules for finding the current layout that were covered earlier in this guide. Within a layout, you have access to three tools for combining different bits of output to form the overall response:</source>
          <target state="translated">Rails가 뷰를 응답으로 렌더링 할 때이 가이드의 앞부분에서 다루었던 현재 레이아웃을 찾기위한 규칙을 사용하여 뷰를 현재 레이아웃과 결합하여 렌더링합니다. 레이아웃 내에서 다양한 출력 비트를 결합하여 전체 응답을 형성하는 세 가지 도구에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f32da9525b7cb6ebcf7f93c63528caea80eed46e" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;:default&lt;/code&gt; option is given, its value will be returned if the translation is missing:</source>
          <target state="translated">때 &lt;code&gt;:default&lt;/code&gt; 옵션이 주어 번역이 누락 된 경우, 그 값이 반환됩니다 :</target>
        </trans-unit>
        <trans-unit id="0f7eb70af8a06669de852f629b5d18beba1b942b" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;:return_path&lt;/code&gt; is specified as header, that value will be used as the 'envelope from' address for the Mail message. Setting this is useful when you want delivery notifications sent to a different address than the one in &lt;code&gt;:from&lt;/code&gt;. Mail will actually use the &lt;code&gt;:return_path&lt;/code&gt; in preference to the &lt;code&gt;:sender&lt;/code&gt; in preference to the &lt;code&gt;:from&lt;/code&gt; field for the 'envelope from' value.</source>
          <target state="translated">경우 &lt;code&gt;:return_path&lt;/code&gt; 가 헤더로서 지정되면, 그 값이 메일 메시지에 대한 주소 '에서 봉투'로 사용한다. 이 설정은 배달 알림을 &lt;code&gt;:from&lt;/code&gt; 의 주소와 다른 주소로 보내려는 경우에 유용합니다 . 메일 실제로 사용 &lt;code&gt;:return_path&lt;/code&gt; 받는 우선 &lt;code&gt;:sender&lt;/code&gt; 받는 우선 &lt;code&gt;:from&lt;/code&gt; 필드 값이 '에서 봉투'에 대한.</target>
        </trans-unit>
        <trans-unit id="a8105326923043b365e08c71ce28876f358e7f50" translate="yes" xml:space="preserve">
          <source>When a class is inherited, wrap its helper module in a new module. This ensures that the parent class's module can be changed independently of the child class's.</source>
          <target state="translated">클래스가 상속되면 도우미 모듈을 새 모듈로 래핑하십시오. 이를 통해 부모 클래스의 모듈을 자식 클래스와 독립적으로 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65b0333e26bcdaef4fddab7b81cd22fffa35068b" translate="yes" xml:space="preserve">
          <source>When a collection is used you might want to know the index of each object into the array. For this purpose, the &lt;code&gt;index&lt;/code&gt; method is available in the &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; object.</source>
          <target state="translated">컬렉션을 사용할 때 배열에 대한 각 개체의 인덱스를 알고 싶을 수 있습니다. 이를 위해 &lt;code&gt;index&lt;/code&gt; 메소드는 &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; 오브젝트 에서 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="db055eb2fbed21e712fa380c71143bcce644d605" translate="yes" xml:space="preserve">
          <source>When a consumer is subscribed to a channel, they act as a subscriber. This connection is called a subscription. Incoming messages are then routed to these channel subscriptions based on an identifier sent by the cable consumer.</source>
          <target state="translated">소비자가 채널을 구독하면 구독자 역할을합니다. 이 연결을 가입이라고합니다. 수신 메시지는 케이블 소비자가 보낸 식별자를 기반으로 이러한 채널 가입으로 라우팅됩니다.</target>
        </trans-unit>
        <trans-unit id="410628c7b26e721f89bfd4c0364a59a9a9b8002b" translate="yes" xml:space="preserve">
          <source>When a file is referenced from a manifest or a helper, Sprockets searches the three default asset locations for it.</source>
          <target state="translated">매니페스트 또는 도우미에서 파일을 참조하면 Sprockets는 3 개의 기본 자산 위치를 검색합니다.</target>
        </trans-unit>
        <trans-unit id="3a83d7cd53f1eeccbfd68de91ac606ff3e139e15" translate="yes" xml:space="preserve">
          <source>When a filename is unique and based on its content, HTTP headers can be set to encourage caches everywhere (whether at CDNs, at ISPs, in networking equipment, or in web browsers) to keep their own copy of the content. When the content is updated, the fingerprint will change. This will cause the remote clients to request a new copy of the content. This is generally known as &lt;em&gt;cache busting&lt;/em&gt;.</source>
          <target state="translated">파일 이름이 고유하고 컨텐츠를 기반으로하는 경우 CDN, ISP, 네트워킹 장비 또는 웹 브라우저 등 어디서나 캐시가 컨텐츠의 자체 사본을 유지하도록 HTTP 헤더를 설정할 수 있습니다. 내용이 업데이트되면 지문이 변경됩니다. 이로 인해 원격 클라이언트가 새로운 컨텐츠 사본을 요청하게됩니다. 이를 일반적으로 &lt;em&gt;캐시 무효화라고&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="093e715b75fc7b3b00b7781d7f7b99331d680a52" translate="yes" xml:space="preserve">
          <source>When a form is submitted, the fields of the form are sent to Rails as &lt;em&gt;parameters&lt;/em&gt;. These parameters can then be referenced inside the controller actions, typically to perform a particular task. To see what these parameters look like, change the &lt;code&gt;create&lt;/code&gt; action to this:</source>
          <target state="translated">양식이 제출되면 양식의 필드가 &lt;em&gt;매개 변수&lt;/em&gt; 로 Rails에 전송됩니다 . 이러한 매개 변수는 일반적으로 특정 작업을 수행하기 위해 컨트롤러 작업 내에서 참조 될 수 있습니다. 이러한 매개 변수의 모양을 보려면 &lt;code&gt;create&lt;/code&gt; 조치를 다음과 같이 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f99a952576340381cc7c8b72b783fe60a51cd03" translate="yes" xml:space="preserve">
          <source>When a job will stop after the allotted time.</source>
          <target state="translated">할당 된 시간이 지난 후 작업이 중지 될 때</target>
        </trans-unit>
        <trans-unit id="47a10ae32bc492a25c391696790dcbdd14867fdb" translate="yes" xml:space="preserve">
          <source>When a module acts as a namespace, Rails does not require the application to define a file for it, a directory matching the namespace is enough.</source>
          <target state="translated">모듈이 네임 스페이스 역할을하는 경우 Rails는 애플리케이션이 파일을 정의하도록 요구하지 않으며 네임 스페이스와 일치하는 디렉토리로 충분합니다.</target>
        </trans-unit>
        <trans-unit id="b37fbe65cbed0100a86dd0277240e3a1a49959ad" translate="yes" xml:space="preserve">
          <source>When a new value is assigned to the value object, the default assumption is that the new value is an instance of the value class. Specifying a custom converter allows the new value to be automatically converted to an instance of value class if necessary.</source>
          <target state="translated">새 값이 값 개체에 할당 될 때 기본 가정은 새 값이 값 클래스의 인스턴스라는 것입니다. 사용자 정의 변환기를 지정하면 필요한 경우 새 값을 값 클래스의 인스턴스로 자동 변환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d17efb02bdf333d4201ab4386115537e51935af5" translate="yes" xml:space="preserve">
          <source>When a partial is called with a collection, the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is &lt;code&gt;_product&lt;/code&gt;, and within it you can refer to &lt;code&gt;product&lt;/code&gt; to get the collection member that is being rendered.</source>
          <target state="translated">부분을 ​​컬렉션과 함께 호출하면 부분의 개별 인스턴스가 부분의 이름을 딴 변수를 통해 렌더링되는 컬렉션 멤버에 액세스 할 수 있습니다. 이 경우, 부분은 &lt;code&gt;_product&lt;/code&gt; 이며 그 안에서 렌더링되는 콜렉션 멤버를 얻기 위해 &lt;code&gt;product&lt;/code&gt; 를 참조 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d73bf4db2c8093e12ad4b4dfae7f16e8d5c0f8e" translate="yes" xml:space="preserve">
          <source>When a partial is called with a pluralized collection, then the individual instances of the partial have access to the member of the collection being rendered via a variable named after the partial. In this case, the partial is &lt;code&gt;_product&lt;/code&gt;, and within the &lt;code&gt;_product&lt;/code&gt; partial, you can refer to &lt;code&gt;product&lt;/code&gt; to get the instance that is being rendered.</source>
          <target state="translated">복수의 컬렉션으로 부분을 호출하면, 부분의 개별 인스턴스는 부분의 이름을 딴 변수를 통해 렌더링되는 컬렉션의 멤버에 액세스 할 수 있습니다. 이 경우 부분은 &lt;code&gt;_product&lt;/code&gt; 이며 &lt;code&gt;_product&lt;/code&gt; 부분에서는 &lt;code&gt;product&lt;/code&gt; 를 참조하여 렌더링중인 인스턴스를 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f39992ffab310773016de4ae16e119d4f3ef6fde" translate="yes" xml:space="preserve">
          <source>When a pattern points to an internal route, the route's &lt;code&gt;:action&lt;/code&gt; and &lt;code&gt;:controller&lt;/code&gt; should be set in options or hash shorthand. Examples:</source>
          <target state="translated">패턴이 내부 경로를 가리킬 때 경로의 &lt;code&gt;:action&lt;/code&gt; 및 &lt;code&gt;:controller&lt;/code&gt; 는 옵션 또는 해시 속기에서 설정해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="d4ab5e1feb0228f13d0ebd292af1d464d4c79b13" translate="yes" xml:space="preserve">
          <source>When a qualified constant is missing Rails does not look for it in the parent namespaces. But there is a caveat: when a constant is missing, Rails is unable to tell if the trigger was a relative reference or a qualified one.</source>
          <target state="translated">정규화 된 상수가 없으면 Rails는 상위 네임 스페이스에서이를 찾지 않습니다. 그러나 경고가 있습니다. 상수가 누락되면 Rails는 트리거가 상대 참조인지 적격 한 것인지 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="27bc79f48b10ec6934d4d228032504fd460f4e90" translate="yes" xml:space="preserve">
          <source>When a release series is no longer supported, it's your own responsibility to deal with bugs and security issues. We may provide backports of the fixes and publish them to git, however there will be no new versions released. If you are not comfortable maintaining your own versions, you should upgrade to a supported version.</source>
          <target state="translated">릴리스 시리즈가 더 이상 지원되지 않으면 버그 및 보안 문제를 처리하는 것은 사용자의 책임입니다. 픽스의 백 포트를 제공하고 git에 게시 할 수 있지만 새로운 버전은 출시되지 않습니다. 고유 한 버전을 유지 관리하는 데 불편한 경우 지원되는 버전으로 업그레이드해야합니다.</target>
        </trans-unit>
        <trans-unit id="6c50ecc1b47c70aebbcf03234a67c3f0b56c25f2" translate="yes" xml:space="preserve">
          <source>When a request comes to an unauthorized host, the &lt;code&gt;response_app&lt;/code&gt; application will be executed and rendered. If no &lt;code&gt;response_app&lt;/code&gt; is given, a default one will run, which responds with +403 Forbidden+.</source>
          <target state="translated">요청이 권한이없는 호스트로 오면 &lt;code&gt;response_app&lt;/code&gt; 응용 프로그램이 실행되고 렌더링됩니다. &lt;code&gt;response_app&lt;/code&gt; 가 제공 되지 않으면 기본 항목이 실행되며 +403 Forbidden +로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="82bb35f20851e06f50472b64d213eaad90cc7c48" translate="yes" xml:space="preserve">
          <source>When a request with a content type other than HTML is made, this middleware will attempt to convert error information into the appropriate response type.</source>
          <target state="translated">HTML 이외의 컨텐츠 유형으로 요청하면이 미들웨어는 오류 정보를 적절한 응답 유형으로 변환하려고 시도합니다.</target>
        </trans-unit>
        <trans-unit id="517d76f819bb6ac72268abf44b74a18225441e00" translate="yes" xml:space="preserve">
          <source>When a subscription is initiated the &lt;code&gt;subscribed&lt;/code&gt; callback gets fired and we take that opportunity to say &quot;the current user has indeed appeared&quot;. That appear/disappear API could be backed by Redis, a database, or whatever else.</source>
          <target state="translated">구독이 시작되면 &lt;code&gt;subscribed&lt;/code&gt; 콜백 이 시작되고 &quot;현재 사용자가 실제로 나타났습니다&quot;라고 말할 기회가 있습니다. API가 나타나거나 사라지는 것은 Redis, 데이터베이스 등으로 뒷받침 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46be056b7bb212e4882bc1b3ca519ec092c2235e" translate="yes" xml:space="preserve">
          <source>When a test fails you are presented with the corresponding backtrace. By default Rails filters that backtrace and will only print lines relevant to your application. This eliminates the framework noise and helps to focus on your code. However there are situations when you want to see the full backtrace. Set the &lt;code&gt;-b&lt;/code&gt; (or &lt;code&gt;--backtrace&lt;/code&gt;) argument to enable this behavior:</source>
          <target state="translated">테스트가 실패하면 해당 역 추적이 표시됩니다. 기본적으로 Rails는 역 추적하고 애플리케이션과 관련된 행만 인쇄하는 필터를 필터링합니다. 이를 통해 프레임 워크 노이즈가 제거되고 코드에 집중할 수 있습니다. 그러나 전체 역 추적을보고 싶은 상황이 있습니다. 이 동작을 활성화 하려면 &lt;code&gt;-b&lt;/code&gt; (또는 &lt;code&gt;--backtrace&lt;/code&gt; ) 인수를 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a8f7b75337c6c90b31a864530ae969168d43e53c" translate="yes" xml:space="preserve">
          <source>When a transaction completes, the &lt;code&gt;after_commit&lt;/code&gt; or &lt;code&gt;after_rollback&lt;/code&gt; callbacks are called for all models created, updated, or destroyed within that transaction. However, if an exception is raised within one of these callbacks, the exception will bubble up and any remaining &lt;code&gt;after_commit&lt;/code&gt; or &lt;code&gt;after_rollback&lt;/code&gt; methods will &lt;em&gt;not&lt;/em&gt; be executed. As such, if your callback code could raise an exception, you'll need to rescue it and handle it within the callback in order to allow other callbacks to run.</source>
          <target state="translated">트랜잭션이 완료되면 해당 트랜잭션 내에서 작성, 업데이트 또는 파기 된 모든 모델에 대해 &lt;code&gt;after_commit&lt;/code&gt; 또는 &lt;code&gt;after_rollback&lt;/code&gt; 콜백이 호출됩니다. 그러나 이러한 콜백 중 하나에서 예외가 발생하면 예외가 발생하고 나머지 &lt;code&gt;after_commit&lt;/code&gt; 또는 &lt;code&gt;after_rollback&lt;/code&gt; 메소드는 실행 &lt;em&gt;되지 않습니다&lt;/em&gt; . 따라서 콜백 코드에서 예외가 발생할 수있는 경우 다른 콜백을 실행할 수 있도록 예외를 구조화하고 콜백 내에서 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="fec11cf7cef455597d0fea69199acdc63584007c" translate="yes" xml:space="preserve">
          <source>When a video's angle is 90 or 270 degrees, its width and height are automatically swapped for convenience.</source>
          <target state="translated">비디오 각도가 90도 또는 270 도인 경우 편의를 위해 너비와 높이가 자동으로 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="44e47728d8eed681af01d4ab229a8b1135c4e4de" translate="yes" xml:space="preserve">
          <source>When address is already an association on a Person you can use &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; to define the writer method for you:</source>
          <target state="translated">address가 이미 Person의 연관 인 경우 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 를 사용하여 작성기 메소드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3cd2086a1b0cba5d4227cd7ce42c1dffd2edf811" translate="yes" xml:space="preserve">
          <source>When an association accepts nested attributes &lt;code&gt;fields_for&lt;/code&gt; renders its block once for every element of the association. In particular, if a person has no addresses it renders nothing. A common pattern is for the controller to build one or more empty children so that at least one set of fields is shown to the user. The example below would result in 2 sets of address fields being rendered on the new person form.</source>
          <target state="translated">연관이 중첩 속성을 허용 할 때 &lt;code&gt;fields_for&lt;/code&gt; 는 연관의 모든 요소에 대해 블록을 한 번 렌더링합니다. 특히, 주소가없는 사람은 아무것도 렌더링하지 않습니다. 일반적인 패턴은 컨트롤러가 하나 이상의 빈 자식을 작성하여 하나 이상의 필드 집합이 사용자에게 표시되도록하는 것입니다. 아래 예제는 새로운 개인 양식에 2 개의 주소 필드 세트가 렌더링되도록합니다.</target>
        </trans-unit>
        <trans-unit id="8c6778ca993e7fb8d310fdba9bef5c6944ce5d24" translate="yes" xml:space="preserve">
          <source>When an engine is created, it may want to use specific classes from an application to provide links between the pieces of the engine and the pieces of the application. In the case of the &lt;code&gt;blorgh&lt;/code&gt; engine, making articles and comments have authors would make a lot of sense.</source>
          <target state="translated">엔진을 만들 때 엔진 조각과 응용 프로그램 조각 사이의 링크를 제공하기 위해 응용 프로그램의 특정 클래스를 사용할 수 있습니다. &lt;code&gt;blorgh&lt;/code&gt; 엔진 의 경우 기사와 의견을 작성하는 것은 많은 의미가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a531f830fd5d38c431c5b5b6d58bba01c2ebd943" translate="yes" xml:space="preserve">
          <source>When an engine is generated, there is a smaller dummy application created inside it at &lt;code&gt;test/dummy&lt;/code&gt;. This application is used as a mounting point for the engine, to make testing the engine extremely simple. You may extend this application by generating controllers, models, or views from within the directory, and then use those to test your engine.</source>
          <target state="translated">엔진이 생성되면 &lt;code&gt;test/dummy&lt;/code&gt; 에서 더 작은 더미 애플리케이션이 엔진 내부에 작성됩니다 . 이 응용 프로그램은 엔진 테스트를 매우 간단하게하기 위해 엔진 장착 지점으로 사용됩니다. 디렉토리 내에서 제어기, 모델 또는보기를 생성하여이 애플리케이션을 확장 한 다음이를 사용하여 엔진을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d02cb8feda2c7d4d869b434ea0356c2bc384a7c0" translate="yes" xml:space="preserve">
          <source>When an exception occurs which is caught by a &lt;code&gt;rescue_from&lt;/code&gt; directive, the exception object is passed to the handler. The handler can be a method or a &lt;code&gt;Proc&lt;/code&gt; object passed to the &lt;code&gt;:with&lt;/code&gt; option. You can also use a block directly instead of an explicit &lt;code&gt;Proc&lt;/code&gt; object.</source>
          <target state="translated">&lt;code&gt;rescue_from&lt;/code&gt; 지시문에 의해 발견 된 예외가 발생 하면 예외 오브젝트가 핸들러로 전달됩니다. 핸들러는 &lt;code&gt;:with&lt;/code&gt; 옵션에 전달 된 메소드 또는 &lt;code&gt;Proc&lt;/code&gt; 오브젝트 일 수 있습니다 . 명시 적 &lt;code&gt;Proc&lt;/code&gt; 객체 대신 블록을 직접 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27b413cc6bfb42269e4b37a26330397aa974f8d4" translate="yes" xml:space="preserve">
          <source>When an explicit locale has not been set for a request (e.g. via one of the above methods), an application should attempt to infer the desired locale.</source>
          <target state="translated">요청에 대해 명시 적 로캘이 설정되지 않은 경우 (예 : 위의 방법 중 하나를 통해) 응용 프로그램은 원하는 로캘을 유추해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f3b923bc9a98ef57e075d022602da002f65e8f7" translate="yes" xml:space="preserve">
          <source>When autoloading is involved that plot has a twist. Let's consider:</source>
          <target state="translated">자동 로딩이 포함 된 경우 해당 플롯에 트위스트가 있습니다. 고려해 봅시다 :</target>
        </trans-unit>
        <trans-unit id="95d1211c06a95edfb62d3673bf1d5b11507f616b" translate="yes" xml:space="preserve">
          <source>When building decorators, a common pattern may emerge:</source>
          <target state="translated">데코레이터를 만들 때 일반적인 패턴이 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ddc118102a2df45430da56de781f7d1788b340c" translate="yes" xml:space="preserve">
          <source>When called without arguments like this, it creates a form tag which, when submitted, will POST to the current page. For instance, assuming the current page is a home page, the generated HTML will look like this:</source>
          <target state="translated">이와 같은 인수없이 호출되면 제출 될 때 현재 페이지로 POST되는 양식 태그가 작성됩니다. 예를 들어, 현재 페이지가 홈 페이지 인 경우 생성 된 HTML은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7d558b5178024952a4702e0e3a494603a7807cd8" translate="yes" xml:space="preserve">
          <source>When called, this middleware renders an error page. By default if an HTML response is expected it will render static error pages from the &lt;code&gt;/public&lt;/code&gt; directory. For example when this middleware receives a 500 response it will render the template found in &lt;code&gt;/public/500.html&lt;/code&gt;. If an internationalized locale is set, this middleware will attempt to render the template in &lt;code&gt;/public/500.&amp;lt;locale&amp;gt;.html&lt;/code&gt;. If an internationalized template is not found it will fall back on &lt;code&gt;/public/500.html&lt;/code&gt;.</source>
          <target state="translated">호출되면이 미들웨어는 오류 페이지를 렌더링합니다. 기본적으로 HTML 응답이 예상되면 &lt;code&gt;/public&lt;/code&gt; 디렉토리 에서 정적 오류 페이지가 렌더링됩니다 . 예를 들어이 미들웨어가 500 응답을 수신하면 &lt;code&gt;/public/500.html&lt;/code&gt; 에 있는 템플리트를 렌더링합니다 . 국제화 된 로케일이 설정된 경우이 미들웨어는 &lt;code&gt;/public/500.&amp;lt;locale&amp;gt;.html&lt;/code&gt; 에 템플리트를 렌더링하려고 시도합니다 . 국제화 된 템플릿이 없으면 &lt;code&gt;/public/500.html&lt;/code&gt; 로 돌아갑니다 .</target>
        </trans-unit>
        <trans-unit id="f361d7ff00bda7f2b49159bc5b0ef1a05c5c964d" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;deliver_later&lt;/code&gt; the job will be placed under &lt;code&gt;mailers&lt;/code&gt; queue. Make sure Active Job adapter support it otherwise the job may be silently ignored preventing email delivery. You can change that by specifying &lt;code&gt;config.action_mailer.deliver_later_queue_name&lt;/code&gt; option.</source>
          <target state="translated">&lt;code&gt;deliver_later&lt;/code&gt; 를 호출 하면 작업이 &lt;code&gt;mailers&lt;/code&gt; 큐 아래에 배치 됩니다. 활성 작업 어댑터가이를 지원하는지 확인하십시오. 그렇지 않으면 작업이 자동으로 무시되어 이메일 전송을 방해 할 수 있습니다. &lt;code&gt;config.action_mailer.deliver_later_queue_name&lt;/code&gt; 옵션 을 지정하여이를 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="929b6c40e495358f8b1160edc86328ec93728648" translate="yes" xml:space="preserve">
          <source>When changing Rails versions, it's best to move slowly, one minor version at a time, in order to make good use of the deprecation warnings. Rails version numbers are in the form Major.Minor.Patch. Major and Minor versions are allowed to make changes to the public API, so this may cause errors in your application. Patch versions only include bug fixes, and don't change any public API.</source>
          <target state="translated">Rails 버전을 변경할 때는 지원 중단 경고를 잘 활용하기 위해 한 번에 하나의 부 버전으로 천천히 이동하는 것이 가장 좋습니다. Rails 버전 번호는 Major.Minor.Patch 형식입니다. 메이저 및 마이너 버전은 공개 API를 변경할 수 있으므로 응용 프로그램에 오류가 발생할 수 있습니다. 패치 버전에는 버그 수정 만 포함되며 공개 API는 변경하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="34238df080e6a5cfae780e683e67c205193765f5" translate="yes" xml:space="preserve">
          <source>When clicked, the link background will become red. Here's the problem: what happens when we have lots of JavaScript we want to execute on a click?</source>
          <target state="translated">클릭하면 링크 배경이 빨간색이됩니다. 문제는 다음과 같습니다. 클릭으로 실행할 JavaScript가 많으면 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="6ef8408a71e03ecbe3aac398eefeee9c64914a20" translate="yes" xml:space="preserve">
          <source>When configuring the &lt;code&gt;test&lt;/code&gt; environment for autoloading you might consider multiple factors.</source>
          <target state="translated">자동로드를 위해 &lt;code&gt;test&lt;/code&gt; 환경을 구성 할 때 여러 가지 요소를 고려할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ae7ca2599adb1f87be08fe0e4e172580497a3d" translate="yes" xml:space="preserve">
          <source>When configuring your Postmark inbound webhook, be sure to check the box labeled &lt;strong&gt;&quot;Include raw email content in JSON payload&quot;&lt;/strong&gt;. Action Mailbox needs the raw email content to work.</source>
          <target state="translated">Postmark 인바운드 웹 후크를 구성 할 때 &lt;strong&gt;&quot;JSON 페이로드에 원시 이메일 콘텐츠 포함&quot;&lt;/strong&gt; 확인란을 선택하십시오 . 작업 사서함이 작동하려면 원시 전자 메일 내용이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="2c40bf6a467e35380e4edf11154e7773adc3d2ff" translate="yes" xml:space="preserve">
          <source>When configuring your SendGrid Inbound Parse webhook, be sure to check the box labeled &lt;strong&gt;&amp;ldquo;Post the raw, full MIME message.&amp;rdquo;&lt;/strong&gt; Action Mailbox needs the raw MIME message to work.</source>
          <target state="translated">SendGrid 인바운드 구문 분석 웹 후크를 구성 할 때 &lt;strong&gt;&amp;ldquo;원시 전체 MIME 메시지 게시&amp;rdquo;&lt;/strong&gt; 상자를 선택하십시오 &lt;strong&gt;. &lt;/strong&gt;작업 사서함이 작동하려면 원시 MIME 메시지가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f218c77c4940672ba31dc8ded45b3cc5d8fa4572" translate="yes" xml:space="preserve">
          <source>When creating a new Rails application, you have the option to specify what kind of database and what kind of source code management system your application is going to use. This will save you a few minutes, and certainly many keystrokes.</source>
          <target state="translated">새로운 Rails 애플리케이션을 생성 할 때, 어떤 종류의 데이터베이스와 애플리케이션이 사용할 소스 코드 관리 시스템을 지정하는 옵션이 있습니다. 이렇게하면 몇 분, 많은 키 입력이 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="e9bae614244da7533a35eb8e4eb7a4f149a69779" translate="yes" xml:space="preserve">
          <source>When dealing with RESTful resources, calls to &lt;code&gt;form_with&lt;/code&gt; can get significantly easier if you rely on &lt;strong&gt;record identification&lt;/strong&gt;. In short, you can just pass the model instance and have Rails figure out model name and the rest:</source>
          <target state="translated">RESTful 자원을 처리 할 때 &lt;strong&gt;레코드 식별에&lt;/strong&gt; 의존하면 &lt;code&gt;form_with&lt;/code&gt; 에 대한 호출 이 훨씬 쉬워 질 수 있습니다 . 간단히 말해서 모델 인스턴스를 전달하고 레일즈가 모델 이름과 나머지를 알아낼 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9cbf419b397994f77e57affce52747f18aedb28" translate="yes" xml:space="preserve">
          <source>When debug mode is off, Sprockets concatenates and runs the necessary preprocessors on all files. With debug mode turned off the manifest above would generate instead:</source>
          <target state="translated">디버그 모드가 해제되면 스프로킷은 모든 파일에서 필요한 전처리기를 연결하고 실행합니다. 디버그 모드를 끄면 위의 매니페스트가 대신 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5e35e7320b44ac9f92b15f8950da01751493dd08" translate="yes" xml:space="preserve">
          <source>When declared inside a class, as above, the callback methods will receive the model object as a parameter. We can now use the callback class in the model:</source>
          <target state="translated">위와 같이 클래스 내에서 선언되면 콜백 메서드는 모델 객체를 매개 변수로받습니다. 이제 모델에서 콜백 클래스를 사용할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0788fdd6c49cccb2a9ec8bd7ea3e83153cf6270f" translate="yes" xml:space="preserve">
          <source>When defining an around callback remember to yield to the block, otherwise it won't be executed:</source>
          <target state="translated">around 콜백을 정의 할 때 블록에 양보해야합니다. 그렇지 않으면 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cbfb05990ebfffabdad9ac3a12caad63565a0002" translate="yes" xml:space="preserve">
          <source>When doing this, ensure you are not using the &lt;code&gt;require_tree&lt;/code&gt; directive, as that will result in your assets being included more than once.</source>
          <target state="translated">이 작업을 수행 할 때는 &lt;code&gt;require_tree&lt;/code&gt; 지시문을 사용하지 않아야 합니다. 그러면 자산이 두 번 이상 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="54305ed8cd0aa2c64b695c8e2f0d63caa435cc37" translate="yes" xml:space="preserve">
          <source>When duplicate connection information is provided the environment variable will take precedence:</source>
          <target state="translated">중복 된 연결 정보가 제공되면 환경 변수가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="4727f5a8410697bbd8a1f36c9b02433d1ad69c46" translate="yes" xml:space="preserve">
          <source>When enqueuing jobs with the Inline adapter the job will be executed immediately.</source>
          <target state="translated">인라인 어댑터로 작업을 대기열에 넣으면 작업이 즉시 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="a2f96ac519b47600178682ec0e7f8abcbfd3029d" translate="yes" xml:space="preserve">
          <source>When filtering user input file names, &lt;em&gt;don't try to remove malicious parts&lt;/em&gt;. Think of a situation where the web application removes all &quot;../&quot; in a file name and an attacker uses a string such as &quot;....//&quot; - the result will be &quot;../&quot;. It is best to use a permitted list approach, which &lt;em&gt;checks for the validity of a file name with a set of accepted characters&lt;/em&gt;. This is opposed to a restricted list approach which attempts to remove not allowed characters. In case it isn't a valid file name, reject it (or replace not accepted characters), but don't remove them. Here is the file name sanitizer from the &lt;a href=&quot;https://github.com/technoweenie/attachment_fu/tree/master&quot;&gt;attachment_fu plugin&lt;/a&gt;:</source>
          <target state="translated">사용자 입력 파일 이름을 필터링 할 때 &lt;em&gt;악성 부분을 제거하지 마십시오&lt;/em&gt; . 웹 응용 프로그램이 파일 이름에서 모든 &quot;../&quot;를 제거하고 공격자가 &quot;.... //&quot;와 같은 문자열을 사용하는 상황을 생각해보십시오. 결과는 &quot;../&quot;입니다. &lt;em&gt;허용되는 문자 집합으로 파일 이름의 유효성&lt;/em&gt; 을 &lt;em&gt;검사&lt;/em&gt; 하는 허용 된 목록 접근 방식을 사용하는 것이 가장 좋습니다 . 이것은 허용되지 않는 문자를 제거하려는 제한된 목록 접근 방식과 반대입니다. 유효한 파일 이름이 아닌 경우 파일을 거부하거나 허용되지 않는 문자로 바꾸십시오. 그러나 제거하지 마십시오. &lt;a href=&quot;https://github.com/technoweenie/attachment_fu/tree/master&quot;&gt;attachment_fu 플러그인&lt;/a&gt; 의 파일 이름 소독제는 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="20a7725639da7c2ab0cf7cc73f24cd5fab4b4075" translate="yes" xml:space="preserve">
          <source>When generating an application or scaffold, an &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file will also be generated containing the base class for system testing. This is where you can change the driver, add Capybara settings, and other configuration for your system tests.</source>
          <target state="translated">애플리케이션 또는 스캐 폴드를 생성 할 때 시스템 테스트를위한 기본 클래스를 포함 하는 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 파일도 생성됩니다. 드라이버를 변경하고 Capybara 설정을 추가하고 시스템 테스트를위한 기타 구성을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="171e2b74c3512a07e35d273bf34823c7229aa24d" translate="yes" xml:space="preserve">
          <source>When given a block, the value for duplicated keys will be determined by the result of invoking the block with the duplicated key, the value in the receiver, and the value in &lt;code&gt;other_hash&lt;/code&gt;. The rules for duplicated keys follow the semantics of indifferent access:</source>
          <target state="translated">블록이 주어지면, 중복 된 키의 값은 중복 된 키, 수신기의 값 및 &lt;code&gt;other_hash&lt;/code&gt; 의 값으로 블록을 호출 한 결과에 의해 결정됩니다 . 중복 키에 대한 규칙은 무차별 액세스의 의미를 따릅니다.</target>
        </trans-unit>
        <trans-unit id="fb04eb174c25e8b718537376f3b6f3c9ad9748ca" translate="yes" xml:space="preserve">
          <source>When given an array of keys, the method tries to require each one of them in order. If it succeeds, an array with the respective return values is returned:</source>
          <target state="translated">키 배열이 주어지면 메소드는 각각의 키를 순서대로 요구합니다. 성공하면 각각의 반환 값을 가진 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="31c5028a74e83f5e9fea82c41a646f0c16557e15" translate="yes" xml:space="preserve">
          <source>When including &lt;code&gt;ActiveModel::Model&lt;/code&gt; you get some features like:</source>
          <target state="translated">&lt;code&gt;ActiveModel::Model&lt;/code&gt; 을 포함하면 다음과 같은 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ef7117cabbadf2c53fb61926df6184d640299d" translate="yes" xml:space="preserve">
          <source>When initializing a new &lt;code&gt;has_one&lt;/code&gt; or &lt;code&gt;belongs_to&lt;/code&gt; association you must use the &lt;code&gt;build_&lt;/code&gt; prefix to build the association, rather than the &lt;code&gt;association.build&lt;/code&gt; method that would be used for &lt;code&gt;has_many&lt;/code&gt; or &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; associations. To create one, use the &lt;code&gt;create_&lt;/code&gt; prefix.</source>
          <target state="translated">새로운 &lt;code&gt;has_one&lt;/code&gt; 또는 &lt;code&gt;belongs_to&lt;/code&gt; 연관을 초기화 할 때 &lt;code&gt;has_many&lt;/code&gt; 또는 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관에 사용되는 &lt;code&gt;association.build&lt;/code&gt; 메소드 대신 &lt;code&gt;build_&lt;/code&gt; 접 두부를 사용하여 연관을 빌드 해야합니다 . 하나를 작성하려면 &lt;code&gt;create_&lt;/code&gt; 접 두부를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c9cc83fef594a450e9bd45e4b43b2542c9912a67" translate="yes" xml:space="preserve">
          <source>When initializing the cache, you need to specify the addresses for all memcached servers in your cluster. If none are specified, it will assume memcached is running on localhost on the default port, but this is not an ideal setup for larger sites.</source>
          <target state="translated">캐시를 초기화 할 때 클러스터에있는 모든 memcached 서버의 주소를 지정해야합니다. 아무것도 지정하지 않으면 memcached가 기본 포트의 localhost에서 실행 중이라고 가정하지만 더 큰 사이트에는 이상적인 설정이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="21153002f1b35f396473c36c4c32f8827a54add3" translate="yes" xml:space="preserve">
          <source>When interpolated into a string, the &lt;code&gt;:to&lt;/code&gt; option should become an expression that evaluates to the object the method is delegated to. Typically a string or symbol. Such an expression is evaluated in the context of the receiver:</source>
          <target state="translated">문자열에 삽입 될 때, &lt;code&gt;:to&lt;/code&gt; 옵션은 메소드가 위임 된 객체로 평가되는 표현식이되어야합니다. 일반적으로 문자열 또는 기호입니다. 이러한 표현은 수신자와 관련하여 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="5470f35c45a0b9fbe439c8e7e26e024c76999446" translate="yes" xml:space="preserve">
          <source>When it comes to streaming, exceptions get a bit more complicated. This happens because part of the template was already rendered and streamed to the client, making it impossible to render a whole exception page.</source>
          <target state="translated">스트리밍의 경우 예외가 좀 더 복잡해집니다. 템플릿의 일부가 이미 렌더링되어 클라이언트로 스트리밍되어 전체 예외 페이지를 렌더링 할 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="15011c1a35de584879bbf122d408a90c297a652e" translate="yes" xml:space="preserve">
          <source>When it's time to invalidate all fragments, simply change the string constant. Or, progressively roll out the cache invalidation using a computed value:</source>
          <target state="translated">모든 조각을 무효화해야 할 때 문자열 상수를 변경하십시오. 또는 계산 된 값을 사용하여 캐시 무효화를 점진적으로 롤아웃합니다.</target>
        </trans-unit>
        <trans-unit id="732b3b920b50dde825e80483861e26dbb9485868" translate="yes" xml:space="preserve">
          <source>When joining tables, nested hashes or keys written in the form 'table_name.column_name' can be used to qualify the table name of a particular condition. For instance:</source>
          <target state="translated">테이블을 조인 할 때 'table_name.column_name'형식으로 작성된 중첩 해시 또는 키를 사용하여 특정 조건의 테이블 이름을 한정 할 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="36782d41f0e6909fb0305cf00cb7a5a2510f57ec" translate="yes" xml:space="preserve">
          <source>When localizing a string, it goes through the lookup returned by this method, which is used in &lt;a href=&quot;name#method-i-human&quot;&gt;ActiveModel::Name#human&lt;/a&gt;, &lt;a href=&quot;errors#method-i-full_messages&quot;&gt;ActiveModel::Errors#full_messages&lt;/a&gt; and &lt;a href=&quot;translation#method-i-human_attribute_name&quot;&gt;#human_attribute_name&lt;/a&gt;.</source>
          <target state="translated">문자열을 지역화 할 때 &lt;a href=&quot;name#method-i-human&quot;&gt;ActiveModel :: Name # human&lt;/a&gt; , &lt;a href=&quot;errors#method-i-full_messages&quot;&gt;ActiveModel :: Errors # full_messages&lt;/a&gt; 및 &lt;a href=&quot;translation#method-i-human_attribute_name&quot;&gt;#human_attribute_name&lt;/a&gt; 에서 사용되는이 메서드에서 반환 된 조회 를 거치게 됩니다.</target>
        </trans-unit>
        <trans-unit id="3204df2e49d38ad052e7face8980be4cd4bd55ff" translate="yes" xml:space="preserve">
          <source>When looking at database query output in logs, it may not be immediately clear why multiple database queries are triggered when a single method is called:</source>
          <target state="translated">로그에서 데이터베이스 쿼리 출력을 볼 때 단일 메소드가 호출 될 때 여러 데이터베이스 쿼리가 트리거되는 이유가 즉시 명확하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0d62965d358178f31ae12631754e5a5b9986db3" translate="yes" xml:space="preserve">
          <source>When making Date comparisons using methods which honor the user time zone, make sure to use &lt;code&gt;Date.current&lt;/code&gt; and not &lt;code&gt;Date.today&lt;/code&gt;. There are cases where the user time zone might be in the future compared to the system time zone, which &lt;code&gt;Date.today&lt;/code&gt; uses by default. This means &lt;code&gt;Date.today&lt;/code&gt; may equal &lt;code&gt;Date.yesterday&lt;/code&gt;.</source>
          <target state="translated">사용자 시간대를 존중하는 방법을 사용하여 날짜를 비교할 때는 &lt;code&gt;Date.current&lt;/code&gt; 가 아닌 &lt;code&gt;Date.today&lt;/code&gt; 합니다. &lt;code&gt;Date.today&lt;/code&gt; 가 기본적으로 사용 하는 시스템 시간대와 비교하여 사용자 시간대가 미래에있을 수 있습니다 . 이는 &lt;code&gt;Date.today&lt;/code&gt; 가 같을 수도 &lt;code&gt;Date.yesterday&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="182fe9f584042629e662549bc62eda6c1306cd4f" translate="yes" xml:space="preserve">
          <source>When making Time comparisons using methods which honor the user time zone, make sure to use &lt;code&gt;Time.current&lt;/code&gt; instead of &lt;code&gt;Time.now&lt;/code&gt;. There are cases where the user time zone might be in the future compared to the system time zone, which &lt;code&gt;Time.now&lt;/code&gt; uses by default. This means &lt;code&gt;Time.now.to_date&lt;/code&gt; may equal &lt;code&gt;Date.yesterday&lt;/code&gt;.</source>
          <target state="translated">사용자의 시간대를 존중 방법을 사용하여 시간 비교를 할 때 사용해야합니다 &lt;code&gt;Time.current&lt;/code&gt; 을 대신 &lt;code&gt;Time.now&lt;/code&gt; . &lt;code&gt;Time.now&lt;/code&gt; 가 기본적으로 사용 하는 시스템 표준 시간대와 비교하여 사용자 표준 시간대가 미래에있을 수 있습니다 . 이는 &lt;code&gt;Time.now.to_date&lt;/code&gt; 가 같을 수도 &lt;code&gt;Date.yesterday&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="4420b2c9d76a662f8aed87346d58567d0040ea5e" translate="yes" xml:space="preserve">
          <source>When multiple conditions define whether or not a callback should happen, an &lt;code&gt;Array&lt;/code&gt; can be used. Moreover, you can apply both &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; to the same callback.</source>
          <target state="translated">여러 조건이 콜백 발생 여부를 정의 할 때 &lt;code&gt;Array&lt;/code&gt; 사용할 수 있습니다. 또한 동일한 콜백에 &lt;code&gt;:if&lt;/code&gt; 와 &lt;code&gt;:unless&lt;/code&gt; 를 모두 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b8a610925f0c3b503423af9b066022fca0684aa" translate="yes" xml:space="preserve">
          <source>When name is &lt;code&gt;nil&lt;/code&gt; the href is presented instead</source>
          <target state="translated">이름이 &lt;code&gt;nil&lt;/code&gt; 이면 href가 대신 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e91339d6410a878b5e2d9c46d6318924123dc0c7" translate="yes" xml:space="preserve">
          <source>When naming inputs, Rails uses certain conventions that make it possible to submit parameters with non-scalar values such as arrays or hashes, which will also be accessible in &lt;code&gt;params&lt;/code&gt;. You can read more about them in chapter &lt;a href=&quot;#understanding-parameter-naming-conventions&quot;&gt;Understanding Parameter Naming Conventions&lt;/a&gt; of this guide. For details on the precise usage of these helpers, please refer to the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html&quot;&gt;API documentation&lt;/a&gt;.</source>
          <target state="translated">입력 이름을 지정할 때 Rails는 배열 또는 해시와 같이 스칼라 이외의 값으로 매개 변수를 제출할 수있는 특정 규칙을 사용하며 &lt;code&gt;params&lt;/code&gt; 에서도 액세스 할 수 있습니다 . 이 안내서의 &lt;a href=&quot;#understanding-parameter-naming-conventions&quot;&gt;매개 변수 명명 규칙 이해&lt;/a&gt; 장에서 자세한 내용을 읽을 수 있습니다 . 이러한 도우미의 정확한 사용법에 대한 자세한 내용은 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html&quot;&gt;API 설명서&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="27d558318f7fdb9b4dde99a730939dfc2ac49a87" translate="yes" xml:space="preserve">
          <source>When no selection is made for a collection of checkboxes most web browsers will not send any value.</source>
          <target state="translated">확인란 모음을 선택하지 않으면 대부분의 웹 브라우저는 값을 보내지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1ab35f254b9872b97e7346dd7b3e9939210e3177" translate="yes" xml:space="preserve">
          <source>When not passing a block, &lt;code&gt;form_with&lt;/code&gt; just generates an opening form tag.</source>
          <target state="translated">블록을 전달하지 않으면 &lt;code&gt;form_with&lt;/code&gt; 는 시작 양식 태그 만 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4391bc5627801574e1970dfeab4d7b8f8e157900" translate="yes" xml:space="preserve">
          <source>When on a line that only contains whitespaces except for the tag, &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; suppresses leading and trailing whitespace, including the trailing newline. &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;%-
-%&amp;gt;&lt;/code&gt; are the same. Note however that &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;%= -%&amp;gt;&lt;/code&gt; are different: only the latter removes trailing whitespaces.</source>
          <target state="translated">태그를 제외한 공백 만 포함 된 행에서 &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; 는 후행 줄 바꿈을 포함하여 선행 및 후행 공백을 억제합니다. &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;%- -%&amp;gt;&lt;/code&gt; 는 동일합니다. 그러나 &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 와 &lt;code&gt;&amp;lt;%= -%&amp;gt;&lt;/code&gt; 는 다릅니다. 후자 만 후행 공백을 제거합니다.</target>
        </trans-unit>
        <trans-unit id="07550e1614de1257d5b75cb073ce9b4e6299fae2" translate="yes" xml:space="preserve">
          <source>When one thread is performing an autoload by evaluating the class definition from the appropriate file, it is important no other thread encounters a reference to the partially-defined constant.</source>
          <target state="translated">하나의 스레드가 적절한 파일에서 클래스 정의를 평가하여 자동로드를 수행하는 경우 다른 스레드가 부분적으로 정의 된 상수에 대한 참조를 만나지 않는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="17e6a6b3c6f808c0039f14caf87b36d411c2c169" translate="yes" xml:space="preserve">
          <source>When one types a Rails command, &lt;code&gt;invoke&lt;/code&gt; tries to lookup a command for the given namespace and executes the command if found.</source>
          <target state="translated">Rails 명령을 입력하면 &lt;code&gt;invoke&lt;/code&gt; 는 지정된 네임 스페이스에 대한 명령을 조회하고 찾은 경우 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="cf742f090390a0f02b0ce9ba50fcd9df17f41dbd" translate="yes" xml:space="preserve">
          <source>When our views change, they should bubble up into HTTP cache freshness and bust browser caches. So the template digest for the current action is automatically included in the ETag.</source>
          <target state="translated">뷰가 변경되면 HTTP 캐시 최신 정보 및 버스트 브라우저 캐시로 버블 링되어야합니다. 따라서 현재 작업에 대한 템플릿 다이제스트가 ETag에 자동으로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4d6cc4ebab8cbea8e9bec435029b0cc80c22167e" translate="yes" xml:space="preserve">
          <source>When parallelizing tests, Active Record automatically handles creating a database and loading the schema into the database for each process. The databases will be suffixed with the number corresponding to the worker. For example, if you have 2 workers the tests will create &lt;code&gt;test-database-0&lt;/code&gt; and &lt;code&gt;test-database-1&lt;/code&gt; respectively.</source>
          <target state="translated">테스트를 병렬화 할 때 Active Record는 자동으로 데이터베이스 작성 및 각 프로세스의 데이터베이스에 스키마로드를 처리합니다. 데이터베이스에는 작업자에 해당하는 번호가 접미사로 붙습니다. 예를 들어 작업자가 2 명인 경우 테스트에서 &lt;code&gt;test-database-0&lt;/code&gt; 및 &lt;code&gt;test-database-1&lt;/code&gt; 이 각각 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="386e54a11d7894ceb241faf51dd51687c5eddd76" translate="yes" xml:space="preserve">
          <source>When parsing POSTed data, Rails will take into account the special &lt;code&gt;_method&lt;/code&gt; parameter and act as if the HTTP method was the one specified inside it (&quot;PATCH&quot; in this example).</source>
          <target state="translated">POST 된 데이터를 구문 분석 할 때 Rails는 특수한 &lt;code&gt;_method&lt;/code&gt; 매개 변수 를 고려하여 HTTP 메소드가 내부에 지정된 것과 같은 역할을합니다 (이 예에서는 &quot;PATCH&quot;).</target>
        </trans-unit>
        <trans-unit id="6ccab1ce91695d166bf7b6ebf2be12918d421aa7" translate="yes" xml:space="preserve">
          <source>When passed a single key, if it exists and its associated value is either present or the singleton &lt;code&gt;false&lt;/code&gt;, returns said value:</source>
          <target state="translated">단일 키를 전달할 때 키가 존재하고 연관된 값이 존재하거나 싱글 톤 &lt;code&gt;false&lt;/code&gt; 인 경우 해당 값을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="42ecdce598e1a1b517ab03063f52f17adaf8d02d" translate="yes" xml:space="preserve">
          <source>When passed a symbol or a name of a method, returns an array of errors for the method.</source>
          <target state="translated">메소드의 기호 또는 이름을 전달하면 메소드에 대한 오류 배열을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="8cc70913884840c6eaf84f856d5e8338c613a836" translate="yes" xml:space="preserve">
          <source>When passing a record or a collection, you can still set the public header:</source>
          <target state="translated">레코드 나 컬렉션을 전달할 때 여전히 공개 헤더를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61def479b1ce6035bbef76e52b0c928dda28638" translate="yes" xml:space="preserve">
          <source>When passing paths, the &amp;ldquo;.js&amp;rdquo; extension is optional. If you do not want &amp;ldquo;.js&amp;rdquo; appended to the path &lt;code&gt;extname: false&lt;/code&gt; can be set on the options.</source>
          <target state="translated">경로를 전달할 때&amp;ldquo;.js&amp;rdquo;확장자는 선택 사항입니다. 경로 &lt;code&gt;extname: false&lt;/code&gt; &amp;ldquo;.js&amp;rdquo;를 추가하지 않으려면 옵션에서 false 를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78fcffbe94f8eacc7f1b3b0a8df898345f4e48ec" translate="yes" xml:space="preserve">
          <source>When performing requests, we will have &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/RequestHelpers.html&quot;&gt;&lt;code&gt;ActionDispatch::Integration::RequestHelpers&lt;/code&gt;&lt;/a&gt; available for our use.</source>
          <target state="translated">요청을 수행 할 때 &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Integration/RequestHelpers.html&quot;&gt; &lt;code&gt;ActionDispatch::Integration::RequestHelpers&lt;/code&gt; &lt;/a&gt; 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67b89614790b85e86b08b28c635a1a044a407e78" translate="yes" xml:space="preserve">
          <source>When possible, provide a content type as well. Active Storage attempts to determine a file&amp;rsquo;s content type from its data. It falls back to the content type you provide if it can&amp;rsquo;t do that.</source>
          <target state="translated">가능하면 컨텐츠 유형도 제공하십시오. Active Storage는 데이터에서 파일의 내용 유형을 확인하려고합니다. 제공 할 수없는 콘텐츠 유형으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="c96208501864eca9c09cb8cc6ccbece8bff38c2f" translate="yes" xml:space="preserve">
          <source>When projects is already an association on Person you can use &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; to define the writer method for you:</source>
          <target state="translated">프로젝트가 이미 Person에 연관되어있는 경우 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt; 를 사용하여 작성기 메소드를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba6fa77835b3dec6c4f379bfa15a6defc7001262" translate="yes" xml:space="preserve">
          <source>When queries are executed on this model, the SQL query will now look something like this:</source>
          <target state="translated">이 모델에서 쿼리가 실행되면 이제 SQL 쿼리는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d60f4c8aad35e00e7d1642bf6b8db6e25bc32f09" translate="yes" xml:space="preserve">
          <source>When rendering a collection of objects that each use the same partial, a &lt;code&gt;:cached&lt;/code&gt; option can be passed.</source>
          <target state="translated">각각 동일한 부분을 사용하는 객체 컬렉션을 렌더링 할 때 &lt;code&gt;:cached&lt;/code&gt; 옵션을 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0fa4aa98c1b62b43d95bf731af559fa0b68eaa9" translate="yes" xml:space="preserve">
          <source>When rendering a different template than the default controller/action style, you can indicate which digest to include in the ETag:</source>
          <target state="translated">기본 컨트롤러 / 액션 스타일과 다른 템플릿을 렌더링 할 때 ETag에 포함 할 다이제스트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95fe1139da26016e8da0c826a650092ec79e4cf8" translate="yes" xml:space="preserve">
          <source>When rendering a response, the controller needs to resolve where the different views are located. By default it only looks inside the &lt;code&gt;app/views&lt;/code&gt; directory.</source>
          <target state="translated">응답을 렌더링 할 때 컨트롤러는 다른보기가있는 위치를 해결해야합니다. 기본적으로 &lt;code&gt;app/views&lt;/code&gt; 디렉토리 내부에서만 보입니다 .</target>
        </trans-unit>
        <trans-unit id="cf5735336e93556233fa4334342425e5e525f1e1" translate="yes" xml:space="preserve">
          <source>When rendering collections it is also possible to use the &lt;code&gt;:layout&lt;/code&gt; option:</source>
          <target state="translated">컬렉션을 렌더링 할 때 &lt;code&gt;:layout&lt;/code&gt; 옵션 을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a62a05f7e0ee3863dc973fd63fcca4cad2ab7fd6" translate="yes" xml:space="preserve">
          <source>When running in the production environment, all &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; errors render the 404 error page. Unless you need a custom behavior you don't need to handle this.</source>
          <target state="translated">프로덕션 환경에서 실행할 때 모든 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 오류는 404 오류 페이지를 렌더링합니다. 사용자 지정 동작이 필요하지 않으면이를 처리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="791c45da2f328ee388ff3d71e5f4389e38b51d55" translate="yes" xml:space="preserve">
          <source>When running multi-user, multi-account applications, it's often useful to be able to filter the logs using some custom rules. &lt;code&gt;TaggedLogging&lt;/code&gt; in Active Support helps you do exactly that by stamping log lines with subdomains, request ids, and anything else to aid debugging such applications.</source>
          <target state="translated">다중 사용자, 다중 계정 응용 프로그램을 실행할 때 일부 사용자 지정 규칙을 사용하여 로그를 필터링하는 것이 유용한 경우가 많습니다. Active Support의 &lt;code&gt;TaggedLogging&lt;/code&gt; 을 사용하면 로그 도메인에 하위 도메인, 요청 ID 및 기타 응용 프로그램을 디버깅하는 데 도움이되는 모든 항목을 스탬프 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="aae8fecbf54922b5571bcbb8179a8367f934650c" translate="yes" xml:space="preserve">
          <source>When serializing job arguments, &lt;code&gt;Time&lt;/code&gt;, &lt;code&gt;DateTime&lt;/code&gt;, and &lt;code&gt;ActiveSupport::TimeWithZone&lt;/code&gt; lose microsecond precision. This means comparing deserialized time with actual time doesn't always work. To compensate for the loss of precision, &lt;code&gt;assert_enqueued_with&lt;/code&gt; and &lt;code&gt;assert_performed_with&lt;/code&gt; will remove microseconds from time objects in argument assertions.</source>
          <target state="translated">작업 인수를 직렬화 할 때 &lt;code&gt;Time&lt;/code&gt; , &lt;code&gt;DateTime&lt;/code&gt; 및 &lt;code&gt;ActiveSupport::TimeWithZone&lt;/code&gt; 은 마이크로 초 정밀도를 잃습니다. 이것은 역 직렬화 된 시간과 실제 시간을 비교하는 것이 항상 작동하는 것은 아닙니다. 정밀도 손실을 보상하기 위해 &lt;code&gt;assert_enqueued_with&lt;/code&gt; 및 &lt;code&gt;assert_performed_with&lt;/code&gt; 는 인수 어설 션의 시간 객체에서 마이크로 초를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="bf299144eb46d9647384489cddda7b32dc47767e" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the association will also have its presence validated. This will validate the association itself, not the id. You can use &lt;code&gt;:inverse_of&lt;/code&gt; to avoid an extra query during validation.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 연결의 존재 여부도 확인됩니다. 이것은 ID가 아닌 연결 자체의 유효성을 검사합니다. &lt;code&gt;:inverse_of&lt;/code&gt; 를 사용 하면 유효성 검사 중에 추가 쿼리를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="20846b814204321ae2eed85dfed04e95603da159" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the association will also have its presence validated. This will validate the association itself, not the id. You can use &lt;code&gt;:inverse_of&lt;/code&gt; to avoid an extra query during validation. NOTE: &lt;code&gt;required&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; by default and is deprecated. If you don't want to have association presence validated, use &lt;code&gt;optional: true&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 연결의 존재 여부도 확인됩니다. 이것은 ID가 아닌 연결 자체의 유효성을 검사합니다. &lt;code&gt;:inverse_of&lt;/code&gt; 를 사용 하면 유효성 검사 중에 추가 쿼리를 피할 수 있습니다 . 참고 : &lt;code&gt;required&lt;/code&gt; 는 기본적 으로 &lt;code&gt;true&lt;/code&gt; 로 설정되어 있으며 더 이상 사용되지 않습니다. 연관 존재 여부를 확인하지 않으려면 &lt;code&gt;optional: true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb83dd910637372d85f8d30b1df8845b034c1a0d" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the association will not have its presence validated.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 연결의 존재가 확인되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cecab59522ddd49c5b6ea86ba4586a86ac20cc67" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, validates new objects added to association when saving the parent object. &lt;code&gt;false&lt;/code&gt; by default. If you want to ensure associated objects are revalidated on every update, use &lt;code&gt;validates_associated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 상위 오브젝트를 저장할 때 연관에 추가 된 새 오브젝트의 유효성을 검증합니다. 기본적으로 &lt;code&gt;false&lt;/code&gt; 입니다. 매번 업데이트 할 때마다 관련 객체의 유효성을 다시 &lt;code&gt;validates_associated&lt;/code&gt; 하려면 validates_related를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f7a1e9af1a9fd24d65e6a24424b0c810c04a35" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, validates new objects added to association when saving the parent object. &lt;code&gt;true&lt;/code&gt; by default. If you want to ensure associated objects are revalidated on every update, use &lt;code&gt;validates_associated&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 로 설정 하면 상위 오브젝트를 저장할 때 연관에 추가 된 새 오브젝트의 유효성을 검증합니다. 기본적으로 &lt;code&gt;true&lt;/code&gt; 입니다. 매번 업데이트 할 때마다 관련 객체의 유효성을 다시 &lt;code&gt;validates_associated&lt;/code&gt; 하려면 validates_related를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="285a271475735e10d3693520ecd463cdb0088977" translate="yes" xml:space="preserve">
          <source>When something is logged, it's printed into the corresponding log if the log level of the message is equal to or higher than the configured log level. If you want to know the current log level, you can call the &lt;code&gt;Rails.logger.level&lt;/code&gt; method.</source>
          <target state="translated">메시지가 기록 될 때 메시지의 로그 수준이 구성된 로그 수준 이상인 경우 해당 로그에 인쇄됩니다. 현재 로그 수준을 알고 싶다면 &lt;code&gt;Rails.logger.level&lt;/code&gt; 메서드를 호출하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="fa7aeb0b5c02ad6002367e96937d55c193718a81" translate="yes" xml:space="preserve">
          <source>When static assets are deployed with each new release of code, the mtime (time of last modification) of &lt;em&gt;all&lt;/em&gt; these files changes, forcing all remote clients to fetch them again, even when the content of those assets has not changed.</source>
          <target state="translated">정적 자산이 각각의 새 코드 릴리스와 함께 배포되면 이러한 &lt;em&gt;모든&lt;/em&gt; 파일 의 mtime (마지막 수정 시간) 이 변경되어 해당 자산의 내용이 변경되지 않은 경우에도 모든 원격 클라이언트가 해당 파일을 다시 가져 오도록합니다.</target>
        </trans-unit>
        <trans-unit id="a709f6cd6f87ce4425874e809c66acd8a9e2f6b5" translate="yes" xml:space="preserve">
          <source>When streaming, rendering happens top-down instead of inside-out. Rails starts with the layout, and the template is rendered later, when its &lt;code&gt;yield&lt;/code&gt; is reached.</source>
          <target state="translated">스트리밍시 렌더링은 내부가 아닌 하향식으로 수행됩니다. Rails는 레이아웃으로 시작하고 템플릿은 &lt;code&gt;yield&lt;/code&gt; 에 도달 하면 나중에 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="a713e9eefe2daa9c26308c8814d6c2565dbf470e" translate="yes" xml:space="preserve">
          <source>When streaming, the HTTP headers are sent to the client right before it renders the first line. This means that, modifying headers, cookies, session or flash after the template starts rendering will not propagate to the client.</source>
          <target state="translated">스트리밍 할 때 HTTP 헤더는 첫 번째 줄을 렌더링하기 직전에 클라이언트로 전송됩니다. 즉, 템플릿 렌더링이 시작된 후 헤더, 쿠키, 세션 또는 플래시를 수정해도 클라이언트에 전파되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15e603a50cb2fa61234ad23bb2ebaf34ced3a456" translate="yes" xml:space="preserve">
          <source>When tests are run in your application, the default order is now &lt;code&gt;:random&lt;/code&gt; instead of &lt;code&gt;:sorted&lt;/code&gt;. Use the following config option to set it back to &lt;code&gt;:sorted&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램에서 테스트를 실행할 때 기본 순서는 이제 &lt;code&gt;:sorted&lt;/code&gt; 대신 &lt;code&gt;:random&lt;/code&gt; 입니다. 다음 구성 옵션을 사용하여 다시 &lt;code&gt;:sorted&lt;/code&gt; 로 설정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4c9df729de86ddceb1b4f87751c8b46a6a9eb54" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;mail&lt;/code&gt; method will be triggered, it will send a multipart email with an attachment, properly nested with the top level being &lt;code&gt;multipart/mixed&lt;/code&gt; and the first part being a &lt;code&gt;multipart/alternative&lt;/code&gt; containing the plain text and HTML email messages.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 메소드가 트리거 될 때 첨부 파일이있는 멀티 파트 이메일을 발송합니다. 최상위 레벨은 &lt;code&gt;multipart/mixed&lt;/code&gt; 이고 첫 번째 파트 는 일반 텍스트 및 HTML 이메일 메시지를 포함 하는 &lt;code&gt;multipart/alternative&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="2eb9453ad50f7b7d4d1fb54ec22d8a449c593f67" translate="yes" xml:space="preserve">
          <source>When the Asset Pipeline is enabled, you can pass the name of your manifest as source, and include other JavaScript or CoffeeScript files inside the manifest.</source>
          <target state="translated">자산 파이프 라인이 활성화되면 매니페스트 이름을 소스로 전달하고 매니페스트 내에 다른 JavaScript 또는 CoffeeScript 파일을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1b970a97d04d63419556c66bdfcc532b2efd48b2" translate="yes" xml:space="preserve">
          <source>When the application is asked to render the view for &lt;code&gt;Blorgh::ArticlesController&lt;/code&gt;'s index action, it will first look for the path &lt;code&gt;app/views/blorgh/articles/index.html.erb&lt;/code&gt; within the application. If it cannot find it, it will look inside the engine.</source>
          <target state="translated">응용 프로그램에 &lt;code&gt;Blorgh::ArticlesController&lt;/code&gt; 의 인덱스 작업에 대한 뷰를 렌더링하도록 요청 하면 먼저 응용 프로그램 내에서 &lt;code&gt;app/views/blorgh/articles/index.html.erb&lt;/code&gt; 경로를 찾습니다 . 찾을 수 없으면 엔진 내부를 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="db4799df64ca1dcd4c792d93182586efacab4966" translate="yes" xml:space="preserve">
          <source>When the application runs, code is reloaded when something relevant to this logic changes. In order to do that, Rails monitors a number of things:</source>
          <target state="translated">응용 프로그램이 실행될 때이 논리와 관련된 사항이 변경되면 코드가 다시로드됩니다. 이를 위해 Rails는 여러 가지 사항을 모니터링합니다.</target>
        </trans-unit>
        <trans-unit id="260fc480713cfdb067c87451b2b5eda43352c152" translate="yes" xml:space="preserve">
          <source>When the argument is a module it will be included directly in the template class.</source>
          <target state="translated">인수가 모듈 인 경우 템플릿 클래스에 직접 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5482e88f34e07ab2326f172a94af14b0cd057adb" translate="yes" xml:space="preserve">
          <source>When the argument is a string or symbol, the method will provide the &amp;ldquo;_helper&amp;rdquo; suffix, require the file and include the module in the template class. The second form illustrates how to include custom helpers when working with namespaced controllers, or other cases where the file containing the helper definition is not in one of Rails' standard load paths:</source>
          <target state="translated">인수가 문자열 또는 기호 인 경우이 메소드는&amp;ldquo;_helper&amp;rdquo;접미사를 제공하고 파일이 필요하며 모듈을 템플릿 클래스에 포함시킵니다. 두 번째 형식은 네임 스페이스 컨트롤러로 작업 할 때 사용자 정의 헬퍼를 포함하는 방법 또는 헬퍼 정의를 포함하는 파일이 Rails의 표준로드 경로 중 하나에없는 경우를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="378a2916b068d742add2441701916dcb54b38163" translate="yes" xml:space="preserve">
          <source>When the browser hits the variant URL, Active Storage will lazily transform the original blob into the specified format and redirect to its new service location.</source>
          <target state="translated">브라우저가 변형 URL에 도달하면 Active Storage는 원래 Blob을 지정된 형식으로 느리게 변환하고 새 서비스 위치로 리디렉션합니다.</target>
        </trans-unit>
        <trans-unit id="676e4bdc78a617bf7aa4548f630661440ce29563" translate="yes" xml:space="preserve">
          <source>When the built-in validation helpers are not enough for your needs, you can write your own validators or validation methods as you prefer.</source>
          <target state="translated">내장 된 유효성 검사 헬퍼가 충분하지 않은 경우 원하는대로 고유 한 유효성 검사기 또는 유효성 검사 방법을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2837507b9624d59f21336f5201fef362c53c6c2" translate="yes" xml:space="preserve">
          <source>When the consumer is subscribed to a channel, they act as a subscriber. The connection between the subscriber and the channel is, surprise-surprise, called a subscription. A consumer can act as a subscriber to a given channel any number of times. For example, a consumer could subscribe to multiple chat rooms at the same time. (And remember that a physical user may have multiple consumers, one per tab/device open to your connection).</source>
          <target state="translated">소비자가 채널을 구독하면 구독자 역할을합니다. 구독자와 채널 간의 연결을 놀랍게도 구독이라고합니다. 소비자는 지정된 채널의 구독자로 여러 번 작동 할 수 있습니다. 예를 들어 소비자는 동시에 여러 대화방에 가입 할 수 있습니다. (실제 사용자는 탭 / 장치 당 하나의 연결에 대해 여러 소비자를 가질 수 있음을 기억하십시오).</target>
        </trans-unit>
        <trans-unit id="08c1f080fa868d0dc65a3e92b05e644521a7a8f2" translate="yes" xml:space="preserve">
          <source>When the database catches such a duplicate insertion, &lt;a href=&quot;../persistence#method-i-save&quot;&gt;ActiveRecord::Base#save&lt;/a&gt; will raise an &lt;a href=&quot;../statementinvalid&quot;&gt;ActiveRecord::StatementInvalid&lt;/a&gt; exception. You can either choose to let this error propagate (which will result in the default Rails exception page being shown), or you can catch it and restart the transaction (e.g. by telling the user that the title already exists, and asking them to re-enter the title). This technique is also known as &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;optimistic concurrency control&lt;/a&gt;.</source>
          <target state="translated">데이터베이스가 이러한 중복 삽입을 발견하면 &lt;a href=&quot;../persistence#method-i-save&quot;&gt;ActiveRecord :: Base # save&lt;/a&gt; 는 &lt;a href=&quot;../statementinvalid&quot;&gt;ActiveRecord :: StatementInvalid&lt;/a&gt; 예외를 발생시킵니다. 이 오류를 전파하도록 선택하거나 (기본 Rails 예외 페이지가 표시됨)이를 포착하여 트랜잭션을 다시 시작할 수 있습니다 (예 : 사용자에게 제목이 이미 있음을 알리고 다시 요청하도록 요청) 제목을 입력하십시오). 이 기술은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Optimistic_concurrency_control&quot;&gt;낙관적 동시성 제어&lt;/a&gt; 라고도 합니다 .</target>
        </trans-unit>
        <trans-unit id="c3d10d0b67944606bbf84d84657fd8833d52fa75" translate="yes" xml:space="preserve">
          <source>When the entirety of &lt;code&gt;ActiveRecord::Base&lt;/code&gt; has been evaluated then &lt;code&gt;run_load_hooks&lt;/code&gt; is invoked. The very last line of &lt;code&gt;ActiveRecord::Base&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;ActiveRecord::Base&lt;/code&gt; 전체 가 평가 &lt;code&gt;run_load_hooks&lt;/code&gt; 가 호출됩니다. &lt;code&gt;ActiveRecord::Base&lt;/code&gt; 의 마지막 줄 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="422630819249f956534b779adb6f4307fb00599d" translate="yes" xml:space="preserve">
          <source>When the gem is ready to be shared as a formal release, it can be published to &lt;a href=&quot;https://rubygems.org&quot;&gt;RubyGems&lt;/a&gt;. For more information about publishing gems to RubyGems, see: &lt;a href=&quot;https://guides.rubygems.org/publishing&quot;&gt;Publishing your gem&lt;/a&gt;.</source>
          <target state="translated">gem을 정식 릴리스로 공유 할 준비가되면 &lt;a href=&quot;https://rubygems.org&quot;&gt;RubyGems에&lt;/a&gt; 공개 할 수 있습니다 . RubyGem에 gem을 게시하는 방법에 대한 자세한 내용은 &lt;a href=&quot;https://guides.rubygems.org/publishing&quot;&gt;gem 게시를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ca8e8098061fe7102515b4e24f13a7b3f1e6e76e" translate="yes" xml:space="preserve">
          <source>When the given key starts with a period, it will be scoped by the current controller and action. So if you call &lt;code&gt;translate(&quot;.foo&quot;)&lt;/code&gt; from &lt;code&gt;PeopleController#index&lt;/code&gt;, it will convert the call to &lt;code&gt;I18n.translate(&quot;people.index.foo&quot;)&lt;/code&gt;. This makes it less repetitive to translate many keys within the same controller / action and gives you a simple framework for scoping them consistently.</source>
          <target state="translated">주어진 키가 마침표로 시작하면 현재 컨트롤러 및 작업에 의해 범위가 지정됩니다. 따라서 &lt;code&gt;PeopleController#index&lt;/code&gt; 에서 &lt;code&gt;translate(&quot;.foo&quot;)&lt;/code&gt; 를 호출하면 호출을 &lt;code&gt;I18n.translate(&quot;people.index.foo&quot;)&lt;/code&gt; 로 변환합니다 . 따라서 동일한 컨트롤러 / 액션 내에서 많은 키를 변환하는 것이 덜 반복적이며 일관성있게 범위를 지정할 수있는 간단한 프레임 워크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ea259506fa511d510d5f7fa7670a54218a8c79d5" translate="yes" xml:space="preserve">
          <source>When the last argument in a method call is a hash, except perhaps for a &lt;code&gt;&amp;amp;block&lt;/code&gt; argument, Ruby allows you to omit the brackets:</source>
          <target state="translated">메소드 호출의 마지막 인수가 &lt;code&gt;&amp;amp;block&lt;/code&gt; 인수 를 제외하고 해시 인 경우 Ruby는 대괄호를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12545d7515c6d63a5db9182d71904c4e4fab09ca" translate="yes" xml:space="preserve">
          <source>When the last parameter is a hash you can add HTML attributes using that parameter.</source>
          <target state="translated">마지막 매개 변수가 해시 인 경우 해당 매개 변수를 사용하여 HTML 속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf6007b2e68be61ceb0427f05c55bafd6c256da1" translate="yes" xml:space="preserve">
          <source>When the last parameter is a hash you can add HTML attributes using that parameter. The following options are supported:</source>
          <target state="translated">마지막 매개 변수가 해시 인 경우 해당 매개 변수를 사용하여 HTML 속성을 추가 할 수 있습니다. 다음과 같은 옵션이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="2b41f1be1c7087182da7de749c694b9cfa2ecc07" translate="yes" xml:space="preserve">
          <source>When the object belonging to the current scope has a nested attribute writer for a certain attribute, &lt;a href=&quot;formbuilder#method-i-fields_for&quot;&gt;#fields_for&lt;/a&gt; will yield a new scope for that attribute. This allows you to create forms that set or change the attributes of a parent object and its associations in one go.</source>
          <target state="translated">현재 범위에 속하는 객체에 특정 속성에 대해 중첩 된 속성 작성 &lt;a href=&quot;formbuilder#method-i-fields_for&quot;&gt;기가있는&lt;/a&gt; 경우 #fields_for 는 해당 속성에 대한 새로운 범위를 생성합니다. 이를 통해 부모 개체의 속성과 해당 연결을 한 번에 설정하거나 변경하는 양식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43b4d4f68f35067a68486f6156453dd0dd1c156c" translate="yes" xml:space="preserve">
          <source>When the object belonging to the current scope has a nested attribute writer for a certain attribute, &lt;a href=&quot;formhelper#method-i-fields_for&quot;&gt;#fields_for&lt;/a&gt; will yield a new scope for that attribute. This allows you to create forms that set or change the attributes of a parent object and its associations in one go.</source>
          <target state="translated">현재 범위에 속하는 객체에 특정 속성에 대해 중첩 된 속성 작성 &lt;a href=&quot;formhelper#method-i-fields_for&quot;&gt;기가있는&lt;/a&gt; 경우 #fields_for 는 해당 속성에 대한 새로운 범위를 생성합니다. 이를 통해 부모 개체의 속성과 해당 연결을 한 번에 설정하거나 변경하는 양식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b6f50abd27ef5e05e0d2d41e13070af1e3c3e01" translate="yes" xml:space="preserve">
          <source>When the record is created, a check is performed to make sure that no record exists in the database with the given value for the specified attribute (that maps to a column). When the record is updated, the same check is made but disregarding the record itself.</source>
          <target state="translated">레코드가 작성 될 때 지정된 속성에 대해 지정된 값 (열에 맵핑 됨)이 지정된 데이터베이스에 레코드가 없는지 확인하기 위해 검사가 수행됩니다. 레코드가 업데이트되면 동일한 검사가 수행되지만 레코드 자체는 무시합니다.</target>
        </trans-unit>
        <trans-unit id="4fdd5dbf88da212d54d7996a4200b2e95741e792" translate="yes" xml:space="preserve">
          <source>When the request is sent.</source>
          <target state="translated">요청이 전송 될 때</target>
        </trans-unit>
        <trans-unit id="62f219c0f8398de2e626fa1f93eb10f510907641" translate="yes" xml:space="preserve">
          <source>When the request is stopped.</source>
          <target state="translated">요청이 중지 된 경우</target>
        </trans-unit>
        <trans-unit id="63f62d63a6f59689b6b6f4791fccac92fd89e087" translate="yes" xml:space="preserve">
          <source>When the schema format is set to &lt;code&gt;:sql&lt;/code&gt;, the database structure will be dumped using a tool specific to the database into &lt;code&gt;db/structure.sql&lt;/code&gt;. For example, for PostgreSQL, the &lt;code&gt;pg_dump&lt;/code&gt; utility is used. For MySQL and MariaDB, this file will contain the output of &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; for the various tables.</source>
          <target state="translated">스키마 형식이 &lt;code&gt;:sql&lt;/code&gt; 로 설정 되면 데이터베이스에 특정한 도구를 사용하여 데이터베이스 구조가 &lt;code&gt;db/structure.sql&lt;/code&gt; 로 덤프됩니다 . 예를 들어 PostgreSQL의 경우 &lt;code&gt;pg_dump&lt;/code&gt; 유틸리티가 사용됩니다. MySQL 및 MariaDB의 경우이 파일에는 다양한 테이블에 대한 &lt;code&gt;SHOW CREATE TABLE&lt;/code&gt; 출력이 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="a30507125724fbe0dca731711306a19afc5738c4" translate="yes" xml:space="preserve">
          <source>When this form is submitted, it is going to attempt to perform a &lt;code&gt;POST&lt;/code&gt; request to a route of &lt;code&gt;/articles/:article_id/comments&lt;/code&gt; within the engine. This route doesn't exist at the moment, but can be created by changing the &lt;code&gt;resources :articles&lt;/code&gt; line inside &lt;code&gt;config/routes.rb&lt;/code&gt; into these lines:</source>
          <target state="translated">이 양식을 제출 하면 엔진 내 &lt;code&gt;/articles/:article_id/comments&lt;/code&gt; 경로에 &lt;code&gt;POST&lt;/code&gt; 요청을 수행하려고 합니다 . 이 경로는 현재 존재하지 않지만 &lt;code&gt;config/routes.rb&lt;/code&gt; 내의 &lt;code&gt;resources :articles&lt;/code&gt; 행 을 다음 행 으로 변경하여 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8527fa37b89b52967c21e362867b58fb687fe771" translate="yes" xml:space="preserve">
          <source>When this form is submitted, the value of &lt;code&gt;params[:client]&lt;/code&gt; will be &lt;code&gt;{ &quot;name&quot; =&amp;gt; &quot;Acme&quot;, &quot;phone&quot; =&amp;gt; &quot;12345&quot;, &quot;address&quot; =&amp;gt; { &quot;postcode&quot; =&amp;gt; &quot;12345&quot;, &quot;city&quot; =&amp;gt; &quot;Carrot City&quot; } }&lt;/code&gt;. Note the nested hash in &lt;code&gt;params[:client][:address]&lt;/code&gt;.</source>
          <target state="translated">이 양식이 제출되면, 값 &lt;code&gt;params[:client]&lt;/code&gt; 것 &lt;code&gt;{ &quot;name&quot; =&amp;gt; &quot;Acme&quot;, &quot;phone&quot; =&amp;gt; &quot;12345&quot;, &quot;address&quot; =&amp;gt; { &quot;postcode&quot; =&amp;gt; &quot;12345&quot;, &quot;city&quot; =&amp;gt; &quot;Carrot City&quot; } }&lt;/code&gt; . &lt;code&gt;params[:client][:address]&lt;/code&gt; 의 중첩 해시를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="713fdaa616285532f53ce5f52f4c42a15742e3f3" translate="yes" xml:space="preserve">
          <source>When this is passed to &lt;code&gt;Person.new&lt;/code&gt; (or &lt;code&gt;update&lt;/code&gt;), Active Record spots that these parameters should all be used to construct the &lt;code&gt;birth_date&lt;/code&gt; attribute and uses the suffixed information to determine in which order it should pass these parameters to functions such as &lt;code&gt;Date.civil&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;Person.new&lt;/code&gt; (또는 &lt;code&gt;update&lt;/code&gt; )에 전달되면 Active Record는 이러한 매개 변수가 모두 &lt;code&gt;birth_date&lt;/code&gt; 속성 을 구성하는 데 사용되어야 하고 접미사 정보를 사용하여 이러한 매개 변수를 &lt;code&gt;Date.civil&lt;/code&gt; 과 같은 함수에 전달할 순서를 결정합니다. .</target>
        </trans-unit>
        <trans-unit id="5637384c5bf05a84dadb8afe90fbed21e946fbd9" translate="yes" xml:space="preserve">
          <source>When this module is prepended to &lt;a href=&quot;../relation&quot;&gt;ActiveRecord::Relation&lt;/a&gt; and &lt;code&gt;config.active_record.warn_on_records_fetched_greater_than&lt;/code&gt; is set to an integer, if the number of records a query returns is greater than the value of &lt;code&gt;warn_on_records_fetched_greater_than&lt;/code&gt;, a warning is logged. This allows for the detection of queries that return a large number of records, which could cause memory bloat.</source>
          <target state="translated">이 모듈이 &lt;a href=&quot;../relation&quot;&gt;ActiveRecord :: Relation&lt;/a&gt; 앞에 추가 되고 &lt;code&gt;config.active_record.warn_on_records_fetched_greater_than&lt;/code&gt; 이 정수로 설정되면 쿼리가 리턴하는 레코드 수가 &lt;code&gt;warn_on_records_fetched_greater_than&lt;/code&gt; 값보다 큰 경우 경고가 기록됩니다. 이를 통해 많은 수의 레코드를 반환하는 쿼리를 감지 할 수 있으며 이로 인해 메모리 팽창이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="61ec2000fed5ac679019a969ff38716d02ad4c22" translate="yes" xml:space="preserve">
          <source>When this option is true, digests will be generated for asset URLs.</source>
          <target state="translated">이 옵션이 true이면 자산 URL에 대해 요약이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="5ceec3c5ef7698aea4335dc1a569310eecfc0aaf" translate="yes" xml:space="preserve">
          <source>When to use streaming</source>
          <target state="translated">스트리밍 사용시기</target>
        </trans-unit>
        <trans-unit id="2b3a3ff7100bf25d424256bb7e806c38c57941f7" translate="yes" xml:space="preserve">
          <source>When triggered by an explicit context, validations are run for that context, as well as any validations &lt;em&gt;without&lt;/em&gt; a context.</source>
          <target state="translated">명시 적 컨텍스트에 의해 트리거되면 컨텍스트가 &lt;em&gt;없는&lt;/em&gt; 유효성 검증뿐만 아니라 해당 컨텍스트에 대한 유효성 검증이 실행 됩니다.</target>
        </trans-unit>
        <trans-unit id="3687cc97b1d8b2790cb22a60d6cfa1c6c8550b56" translate="yes" xml:space="preserve">
          <source>When upgrading from Rails 4.2 to Rails 5.0, you need to create an &lt;code&gt;application_job.rb&lt;/code&gt; file in &lt;code&gt;app/jobs/&lt;/code&gt; and add the following content:</source>
          <target state="translated">Rails 4.2에서 Rails 5.0으로 업그레이드 할 때 &lt;code&gt;app/jobs/&lt;/code&gt; 에 &lt;code&gt;application_job.rb&lt;/code&gt; 파일 을 생성 하고 다음 내용을 추가해야합니다 :</target>
        </trans-unit>
        <trans-unit id="f4cd617710b955c629cd9f25420790186c053edd" translate="yes" xml:space="preserve">
          <source>When upgrading from Rails 4.2 to Rails 5.0, you need to create an &lt;code&gt;application_record.rb&lt;/code&gt; file in &lt;code&gt;app/models/&lt;/code&gt; and add the following content:</source>
          <target state="translated">Rails 4.2에서 Rails 5.0으로 업그레이드 할 때 &lt;code&gt;app/models/&lt;/code&gt; 에 &lt;code&gt;application_record.rb&lt;/code&gt; 파일 을 생성 하고 다음 내용을 추가해야합니다 :</target>
        </trans-unit>
        <trans-unit id="0966045c9b81868d24e938999d7ec5852ec8ee0c" translate="yes" xml:space="preserve">
          <source>When used with the &lt;code&gt;collection_select&lt;/code&gt; helper, &lt;code&gt;:disabled&lt;/code&gt; can also be a Proc that identifies those options that should be disabled.</source>
          <target state="translated">&lt;code&gt;collection_select&lt;/code&gt; 헬퍼 와 함께 사용하면 &lt;code&gt;:disabled&lt;/code&gt; 는 비활성화해야하는 옵션을 식별하는 Proc 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="11dae9c62c610f253df5843ae0d6f53bdb545fd8" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;html:&lt;/code&gt; option, HTML entities will be escaped if the string is not composed with &lt;code&gt;html_safe&lt;/code&gt;-aware APIs.</source>
          <target state="translated">&lt;code&gt;html:&lt;/code&gt; 옵션을 사용할 때 문자열이 &lt;code&gt;html_safe&lt;/code&gt; -aware API 로 구성되지 않으면 HTML 엔티티가 이스케이프됩니다 .</target>
        </trans-unit>
        <trans-unit id="db16016376dc96afd4491510e8e049bff9ee8050" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;magazine_ad_path&lt;/code&gt;, you can pass in instances of &lt;code&gt;Magazine&lt;/code&gt; and &lt;code&gt;Ad&lt;/code&gt; instead of the numeric IDs:</source>
          <target state="translated">사용하는 경우 &lt;code&gt;magazine_ad_path&lt;/code&gt; 를 , 당신의 경우에 전달할 수있는 &lt;code&gt;Magazine&lt;/code&gt; 와 &lt;code&gt;Ad&lt;/code&gt; 대신 숫자 ID의 :</target>
        </trans-unit>
        <trans-unit id="017d65dd8bdfe943a8612df98eaa80e2a46cc0f1" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;url_for&lt;/code&gt; you'll need to provide the &lt;code&gt;:host&lt;/code&gt;, &lt;code&gt;:controller&lt;/code&gt;, and &lt;code&gt;:action&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;url_for&lt;/code&gt; 를 사용 하는 경우 &lt;code&gt;:host&lt;/code&gt; , &lt;code&gt;:controller&lt;/code&gt; 및 &lt;code&gt;:action&lt;/code&gt; 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e1b38e046cff72828f38a2605f844684774dd156" translate="yes" xml:space="preserve">
          <source>When using Ruby 2.4, you can preserve the timezone of the receiver when calling &lt;code&gt;to_time&lt;/code&gt;.</source>
          <target state="translated">Ruby 2.4를 사용하면 &lt;code&gt;to_time&lt;/code&gt; 을 호출 할 때 수신자의 시간대를 유지할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2ad0cd2e495bae106cf61d19d1f42023aed5125" translate="yes" xml:space="preserve">
          <source>When using a custom coder (e.g. &lt;code&gt;serialize :metadata, JSON&lt;/code&gt;), assigning &lt;code&gt;nil&lt;/code&gt; to a serialized attribute will save it to the database as &lt;code&gt;NULL&lt;/code&gt; instead of passing the &lt;code&gt;nil&lt;/code&gt; value through the coder (e.g. &lt;code&gt;&quot;null&quot;&lt;/code&gt; when using the &lt;code&gt;JSON&lt;/code&gt; coder).</source>
          <target state="translated">사용자 정의 코더 (예 : &lt;code&gt;serialize :metadata, JSON&lt;/code&gt; ) 를 사용하는 경우 직렬화 된 속성에 &lt;code&gt;nil&lt;/code&gt; 을 지정 하면 &lt;code&gt;nil&lt;/code&gt; 값을 코더를 통해 전달하는 대신 &lt;code&gt;NULL&lt;/code&gt; 로 데이터베이스에 저장합니다 (예 : &lt;code&gt;JSON&lt;/code&gt; 코더를 사용할 때 &lt;code&gt;&quot;null&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="66cfcf22b3c676a6997ffa9902a30809f2d3184d" translate="yes" xml:space="preserve">
          <source>When using a nested association, you will not be able to modify the association because there is not enough information to know what modification to make. For example, if you tried to add a &lt;code&gt;Commenter&lt;/code&gt; in the example above, there would be no way to tell how to set up the intermediate &lt;code&gt;Post&lt;/code&gt; and &lt;code&gt;Comment&lt;/code&gt; objects.</source>
          <target state="translated">중첩 된 연결을 사용할 때는 수정해야 할 내용을 알 수있는 정보가 충분하지 않기 때문에 연결을 수정할 수 없습니다. 당신이 추가하려고 예를 들어, &lt;code&gt;Commenter&lt;/code&gt; 위의 예에서, 중간 설정하는 방법을 알 수있는 방법이 없을 것 &lt;code&gt;Post&lt;/code&gt; 및 &lt;code&gt;Comment&lt;/code&gt; 개체를.</target>
        </trans-unit>
        <trans-unit id="9fb14fc1ba31f4e1ea9e37cf65b0238fc88da75d" translate="yes" xml:space="preserve">
          <source>When using a replica database you need to add a &lt;code&gt;replica: true&lt;/code&gt; entry to the replica in the &lt;code&gt;database.yml&lt;/code&gt;. This is because Rails otherwise has no way of knowing which one is a replica and which one is the primary.</source>
          <target state="translated">복제 데이터베이스를 사용하는 경우 당신은 추가 할 필요 &lt;code&gt;replica: true&lt;/code&gt; 의 복제에 대한 항목 &lt;code&gt;database.yml&lt;/code&gt; 을을 . 그렇지 않으면 Rails는 어느 것이 복제본이고 어떤 것이 기본인지 알 수 없기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="1491a0d8a6ea33ff245dd6cc7c74ca7d3bdbc45d" translate="yes" xml:space="preserve">
          <source>When using a symbol for &lt;code&gt;cast_type&lt;/code&gt;, extra options are forwarded to the constructor of the type object.</source>
          <target state="translated">&lt;code&gt;cast_type&lt;/code&gt; 에 기호를 사용하면 추가 옵션이 유형 객체의 생성자로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="7370c9863746c973185e4c2a5aad9ffcbde16aef" translate="yes" xml:space="preserve">
          <source>When using a threaded web server, such as the default Puma, multiple HTTP requests will be served simultaneously, with each request provided its own controller instance.</source>
          <target state="translated">기본 Puma와 같은 스레드 웹 서버를 사용하는 경우 각 요청에 자체 컨트롤러 인스턴스가 제공되는 여러 HTTP 요청이 동시에 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="44b21096e69b68ae4ff5c6383c48e95d27e538c4" translate="yes" xml:space="preserve">
          <source>When using another library to make Ajax calls, it is necessary to add the security token as a default header for Ajax calls in your library. To get the token:</source>
          <target state="translated">다른 라이브러리를 사용하여 Ajax 호출을 수행하는 경우 라이브러리에서 Ajax 호출의 기본 헤더로 보안 토큰을 추가해야합니다. 토큰을 얻으려면</target>
        </trans-unit>
        <trans-unit id="3ebd1d3db42111fdba613c33ce7d2d94e6e89e29" translate="yes" xml:space="preserve">
          <source>When using asset precompilation, you will need to ensure that your controller assets will be precompiled when loading them on a per page basis. By default &lt;code&gt;.coffee&lt;/code&gt; and &lt;code&gt;.scss&lt;/code&gt; files will not be precompiled on their own. See &lt;a href=&quot;#precompiling-assets&quot;&gt;Precompiling Assets&lt;/a&gt; for more information on how precompiling works.</source>
          <target state="translated">자산 사전 컴파일을 사용하는 경우 컨트롤러 자산을 페이지 당로드 할 때 사전 컴파일해야합니다. 기본적으로 &lt;code&gt;.coffee&lt;/code&gt; 및 &lt;code&gt;.scss&lt;/code&gt; 파일은 자체적으로 사전 컴파일되지 않습니다. 사전 컴파일 작동 방식에 대한 자세한 내용은 &lt;a href=&quot;#precompiling-assets&quot;&gt;자산 사전 컴파일을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5e3736fbf61b5ba2e5b61df2c03d5c15a2c2c6e8" translate="yes" xml:space="preserve">
          <source>When using inheritance in your models, it will check all the inherited models too, but only if the model itself hasn't been found. Say you have &lt;code&gt;class Admin &amp;lt; User; end&lt;/code&gt; and you wanted the translation for the &lt;code&gt;:blank&lt;/code&gt; error message for the &lt;code&gt;title&lt;/code&gt; attribute, it looks for these translations:</source>
          <target state="translated">모델에서 상속을 사용하면 상속 된 모든 모델도 검사하지만 모델 자체를 찾지 못한 경우에만 검사합니다. &lt;code&gt;class Admin &amp;lt; User; end&lt;/code&gt; 가 있다고 가정하십시오 . end 및 &lt;code&gt;title&lt;/code&gt; 속성에 대한 &lt;code&gt;:blank&lt;/code&gt; 오류 메시지에 대한 번역을 원하면 다음 번역을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="ad68c2e0fd6a9cc9b32d54966fe897b7b3e7a663" translate="yes" xml:space="preserve">
          <source>When using multiple databases there are a few important settings.</source>
          <target state="translated">여러 데이터베이스를 사용하는 경우 몇 가지 중요한 설정이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2364174d18c390a48a043b75041eb38d23b38b9" translate="yes" xml:space="preserve">
          <source>When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing the question marks with symbols and supplying a hash with values for the matching symbol keys:</source>
          <target state="translated">조건에서 여러 매개 변수를 사용하는 경우 네 번째 또는 다섯 번째 물음표가 무엇을 나타내는 지 정확하게 이해하기가 어려워 질 수 있습니다. 이 경우 대신 명명 된 바인드 변수를 사용할 수 있습니다. 물음표를 기호로 바꾸고 일치하는 기호 키의 값으로 해시를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="1a92868f0bdbc6ee725f49daf538aa57784a0acf" translate="yes" xml:space="preserve">
          <source>When using named routes you only need to supply the &lt;code&gt;:host&lt;/code&gt;:</source>
          <target state="translated">명명 된 경로를 사용하는 경우 &lt;code&gt;:host&lt;/code&gt; 만 제공하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="380f02f26ca07a28e8e80366b0d2586600dd0133" translate="yes" xml:space="preserve">
          <source>When using shortcut form, ranges and arrays are passed to your validator's initializer as &lt;code&gt;options[:in]&lt;/code&gt; while other types including regular expressions and strings are passed as &lt;code&gt;options[:with]&lt;/code&gt;.</source>
          <target state="translated">바로 가기 형식을 사용하면 범위와 배열이 유효성 검사기의 이니셜 라이저에 &lt;code&gt;options[:in]&lt;/code&gt; 으로 전달되는 반면 정규 표현식 및 문자열을 포함한 다른 유형은 &lt;code&gt;options[:with]&lt;/code&gt; 로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="0002d8ab620faf67f450aa23ebca8349745f6f90" translate="yes" xml:space="preserve">
          <source>When using strings to specify conditions, you can use any operator available from the database. While this provides the most flexibility, you can also unintentionally introduce dependencies on the underlying database. If your code is intended for general consumption, test with multiple database backends.</source>
          <target state="translated">문자열을 사용하여 조건을 지정할 때 데이터베이스에서 사용 가능한 모든 연산자를 사용할 수 있습니다. 이것이 가장 융통성을 제공하지만 의도하지 않게 기본 데이터베이스에 대한 종속성을 도입 할 수도 있습니다. 코드가 일반 소비 용인 경우 여러 데이터베이스 백엔드로 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ca09c0bc8773dca87f2fd48691931414f6b466b1" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;:json&lt;/code&gt; or &lt;code&gt;:hybrid&lt;/code&gt; serializer, you should beware that not all Ruby objects can be serialized as JSON. For example, &lt;code&gt;Date&lt;/code&gt; and &lt;code&gt;Time&lt;/code&gt; objects will be serialized as strings, and &lt;code&gt;Hash&lt;/code&gt;es will have their keys stringified.</source>
          <target state="translated">사용하는 경우 &lt;code&gt;:json&lt;/code&gt; 나 &lt;code&gt;:hybrid&lt;/code&gt; serializer를, 모든 루비 객체를 JSON으로 직렬화 할 수없는 것을 조심해야한다. 예를 들어 &lt;code&gt;Date&lt;/code&gt; 및 &lt;code&gt;Time&lt;/code&gt; 개체는 문자열로 직렬화되며 &lt;code&gt;Hash&lt;/code&gt; 에는 키가 문자열로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="20d3e495122f477e133c87b59e2aea2cc57d5348" translate="yes" xml:space="preserve">
          <source>When using the Classic Autoloader in Rails 6 application it is recommended to set concurrency level to 1 in development environment, for the web servers and background processors, due to the thread-safety concerns.</source>
          <target state="translated">Rails 6 애플리케이션의 Classic Autoloader를 사용하는 경우 스레드 안전성 문제로 인해 웹 서버 및 백그라운드 프로세서의 개발 환경에서 동시성 레벨을 1로 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="cdc6da640abf279c493c0e43610fe41c683757b7" translate="yes" xml:space="preserve">
          <source>When using the asset pipeline, paths to assets must be re-written and &lt;code&gt;sass-rails&lt;/code&gt; provides &lt;code&gt;-url&lt;/code&gt; and &lt;code&gt;-path&lt;/code&gt; helpers (hyphenated in Sass, underscored in Ruby) for the following asset classes: image, font, video, audio, JavaScript and stylesheet.</source>
          <target state="translated">자산 파이프 라인을 사용하는 경우, 자산에 대한 경로는 재 작성하고 있어야합니다 &lt;code&gt;sass-rails&lt;/code&gt; 제공 &lt;code&gt;-url&lt;/code&gt; 및 &lt;code&gt;-path&lt;/code&gt; 이미지, 글꼴, 비디오, 오디오, 자바 스크립트, 다음 자산 클래스 (루비 강조 말대꾸에 하이픈) 헬퍼 스타일 시트.</target>
        </trans-unit>
        <trans-unit id="19a526ec41e2633f2f7889f448da649f747f6ac6" translate="yes" xml:space="preserve">
          <source>When using the database key a new connection will be established every time.</source>
          <target state="translated">데이터베이스 키를 사용할 때마다 새로운 연결이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="fb3c1f35688ed259e0ceb699a164024618bbc3c5" translate="yes" xml:space="preserve">
          <source>When using the default coder, assigning &lt;code&gt;nil&lt;/code&gt; to a serialized attribute will save it to the database as &lt;code&gt;NULL&lt;/code&gt; instead of passing the &lt;code&gt;nil&lt;/code&gt; value through YAML (&lt;code&gt;&quot;--- \n...\n&quot;&lt;/code&gt;).</source>
          <target state="translated">기본 코더를 사용하는 경우 직렬화 된 속성에 &lt;code&gt;nil&lt;/code&gt; 을 지정 하면 YAML ( &lt;code&gt;&quot;--- \n...\n&quot;&lt;/code&gt; )을 통해 &lt;code&gt;nil&lt;/code&gt; 값을 전달하는 대신이를 &lt;code&gt;NULL&lt;/code&gt; 로 데이터베이스에 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="af2a017883c23b5ded137a7ee4fa376812adb77b" translate="yes" xml:space="preserve">
          <source>When using this method, you list the cache dependency as the name of the cache, like so:</source>
          <target state="translated">이 방법을 사용할 때 다음과 같이 캐시 종속성을 캐시 이름으로 나열합니다.</target>
        </trans-unit>
        <trans-unit id="cd1ed42a69d5abca994e03a762f9b39e917bd1c2" translate="yes" xml:space="preserve">
          <source>When we execute &lt;code&gt;@user.todos.create&lt;/code&gt; then the &lt;code&gt;@todo&lt;/code&gt; record will have its &lt;code&gt;user_id&lt;/code&gt; value as the &lt;code&gt;guid&lt;/code&gt; value of &lt;code&gt;@user&lt;/code&gt;.</source>
          <target state="translated">우리가 실행하면 &lt;code&gt;@user.todos.create&lt;/code&gt; 다음 &lt;code&gt;@todo&lt;/code&gt; 의 기록은있을 것이다 &lt;code&gt;user_id&lt;/code&gt; 는 AS 값 &lt;code&gt;guid&lt;/code&gt; 값 &lt;code&gt;@user&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="025a348a1d5325c407bced341d83c2791ef953d2" translate="yes" xml:space="preserve">
          <source>When we visit our root path, we should see &lt;code&gt;welcome/index.html.erb&lt;/code&gt; rendered for the view. So this assertion should pass.</source>
          <target state="translated">루트 경로를 방문하면 &lt;code&gt;welcome/index.html.erb&lt;/code&gt; 가 뷰에 렌더링됩니다. 따라서이 주장은 통과해야합니다.</target>
        </trans-unit>
        <trans-unit id="76475c3e53fb811104dd4f40813664a40e46ad21" translate="yes" xml:space="preserve">
          <source>When working around this exception, caution should be taken to avoid SQL injection vulnerabilities when passing user-provided values to query methods. Known-safe values can be passed to query methods by wrapping them in Arel.sql.</source>
          <target state="translated">이 예외를 해결할 때 사용자 제공 값을 쿼리 메소드에 전달할 때 SQL 주입 취약점을 피하기 위해주의를 기울여야합니다. 알려진 안전한 값은 Arel.sql에 래핑하여 쿼리 메서드에 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ab16691251998d9f14a5223d0184ac4c8f6ae83" translate="yes" xml:space="preserve">
          <source>When working with an &lt;code&gt;InboundEmail&lt;/code&gt;, you'll usually interact with the parsed version of the source, which is available as a &lt;code&gt;Mail&lt;/code&gt; object from &lt;code&gt;#mail&lt;/code&gt;. But you can also access the raw source directly using the &lt;code&gt;#source&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;InboundEmail&lt;/code&gt; 작업시 일반적으로 &lt;code&gt;#mail&lt;/code&gt; 에서 &lt;code&gt;Mail&lt;/code&gt; 객체 로 제공되는 구문 분석 된 소스 버전과 상호 작용 합니다 . 그러나 &lt;code&gt;#source&lt;/code&gt; 메소드를 사용하여 원시 소스에 직접 액세스 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d8e0cd5ad81b1bf0cf8abdf91ad1c3b12109168e" translate="yes" xml:space="preserve">
          <source>When writing CoffeeScript, you'll often want to do some sort of processing upon page load. With jQuery, you'd write something like this:</source>
          <target state="translated">CoffeeScript를 작성할 때 종종 페이지로드시 일종의 처리를 원할 것입니다. jQuery를 사용하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f04c2bf6f9fc7a6c84938114eb5353de0afb89b" translate="yes" xml:space="preserve">
          <source>When writing applications using other programming languages or frameworks, it may be necessary to write a lot of configuration code. This is particularly true for ORM frameworks in general. However, if you follow the conventions adopted by Rails, you'll need to write very little configuration (in some cases no configuration at all) when creating Active Record models. The idea is that if you configure your applications in the very same way most of the time then this should be the default way. Thus, explicit configuration would be needed only in those cases where you can't follow the standard convention.</source>
          <target state="translated">다른 프로그래밍 언어 나 프레임 워크를 사용하여 응용 프로그램을 작성할 때 많은 구성 코드를 작성해야 할 수도 있습니다. 이것은 일반적으로 ORM 프레임 워크에 적용됩니다. 그러나 Rails에서 채택한 규칙을 따르는 경우 Active Record 모델을 작성할 때 구성을 거의 작성하지 않아도됩니다 (일부 구성이 전혀 필요 없음). 아이디어는 대부분의 경우 동일한 방식으로 응용 프로그램을 구성하는 경우 이것이 기본 방법이어야한다는 것입니다. 따라서 표준 컨벤션을 따르지 않는 경우에만 명시 적 구성이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c81b02a41e7976013a324547ba2d04433175fd73" translate="yes" xml:space="preserve">
          <source>When writing conditional callbacks, it is possible to mix both &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; in the same callback declaration:</source>
          <target state="translated">조건부 콜백을 작성할 때 동일한 콜백 선언에서 &lt;code&gt;:if&lt;/code&gt; 와 &lt;code&gt;:unless&lt;/code&gt; 를 혼합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="728f464aff492a837e056143a56f1056162db752" translate="yes" xml:space="preserve">
          <source>When you are defining an attribute in a class that is meant to be subclassed, name collisions are a risk. That's remarkably important for libraries.</source>
          <target state="translated">서브 클래 싱 될 클래스에서 속성을 정의 할 때 이름 충돌이 위험합니다. 그것은 도서관에서 매우 중요합니다.</target>
        </trans-unit>
        <trans-unit id="3ac9d42051228151bf15569009b27b9dfbb51a9f" translate="yes" xml:space="preserve">
          <source>When you are ready, you can opt into the new behavior and remove the deprecation warning by adding the following configuration to your &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">준비가되면 &lt;code&gt;config/application.rb&lt;/code&gt; 에 다음 구성을 추가하여 새 동작을 선택하고 사용 중단 경고를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48b837488c330810fddfb63739e09169aca21ef7" translate="yes" xml:space="preserve">
          <source>When you are using the default SimpleStore shipped with the i18n library, dictionaries are stored in plain-text files on the disk. Putting translations for all parts of your application in one file per locale could be hard to manage. You can store these files in a hierarchy which makes sense to you.</source>
          <target state="translated">i18n 라이브러리와 함께 제공되는 기본 SimpleStore를 사용하는 경우 사전은 디스크의 일반 텍스트 파일로 저장됩니다. 응용 프로그램의 모든 부분에 대한 번역을 로캘 당 하나의 파일에 넣는 것은 관리하기 어려울 수 있습니다. 이러한 파일을 자신에게 적합한 계층 구조로 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13f5f6ea85c88ff7173250734145358c89b44798" translate="yes" xml:space="preserve">
          <source>When you assign an object to a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association, that object is automatically saved (in order to update the join table). If you assign multiple objects in one statement, then they are all saved.</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관에 오브젝트를 지정하면 해당 오브젝트가 조인 테이블을 업데이트하기 위해 자동으로 저장됩니다. 한 명령문에 여러 오브젝트를 지정하면 모두 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="40cc54d23b859b7d8dd47d2fdf6d8c0c515b8b38" translate="yes" xml:space="preserve">
          <source>When you assign an object to a &lt;code&gt;has_many&lt;/code&gt; association, that object is automatically saved (in order to update its foreign key). If you assign multiple objects in one statement, then they are all saved.</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 연관에 오브젝트를 지정하면 해당 오브젝트가 외래 키를 업데이트하기 위해 자동으로 저장됩니다. 한 명령문에 여러 오브젝트를 지정하면 모두 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="d5d88c9a358d929ad656545a471225303c27562d" translate="yes" xml:space="preserve">
          <source>When you assign an object to a &lt;code&gt;has_one&lt;/code&gt; association, that object is automatically saved (in order to update its foreign key). In addition, any object being replaced is also automatically saved, because its foreign key will change too.</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 연결에 객체를 할당하면 해당 객체가 외래 키를 업데이트하기 위해 자동으로 저장됩니다. 또한 교체되는 모든 객체도 외래 키도 변경되므로 자동으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="cb58c38c5d9ba326b83c93060c2f50e0c886ecb4" translate="yes" xml:space="preserve">
          <source>When you build forms to external resources sometimes you need to set an authenticity token or just render a form without it, for example when you submit data to a payment gateway number and types of fields could be limited.</source>
          <target state="translated">외부 자원에 양식을 빌드 할 때 인증 토큰을 설정하거나 양식없이 양식을 렌더링해야하는 경우가 있습니다 (예 : 지불 게이트웨이 번호에 데이터를 제출할 때 필드 유형이 제한 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="eaa6dd50de12b00ae1e2570dc7f66cede65bfe2f" translate="yes" xml:space="preserve">
          <source>When you call &lt;code&gt;form_with&lt;/code&gt;, you pass it an identifying scope for this form. In this case, it's the symbol &lt;code&gt;:article&lt;/code&gt;. This tells the &lt;code&gt;form_with&lt;/code&gt; helper what this form is for. Inside the block for this method, the &lt;code&gt;FormBuilder&lt;/code&gt; object - represented by &lt;code&gt;form&lt;/code&gt; - is used to build two labels and two text fields, one each for the title and text of an article. Finally, a call to &lt;code&gt;submit&lt;/code&gt; on the &lt;code&gt;form&lt;/code&gt; object will create a submit button for the form.</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 를 호출하면 이 양식의 식별 범위를 전달합니다. 이 경우 심볼은 &lt;code&gt;:article&lt;/code&gt; 입니다. 이것은 &lt;code&gt;form_with&lt;/code&gt; 헬퍼에게이 양식이 무엇인지 알려줍니다 . 이 메소드의 블록 내에서 &lt;code&gt;form&lt;/code&gt; 표시되는 &lt;code&gt;FormBuilder&lt;/code&gt; 오브젝트 는 기사의 제목 및 텍스트에 대해 하나씩 두 개의 레이블과 두 개의 텍스트 필드를 빌드하는 데 사용됩니다. 마지막으로 &lt;code&gt;form&lt;/code&gt; 객체 에 &lt;code&gt;submit&lt;/code&gt; 하기 위해 호출 하면 양식에 대한 제출 버튼이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="164fb4bc57ab2cae80aa356518aa4e1f45cc7e82" translate="yes" xml:space="preserve">
          <source>When you call the &lt;code&gt;mail&lt;/code&gt; method now, Action Mailer will detect the two templates (text and HTML) and automatically generate a &lt;code&gt;multipart/alternative&lt;/code&gt; email.</source>
          <target state="translated">&lt;code&gt;mail&lt;/code&gt; 메소드를 지금 호출하면 Action Mailer는 두 템플리트 (텍스트 및 HTML)를 감지하여 자동으로 &lt;code&gt;multipart/alternative&lt;/code&gt; 이메일을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="2ec8a2d934f28f30151d8d95376b3c2c89935d0f" translate="yes" xml:space="preserve">
          <source>When you create an application using the &lt;code&gt;rails&lt;/code&gt; command, you are in fact using a Rails generator. After that, you can get a list of all available generators by just invoking &lt;code&gt;rails generate&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;rails&lt;/code&gt; 명령을 사용하여 응용 프로그램을 만들면 실제로 Rails 생성기를 사용하고있는 것입니다. 그런 다음 &lt;code&gt;rails generate&lt;/code&gt; 를 호출하여 사용 가능한 모든 생성기 목록을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8122aab495d508cf61370cd81b097cc041707e34" translate="yes" xml:space="preserve">
          <source>When you declare a &lt;code&gt;belongs_to&lt;/code&gt; association, the declaring class automatically gains 6 methods related to the association:</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 연관 을 선언 하면 선언 클래스는 연관과 관련된 6 개의 메소드를 자동으로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ed854a43c1df9ccf0837945691953a839d721e32" translate="yes" xml:space="preserve">
          <source>When you declare a &lt;code&gt;belongs_to&lt;/code&gt; association, you need to create foreign keys as appropriate. For example, consider this model:</source>
          <target state="translated">&lt;code&gt;belongs_to&lt;/code&gt; 연관 을 선언 할 때 , 외래 키를 적절하게 만들어야합니다. 예를 들어 다음 모델을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="16a82322212b07c1bf8d15873a0ef6fa9784264b" translate="yes" xml:space="preserve">
          <source>When you declare a &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association, the declaring class automatically gains 17 methods related to the association:</source>
          <target state="translated">&lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관 을 선언 하면 선언 클래스는 연관과 관련된 17 개의 메소드를 자동으로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="dbe729b1b61664db952c464879352a04f4fdb8fa" translate="yes" xml:space="preserve">
          <source>When you declare a &lt;code&gt;has_many&lt;/code&gt; association, the declaring class automatically gains 17 methods related to the association:</source>
          <target state="translated">&lt;code&gt;has_many&lt;/code&gt; 연관 을 선언 하면 선언 클래스는 연관과 관련된 17 개의 메소드를 자동으로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ad523f8be1b969c520b411e526dcaa9329b70c0f" translate="yes" xml:space="preserve">
          <source>When you declare a &lt;code&gt;has_one&lt;/code&gt; association, the declaring class automatically gains 6 methods related to the association:</source>
          <target state="translated">&lt;code&gt;has_one&lt;/code&gt; 연관 을 선언 하면 선언 클래스는 연관과 관련된 6 개의 메소드를 자동으로 얻습니다.</target>
        </trans-unit>
        <trans-unit id="4c43ccb45142afa17595a75a2f9e619fc1269678" translate="yes" xml:space="preserve">
          <source>When you define an &lt;code&gt;after_rollback&lt;/code&gt; or &lt;code&gt;after_commit&lt;/code&gt; callback, you will receive a deprecation warning about this upcoming change. When you are ready, you can opt into the new behavior and remove the deprecation warning by adding following configuration to your &lt;code&gt;config/application.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;after_rollback&lt;/code&gt; 또는 &lt;code&gt;after_commit&lt;/code&gt; 콜백 을 정의하면 이 향후 변경에 대한 지원 중단 경고가 표시됩니다. 준비가되면 &lt;code&gt;config/application.rb&lt;/code&gt; 에 다음 구성을 추가하여 새 동작을 선택하고 사용 중단 경고를 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6e4683fcfa3e636acd0df81676786bea25eee21d" translate="yes" xml:space="preserve">
          <source>When you delete migration files in the &lt;code&gt;db/migrate/&lt;/code&gt; directory, any environment where &lt;code&gt;rails db:migrate&lt;/code&gt; was run when those files still existed will hold a reference to the migration timestamp specific to them inside an internal Rails database table named &lt;code&gt;schema_migrations&lt;/code&gt;. This table is used to keep track of whether migrations have been executed in a specific environment.</source>
          <target state="translated">&lt;code&gt;db/migrate/&lt;/code&gt; 디렉토리 에서 마이그레이션 파일을 삭제 하면 해당 파일이 존재할 때 &lt;code&gt;rails db:migrate&lt;/code&gt; 가 실행 된 모든 환경에는 &lt;code&gt;schema_migrations&lt;/code&gt; 라는 내부 Rails 데이터베이스 테이블 내에서 해당 파일에 고유 한 마이그레이션 타임 스탬프에 대한 참조가 유지됩니다 . 이 테이블은 특정 환경에서 마이그레이션이 실행되었는지 여부를 추적하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97488d66ab8a75a0b31ccd700b2165a6fd379ba7" translate="yes" xml:space="preserve">
          <source>When you do &lt;code&gt;Firm.create(name: &quot;37signals&quot;)&lt;/code&gt;, this record will be saved in the companies table with type = &amp;ldquo;Firm&amp;rdquo;. You can then fetch this row again using &lt;code&gt;Company.where(name:
'37signals').first&lt;/code&gt; and it will return a Firm object.</source>
          <target state="translated">당신이 할 때 &lt;code&gt;Firm.create(name: &quot;37signals&quot;)&lt;/code&gt; ,이 기록은 &quot;기업&quot;= 유형 회사 테이블에 저장됩니다. 그런 다음 &lt;code&gt;Company.where(name: '37signals').first&lt;/code&gt; 사용하여이 행을 다시 가져올 수 있으며 Firm 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7c33623daf4146c68a08be23150893f7d701c758" translate="yes" xml:space="preserve">
          <source>When you do want to actually produce the variant needed, call &lt;code&gt;processed&lt;/code&gt;. This will check that the variant has already been processed and uploaded to the service, and, if so, just return that. Otherwise it will perform the transformations, upload the variant to the service, and return itself again. Example:</source>
          <target state="translated">실제로 필요한 변형을 생성하려면을 &lt;code&gt;processed&lt;/code&gt; 합니다. 이를 통해 변형이 이미 처리되어 서비스에 업로드되었는지 확인한 경우 해당 변형을 반환합니다. 그렇지 않으면 변환을 수행하고 변형을 서비스에 업로드 한 후 다시 반환됩니다. 예:</target>
        </trans-unit>
        <trans-unit id="59e6968f10af94ead46f8157d3682dc82088d387" translate="yes" xml:space="preserve">
          <source>When you don't pass an explicit receiver, it executes the whole block in merging options context:</source>
          <target state="translated">명시 적 리시버를 전달하지 않으면 옵션 컨텍스트를 병합하여 전체 블록을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="46a664655305ddaf507a67c7d44695f78b9398ce" translate="yes" xml:space="preserve">
          <source>When you generate a new application or scaffold, an &lt;code&gt;application_system_test_case.rb&lt;/code&gt; file is created in the test directory. This is where all the configuration for your system tests should live.</source>
          <target state="translated">새 애플리케이션 또는 스캐 폴드를 생성하면 &lt;code&gt;application_system_test_case.rb&lt;/code&gt; 파일이 테스트 디렉토리에 작성됩니다. 시스템 테스트를위한 모든 구성이 적용되는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="1c4e5dd6da78cdbd5a4025ef6673c0fb25cb5835" translate="yes" xml:space="preserve">
          <source>When you generate a scaffold or a controller, Rails also generates a Cascading Style Sheet file (or SCSS file if &lt;code&gt;sass-rails&lt;/code&gt; is in the &lt;code&gt;Gemfile&lt;/code&gt;) for that controller. Additionally, when generating a scaffold, Rails generates the file &lt;code&gt;scaffolds.css&lt;/code&gt; (or &lt;code&gt;scaffolds.scss&lt;/code&gt; if &lt;code&gt;sass-rails&lt;/code&gt; is in the &lt;code&gt;Gemfile&lt;/code&gt;.)</source>
          <target state="translated">스캐 폴드 또는 컨트롤러를 생성 할 때 Rails는 해당 컨트롤러에 대한 캐스 케이 딩 스타일 시트 파일 (또는 &lt;code&gt;sass-rails&lt;/code&gt; 가 &lt;code&gt;Gemfile&lt;/code&gt; 에있는 경우 SCSS 파일)도 생성합니다 . 스캐 폴드를 생성 할 때 부가 적으로, 레일은 파일 생성 &lt;code&gt;scaffolds.css&lt;/code&gt; (또는 &lt;code&gt;scaffolds.scss&lt;/code&gt; 을 경우 &lt;code&gt;sass-rails&lt;/code&gt; 에 &lt;code&gt;Gemfile&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="869d09bef8fd7c0c3f6ce3ae85e7689e46af2ecd" translate="yes" xml:space="preserve">
          <source>When you refresh http://localhost:3000/articles/new you'll now see that the page has a title. The route, controller, action, and view are now working harmoniously! It's time to create the form for a new article.</source>
          <target state="translated">http : // localhost : 3000 / articles / new를 새로 고치면 페이지에 제목이 있음을 알 수 있습니다. 경로, 컨트롤러, 액션 및 뷰가 조화롭게 작동합니다! 새 기사를위한 양식을 만들 차례입니다.</target>
        </trans-unit>
        <trans-unit id="b81c4679ec859a8f47d58ccc2181600474890e26" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;bin/test&lt;/code&gt;, you should see the following:</source>
          <target state="translated">&lt;code&gt;bin/test&lt;/code&gt; 를 실행 하면 다음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a3b0b98159de1a0d6b61faad2fb45ce4dc35fb59" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;bin/test&lt;/code&gt;, you should see the tests all pass:</source>
          <target state="translated">&lt;code&gt;bin/test&lt;/code&gt; 를 실행 하면 테스트가 모두 통과 된 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f054c504d9e717e351147f39eae29293dda4c305" translate="yes" xml:space="preserve">
          <source>When you run &lt;code&gt;rails generate initializer core_extensions&lt;/code&gt; Rails requires these files in turn until one is found:</source>
          <target state="translated">&lt;code&gt;rails generate initializer core_extensions&lt;/code&gt; 를 실행할 때 초기화 프로그램 core_extensions 생성 Rails는 파일이 발견 될 때까지 다음 파일을 차례로 요구합니다.</target>
        </trans-unit>
        <trans-unit id="ccdabdd3d8a1a9117922bafc7cfe0dd647387889" translate="yes" xml:space="preserve">
          <source>When you set up a regular route, you supply a series of symbols that Rails maps to parts of an incoming HTTP request. For example, consider this route:</source>
          <target state="translated">일반 경로를 설정할 때 Rails가 들어오는 HTTP 요청의 일부에 매핑하는 일련의 기호를 제공합니다. 예를 들어 다음 경로를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="ebee4ff4fdde5b9e938ea1e0ab298136d546e4d5" translate="yes" xml:space="preserve">
          <source>When you specify a class option, the default value for that attribute will be a new instance of that class.</source>
          <target state="translated">클래스 옵션을 지정하면 해당 속성의 기본값이 해당 클래스의 새 인스턴스가됩니다.</target>
        </trans-unit>
        <trans-unit id="20d401d6683ead2b42845f21ffeebbd5a302bb31" translate="yes" xml:space="preserve">
          <source>When you specify an association, there is usually an association on the associated model that specifies the same relationship in reverse. For example, with the following models:</source>
          <target state="translated">연관을 지정하면 일반적으로 동일한 관계를 반대로 지정하는 연관된 모델에 연관이 있습니다. 예를 들어 다음 모델의 경우 :</target>
        </trans-unit>
        <trans-unit id="2a6ef0056c03967a40f23f720860ed8422f58716" translate="yes" xml:space="preserve">
          <source>When you start debugging your application, you will be placed in different contexts as you go through the different parts of the stack.</source>
          <target state="translated">응용 프로그램 디버깅을 시작하면 스택의 다른 부분을 거치면서 다른 컨텍스트에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="bde9d5f2d35e6559b94125d7a15f4526570fc799" translate="yes" xml:space="preserve">
          <source>When you type &lt;code&gt;http://localhost:3000&lt;/code&gt; into your browser's address bar and hit 'Go', the browser (your 'client') makes a request to the server. It parses the response, then fetches all associated assets, like JavaScript files, stylesheets and images. It then assembles the page. If you click a link, it does the same process: fetch the page, fetch the assets, put it all together, show you the results. This is called the 'request response cycle'.</source>
          <target state="translated">브라우저의 주소 표시 줄에 &lt;code&gt;http://localhost:3000&lt;/code&gt; 을 입력 하고 'Go'를 누르면 브라우저 ( 'client')가 서버에 요청합니다. 응답을 구문 분석 한 다음 JavaScript 파일, 스타일 시트 및 이미지와 같은 모든 관련 자산을 가져옵니다. 그런 다음 페이지를 조립합니다. 링크를 클릭하면 동일한 프로세스를 수행합니다. 페이지 가져 오기, 자산 가져 오기, 모두 가져 오기, 결과 표시. 이것을 '요청 응답주기'라고합니다.</target>
        </trans-unit>
        <trans-unit id="fbf2f51471775cbe8ec9ea81c68e945798f4fb87" translate="yes" xml:space="preserve">
          <source>When you upgrade from Rails 4.2 to Rails 5.0, returning &lt;code&gt;false&lt;/code&gt; in those kind of callbacks will still halt the callback chain, but you will receive a deprecation warning about this upcoming change.</source>
          <target state="translated">Rails 4.2에서 Rails 5.0으로 업그레이드 할 때 이러한 종류의 콜백에서 &lt;code&gt;false&lt;/code&gt; 를 반환 하면 여전히 콜백 체인이 중단되지만이 변경 사항에 대한 지원 중단 경고가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="ce3f49c5a9ef97c317811c0adf8b24ae2e11d9fe" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;send_file&lt;/code&gt; method inside a Rails controller, it sets the &lt;code&gt;X-Sendfile&lt;/code&gt; header. &lt;code&gt;Rack::Sendfile&lt;/code&gt; is responsible for actually sending the file.</source>
          <target state="translated">Rails 컨트롤러 내 에서 &lt;code&gt;send_file&lt;/code&gt; 메소드 를 사용하면 &lt;code&gt;X-Sendfile&lt;/code&gt; 헤더가 설정됩니다. &lt;code&gt;Rack::Sendfile&lt;/code&gt; 은 실제로 파일을 전송합니다.</target>
        </trans-unit>
        <trans-unit id="1f8acc8f165d1eaa8b523c76b77a253c16a8412f" translate="yes" xml:space="preserve">
          <source>When you want to call a method on an object only if it is not &lt;code&gt;nil&lt;/code&gt;, the simplest way to achieve it is with conditional statements, adding unnecessary clutter. The alternative is to use &lt;code&gt;try&lt;/code&gt;. &lt;code&gt;try&lt;/code&gt; is like &lt;code&gt;Object#send&lt;/code&gt; except that it returns &lt;code&gt;nil&lt;/code&gt; if sent to &lt;code&gt;nil&lt;/code&gt;.</source>
          <target state="translated">객체가 &lt;code&gt;nil&lt;/code&gt; 이 아닌 경우에만 메소드를 호출하려고 할 때 가장 간단한 방법은 조건문을 사용하여 불필요한 혼란을 추가하는 것입니다. 대안은 &lt;code&gt;try&lt;/code&gt; 를 사용 하는 것 입니다. &lt;code&gt;try&lt;/code&gt; 는 &lt;code&gt;Object#send&lt;/code&gt; 와 비슷 하지만 &lt;code&gt;nil&lt;/code&gt; 로 전송되면 &lt;code&gt;nil&lt;/code&gt; 을 반환한다는 점이 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="ebe444966be6c53b906104cbaa8d66974529520e" translate="yes" xml:space="preserve">
          <source>When you want to save it to the database, just call &lt;code&gt;save&lt;/code&gt;:</source>
          <target state="translated">데이터베이스에 &lt;code&gt;save&lt;/code&gt; 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9679effbbd348e915c57597e117e7cc6cb0b08c0" translate="yes" xml:space="preserve">
          <source>When you're not sharing any code within the format, you can simplify defining variants using the inline syntax:</source>
          <target state="translated">형식 내에서 코드를 공유하지 않는 경우 인라인 구문을 사용하여 변형 정의를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe6642b55d946062c55f84fa54981eebbbebf362" translate="yes" xml:space="preserve">
          <source>When you're using STI (single-table inheritance) with your models, you can't rely on record identification on a subclass if only their parent class is declared a resource. You will have to specify &lt;code&gt;:url&lt;/code&gt;, and &lt;code&gt;:scope&lt;/code&gt; (the model name) explicitly.</source>
          <target state="translated">모델과 함께 STI (단일 테이블 상속)를 사용하는 경우 상위 클래스 만 자원으로 선언 된 경우 서브 클래스의 레코드 식별에 의존 할 수 없습니다. 당신은 지정해야합니다 &lt;code&gt;:url&lt;/code&gt; 및 &lt;code&gt;:scope&lt;/code&gt; 명시 적으로 (모델명).</target>
        </trans-unit>
        <trans-unit id="e767b9d29c718b4529dde90bff5a9a9f50f45fe3" translate="yes" xml:space="preserve">
          <source>When you're using the flash, it's generally used as a conditional on the view. This means the content of the view depends on the flash. Which in turn means that the ETag for a response should be computed with the content of the flash in mind. This does that by including the content of the flash as a component in the ETag that's generated for a response.</source>
          <target state="translated">플래시를 사용할 때는 일반적으로 뷰에서 조건부로 사용됩니다. 이것은 뷰의 내용이 플래시에 의존한다는 것을 의미합니다. 이는 플래시의 내용을 염두에두고 응답에 대한 ETag를 계산해야 함을 의미합니다. 이는 응답을 위해 생성 된 ETag의 구성 요소로 플래시의 내용을 포함시킴으로써 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="2419ec26681d2a042ad7890cfc0ae5349da6ef3e" translate="yes" xml:space="preserve">
          <source>When your Rails application receives an incoming request for:</source>
          <target state="translated">Rails 애플리케이션이 다음에 대한 수신 요청을 수신 한 경우 :</target>
        </trans-unit>
        <trans-unit id="b845f5784fbe1b995c2a6848e69096864fa27699" translate="yes" xml:space="preserve">
          <source>When your application receives its first request to this page, Rails will write a new cache entry with a unique key. A key looks something like this:</source>
          <target state="translated">애플리케이션이이 페이지에 대한 첫 번째 요청을 받으면 Rails는 고유 키를 사용하여 새 캐시 항목을 작성합니다. 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7ae5e91279598923cb321d1228b42d97c7d86e1c" translate="yes" xml:space="preserve">
          <source>When your code is behaving in unexpected ways, you can try printing to logs or the console to diagnose the problem. Unfortunately, there are times when this sort of error tracking is not effective in finding the root cause of a problem. When you actually need to journey into your running source code, the debugger is your best companion.</source>
          <target state="translated">코드가 예기치 않은 방식으로 작동하는 경우 로그 또는 콘솔로 인쇄하여 문제를 진단 할 수 있습니다. 불행히도 이러한 종류의 오류 추적이 문제의 근본 원인을 찾는 데 효과적이지 않은 경우가 있습니다. 실제로 실행중인 소스 코드로 이동해야하는 경우 디버거가 최고의 동반자입니다.</target>
        </trans-unit>
        <trans-unit id="bda221b7f1c1720cd4c59a2f7ad9d2e8e7f15264" translate="yes" xml:space="preserve">
          <source>When your models are additionally using inheritance then the messages are looked up in the inheritance chain.</source>
          <target state="translated">모델이 상속을 추가로 사용하는 경우 메시지는 상속 체인에서 조회됩니다.</target>
        </trans-unit>
        <trans-unit id="7a353e2b115d12d337b6f6f4eb9d0776ee5f3b8a" translate="yes" xml:space="preserve">
          <source>Whenever Rails sees that the internal value of an option being generated matches this value, it will add the &lt;code&gt;selected&lt;/code&gt; attribute to that option.</source>
          <target state="translated">Rails는 생성되는 옵션의 내부 값이이 값과 일치 할 때마다 &lt;code&gt;selected&lt;/code&gt; 속성을 해당 옵션에 추가합니다 .</target>
        </trans-unit>
        <trans-unit id="2c22f0a718ae1833492a4aa8d0f2fa9791a01239" translate="yes" xml:space="preserve">
          <source>Whenever the user is allowed to pass (parts of) the URL for redirection, it is possibly vulnerable. The most obvious attack would be to redirect users to a fake web application which looks and feels exactly as the original one. This so-called phishing attack works by sending an unsuspicious link in an email to the users, injecting the link by XSS in the web application or putting the link into an external site. It is unsuspicious, because the link starts with the URL to the web application and the URL to the malicious site is hidden in the redirection parameter: &lt;a href=&quot;http://www.example.com/site/redirect?to=www.attacker.com&quot;&gt;http://www.example.com/site/redirect?to=www.attacker.com&lt;/a&gt;. Here is an example of a legacy action:</source>
          <target state="translated">사용자가 리디렉션을 위해 URL의 일부를 전달하도록 허용 될 때마다 취약 할 수 있습니다. 가장 명백한 공격은 사용자를 원래의 모양과 느낌이 같은 가짜 웹 응용 프로그램으로 리디렉션하는 것입니다. 이 피싱 공격은 사용자에게 전자 메일에 의심스러운 링크를 보내거나 웹 응용 프로그램에 XSS에 의해 링크를 삽입하거나 링크를 외부 사이트에 배치함으로써 작동합니다. 링크는 웹 응용 프로그램에 대한 URL로 시작하고 악의적 인 사이트에 대한 URL은 리디렉션 매개 변수 ( &lt;a href=&quot;http://www.example.com/site/redirect?to=www.attacker.com&quot;&gt;http://www.example.com/site/redirect?to=www.attacker.com&lt;/a&gt; )에 숨겨져 있기 때문에 의심스럽지 않습니다 . . 레거시 작업의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bc0d4cf1cf59423fe9009dbb43b8c242face6a8a" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;&amp;lt;attribute&amp;gt;&lt;/code&gt; is the attribute you asked for. The &lt;code&gt;id&lt;/code&gt; method will not raise the &lt;code&gt;ActiveRecord::MissingAttributeError&lt;/code&gt;, so just be careful when working with associations because they need the &lt;code&gt;id&lt;/code&gt; method to function properly.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;attribute&amp;gt;&lt;/code&gt; 는 요청한 속성입니다. &lt;code&gt;id&lt;/code&gt; 인상하지 않을 방법 &lt;code&gt;ActiveRecord::MissingAttributeError&lt;/code&gt; 협회로 작업 할 때 그들이 필요로하기 때문에, 그래서 그냥 조심 &lt;code&gt;id&lt;/code&gt; 제대로 작동 방법.</target>
        </trans-unit>
        <trans-unit id="dc5b1184716c4aa509982bd4144d580b5c5090f5" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@document = Document.find(params[:id])&lt;/code&gt; and &lt;code&gt;@comment = Comment.new&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;@document = Document.find(params[:id])&lt;/code&gt; 및 &lt;code&gt;@comment = Comment.new&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="630719e48d4bfb3c213e28dc49a696ef565260fd" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;@document = Document.find(params[:id])&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;@document = Document.find(params[:id])&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="09f2188d3f99b86c66b2904368987ac4755f07dc" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;param_encoder&lt;/code&gt; defines how the params should be encoded and &lt;code&gt;response_parser&lt;/code&gt; defines how the response body should be parsed through &lt;code&gt;parsed_body&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;param_encoder&lt;/code&gt; 는 params 인코딩 방법을 정의 하고 &lt;code&gt;response_parser&lt;/code&gt; 는 &lt;code&gt;parsed_body&lt;/code&gt; 를 통해 응답 본문을 구문 분석하는 방법을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="711c57f445c6ba37efbd613d810b8b02a1d2f9b2" translate="yes" xml:space="preserve">
          <source>Where different files are required by the boot sequence.</source>
          <target state="translated">부팅 순서에 따라 다른 파일이 필요한 경우</target>
        </trans-unit>
        <trans-unit id="b383219238b74df182bca03af2be60732306af0f" translate="yes" xml:space="preserve">
          <source>Where is a Given Autoload Triggered?</source>
          <target state="translated">주어진 자동로드는 어디에서 발생합니까?</target>
        </trans-unit>
        <trans-unit id="9684da1350da426516e1f9c0f4d222729aacc28a" translate="yes" xml:space="preserve">
          <source>Where possible, prefer &lt;code&gt;wrap&lt;/code&gt;.</source>
          <target state="translated">가능하면 &lt;code&gt;wrap&lt;/code&gt; 을 선호하십시오 .</target>
        </trans-unit>
        <trans-unit id="90ccad0a7f6f447de287f19be40451cd5cc7c457" translate="yes" xml:space="preserve">
          <source>Where the deprecation came from</source>
          <target state="translated">더 이상 사용되지 않는 곳</target>
        </trans-unit>
        <trans-unit id="cb51e44d283a54cce4eb3a11c3f93da75a2054cf" translate="yes" xml:space="preserve">
          <source>Whereas for an existing table, it might look like this:</source>
          <target state="translated">기존 테이블의 경우 다음과 같이 보일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a606b9ee89ce92b8b1fe80fe03dfcea2bdb46053" translate="yes" xml:space="preserve">
          <source>Whether a one-to-one or one-to-many style form builder will be yielded depends on whether the normal reader method returns a &lt;em&gt;single&lt;/em&gt; object or an &lt;em&gt;array&lt;/em&gt; of objects.</source>
          <target state="translated">일대일 또는 일대 다 스타일 양식 작성기의 생성 여부는 일반 판독기 메소드가 &lt;em&gt;단일&lt;/em&gt; 오브젝트 또는 오브젝트 &lt;em&gt;배열&lt;/em&gt; 을 리턴하는지 여부에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="5cfb0f473d6e2c39d849373d914053ed3accb240" translate="yes" xml:space="preserve">
          <source>Whether an additional &lt;code&gt;_type&lt;/code&gt; column should be added. Defaults to false.</source>
          <target state="translated">추가 &lt;code&gt;_type&lt;/code&gt; 열을 추가해야하는지 여부 기본값은 false입니다.</target>
        </trans-unit>
        <trans-unit id="377ed4dce20d3262b60586a077e6f1e9a655802a" translate="yes" xml:space="preserve">
          <source>Whether delivery of this message is performed or not</source>
          <target state="translated">이 메시지의 전달 여부</target>
        </trans-unit>
        <trans-unit id="707944ef603c96a8f983086d1b09ebbc3c97dc21" translate="yes" xml:space="preserve">
          <source>Whether or not errors should be raised if the email fails to be delivered. This only works if the external email server is configured for immediate delivery.</source>
          <target state="translated">이메일이 전달되지 않으면 오류가 발생하는지 여부입니다. 외부 전자 메일 서버가 즉시 배달되도록 구성된 경우에만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="17c8ca51793d6084fc1a82afdf18760bc96c7380" translate="yes" xml:space="preserve">
          <source>Whether the column allows nulls. Defaults to true.</source>
          <target state="translated">열이 널을 허용하는지 여부 기본값은 true입니다.</target>
        </trans-unit>
        <trans-unit id="05c3fee19a974111fa7506a08df68f29fb4ba473" translate="yes" xml:space="preserve">
          <source>Whether to automatically add a primary key column. Defaults to true. Join tables for &lt;a href=&quot;../associations/classmethods#method-i-has_and_belongs_to_many&quot;&gt;ActiveRecord::Base.has_and_belongs_to_many&lt;/a&gt; should set it to false.</source>
          <target state="translated">기본 키 열을 자동으로 추가할지 여부 기본값은 true입니다. &lt;a href=&quot;../associations/classmethods#method-i-has_and_belongs_to_many&quot;&gt;ActiveRecord :: Base.has_and_belongs_to_many에&lt;/a&gt; 대한 조인 테이블은 false로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="d492c04afc4a5e9b28b6c98b83037b0f73faa754" translate="yes" xml:space="preserve">
          <source>Whether to print a backtrace along with the warning.</source>
          <target state="translated">경고와 함께 역 추적을 인쇄할지 여부</target>
        </trans-unit>
        <trans-unit id="044267609b9e2af9e168fb11303f2e04f2afcc62" translate="yes" xml:space="preserve">
          <source>Whether to print a message (silent mode)</source>
          <target state="translated">메시지 인쇄 여부 (자동 모드)</target>
        </trans-unit>
        <trans-unit id="85cdd85cd5a0d312a5bc61b03a7d14dd40c3fd7a" translate="yes" xml:space="preserve">
          <source>Which Constants Have Been Autoloaded?</source>
          <target state="translated">어떤 상수가 자동로드 되었습니까?</target>
        </trans-unit>
        <trans-unit id="44975897bac66ee81456ff845b5c4cfaef405d16" translate="yes" xml:space="preserve">
          <source>Which allows you to quickly change your code to:</source>
          <target state="translated">코드를 빠르게 다음과 같이 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dfd42080986ebe8f42efa80ee9acd153fbfcc07e" translate="yes" xml:space="preserve">
          <source>Which are then automatically available to the view:</source>
          <target state="translated">그러면 뷰에서 자동으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70ed05e9fe979dea75cdfb0d39d9338a537b0f68" translate="yes" xml:space="preserve">
          <source>Which attributes have changed?</source>
          <target state="translated">어떤 속성이 변경 되었습니까?</target>
        </trans-unit>
        <trans-unit id="bbc3aa1484bfc575cc8022101786270eed1c28d6" translate="yes" xml:space="preserve">
          <source>Which in turn renders this view:</source>
          <target state="translated">다음은이보기를 렌더링합니다.</target>
        </trans-unit>
        <trans-unit id="3550af04ce4cdba3de5085c8ca4b0eb59bfe7c34" translate="yes" xml:space="preserve">
          <source>Which is approximately the same as writing this:</source>
          <target state="translated">이것을 쓰는 것과 거의 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ef899c65508c2169a5ab932765b510c390e0e7b5" translate="yes" xml:space="preserve">
          <source>Which is not the desired lookup. You can change it by providing the :as option:</source>
          <target state="translated">원하는 조회가 아닙니다. : as 옵션을 제공하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="773f331a034a6994f65198f476b78134a7871354" translate="yes" xml:space="preserve">
          <source>Which is what we expected. We can now tell scaffold to use our new helper generator by editing &lt;code&gt;config/application.rb&lt;/code&gt; once again:</source>
          <target state="translated">우리가 예상 한 것입니다. 이제 &lt;code&gt;config/application.rb&lt;/code&gt; 를 다시 한 번 편집하여 새 헬퍼 생성기를 사용하도록 스캐 폴드에 지시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e4f021bcea7ce82f3994d96e4eb9ee4b7be56dbc" translate="yes" xml:space="preserve">
          <source>Which means: &quot;return all authors with their count of posts, whether or not they have any posts at all&quot;</source>
          <target state="translated">&quot;모든 게시물이 있는지 여부에 관계없이 모든 작성자에게 게시물 수를 반환&quot;</target>
        </trans-unit>
        <trans-unit id="06dbe543f6a658cb185a9151eaa8103808649f61" translate="yes" xml:space="preserve">
          <source>Which one you use is really a matter of style and convention, but the rule of thumb is to use the simplest one that makes sense for the code you are writing.</source>
          <target state="translated">어떤 것을 사용하는지는 실제로 스타일과 관습의 문제이지만, 경험의 법칙은 작성하는 코드에 맞는 가장 간단한 것을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3631991286d3139c1de9a41ef4982f8e5d886ce2" translate="yes" xml:space="preserve">
          <source>Which produces:</source>
          <target state="translated">어느 생산 :</target>
        </trans-unit>
        <trans-unit id="eb8d6e059ec60b567436efa763d6ea1befe48471" translate="yes" xml:space="preserve">
          <source>Which provides you with the full standard validation stack that you know from Active Record:</source>
          <target state="translated">다음은 Active Record에서 아는 전체 표준 유효성 검사 스택을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fd3a3d542d4bc90b3f4c1841760539b30c13ec8e" translate="yes" xml:space="preserve">
          <source>Which then will result in</source>
          <target state="translated">그러면 결과</target>
        </trans-unit>
        <trans-unit id="f33472b10165ce8ea92306d6246af46d215e4ed8" translate="yes" xml:space="preserve">
          <source>Which will (if it had both a &lt;code&gt;welcome.text.erb&lt;/code&gt; and &lt;code&gt;welcome.html.erb&lt;/code&gt; template in the view directory), send a complete &lt;code&gt;multipart/mixed&lt;/code&gt; email with two parts, the first part being a &lt;code&gt;multipart/alternative&lt;/code&gt; with the text and HTML email parts inside, and the second being a &lt;code&gt;application/pdf&lt;/code&gt; with a Base64 encoded copy of the file.pdf book with the filename &lt;code&gt;free_book.pdf&lt;/code&gt;.</source>
          <target state="translated">( 보기 디렉토리에 &lt;code&gt;welcome.text.erb&lt;/code&gt; 및 &lt;code&gt;welcome.html.erb&lt;/code&gt; 템플릿 이 모두있는 경우 ) 두 부분으로 &lt;code&gt;multipart/mixed&lt;/code&gt; 완전한 다중 부분 / 혼합 전자 메일을 보내면 첫 부분 은 텍스트 및 HTML과 &lt;code&gt;multipart/alternative&lt;/code&gt; 입니다. 전자 메일 부분을 포함하고 두 번째 는 파일 이름이 &lt;code&gt;free_book.pdf&lt;/code&gt; 인 file.pdf 책의 Base64 인코딩 사본이 포함 된 &lt;code&gt;application/pdf&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="a29c23638fe9267ee418398803d58ab9385fb1c6" translate="yes" xml:space="preserve">
          <source>Which will execute:</source>
          <target state="translated">어느 것이 실행될 것인가?</target>
        </trans-unit>
        <trans-unit id="4584b968ef8035bde2a7e704853bd070950acfde" translate="yes" xml:space="preserve">
          <source>Which will render a &lt;code&gt;multipart/alternative&lt;/code&gt; email with &lt;code&gt;text/plain&lt;/code&gt; and &lt;code&gt;text/html&lt;/code&gt; parts.</source>
          <target state="translated">그러면 &lt;code&gt;text/plain&lt;/code&gt; 및 &lt;code&gt;text/html&lt;/code&gt; 부분이 포함 된 &lt;code&gt;multipart/alternative&lt;/code&gt; 전자 메일 이 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4b437e2a757f07a96f3bfea1607d0cbe8dba1b9" translate="yes" xml:space="preserve">
          <source>Which will then result in the following:</source>
          <target state="translated">그러면 다음과 같은 결과가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4456171cd4cc8074d8af762f53b44a9a7090c527" translate="yes" xml:space="preserve">
          <source>Which would produce:</source>
          <target state="translated">어떤 생산 :</target>
        </trans-unit>
        <trans-unit id="290e790bf6faaea91abdd44de8d4ac5d40ed764a" translate="yes" xml:space="preserve">
          <source>Which would provide you with:</source>
          <target state="translated">다음을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5615d4442d1bffa921b43a242c0716146447b868" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;form_with&lt;/code&gt; uses a &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; object it's possible to mix and match the stand-alone &lt;a href=&quot;formhelper&quot;&gt;FormHelper&lt;/a&gt; methods and methods from FormTagHelper:</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 는 &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; 객체를 사용 하지만 FormTagHelper 의 독립형 &lt;a href=&quot;formhelper&quot;&gt;FormHelper&lt;/a&gt; 메소드와 메소드 를 혼합하고 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d09898f0950964f8cd539cf8e470c95a79351fb1" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;indent_string&lt;/code&gt; is typically one space or tab, it may be any string.</source>
          <target state="translated">하지만 &lt;code&gt;indent_string&lt;/code&gt; 는 일반적으로 하나 개의 공백이나 탭, 그것은 임의의 문자열이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0648e73508d98ce9948771ae9ff3139d98f150d" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;send_data&lt;/code&gt; works just fine, if you are creating a RESTful application having separate actions for file downloads is usually not necessary. In REST terminology, the PDF file from the example above can be considered just another representation of the client resource. Rails provides an easy and quite sleek way of doing &quot;RESTful downloads&quot;. Here's how you can rewrite the example so that the PDF download is a part of the &lt;code&gt;show&lt;/code&gt; action, without any streaming:</source>
          <target state="translated">&lt;code&gt;send_data&lt;/code&gt; 는 정상적으로 작동 하지만 파일 다운로드에 대해 별도의 조치를 갖는 RESTful 애플리케이션을 작성하는 경우 일반적으로 필요하지 않습니다. REST 용어에서, 위 예제의 PDF 파일은 클라이언트 자원의 다른 표현으로 간주 될 수 있습니다. Rails는 &quot;RESTful downloads&quot;를 수행하는 쉽고 세련된 방법을 제공합니다. 다음은 스트리밍없이 PDF 다운로드가 &lt;code&gt;show&lt;/code&gt; 작업 의 일부가되도록 예제를 다시 작성하는 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="a6b071055ebfe5d2a68d7bcacb175353242234a9" translate="yes" xml:space="preserve">
          <source>While Rails supports numbering of initializer file names for load ordering purposes, a better technique is to place any code that need to load in a specific order within the same file. This reduces file name churn, makes dependencies more explicit, and can help surface new concepts within your application.</source>
          <target state="translated">Rails는로드 순서를 위해 이니셜 라이저 파일 이름 번호 매기기를 지원하지만 더 나은 기술은로드해야하는 코드를 동일한 파일 내에서 특정 순서로 배치하는 것입니다. 이렇게하면 파일 이름 이탈이 줄어들고 종속성이보다 명확 해지며 응용 프로그램 내에서 새로운 개념을 드러 낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79f2cfa8d6e7362df1260664b1c3801080f3405c" translate="yes" xml:space="preserve">
          <source>While Rails tries to do most of the work for you there are still some steps you'll need to do to get your application ready for multiple databases.</source>
          <target state="translated">Rails가 대부분의 작업을 수행하려고 시도하는 동안 여러 데이터베이스에 대해 애플리케이션을 준비하려면 몇 가지 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="93790c8337c44cc473c652d5bb369213f682d787" translate="yes" xml:space="preserve">
          <source>While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the &lt;code&gt;belongs_to&lt;/code&gt; association reference. Such customizations can easily be accomplished by passing options and scope blocks when you create the association. For example, this association uses two such options:</source>
          <target state="translated">Rails는 대부분의 상황에서 잘 작동하는 지능적인 기본값을 사용하지만 &lt;code&gt;belongs_to&lt;/code&gt; 연관 참조 의 동작을 사용자 정의하고 싶을 때가 있습니다 . 연관을 작성할 때 옵션 및 범위 블록을 전달하여 이러한 사용자 정의를 쉽게 수행 할 수 있습니다. 예를 들어이 연결은 두 가지 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce00d1e69418d733da1a6debee500af28c199a35" translate="yes" xml:space="preserve">
          <source>While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; association reference. Such customizations can easily be accomplished by passing options when you create the association. For example, this association uses two such options:</source>
          <target state="translated">Rails는 대부분의 상황에서 잘 작동하는 지능형 기본값을 사용하지만 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관 참조 의 동작을 사용자 정의하려는 경우가 있습니다 . 이러한 사용자 지정은 연결을 만들 때 옵션을 전달하여 쉽게 수행 할 수 있습니다. 예를 들어이 연결은 두 가지 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="55870d2f7ea017e1232e597872c82fb8b5918dd0" translate="yes" xml:space="preserve">
          <source>While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the &lt;code&gt;has_many&lt;/code&gt; association reference. Such customizations can easily be accomplished by passing options when you create the association. For example, this association uses two such options:</source>
          <target state="translated">Rails는 대부분의 상황에서 잘 작동하는 지능형 기본값을 사용하지만 &lt;code&gt;has_many&lt;/code&gt; 연관 참조 의 동작을 사용자 정의하려는 경우가 있습니다 . 이러한 사용자 지정은 연결을 만들 때 옵션을 전달하여 쉽게 수행 할 수 있습니다. 예를 들어이 연결은 두 가지 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cceb89d24af228ef365c7347311cea1b5314922b" translate="yes" xml:space="preserve">
          <source>While Rails uses intelligent defaults that will work well in most situations, there may be times when you want to customize the behavior of the &lt;code&gt;has_one&lt;/code&gt; association reference. Such customizations can easily be accomplished by passing options when you create the association. For example, this association uses two such options:</source>
          <target state="translated">Rails는 대부분의 상황에서 잘 작동하는 지능형 기본값을 사용하지만 &lt;code&gt;has_one&lt;/code&gt; 연관 참조 의 동작을 사용자 정의하려는 경우가 있습니다 . 이러한 사용자 지정은 연결을 만들 때 옵션을 전달하여 쉽게 수행 할 수 있습니다. 예를 들어이 연결은 두 가지 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f675fd2794cf3e97a6a37913e5e53468953275f6" translate="yes" xml:space="preserve">
          <source>While a CDN is described as being good for caching assets, in reality caches the entire request. This includes the body of the asset as well as any headers. The most important one being &lt;code&gt;Cache-Control&lt;/code&gt; which tells the CDN (and web browsers) how to cache contents. This means that if someone requests an asset that does not exist &lt;code&gt;/assets/i-dont-exist.png&lt;/code&gt; and your Rails application returns a 404, then your CDN will likely cache the 404 page if a valid &lt;code&gt;Cache-Control&lt;/code&gt; header is present.</source>
          <target state="translated">CDN은 자산 캐싱에 적합하다고 설명되어 있지만 실제로는 전체 요청을 캐시합니다. 여기에는 자산의 본문과 헤더가 포함됩니다. 가장 중요한 것은 CDN (및 웹 브라우저)에 내용을 캐시하는 방법을 알려주는 &lt;code&gt;Cache-Control&lt;/code&gt; 입니다. 이는 누군가가 &lt;code&gt;/assets/i-dont-exist.png&lt;/code&gt; 존재하지 않는 자산을 요청하고 Rails 애플리케이션이 404를 반환하면 유효한 &lt;code&gt;Cache-Control&lt;/code&gt; 헤더가 존재 하면 CDN이 404 페이지를 캐시 할 가능성 이 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c854cc5ae403c51c09fc46e865852b80b7105c01" translate="yes" xml:space="preserve">
          <source>While applications should stick to that interface, the actual Zeitwerk loader object can be accessed as</source>
          <target state="translated">응용 프로그램이 해당 인터페이스에 충실해야하지만 실제 Zeitwerk 로더 객체는 다음과 같이 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="224e6f8bb06b6abc629c5879b0e0841576ac3fe5" translate="yes" xml:space="preserve">
          <source>While constants are trivial in most programming languages, they are a rich topic in Ruby.</source>
          <target state="translated">상수는 대부분의 프로그래밍 언어에서 사소한 것이지만 Ruby에서는 풍부한 주제입니다.</target>
        </trans-unit>
        <trans-unit id="036d9032d77f439369551baaa0b9f2de113ffef6" translate="yes" xml:space="preserve">
          <source>While executing the given block, the recorded will be in reverting mode. All commands recorded will end up being recorded reverted and in reverse order. For example:</source>
          <target state="translated">주어진 블록을 실행하는 동안 기록 된 모드는 되돌리기 모드입니다. 기록 된 모든 명령은 역순으로 기록됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b70ce16096579aa5e925a4c792e06ceb933d95c" translate="yes" xml:space="preserve">
          <source>While if it did it the other way around the result would be different:</source>
          <target state="translated">반면에 다른 방법으로 결과를 바꾸면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f979419e932afa8e68d008b3e1ab37cd29aa2517" translate="yes" xml:space="preserve">
          <source>While in a small application, this added latency might not be a problem, it is something to think about if response time is a concern. We can demonstrate one way to handle this with a contrived example:</source>
          <target state="translated">작은 응용 프로그램에서는 이러한 추가 대기 시간이 문제가되지 않을 수 있지만 응답 시간이 중요한지 고려해야합니다. 고려 된 예제를 통해이를 처리하는 한 가지 방법을 보여줄 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1a7831a520be794fae3c9d9191a28b283a7e2ca" translate="yes" xml:space="preserve">
          <source>While it's not required you might want to add foreign key constraints to &lt;a href=&quot;#active-record-and-referential-integrity&quot;&gt;guarantee referential integrity&lt;/a&gt;.</source>
          <target state="translated">필수는 아니지만 &lt;a href=&quot;#active-record-and-referential-integrity&quot;&gt;참조 무결성&lt;/a&gt; 을 보장 하기 위해 외래 키 제약 조건을 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="afecea99fad666297024ea84b5aa5cd03c83d6cd" translate="yes" xml:space="preserve">
          <source>While it's strongly recommended that you use key-based cache expiration (see links in CacheHelper for more information), it is also possible to manually expire caches. For example:</source>
          <target state="translated">키 기반 캐시 만기를 사용하는 것이 좋습니다 (자세한 정보는 CacheHelper의 링크 참조). 또한 수동으로 캐시를 만료시킬 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6c3dc422b84d760b26a9eea8036290acf5307153" translate="yes" xml:space="preserve">
          <source>While the default routes and helpers generated by &lt;code&gt;resources :articles&lt;/code&gt; will usually serve you well, you may want to customize them in some way. Rails allows you to customize virtually any generic part of the resourceful helpers.</source>
          <target state="translated">&lt;code&gt;resources :articles&lt;/code&gt; 의해 생성되는 기본 경로와 도우미 는 일반적으로 잘 작동하지만 어떤 방식 으로든 사용자 정의 할 수 있습니다. Rails를 사용하면 리소스가 많은 헬퍼의 거의 모든 부분을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d989e21059962a67b936bb165b05550f5f5204d6" translate="yes" xml:space="preserve">
          <source>While the most common way to use filters is by creating private methods and using *_action to add them, there are two other ways to do the same thing.</source>
          <target state="translated">필터를 사용하는 가장 일반적인 방법은 개인용 메소드를 작성하고 추가하기 위해 * _action을 사용하는 것이지만, 동일한 방법을 수행하는 다른 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f90be4399bcd34e5b04c6a8dc5053f9fc06be654" translate="yes" xml:space="preserve">
          <source>While these column names are optional, they are in fact reserved by Active Record. Steer clear of reserved keywords unless you want the extra functionality. For example, &lt;code&gt;type&lt;/code&gt; is a reserved keyword used to designate a table using Single Table Inheritance (STI). If you are not using STI, try an analogous keyword like &quot;context&quot;, that may still accurately describe the data you are modeling.</source>
          <target state="translated">이러한 열 이름은 선택 사항이지만 실제로는 Active Record에 의해 예약되어 있습니다. 추가 기능이 필요하지 않으면 예약 키워드를 사용하지 마십시오. 예를 들어 &lt;code&gt;type&lt;/code&gt; 은 STI (Single Table Inheritance)를 사용하여 테이블을 지정하는 데 사용되는 예약 키워드입니다. STI를 사용하지 않는 경우 &quot;컨텍스트&quot;와 같은 유사한 키워드를 사용해보십시오. 그래도 모델링중인 데이터를 정확하게 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3829b8bb4b55dc17a4b6a7e2276f46b250ae4873" translate="yes" xml:space="preserve">
          <source>While this creates the subscription, the functionality needed to respond to received data will be described later on.</source>
          <target state="translated">구독이 생성되는 동안 수신 된 데이터에 응답하는 데 필요한 기능은 나중에 설명합니다.</target>
        </trans-unit>
        <trans-unit id="2e2f8c9ad37d011518527ddb615ec4c389722f38" translate="yes" xml:space="preserve">
          <source>While this is an increase in comfort it is far from perfect. If &lt;code&gt;Person&lt;/code&gt; has many attributes to edit then we would be repeating the name of the edited object many times. What we want to do is somehow bind a form to a model object, which is exactly what &lt;code&gt;form_with&lt;/code&gt; with &lt;code&gt;:model&lt;/code&gt; does.</source>
          <target state="translated">이것은 편안함의 증가이지만 완벽하지는 않습니다. &lt;code&gt;Person&lt;/code&gt; 에 편집 할 속성이 많은 경우 편집 된 오브젝트의 이름을 여러 번 반복합니다. 우리가하고 싶은 것은 어떻게 폼을 모델 객체에 바인딩하는 것입니다. &lt;code&gt;form_with&lt;/code&gt; with &lt;code&gt;:model&lt;/code&gt; 이하 는 것과 정확히 같습니다 .</target>
        </trans-unit>
        <trans-unit id="af9162b567e7ccd9709565023087ccc802dfc61e" translate="yes" xml:space="preserve">
          <source>While we avoid the race condition between SELECT -&amp;gt; INSERT from &lt;a href=&quot;relation#method-i-find_or_create_by&quot;&gt;find_or_create_by&lt;/a&gt;, we actually have another race condition between INSERT -&amp;gt; SELECT, which can be triggered if a DELETE between those two statements is run by another client. But for most applications, that's a significantly less likely condition to hit.</source>
          <target state="translated">&lt;a href=&quot;relation#method-i-find_or_create_by&quot;&gt;find_or_create_by&lt;/a&gt; 에서 SELECT- &amp;gt; INSERT 간의 경쟁 조건을 피하지만 실제로는 두 클라이언트 사이의 DELETE가 다른 클라이언트에 의해 실행될 경우 트리거 될 수있는 INSERT- &amp;gt; SELECT 간의 경쟁 조건이 실제로 있습니다. 그러나 대부분의 응용 프로그램의 경우 공격 가능성이 크게 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="525d589d595b7b8807dd7eb8f0c3e0db904df25d" translate="yes" xml:space="preserve">
          <source>While working with &lt;code&gt;Polygon&lt;/code&gt; you do not need to be aware of all its descendants, because anything in the table is by definition a polygon, but when working with subclasses Active Record needs to be able to enumerate the types it is looking for. Let's see an example.</source>
          <target state="translated">&lt;code&gt;Polygon&lt;/code&gt; 으로 작업하는 동안 테이블의 모든 것은 다각형으로 정의되기 때문에 모든 하위 항목을 인식 할 필요는 없지만 서브 클래스로 작업 할 때 Active Record는 찾고있는 유형을 열거 할 수 있어야합니다. 예를 보자.</target>
        </trans-unit>
        <trans-unit id="10ca2304c5436d2eedf4c9b8b44bc81f63147f5d" translate="yes" xml:space="preserve">
          <source>While you are here, change the Hickwall and Wickwall models so that they know that they are supposed to act like yaffles.</source>
          <target state="translated">여기있는 동안 Hickwall 및 Wickwall 모델을 변경하여 Yaffles처럼 작동해야한다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c6c26e8f9bd26f5186077569aa13edc15f86912" translate="yes" xml:space="preserve">
          <source>While you can setup as many rotations as you'd like it's not common to have many rotations going at any one time.</source>
          <target state="translated">원하는만큼 회전을 설정할 수 있지만 한 번에 많은 회전을하는 것은 일반적이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87e1ea61c9a1c54528d71d3a4ab31bebde1708c7" translate="yes" xml:space="preserve">
          <source>While you could obviously build these up in terms of existing Rack middleware, this list demonstrates that the default Rails middleware stack provides a lot of value, even if you're &quot;just generating JSON&quot;.</source>
          <target state="translated">기존 랙 미들웨어와 관련하여 분명히 구축 할 수 있지만이 목록은 기본 JSON 미들웨어 스택이 &quot;JSON 만 생성&quot;하더라도 많은 가치를 제공함을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="45681547956f9f5c6b82580cfc860375a7abb060" translate="yes" xml:space="preserve">
          <source>While you should usually use resourceful routing, there are still many places where the simpler routing is more appropriate. There's no need to try to shoehorn every last piece of your application into a resourceful framework if that's not a good fit.</source>
          <target state="translated">일반적으로 리소스가 많은 라우팅을 사용해야하지만 간단한 라우팅이 더 적합한 곳이 여전히 많습니다. 적합하지 않은 응용 프로그램의 마지막 부분을 모두 유용한 프레임 워크로 만들려고 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="7f1f40e553d7069f8daf618021ec20ecbe50f53f" translate="yes" xml:space="preserve">
          <source>Whilst the final section of this guide doesn't cover how to generate the most awesome template known to man, it will take you through the methods available at your disposal so that you can develop it yourself. These same methods are also available for generators.</source>
          <target state="translated">이 가이드의 마지막 섹션은 사람에게 알려진 가장 멋진 템플릿을 생성하는 방법을 다루지 않지만, 사용자가 직접 개발할 수 있도록 사용 가능한 방법을 안내합니다. 발전기에도 이와 동일한 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="701dfc11e1dae3ffe96a98471b3b0487d935a5e7" translate="yes" xml:space="preserve">
          <source>Why Associations?</source>
          <target state="translated">왜 협회인가?</target>
        </trans-unit>
        <trans-unit id="d5c58acc9f909b668f11453a210cd84b3a1c03d6" translate="yes" xml:space="preserve">
          <source>Why Use Rails for JSON APIs?</source>
          <target state="translated">JSON API에 Rails를 사용해야하는 이유</target>
        </trans-unit>
        <trans-unit id="e17582dabb3d0d2d831afcca55a5f0ed7faca185" translate="yes" xml:space="preserve">
          <source>Why Use Validations?</source>
          <target state="translated">왜 유효성 검사를 사용합니까?</target>
        </trans-unit>
        <trans-unit id="f5747762903b01a1fead86e6ac747f334d8116be" translate="yes" xml:space="preserve">
          <source>Why Write Tests for your Rails Applications?</source>
          <target state="translated">왜 Rails 애플리케이션에 대한 테스트를 작성해야합니까?</target>
        </trans-unit>
        <trans-unit id="585c960e42dfb2ab8e2ee37cf9fd2412214d3ddd" translate="yes" xml:space="preserve">
          <source>Why do you have to bother? The ability to grab and automatically assign all controller parameters to your model in one shot makes the programmer's job easier, but this convenience also allows malicious use. What if a request to the server was crafted to look like a new article form submit but also included extra fields with values that violated your application's integrity? They would be 'mass assigned' into your model and then into the database along with the good stuff - potentially breaking your application or worse.</source>
          <target state="translated">왜 귀찮게해야합니까? 한 번에 모델에 모든 컨트롤러 매개 변수를 부여하고 자동으로 할당하는 기능을 통해 프로그래머의 작업이 쉬워 지지만이 편의성으로 인해 악의적 인 사용이 가능합니다. 서버에 대한 요청이 새 기사 양식 제출처럼 보이도록 제작되었지만 응용 프로그램의 무결성을 위반하는 값을 가진 추가 필드가 포함 된 경우 어떻게됩니까? 그것들은 모델과 데이터베이스에 '대량 할당'되어 좋은 것들과 함께 데이터베이스에 저장되어 응용 프로그램을 손상 시키거나 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e73a0adf49ce87cd4425cf968e3b325d32771834" translate="yes" xml:space="preserve">
          <source>Width (pixels)</source>
          <target state="translated">폭 (픽셀)</target>
        </trans-unit>
        <trans-unit id="5105ea248c9d8b78c6ce0a0e71bc7142f5f3becc" translate="yes" xml:space="preserve">
          <source>Wildcard segments can occur anywhere in a route. For example:</source>
          <target state="translated">와일드 카드 세그먼트는 경로의 어느 곳에서나 발생할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96a2439d5c9d1d9d35a8bdb658068485b593bcb9" translate="yes" xml:space="preserve">
          <source>Will be a completely different cache from</source>
          <target state="translated">완전히 다른 캐시가됩니다</target>
        </trans-unit>
        <trans-unit id="106d426620d8566fec8d5ffe2324e041059666ee" translate="yes" xml:space="preserve">
          <source>Will load a file named &lt;code&gt;hotels/hotel.erb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;hotels/hotel.erb&lt;/code&gt; 라는 파일을로드합니다 .</target>
        </trans-unit>
        <trans-unit id="be2aec11575f04e992e11f7ecbb99b860fde279e" translate="yes" xml:space="preserve">
          <source>Will load a file named &lt;code&gt;hotels/hotel.html.erb&lt;/code&gt; in any file mime type, for example you could include this partial in a JavaScript file.</source>
          <target state="translated">&lt;code&gt;hotels/hotel.html.erb&lt;/code&gt; 라는 파일 을 모든 파일 MIME 유형으로로드합니다. 예를 들어이 부분을 ​​JavaScript 파일에 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f5d9587d86aa8f131bedd2a2c29c74b77cc5864" translate="yes" xml:space="preserve">
          <source>Will look for all templates at &amp;ldquo;app/views/notifier&amp;rdquo; with name &amp;ldquo;welcome&amp;rdquo;. If no welcome template exists, it will raise an ActionView::MissingTemplate error.</source>
          <target state="translated">이름이 &quot;welcome&quot;인 &quot;app / views / notifier&quot;에서 모든 템플릿을 찾습니다. 환영 템플릿이 없으면 ActionView :: MissingTemplate 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a511d21ddc2477b7e4db799930f4b3274becd963" translate="yes" xml:space="preserve">
          <source>Will not select a person with the id of 1 because 1 (an &lt;a href=&quot;../../integer&quot;&gt;Integer&lt;/a&gt;) is not the same as '1' (a string)</source>
          <target state="translated">1 ( &lt;a href=&quot;../../integer&quot;&gt;정수&lt;/a&gt; )이 '1'(문자열)과 같지 않기 때문에 id가 1 인 사람을 선택 하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15bf6e6c56c7f0247f98be0f4834f6d0bea4985e" translate="yes" xml:space="preserve">
          <source>Will render the HTML part using the &lt;code&gt;my_layout.html.erb&lt;/code&gt; file and the text part with the usual &lt;code&gt;user_mailer.text.erb&lt;/code&gt; file if it exists.</source>
          <target state="translated">&lt;code&gt;my_layout.html.erb&lt;/code&gt; 파일을 사용하여 HTML 부분 과 일반적인 &lt;code&gt;user_mailer.text.erb&lt;/code&gt; 파일이 있으면 텍스트 부분을 렌더링 합니다.</target>
        </trans-unit>
        <trans-unit id="87ab8fe8130e40e084dc4e1c213c1ca1bb051613" translate="yes" xml:space="preserve">
          <source>Will render:</source>
          <target state="translated">렌더링합니다 :</target>
        </trans-unit>
        <trans-unit id="dd07977c08c15c544f1e45f48b43633fe8ce4463" translate="yes" xml:space="preserve">
          <source>Will the next call to &lt;code&gt;save&lt;/code&gt; have any changes to persist?</source>
          <target state="translated">할 다음 호출 &lt;code&gt;save&lt;/code&gt; 지속 어떤 변화가?</target>
        </trans-unit>
        <trans-unit id="3783b5cf7b592b9f78fe413667bc0788566f1a31" translate="yes" xml:space="preserve">
          <source>Will this attribute change the next time we save?</source>
          <target state="translated">다음에 저장할 때이 속성이 변경됩니까?</target>
        </trans-unit>
        <trans-unit id="1601014ac633600b6b9ba81f913d6f429285c110" translate="yes" xml:space="preserve">
          <source>Will throw an error, but this will work:</source>
          <target state="translated">오류가 발생하지만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="c775cc11120c15229b8e90ea44ac8b2189edf99d" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;has_and_belongs_to_many&lt;/a&gt; and &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;&lt;code&gt;:through&lt;/code&gt;, if you want to delete the associated records themselves, you can always do something along the lines of &lt;code&gt;person.tasks.each(&amp;amp;:destroy)&lt;/code&gt;.</source>
          <target state="translated">로 &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;has_and_belongs_to_many&lt;/a&gt; 및 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many &lt;/a&gt; &lt;code&gt;:through&lt;/code&gt; 당신은 관련 기록 자체를 삭제하려면, 당신은 항상의 라인을 따라 뭔가 할 수 &lt;code&gt;person.tasks.each(&amp;amp;:destroy)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="923d698daee78d80a70a33dab6292adb7b0804be" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;:allow_nil&lt;/code&gt; the call &lt;code&gt;user.name&lt;/code&gt; returns &lt;code&gt;nil&lt;/code&gt; if the user has no profile.</source>
          <target state="translated">&lt;code&gt;:allow_nil&lt;/code&gt; 을 사용하면 &lt;code&gt;user.name&lt;/code&gt; 호출 은 사용자에게 프로파일이없는 경우 &lt;code&gt;nil&lt;/code&gt; 을 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="365f01465dda17cc57132d71e3bf1f2a1a675651" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Module#delegate_missing_to&lt;/code&gt;, the above is condensed to:</source>
          <target state="translated">함께 &lt;code&gt;Module#delegate_missing_to&lt;/code&gt; , 위가 응축되어있다 :</target>
        </trans-unit>
        <trans-unit id="7ee2f0e11ee11d6ce2ebdf11a3ca34cdd5a84b84" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;include_seconds: true&lt;/code&gt; and the difference &amp;lt; 1 minute 29 seconds:</source>
          <target state="translated">와 &lt;code&gt;include_seconds: true&lt;/code&gt; 와의 차이 &amp;lt;일분 29초 :</target>
        </trans-unit>
        <trans-unit id="4e9f6a4883af8e8d982955f5e0b36dc14883f1ff" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;through: :sections&lt;/code&gt; specified, Rails will now understand:</source>
          <target state="translated">로 &lt;code&gt;through: :sections&lt;/code&gt; 지정, 레일 이제 이해할 수있을 것이다 :</target>
        </trans-unit>
        <trans-unit id="3c3685a2391d0c5d200af26ede11572aa831707d" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;touch&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, any action which changes &lt;code&gt;updated_at&lt;/code&gt; for a game record will also change it for the associated product, thereby expiring the cache.</source>
          <target state="translated">함께 &lt;code&gt;touch&lt;/code&gt; 로 설정 &lt;code&gt;true&lt;/code&gt; , 변경 조치 &lt;code&gt;updated_at&lt;/code&gt; 게임 레코드도하여 캐시 만료, 관련 제품에 대한 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="14bb11e834530581b942be6e9e4f0f905ef611cc" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;try&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 와 함께</target>
        </trans-unit>
        <trans-unit id="2c1b48450d1e24f30f292cc318744103511f70f9" translate="yes" xml:space="preserve">
          <source>With Active Record associations, we can streamline these - and other - operations by declaratively telling Rails that there is a connection between the two models. Here's the revised code for setting up authors and books:</source>
          <target state="translated">Active Record 연결을 사용하면 두 모델 사이에 연결이 있음을 Rails에 선언적으로 선언하여 이러한 작업과 다른 작업을 간소화 할 수 있습니다. 다음은 저자와 책을 설정하기 위해 수정 된 코드입니다.</target>
        </trans-unit>
        <trans-unit id="df4d76cd89805d3bf61785ff792b3b15203da6e7" translate="yes" xml:space="preserve">
          <source>With a block which is passed with the current record to be validated:</source>
          <target state="translated">검증 할 현재 레코드와 함께 전달 된 블록으로 :</target>
        </trans-unit>
        <trans-unit id="d74a775b525e9452218cc4abddc3b9df4a1283b5" translate="yes" xml:space="preserve">
          <source>With a normal, plain-old Rails application, your URLs will generally follow the pattern of http://(host)/(controller)/(action), and a URL like http://(host)/(controller) will hit the &lt;strong&gt;index&lt;/strong&gt; action of that controller.</source>
          <target state="translated">평범한 평범한 Rails 애플리케이션을 사용하면 URL은 일반적으로 http : // (host) / (controller) / (action) 패턴을 따르며 http : // (host) / (controller)와 같은 URL은 해당 컨트롤러 의 &lt;strong&gt;인덱스&lt;/strong&gt; 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="28823126a203741bc3475e525b6819485f646608" translate="yes" xml:space="preserve">
          <source>With a regular &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; there is no distinction between the &amp;ldquo;associated records&amp;rdquo; and the &amp;ldquo;link&amp;rdquo;, so there is only one choice for what gets deleted.</source>
          <target state="translated">정기적 인 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many를&lt;/a&gt; 사용하면 &quot;관련 레코드&quot;와 &quot;링크&quot;가 구분되지 않으므로 삭제할 항목에 대한 선택은 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="7bb0fb90180dd0bfb344cee86094cf11085d82ff" translate="yes" xml:space="preserve">
          <source>With an inline module:</source>
          <target state="translated">인라인 모듈로 :</target>
        </trans-unit>
        <trans-unit id="8cfd3740d4a26a52ded3694f1a15d93ce3428a9f" translate="yes" xml:space="preserve">
          <source>With just three commands we whipped up a Rails server listening on port 3000. Go to your browser and open http://localhost:3000, you will see a basic Rails app running.</source>
          <target state="translated">3 개의 명령만으로 포트 3000에서 수신 대기하는 Rails 서버를 채웠습니다. 브라우저로 이동하여 http : // localhost : 3000을 열면 기본 Rails 앱이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="d6061e0fa2f1ac3150f97850f3468fa725d52643" translate="yes" xml:space="preserve">
          <source>With layouts, you can flip it around and have the common structure know where to insert changing content. This means that the header and footer are only mentioned in one place, like this:</source>
          <target state="translated">레이아웃을 사용하면 레이아웃을 뒤집을 수 있으며 일반적인 구조로 변경 내용을 삽입 할 위치를 알 수 있습니다. 이는 머리글과 바닥 글이 다음과 같이 한 곳에만 언급됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ad8fc9a12fc103f21678ea0a5a689c2080e82660" translate="yes" xml:space="preserve">
          <source>With most of the options to &lt;code&gt;render&lt;/code&gt;, the rendered content is displayed as part of the current layout. You'll learn more about layouts and how to use them later in this guide.</source>
          <target state="translated">&lt;code&gt;render&lt;/code&gt; 옵션의 대부분을 사용하면 렌더링 된 컨텐츠가 현재 레이아웃의 일부로 표시됩니다. 이 가이드의 뒷부분에서 레이아웃과 사용 방법에 대해 자세히 알아 봅니다.</target>
        </trans-unit>
        <trans-unit id="cdae58ca0292cbd0152512d2011e72b5d2704c4f" translate="yes" xml:space="preserve">
          <source>With no further work, &lt;code&gt;rails server&lt;/code&gt; will run our new shiny Rails app:</source>
          <target state="translated">추가 작업없이 Rails &lt;code&gt;rails server&lt;/code&gt; 는 새로운 반짝이는 Rails 앱을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="ebb4cf01fc0054b91d91820fd6991877cee5c5a6" translate="yes" xml:space="preserve">
          <source>With strong parameters, Action Controller parameters are forbidden to be used in Active Model mass assignments until they have been permitted. This means that you'll have to make a conscious decision about which attributes to permit for mass update. This is a better security practice to help prevent accidentally allowing users to update sensitive model attributes.</source>
          <target state="translated">강력한 매개 변수를 사용하면 Action Controller 매개 변수는 허용 될 때까지 Active Model 질량 지정에 사용할 수 없습니다. 즉, 대량 업데이트를 허용 할 속성에 대해 신중하게 결정해야합니다. 이는 실수로 사용자가 민감한 모델 속성을 업데이트 할 수 없도록하는보다 나은 보안 방법입니다.</target>
        </trans-unit>
        <trans-unit id="ae4abb4d46921b4b2b425be5baccd64bbecc7fbf" translate="yes" xml:space="preserve">
          <source>With such an engine, everything that is inside the &lt;code&gt;MyEngine&lt;/code&gt; module will be isolated from the application.</source>
          <target state="translated">이러한 엔진을 사용하면 &lt;code&gt;MyEngine&lt;/code&gt; 모듈 내부의 모든 것이 응용 프로그램과 격리됩니다.</target>
        </trans-unit>
        <trans-unit id="ff4e39b39bb18ef6c521d1eab5523984c5801456" translate="yes" xml:space="preserve">
          <source>With that command we told Rails that we want an &lt;code&gt;Article&lt;/code&gt; model, together with a &lt;em&gt;title&lt;/em&gt; attribute of type string, and a &lt;em&gt;text&lt;/em&gt; attribute of type text. Those attributes are automatically added to the &lt;code&gt;articles&lt;/code&gt; table in the database and mapped to the &lt;code&gt;Article&lt;/code&gt; model.</source>
          <target state="translated">이 명령을 사용하여 문자열 유형 의 &lt;em&gt;제목&lt;/em&gt; 속성 및 &lt;em&gt;텍스트&lt;/em&gt; 유형 의 &lt;em&gt;텍스트&lt;/em&gt; 속성 과 함께 &lt;code&gt;Article&lt;/code&gt; 모델 을 원한다고 Rails에 알 렸습니다 . 이러한 속성은 자동으로 추가됩니다 &lt;code&gt;articles&lt;/code&gt; 데이터베이스에 테이블과 매핑 &lt;code&gt;Article&lt;/code&gt; 모델.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="704e2bb9dccc32a9de191a9528ae22eb0b73ce7e" translate="yes" xml:space="preserve">
          <source>With that configuration you get a user's name via their profile, &lt;code&gt;user.profile.name&lt;/code&gt;, but it could be handy to still be able to access such attribute directly:</source>
          <target state="translated">이 구성을 사용하면 프로파일 &lt;code&gt;user.profile.name&lt;/code&gt; 을 통해 사용자 이름을 얻지 만 여전히 그러한 속성에 직접 액세스하는 것이 편리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="a52dcf6596891564caba4d273bdba3772d7ecec1" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;https://github.com/rails/spring&quot;&gt;Spring&lt;/a&gt; pre-loader (included with new Rails apps), you ideally keep &lt;code&gt;config.eager_load = false&lt;/code&gt; as per development. Sometimes you may end up with a hybrid configuration (&lt;code&gt;config.eager_load = true&lt;/code&gt;, &lt;code&gt;config.cache_classes = true&lt;/code&gt; AND &lt;code&gt;config.enable_dependency_loading = true&lt;/code&gt;), see &lt;a href=&quot;https://github.com/rails/spring/issues/519#issuecomment-348324369&quot;&gt;spring issue&lt;/a&gt;. However it might be simpler to keep the same configuration as development, and work out whatever it is that is causing autoloading to fail (perhaps by the results of your CI test results).</source>
          <target state="translated">으로 &lt;a href=&quot;https://github.com/rails/spring&quot;&gt;봄&lt;/a&gt; (새 레일 애플 리케이션에 포함) 사전 로더, 당신은 이상적으로 유지 &lt;code&gt;config.eager_load = false&lt;/code&gt; 개발에 따라. 때로는 하이브리드 구성 ( &lt;code&gt;config.eager_load = true&lt;/code&gt; , &lt;code&gt;config.cache_classes = true&lt;/code&gt; AND &lt;code&gt;config.enable_dependency_loading = true&lt;/code&gt; )으로 끝날 수 있습니다 ( &lt;a href=&quot;https://github.com/rails/spring/issues/519#issuecomment-348324369&quot;&gt;봄 문제&lt;/a&gt; 참조) . 그러나 개발과 동일한 구성을 유지하고 자동로드 실패 (CI 테스트 결과의 결과)를 유발하는 원인을 해결하는 것이 더 간단 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5914b2485302c73118389946cece6c3fc3468659" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;:as&lt;/code&gt; option we can specify a different name for said local variable. For example, if we wanted it to be &lt;code&gt;user&lt;/code&gt; instead of &lt;code&gt;account&lt;/code&gt; we'd do:</source>
          <target state="translated">&lt;code&gt;:as&lt;/code&gt; 옵션을 사용하면 해당 로컬 변수에 다른 이름을 지정할 수 있습니다. 예를 들어 &lt;code&gt;account&lt;/code&gt; 대신 &lt;code&gt;user&lt;/code&gt; 가되기를 원한다면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="d21d9ba3a34d1b240fa8781560edfaa4e29fc6a1" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;app&lt;/code&gt; method you can access named route helpers, as well as do requests.</source>
          <target state="translated">&lt;code&gt;app&lt;/code&gt; 메소드를 사용하면 이름 지정된 경로 도우미에 액세스하고 요청을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea82bf7769cdfa07eedb989bcea27fe7e89080bb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;as&lt;/code&gt; option we can specify a different name for the said local variable. For example, if we wanted it to be &lt;code&gt;item&lt;/code&gt; instead of &lt;code&gt;product&lt;/code&gt; we would do:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 옵션을 사용하면 해당 로컬 변수에 다른 이름을 지정할 수 있습니다. 예를 들어, &lt;code&gt;product&lt;/code&gt; 대신 &lt;code&gt;item&lt;/code&gt; 이 되려면 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="1a3a7ab03d7454ff02fb5e76d8ba1cc1b05875fb" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;default_options&lt;/code&gt; set to this:</source>
          <target state="translated">&lt;code&gt;default_options&lt;/code&gt; 를 다음 과 같이 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="a02b074ceadbf67fcac505cbc260df3198bbc054" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;helper&lt;/code&gt; method it is possible to access Rails and your application's helpers.</source>
          <target state="translated">&lt;code&gt;helper&lt;/code&gt; 메소드를 사용하면 Rails와 애플리케이션의 헬퍼에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf0fa2c264a67dd7674e1c11a20e219a9e9ec77c" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;human_attribute_name&lt;/code&gt; method, you can transform attribute names into a more human-readable format. The human-readable format is defined in your locale file(s).</source>
          <target state="translated">으로 &lt;code&gt;human_attribute_name&lt;/code&gt; 의 방법, 당신은 더 많은 사람이 읽을 수있는 형식으로 속성 이름을 변환 할 수 있습니다. 사람이 읽을 수있는 형식은 로캘 파일에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fc0248a613e3fac57f5f4e1457c0e50d2c32619" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;new&lt;/code&gt; method defined in &lt;code&gt;ArticlesController&lt;/code&gt;, if you refresh http://localhost:3000/articles/new you'll see another error:</source>
          <target state="translated">&lt;code&gt;ArticlesController&lt;/code&gt; 에 정의 된 &lt;code&gt;new&lt;/code&gt; 메소드를 사용하여 http : // localhost : 3000 / articles / new를 새로 고치면 다른 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="99f6a59c47c1f87b127ead7a16aabfc85069e8ec" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;scope&lt;/code&gt; option, you can define a custom scope for Rails to look up the translation.</source>
          <target state="translated">&lt;code&gt;scope&lt;/code&gt; 옵션을 사용하면 Rails가 번역을 조회 할 사용자 정의 범위를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b0881eb4c62b30f963e362db4eff5cff20f1bf" translate="yes" xml:space="preserve">
          <source>With the &lt;code&gt;server&lt;/code&gt; command, Rails will further run the following code:</source>
          <target state="translated">으로 &lt;code&gt;server&lt;/code&gt; 명령, 레일 추가로 다음 코드를 실행합니다 :</target>
        </trans-unit>
        <trans-unit id="4c45ce69c72a6e867e0a593e006c34b5339530de" translate="yes" xml:space="preserve">
          <source>With the Asset Pipeline the :cache and :concat options aren't used anymore, delete these options from your views.</source>
          <target state="translated">Asset Pipeline을 사용하면 : cache 및 : concat 옵션이 더 이상 사용되지 않으므로 뷰에서 이러한 옵션을 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="8593b03dcee2c84e7bde22901f7640aad1cba2df" translate="yes" xml:space="preserve">
          <source>With the Chain backend, you could use the Active Record backend and fall back to the (default) Simple backend:</source>
          <target state="translated">체인 백엔드를 사용하면 활성 레코드 백엔드를 사용하여 (기본) 단순 백엔드로 폴백 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c76771f6e6ce039c23f672dfaea7d481f76e253" translate="yes" xml:space="preserve">
          <source>With the above example, the bang and predicate methods along with the associated scopes are now prefixed and/or suffixed accordingly:</source>
          <target state="translated">위의 예에서 관련 범위와 함께 bang 및 predicate 메소드에 접두사 및 / 또는 접미사가 붙습니다.</target>
        </trans-unit>
        <trans-unit id="8cc0edd1be0ce12780e04d7868d363a44cdc3527" translate="yes" xml:space="preserve">
          <source>With the advent of client-side frameworks, more developers are using Rails to build a back-end that is shared between their web application and other native applications.</source>
          <target state="translated">클라이언트 측 프레임 워크의 출현으로 더 많은 개발자들이 Rails를 사용하여 웹 애플리케이션과 다른 기본 애플리케이션간에 공유되는 백엔드를 구축하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="b04e41a47fa5954745441a7a1a418081b22e7934" translate="yes" xml:space="preserve">
          <source>With the asset pipeline</source>
          <target state="translated">자산 파이프 라인</target>
        </trans-unit>
        <trans-unit id="7104c52d914cc37216c41f270cf166d50e723b74" translate="yes" xml:space="preserve">
          <source>With the class method &lt;code&gt;File.atomic_write&lt;/code&gt; you can write to a file in a way that will prevent any reader from seeing half-written content.</source>
          <target state="translated">&lt;code&gt;File.atomic_write&lt;/code&gt; 클래스 메소드를 사용하면 독자가 반으로 쓴 내용을 볼 수 없도록 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1aebad76c66b784de886a599843d99d4a7e7815" translate="yes" xml:space="preserve">
          <source>With the code in this form, there will likely be a problem if the &lt;code&gt;@book&lt;/code&gt; variable is &lt;code&gt;nil&lt;/code&gt;. Remember, a &lt;code&gt;render :action&lt;/code&gt; doesn't run any code in the target action, so nothing will set up the &lt;code&gt;@books&lt;/code&gt; variable that the &lt;code&gt;index&lt;/code&gt; view will probably require. One way to fix this is to redirect instead of rendering:</source>
          <target state="translated">이 형식의 코드를 사용하면 &lt;code&gt;@book&lt;/code&gt; 변수가 &lt;code&gt;nil&lt;/code&gt; 인 경우 문제가 발생할 수 있습니다 . A, 기억 &lt;code&gt;render :action&lt;/code&gt; 아무것도 설정하지 않게, 목표 행동의 코드를 실행하지 않습니다 &lt;code&gt;@books&lt;/code&gt; 의 것을 변수 &lt;code&gt;index&lt;/code&gt; 보기는 아마 필요합니다. 이 문제를 해결하는 한 가지 방법은 렌더링 대신 리디렉션하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3ecd2bd8a99cc40d5d99d0c4c42297e9c0b39ccd" translate="yes" xml:space="preserve">
          <source>With the default configuration for Rails 6.0, assigning to a collection of attachments replaces existing files instead of appending to them. This matches Active Record behavior when assigning to a collection association:</source>
          <target state="translated">Rails 6.0의 기본 구성에서 첨부 파일 모음에 할당하면 기존 파일이 추가되지 않고 대체됩니다. 이는 콜렉션 연관에 지정할 때 활성 레코드 작동과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e79f2da8d571f971fa1f3fcebbb46af49b9670a4" translate="yes" xml:space="preserve">
          <source>With the form and its associated route defined, you will be able to fill in the form and then click the submit button to begin the process of creating a new article, so go ahead and do that. When you submit the form, you should see a familiar error:</source>
          <target state="translated">양식과 관련 경로가 정의되면 양식을 작성한 다음 제출 단추를 클릭하여 새 기사 작성 프로세스를 시작할 수 있으므로 계속 진행하십시오. 양식을 제출하면 익숙한 오류가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2404776220fce42b52f446e20ae883e04e47c3d3" translate="yes" xml:space="preserve">
          <source>With the model in hand, you can turn your attention to creating a matching controller. Again, we'll use the same generator we used before:</source>
          <target state="translated">모델을 준비하면 일치하는 컨트롤러를 만드는 데 관심을 돌릴 수 있습니다. 다시, 우리는 전에 사용했던 것과 같은 발전기를 사용할 것입니다 :</target>
        </trans-unit>
        <trans-unit id="45dc33f5a322ca9495b1bbd4c1c32a69aa4ebb1b" translate="yes" xml:space="preserve">
          <source>With the validation now in place, when you call &lt;code&gt;@article.save&lt;/code&gt; on an invalid article, it will return &lt;code&gt;false&lt;/code&gt;. If you open &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; again, you'll notice that we don't check the result of calling &lt;code&gt;@article.save&lt;/code&gt; inside the &lt;code&gt;create&lt;/code&gt; action. If &lt;code&gt;@article.save&lt;/code&gt; fails in this situation, we need to show the form back to the user. To do this, change the &lt;code&gt;new&lt;/code&gt; and &lt;code&gt;create&lt;/code&gt; actions inside &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; to these:</source>
          <target state="translated">유효성 검사가 완료되면 잘못된 기사에서 &lt;code&gt;@article.save&lt;/code&gt; 를 호출하면 &lt;code&gt;false&lt;/code&gt; 가 반환 됩니다. &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; 를 다시 열면 &lt;code&gt;create&lt;/code&gt; 액션 내에서 &lt;code&gt;@article.save&lt;/code&gt; 를 호출 한 결과를 확인하지 않습니다 . 경우 &lt;code&gt;@article.save&lt;/code&gt; 이 상황에서 실패, 우리는 사용자에게 양식 등을 표시해야합니다. 이렇게하려면 &lt;code&gt;app/controllers/articles_controller.rb&lt;/code&gt; 에서 &lt;code&gt;new&lt;/code&gt; 변경하고 다음 과 같이 작업을 &lt;code&gt;create&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71fb1f76fb9fa209e3325ea1dd78ec807ece3983" translate="yes" xml:space="preserve">
          <source>With these declarations, asking for the value of &lt;code&gt;@author.books.size&lt;/code&gt; requires making a call to the database to perform a &lt;code&gt;COUNT(*)&lt;/code&gt; query. To avoid this call, you can add a counter cache to the &lt;em&gt;belonging&lt;/em&gt; model:</source>
          <target state="translated">이러한 선언으로 &lt;code&gt;@author.books.size&lt;/code&gt; 값을 요청 하려면 &lt;code&gt;COUNT(*)&lt;/code&gt; 쿼리 를 수행하기 위해 데이터베이스를 호출해야합니다 . 이 호출을 피하기 위해 &lt;em&gt;소속&lt;/em&gt; 모델에 카운터 캐시를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88a0b5dc5714af395cfe75e6e04697d43baa0c16" translate="yes" xml:space="preserve">
          <source>With this approach you will not get a &lt;code&gt;Routing Error&lt;/code&gt; when accessing your resources such as &lt;code&gt;http://localhost:3001/books&lt;/code&gt; without a locale. This is useful for when you want to use the default locale when one is not specified.</source>
          <target state="translated">이 방법을 사용하면 로케일없이 &lt;code&gt;http://localhost:3001/books&lt;/code&gt; 와 같은 자원에 액세스 할 때 &lt;code&gt;Routing Error&lt;/code&gt; 발생 하지 않습니다 . 기본 로캘을 지정하지 않은 경우 사용하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7ed8b7234e673e3344b8cfbdc09a5c72e9cdf871" translate="yes" xml:space="preserve">
          <source>With this cache store, multiple server processes on the same host can share a cache. This cache store is appropriate for low to medium traffic sites that are served off one or two hosts. Server processes running on different hosts could share a cache by using a shared file system, but that setup is not recommended.</source>
          <target state="translated">이 캐시 저장소를 사용하면 동일한 호스트의 여러 서버 프로세스가 캐시를 공유 할 수 있습니다. 이 캐시 저장소는 하나 또는 두 개의 호스트에서 제공되는 트래픽이 적은 중간 규모 사이트에 적합합니다. 다른 호스트에서 실행되는 서버 프로세스는 공유 파일 시스템을 사용하여 캐시를 공유 할 수 있지만 해당 설정은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="55ed787ba517af84e729abd0a8e5ba84740b0645" translate="yes" xml:space="preserve">
          <source>With this change, creating a new book for a particular author is easier:</source>
          <target state="translated">이 변경으로 특정 저자를위한 새 책을 만드는 것이 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="752c40992932234254549520abfb4735580f354e" translate="yes" xml:space="preserve">
          <source>With this change, you can access an instance of the &lt;code&gt;@products&lt;/code&gt; collection as the &lt;code&gt;item&lt;/code&gt; local variable within the partial.</source>
          <target state="translated">이 변경으로 &lt;code&gt;@products&lt;/code&gt; 컬렉션 의 인스턴스에 부분 내 &lt;code&gt;item&lt;/code&gt; 로컬 변수 로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fdcba96a5de6785f05d39a5732d409c3a3eafe57" translate="yes" xml:space="preserve">
          <source>With this change, you should finally be able to create new articles. Visit http://localhost:3000/articles/new and give it a try!</source>
          <target state="translated">이 변경으로 마침내 새 기사를 작성할 수 있습니다. http : // localhost : 3000 / articles / new를 방문하여 사용해보십시오!</target>
        </trans-unit>
        <trans-unit id="7047fc442cc7b1b30d3b2c365d2f6b3aa9f51eb4" translate="yes" xml:space="preserve">
          <source>With this code, the browser will make a fresh request for the index page, the code in the &lt;code&gt;index&lt;/code&gt; method will run, and all will be well.</source>
          <target state="translated">이 코드를 사용하면 브라우저가 색인 페이지를 새로 요청하고 &lt;code&gt;index&lt;/code&gt; 메소드 의 코드 가 실행되며 모든 것이 잘됩니다.</target>
        </trans-unit>
        <trans-unit id="0d4c9d7ae1f73420016d1bc31d16955b28c3793a" translate="yes" xml:space="preserve">
          <source>With this declaration, Rails will keep the cache value up to date, and then return that value in response to the &lt;code&gt;size&lt;/code&gt; method.</source>
          <target state="translated">이 선언으로 Rails는 캐시 값을 최신 상태로 유지 한 다음 &lt;code&gt;size&lt;/code&gt; 메소드 에 대한 응답으로 해당 값을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0b2ed02c4d64db6cf19ab13f87db358a64b99ba" translate="yes" xml:space="preserve">
          <source>With this declaration, all of the views in the entire application will use &lt;code&gt;app/views/layouts/main.html.erb&lt;/code&gt; for their layout.</source>
          <target state="translated">이 선언으로 전체 응용 프로그램의 모든 뷰는 &lt;code&gt;app/views/layouts/main.html.erb&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="fc393ae12058c0813c491d21314a7d56967db2a2" translate="yes" xml:space="preserve">
          <source>With this declaration, all of the views rendered by the &lt;code&gt;ProductsController&lt;/code&gt; will use &lt;code&gt;app/views/layouts/inventory.html.erb&lt;/code&gt; as their layout.</source>
          <target state="translated">이 선언으로 &lt;code&gt;ProductsController&lt;/code&gt; 에 의해 렌더링 된 모든 뷰 는 &lt;code&gt;app/views/layouts/inventory.html.erb&lt;/code&gt; 를 레이아웃으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a710048f9d10a6cbec587e5457d4681878042f13" translate="yes" xml:space="preserve">
          <source>With this declaration, the &lt;code&gt;product&lt;/code&gt; layout would be used for everything but the &lt;code&gt;rss&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; methods.</source>
          <target state="translated">이 선언으로 &lt;code&gt;product&lt;/code&gt; 레이아웃은 &lt;code&gt;rss&lt;/code&gt; 및 &lt;code&gt;index&lt;/code&gt; 메소드 를 제외한 모든 것에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e296a2071dcd49c3299304fac5613063fc553fc5" translate="yes" xml:space="preserve">
          <source>With this in place, you can create namespaced controllers that inherit from &lt;code&gt;AdminsController&lt;/code&gt;. The filter will thus be run for all actions in those controllers, protecting them with HTTP basic authentication.</source>
          <target state="translated">이를 통해 &lt;code&gt;AdminsController&lt;/code&gt; 에서 상속되는 네임 스페이스 컨트롤러를 만들 수 있습니다 . 따라서 해당 컨트롤러의 모든 작업에 대해 필터가 실행되어 HTTP 기본 인증으로 보호합니다.</target>
        </trans-unit>
        <trans-unit id="aaf4c5e752b4b9989114d84ef7e41fc3a2de19b5" translate="yes" xml:space="preserve">
          <source>With this set of variants Rails will look for the following set of templates and use the first that exists.</source>
          <target state="translated">이 변형 세트를 사용하여 Rails는 다음 템플릿 세트를 찾아서 가장 먼저 존재하는 템플릿을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c1b823c3416974f021a7aa71e0174be5add44932" translate="yes" xml:space="preserve">
          <source>With this setup, you can retrieve &lt;code&gt;@employee.subordinates&lt;/code&gt; and &lt;code&gt;@employee.manager&lt;/code&gt;.</source>
          <target state="translated">이 설정을 사용하면 &lt;code&gt;@employee.subordinates&lt;/code&gt; 및 &lt;code&gt;@employee.manager&lt;/code&gt; 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e341d5d07cad4b1c8a97491f82d5a23b0c9c304d" translate="yes" xml:space="preserve">
          <source>With web page defacement an attacker can do a lot of things, for example, present false information or lure the victim on the attackers web site to steal the cookie, login credentials, or other sensitive data. The most popular way is to include code from external sources by iframes:</source>
          <target state="translated">웹 페이지가 손상되면 공격자는 예를 들어 허위 정보를 제공하거나 공격자 웹 사이트에서 피해자를 유혹하여 쿠키, 로그인 자격 증명 또는 기타 중요한 데이터를 훔칠 수 있습니다. 가장 널리 사용되는 방법은 iframe별로 외부 소스의 코드를 포함시키는 것입니다.</target>
        </trans-unit>
        <trans-unit id="899714a8d6f08076d9655040a4f75e83ab04e73e" translate="yes" xml:space="preserve">
          <source>Within &lt;code&gt;lib/blorgh/engine.rb&lt;/code&gt; is the base class for the engine:</source>
          <target state="translated">내 &lt;code&gt;lib/blorgh/engine.rb&lt;/code&gt; 엔진의 기본 클래스입니다 :</target>
        </trans-unit>
        <trans-unit id="e7927191a9c86f6f47c20a970363d08745671702" translate="yes" xml:space="preserve">
          <source>Within an ERB template, Ruby code can be included using both &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; tags. The &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; tags are used to execute Ruby code that does not return anything, such as conditions, loops, or blocks, and the &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; tags are used when you want output.</source>
          <target state="translated">ERB 템플릿 내에서 &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 태그 를 모두 사용하여 Ruby 코드를 포함 할 수 있습니다 . &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; 태그는 이러한 조건, 루프, 또는 블록으로, 아무것도 반환하지 않습니다 루비 코드를 실행하는 데 사용되며, &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 당신은 출력을 할 때 태그가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fcd0c36b686f151fcc9568da3ed027519222a666" translate="yes" xml:space="preserve">
          <source>Within an autoload path, file names must match the constants they define as documented &lt;a href=&quot;https://github.com/fxn/zeitwerk#file-structure&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">자동로드 경로 내에서 파일 이름은 &lt;a href=&quot;https://github.com/fxn/zeitwerk#file-structure&quot;&gt;여기에&lt;/a&gt; 설명 된대로 정의한 상수와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ac08c4d562b6eaae10bb9de92923362d9f42b476" translate="yes" xml:space="preserve">
          <source>Within an engine, there may come a time where you wish to use things such as initializers, internationalization, or other configuration options. The great news is that these things are entirely possible, because a Rails engine shares much the same functionality as a Rails application. In fact, a Rails application's functionality is actually a superset of what is provided by engines!</source>
          <target state="translated">엔진 내에서 초기화, 국제화 또는 기타 구성 옵션과 같은 것을 사용하려는 시간이 올 수 있습니다. 좋은 소식은 Rails 엔진이 Rails 애플리케이션과 거의 동일한 기능을 공유하기 때문에 이러한 모든 것이 가능하다는 것입니다. 실제로 Rails 애플리케이션의 기능은 실제로 엔진이 제공하는 기능의 상위 집합입니다!</target>
        </trans-unit>
        <trans-unit id="28690244620e2395540df3d6e2805350ccbe25a2" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;app/assets&lt;/code&gt; directory, there are the &lt;code&gt;images&lt;/code&gt;, &lt;code&gt;javascripts&lt;/code&gt; and &lt;code&gt;stylesheets&lt;/code&gt; directories which, again, you should be familiar with due to their similarity to an application. One difference here, however, is that each directory contains a sub-directory with the engine name. Because this engine is going to be namespaced, its assets should be too.</source>
          <target state="translated">내 &lt;code&gt;app/assets&lt;/code&gt; 디렉토리의가있는 &lt;code&gt;images&lt;/code&gt; , &lt;code&gt;javascripts&lt;/code&gt; 와 &lt;code&gt;stylesheets&lt;/code&gt; 인해 응용 프로그램에 자신의 유사성에 다시, 당신이 잘 알고 있어야 디렉토리. 그러나 여기서 한 가지 차이점은 각 디렉토리에 엔진 이름이있는 서브 디렉토리가 있다는 것입니다. 이 엔진은 네임 스페이스가 될 것이기 때문에 자산도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="cdc776e72d88011129a378e5e481f20e38194c73" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;app/controllers&lt;/code&gt; directory there is a &lt;code&gt;blorgh&lt;/code&gt; directory that contains a file called &lt;code&gt;application_controller.rb&lt;/code&gt;. This file will provide any common functionality for the controllers of the engine. The &lt;code&gt;blorgh&lt;/code&gt; directory is where the other controllers for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named controllers within other engines or even within the application.</source>
          <target state="translated">내 &lt;code&gt;app/controllers&lt;/code&gt; 디렉토리이 &lt;code&gt;blorgh&lt;/code&gt; 라는 파일이 들어 디렉토리 &lt;code&gt;application_controller.rb&lt;/code&gt; 을 . 이 파일은 엔진 컨트롤러에 대한 공통 기능을 제공합니다. &lt;code&gt;blorgh&lt;/code&gt; 엔진에 대한 다른 컨트롤러가 갈 곳 디렉토리입니다. 이 네임 스페이스가있는 디렉토리에 배치하면 다른 엔진 또는 응용 프로그램 내에서 동일한 이름의 컨트롤러와 충돌하는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8024b0b139f594c07317e9d46dbe87ca01c300ad" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;app/helpers&lt;/code&gt; directory there is a &lt;code&gt;blorgh&lt;/code&gt; directory that contains a file called &lt;code&gt;application_helper.rb&lt;/code&gt;. This file will provide any common functionality for the helpers of the engine. The &lt;code&gt;blorgh&lt;/code&gt; directory is where the other helpers for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named route helpers within other engines or even within the application.</source>
          <target state="translated">내 &lt;code&gt;app/helpers&lt;/code&gt; 디렉토리이 &lt;code&gt;blorgh&lt;/code&gt; 라는 파일이 들어 디렉토리 &lt;code&gt;application_helper.rb&lt;/code&gt; 을 . 이 파일은 엔진 헬퍼를위한 공통 기능을 제공합니다. &lt;code&gt;blorgh&lt;/code&gt; 엔진에 대한 다른 도우미가 갈 곳 디렉토리입니다. 이 네임 스페이스 디렉토리에 배치하면 다른 엔진 또는 애플리케이션 내에서 동일한 이름의 라우트 헬퍼와 충돌하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8a7e9f92834d114f6a93d39f859d586ead44d86" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;app/jobs&lt;/code&gt; directory there is a &lt;code&gt;blorgh&lt;/code&gt; directory that contains a file called &lt;code&gt;application_job.rb&lt;/code&gt;. This file will provide any common functionality for the jobs of the engine. The &lt;code&gt;blorgh&lt;/code&gt; directory is where the other jobs for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named jobs within other engines or even within the application.</source>
          <target state="translated">내 &lt;code&gt;app/jobs&lt;/code&gt; 디렉토리이 &lt;code&gt;blorgh&lt;/code&gt; 라는 파일이 들어 디렉토리 &lt;code&gt;application_job.rb&lt;/code&gt; 을 . 이 파일은 엔진 작업에 대한 공통 기능을 제공합니다. &lt;code&gt;blorgh&lt;/code&gt; 엔진에 대한 다른 작업이 갈 곳 디렉토리입니다. 이 네임 스페이스가있는 디렉토리에 배치하면 다른 엔진 또는 응용 프로그램 내에서 동일한 이름의 작업과 충돌하는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="540ac329ed1554e8636c996d3e85e1f831cb95a9" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;app/mailers&lt;/code&gt; directory there is a &lt;code&gt;blorgh&lt;/code&gt; directory that contains a file called &lt;code&gt;application_mailer.rb&lt;/code&gt;. This file will provide any common functionality for the mailers of the engine. The &lt;code&gt;blorgh&lt;/code&gt; directory is where the other mailers for the engine will go. By placing them within this namespaced directory, you prevent them from possibly clashing with identically-named mailers within other engines or even within the application.</source>
          <target state="translated">내 &lt;code&gt;app/mailers&lt;/code&gt; 디렉토리이 &lt;code&gt;blorgh&lt;/code&gt; 라는 파일이 들어 디렉토리 &lt;code&gt;application_mailer.rb&lt;/code&gt; 을 . 이 파일은 엔진 메일러에게 공통적 인 기능을 제공합니다. &lt;code&gt;blorgh&lt;/code&gt; 엔진에 대한 다른 우편물이 갈 곳 디렉토리입니다. 이 네임 스페이스 디렉토리에 배치하면 다른 엔진 또는 애플리케이션 내에서 동일한 이름의 메일러와 충돌하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="101e6dd13d99d77eea5e41319ee8c9964e420f4f" translate="yes" xml:space="preserve">
          <source>Within the &lt;code&gt;customer&lt;/code&gt; partial, the &lt;code&gt;customer&lt;/code&gt; variable will refer to &lt;code&gt;@new_customer&lt;/code&gt; from the parent view.</source>
          <target state="translated">내에서 &lt;code&gt;customer&lt;/code&gt; 부분은 &lt;code&gt;customer&lt;/code&gt; 변수를 참조합니다 &lt;code&gt;@new_customer&lt;/code&gt; 부모 뷰에서.</target>
        </trans-unit>
        <trans-unit id="c25a818286e5fb24aa89232efa2698d3358957c7" translate="yes" xml:space="preserve">
          <source>Within the Ruby on Rails framework, there are a number of hooks provided for common events. These are detailed below.</source>
          <target state="translated">Ruby on Rails 프레임 워크에는 일반적인 이벤트를 위해 여러 가지 후크가 제공됩니다. 이것들은 아래에 자세히 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="09a3c042711d0b97ad6d99c9ef5e8c2ddae9dac4" translate="yes" xml:space="preserve">
          <source>Within the block of member routes, each route name specifies the HTTP verb that will be recognized. You can use &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;post&lt;/code&gt;, or &lt;code&gt;delete&lt;/code&gt; here . If you don't have multiple &lt;code&gt;member&lt;/code&gt; routes, you can also pass &lt;code&gt;:on&lt;/code&gt; to a route, eliminating the block:</source>
          <target state="translated">구성원 경로 블록 내에서 각 경로 이름은 인식 될 HTTP 동사를 지정합니다. 여기서 &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;post&lt;/code&gt; 또는 &lt;code&gt;delete&lt;/code&gt; 를 사용할 수 있습니다. &lt;code&gt;member&lt;/code&gt; 라우트 가 여러 개인 경우 &lt;code&gt;:on&lt;/code&gt; 을 경로로 전달 하여 블록을 제거 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="df90ef0557839e06b278a6e6491f0c912e330c70" translate="yes" xml:space="preserve">
          <source>Within the context of a layout, &lt;code&gt;yield&lt;/code&gt; identifies a section where content from the view should be inserted. The simplest way to use this is to have a single &lt;code&gt;yield&lt;/code&gt;, into which the entire contents of the view currently being rendered is inserted:</source>
          <target state="translated">레이아웃 컨텍스트 내에서 &lt;code&gt;yield&lt;/code&gt; 는 뷰의 컨텐츠를 삽입해야하는 섹션을 식별합니다. 이것을 사용하는 가장 간단한 방법은 현재 렌더링되는 뷰의 전체 내용이 삽입되는 단일 &lt;code&gt;yield&lt;/code&gt; 를 얻는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="3ac99994965f8ec25e456f0f95d73c7b9afd819a" translate="yes" xml:space="preserve">
          <source>Within the mailer method, you have access to the following methods:</source>
          <target state="translated">메일러 메소드 내에서 다음 메소드에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cb0ba994527636d101910f0140b5f58db5e8c22" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;try&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;try&lt;/code&gt; 하지 않고</target>
        </trans-unit>
        <trans-unit id="36df043df8c53225e2af5a06a49aa1243a98cd00" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;with_options&lt;/code&gt;, this code contains duplication:</source>
          <target state="translated">&lt;code&gt;with_options&lt;/code&gt; 가 없으면 이 코드에는 중복이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c1b3cd30124d02f50ea647a1dd486bab141c4243" translate="yes" xml:space="preserve">
          <source>Without any &lt;code&gt;options&lt;/code&gt;, the returned &lt;a href=&quot;../../hash&quot;&gt;Hash&lt;/a&gt; will include all the model's attributes.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 없으면 반환 된 &lt;a href=&quot;../../hash&quot;&gt;해시에&lt;/a&gt; 모든 모델 속성이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a949a7f7f400928464609a2db9ce9a968bb45f22" translate="yes" xml:space="preserve">
          <source>Without getting too much into the details, the resolution algorithm for relative constant references goes like this:</source>
          <target state="translated">세부 사항에 너무 많이 들어 가지 않으면 상대 상수 참조에 대한 해상도 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5bcca139a2666fb0ea6ecd4854edaba7bcd3f95" translate="yes" xml:space="preserve">
          <source>Without the asset pipeline (&lt;code&gt;skip_pipeline: true&lt;/code&gt;)</source>
          <target state="translated">자산 파이프 라인이없는 경우 ( &lt;code&gt;skip_pipeline: true&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c200537e6376c18b52f8c90e81ccdd31725ef299" translate="yes" xml:space="preserve">
          <source>Without web-service support, an action which collects the data for displaying a list of people might look something like this:</source>
          <target state="translated">웹 서비스 지원이 없으면 사람들 목록을 표시하기 위해 데이터를 수집하는 조치는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e47daa7a6731608211a6729ba435943b8d544c06" translate="yes" xml:space="preserve">
          <source>Work in progress</source>
          <target state="translated">진행중인 작업</target>
        </trans-unit>
        <trans-unit id="4614fcbf9fd7328da6193e2e58395ba0c0fcdf6f" translate="yes" xml:space="preserve">
          <source>Worker Pool Configuration</source>
          <target state="translated">작업자 풀 구성</target>
        </trans-unit>
        <trans-unit id="d804d4849f526c1d55df6cfddcedf18304809d28" translate="yes" xml:space="preserve">
          <source>Working with Action Mailbox in development</source>
          <target state="translated">개발중인 Action Mailbox 작업</target>
        </trans-unit>
        <trans-unit id="4fce12f21c55e836453dd95303ee0ec1141dc76e" translate="yes" xml:space="preserve">
          <source>Working with JavaScript in Rails</source>
          <target state="translated">Rails에서 JavaScript로 작업하기</target>
        </trans-unit>
        <trans-unit id="f7d8062e05cb6917f270cd5b2f4c3f4167cfd778" translate="yes" xml:space="preserve">
          <source>Working with Keys</source>
          <target state="translated">키 작업</target>
        </trans-unit>
        <trans-unit id="423d601a56f7002003c22e452aa9298b0a15a594" translate="yes" xml:space="preserve">
          <source>Working with Validation Errors</source>
          <target state="translated">유효성 검사 오류 작업</target>
        </trans-unit>
        <trans-unit id="e32fdd98629bee206ab48fa01296302158ae8e70" translate="yes" xml:space="preserve">
          <source>Works great alongside individual template fragment caching. For instance if the template the collection renders is cached like:</source>
          <target state="translated">개별 템플릿 조각 캐싱과 함께 작동합니다. 예를 들어 컬렉션이 렌더링하는 템플릿이 다음과 같이 캐시 된 경우 :</target>
        </trans-unit>
        <trans-unit id="6929247e0d26981b97b6c1af52ca96ede25f128b" translate="yes" xml:space="preserve">
          <source>Works in two unique ways.</source>
          <target state="translated">두 가지 독특한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="bb96ff4d5fc708a690532720678fd4d366e2df11" translate="yes" xml:space="preserve">
          <source>Works in two ways.</source>
          <target state="translated">두 가지 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="fcce9dc70ef1d9c562399bbfce24e465358caa53" translate="yes" xml:space="preserve">
          <source>Works just like &lt;code&gt;String#split&lt;/code&gt;, with the exception that the items in the resulting list are &lt;a href=&quot;chars&quot;&gt;Chars&lt;/a&gt; instances instead of &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt;. This makes chaining methods easier.</source>
          <target state="translated">결과 목록의 항목 이 &lt;a href=&quot;../../string&quot;&gt;String&lt;/a&gt; 대신 &lt;a href=&quot;chars&quot;&gt;Chars&lt;/a&gt; 인스턴스 라는 점을 제외하고 &lt;code&gt;String#split&lt;/code&gt; 과 동일하게 작동 합니다. 이렇게하면 연결 방법이 쉬워집니다.</target>
        </trans-unit>
        <trans-unit id="8f9c23fd443cf0afd037d08db21e204ab4250a37" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;String#slice!&lt;/code&gt;, but returns an instance of &lt;a href=&quot;chars&quot;&gt;Chars&lt;/a&gt;, or &lt;code&gt;nil&lt;/code&gt; if the string was not modified. The string will not be modified if the range given is out of bounds</source>
          <target state="translated">&lt;code&gt;String#slice!&lt;/code&gt; 처럼 작동합니다 ! 이지만 &lt;a href=&quot;chars&quot;&gt;Chars&lt;/a&gt; 인스턴스를 반환 하거나 문자열이 수정되지 않은 경우 &lt;code&gt;nil&lt;/code&gt; 을 반환합니다. 주어진 범위가 범위를 벗어나면 문자열이 수정되지 않습니다</target>
        </trans-unit>
        <trans-unit id="08c458beabcbe34f4667c55b97e644bb2ec0002d" translate="yes" xml:space="preserve">
          <source>Works like &lt;code&gt;table_name_prefix=&lt;/code&gt;, but appends instead of prepends (set to &amp;ldquo;_basecamp&amp;rdquo; gives &amp;ldquo;projects_basecamp&amp;rdquo;, &amp;ldquo;people_basecamp&amp;rdquo;). By default, the suffix is the empty string.</source>
          <target state="translated">&lt;code&gt;table_name_prefix=&lt;/code&gt; 처럼 작동 하지만 접두사 대신 추가합니다 (&amp;ldquo;_basecamp&amp;rdquo;로 설정하면&amp;ldquo;projects_basecamp&amp;rdquo;,&amp;ldquo;people_basecamp&amp;rdquo;). 기본적으로 접미사는 빈 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="551deaf59edd74216bd324bebcfaf057b3f2449b" translate="yes" xml:space="preserve">
          <source>Would create &lt;code&gt;after_create&lt;/code&gt;, &lt;code&gt;before_update&lt;/code&gt; and &lt;code&gt;around_destroy&lt;/code&gt; methods only.</source>
          <target state="translated">만들겠습니까 &lt;code&gt;after_create&lt;/code&gt; , &lt;code&gt;before_update&lt;/code&gt; 및 &lt;code&gt;around_destroy&lt;/code&gt; 방법 만.</target>
        </trans-unit>
        <trans-unit id="6e85e2af16fe60fec4da3886c7087d08ec680aad" translate="yes" xml:space="preserve">
          <source>Would only create the &lt;code&gt;after_create&lt;/code&gt; and &lt;code&gt;before_create&lt;/code&gt; callback methods in your class.</source>
          <target state="translated">클래스에서 &lt;code&gt;after_create&lt;/code&gt; 및 &lt;code&gt;before_create&lt;/code&gt; 콜백 메소드 만 작성하십시오 .</target>
        </trans-unit>
        <trans-unit id="f19be442525da0ff86e071f2ca9f6a92eae2ec07" translate="yes" xml:space="preserve">
          <source>Wrap block with namespace of current application if namespace exists and is not skipped</source>
          <target state="translated">네임 스페이스가 존재하고 건너 뛰지 않은 경우 현재 애플리케이션의 네임 스페이스로 블록 랩</target>
        </trans-unit>
        <trans-unit id="7604bdf393682bd93e95a7e101d8923e9046e984" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;persistence#method-i-becomes&quot;&gt;becomes&lt;/a&gt; that also changes the instance's sti column value. This is especially useful if you want to persist the changed class in your database.</source>
          <target state="translated">래퍼는 약 &lt;a href=&quot;persistence#method-i-becomes&quot;&gt;이된다&lt;/a&gt; 또한 인스턴스의 STI 열 값을 변경하는 것이다. 데이터베이스에서 변경된 클래스를 유지하려는 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b3380f24a5c496c07105616ea483701fb364b420" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;persistence#method-i-decrement&quot;&gt;decrement&lt;/a&gt; that writes the update to the database. Only &lt;code&gt;attribute&lt;/code&gt; is updated; the record itself is not saved. This means that any other modified attributes will still be dirty. &lt;a href=&quot;validations&quot;&gt;Validations&lt;/a&gt; and callbacks are skipped. Supports the &lt;code&gt;touch&lt;/code&gt; option from &lt;code&gt;update_counters&lt;/code&gt;, see that for more. Returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">업데이트를 데이터베이스에 기록하는 &lt;a href=&quot;persistence#method-i-decrement&quot;&gt;감소&lt;/a&gt; 를 감싼 래퍼 입니다. &lt;code&gt;attribute&lt;/code&gt; 만 업데이트됩니다. 레코드 자체는 저장되지 않습니다. 이것은 다른 수정 된 속성이 여전히 더럽다는 것을 의미합니다. &lt;a href=&quot;validations&quot;&gt;유효성 검사&lt;/a&gt; 및 콜백을 건너 뜁니다. &lt;code&gt;update_counters&lt;/code&gt; 의 &lt;code&gt;touch&lt;/code&gt; 옵션을 지원합니다 . 자세한 내용은 참조하십시오. &lt;code&gt;self&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c51113d47afe8594e08f7f258c40c22adc8b643e" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;persistence#method-i-increment&quot;&gt;increment&lt;/a&gt; that writes the update to the database. Only &lt;code&gt;attribute&lt;/code&gt; is updated; the record itself is not saved. This means that any other modified attributes will still be dirty. &lt;a href=&quot;validations&quot;&gt;Validations&lt;/a&gt; and callbacks are skipped. Supports the &lt;code&gt;touch&lt;/code&gt; option from &lt;code&gt;update_counters&lt;/code&gt;, see that for more. Returns &lt;code&gt;self&lt;/code&gt;.</source>
          <target state="translated">업데이트를 데이터베이스에 기록하는 &lt;a href=&quot;persistence#method-i-increment&quot;&gt;증분&lt;/a&gt; 주위 래퍼 입니다. &lt;code&gt;attribute&lt;/code&gt; 만 업데이트됩니다. 레코드 자체는 저장되지 않습니다. 이것은 다른 수정 된 속성이 여전히 더럽다는 것을 의미합니다. &lt;a href=&quot;validations&quot;&gt;유효성 검사&lt;/a&gt; 및 콜백을 건너 뜁니다. &lt;code&gt;update_counters&lt;/code&gt; 의 &lt;code&gt;touch&lt;/code&gt; 옵션을 지원합니다 . 자세한 내용은 참조하십시오. &lt;code&gt;self&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b5d88209faf04493f90eae8dca5acdf92397f6cf" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;a href=&quot;persistence#method-i-toggle&quot;&gt;toggle&lt;/a&gt; that saves the record. This method differs from its non-bang version in the sense that it passes through the attribute setter. Saving is not subjected to validation checks. Returns &lt;code&gt;true&lt;/code&gt; if the record could be saved.</source>
          <target state="translated">레코드를 저장하는 &lt;a href=&quot;persistence#method-i-toggle&quot;&gt;토글&lt;/a&gt; 주위 래퍼 . 이 방법은 속성 설정기를 통과한다는 점에서 뱅이 아닌 버전과 다릅니다. 저장은 유효성 검사를받지 않습니다. 레코드를 저장할 수 있으면 &lt;code&gt;true&lt;/code&gt; 를 리턴 합니다 .</target>
        </trans-unit>
        <trans-unit id="ef840afcddbb0c72a9932bf338567231c320f6c4" translate="yes" xml:space="preserve">
          <source>Wrapping</source>
          <target state="translated">Wrapping</target>
        </trans-unit>
        <trans-unit id="43dd0ed74dbdb250c8008544118eb48c5dbeb102" translate="yes" xml:space="preserve">
          <source>Wrapping a string in this class gives you a prettier way to test for equality. The value returned by &lt;code&gt;Rails.env&lt;/code&gt; is wrapped in a &lt;a href=&quot;stringinquirer&quot;&gt;StringInquirer&lt;/a&gt; object, so instead of calling this:</source>
          <target state="translated">이 클래스에서 문자열을 감싸면 평등을 테스트하는 더 좋은 방법을 제공합니다. &lt;code&gt;Rails.env&lt;/code&gt; 에 의해 리턴 된 값 은 이것을 호출하는 대신 &lt;a href=&quot;stringinquirer&quot;&gt;StringInquirer&lt;/a&gt; 오브젝트로 랩핑됩니다 .</target>
        </trans-unit>
        <trans-unit id="2a9d59058867927203b8562603da5227b2231449" translate="yes" xml:space="preserve">
          <source>Wrapping an array in an &lt;code&gt;ArrayInquirer&lt;/code&gt; gives a friendlier way to check its string-like contents:</source>
          <target state="translated">&lt;code&gt;ArrayInquirer&lt;/code&gt; 에서 배열을 래핑하면 문자열과 같은 내용을 확인하는 것이 더 쉽습니다 .</target>
        </trans-unit>
        <trans-unit id="a94541e9999f3d999b5e33ccbd1138471317d95f" translate="yes" xml:space="preserve">
          <source>Wrapping application code</source>
          <target state="translated">랩핑 애플리케이션 코드</target>
        </trans-unit>
        <trans-unit id="b8546ef965d0098d62f53abe18a65583f04caac6" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;datehelper#method-i-date_select&quot;&gt;ActionView::Helpers::DateHelper#date_select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;datehelper#method-i-date_select&quot;&gt;ActionView :: 도우미 :: DateHelper # date_select&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="3cb0b493cf0247474aa94af1cef803b0b8320280" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;datehelper#method-i-datetime_select&quot;&gt;ActionView::Helpers::DateHelper#datetime_select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;datehelper#method-i-datetime_select&quot;&gt;ActionView :: 도우미 :: DateHelper # datetime_select&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="385465a8b6eeb833d7279f5ec9bc90eb4063ea6c" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;datehelper#method-i-time_select&quot;&gt;ActionView::Helpers::DateHelper#time_select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;datehelper#method-i-time_select&quot;&gt;ActionView :: 도우미 :: DateHelper # time_select&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="b9fa0a568625a132b9ec88aba24db72173427dde" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-color_field&quot;&gt;ActionView::Helpers::FormHelper#color_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-color_field&quot;&gt;ActionView :: 도우미 :: FormHelper # color_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="abc8e80e95b190630bbde1da2244afa1f37391f1" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-date_field&quot;&gt;ActionView::Helpers::FormHelper#date_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-date_field&quot;&gt;ActionView :: 도우미 :: FormHelper # DATE_FIELD&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="df621530085ff8f3fb269f5fe6e03e3b5cc5b177" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-datetime_field&quot;&gt;ActionView::Helpers::FormHelper#datetime_field&lt;/a&gt; for form builders:</source>
          <target state="translated">양식 빌더를 위해 &lt;a href=&quot;formhelper#method-i-datetime_field&quot;&gt;ActionView :: Helpers :: FormHelper # datetime_field&lt;/a&gt; 를 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="f2d9fd316bbc91af402ff9794ab1848b00af1da6" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-datetime_local_field&quot;&gt;ActionView::Helpers::FormHelper#datetime_local_field&lt;/a&gt; for form builders:</source>
          <target state="translated">폼 빌더를 위해 &lt;a href=&quot;formhelper#method-i-datetime_local_field&quot;&gt;ActionView :: Helpers :: FormHelper # datetime_local_field&lt;/a&gt; 를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="6c111aeb0c914f76126c84455977b6b21767f394" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-email_field&quot;&gt;ActionView::Helpers::FormHelper#email_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-email_field&quot;&gt;ActionView :: 도우미 :: FormHelper # email_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="d68a01e0ae1f4266a6ca2b32d7cc3e2e13daac93" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-month_field&quot;&gt;ActionView::Helpers::FormHelper#month_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-month_field&quot;&gt;ActionView :: 도우미 :: FormHelper # MONTH_FIELD&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="a0530a1ed29cd691567dc08770d74a79f6ef8376" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-number_field&quot;&gt;ActionView::Helpers::FormHelper#number_field&lt;/a&gt; for form builders:</source>
          <target state="translated">폼 빌더의 &lt;a href=&quot;formhelper#method-i-number_field&quot;&gt;ActionView :: Helpers :: FormHelper # number_field&lt;/a&gt; 를 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="0d258f57456406303cd9a3524c0273a483e71734" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-password_field&quot;&gt;ActionView::Helpers::FormHelper#password_field&lt;/a&gt; for form builders:</source>
          <target state="translated">폼 빌더의 &lt;a href=&quot;formhelper#method-i-password_field&quot;&gt;ActionView :: Helpers :: FormHelper # password_field&lt;/a&gt; 를 랩핑 합니다 .</target>
        </trans-unit>
        <trans-unit id="ba95f0fce3e8352510f2d251a53e7aebbe4a3d45" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-phone_field&quot;&gt;ActionView::Helpers::FormHelper#phone_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-phone_field&quot;&gt;ActionView :: 도우미 :: FormHelper # phone_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="726da350a0cae9d4a97178353e5e135f04b0944c" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-range_field&quot;&gt;ActionView::Helpers::FormHelper#range_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-range_field&quot;&gt;ActionView :: 도우미 :: FormHelper # range_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="aa14b9e3b7b4fd2cb708de9fe14ef247df1077a2" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-search_field&quot;&gt;ActionView::Helpers::FormHelper#search_field&lt;/a&gt; for form builders:</source>
          <target state="translated">양식 빌더를 위해 &lt;a href=&quot;formhelper#method-i-search_field&quot;&gt;ActionView :: Helpers :: FormHelper # search_field&lt;/a&gt; 를 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="93711269091d6ee4ae4bed09d71f7cc7ccaf337d" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-telephone_field&quot;&gt;ActionView::Helpers::FormHelper#telephone_field&lt;/a&gt; for form builders:</source>
          <target state="translated">폼 빌더를 위해 &lt;a href=&quot;formhelper#method-i-telephone_field&quot;&gt;ActionView :: Helpers :: FormHelper # telephone_field&lt;/a&gt; 를 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="b7e05db2fc287814d5334b48a6af7536243ee466" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-text_area&quot;&gt;ActionView::Helpers::FormHelper#text_area&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-text_area&quot;&gt;ActionView :: 도우미 :: FormHelper #의 text_area&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="efd630ed291c186a928c7d08a9ac8c06bc17cde8" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-text_field&quot;&gt;ActionView::Helpers::FormHelper#text_field&lt;/a&gt; for form builders:</source>
          <target state="translated">양식 빌더를 위해 &lt;a href=&quot;formhelper#method-i-text_field&quot;&gt;ActionView :: Helpers :: FormHelper # text_field&lt;/a&gt; 를 랩핑합니다 .</target>
        </trans-unit>
        <trans-unit id="1018138a0f7f235ecf2024dc4d5b3253f519d56e" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-time_field&quot;&gt;ActionView::Helpers::FormHelper#time_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-time_field&quot;&gt;ActionView :: 도우미 :: FormHelper # time_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="40b64a8571a2ceaceec1f7a1dc73be2ac2359c33" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-url_field&quot;&gt;ActionView::Helpers::FormHelper#url_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-url_field&quot;&gt;ActionView :: 도우미 :: FormHelper # url_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="e8247e204371996bbffddeb185a48d4d448f125c" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formhelper#method-i-week_field&quot;&gt;ActionView::Helpers::FormHelper#week_field&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formhelper#method-i-week_field&quot;&gt;ActionView :: 도우미 :: FormHelper # week_field&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="2bb5a2017932c52fe20a2a7c980bb7673660fece" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formoptionshelper#method-i-collection_check_boxes&quot;&gt;ActionView::Helpers::FormOptionsHelper#collection_check_boxes&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formoptionshelper#method-i-collection_check_boxes&quot;&gt;ActionView :: 도우미 :: FormOptionsHelper # collection_check_boxes&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="5ab8cb6a2146fe56a6d49ca18abeab078836ab0d" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formoptionshelper#method-i-collection_radio_buttons&quot;&gt;ActionView::Helpers::FormOptionsHelper#collection_radio_buttons&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formoptionshelper#method-i-collection_radio_buttons&quot;&gt;ActionView :: 도우미 :: FormOptionsHelper #의 collection_radio_buttons&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="5802d755104febf0289e4b4e174b6887e54fb201" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formoptionshelper#method-i-collection_select&quot;&gt;ActionView::Helpers::FormOptionsHelper#collection_select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formoptionshelper#method-i-collection_select&quot;&gt;ActionView :: 도우미 :: FormOptionsHelper # collection_select&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="afe6b2c463baf222ad914938611e70a33d5ca397" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formoptionshelper#method-i-grouped_collection_select&quot;&gt;ActionView::Helpers::FormOptionsHelper#grouped_collection_select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formoptionshelper#method-i-grouped_collection_select&quot;&gt;ActionView :: 도우미 :: FormOptionsHelper # grouped_collection_select&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="d3b84ced4109844a2b10630391fa74883ed10b61" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formoptionshelper#method-i-select&quot;&gt;ActionView::Helpers::FormOptionsHelper#select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formoptionshelper#method-i-select&quot;&gt;ActionView :: 도우미 :: FormOptionsHelper # 선택&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="879612bc032e464b5a3f5f3b598f2e6dd11a0475" translate="yes" xml:space="preserve">
          <source>Wraps &lt;a href=&quot;formoptionshelper#method-i-time_zone_select&quot;&gt;ActionView::Helpers::FormOptionsHelper#time_zone_select&lt;/a&gt; for form builders:</source>
          <target state="translated">랩 &lt;a href=&quot;formoptionshelper#method-i-time_zone_select&quot;&gt;ActionView :: 도우미 :: FormOptionsHelper # time_zone_select&lt;/a&gt; 폼 빌더 :</target>
        </trans-unit>
        <trans-unit id="1938a626cd21a3680d43346c19d0d54aa23f8316" translate="yes" xml:space="preserve">
          <source>Wraps a local disk path as an Active Storage service. See &lt;a href=&quot;../service&quot;&gt;ActiveStorage::Service&lt;/a&gt; for the generic API documentation that applies to all services.</source>
          <target state="translated">로컬 디스크 경로를 Active Storage 서비스로 래핑합니다. 모든 서비스에 적용되는 일반 API 설명서는 &lt;a href=&quot;../service&quot;&gt;ActiveStorage :: Service&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e63986ab318091b898ec944402acc6968561dae4" translate="yes" xml:space="preserve">
          <source>Wraps a set of mirror services and provides a single &lt;a href=&quot;../service&quot;&gt;ActiveStorage::Service&lt;/a&gt; object that will all have the files uploaded to them. A &lt;code&gt;primary&lt;/code&gt; service is designated to answer calls to &lt;code&gt;download&lt;/code&gt;, &lt;code&gt;exists?&lt;/code&gt;, and &lt;code&gt;url&lt;/code&gt;.</source>
          <target state="translated">미러 서비스 집합을 래핑 하고 파일을 모두 업로드 할 단일 &lt;a href=&quot;../service&quot;&gt;ActiveStorage :: Service&lt;/a&gt; 개체를 제공합니다. &lt;code&gt;primary&lt;/code&gt; 서비스에 응답 호출에 지정된 &lt;code&gt;download&lt;/code&gt; , &lt;code&gt;exists?&lt;/code&gt; 및 &lt;code&gt;url&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9ff38c87a49d8850ef64a42c7f2c3b9599e5cf4" translate="yes" xml:space="preserve">
          <source>Wraps any standard &lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt; object to provide tagging capabilities.</source>
          <target state="translated">태그 지정 기능을 제공하기 위해 모든 표준 &lt;a href=&quot;logger&quot;&gt;Logger&lt;/a&gt; 객체를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="3d9e28efdc4f462e98b3b4d0e8e6debdb6f0d597" translate="yes" xml:space="preserve">
          <source>Wraps gem entries inside a group.</source>
          <target state="translated">보석 항목을 그룹으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="2a120fd8416c72af30bfb0298afa8ec2b8708547" translate="yes" xml:space="preserve">
          <source>Wraps gem entries inside a group:</source>
          <target state="translated">보석 항목을 그룹으로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="47ded7ecd046d65a482a826d10a11d9b379018a8" translate="yes" xml:space="preserve">
          <source>Wraps its argument in an array unless it is already an array (or array-like).</source>
          <target state="translated">이미 배열 (또는 배열과 같은)이 아닌 한 인수를 배열에 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="35b87ade3707e7464cbbfbd66840c975454f01c7" translate="yes" xml:space="preserve">
          <source>Wraps the &lt;code&gt;text&lt;/code&gt; into lines no longer than &lt;code&gt;line_width&lt;/code&gt; width. This method breaks on the first whitespace character that does not exceed &lt;code&gt;line_width&lt;/code&gt; (which is 80 by default).</source>
          <target state="translated">감쌈없는 &lt;code&gt;text&lt;/code&gt; 더 이상 라인에를 &lt;code&gt;line_width&lt;/code&gt; 폭입니다. 이 방법은 &lt;code&gt;line_width&lt;/code&gt; (기본적으로 80)를 초과하지 않는 첫 번째 공백 문자에서 중단됩니다 .</target>
        </trans-unit>
        <trans-unit id="908f1855e9a175b431fa0948765ecc2bbf6dbb0a" translate="yes" xml:space="preserve">
          <source>Wraps the Amazon Simple Storage &lt;a href=&quot;../service&quot;&gt;Service&lt;/a&gt; (S3) as an Active Storage service. See &lt;a href=&quot;../service&quot;&gt;ActiveStorage::Service&lt;/a&gt; for the generic API documentation that applies to all services.</source>
          <target state="translated">Amazon Simple Storage &lt;a href=&quot;../service&quot;&gt;Service&lt;/a&gt; (S3)를 Active Storage 서비스로 래핑합니다 . 모든 서비스에 적용되는 일반 API 설명서는 &lt;a href=&quot;../service&quot;&gt;ActiveStorage :: Service&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="91f330be9930c6bbd3bad639e7a2850098b71004" translate="yes" xml:space="preserve">
          <source>Wraps the Google Cloud Storage as an Active Storage service. See &lt;a href=&quot;../service&quot;&gt;ActiveStorage::Service&lt;/a&gt; for the generic API documentation that applies to all services.</source>
          <target state="translated">Google Cloud Storage를 Active Storage 서비스로 래핑합니다. 모든 서비스에 적용되는 일반 API 설명서는 &lt;a href=&quot;../service&quot;&gt;ActiveStorage :: Service&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eea889ef160e7a8e7cc5d7cd8b5b8f2bfeb11933" translate="yes" xml:space="preserve">
          <source>Wraps the Microsoft Azure Storage &lt;a href=&quot;../blob&quot;&gt;Blob&lt;/a&gt;&lt;a href=&quot;../service&quot;&gt;Service&lt;/a&gt; as an Active Storage service. See &lt;a href=&quot;../service&quot;&gt;ActiveStorage::Service&lt;/a&gt; for the generic API documentation that applies to all services.</source>
          <target state="translated">Microsoft Azure Storage &lt;a href=&quot;../blob&quot;&gt;Blob &lt;/a&gt;&lt;a href=&quot;../service&quot;&gt;서비스&lt;/a&gt; 를 Active Storage 서비스 로 래핑합니다 . 모든 서비스에 적용되는 일반 API 설명서는 &lt;a href=&quot;../service&quot;&gt;ActiveStorage :: Service&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="5f7314ba35229d2d6949855adee7605590569bb6" translate="yes" xml:space="preserve">
          <source>Wraps the array in an &lt;code&gt;ArrayInquirer&lt;/code&gt; object, which gives a friendlier way to check its string-like contents.</source>
          <target state="translated">배열을 &lt;code&gt;ArrayInquirer&lt;/code&gt; 객체로 래핑하여 문자열과 같은 내용을보다 쉽게 ​​확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81572172471a96d13378b8323c3c37046b2a5f21" translate="yes" xml:space="preserve">
          <source>Wraps the current string in the &lt;code&gt;ActiveSupport::StringInquirer&lt;/code&gt; class, which gives you a prettier way to test for equality.</source>
          <target state="translated">현재 문자열을 &lt;code&gt;ActiveSupport::StringInquirer&lt;/code&gt; 클래스 에 래핑하여 동등성을 테스트하는 더 좋은 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="84d5d582a608648a96ea4621ede51988a4a6da6c" translate="yes" xml:space="preserve">
          <source>Wraps the original exception raised as &lt;code&gt;cause&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cause&lt;/code&gt; 발생한 원래 예외를 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="53ef5f4e0b6b2bfb8419cf2be8f0535872435866" translate="yes" xml:space="preserve">
          <source>Wraps the parameters hash into a nested hash. This will allow clients to submit requests without having to specify any root elements.</source>
          <target state="translated">매개 변수 해시를 중첩 해시로 래핑합니다. 이를 통해 클라이언트는 루트 요소를 지정하지 않고도 요청을 제출할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc6346cafe5f99f56a9f0e0b81d0cbdac64edc4d" translate="yes" xml:space="preserve">
          <source>Wraps the passed block in a transaction, locking the object before yielding. You can pass the SQL locking clause as argument (see &lt;code&gt;lock!&lt;/code&gt;).</source>
          <target state="translated">전달 된 블록을 트랜잭션에 래핑하여 객체를 생성하기 전에 잠급니다. SQL 잠금 절을 인수로 전달할 수 있습니다 ( &lt;code&gt;lock!&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="4011b4083b52da51ac34e29a3547b20cd6b8eb1c" translate="yes" xml:space="preserve">
          <source>Wraps the underlying database error as &lt;code&gt;cause&lt;/code&gt;.</source>
          <target state="translated">기본 데이터베이스 오류를 &lt;code&gt;cause&lt;/code&gt; 으로 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="4dda1f021c3168caac40baf568641d062401b7df" translate="yes" xml:space="preserve">
          <source>Write tests and make sure they pass.</source>
          <target state="translated">테스트를 작성하고 합격했는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7c529c079bc11447cc397e2b9b0627ac412a7895" translate="yes" xml:space="preserve">
          <source>Write to a file atomically. Useful for situations where you don't want other processes or threads to see half-written files.</source>
          <target state="translated">원자 적으로 파일에 씁니다. 다른 프로세스 나 스레드가 반으로 쓴 파일을 보지 않으려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f1b9d8ffa0afae0650e6ec9c0d7fa945b89ac225" translate="yes" xml:space="preserve">
          <source>Writes &lt;code&gt;content&lt;/code&gt; to the location signified by &lt;code&gt;key&lt;/code&gt; (see &lt;code&gt;expire_fragment&lt;/code&gt; for acceptable formats).</source>
          <target state="translated">&lt;code&gt;key&lt;/code&gt; 지정된 위치에 &lt;code&gt;content&lt;/code&gt; 을 씁니다 ( 허용되는 형식 은 &lt;code&gt;expire_fragment&lt;/code&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="88a71074d1bf85388e2492cd854f7144f6359eef" translate="yes" xml:space="preserve">
          <source>Writes the value to the cache, with the key.</source>
          <target state="translated">키를 사용하여 값을 캐시에 씁니다.</target>
        </trans-unit>
        <trans-unit id="29ea0226f4054f1c523a78567eab72f958b90ffb" translate="yes" xml:space="preserve">
          <source>Writing a Migration</source>
          <target state="translated">마이그레이션 작성</target>
        </trans-unit>
        <trans-unit id="993646e6d67c9e02f757b9fe3ac2b4ef64f3daf9" translate="yes" xml:space="preserve">
          <source>Writing an object will convert it into standard &lt;a href=&quot;sse&quot;&gt;SSE&lt;/a&gt; format with whatever options you have configured. You may choose to set the following options:</source>
          <target state="translated">객체를 작성하면 구성한 옵션이있는 표준 &lt;a href=&quot;sse&quot;&gt;SSE&lt;/a&gt; 형식 으로 객체가 변환됩니다 . 다음 옵션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff0144beabe2e0bec6eced06f50b85e8f1d25a2f" translate="yes" xml:space="preserve">
          <source>Writing value objects</source>
          <target state="translated">가치 객체 작성</target>
        </trans-unit>
        <trans-unit id="9ce4ba672dbfa70c136d86802b2038833d699c47" translate="yes" xml:space="preserve">
          <source>X-Sendfile Headers</source>
          <target state="translated">X-Sendfile 헤더</target>
        </trans-unit>
        <trans-unit id="fd7680c35859b5777f85041c7c4cf5302a762162" translate="yes" xml:space="preserve">
          <source>XML Serialization</source>
          <target state="translated">XML 직렬화</target>
        </trans-unit>
        <trans-unit id="09e6645d471494bf5a688d21ef32c01395d65e1f" translate="yes" xml:space="preserve">
          <source>XSS attacks work like this: An attacker injects some code, the web application saves it and displays it on a page, later presented to a victim. Most XSS examples simply display an alert box, but it is more powerful than that. XSS can steal the cookie, hijack the session, redirect the victim to a fake website, display advertisements for the benefit of the attacker, change elements on the web site to get confidential information or install malicious software through security holes in the web browser.</source>
          <target state="translated">XSS 공격은 다음과 같이 작동합니다. 공격자는 일부 코드를 주입하고 웹 응용 프로그램이 코드를 저장 한 후 페이지에 표시하여 나중에 피해자에게 제공합니다. 대부분의 XSS 예제는 단순히 경고 상자를 표시하지만 그보다 강력합니다. XSS는 쿠키를 훔치고, 세션을 가로 채고, 피해자를 가짜 웹 사이트로 리디렉션하고, 공격자의 이익을 위해 광고를 표시하고, 웹 사이트의 요소를 변경하여 기밀 정보를 얻거나 웹 브라우저의 보안 허점을 통해 악성 소프트웨어를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09fe790f978055da103ba46b6d799eee28cfe8d9" translate="yes" xml:space="preserve">
          <source>YAML-formatted fixtures are a human-friendly way to describe your sample data. These types of fixtures have the &lt;strong&gt;.yml&lt;/strong&gt; file extension (as in &lt;code&gt;users.yml&lt;/code&gt;).</source>
          <target state="translated">YAML 형식의 조명기는 샘플 데이터를 설명하기위한 인간 친화적 인 방법입니다. 이러한 유형의 조명기의 파일 확장자 는 &lt;strong&gt;.yml&lt;/strong&gt; ( &lt;code&gt;users.yml&lt;/code&gt; 과 동일 )입니다.</target>
        </trans-unit>
        <trans-unit id="f83a0e54478505513704d0569e61871e8b8b37a7" translate="yes" xml:space="preserve">
          <source>YELLOW</source>
          <target state="translated">YELLOW</target>
        </trans-unit>
        <trans-unit id="0323008786597f0bc9844ace09b953639f0bbb0c" translate="yes" xml:space="preserve">
          <source>Yes: Allows the priority to be set on the job object, at the queue level or as default configuration option.</source>
          <target state="translated">예 : 작업 오브젝트, 큐 레벨 또는 기본 구성 옵션으로 우선 순위를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6c15e1f21f3259d5bb359bb473bd786b29f8269" translate="yes" xml:space="preserve">
          <source>Yes: Jobs may set which queue they are run in with queue_as or by using the set method.</source>
          <target state="translated">예 : 작업은 queue_as 또는 set 메소드를 사용하여 실행되는 큐를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cb4f3f2291563f1705b99b0a25c67ff90b41dd8" translate="yes" xml:space="preserve">
          <source>Yes: The Number of retries can be configured globally, for each instance or on the queue. This adapter may also present failed instances of the job class that can be restarted.</source>
          <target state="translated">예 : 재시도 횟수는 각 인스턴스 또는 큐에 대해 전체적으로 구성 할 수 있습니다. 이 어댑터는 재시작 할 수있는 작업 클래스의 실패한 인스턴스를 표시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e30f06a26b3a02e813bacd58a98bc9ad5629b1f" translate="yes" xml:space="preserve">
          <source>Yes: The Queue Adapter has the ability to run the job in a non-blocking manner. It either runs on a separate or forked process, or on a different thread.</source>
          <target state="translated">예 : 큐 어댑터는 비 차단 방식으로 작업을 실행할 수 있습니다. 별도의 프로세스 또는 분기 된 프로세스 또는 다른 스레드에서 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="2dbe4eab5f8b127d4a1975d143ccbb2b6d02d074" translate="yes" xml:space="preserve">
          <source>Yes: The adapter will run the job in the future through perform_later.</source>
          <target state="translated">예 : 어댑터는 나중에 perform_later를 통해 작업을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="dca75359fefce732c6fbc88955c6bc7662afc24e" translate="yes" xml:space="preserve">
          <source>Yields &lt;a href=&quot;relation&quot;&gt;ActiveRecord::Relation&lt;/a&gt; objects to work with a batch of records.</source>
          <target state="translated">수익률은 &lt;a href=&quot;relation&quot;&gt;액티브 :: 관계&lt;/a&gt; 객체를 작업에 레코드의 배치와 함께.</target>
        </trans-unit>
        <trans-unit id="ca8fe1d8d4f29cf627d10de0048185d3f4f0c20b" translate="yes" xml:space="preserve">
          <source>Yields a singleton instance of &lt;a href=&quot;inflector/inflections&quot;&gt;Inflector::Inflections&lt;/a&gt; so you can specify additional inflector rules. If passed an optional locale, rules for other languages can be specified. If not specified, defaults to &lt;code&gt;:en&lt;/code&gt;. Only rules for English are provided.</source>
          <target state="translated">추가 인플 렉터 규칙을 지정할 수 있도록 &lt;a href=&quot;inflector/inflections&quot;&gt;Inflector :: Inflections&lt;/a&gt; 의 단일 인스턴스를 생성 합니다 . 선택적 로케일을 전달하면 다른 언어에 대한 규칙을 지정할 수 있습니다. 지정하지 않으면 기본값은 &lt;code&gt;:en&lt;/code&gt; 입니다. 영어 규칙 만 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="7af77031aa5483dc3c5212997daf7f80484e94a7" translate="yes" xml:space="preserve">
          <source>Yields an &lt;a href=&quot;../relation&quot;&gt;ActiveRecord::Relation&lt;/a&gt; object for each batch of records.</source>
          <target state="translated">산출 &lt;a href=&quot;../relation&quot;&gt;액티브 :: 관계&lt;/a&gt; 기록의 각 배치에 대한 개체를.</target>
        </trans-unit>
        <trans-unit id="02825770b8ec84c175b3fcdcc219525a2e1f0ee5" translate="yes" xml:space="preserve">
          <source>Yields each batch of records that was found by the find options as an array.</source>
          <target state="translated">찾기 옵션에서 찾은 각 레코드 배치를 배열로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="51fafe39a620d2088ad59802643a747dcc537a48" translate="yes" xml:space="preserve">
          <source>You &lt;strong&gt;must&lt;/strong&gt; call close on your stream when you're finished, otherwise the socket may be left open forever.</source>
          <target state="translated">당신은 &lt;strong&gt;해야한다&lt;/strong&gt; , 그렇지 않으면 소켓이 영원히 개방 할 수있다, 가까운 작업을 마친 스트림에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="294a3dd89a764318df53ccee20220897b789e1b3" translate="yes" xml:space="preserve">
          <source>You actually have a functional Rails application already. To see it, you need to start a web server on your development machine. You can do this by running the following in the &lt;code&gt;blog&lt;/code&gt; directory:</source>
          <target state="translated">실제로 기능적 Rails 애플리케이션이 이미 있습니다. 이를 확인하려면 개발 시스템에서 웹 서버를 시작해야합니다. &lt;code&gt;blog&lt;/code&gt; 디렉토리 에서 다음을 실행하여이를 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="681e3dc347a2eb528dcfb825be20348ea919af91" translate="yes" xml:space="preserve">
          <source>You also have access to three instance variables in your functional tests, after a request is made:</source>
          <target state="translated">요청 후 기능 테스트에서 세 가지 인스턴스 변수에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fc926cb3e2bf7174eb1a1092f36dc9fe8c9706e" translate="yes" xml:space="preserve">
          <source>You also have the option to call instrument without passing a block. This lets you leverage the instrumentation infrastructure for other messaging uses.</source>
          <target state="translated">블록을 통과하지 않고 계측기를 호출 할 수도 있습니다. 이를 통해 다른 메시징 용도로 계측 인프라를 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f2c22a22f868638afa467d3d6feaea4cfa99c333" translate="yes" xml:space="preserve">
          <source>You also need to set the &lt;code&gt;migrations_paths&lt;/code&gt; in the database configurations to tell Rails where to find the migrations.</source>
          <target state="translated">데이터베이스 구성에서 &lt;code&gt;migrations_paths&lt;/code&gt; 를 설정하여 Rails에 마이그레이션을 찾을 위치를 알려 주어야 합니다.</target>
        </trans-unit>
        <trans-unit id="14a9b0f75deaff5698b682d13079d1968adffd89" translate="yes" xml:space="preserve">
          <source>You are able to move this logic out into a class if it is too complex for routes. This class must have a &lt;code&gt;matches?&lt;/code&gt; method defined on it which either returns &lt;code&gt;true&lt;/code&gt; if the user should be given access to that route, or &lt;code&gt;false&lt;/code&gt; if the user should not.</source>
          <target state="translated">이 논리가 경로에 비해 너무 복잡한 경우이 논리를 클래스로 옮길 수 있습니다. 이 클래스는 &lt;code&gt;matches?&lt;/code&gt; 해야 합니까? 메소드가 정의하는 중 반환 &lt;code&gt;true&lt;/code&gt; 사용자가 해당 경로에 액세스 또는 제공 할 필요가있는 경우 &lt;code&gt;false&lt;/code&gt; 경우 사용자는 안된다.</target>
        </trans-unit>
        <trans-unit id="3f317ca9ebd16a640cc03f2f977672b875d4231c" translate="yes" xml:space="preserve">
          <source>You are creating a nested (savepoint) transaction</source>
          <target state="translated">중첩 (저장 점) 트랜잭션을 작성 중입니다.</target>
        </trans-unit>
        <trans-unit id="084e0a5e0164bdfaf97a83b19a81de5b853266d6" translate="yes" xml:space="preserve">
          <source>You are even able to create your own events inside your application which you can later subscribe to.</source>
          <target state="translated">당신은 당신이 나중에 가입 할 수있는 응용 프로그램 내에서 자신의 이벤트를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8587767d2d0d7b672903bbd4742052bd94d0dbd3" translate="yes" xml:space="preserve">
          <source>You are guaranteed that the key is returned as a string:</source>
          <target state="translated">키는 문자열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3fe6ff6fc48c797ef8888f4f87efaa5cc97f5e6c" translate="yes" xml:space="preserve">
          <source>You are joining an existing open transaction</source>
          <target state="translated">기존 공개 거래에 참여하고 있습니다</target>
        </trans-unit>
        <trans-unit id="5e9d60da70a08f02e626d226545dfd81c92b8477" translate="yes" xml:space="preserve">
          <source>You are not free to use just any name for your associations. Because creating an association adds a method with that name to the model, it is a bad idea to give an association a name that is already used for an instance method of &lt;code&gt;ActiveRecord::Base&lt;/code&gt;. The association method would override the base method and break things. For instance, &lt;code&gt;attributes&lt;/code&gt; or &lt;code&gt;connection&lt;/code&gt; are bad names for associations.</source>
          <target state="translated">당신은 당신의 협회 이름을 자유롭게 사용할 수 없습니다. 연결을 만들면 해당 이름의 메서드가 모델에 추가되므로 &lt;code&gt;ActiveRecord::Base&lt;/code&gt; 의 인스턴스 메서드에 이미 사용 된 이름을 연결에 제공하는 것은 좋지 않습니다 . 연결 방법은 기본 방법을 무시하고 문제를 해결합니다. 예를 들어 &lt;code&gt;attributes&lt;/code&gt; 또는 &lt;code&gt;connection&lt;/code&gt; 은 연결 에 잘못된 이름입니다.</target>
        </trans-unit>
        <trans-unit id="104f499e65caa019db21658db26a90d7126f18e3" translate="yes" xml:space="preserve">
          <source>You are not limited to one magically generated column. For example:</source>
          <target state="translated">마술처럼 생성 된 하나의 열로 제한되지 않습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="50cf21775cef53618cec0e58c74930981920d685" translate="yes" xml:space="preserve">
          <source>You are not limited to querying fields from a single table, you can query multiple tables as well.</source>
          <target state="translated">단일 테이블에서 필드를 쿼리하는 것에 만 국한되지 않고 여러 테이블을 쿼리 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cd7b4ce175b227dd05123992042e5800839f200" translate="yes" xml:space="preserve">
          <source>You are not limited to the seven routes that RESTful routing creates by default. If you like, you may add additional routes that apply to the collection or individual members of the collection.</source>
          <target state="translated">RESTful 라우팅이 기본적으로 작성하는 7 개의 라우트로 제한되지 않습니다. 원하는 경우 컬렉션 또는 컬렉션의 개별 멤버에 적용되는 추가 경로를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1d35ef25dd6ca63f0e6fbedd944b5f9e23aa5b8" translate="yes" xml:space="preserve">
          <source>You can access the cache by calling &lt;code&gt;Rails.cache&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Rails.cache&lt;/code&gt; 를 호출하여 캐시에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c530329545cd23f99f4cd2ea0c1082b3a74dad5e" translate="yes" xml:space="preserve">
          <source>You can actually specify &lt;strong&gt;any&lt;/strong&gt; association with the &lt;code&gt;:through&lt;/code&gt; option, including an association which has a &lt;code&gt;:through&lt;/code&gt; option itself. For example:</source>
          <target state="translated">당신은 실제로 지정할 수 &lt;strong&gt;있는&lt;/strong&gt; 과 관련을 &lt;code&gt;:through&lt;/code&gt; 옵션을하는이 협회를 포함 &lt;code&gt;:through&lt;/code&gt; 옵션 자체. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1ddc87d6feffeebc605dc575f37022baa9637660" translate="yes" xml:space="preserve">
          <source>You can add HTML attributes using the &lt;code&gt;options&lt;/code&gt;. The &lt;code&gt;options&lt;/code&gt; supports additional keys for convenience and conformance:</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 사용하여 HTML 속성을 추가 할 수 있습니다 . &lt;code&gt;options&lt;/code&gt; 편의성과 적합성에 대한 추가 키를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="dfabdbc6eaf9706d38cb9b9efa65e26a262aaa5e" translate="yes" xml:space="preserve">
          <source>You can add a new middleware to the middleware stack using any of the following methods:</source>
          <target state="translated">다음 방법 중 하나를 사용하여 미들웨어 스택에 새 미들웨어를 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6cf5b312541205d410ce6fcd4a7a38efaf6cc28" translate="yes" xml:space="preserve">
          <source>You can add an object to a collection without automatically saving it by using the &lt;code&gt;collection.build&lt;/code&gt; method (documented below).</source>
          <target state="translated">&lt;code&gt;collection.build&lt;/code&gt; 메소드 를 사용하여 자동으로 저장하지 않고 컬렉션에 객체를 추가 할 수 있습니다 (아래에 설명되어 있음).</target>
        </trans-unit>
        <trans-unit id="73995fa477645127524d7f813ee3438c0d00dac3" translate="yes" xml:space="preserve">
          <source>You can add arbitrary attributes to the options using hashes:</source>
          <target state="translated">해시를 사용하여 옵션에 임의의 속성을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10e36c07c5d759062c598044b8b82d7f651252a8" translate="yes" xml:space="preserve">
          <source>You can add breakpoints dynamically with the command &lt;code&gt;break&lt;/code&gt; (or just &lt;code&gt;b&lt;/code&gt;). There are 3 possible ways of adding breakpoints manually:</source>
          <target state="translated">&lt;code&gt;break&lt;/code&gt; 명령 (또는 &lt;code&gt;b&lt;/code&gt; )을 사용하여 중단 점을 동적으로 추가 할 수 있습니다 . 중단 점을 수동으로 추가하는 3 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3efa5f758479db8ccd1bc617f6148e0648381644" translate="yes" xml:space="preserve">
          <source>You can add error messages that are related to the object's state as a whole, instead of being related to a specific attribute. You can use this method when you want to say that the object is invalid, no matter the values of its attributes. Since &lt;code&gt;errors[:base]&lt;/code&gt; is an array, you can simply add a string to it and it will be used as an error message.</source>
          <target state="translated">특정 속성과 관련되지 않고 객체의 상태와 관련된 오류 메시지를 추가 할 수 있습니다. 속성 값에 관계없이 객체가 유효하지 않다고 말하고 싶을 때이 방법을 사용할 수 있습니다. 이후 &lt;code&gt;errors[:base]&lt;/code&gt; 배열, 당신은 단순히 문자열을 추가 할 수 있으며 오류 메시지로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ebe9a374cb043e6da2b3cab5e7454f2d1ed5a41" translate="yes" xml:space="preserve">
          <source>You can add more default directories to search from by using &lt;code&gt;config.annotations.register_directories&lt;/code&gt;. It receives a list of directory names.</source>
          <target state="translated">&lt;code&gt;config.annotations.register_directories&lt;/code&gt; 를 사용하여 검색 할 기본 디렉토리를 더 추가 할 수 있습니다 . 디렉토리 이름 목록을받습니다.</target>
        </trans-unit>
        <trans-unit id="fe38ee8171a18a570a4b5aa2fa46d1280f5d8ffd" translate="yes" xml:space="preserve">
          <source>You can add more default file extensions to search from by using &lt;code&gt;config.annotations.register_extensions&lt;/code&gt;. It receives a list of extensions with its corresponding regex to match it up.</source>
          <target state="translated">&lt;code&gt;config.annotations.register_extensions&lt;/code&gt; 를 사용하여 검색 할 기본 파일 확장자를 더 추가 할 수 있습니다 . 일치하는 정규 표현식이있는 확장 목록을받습니다.</target>
        </trans-unit>
        <trans-unit id="13bbfb7d06ba127f92a766fb55ae530c6c4d07a8" translate="yes" xml:space="preserve">
          <source>You can add more default tags to search for by using &lt;code&gt;config.annotations.register_tags&lt;/code&gt;. It receives a list of tags.</source>
          <target state="translated">&lt;code&gt;config.annotations.register_tags&lt;/code&gt; 를 사용하여 검색 할 기본 태그를 더 추가 할 수 있습니다 . 태그 목록을받습니다.</target>
        </trans-unit>
        <trans-unit id="64413cb701d63ad6f1c3d121228bb9cc5ea07fc8" translate="yes" xml:space="preserve">
          <source>You can add your own formats to the &lt;a href=&quot;date#DATE_FORMATS&quot;&gt;Date::DATE_FORMATS&lt;/a&gt; hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a date argument as the value.</source>
          <target state="translated">&lt;a href=&quot;date#DATE_FORMATS&quot;&gt;Date :: DATE_FORMATS&lt;/a&gt; 해시에 고유 한 형식을 추가 할 수 있습니다 . 형식 이름을 해시 키로 사용하고 날짜 인수를 값으로 사용하는 strftime 문자열 또는 Proc 인스턴스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fa1f024a818bd2f5895be3f48b2de7648053fbe7" translate="yes" xml:space="preserve">
          <source>You can add your own formats to the &lt;a href=&quot;time#DATE_FORMATS&quot;&gt;Time::DATE_FORMATS&lt;/a&gt; hash. Use the format name as the hash key and either a strftime string or Proc instance that takes a time argument as the value.</source>
          <target state="translated">&lt;a href=&quot;time#DATE_FORMATS&quot;&gt;Time :: DATE_FORMATS&lt;/a&gt; 해시에 고유 한 형식을 추가 할 수 있습니다 . 형식 이름을 해시 키로 사용하고 시간 인수를 값으로 사용하는 strftime 문자열 또는 Proc 인스턴스를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e82c9b5d88c94ad8004196cf732dec9e73818d7f" translate="yes" xml:space="preserve">
          <source>You can add your own formats to the Range::RANGE_FORMATS hash. Use the format name as the hash key and a Proc instance.</source>
          <target state="translated">Range :: RANGE_FORMATS 해시에 고유 한 형식을 추가 할 수 있습니다. 형식 이름을 해시 키 및 Proc 인스턴스로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="007fedcd68699c59cd8841a2dc496117297ab795" translate="yes" xml:space="preserve">
          <source>You can add your own middlewares by using the &lt;code&gt;config.middleware.use&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;config.middleware.use&lt;/code&gt; 메소드 를 사용하여 고유 한 미들웨어를 추가 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="163d9d9200f29abd2a28d7293452ec8d912e0935" translate="yes" xml:space="preserve">
          <source>You can allow users to delete associated objects by passing &lt;code&gt;allow_destroy: true&lt;/code&gt; to &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;allow_destroy: true&lt;/code&gt; 를 전달하여 사용자가 관련 객체를 삭제하도록 허용 할 수 있습니다 . true 를 &lt;code&gt;accepts_nested_attributes_for&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a590f54852fd07188b8e55e57934c35f76d93f20" translate="yes" xml:space="preserve">
          <source>You can also add database specific timezone aware types. For example, for PostgreSQL:</source>
          <target state="translated">데이터베이스 특정 시간대 인식 유형을 추가 할 수도 있습니다. 예를 들어 PostgreSQL의 경우 :</target>
        </trans-unit>
        <trans-unit id="cd38e4dd8fb9d5633a5087ab09fbbc25342e067f" translate="yes" xml:space="preserve">
          <source>You can also apply a layout to a block within any template:</source>
          <target state="translated">템플릿 내 블록에 레이아웃을 적용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5895348923d121440c44c4abbc0eede41b6afc79" translate="yes" xml:space="preserve">
          <source>You can also build forms using a customized &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; class. Subclass &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; and override or define some more helpers, then use your custom builder. For example, let's say you made a helper to automatically add labels to form inputs.</source>
          <target state="translated">사용자 정의 된 &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; 클래스를 사용하여 양식을 작성할 수도 있습니다 . &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder를&lt;/a&gt; 서브 클래스로 만들고 추가 헬퍼를 재정의하거나 정의한 다음 사용자 정의 빌더를 사용하십시오. 예를 들어, 입력을 구성하기 위해 레이블을 자동으로 추가하는 도우미를 만들었다 고 가정 해 봅시다.</target>
        </trans-unit>
        <trans-unit id="88eafe740cfd5cc16e0ad9e9125853f19719b530" translate="yes" xml:space="preserve">
          <source>You can also call try with a block without accepting an argument, and the block will be instance_eval'ed instead:</source>
          <target state="translated">인수를 허용하지 않고 블록으로 try를 호출하면 블록이 대신 instance_eval'ed됩니다.</target>
        </trans-unit>
        <trans-unit id="6ec906e7658edcad649751ab7a3819da46fe6b60" translate="yes" xml:space="preserve">
          <source>You can also configure your backend on a per job basis.</source>
          <target state="translated">작업별로 백엔드를 구성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="593c6cce27da04d32d7552fa299b0dd68148079b" translate="yes" xml:space="preserve">
          <source>You can also consider using the &lt;a href=&quot;https://guides.rubyonrails.org/action_view_overview.html#view-paths&quot;&gt;append_view_path&lt;/a&gt; method.</source>
          <target state="translated">&lt;a href=&quot;https://guides.rubyonrails.org/action_view_overview.html#view-paths&quot;&gt;append_view_path&lt;/a&gt; 메소드 사용을 고려할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a5225acc0450d281786c2a6bcbc653bcbed1811" translate="yes" xml:space="preserve">
          <source>You can also constrain a route based on any method on the &lt;a href=&quot;action_controller_overview#the-request-object&quot;&gt;Request object&lt;/a&gt; that returns a &lt;code&gt;String&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;String&lt;/code&gt; 을 반환하는 &lt;a href=&quot;action_controller_overview#the-request-object&quot;&gt;Request 객체의&lt;/a&gt; 모든 메소드를 기반으로 경로를 제한 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0f8726beb95c1a65412628ce15181acc7d62c5b4" translate="yes" xml:space="preserve">
          <source>You can also create a job that will run on a specific queue:</source>
          <target state="translated">특정 대기열에서 실행될 작업을 생성 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fc0b5b9048af556a6ca2a3fb4cd5933ec08d2274" translate="yes" xml:space="preserve">
          <source>You can also create a layout with multiple yielding regions:</source>
          <target state="translated">여러 항복 영역이있는 레이아웃을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c52934d4b193b0806df41fff2ecf0fc3e7af744f" translate="yes" xml:space="preserve">
          <source>You can also create methods that verify the state of your models and add messages to the &lt;code&gt;errors&lt;/code&gt; collection when they are invalid. You must then register these methods by using the &lt;code&gt;validate&lt;/code&gt; (&lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validate&quot;&gt;API&lt;/a&gt;) class method, passing in the symbols for the validation methods' names.</source>
          <target state="translated">모델의 상태를 확인하는 메소드를 작성하고 &lt;code&gt;errors&lt;/code&gt; 콜렉션이 유효하지 않은 경우 오류 콜렉션에 메시지를 추가 할 수도 있습니다. 그런 다음 &lt;code&gt;validate&lt;/code&gt; ( &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActiveModel/Validations/ClassMethods.html#method-i-validate&quot;&gt;API&lt;/a&gt; ) 클래스 메소드를 사용하여 유효성 검증 메소드 이름의 기호를 전달 하여 이러한 메소드를 등록해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dc43f298cd913d29b58cd18d7201df0039e76307" translate="yes" xml:space="preserve">
          <source>You can also define a &lt;code&gt;default_url_options&lt;/code&gt; method on individual mailers to override these default settings per-mailer.</source>
          <target state="translated">개별 메일러에서 &lt;code&gt;default_url_options&lt;/code&gt; 메소드를 정의하여 메일러별로 이러한 기본 설정을 대체 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2166c7e47dcfe47da0426db905d2c76f779dceed" translate="yes" xml:space="preserve">
          <source>You can also define the &lt;a href=&quot;classmethods#method-i-primary_key&quot;&gt;primary_key&lt;/a&gt; method yourself:</source>
          <target state="translated">&lt;a href=&quot;classmethods#method-i-primary_key&quot;&gt;primary_key&lt;/a&gt; 메소드를 직접 정의 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7870edcf01aa2335eb862da133c5f358b3fafde4" translate="yes" xml:space="preserve">
          <source>You can also define the attributes for a model from a JSON string. However, you need to define the &lt;code&gt;attributes=&lt;/code&gt; method on your class:</source>
          <target state="translated">JSON 문자열에서 모델의 속성을 정의 할 수도 있습니다. 그러나 클래스 에서 &lt;code&gt;attributes=&lt;/code&gt; 메소드 를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d68270f39e5e1dd6c9f4f9ba28714138ef4f7a41" translate="yes" xml:space="preserve">
          <source>You can also define your own unit-quantifier names if you want to use other decimal units (eg.: 1500 becomes &amp;ldquo;1.5 kilometers&amp;rdquo;, 0.150 becomes &amp;ldquo;150 milliliters&amp;rdquo;, etc). You may define a wide range of unit quantifiers, even fractional ones (centi, deci, mili, etc).</source>
          <target state="translated">다른 10 진수 단위를 사용하려는 경우 고유 한 단위 수량 자 이름을 정의 할 수도 있습니다 (예 : 1500은 &quot;1.5 킬로미터&quot;, 0.150은 &quot;150 밀리리터&quot;등). 광범위한 단위 수량 자, 심지어 분수 단위 (centi, deci, mili 등)를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec67a540ecf04f925e83dae2d9b325b29e88c336" translate="yes" xml:space="preserve">
          <source>You can also disable generation of controller specific asset files by adding the following to your &lt;code&gt;config/application.rb&lt;/code&gt; configuration:</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 구성에 다음을 추가하여 컨트롤러 특정 자산 파일 생성을 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="70be43cd51ad0026d90c3c2114db9911e0b7439f" translate="yes" xml:space="preserve">
          <source>You can also do:</source>
          <target state="translated">당신은 또한 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="6d6d711b549c263f0f4cf789394c4567113eda88" translate="yes" xml:space="preserve">
          <source>You can also enable compression in development mode as a sanity check, and disable it on-demand as required for debugging.</source>
          <target state="translated">또한 상태 검사로 개발 모드에서 압축을 활성화하고 디버깅에 필요에 따라 압축을 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1555d79ab7a45ab64b52328a3412cd5c3aed67c2" translate="yes" xml:space="preserve">
          <source>You can also enable or disable breakpoints:</source>
          <target state="translated">중단 점을 활성화하거나 비활성화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="94601621bafc70d30b4d4d4e57ad3b9e98890e90" translate="yes" xml:space="preserve">
          <source>You can also generate paths and URLs. If the route above is modified to be:</source>
          <target state="translated">경로와 URL을 생성 할 수도 있습니다. 위의 경로가 다음과 같이 수정 된 경우 :</target>
        </trans-unit>
        <trans-unit id="7fdfab1748b3303f54af7c988375556e5d299c6e" translate="yes" xml:space="preserve">
          <source>You can also go through a &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; association on the join model:</source>
          <target state="translated">조인 모델에서 &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; 연관을 통해 이동할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ffdc57fa109ff75a798504677749e982013bab42" translate="yes" xml:space="preserve">
          <source>You can also have your controllers loaded from both &lt;code&gt;app/controllers&lt;/code&gt; and &lt;code&gt;lib/controllers&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;app/controllers&lt;/code&gt; 및 &lt;code&gt;lib/controllers&lt;/code&gt; 에서 컨트롤러를로드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="05330f890fa08e1be70a287b1e1db2f33f1f3831" translate="yes" xml:space="preserve">
          <source>You can also implement a custom asset host object that responds to &lt;code&gt;call&lt;/code&gt; and takes either one or two parameters just like the proc.</source>
          <target state="translated">&lt;code&gt;call&lt;/code&gt; 응답 하고 proc처럼 하나 또는 두 개의 매개 변수를 취하는 사용자 정의 자산 호스트 오브젝트를 구현할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93188de0200f4a242854410bb5aa07db167ab390" translate="yes" xml:space="preserve">
          <source>You can also insert your own messages and benchmarks by using the &lt;code&gt;say_with_time&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;say_with_time&lt;/code&gt; 메소드 를 사용하여 자신의 메시지와 벤치 마크를 삽입 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f56860c69fe27414bf6755638a4431e85472b82f" translate="yes" xml:space="preserve">
          <source>You can also inspect for an object method this way:</source>
          <target state="translated">이 방법으로 객체 방법을 검사 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a196ba61623f3e368e72d8a857180d54d954ac0" translate="yes" xml:space="preserve">
          <source>You can also just pass a record. In this case &lt;code&gt;last_modified&lt;/code&gt; will be set by calling &lt;code&gt;updated_at&lt;/code&gt; and &lt;code&gt;etag&lt;/code&gt; by passing the object itself.</source>
          <target state="translated">레코드를 전달할 수도 있습니다. 이 경우 &lt;code&gt;last_modified&lt;/code&gt; 는 객체 자체를 전달하여 &lt;code&gt;updated_at&lt;/code&gt; 및 &lt;code&gt;etag&lt;/code&gt; 를 호출하여 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="b50c687b6a2dbaa84c6efe63f08e4106ed401f6f" translate="yes" xml:space="preserve">
          <source>You can also opt to include controller specific stylesheets and JavaScript files only in their respective controllers using the following:</source>
          <target state="translated">다음을 사용하여 컨트롤러 별 스타일 시트 및 JavaScript 파일을 해당 컨트롤러에만 포함하도록 선택할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b18b32c427d3c94197662a067463e67add60b47" translate="yes" xml:space="preserve">
          <source>You can also override conditions using the &lt;code&gt;only&lt;/code&gt; method. For example:</source>
          <target state="translated">&lt;code&gt;only&lt;/code&gt; 방법을 사용하여 조건을 재정의 할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d3993b132c92af6847ba6c7ada43fe6d1b0a085c" translate="yes" xml:space="preserve">
          <source>You can also pass a &lt;code&gt;:domain&lt;/code&gt; key and specify the domain name for the cookie:</source>
          <target state="translated">&lt;code&gt;:domain&lt;/code&gt; 키를 전달 하고 쿠키의 도메인 이름을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9cf180d42812057ba61bfc06df92eb1978c71311" translate="yes" xml:space="preserve">
          <source>You can also pass a &lt;code&gt;block&lt;/code&gt; to define criteria. The behavior is the same, it returns true if the collection based on the criteria has more than one record.</source>
          <target state="translated">기준을 정의하기 위해 &lt;code&gt;block&lt;/code&gt; 을 전달할 수도 있습니다 . 동작은 동일하며, 기준에 따른 콜렉션에 둘 이상의 레코드가있는 경우 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6baf9d4b879959e98e31186cbf00924d91f717e1" translate="yes" xml:space="preserve">
          <source>You can also pass a &lt;code&gt;block&lt;/code&gt; to define criteria. The behavior is the same, it returns true if the collection based on the criteria is not empty.</source>
          <target state="translated">기준을 정의하기 위해 &lt;code&gt;block&lt;/code&gt; 을 전달할 수도 있습니다 . 동작은 동일하며 기준에 따른 컬렉션이 비어 있지 않으면 true를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c21ece5bd908c31c3f2be9f2b1001f3c36b49b19" translate="yes" xml:space="preserve">
          <source>You can also pass a block that'll be invoked if the retry attempts fail for custom logic rather than letting the exception bubble up. This block is yielded with the job instance as the first and the error instance as the second parameter.</source>
          <target state="translated">예외가 발생하지 않고 사용자 지정 논리에 대해 재 시도에 실패하면 호출 될 블록을 전달할 수도 있습니다. 이 블록은 작업 인스턴스를 첫 번째로, 오류 인스턴스를 두 번째 매개 변수로 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="0501fe5d6ab1d3320eeeda2da4a05d9993faee7a" translate="yes" xml:space="preserve">
          <source>You can also pass a block that'll be invoked. This block is yielded with the job instance as the first and the error instance as the second parameter.</source>
          <target state="translated">호출 될 블록을 전달할 수도 있습니다. 이 블록은 작업 인스턴스를 첫 번째로, 오류 인스턴스를 두 번째 매개 변수로 사용하여 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="fff92d73f44216c865bdaa1c606699f93bde4741" translate="yes" xml:space="preserve">
          <source>You can also pass a block to &lt;code&gt;select&lt;/code&gt; helper:</source>
          <target state="translated">도우미 를 &lt;code&gt;select&lt;/code&gt; 하기 위해 블록을 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4313a70755d30d72528541a84f9eeca66772c4b2" translate="yes" xml:space="preserve">
          <source>You can also pass a block to new with the new record as argument:</source>
          <target state="translated">새로운 레코드를 인자로하여 새로운 블록을 전달할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="79a43cec243528ea2cf7c6c94e59f5de31f9020d" translate="yes" xml:space="preserve">
          <source>You can also pass a custom timestamp column to fetch the timestamp of the last updated record.</source>
          <target state="translated">사용자 정의 타임 스탬프 열을 전달하여 마지막으로 업데이트 된 레코드의 타임 스탬프를 가져올 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a98a0f5b62680df505995dca24e4aad954506e3" translate="yes" xml:space="preserve">
          <source>You can also pass a hash into headers of header field names and values, which will then be set on the &lt;code&gt;Mail::Message&lt;/code&gt; object:</source>
          <target state="translated">또한 헤더 필드 이름 및 값의 헤더에 해시를 전달하면 &lt;code&gt;Mail::Message&lt;/code&gt; 객체 에 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="f43fca077e4d9ba19cde93b566514754dd4884cd" translate="yes" xml:space="preserve">
          <source>You can also pass a list of modules:</source>
          <target state="translated">모듈 목록을 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d93eb78b9fb417baad45b38f4deca34422d60cc" translate="yes" xml:space="preserve">
          <source>You can also pass a string which will expand</source>
          <target state="translated">확장 할 문자열을 전달할 수도 있습니다</target>
        </trans-unit>
        <trans-unit id="209e9c75edede5883cce7550ebfa07c635ca4bf4" translate="yes" xml:space="preserve">
          <source>You can also pass an explicit status number like &lt;code&gt;assert_response(501)&lt;/code&gt; or its symbolic equivalent &lt;code&gt;assert_response(:not_implemented)&lt;/code&gt;. See Rack::Utils::SYMBOL_TO_STATUS_CODE for a full list.</source>
          <target state="translated">&lt;code&gt;assert_response(501)&lt;/code&gt; 와 같은 명시 적 상태 번호 또는 해당 기호 인 &lt;code&gt;assert_response(:not_implemented)&lt;/code&gt; . 전체 목록은 Rack :: Utils :: SYMBOL_TO_STATUS_CODE를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2d53d25fc9a44c25a3710b625ff3e7c994b643bb" translate="yes" xml:space="preserve">
          <source>You can also pass an object that responds to &lt;code&gt;maximum&lt;/code&gt;, such as a collection of active records. In this case &lt;code&gt;last_modified&lt;/code&gt; will be set by calling +maximum(:updated_at)+ on the collection (the timestamp of the most recently updated record) and the &lt;code&gt;etag&lt;/code&gt; by passing the object itself.</source>
          <target state="translated">활성 레코드 콜렉션과 같이 &lt;code&gt;maximum&lt;/code&gt; 에 응답하는 오브젝트를 전달할 수도 있습니다 . 이 경우 컬렉션 (가장 최근 업데이트 된 레코드의 타임 스탬프)에서 + maximum (: updated_at) +를 호출 하고 객체 자체를 전달하여 &lt;code&gt;etag&lt;/code&gt; 를 호출하여 &lt;code&gt;last_modified&lt;/code&gt; 를 설정 합니다.</target>
        </trans-unit>
        <trans-unit id="9e7634f61ad481b47ab734c9d2b303d881ea2183" translate="yes" xml:space="preserve">
          <source>You can also pass an object that responds to &lt;code&gt;maximum&lt;/code&gt;, such as a collection of active records. In this case &lt;code&gt;last_modified&lt;/code&gt; will be set by calling &lt;code&gt;maximum(:updated_at)&lt;/code&gt; on the collection (the timestamp of the most recently updated record) and the &lt;code&gt;etag&lt;/code&gt; by passing the object itself.</source>
          <target state="translated">활성 레코드 콜렉션과 같이 &lt;code&gt;maximum&lt;/code&gt; 에 응답하는 오브젝트를 전달할 수도 있습니다 . 이 경우 &lt;code&gt;last_modified&lt;/code&gt; 는 컬렉션 (가장 최근 업데이트 된 레코드의 타임 스탬프 &lt;code&gt;maximum(:updated_at)&lt;/code&gt; 에서 최대 (: updated_at ) 및 개체 자체를 전달하여 &lt;code&gt;etag&lt;/code&gt; 를 호출하여 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="29be9a263ab7fab349c724884b9de5bbb03232d5" translate="yes" xml:space="preserve">
          <source>You can also pass in &lt;code&gt;extras&lt;/code&gt; with a hash containing URL parameters that would normally be in the query string. This can be used to assert that values in the query string will end up in the params hash correctly. To test query strings you must use the extras argument because appending the query string on the path directly will not work. For example:</source>
          <target state="translated">또한 일반적으로 쿼리 문자열에있는 URL 매개 변수를 포함하는 해시 로 &lt;code&gt;extras&lt;/code&gt; 를 전달할 수도 있습니다. 쿼리 문자열의 값이 매개 변수 해시로 올바르게 종료되도록하는 데 사용할 수 있습니다. 쿼리 문자열을 테스트하려면 경로에 쿼리 문자열을 직접 추가 할 수 없으므로 extras 인수를 사용해야합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f920d50aebb2023a001843bd9c8e9d6a099f794b" translate="yes" xml:space="preserve">
          <source>You can also pass in a &lt;code&gt;layout: 'layout_name'&lt;/code&gt; option to the render call inside the format block to specify different layouts for different formats:</source>
          <target state="translated">당신은 또한에 전달할 수 있습니다 &lt;code&gt;layout: 'layout_name'&lt;/code&gt; 포맷 블록 내부 렌더링 호출에 대한 옵션을 다른 형식에 대해 서로 다른 레이아웃을 지정합니다 :</target>
        </trans-unit>
        <trans-unit id="66d61247ce60750666d639f74ffe19c2e7082fcc" translate="yes" xml:space="preserve">
          <source>You can also pass in a TimeZone instance or string that identifies a TimeZone as an argument, and the conversion will be based on that zone instead of &lt;code&gt;Time.zone&lt;/code&gt;.</source>
          <target state="translated">TimeZone을 인수로 식별하는 TimeZone 인스턴스 또는 문자열을 전달할 수도 있으며 변환은 &lt;code&gt;Time.zone&lt;/code&gt; 대신 해당 영역을 기반으로합니다 .</target>
        </trans-unit>
        <trans-unit id="ebae0cf64e77b402dfd54b9959c63099713def81" translate="yes" xml:space="preserve">
          <source>You can also pass in arbitrary local variables to any partial you are rendering with the &lt;code&gt;locals: {}&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;locals: {}&lt;/code&gt; 옵션을 사용하여 렌더링하는 부분에 임의의 로컬 변수를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db6035b2dd4919f23c4755c517b6757a348a84ca" translate="yes" xml:space="preserve">
          <source>You can also pass local variables into partials, making them even more powerful and flexible. For example, you can use this technique to reduce duplication between new and edit pages, while still keeping a bit of distinct content:</source>
          <target state="translated">지역 변수를 부분으로 전달하여 더욱 강력하고 유연하게 만들 수 있습니다. 예를 들어,이 기술을 사용하면 약간의 고유 한 내용을 유지하면서 새 페이지와 편집 페이지 간의 중복을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2f2ee18d426772792cd120169d8df3f9057ce3" translate="yes" xml:space="preserve">
          <source>You can also pass raw SQL to the &lt;code&gt;lock&lt;/code&gt; method for allowing different types of locks. For example, MySQL has an expression called &lt;code&gt;LOCK IN SHARE MODE&lt;/code&gt; where you can lock a record but still allow other queries to read it. To specify this expression just pass it in as the lock option:</source>
          <target state="translated">다른 유형의 잠금을 허용하기 위해 원시 SQL을 &lt;code&gt;lock&lt;/code&gt; 방법으로 전달할 수도 있습니다 . 예를 들어, MySQL에는 &lt;code&gt;LOCK IN SHARE MODE&lt;/code&gt; 라는 표현식이 있어 레코드를 잠글 수는 있지만 다른 쿼리는 읽을 수 있습니다. 이 표현식을 지정하려면 잠금 옵션으로 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="132a865d7487f8497b1030ddd091e025e2dd54c3" translate="yes" xml:space="preserve">
          <source>You can also perform actions:</source>
          <target state="translated">작업을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="590fee298a51c66ae56d2099ae9e59d8b8170162" translate="yes" xml:space="preserve">
          <source>You can also provide a block to redirect, which receives the symbolized path parameters and the request object:</source>
          <target state="translated">또한 경로를 재 지정할 블록을 제공 할 수 있습니다.이 블록은 기호화 된 경로 매개 변수와 요청 오브젝트를 수신합니다.</target>
        </trans-unit>
        <trans-unit id="f0b26e26a654f7e037a1212c67c8dace8ce0149f" translate="yes" xml:space="preserve">
          <source>You can also provide a proc or lambda which will determine the regular expression that will be used to validate the attribute.</source>
          <target state="translated">속성의 유효성을 검사하는 데 사용될 정규식을 결정하는 proc 또는 lambda를 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="de1432b2b24086ab6f185d0eec31428e1c8a1f01" translate="yes" xml:space="preserve">
          <source>You can also remove the uniqueness constraint:</source>
          <target state="translated">고유성 제한 조건을 제거 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f42c641f7b164df35d8d45e59a74903d8a3f747f" translate="yes" xml:space="preserve">
          <source>You can also render a block of code within a partial layout instead of calling &lt;code&gt;yield&lt;/code&gt;. For example, if we didn't have the &lt;code&gt;_article&lt;/code&gt; partial, we could do this instead:</source>
          <target state="translated">&lt;code&gt;yield&lt;/code&gt; 를 호출하는 대신 부분 레이아웃 내에서 코드 블록을 렌더링 할 수도 있습니다 . 예를 들어 &lt;code&gt;_article&lt;/code&gt; 부분 이없는 경우 대신 다음과 같이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67a51086fa97dc2d553d0adb9a201101a177590" translate="yes" xml:space="preserve">
          <source>You can also reuse dynamic segments from the match in the path to redirect to:</source>
          <target state="translated">경로에서 일치하는 동적 세그먼트를 재사용하여 다음으로 리디렉션 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b991c91a277c514d5e0978c34b83f94fa207adc2" translate="yes" xml:space="preserve">
          <source>You can also run a particular test method from the test case by providing the &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;--name&lt;/code&gt; flag and the test's method name.</source>
          <target state="translated">&lt;code&gt;-n&lt;/code&gt; 또는 &lt;code&gt;--name&lt;/code&gt; 플래그와 테스트의 메소드 이름 을 제공하여 테스트 케이스에서 특정 테스트 메소드를 실행할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb1f3ba141b2b9bdb8b3eb3637f73d9ae4ed5132" translate="yes" xml:space="preserve">
          <source>You can also run a test at a specific line by providing the line number.</source>
          <target state="translated">줄 번호를 제공하여 특정 줄에서 테스트를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4a43c37df8c7049f8ac2597eb7d63e4d215adaa" translate="yes" xml:space="preserve">
          <source>You can also run an entire directory of tests by providing the path to the directory.</source>
          <target state="translated">디렉토리 경로를 제공하여 전체 테스트 디렉토리를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c63351a3fb2ee629a636054253a9c980aa4028b" translate="yes" xml:space="preserve">
          <source>You can also run commands as a super-user:</source>
          <target state="translated">수퍼 유저로 명령을 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f67d5cd3fc082a416e6fc456577d184242964fa" translate="yes" xml:space="preserve">
          <source>You can also run commands that should abort application generation if they fail:</source>
          <target state="translated">실패 할 경우 응용 프로그램 생성을 중단해야하는 명령을 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba3dd417e4d836a4b8b1b039178daec1f8de48fa" translate="yes" xml:space="preserve">
          <source>You can also run commands with a different Rails environment:</source>
          <target state="translated">다른 Rails 환경에서 명령을 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e6f8b9f6619e938f72d4a81883a4ff108fac07b" translate="yes" xml:space="preserve">
          <source>You can also run these validations on your own. &lt;code&gt;valid?&lt;/code&gt; triggers your validations and returns true if no errors were found in the object, and false otherwise. As you saw above:</source>
          <target state="translated">이러한 유효성 검사를 직접 실행할 수도 있습니다. &lt;code&gt;valid?&lt;/code&gt; 유효성 검사를 트리거하고 개체에 오류가 없으면 true를 반환하고 그렇지 않으면 false를 반환합니다. 위에서 본 것처럼 :</target>
        </trans-unit>
        <trans-unit id="8ea7e508bc95dcc7fedf898a58f2e9c1b9ad6e52" translate="yes" xml:space="preserve">
          <source>You can also search for specific attachments:</source>
          <target state="translated">특정 첨부 파일을 검색 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6272c94e85052b06e6bd54184729336b0d3af9" translate="yes" xml:space="preserve">
          <source>You can also send a real document in the simulated HTTP request.</source>
          <target state="translated">시뮬레이션 된 HTTP 요청으로 실제 문서를 보낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a766289f7f4f88b39de99bcafb2f1d87f6841bdd" translate="yes" xml:space="preserve">
          <source>You can also send attachments with html template, in this case you need to add body, attachments, and custom content type like this:</source>
          <target state="translated">html 템플릿으로 첨부 파일을 보낼 수도 있습니다.이 경우 다음과 같이 본문, 첨부 파일 및 사용자 정의 컨텐츠 유형을 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="bf0a19674ee940990d8674527db7a7688a6f84ee" translate="yes" xml:space="preserve">
          <source>You can also set a plural form for model names, adding as following:</source>
          <target state="translated">다음과 같이 모델 이름에 복수형을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="715ccf3361589bd5c0d2a7c7dca850eb0c1a28f1" translate="yes" xml:space="preserve">
          <source>You can also set an array of variants:</source>
          <target state="translated">변형의 배열을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c730e8f957a06d38c9526358ce28efc0881674df" translate="yes" xml:space="preserve">
          <source>You can also set conditions via a hash:</source>
          <target state="translated">해시를 통해 조건을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6c1b2b2dc80c4154aa342904f384963a609b2537" translate="yes" xml:space="preserve">
          <source>You can also set generators for an application by using &lt;code&gt;config.app_generators&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;config.app_generators&lt;/code&gt; 를 사용하여 애플리케이션의 생성기를 설정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1dbf53c72db486b6b8e9b821c247e6d7be65923c" translate="yes" xml:space="preserve">
          <source>You can also set the answer format, like this:</source>
          <target state="translated">다음과 같이 답변 형식을 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="16aae775fd6bff2c114b0b20512f42918057f86a" translate="yes" xml:space="preserve">
          <source>You can also set the strong ETag directly on the response.</source>
          <target state="translated">응답에 직접 강력한 ETag를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0372b2526ba8649df791ef01acb1453abf3d7a25" translate="yes" xml:space="preserve">
          <source>You can also set this value through an &lt;a href=&quot;https://en.wikipedia.org/wiki/Environment_variable&quot;&gt;environment variable&lt;/a&gt; to make running a staging copy of your site easier:</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/Environment_variable&quot;&gt;환경 변수&lt;/a&gt; 를 통해이 값을 설정 하여 사이트의 준비 복사본을보다 쉽게 ​​실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23449d1901273fcaa52068821e1371d0230c3d86" translate="yes" xml:space="preserve">
          <source>You can also set your own table name explicitly:</source>
          <target state="translated">고유 한 테이블 이름을 명시 적으로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="776004ce3cb1710499a9ebf689b4de69eafba0c7" translate="yes" xml:space="preserve">
          <source>You can also setup the correct cookies before the connection request:</source>
          <target state="translated">연결 요청 전에 올바른 쿠키를 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9c1c7dec54552772c6a5b19a0d0eac90be289b2" translate="yes" xml:space="preserve">
          <source>You can also simulate POST, PATCH, PUT, DELETE, and HEAD requests with &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;patch&lt;/code&gt;, &lt;code&gt;put&lt;/code&gt;, &lt;code&gt;delete&lt;/code&gt;, and &lt;code&gt;head&lt;/code&gt;. Example sending parameters, session and setting a flash message:</source>
          <target state="translated">&lt;code&gt;post&lt;/code&gt; , &lt;code&gt;patch&lt;/code&gt; , &lt;code&gt;put&lt;/code&gt; , &lt;code&gt;delete&lt;/code&gt; 및 &lt;code&gt;head&lt;/code&gt; 를 사용하여 POST, PATCH, PUT, DELETE 및 HEAD 요청을 시뮬레이션 할 수도 있습니다 . 매개 변수 전송, 세션 및 플래시 메시지 설정 예 :</target>
        </trans-unit>
        <trans-unit id="36b331ab104931667aeae850a2006daf7d3deed4" translate="yes" xml:space="preserve">
          <source>You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a descendant of a class not in the hierarchy.</source>
          <target state="translated">직렬화 된 개체가 계층 구조에없는 클래스의 하위 항목으로 검색되는 경우 예외를 발생시키는 두 번째 매개 변수로 클래스 옵션을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e9413235bf821650089a7445acc32a2b9205dc6" translate="yes" xml:space="preserve">
          <source>You can also specify a second partial to be rendered between instances of the main partial by using the &lt;code&gt;:spacer_template&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:spacer_template&lt;/code&gt; 옵션 을 사용하여 기본 부분의 인스턴스간에 렌더링 할 두 번째 부분을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9c3450dcdb2e38894297c7236338d823b576bfb" translate="yes" xml:space="preserve">
          <source>You can also specify a special size tag, in the format &quot;{width}x{height}&quot;:</source>
          <target state="translated">&quot;{width} x {height}&quot;형식으로 특수 크기 태그를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ee137f246c4187c500992f6e71c27b6b6d8171d" translate="yes" xml:space="preserve">
          <source>You can also specify constraints as a lambda:</source>
          <target state="translated">제약 조건을 람다로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d07485265f7717ffc7169dcbe4001b3c51f9720c" translate="yes" xml:space="preserve">
          <source>You can also specify constraints in a block form:</source>
          <target state="translated">블록 형식으로 제약 조건을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7477fab244a2741c739a797cdf4558b740c66b2" translate="yes" xml:space="preserve">
          <source>You can also specify default options that will be passed through to your URL helper definition, e.g:</source>
          <target state="translated">다음과 같이 URL 도우미 정의로 전달 될 기본 옵션을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc7a629d30ae40fc90f9cd416e9b95c7f65270b4" translate="yes" xml:space="preserve">
          <source>You can also specify multiple relationships, like this:</source>
          <target state="translated">다음과 같이 여러 관계를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a0140d14bc466ff6029568a59cb2b6a547a84f2d" translate="yes" xml:space="preserve">
          <source>You can also specify multiple videos to play by passing an array of videos to the &lt;code&gt;video_tag&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;video_tag&lt;/code&gt; 에 비디오 배열을 전달하여 재생할 여러 개의 비디오를 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06d63b4b10be5f66849142a8644b81381e44c795" translate="yes" xml:space="preserve">
          <source>You can also specify overrides if you want by passing a hash instead of a string:</source>
          <target state="translated">문자열 대신 해시를 전달하여 원하는 경우 재정의를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="db40d0ab564c2206fc43120faa6e242195b34334" translate="yes" xml:space="preserve">
          <source>You can also specify request cookies the same way you do in integration tests:</source>
          <target state="translated">통합 테스트에서와 동일한 방식으로 요청 쿠키를 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6fdd32d2675e9a8470b09e6c3dde90acf66b88b0" translate="yes" xml:space="preserve">
          <source>You can also specify that a file should be displayed inline with other HTML. This is useful if you want to display a corporate logo or a photo.</source>
          <target state="translated">파일을 다른 HTML과 함께 인라인으로 표시하도록 지정할 수도 있습니다. 회사 로고나 사진을 표시하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="3b7c90d8ebf506f5bc5206ab82f3f1b6876c14ad" translate="yes" xml:space="preserve">
          <source>You can also specify that only &lt;code&gt;datetime&lt;/code&gt; columns should be time-zone aware (while &lt;code&gt;time&lt;/code&gt; should not) by setting:</source>
          <target state="translated">다음을 설정하여 &lt;code&gt;datetime&lt;/code&gt; 열만 시간대를 인식하도록 ( &lt;code&gt;time&lt;/code&gt; 은 인식 하지 않아야 함) 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b95162d698781f81ee81baea4c88546fff4da27e" translate="yes" xml:space="preserve">
          <source>You can also specify the key in which the parameters should be wrapped to, and also the list of attributes it should wrap by using either &lt;code&gt;:include&lt;/code&gt; or &lt;code&gt;:exclude&lt;/code&gt; options like this:</source>
          <target state="translated">&lt;code&gt;:include&lt;/code&gt; 과 같이 : include 또는 &lt;code&gt;:exclude&lt;/code&gt; 옵션 을 사용하여 매개 변수를 랩핑 할 키와 랩핑해야하는 속성 목록을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="04a65c9acb4d2e4854a1519e24000c89dda85b96" translate="yes" xml:space="preserve">
          <source>You can also specify the underlying connection identifiers. Here's an example test with a web notifications channel:</source>
          <target state="translated">기본 연결 식별자를 지정할 수도 있습니다. 웹 알림 채널을 사용한 테스트 예제는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4ae45a3047876964edbdb6eaa4ec016894b8b89f" translate="yes" xml:space="preserve">
          <source>You can also specify these assets as dependencies of other assets using Asset Pipeline require statements in processed files:</source>
          <target state="translated">처리 된 파일의 Asset Pipeline require 문을 사용하여 이러한 자산을 다른 자산의 종속성으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3eb089951c69a1ce81a14ee287acca750daa1673" translate="yes" xml:space="preserve">
          <source>You can also specify validations to be strict and raise &lt;code&gt;ActiveModel::StrictValidationFailed&lt;/code&gt; when the object is invalid.</source>
          <target state="translated">개체가 유효하지 않은 경우 유효성 검사를 엄격하게 지정하고 &lt;code&gt;ActiveModel::StrictValidationFailed&lt;/code&gt; 발생 시킬 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="97e11679f83fc9677da8c27421a9a165b179799c" translate="yes" xml:space="preserve">
          <source>You can also step into &lt;strong&gt;irb&lt;/strong&gt; mode with the command &lt;code&gt;irb&lt;/code&gt; (of course!). This will start an irb session within the context you invoked it.</source>
          <target state="translated">또한 한 단계 수 &lt;strong&gt;IRB&lt;/strong&gt; 명령과 모드 &lt;code&gt;irb&lt;/code&gt; (물론!). 그러면 호출 한 컨텍스트 내에서 irb 세션이 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="b77c42c9439512b16428192029c489fb37eb214f" translate="yes" xml:space="preserve">
          <source>You can also style the HTML used for embedded images and other attachments (known as blobs). On installation, Action Text will copy over a partial to &lt;code&gt;app/views/active_storage/blobs/_blob.html.erb&lt;/code&gt;, which you can specialize.</source>
          <target state="translated">포함 된 이미지 및 기타 첨부 파일 (blob)에 사용되는 HTML의 스타일을 지정할 수도 있습니다. 설치시 동작 텍스트는 부분적으로 &lt;code&gt;app/views/active_storage/blobs/_blob.html.erb&lt;/code&gt; 로 복사되며 , 전문화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166af9c392b94d2fe5501876b08a71f8e22ca4bf" translate="yes" xml:space="preserve">
          <source>You can also subscribe to all events whose name matches a certain regexp:</source>
          <target state="translated">이름이 특정 정규 표현식과 일치하는 모든 이벤트를 구독 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c250096cd75c7ef74e25db63acf224a337447f82" translate="yes" xml:space="preserve">
          <source>You can also supply a block to &lt;a href=&quot;base#method-c-hook_for&quot;&gt;::hook_for&lt;/a&gt; to customize how the hook is going to be invoked. The block receives two arguments, an instance of the current class and the class to be invoked.</source>
          <target state="translated">&lt;a href=&quot;base#method-c-hook_for&quot;&gt;:: hook_for&lt;/a&gt; 에 블록을 제공 하여 후크 호출 방법을 사용자 정의 할 수도 있습니다. 이 블록은 현재 클래스의 인스턴스와 호출 할 클래스의 두 가지 인수를받습니다.</target>
        </trans-unit>
        <trans-unit id="0411251e2e7fb3e3c16245191c68d564a416891e" translate="yes" xml:space="preserve">
          <source>You can also supply a hash of additional options, such as &lt;code&gt;:id&lt;/code&gt;, &lt;code&gt;:class&lt;/code&gt; etc.</source>
          <target state="translated">&lt;code&gt;:id&lt;/code&gt; , &lt;code&gt;:class&lt;/code&gt; 등과 같은 추가 옵션의 해시를 제공 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be664cec1255cb066942bb0eec18ff4b192560ab" translate="yes" xml:space="preserve">
          <source>You can also supply an array of &lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport::TimeZone&lt;/a&gt; objects as &lt;code&gt;priority_zones&lt;/code&gt; so that they will be listed above the rest of the (long) list. You can use &lt;a href=&quot;../../activesupport/timezone#method-c-us_zones&quot;&gt;ActiveSupport::TimeZone.us_zones&lt;/a&gt; for a list of US time zones, &lt;a href=&quot;../../activesupport/timezone#method-c-country_zones&quot;&gt;ActiveSupport::TimeZone.country_zones&lt;/a&gt; for another country's time zones, or a Regexp to select the zones of your choice.</source>
          <target state="translated">&lt;a href=&quot;../../activesupport/timezone&quot;&gt;ActiveSupport :: TimeZone&lt;/a&gt; 객체 배열을 &lt;code&gt;priority_zones&lt;/code&gt; 로 제공 하여 나머지 (긴) 목록 위에 나열되도록 할 수도 있습니다. 당신이 사용할 수있는 &lt;a href=&quot;../../activesupport/timezone#method-c-us_zones&quot;&gt;ActiveSupport :: TimeZone.us_zones을&lt;/a&gt; 미국 시간대의 목록을 &lt;a href=&quot;../../activesupport/timezone#method-c-country_zones&quot;&gt;ActiveSupport :: TimeZone.country_zones&lt;/a&gt; 원하는 영역을 선택하기 위해 다른 국가의 시간대에, 또는 정규 표현식.</target>
        </trans-unit>
        <trans-unit id="16f8ee178035336d88c5be576f79d71723abc79a" translate="yes" xml:space="preserve">
          <source>You can also tell Rails to render with no layout at all:</source>
          <target state="translated">레이아웃이 전혀없이 렌더링하도록 Rails에 지시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1364f32148f35d02e816485f91106ef0cb1f9961" translate="yes" xml:space="preserve">
          <source>You can also test your JSON API easily by setting what the request should be encoded as:</source>
          <target state="translated">요청을 인코딩 할 대상을 다음과 같이 설정하여 JSON API를 쉽게 테스트 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="857477a5f408eb0b0349fbc54197727992440396" translate="yes" xml:space="preserve">
          <source>You can also unscope specific &lt;code&gt;where&lt;/code&gt; clauses. For example:</source>
          <target state="translated">특정 &lt;code&gt;where&lt;/code&gt; 절을 범위 지정하지 않을 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1c530f519aa65e34eac958ec7e04f3214125bff6" translate="yes" xml:space="preserve">
          <source>You can also unsubscribe by passing the name of the subscriber object. Note that this will unsubscribe all subscriptions with the given name:</source>
          <target state="translated">구독자 개체의 이름을 전달하여 구독을 취소 할 수도 있습니다. 이렇게하면 지정된 이름의 구독을 모두 구독 취소합니다.</target>
        </trans-unit>
        <trans-unit id="74c85e567de84e338e0fed11d2582027ee791b67" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;ActiveRecord::Base#lock!&lt;/code&gt; method to lock one record by id. This may be better if you don't need to lock every row. Example:</source>
          <target state="translated">&lt;code&gt;ActiveRecord::Base#lock!&lt;/code&gt; 사용할 수도 있습니다 . ID별로 하나의 레코드를 잠그는 방법. 모든 행을 잠글 필요가없는 경우이 방법이 더 좋습니다. 예:</target>
        </trans-unit>
        <trans-unit id="1fb9bf2806c04d58a7f858a30f479945a52c7fa3" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;Rails::Application.config_for&lt;/code&gt; to load whole configuration files:</source>
          <target state="translated">&lt;code&gt;Rails::Application.config_for&lt;/code&gt; 를 사용 하여 전체 구성 파일을로드 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="376742689162ca42aa8bdd2630287e481cc17f27" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;any?&lt;/code&gt; and &lt;code&gt;many?&lt;/code&gt; to check for existence on a model or relation.</source>
          <target state="translated">&lt;code&gt;any?&lt;/code&gt; 것도 사용할 수 있습니까? 그리고 &lt;code&gt;many?&lt;/code&gt; 모델이나 관계에 존재하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="b2ca66a882b0df25a870e950e134fcfef1b77c7d" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;defaults&lt;/code&gt; in a block format to define the defaults for multiple items:</source>
          <target state="translated">당신은 또한 사용할 수있는 &lt;code&gt;defaults&lt;/code&gt; 여러 항목에 대한 기본값을 정의하는 블록 형식 :</target>
        </trans-unit>
        <trans-unit id="3bdea88e37bb457c03492c50407f33ea9ccb1fcf" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;display&lt;/code&gt; to start watching variables. This is a good way of tracking the values of a variable while the execution goes on.</source>
          <target state="translated">&lt;code&gt;display&lt;/code&gt; 를 사용 하여 변수 시청을 시작할 수도 있습니다 . 이것은 실행이 진행되는 동안 변수의 값을 추적하는 좋은 방법입니다.</target>
        </trans-unit>
        <trans-unit id="01dc3fcf5b4d877cb46da0a4f1b22aeb6d872f1e" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;find_or_create_by!&lt;/code&gt; to raise an exception if the new record is invalid. Validations are not covered on this guide, but let's assume for a moment that you temporarily add</source>
          <target state="translated">&lt;code&gt;find_or_create_by!&lt;/code&gt; 사용할 수도 있습니다 ! 새 레코드가 유효하지 않은 경우 예외를 발생시킵니다. 유효성 검사는이 가이드에서 다루지 않지만 일시적으로 추가한다고 가정하겠습니다.</target>
        </trans-unit>
        <trans-unit id="2a8ddfbf085cd03a6387055f882f25a25ec922d9" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;on:&lt;/code&gt; to define custom contexts. Custom contexts need to be triggered explicitly by passing the name of the context to &lt;code&gt;valid?&lt;/code&gt;, &lt;code&gt;invalid?&lt;/code&gt;, or &lt;code&gt;save&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;on:&lt;/code&gt; 을 사용 하여 사용자 정의 컨텍스트를 정의 할 수도 있습니다 . 컨텍스트의 이름을 &lt;code&gt;valid?&lt;/code&gt; 에 전달하여 사용자 정의 컨텍스트를 명시 적으로 트리거해야 합니까? , &lt;code&gt;invalid?&lt;/code&gt; 또는 &lt;code&gt;save&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="798d14d81fef8d6387558ac3e22c6665496da57a" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;permit&lt;/code&gt; on nested parameters, like:</source>
          <target state="translated">다음 과 같이 중첩 매개 변수에 &lt;code&gt;permit&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1b300e43434a2a985b21245d5d8b7dec5ba2ca0" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;silence_redefinition_of_method&lt;/code&gt; if you need to define the replacement method yourself (because you're using &lt;code&gt;delegate&lt;/code&gt;, for example).</source>
          <target state="translated">예를 들어 &lt;code&gt;delegate&lt;/code&gt; 를 사용하기 때문에 대체 방법을 직접 정의해야하는 경우 &lt;code&gt;silence_redefinition_of_method&lt;/code&gt; 를 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cb7a9bbc2d13a338c3f24ed856d5f1ff4c719b8e" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;step n&lt;/code&gt; or &lt;code&gt;next n&lt;/code&gt; to move forward &lt;code&gt;n&lt;/code&gt; steps at once.</source>
          <target state="translated">&lt;code&gt;step n&lt;/code&gt; 또는 &lt;code&gt;next n&lt;/code&gt; 을 사용하여 &lt;code&gt;n&lt;/code&gt; 단계를 한 번에 앞으로 이동할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5776bf51bcfbda9d5f8a70fcc375aa18d7610b5b" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;up [n]&lt;/code&gt; and &lt;code&gt;down [n]&lt;/code&gt; commands in order to change the context &lt;em&gt;n&lt;/em&gt; frames up or down the stack respectively. &lt;em&gt;n&lt;/em&gt; defaults to one. Up in this case is towards higher-numbered stack frames, and down is towards lower-numbered stack frames.</source>
          <target state="translated">또한 사용할 수 &lt;code&gt;up [n]&lt;/code&gt; 및 &lt;code&gt;down [n]&lt;/code&gt; 컨텍스트 변경하기 위해 명령 &lt;em&gt;N&lt;/em&gt; 위 또는 아래에 각각의 스택 프레임. &lt;em&gt;n은&lt;/em&gt; 기본적으로 1입니다. 이 경우 위로 번호가 높은 스택 프레임을 향하고 아래로 번호가 낮은 스택 프레임을 향합니다.</target>
        </trans-unit>
        <trans-unit id="46ab236e1334cd78dc5de23bfcc864a4cee8e826" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;url_for&lt;/code&gt; with a set of objects, and Rails will automatically determine which route you want:</source>
          <target state="translated">&lt;code&gt;url_for&lt;/code&gt; 를 일련의 객체와 함께 사용할 수도 있으며 Rails는 원하는 경로를 자동으로 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d4b1b3d12a44ac21ab78c04347d37a0c632abad9" translate="yes" xml:space="preserve">
          <source>You can also use a block and a module list:</source>
          <target state="translated">블록과 모듈 목록을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5b9df811266c3568baee5b2090fdb96d6b9b1ae" translate="yes" xml:space="preserve">
          <source>You can also use block initialization:</source>
          <target state="translated">블록 초기화를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a78c1f1b35988f66b88ef3c9ee5c73db28240db" translate="yes" xml:space="preserve">
          <source>You can also use custom data attributes using the &lt;code&gt;:data&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:data&lt;/code&gt; 옵션을 사용하여 사용자 정의 데이터 속성을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f873b2963d942e169acfeed102ba49b3a45d80e3" translate="yes" xml:space="preserve">
          <source>You can also use custom deprecator instance:</source>
          <target state="translated">커스텀 디 프리 케이 터 인스턴스를 사용할 수도 있습니다 :</target>
        </trans-unit>
        <trans-unit id="0ee81600746fa33192478e72fc19b0485800bf5b" translate="yes" xml:space="preserve">
          <source>You can also use interpolation in the supplied redirect argument:</source>
          <target state="translated">제공된 리디렉션 인수에 보간을 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3a949acc50ee07f71dfe1c3d1a9a7df6af4d92d" translate="yes" xml:space="preserve">
          <source>You can also use nested &lt;code&gt;assert_select&lt;/code&gt; blocks for deeper investigation.</source>
          <target state="translated">더 자세한 조사를 위해 중첩 된 &lt;code&gt;assert_select&lt;/code&gt; 블록을 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1aa77e14e25818ca57c4d6a138eb30cb71b0d1f" translate="yes" xml:space="preserve">
          <source>You can also use one or more strings, which will be used unchanged as SELECT fields.</source>
          <target state="translated">하나 이상의 문자열을 사용할 수도 있습니다.이 문자열은 변경되지 않고 SELECT 필드로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="546f4d7f3d470c9a8e44a9a1712c56852f1e99d2" translate="yes" xml:space="preserve">
          <source>You can also use root inside namespaces and scopes as well. For example:</source>
          <target state="translated">네임 스페이스 및 범위 내에서 루트를 사용할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f4bba1385e41da00275e6987fca5d06e86cbafa3" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;--expanded&lt;/code&gt; option to turn on the expanded table formatting mode.</source>
          <target state="translated">&lt;code&gt;--expanded&lt;/code&gt; 옵션을 사용 하여 확장 테이블 포맷 모드를 켤 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="209817d7b5228179eee9a35e952fb789e45fc6f3" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;yield&lt;/code&gt; syntax alongside an existing call to &lt;code&gt;yield&lt;/code&gt; in a layout. For example:</source>
          <target state="translated">레이아웃에서 &lt;code&gt;yield&lt;/code&gt; 를 생성 하기 위해 기존 호출과 함께 &lt;code&gt;yield&lt;/code&gt; 구문을 사용할 수도 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="38666886312c85ce5bfbb02b67c2ae3e0a8c2f66" translate="yes" xml:space="preserve">
          <source>You can also use the alias &quot;c&quot; to invoke the console: &lt;code&gt;rails c&lt;/code&gt;.</source>
          <target state="translated">별명 &quot;c&quot;를 사용하여 콘솔을 호출 할 수도 있습니다. &lt;code&gt;rails c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30aedf584e03771957030a796b2072657e6228a8" translate="yes" xml:space="preserve">
          <source>You can also use the alias &quot;d&quot; to invoke the destroy command: &lt;code&gt;rails d&lt;/code&gt;.</source>
          <target state="translated">별명 &quot;d&quot;를 사용하여 destroy 명령을 실행할 수도 있습니다. &lt;code&gt;rails d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aef1060eaef6f25939de4a3fab949737bf4022c3" translate="yes" xml:space="preserve">
          <source>You can also use the alias &quot;db&quot; to invoke the dbconsole: &lt;code&gt;rails db&lt;/code&gt;.</source>
          <target state="translated">별명 &quot;db&quot;를 사용하여 dbconsole을 호출 할 수도 있습니다. &lt;code&gt;rails db&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2fa942ecc22150d810a33b2aaf8d2052f3efab" translate="yes" xml:space="preserve">
          <source>You can also use the alias &quot;g&quot; to invoke the generator command: &lt;code&gt;rails g&lt;/code&gt;.</source>
          <target state="translated">별명 &quot;g&quot;를 사용하여 generator 명령을 실행할 수도 있습니다 : &lt;code&gt;rails g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="344c94763138c637a6092f3a5717c1535de4dc5f" translate="yes" xml:space="preserve">
          <source>You can also use the alias &quot;r&quot; to invoke the runner: &lt;code&gt;rails r&lt;/code&gt;.</source>
          <target state="translated">별명 &quot;r&quot;을 사용하여 러너를 호출 할 수도 있습니다. &lt;code&gt;rails r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48c4755ce9f45974388a3057fb100cf7db02d225" translate="yes" xml:space="preserve">
          <source>You can also use the alias &quot;s&quot; to start the server: &lt;code&gt;rails s&lt;/code&gt;.</source>
          <target state="translated">별명 &quot;s&quot;를 사용하여 서버를 시작할 수도 있습니다 : &lt;code&gt;rails s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0589455e3535ba6187b99f8f3b071711442fd268" translate="yes" xml:space="preserve">
          <source>You can also use the method &lt;code&gt;create_join_table&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;create_join_table&lt;/code&gt; 메소드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="06481cd97b342b15a9d4e07a3174ee03ea54afe7" translate="yes" xml:space="preserve">
          <source>You can also use the old style of migration using &lt;code&gt;up&lt;/code&gt; and &lt;code&gt;down&lt;/code&gt; methods instead of the &lt;code&gt;change&lt;/code&gt; method. The &lt;code&gt;up&lt;/code&gt; method should describe the transformation you'd like to make to your schema, and the &lt;code&gt;down&lt;/code&gt; method of your migration should revert the transformations done by the &lt;code&gt;up&lt;/code&gt; method. In other words, the database schema should be unchanged if you do an &lt;code&gt;up&lt;/code&gt; followed by a &lt;code&gt;down&lt;/code&gt;. For example, if you create a table in the &lt;code&gt;up&lt;/code&gt; method, you should drop it in the &lt;code&gt;down&lt;/code&gt; method. It is wise to perform the transformations in precisely the reverse order they were made in the &lt;code&gt;up&lt;/code&gt; method. The example in the &lt;code&gt;reversible&lt;/code&gt; section is equivalent to:</source>
          <target state="translated">&lt;code&gt;change&lt;/code&gt; 메소드 대신 &lt;code&gt;up&lt;/code&gt; 및 &lt;code&gt;down&lt;/code&gt; 메소드를 사용하여 이전 스타일의 마이그레이션을 사용할 수도 있습니다 . &lt;code&gt;up&lt;/code&gt; 방법은 당신이 당신의 스키마에하고 싶습니다 변환을 설명해야하고, &lt;code&gt;down&lt;/code&gt; 마이그레이션의 방법에 의해 수행 된 변환 복귀해야 &lt;code&gt;up&lt;/code&gt; 방법. 즉, &lt;code&gt;up&lt;/code&gt; 다음에 &lt;code&gt;down&lt;/code&gt; 을 수행하면 데이터베이스 스키마가 변경되지 않아야합니다 . 예를 들어, &lt;code&gt;up&lt;/code&gt; 메소드 에서 테이블을 작성하는 경우 &lt;code&gt;down&lt;/code&gt; 메소드 에서 테이블을 삭제해야합니다 . &lt;code&gt;up&lt;/code&gt; 에서 만들어진 역순으로 변환을 수행하는 것이 현명 합니다.방법. &lt;code&gt;reversible&lt;/code&gt; 섹션 의 예 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4a676b5537d0cdad204fe8b34d22d53595175ca6" translate="yes" xml:space="preserve">
          <source>You can also use this method to query for multiple objects. Call the &lt;code&gt;find&lt;/code&gt; method and pass in an array of primary keys. The return will be an array containing all of the matching records for the supplied &lt;em&gt;primary keys&lt;/em&gt;. For example:</source>
          <target state="translated">이 방법을 사용하여 여러 개체를 쿼리 할 수도 있습니다. &lt;code&gt;find&lt;/code&gt; 메소드를 호출하고 기본 키 배열을 전달하십시오. 제공된 &lt;em&gt;기본 키&lt;/em&gt; 와 일치하는 모든 레코드가 포함 된 배열이 반환됩니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0286fa8996fbe2452c5fc1cf5641d44bcd9903d3" translate="yes" xml:space="preserve">
          <source>You can also use this to override routing methods defined by resources, like this:</source>
          <target state="translated">이를 사용하여 다음과 같이 자원에 의해 정의 된 라우팅 방법을 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7dcf98306a9b0d56da05f3f3d0811fe0b85f54bb" translate="yes" xml:space="preserve">
          <source>You can also use various finder methods on a relation for performing complex calculations:</source>
          <target state="translated">복잡한 계산을 수행하기 위해 관계에 다양한 파인더 메소드를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="721f4de4eef3158767e13765c1928ca0df119d72" translate="yes" xml:space="preserve">
          <source>You can also use your own custom unit quantifiers:</source>
          <target state="translated">자신 만의 맞춤 단위 수량자를 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb2b942b8a9f76d0ab836a81413851880268ada3" translate="yes" xml:space="preserve">
          <source>You can also yield multiple times in one layout and use block arguments to differentiate the sections.</source>
          <target state="translated">하나의 레이아웃에서 여러 번 산출하고 블록 인수를 사용하여 섹션을 구별 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8021e8293e1aff386d79be899c2f365a244b9e79" translate="yes" xml:space="preserve">
          <source>You can append as many column name/type pairs as you want.</source>
          <target state="translated">원하는만큼 열 이름 / 유형 쌍을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f8d734f4a771794e94803d877e96d0f8a4e3990" translate="yes" xml:space="preserve">
          <source>You can ask for an extra confirmation of the user by adding a &lt;code&gt;data-confirm&lt;/code&gt; attribute on links and forms. The user will be presented a JavaScript &lt;code&gt;confirm()&lt;/code&gt; dialog containing the attribute's text. If the user chooses to cancel, the action doesn't take place.</source>
          <target state="translated">링크와 양식에 &lt;code&gt;data-confirm&lt;/code&gt; 속성을 추가하여 사용자에 대한 추가 확인을 요청할 수 있습니다 . 사용자에게 속성 텍스트가 포함 된 JavaScript &lt;code&gt;confirm()&lt;/code&gt; 대화 상자가 표시됩니다. 사용자가 취소를 선택하면 작업이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b0b78a8e6ea63d111186be84283beac8c767d76d" translate="yes" xml:space="preserve">
          <source>You can associate the &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; options with a symbol corresponding to the name of a method that will get called right before validation happens. This is the most commonly used option.</source>
          <target state="translated">&lt;code&gt;:if&lt;/code&gt; 및 &lt;code&gt;:unless&lt;/code&gt; 옵션을 유효성 검사가 발생하기 직전에 호출되는 메서드 이름에 해당하는 기호 와 연결할 수 있습니다 . 가장 일반적으로 사용되는 옵션입니다.</target>
        </trans-unit>
        <trans-unit id="400f415be47e4c25de13fa369beaa9773d9ce352" translate="yes" xml:space="preserve">
          <source>You can associate the &lt;code&gt;:if&lt;/code&gt; and &lt;code&gt;:unless&lt;/code&gt; options with a symbol corresponding to the name of a predicate method that will get called right before the callback. When using the &lt;code&gt;:if&lt;/code&gt; option, the callback won't be executed if the predicate method returns false; when using the &lt;code&gt;:unless&lt;/code&gt; option, the callback won't be executed if the predicate method returns true. This is the most common option. Using this form of registration it is also possible to register several different predicates that should be called to check if the callback should be executed.</source>
          <target state="translated">콜백 직전에 호출 될 술어 메소드의 이름에 해당하는 기호와 &lt;code&gt;:if&lt;/code&gt; 및 &lt;code&gt;:unless&lt;/code&gt; 옵션을 연관시킬 수 있습니다 . &lt;code&gt;:if&lt;/code&gt; 옵션을 사용할 때 술어 메소드가 false를 리턴하면 콜백이 실행되지 않습니다. &lt;code&gt;:unless&lt;/code&gt; 옵션을 사용할 때 술어 메소드가 true를 리턴하면 콜백이 실행되지 않습니다. 가장 일반적인 옵션입니다. 이 등록 양식을 사용하면 콜백 실행 여부를 확인하기 위해 호출해야하는 여러 가지 술어를 등록 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="4708e76844441658753826e265895ca038c0e53c" translate="yes" xml:space="preserve">
          <source>You can autoload and eager load from a standard structure like</source>
          <target state="translated">다음과 같은 표준 구조에서 자동로드 및 열망 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ef1a75d42a69278bba1633eb50ae9d3d2b5bbea" translate="yes" xml:space="preserve">
          <source>You can bind to the same Ajax events as &lt;code&gt;form_with&lt;/code&gt;. Here's an example. Let's assume that we have a list of articles that can be deleted with just one click. We would generate some HTML like this:</source>
          <target state="translated">&lt;code&gt;form_with&lt;/code&gt; 와 동일한 Ajax 이벤트에 바인딩 할 수 있습니다 . 다음은 예입니다. 한 번의 클릭으로 삭제할 수있는 기사 목록이 있다고 가정합니다. 다음과 같은 HTML을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c1af81cbcdabdb20560793984e8c87a4a175d70a" translate="yes" xml:space="preserve">
          <source>You can bypass the content type inference from the data by passing in &lt;code&gt;identify: false&lt;/code&gt; along with the &lt;code&gt;content_type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;content_type&lt;/code&gt; 과 함께 identifier &lt;code&gt;identify: false&lt;/code&gt; 를 전달하여 데이터에서 컨텐츠 유형 유추를 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfe22eaa55aa3608559c680c249c14206633b6e1" translate="yes" xml:space="preserve">
          <source>You can call &lt;code&gt;destroy&lt;/code&gt; on Active Record objects when you want to delete them from the database. Note that we don't need to add a view for this action since we're redirecting to the &lt;code&gt;index&lt;/code&gt; action.</source>
          <target state="translated">데이터베이스에서 삭제하려는 경우 Active Record 객체에서 &lt;code&gt;destroy&lt;/code&gt; 를 호출 할 수 있습니다 . &lt;code&gt;index&lt;/code&gt; 작업으로 리디렉션되므로이 작업에 대한보기를 추가 할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="60a36b9daa5bc0dbf5a2f5c7ac3a6d38c2565d60" translate="yes" xml:space="preserve">
          <source>You can call this command on the server during deployment to create compiled versions of your assets directly on the server. See the next section for information on compiling locally.</source>
          <target state="translated">배치 중에 서버에서이 명령을 호출하여 서버에서 직접 컴파일 된 버전의 자산을 작성할 수 있습니다. 로컬 컴파일에 대한 정보는 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8cc264e18dfa26b149100ab70a45e66c310ff778" translate="yes" xml:space="preserve">
          <source>You can chain methods in a statement when the previous method called returns an &lt;code&gt;ActiveRecord::Relation&lt;/code&gt;, like &lt;code&gt;all&lt;/code&gt;, &lt;code&gt;where&lt;/code&gt;, and &lt;code&gt;joins&lt;/code&gt;. Methods that return a single object (see &lt;a href=&quot;#retrieving-a-single-object&quot;&gt;Retrieving a Single Object Section&lt;/a&gt;) have to be at the end of the statement.</source>
          <target state="translated">호출 된 이전 메소드가 &lt;code&gt;all&lt;/code&gt; , &lt;code&gt;where&lt;/code&gt; 및 &lt;code&gt;joins&lt;/code&gt; 와 같이 &lt;code&gt;ActiveRecord::Relation&lt;/code&gt; 리턴 할 때 명령문에서 메소드를 연결할 수 있습니다 . 단일 오브젝트를 리턴하는 메소드 ( &lt;a href=&quot;#retrieving-a-single-object&quot;&gt;단일 오브젝트 섹션 검색&lt;/a&gt; 참조 )는 명령문의 끝에 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc5348485684b1a5ffee6c56f4b97ddac8266670" translate="yes" xml:space="preserve">
          <source>You can change the default locale as well as configure the translations load paths in &lt;code&gt;config/application.rb&lt;/code&gt; as follows:</source>
          <target state="translated">다음과 같이 기본 로케일을 변경하고 &lt;code&gt;config/application.rb&lt;/code&gt; 에서 변환로드 경로를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fced3db414e226a808dfe8ae367bfd41adc6dbd7" translate="yes" xml:space="preserve">
          <source>You can change this padding value using the second optional argument:</source>
          <target state="translated">두 번째 선택적 인수를 사용하여이 패딩 값을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a409727fb6cad94d06678d3c9226a7d5b3ae1f9" translate="yes" xml:space="preserve">
          <source>You can check if &lt;code&gt;zeitwerk&lt;/code&gt; mode is enabled with</source>
          <target state="translated">&lt;code&gt;zeitwerk&lt;/code&gt; 모드가 활성화되어 있는지 확인할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="434b87f67138b677c525dcc4bb11544c6fa391ff" translate="yes" xml:space="preserve">
          <source>You can check whether a module has a name with the predicate &lt;code&gt;anonymous?&lt;/code&gt;:</source>
          <target state="translated">모듈에 술어가 &lt;code&gt;anonymous?&lt;/code&gt; 이름이 있는지 확인할 수 있습니까? :</target>
        </trans-unit>
        <trans-unit id="ed29dfcd7bd39857a3c494bcd6eda545701b3369" translate="yes" xml:space="preserve">
          <source>You can checkout the service's constructor to know which keys are required.</source>
          <target state="translated">서비스 생성자를 확인하여 필요한 키를 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7344c62a47791c62b50f75ec0231b9bf3c9c892b" translate="yes" xml:space="preserve">
          <source>You can choose not to use the form helpers generating HTML5 date and time input fields and use the alternative date and time helpers. These date and time helpers differ from all the other form helpers in two important respects:</source>
          <target state="translated">HTML5 날짜 및 시간 입력 필드를 생성하는 양식 헬퍼를 사용하지 않고 대체 날짜 및 시간 헬퍼를 사용하도록 선택할 수 있습니다. 이 날짜 및 시간 도우미는 두 가지 중요한 측면에서 다른 모든 형식 도우미와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="5cb8b97563bb7e22184e0052cb1a4250d5b61b75" translate="yes" xml:space="preserve">
          <source>You can choose not to yield and build the response yourself, in which case the action will not be run.</source>
          <target state="translated">직접 응답을 생성하지 않고 빌드하지 않도록 선택할 수 있으며이 경우 작업이 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="908d9eddc016a07afe6b465a7a2d2f2727d7c1c5" translate="yes" xml:space="preserve">
          <source>You can choose to have only specific callbacks by passing a hash to the &lt;code&gt;define_model_callbacks&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;define_model_callbacks&lt;/code&gt; 메소드에 해시를 전달하여 특정 콜백 만 갖도록 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7ee1d2d8ceb684a71583bc8ad3691c3dd04a0f9" translate="yes" xml:space="preserve">
          <source>You can combine any number of ImageMagick/libvips operations into a variant, as well as any macros provided by the ImageProcessing gem (such as &lt;code&gt;resize_to_limit&lt;/code&gt;):</source>
          <target state="translated">ImageProcessing gem에서 제공하는 매크로 (예 : &lt;code&gt;resize_to_limit&lt;/code&gt; ) 뿐만 아니라 여러 ImageMagick / libvips 작업을 변형으로 결합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b306e4f64f77aba498057b984004d0e73e65dbf5" translate="yes" xml:space="preserve">
          <source>You can configure default headers in &lt;code&gt;config/application.rb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 에서 기본 헤더를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18eba4a7cff338d17ea9e786e668aeab6499a1c0" translate="yes" xml:space="preserve">
          <source>You can configure the name of the header that your front-end server uses for this purpose using &lt;code&gt;config.action_dispatch.x_sendfile_header&lt;/code&gt; in the appropriate environment's configuration file.</source>
          <target state="translated">적절한 환경의 구성 파일에서 &lt;code&gt;config.action_dispatch.x_sendfile_header&lt;/code&gt; 를 사용하여 프런트 엔드 서버가이 목적으로 사용하는 헤더 이름을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0ece63c27e878a8361b4489eb6d40bef6e35535e" translate="yes" xml:space="preserve">
          <source>You can configure when this &lt;code&gt;IncinerationJob&lt;/code&gt; will be run as a time-after-processing using the &lt;code&gt;config.action_mailbox.incinerate_after&lt;/code&gt; or &lt;code&gt;ActionMailbox.incinerate_after&lt;/code&gt; setting.</source>
          <target state="translated">&lt;code&gt;config.action_mailbox.incinerate_after&lt;/code&gt; 또는 &lt;code&gt;ActionMailbox.incinerate_after&lt;/code&gt; 설정을 사용 하여이 &lt;code&gt;IncinerationJob&lt;/code&gt; 이 처리 후 시간으로 실행될 시기를 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e9812112be087d43b8d72956658652b8c28dcbc" translate="yes" xml:space="preserve">
          <source>You can configure your own code through the Rails configuration object with custom configuration under either the &lt;code&gt;config.x&lt;/code&gt; namespace, or &lt;code&gt;config&lt;/code&gt; directly. The key difference between these two is that you should be using &lt;code&gt;config.x&lt;/code&gt; if you are defining &lt;em&gt;nested&lt;/em&gt; configuration (ex: &lt;code&gt;config.x.nested.hi&lt;/code&gt;), and just &lt;code&gt;config&lt;/code&gt; for &lt;em&gt;single level&lt;/em&gt; configuration (ex: &lt;code&gt;config.hello&lt;/code&gt;).</source>
          <target state="translated">&lt;code&gt;config.x&lt;/code&gt; 네임 스페이스 또는 &lt;code&gt;config&lt;/code&gt; 에서 직접 사용자 정의 구성을 사용하여 Rails 구성 오브젝트를 통해 고유 코드를 구성 할 수 있습니다 . 이 두 가지의 주요 차이점은 사용되어야한다는 것이다 &lt;code&gt;config.x&lt;/code&gt; 을 당신이 정의하는 경우 &lt;em&gt;중첩 된&lt;/em&gt; (: 예 구성 &lt;code&gt;config.x.nested.hi&lt;/code&gt; 를 ) 그냥 &lt;code&gt;config&lt;/code&gt; (설정) 에 대한 &lt;em&gt;단일 레벨&lt;/em&gt; 구성 (예 : &lt;code&gt;config.hello&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9bb10a2ca1afaa716b633161ce454b9cf59d1458" translate="yes" xml:space="preserve">
          <source>You can consume those events and the information they provide by registering a subscriber.</source>
          <target state="translated">가입자를 등록하여 해당 이벤트 및 이벤트가 제공하는 정보를 이용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28fc5069f2e996c88ea02f608dc66bdc4c3f2faf" translate="yes" xml:space="preserve">
          <source>You can create a message with images:</source>
          <target state="translated">이미지가 포함 된 메시지를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ccb0ea1584c058cb404d81ce71fbc74723495d67" translate="yes" xml:space="preserve">
          <source>You can create a similar binding without actually creating &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; tags with the &lt;code&gt;fields_for&lt;/code&gt; helper. This is useful for editing additional model objects with the same form. For example, if you had a &lt;code&gt;Person&lt;/code&gt; model with an associated &lt;code&gt;ContactDetail&lt;/code&gt; model, you could create a form for creating both like so:</source>
          <target state="translated">&lt;code&gt;fields_for&lt;/code&gt; 도우미로 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 태그를 실제로 만들지 않고도 비슷한 바인딩을 만들 수 있습니다 . 동일한 형식으로 추가 모델 객체를 편집 할 때 유용합니다. 예를 들어, &lt;code&gt;ContactDetail&lt;/code&gt; 모델 과 연관된 &lt;code&gt;Person&lt;/code&gt; 모델 이있는 경우 다음 과 같이 작성하기위한 양식을 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdb210c8b9da0cb133796400d028dd156b1f104b" translate="yes" xml:space="preserve">
          <source>You can create a user with an avatar:</source>
          <target state="translated">아바타를 사용하여 사용자를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d0834eaa206b4da17366434a303e19b92a8411d" translate="yes" xml:space="preserve">
          <source>You can create custom URL helpers directly. For example:</source>
          <target state="translated">사용자 정의 URL 헬퍼를 직접 작성할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1bd4447acb3cf72d72aa5b4c1cc89e7f293915d1" translate="yes" xml:space="preserve">
          <source>You can create values for the &amp;ldquo;min&amp;rdquo; and &amp;ldquo;max&amp;rdquo; attributes by passing instances of &lt;a href=&quot;../../date&quot;&gt;Date&lt;/a&gt; or &lt;a href=&quot;../../time&quot;&gt;Time&lt;/a&gt; to the options hash.</source>
          <target state="translated">&lt;a href=&quot;../../date&quot;&gt;날짜&lt;/a&gt; 또는 &lt;a href=&quot;../../time&quot;&gt;시간&lt;/a&gt; 인스턴스를 옵션 해시 에 전달하여 &quot;min&quot;및 &quot;max&quot;속성에 대한 값을 작성할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1443f5db5f7d5989679cfc918e2f9979a4eb1ef7" translate="yes" xml:space="preserve">
          <source>You can create your own custom &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; templates by subclassing this class. For example:</source>
          <target state="translated">이 클래스를 서브 클래 싱 하여 사용자 정의 &lt;a href=&quot;formbuilder&quot;&gt;FormBuilder&lt;/a&gt; 템플리트를 작성할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="847c0c3dfe1299c34282c6634d93cab64135b425" translate="yes" xml:space="preserve">
          <source>You can create your own custom cache store by simply extending &lt;code&gt;ActiveSupport::Cache::Store&lt;/code&gt; and implementing the appropriate methods. This way, you can swap in any number of caching technologies into your Rails application.</source>
          <target state="translated">&lt;code&gt;ActiveSupport::Cache::Store&lt;/code&gt; 를 확장 하고 적절한 메소드를 구현 하여 고유 한 사용자 정의 캐시 저장소를 작성할 수 있습니다 . 이런 식으로, 여러 가지 캐싱 기술을 Rails 애플리케이션으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a95692b18a01df2dab44496996d3192a57b471db" translate="yes" xml:space="preserve">
          <source>You can customize the name of the key or specific parameters you want to wrap by consulting the &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionController/ParamsWrapper.html&quot;&gt;API documentation&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionController/ParamsWrapper.html&quot;&gt;API 문서&lt;/a&gt; 를 참조하여 랩하려는 키 또는 특정 매개 변수의 이름을 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15053f4277702cf31c6da3089b4f0aca4bd78d93" translate="yes" xml:space="preserve">
          <source>You can declare as many callbacks as you want inside your callback classes.</source>
          <target state="translated">콜백 클래스 내에서 원하는만큼의 콜백을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2999236cbeaededccfe70af147bd19920a56d278" translate="yes" xml:space="preserve">
          <source>You can define a scope that applies to all finders using &lt;a href=&quot;../default/classmethods#method-i-default_scope&quot;&gt;default_scope&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../default/classmethods#method-i-default_scope&quot;&gt;default_scope를&lt;/a&gt; 사용하여 모든 파인더에 적용되는 범위를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d59e5e82b7a5e1e5ae98771157b36316ae711dfc" translate="yes" xml:space="preserve">
          <source>You can define assets for precompilation in &lt;code&gt;engine.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;engine.rb&lt;/code&gt; 에서 사전 컴파일을위한 자산을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="74ccd9c23187b06ee7bd07c4a63e11d14cdcc3e1" translate="yes" xml:space="preserve">
          <source>You can define defaults in a route by supplying a hash for the &lt;code&gt;:defaults&lt;/code&gt; option. This even applies to parameters that you do not specify as dynamic segments. For example:</source>
          <target state="translated">&lt;code&gt;:defaults&lt;/code&gt; 옵션에 해시를 제공하여 경로에서 기본값을 정의 할 수 있습니다 . 이는 동적 세그먼트로 지정하지 않은 매개 변수에도 적용됩니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b1212cb684c95901d6cab042188412b9f6e0237e" translate="yes" xml:space="preserve">
          <source>You can delete multiple rows at once by passing an &lt;a href=&quot;../../array&quot;&gt;Array&lt;/a&gt; of &lt;code&gt;id&lt;/code&gt;s.</source>
          <target state="translated">&lt;code&gt;id&lt;/code&gt; &lt;a href=&quot;../../array&quot;&gt;배열&lt;/a&gt; 을 전달하여 여러 행을 한 번에 삭제할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c7f8a4006cd8bbc50261d4a7acf122afae4a0f0d" translate="yes" xml:space="preserve">
          <source>You can disable forgery protection on controller by skipping the verification before_action:</source>
          <target state="translated">before_action 검증을 건너 뛰어 컨트롤러에서 위조 방지를 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bba132a3370bf0e5506c48f46a133ee85e2b98da" translate="yes" xml:space="preserve">
          <source>You can disable incinerating processed emails by setting &lt;code&gt;config.action_mailbox.incinerate&lt;/code&gt; or &lt;code&gt;ActionMailbox.incinerate&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;config.action_mailbox.incinerate&lt;/code&gt; 또는 &lt;code&gt;ActionMailbox.incinerate&lt;/code&gt; 를 &lt;code&gt;false&lt;/code&gt; 로 설정하여 처리 된 이메일 소각을 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="21ab7b2870db7ee8a0dc5ac9e0224d1209c8c320" translate="yes" xml:space="preserve">
          <source>You can do file globbing as well using &lt;code&gt;@import &quot;*&quot;&lt;/code&gt;, and &lt;code&gt;@import &quot;**/*&quot;&lt;/code&gt; to add the whole tree which is equivalent to how &lt;code&gt;require_tree&lt;/code&gt; works. Check the &lt;a href=&quot;https://github.com/rails/sass-rails#features&quot;&gt;sass-rails documentation&lt;/a&gt; for more info and important caveats.</source>
          <target state="translated">&lt;code&gt;@import &quot;*&quot;&lt;/code&gt; 및 &lt;code&gt;@import &quot;**/*&quot;&lt;/code&gt; 를 사용하여 파일 globbing을 수행하여 &lt;code&gt;require_tree&lt;/code&gt; 작동 방식과 동일한 전체 트리를 추가 할 수 있습니다 . 더 많은 정보와 중요한 경고 사항에 대해서는 &lt;a href=&quot;https://github.com/rails/sass-rails#features&quot;&gt;sass-rails 설명서&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="4ed3551f4e2ffd793ede4ad5a34caa30915326dd" translate="yes" xml:space="preserve">
          <source>You can easily set your queuing backend:</source>
          <target state="translated">큐 백엔드를 쉽게 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac00a334ec72005d3e87e5dcce19b0f5616f38a1" translate="yes" xml:space="preserve">
          <source>You can either specify a layout declaratively (using the layout class method) or give it the same name as your controller, and place it in &lt;code&gt;app/views/layouts&lt;/code&gt;. If a subclass does not have a layout specified, it inherits its layout using normal Ruby inheritance.</source>
          <target state="translated">레이아웃을 선언적으로 지정하거나 (레이아웃 클래스 메소드를 사용하여) 컨트롤러와 동일한 이름을 지정하고 &lt;code&gt;app/views/layouts&lt;/code&gt; 에 배치 할 수 있습니다 . 서브 클래스에 지정된 레이아웃이 없으면 일반적인 Ruby 상속을 사용하여 해당 레이아웃을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="dd8d1866bc4613d9f169066174441d9a1949a69e" translate="yes" xml:space="preserve">
          <source>You can enable automatic nonce generation:</source>
          <target state="translated">자동 nonce 생성을 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7972e845e798ec5e8a687a987b33e767b9ea953d" translate="yes" xml:space="preserve">
          <source>You can enable support for the faster &lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt; connection library by additionally adding its ruby wrapper to your Gemfile:</source>
          <target state="translated">루비 래퍼를 Gemfile에 추가하여 더 빠른 &lt;a href=&quot;https://github.com/redis/hiredis&quot;&gt;hiredis&lt;/a&gt; 연결 라이브러리를 지원할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f66bee6df38828566012ac623f395e85b750da55" translate="yes" xml:space="preserve">
          <source>You can evaluate code in the context of any object's singleton class using &lt;code&gt;class_eval&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;class_eval&lt;/code&gt; 을 사용하여 객체의 싱글 톤 클래스의 컨텍스트에서 코드를 평가할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18ba7d04c19a89a6ff17a7966569ddfc883b96b2" translate="yes" xml:space="preserve">
          <source>You can even execute ruby code written in a file with runner.</source>
          <target state="translated">러너로 파일에 작성된 루비 코드를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3588c5efc3cef1a33c5fcfd4d6acf71f0fb01074" translate="yes" xml:space="preserve">
          <source>You can even render plain text directly without using a template:</source>
          <target state="translated">템플릿을 사용하지 않고 일반 텍스트를 직접 렌더링 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="088a4bf4c5af5e73b40e716f166a4145faf3212d" translate="yes" xml:space="preserve">
          <source>You can even use Action View helpers in these views. For example:</source>
          <target state="translated">이러한보기에서 작업보기 도우미를 사용할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f86b85b68fb866a85b735eb36da6b9e7a7eaddc1" translate="yes" xml:space="preserve">
          <source>You can even use an inline method, such as a Proc, to determine the layout. For example, if you pass a Proc object, the block you give the Proc will be given the &lt;code&gt;controller&lt;/code&gt; instance, so the layout can be determined based on the current request:</source>
          <target state="translated">Proc와 같은 인라인 방법을 사용하여 레이아웃을 결정할 수도 있습니다. 예를 들어 Proc 객체를 전달하면 Proc에 제공 한 블록에 &lt;code&gt;controller&lt;/code&gt; 인스턴스가 제공되므로 현재 요청에 따라 레이아웃을 결정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e845b3c2090a3be51d3338370e812560f89dabd5" translate="yes" xml:space="preserve">
          <source>You can extend the list of supported argument types. You just need to define your own serializer:</source>
          <target state="translated">지원되는 인수 유형 목록을 확장 할 수 있습니다. 자신 만의 시리얼 라이저를 정의하면됩니다.</target>
        </trans-unit>
        <trans-unit id="fcb63fbfd5602ad91ed6bf3e908e717c51a1a044" translate="yes" xml:space="preserve">
          <source>You can fetch values of &lt;code&gt;ActionController::Parameters&lt;/code&gt; using either &lt;code&gt;:key&lt;/code&gt; or &lt;code&gt;&quot;key&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:key&lt;/code&gt; 또는 &lt;code&gt;&quot;key&quot;&lt;/code&gt; 를 사용하여 &lt;code&gt;ActionController::Parameters&lt;/code&gt; 값을 가져올 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="da172ae7799f974997c9de7f78a6159e8626493d" translate="yes" xml:space="preserve">
          <source>You can filter out sensitive request parameters from your log files by appending them to &lt;code&gt;config.filter_parameters&lt;/code&gt; in the application configuration. These parameters will be marked [FILTERED] in the log.</source>
          <target state="translated">애플리케이션 구성에서 &lt;code&gt;config.filter_parameters&lt;/code&gt; 에 추가하여 로그 파일에서 민감한 요청 매개 변수를 필터링 할 수 있습니다 . 이 매개 변수는 로그에 [FILTERED]로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6bd39b3b6e84c5ddaae1977f6c932b8e9de6ff32" translate="yes" xml:space="preserve">
          <source>You can find a list of all released Rails versions &lt;a href=&quot;https://rubygems.org/gems/rails/versions&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">모든 릴리스 된 Rails 버전 목록은 &lt;a href=&quot;https://rubygems.org/gems/rails/versions&quot;&gt;여기에서&lt;/a&gt; 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fb9e9b84c05471160a8d34b618702f7a9b7e1dbb" translate="yes" xml:space="preserve">
          <source>You can find detailed instructions on how to test your Action Cable functionality in the &lt;a href=&quot;testing#testing-action-cable&quot;&gt;testing guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#testing-action-cable&quot;&gt;테스트 가이드&lt;/a&gt; 에서 액션 케이블 기능을 테스트하는 방법에 대한 자세한 지침을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ad9ea6effa872f77728082cdb3eb397a57257387" translate="yes" xml:space="preserve">
          <source>You can find detailed instructions on how to test your jobs in the &lt;a href=&quot;testing#testing-jobs&quot;&gt;testing guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#testing-jobs&quot;&gt;테스트 안내서&lt;/a&gt; 에서 작업을 테스트하는 방법에 대한 자세한 지침을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e8906a55af0ccf8bec15de6b36c8a9007b1ff22f" translate="yes" xml:space="preserve">
          <source>You can find detailed instructions on how to test your mailers in the &lt;a href=&quot;testing#testing-your-mailers&quot;&gt;testing guide&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;testing#testing-your-mailers&quot;&gt;테스트 가이드&lt;/a&gt; 에서 메일러를 테스트하는 방법에 대한 자세한 지침을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a2086daa0d12821a5dc56d3ca3f6bc1bcb0c96f" translate="yes" xml:space="preserve">
          <source>You can find more detailed configuration options in the &lt;a href=&quot;action_cable_overview#configuration&quot;&gt;Action Cable Overview&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;action_cable_overview#configuration&quot;&gt;동작 케이블 개요&lt;/a&gt; 에서보다 자세한 구성 옵션을 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db3658e10a8bf8920f940a97bfaee2c91b193d6b" translate="yes" xml:space="preserve">
          <source>You can find more information in the &lt;a href=&quot;https://bogomips.org/unicorn/README.html&quot;&gt;Unicorn readme&lt;/a&gt; and understand the &lt;a href=&quot;https://bogomips.org/unicorn/PHILOSOPHY.html&quot;&gt;philosophy&lt;/a&gt; behind it.</source>
          <target state="translated">&lt;a href=&quot;https://bogomips.org/unicorn/README.html&quot;&gt;Unicorn readme&lt;/a&gt; 에서 더 많은 정보를 찾고 그 뒤에 있는 &lt;a href=&quot;https://bogomips.org/unicorn/PHILOSOPHY.html&quot;&gt;철학을&lt;/a&gt; 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53dc5194c4f1497615e41b2f48b3016b634275a5" translate="yes" xml:space="preserve">
          <source>You can find more sophisticated negative CAPTCHAs in Ned Batchelder's &lt;a href=&quot;http://nedbatchelder.com/text/stopbots.html&quot;&gt;blog post&lt;/a&gt;:</source>
          <target state="translated">Ned Batchelder의 &lt;a href=&quot;http://nedbatchelder.com/text/stopbots.html&quot;&gt;블로그 게시물&lt;/a&gt; 에서보다 정교한 부정적 보안 문자를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dcde21463e90b3057a10a2e95bd760dceb7e424f" translate="yes" xml:space="preserve">
          <source>You can force the form to use the full array of HTTP verbs by setting</source>
          <target state="translated">양식을 설정하여 HTTP 동사의 전체 배열을 사용하도록 강제 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f46e0b091d94cc2951ed46d703398c99e1dd633" translate="yes" xml:space="preserve">
          <source>You can generate a new api Rails app:</source>
          <target state="translated">새로운 api Rails 앱을 생성 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="03e480752dd6bd7aeff2c1b715478ddaa76b7f84" translate="yes" xml:space="preserve">
          <source>You can get a list of all middleware in your application via:</source>
          <target state="translated">다음을 통해 애플리케이션의 모든 미들웨어 목록을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b88fd4e3fcf250e2c92d50a5954e5de19927eb5a" translate="yes" xml:space="preserve">
          <source>You can get a list of rails commands available to you, which will often depend on your current directory, by typing &lt;code&gt;rails --help&lt;/code&gt;. Each command has a description, and should help you find the thing you need.</source>
          <target state="translated">&lt;code&gt;rails --help&lt;/code&gt; 를 입력하여 사용 가능한 rails 명령 목록을 얻을 수 있습니다.이 명령은 종종 현재 디렉토리에 따라 다릅니다 . 각 명령에는 설명이 있으며 필요한 것을 찾는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="3a9a98d5a9ee0a7180a45e34dd99ca36bf00f557" translate="yes" xml:space="preserve">
          <source>You can group tasks by placing them in namespaces:</source>
          <target state="translated">네임 스페이스에 배치하여 작업을 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="357521b438f8f53bf81b95ebb993053ed99112af" translate="yes" xml:space="preserve">
          <source>You can have as many manifest files as you need. For example, the &lt;code&gt;admin.css&lt;/code&gt; and &lt;code&gt;admin.js&lt;/code&gt; manifest could contain the JS and CSS files that are used for the admin section of an application.</source>
          <target state="translated">필요한만큼 매니페스트 파일을 가질 수 있습니다. 예를 들어, &lt;code&gt;admin.css&lt;/code&gt; 및 &lt;code&gt;admin.js&lt;/code&gt; 매니페스트에는 애플리케이션의 관리 섹션에 사용되는 JS 및 CSS 파일이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e44c4ab0f79c1022b32dca64d05226e07ab90bff" translate="yes" xml:space="preserve">
          <source>You can help test performance with these additions to your test environment:</source>
          <target state="translated">테스트 환경에 다음을 추가하여 성능을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81f6195e35fdef102557c895a278e3874c8b6cb5" translate="yes" xml:space="preserve">
          <source>You can implement it like this in your &lt;code&gt;ApplicationController&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ApplicationController&lt;/code&gt; 에서 다음과 같이 구현할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dfce78de11ac4dbcec73340f3557cc033df7dc18" translate="yes" xml:space="preserve">
          <source>You can install more generators through generator gems, portions of plugins you'll undoubtedly install, and you can even create your own!</source>
          <target state="translated">생성기 젬, 의심 할 여지없이 설치할 플러그인의 일부를 통해 더 많은 생성기를 설치할 수 있으며, 직접 생성 할 수도 있습니다!</target>
        </trans-unit>
        <trans-unit id="bdd77b9424f4864a1575155fa0cf0a3dae9bc9e1" translate="yes" xml:space="preserve">
          <source>You can install the rails gem by typing &lt;code&gt;gem install rails&lt;/code&gt;, if you don't have it already.</source>
          <target state="translated">&lt;code&gt;gem install rails&lt;/code&gt; 를 아직 입력 하지 않은 경우이를 입력하여 rails gem을 설치할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70240e2ccc19d89f9eeed8f2bae16f7f2d747d2b" translate="yes" xml:space="preserve">
          <source>You can invoke &lt;code&gt;instance_variables&lt;/code&gt; to list all the instance variables available in your context. If you want to list all the local variables, you can do that with &lt;code&gt;local_variables&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;instance_variables&lt;/code&gt; 를 호출 하여 컨텍스트에서 사용 가능한 모든 인스턴스 변수를 나열 할 수 있습니다 . 모든 지역 변수를 나열하려면 &lt;code&gt;local_variables&lt;/code&gt; 로 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4e4397c0d1c11cae01b6cd2c30bc4e3f441bc04" translate="yes" xml:space="preserve">
          <source>You can just supply the raw SQL specifying the &lt;code&gt;JOIN&lt;/code&gt; clause to &lt;code&gt;joins&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;joins&lt;/code&gt; 할 &lt;code&gt;JOIN&lt;/code&gt; 절을 지정하여 원시 SQL을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e2e64c66b90bbe220f174d879374385d9b2b5f28" translate="yes" xml:space="preserve">
          <source>You can keep multiple services in sync by defining a mirror service. When a file is uploaded or deleted, it's done across all the mirrored services. Mirrored services can be used to facilitate a migration between services in production. You can start mirroring to the new service, copy existing files from the old service to the new, then go all-in on the new service. Define each of the services you'd like to use as described above and reference them from a mirrored service.</source>
          <target state="translated">미러 서비스를 정의하여 여러 서비스를 동기화 된 상태로 유지할 수 있습니다. 파일을 업로드하거나 삭제하면 모든 미러 서비스에서 수행됩니다. 미러 된 서비스를 사용하여 프로덕션 서비스 간 마이그레이션을 용이하게 할 수 있습니다. 새 서비스로 미러링을 시작하고 기존 서비스에서 기존 파일을 새 파일로 복사 한 다음 새 서비스를 올인 할 수 있습니다. 위에서 설명한대로 사용하려는 각 서비스를 정의하고 미러링 된 서비스에서 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9972a044265c4fe232176c9470ddc2b53a3c4c49" translate="yes" xml:space="preserve">
          <source>You can learn more about how to use &lt;code&gt;Rack::Sendfile&lt;/code&gt; with popular front-ends in &lt;a href=&quot;https://www.rubydoc.info/github/rack/rack/master/Rack/Sendfile&quot;&gt;the Rack::Sendfile documentation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.rubydoc.info/github/rack/rack/master/Rack/Sendfile&quot;&gt;Rack :: Sendfile 문서&lt;/a&gt; 에서 널리 사용되는 프런트 엔드와 함께 &lt;code&gt;Rack::Sendfile&lt;/code&gt; 을 사용하는 방법에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d2b2f61e2c17c9722731e06238a78b5c1cc836ab" translate="yes" xml:space="preserve">
          <source>You can learn more about querying an Active Record model in the &lt;a href=&quot;active_record_querying&quot;&gt;Active Record Query Interface&lt;/a&gt; guide.</source>
          <target state="translated">&lt;a href=&quot;active_record_querying&quot;&gt;활성 레코드 쿼리 인터페이스&lt;/a&gt; 안내서 에서 활성 레코드 모델 쿼리에 대해 자세히 알아볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b452351515935a7415f0f181504f500e962daff9" translate="yes" xml:space="preserve">
          <source>You can learn more about validations in the &lt;a href=&quot;active_record_validations&quot;&gt;Active Record Validations guide&lt;/a&gt;.</source>
          <target state="translated">유효성 검사에 대한 자세한 내용은 &lt;a href=&quot;active_record_validations&quot;&gt;활성 레코드 유효성 검사 안내서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cde047ade8d3260a324ebda341401dec5ef6a052" translate="yes" xml:space="preserve">
          <source>You can leave out the &lt;code&gt;:on&lt;/code&gt; option, this will create the same member route except that the resource id value will be available in &lt;code&gt;params[:photo_id]&lt;/code&gt; instead of &lt;code&gt;params[:id]&lt;/code&gt;. Route helpers will also be renamed from &lt;code&gt;preview_photo_url&lt;/code&gt; and &lt;code&gt;preview_photo_path&lt;/code&gt; to &lt;code&gt;photo_preview_url&lt;/code&gt; and &lt;code&gt;photo_preview_path&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;:on&lt;/code&gt; 옵션을 생략하면 자원 ID 값이 &lt;code&gt;params[:id]&lt;/code&gt; 대신 &lt;code&gt;params[:photo_id]&lt;/code&gt; 에서 사용 가능하다는 점을 제외하고 동일한 멤버 라우트가 작성됩니다 . 경로 도우미는 또한 &lt;code&gt;preview_photo_url&lt;/code&gt; 및 &lt;code&gt;preview_photo_path&lt;/code&gt; 에서 &lt;code&gt;photo_preview_url&lt;/code&gt; 및 &lt;code&gt;photo_preview_path&lt;/code&gt; 로 이름이 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="df0dac0c4a1e3175feba58156a49179a3e04a085" translate="yes" xml:space="preserve">
          <source>You can localize your labels based on model and attribute names. For example you can define the following in your locale (e.g. en.yml)</source>
          <target state="translated">모델 및 속성 이름을 기반으로 레이블을 현지화 할 수 있습니다. 예를 들어 로케일에서 다음을 정의 할 수 있습니다 (예 : en.yml)</target>
        </trans-unit>
        <trans-unit id="a7b0974a254b6848f10357aecb3f5f88c3308169" translate="yes" xml:space="preserve">
          <source>You can make use of this feature, e.g. when working with a large amount of static content, which would be clumsy to put inside YAML or Ruby dictionaries. Bear in mind, though, that any change you would like to do later to the template must be propagated to all of them.</source>
          <target state="translated">예를 들어 대량의 정적 컨텐츠로 작업 할 때 YAML 또는 Ruby 사전에 넣기가 서투른이 기능을 사용할 수 있습니다. 그러나 템플릿에 대해 나중에 변경하려는 변경 사항은 모두 해당 템플릿에 전파되어야합니다.</target>
        </trans-unit>
        <trans-unit id="4c6dd4d6bf440f65061dee424ac298d56e12c085" translate="yes" xml:space="preserve">
          <source>You can manipulate objects and associations before they are saved to the database, but there is some special behavior you should be aware of, mostly involving the saving of associated objects.</source>
          <target state="translated">데이터베이스에 저장하기 전에 객체 및 연결을 조작 할 수 있지만, 관련 객체 저장과 관련하여 알아야 할 특별한 동작이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bce7400aaabcd9c4d1db4804f4e1fd23cd01cb9" translate="yes" xml:space="preserve">
          <source>You can match all verbs to a particular route using &lt;code&gt;via: :all&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;via: :all&lt;/code&gt; :을 사용하여 모든 동사를 특정 경로에 일치시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e294483254a54aa8330aae52a2784dd55f7cd36d" translate="yes" xml:space="preserve">
          <source>You can mitigate these attacks (in the obvious way) by adding the &lt;strong&gt;httpOnly&lt;/strong&gt; flag to cookies, so that document.cookie may not be read by JavaScript. HTTP only cookies can be used from IE v6.SP1, Firefox v2.0.0.5, Opera 9.5, Safari 4, and Chrome 1.0.154 onwards. But other, older browsers (such as WebTV and IE 5.5 on Mac) can actually cause the page to fail to load. Be warned that cookies &lt;a href=&quot;https://www.owasp.org/index.php/HTTPOnly#Browsers_Supporting_HttpOnly&quot;&gt;will still be visible using Ajax&lt;/a&gt;, though.</source>
          <target state="translated">&lt;strong&gt;httpOnly&lt;/strong&gt; 플래그를 쿠키 에 추가하여 이러한 공격을 명백히 완화 할 수 있으므로 JavaScript가 document.cookie를 읽을 수 없습니다. IE v6.SP1, Firefox v2.0.0.5, Opera 9.5, Safari 4 및 Chrome 1.0.154 이상에서 HTTP 전용 쿠키를 사용할 수 있습니다. 그러나 다른 오래된 브라우저 (예 : Mac의 WebTV 및 IE 5.5)는 실제로 페이지를로드하지 못할 수 있습니다. 쿠키 &lt;a href=&quot;https://www.owasp.org/index.php/HTTPOnly#Browsers_Supporting_HttpOnly&quot;&gt;는 여전히 Ajax를 사용하여 볼 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ee403c2d36c2b3e8289d4b44f0e1d3a636690780" translate="yes" xml:space="preserve">
          <source>You can mix it with &lt;code&gt;from&lt;/code&gt; method and do fun things like:</source>
          <target state="translated">당신은 그것을 혼합 할 수 &lt;code&gt;from&lt;/code&gt; 방법과 같은 재미있는 일을 :</target>
        </trans-unit>
        <trans-unit id="35f1975b1f0d5a64a6e4f81bcfcf1900ad849f14" translate="yes" xml:space="preserve">
          <source>You can mix it with &lt;code&gt;to&lt;/code&gt; method and do fun things like:</source>
          <target state="translated">방법과 혼합하여 다음과 같은 재미있는 일 &lt;code&gt;to&lt;/code&gt; 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7262b6b97663dcb8dfa5a08f3085907ee16ed3d2" translate="yes" xml:space="preserve">
          <source>You can modify the HTML attributes of the script tag by passing a hash as the last argument.</source>
          <target state="translated">마지막 인수로 해시를 전달하여 스크립트 태그의 HTML 속성을 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19bc4f8bc9ae0bb9618408d51972163f8228339c" translate="yes" xml:space="preserve">
          <source>You can navigate to the directory that contains the plugin, run the &lt;code&gt;bundle install&lt;/code&gt; command and run the one generated test using the &lt;code&gt;bin/test&lt;/code&gt; command.</source>
          <target state="translated">플러그인이 포함 된 디렉토리로 이동하고 &lt;code&gt;bundle install&lt;/code&gt; 명령을 실행 한 후 &lt;code&gt;bin/test&lt;/code&gt; 명령을 사용하여 생성 된 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12527ecccc43602a7ba9aee80b0558cb2aa626be" translate="yes" xml:space="preserve">
          <source>You can nest resources within other nested resources if you like. For example:</source>
          <target state="translated">원하는 경우 다른 중첩 된 자원 내에 자원을 중첩 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5b13339cf0c577697235c8e130bf416c99aaecb" translate="yes" xml:space="preserve">
          <source>You can now configure your application to check if the HTTP &lt;code&gt;Origin&lt;/code&gt; header should be checked against the site's origin as an additional CSRF defense. Set the following in your config to true:</source>
          <target state="translated">이제 추가 오리지널 CSRF 방어로 HTTP &lt;code&gt;Origin&lt;/code&gt; 헤더를 사이트 오리진과 비교해야하는지 확인하도록 애플리케이션을 구성 할 수 있습니다 . 구성에서 다음을 true로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="89c7f3f9b59018216b3dc63fa1aaf7a18c5478a8" translate="yes" xml:space="preserve">
          <source>You can now create, show, and list articles. Now let's add some links to navigate through pages.</source>
          <target state="translated">이제 기사를 작성, 표시 및 나열 할 수 있습니다. 이제 페이지를 탐색 할 수있는 링크를 추가하겠습니다.</target>
        </trans-unit>
        <trans-unit id="76d4be262fb68a4c5e963717e5a69e0cf726c82f" translate="yes" xml:space="preserve">
          <source>You can now just call the dependency once with a wildcard.</source>
          <target state="translated">와일드 카드로 종속성을 한 번만 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="064dd1559492ca12147d7214ee7e7c2af3b6ea2f" translate="yes" xml:space="preserve">
          <source>You can now robustly use constant paths in class and module definitions:</source>
          <target state="translated">클래스 및 모듈 정의에서 상수 경로를 강력하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec20829c9911f07cc5b048dc67c8b7c80b8b302c" translate="yes" xml:space="preserve">
          <source>You can now set or update attributes on the associated posts through an attribute hash for a member: include the key &lt;code&gt;:posts_attributes&lt;/code&gt; with an array of hashes of post attributes as a value.</source>
          <target state="translated">이제 구성원의 속성 해시를 통해 연관된 게시물의 속성을 설정하거나 업데이트 할 수 있습니다. 게시물 속성의 해시 배열을 값으로 사용하여 &lt;code&gt;:posts_attributes&lt;/code&gt; 키를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="937e46514426c72c2cf9b728317542791936fe31" translate="yes" xml:space="preserve">
          <source>You can now use wildcard matching for your template dependencies. For example, if you were defining your templates as such:</source>
          <target state="translated">이제 템플릿 종속성에 와일드 카드 일치를 사용할 수 있습니다. 예를 들어 템플릿을 다음과 같이 정의한 경우 :</target>
        </trans-unit>
        <trans-unit id="8abd6d3bb8b106f0fe6a56142977c39bf5114569" translate="yes" xml:space="preserve">
          <source>You can now wrap the &lt;code&gt;git&lt;/code&gt; calls in an &lt;code&gt;after_bundle&lt;/code&gt; block. It will be run after the binstubs have been generated.</source>
          <target state="translated">이제 &lt;code&gt;git&lt;/code&gt; 호출을 &lt;code&gt;after_bundle&lt;/code&gt; 블록 에 래핑 할 수 있습니다 . binstub이 생성 된 후에 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="dba25fc6aea961f82aca80a6d1e712b354b5bb5a" translate="yes" xml:space="preserve">
          <source>You can obtain a safe string from a given one with the &lt;code&gt;html_safe&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;html_safe&lt;/code&gt; 메소드를 사용하여 주어진 문자열에서 안전한 문자열을 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="75d7db5406967c4186703fcffbf7c6e9f154722c" translate="yes" xml:space="preserve">
          <source>You can optionally provide HTML attributes as the last element of the array.</source>
          <target state="translated">선택적으로 배열의 마지막 요소로 HTML 속성을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a241d5056cfb48c0b751673be74cf53eada98f55" translate="yes" xml:space="preserve">
          <source>You can override &lt;code&gt;ActiveRecord::Base#to_param&lt;/code&gt; of a related model to construct a URL:</source>
          <target state="translated">관련 모델의 &lt;code&gt;ActiveRecord::Base#to_param&lt;/code&gt; 을 재정 의하여 URL을 구성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ca136a4a5e14d9c65355df5daa9a6c6bc337c95b" translate="yes" xml:space="preserve">
          <source>You can override &lt;code&gt;to_param&lt;/code&gt; in your model to make &lt;code&gt;user_path&lt;/code&gt; construct a path using the user's name instead of the user's id:</source>
          <target state="translated">모델에서 &lt;code&gt;to_param&lt;/code&gt; 을 재정 의하여 &lt;code&gt;user_path&lt;/code&gt; 가 사용자 ID 대신 사용자 이름을 사용하여 경로를 생성 하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ed6885a113854e574054e9447686422a4a67b38" translate="yes" xml:space="preserve">
          <source>You can override the default column name by specifying a custom column name in the &lt;code&gt;counter_cache&lt;/code&gt; declaration instead of &lt;code&gt;true&lt;/code&gt;. For example, to use &lt;code&gt;count_of_books&lt;/code&gt; instead of &lt;code&gt;books_count&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;true&lt;/code&gt; 대신 &lt;code&gt;counter_cache&lt;/code&gt; 선언 에 사용자 정의 열 이름을 지정하여 기본 열 이름을 대체 할 수 있습니다 . 예를 들어, 사용하는 &lt;code&gt;count_of_books&lt;/code&gt; 대신 &lt;code&gt;books_count&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="176a21a45c9a829b01ea56d86938046e27f5e3b5" translate="yes" xml:space="preserve">
          <source>You can override the default layout conventions in your controllers by using the &lt;code&gt;layout&lt;/code&gt; declaration. For example:</source>
          <target state="translated">&lt;code&gt;layout&lt;/code&gt; 선언 을 사용하여 컨트롤러의 기본 레이아웃 규칙을 재정의 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8f1085ae0bf061ebd25b7d4073de5894f9cf01a2" translate="yes" xml:space="preserve">
          <source>You can override this view in the application by simply creating a new file at &lt;code&gt;app/views/blorgh/articles/index.html.erb&lt;/code&gt;. Then you can completely change what this view would normally output.</source>
          <target state="translated">&lt;code&gt;app/views/blorgh/articles/index.html.erb&lt;/code&gt; 에 새 파일을 작성하여 애플리케이션에서이보기를 대체 할 수 있습니다 . 그런 다음이보기가 정상적으로 출력하는 것을 완전히 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d115393f6ebd8c83dd3ef6c7793fc1189e3e4d" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; values, it finds the records responding to the &lt;code&gt;id&lt;/code&gt; and executes delete on them.</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; 또는 &lt;code&gt;String&lt;/code&gt; 값을 전달할 수 있으며 &lt;code&gt;id&lt;/code&gt; 응답하는 레코드를 찾아 삭제를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="23211aa846d02d6068e8d87abeaefd5a0e4d09a7" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;Integer&lt;/code&gt; or &lt;code&gt;String&lt;/code&gt; values, it finds the records responding to the &lt;code&gt;id&lt;/code&gt; and then deletes them from the database.</source>
          <target state="translated">&lt;code&gt;Integer&lt;/code&gt; 또는 &lt;code&gt;String&lt;/code&gt; 값을 전달 하면 &lt;code&gt;id&lt;/code&gt; 응답하는 레코드를 찾은 다음 데이터베이스에서 삭제합니다.</target>
        </trans-unit>
        <trans-unit id="c48ef4aa2541dfd2dfbc4737e0630b0ba8480edf" translate="yes" xml:space="preserve">
          <source>You can pass &lt;code&gt;nil&lt;/code&gt; to &lt;a href=&quot;querymethods#method-i-create_with&quot;&gt;create_with&lt;/a&gt; to reset attributes:</source>
          <target state="translated">속성을 재설정하기 위해 &lt;code&gt;nil&lt;/code&gt; 을 &lt;a href=&quot;querymethods#method-i-create_with&quot;&gt;create_with&lt;/a&gt; 에 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d3c5a31c832817515e6bbdf64c2b4d58a9d3cc0d" translate="yes" xml:space="preserve">
          <source>You can pass a second argument &lt;code&gt;scope&lt;/code&gt; as a callable (i.e. proc or lambda) to retrieve a specific record or customize the generated query when you access the associated object.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;scope&lt;/code&gt; 를 호출 가능 (예 : proc 또는 lambda)으로 전달하여 특정 객체를 검색하거나 연결된 객체에 액세스 할 때 생성 된 쿼리를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5edb638975cda410161ada50ce4aa6f5b1e6d7a" translate="yes" xml:space="preserve">
          <source>You can pass a second argument &lt;code&gt;scope&lt;/code&gt; as a callable (i.e. proc or lambda) to retrieve a specific set of records or customize the generated query when you access the associated collection.</source>
          <target state="translated">두 번째 인수 &lt;code&gt;scope&lt;/code&gt; 를 호출 가능 (예 : proc 또는 lambda)으로 전달하여 특정 레코드 세트를 검색하거나 연관된 콜렉션에 액세스 할 때 생성 된 쿼리를 사용자 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77ab48471779a54f66b267b09a1f539ef3f34929" translate="yes" xml:space="preserve">
          <source>You can pass an &lt;code&gt;options&lt;/code&gt; hash which can include the following keys:</source>
          <target state="translated">다음 키를 포함 할 수 있는 &lt;code&gt;options&lt;/code&gt; 해시를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fc68c3b1a86539a4b143797b0648d9c350fc2961" translate="yes" xml:space="preserve">
          <source>You can pass any HTML attributes into &lt;code&gt;html_options&lt;/code&gt;. These will be added to all created paragraphs.</source>
          <target state="translated">HTML 속성을 &lt;code&gt;html_options&lt;/code&gt; 로 전달할 수 있습니다 . 이것들은 만들어진 모든 단락에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5564f43da3bc6c0cb6a53594e3155e4c71da9f08" translate="yes" xml:space="preserve">
          <source>You can pass any object as a target (e.g. Active Record model), and it would be serialized into a string under the hood.</source>
          <target state="translated">모든 객체를 대상 (예 : Active Record 모델)으로 전달할 수 있으며 후드 아래의 문자열로 직렬화됩니다.</target>
        </trans-unit>
        <trans-unit id="b74c41991081fd019cbe5d219fa081753f1cba66" translate="yes" xml:space="preserve">
          <source>You can pass anything that the session can store; you're not limited to notices and alerts:</source>
          <target state="translated">세션이 저장할 수있는 모든 것을 전달할 수 있습니다. 당신은 통지 및 경고로 제한되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="083d645e0d981d6c8b0b4b1634448c8efe6f4bef" translate="yes" xml:space="preserve">
          <source>You can pass in a class to before_&amp;lt;type&amp;gt;, after_&amp;lt;type&amp;gt; and around_&amp;lt;type&amp;gt;, in which case the callback will call that class's &amp;lt;action&amp;gt;_&amp;lt;type&amp;gt; method passing the object that the callback is being called on.</source>
          <target state="translated">클래스를 before_ &amp;lt;type&amp;gt;, after_ &amp;lt;type&amp;gt; 및 around_ &amp;lt;type&amp;gt;에 전달할 수 있습니다.이 경우 콜백은 콜백이 호출되는 객체를 전달하는 해당 클래스의 &amp;lt;action&amp;gt; _ &amp;lt;type&amp;gt; 메소드를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="f8726b97b5fee3f64f0f6534825d291d419b4a20" translate="yes" xml:space="preserve">
          <source>You can pass in a numerical argument to the &lt;code&gt;first&lt;/code&gt; method to return up to that number of results. For example</source>
          <target state="translated">&lt;code&gt;first&lt;/code&gt; 메소드에 숫자 인수를 전달 하여 해당 개수의 결과를 리턴 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="91ff6479bd8cb739d62a7f4a4c580d196e357236" translate="yes" xml:space="preserve">
          <source>You can pass in a numerical argument to the &lt;code&gt;last&lt;/code&gt; method to return up to that number of results. For example</source>
          <target state="translated">&lt;code&gt;last&lt;/code&gt; 메서드에 숫자 인수를 전달 하여 해당 개수의 결과를 반환 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="fa2097feac3aff0de1bd96e7b099f2dac231478b" translate="yes" xml:space="preserve">
          <source>You can pass in a numerical argument to the &lt;code&gt;take&lt;/code&gt; method to return up to that number of results. For example</source>
          <target state="translated">&lt;code&gt;take&lt;/code&gt; 메소드에 숫자 인수를 전달 하여 해당 개수의 결과를 리턴 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="6b7f4447cb8147641a7e84c11bd31431342872d6" translate="yes" xml:space="preserve">
          <source>You can pass in any header value that a &lt;code&gt;Mail::Message&lt;/code&gt; accepts. Out of the box, &lt;code&gt;ActionMailer::Base&lt;/code&gt; sets the following:</source>
          <target state="translated">&lt;code&gt;Mail::Message&lt;/code&gt; 허용 하는 모든 헤더 값을 전달할 수 있습니다 . 상자 중, &lt;code&gt;ActionMailer::Base&lt;/code&gt; 다음을 설정합니다 :</target>
        </trans-unit>
        <trans-unit id="39c9c4d2462be1a56998de5aa4a20a93bf97d110" translate="yes" xml:space="preserve">
          <source>You can pass local variables to sub templates by using a hash with the variable names as keys and the objects as values:</source>
          <target state="translated">변수 이름을 키로 사용하고 객체를 값으로 사용하여 해시를 사용하여 하위 템플릿에 로컬 변수를 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2696c04c9fe8f3f115208acfee3d97f1328fc703" translate="yes" xml:space="preserve">
          <source>You can pass more than one symbol for each class method and the respective validations will be run in the same order as they were registered.</source>
          <target state="translated">각 클래스 메소드에 대해 둘 이상의 기호를 전달할 수 있으며 각 유효성 검사는 등록 된 순서와 동일한 순서로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="9c48e0af9d7313528e3a230a7ff4a3212c8cbed9" translate="yes" xml:space="preserve">
          <source>You can pass options to a polymorphic mapping - the arity for the block needs to be two as the instance is passed as the first argument, e.g:</source>
          <target state="translated">옵션을 다형성 매핑에 전달할 수 있습니다. 인스턴스가 첫 번째 인수로 전달 될 때 블록의 arity는 2 여야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="ddeb1cda8fa9c9d65829e74c859b1d0683612d76" translate="yes" xml:space="preserve">
          <source>You can pass parameters from the client side to the server side when creating a subscription. For example:</source>
          <target state="translated">서브 스크립 션을 작성할 때 클라이언트 측에서 서버 측으로 매개 변수를 전달할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="822af7778fbe473b3594f616ddb7b54e05b6ec6f" translate="yes" xml:space="preserve">
          <source>You can pass specific annotations by using the &lt;code&gt;--annotations&lt;/code&gt; argument. By default, it will search for FIXME, OPTIMIZE, and TODO. Note that annotations are case sensitive.</source>
          <target state="translated">&lt;code&gt;--annotations&lt;/code&gt; 인수 를 사용하여 특정 주석을 전달할 수 있습니다 . 기본적으로 FIXME, OPTIMIZE 및 TODO를 검색합니다. 주석은 대소 문자를 구분합니다.</target>
        </trans-unit>
        <trans-unit id="c28be36744dee3e7045122eba376e828d7a805be" translate="yes" xml:space="preserve">
          <source>You can pass the block as a string to be evaluated in the context of the block. A lambda can be passed for the block as well.</source>
          <target state="translated">블록의 컨텍스트에서 평가할 문자열을 블록으로 전달할 수 있습니다. 람다는 블록에도 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b7651f984e79d6f180b39d16b3733e7d3daef9c6" translate="yes" xml:space="preserve">
          <source>You can pass the following options to change the default behavior. If you pass an option key that doesn't exist in the list below, it will raise an &lt;code&gt;ArgumentError&lt;/code&gt;.</source>
          <target state="translated">다음 옵션을 전달하여 기본 동작을 변경할 수 있습니다. 아래 목록에없는 옵션 키를 전달하면 &lt;code&gt;ArgumentError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="5cd21ed769b4575be4eb599d3ddf3dc377f79bd8" translate="yes" xml:space="preserve">
          <source>You can perform fragment caching in mailer views like in application views using the &lt;code&gt;cache&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;cache&lt;/code&gt; 방법을 사용하여 애플리케이션보기에서와 같이 메일러보기에서 단편 캐싱을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b2fb318ffd4c22f35900e1dbe20b1576cb6210d1" translate="yes" xml:space="preserve">
          <source>You can place objects in the session by using the &lt;code&gt;session&lt;/code&gt; method, which accesses a hash:</source>
          <target state="translated">해시에 액세스하는 &lt;code&gt;session&lt;/code&gt; 메소드 를 사용하여 세션에 객체를 배치 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64ed2cf52a086f8428ac9b8a4be32f3e63b6684d" translate="yes" xml:space="preserve">
          <source>You can precompile the assets in &lt;code&gt;app/assets&lt;/code&gt; using &lt;code&gt;rails assets:precompile&lt;/code&gt;, and remove older compiled assets using &lt;code&gt;rails assets:clean&lt;/code&gt;. The &lt;code&gt;assets:clean&lt;/code&gt; command allows for rolling deploys that may still be linking to an old asset while the new assets are being built.</source>
          <target state="translated">&lt;code&gt;rails assets:precompile&lt;/code&gt; 사용하여 &lt;code&gt;app/assets&lt;/code&gt; assets에서 자산 을 사전 컴파일하고 &lt;code&gt;rails assets:clean&lt;/code&gt; 사용하여 오래된 컴파일 된 자산을 제거 할 수 있습니다. &lt;code&gt;assets:clean&lt;/code&gt; 명령은 새로운 자산이 건설되는 동안 여전히 오래된 자산에 링크 할 수있다 전개함에 롤링 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28f39c65041ea0263f0caf27c476f6a09413830b" translate="yes" xml:space="preserve">
          <source>You can prefix routes with a named parameter also:</source>
          <target state="translated">명명 된 매개 변수로 경로를 접두사로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cbd6f1ece1f305d1c5ad9eee220c5297985dc68" translate="yes" xml:space="preserve">
          <source>You can prefix the queue name for all your jobs using &lt;code&gt;config.active_job.queue_name_prefix&lt;/code&gt; in &lt;code&gt;application.rb&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;application.rb&lt;/code&gt; 에서 &lt;code&gt;config.active_job.queue_name_prefix&lt;/code&gt; 를 사용하여 모든 작업의 ​​대기열 이름을 접두어로 붙일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c1f3e73931f16c89f5b3fef7cc288e64a72134c4" translate="yes" xml:space="preserve">
          <source>You can preview your email templates visually by adding a mailer preview file to the &lt;code&gt;ActionMailer::Base.preview_path&lt;/code&gt;. Since most emails do something interesting with database data, you'll need to write some scenarios to load messages with fake data:</source>
          <target state="translated">메일러 미리보기 파일을 &lt;code&gt;ActionMailer::Base.preview_path&lt;/code&gt; 에 추가하여 이메일 템플리트를 시각적으로 미리 볼 수 있습니다 . 대부분의 전자 메일은 데이터베이스 데이터와 관련하여 흥미로운 작업을 수행하므로 가짜 데이터가있는 메시지를로드하려면 몇 가지 시나리오를 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="06ec3704a9f798e0f9a5cd3de35690f5f482dc6f" translate="yes" xml:space="preserve">
          <source>You can quiet them down by setting ActiveRecord::Migration.verbose = false.</source>
          <target state="translated">ActiveRecord :: Migration.verbose = false를 설정하여 소리를 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f084bbe9af219bda931be7bf2865e8a68e13161f" translate="yes" xml:space="preserve">
          <source>You can read below about the different events that are fired dealing with remote elements inside your application.</source>
          <target state="translated">애플리케이션 내부의 원격 요소를 처리하는 다양한 이벤트에 대해 아래에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="27d9474b4755f717bb0265a25d8cd843dd71efbe" translate="yes" xml:space="preserve">
          <source>You can read more about about Cross-Site Request Forgery in &lt;a href=&quot;https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf&quot;&gt;Security&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://guides.rubyonrails.org/security.html#cross-site-request-forgery-csrf&quot;&gt;보안의&lt;/a&gt; 사이트 간 요청 위조에 대한 자세한 내용을 읽을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="94c7d7493d4877cc31e987dd713369b7cc438731" translate="yes" xml:space="preserve">
          <source>You can read more about each approach by clicking the modules below.</source>
          <target state="translated">아래 모듈을 클릭하여 각 접근 방식에 대한 자세한 내용을 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="988f86ca76b71a463157427b3badc23e94374905" translate="yes" xml:space="preserve">
          <source>You can read more about partials in the &lt;a href=&quot;layouts_and_rendering&quot;&gt;Layouts and Rendering in Rails&lt;/a&gt; guide.</source>
          <target state="translated">&lt;a href=&quot;layouts_and_rendering&quot;&gt;레일스&lt;/a&gt; 의 레이아웃 및 렌더링 안내서 에서 부분에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed0450d2efee58423c1386b438e5f277dd52a87f" translate="yes" xml:space="preserve">
          <source>You can read more about the Rails Internationalization (I18n) API &lt;a href=&quot;i18n&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Rails Internationalization (I18n) API에 대한 자세한 내용은 &lt;a href=&quot;i18n&quot;&gt;여기를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31248b64f7d2f2ee47b08cfda01dd589caf0994a" translate="yes" xml:space="preserve">
          <source>You can redirect any path to another path using the &lt;code&gt;redirect&lt;/code&gt; helper in your router:</source>
          <target state="translated">라우터 의 &lt;code&gt;redirect&lt;/code&gt; 도우미를 사용하여 경로를 다른 경로로 리디렉션 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0e3a9d45289276e9157bd5f51fbca04fc79abebb" translate="yes" xml:space="preserve">
          <source>You can redirect any path to another path using the redirect helper in your router:</source>
          <target state="translated">라우터의 리디렉션 도우미를 사용하여 경로를 다른 경로로 리디렉션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c00654a8b78ecb694433cb0a1609f4dd587d129b" translate="yes" xml:space="preserve">
          <source>You can refer to the modules included in &lt;code&gt;ActionController::Base&lt;/code&gt; to see other features you can bring into your metal controller.</source>
          <target state="translated">&lt;code&gt;ActionController::Base&lt;/code&gt; 에 포함 된 모듈 을 참조하여 금속 컨트롤러에 가져올 수있는 다른 기능을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="49cbebbedc03f8fa30674cb99d892f3db4d78e93" translate="yes" xml:space="preserve">
          <source>You can reload routes if you feel you must:</source>
          <target state="translated">필요하다고 생각되면 경로를 다시로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec601b590ebccdec5fa3b041efc3d5450322e63" translate="yes" xml:space="preserve">
          <source>You can retrieve it again through the same hash:</source>
          <target state="translated">동일한 해시를 통해 다시 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a72d98a402df568c72f090eb52ade150eeeb6c8" translate="yes" xml:space="preserve">
          <source>You can run &lt;code&gt;rails -T&lt;/code&gt; to see all the commands you're able to run. You should see the following:</source>
          <target state="translated">당신은 실행할 수 있습니다 &lt;code&gt;rails -T&lt;/code&gt; 실행할 수있어 모든 명령을 볼 수 있습니다. 다음이 표시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="d8954f2507b4641f2937af84a5a6e79e846127af" translate="yes" xml:space="preserve">
          <source>You can run EXPLAIN on the queries triggered by relations. For example,</source>
          <target state="translated">관계에 의해 트리거 된 쿼리에서 EXPLAIN을 실행할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="0c4ae7ce63b7674174b7c04a7c4469ca5eb759f5" translate="yes" xml:space="preserve">
          <source>You can save these settings in an &lt;code&gt;.byebugrc&lt;/code&gt; file in your home directory. The debugger reads these global settings when it starts. For example:</source>
          <target state="translated">이러한 설정은 홈 디렉토리 의 &lt;code&gt;.byebugrc&lt;/code&gt; 파일에 저장할 수 있습니다 . 디버거는 시작할 때 이러한 전역 설정을 읽습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bdf4a43944f9bdf40ce29ffd2a99d9b507a79c11" translate="yes" xml:space="preserve">
          <source>You can search through your routes with the grep option: -g. This outputs any routes that partially match the URL helper method name, the HTTP verb, or the URL path.</source>
          <target state="translated">grep 옵션을 사용하여 경로를 검색 할 수 있습니다 : -g. URL 도우미 메서드 이름, HTTP 동사 또는 URL 경로와 부분적으로 일치하는 경로를 출력합니다.</target>
        </trans-unit>
        <trans-unit id="dfbc5aaf5a5a18d2594e5a5626cdc47e6722d108" translate="yes" xml:space="preserve">
          <source>You can see all of the command line options that the Rails application builder accepts by running &lt;code&gt;rails new -h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rails new -h&lt;/code&gt; 를 실행하여 Rails 애플리케이션 빌더가 허용하는 모든 명령 행 옵션을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="04788ab9f898a4ef196b13c69495ebe99cb81d66" translate="yes" xml:space="preserve">
          <source>You can see if any associated objects exist by using the &lt;code&gt;association.nil?&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;association.nil?&lt;/code&gt; 을 사용하여 연결된 객체가 있는지 확인할 수 있습니다 . 방법:</target>
        </trans-unit>
        <trans-unit id="32f149e6ea2e2beeb843ac2936220563ef2b2684" translate="yes" xml:space="preserve">
          <source>You can see what the engine has so far by running &lt;code&gt;rails db:migrate&lt;/code&gt; at the root of our engine to run the migration generated by the scaffold generator, and then running &lt;code&gt;rails server&lt;/code&gt; in &lt;code&gt;test/dummy&lt;/code&gt;. When you open &lt;code&gt;http://localhost:3000/blorgh/articles&lt;/code&gt; you will see the default scaffold that has been generated. Click around! You've just generated your first engine's first functions.</source>
          <target state="translated">엔진 루트에서 &lt;code&gt;rails db:migrate&lt;/code&gt; 를 실행하여 스캐 폴드 생성기에서 생성 된 마이그레이션을 실행 한 다음 &lt;code&gt;rails server&lt;/code&gt; 를 &lt;code&gt;test/dummy&lt;/code&gt; 에서 실행하면 엔진의 현재 상태를 확인할 수 있습니다 . 당신이 열 때 &lt;code&gt;http://localhost:3000/blorgh/articles&lt;/code&gt; 당신이 생성 된 기본 골격을 볼 수 있습니다. 주위를 클릭하십시오! 첫 번째 엔진의 첫 번째 기능을 생성했습니다.</target>
        </trans-unit>
        <trans-unit id="8de9152c05d75779b6225d0496b6c087fabb78c3" translate="yes" xml:space="preserve">
          <source>You can send a raw content back to the browser, without setting any content type, by using the &lt;code&gt;:body&lt;/code&gt; option to &lt;code&gt;render&lt;/code&gt;:</source>
          <target state="translated">당신은 사용하여 콘텐츠 유형을 설정하지 않고, 브라우저에 원시 콘텐츠 등을 보낼 수 있습니다 &lt;code&gt;:body&lt;/code&gt; 하는 옵션을 &lt;code&gt;render&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dab63a11b5bc722cbb23363313530b897acb110a" translate="yes" xml:space="preserve">
          <source>You can send an HTML string back to the browser by using the &lt;code&gt;:html&lt;/code&gt; option to &lt;code&gt;render&lt;/code&gt;:</source>
          <target state="translated">당신은 사용하여 브라우저에 HTML 문자열을 다시 보낼 수 있습니다 &lt;code&gt;:html&lt;/code&gt; 하는 옵션을 &lt;code&gt;render&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="14a4b2b8f8eb39f0955a3505d3c14110efb88090" translate="yes" xml:space="preserve">
          <source>You can send parameters like this:</source>
          <target state="translated">다음과 같은 매개 변수를 보낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fbee11d801a3852eec1cb0969328238890f3b39" translate="yes" xml:space="preserve">
          <source>You can send plain text - with no markup at all - back to the browser by using the &lt;code&gt;:plain&lt;/code&gt; option to &lt;code&gt;render&lt;/code&gt;:</source>
          <target state="translated">당신은 일반 텍스트를 보낼 수 있습니다 - 전혀 마크 업 - 브라우저에 다시를 사용하여 &lt;code&gt;:plain&lt;/code&gt; 에 옵션을 &lt;code&gt;render&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9c88bd657c6d0b8d863c008c64413e67936b6073" translate="yes" xml:space="preserve">
          <source>You can set a default value for the attribute.</source>
          <target state="translated">속성의 기본값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83f823a5c604a701c801b3db623fc02454399589" translate="yes" xml:space="preserve">
          <source>You can set and reuse defaults in your fixtures YAML file. This is the same technique used in the &lt;code&gt;database.yml&lt;/code&gt; file to specify defaults:</source>
          <target state="translated">조명기 YAML 파일에서 기본값을 설정하고 재사용 할 수 있습니다. 이것은 &lt;code&gt;database.yml&lt;/code&gt; 파일에서 기본값을 지정 하는 데 사용 된 것과 동일한 기술입니다 .</target>
        </trans-unit>
        <trans-unit id="6644a6ae2134bf2d3b277a18d5f63f2f7d164118" translate="yes" xml:space="preserve">
          <source>You can set custom coder to encode/decode your serialized attributes to/from different formats. JSON, YAML, Marshal are supported out of the box. Generally it can be any wrapper that provides &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;dump&lt;/code&gt;.</source>
          <target state="translated">직렬화 된 속성을 다른 형식으로 / 다른 형식으로 인코딩 / 디코딩하도록 사용자 지정 코더를 설정할 수 있습니다. JSON, YAML, Marshal은 기본적으로 지원됩니다. 일반적으로 &lt;code&gt;load&lt;/code&gt; 및 &lt;code&gt;dump&lt;/code&gt; 를 제공하는 모든 랩퍼 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b3a5ef34eda7a02a27287551ff60bc389446846" translate="yes" xml:space="preserve">
          <source>You can set data attributes directly by passing in a data hash, but all other HTML options must be wrapped in the HTML key. Example:</source>
          <target state="translated">데이터 해시를 전달하여 데이터 속성을 직접 설정할 수 있지만 다른 모든 HTML 옵션은 HTML 키로 래핑해야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="39296409bcc45c4dab45dc96b4d7f40717785e55" translate="yes" xml:space="preserve">
          <source>You can set data attributes directly in a data hash, but HTML options besides id and class must be wrapped in an HTML key:</source>
          <target state="translated">데이터 해시에서 직접 데이터 속성을 설정할 수 있지만 id 및 class 이외의 HTML 옵션은 HTML 키로 래핑해야합니다.</target>
        </trans-unit>
        <trans-unit id="9d82d0b4e3ac695572386de4524f99f0d28eb6e4" translate="yes" xml:space="preserve">
          <source>You can set default values for any of the above headers (except &lt;code&gt;:date&lt;/code&gt;) by using the &lt;a href=&quot;base#method-c-default&quot;&gt;::default&lt;/a&gt; class method:</source>
          <target state="translated">&lt;a href=&quot;base#method-c-default&quot;&gt;:: default&lt;/a&gt; 클래스 메소드를 사용하여 위의 헤더 ( &lt;code&gt;:date&lt;/code&gt; 제외 )에 대한 기본값을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="200b57c0abad2a29eb9e95c2554e286b02511ff2" translate="yes" xml:space="preserve">
          <source>You can set global default parameters for URL generation by defining a method called &lt;code&gt;default_url_options&lt;/code&gt; in your controller. Such a method must return a hash with the desired defaults, whose keys must be symbols:</source>
          <target state="translated">컨트롤러에서 &lt;code&gt;default_url_options&lt;/code&gt; 라는 메소드를 정의하여 URL 생성을위한 글로벌 기본 매개 변수를 설정할 수 있습니다 . 이러한 메소드는 원하는 기본값을 가진 해시를 리턴해야하며 키는 기호 여야합니다.</target>
        </trans-unit>
        <trans-unit id="98d63a9244fd424ce0e95585c383c5d1a9d3d9ce" translate="yes" xml:space="preserve">
          <source>You can set it to a String, a Regexp, or an array of both.</source>
          <target state="translated">문자열, Regexp 또는 둘 다의 배열로 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03c1190acff6dd1f46a718415821e23cd0cbcf85" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;:autosave&lt;/code&gt; option on a &lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt;, &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt;, &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt;, or &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;has_and_belongs_to_many&lt;/a&gt; association. Setting it to &lt;code&gt;true&lt;/code&gt; will &lt;em&gt;always&lt;/em&gt; save the members, whereas setting it to &lt;code&gt;false&lt;/code&gt; will &lt;em&gt;never&lt;/em&gt; save the members. More details about &lt;code&gt;:autosave&lt;/code&gt; option is available at &lt;a href=&quot;../autosaveassociation&quot;&gt;AutosaveAssociation&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;classmethods#method-i-has_one&quot;&gt;has_one&lt;/a&gt; , &lt;a href=&quot;classmethods#method-i-belongs_to&quot;&gt;belongs_to&lt;/a&gt; , &lt;a href=&quot;classmethods#method-i-has_many&quot;&gt;has_many&lt;/a&gt; 또는 &lt;a href=&quot;classmethods#method-i-has_and_belongs_to_many&quot;&gt;has_and_belongs_to_many&lt;/a&gt; 연관 에서 &lt;code&gt;:autosave&lt;/code&gt; 옵션을 설정할 수 있습니다 . 로 설정하지 &lt;code&gt;true&lt;/code&gt; 의지 &lt;em&gt;항상&lt;/em&gt; 로 설정하는 반면, 구성원 저장 &lt;code&gt;false&lt;/code&gt; 것입니다 &lt;em&gt;결코&lt;/em&gt; 구성원 저장합니다. &lt;code&gt;:autosave&lt;/code&gt; 옵션 에 대한 자세한 내용은 &lt;a href=&quot;../autosaveassociation&quot;&gt;AutosaveAssociation&lt;/a&gt; 에서 사용할 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a4dc9f1aec0840aaecfb24fe729467390fffa3d0" translate="yes" xml:space="preserve">
          <source>You can set the &lt;code&gt;RAILS_SYSTEM_TESTING_SCREENSHOT&lt;/code&gt; environment variable to control the output. Possible values are:</source>
          <target state="translated">&lt;code&gt;RAILS_SYSTEM_TESTING_SCREENSHOT&lt;/code&gt; 환경 변수를 설정 하여 출력을 제어 할 수 있습니다 . 가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8a56950d93733a86d78cf00531c06d7cbbb60f82" translate="yes" xml:space="preserve">
          <source>You can set the default value from the database declaration, like:</source>
          <target state="translated">다음과 같이 데이터베이스 선언에서 기본값을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dc9540e9fce12388cb457d2d1844ca3ec443deb8" translate="yes" xml:space="preserve">
          <source>You can set the option to &lt;code&gt;true&lt;/code&gt; for using default locale as fallback, like so:</source>
          <target state="translated">다음 과 같이 기본 로캘을 폴백으로 사용 하기 위해 옵션을 &lt;code&gt;true&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bfd05e9aeff161745c53e0582e588df3928d35ab" translate="yes" xml:space="preserve">
          <source>You can set the variant in a &lt;code&gt;before_action&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;before_action&lt;/code&gt; 에서 변형을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42f146bffc93bb7d75bb84705d28f0b2d313ca29" translate="yes" xml:space="preserve">
          <source>You can set up as many dynamic segments within a regular route as you like. Any segment will be available to the action as part of &lt;code&gt;params&lt;/code&gt;. If you set up this route:</source>
          <target state="translated">일반 경로 내에서 원하는만큼 동적 세그먼트를 설정할 수 있습니다. 모든 세그먼트는 &lt;code&gt;params&lt;/code&gt; 의 일부로 조치에 사용 가능합니다 . 이 경로를 설정 한 경우 :</target>
        </trans-unit>
        <trans-unit id="cb825b898c3f8ca013236437c77464d1d1162756" translate="yes" xml:space="preserve">
          <source>You can set up generators for engines with &lt;code&gt;config.generators&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;config.generators&lt;/code&gt; 메소드 를 사용하여 엔진 생성기를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88e5d22065491fd65ba10273fcaaf17333e54e83" translate="yes" xml:space="preserve">
          <source>You can set up your application's default cache store by setting the &lt;code&gt;config.cache_store&lt;/code&gt; configuration option. Other parameters can be passed as arguments to the cache store's constructor:</source>
          <target state="translated">&lt;code&gt;config.cache_store&lt;/code&gt; 구성 옵션 을 설정하여 애플리케이션의 기본 캐시 저장소를 설정할 수 있습니다. 다른 매개 변수는 캐시 저장소의 생성자에 인수로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bc2e6f9daa90bfa579eac56d832bc85593030d7" translate="yes" xml:space="preserve">
          <source>You can specify a full path relative to the document root, or a URL, if you prefer. For example, to link to a JavaScript file that is inside a directory called &lt;code&gt;javascripts&lt;/code&gt; inside of one of &lt;code&gt;app/assets&lt;/code&gt;, &lt;code&gt;lib/assets&lt;/code&gt; or &lt;code&gt;vendor/assets&lt;/code&gt;, you would do this:</source>
          <target state="translated">원하는 경우 문서 루트 또는 URL에 상대적인 전체 경로를 지정할 수 있습니다. 예를 들어 &lt;code&gt;app/assets&lt;/code&gt; , &lt;code&gt;lib/assets&lt;/code&gt; 또는 &lt;code&gt;vendor/assets&lt;/code&gt; 중 하나의 &lt;code&gt;javascripts&lt;/code&gt; 디렉토리에있는 JavaScript 파일에 링크하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="c997a00c6b426612cc8c0d877565f65c632f5c77" translate="yes" xml:space="preserve">
          <source>You can specify a full path relative to the document root, or a URL. For example, to link to a stylesheet file that is inside a directory called &lt;code&gt;stylesheets&lt;/code&gt; inside of one of &lt;code&gt;app/assets&lt;/code&gt;, &lt;code&gt;lib/assets&lt;/code&gt; or &lt;code&gt;vendor/assets&lt;/code&gt;, you would do this:</source>
          <target state="translated">문서 루트 또는 URL에 상대적인 전체 경로를 지정할 수 있습니다. 예를 들어 &lt;code&gt;app/assets&lt;/code&gt; , &lt;code&gt;lib/assets&lt;/code&gt; 또는 &lt;code&gt;vendor/assets&lt;/code&gt; 중 하나에있는 &lt;code&gt;stylesheets&lt;/code&gt; 디렉토리 내에있는 스타일 시트 파일에 링크하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b1fd77e93cb4f9294f065ae9e5a35a8c480b29cc" translate="yes" xml:space="preserve">
          <source>You can specify a name for any route using the &lt;code&gt;:as&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:as&lt;/code&gt; 옵션을 사용하여 경로 이름을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="769d79e42ed90236159e53e94828cc1efc172aff" translate="yes" xml:space="preserve">
          <source>You can specify a partial to be rendered between elements via the &lt;code&gt;:spacer_template&lt;/code&gt; option. The following example will render &lt;code&gt;advertiser/_ad_divider.html.erb&lt;/code&gt; between each ad partial:</source>
          <target state="translated">&lt;code&gt;:spacer_template&lt;/code&gt; 옵션을 통해 요소간에 렌더링 할 부분을 지정할 수 있습니다 . 다음 예는 각 광고 부분 사이에 &lt;code&gt;advertiser/_ad_divider.html.erb&lt;/code&gt; 를 렌더링합니다 .</target>
        </trans-unit>
        <trans-unit id="4c1dd4672a83f36deda67d570bf162ba208e88ed" translate="yes" xml:space="preserve">
          <source>You can specify a regular expression to define a format for a parameter.</source>
          <target state="translated">정규식을 지정하여 매개 변수의 형식을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee3172278262bcac44f5fa75481081543b57477f" translate="yes" xml:space="preserve">
          <source>You can specify a single constraint to apply to a number of routes by using the block form:</source>
          <target state="translated">블록 형식을 사용하여 여러 경로에 적용 할 단일 구속 조건을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230b35d74b42e511f741a7754a12594ea78b498f" translate="yes" xml:space="preserve">
          <source>You can specify a validator type to the returned error details hash using the &lt;code&gt;errors.add&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;errors.add&lt;/code&gt; 메소드를 사용하여 리턴 된 오류 세부 사항 해시에 유효성 검증기 유형을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e49c70db1b9d10a2696fd10e6f8d3e76dbc2b95d" translate="yes" xml:space="preserve">
          <source>You can specify an alternative logger in &lt;code&gt;config/application.rb&lt;/code&gt; or any other environment file, for example:</source>
          <target state="translated">&lt;code&gt;config/application.rb&lt;/code&gt; 또는 다른 환경 파일 에서 대체 로거를 지정할 수 있습니다 ( 예 :</target>
        </trans-unit>
        <trans-unit id="8022c2b80cec7e1a54e313244ae229f31233fae4" translate="yes" xml:space="preserve">
          <source>You can specify an exclamation point (&lt;code&gt;!&lt;/code&gt;) on the end of the dynamic finders to get them to raise an &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; error if they do not return any records, like &lt;code&gt;Client.find_by_name!(&quot;Ryan&quot;)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;Client.find_by_name!(&quot;Ryan&quot;)&lt;/code&gt; 과 같은 레코드를 반환하지 않으면 동적 파인더 끝에 느낌표 ( &lt;code&gt;!&lt;/code&gt; )를 지정하여 &lt;code&gt;ActiveRecord::RecordNotFound&lt;/code&gt; 오류를 발생 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5bcaf6a23afbc1cfd71ed07da02c228125321b5b" translate="yes" xml:space="preserve">
          <source>You can specify callbacks using &lt;code&gt;before_action&lt;/code&gt; and &lt;code&gt;after_action&lt;/code&gt; for configuring your messages. This may be useful, for example, when you want to add default inline attachments for all messages sent out by a certain mailer class:</source>
          <target state="translated">메시지 구성을 위해 &lt;code&gt;before_action&lt;/code&gt; 및 &lt;code&gt;after_action&lt;/code&gt; 을 사용하여 콜백을 지정할 수 있습니다 . 예를 들어 특정 메일러 클래스가 보낸 모든 메시지에 기본 인라인 첨부 파일을 추가하려는 경우에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e806cbaacedba114a72a445096e96b77ef949ed8" translate="yes" xml:space="preserve">
          <source>You can specify certain conditions to be removed using the &lt;code&gt;unscope&lt;/code&gt; method. For example:</source>
          <target state="translated">&lt;code&gt;unscope&lt;/code&gt; 방법을 사용하여 제거 할 특정 조건을 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59c0ac45efbbf1b0f8c0da9b5ef679e2ba0548f9" translate="yes" xml:space="preserve">
          <source>You can specify conditions on the joined tables using the regular &lt;a href=&quot;#array-conditions&quot;&gt;Array&lt;/a&gt; and &lt;a href=&quot;#pure-string-conditions&quot;&gt;String&lt;/a&gt; conditions. &lt;a href=&quot;#hash-conditions&quot;&gt;Hash conditions&lt;/a&gt; provide a special syntax for specifying conditions for the joined tables:</source>
          <target state="translated">일반 &lt;a href=&quot;#array-conditions&quot;&gt;배열&lt;/a&gt; 및 &lt;a href=&quot;#pure-string-conditions&quot;&gt;문자열&lt;/a&gt; 조건을 사용하여 조인 된 테이블에 조건을 지정할 수 있습니다 . &lt;a href=&quot;#hash-conditions&quot;&gt;해시 조건&lt;/a&gt; 은 결합 된 테이블의 조건을 지정하기위한 특수 구문을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="88d33a0609f88167523a6a33b06da97823fa41d4" translate="yes" xml:space="preserve">
          <source>You can specify static segments when creating a route by not prepending a colon to a fragment:</source>
          <target state="translated">콜론을 조각 앞에 추가하지 않고 라우트를 작성할 때 정적 세그먼트를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f15d1b1855ffa0c6966bcf19894ae36301761577" translate="yes" xml:space="preserve">
          <source>You can specify that the callback should only be fired by a certain action with the &lt;code&gt;:on&lt;/code&gt; option:</source>
          <target state="translated">&lt;code&gt;:on&lt;/code&gt; 옵션을 사용하여 특정 작업으로 만 콜백을 시작하도록 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a4540680900ac571fd54d2d8e86e62fd412ccb7" translate="yes" xml:space="preserve">
          <source>You can specify the environment in which the &lt;code&gt;console&lt;/code&gt; command should operate.</source>
          <target state="translated">&lt;code&gt;console&lt;/code&gt; 명령이 작동 할 환경을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec5a8b1037527e768af254a0bbc318037d780cad" translate="yes" xml:space="preserve">
          <source>You can specify the environment in which the &lt;code&gt;runner&lt;/code&gt; command should operate using the &lt;code&gt;-e&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;runner&lt;/code&gt; 명령이 &lt;code&gt;-e&lt;/code&gt; 스위치를 사용하여 작동해야하는 환경을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cfe03657048c4c53798d60b931e985e11e7db0f" translate="yes" xml:space="preserve">
          <source>You can specify unicode character routes directly. For example:</source>
          <target state="translated">유니 코드 문자 경로를 직접 지정할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3fbfc58ea22f1b51e989f343fbb9846358bdb077" translate="yes" xml:space="preserve">
          <source>You can specify unicode character routes in your router:</source>
          <target state="translated">라우터에서 유니 코드 문자 경로를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8ae588112efd78728d88241062da3ad101454bc" translate="yes" xml:space="preserve">
          <source>You can specify what Rails should route &amp;ldquo;/&amp;rdquo; to with the root method:</source>
          <target state="translated">루트 방법으로 Rails가&amp;ldquo;/&amp;rdquo;를 라우팅 할 대상을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1ec99165aaa3e87fbf3a2efd432cd5e9ec7bfc3" translate="yes" xml:space="preserve">
          <source>You can specify what Rails should route &lt;code&gt;'/'&lt;/code&gt; to with the &lt;code&gt;root&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;root&lt;/code&gt; 메소드 를 사용하여 Rails에서 &lt;code&gt;'/'&lt;/code&gt; 를 라우팅 할 대상을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ace1e16da8fc96507e6c7c2ce5c034d1e108f9ff" translate="yes" xml:space="preserve">
          <source>You can specify what serializer to use:</source>
          <target state="translated">사용할 직렬 변환기를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="15ba2d0dfbb31d52a876b0a3ce6534ee37349fe5" translate="yes" xml:space="preserve">
          <source>You can stack callbacks on a single event by passing them as an array:</source>
          <target state="translated">콜백을 배열로 전달하여 단일 이벤트에 콜백을 쌓을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdeef9de4abb52721ffdb5e496cf4bffe1d8a86b" translate="yes" xml:space="preserve">
          <source>You can start a transaction and acquire the lock in one go by calling &lt;code&gt;with_lock&lt;/code&gt; with a block. The block is called from within a transaction, the object is already locked. Example:</source>
          <target state="translated">&lt;code&gt;with_lock&lt;/code&gt; 을 블록 으로 호출하여 트랜잭션을 시작하고 한 번에 잠금을 획득 할 수 있습니다 . 트랜잭션 내에서 블록이 호출되고 개체가 이미 잠겨 있습니다. 예:</target>
        </trans-unit>
        <trans-unit id="714eff2aba7a3cbcd4eebf099c5e1ddacfa36403" translate="yes" xml:space="preserve">
          <source>You can stop execution of the Ajax request by running &lt;code&gt;event.preventDefault()&lt;/code&gt; from the handlers methods &lt;code&gt;ajax:before&lt;/code&gt; or &lt;code&gt;ajax:beforeSend&lt;/code&gt;. The &lt;code&gt;ajax:before&lt;/code&gt; event can manipulate form data before serialization and the &lt;code&gt;ajax:beforeSend&lt;/code&gt; event is useful for adding custom request headers.</source>
          <target state="translated">핸들러 메소드 &lt;code&gt;ajax:before&lt;/code&gt; 또는 &lt;code&gt;ajax:beforeSend&lt;/code&gt; 에서 &lt;code&gt;event.preventDefault()&lt;/code&gt; 를 실행하여 Ajax 요청의 실행을 중지 할 수 있습니다 . &lt;code&gt;ajax:before&lt;/code&gt; 이벤트 직렬화 전 형태 데이터를 조작 할 수 &lt;code&gt;ajax:beforeSend&lt;/code&gt; 이벤트가 사용자 요청 헤더를 추가 할 때 유용하다.</target>
        </trans-unit>
        <trans-unit id="e9475189fe4eb6d7c6233e9a2c54ad961d01f869" translate="yes" xml:space="preserve">
          <source>You can stop streaming from all broadcasts by calling &lt;a href=&quot;streams#method-i-stop_all_streams&quot;&gt;stop_all_streams&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;streams#method-i-stop_all_streams&quot;&gt;stop_all_streams&lt;/a&gt; 를 호출하여 모든 브로드 캐스트에서 스트리밍을 중지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="009c66c2e63d092870be55804e256d4f71057540" translate="yes" xml:space="preserve">
          <source>You can subscribe to events by passing a &lt;a href=&quot;../string&quot;&gt;String&lt;/a&gt; to match exact event names, or by passing a Regexp to match all events that match a pattern.</source>
          <target state="translated">정확한 이벤트 이름과 일치하도록 &lt;a href=&quot;../string&quot;&gt;문자열&lt;/a&gt; 을 전달하거나 패턴과 일치하는 모든 이벤트와 일치하도록 Regexp를 전달하여 이벤트를 구독 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2330d33c8675bb02a254f9f9256b7011077f3f6c" translate="yes" xml:space="preserve">
          <source>You can subscribe to some event temporarily while some block runs. For example, in</source>
          <target state="translated">일부 블록이 실행되는 동안 일부 이벤트를 일시적으로 구독 할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="5896c30f7b54fe0e6223ab5595f4513a75023113" translate="yes" xml:space="preserve">
          <source>You can supply a &lt;code&gt;:method&lt;/code&gt; argument to specify the HTTP verb:</source>
          <target state="translated">HTTP 동사를 지정하기 위해 &lt;code&gt;:method&lt;/code&gt; 인수를 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d1899832d2e363abf74d557905d3c84eb6238fb6" translate="yes" xml:space="preserve">
          <source>You can supply a hash of additional HTML options:</source>
          <target state="translated">추가 HTML 옵션의 해시를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b92a9881bee641204a8fc8bde604a58d5dab27bb" translate="yes" xml:space="preserve">
          <source>You can supply a path to the audio file if you like:</source>
          <target state="translated">원하는 경우 오디오 파일의 경로를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e474e4f202f734759b978f6a597bf647c5f9707" translate="yes" xml:space="preserve">
          <source>You can supply a path to the image if you like:</source>
          <target state="translated">원하는 경우 이미지의 경로를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec0e58ffa2b119e9add9c2b363b0f0afa3aa0eed" translate="yes" xml:space="preserve">
          <source>You can supply alternate text for the image which will be used if the user has images turned off in their browser. If you do not specify an alt text explicitly, it defaults to the file name of the file, capitalized and with no extension. For example, these two image tags would return the same code:</source>
          <target state="translated">사용자가 브라우저에서 이미지를 끈 경우 사용할 대체 텍스트를 이미지에 제공 할 수 있습니다. 대체 텍스트를 명시 적으로 지정하지 않으면 기본적으로 파일의 파일 이름이 대문자로 표시되며 확장자는 없습니다. 예를 들어이 두 이미지 태그는 동일한 코드를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98c87fd33789880d7e5ee418344e66e3157b70b7" translate="yes" xml:space="preserve">
          <source>You can swap an existing middleware in the middleware stack using &lt;code&gt;config.middleware.swap&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;config.middleware.swap&lt;/code&gt; 을 사용하여 미들웨어 스택에서 기존 미들웨어를 교체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a48e8591a68e13d153bad44cee1eecddb8e6fb9" translate="yes" xml:space="preserve">
          <source>You can test whether an object is compliant with the Active Model API by including &lt;code&gt;ActiveModel::Lint::Tests&lt;/code&gt; in your TestCase. It will include tests that tell you whether your object is fully compliant, or if not, which aspects of the API are not implemented.</source>
          <target state="translated">TestCase에 &lt;code&gt;ActiveModel::Lint::Tests&lt;/code&gt; 를 포함시켜 객체가 Active Model API를 준수하는지 테스트 할 수 있습니다 . 객체가 완전히 호환되는지 또는 그렇지 않은 경우 API의 어떤 측면이 구현되지 않았는지 알려주는 테스트가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b575b896cc8ed791f2f81d418e235669062ba3" translate="yes" xml:space="preserve">
          <source>You can then broadcast to this channel like this:</source>
          <target state="translated">그런 다음 다음과 같이이 채널로 브로드 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="879372112d05cea9169e5cf4927caf264a53622b" translate="yes" xml:space="preserve">
          <source>You can then broadcast to this channel using:</source>
          <target state="translated">그런 다음 다음을 사용하여이 채널로 브로드 캐스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cdbea70f948d4e44c7e77c5da35fac3e8693c29" translate="yes" xml:space="preserve">
          <source>You can then declare accessors to this store that are then accessible just like any other attribute of the model. This is very helpful for easily exposing store keys to a form or elsewhere that's already built around just accessing attributes on the model.</source>
          <target state="translated">그런 다음 모델의 다른 속성처럼 액세스 할 수있는이 상점에 대한 접근자를 선언 할 수 있습니다. 이는 모델의 속성에 액세스하기 위해 이미 작성된 양식 또는 다른 곳에 상점 키를 쉽게 노출시키는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1e2dc3c2530dda67d0db2bba3f5237f51c9d7861" translate="yes" xml:space="preserve">
          <source>You can then return to the root directory (&lt;code&gt;cd ../..&lt;/code&gt;) of your plugin and rerun the tests using &lt;code&gt;bin/test&lt;/code&gt;.</source>
          <target state="translated">그런 다음 플러그인 의 루트 디렉토리 ( &lt;code&gt;cd ../..&lt;/code&gt; ) 로 돌아가서 &lt;code&gt;bin/test&lt;/code&gt; 를 사용하여 테스트를 다시 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bb4815c656782ce685fa1c86a475f13f0e962ea7" translate="yes" xml:space="preserve">
          <source>You can then style this div however you'd like. The default scaffold that Rails generates, for example, adds this CSS rule:</source>
          <target state="translated">그런 다음 원하는 대로이 div의 스타일을 지정할 수 있습니다. 예를 들어 Rails가 생성하는 기본 스캐 폴드는 다음 CSS 규칙을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="ec6de18837f51e7ea287678797758284552c5dac" translate="yes" xml:space="preserve">
          <source>You can then submit this token as a X-CSRF-Token in your header for your Ajax requst. You do not need to add a CSRF for GET requests, only non-GET requests.</source>
          <target state="translated">그런 다음이 토큰을 Ajax 요청에 대한 헤더에 X-CSRF- 토큰으로 제출할 수 있습니다. GET 요청에는 CSRF를 추가 할 필요가없고 비 GET 요청 만 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="8160daa1935c1b5b329719d72b9061fd72d6b3fc" translate="yes" xml:space="preserve">
          <source>You can then use &lt;code&gt;content_for :not_authorized&lt;/code&gt; anywhere in your templates.</source>
          <target state="translated">그런 다음 템플릿의 어느 곳에서나 &lt;code&gt;content_for :not_authorized&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9f067df383a397b4c7514225034e01e0cdb4e4a" translate="yes" xml:space="preserve">
          <source>You can then use that variable anywhere else. For example:</source>
          <target state="translated">그런 다음 다른 곳에서 해당 변수를 사용할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e1ddb58f1493c93408ff47a7e0d565eb8688c5f" translate="yes" xml:space="preserve">
          <source>You can think of a layout as a method that is called with a block. If the user calls &lt;code&gt;yield :some_name&lt;/code&gt;, the block, by default, returns &lt;code&gt;content_for(:some_name)&lt;/code&gt;. If the user calls simply &lt;code&gt;yield&lt;/code&gt;, the default block returns &lt;code&gt;content_for(:layout)&lt;/code&gt;.</source>
          <target state="translated">레이아웃은 블록으로 호출되는 메소드로 생각할 수 있습니다. 사용자가 &lt;code&gt;yield :some_name&lt;/code&gt; 호출 하면 블록은 기본적으로 &lt;code&gt;content_for(:some_name)&lt;/code&gt; 반환합니다 . 사용자가 간단히 &lt;code&gt;yield&lt;/code&gt; 를 호출하면 기본 블록은 &lt;code&gt;content_for(:layout)&lt;/code&gt; 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a1e0385f81a5a70fd9b7c55a838342e613fee85b" translate="yes" xml:space="preserve">
          <source>You can think of a polymorphic &lt;code&gt;belongs_to&lt;/code&gt; declaration as setting up an interface that any other model can use. From an instance of the &lt;code&gt;Employee&lt;/code&gt; model, you can retrieve a collection of pictures: &lt;code&gt;@employee.pictures&lt;/code&gt;.</source>
          <target state="translated">다형성 &lt;code&gt;belongs_to&lt;/code&gt; 선언은 다른 모델이 사용할 수있는 인터페이스를 설정하는 것으로 생각할 수 있습니다. &lt;code&gt;Employee&lt;/code&gt; 모델 의 인스턴스에서 &lt;code&gt;@employee.pictures&lt;/code&gt; 사진 모음을 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0bd5154ccb7a51928333adde50e4b7d52965d37b" translate="yes" xml:space="preserve">
          <source>You can think of each migration as being a new 'version' of the database. A schema starts off with nothing in it, and each migration modifies it to add or remove tables, columns, or entries. Active Record knows how to update your schema along this timeline, bringing it from whatever point it is in the history to the latest version. Active Record will also update your &lt;code&gt;db/schema.rb&lt;/code&gt; file to match the up-to-date structure of your database.</source>
          <target state="translated">각 마이그레이션을 데이터베이스의 새로운 '버전'으로 생각할 수 있습니다. 스키마는 아무 것도없는 상태에서 시작하며 각 마이그레이션은 테이블, 열 또는 항목을 추가하거나 제거하도록 스키마를 수정합니다. Active Record는이 타임 라인에 따라 스키마를 업데이트하는 방법을 알고 있으며 기록의 어느 지점에서나 최신 버전으로 가져옵니다. Active Record는 또한 데이터베이스의 최신 구조와 일치하도록 &lt;code&gt;db/schema.rb&lt;/code&gt; 파일을 업데이트합니다 .</target>
        </trans-unit>
        <trans-unit id="a0d43d94c64948469d0ff03eb54aa07c63741808" translate="yes" xml:space="preserve">
          <source>You can turn off debug mode by updating &lt;code&gt;config/environments/development.rb&lt;/code&gt; to include:</source>
          <target state="translated">다음을 포함하도록 &lt;code&gt;config/environments/development.rb&lt;/code&gt; 를 업데이트하여 디버그 모드를 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d8cc246bbdfa5a6590a8aeae918997b5c16662b" translate="yes" xml:space="preserve">
          <source>You can turn off digests by updating &lt;code&gt;config/environments/development.rb&lt;/code&gt; to include:</source>
          <target state="translated">다음을 포함하도록 &lt;code&gt;config/environments/development.rb&lt;/code&gt; 를 업데이트하여 요약을 끌 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a312de7208c1b49165434de1e750b28852355ad8" translate="yes" xml:space="preserve">
          <source>You can turn off the automatic detection of inverse associations by setting the &lt;code&gt;:inverse_of&lt;/code&gt; option to &lt;code&gt;false&lt;/code&gt; like so:</source>
          <target state="translated">&lt;code&gt;:inverse_of&lt;/code&gt; 옵션을 &lt;code&gt;false&lt;/code&gt; 로 설정하여 역 연관의 자동 감지를 해제 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd3ae34adb037477068eb8fbdb44e5d9dc2bdd59" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;ActionCable.createConsumer()&lt;/code&gt; to connect to the cable server if &lt;code&gt;action_cable_meta_tag&lt;/code&gt; is invoked in the layout. Otherwise, A path is specified as first argument to &lt;code&gt;createConsumer&lt;/code&gt; (e.g. &lt;code&gt;ActionCable.createConsumer(&quot;/websocket&quot;)&lt;/code&gt;).</source>
          <target state="translated">레이아웃에서 &lt;code&gt;action_cable_meta_tag&lt;/code&gt; 가 호출 된 경우 &lt;code&gt;ActionCable.createConsumer()&lt;/code&gt; 를 사용하여 케이블 서버에 연결할 수 있습니다 . 그렇지 않으면 경로는 &lt;code&gt;createConsumer&lt;/code&gt; 의 첫 번째 인수로 지정됩니다 (예 : &lt;code&gt;ActionCable.createConsumer(&quot;/websocket&quot;)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a3905705cb7c87e0a5c3b9cd71bccb434f575770" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;limit&lt;/code&gt; to specify the number of records to be retrieved, and use &lt;code&gt;offset&lt;/code&gt; to specify the number of records to skip before starting to return the records. For example</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;limit&lt;/code&gt; 검색 할 레코드 수를 지정하려면 사용 &lt;code&gt;offset&lt;/code&gt; 레코드를 반환을 시작하기 전에 건너 뛸 레코드의 수를 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="b17c15dced72e9af3c321ded6a737aadc9b5e211" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;local_assigns&lt;/code&gt; in the sub templates to access the local variables:</source>
          <target state="translated">하위 템플릿에서 &lt;code&gt;local_assigns&lt;/code&gt; 를 사용하여 로컬 변수에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0b3603c6fb4a409b36e5080315b5be84bce109a4" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;redirect_back&lt;/code&gt; to return the user to the page they just came from. This location is pulled from the &lt;code&gt;HTTP_REFERER&lt;/code&gt; header which is not guaranteed to be set by the browser, so you must provide the &lt;code&gt;fallback_location&lt;/code&gt; to use in this case.</source>
          <target state="translated">&lt;code&gt;redirect_back&lt;/code&gt; 을 사용 하여 사용자를 방금 온 페이지로 되돌릴 수 있습니다 . 이 위치는 &lt;code&gt;HTTP_REFERER&lt;/code&gt; 헤더 에서 가져와 브라우저에서 설정하지 않을 수 있으므로이 경우 사용할 &lt;code&gt;fallback_location&lt;/code&gt; 을 제공해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aa123839737dcc8f05d94dc5cd4679b2d6a447ab" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;uuid&lt;/code&gt; type to define references in migrations:</source>
          <target state="translated">&lt;code&gt;uuid&lt;/code&gt; 유형을 사용하여 마이그레이션에서 참조를 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deb85c11277f01b9c34fc9a09f00e0908ad4a66a" translate="yes" xml:space="preserve">
          <source>You can use Active Record's ability to rollback migrations using the &lt;code&gt;revert&lt;/code&gt; method:</source>
          <target state="translated">&lt;code&gt;revert&lt;/code&gt; 방법을 사용하여 Active Record의 마이그레이션 롤백 기능을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd72cb8386a48e87e825c83a5af2e145b89fbc78" translate="yes" xml:space="preserve">
          <source>You can use Hashes and Arrays of values as cache keys.</source>
          <target state="translated">해시 및 값 배열을 캐시 키로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33614f3da0a4e53131c3990a3d782f79ba2d87f7" translate="yes" xml:space="preserve">
          <source>You can use a block as well if your link target is hard to fit into the name parameter. ERB example:</source>
          <target state="translated">링크 대상이 name 매개 변수에 적합하지 않은 경우에도 블록을 사용할 수 있습니다. ERB 예 :</target>
        </trans-unit>
        <trans-unit id="2f9ac0993a207f9eef7a1bc6e0d33a7e63baf46b" translate="yes" xml:space="preserve">
          <source>You can use a shorthand syntax for rendering collections. Assuming &lt;code&gt;@products&lt;/code&gt; is a collection of &lt;code&gt;Product&lt;/code&gt; instances, you can simply write the following to produce the same result:</source>
          <target state="translated">컬렉션을 렌더링하기 위해 간단한 구문을 사용할 수 있습니다. &lt;code&gt;@products&lt;/code&gt; 가 &lt;code&gt;Product&lt;/code&gt; 인스턴스 의 모음 이라고 가정하면 다음을 간단히 작성하여 동일한 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65df486ec113987ad531024fd53520bd41fb8f7a" translate="yes" xml:space="preserve">
          <source>You can use a symbol to defer the choice of layout until a request is processed:</source>
          <target state="translated">요청을 처리 할 때까지 기호를 사용하여 레이아웃 선택을 연기 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef2eed113a1015bab2583c75a5e401c068b65203" translate="yes" xml:space="preserve">
          <source>You can use any of the standard &lt;a href=&quot;active_record_querying&quot;&gt;querying methods&lt;/a&gt; inside the scope block. The following ones are discussed below:</source>
          <target state="translated">범위 블록 내에서 표준 &lt;a href=&quot;active_record_querying&quot;&gt;쿼리 방법을&lt;/a&gt; 사용할 수 있습니다 . 다음은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c8dc4e44f22551db63f254b1147f12d264967e93" translate="yes" xml:space="preserve">
          <source>You can use strings in order to customize your joins:</source>
          <target state="translated">조인을 사용자 정의하기 위해 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="926f3672f793ba1729bda3182d9656dd588acb1b" translate="yes" xml:space="preserve">
          <source>You can use subfolders to organize your initializers if you like, because Rails will look into the whole file hierarchy from the initializers folder on down.</source>
          <target state="translated">Rails는 아래의 initializers 폴더에서 전체 파일 계층 구조를 조사하기 때문에 원하는 경우 하위 폴더를 사용하여 이니셜 라이저를 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="325c49ee88395253ef3dfd761ea9d6beba373536" translate="yes" xml:space="preserve">
          <source>You can use symbols or strings for the attribute names.</source>
          <target state="translated">속성 이름에 기호 또는 문자열을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0457253b76c8880b05f7d7998c8a4f8100fe166e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;:_prefix&lt;/code&gt; or &lt;code&gt;:_suffix&lt;/code&gt; options when you need to define multiple enums with same values. If the passed value is &lt;code&gt;true&lt;/code&gt;, the methods are prefixed/suffixed with the name of the enum. It is also possible to supply a custom value:</source>
          <target state="translated">당신은 사용할 수 있습니다 &lt;code&gt;:_prefix&lt;/code&gt; 또는 &lt;code&gt;:_suffix&lt;/code&gt; 당신은 같은 값으로 여러 열거 형을 정의 할 때 옵션을. 전달 된 값이 &lt;code&gt;true&lt;/code&gt; 이면 메소드 이름 앞에 열거 형 접미사 / 접미사가 붙습니다. 사용자 정의 값을 제공 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="26727172aa92cce8412e9fe0802d6ad37e164927" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;:as&lt;/code&gt; option to prefix the named route helpers that Rails generates for a route. Use this option to prevent name collisions between routes using a path scope. For example:</source>
          <target state="translated">&lt;code&gt;:as&lt;/code&gt; 옵션을 사용하여 Rails가 경로에 대해 생성하는 명명 된 경로 도우미를 접두어 로 사용할 수 있습니다 . 경로 범위를 사용하는 경로 간의 이름 충돌을 방지하려면이 옵션을 사용하십시오. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a11f9f8cf2416f243e8db24e44e6d138b71297e" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;:constraints&lt;/code&gt; option to enforce a format for a dynamic segment:</source>
          <target state="translated">&lt;code&gt;:constraints&lt;/code&gt; 옵션을 사용하여 동적 세그먼트에 형식을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="345a6e11729dcf24593b45e991a36ccbd0ea3b58" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;:constraints&lt;/code&gt; option to specify a required format on the implicit &lt;code&gt;id&lt;/code&gt;. For example:</source>
          <target state="translated">&lt;code&gt;:constraints&lt;/code&gt; 옵션을 사용하여 암시 적 &lt;code&gt;id&lt;/code&gt; 에 필요한 형식을 지정할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="31cdda9ee709b09f2a821a4da769bd06c215ed3a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;:layout&lt;/code&gt; option to tell Rails to use a specific file as the layout for the current action:</source>
          <target state="translated">&lt;code&gt;:layout&lt;/code&gt; 옵션을 사용하여 Rails에게 특정 파일을 현재 작업의 레이아웃으로 사용하도록 지시 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="54192e3538ad8ec81011221d0844600ed07bcecd" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;:location&lt;/code&gt; option to set the HTTP &lt;code&gt;Location&lt;/code&gt; header:</source>
          <target state="translated">&lt;code&gt;:location&lt;/code&gt; 옵션을 사용하여 HTTP &lt;code&gt;Location&lt;/code&gt; 헤더 를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="08debfd2f4f788907c2b806b7eb333b6a2acd893" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;app:template&lt;/code&gt; rails command to apply templates to an existing Rails application. The location of the template needs to be passed in via the LOCATION environment variable. Again, this can either be path to a file or a URL.</source>
          <target state="translated">&lt;code&gt;app:template&lt;/code&gt; rails 명령을 사용하여 기존 Rails 애플리케이션에 템플릿을 적용 할 수 있습니다 . 템플릿의 위치는 LOCATION 환경 변수를 통해 전달되어야합니다. 다시 말하지만, 이것은 파일 또는 URL의 경로 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e3c62cef27759a9a3affddb3775aa0b23bae7e86" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;byebug&lt;/code&gt; gem to set breakpoints and step through live code in Rails. To install it, just run:</source>
          <target state="translated">&lt;code&gt;byebug&lt;/code&gt; gem을 사용하여 중단 점을 설정하고 Rails에서 라이브 코드를 단계별로 실행할 수 있습니다 . 설치하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c17ef4573596abd3f5ae7dc7d061b53b7ef87b72" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;includes&lt;/code&gt; method to specify second-order associations that should be eager-loaded when this association is used.</source>
          <target state="translated">&lt;code&gt;includes&lt;/code&gt; 메소드를 사용하여이 연관을 사용할 때 열어야 할 2 차 연관을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="88bc5297f0fca7e8110ddaeb4fe5f54f5fdf69df" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;includes&lt;/code&gt; method to specify second-order associations that should be eager-loaded when this association is used. For example, consider these models:</source>
          <target state="translated">&lt;code&gt;includes&lt;/code&gt; 메소드를 사용하여이 연관을 사용할 때 열어야 할 2 차 연관을 지정할 수 있습니다 . 예를 들어 다음 모델을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="395939bc64ca2f6c173097feb0b20408aa800e47" translate="yes" xml:space="preserve">
          <source>You can use the methods &lt;code&gt;Model.model_name.human&lt;/code&gt; and &lt;code&gt;Model.human_attribute_name(attribute)&lt;/code&gt; to transparently look up translations for your model and attribute names.</source>
          <target state="translated">&lt;code&gt;Model.model_name.human&lt;/code&gt; 및 &lt;code&gt;Model.human_attribute_name(attribute)&lt;/code&gt; 메소드를 사용 하여 모델 및 속성 이름에 대한 번역을 투명하게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="477bad5f77e1edb8ece3031f817af82871b3fc4e" translate="yes" xml:space="preserve">
          <source>You can use the same string replacement techniques as you can with &lt;code&gt;ActiveRecord::QueryMethods#where&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ActiveRecord::QueryMethods#where&lt;/code&gt; 와 동일한 문자열 대체 기술을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ae6d7b66e316f3e6f3ed02b6e27e10217ad9cf0" translate="yes" xml:space="preserve">
          <source>You can use the same technique to localize the rescue files in your public directory. For example, setting &lt;code&gt;I18n.locale = :de&lt;/code&gt; and creating &lt;code&gt;public/500.de.html&lt;/code&gt; and &lt;code&gt;public/404.de.html&lt;/code&gt; would allow you to have localized rescue pages.</source>
          <target state="translated">동일한 기술을 사용하여 공용 디렉토리의 복구 파일을 현지화 할 수 있습니다. 예를 들어, &lt;code&gt;I18n.locale = :de&lt;/code&gt; 설정 하고 &lt;code&gt;public/500.de.html&lt;/code&gt; 및 &lt;code&gt;public/404.de.html&lt;/code&gt; 을 작성하면 지역화 된 구조 페이지를 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58f140165c81ad318674b38a86a40c849f58b0e8" translate="yes" xml:space="preserve">
          <source>You can use the signed ID of a blob to refer to it on the client side without fear of tampering. This is particularly helpful for direct uploads where the client-side needs to refer to the blob that was created ahead of the upload itself on form submission.</source>
          <target state="translated">서명 된 Blob의 ID를 사용하여 조작에 대한 두려움없이 클라이언트 측에서 참조 할 수 있습니다. 이는 클라이언트 측에서 양식 제출시 업로드 자체보다 먼저 작성된 Blob을 참조해야하는 직접 업로드에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c2311419f79428af7da0c7e57a0d9e03c88ca5a8" translate="yes" xml:space="preserve">
          <source>You can use these events to show the progress of an upload.</source>
          <target state="translated">이 이벤트를 사용하여 업로드 진행률을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca75ebbd6b977452e36990048ee415d2602887d6" translate="yes" xml:space="preserve">
          <source>You can use these tags in layouts or other views, although the &lt;code&gt;auto_discovery_link_tag&lt;/code&gt;, &lt;code&gt;javascript_include_tag&lt;/code&gt;, and &lt;code&gt;stylesheet_link_tag&lt;/code&gt;, are most commonly used in the &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; section of a layout.</source>
          <target state="translated">&lt;code&gt;auto_discovery_link_tag&lt;/code&gt; , &lt;code&gt;javascript_include_tag&lt;/code&gt; 및 &lt;code&gt;stylesheet_link_tag&lt;/code&gt; 가 레이아웃 의 &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; 섹션 에서 가장 일반적으로 사용 되지만 레이아웃 또는 다른보기에서이 태그를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="111b92c84fa0ff04eb963111e02002c20c797f77" translate="yes" xml:space="preserve">
          <source>You can use this method when you have an HTTP response that never changes, and the browser and proxies should cache it indefinitely.</source>
          <target state="translated">절대 변하지 않는 HTTP 응답이있을 때이 방법을 사용할 수 있으며 브라우저와 프록시는이를 무한정 캐시해야합니다.</target>
        </trans-unit>
        <trans-unit id="ec396b1d9adfd1e7553de98afc968a971fbb0c60" translate="yes" xml:space="preserve">
          <source>You can use this shortcut in a controller, instead of the previous example:</source>
          <target state="translated">이전 예제 대신 컨트롤러에서이 바로 가기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="509d0695e099b9cc232ce1c5a11236c795d126fe" translate="yes" xml:space="preserve">
          <source>You can view the search path by inspecting &lt;code&gt;Rails.application.config.assets.paths&lt;/code&gt; in the Rails console.</source>
          <target state="translated">Rails 콘솔에서 &lt;code&gt;Rails.application.config.assets.paths&lt;/code&gt; 를 검사하여 검색 경로를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbce7abba2dc88c127ff113280159282f06c5891" translate="yes" xml:space="preserve">
          <source>You cannot override defaults via query parameters - this is for security reasons. The only defaults that can be overridden are dynamic segments via substitution in the URL path.</source>
          <target state="translated">쿼리 매개 변수를 통해 기본값을 재정의 할 수 없습니다. 이는 보안상의 이유 때문입니다. 재정의 할 수있는 유일한 기본값은 URL 경로에서 대체를 통한 동적 세그먼트입니다.</target>
        </trans-unit>
        <trans-unit id="3fa4d915c6e34684c72dcea14b4da3ce8a251e52" translate="yes" xml:space="preserve">
          <source>You could also turn it on per controller by setting the format array to a non-empty array:</source>
          <target state="translated">형식 배열을 비어 있지 않은 배열로 설정하여 컨트롤러별로 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8fd3640ccf69ffc48e01247d64334c8a82ff61b8" translate="yes" xml:space="preserve">
          <source>You could also write the above &lt;code&gt;change_column_default&lt;/code&gt; migration as &lt;code&gt;change_column_default :products, :approved, false&lt;/code&gt;, but unlike the previous example, this would make your migration irreversible.</source>
          <target state="translated">위의 &lt;code&gt;change_column_default&lt;/code&gt; 마이그레이션을 &lt;code&gt;change_column_default :products, :approved, false&lt;/code&gt; 로 작성할 수도 있지만 이전 예제와 달리 마이그레이션을 되돌릴 수 없게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a3137142a630c9d51c495a82436b906489e50e79" translate="yes" xml:space="preserve">
          <source>You could specify &lt;code&gt;ASC&lt;/code&gt; or &lt;code&gt;DESC&lt;/code&gt; as well:</source>
          <target state="translated">&lt;code&gt;ASC&lt;/code&gt; 또는 &lt;code&gt;DESC&lt;/code&gt; 도 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a7a107a2ca55ada5d3da3e2756b26f816ed9752" translate="yes" xml:space="preserve">
          <source>You could use a &lt;code&gt;before_action&lt;/code&gt; to populate the mail object with defaults, delivery_method_options or insert default headers and attachments.</source>
          <target state="translated">&lt;code&gt;before_action&lt;/code&gt; 을 사용 하여 메일 오브젝트를 기본값, delivery_method_options로 채우거나 기본 헤더 및 첨부 파일을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12779942248601c1723a9daea3d90fc7ac0bdae8" translate="yes" xml:space="preserve">
          <source>You could use an &lt;code&gt;after_action&lt;/code&gt; to do similar setup as a &lt;code&gt;before_action&lt;/code&gt; but using instance variables set in your mailer action.</source>
          <target state="translated">당신은 사용할 수 &lt;code&gt;after_action&lt;/code&gt; 을 A와 비슷한 설정을 할 &lt;code&gt;before_action&lt;/code&gt; 하지만 메일러 행동에 설정된 인스턴스 변수를 사용하여.</target>
        </trans-unit>
        <trans-unit id="03c97303fc49a624b742e912bc84625c24767088" translate="yes" xml:space="preserve">
          <source>You define association callbacks by adding options to the association declaration. For example:</source>
          <target state="translated">연관 선언에 옵션을 추가하여 연관 콜백을 정의합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="995bbbfd5324308e8d61a316b152e158c82b3be8" translate="yes" xml:space="preserve">
          <source>You do not configure Zeitwerk manually in a Rails application. Rather, you configure the application using the portable configuration points explained in this guide, and Rails translates that to Zeitwerk on your behalf.</source>
          <target state="translated">Rails 애플리케이션에서 Zeitwerk를 수동으로 구성하지 마십시오. 오히려이 안내서에 설명 된 휴대용 구성 지점을 사용하여 응용 프로그램을 구성하면 Rails가이를 대신하여 Zeitwerk로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="fc096f65f5dc0c4fb2ae13070fabb6679f3ff367" translate="yes" xml:space="preserve">
          <source>You don't have to call this method to access the attachment's methods as they are all available at the model level.</source>
          <target state="translated">첨부 파일의 메소드가 모두 모델 레벨에서 사용 가능하므로이 메소드를 호출하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="a731437b0289a78370d177c37028cc9f1d617bf8" translate="yes" xml:space="preserve">
          <source>You don't have to rely on the automated rendering. For example, actions that could result in the rendering of different templates will use the manual rendering methods:</source>
          <target state="translated">자동화 된 렌더링에 의존 할 필요는 없습니다. 예를 들어, 다른 템플릿을 렌더링 할 수있는 작업은 수동 렌더링 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1b6095ab5d2243a43ea312660511b2b8ed43e290" translate="yes" xml:space="preserve">
          <source>You don't have to update the database configurations manually. If you look at the options of the application generator, you will see that one of the options is named &lt;code&gt;--database&lt;/code&gt;. This option allows you to choose an adapter from a list of the most used relational databases. You can even run the generator repeatedly: &lt;code&gt;cd .. &amp;amp;&amp;amp; rails new blog --database=mysql&lt;/code&gt;. When you confirm the overwriting of the &lt;code&gt;config/database.yml&lt;/code&gt; file, your application will be configured for MySQL instead of SQLite. Detailed examples of the common database connections are below.</source>
          <target state="translated">데이터베이스 구성을 수동으로 업데이트하지 않아도됩니다. 응용 프로그램 생성기의 옵션을 보면 옵션 중 하나의 이름이 &lt;code&gt;--database&lt;/code&gt; 임을 알 수 있습니다 . 이 옵션을 사용하면 가장 많이 사용되는 관계형 데이터베이스 목록에서 어댑터를 선택할 수 있습니다. 생성기를 반복해서 실행할 수도 있습니다. &lt;code&gt;cd .. &amp;amp;&amp;amp; rails new blog --database=mysql&lt;/code&gt; . &lt;code&gt;config/database.yml&lt;/code&gt; 파일 덮어 쓰기를 확인하면 응용 프로그램이 SQLite 대신 MySQL 용으로 구성됩니다. 공통 데이터베이스 연결의 자세한 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4c503fae8979882e8f434075e9417d6a02f05bdc" translate="yes" xml:space="preserve">
          <source>You don't need to call &lt;code&gt;to_json&lt;/code&gt; on the object that you want to render. If you use the &lt;code&gt;:json&lt;/code&gt; option, &lt;code&gt;render&lt;/code&gt; will automatically call &lt;code&gt;to_json&lt;/code&gt; for you.</source>
          <target state="translated">렌더링하려는 객체에서 &lt;code&gt;to_json&lt;/code&gt; 을 호출 할 필요는 없습니다 . &lt;code&gt;:json&lt;/code&gt; 옵션 을 사용하면 &lt;code&gt;render&lt;/code&gt; 가 자동으로 &lt;code&gt;to_json&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="1bb9d385e3f726a4bb6b3764ad9ab407a0e7c51d" translate="yes" xml:space="preserve">
          <source>You don't need to call &lt;code&gt;to_xml&lt;/code&gt; on the object that you want to render. If you use the &lt;code&gt;:xml&lt;/code&gt; option, &lt;code&gt;render&lt;/code&gt; will automatically call &lt;code&gt;to_xml&lt;/code&gt; for you.</source>
          <target state="translated">렌더링하려는 객체에서 &lt;code&gt;to_xml&lt;/code&gt; 을 호출 할 필요는 없습니다 . &lt;code&gt;:xml&lt;/code&gt; 옵션 을 사용하면 &lt;code&gt;render&lt;/code&gt; 가 자동으로 &lt;code&gt;to_xml&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="69b3e4cf1cbcff915677c14e1e9a94eecdaca575" translate="yes" xml:space="preserve">
          <source>You don't need to use these tags for regular forms as they generate their own hidden fields.</source>
          <target state="translated">숨겨진 필드를 생성하는 일반 양식에는이 태그를 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="40ceb12d19b0ef8aa034c118f9fa8ef660e71287" translate="yes" xml:space="preserve">
          <source>You get a concrete renderer class by invoking ActionController::Base#renderer. For example:</source>
          <target state="translated">ActionController :: Base # renderer를 호출하여 콘크리트 렌더러 클래스를 얻습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfdb48e445061536def73272bf1dfc6ec8aa0343" translate="yes" xml:space="preserve">
          <source>You may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for master. Make sure to check &lt;a href=&quot;https://edgeguides.rubyonrails.org&quot;&gt;Edge Guides&lt;/a&gt; first to verify if the issues are already fixed or not on the master branch. Check the Ruby on Rails Guides Guidelines for style and conventions.</source>
          <target state="translated">최신이 아닌 불완전한 내용이나 물건을 찾을 수도 있습니다. 마스터에 대한 누락 된 문서를 추가하십시오. 마스터 &lt;a href=&quot;https://edgeguides.rubyonrails.org&quot;&gt;가이드&lt;/a&gt; 에서 문제가 이미 수정되었는지 여부를 확인하려면 먼저 에지 가이드 를 확인하십시오 . 스타일과 규칙에 대해서는 Ruby on Rails Guides 가이드 라인을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="0ec98b7952e381ed67bd01ebe0481a6cab80bc92" translate="yes" xml:space="preserve">
          <source>You may also pass a custom stored procedure that returns a UUID or use a different UUID generation function from another library.</source>
          <target state="translated">UUID를 반환하거나 다른 라이브러리와 다른 UUID 생성 함수를 사용하는 사용자 지정 저장 프로 시저를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd6b10d206877ecd52ec3c3aec00575a8945a703" translate="yes" xml:space="preserve">
          <source>You may also pass block with only one argument, it will yield an event object to the block:</source>
          <target state="translated">하나의 인수로 블록을 전달할 수도 있습니다. 블록에 이벤트 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="37a1b72ec655d357add3217cdd9f81a1320b1d22" translate="yes" xml:space="preserve">
          <source>You may also pass it multiple classes, like so:</source>
          <target state="translated">다음과 같이 여러 클래스를 전달할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="57279de07432bf9089416bb8b5400a3b9da15f83" translate="yes" xml:space="preserve">
          <source>You may also set a &lt;code&gt;:reject_if&lt;/code&gt; proc to silently ignore any new record hashes if they fail to pass your criteria. For example, the previous example could be rewritten as:</source>
          <target state="translated">또한 새로운 레코드 해시가 기준을 통과하지 못하면 새 레코드 해시를 자동으로 무시하도록 &lt;code&gt;:reject_if&lt;/code&gt; 프로 시저를 설정할 수도 있습니다 . 예를 들어, 이전 예제는 다음과 같이 다시 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90de31e55648d20aa8c98b8f20b0cc023ece55c0" translate="yes" xml:space="preserve">
          <source>You may also set this option to &lt;code&gt;:hybrid&lt;/code&gt;, in which case Rails would transparently deserialize existing (&lt;code&gt;Marshal&lt;/code&gt;-serialized) cookies on read and re-write them in the &lt;code&gt;JSON&lt;/code&gt; format. This is useful for migrating existing applications to the &lt;code&gt;:json&lt;/code&gt; serializer.</source>
          <target state="translated">이 옵션을 &lt;code&gt;:hybrid&lt;/code&gt; 로 설정할 수도 있습니다.이 경우 Rails는 기존 ( &lt;code&gt;Marshal&lt;/code&gt; 직렬화) 쿠키를 투명하게 직렬화 하여 &lt;code&gt;JSON&lt;/code&gt; 형식으로 다시 작성합니다 . 기존 응용 프로그램을 &lt;code&gt;:json&lt;/code&gt; serializer 로 마이그레이션하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="33259156b80b5bfdbd8cd9598a9d79db22e6f180" translate="yes" xml:space="preserve">
          <source>You may also specify additional options via the &lt;code&gt;options&lt;/code&gt; argument. Setting &lt;code&gt;force: true&lt;/code&gt; forces a cache &amp;ldquo;miss,&amp;rdquo; meaning we treat the cache value as missing even if it's present. Passing a block is required when &lt;code&gt;force&lt;/code&gt; is true so this always results in a cache write.</source>
          <target state="translated">&lt;code&gt;options&lt;/code&gt; 인수 를 통해 추가 옵션을 지정할 수도 있습니다 . &lt;code&gt;force: true&lt;/code&gt; 설정 : true 는 캐시를 &quot;누락&quot;으로 강제합니다. 캐시 값이 존재하더라도 캐시 값이 누락 된 것으로 간주합니다. &lt;code&gt;force&lt;/code&gt; 가 true이면 블록을 전달해야 하므로 항상 캐시 쓰기가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c7634fe68b2ce3c8af0f7a1853cbcf931466aa1d" translate="yes" xml:space="preserve">
          <source>You may also subscribe to events matching a regular expression. This enables you to subscribe to multiple events at once. Here's you could subscribe to everything from &lt;code&gt;ActionController&lt;/code&gt;.</source>
          <target state="translated">정규식과 일치하는 이벤트를 구독 할 수도 있습니다. 이를 통해 한 번에 여러 이벤트를 구독 할 수 있습니다. 다음은 &lt;code&gt;ActionController&lt;/code&gt; 의 모든 것을 구독 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19d40b47e9310fc15eef2212fd3d038234b38408" translate="yes" xml:space="preserve">
          <source>You may also want to configure other parameters like &lt;code&gt;:tcp_nodelay&lt;/code&gt;. Please check its documentation for more information: &lt;a href=&quot;https://bogomips.org/unicorn/Unicorn/Configurator.html#method-i-listen&quot;&gt;bogomips.org/unicorn/Unicorn/Configurator.html#method-i-listen&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;:tcp_nodelay&lt;/code&gt; 와 같은 다른 매개 변수를 구성 할 수도 있습니다 . 자세한 내용은 설명서를 확인하십시오. &lt;a href=&quot;https://bogomips.org/unicorn/Unicorn/Configurator.html#method-i-listen&quot;&gt;bogomips.org/unicorn/Unicorn/Configurator.html#method-i-listen&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d6bdc4407ccf427d5692074c5444adce38d43ee8" translate="yes" xml:space="preserve">
          <source>You may also want to use a separate service definition for the test environment so your tests don't delete the files you create during development.</source>
          <target state="translated">테스트 환경에서 별도의 서비스 정의를 사용하여 개발 중에 생성 한 파일을 테스트에서 삭제하지 않을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b46d7c554f865300880b6c74b1090b6ea8cb5ba" translate="yes" xml:space="preserve">
          <source>You may be deploying to more than one server, and want to avoid duplication of work.</source>
          <target state="translated">둘 이상의 서버에 배치하고 작업 중복을 피하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="344a01a20857b91311da97b5df493d01253f40da" translate="yes" xml:space="preserve">
          <source>You may be doing frequent deploys that do not include asset changes.</source>
          <target state="translated">자산 변경이 포함되지 않은 배포가 빈번 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e26e2c47afa15fcf1fbbd3284f1f17989c80bd06" translate="yes" xml:space="preserve">
          <source>You may be satisfied with this. It does impact the readability of URLs, though, when the locale &quot;hangs&quot; at the end of every URL in your application. Moreover, from the architectural standpoint, locale is usually hierarchically above the other parts of the application domain: and URLs should reflect this.</source>
          <target state="translated">당신은 이것에 만족할 것입니다. 그러나 로캘이 응용 프로그램의 모든 URL 끝에 &quot;정지&quot;될 때 URL의 가독성에 영향을줍니다. 또한 아키텍처 관점에서 로캘은 일반적으로 응용 프로그램 도메인의 다른 부분보다 계층 적으로 나타납니다. URL은이를 반영해야합니다.</target>
        </trans-unit>
        <trans-unit id="a6b00738ff784ab1cc863581f92d467d672ab61f" translate="yes" xml:space="preserve">
          <source>You may be tempted to store the chosen locale in a &lt;em&gt;session&lt;/em&gt; or a &lt;em&gt;cookie&lt;/em&gt;. However, &lt;strong&gt;do not do this&lt;/strong&gt;. The locale should be transparent and a part of the URL. This way you won't break people's basic assumptions about the web itself: if you send a URL to a friend, they should see the same page and content as you. A fancy word for this would be that you're being &lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;&lt;em&gt;RESTful&lt;/em&gt;&lt;/a&gt;. Read more about the RESTful approach in &lt;a href=&quot;https://www.infoq.com/articles/rest-introduction&quot;&gt;Stefan Tilkov's articles&lt;/a&gt;. Sometimes there are exceptions to this rule and those are discussed below.</source>
          <target state="translated">선택한 로케일을 &lt;em&gt;세션&lt;/em&gt; 이나 &lt;em&gt;쿠키&lt;/em&gt; 에 저장하려고 할 수 있습니다 . 그러나이 &lt;strong&gt;작업을 수행하지 마십시오&lt;/strong&gt; . 로케일은 투명하고 URL의 일부 여야합니다. 이렇게하면 웹 자체에 대한 사람들의 기본 가정을 어 기지 않아도됩니다. 친구에게 URL을 보내면 사용자와 동일한 페이지와 내용이 표시됩니다. 이것에 대한 멋진 단어는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Representational_State_Transfer&quot;&gt;&lt;em&gt;RESTful&lt;/em&gt;&lt;/a&gt; 되고 있다는 것 입니다. &lt;a href=&quot;https://www.infoq.com/articles/rest-introduction&quot;&gt;Stefan Tilkov의 기사&lt;/a&gt; 에서 RESTful 접근 방식에 대해 자세히 알아보십시오 . 때때로이 규칙에는 예외가 있으며 아래에서 논의됩니다.</target>
        </trans-unit>
        <trans-unit id="5909507516d8b5fe0c8badd73c539e9e4c20846c" translate="yes" xml:space="preserve">
          <source>You may declare that the parameter should be an array of permitted scalars by mapping it to an empty array:</source>
          <target state="translated">매개 변수를 빈 배열에 맵핑하여 매개 변수가 허용 된 스칼라의 배열이어야 함을 선언 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cecb87e616c0c692159c215a7d7555476f2e2e9e" translate="yes" xml:space="preserve">
          <source>You may find it convenient to eagerly require helpers in &lt;code&gt;test_helper.rb&lt;/code&gt; so your test files have implicit access to them. This can be accomplished using globbing, as follows</source>
          <target state="translated">&lt;code&gt;test_helper.rb&lt;/code&gt; 에 도우미가 간절히 필요 하므로 테스트 파일에 암시 적으로 액세스 할 수 있습니다. 다음과 같이 globbing을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23c2dcbe205807d2f34f44d29df3526e483934ed" translate="yes" xml:space="preserve">
          <source>You may find that your application requires a layout that differs slightly from your regular application layout to support one particular controller. Rather than repeating the main layout and editing it, you can accomplish this by using nested layouts (sometimes called sub-templates). Here's an example:</source>
          <target state="translated">특정 컨트롤러를 지원하기 위해 응용 프로그램에 일반 응용 프로그램 레이아웃과 약간 다른 레이아웃이 필요하다는 것을 알 수 있습니다. 기본 레이아웃을 반복하고 편집하는 대신 중첩 레이아웃 (하위 템플릿이라고도 함)을 사용하여이 작업을 수행 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4682b32de0f1abe8e092a7fcb6ef33d47493cf57" translate="yes" xml:space="preserve">
          <source>You may give an optional logger level (&lt;code&gt;:debug&lt;/code&gt;, &lt;code&gt;:info&lt;/code&gt;, &lt;code&gt;:warn&lt;/code&gt;, &lt;code&gt;:error&lt;/code&gt;) as the &lt;code&gt;:level&lt;/code&gt; option. The default logger level value is &lt;code&gt;:info&lt;/code&gt;.</source>
          <target state="translated">선택적인 로거 레벨 ( &lt;code&gt;:debug&lt;/code&gt; , &lt;code&gt;:info&lt;/code&gt; , &lt;code&gt;:warn&lt;/code&gt; , &lt;code&gt;:error&lt;/code&gt; )을 &lt;code&gt;:level&lt;/code&gt; 옵션으로 제공 할 수 있습니다. 기본 로거 레벨 값은 &lt;code&gt;:info&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="38d1eac50e4d68925ffaa1b205514b0d70780a6a" translate="yes" xml:space="preserve">
          <source>You may not have write access to your production file system.</source>
          <target state="translated">프로덕션 파일 시스템에 대한 쓰기 권한이 없을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c56380de0b4a7348b159edec7f5c43ef69af5ebb" translate="yes" xml:space="preserve">
          <source>You may notice in the above code that we're using &lt;code&gt;render xml: @users&lt;/code&gt;, not &lt;code&gt;render xml: @users.to_xml&lt;/code&gt;. If the object is not a String, then Rails will automatically invoke &lt;code&gt;to_xml&lt;/code&gt; for us.</source>
          <target state="translated">위 코드에서 &lt;code&gt;render xml: @users.to_xml&lt;/code&gt; 아니라 render xml : &lt;code&gt;render xml: @users&lt;/code&gt; 사용하고 있음을 알 수 있습니다 . 객체가 문자열이 아닌 경우 Rails는 자동으로 &lt;code&gt;to_xml&lt;/code&gt; 을 호출 합니다.</target>
        </trans-unit>
        <trans-unit id="88bce85959e2e42ccb7eadfc436b236fb6ccec32" translate="yes" xml:space="preserve">
          <source>You may prefer just to load all core extensions, there is a file for that:</source>
          <target state="translated">모든 핵심 확장명을로드하는 것을 선호 할 수 있습니다. 해당 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="658a06caec21ccea99f6787eff9d8496ce25223b" translate="yes" xml:space="preserve">
          <source>You may put your initializer before or after any other initializer in the chain, as long as it is logical. Say you have 4 initializers called &quot;one&quot; through &quot;four&quot; (defined in that order) and you define &quot;four&quot; to go &lt;em&gt;before&lt;/em&gt; &quot;four&quot; but &lt;em&gt;after&lt;/em&gt; &quot;three&quot;, that just isn't logical and Rails will not be able to determine your initializer order.</source>
          <target state="translated">논리적 인 한, 이니셜 라이저를 체인의 다른 이니셜 라이저 앞뒤에 둘 수 있습니다. &quot;1&quot;에서 &quot;4&quot;(순서대로 정의 됨)라는 4 개의 이니셜 라이저가 있고 &quot;4&quot;를 &quot;4&quot; &lt;em&gt;이전&lt;/em&gt; 으로 이동 하지만 &quot;3&quot; &lt;em&gt;이후&lt;/em&gt; 로 정의하면 논리적이지 않으며 Rails는이를 수행 할 수 없습니다 이니셜 라이저 순서를 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="c92aa3b2da485663dfcb5f9dfd02990c5d522d51" translate="yes" xml:space="preserve">
          <source>You may use YAML (&lt;code&gt;.yml&lt;/code&gt;) or plain Ruby (&lt;code&gt;.rb&lt;/code&gt;) files for storing your translations in SimpleStore. YAML is the preferred option among Rails developers. However, it has one big disadvantage. YAML is very sensitive to whitespace and special characters, so the application may not load your dictionary properly. Ruby files will crash your application on first request, so you may easily find what's wrong. (If you encounter any &quot;weird issues&quot; with YAML dictionaries, try putting the relevant portion of your dictionary into a Ruby file.)</source>
          <target state="translated">번역을 SimpleStore에 저장하기 위해 YAML ( &lt;code&gt;.yml&lt;/code&gt; ) 또는 일반 Ruby ( &lt;code&gt;.rb&lt;/code&gt; ) 파일을 사용할 수 있습니다 . YAML은 Rails 개발자들이 선호하는 옵션입니다. 그러나 한 가지 큰 단점이 있습니다. YAML은 공백 및 특수 문자에 매우 민감하므로 응용 프로그램에서 사전을 제대로로드하지 못할 수 있습니다. 루비 파일은 첫 번째 요청에 따라 응용 프로그램이 중단되므로 잘못된 것을 쉽게 찾을 수 있습니다. YAML 사전에서 &quot;이상한 문제&quot;가 발생하면 사전의 관련 부분을 Ruby 파일에 넣으십시오.</target>
        </trans-unit>
        <trans-unit id="cbe4f200a4ef257e1c7cebae8398f253d12cd89b" translate="yes" xml:space="preserve">
          <source>You may use a type not in this list as long as it is supported by your database (for example, &amp;ldquo;polygon&amp;rdquo; in MySQL), but this will not be database agnostic and should usually be avoided.</source>
          <target state="translated">데이터베이스에서 지원하는 한 (예 : MySQL의 &quot;polygon&quot;)이 목록에없는 유형을 사용할 수 있지만 데이터베이스에 구애받지 않으므로 일반적으로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d89fe2a7b6668dace4fe3390e82c54ebee27153" translate="yes" xml:space="preserve">
          <source>You may use this to also restrict other parameters:</source>
          <target state="translated">이를 사용하여 다른 매개 변수를 제한 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="13c8043d4ce046358e5064b3231945faef1b3e91" translate="yes" xml:space="preserve">
          <source>You may want to also use the permitted attributes in your &lt;code&gt;new&lt;/code&gt; action. This raises the problem that you can't use &lt;code&gt;require&lt;/code&gt; on the root key because, normally, it does not exist when calling &lt;code&gt;new&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 조치 에 허용 된 속성을 사용할 수도 있습니다 . 루트 키에서 &lt;code&gt;require&lt;/code&gt; 를 사용할 수없는 문제가 발생합니다 . 일반적으로 &lt;code&gt;new&lt;/code&gt; 를 호출 할 때는 존재하지 않기 때문입니다 .</target>
        </trans-unit>
        <trans-unit id="05c7f53dde519660cebc46a0c02382a32bfccdca" translate="yes" xml:space="preserve">
          <source>You may want to nest cached fragments inside other cached fragments. This is called Russian doll caching.</source>
          <target state="translated">캐시 된 조각을 다른 캐시 된 조각 안에 중첩시킬 수 있습니다. 이것을 러시아 인형 캐싱이라고합니다.</target>
        </trans-unit>
        <trans-unit id="a19cabcd1e2a41faecc70e4a6c2527b261e026aa" translate="yes" xml:space="preserve">
          <source>You may wish to organize groups of controllers under a namespace. Most commonly, you might group a number of administrative controllers under an &lt;code&gt;Admin::&lt;/code&gt; namespace. You would place these controllers under the &lt;code&gt;app/controllers/admin&lt;/code&gt; directory, and you can group them together in your router:</source>
          <target state="translated">네임 스페이스 아래에서 컨트롤러 그룹을 구성 할 수 있습니다. 가장 일반적으로 &lt;code&gt;Admin::&lt;/code&gt; 네임 스페이스 아래에 여러 관리 컨트롤러를 그룹화 할 수 있습니다 . 이러한 컨트롤러를 &lt;code&gt;app/controllers/admin&lt;/code&gt; 디렉토리에 배치하고 라우터에서 컨트롤러 를 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bee136a197bcb9b19a5db342a0a5d2bc79043ca5" translate="yes" xml:space="preserve">
          <source>You may wish to organize groups of controllers under a namespace. Most commonly, you might group a number of administrative controllers under an &lt;code&gt;admin&lt;/code&gt; namespace. You would place these controllers under the &lt;code&gt;app/controllers/admin&lt;/code&gt; directory, and you can group them together in your router:</source>
          <target state="translated">네임 스페이스 아래에서 컨트롤러 그룹을 구성 할 수 있습니다. 가장 일반적으로 &lt;code&gt;admin&lt;/code&gt; 네임 스페이스 아래에 여러 관리 컨트롤러를 그룹화 할 수 있습니다 . 이러한 컨트롤러를 &lt;code&gt;app/controllers/admin&lt;/code&gt; 디렉토리에 배치하고 라우터에서 컨트롤러 를 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79af4434fc412de1d7aaaa29ca299b409ddc8570" translate="yes" xml:space="preserve">
          <source>You might be wondering why the &lt;code&gt;A&lt;/code&gt; in &lt;code&gt;Article.new&lt;/code&gt; is capitalized above, whereas most other references to articles in this guide have used lowercase. In this context, we are referring to the class named &lt;code&gt;Article&lt;/code&gt; that is defined in &lt;code&gt;app/models/article.rb&lt;/code&gt;. Class names in Ruby must begin with a capital letter.</source>
          <target state="translated">&lt;code&gt;Article.new&lt;/code&gt; 의 &lt;code&gt;A&lt;/code&gt; 가 대문자로 표시 되는 이유가 궁금 할 수 있지만이 안내서의 기사에 대한 대부분의 다른 참조는 소문자를 사용했습니다. 이와 관련하여 &lt;code&gt;app/models/article.rb&lt;/code&gt; 에 정의 된 &lt;code&gt;Article&lt;/code&gt; 이라는 클래스를 참조합니다 . Ruby의 클래스 이름은 대문자로 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="909ebfa8bfa9e1fc9f6c2b2e323d97fbee297631" translate="yes" xml:space="preserve">
          <source>You might want to download a blob to a file on disk so an external program (e.g. a virus scanner or media transcoder) can operate on it. Use &lt;code&gt;ActiveStorage::Blob#open&lt;/code&gt; to download a blob to a tempfile on disk:</source>
          <target state="translated">Blob을 디스크의 파일로 다운로드하여 외부 프로그램 (예 : 바이러스 스캐너 또는 미디어 트랜스 코더)이 작동 할 수 있습니다. &lt;code&gt;ActiveStorage::Blob#open&lt;/code&gt; 을 사용 하여 blob을 디스크의 임시 파일로 다운로드하십시오.</target>
        </trans-unit>
        <trans-unit id="57fdee87aa35bb69e12a0cc8d333df926b3c4156" translate="yes" xml:space="preserve">
          <source>You might want to render a form with a set of edit fields for each of a person's addresses. For example:</source>
          <target state="translated">각 개인 주소에 대한 편집 필드 세트가있는 양식을 렌더링 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5e58a4967e49a3b01287607700455ba8b4e9757a" translate="yes" xml:space="preserve">
          <source>You must change the following application configuration setting:</source>
          <target state="translated">다음 애플리케이션 구성 설정을 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="89e598c013979cc66d702aa8be0b01a998f39c7c" translate="yes" xml:space="preserve">
          <source>You must disambiguate column references for this fallback to happen, for example &lt;code&gt;order: &quot;author.name DESC&quot;&lt;/code&gt; will work but &lt;code&gt;order: &quot;name DESC&quot;&lt;/code&gt; will not.</source>
          <target state="translated">이 폴 백이 발생 &lt;code&gt;order: &quot;author.name DESC&quot;&lt;/code&gt; 열 참조를 명확하게해야합니다. 예를 들어 order : &quot;author.name DESC&quot; 는 작동하지만 &lt;code&gt;order: &quot;name DESC&quot;&lt;/code&gt; 는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d15d40da003c4584611e60a5f9018503e42cb604" translate="yes" xml:space="preserve">
          <source>You must ensure any necessary compressors or minifiers are available on your development system.</source>
          <target state="translated">개발 시스템에서 필요한 컴프레서 또는 축소기를 사용할 수 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c2c1d93a4db1a16cbed88598565dc5c468a7794f" translate="yes" xml:space="preserve">
          <source>You must have an ExecJS supported runtime in order to use CoffeeScript. If you are using macOS or Windows, you have a JavaScript runtime installed in your operating system. Check &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS&lt;/a&gt; documentation to know all supported JavaScript runtimes.</source>
          <target state="translated">CoffeeScript를 사용하려면 ExecJS 지원 런타임이 있어야합니다. macOS 또는 Windows를 사용하는 경우 운영 체제에 JavaScript 런타임이 설치되어 있습니다. 지원되는 모든 JavaScript 런타임을 확인 &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;하려면 ExecJS&lt;/a&gt; 설명서를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="310afb0b1584715129761c5fb83b8df6523f18fd" translate="yes" xml:space="preserve">
          <source>You must not run the Capistrano deployment task that precompiles assets.</source>
          <target state="translated">자산을 사전 컴파일하는 Capistrano 배포 작업을 실행하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cda2f62636ed5585c586eba40dfd841bc4e34e6f" translate="yes" xml:space="preserve">
          <source>You must pass either &lt;code&gt;:with&lt;/code&gt; or &lt;code&gt;:without&lt;/code&gt; as an option. In addition, both must be a regular expression or a proc or lambda, or else an exception will be raised.</source>
          <target state="translated">옵션으로 &lt;code&gt;:with&lt;/code&gt; 또는 &lt;code&gt;:without&lt;/code&gt; 을 전달해야합니다 . 또한 둘 다 정규 표현식이거나 proc 또는 lambda 여야합니다. 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f1c6507a2f85b50f30804f7e025cd6ed8f77cdf1" translate="yes" xml:space="preserve">
          <source>You must pass the name of an instance variable, i.e. &lt;code&gt;:person&lt;/code&gt; or &lt;code&gt;&quot;person&quot;&lt;/code&gt;, not an actual instance of your model object.</source>
          <target state="translated">모델 객체의 실제 인스턴스가 아닌 인스턴스 변수의 이름 (예 &lt;code&gt;:person&lt;/code&gt; 또는 &lt;code&gt;&quot;person&quot;&lt;/code&gt; )을 전달해야합니다.</target>
        </trans-unit>
        <trans-unit id="a3786adac7d5e07f32eb27219b520b4498e68539" translate="yes" xml:space="preserve">
          <source>You must specify a &lt;code&gt;use_renderer&lt;/code&gt;, else the &lt;code&gt;controller.renderer&lt;/code&gt; and &lt;code&gt;controller._renderers&lt;/code&gt; will be &lt;code&gt;nil&lt;/code&gt;, and the action will fail.</source>
          <target state="translated">&lt;code&gt;use_renderer&lt;/code&gt; 를 지정해야합니다 . 그렇지 않으면 &lt;code&gt;controller.renderer&lt;/code&gt; 및 &lt;code&gt;controller._renderers&lt;/code&gt; 가 &lt;code&gt;nil&lt;/code&gt; 이되고 조치가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="ae874defb20d402db844e2806d306243eb02114c" translate="yes" xml:space="preserve">
          <source>You need to change your session key to something new, or remove all sessions:</source>
          <target state="translated">세션 키를 새로운 것으로 변경하거나 모든 세션을 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="86b68ff3297d82cfd915fd24064c32bf506b8ccc" translate="yes" xml:space="preserve">
          <source>You need to enable the &lt;code&gt;hstore&lt;/code&gt; extension to use hstore.</source>
          <target state="translated">&lt;code&gt;hstore&lt;/code&gt; 를 사용하려면 hstore 확장 을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8549b48527d1d45217ab24e5173c761675e71ea3" translate="yes" xml:space="preserve">
          <source>You need to enable the &lt;code&gt;pgcrypto&lt;/code&gt; (only PostgreSQL &amp;gt;= 9.4) or &lt;code&gt;uuid-ossp&lt;/code&gt; extension to generate random UUIDs.</source>
          <target state="translated">임의의 UUID를 생성 하려면 &lt;code&gt;pgcrypto&lt;/code&gt; (PostgreSQL&amp;gt; = 9.4 만) 또는 &lt;code&gt;uuid-ossp&lt;/code&gt; 확장 을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="586a576e016642062e5a9cbaa78feb1fb88c2b52" translate="yes" xml:space="preserve">
          <source>You need to enable the &lt;code&gt;pgcrypto&lt;/code&gt; (only PostgreSQL &amp;gt;= 9.4) or &lt;code&gt;uuid-ossp&lt;/code&gt; extension to use uuid.</source>
          <target state="translated">&lt;code&gt;uuid-ossp&lt;/code&gt; 를 사용하려면 &lt;code&gt;pgcrypto&lt;/code&gt; (PostgreSQL&amp;gt; = 9.4 만) 또는 uuid-ossp 확장 을 활성화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="112d00bd9d3b5f44cb4f8b8ad7fd323f750c85ac" translate="yes" xml:space="preserve">
          <source>You need to restart the server when you add new locale files.</source>
          <target state="translated">새 로케일 파일을 추가 할 때 서버를 다시 시작해야합니다.</target>
        </trans-unit>
        <trans-unit id="dae9e35001eee15eb4a5bcfaeedb49da194896d7" translate="yes" xml:space="preserve">
          <source>You need to set up your connection manually to provide values for the identifiers. To do this just use:</source>
          <target state="translated">식별자 값을 제공하려면 연결을 수동으로 설정해야합니다. 이렇게하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="93d3c48196c13c0bb120cd94665188d5b4a774c1" translate="yes" xml:space="preserve">
          <source>You never instantiate your mailer class. Rather, you just call the method you defined on the class itself. All instance methods are expected to return a message object to be sent.</source>
          <target state="translated">메일러 클래스를 인스턴스화하지 마십시오. 오히려 클래스 자체에서 정의한 메소드를 호출하기 만하면됩니다. 모든 인스턴스 메소드는 전송 될 메시지 오브젝트를 리턴해야합니다.</target>
        </trans-unit>
        <trans-unit id="fa7ae451e87f25e98269c57528abcd62db2ef213" translate="yes" xml:space="preserve">
          <source>You now need to create the &lt;code&gt;create&lt;/code&gt; action within the &lt;code&gt;ArticlesController&lt;/code&gt; for this to work.</source>
          <target state="translated">이제이 작업을 수행하려면 &lt;code&gt;ArticlesController&lt;/code&gt; 내에서 &lt;code&gt;create&lt;/code&gt; 조치 를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b2553688f398ba3088d0a662297c3ace031a2ce8" translate="yes" xml:space="preserve">
          <source>You only need to provide the &quot;host&quot;, this is the subdomain and root domain, you do not need to specify a protocol or &quot;scheme&quot; such as &lt;code&gt;http://&lt;/code&gt; or &lt;code&gt;https://&lt;/code&gt;. When a web page is requested, the protocol in the link to your asset that is generated will match how the webpage is accessed by default.</source>
          <target state="translated">&quot;호스트&quot;만 제공하면됩니다.이 도메인은 하위 도메인과 루트 도메인입니다. &lt;code&gt;http://&lt;/code&gt; 또는 &lt;code&gt;https://&lt;/code&gt; 와 같은 프로토콜이나 &quot;체계&quot;를 지정할 필요가 없습니다 . 웹 페이지가 요청되면 생성 된 자산에 대한 링크의 프로토콜이 기본적으로 웹 페이지에 액세스하는 방법과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="09208900c19fcd0026f3644adb2cada0d4267dce" translate="yes" xml:space="preserve">
          <source>You only need to specify the &lt;code&gt;:counter_cache&lt;/code&gt; option on the &lt;code&gt;belongs_to&lt;/code&gt; side of the association.</source>
          <target state="translated">연관 의 &lt;code&gt;belongs_to&lt;/code&gt; 측 에 &lt;code&gt;:counter_cache&lt;/code&gt; 옵션 만 지정하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="9b0f13598656caad60aee7fa8a1de2a1cd0e0dce" translate="yes" xml:space="preserve">
          <source>You probably don't want to just sit there with a filled out &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;, though. You probably want to do something upon a successful submission. To do that, bind to the &lt;code&gt;ajax:success&lt;/code&gt; event. On failure, use &lt;code&gt;ajax:error&lt;/code&gt;. Check it out:</source>
          <target state="translated">그래도 채워진 &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; 으로 거기에 앉아 싶지 않을 것입니다 . 성공적인 제출시 무언가를하고 싶을 것입니다. 이를 수행하려면 &lt;code&gt;ajax:success&lt;/code&gt; 이벤트에 바인딩하십시오 . 실패하면 &lt;code&gt;ajax:error&lt;/code&gt; 를 사용하십시오 . 확인 해봐:</target>
        </trans-unit>
        <trans-unit id="946bb170cc9dc5c179e88a988c84173b74e22159" translate="yes" xml:space="preserve">
          <source>You probably want URLs to look like this: &lt;code&gt;http://www.example.com/en/books&lt;/code&gt; (which loads the English locale) and &lt;code&gt;http://www.example.com/nl/books&lt;/code&gt; (which loads the Dutch locale). This is achievable with the &quot;over-riding &lt;code&gt;default_url_options&lt;/code&gt;&quot; strategy from above: you just have to set up your routes with &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/Scoping.html&quot;&gt;&lt;code&gt;scope&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;http://www.example.com/en/books&lt;/code&gt; (영어 로캘을로드) 및 &lt;code&gt;http://www.example.com/nl/books&lt;/code&gt; (네덜란드 로캘을로드 )와 같은 URL을 원할 것입니다. . 위에서 언급 한 &quot;over-riding &lt;code&gt;default_url_options&lt;/code&gt; &quot;전략으로 이를 달성 할 수 있습니다. &lt;a href=&quot;https://edgeapi.rubyonrails.org/classes/ActionDispatch/Routing/Mapper/Scoping.html&quot;&gt; &lt;code&gt;scope&lt;/code&gt; &lt;/a&gt; 하여 경로를 설정하기 만하면 됩니다 .</target>
        </trans-unit>
        <trans-unit id="4def473e9350595ea54a9d7da6883721f157b150" translate="yes" xml:space="preserve">
          <source>You should always pass a callable object to the scopes defined with &lt;a href=&quot;classmethods#method-i-scope&quot;&gt;scope&lt;/a&gt;. This ensures that the scope is re-evaluated each time it is called.</source>
          <target state="translated">당신은 항상로 정의 된 범위에 호출 개체를 전달해야 &lt;a href=&quot;classmethods#method-i-scope&quot;&gt;범위&lt;/a&gt; . 이렇게하면 호출 될 때마다 범위가 다시 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="5e2390a2a51e68c23e3041cf6a91b23538ae355f" translate="yes" xml:space="preserve">
          <source>You should consult the documentation for your database to understand the semantics of these different levels:</source>
          <target state="translated">다음과 같은 다양한 레벨의 의미를 이해하려면 데이터베이스 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db945c5d21a1088da0df3a48d0b20000acf6cde6" translate="yes" xml:space="preserve">
          <source>You should follow Rails conventions when defining your own events. The format is: &lt;code&gt;event.library&lt;/code&gt;. If your application is sending Tweets, you should create an event named &lt;code&gt;tweet.twitter&lt;/code&gt;.</source>
          <target state="translated">자신의 이벤트를 정의 할 때 Rails 규칙을 따라야합니다. 형식은 &lt;code&gt;event.library&lt;/code&gt; 입니다. 애플리케이션이 트윗을 보내는 경우 &lt;code&gt;tweet.twitter&lt;/code&gt; 라는 이벤트를 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a90fa6fd9b954cf7b3f738f7025b6547e979c47e" translate="yes" xml:space="preserve">
          <source>You should have a good understanding of using the i18n library now and know how to internationalize a basic Rails application. In the following chapters, we'll cover its features in more depth.</source>
          <target state="translated">i18n 라이브러리 사용에 대해 잘 알고 있어야하며 기본 Rails 애플리케이션을 국제화하는 방법을 알고 있어야합니다. 다음 장에서는 그 기능에 대해 좀 더 자세히 다룰 것입니다.</target>
        </trans-unit>
        <trans-unit id="21807d77344ec28f368544e34eb49a4c55de2351" translate="yes" xml:space="preserve">
          <source>You should not specify this option on a &lt;code&gt;belongs_to&lt;/code&gt; association that is connected with a &lt;code&gt;has_many&lt;/code&gt; association on the other class. Doing so can lead to orphaned records in your database.</source>
          <target state="translated">다른 클래스 의 &lt;code&gt;has_many&lt;/code&gt; 연관과 연결된 &lt;code&gt;belongs_to&lt;/code&gt; 연관 에서이 옵션을 지정해서는 안됩니다 . 그렇게하면 데이터베이스에 레코드가 분리 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="166bf0e98f4e99039b079af31c92fff61f02ad10" translate="yes" xml:space="preserve">
          <source>You should not use the &lt;code&gt;match&lt;/code&gt; method in your router without specifying an HTTP method.</source>
          <target state="translated">HTTP 메소드를 지정하지 않고 라우터에서 &lt;code&gt;match&lt;/code&gt; 메소드를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="9de9f1feb2ce83cbfdbf72efa9df8c512c0c6b16" translate="yes" xml:space="preserve">
          <source>You should put the &lt;code&gt;root&lt;/code&gt; route at the top of the file, because it is the most popular route and should be matched first.</source>
          <target state="translated">당신은 넣어해야 &lt;code&gt;root&lt;/code&gt; 는 가장 인기있는 노선이며, 첫 번째 일치해야하기 때문에, 파일의 상단에 경로를.</target>
        </trans-unit>
        <trans-unit id="ad0988339f9100d2c37b366a52abb889765bceb7" translate="yes" xml:space="preserve">
          <source>You should put the root route at the top of &lt;code&gt;config/routes.rb&lt;/code&gt;, because this means it will be matched first. As this is the most popular route of most Rails applications, this is beneficial.</source>
          <target state="translated">루트 경로는 &lt;code&gt;config/routes.rb&lt;/code&gt; 맨 위에 두어야합니다. 루트 경로가 먼저 일치하기 때문입니다. 이것이 대부분의 Rails 애플리케이션에서 가장 많이 사용되는 경로이므로이 방법이 유리합니다.</target>
        </trans-unit>
        <trans-unit id="f2532bacaa3a7fcecb1f3c7a2465a18b789a0e26" translate="yes" xml:space="preserve">
          <source>You should see:</source>
          <target state="translated">넌 봐야 해:</target>
        </trans-unit>
        <trans-unit id="9c04c2f59cceaa4cdc2ac83c13722f942e4f26a6" translate="yes" xml:space="preserve">
          <source>You should test for things such as:</source>
          <target state="translated">다음과 같은 사항을 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="13bb18ff71b885aed7750f4ada07156428657bf4" translate="yes" xml:space="preserve">
          <source>You should use &lt;code&gt;has_many :through&lt;/code&gt; if you need validations, callbacks, or extra attributes on the join model.</source>
          <target state="translated">당신은 사용해야 &lt;code&gt;has_many :through&lt;/code&gt; 당신이 가입 모델을 검증, 콜백, 또는 추가 속성을 필요로하는 경우.</target>
        </trans-unit>
        <trans-unit id="1cb021ef9b725031a5746f0866ab7abbc1f1ef82" translate="yes" xml:space="preserve">
          <source>You should use the &lt;code&gt;named_route_url&lt;/code&gt; style (which generates absolute URLs) and avoid using the &lt;code&gt;named_route_path&lt;/code&gt; style (which generates relative URLs), since clients reading the mail will have no concept of a current URL from which to determine a relative path.</source>
          <target state="translated">당신은 사용해야 &lt;code&gt;named_route_url&lt;/code&gt; 의 와 사용하지 마십시오 (절대 URL 생성) 스타일 &lt;code&gt;named_route_path&lt;/code&gt; 의 상대 경로를 결정하기 위해있는 현재의 URL의 개념이없는 것 메일을 읽을 클라이언트 때문에 (상대 URL을 생성) 스타일.</target>
        </trans-unit>
        <trans-unit id="fb35d285bc1ae987b173c3b463d23b792f9f050c" translate="yes" xml:space="preserve">
          <source>You should use this helper when you have two text fields that should receive exactly the same content. For example, you may want to confirm an email address or a password. This validation creates a virtual attribute whose name is the name of the field that has to be confirmed with &quot;_confirmation&quot; appended.</source>
          <target state="translated">정확히 동일한 내용을 수신해야하는 두 개의 텍스트 필드가있는 경우이 도우미를 사용해야합니다. 예를 들어 이메일 주소 나 비밀번호를 확인하려고 할 수 있습니다. 이 유효성 검증은 이름이 &quot;_confirmation&quot;이 추가되어 확인되어야하는 필드 이름 인 가상 속성을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="12c95256a50fc492ff84c9e12e744d099683de71" translate="yes" xml:space="preserve">
          <source>You should use this helper when your model has associations with other models and they also need to be validated. When you try to save your object, &lt;code&gt;valid?&lt;/code&gt; will be called upon each one of the associated objects.</source>
          <target state="translated">모델이 다른 모델과 연관되어 있고 유효성을 검증해야하는 경우이 헬퍼를 사용해야합니다. 객체를 저장하려고 할 때 &lt;code&gt;valid?&lt;/code&gt; 관련 개체 각각에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="c80a39fbdf55175c9503194abde211aa66ef43c5" translate="yes" xml:space="preserve">
          <source>You shouldn't ever need to create a &lt;a href=&quot;timewithzone&quot;&gt;TimeWithZone&lt;/a&gt; instance directly via &lt;code&gt;new&lt;/code&gt;. Instead use methods &lt;code&gt;local&lt;/code&gt;, &lt;code&gt;parse&lt;/code&gt;, &lt;code&gt;at&lt;/code&gt; and &lt;code&gt;now&lt;/code&gt; on &lt;a href=&quot;timezone&quot;&gt;TimeZone&lt;/a&gt; instances, and &lt;code&gt;in_time_zone&lt;/code&gt; on &lt;a href=&quot;../time&quot;&gt;Time&lt;/a&gt; and &lt;a href=&quot;../datetime&quot;&gt;DateTime&lt;/a&gt; instances.</source>
          <target state="translated">&lt;code&gt;new&lt;/code&gt; 를 통해 &lt;a href=&quot;timewithzone&quot;&gt;TimeWithZone&lt;/a&gt; 인스턴스를 직접 만들 필요는 없습니다 . 대신 방법 사용 &lt;code&gt;local&lt;/code&gt; , &lt;code&gt;parse&lt;/code&gt; , &lt;code&gt;at&lt;/code&gt; 하고 &lt;code&gt;now&lt;/code&gt; 에 &lt;a href=&quot;timezone&quot;&gt;시간대의&lt;/a&gt; 인스턴스 및 &lt;code&gt;in_time_zone&lt;/code&gt; 에 &lt;a href=&quot;../time&quot;&gt;시간&lt;/a&gt; 및 &lt;a href=&quot;../datetime&quot;&gt;날짜 시간&lt;/a&gt; 인스턴스.</target>
        </trans-unit>
        <trans-unit id="2fa6bd88c92aceac3be552524f6ae124a1f70bc6" translate="yes" xml:space="preserve">
          <source>You specify a request-based constraint the same way that you specify a segment constraint:</source>
          <target state="translated">세그먼트 제한 조건을 지정하는 것과 동일한 방식으로 요청 기반 제한 조건을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="2cf854df8722d58c35a4a6e91702b20f03d87c63" translate="yes" xml:space="preserve">
          <source>You still could pass &lt;code&gt;:include&lt;/code&gt; and &lt;code&gt;:exclude&lt;/code&gt; to set the list of attributes you want to wrap.</source>
          <target state="translated">랩핑하려는 속성 목록을 설정 &lt;code&gt;:exclude&lt;/code&gt; 위해 여전히 &lt;code&gt;:include&lt;/code&gt; 및 : exclude 를 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0fb1d66798c26f15f3c5b5a668b7b04c812a4335" translate="yes" xml:space="preserve">
          <source>You trigger ERB by using embeddings such as &lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;% -%&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;%=
%&amp;gt;&lt;/code&gt;. The &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; tag set is used when you want output. Consider the following loop for names:</source>
          <target state="translated">&lt;code&gt;&amp;lt;% %&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;% -%&amp;gt;&lt;/code&gt; 및 &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 와 같은 임베딩을 사용하여 ERB를 트리거 합니다. &lt;code&gt;&amp;lt;%= %&amp;gt;&lt;/code&gt; 당신은 출력을 할 때 태그 세트가 사용됩니다. 이름에 대해 다음 루프를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="3b21c9902b82c1f8dfa48fd17b8ffa085e630b50" translate="yes" xml:space="preserve">
          <source>You will also need an installation of the SQLite3 database. Many popular UNIX-like OSes ship with an acceptable version of SQLite3. On Windows, if you installed Rails through Rails Installer, you already have SQLite installed. Others can find installation instructions at the &lt;a href=&quot;https://www.sqlite.org&quot;&gt;SQLite3 website&lt;/a&gt;. Verify that it is correctly installed and in your PATH:</source>
          <target state="translated">또한 SQLite3 데이터베이스를 설치해야합니다. 많이 사용되는 UNIX 유사 OS는 허용 가능한 버전의 SQLite3과 함께 제공됩니다. Windows에서 Rails 설치 프로그램을 통해 Rails를 설치 한 경우 이미 SQLite가 설치되어 있습니다. 다른 사람들은 &lt;a href=&quot;https://www.sqlite.org&quot;&gt;SQLite3 웹 사이트&lt;/a&gt; 에서 설치 지침을 찾을 수 있습니다 . 올바르게 설치되었고 PATH에 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f7d56900a000f8df591962d61753b511fd1db9c2" translate="yes" xml:space="preserve">
          <source>You will get a list of all generators that comes with Rails. If you need a detailed description of the helper generator, for example, you can simply do:</source>
          <target state="translated">Rails와 함께 제공되는 모든 발전기 목록이 표시됩니다. 예를 들어, 헬퍼 생성기에 대한 자세한 설명이 필요한 경우 다음을 수행하면됩니다.</target>
        </trans-unit>
        <trans-unit id="4fbe43ca46fafab52c776d602e079677f80b3401" translate="yes" xml:space="preserve">
          <source>You will get two keys from the API, a public and a private key, which you have to put into your Rails environment. After that you can use the recaptcha_tags method in the view, and the verify_recaptcha method in the controller. Verify_recaptcha will return false if the validation fails. The problem with CAPTCHAs is that they have a negative impact on the user experience. Additionally, some visually impaired users have found certain kinds of distorted CAPTCHAs difficult to read. Still, positive CAPTCHAs are one of the best methods to prevent all kinds of bots from submitting forms.</source>
          <target state="translated">API에서 공개 키와 개인 키의 두 가지 키를 얻을 수 있으며이 키는 Rails 환경에 배치해야합니다. 그런 다음보기에서 recaptcha_tags 메소드를 사용하고 컨트롤러에서 verify_recaptcha 메소드를 사용할 수 있습니다. 유효성 검사에 실패하면 Verify_recaptcha가 false를 반환합니다. 보안 문자의 문제점은 사용자 경험에 부정적인 영향을 미친다는 것입니다. 또한 시각 장애가있는 일부 사용자는 특정 종류의 왜곡 된 보안 문자를 읽기가 어렵다는 것을 알게되었습니다. 여전히 긍정적 인 보안 문자는 모든 종류의 봇이 양식을 제출하지 못하게하는 가장 좋은 방법 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="239043e4b2867b8e410ffaced18e22f27a6c9224" translate="yes" xml:space="preserve">
          <source>You will have to rewrite those to the explicit form:</source>
          <target state="translated">명시적인 형식으로 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="407a52afc79c64ea6af0dd5cbc6a7e131e0d6dfc" translate="yes" xml:space="preserve">
          <source>You will need an &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS&lt;/a&gt; supported runtime in order to use &lt;code&gt;uglifier&lt;/code&gt;. If you are using macOS or Windows you have a JavaScript runtime installed in your operating system.</source>
          <target state="translated">당신은해야합니다 &lt;a href=&quot;https://github.com/rails/execjs#readme&quot;&gt;ExecJS&lt;/a&gt; 사용하기 위해 런타임 지원을 &lt;code&gt;uglifier&lt;/code&gt; . macOS 또는 Windows를 사용하는 경우 운영 체제에 JavaScript 런타임이 설치되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e999038b909701f0ea79d0c1a2de2adbf75868da" translate="yes" xml:space="preserve">
          <source>You will need to use:</source>
          <target state="translated">다음을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4f439a572c57f992ca29e0bcab7e21a5afce688" translate="yes" xml:space="preserve">
          <source>You will probably want to access data sent in by the user or other parameters in your controller actions. There are two kinds of parameters possible in a web application. The first are parameters that are sent as part of the URL, called query string parameters. The query string is everything after &quot;?&quot; in the URL. The second type of parameter is usually referred to as POST data. This information usually comes from an HTML form which has been filled in by the user. It's called POST data because it can only be sent as part of an HTTP POST request. Rails does not make any distinction between query string parameters and POST parameters, and both are available in the &lt;code&gt;params&lt;/code&gt; hash in your controller:</source>
          <target state="translated">컨트롤러 작업에서 사용자 또는 다른 매개 변수가 전송 한 데이터에 액세스하려고 할 수 있습니다. 웹 응용 프로그램에는 두 가지 종류의 매개 변수가 있습니다. 첫 번째는 쿼리 문자열 매개 변수라고하는 URL의 일부로 전송되는 매개 변수입니다. 쿼리 문자열은 &quot;?&quot;뒤의 모든 것입니다. URL에서. 두 번째 유형의 매개 변수는 일반적으로 POST 데이터라고합니다. 이 정보는 일반적으로 사용자가 작성한 HTML 양식에서 가져옵니다. HTTP POST 요청의 일부로 만 보낼 수 있기 때문에 POST 데이터라고합니다. Rails는 쿼리 문자열 매개 변수와 POST 매개 변수를 구별하지 않으며 컨트롤러 의 &lt;code&gt;params&lt;/code&gt; hash에서 두 가지를 모두 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="291c95325d391bb9e0c57e697f868eb83dcb8c30" translate="yes" xml:space="preserve">
          <source>You will see how the token gets added as a hidden field:</source>
          <target state="translated">토큰이 숨겨진 필드로 추가되는 방법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="068924df98c911ca637b1f050e31796451914374" translate="yes" xml:space="preserve">
          <source>You won't ordinarily need to call this method from a Rails application. New blobs are automatically and asynchronously analyzed via &lt;a href=&quot;analyzable#method-i-analyze_later&quot;&gt;analyze_later&lt;/a&gt; when they're attached for the first time.</source>
          <target state="translated">일반적으로 Rails 애플리케이션에서이 메소드를 호출 할 필요는 없습니다. 새로운 &lt;a href=&quot;analyzable#method-i-analyze_later&quot;&gt;블로 브&lt;/a&gt; 는 처음 첨부 될 때 analyze_later 를 통해 자동으로 비동기 적으로 분석됩니다 .</target>
        </trans-unit>
        <trans-unit id="b37151ff57ddfb01faa457e8cb06b5f175527329" translate="yes" xml:space="preserve">
          <source>You would need to set &lt;code&gt;CDN_HOST&lt;/code&gt; on your server to &lt;code&gt;mycdnsubdomain
.fictional-cdn.com&lt;/code&gt; for this to work.</source>
          <target state="translated">당신은 설정해야 &lt;code&gt;CDN_HOST&lt;/code&gt; 을 위해 서버에 &lt;code&gt;mycdnsubdomain .fictional-cdn.com&lt;/code&gt; 이 작업을 수행하려면.</target>
        </trans-unit>
        <trans-unit id="88337d05e336f6c9da472cfd55095f9639171480" translate="yes" xml:space="preserve">
          <source>You would probably need to map URLs like these:</source>
          <target state="translated">아마도 다음과 같은 URL을 매핑해야 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1226e58a2bf8082400185104caa678850de0c03d" translate="yes" xml:space="preserve">
          <source>You would use &lt;code&gt;content_for&lt;/code&gt; in your template to specify the title:</source>
          <target state="translated">당신이 사용하는 것이 &lt;code&gt;content_for&lt;/code&gt; 제목을 지정하는 템플릿에 :</target>
        </trans-unit>
        <trans-unit id="078c83f2452a579699d0e8d46ff4cd688c35c13c" translate="yes" xml:space="preserve">
          <source>You'd give your encryptor the new defaults:</source>
          <target state="translated">암호화기에 새로운 기본값을 부여합니다.</target>
        </trans-unit>
        <trans-unit id="52dba8a42c7f202119984d737308c8dbd5c3668e" translate="yes" xml:space="preserve">
          <source>You'd give your verifier the new defaults:</source>
          <target state="translated">검증 자에게 새로운 기본값을 부여합니다.</target>
        </trans-unit>
        <trans-unit id="0cd302b4663a64499f6e3c4c90e8cf3212ead9bb" translate="yes" xml:space="preserve">
          <source>You'll find fixtures under your &lt;code&gt;test/fixtures&lt;/code&gt; directory. When you run &lt;code&gt;rails generate model&lt;/code&gt; to create a new model, Rails automatically creates fixture stubs in this directory.</source>
          <target state="translated">&lt;code&gt;test/fixtures&lt;/code&gt; 디렉토리 아래에 조명기가 있습니다 . &lt;code&gt;rails generate model&lt;/code&gt; 을 실행 하여 새 모델 을 작성하면 Rails는이 디렉토리에 조명기 스터브를 자동으로 작성합니다.</target>
        </trans-unit>
        <trans-unit id="d528dfeb22821cdd901d790d9e428bd9f049b40c" translate="yes" xml:space="preserve">
          <source>You'll find that the output from &lt;code&gt;rails routes&lt;/code&gt; is much more readable if you widen your terminal window until the output lines don't wrap.</source>
          <target state="translated">출력 라인이 줄 바꿈되지 않을 때까지 터미널 창을 넓히면 &lt;code&gt;rails routes&lt;/code&gt; 의 출력을 훨씬 더 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ae862639b17cab9b4af170f3d5db0ac0d31548e" translate="yes" xml:space="preserve">
          <source>You'll need to edit &lt;code&gt;app/models/article.rb&lt;/code&gt; to add the other side of the association:</source>
          <target state="translated">연결의 다른 쪽을 추가 하려면 &lt;code&gt;app/models/article.rb&lt;/code&gt; 를 편집해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f232f1e75f28f65a620f68584e881b40833dd301" translate="yes" xml:space="preserve">
          <source>You'll need to use a special comment format to call those out:</source>
          <target state="translated">당신은 그것들을 불러 내기 위해 특별한 주석 형식을 사용해야합니다 :</target>
        </trans-unit>
        <trans-unit id="2477e2665baa35e39014c5a501a8a262581f20eb" translate="yes" xml:space="preserve">
          <source>You'll notice that the HTML contains an &lt;code&gt;input&lt;/code&gt; element with type &lt;code&gt;hidden&lt;/code&gt;. This &lt;code&gt;input&lt;/code&gt; is important, because non-GET form cannot be successfully submitted without it. The hidden input element with the name &lt;code&gt;authenticity_token&lt;/code&gt; is a security feature of Rails called &lt;strong&gt;cross-site request forgery protection&lt;/strong&gt;, and form helpers generate it for every non-GET form (provided that this security feature is enabled). You can read more about this in the &lt;a href=&quot;security#cross-site-request-forgery-csrf&quot;&gt;Securing Rails Applications&lt;/a&gt; guide.</source>
          <target state="translated">HTML에는 &lt;code&gt;hidden&lt;/code&gt; 유형 의 &lt;code&gt;input&lt;/code&gt; 요소가 포함되어 있습니다 . 이 &lt;code&gt;input&lt;/code&gt; 비 GET 양식이 성공적으로하지 않고 제출 할 수 없기 때문에 중요합니다. 이름이 &lt;code&gt;authenticity_token&lt;/code&gt; 인 숨겨진 입력 요소 는 &lt;strong&gt;Cross-site request forgery protection&lt;/strong&gt; 이라는 Rails의 보안 기능 이며 양식 도우미는 모든 비 GET 양식에 대해이 보안 기능이 활성화 된 경우이를 생성합니다. 이에 대한 자세한 내용은 &lt;a href=&quot;security#cross-site-request-forgery-csrf&quot;&gt;Securing Rails Applications&lt;/a&gt; 안내서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="49ade38eb32f27dcb828cc51002b18554cc5d2b0" translate="yes" xml:space="preserve">
          <source>You'll see a bit more complexity here than you did in the controller for articles. That's a side-effect of the nesting that you've set up. Each request for a comment has to keep track of the article to which the comment is attached, thus the initial call to the &lt;code&gt;find&lt;/code&gt; method of the &lt;code&gt;Article&lt;/code&gt; model to get the article in question.</source>
          <target state="translated">기사의 컨트롤러에서보다 약간 더 복잡합니다. 이는 설정 한 중첩의 부작용입니다. 코멘트에 대한 각 요청은 주석이의에 따라서 초기 호출 부착 된 물품의 트랙을 유지하는 &lt;code&gt;find&lt;/code&gt; 의 방법 &lt;code&gt;Article&lt;/code&gt; 문제의 기사를 얻기 위해 모델을.</target>
        </trans-unit>
        <trans-unit id="40958febf05881dda4278aa60310822903c43438" translate="yes" xml:space="preserve">
          <source>You'll see something like this:</source>
          <target state="translated">다음과 같은 것을 보게 될 것입니다 :</target>
        </trans-unit>
        <trans-unit id="525e1a7311d98bb51e6abc4336c434d09cf56bb4" translate="yes" xml:space="preserve">
          <source>You'll see the usage of some of these assertions in the next chapter.</source>
          <target state="translated">다음 장에서 이러한 어설 션 중 일부의 사용법을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bec85ff1b139d727c2c507cfd50bbb9000e606dc" translate="yes" xml:space="preserve">
          <source>You're encouraged to help improve the quality of this guide.</source>
          <target state="translated">이 가이드의 품질을 향상시키는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="9b7c6efdb452f8d502efbbeb09df1c641f6285ef" translate="yes" xml:space="preserve">
          <source>You're getting this error now because Rails expects plain actions like this one to have views associated with them to display their information. With no view available, Rails will raise an exception.</source>
          <target state="translated">Rails는 이와 같은 일반 작업에 정보를 표시하기 위해 관련된보기가있을 것으로 예상하기 때문에이 오류가 발생합니다. 보기가 없으면 Rails에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1133865f93c26c9b51ce1b04a0ac88b5fe4d098e" translate="yes" xml:space="preserve">
          <source>You're not limited to the functionality that Rails automatically builds into association proxy objects. You can also extend these objects through anonymous modules, adding new finders, creators, or other methods. For example:</source>
          <target state="translated">Rails가 자동으로 연관 프록시 객체에 구축하는 기능에만 국한되지는 않습니다. 익명 모듈을 통해 이러한 객체를 확장하여 새로운 파인더, 생성자 또는 기타 방법을 추가 할 수도 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ebe356d8db57db3a2cacba3bc5b67f96f0b3797f" translate="yes" xml:space="preserve">
          <source>You're testing whether a transaction works correctly. Nested transactions don't commit until all parent transactions commit, particularly, the fixtures transaction which is begun in setup and rolled back in teardown. Thus, you won't be able to verify the results of your transaction until Active Record supports nested transactions or savepoints (in progress).</source>
          <target state="translated">트랜잭션이 올바르게 작동하는지 테스트 중입니다. 중첩 된 트랜잭션은 모든 상위 트랜잭션, 특히 설정에서 시작되어 철회시 롤백 된 조명기 트랜잭션을 커밋 할 때까지 커밋되지 않습니다. 따라서 Active Record가 중첩 된 트랜잭션 또는 저장 점 (진행 중)을 지원할 때까지 트랜잭션 결과를 확인할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ecd9413e60f1b1d60ce3af64d44836b8a8d3bcc0" translate="yes" xml:space="preserve">
          <source>You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging, or otherwise apply the business logic needed to resolve the conflict.</source>
          <target state="translated">그런 다음 예외를 구하고 충돌을 해결하는 데 필요한 비즈니스 논리를 롤백, 병합 또는 적용하여 충돌을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="c9c901b99847a9e2147df0c384a702a028151eab" translate="yes" xml:space="preserve">
          <source>You've heard that Rails promotes &quot;convention over configuration&quot;. Default rendering is an excellent example of this. By default, controllers in Rails automatically render views with names that correspond to valid routes. For example, if you have this code in your &lt;code&gt;BooksController&lt;/code&gt; class:</source>
          <target state="translated">Rails는 &quot;컨벤션 오버 컨벤션&quot;을 장려한다고 들었습니다. 기본 렌더링은 이에 대한 훌륭한 예입니다. 기본적으로 Rails의 컨트롤러는 유효한 경로에 해당하는 이름으로보기를 자동 렌더링합니다. 예를 들어, &lt;code&gt;BooksController&lt;/code&gt; 클래스 에이 코드가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="e479d211e541fe121533f550dee3e8dc3b7f0597" translate="yes" xml:space="preserve">
          <source>Your application can store small amounts of data on the client - called cookies - that will be persisted across requests and even sessions. Rails provides easy access to cookies via the &lt;code&gt;cookies&lt;/code&gt; method, which - much like the &lt;code&gt;session&lt;/code&gt; - works like a hash:</source>
          <target state="translated">응용 프로그램은 쿠키라고하는 클라이언트에 소량의 데이터를 저장할 수 있으며 이는 요청과 세션에 걸쳐 지속됩니다. 레일은 통해 쿠키에 쉽게 액세스를 제공 &lt;code&gt;cookies&lt;/code&gt; 등 많은 - 방법, &lt;code&gt;session&lt;/code&gt; - 해시처럼 작동을 :</target>
        </trans-unit>
        <trans-unit id="f74da06d901df969e1ca6fb2618772d35a8664dd" translate="yes" xml:space="preserve">
          <source>Your application has a session for each user in which you can store small amounts of data that will be persisted between requests. The session is only available in the controller and the view and can use one of a number of different storage mechanisms:</source>
          <target state="translated">응용 프로그램에는 각 사용자에 대한 세션이있어 요청간에 유지 될 소량의 데이터를 저장할 수 있습니다. 세션은 컨트롤러 및보기에서만 사용 가능하며 여러 가지 다른 스토리지 메커니즘 중 하나를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f593856f75c1aad418400c6709634b66c707e1f9" translate="yes" xml:space="preserve">
          <source>Your controller will receive &lt;code&gt;params[:company]&lt;/code&gt; as &lt;code&gt;{ &quot;name&quot; =&amp;gt; &quot;acme&quot;, &quot;address&quot; =&amp;gt; &quot;123 Carrot Street&quot; }&lt;/code&gt;.</source>
          <target state="translated">컨트롤러는 &lt;code&gt;params[:company]&lt;/code&gt; 를 &lt;code&gt;{ &quot;name&quot; =&amp;gt; &quot;acme&quot;, &quot;address&quot; =&amp;gt; &quot;123 Carrot Street&quot; }&lt;/code&gt; 받습니다.</target>
        </trans-unit>
        <trans-unit id="3f9ae354556926182b3731cdf55708a8c5d75f06" translate="yes" xml:space="preserve">
          <source>Your cookies will be encrypted using your apps secret_key_base. This goes a step further than signed cookies in that encrypted cookies cannot be altered or read by users. This is the default starting in Rails 4.</source>
          <target state="translated">쿠키는 앱 secret_key_base를 사용하여 암호화됩니다. 암호화 된 쿠키는 사용자가 변경하거나 읽을 수 없다는 점에서 서명 된 쿠키보다 한 단계 더 나아갑니다. 이것이 Rails 4에서 시작하는 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="9d3ee810a41c776762a57d7b47c01334cd6a04d1" translate="yes" xml:space="preserve">
          <source>Your database does not support transactions. Every Active Record database supports transactions except MySQL MyISAM. Use InnoDB, MaxDB, or NDB instead.</source>
          <target state="translated">데이터베이스가 트랜잭션을 지원하지 않습니다. 모든 Active Record 데이터베이스는 MySQL MyISAM을 제외한 트랜잭션을 지원합니다. 대신 InnoDB, MaxDB 또는 NDB를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="124f5e00bd1bbfbdc4278e5da2840cb0c204c415" translate="yes" xml:space="preserve">
          <source>Your database: Rails defaults to converting data from your database into UTF-8 at the boundary. However, if your database is not using UTF-8 internally, it may not be able to store all characters that your users enter. For instance, if your database is using Latin-1 internally, and your user enters a Russian, Hebrew, or Japanese character, the data will be lost forever once it enters the database. If possible, use UTF-8 as the internal storage of your database.</source>
          <target state="translated">데이터베이스 : Rails는 기본적으로 경계에서 데이터베이스의 데이터를 UTF-8로 변환합니다. 그러나 데이터베이스가 UTF-8을 내부적으로 사용하지 않는 경우 사용자가 입력 한 모든 문자를 저장하지 못할 수 있습니다. 예를 들어, 데이터베이스가 내부에서 Latin-1을 사용하고 있고 사용자가 러시아어, 히브리어 또는 일본어 문자를 입력하면 데이터베이스에 들어 오면 데이터가 영구적으로 손실됩니다. 가능하면 데이터베이스의 내부 저장소로 UTF-8을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2938c7a03b69cd87f9b1aa212b423aa26fbaac81" translate="yes" xml:space="preserve">
          <source>Your mailer classes - like every other part of your Rails application - should be tested to ensure that they are working as expected.</source>
          <target state="translated">Rails 애플리케이션의 다른 모든 부분과 마찬가지로 메일러 클래스를 테스트하여 예상대로 작동하는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ab42293e29e1ffb306c1403dd95144d664853a60" translate="yes" xml:space="preserve">
          <source>Your name</source>
          <target state="translated">당신의 이름</target>
        </trans-unit>
        <trans-unit id="aeeb3d354b00626c8211572d585a88e90b421995" translate="yes" xml:space="preserve">
          <source>Your own &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags are treated as cross-origin and blocked by default, too. If you really mean to load JavaScript from &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tags, you must now explicitly skip CSRF protection on those actions.</source>
          <target state="translated">자신의 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그는 교차 출처로 취급되며 기본적으로 차단됩니다. &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 태그 에서 JavaScript를로드하려는 경우 , 해당 조치에서 CSRF 보호를 명시 적으로 건너 뛰어야합니다.</target>
        </trans-unit>
        <trans-unit id="ed49c1afbc0be867d6962c73c3c84066660bff1e" translate="yes" xml:space="preserve">
          <source>Your primary database in the development environment is &amp;ldquo;my_application&amp;rdquo; but the Book model connects to a separate database called &amp;ldquo;library_db&amp;rdquo; (this can even be a database on a different machine).</source>
          <target state="translated">개발 환경의 기본 데이터베이스는 &quot;my_application&quot;이지만 Book 모델은 &quot;library_db&quot;라는 별도의 데이터베이스에 연결됩니다 (이는 다른 컴퓨터의 데이터베이스 일 수도 있음).</target>
        </trans-unit>
        <trans-unit id="e575b4b962be144e9bd0a0a34c79568704539c00" translate="yes" xml:space="preserve">
          <source>Your scope can take arguments:</source>
          <target state="translated">당신의 범위는 논쟁을 취할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="76b83c70cf41d41178e75bb589de1c3057228144" translate="yes" xml:space="preserve">
          <source>Your scope can utilize conditionals:</source>
          <target state="translated">스코프는 조건을 활용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="306d334515210a72e388684c16f2cb1ad2d86345" translate="yes" xml:space="preserve">
          <source>Your tests are run under &lt;code&gt;RAILS_ENV=test&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;RAILS_ENV=test&lt;/code&gt; 에서 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fa3760eb9f0094663d4fa4d25f6e8e7cc58d4d5" translate="yes" xml:space="preserve">
          <source>Your text editor: Most text editors (such as TextMate), default to saving files as UTF-8. If your text editor does not, this can result in special characters that you enter in your templates (such as &amp;eacute;) to appear as a diamond with a question mark inside in the browser. This also applies to your i18n translation files. Most editors that do not already default to UTF-8 (such as some versions of Dreamweaver) offer a way to change the default to UTF-8. Do so.</source>
          <target state="translated">텍스트 편집기 : 대부분의 텍스트 편집기 (예 : TextMate)는 기본적으로 파일을 UTF-8로 저장합니다. 텍스트 편집기가 그렇지 않으면 템플릿에 입력하는 특수 문자 (예 : &amp;eacute;)가 브라우저에 물음표가있는 다이아몬드로 표시 될 수 있습니다. 이것은 i18n 번역 파일에도 적용됩니다. UTF-8로 기본 설정되지 않은 대부분의 편집기 (예 : 일부 Dreamweaver 버전)에서는 기본값을 UTF-8로 변경하는 방법을 제공합니다. 그렇게하세요</target>
        </trans-unit>
        <trans-unit id="3659661b6ab9cdb12729ba743a8a4b8128b34f3f" translate="yes" xml:space="preserve">
          <source>Zap! No more fruits_monkeys.yml file. We've specified the list of fruits on George's fixture, but we could've just as easily specified a list of monkeys on each fruit. As with &lt;code&gt;belongs_to&lt;/code&gt;, Active Record reflects on the fixture's model class and discovers the &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; associations.</source>
          <target state="translated">기력! fruits_monkeys.yml 파일이 더 이상 없습니다. 조지의 비품에 과일 목록을 지정했지만 각 과일에 원숭이 목록을 쉽게 지정할 수있었습니다. &lt;code&gt;belongs_to&lt;/code&gt; 와 마찬가지로 , Active Record는 조명기의 모델 클래스를 반영하고 &lt;code&gt;has_and_belongs_to_many&lt;/code&gt; 연관을 발견합니다 .</target>
        </trans-unit>
        <trans-unit id="4c348f27332d02b4c11176b5b52567e1c4f49b9a" translate="yes" xml:space="preserve">
          <source>Zones#in_time_zone</source>
          <target state="translated">Zones#in_time_zone</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
