<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="58f4a5191b04c275b13b1266e03ae0e69f92c2c1" translate="yes" xml:space="preserve">
          <source>Structured type, two fields: the first field contains an unsigned int, the second an int32:</source>
          <target state="translated">구조화 된 유형, 두 개의 필드 : 첫 번째 필드에는 부호없는 int가 있고 두 번째 필드에는 int32가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca4456203ca66897ff0941bbafc31276906d7671" translate="yes" xml:space="preserve">
          <source>Structured view(s) of &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; in memory, matching the reordered and optimized iterator access pattern. Valid only before the iterator is closed.</source>
          <target state="translated">재정렬되고 최적화 된 반복자 액세스 패턴과 일치하는 메모리 내 &lt;a href=&quot;numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt; 의 구조적 뷰 . 반복자가 닫히기 전에 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="64b82b877494406e2f3a32e02b06a27f71eea3a4" translate="yes" xml:space="preserve">
          <source>Style Guide for C Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d5cb7a8cd071c4380d4985485547b9c9160ad6" translate="yes" xml:space="preserve">
          <source>Style Guide for Python Code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0404cfe2117190faccc065f3c4e76c4322b57e18" translate="yes" xml:space="preserve">
          <source>Stylistic Guidelines</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="803fd087e54001bfefdde2c389864825258535d4" translate="yes" xml:space="preserve">
          <source>Sub-arrays always have a C-contiguous memory layout.</source>
          <target state="translated">하위 배열은 항상 C 연속 메모리 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="b5f988ec613aba03f62b8fb5c8cfc27a7a1a6d0f" translate="yes" xml:space="preserve">
          <source>Sub-optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (due to repeated path calculation time): ~330ms</source>
          <target state="translated">차선 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; 계산 값 (반복 경로 계산 시간으로 인해) : ~ 330ms</target>
        </trans-unit>
        <trans-unit id="fa0a23c0a00071a5375730590cb136590b810c95" translate="yes" xml:space="preserve">
          <source>Subclasses of &lt;code&gt;ndarray&lt;/code&gt; are preserved except for the &amp;lsquo;raw&amp;rsquo; mode. So if &lt;code&gt;a&lt;/code&gt; is of type &lt;code&gt;matrix&lt;/code&gt;, all the return values will be matrices too.</source>
          <target state="translated">'원시'모드를 제외하고 &lt;code&gt;ndarray&lt;/code&gt; 의 서브 클래스 가 유지됩니다. 따라서 &lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;matrix&lt;/code&gt; 유형 이면 모든 반환 값도 행렬이됩니다.</target>
        </trans-unit>
        <trans-unit id="a9ce918753c36dd7a183b105790cb0ccc1e3d737" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;../user/basics.dispatch#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d147ab8047bc6066411af552791a9504b59a189" translate="yes" xml:space="preserve">
          <source>Subclassing a &lt;code&gt;numpy.ndarray&lt;/code&gt; is possible but if your goal is to create an array with &lt;em&gt;modified&lt;/em&gt; behavior, as do dask arrays for distributed computation and cupy arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy&amp;rsquo;s &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;dispatch mechanism&lt;/a&gt; is recommended.</source>
          <target state="translated">&lt;code&gt;numpy.ndarray&lt;/code&gt; 를 서브 클래 싱하는 것이 가능하지만 분산 계산을위한 dask 배열과 GPU 기반 계산을위한 cupy 배열과 같이 &lt;em&gt;수정 된&lt;/em&gt; 동작으로 배열을 만드는 것이 목표 라면 서브 클래 싱은 권장되지 않습니다. 대신 numpy의 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.dispatch.html#basics-dispatch&quot;&gt;디스패치 메커니즘&lt;/a&gt; 을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="272f065bb249898427d153b9ddec706f4a4c8ea8" translate="yes" xml:space="preserve">
          <source>Subclassing and Downstream Compatibility</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc88cf96b41fa0646c461894f505af99f67ac1" translate="yes" xml:space="preserve">
          <source>Subclassing is preserved. This means that if, e.g., the data part of the masked array is a recarray, &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt;&lt;code&gt;filled&lt;/code&gt;&lt;/a&gt; returns a recarray:</source>
          <target state="translated">서브 클래 싱이 유지됩니다. 즉, 예를 들어 마스킹 된 배열의 데이터 부분이 recarray 인 경우 &lt;a href=&quot;numpy.ma.filled#numpy.ma.filled&quot;&gt; &lt;code&gt;filled&lt;/code&gt; &lt;/a&gt; 는 recarray 를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dcd026d87f16ab5d865099378d38748e1049d4d8" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray</source>
          <target state="translated">서브 클래딩 ndarray</target>
        </trans-unit>
        <trans-unit id="b7c286e3d93f3ece394b3827e135e8a12233cdf1" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is complicated by the fact that new instances of ndarray classes can come about in three different ways. These are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a44ddbc8fd0076edc9e53d1235eba11c7929dc0" translate="yes" xml:space="preserve">
          <source>Subclassing ndarray is relatively simple, but it has some complications compared to other Python objects. On this page we explain the machinery that allows you to subclass ndarray, and the implications for implementing a subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63f32464b42a864e77739b2bee513b261ea02191" translate="yes" xml:space="preserve">
          <source>Subcommittees</source>
          <target state="translated">Subcommittees</target>
        </trans-unit>
        <trans-unit id="d9952117e8cb53d0fd7ca6ba7d99ad537965d8c9" translate="yes" xml:space="preserve">
          <source>Subdivide &lt;code&gt;int16&lt;/code&gt; into 2 &lt;code&gt;int8&lt;/code&gt;&amp;rsquo;s, called x and y. 0 and 1 are the offsets in bytes:</source>
          <target state="translated">&lt;code&gt;int16&lt;/code&gt; 을 x와 y라는 2 개의 &lt;code&gt;int8&lt;/code&gt; 로 세분화 합니다. 0과 1은 바이트 단위의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="7cd760711c541e202c788fb098af0b33b391721e" translate="yes" xml:space="preserve">
          <source>Subsequence with trailing zeros removed. If the resulting sequence would be empty, return the first element. The returned sequence may or may not be a view.</source>
          <target state="translated">후행 0이 제거 된 서브 시퀀스. 결과 시퀀스가 ​​비어 있으면 첫 번째 요소를 반환하십시오. 리턴 된 순서는보기 일 수도 있고 아닐 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="c763109714f2536fc1c4a6c89fdf2646454177e1" translate="yes" xml:space="preserve">
          <source>Substantial portions of this document were adapted from the &lt;a href=&quot;https://github.com/jupyter/governance/blob/master/governance.md&quot;&gt;Jupyter/IPython project&amp;rsquo;s governance document&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="259ff26648e77d2b9a5ec16a4f186ec8e1c65753" translate="yes" xml:space="preserve">
          <source>Substitute a polynomial for x and expand the result. Here we substitute p in itself leading to a new polynomial of degree 4 after expansion. If the polynomials are regarded as functions this is composition of functions:</source>
          <target state="translated">x에 다항식을 대입하고 결과를 확장합니다. 여기서 우리는 p를 그 자체로 대치하여 확장 후 4 도의 새로운 다항식을 만듭니다. 다항식이 함수로 간주되는 경우 이는 함수의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="8d18e7a773fc8ec030ec151dbf7cd596c836697a" translate="yes" xml:space="preserve">
          <source>Substitution:</source>
          <target state="translated">Substitution:</target>
        </trans-unit>
        <trans-unit id="976370d3324e5eaaec19ed99a261ec090486b0fa" translate="yes" xml:space="preserve">
          <source>Subtract arguments, element-wise.</source>
          <target state="translated">요소별로 인수를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="8567fbb4d729f4cd5b7fbe5674c01c465635fa47" translate="yes" xml:space="preserve">
          <source>Subtract one Chebyshev series from another.</source>
          <target state="translated">한 체비 쇼프 시리즈에서 다른 체비 쇼프 시리즈를 뺍니다.</target>
        </trans-unit>
        <trans-unit id="a494f472ea255a2aaa4f1c8f52b90c62196690f5" translate="yes" xml:space="preserve">
          <source>Subtract one Hermite series from another.</source>
          <target state="translated">하나의 Hermite 시리즈를 다른 시리즈에서 빼십시오.</target>
        </trans-unit>
        <trans-unit id="60b31c93b32c6d82ec367e99b58e2a7fd1690435" translate="yes" xml:space="preserve">
          <source>Subtract one Laguerre series from another.</source>
          <target state="translated">하나의 Laguerre 시리즈를 다른 시리즈에서 빼십시오.</target>
        </trans-unit>
        <trans-unit id="09477810015d786e3a1ce0d9827bfd9d00039de6" translate="yes" xml:space="preserve">
          <source>Subtract one Legendre series from another.</source>
          <target state="translated">하나의 Legendre 시리즈를 다른 시리즈에서 빼십시오.</target>
        </trans-unit>
        <trans-unit id="a2407a57a6647eba13b915586134c7e1d7534217" translate="yes" xml:space="preserve">
          <source>Subtract one polynomial from another.</source>
          <target state="translated">하나의 다항식을 다른 다항식에서 뺍니다.</target>
        </trans-unit>
        <trans-unit id="5de67be97d964e12a293477e154e8fa146741938" translate="yes" xml:space="preserve">
          <source>Subtract other from self in-place.</source>
          <target state="translated">제자리에서 다른 것을 빼십시오.</target>
        </trans-unit>
        <trans-unit id="b3957443ea74659d4523c7bc9e466d304ba155cf" translate="yes" xml:space="preserve">
          <source>Subtract other from self, and return a new masked array.</source>
          <target state="translated">self에서 other를 빼고 새로운 마스크 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6cf676697a4c117ec3074a618da8a2b0fca9cd14" translate="yes" xml:space="preserve">
          <source>Subtract self from other, and return a new masked array.</source>
          <target state="translated">다른 것에서 자기를 빼고 새로운 마스크 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="77a74ccf7fd60ada9c57d2300edad576a2eb6285" translate="yes" xml:space="preserve">
          <source>Subtyping the ndarray in C</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b818b7784e48b243d98be89f763b62cb9fc7bd" translate="yes" xml:space="preserve">
          <source>Successfully tested on:</source>
          <target state="translated">다음에서 성공적으로 테스트되었습니다.</target>
        </trans-unit>
        <trans-unit id="7f477dc5121884706ef8fed21e4d11c24e6db091" translate="yes" xml:space="preserve">
          <source>Sum across array propagating NaNs.</source>
          <target state="translated">배열 전파 NaN을 합산합니다.</target>
        </trans-unit>
        <trans-unit id="b2cc82eaee79a7562889de3502bb827b013693aa" translate="yes" xml:space="preserve">
          <source>Sum along diagonals.</source>
          <target state="translated">대각선을 따라 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="b221abad8e52361732192c7acb9613f67b076ac3" translate="yes" xml:space="preserve">
          <source>Sum array elements.</source>
          <target state="translated">배열 요소 합.</target>
        </trans-unit>
        <trans-unit id="96c00e26cd369dd11b081a1035d4633225e7965d" translate="yes" xml:space="preserve">
          <source>Sum of array elements over a given axis.</source>
          <target state="translated">주어진 축에 대한 배열 요소의 합입니다.</target>
        </trans-unit>
        <trans-unit id="6302a8aa98d30db8a3e7186cb73eb9e4337d618b" translate="yes" xml:space="preserve">
          <source>Sum over an axis (requires explicit form):</source>
          <target state="translated">축에 대한 합계 (명시 적 형식 필요) :</target>
        </trans-unit>
        <trans-unit id="1c979daf2b6e4cef98bd537ad236de258dbc0d5a" translate="yes" xml:space="preserve">
          <source>Sum over axes 0 and 2. The result has same number of dimensions as the original array:</source>
          <target state="translated">축 0과 2에 대한 합입니다. 결과는 원래 배열과 동일한 차원 수를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="1103f1f7acbd2c5b9349bcbddbb45121fae537eb" translate="yes" xml:space="preserve">
          <source>Sum products over arbitrary axes.</source>
          <target state="translated">임의의 축에 곱을 합산하십시오.</target>
        </trans-unit>
        <trans-unit id="12b71c3e0fe5f7c0b8d17cc03186e281412da4a8" translate="yes" xml:space="preserve">
          <source>Summary</source>
          <target state="translated">Summary</target>
        </trans-unit>
        <trans-unit id="bf661fd6213ae079ce34c2c9dd00db526c359e2b" translate="yes" xml:space="preserve">
          <source>Sums of residuals; squared Euclidean 2-norm for each column in &lt;code&gt;b - a*x&lt;/code&gt;. If the rank of &lt;code&gt;a&lt;/code&gt; is &amp;lt; N or M &amp;lt;= N, this is an empty array. If &lt;code&gt;b&lt;/code&gt; is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</source>
          <target state="translated">잔차의 합; 제곱 유클리드 각 열의 2- 놈 &lt;code&gt;b - a*x&lt;/code&gt; . 의 랭크 경우 &lt;code&gt;a&lt;/code&gt; &amp;lt;N 또는 M &amp;lt;= N이며, 이는 빈 배열이다. 경우 &lt;code&gt;b&lt;/code&gt; 는 1 차원이고, 이것은 (1) 형상으로 배열된다. 그렇지 않으면 모양은 (K,)입니다.</target>
        </trans-unit>
        <trans-unit id="b6c71b95244ccde5ac8df906b9633b9278b04563" translate="yes" xml:space="preserve">
          <source>Sums, products, differences</source>
          <target state="translated">합계, 곱, 차이</target>
        </trans-unit>
        <trans-unit id="56cedb0b6384ebe895f048d3113a97e19adce9ed" translate="yes" xml:space="preserve">
          <source>SunOS 5.9, Python 2.2, 2.3.2</source>
          <target state="translated">SunOS 5.9, Python 2.2, 2.3.2</target>
        </trans-unit>
        <trans-unit id="67fd60fec12a23f41f4967a1b913d9c8325a3d58" translate="yes" xml:space="preserve">
          <source>Superposes arrays fields by fields</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f3a3e0dca6bfb201866f4e02f7f0f252f0503d" translate="yes" xml:space="preserve">
          <source>Supplying additional compiler flags</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd465d5e53c115d109beacd89675429e7fe9e2eb" translate="yes" xml:space="preserve">
          <source>Support for 64-bit OpenBLAS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05979ff1799bf4b31c7aaaf6575b3a44600e6938" translate="yes" xml:space="preserve">
          <source>Support for &lt;code&gt;decimal.Decimal&lt;/code&gt; in &lt;code&gt;np.lib.financial&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94bf5963bbdc6b1a3677d96a194c63df08cc0ebe" translate="yes" xml:space="preserve">
          <source>Support for PGI flang compiler on Windows</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbec54e843ff9113eeef63ba5ba94427429af2" translate="yes" xml:space="preserve">
          <source>Support for cross-platform builds for iOS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4312602ded392453d6506535641b2fe8fc3f434" translate="yes" xml:space="preserve">
          <source>Support for linear algebra on stacked arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1486bb007dde41a6cd27d40051180a9824cbf65" translate="yes" xml:space="preserve">
          <source>Support for median and percentile in nanfunctions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5732c875d678ed7bc376f8bdb01c865cd0e57b5f" translate="yes" xml:space="preserve">
          <source>Support for multiple insertions when &lt;code&gt;obj&lt;/code&gt; is a single scalar or a sequence with one element (similar to calling insert multiple times).</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 단일 스칼라이거나 하나의 요소가있는 시퀀스 인 경우 다중 삽입 지원 (삽입을 여러 번 호출하는 것과 유사).</target>
        </trans-unit>
        <trans-unit id="4c2c6be525f6d9a610c57848f9ef0612672209f9" translate="yes" xml:space="preserve">
          <source>Support for reading lzma compressed text files in Python 3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ebd340f9cd250715efd00bc82361318ecaf77c" translate="yes" xml:space="preserve">
          <source>Support for returning arrays of arbitrary dimensions in &lt;code&gt;apply_along_axis&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d5e2188fd70bec3fdf433ddaeea9f504cb04b41" translate="yes" xml:space="preserve">
          <source>Support for the &amp;lsquo;@&amp;rsquo; operator in Python 3.5+</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96793ccd7b743fcb4b68f47fc4a80f55eade2824" translate="yes" xml:space="preserve">
          <source>Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="729714232faf9c660ac35de89eac7db896893cb6" translate="yes" xml:space="preserve">
          <source>Support for tracemalloc in Python 3.6</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08bf3021612bda0edd29ed3bce556141bfaab8f8" translate="yes" xml:space="preserve">
          <source>Support of object arrays in &lt;code&gt;matmul&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="738f921dd6d285f914885c453cfc677ad8fc0e6b" translate="yes" xml:space="preserve">
          <source>Support path-like objects for more functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d95257e0d6b5ee52701ed6e60955d7b5cf2355f" translate="yes" xml:space="preserve">
          <source>Supported BitGenerators</source>
          <target state="translated">지원되는 BitGenerator</target>
        </trans-unit>
        <trans-unit id="35d1294934e4cc4b101779bccdbe627fdf3b5b49" translate="yes" xml:space="preserve">
          <source>Supported platforms and versions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="090678b79c24d0799aa7434df5ba4e013c0ea2ff" translate="yes" xml:space="preserve">
          <source>Supports Fortran-contiguous arrays directly.</source>
          <target state="translated">포트란 연속 배열을 직접 지원합니다.</target>
        </trans-unit>
        <trans-unit id="62c4a407a3644c899b58964ef70d8d5ea099dfdd" translate="yes" xml:space="preserve">
          <source>Supports full broadcasting of the inputs.</source>
          <target state="translated">입력의 전체 방송을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="12f46de9102cae348756a951378fba972f726b07" translate="yes" xml:space="preserve">
          <source>Supports rolling over multiple dimensions simultaneously.</source>
          <target state="translated">여러 치수를 동시에 롤오버 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c531221221ae570c082e108201b731a1c902860f" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97b0cce7cf0a1a8ea78834b26b7eaa1e93207d9" translate="yes" xml:space="preserve">
          <source>Supports the method &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt; to advance the RNG an arbitrary number of steps. The state of the PCG-64 RNG is represented by 2 128-bit unsigned integers.</source>
          <target state="translated">RNG를 임의의 수의 단계로 &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; 하기 위한 방법 진행 을 지원 합니다. PCG-64 RNG의 상태는 2 개의 128 비트 부호없는 정수로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="34c5f00d14223115d609ab63804b8bf6dbd38059" translate="yes" xml:space="preserve">
          <source>Suppose &lt;code&gt;x.shape&lt;/code&gt; is (10,20,30) and &lt;code&gt;ind&lt;/code&gt; is a (2,3,4)-shaped indexing &lt;code&gt;intp&lt;/code&gt; array, then &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; has shape (10,2,3,4,30) because the (20,)-shaped subspace has been replaced with a (2,3,4)-shaped broadcasted indexing subspace. If we let &lt;em&gt;i, j, k&lt;/em&gt; loop over the (2,3,4)-shaped subspace then &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt;. This example produces the same result as &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;x.shape&lt;/code&gt; 가 (10,20,30)이고 &lt;code&gt;ind&lt;/code&gt; 가 (2,3,4) 모양의 인덱스 &lt;code&gt;intp&lt;/code&gt; 배열 이라고 가정 하고 &lt;code&gt;result = x[...,ind,:]&lt;/code&gt; 모양이 (10,2,3) (20,) 형 서브 스페이스가 (2,3,4) 형 브로드 캐스트 인덱싱 서브 스페이스로 대체 되었기 때문이다. 만약 우리가 &lt;em&gt;i, j, k&lt;/em&gt; 가 (2,3,4) 모양의 부분 공간을 반복하게하면 &lt;code&gt;result[...,i,j,k,:] = x[...,ind[i,j,k],:]&lt;/code&gt; . 이 예제는 &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;x.take(ind, axis=-2)&lt;/code&gt; &lt;/a&gt; 와 동일한 결과를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="ab6e03b971eeb9906907892d695f98f70c00c465" translate="yes" xml:space="preserve">
          <source>Suppose I have two files coolmodule.c and coolhelper.c which need to be compiled and linked into a single extension module. Suppose coolmodule.c contains the required initcool module initialization function (with the import_array() function called). Then, coolmodule.c would have at the top:</source>
          <target state="translated">coolmodule.c와 coolhelper.c라는 파일 두 개가 컴파일되어 단일 확장 모듈에 연결되어 있다고 가정 해 봅시다. coolmodule.c에 필요한 initcool 모듈 초기화 함수 (import_array () 함수 호출)가 포함되어 있다고 가정하십시오. 그러면 coolmodule.c가 맨 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a06be2cc716b778d6a1c32b124922e42d2cce52" translate="yes" xml:space="preserve">
          <source>Suppose now that we wish to print that same data, but with the missing values replaced by the average value.</source>
          <target state="translated">동일한 데이터를 인쇄하려고하지만 결 측값이 평균값으로 대체되었다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="c30e0906e4415225d057040ed0740bd62f0ab08e" translate="yes" xml:space="preserve">
          <source>Suppose that the commit history looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5dca6dc181cc53601add013bc2ada72709458943" translate="yes" xml:space="preserve">
          <source>Suppose the first operand is one dimensional and the second operand is two dimensional. The iterator will have three dimensions, so &lt;code&gt;op_axes&lt;/code&gt; will have two 3-element lists. The first list picks out the one axis of the first operand, and is -1 for the rest of the iterator axes, with a final result of [0, -1, -1]. The second list picks out the two axes of the second operand, but shouldn&amp;rsquo;t overlap with the axes picked out in the first operand. Its list is [-1, 0, 1]. The output operand maps onto the iterator axes in the standard manner, so we can provide None instead of constructing another list.</source>
          <target state="translated">첫 번째 피연산자가 1 차원이고 두 번째 피연산자가 2 차원이라고 가정하십시오. 반복자는 3 차원을 가지므로 &lt;code&gt;op_axes&lt;/code&gt; 에는 2 개의 3 요소 목록이 있습니다. 첫 번째 목록은 첫 번째 피연산자의 한 축을 선택하고 나머지 반복기 축의 경우 -1이며 최종 결과는 [0, -1, -1]입니다. 두 번째 목록은 두 번째 피연산자의 두 축을 선택하지만 첫 번째 피연산자에서 선택한 축과 겹치지 않아야합니다. 그 목록은 [-1, 0, 1]입니다. 출력 피연산자는 표준 방식으로 반복자 축에 매핑되므로 다른 목록을 구성하는 대신 없음을 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbff519fe81519b5859278de1db83d3776384bb" translate="yes" xml:space="preserve">
          <source>Suppose you have a SciPy module &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; containing a function &lt;code&gt;zzz()&lt;/code&gt;. To test this function you would create a test module called &lt;code&gt;test_yyy.py&lt;/code&gt;. If you only need to test one aspect of &lt;code&gt;zzz&lt;/code&gt;, you can simply add a test function:</source>
          <target state="translated">&lt;code&gt;zzz()&lt;/code&gt; 함수를 포함 하는 SciPy 모듈 &lt;code&gt;scipy/xxx/yyy.py&lt;/code&gt; 가 있다고 가정하십시오 . 이 함수를 테스트하려면 &lt;code&gt;test_yyy.py&lt;/code&gt; 라는 테스트 모듈을 작성하십시오 . &lt;code&gt;zzz&lt;/code&gt; 의 한 측면 만 테스트해야하는 경우 간단히 테스트 기능을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="561e62ec5d03ac50c21e0a257548d3eb990ac028" translate="yes" xml:space="preserve">
          <source>Suppose you have an urn with 15 white and 15 black marbles. If you pull 15 marbles at random, how likely is it that 12 or more of them are one color?</source>
          <target state="translated">15 개의 흰색 대리석과 15 개의 검은 구슬이있는 항아리가 있다고 가정합니다. 15 개의 구슬을 무작위로 뽑으면 12 개 이상의 구슬이 한 가지 색일 가능성이 얼마나됩니까?</target>
        </trans-unit>
        <trans-unit id="7c7cd36a0c21d430e2827a371600cad0b35b80b7" translate="yes" xml:space="preserve">
          <source>Suppress the rows and/or columns of a 2-D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2 차원 배열의 행 및 / 또는 열을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="00f54cf02ad98c4bd3014ede43830053636d4545" translate="yes" xml:space="preserve">
          <source>Suppress whole columns of a 2-D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2 차원 배열의 전체 열을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="685b0c43425911b6f904fe6d170e96c0345d4cbf" translate="yes" xml:space="preserve">
          <source>Suppress whole rows of a 2-D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2 차원 배열의 전체 행을 억제합니다.</target>
        </trans-unit>
        <trans-unit id="b11d9a95741366c39b17b9d4fd94445d808b15b4" translate="yes" xml:space="preserve">
          <source>Swap the bytes of the array elements</source>
          <target state="translated">배열 요소의 바이트 교체</target>
        </trans-unit>
        <trans-unit id="bbdcf90ffec6f9d47a9ac51cf19b00a93a140fa9" translate="yes" xml:space="preserve">
          <source>Switch determining nature of return value. When it is False (the default) just the coefficients are returned, when True diagnostic information from the singular value decomposition is also returned.</source>
          <target state="translated">반환 값의 특성을 결정하는 스위치. False (기본값) 인 경우 특이 값 분해의 True 진단 정보도 반환 될 때 계수 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6b3384dea957229bd45073ab4c8cae823f791969" translate="yes" xml:space="preserve">
          <source>Switch determining the nature of the return value. When &lt;code&gt;False&lt;/code&gt; (the default) just the coefficients are returned; when &lt;code&gt;True&lt;/code&gt;, diagnostic information from the singular value decomposition (used to solve the fit&amp;rsquo;s matrix equation) is also returned.</source>
          <target state="translated">리턴 값의 특성을 결정하는 스위치. 때 &lt;code&gt;False&lt;/code&gt; (기본) 단지 계수가 반환된다 &lt;code&gt;True&lt;/code&gt; 일 때 특이 값 분해 (피트의 행렬 방정식을 푸는 데 사용)의 진단 정보도 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="7af38070c59fd5383f5319f90871324cb011240a" translate="yes" xml:space="preserve">
          <source>System Entropy</source>
          <target state="translated">시스템 엔트로피</target>
        </trans-unit>
        <trans-unit id="1b1430441b7b7dd5a90d83f42f914deacc5fd0e5" translate="yes" xml:space="preserve">
          <source>System configuration</source>
          <target state="translated">시스템 설정</target>
        </trans-unit>
        <trans-unit id="c2c53d66948214258a26ca9ca845d7ac0c17f8e7" translate="yes" xml:space="preserve">
          <source>T</source>
          <target state="translated">T</target>
        </trans-unit>
        <trans-unit id="29f1b70dfc7cd7e2755985e321ea4063c37e7f58" translate="yes" xml:space="preserve">
          <source>T (numpy.char.chararray attribute)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08fb6d4b20d17768263265c26a0d6392cfb83ed1" translate="yes" xml:space="preserve">
          <source>T() (numpy.ma.masked_array property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="494db6c744e0093634443456957eafcc51937e81" translate="yes" xml:space="preserve">
          <source>THE RESULTING LOGIT FUNCTION IS NOT FAST! numpy.vectorize simply loops over spam.logit. The loop is done at the C level, but the numpy array is constantly being parsed and build back up. This is expensive. When the author compared numpy.vectorize(spam.logit) against the logit ufuncs constructed below, the logit ufuncs were almost exactly 4 times faster. Larger or smaller speedups are, of course, possible depending on the nature of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d06ee651a160babb28eda47548bd9fad2ca6df2" translate="yes" xml:space="preserve">
          <source>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &amp;ldquo;AS IS&amp;rdquo; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e0d354392fe3fc9d2a5d83e7fd5a6f24a2b815a" translate="yes" xml:space="preserve">
          <source>TODO: Maybe it would be better to introduce a function &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; and remove this flag?</source>
          <target state="translated">TODO : &lt;code&gt;NpyIter_GetWrappedOutput&lt;/code&gt; 함수를 도입 하고이 플래그를 제거 하는 것이 더 좋을 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c398f641b79127cbb5368a052c9c18ee4b191edd" translate="yes" xml:space="preserve">
          <source>TODO: This feature can be easily extended for Fortran 90 codes as well. Let us know if you would need such a feature.</source>
          <target state="translated">TODO :이 기능은 Fortran 90 코드에서도 쉽게 확장 할 수 있습니다. 이러한 기능이 필요한 경우 알려주십시오.</target>
        </trans-unit>
        <trans-unit id="8cfd932f7721749006331a6f950d4068e186ddf4" translate="yes" xml:space="preserve">
          <source>Table of Rough MATLAB-NumPy Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2e0fad2c7303a14e3d40f2816778e4a945515d7" translate="yes" xml:space="preserve">
          <source>Tag the release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2bf59208074c19e062d597b69c91e24c1b3f65d" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">일련의 1D 배열을 가져와 열로 쌓아서 단일 2D 배열을 만듭니다. 2 차원 배열은 &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 그대로 쌓 입니다. 1 차원 배열은 먼저 2 차원 열로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="a7063ff9c282b69776d4b6c1965ce5cc8d3d21f1" translate="yes" xml:space="preserve">
          <source>Take a sequence of 1-D arrays and stack them as columns to make a single 2-D array. 2-D arrays are stacked as-is, just like with &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;. 1-D arrays are turned into 2-D columns first.</source>
          <target state="translated">일련의 1D 배열을 가져와 열로 쌓아서 단일 2D 배열을 만듭니다. 2 차원 배열은 &lt;a href=&quot;numpy.ma.hstack#numpy.ma.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 과 마찬가지로 그대로 쌓 입니다. 1 차원 배열은 먼저 2 차원 열로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="948650b27c1b2b9784a79436cafe48d7d653c938" translate="yes" xml:space="preserve">
          <source>Take along an axis, using the same indices for every 1d slice</source>
          <target state="translated">1d 슬라이스마다 동일한 인덱스를 사용하여 축을 따라 가십시오.</target>
        </trans-unit>
        <trans-unit id="750d821c9fa304621f4be0f3b88564bf9278e152" translate="yes" xml:space="preserve">
          <source>Take elements by matching the array and the index arrays</source>
          <target state="translated">배열과 인덱스 배열을 일치시켜 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="e11fd16230a195030272e04871b014d038eef9ab" translate="yes" xml:space="preserve">
          <source>Take elements from an array along an axis.</source>
          <target state="translated">축을 따라 배열에서 요소를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="2bd0abec8d18fb4f628e5467a962eaf329bb6905" translate="yes" xml:space="preserve">
          <source>Take elements using a boolean mask</source>
          <target state="translated">부울 마스크를 사용하여 요소 가져 오기</target>
        </trans-unit>
        <trans-unit id="b8cd92f0049ea13b3db726f84fc3411287caeddf" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">data-type 객체에 첨부 된 것과 같은 필드 사전 인 &lt;em&gt;dict를&lt;/em&gt; 가져 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 객체 의 names 필드에 저장된 것과 같이 정렬 된 필드 이름 목록을 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="8588b385cd332763c111b95b02976dcd4b8a50f6" translate="yes" xml:space="preserve">
          <source>Take the fields dictionary, &lt;em&gt;dict&lt;/em&gt;, such as the one attached to a data-type object and construct an ordered-list of field names such as is stored in the names field of the &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="673397230d0da22f7147b4eeece871fd1294c5ff" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices</source>
          <target state="translated">1d 인덱스와 데이터 슬라이스를 일치시켜 입력 배열에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="7f4b8f1ca46302f3d1aba5fbdc3749dad60f0480" translate="yes" xml:space="preserve">
          <source>Take values from the input array by matching 1d index and data slices.</source>
          <target state="translated">1d 인덱스와 데이터 슬라이스를 일치시켜 입력 배열에서 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="567aaaa85050a78f736c937e4e349477825e7c6c" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a NumPy ufunc.</source>
          <target state="translated">임의의 Python 함수를 사용하고 NumPy ufunc를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ad884a5ab2796ce61beab25497caa48a0c350a18" translate="yes" xml:space="preserve">
          <source>Takes an arbitrary Python function and returns a ufunc</source>
          <target state="translated">임의의 파이썬 함수를 가져 와서 ufunc를 반환합니다</target>
        </trans-unit>
        <trans-unit id="4fe8421f7b4bac2910c2919a03e01d32f910e006" translate="yes" xml:space="preserve">
          <source>Taking an example cited in Wikipedia, this distribution can be used if one wanted to cut strings (each of initial length 1.0) into K pieces with different lengths, where each piece had, on average, a designated average length, but allowing some variation in the relative sizes of the pieces.</source>
          <target state="translated">Wikipedia에서 인용 된 예를 들어,이 분포는 문자열 (각 초기 길이 1.0)을 길이가 다른 K 조각으로 자르고 싶을 때 사용할 수 있습니다. 각 조각은 평균적으로 지정된 평균 길이를 가지지 만 조각의 상대 크기.</target>
        </trans-unit>
        <trans-unit id="a8980c440e8f502e5c59dc6cdcc36215481bcc7e" translate="yes" xml:space="preserve">
          <source>Taking no further action</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af1237aaefe517f485a7a53e6bb8a3bb8a86a6a4" translate="yes" xml:space="preserve">
          <source>Target array.</source>
          <target state="translated">대상 배열.</target>
        </trans-unit>
        <trans-unit id="51038a1a794fec6114fafbb47a8bce902f23294f" translate="yes" xml:space="preserve">
          <source>Target indices, interpreted as integers.</source>
          <target state="translated">정수로 해석되는 대상 인덱스.</target>
        </trans-unit>
        <trans-unit id="695f8bb0287f4fc300e17fa93e5262f0b53e9bb1" translate="yes" xml:space="preserve">
          <source>Temporary directories are deleted when the DataSource is deleted.</source>
          <target state="translated">데이터 소스가 삭제되면 임시 디렉토리가 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b3d2d960e69084c198868bb0c51081b279e6d57d" translate="yes" xml:space="preserve">
          <source>Temporary elision</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6701dda5ea2a62c52d8395d7a5c8f390a0ab64df" translate="yes" xml:space="preserve">
          <source>Tensor contraction:</source>
          <target state="translated">텐서 수축 :</target>
        </trans-unit>
        <trans-unit id="7e786b6ecaa33c3bfa2a663250579b348bbb6678" translate="yes" xml:space="preserve">
          <source>Tensor contractions, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt;&lt;code&gt;numpy.tensordot&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">텐서 수축, &lt;a href=&quot;numpy.tensordot#numpy.tensordot&quot;&gt; &lt;code&gt;numpy.tensordot&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa53899fcc2f4722e3aaa13b02a9f0c21a58b0c" translate="yes" xml:space="preserve">
          <source>Tensor to &amp;lsquo;invert&amp;rsquo;. Its shape must be &amp;lsquo;square&amp;rsquo;, i. e., &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt;.</source>
          <target state="translated">텐서 '반전'. 모양은 '사각형'이어야합니다. 즉, &lt;code&gt;prod(a.shape[:ind]) == prod(a.shape[ind:])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a7912060e7ae8d981d410c16692b658bc5a8653" translate="yes" xml:space="preserve">
          <source>Tensors to &amp;ldquo;dot&amp;rdquo;.</source>
          <target state="translated">텐서가 &quot;점&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="71218d40834bc4913fe2fbb95e52de19a584b43a" translate="yes" xml:space="preserve">
          <source>Test Running</source>
          <target state="translated">시운전</target>
        </trans-unit>
        <trans-unit id="2ec99dbb44d0090912e3c4ddf71222f3cee61914" translate="yes" xml:space="preserve">
          <source>Test Support (&lt;code&gt;numpy.testing&lt;/code&gt;)</source>
          <target state="translated">테스트 지원 ( &lt;code&gt;numpy.testing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c35554b04739c6c6869f7c83d9841e0dda4c5073" translate="yes" xml:space="preserve">
          <source>Test Support (numpy.testing)</source>
          <target state="translated">테스트 지원 (numpy.testing)</target>
        </trans-unit>
        <trans-unit id="a0b0d520e3181fa7765d42a80050b97cb70dbe30" translate="yes" xml:space="preserve">
          <source>Test coverage</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59afddee1692b59da457c30d92a5b65f5e31115a" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaN and return result as a boolean array.</source>
          <target state="translated">NaN에 대해 요소별로 테스트하고 결과를 부울 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed391a308f11ca7f40c17a765e9b20cc4e1035a2" translate="yes" xml:space="preserve">
          <source>Test element-wise for NaT (not a time) and return result as a boolean array.</source>
          <target state="translated">NaT에 대해 요소별로 테스트하고 (시간 아님) 결과를 부울 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f34997c659f4457d18a667e13e9b54ff7ea7b5d" translate="yes" xml:space="preserve">
          <source>Test element-wise for finiteness (not infinity or not Not a Number).</source>
          <target state="translated">유한 요소 (무한이 아니거나 숫자가 아님)에 대해 요소별로 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b73482f0dd7c13ea3e95362c875b37244def5b6c" translate="yes" xml:space="preserve">
          <source>Test element-wise for negative infinity, return result as bool array.</source>
          <target state="translated">음의 무한대에 대해 요소별로 테스트하고 결과를 부울 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f441420173d81baeaa59a4fb443d5293972df75a" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive infinity, return result as bool array.</source>
          <target state="translated">양의 무한대에 대해 요소별로 테스트하고 결과를 부울 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f76286ad13fcd1d6939365b38ad9443c5711054b" translate="yes" xml:space="preserve">
          <source>Test element-wise for positive or negative infinity.</source>
          <target state="translated">양의 또는 음의 무한대에 대해 요소별로 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="a54ae1b5fd87138bbeb065cc5056362be6e773bd" translate="yes" xml:space="preserve">
          <source>Test if &lt;code&gt;path&lt;/code&gt; exists as (and in this order):</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 다음과 같은 순서 로 존재 하는지 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="6db21c53daecd81068cb27c5716c17cf9ec8f853" translate="yes" xml:space="preserve">
          <source>Test if path exists.</source>
          <target state="translated">경로가 존재하는지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="ab9c97d91f47360ac72bf2e9386f7b26c75db7d2" translate="yes" xml:space="preserve">
          <source>Test if two strings are equal.</source>
          <target state="translated">두 문자열이 같은지 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="90c99592ef3a4e369f5b8438543a142bc4a6d8c8" translate="yes" xml:space="preserve">
          <source>Test support</source>
          <target state="translated">테스트 지원</target>
        </trans-unit>
        <trans-unit id="fe6e53750db930a15ff2a9eb0786f6b4b0dd49e8" translate="yes" xml:space="preserve">
          <source>Test whether &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return 1. Otherwise, set a Python error and return 0.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; 가 연속적 인지 테스트합니다 . 그렇다면 1을 반환하고, 그렇지 않으면 Python 오류를 설정하고 0을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="e52099e2b541a96f27cc77aa438f266ac05e538f" translate="yes" xml:space="preserve">
          <source>Test whether all array elements along a given axis evaluate to True.</source>
          <target state="translated">주어진 축을 따라 모든 배열 요소가 True로 평가되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="7d4c1c04414d7af36c37c81837979d62019dac75" translate="yes" xml:space="preserve">
          <source>Test whether all elements along a given axis evaluate to True.</source>
          <target state="translated">주어진 축을 따라 모든 요소가 True로 평가되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="8dcb7ed405671230192b179ae33bab118c7f5996" translate="yes" xml:space="preserve">
          <source>Test whether all matrix elements along a given axis evaluate to True.</source>
          <target state="translated">주어진 축을 따라 모든 행렬 요소가 True로 평가되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="a8cd365e47952360dc676cadf55d3bc2ecae44b5" translate="yes" xml:space="preserve">
          <source>Test whether any array element along a given axis evaluates to True.</source>
          <target state="translated">주어진 축을 따라 배열 요소가 True로 평가되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e54011a9e26f7c9e97e1ca23a771785990f7e7d4" translate="yes" xml:space="preserve">
          <source>Test whether any element along a given axis evaluates to True.</source>
          <target state="translated">주어진 축을 따라 어떤 요소가 True로 평가되는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="3c5d24b0586eac0954dbcb6d49897a1641c89d36" translate="yes" xml:space="preserve">
          <source>Test whether each element of a 1-D array is also present in a second array.</source>
          <target state="translated">1 차원 배열의 각 요소가 두 번째 배열에도 있는지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="025a700084bfede250ccd79227b915c047f7f35d" translate="yes" xml:space="preserve">
          <source>Test whether input is an instance of MaskedArray.</source>
          <target state="translated">입력이 MaskedArray의 인스턴스인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="5904fc9bcfebbe0d053c7cdc88d0d4fdd88cf00c" translate="yes" xml:space="preserve">
          <source>Tester (in module numpy.testing)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0820b32b206b7352858e8903a838ed14319acdfd" translate="yes" xml:space="preserve">
          <source>Testing</source>
          <target state="translated">Testing</target>
        </trans-unit>
        <trans-unit id="43d2fa7f4fbc625f4df01f08ea6653e49f950cbd" translate="yes" xml:space="preserve">
          <source>Testing Guidelines</source>
          <target state="translated">테스트 지침</target>
        </trans-unit>
        <trans-unit id="ef9606fae34bdb52d82ad257949ec42aea0b9b12" translate="yes" xml:space="preserve">
          <source>Testing Header Files</source>
          <target state="translated">헤더 파일 테스트</target>
        </trans-unit>
        <trans-unit id="d322a0e8fe52f19dbe7d5bd52156ee63071b90d8" translate="yes" xml:space="preserve">
          <source>Testing Organization</source>
          <target state="translated">테스트 조직</target>
        </trans-unit>
        <trans-unit id="e3148b0ff766bdb8347a198898838253aab4da96" translate="yes" xml:space="preserve">
          <source>Testing Python Scripts</source>
          <target state="translated">파이썬 스크립트 테스트</target>
        </trans-unit>
        <trans-unit id="8c3a61a48bb499744371cb7fc30761102d86f229" translate="yes" xml:space="preserve">
          <source>Testing SWIG Interface Files</source>
          <target state="translated">SWIG 인터페이스 파일 테스트</target>
        </trans-unit>
        <trans-unit id="34d08d85bddb11f11da76ad84dab43a94d74c7ed" translate="yes" xml:space="preserve">
          <source>Testing Source Files</source>
          <target state="translated">소스 파일 테스트</target>
        </trans-unit>
        <trans-unit id="ad0aa0ce3fefa4686bfefac5eb7c9ff2df0a50c6" translate="yes" xml:space="preserve">
          <source>Testing builds</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7704b172077f920ddd46d5adbcffe86730e58a19" translate="yes" xml:space="preserve">
          <source>Testing looks for module-level or class-level setup and teardown functions by name; thus:</source>
          <target state="translated">테스트는 이름별로 모듈 수준 또는 클래스 수준 설정 및 해제 기능을 찾습니다. 그러므로:</target>
        </trans-unit>
        <trans-unit id="45ece46e91d1fe305feeee99aed2fad182be7b30" translate="yes" xml:space="preserve">
          <source>Testing the numpy.i Typemaps</source>
          <target state="translated">numpy.i 타입 맵 테스트</target>
        </trans-unit>
        <trans-unit id="00774e7f83f997b0fda8acccd1c59071701a2ddf" translate="yes" xml:space="preserve">
          <source>Tests can also be run with &lt;code&gt;pytest numpy&lt;/code&gt;, however then the NumPy-specific plugin is not found which causes strange side effects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f86100126c53e2e34ca1a3d91679a3a06b6d132" translate="yes" xml:space="preserve">
          <source>Tests for a module should ideally cover all code in that module, i.e., statement coverage should be at 100%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="417d130b240483956f423e540d6cb689832b6f9e" translate="yes" xml:space="preserve">
          <source>Tests on random data</source>
          <target state="translated">무작위 데이터에 대한 테스트</target>
        </trans-unit>
        <trans-unit id="f3d72180c504c070f745ad049bd21c11042867d1" translate="yes" xml:space="preserve">
          <source>Tests on random data are good, but since test failures are meant to expose new bugs or regressions, a test that passes most of the time but fails occasionally with no code changes is not helpful. Make the random data deterministic by setting the random number seed before generating it. Use either Python&amp;rsquo;s &lt;code&gt;random.seed(some_number)&lt;/code&gt; or NumPy&amp;rsquo;s &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt;, depending on the source of random numbers.</source>
          <target state="translated">임의의 데이터에 대한 테스트는 좋지만 테스트 실패는 새로운 버그 나 회귀를 드러내 기위한 것이기 때문에 대부분의 시간은 지났지 만 코드 변경없이 때때로 실패하는 테스트는 도움이되지 않습니다. 난수 시드를 생성하기 전에 난수 시드를 설정하여 난수 데이터를 결정 론적으로 만드십시오. 난수의 소스에 따라 Python의 &lt;code&gt;random.seed(some_number)&lt;/code&gt; 또는 NumPy의 &lt;code&gt;numpy.random.seed(some_number)&lt;/code&gt; 를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="927f696caa5bf0529c4f0991bbe8b99afb2fa55b" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float has a value equal to zero. This may be slightly faster than calling npy_half_eq(h, NPY_ZERO).</source>
          <target state="translated">반 정밀도 부동 소수점 값이 0인지 여부를 테스트합니다. 이것은 npy_half_eq (h, NPY_ZERO)를 호출하는 것보다 약간 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3be553d33f0513a6775eaa86f3391147a1aac09" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is a NaN.</source>
          <target state="translated">반 정밀도 부동 소수점이 NaN인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="6424a62751d70065c8ad2d16d22d5e29e4d2e45c" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is finite (not NaN or Inf).</source>
          <target state="translated">반 정밀도 부동 소수점이 유한인지 (NaN 또는 Inf 아님) 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="b796fd95ec3aee28c84902e310b3fcc5e87bd087" translate="yes" xml:space="preserve">
          <source>Tests whether the half-precision float is plus or minus Inf.</source>
          <target state="translated">반 정밀도 부동 소수점이 플러스 또는 마이너스 Inf인지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="9cad929af9630184e2ec9f960cd674271afcf718" translate="yes" xml:space="preserve">
          <source>Tests, that send messages to stderr, fail when executed from MSYS prompt because the messages are lost at some point.</source>
          <target state="translated">메시지가 어느 시점에서 유실되므로 MSYS 프롬프트에서 실행될 때 stderr로 메시지를 보내는 테스트가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="d627254d7ccb3ce266ce9cf0341eff8096cd2a09" translate="yes" xml:space="preserve">
          <source>Texlive (or MikTeX on Windows)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a988a505d4f9bd1f41a57f4c2458a2423baedc7" translate="yes" xml:space="preserve">
          <source>Text files</source>
          <target state="translated">텍스트 파일</target>
        </trans-unit>
        <trans-unit id="4ba343aecd438b7c22876dbbd27f537f09be5607" translate="yes" xml:space="preserve">
          <source>Text formatting options</source>
          <target state="translated">텍스트 서식 옵션</target>
        </trans-unit>
        <trans-unit id="839b1da5d3ca352faa5ce69a674d5b04a8fa489d" translate="yes" xml:space="preserve">
          <source>Thanks to Yarik Halchenko for this explanation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5219411122630dca47bf818c11bfaef89c8f5266" translate="yes" xml:space="preserve">
          <source>That also takes extra arguments, like &lt;code&gt;--pdb&lt;/code&gt; which drops you into the Python debugger when a test fails or an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e8faeace432448f3522160a796443560f628f2" translate="yes" xml:space="preserve">
          <source>That can be one of 12 different scalar types: &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">: 그 12 개 가지 스칼라 유형 중 하나 일 수 있습니다 &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 와 &lt;code&gt;double&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be4b72468f984c83d93633e8f8bf75388e94a047" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation did up to rounding vagaries. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">그것은 원래 문서화 된 것보다 느슨한 테스트이지만 실제 구현이 반올림 vagaries까지 수행 한 것에 동의합니다. 모양 불일치 또는 충돌하는 값에서 예외가 발생합니다. Numpy의 표준 사용법과 달리 NaN은 숫자처럼 비교되며 두 객체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="31ca174a88927a9e0e7f8f15283f8ce9b3459f51" translate="yes" xml:space="preserve">
          <source>That is a looser test than originally documented, but agrees with what the actual implementation in &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt;&lt;code&gt;assert_array_almost_equal&lt;/code&gt;&lt;/a&gt; did up to rounding vagaries. An exception is raised at conflicting values. For ndarrays this delegates to assert_array_almost_equal</source>
          <target state="translated">그것은 원래 문서화 된 것보다 느슨한 테스트이지만 &lt;a href=&quot;numpy.testing.assert_array_almost_equal#numpy.testing.assert_array_almost_equal&quot;&gt; &lt;code&gt;assert_array_almost_equal&lt;/code&gt; &lt;/a&gt; 의 실제 구현 이 반올림 vagaries까지 수행 한 것과 일치합니다 . 충돌하는 값에서 예외가 발생합니다. ndarray의 경우 assert_array_almost_equal에 위임합니다.</target>
        </trans-unit>
        <trans-unit id="89910f6f21cfa928fbf09ccc006fad6eb4f77601" translate="yes" xml:space="preserve">
          <source>That is, each index specified selects the array corresponding to the rest of the dimensions selected. In the above example, choosing 0 means that the remaining dimension of length 5 is being left unspecified, and that what is returned is an array of that dimensionality and size. It must be noted that the returned array is not a copy of the original, but points to the same values in memory as does the original array. In this case, the 1-D array at the first position (0) is returned. So using a single index on the returned array, results in a single element being returned. That is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9424a0780491d95b42071bfcb7519b4471231e07" translate="yes" xml:space="preserve">
          <source>That solves the problem of returning views of the same type, but now we have a new problem. The machinery of ndarray can set the class this way, in its standard methods for taking views, but the ndarray &lt;code&gt;__new__&lt;/code&gt; method knows nothing of what we have done in our own &lt;code&gt;__new__&lt;/code&gt; method in order to set attributes, and so on. (Aside - why not call &lt;code&gt;obj = subdtype.__new__(...&lt;/code&gt; then? Because we may not have a &lt;code&gt;__new__&lt;/code&gt; method with the same call signature).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5240cf478eeccab2d778da09495ef32dd780cc8" translate="yes" xml:space="preserve">
          <source>That support 74 different argument signatures for each data type, including:</source>
          <target state="translated">다음을 포함하여 각 데이터 유형에 대해 74 개의 서로 다른 인수 서명을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="93ef0dd827103681fcee453b78be2ff14e1a261d" translate="yes" xml:space="preserve">
          <source>The</source>
          <target state="translated">The</target>
        </trans-unit>
        <trans-unit id="5c4c1c79691cc97764af36fe5679519dac98f423" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;busday&amp;rdquo; functions can additionally check a list of &amp;ldquo;holiday&amp;rdquo; dates, specific dates that are not valid days.</source>
          <target state="translated">&quot;busday&quot;기능은 유효하지 않은 특정 날짜 인 &quot;휴일&quot;날짜 목록을 추가로 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6c70d4694de1c6fa7fc40232e3591d1a1b102a5" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm is roughly equivalent to the following numpy code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a2e889671201d8619d4999f2673b8d825f07526" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;count&amp;rdquo; algorithm uses a temporary array of integers with length &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701df984a45b35c07efc7a2ab11dc3b2d9004e29" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;four quadrant&amp;rdquo; arctan of the angle formed by (&lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;) and the positive &lt;code&gt;x&lt;/code&gt;-axis.</source>
          <target state="translated">( &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; )와 양의 &lt;code&gt;x&lt;/code&gt; 축으로 형성된 각도의 &quot;사분면&quot;아크 탄.</target>
        </trans-unit>
        <trans-unit id="7af7d8f19766359bdf4ea2069305031d08b0663c" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;marginals&amp;rdquo; algorithm generates a variate by using repeated calls to the univariate hypergeometric sampler. It is roughly equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72e5831aa41d1e2f9af8c987044c60e05af0be5f" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;smart way&amp;rdquo; of wrapping Fortran functions, as explained above, is suitable for wrapping (e.g. third party) Fortran codes for which modifications to their source codes are not desirable nor even possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2adc5d4e116d43dd248737cacbfac03ed3ef63f9" translate="yes" xml:space="preserve">
          <source>The &amp;ldquo;y-intercept&amp;rdquo; and &amp;ldquo;slope&amp;rdquo; of the line, respectively.</source>
          <target state="translated">선의&amp;ldquo;y- 절편&amp;rdquo;및&amp;ldquo;기울기&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="e4a0235cef14b392c275cecc105837cde82d5723" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;a&amp;rsquo; variable is unstripped from c[1] because whitespace leading.</source>
          <target state="translated">공백이 선행되므로 'a'변수는 c [1]에서 잘리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bda37a7da4e6885245e567c4fedb24dc646e8a1c" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be &lt;code&gt;None&lt;/code&gt; for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="translated">'out'키워드 인수는 출력 당 하나의 항목이있는 튜플이어야합니다 ( ufunc에서 배열을 할당 할 경우 &lt;code&gt;None&lt;/code&gt; 일 수 있음 ). 단일 출력의 ufunc의 경우 단일 배열을 보유하는 튜플 대신 단일 배열을 전달하는 것도 유효합니다.</target>
        </trans-unit>
        <trans-unit id="db204a13b36f2cf86d7bd1794820137a1ac066ee" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;out&amp;rsquo; keyword argument is expected to be a tuple with one entry per output (which can be None for arrays to be allocated by the ufunc). For ufuncs with a single output, passing a single array (instead of a tuple holding a single array) is also valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34701f78458bf915d5b828bf9386058d6824fbe4" translate="yes" xml:space="preserve">
          <source>The &amp;lsquo;per&amp;rsquo; variable represents the periods of the loan. Remember that financial equations start the period count at 1!</source>
          <target state="translated">'per'변수는 대출 기간을 나타냅니다. 재무 방정식은 1에서 기간 카운트를 시작한다는 것을 기억하십시오!</target>
        </trans-unit>
        <trans-unit id="cb090179fdd970838b19c1b214a4530cfcd16ee3" translate="yes" xml:space="preserve">
          <source>The (non-conjugated) transpose of the matrix.</source>
          <target state="translated">매트릭스의 (공액이 아닌) 전치.</target>
        </trans-unit>
        <trans-unit id="2c0a3ac18c0e35ff547f3a4005419b0e018f9e8e" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime does not convert between units correctly.:</source>
          <target state="translated">datetime의 1.6 구현은 단위 간을 올바르게 변환하지 않습니다. :</target>
        </trans-unit>
        <trans-unit id="f72725eb7318a896f41cd0cf447d8c91f324fb0d" translate="yes" xml:space="preserve">
          <source>The 1.6 implementation of datetime only works correctly for a small subset of arithmetic operations. Here we show some simple cases.:</source>
          <target state="translated">날짜 / 시간의 1.6 구현은 작은 산술 연산 서브 세트에 대해서만 올바르게 작동합니다. 다음은 간단한 사례를 보여줍니다. :</target>
        </trans-unit>
        <trans-unit id="887cfe3b8a793575511e5fe48982dbd8c7813d6e" translate="yes" xml:space="preserve">
          <source>The 2-D output array.</source>
          <target state="translated">2 차원 출력 배열.</target>
        </trans-unit>
        <trans-unit id="8d40d72287619706da0622aa60cf9b527faa81be" translate="yes" xml:space="preserve">
          <source>The 24 built-in &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;array scalar type objects&lt;/a&gt; all convert to an associated data-type object. This is true for their sub-classes as well.</source>
          <target state="translated">24 개의 내장 &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;배열 스칼라 유형 오브젝트는&lt;/a&gt; 모두 연관된 데이터 유형 오브젝트로 변환됩니다. 하위 클래스에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="3182f1dfa2639174f8b34fe5f092a96393f1cf6d" translate="yes" xml:space="preserve">
          <source>The 64-bit OpenBLAS with &lt;code&gt;64_&lt;/code&gt; symbol suffix is obtained by compiling OpenBLAS with settings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44abfc0b778e06539587a775fdc8b33ee9085231" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; array flags can be &amp;ldquo;calculated&amp;rdquo; from the array object itself. This routine updates one or more of these flags of &lt;em&gt;arr&lt;/em&gt; as specified in &lt;em&gt;flagmask&lt;/em&gt; by performing the required calculation.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; 의&lt;/a&gt; 배열 플래그는 어레이 오브젝트 자체에서 &quot;계산&quot;할 수있다. 이 루틴 은 필요한 계산을 수행하여 플래그 &lt;em&gt;마스크&lt;/em&gt; 에 지정된대로 이러한 &lt;em&gt;arr&lt;/em&gt; 플래그 중 하나 이상을 업데이트 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5ab1d9e20a833c167142777c07717d8769b7541" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83e501c171dddeb86862ef16beddd704b5bc114a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the built-in type of the data-type-descriptor objects used to describe how the bytes comprising the array are to be interpreted. There are 21 statically-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects for the built-in data-types. While these participate in reference counting, their reference count should never reach zero. There is also a dynamic table of user-defined &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects that is also maintained. Once a data-type-descriptor object is &amp;ldquo;registered&amp;rdquo; it should never be deallocated either. The function &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to retrieve a &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; object from an enumerated type-number (either built-in or user- defined).</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; 는&lt;/a&gt; 내장 데이터 타입 디스크립터 타입의 배열을 포함하는 바이트가 해석되는 방법을 설명하기 위해 사용 된 객체이다. 내장 데이터 유형에 대해 21 개의 정적으로 정의 된 &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 오브젝트가 있습니다. 이들은 참조 카운트에 참여하지만 참조 카운트는 절대 0에 도달해서는 안됩니다. 또한 유지 관리되는 사용자 정의 &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 객체 의 동적 테이블 도 있습니다. 데이터 유형 설명자 객체가 &quot;등록&quot;되면 할당을 해제해서는 안됩니다. &lt;a href=&quot;c-api.array#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 함수 는 열거 된 유형 번호 (내장 또는 사용자 정의)에서 &lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 객체 를 검색하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3bd6fb4bf6c794847df919e4e53f9f40e8a12e37" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure is defined so that NumPy and other extension modules can use the rapid array interface protocol. The &lt;code&gt;__array_struct__&lt;/code&gt; method of an object that supports the rapid array interface protocol should return a &lt;code&gt;PyCObject&lt;/code&gt; that contains a pointer to a &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure with the relevant details of the array. After the new array is created, the attribute should be &lt;code&gt;DECREF&lt;/code&gt;&amp;rsquo;d which will free the &lt;a href=&quot;#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Remember to &lt;code&gt;INCREF&lt;/code&gt; the object (whose &lt;code&gt;__array_struct__&lt;/code&gt; attribute was retrieved) and point the base member of the new &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; to this same object. In this way the memory for the array will be managed correctly.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; 의&lt;/a&gt; NumPy와 다른 확장 모듈은 급격한 배열 인터페이스 프로토콜을 사용할 수 있도록 구조가 정의된다. 빠른 배열 인터페이스 프로토콜을 지원하는 개체 의 &lt;code&gt;__array_struct__&lt;/code&gt; 메서드는 배열 의 관련 세부 정보와 함께 &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; 구조에 대한 포인터가 포함 된 &lt;code&gt;PyCObject&lt;/code&gt; 를 반환해야합니다 . 새 배열을 만든 후에는 &lt;a href=&quot;#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; 구조를 해제하는 특성이 &lt;code&gt;DECREF&lt;/code&gt; 'd 여야합니다 . &lt;code&gt;__array_struct__&lt;/code&gt; 속성을 검색 한 객체 를 &lt;code&gt;INCREF&lt;/code&gt; 하고 새 &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 의 기본 멤버를 가리켜 야합니다.이 같은 개체에. 이러한 방식으로 어레이의 메모리가 올바르게 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="cd84e3bef1191839ce6ab3739e785dd2e1559188" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; C 구조 배열에 필요한 모든 정보를 포함한다. ndarray (및 해당 서브 클래스)의 모든 인스턴스는이 구조를 갖습니다. 향후 호환성을 위해 이러한 구조 멤버는 일반적으로 제공된 매크로를 사용하여 액세스해야합니다. 당신이 짧은 이름이 필요하면, 당신은 사용 할 수 &lt;code&gt;NPY_AO&lt;/code&gt; 을 동등로 정의 된 (사용되지 않음) &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ef190e5abe2d8e5d647d302d7a90a94792c8ed21" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; C-structure contains all of the required information for an array. All instances of an ndarray (and its subclasses) will have this structure. For future compatibility, these structure members should normally be accessed using the provided macros. If you need a shorter name, then you can make use of &lt;code&gt;NPY_AO&lt;/code&gt; (deprecated) which is defined to be equivalent to &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. Direct access to the struct fields are deprecated. Use the &lt;code&gt;PyArray_*(arr)&lt;/code&gt; form instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d2c044849f6b8be8bb6f06a8ac4ced885f369cf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure lies at the heart of the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt;. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyArrayDescr_*&lt;/code&gt; or &lt;code&gt;PyDataType*&lt;/code&gt; functions and macros. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; 의&lt;/a&gt; 의 핵심 구조 거짓말 &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; . 완전성을 위해 여기에 설명되어 있지만 NumPy 내부에있는 것으로 간주하고 &lt;code&gt;PyArrayDescr_*&lt;/code&gt; 또는 &lt;code&gt;PyDataType*&lt;/code&gt; 함수 및 매크로 를 통해 조작해야 합니다. 이 구조의 크기는 NumPy 버전에 따라 변경 될 수 있습니다. 호환성을 보장하려면</target>
        </trans-unit>
        <trans-unit id="2e3e60e01ee7ee0a4514d09bc8a1e601d0467625" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject implements many of the features of &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt;&lt;code&gt;Python objects&lt;/code&gt;&lt;/a&gt; including the &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt;&lt;code&gt;tp_as_number&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt;&lt;code&gt;tp_as_sequence&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt;&lt;code&gt;tp_as_mapping&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt;&lt;code&gt;tp_as_buffer&lt;/code&gt;&lt;/a&gt; interfaces. The &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt;&lt;code&gt;rich comparison&lt;/code&gt;&lt;/a&gt;) is also used along with new-style attribute lookup for member (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt;&lt;code&gt;tp_members&lt;/code&gt;&lt;/a&gt;) and properties (&lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt;&lt;code&gt;tp_getset&lt;/code&gt;&lt;/a&gt;). The &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; can also be sub-typed.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; 의&lt;/a&gt; 의 많은 기능 typeobject 구현 &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyTypeObject&quot;&gt; &lt;code&gt;Python objects&lt;/code&gt; &lt;/a&gt; 포함 &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_number&quot;&gt; &lt;code&gt;tp_as_number&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_sequence&quot;&gt; &lt;code&gt;tp_as_sequence&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_mapping&quot;&gt; &lt;code&gt;tp_as_mapping&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_as_buffer&quot;&gt; &lt;code&gt;tp_as_buffer&lt;/code&gt; &lt;/a&gt; 인터페이스를. &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.richcmpfunc&quot;&gt; &lt;code&gt;rich comparison&lt;/code&gt; &lt;/a&gt; ) 새로운 스타일 속성 부재 (위한 룩업 함께 사용 &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_members&quot;&gt; &lt;code&gt;tp_members&lt;/code&gt; &lt;/a&gt; )와 속성 ( &lt;a href=&quot;https://docs.python.org/dev/c-api/typeobj.html#c.PyTypeObject.tp_getset&quot;&gt; &lt;code&gt;tp_getset&lt;/code&gt; &lt;/a&gt; ). &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; 는&lt;/a&gt; 또한 하위 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa6c6f999e9bb42f4a925a834755e66032534d3b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; holds the current state of the BitGenerator and pointers to functions that return standard C types while advancing the state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2f36b5d156bf75520af226984583d62ec445b7c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module provides a set of vectorized string operations for arrays of type &lt;code&gt;numpy.string_&lt;/code&gt; or &lt;code&gt;numpy.unicode_&lt;/code&gt;. All of them are based on the string methods in the Python standard library.</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; 의&lt;/a&gt; 모듈 타입의 배열 벡터화 된 문자열 연산의 집합 제공 &lt;code&gt;numpy.string_&lt;/code&gt; 또는 &lt;code&gt;numpy.unicode_&lt;/code&gt; 을 . 그들 모두는 파이썬 표준 라이브러리의 문자열 메소드를 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="2314014335c763a38d9f2613dc7158883ea47e7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used as an addition to &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 된&lt;/a&gt; 모듈에 추가로 사용될 수 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="bc31921d14e06fe1077c1cf00e508c39081a2db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module comes with a specific implementation of most ufuncs. Unary and binary functions that have a validity domain (such as &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt;&lt;code&gt;divide&lt;/code&gt;&lt;/a&gt;) return the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant whenever the input is masked or falls outside the validity domain:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈은 대부분의 ufuncs의 특정 구현되어 있습니다. 유효 도메인 (예 : &lt;a href=&quot;generated/numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;generated/numpy.divide#numpy.divide&quot;&gt; &lt;code&gt;divide&lt;/code&gt; &lt;/a&gt; ) 이있는 단항 및 이진 함수 는 입력이 마스크되거나 유효 도메인 밖에있을 때마다 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 상수를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b2581729cb5a508c4225155bce5e9d0c211d34fc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 클래스 는 Numarray 와의 하위 호환성을 위해 존재하므로 새로운 개발에는 권장되지 않습니다. 문자열 중 하나 필요 배열, 그것은 사용 배열에 추천하면, NumPy와 1.4부터 시작 &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; 또는 &lt;code&gt;unicode_&lt;/code&gt; 하고있는 무료 기능을 사용 &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; 의&lt;/a&gt; 빠른 벡터화 문자열 연산을위한 모듈.</target>
        </trans-unit>
        <trans-unit id="bfd56b98bdff55bc0967f4255e8d608e0cada88c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.char.chararray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; 객체는 사전 형 (처럼 액세스 될 수 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ) 또는 (같이 소문자 속성 이름을 사용하여 &lt;code&gt;a.flags.writeable&lt;/code&gt; ). 짧은 플래그 이름은 사전 액세스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5b3e9186bfdffbf3c12bbb5a751b0411b0862a0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 클래스 는 Numarray 와의 하위 호환성을 위해 존재하므로 새로운 개발에는 권장되지 않습니다. 문자열 중 하나 필요 배열, 그것은 사용 배열에 추천하면, NumPy와 1.4부터 시작 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; 또는 &lt;code&gt;unicode_&lt;/code&gt; 하고있는 무료 기능을 사용 &lt;a href=&quot;../routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; 의&lt;/a&gt; 빠른 벡터화 문자열 연산을위한 모듈.</target>
        </trans-unit>
        <trans-unit id="680a1891b2c8f5bcdb98b3e8673e99320813b4a5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.chararray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c48c115471617c80e93a7432dc970b4f61e8b90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt;, as a regular &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype (the data).</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; , 일반 등 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 임의의 형상 또는 데이터 유형 (데이터)의.</target>
        </trans-unit>
        <trans-unit id="a0df6452154474f3f899180d65ac301d22c1fea9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; 객체는 사전 형 (처럼 액세스 될 수 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ) 또는 (같이 소문자 속성 이름을 사용하여 &lt;code&gt;a.flags.writeable&lt;/code&gt; ). 짧은 플래그 이름은 사전 액세스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="768878a0d288c4cac805d022d60e3e5c74cdd571" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; constant is a special case of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, with a float datatype and a null shape. It is used to test whether a specific entry of a masked array is masked, or to mask one or several entries of a masked array:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 상수의 특별한 경우이다 &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 부동 소수점 데이터 유형 및 null의 모양. 마스킹 된 어레이의 특정 항목이 마스킹되었는지 또는 마스킹 된 어레이의 하나 또는 여러 항목을 마스킹하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7aed7dc2945cfed4e354b7948f5becc4b487bdfa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ma.masked_array.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="146a5b50c3ebb2fb745630d24192949df345a171" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.matrix.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.matrix.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; 객체는 사전 형 (처럼 액세스 될 수 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ) 또는 (같이 소문자 속성 이름을 사용하여 &lt;code&gt;a.flags.writeable&lt;/code&gt; ). 짧은 플래그 이름은 사전 액세스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="3f13797b1afe52954d80b3598ced06b92d07000d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.memmap.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59336961ce31b9039ac38b42d5319606fa0f917b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; 객체는 사전 형 (처럼 액세스 될 수 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ) 또는 (같이 소문자 속성 이름을 사용하여 &lt;code&gt;a.flags.writeable&lt;/code&gt; ). 짧은 플래그 이름은 사전 액세스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="6d0bd00bbf169f78d9e7d2f8db44466c1472859d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="550894140eb6b413b0c8bb49cded0a5d50198b4c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; provides access to a wide range of distributions, and served as a replacement for &lt;code&gt;RandomState&lt;/code&gt;. The main difference between the two is that &lt;code&gt;Generator&lt;/code&gt; relies on an additional BitGenerator to manage state and generate the random bits, which are then transformed into random values from useful distributions. The default BitGenerator used by &lt;code&gt;Generator&lt;/code&gt; is &lt;code&gt;PCG64&lt;/code&gt;. The BitGenerator can be changed by passing an instantized BitGenerator to &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 분포의 넓은 범위에 대한 액세스를 제공하고, 대체 역임 &lt;code&gt;RandomState&lt;/code&gt; . 이 둘의 주요 차이점은 &lt;code&gt;Generator&lt;/code&gt; 가 추가 BitGenerator를 사용하여 상태를 관리하고 난수 비트를 생성 한 다음 유용한 분포에서 난수 값으로 변환한다는 점입니다. &lt;code&gt;Generator&lt;/code&gt; 가 사용하는 기본 BitGenerator 는 &lt;code&gt;PCG64&lt;/code&gt; 입니다. BitGenerator는 인스턴스화 된 BitGenerator를 &lt;code&gt;Generator&lt;/code&gt; 로 전달하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f79d27f6e9c849366cec196aa3ca02a3888f3ef3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4a823e24105a263472e6db5aa11ef1abc5d69b0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; provides access to legacy generators. This generator is considered frozen and will have no further improvements. It is guaranteed to produce the same values as the final point release of NumPy v1.16. These all depend on Box-Muller normals or inverse CDF exponentials or gammas. This class should only be used if it is essential to have randoms that are identical to what would have been produced by previous versions of NumPy.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 는&lt;/a&gt; 기존 발전기에 대한 액세스를 제공합니다. 이 발전기는 정지 된 것으로 간주되며 더 이상 개선되지 않습니다. NumPy v1.16의 최종 릴리스와 동일한 값을 생성하는 것이 보장됩니다. 이들은 모두 Box-Muller 법선 또는 역 CDF 지수 또는 감마에 의존합니다. 이 클래스는 이전 버전의 NumPy에서 생성 된 것과 동일한 난수를 가져야하는 경우에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="81979ac862ad90b476e52b55f8477208f98b95b1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.recarray.flags&quot;&gt;&lt;code&gt;flags&lt;/code&gt;&lt;/a&gt; object can be accessed dictionary-like (as in &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt;), or by using lowercased attribute names (as in &lt;code&gt;a.flags.writeable&lt;/code&gt;). Short flag names are only supported in dictionary access.</source>
          <target state="translated">&lt;a href=&quot;#numpy.recarray.flags&quot;&gt; &lt;code&gt;flags&lt;/code&gt; &lt;/a&gt; 객체는 사전 형 (처럼 액세스 될 수 &lt;code&gt;a.flags['WRITEABLE']&lt;/code&gt; ) 또는 (같이 소문자 속성 이름을 사용하여 &lt;code&gt;a.flags.writeable&lt;/code&gt; ). 짧은 플래그 이름은 사전 액세스에서만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="84da36ced33272fa147152f5a355ea7313e10b52" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt;. nan is returned for nan inputs.</source>
          <target state="translated">&lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; 함수 리턴 &lt;code&gt;-1 if x &amp;lt; 0, 0 if x==0, 1 if x &amp;gt; 0&lt;/code&gt; . nan은 nan 입력에 대해 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="158d36e54da803a47a7693e104765168fbd40d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.dec.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f5bdf7e480a14edfbd94978da2fd35d2b6fd26" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt;&lt;code&gt;deprecated&lt;/code&gt;&lt;/a&gt; decorator itself.</source>
          <target state="translated">&lt;a href=&quot;#numpy.testing.decorators.deprecated&quot;&gt; &lt;code&gt;deprecated&lt;/code&gt; &lt;/a&gt; 장식 자체.</target>
        </trans-unit>
        <trans-unit id="f00c158e6b19c749648df9ba6c6e65d03c7d496b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; function is provided primarily for convenience, not for performance. The implementation is essentially a for loop.</source>
          <target state="translated">&lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt; 기능은없는 성능을 위해 주로 편의를 위해 제공됩니다. 구현은 본질적으로 for 루프입니다.</target>
        </trans-unit>
        <trans-unit id="5870961c86339efdff46c3532a51705af2f592f0" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt; on which this dtype is based.</source>
          <target state="translated">&lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;날짜 유닛&lt;/a&gt; 이 DTYPE 기반이되는.</target>
        </trans-unit>
        <trans-unit id="3bf8c2953924a9568aac6e665e279dc1312c55ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterAllButAxis&quot;&gt;&lt;code&gt;PyArray_IterAllButAxis&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt;, &lt;code&gt;&amp;amp;dim&lt;/code&gt; ) constructs an iterator object that is modified so that it will not iterate over the dimension indicated by dim. The only restriction on this iterator object, is that the &lt;code&gt;PyArray_Iter_GOTO1D&lt;/code&gt; ( &lt;code&gt;it&lt;/code&gt;, &lt;code&gt;ind&lt;/code&gt; ) macro cannot be used (thus flat indexing won&amp;rsquo;t work either if you pass this object back to Python &amp;mdash; so you shouldn&amp;rsquo;t do this). Note that the returned object from this routine is still usually cast to PyArrayIterObject *. All that&amp;rsquo;s been done is to modify the strides and dimensions of the returned iterator to simulate iterating over array[&amp;hellip;,0,&amp;hellip;] where 0 is placed on the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26c941be06c3bf21e3b8632eab293bedde5eb0c6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function can be used to combine different vectors so as to obtain the result for each n-uplet. For example, if you want to compute all the a+b*c for all the triplets taken from each of the vectors a, b and c:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7647b692ad78d569f80f8f518b4edab8e65fa5cd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; function returns its argument with a modified shape, whereas the &lt;a href=&quot;../reference/generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; method modifies the array itself:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28dfdb3c00777ce3fdb3f61c50c67ab257910e81" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; module includes a &lt;code&gt;norm&lt;/code&gt; function, which computes the norm of a vector or matrix represented in a NumPy array. For example, from the SVD explanation above, we would expect the norm of the difference between &lt;code&gt;img_gray&lt;/code&gt; and the reconstructed SVD product to be small. As expected, you should see something like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a98bd2e9d383259ba90aad2f3b46a4c0ddbbec99" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt;&lt;code&gt;numpy.testing&lt;/code&gt;&lt;/a&gt; module includes &lt;code&gt;import decorators as dec&lt;/code&gt;. A test can be decorated as slow like this:</source>
          <target state="translated">&lt;a href=&quot;../routines.testing#module-numpy.testing&quot;&gt; &lt;code&gt;numpy.testing&lt;/code&gt; 의&lt;/a&gt; 모듈을 포함 &lt;code&gt;import decorators as dec&lt;/code&gt; . 테스트는 다음과 같이 느리게 장식 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="081ce1a530a1e04a18f2e8f054e26ae81b0c4d57" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4d94d478ef39d11efc586cafc38818b04af19cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="translated">&lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; 의&lt;/a&gt; 기능이 이미 정의되어있는 반복기를 받아 각 차원에서 방송 형태를 결정하도록 사용 (방송 후 사용할 발생하는 동시에 반복자 만드는 &lt;code&gt;PyMultiIter_New&lt;/code&gt; 의 기능). 그런 다음 각 반복자가 브로드 캐스트 크기의 배열을 반복한다고 생각하도록 반복자가 조정됩니다. 이것은 이터레이터의 차원 수와 각 차원의 모양을 조정하여 수행됩니다. 반복자 보폭도 조정되기 때문에 작동합니다. 브로드 캐스트는 길이 -1 치수 만 조정 (또는 추가)합니다. 이러한 차원의 경우 strides 변수는 단순히 0으로 설정되므로 브로드 캐스트 작업이 확장 차원에서 작동 할 때 해당 배열의 반복자에 대한 데이터 포인터가 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="725a4957fd19b096134c24b6194f54dd74c72c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; function takes the iterators that have already been defined and uses them to determine the broadcast shape in each dimension (to create the iterators at the same time that broadcasting occurs then use the &lt;code&gt;PyMultiIter_New&lt;/code&gt; function). Then, the iterators are adjusted so that each iterator thinks it is iterating over an array with the broadcast size. This is done by adjusting the iterators number of dimensions, and the shape in each dimension. This works because the iterator strides are also adjusted. Broadcasting only adjusts (or adds) length-1 dimensions. For these dimensions, the strides variable is simply set to 0 so that the data-pointer for the iterator over that array doesn&amp;rsquo;t move as the broadcasting operation operates over the extended dimension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d36f842f2997c8193b726b30df3debd673ecb729" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object can be used in all slicing operations to create an axis of length one. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; is an alias for &amp;lsquo;None&amp;rsquo;, and &amp;lsquo;None&amp;rsquo; can be used in place of this with the same result.</source>
          <target state="translated">&lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; 의&lt;/a&gt; 목적은 길이가 하나의 축을 만드는 모든 슬라이싱 연산에 사용될 수있다. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 는 'None'의 별칭이며, 대신 'None'을 동일한 결과로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="149f4058a1754093961b02f9ea6b9d5dd9c10925" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; class exists for backwards compatibility with Numarray, it is not recommended for new development. Starting from numpy 1.4, if one needs arrays of strings, it is recommended to use arrays of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;&lt;code&gt;object_&lt;/code&gt;, &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, and use the free functions in the &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt;&lt;code&gt;numpy.char&lt;/code&gt;&lt;/a&gt; module for fast vectorized string operations.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 클래스 는 Numarray 와의 하위 호환성을 위해 존재하므로 새로운 개발에는 권장되지 않습니다. 문자열 중 하나 필요 배열, 그것은 사용 배열에 추천하면, NumPy와 1.4부터 시작 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; &lt;code&gt;object_&lt;/code&gt; , &lt;code&gt;string_&lt;/code&gt; 또는 &lt;code&gt;unicode_&lt;/code&gt; 하고있는 무료 기능을 사용 &lt;a href=&quot;routines.char#module-numpy.char&quot;&gt; &lt;code&gt;numpy.char&lt;/code&gt; 의&lt;/a&gt; 빠른 벡터화 문자열 연산을위한 모듈.</target>
        </trans-unit>
        <trans-unit id="f9537bf435fae2ec4edc2520b8aeb23abd0ca21e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be inherited from (in Python or in C) if desired. Therefore, it can form a foundation for many useful classes. Often whether to sub-class the array object or to simply use the core array component as an internal part of a new class is a difficult decision, and can be simply a matter of choice. NumPy has several tools for simplifying how your new object interacts with other array objects, and so the choice may not be significant in the end. One way to simplify the question is by asking yourself if the object you are interested in can be replaced as a single array or does it really require two or more arrays at its core.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 원한다면 (파이썬 또는 C)로부터 상속 할 수있다. 따라서 많은 유용한 클래스의 기초를 형성 할 수 있습니다. 배열 객체의 서브 클래스 화 여부 또는 핵심 배열 구성 요소를 단순히 새로운 클래스의 내부 부분으로 사용할지 여부는 어려운 결정이며 단순히 선택의 문제 일 수 있습니다. NumPy에는 새 객체가 다른 배열 객체와 상호 작용하는 방식을 단순화하는 여러 도구가 있으므로 결국 선택의 여지가 없을 수 있습니다. 질문을 단순화하는 한 가지 방법은 관심있는 객체를 단일 배열로 교체 할 수 있는지 또는 실제로 코어에 둘 이상의 배열이 필요한지 스스로에게 묻는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c0cd171dc2a149543f352698d4bc596e7f8afac8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; will try to provide chunks that are as large as possible to the inner loop. By forcing &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; order, we get different external loop sizes. This mode is enabled by specifying an iterator flag.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 내부 루프에 가능한 한 큰 덩어리를 제공하도록 시도 할 것이다. 'C'와 'F'순서를 강제함으로써, 우리는 다른 외부 루프 크기를 얻습니다. 이 모드는 반복자 플래그를 지정하여 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="60bea32ad7ce3442c75308b468830ac8ceb23fe9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0287b2a9be936e86bf33e5d1e69557ad4042b14" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; is the user-facing object that is nearly identical to &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. The canonical method to initialize a generator passes a &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator as the sole argument.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 거의 동일 사용자 지향 목적 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; . 생성기를 초기화하는 표준 방법 은 유일한 인수로 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 비트 생성기를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="a44536d85a990a438123d796af5725162190334f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;random generator&lt;/code&gt;&lt;/a&gt; takes the bit generator-provided stream and transforms them into more useful distributions, e.g., simulated normal random values. This structure allows alternative bit generators to be used with little code duplication.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;random generator&lt;/code&gt; &lt;/a&gt; 비트 스트림 생성기 제공 걸리며 예 유용한 분포, 시뮬레이션 정규 확률 값로 변환한다. 이 구조를 통해 대체 비트 생성기를 거의 코드 중복없이 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="65fbb3e3590895ec54d650742d5a8544c871fca6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt; is an easy read explaining the concepts behind git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f755efceb36d8200d20dc31c04e76cd3c9faf2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; type checking and conversion system is a complicated combination of C macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; fragments. Fragments are a way to conditionally insert code into your wrapper file if it is needed, and not insert it if not needed. If multiple typemaps require the same fragment, the fragment only gets inserted into your wrapper code once.</source>
          <target state="translated">&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG의&lt;/a&gt; 유형 검사 및 변환 시스템은 C 매크로의 복잡한 조합 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG의&lt;/a&gt; 매크로 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG의&lt;/a&gt; 적인 typemap 및 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 단편. 조각은 필요한 경우 래퍼 파일에 조건부로 코드를 삽입하고 필요하지 않은 경우에는 삽입하지 않는 방법입니다. 여러 유형 맵에 동일한 조각이 필요한 경우 조각이 래퍼 코드에 한 번만 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="03230fc37f6936da8ac6bdd751efc6bea8b56636" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://book.git-scm.com/&quot;&gt;git community book&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81e8045e59daf616aee34810d48dbb7db178f9f3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3ce3d1a866c8fe3ec8d4e7bfc02ebc4b98d4d1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://git-scm.com/book/&quot;&gt;pro git book&lt;/a&gt; is a good in-depth book on git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5b683753cdf3b551962126ba95310173bb4c1cb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/gittutorial.html&quot;&gt;git tutorial&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bccf408a44196396f7493f86e249b28e7b329b3e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/user-manual.html&quot;&gt;git user manual&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a20426fc7bb4d929b1ae303283b379020fbc254" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt;&lt;code&gt;Polynomial.fit&lt;/code&gt;&lt;/a&gt; class method is recommended for new code as it is more stable numerically. See the documentation of the method for more information.</source>
          <target state="translated">&lt;a href=&quot;numpy.polynomial.polynomial.polynomial.fit#numpy.polynomial.polynomial.Polynomial.fit&quot;&gt; &lt;code&gt;Polynomial.fit&lt;/code&gt; 의&lt;/a&gt; 더 안정적인 수치이기 때문에 클래스 메소드는 새로운 코드를 권장합니다. 자세한 내용은 방법 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3210c2d9abaca33a8760be87735591310e75c5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; operators always return &lt;code&gt;False&lt;/code&gt; when comparing void structured arrays, and arithmetic and bitwise operations are not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7efea03dca2b9d161f9ef2bba68b5604f07ac3fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;argument/variable attribute statement&amp;gt;&lt;/code&gt; is &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; without &lt;code&gt;&amp;lt;typespec&amp;gt;&lt;/code&gt;. In addition, in an attribute statement one cannot use other attributes, also &lt;code&gt;&amp;lt;entitydecl&amp;gt;&lt;/code&gt; can be only a list of names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa4578e6de9d14302f059bb642ff99cac46413e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;other statement&amp;gt;&lt;/code&gt; part refers to any other Fortran language constructs that are not described above. F2PY ignores most of them except</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03addd0e1d3adac1696638d2556f4f3e8a49b2fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-s&lt;/code&gt; flag makes a PGP (usually GPG) signed tag. Please do sign the release tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1f02257b982558ed0038cd836405c4aaec01705" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-v&lt;/code&gt; flag gives verbose feedback, &lt;code&gt;-s&lt;/code&gt; causes the script to sign the wheels with your GPG key before upload. Don&amp;rsquo;t forget to upload the wheels before the source tarball, so there is no period for which people switch from an expected binary install to a source install from PyPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea1937064d555fd6f04fc2b57ae9e905ce9bf17" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format is the standard binary file format in NumPy for persisting a &lt;em&gt;single&lt;/em&gt; arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly even on another machine with a different architecture. The format is designed to be as simple as possible while achieving its limited goals.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; 포맷은 지속위한 NumPy와의 표준 이진 파일 형식 &lt;em&gt;단일&lt;/em&gt; 디스크상의 임의 NumPy와 배열. 형식은 다른 아키텍처를 가진 다른 시스템에서도 배열을 올바르게 재구성하는 데 필요한 모든 모양 및 dtype 정보를 저장합니다. 형식은 제한된 목표를 달성하면서 가능한 한 단순하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="d25fde9120bc920bdf839700f32d6b700adf8720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npy&lt;/code&gt; format, including motivation for creating it and a comparison of alternatives, is described in the &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&amp;ldquo;npy-format&amp;rdquo; NEP&lt;/a&gt;, however details have evolved with time and this document is more current.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; 를 만들기위한 동기를 부여하고 대안의 비교를 포함하여 형식,의에 설명되어 있습니다 &lt;a href=&quot;https://www.numpy.org/neps/nep-0001-npy-format.html&quot;&gt;&quot;NPY-형식&quot;NEP&lt;/a&gt; , 그러나 세부 사항은 시간과 함께 진화이 문서는 더 많은 전류입니다했다.</target>
        </trans-unit>
        <trans-unit id="22e53f126c53ee44cfae93fe323456796e3a7525" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is compressed with &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; 의 파일 형식에 포함 된 변수의 이름을 따서 명명 된 파일의 압축 된 아카이브입니다. 아카이브는 &lt;code&gt;zipfile.ZIP_DEFLATED&lt;/code&gt; 로 압축되며 아카이브의 각 파일에는 &lt;code&gt;.npy&lt;/code&gt; 형식의 변수가 하나 있습니다 . 의 설명은 &lt;code&gt;.npy&lt;/code&gt; 형식을 참조 &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b51e4d01309ff5a759f392af08bb39d1e99043e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; file format is a zipped archive of files named after the variables they contain. The archive is not compressed and each file in the archive contains one variable in &lt;code&gt;.npy&lt;/code&gt; format. For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; 의 파일 형식에 포함 된 변수의 이름을 따서 명명 된 파일의 압축 된 아카이브입니다. 아카이브는 압축되지 않으며 아카이브의 각 파일에는 &lt;code&gt;.npy&lt;/code&gt; 형식의 변수가 하나 있습니다 . 의 설명은 &lt;code&gt;.npy&lt;/code&gt; 형식을 참조 &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5c00dd2aa73f26e18024a200e3875179deacef9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;.npz&lt;/code&gt; format is the standard format for persisting &lt;em&gt;multiple&lt;/em&gt; NumPy arrays on disk. A &lt;code&gt;.npz&lt;/code&gt; file is a zip file containing multiple &lt;code&gt;.npy&lt;/code&gt; files, one for each array.</source>
          <target state="translated">&lt;code&gt;.npz&lt;/code&gt; 형식은 지속을위한 표준 형식입니다 &lt;em&gt;여러&lt;/em&gt; 디스크에 NumPy와 배열을. &lt;code&gt;.npz&lt;/code&gt; 의 파일은 다수 포함하는 압축 파일 &lt;code&gt;.npy&lt;/code&gt; 파일 각 어레이 하나.</target>
        </trans-unit>
        <trans-unit id="19658579206ac4f8753c064c0302ad76f2f72a46" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ALIGNED&lt;/code&gt; flag of an ndarray, computed in &lt;code&gt;IsAligned&lt;/code&gt; and checked by &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt;. This is computed from &lt;code&gt;dtype.alignment&lt;/code&gt;. It is set to &lt;code&gt;True&lt;/code&gt; if every item in the array is at a memory location consistent with &lt;code&gt;dtype.alignment&lt;/code&gt;, which is the case if the data ptr and all strides of the array are multiples of that alignment.</source>
          <target state="translated">IsAligned에서 계산되고 &lt;code&gt;IsAligned&lt;/code&gt; 에 의해 검사되는 &lt;code&gt;PyArray_ISALIGNED&lt;/code&gt; 의 &lt;code&gt;ALIGNED&lt;/code&gt; 플래그입니다 . 이것은 &lt;code&gt;dtype.alignment&lt;/code&gt; 에서 계산됩니다 . 배열의 모든 항목이 &lt;code&gt;dtype.alignment&lt;/code&gt; 와 일치하는 메모리 위치에 있으면 &lt;code&gt;True&lt;/code&gt; 로 설정됩니다 . 이는 데이터 ptr 및 배열의 ​​모든 보폭이 해당 정렬의 배수 인 경우입니다.</target>
        </trans-unit>
        <trans-unit id="85388f353d8827d53025cb4498ec7c4f7175db9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BitGenerator&lt;/code&gt; has a limited set of responsibilities. It manages state and provides functions to produce random doubles and random unsigned 32- and 64-bit values.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; 은 책임의 제한 집합이 있습니다. 상태를 관리하고 임의의 double 및 임의의 부호없는 32 비트 및 64 비트 값을 생성하는 기능을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="29642d4a46e1b1f330f5d899a27d8931b3675855" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Configuration&lt;/code&gt; constructor has a fourth optional argument, &lt;code&gt;package_path&lt;/code&gt;, that can be used when package files are located in a different location than the directory of the &lt;code&gt;setup.py&lt;/code&gt; file.</source>
          <target state="translated">&lt;code&gt;Configuration&lt;/code&gt; 생성자는 네 번째의 선택적 인수가 &lt;code&gt;package_path&lt;/code&gt; 패키지 파일의 디렉토리가 아닌 다른 위치에있는 경우에 사용할 수 있습니다, &lt;code&gt;setup.py&lt;/code&gt; 의 파일을.</target>
        </trans-unit>
        <trans-unit id="831e4b75031bb8f9a8d29e89a9890ddda53ce469" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LibraryInfo&lt;/code&gt; instance containing the build information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d942d62411c592ee85272583cee21a0d612eb9cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MT19937&lt;/code&gt; state vector consists of a 624-element array of 32-bit unsigned integers plus a single integer value between 0 and 624 that indexes the current position within the main array.</source>
          <target state="translated">&lt;code&gt;MT19937&lt;/code&gt; 상태 벡터가 32 비트 부호없는 정수의 624 소자 어레이 플러스 하나의 정수 값으로 구성 0 내지 624 인덱싱 메인 어레이 내의 현재 위치.</target>
        </trans-unit>
        <trans-unit id="a95fd45cabac9b94aa97772f024779835dc306b4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Makefile&lt;/code&gt; calls &lt;code&gt;swig&lt;/code&gt; to generate &lt;code&gt;Vector.py&lt;/code&gt; and &lt;code&gt;Vector_wrap.cxx&lt;/code&gt;, and also executes the &lt;code&gt;setup.py&lt;/code&gt; script that compiles &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; and links together the extension module &lt;code&gt;_Vector.so&lt;/code&gt; or &lt;code&gt;_Vector.dylib&lt;/code&gt;, depending on the platform. This extension module and the proxy file &lt;code&gt;Vector.py&lt;/code&gt; are both placed in a subdirectory under the &lt;code&gt;build&lt;/code&gt; directory.</source>
          <target state="translated">&lt;code&gt;Makefile&lt;/code&gt; 호출은 &lt;code&gt;swig&lt;/code&gt; 생성하는 &lt;code&gt;Vector.py&lt;/code&gt; 및 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 을 , 또한 실행 &lt;code&gt;setup.py&lt;/code&gt; 컴파일 스크립트 &lt;code&gt;Vector_wrap.cxx&lt;/code&gt; 함께 확장 모듈과 링크를 &lt;code&gt;_Vector.so&lt;/code&gt; 또는 &lt;code&gt;_Vector.dylib&lt;/code&gt; 를 플랫폼에 따라. 이 확장 모듈과 프록시 파일 &lt;code&gt;Vector.py&lt;/code&gt; 는 모두 &lt;code&gt;build&lt;/code&gt; 디렉토리 아래의 서브 디렉토리에 있습니다.</target>
        </trans-unit>
        <trans-unit id="a509290375510505b589158f3b8f2b07b506f6b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MaskedArray&lt;/code&gt; class</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; 의 클래스</target>
        </trans-unit>
        <trans-unit id="b55e755e6d26d2135c464a8b79f8ff9c154dcada" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants are defined so that sizeof information is available to the pre-processor.</source>
          <target state="translated">&lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 상수를 sizeof 정보 전처리 사용할 수 있도록 정의된다.</target>
        </trans-unit>
        <trans-unit id="d0911aba3c1681f9c5a1ccf39d3f2fd5866ac6b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NpzFile&lt;/code&gt; returned by &lt;code&gt;np.savez&lt;/code&gt; is now a &lt;code&gt;collections.abc.Mapping&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d918fc830e6f124f45ecb19bab96030d1a7583a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PCG64&lt;/code&gt; state vector consists of 2 unsigned 128-bit values, which are represented externally as Python ints. One is the state of the PRNG, which is advanced by a linear congruential generator (LCG). The second is a fixed odd increment used in the LCG.</source>
          <target state="translated">&lt;code&gt;PCG64&lt;/code&gt; 의 상태 벡터 파이썬의 int로 표현되는 2 외부 부호 128 비트 값들로 구성된다. 하나는 선형 합동 발생기 (LCG)에 의해 진행되는 PRNG의 상태이다. 두 번째는 LCG에서 사용되는 고정 홀수 증분입니다.</target>
        </trans-unit>
        <trans-unit id="c1a90ac63bb863a062bb153b73df1e64c4857aff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Philox&lt;/code&gt; state vector consists of a 256-bit value encoded as a 4-element uint64 array and a 128-bit value encoded as a 2-element uint64 array. The former is a counter which is incremented by 1 for every 4 64-bit randoms produced. The second is a key which determined the sequence produced. Using different keys produces independent sequences.</source>
          <target state="translated">&lt;code&gt;Philox&lt;/code&gt; 의 상태 벡터는 4 소자 UINT64 배열로 인코딩 된 256 비트 값으로 구성하고, 128 비트 값은 2 소자 UINT64 배열로 인코딩. 전자는 생성 된 4 개의 64 비트 난수마다 1 씩 증가하는 카운터입니다. 두 번째는 생산 순서를 결정하는 열쇠입니다. 다른 키를 사용하면 독립적 인 시퀀스가 ​​생성됩니다.</target>
        </trans-unit>
        <trans-unit id="4d1f94165781d8145f1fd80c467f6bd0f760f0b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SFC64&lt;/code&gt; state vector consists of 4 unsigned 64-bit values. The last is a 64-bit counter that increments by 1 each iteration.</source>
          <target state="translated">&lt;code&gt;SFC64&lt;/code&gt; 의 상태 벡터 부호 4는 64 비트 값으로 구성. 마지막은 각 반복마다 1 씩 증가하는 64 비트 카운터입니다.</target>
        </trans-unit>
        <trans-unit id="a79e711795f6e28c85d83994efa93c2930d50249" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__array_ufunc__&lt;/code&gt; receives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7be3375866469167b9378a498844a5222b829ab9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__complex__&lt;/code&gt; method has been implemented for the ndarrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="395b8858a352467f67b6a09c4a5fc424e26cfad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__init__.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;__init__.py&lt;/code&gt; 파일</target>
        </trans-unit>
        <trans-unit id="55e0b71eae2cfd6e566258a88d10c513a1a5a113" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;align&lt;/code&gt; keyword of the dtype constructor, which only affects structured arrays. If the structure&amp;rsquo;s field offsets are not manually provided numpy determines offsets automatically. In that case, &lt;code&gt;align=True&lt;/code&gt; pads the structure so that each field is &amp;ldquo;true&amp;rdquo; aligned in memory and sets &lt;code&gt;dtype.alignment&lt;/code&gt; to be the largest of the field &amp;ldquo;true&amp;rdquo; alignments. This is like what C-structs usually do. Otherwise if offsets or itemsize were manually provided &lt;code&gt;align=True&lt;/code&gt; simply checks that all the fields are &amp;ldquo;true&amp;rdquo; aligned and that the total itemsize is a multiple of the largest field alignment. In either case &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; is also set to True.</source>
          <target state="translated">구조화 된 배열에만 영향을주는 dtype 생성자 의 &lt;code&gt;align&lt;/code&gt; 키워드입니다. 구조의 필드 오프셋이 수동으로 제공되지 않으면 numpy가 오프셋을 자동으로 결정합니다. 이 경우, &lt;code&gt;align=True&lt;/code&gt; 는 각 필드가 메모리에서 &quot;true&quot;로 정렬되도록 구조를 &lt;code&gt;dtype.alignment&lt;/code&gt; 를 &quot;true&quot;로 가장 큰 필드로 설정합니다. 이것은 C-struct가 일반적으로하는 것과 같습니다. 그렇지 않으면 오프셋 또는 항목 크기가 수동으로 제공된 경우 &lt;code&gt;align=True&lt;/code&gt; 는 모든 필드가 &quot;참&quot;으로 정렬되고 전체 항목 크기가 가장 큰 필드 정렬의 배수인지 확인합니다. 두 경우 모두 &lt;code&gt;dtype.isalignedstruct&lt;/code&gt; 도 True로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ed305f750328762db1dc6ead8c6be67eaf77ffcb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; constructor &lt;strong&gt;takes (nested) Python sequences as initializers&lt;/strong&gt;. As in, &lt;code&gt;array([[1,2,3],[4,5,6]])&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7af29f13d56d1534071fc5be1d8e6902e6aa373" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;array&lt;/code&gt; is thus much more advisable to use. Indeed, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd27c9fa716237737a1b850fd84a88e9e84db97b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as&lt;/code&gt;-clause of the &lt;code&gt;with&lt;/code&gt;-statement gives the current print options:</source>
          <target state="translated">&lt;code&gt;as&lt;/code&gt; 의 -clause &lt;code&gt;with&lt;/code&gt; -statement 현재 인쇄 옵션을 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="2c28e104a97f1a1f15fc38cbcd9f731be438b4c3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autostrip&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad906fe89b0c268cf5fd9b3376621745175a9a41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; argument to &lt;code&gt;numpy.ma.mask_cols&lt;/code&gt; and &lt;code&gt;numpy.ma.mask_row&lt;/code&gt; is deprecated</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caa858c948295450c18bcef4c572e68d7eda67a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; keyword can be used to specify a subset of axes of which the gradient is calculated</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 키워드는 그라데이션을 산출 한 축의 일부를 지정하는 데 사용될 수있다</target>
        </trans-unit>
        <trans-unit id="c68a2d64e2aeed4fdf4077c45259bb4b7c07822e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;axis&lt;/code&gt; parameter specifies the index of the new axis in the dimensions of the result. For example, if &lt;code&gt;axis=0&lt;/code&gt; it will be the first dimension and if &lt;code&gt;axis=-1&lt;/code&gt; it will be the last dimension.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 매개 변수는 결과의 크기의 새로운 축 인덱스를 지정한다. 예를 들어 &lt;code&gt;axis=0&lt;/code&gt; 인 경우 첫 번째 차원이되고 &lt;code&gt;axis=-1&lt;/code&gt; 인 경우 마지막 차원이됩니다.</target>
        </trans-unit>
        <trans-unit id="285d55a28a1a269db45a5f84582658fc7e3a43b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;base&lt;/code&gt; attribute is useful in being able to tell whether we have a view or the original array. This in turn can be useful if we need to know whether or not to do some specific cleanup when the subclassed array is deleted. For example, we may only want to do the cleanup if the original array is deleted, but not the views. For an example of how this can work, have a look at the &lt;code&gt;memmap&lt;/code&gt; class in &lt;code&gt;numpy.core&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d4cb66724d02c13ff5f50a065c67d6d75a20a6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; data type is very similar to the Python &lt;code&gt;BooleanType&lt;/code&gt; but does not inherit from it because Python&amp;rsquo;s &lt;code&gt;BooleanType&lt;/code&gt; does not allow itself to be inherited from, and on the C-level the size of the actual bool data is not the same as a Python Boolean scalar.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; 의 데이터 유형은 파이썬과 매우 유사 &lt;code&gt;BooleanType&lt;/code&gt; 하지만 파이썬 때문에 상속하지 않습니다 &lt;code&gt;BooleanType&lt;/code&gt; 는 자체에서 상속을 허용하지 않으며, C 수준에 실제 부울 데이터의 크기는 파이썬 부울 동일하지 않습니다 스칼라.</target>
        </trans-unit>
        <trans-unit id="1a9ec4df6ec3fb7357baf90864b29d969f59440a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bool_&lt;/code&gt; type is not a subclass of the &lt;code&gt;int_&lt;/code&gt; type (the &lt;code&gt;bool_&lt;/code&gt; is not even a number type). This is different than Python&amp;rsquo;s default implementation of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/a&gt; as a sub-class of int.</source>
          <target state="translated">&lt;code&gt;bool_&lt;/code&gt; 의 타입의 서브 클래스가 아닌 &lt;code&gt;int_&lt;/code&gt; 입력합니다 ( &lt;code&gt;bool_&lt;/code&gt; 는 심지어 다수의 타입이다). 이것은 int의 하위 클래스로 파이썬의 기본 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; 구현과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="3f5c3b6d52d4becfb53cc5a7dd0ae6b04cdb9085" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix or suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 인수는 문자 집합을 지정하는 문자열을 제거 할 것입니다. 생략되거나 없음 인 경우 &lt;code&gt;chars&lt;/code&gt; 인수는 기본적으로 공백을 제거합니다. &lt;code&gt;chars&lt;/code&gt; 인수는 접두사 나 접미사 아니다; 오히려 값의 모든 조합이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="44ca716c299a61027880c154634feb6b89178fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a prefix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 인수는 문자 집합을 지정하는 문자열을 제거 할 것입니다. 생략되거나 없음 인 경우 &lt;code&gt;chars&lt;/code&gt; 인수는 기본적으로 공백을 제거합니다. &lt;code&gt;chars&lt;/code&gt; 인수는 접두사 아니다; 오히려 값의 모든 조합이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="3ab81d1fe754db2126af526470043294b9859fdc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chars&lt;/code&gt; argument is a string specifying the set of characters to be removed. If omitted or None, the &lt;code&gt;chars&lt;/code&gt; argument defaults to removing whitespace. The &lt;code&gt;chars&lt;/code&gt; argument is not a suffix; rather, all combinations of its values are stripped.</source>
          <target state="translated">&lt;code&gt;chars&lt;/code&gt; 인수는 문자 집합을 지정하는 문자열을 제거 할 것입니다. 생략되거나 없음 인 경우 &lt;code&gt;chars&lt;/code&gt; 인수는 기본적으로 공백을 제거합니다. &lt;code&gt;chars&lt;/code&gt; 인수는 접미사 아니다; 오히려 값의 모든 조합이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="c5f389d1809eca65fc531558b3a6934398b93db5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;code.c&lt;/code&gt; file also contains the function &lt;code&gt;dfilter2d&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1062b010a751d11306d8dd6990fc1281fafefff6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;comments&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f924ee1f48ac861086d833eab7f0e461342200" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;converters&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bf25618f0e89873a8966e075d9cc930c281ddb2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; method makes a complete copy of the array and its data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c7d601eb1b28391adc5c0db2ef77348e27c0e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;defaultfmt&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a534898d388f95602366c3e92d612246a0ec8f63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delimiter&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="961750d0f31ee27657eeda3c0b92ff071d0d3872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;doc/swig&lt;/code&gt; directory moved</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f33c0fec12debe8698b9f3d00999bb3fb759ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.alignment&lt;/code&gt; attribute (&lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; in C). This is meant to reflect the &amp;ldquo;true alignment&amp;rdquo; of the type. It has arch-dependent default values for all datatypes, with the exception of structured types created with &lt;code&gt;align=True&lt;/code&gt; as described below.</source>
          <target state="translated">&lt;code&gt;dtype.alignment&lt;/code&gt; 속성 ( &lt;code&gt;descr-&amp;gt;alignment&lt;/code&gt; C에서). 이는 유형의 &quot;실제 정렬&quot;을 반영하기위한 것입니다. 아래에 설명 된대로 &lt;code&gt;align=True&lt;/code&gt; 로 작성된 구조화 된 유형을 제외하고 모든 데이터 유형에 대해 아치 종속 기본값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="323a6b614fe91ba8419451439d97b4868d61c2a1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype.fields&lt;/code&gt; dictionary will contain titles as keys, if any titles are used. This means effectively that a field with a title will be represented twice in the fields dictionary. The tuple values for these fields will also have a third element, the field title. Because of this, and because the &lt;code&gt;names&lt;/code&gt; attribute preserves the field order while the &lt;code&gt;fields&lt;/code&gt; attribute may not, it is recommended to iterate through the fields of a dtype using the &lt;code&gt;names&lt;/code&gt; attribute of the dtype, which will not list titles, as in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0428300bbf21ef1b533ffa3e86adb5ceddd8dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dtype&lt;/code&gt; parameter defines the underlying data type.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 매개 변수는 기본 데이터 유형을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="93f7d511e2846b265125fabe4d5030e15709832e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;excluded&lt;/code&gt; argument can be used to prevent vectorizing over certain arguments. This can be useful for array-like arguments of a fixed length such as the coefficients for a polynomial as in &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;polyval&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;excluded&lt;/code&gt; 인수는 특정 인수를 통해 벡터화 방지 할 수 있습니다. 이것은 &lt;a href=&quot;numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;polyval&lt;/code&gt; &lt;/a&gt; 에서와 같이 다항식의 계수와 같이 고정 길이의 배열과 같은 인수에 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="359c30915e6710377793414f9e99d77e6eeeea63" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;f2py -c&lt;/code&gt; option must be applied either to an existing &lt;code&gt;.pyf&lt;/code&gt; file (plus the source/object/library files) or one must specify the &lt;code&gt;-m &amp;lt;modulename&amp;gt;&lt;/code&gt; option (plus the sources/object/library files). Use one of the following options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2beff53e54fda1bd096a7e81c4708f352287d275" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; attribute of the &lt;code&gt;PyArrayObject&lt;/code&gt; structure contains important information about the memory used by the array (pointed to by the data member) This flag information must be kept accurate or strange results and even segfaults may result.</source>
          <target state="translated">&lt;code&gt;PyArrayObject&lt;/code&gt; 구조체 의 &lt;code&gt;flags&lt;/code&gt; 속성은 배열이 사용하는 메모리 (데이터 멤버가 가리키는)에 대한 중요한 정보를 포함합니다.이 플래그 정보는 정확하거나 이상한 결과를 유지해야하며 segfault가 발생할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cff4dd26e77da7e42ef944b6a6e55860dbd33d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;genfromtxt&lt;/code&gt; function provides two other complementary mechanisms: the &lt;code&gt;missing_values&lt;/code&gt; argument is used to recognize missing data and a second argument, &lt;code&gt;filling_values&lt;/code&gt;, is used to process these missing data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b08d522b6b1cfd800cd6bda4d86b04d644f1baf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;int_&lt;/code&gt; type does &lt;strong&gt;not&lt;/strong&gt; inherit from the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; built-in under Python 3, because type &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is no longer a fixed-width integer type.</source>
          <target state="translated">&lt;code&gt;int_&lt;/code&gt; 유형은 않습니다 &lt;strong&gt;하지&lt;/strong&gt; 로부터 상속하지 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 형 때문에, 내장 된 파이썬 3에서 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 더 이상 고정 폭 정수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5032550323e57bc7dec27d8af2d8f9df18642750" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;itershape&lt;/code&gt; parameter allows you to force the iterator to have a specific iteration shape. It is an array of length &lt;code&gt;oa_ndim&lt;/code&gt;. When an entry is negative, its value is determined from the operands. This parameter allows automatically allocated outputs to get additional dimensions which don&amp;rsquo;t match up with any dimension of an input.</source>
          <target state="translated">&lt;code&gt;itershape&lt;/code&gt; 의 매개 변수를 사용하면 특정 반복의 형상으로 반복자를 강제 할 수 있습니다. 길이가 &lt;code&gt;oa_ndim&lt;/code&gt; 인 배열입니다 . 항목이 음수이면 해당 값은 피연산자에서 결정됩니다. 이 매개 변수를 사용하면 자동으로 할당 된 출력이 입력의 차원과 일치하지 않는 추가 차원을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d1b139e99319cf8723f8471165f727072e0de12d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;k&lt;/code&gt; different &amp;ldquo;columns&amp;rdquo; to be sorted. The last column (or row if &lt;code&gt;keys&lt;/code&gt; is a 2D array) is the primary sort key.</source>
          <target state="translated">&lt;code&gt;k&lt;/code&gt; 개의 서로 다른 &quot;열은&quot;분류한다. 마지막 열 (또는 &lt;code&gt;keys&lt;/code&gt; 가 2D 배열 인 경우 행 )이 기본 정렬 키입니다.</target>
        </trans-unit>
        <trans-unit id="bf501ea6ca94cccfb99a424407f3991a7fe0b23a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mask&lt;/code&gt; can be initialized with an array of boolean values with the same shape as &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7a81ce30e9985e9cc6aff4a084478e80352aabd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;matrix&lt;/code&gt; constructor additionally &lt;strong&gt;takes a convenient string initializer&lt;/strong&gt;. As in &lt;code&gt;matrix(&quot;[1&amp;nbsp;2&amp;nbsp;3;&amp;nbsp;4&amp;nbsp;5&amp;nbsp;6]&quot;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab61433b884d13cbf28918d009f77e172c843e81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;n&lt;/code&gt; arrays of indices corresponding to the locations where &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 위치에 대응하는 인덱스의 배열 &lt;code&gt;mask_func(np.ones((n, n)), k)&lt;/code&gt; 참이다.</target>
        </trans-unit>
        <trans-unit id="69bba282bdcb3fd4a040d50fe46e42c40f81a639" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;names&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68e43d8a15f5f97ea384a5e71f1342015a6bc434" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ndarray&lt;/code&gt; is an object that provide a python array interface to data in memory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68dcfe0b1fdf3a267f300958e2039277e48ae02c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_order&lt;/code&gt; code can be any from the following:</source>
          <target state="translated">&lt;code&gt;new_order&lt;/code&gt; 코드는 다음에서 하나가 될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="8693a0f592844bcf9978c5fbaa78f4621036206e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nonzero&lt;/code&gt; method of the condition array can also be called.</source>
          <target state="translated">조건 배열 의 &lt;code&gt;nonzero&lt;/code&gt; 이 아닌 메소드를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="119598850fcb719f758c8505ecbfd545e55a9647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.einsum&lt;/code&gt; function will use BLAS when possible and optimize by default</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e03ccb4d87ad4f35f1ad3c43da765c8e7da17640" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;np.percentile&lt;/code&gt; &amp;lsquo;midpoint&amp;rsquo; interpolation method fixed for exact indices</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabf6694e45f9bef7f8445dcaf6ddb978e5e6f05" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;npy_3kcompat.h&lt;/code&gt; header changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d18c665ad6cff39ded6fc90bc8648963ab9ee138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file contains several macros and routines that it uses internally to build its typemaps. However, these functions may be useful elsewhere in your interface file. These macros and routines are implemented as fragments, which are described briefly in the previous section. If you try to use one or more of the following macros or functions, but your compiler complains that it does not recognize the symbol, then you need to force these fragments to appear in your code using:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 파일은 그것의적인 typemap을 구축하기 위해 내부적으로 사용하는 몇 가지 매크로와 루틴이 포함되어 있습니다. 그러나 이러한 기능은 인터페이스 파일의 다른 곳에서 유용 할 수 있습니다. 이 매크로와 루틴은 조각으로 구현되며, 이전 섹션에서 간략하게 설명했습니다. 다음 매크로 또는 함수 중 하나 이상을 사용하려고하지만 컴파일러에서 심볼을 인식하지 못한다고 불평하는 경우 다음을 사용하여 코드에 이러한 조각이 나타나도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f4cb37fdc51e8b1f5c2b248e5fd15fdd94aa9b6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; file is currently located in the &lt;code&gt;tools/swig&lt;/code&gt; sub-directory under the &lt;code&gt;numpy&lt;/code&gt; installation directory. Typically, you will want to copy it to the directory where you are developing your wrappers.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 파일은 현재에 위치하고 &lt;code&gt;tools/swig&lt;/code&gt; 세 이하 하위 디렉토리 &lt;code&gt;numpy&lt;/code&gt; 설치 디렉토리. 일반적으로 랩퍼를 개발중인 디렉토리에 복사하려고합니다.</target>
        </trans-unit>
        <trans-unit id="96831ff16133b13c87cfe870992604959917c570" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file also provides additional tools for wrapper developers, including:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 인터페이스 파일은 포함 래퍼 개발자를위한 추가 도구를 제공합니다 :</target>
        </trans-unit>
        <trans-unit id="d04832f55eba99f2bc4cc0dceb3d718f68b6cac8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file does not support typemaps for output arrays, for several reasons. First, C/C++ return arguments are limited to a single value. This prevents obtaining dimension information in a general way. Second, arrays with hard-coded lengths are not permitted as return arguments. In other words:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 인터페이스 파일은 여러 가지 이유로, 출력 배열에 대한적인 typemap을 지원하지 않습니다. 먼저, C / C ++ 리턴 인수는 단일 값으로 제한됩니다. 이렇게하면 일반적인 방식으로 차원 정보를 얻을 수 없습니다. 둘째, 하드 코딩 된 길이를 가진 배열은 반환 인수로 허용되지 않습니다. 다시 말해:</target>
        </trans-unit>
        <trans-unit id="65e8b572ae6dc55c16aea9abc0f0766e897fe055" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.i&lt;/code&gt; interface file uses the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for the following C data types and &lt;code&gt;int&lt;/code&gt; dimension types:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 인터페이스 파일은 사용 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 다음 C 데이터 유형 및 대한적인 typemap을 구현하는 매크로 &lt;code&gt;int&lt;/code&gt; 치수 유형 :</target>
        </trans-unit>
        <trans-unit id="d99e0e96fa984690444350c5bb3087380beb5586" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; 의 모듈</target>
        </trans-unit>
        <trans-unit id="1f4db4ab31f145b9bac6edb4b0915cc64c0ea3a4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.ndarray&lt;/code&gt; constructor no longer interprets &lt;code&gt;strides=()&lt;/code&gt; as &lt;code&gt;strides=None&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70a302d51ef0fc934fa61a7faa2fee138940dfc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;numpy.rec&lt;/code&gt; module provides a number of other convenience functions for creating record arrays, see &lt;a href=&quot;../reference/routines.array-creation#routines-array-creation-rec&quot;&gt;record array creation routines&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c8ade543f0e1c46d97cf061c562c3116b9639d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;order&lt;/code&gt; keyword gives the index ordering both for &lt;em&gt;fetching&lt;/em&gt; the values from &lt;code&gt;a&lt;/code&gt;, and then &lt;em&gt;placing&lt;/em&gt; the values into the output array. For example, let&amp;rsquo;s say you have an array:</source>
          <target state="translated">&lt;code&gt;order&lt;/code&gt; 키워드 모두 주문 인덱스 제공 &lt;em&gt;페치&lt;/em&gt; 의 값을 하고 &lt;em&gt;배치&lt;/em&gt; 출력 배열에 값. 예를 들어 배열이 있다고 가정 해 봅시다. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b38e6e5718f484c9be916df67070a4920d8e24c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;repr&lt;/code&gt; of &lt;code&gt;np.polynomial&lt;/code&gt; classes is more explicit</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7075c0200f067381f77164e531b354de40ba5d19" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;savetxt()&lt;/code&gt; and &lt;code&gt;loadtxt()&lt;/code&gt; functions accept additional optional parameters such as header, footer, and delimiter. While text files can be easier for sharing, .npy and .npz files are smaller and faster to read. If you need more sophisticated handling of your text file (for example, if you need to work with lines that contain missing values), you will want to use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="022ed8cd0b6cf9d8c83ca5b8b482f20886ea6324" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;series&lt;/code&gt; is expected to be an instance of some polynomial series of one of the types supported by by the numpy.polynomial module, but could be some other class that supports the convert method.</source>
          <target state="translated">이 &lt;code&gt;series&lt;/code&gt; 는 numpy.polynomial 모듈에서 지원하는 유형 중 하나의 일부 다항식 시리즈의 인스턴스 일 것으로 예상되지만 convert 메소드를 지원하는 다른 클래스 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4910f2b9024b32efada1e65d4c1134f65374f1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;setup.py&lt;/code&gt; file</source>
          <target state="translated">&lt;code&gt;setup.py&lt;/code&gt; 파일</target>
        </trans-unit>
        <trans-unit id="0948550106d7d72b97910c4e4918bcddbe3d6d6b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;signature&lt;/code&gt; argument allows for vectorizing functions that act on non-scalar arrays of fixed length. For example, you can use it for a vectorized calculation of Pearson correlation coefficient and its p-value:</source>
          <target state="translated">&lt;code&gt;signature&lt;/code&gt; 인수는 고정 된 길이의 비 스칼라 배열에 작용하는 기능을 벡터화 수 있습니다. 예를 들어, Pearson 상관 계수 및 p- 값의 벡터화 된 계산에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="692ace7013c4ccf7dfcd73ad9c88abfaeb03c00c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip_header&lt;/code&gt; and &lt;code&gt;skip_footer&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19cc10b9b9bd6104c6aeb8b9be441a8dc8445028" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; argument must be a sequence that contains the following elements:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 인수는 다음과 같은 요소를 포함하는 순서해야합니다 :</target>
        </trans-unit>
        <trans-unit id="28db18b99085783cc1cb19c430887ae4c1bd2dc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; tuple has the following items:</source>
          <target state="translated">&lt;code&gt;state&lt;/code&gt; 튜플에는 다음과 같은 항목이</target>
        </trans-unit>
        <trans-unit id="0e4c35736a2eec986972a33d172a5be16d326f7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;tp_as_number&lt;/code&gt; 의 방법은 작업을 처리하기 위해 등록 된 어떤 함수를 호출하는 일반적인 방법을 사용합니다. 때 &lt;code&gt;_multiarray_umath module&lt;/code&gt; 가져, 그것은 해당 ufuncs 모든 배열에 대한 수치 연산을 설정합니다. 이 선택은 &lt;a href=&quot;c-api.ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt; &lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt; &lt;/a&gt; 로 변경할 수 있습니다 . &lt;code&gt;tp_str&lt;/code&gt; 및 &lt;code&gt;tp_repr&lt;/code&gt; 메소드는 &lt;a href=&quot;c-api.array#c.PyArray_SetStringFunction&quot;&gt; &lt;code&gt;PyArray_SetStringFunction&lt;/code&gt; 을&lt;/a&gt; 사용하여 변경할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="008291952c69e3c178208fe3d11495f165132897" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tp_as_number&lt;/code&gt; methods use a generic approach to call whatever function has been registered for handling the operation. When the &lt;code&gt;_multiarray_umath module&lt;/code&gt; is imported, it sets the numeric operations for all arrays to the corresponding ufuncs. This choice can be changed with &lt;a href=&quot;ufunc#c.PyUFunc_ReplaceLoopBySignature&quot;&gt;&lt;code&gt;PyUFunc_ReplaceLoopBySignature&lt;/code&gt;&lt;/a&gt; The &lt;code&gt;tp_str&lt;/code&gt; and &lt;code&gt;tp_repr&lt;/code&gt; methods can also be altered using &lt;a href=&quot;array#c.PyArray_SetStringFunction&quot;&gt;&lt;code&gt;PyArray_SetStringFunction&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5f797071b24065d3a9e203b1fcea474546397a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;usecols&lt;/code&gt; argument</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5186f89054917ad06c4418d857ded8a6ad552d9f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;Documentation&lt;/em&gt; for a software project is the set of reference, instructional, educational, informative material generated by the project developers and contributors, as well as discussions, presentations, videos and other user-generated content. It may include learning-oriented content (such as tutorials and how-tos), use-cases or in-depth explanations and reference for developers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a54cde186ec5ee99014b55275737fd8ded4abc" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;bounds&lt;/em&gt; argument is expected to be a (2 * iter-&amp;gt;ao-&amp;gt;nd) arrays, such as the range bound[2*i]-&amp;gt;bounds[2*i+1] defines the range where to walk for dimension i (both bounds are included in the walked coordinates). The bounds should be ordered for each dimension (bounds[2*i] &amp;lt;= bounds[2*i+1]).</source>
          <target state="translated">&lt;em&gt;경계&lt;/em&gt; 인자가 될 것으로 예상된다 (2 * iter-&amp;gt; AO-&amp;gt; nd)이 결속 범위로서 배열 [2 * i]는 -&amp;gt; 여기서 치수 나 도보의 범위를 규정 범위 [I + 1 * 2] (두 경계는 도보 좌표에 포함됩니다). 경계는 각 차원에 대해 정렬되어야합니다 (bounds [2 * i] &amp;lt;= bounds [2 * i + 1]).</target>
        </trans-unit>
        <trans-unit id="167173497ff130611588ae9a0a550c00ffde124f" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;compile-time&lt;/em&gt; environment variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea1fe523a0552e237800f38d8997bfcb72c8d0f5" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;func&lt;/em&gt;, &lt;em&gt;data&lt;/em&gt;, &lt;em&gt;types&lt;/em&gt;, &lt;em&gt;name&lt;/em&gt;, and &lt;em&gt;doc&lt;/em&gt; arguments are not copied by &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt;. The caller must ensure that the memory used by these arrays is not freed as long as the ufunc object is alive.</source>
          <target state="translated">&lt;em&gt;FUNC&lt;/em&gt; , &lt;em&gt;데이터&lt;/em&gt; , &lt;em&gt;유형&lt;/em&gt; , &lt;em&gt;이름&lt;/em&gt; , 및 &lt;em&gt;문서의&lt;/em&gt; 인수로 복사되지 않습니다 &lt;a href=&quot;#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; &lt;/a&gt; . 호출자는 ufunc 객체가 존재하는 한이 배열에 사용 된 메모리가 해제되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="20c9d63d4d93167ef641a021fb26c115a182b092" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;itemsize&lt;/em&gt; key allows the total size of the dtype to be set, and must be an integer large enough so all the fields are within the dtype. If the dtype being constructed is aligned, the &lt;em&gt;itemsize&lt;/em&gt; must also be divisible by the struct alignment. Total dtype &lt;em&gt;itemsize&lt;/em&gt; is limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;itemsize의&lt;/em&gt; 키는 DTYPE의 전체 크기가 설정 될 수 있으며 모든 필드는 DTYPE 내에 있도록 정수 충분한해야합니다. 구성되는 DTYPE이 정렬되면 &lt;em&gt;itemsize는&lt;/em&gt; 또한 구조체 정렬로 나눌 수 있어야. 총 D- 타입 &lt;em&gt;itemsize이&lt;/em&gt; 제한됩니다 &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ed9f0881461d81b2f7af8ce5229589ca6d28abd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">실제 입력 의 &lt;em&gt;n&lt;/em&gt; 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="35066a9f7cb50260dfe6cd2d771163f62f1011ce" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;N&lt;/em&gt; 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="1f82e353fb8bee88c46f056efaf0e1b9b205e05a" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;out&lt;/em&gt; argument to &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; is not supported, &lt;code&gt;third&lt;/code&gt; has to be None.</source>
          <target state="translated">그만큼 &lt;em&gt;&lt;/em&gt;&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; 에&lt;/a&gt;&lt;em&gt; out&lt;/em&gt; 인수 는 지원되지 않으며 &lt;code&gt;third&lt;/code&gt; 는 None이어야합니다.</target>
        </trans-unit>
        <trans-unit id="17d0c90784f11b0394d45b1939c2a01c10fdf407" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;shape&lt;/em&gt; is the fixed shape of the sub-array described by this data type, and &lt;em&gt;item_dtype&lt;/em&gt; the data type of the array.</source>
          <target state="translated">&lt;em&gt;형상&lt;/em&gt; 이 데이터 형식으로 기술 된 서브 어레이의 고정 형태이고, &lt;em&gt;item_dtype&lt;/em&gt; 배열의 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="e35e90d2e4f0ba849a49c1795babe3ab2a9f08fe" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;side&lt;/em&gt; argument indicates whether the index returned should be that of the first suitable location (if &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;) or of the last (if &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;).</source>
          <target state="translated">그만큼 &lt;em&gt;측&lt;/em&gt; 인수 리턴 인덱스할지 여부를 나타내는 상기 제 1 위치에 적합한 (만약 &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ) 또는 최근의 (만약 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="099bc64f90d3db4f6c006d553b07493bf40349bd" translate="yes" xml:space="preserve">
          <source>The &lt;em&gt;sorter&lt;/em&gt; argument, if not &lt;code&gt;NULL&lt;/code&gt;, must be a 1D array of integer indices the same length as &lt;em&gt;self&lt;/em&gt;, that sorts it into ascending order. This is typically the result of a call to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) Binary search is used to find the required insertion points.</source>
          <target state="translated">&lt;em&gt;소터&lt;/em&gt; 인수, 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 정수의 1 차원 어레이는 동일한 길이와 indices 있어야&lt;em&gt; 자기&lt;/em&gt; , 오름차순으로 정렬을 그. 이것은 일반적으로 &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 에 대한 호출의 결과입니다. 이진 검색은 필요한 삽입 점을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9171c42e0d10b56599a94002523d8b2e0c0e8b3e" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;.npy&lt;/strong&gt; and &lt;strong&gt;.npz&lt;/strong&gt; files store data, shape, dtype, and other information required to reconstruct the ndarray in a way that allows the array to be correctly retrieved, even when the file is on another machine with different architecture.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a635945c029e67349a5e1c329cf33ef8efa9b4ec" translate="yes" xml:space="preserve">
          <source>The &lt;strong&gt;dots&lt;/strong&gt; (&lt;code&gt;...&lt;/code&gt;) represent as many colons as needed to produce a complete indexing tuple. For example, if &lt;code&gt;x&lt;/code&gt; is an array with 5 axes, then</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fad9b84d117a49a76f66aa7359451abb9299209" translate="yes" xml:space="preserve">
          <source>The API exposed by NumPy for third-party extensions has grown over years of releases, and has allowed programmers to directly access NumPy functionality from C. This API can be best described as &amp;ldquo;organic&amp;rdquo;. It has emerged from multiple competing desires and from multiple points of view over the years, strongly influenced by the desire to make it easy for users to move to NumPy from Numeric and Numarray. The core API originated with Numeric in 1995 and there are patterns such as the heavy use of macros written to mimic Python&amp;rsquo;s C-API as well as account for compiler technology of the late 90&amp;rsquo;s. There is also only a small group of volunteers who have had very little time to spend on improving this API.</source>
          <target state="translated">써드 파티 확장을 위해 NumPy에 의해 공개 된 API는 수년에 걸쳐 릴리스되었으며 프로그래머는 C에서 NumPy 기능에 직접 액세스 할 수있었습니다.이 API는 &quot;유기적&quot;으로 가장 잘 설명 될 수 있습니다. 그것은 수년 동안 여러 경쟁 욕구와 여러 관점에서 나 왔으며, 사용자가 Numeric 및 Numarray에서 NumPy로 쉽게 이동할 수 있도록하려는 욕구에 크게 영향을 받았습니다. 핵심 API는 1995 년 Numeric에서 시작되었으며 90 년대 후반의 컴파일러 기술을 설명 할뿐만 아니라 Python의 C-API를 모방하기 위해 작성된 매크로를 많이 사용하는 것과 같은 패턴이 있습니다. 이 API를 개선하는 데 시간이 거의없는 소수의 자원 봉사자도 있습니다.</target>
        </trans-unit>
        <trans-unit id="00284168716cc312202174053f58f3f176efd9f0" translate="yes" xml:space="preserve">
          <source>The Array Interface</source>
          <target state="translated">어레이 인터페이스</target>
        </trans-unit>
        <trans-unit id="0126a67e2a45442b450ea70b10470e175bf968af" translate="yes" xml:space="preserve">
          <source>The Bartlett window is defined as</source>
          <target state="translated">바틀렛 창은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="937ca2e1b9d54c371bf73ce20e57493839ccf829" translate="yes" xml:space="preserve">
          <source>The Bartlett window is very similar to a triangular window, except that the end points are at zero. It is often used in signal processing for tapering a signal, without generating too much ripple in the frequency domain.</source>
          <target state="translated">Bartlett 창은 끝 점이 0임을 제외하고 삼각형 창과 매우 유사합니다. 주파수 영역에서 너무 많은 리플을 생성하지 않고 신호 테이퍼링을 위해 신호 처리에 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c87b609239622a7f33fd7054a79bbe3b69d99bf" translate="yes" xml:space="preserve">
          <source>The Beta distribution is a special case of the Dirichlet distribution, and is related to the Gamma distribution. It has the probability distribution function</source>
          <target state="translated">베타 배포판은 Dirichlet 배포판의 특별한 경우이며 감마 배포판과 관련이 있습니다. 확률 분포 함수가 있습니다</target>
        </trans-unit>
        <trans-unit id="2fd0f76d8d8eab0518886bc71aed9b0148fca33e" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the &lt;code&gt;bitgen_t&lt;/code&gt; struct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b111fe41355b271c80f9d028d2e71b1df692e910" translate="yes" xml:space="preserve">
          <source>The BitGenerator can also be directly accessed using the members of the basic RNG structure.</source>
          <target state="translated">BitGenerator는 기본 RNG 구조의 멤버를 사용하여 직접 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe9a0ff0e1aba5f3307dd340548f412e309bd12d" translate="yes" xml:space="preserve">
          <source>The BitGenerators have been designed to be extendable using standard tools for high-performance Python &amp;ndash; numba and Cython. The &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; object can also be used with user-provided BitGenerators as long as these export a small set of required functions.</source>
          <target state="translated">BitGenerator는 고성능 Python &amp;ndash; numba 및 Cython 용 표준 도구를 사용하여 확장 가능하도록 설계되었습니다. &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 객체 이러한 수출만큼 사용자 제공 BitGenerators에 요구되는 기능의 작은 세트를 사용할 수있다.</target>
        </trans-unit>
        <trans-unit id="d038e7d7a9d5b6013d6bf710bb0f42c26b9ffb86" translate="yes" xml:space="preserve">
          <source>The Blackman window is a taper formed by using the first three terms of a summation of cosines. It was designed to have close to the minimal leakage possible. It is close to optimal, only slightly worse than a Kaiser window.</source>
          <target state="translated">블랙맨 창은 코사인 합산의 처음 세 항을 사용하여 형성된 테이퍼입니다. 누출을 최소화 할 수 있도록 설계되었습니다. 그것은 Kaiser 창보다 약간 나쁘지만 최적에 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="df8aff554aa2b04bd579ded0666721d3f45ae21e" translate="yes" xml:space="preserve">
          <source>The Blackman window is defined as</source>
          <target state="translated">블랙맨 창은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b108efac05f697f2e430596f72b3bb61068c8903" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.generator.gamma#numpy.random.Generator.gamma&quot;&gt;&lt;code&gt;Generator.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_t#numpy.random.Generator.standard_t&quot;&gt;&lt;code&gt;Generator.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, i.e., &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201133c822c73c7e6eedbd7735bf455db76c868e" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using &lt;code&gt;Generator&lt;/code&gt; for the normal distribution or any other distribution that relies on the normal such as the &lt;code&gt;gamma&lt;/code&gt; or &lt;code&gt;standard_t&lt;/code&gt;. If you require bitwise backward compatible streams, use &lt;code&gt;RandomState&lt;/code&gt;.</source>
          <target state="translated">NumPy의 법선을 생성하는 데 사용되는 Box-Muller 방법은 더 이상 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 없습니다 . 정규 분포에 대해 &lt;code&gt;Generator&lt;/code&gt; 를 사용 하거나 &lt;code&gt;gamma&lt;/code&gt; 또는 &lt;code&gt;standard_t&lt;/code&gt; 와 같이 정규 분포에 의존하는 다른 분포에 대해 정확한 임의의 값을 재현 할 수 없습니다 . 비트 호환 하위 스트림이 필요한 경우 &lt;code&gt;RandomState&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="530afb1a91925fe435a9294f8360e96b319ffb64" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy의 법선을 생성하는 데 사용되는 Box-Muller 방법은 더 이상 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 없습니다 . 정규 분포 또는 정규에 의존하는 다른 분포 (예 : &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.gamma#numpy.random.mtrand.RandomState.gamma&quot;&gt; &lt;code&gt;RandomState.gamma&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;generated/numpy.random.mtrand.randomstate.standard_t#numpy.random.mtrand.RandomState.standard_t&quot;&gt; &lt;code&gt;RandomState.standard_t&lt;/code&gt; )&lt;/a&gt; 에는 Generator를 사용하여 정확한 임의의 값을 재현 할 수 없습니다 . 비트 호환 하위 스트림이 필요한 경우 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오. .</target>
        </trans-unit>
        <trans-unit id="21ca435d6d38aadf77947319cb2cc6cd824fa4fc" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available in &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. It is not possible to reproduce the exact random values using Generator for the normal distribution or any other distribution that relies on the normal such as the &lt;a href=&quot;generated/numpy.random.randomstate.gamma#numpy.random.RandomState.gamma&quot;&gt;&lt;code&gt;RandomState.gamma&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.randomstate.standard_t#numpy.random.RandomState.standard_t&quot;&gt;&lt;code&gt;RandomState.standard_t&lt;/code&gt;&lt;/a&gt;. If you require bitwise backward compatible streams, use &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08ca8f1d4aa8ba16007dde802489e6ef41f52bf0" translate="yes" xml:space="preserve">
          <source>The Box-Muller method used to produce NumPy&amp;rsquo;s normals is no longer available.</source>
          <target state="translated">NumPy의 법선을 생성하는 데 사용되는 Box-Muller 방법은 더 이상 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2ae4a149c67359ea20a856b43946c0a1b6f16635" translate="yes" xml:space="preserve">
          <source>The Broadcasting Rule</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9895a5af5b1d937c582f3977255f2f51e2fa8cde" translate="yes" xml:space="preserve">
          <source>The C ABI version number in numpy/core/setup_common.py should only be updated for a major release.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f1ca425ef21b0d3713606817fa90d6d2d43ef46" translate="yes" xml:space="preserve">
          <source>The C API version needs to be tracked in three places</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c85becd504bcc9e1840ed9b25393915f66f319" translate="yes" xml:space="preserve">
          <source>The C code to be wrapped for argoutview arrays are characterized by pointers: pointers to the dimensions and double pointers to the data, so that these values can be passed back to the user. The argoutview typemap signatures are therefore</source>
          <target state="translated">argoutview 배열을 위해 랩핑 될 C 코드는 포인터에 의해 특징 지워진다 : 차원에 대한 포인터와 데이터에 대한 이중 포인터.이 값들은 사용자에게 다시 전달 될 수있다. 따라서 argoutview 타입 맵 시그니처는</target>
        </trans-unit>
        <trans-unit id="21de11f0f6aeb101275d43918daa34e6c36dce23" translate="yes" xml:space="preserve">
          <source>The C file is given below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce59a78e88c7f509dea5f34f975be44fdfb7e3ba" translate="yes" xml:space="preserve">
          <source>The C file is given below. The ufunc generated takes two arguments A and B. It returns a tuple whose first element is A*B and whose second element is logit(A*B). Note that it automatically supports broadcasting, as well as all other properties of a ufunc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b86dcfa016c911d4342c93c728710eb6da34647" translate="yes" xml:space="preserve">
          <source>The C-API is actually an array of function pointers. This array is created (and pointed to by a global variable) by import_ufunc. The global variable is either statically defined or allowed to be seen by other files depending on the state of &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C-API는 실제로 함수 포인터의 배열입니다. 이 배열은 import_ufunc에 의해 작성 (전역 변수로 지정)됩니다. 전역 변수는 &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt; 상태에 따라 정적으로 정의되거나 다른 파일에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96e666c1c0b5a663da4c4f946173e189e8d49d4f" translate="yes" xml:space="preserve">
          <source>The C-code generated by Cython is hard to read and modify (and typically compiles with annoying but harmless warnings).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ac48dd933ed72b23987767613d8001cf662454" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; is used to keep track of a pointer into an N-dimensional array. It contains associated information used to quickly march through the array. The pointer can be adjusted in three basic ways: 1) advance to the &amp;ldquo;next&amp;rdquo; position in the array in a C-style contiguous fashion, 2) advance to an arbitrary N-dimensional coordinate in the array, and 3) advance to an arbitrary one-dimensional index into the array. The members of the &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure are used in these calculations. Iterator objects keep their own dimension and strides information about an array. This can be adjusted as needed for &amp;ldquo;broadcasting,&amp;rdquo; or to loop over only specific dimensions.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt; 의 객체에 해당하는 C 구조 는 &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; 은&lt;/a&gt; 은 N 차원 어레이로의 포인터를 추적하는데 사용된다. 여기에는 어레이를 빠르게 진행하는 데 사용되는 관련 정보가 포함되어 있습니다. 포인터는 3 가지 기본 방식으로 조정할 수 있습니다. 1) C 스타일 연속 방식으로 배열에서 &quot;다음&quot;위치로 진행, 2) 배열에서 임의의 N- 차원 좌표로 진행, 3) 배열에 대한 임의의 1 차원 인덱스. &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 의 멤버이러한 계산에는 구조가 사용됩니다. 반복자 객체는 자체 차원을 유지하고 배열에 대한 정보를 보폭합니다. 이는 &quot;방송&quot;에 필요에 따라 조정하거나 특정 크기 만 반복하도록 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b65035b5e2ef1f9ddd680e8269d8b6e8cd78edf" translate="yes" xml:space="preserve">
          <source>The C-structure corresponding to an object of &lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt;&lt;/a&gt; is the &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt;&lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArrayNeighborhoodIter_Type&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIter_Type&lt;/code&gt; &lt;/a&gt; 의 객체에 해당하는 C 구조 는 &lt;a href=&quot;#c.PyArrayNeighborhoodIterObject&quot;&gt; &lt;code&gt;PyArrayNeighborhoodIterObject&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b70a592ea3e52c944c4250fca143b3a7150ee3c2" translate="yes" xml:space="preserve">
          <source>The Cauchy distribution arises in the solution to the driven harmonic oscillator problem, and also describes spectral line broadening. It also describes the distribution of values at which a line tilted at a random angle will cut the x axis.</source>
          <target state="translated">Cauchy 분포는 구동 고조파 발진기 문제에 대한 솔루션에서 발생하며 스펙트럼 선 확대도 설명합니다. 또한 임의 각도로 기울어 진 선이 x 축을 절단하는 값의 분포를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7e16b7bac76fd95a18826e75104c29f03fcae229" translate="yes" xml:space="preserve">
          <source>The Chebyshev class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the methods listed below.</source>
          <target state="translated">Chebyshev 클래스는 표준 Python 숫자 메소드 '+', '-', '*', '//', '%', 'divmod', '**'및 '()'및 나열된 메소드를 제공합니다. 이하.</target>
        </trans-unit>
        <trans-unit id="c6a112ce3f849b264d8d346313df28993dc02ff9" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*(k + .5)/npts for k in range(npts)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0a900a5e45540387f1b83ea73e67c934d19eae" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the first kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca4f0f30abc65b046f7d9e6e691b51c78603fec0" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind are the points &lt;code&gt;cos(x)&lt;/code&gt;, where &lt;code&gt;x = [pi*k/(npts - 1) for k in range(npts)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="196d20b8bbd6f4729eb062a203e433edbc71fdcc" translate="yes" xml:space="preserve">
          <source>The Chebyshev points of the second kind.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18aa36d5e6637359f0f8c985312900157e497010" translate="yes" xml:space="preserve">
          <source>The Chebyshev polynomials used in the interpolation are orthogonal when sampled at the Chebyshev points of the first kind. If it is desired to constrain some of the coefficients they can simply be set to the desired value after the interpolation, no new interpolation or fit is needed. This is especially useful if it is known apriori that some of coefficients are zero. For instance, if the function is even then the coefficients of the terms of odd degree in the result can be set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="993466511b9f370f4f72797c543b0fe46fcac4af" translate="yes" xml:space="preserve">
          <source>The Chebyshev series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Chebyshev 계열 기본 다항식은 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱이 아니므 로이 함수의 결과는 직관적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d5d357969a2c2d8e943734dcd70f209f532e7d" translate="yes" xml:space="preserve">
          <source>The Cholesky decomposition is often used as a fast way of solving</source>
          <target state="translated">hole 레 스키 분해는 종종 빠른 해결 방법으로 사용됩니다</target>
        </trans-unit>
        <trans-unit id="794b3c9b410012bd85aeaac5a58c341f1529d513" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee should aim to have a resolution agreed upon within two weeks. In the event that a resolution can&amp;rsquo;t be determined in that time, the committee will respond to the reporter(s) with an update and projected timeline for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5489514988058a36fb9ae08de6595979ec21a6" translate="yes" xml:space="preserve">
          <source>The Code of Conduct Committee will formally review and sign off on all cases where this mechanism has been applied to make sure it is not being used to control ordinary heated disagreement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e3bda4dc5a743a992fdb89cad8080af0867b844" translate="yes" xml:space="preserve">
          <source>The Council can create subcommittees that provide leadership and guidance for specific aspects of the project. Like the Council as a whole, subcommittees should conduct their business in an open and public manner unless privacy is specifically called for. Private subcommittee communications should happen on the main private mailing list of the Council unless specifically called for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cca4e29456fdc96aaa3058f6b88f125bd4fb528" translate="yes" xml:space="preserve">
          <source>The Council reserves the right to eject current Members, if they are deemed to be actively harmful to the project&amp;rsquo;s well-being, and attempts at communication and conflict resolution have failed. This requires the consensus of the remaining Members.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777c1bc322cb9c22bf40b3217235aef27f1cd1cf" translate="yes" xml:space="preserve">
          <source>The Council will maintain one narrowly focused subcommittee to manage its interactions with NumFOCUS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7319ec02e3cbbaab7add308cd0a417516f369a3b" translate="yes" xml:space="preserve">
          <source>The DFT is defined, with the conventions used in this implementation, in the documentation for the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">DFT는이 구현에 사용 된 규칙과 함께 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; 모듈 의 문서에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c850428d828f95dc2c92af14d3b7a369fbb6f873" translate="yes" xml:space="preserve">
          <source>The DFT is in general defined for complex inputs and outputs, and a single-frequency component at linear frequency</source>
          <target state="translated">DFT는 일반적으로 복잡한 입력 및 출력과 선형 주파수의 단일 주파수 성분에 대해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e1f0dbe8081449397bad0aa2cc6ad0fe41215d23" translate="yes" xml:space="preserve">
          <source>The Datetime and Timedelta data types support a large number of time units, as well as generic units which can be coerced into any of the other units based on input data.</source>
          <target state="translated">Datetime 및 Timedelta 데이터 유형은 입력 데이터를 기반으로 다른 단위로 변환 될 수있는 일반 단위뿐만 아니라 많은 시간 단위를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="fcc8fbde1f068047c588e86f64b1d9bca100dc12" translate="yes" xml:space="preserve">
          <source>The Dirichlet distribution is a distribution over vectors</source>
          <target state="translated">Dirichlet 분포는 벡터에 대한 분포입니다</target>
        </trans-unit>
        <trans-unit id="a4edf1637ded5c0257b8e49c407baa1302046498" translate="yes" xml:space="preserve">
          <source>The Einstein summation convention can be used to compute many multi-dimensional, linear algebraic array operations. &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides a succinct way of representing these.</source>
          <target state="translated">아인슈타인 합산 규칙은 많은 다차원 선형 대수 배열 연산을 계산하는 데 사용될 수 있습니다. &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; 은이&lt;/a&gt; 를 대표하는 간결한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="28b073ac0a61d366802edc13aac74cfca673e0d2" translate="yes" xml:space="preserve">
          <source>The Euler constant</source>
          <target state="translated">오일러 상수</target>
        </trans-unit>
        <trans-unit id="e516b8e0c93fdf83378c5af74b4c3f11ab8b2eec" translate="yes" xml:space="preserve">
          <source>The F statistic is used to compare in-group variances to between-group variances. Calculating the distribution depends on the sampling, and so it is a function of the respective degrees of freedom in the problem. The variable &lt;code&gt;dfnum&lt;/code&gt; is the number of samples minus one, the between-groups degrees of freedom, while &lt;code&gt;dfden&lt;/code&gt; is the within-groups degrees of freedom, the sum of the number of samples in each group minus the number of groups.</source>
          <target state="translated">F 통계량은 그룹 내 분산과 그룹 간 분산을 비교하는 데 사용됩니다. 분포 계산은 표본 추출에 따라 달라 지므로 문제의 각 자유도의 함수입니다. 변수 &lt;code&gt;dfnum&lt;/code&gt; 은 샘플 수에서 1을 뺀 군간 자유도이고, &lt;code&gt;dfden&lt;/code&gt; 은 그룹 내 자유도, 각 ​​그룹의 샘플 수에서 그룹 수를 뺀 값입니다.</target>
        </trans-unit>
        <trans-unit id="ec341083311bc5d9e93dc0e719289499e7876f9f" translate="yes" xml:space="preserve">
          <source>The F2PY interface to Fortran 90 module data is similar to Fortran 77 common blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="255611abe871551a6f0d10449c721d9ac320d3a5" translate="yes" xml:space="preserve">
          <source>The Frobenius norm is given by &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">프로 베니 우스 표준은 &lt;a href=&quot;#rac1c834adb66-1&quot; id=&quot;id1&quot;&gt;[1]에&lt;/a&gt; 의해 주어진다 :</target>
        </trans-unit>
        <trans-unit id="4ebf7b4a74f003f8630476569ef53bec8c91caed" translate="yes" xml:space="preserve">
          <source>The GIL is released for all &lt;code&gt;np.einsum&lt;/code&gt; variations</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7783b7563d5c19477bd0cec8f560b128f37ead00" translate="yes" xml:space="preserve">
          <source>The Gamma distribution is often used to model the times to failure of electronic components, and arises naturally in processes for which the waiting times between Poisson distributed events are relevant.</source>
          <target state="translated">감마 분포는 전자 부품의 고장 시간을 모델링하는 데 종종 사용되며, 포아송 분산 이벤트 간의 대기 시간이 관련된 프로세스에서 자연스럽게 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9c990e445bfb7966adc1e3b9adac640f1e0e9113" translate="yes" xml:space="preserve">
          <source>The Generator&amp;rsquo;s normal, exponential and gamma functions use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s Box-Muller or inverse CDF implementations.</source>
          <target state="translated">Generator의 정규, 지수 및 감마 함수는 NumPy의 Box-Muller 또는 역 CDF 구현보다 2-10 배 빠른 256 단계 Ziggurat 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5fd129bc188ef44c6bd32a38b068d9f3ddc783f7" translate="yes" xml:space="preserve">
          <source>The Gumbel (named for German mathematician Emil Julius Gumbel) was used very early in the hydrology literature, for modeling the occurrence of flood events. It is also used for modeling maximum wind speed and rainfall rates. It is a &amp;ldquo;fat-tailed&amp;rdquo; distribution - the probability of an event in the tail of the distribution is larger than if one used a Gaussian, hence the surprisingly frequent occurrence of 100-year floods. Floods were initially modeled as a Gaussian process, which underestimated the frequency of extreme events.</source>
          <target state="translated">Gumbel (독일 수학자 Emil Julius Gumbel의 이름을 딴)은 수 문학 문학 초기에 홍수 사건의 발생을 모델링하는 데 사용되었습니다. 또한 최대 풍속과 강우량을 모델링하는 데 사용됩니다. 그것은 &quot;뚱뚱한 꼬리&quot;분포입니다-분포의 꼬리에서 사건이 가우시안을 사용했을 때보 다 더 커질 것입니다. 따라서 놀랍게도 100 년 홍수가 자주 발생합니다. 홍수는 초기에 가우시안 프로세스로 모델링되어 극단적 인 사건의 빈도를 과소 평가했습니다.</target>
        </trans-unit>
        <trans-unit id="aa1cbdb34f4d0d2f5ba482222c9284e53a83897b" translate="yes" xml:space="preserve">
          <source>The Gumbel (or Smallest Extreme Value (SEV) or the Smallest Extreme Value Type I) distribution is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. The Gumbel is a special case of the Extreme Value Type I distribution for maximums from distributions with &amp;ldquo;exponential-like&amp;rdquo; tails.</source>
          <target state="translated">Gumbel (또는 SEV (Smallest Extreme Value) 또는 I (Small Extreme Extreme Value Type I)) 분포는 극한값 문제를 모델링하는 데 사용되는 GEV (Generalized Extreme Value) 분포 중 하나입니다. Gumbel은 &quot;지수 형&quot;꼬리가있는 분포에서 최대 값을 얻기위한 극한값 유형 I 분포의 특수한 경우입니다.</target>
        </trans-unit>
        <trans-unit id="d38e3c533241c1cffef7a77e2fb316d839d0e953" translate="yes" xml:space="preserve">
          <source>The Hamming was named for R. W. Hamming, an associate of J. W. Tukey and is described in Blackman and Tukey. It was recommended for smoothing the truncated autocovariance function in the time domain. Most references to the Hamming window come from the signal processing literature, where it is used as one of many windowing functions for smoothing values. It is also known as an apodization (which means &amp;ldquo;removing the foot&amp;rdquo;, i.e. smoothing discontinuities at the beginning and end of the sampled signal) or tapering function.</source>
          <target state="translated">해밍은 JW Tukey의 직원 인 RW Hamming의 이름을 따서 명명되었으며 Blackman과 Tukey에 설명되어 있습니다. 시간 영역에서 절단 된 자기 공분산 함수를 평활화하는 것이 좋습니다. 해밍 윈도우에 대한 대부분의 참조는 신호 처리 문헌에서 가져온 것으로, 값을 평활화하기위한 많은 윈도우 기능 중 하나로 사용됩니다. 또한 아포 디제이 션 ( &quot;발 제거&quot;, 즉 샘플링 된 신호의 시작과 끝에서 스무딩 불연속을 의미 함) 또는 테이퍼링 기능이라고도합니다.</target>
        </trans-unit>
        <trans-unit id="f6f99a10c7b1d0ed496e360cabc47ad0e8b4f95f" translate="yes" xml:space="preserve">
          <source>The Hamming window is a taper formed by using a weighted cosine.</source>
          <target state="translated">해밍 윈도우는 가중 코사인을 사용하여 형성된 테이퍼이다.</target>
        </trans-unit>
        <trans-unit id="c543c8775de7884a498fb8d25199a6da7865f313" translate="yes" xml:space="preserve">
          <source>The Hamming window is defined as</source>
          <target state="translated">해밍 창은 다음과 같이 정의됩니다</target>
        </trans-unit>
        <trans-unit id="c53c036c06b914f30dfda36ac484fab584082b10" translate="yes" xml:space="preserve">
          <source>The Hanning was named for Julius von Hann, an Austrian meteorologist. It is also known as the Cosine Bell. Some authors prefer that it be called a Hann window, to help avoid confusion with the very similar Hamming window.</source>
          <target state="translated">Hanning은 오스트리아 기상 학자 Julius von Hann의 이름을 따서 명명되었습니다. 코사인 벨이라고도합니다. 일부 저자는 매우 유사한 Hamming 창과 혼동을 피하기 위해 Hann 창이라고합니다.</target>
        </trans-unit>
        <trans-unit id="ff9ff54dbcac5fb28018a438cebbfd23097afaae" translate="yes" xml:space="preserve">
          <source>The Hanning window is a taper formed by using a weighted cosine.</source>
          <target state="translated">해닝 윈도우는 가중 코사인을 사용하여 형성된 테이퍼입니다.</target>
        </trans-unit>
        <trans-unit id="7063e81cb7e74fa0cdbf05d1c6333c059e7c5e09" translate="yes" xml:space="preserve">
          <source>The Hanning window is defined as</source>
          <target state="translated">해닝 윈도우는 다음과 같이 정의됩니다</target>
        </trans-unit>
        <trans-unit id="48a86546760e1edd4295f33a270bba0337fe9c75" translate="yes" xml:space="preserve">
          <source>The Heaviside step function is defined as:</source>
          <target state="translated">헤비 사이드 단계 함수는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="a4ab8a335073ed439b508ce34550cc0419ac6836" translate="yes" xml:space="preserve">
          <source>The Hermite class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Hermite 클래스는 속성 및 &lt;code&gt;ABCPolyBase&lt;/code&gt; 설명서에 나와있는 메서드</target>
        </trans-unit>
        <trans-unit id="18c51c2fe8d0823ca52707c91973d012f1770684" translate="yes" xml:space="preserve">
          <source>The Hermite series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Hermite 계열 기본 다항식은 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱이 아니므 로이 함수의 결과는 직관적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29f886dede3063b00d8467b1f756a147bc393097" translate="yes" xml:space="preserve">
          <source>The HermiteE class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">HermiteE 클래스는 속성 및 &lt;code&gt;ABCPolyBase&lt;/code&gt; 설명서에 나와있는 메서드</target>
        </trans-unit>
        <trans-unit id="8cc8b1724a44c8d63d2cfd0d81bc585f17fc260c" translate="yes" xml:space="preserve">
          <source>The HermiteE series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">HermiteE 계열 기본 다항식은 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱이 아니므 로이 함수의 결과는 직관적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4c697a75ca6fe93876f5946baa1a9463872c64a" translate="yes" xml:space="preserve">
          <source>The IRR is perhaps best understood through an example (illustrated using np.irr in the Examples section below). Suppose one invests 100 units and then makes the following withdrawals at regular (fixed) intervals: 39, 59, 55, 20. Assuming the ending value is 0, one&amp;rsquo;s 100 unit investment yields 173 units; however, due to the combination of compounding and the periodic withdrawals, the &amp;ldquo;average&amp;rdquo; rate of return is neither simply 0.73/4 nor (1.73)^0.25-1. Rather, it is the solution (for</source>
          <target state="translated">IRR은 예를 통해 가장 잘 이해 될 수 있습니다 (아래 예 섹션의 np.irr를 사용하여 설명). 100 개 단위를 투자 한 다음 일정한 (고정 된) 간격으로 다음과 같이 인출한다고 가정하십시오. 39, 59, 55, 20. 종료 값이 0이라고 가정하면 100 개 단위의 투자 수익률은 173 개입니다. 그러나 복리와 정기 출금의 조합으로 인해 &quot;평균&quot;수익률은 단순히 0.73 / 4도 아니고 (1.73) ^ 0.25-1도 아닙니다. 오히려 그것은 해결책입니다.</target>
        </trans-unit>
        <trans-unit id="ddbfb62d79e442dbada344aa5b0b7d3f75bd62fd" translate="yes" xml:space="preserve">
          <source>The Kaiser can approximate many other windows by varying the beta parameter.</source>
          <target state="translated">카이저는 베타 매개 변수를 변경하여 다른 많은 창과 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="61a6a7b7c0a7a3c07a636b9187a5aa5c8ed22e80" translate="yes" xml:space="preserve">
          <source>The Kaiser was named for Jim Kaiser, who discovered a simple approximation to the DPSS window based on Bessel functions. The Kaiser window is a very good approximation to the Digital Prolate Spheroidal Sequence, or Slepian window, which is the transform which maximizes the energy in the main lobe of the window relative to total energy.</source>
          <target state="translated">Kaiser는 Jim Kaiser의 이름을 딴 것으로, Bessel 기능을 기반으로 DPSS 창에 대한 간단한 근사치를 발견했습니다. Kaiser 윈도우는 Digital Prolate Spheroidal Sequence 또는 Slepian 윈도우에 대한 아주 근사치입니다.이 윈도우는 전체 에너지에 대해 윈도우의 메인 로브에서 에너지를 최대화하는 변환입니다.</target>
        </trans-unit>
        <trans-unit id="3c47d6f84b8a7a5230ef01c3b24f485faf045505" translate="yes" xml:space="preserve">
          <source>The Kaiser window is a taper formed by using a Bessel function.</source>
          <target state="translated">Kaiser 창은 Bessel 기능을 사용하여 형성된 테이퍼입니다.</target>
        </trans-unit>
        <trans-unit id="d40317952ac62ac63be6a7eb42d8bb031447a844" translate="yes" xml:space="preserve">
          <source>The Kaiser window is defined as</source>
          <target state="translated">카이저 창은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="de389ba4bc7accb91ca973f3199d4d09bb36d074" translate="yes" xml:space="preserve">
          <source>The Laguerre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Laguerre 클래스는 표준 Python 숫자 메소드 '+', '-', '*', '//', '%', 'divmod', '**'및 '()'과 속성 및 &lt;code&gt;ABCPolyBase&lt;/code&gt; 설명서에 나와있는 메서드</target>
        </trans-unit>
        <trans-unit id="673da347447c32096475798f43cd3eae37f1e962" translate="yes" xml:space="preserve">
          <source>The Laguerre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Laguerre 계열 기본 다항식은 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱이 아니므 로이 함수의 결과는 직관적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="beacaa427ac9dd11f90d057bc9c94b6f47608f00" translate="yes" xml:space="preserve">
          <source>The Laplace distribution is similar to the Gaussian/normal distribution, but is sharper at the peak and has fatter tails. It represents the difference between two independent, identically distributed exponential random variables.</source>
          <target state="translated">라플라스 분포는 가우스 / 정규 분포와 유사하지만 피크에서 더 날카 로워지고 꼬리가 굵습니다. 두 개의 독립적이고 동일하게 분포 된 지수 랜덤 변수 간의 차이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9f6965544802824fa340cc542a5a8e5ec41b1a8a" translate="yes" xml:space="preserve">
          <source>The Legendre class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">Legendre 클래스는 속성 및 &lt;code&gt;ABCPolyBase&lt;/code&gt; 설명서에 나와있는 메서드</target>
        </trans-unit>
        <trans-unit id="083c119f1df4d844bfc4b2160deea854a1daea76" translate="yes" xml:space="preserve">
          <source>The Legendre series basis polynomials aren&amp;rsquo;t powers of &lt;code&gt;x&lt;/code&gt; so the results of this function may seem unintuitive.</source>
          <target state="translated">Legendre 계열 기본 다항식은 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱이 아니므 로이 함수의 결과는 직관적이지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="191a6c01d66efbf4468b0c4b76d708edbb3efb30" translate="yes" xml:space="preserve">
          <source>The Logistic distribution is used in Extreme Value problems where it can act as a mixture of Gumbel distributions, in Epidemiology, and by the World Chess Federation (FIDE) where it is used in the Elo ranking system, assuming the performance of each player is a logistically distributed random variable.</source>
          <target state="translated">로지스틱 분포는 Gumbel 분포, 역학 및 Elo 순위 시스템에서 사용되는 세계 체스 연맹 (FIDE)의 혼합 역할을 할 수있는 극한 가치 문제에 사용되며 각 플레이어의 성능이 논리적으로 분포 된 랜덤 변수.</target>
        </trans-unit>
        <trans-unit id="7e46f1b490ad93ea0aa4b70cea1c8217c1eeec4d" translate="yes" xml:space="preserve">
          <source>The Lomax or Pareto II distribution is a shifted Pareto distribution. The classical Pareto distribution can be obtained from the Lomax distribution by adding 1 and multiplying by the scale parameter &lt;code&gt;m&lt;/code&gt; (see Notes). The smallest value of the Lomax distribution is zero while for the classical Pareto distribution it is &lt;code&gt;mu&lt;/code&gt;, where the standard Pareto distribution has location &lt;code&gt;mu = 1&lt;/code&gt;. Lomax can also be considered as a simplified version of the Generalized Pareto distribution (available in SciPy), with the scale set to one and the location set to zero.</source>
          <target state="translated">Lomax 또는 Pareto II 분포는 이동 된 파레토 분포입니다. 1을 더하고 스케일 모수 &lt;code&gt;m&lt;/code&gt; 을 곱하여 Lomax 분포에서 고전적 파레토 분포를 얻을 수 있습니다 (주 참조). Lomax 분포의 최소값은 0 인 반면 고전적인 파레토 분포의 경우 &lt;code&gt;mu&lt;/code&gt; 이며 표준 파레토 분포의 위치는 &lt;code&gt;mu = 1&lt;/code&gt; 입니다. Lomax는 스케일이 1로 설정되고 위치가 0으로 설정된 일반 파레토 분포 (SciPy에서 사용 가능)의 단순화 된 버전으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="913eec14ed443e489cdc77c2f2c24950a32724fd" translate="yes" xml:space="preserve">
          <source>The MATLAB &lt;code&gt;rem&lt;/code&gt; function and or the C &lt;code&gt;%&lt;/code&gt; operator which is the complement to &lt;code&gt;int(x1 / x2)&lt;/code&gt;.</source>
          <target state="translated">MATLAB &lt;code&gt;rem&lt;/code&gt; 함수 및 / 또는 &lt;code&gt;int(x1 / x2)&lt;/code&gt; 의 보수 인 C &lt;code&gt;%&lt;/code&gt; 연산자 .</target>
        </trans-unit>
        <trans-unit id="accc4f84d711af6e82c6efbbd034211d91d17fc7" translate="yes" xml:space="preserve">
          <source>The MaskedArray class</source>
          <target state="translated">MaskedArray 클래스</target>
        </trans-unit>
        <trans-unit id="5110aa799914ad12dc0bd211beae0c5585bdbc96" translate="yes" xml:space="preserve">
          <source>The Matrix class</source>
          <target state="translated">매트릭스 클래스</target>
        </trans-unit>
        <trans-unit id="aae8587a9f8f2d6d760d4e3f9211a40fc1df3fef" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (&lt;code&gt;ndarray&lt;/code&gt;)</source>
          <target state="translated">N 차원 배열 ( &lt;code&gt;ndarray&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ebbab7ca4ee7572bcfa080543866bf18ac7ca419" translate="yes" xml:space="preserve">
          <source>The N-dimensional array (ndarray)</source>
          <target state="translated">N 차원 배열 (ndarray)</target>
        </trans-unit>
        <trans-unit id="9062ffe94800b2d5eac1ade12a3d3195e3fb90d9" translate="yes" xml:space="preserve">
          <source>The NPV of the input cash flow series &lt;code&gt;values&lt;/code&gt; at the discount &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 현금 흐름 시리즈의 NPV &lt;code&gt;values&lt;/code&gt; 할인에 &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb50b084062a9f4384d9b2a21c7bda6e285e1c12" translate="yes" xml:space="preserve">
          <source>The NumFOCUS Subcommittee is comprised of 5 persons who manage project funding that comes through NumFOCUS. It is expected that these funds will be spent in a manner that is consistent with the non-profit mission of NumFOCUS and the direction of the Project as determined by the full Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06341e3da348b45983c3d2e0a0cf15e91944f0fa" translate="yes" xml:space="preserve">
          <source>The NumPy 1.6 release includes a more primitive datetime data type than 1.7. This section documents many of the changes that have taken place.</source>
          <target state="translated">NumPy 1.6 릴리스에는 1.7보다 더 원시적 인 날짜 / 시간 데이터 유형이 포함되어 있습니다. 이 섹션에서는 발생한 많은 변경 사항에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="5b56ea0dc221ea864b938eecd7f439b2151cafda" translate="yes" xml:space="preserve">
          <source>The NumPy &lt;code&gt;histogram&lt;/code&gt; function applied to an array returns a pair of vectors: the histogram of the array and a vector of the bin edges. Beware: &lt;code&gt;matplotlib&lt;/code&gt; also has a function to build histograms (called &lt;code&gt;hist&lt;/code&gt;, as in Matlab) that differs from the one in NumPy. The main difference is that &lt;code&gt;pylab.hist&lt;/code&gt; plots the histogram automatically, while &lt;code&gt;numpy.histogram&lt;/code&gt; only generates the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7115851ea78ca88c35b2190db524dfdbfb383870" translate="yes" xml:space="preserve">
          <source>The NumPy C coding conventions are based on Python PEP-0007 by Guido van Rossum with a few added strictures. There are many C coding conventions and it must be emphasized that the primary goal of the NumPy conventions isn&amp;rsquo;t to choose the &amp;lsquo;best&amp;rsquo;, about which there is certain to be disagreement, but to achieve uniformity. Because the NumPy conventions are very close to those in PEP-0007, that PEP is used as a template below with the NumPy additions and variations in the appropriate spots.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04034fa7b7a5e94b567d768903257e06b83fadc3" translate="yes" xml:space="preserve">
          <source>The NumPy Project (The Project) is an open source software project affiliated with the 501(c)3 NumFOCUS Foundation. The goal of The Project is to develop open source software for array-based computing in Python, and in particular the &lt;code&gt;numpy&lt;/code&gt; package, along with related software such as &lt;code&gt;f2py&lt;/code&gt; and the NumPy Sphinx extensions. The Software developed by The Project is released under the BSD (or similar) open source license, developed openly and hosted on public GitHub repositories under the &lt;code&gt;numpy&lt;/code&gt; GitHub organization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318543629420726d92de226b61b0ea2568472ff7" translate="yes" xml:space="preserve">
          <source>The NumPy library contains multidimensional array and matrix data structures (you&amp;rsquo;ll find more information about this in later sections). It provides &lt;strong&gt;ndarray&lt;/strong&gt;, a homogeneous n-dimensional array object, with methods to efficiently operate on it. NumPy can be used to perform a wide variety of mathematical operations on arrays. It adds powerful data structures to Python that guarantee efficient calculations with arrays and matrices and it supplies an enormous library of high-level mathematical functions that operate on these arrays and matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22808a8257a77bd3771514110cd88913c8cbfe31" translate="yes" xml:space="preserve">
          <source>The NumPy linear algebra functions rely on BLAS and LAPACK to provide efficient low level implementations of standard linear algebra algorithms. Those libraries may be provided by NumPy itself using C versions of a subset of their reference implementations but, when possible, highly optimized libraries that take advantage of specialized processor functionality are preferred. Examples of such libraries are &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt;, MKL (TM), and ATLAS. Because those libraries are multithreaded and processor dependent, environmental variables and external packages such as &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;threadpoolctl&lt;/a&gt; may be needed to control the number of threads or specify the processor architecture.</source>
          <target state="translated">NumPy 선형 대수 함수는 표준 선형 대수 알고리즘의 효율적인 저수준 구현을 제공하기 위해 BLAS 및 LAPACK에 의존합니다. 이러한 라이브러리는 NumPy 자체에서 참조 구현의 C 버전 서브 세트를 사용하여 제공 될 수 있지만 가능하면 특수한 프로세서 기능을 이용하는 고도로 최적화 된 라이브러리가 선호됩니다. 이러한 라이브러리의 예는 &lt;a href=&quot;https://www.openblas.net/&quot;&gt;OpenBLAS&lt;/a&gt; , MKL (TM) 및 ATLAS입니다. 이러한 라이브러리는 멀티 스레드 및 프로세서에 따라 &lt;a href=&quot;https://github.com/joblib/threadpoolctl&quot;&gt;다르&lt;/a&gt; 므로 스레드 수를 제어하거나 프로세서 아키텍처를 지정하기 위해 환경 변수 및 threadpoolctl 과 같은 외부 패키지 가 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d47a0c6ae88af6350c5a45d963a159c319eddcab" translate="yes" xml:space="preserve">
          <source>The NumPy project welcomes and encourages participation by everyone. We are committed to being a community that everyone enjoys being part of. Although we may not always be able to accommodate each individual&amp;rsquo;s preferences, we try our best to treat everyone kindly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3df208d2d18d19aa23dcbfeea9ad1c54e2544eb" translate="yes" xml:space="preserve">
          <source>The NumPy source code includes an example of a custom data-type as part of its test suite. The file &lt;code&gt;_rational_tests.c.src&lt;/code&gt; in the source code directory &lt;code&gt;numpy/numpy/core/src/umath/&lt;/code&gt; contains an implementation of a data-type that represents a rational number as the ratio of two 32 bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5abe575872513074969d9820a4d531c3d12a22f7" translate="yes" xml:space="preserve">
          <source>The Pareto distribution must be greater than zero, and is unbounded above. It is also known as the &amp;ldquo;80-20 rule&amp;rdquo;. In this distribution, 80 percent of the weights are in the lowest 20 percent of the range, while the other 20 percent fill the remaining 80 percent of the range.</source>
          <target state="translated">파레토 분포는 0보다 커야하며 위에 제한이 없습니다. &quot;80-20 규칙&quot;이라고도합니다. 이 분포에서 가중치의 80 %는 범위의 가장 낮은 20 %에 있고 나머지 20 %는 나머지 80 %를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b64969899a77da87dee3d04492ed6838966132f3" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r3973533a530a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bc6e3f7c2b1acfa8159e10332ced928c3809746" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r4338a4b3d731-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5b998678bc3c838f5d54a5f0beb5816b99470d" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">이탈리아 경제학자 인 빌 프레도 파레토 (Vilfredo Pareto)의 이름을 따서 명명 된 파레토 분포는 많은 실제 문제에 유용한 권력 법 확률 분포입니다. 경제학 이외에서는 일반적으로 브래드 포드 (Bradford) 분포라고합니다. 파레토는 경제에서 부의 분배를 설명하기 위해 분배를 개발했다. 또한 보험, 웹 페이지 액세스 통계, 유전 크기 및 Sourceforge &lt;a href=&quot;#r8689274e67cd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 프로젝트의 다운로드 빈도를 포함한 기타 여러 문제에서 사용되는 것으로 나타났습니다 . 소위 &quot;팻 테일&quot;분포 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="2867a07ee69e6406fe64c658305fdda7fb7b8075" translate="yes" xml:space="preserve">
          <source>The Pareto distribution, named after the Italian economist Vilfredo Pareto, is a power law probability distribution useful in many real world problems. Outside the field of economics it is generally referred to as the Bradford distribution. Pareto developed the distribution to describe the distribution of wealth in an economy. It has also found use in insurance, web page access statistics, oil field sizes, and many other problems, including the download frequency for projects in Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. It is one of the so-called &amp;ldquo;fat-tailed&amp;rdquo; distributions.</source>
          <target state="translated">이탈리아 경제학자 인 빌 프레도 파레토 (Vilfredo Pareto)의 이름을 따서 명명 된 파레토 분포는 많은 실제 문제에 유용한 권력 법 확률 분포입니다. 경제학 이외에서는 일반적으로 브래드 포드 (Bradford) 분포라고합니다. 파레토는 경제에서 부의 분배를 설명하기 위해 분배를 개발했다. 또한 보험, 웹 페이지 액세스 통계, 유전 크기 및 Sourceforge &lt;a href=&quot;#rc338d9f74bfc-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 프로젝트의 다운로드 빈도를 포함한 기타 여러 문제에서 사용되는 것으로 나타났습니다 . 소위 &quot;팻 테일&quot;분포 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="8aa87161535a17c7b4517b9679a26277a14402b5" translate="yes" xml:space="preserve">
          <source>The Poisson distribution</source>
          <target state="translated">푸 아송 분포</target>
        </trans-unit>
        <trans-unit id="0ebdde94b2528198e1aa6a1394f362ff4a94706c" translate="yes" xml:space="preserve">
          <source>The Poisson distribution is the limit of the binomial distribution for large N.</source>
          <target state="translated">푸 아송 분포는 큰 N에 대한 이항 분포의 한계입니다.</target>
        </trans-unit>
        <trans-unit id="9280ad29766a65718d4060a0ccabd4c148a5c905" translate="yes" xml:space="preserve">
          <source>The Polynomial class provides the standard Python numerical methods &amp;lsquo;+&amp;rsquo;, &amp;lsquo;-&amp;lsquo;, &amp;lsquo;*&amp;rsquo;, &amp;lsquo;//&amp;rsquo;, &amp;lsquo;%&amp;rsquo;, &amp;lsquo;divmod&amp;rsquo;, &amp;lsquo;**&amp;rsquo;, and &amp;lsquo;()&amp;rsquo; as well as the attributes and methods listed in the &lt;code&gt;ABCPolyBase&lt;/code&gt; documentation.</source>
          <target state="translated">다항식 클래스는 속성 및 &lt;code&gt;ABCPolyBase&lt;/code&gt; 설명서에 나와있는 메서드</target>
        </trans-unit>
        <trans-unit id="ababcd2092c790cd48094defea5bb6fa5036c0d6" translate="yes" xml:space="preserve">
          <source>The Project</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd0ae31276093703b68264061cf438be92cd228" translate="yes" xml:space="preserve">
          <source>The Project Community consists of all Contributors and Users of the Project. Contributors work on behalf of and are responsible to the larger Project Community and we strive to keep the barrier between Contributors and Users as low as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d50f5379e9d76b5e7242532277a2b9c64fd49c0" translate="yes" xml:space="preserve">
          <source>The Project is developed by a team of distributed developers, called Contributors. Contributors are individuals who have contributed code, documentation, designs or other work to the Project. Anyone can be a Contributor. Contributors can be affiliated with any legal entity or none. Contributors participate in the project by submitting, reviewing and discussing GitHub Pull Requests and Issues and participating in open and public Project discussions on GitHub, mailing lists, and other channels. The foundation of Project participation is openness and transparency.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1c2647aef99f143f4382e220b44eada277008ef" translate="yes" xml:space="preserve">
          <source>The Project is formally affiliated with the 501(c)3 NumFOCUS Foundation (&lt;a href=&quot;http://numfocus.org&quot;&gt;http://numfocus.org&lt;/a&gt;), which serves as its fiscal sponsor, may hold project trademarks and other intellectual property, helps manage project donations and acts as a parent legal entity. NumFOCUS is the only legal entity that has a formal relationship with the project (see Institutional Partners section below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f211023ee392fd3cd9d9691f710a52d06a9bae2" translate="yes" xml:space="preserve">
          <source>The Project will have a Steering Council that consists of Project Contributors who have produced contributions that are substantial in quality and quantity, and sustained over at least one year. The overall role of the Council is to ensure, with input from the Community, the long-term well-being of the project, both technically and as a community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="827ba55564ba45b324c36aacf3e17c27674e9dcd" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure had no descr member at the end (and therefore no flag ARR_HAS_DESCR)</source>
          <target state="translated">PyArrayInterface 구조에는 끝에 descr 멤버가 없으므로 플래그 ARR_HAS_DESCR이 없습니다.</target>
        </trans-unit>
        <trans-unit id="41d158f9c0cb59631db3742cfa40b5047248d25c" translate="yes" xml:space="preserve">
          <source>The PyArrayInterface structure is defined in &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; as:</source>
          <target state="translated">PyArrayInterface 구조는 다음과 같이 &lt;code&gt;numpy/ndarrayobject.h&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f9e4e5af356a67d9cce5fec6bebfc002a3fe5b0" translate="yes" xml:space="preserve">
          <source>The Python exposure supplies two iteration interfaces, one which follows the Python iterator protocol, and another which mirrors the C-style do-while pattern. The native Python approach is better in most cases, but if you need the coordinates or index of an iterator, use the C-style pattern.</source>
          <target state="translated">Python 노출은 두 개의 반복 인터페이스를 제공합니다. 하나는 Python 반복자 프로토콜을 따르고 다른 하나는 C 스타일 do-while 패턴을 반영합니다. 대부분의 경우 기본 Python 접근 방식이 더 좋지만 반복자의 좌표 나 색인이 필요한 경우 C 스타일 패턴을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="52c071d4e6dd56561ca8fc870ab3c5e829454e91" translate="yes" xml:space="preserve">
          <source>The Python function &lt;code&gt;max()&lt;/code&gt; will find the maximum over a one-dimensional array, but it will do so using a slower sequence interface. The reduce method of the maximum ufunc is much faster. Also, the &lt;code&gt;max()&lt;/code&gt; method will not give answers you might expect for arrays with greater than one dimension. The reduce method of minimum also allows you to compute a total minimum over an array.</source>
          <target state="translated">파이썬 함수 &lt;code&gt;max()&lt;/code&gt; 는 1 차원 배열에서 최대 값을 찾지 만 느린 시퀀스 인터페이스를 사용하여 그렇게합니다. 최대 ufunc의 감소 방법이 훨씬 빠릅니다. 또한 &lt;code&gt;max()&lt;/code&gt; 메서드는 차원이 2보다 큰 배열에 대해 예상되는 답변을 제공하지 않습니다. 최소 축소 방법을 사용하면 배열에 대한 총 최소값을 계산할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="faf8bfa039d6b92e8c05db35a7f948162088fe3f" translate="yes" xml:space="preserve">
          <source>The Python interactive interpreter unfortunately prints out the values of expressions inside the while loop during each iteration of the loop. We have modified the output in the examples using this looping construct in order to be more readable.</source>
          <target state="translated">불행히도 파이썬 인터랙티브 인터프리터는 루프가 반복 될 때마다 while 루프 내부의 표현식 값을 출력합니다. 더 읽기 쉽게하기 위해이 반복 구조를 사용하여 예제의 출력을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="4b9b366242a59401489f5a3a46b627dbab76f505" translate="yes" xml:space="preserve">
          <source>The Python interface that we want is:</source>
          <target state="translated">우리가 원하는 Python 인터페이스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a4e789fdc99a292c8a541209ecbc17b1d6c5f8c7" translate="yes" xml:space="preserve">
          <source>The Python iterator protocol doesn&amp;rsquo;t have a natural way to query these additional values from the iterator, so we introduce an alternate syntax for iterating with an &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;. This syntax explicitly works with the iterator object itself, so its properties are readily accessible during iteration. With this looping construct, the current value is accessible by indexing into the iterator, and the index being tracked is the property &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; depending on what was requested.</source>
          <target state="translated">파이썬 반복자 프로토콜에는 반복자에서 이러한 추가 값을 쿼리하는 자연스러운 방법이 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 로 반복하는 대체 구문을 소개합니다 . 이 구문은 명시 적으로 iterator 객체 자체와 함께 작동하므로 반복 중에 속성에 쉽게 액세스 할 수 있습니다. 이 루핑 구조를 사용하면 반복기에 색인을 작성하여 현재 값에 액세스 할 수 있으며 추적되는 &lt;code&gt;index&lt;/code&gt; 은 요청 된 &lt;code&gt;multi_index&lt;/code&gt; 에 따라 특성 색인 또는 multi_index 입니다.</target>
        </trans-unit>
        <trans-unit id="6867d7144d35416337495ca1b602061770d80f10" translate="yes" xml:space="preserve">
          <source>The Python list representation of the masked array.</source>
          <target state="translated">마스크 배열의 파이썬리스트 표현.</target>
        </trans-unit>
        <trans-unit id="10730a9ceb03252e7c33bf729de07821aa7c70e5" translate="yes" xml:space="preserve">
          <source>The Python object this chunk of memory comes from. Needed so that memory can be accounted for properly.</source>
          <target state="translated">이 메모리 덩어리가 나온 파이썬 객체. 메모리를 올바르게 설명하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="0d4a1c83a85c3f9ef90edda93dbe3641642446d4" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0585dac865895f74c0e37d281119c6e2073a73" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator with a number of methods that are similar to the ones available in &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib 모듈 &quot;random&quot;에는 &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 에서 사용할 수있는 메소드와 유사한 여러 가지 메소드가있는 Mersenne Twister 의사 난수 생성기가 포함되어 있습니다 . NumPy를 인식하는 것 외에도 &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 는 훨씬 더 많은 확률 분포를 선택할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2bba830daa553cb7faa782d38dcb55b1552bd1f" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &amp;ldquo;random&amp;rdquo; also contains a Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Python stdlib 모듈&amp;ldquo;random&amp;rdquo;에는 Mersenne Twister 의사 난수 생성기가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16bb9351563ad26c9ac5328e3a25381d78f799b" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="translated">Python stdlib 모듈 &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 에는 &lt;code&gt;Generator&lt;/code&gt; 에서 사용 가능한 메소드와 유사한 여러 메소드가 포함 된 의사 난수 생성기가 포함되어 있습니다 . Mersenne Twister를 사용 &lt;code&gt;MT19937&lt;/code&gt; 비트 생성기는 MT19937을 사용하여 액세스 할 수 있습니다 . NumPy를 인식하는 것 외에도 &lt;code&gt;Generator&lt;/code&gt; 는 훨씬 더 많은 확률 분포를 선택할 수 있다는 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="da363cfdc7ce6e2caf650d00ffad698f370feca3" translate="yes" xml:space="preserve">
          <source>The Python stdlib module &lt;a href=&quot;generated/numpy.random.random#numpy.random.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; contains pseudo-random number generator with a number of methods that are similar to the ones available in &lt;code&gt;Generator&lt;/code&gt;. It uses Mersenne Twister, and this bit generator can be accessed using &lt;code&gt;MT19937&lt;/code&gt;. &lt;code&gt;Generator&lt;/code&gt;, besides being NumPy-aware, has the advantage that it provides a much larger number of probability distributions to choose from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbfe8c34ab4f057b17acc33f18a11bfdb2e17b46" translate="yes" xml:space="preserve">
          <source>The Python type of the ndarray is &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. In C, every ndarray is a pointer to a &lt;a href=&quot;#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure. The ob_type member of this structure contains a pointer to the &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; typeobject.</source>
          <target state="translated">ndarray의 Python 유형은 &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 입니다. C에서 모든 ndarray는 &lt;a href=&quot;#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 구조에 대한 포인터 입니다. 이 구조체의 ob_type 멤버는 &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 타입 객체에 대한 포인터를 포함합니다 .</target>
        </trans-unit>
        <trans-unit id="92e614f1f8b5e40429cf0717c65db8d5a132db4d" translate="yes" xml:space="preserve">
          <source>The Rayleigh distribution would arise, for example, if the East and North components of the wind velocity had identical zero-mean Gaussian distributions. Then the wind speed would have a Rayleigh distribution.</source>
          <target state="translated">예를 들어, 풍속의 동 및 북 성분이 동일한 제로 평균 가우시안 분포를 갖는 경우 레일리 분포가 발생할 수있다. 그러면 풍속은 레일리 분포를 갖게됩니다.</target>
        </trans-unit>
        <trans-unit id="d73f8fe753523f4db33185ee7a9f4cc2e7b4d46f" translate="yes" xml:space="preserve">
          <source>The SciPy Code of Conduct</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e766ac17c08bb4c8b9b072ff682fb439dd2765" translate="yes" xml:space="preserve">
          <source>The SciPy library also contains a &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;linalg&lt;/code&gt;&lt;/a&gt; submodule, and there is overlap in the functionality provided by the SciPy and NumPy submodules. SciPy contains functions not found in &lt;a href=&quot;#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, such as functions related to LU decomposition and the Schur decomposition, multiple ways of calculating the pseudoinverse, and matrix transcendentals such as the matrix logarithm. Some functions that exist in both have augmented functionality in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;. For example, &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig&quot;&gt;&lt;code&gt;scipy.linalg.eig&lt;/code&gt;&lt;/a&gt; can take a second matrix argument for solving generalized eigenvalue problems. Some functions in NumPy, however, have more flexible broadcasting options. For example, &lt;a href=&quot;generated/numpy.linalg.solve#numpy.linalg.solve&quot;&gt;&lt;code&gt;numpy.linalg.solve&lt;/code&gt;&lt;/a&gt; can handle &amp;ldquo;stacked&amp;rdquo; arrays, while &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve&quot;&gt;&lt;code&gt;scipy.linalg.solve&lt;/code&gt;&lt;/a&gt; accepts only a single square array as its first argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0175f443d47358199cf2723ff7e49526482ab828" translate="yes" xml:space="preserve">
          <source>The Simple Wrapper and Interface Generator (or &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;) is a powerful tool for generating wrapper code for interfacing to a wide variety of scripting languages. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; can parse header files, and using only the code prototypes, create an interface to the target language. But &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; is not omnipotent. For example, it cannot know from the prototype:</source>
          <target state="translated">단순 래퍼 및 인터페이스 생성기 (또는 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; )는 다양한 스크립팅 언어와 인터페이스하기위한 래퍼 코드를 생성하는 강력한 도구입니다. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는 헤더 파일을 구문 분석하고 코드 프로토 타입 만 사용하여 대상 언어에 대한 인터페이스를 만듭니다. 그러나 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는 전능하지 않습니다. 예를 들어, 프로토 타입에서 알 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="50fd73730ba7e10c720fa72fd00d9f7e0810994f" translate="yes" xml:space="preserve">
          <source>The Steering Council and its Members play a special role in certain situations. In particular, the Council may, if necessary:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd611f012e4b731c3416db83b8b9fa4821f6de96" translate="yes" xml:space="preserve">
          <source>The Steering Council are the primary leadership for the project. No outside institution, individual or legal entity has the ability to own, control, usurp or influence the project other than by participating in the Project as Contributors and Council Members. However, because institutions can be an important funding mechanism for the project, it is important to formally acknowledge institutional participation in the project. These are Institutional Partners.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3486112e5f71acaa9b7cc7fff52d1dbfa7f50dd3" translate="yes" xml:space="preserve">
          <source>The Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where the last index is the power of &lt;code&gt;x&lt;/code&gt;. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Vandermonde 매트릭스. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 인덱스는 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱입니다 . dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="39a7c567f58b9f21ca516451a55bb90e053dd395" translate="yes" xml:space="preserve">
          <source>The Weibull (or Type III asymptotic extreme value distribution for smallest values, SEV Type III, or Rosin-Rammler distribution) is one of a class of Generalized Extreme Value (GEV) distributions used in modeling extreme value problems. This class includes the Gumbel and Frechet distributions.</source>
          <target state="translated">Weibull (또는 최소값에 대한 Type III 점근 극값 분포, SEV Type III 또는 Rosin-Rammler 분포)은 극단 값 문제를 모델링하는 데 사용되는 GEV (Generalized Extreme Value) 분포 중 하나입니다. 이 클래스에는 Gumbel 및 Frechet 배포판이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="201b34b560ffa9f638b13b95cb2b860322d162bb" translate="yes" xml:space="preserve">
          <source>The Zipf distribution (also known as the zeta distribution) is a continuous probability distribution that satisfies Zipf&amp;rsquo;s law: the frequency of an item is inversely proportional to its rank in a frequency table.</source>
          <target state="translated">Zipf 분포 (제타 분포라고도 함)는 Zipf의 법칙을 만족하는 연속 확률 분포입니다. 항목의 빈도는 빈도 표의 순위에 반비례합니다.</target>
        </trans-unit>
        <trans-unit id="9f96ae0b2c3d21dc0c18c679782e710a2d562c21" translate="yes" xml:space="preserve">
          <source>The __array_finalize__ method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8acfe985a2bfa5e5957d0281e0418889b56a0c2" translate="yes" xml:space="preserve">
          <source>The __array_priority__ attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c8638dacd7dbc859e55b29c8e0ee5d2ee1f9573" translate="yes" xml:space="preserve">
          <source>The __array_wrap__ method</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb048510e93bd94f0172757e215cb9cb29cef573" translate="yes" xml:space="preserve">
          <source>The ability to be used as a context manager is new in NumPy v1.11.0.</source>
          <target state="translated">NumPy v1.11.0에서는 컨텍스트 관리자로 사용할 수있는 기능이 새로 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="10ff963859461b5262a67238fd0cc7b697172b26" translate="yes" xml:space="preserve">
          <source>The above does not hold for in-place operators, for which &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; never returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;. Hence, &lt;code&gt;arr += obj&lt;/code&gt; would always lead to a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is because for arrays in-place operations cannot generically be replaced by a simple reverse operation. (For instance, by default, &lt;code&gt;arr += obj&lt;/code&gt; would be translated to &lt;code&gt;arr =
arr + obj&lt;/code&gt;, i.e., &lt;code&gt;arr&lt;/code&gt; would be replaced, contrary to what is expected for in-place array operations.)</source>
          <target state="translated">위는있는, 현재 위치에서 운영자 보유하지 않는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 반환하지 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 을&lt;/a&gt; . 따라서 &lt;code&gt;arr += obj&lt;/code&gt; 는 항상 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 로 이어&lt;/a&gt; 집니다. 배열의 경우 내부 작업은 일반적으로 간단한 역 작업으로 대체 할 수 없기 때문입니다. 예를 들어, 기본적으로 &lt;code&gt;arr += obj&lt;/code&gt; 는 &lt;code&gt;arr = arr + obj&lt;/code&gt; 로 변환됩니다 . 즉, 내부 배열 조작에 예상되는 것과 반대로 &lt;code&gt;arr&lt;/code&gt; 이 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="68e86910bcee8988f5fee730ecb24162fd22e6a7" translate="yes" xml:space="preserve">
          <source>The above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, so that &lt;code&gt;allclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;allclose(b, a)&lt;/code&gt; in some rare cases.</source>
          <target state="translated">위의 방정식에서 대칭 아니다 및 &lt;code&gt;b&lt;/code&gt; 그래서, &lt;code&gt;allclose(a, b)&lt;/code&gt; 상이 할 수있다 &lt;code&gt;allclose(b, a)&lt;/code&gt; 간혹. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6185045f653324c861d3553f34d55db24911888b" translate="yes" xml:space="preserve">
          <source>The above is &lt;strong&gt;not&lt;/strong&gt; true for advanced indexing.</source>
          <target state="translated">위의 고급 인덱싱 &lt;strong&gt;에는&lt;/strong&gt; 해당 &lt;strong&gt;되지 않습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="21db79b1f2f5936ea0ef3cfbbfc9697c308c56be" translate="yes" xml:space="preserve">
          <source>The above rules may be clearer in the following template source example:</source>
          <target state="translated">위의 규칙은 다음 템플릿 소스 예에서 더 명확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbd30ffed27aefb02b7cc5cbecba164ede0884a8" translate="yes" xml:space="preserve">
          <source>The absolute tolerance parameter (see Notes).</source>
          <target state="translated">절대 공차 매개 변수 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="b410151dc56a82d87375b78c87d1aad1438a967a" translate="yes" xml:space="preserve">
          <source>The absolute values of &lt;code&gt;x&lt;/code&gt;, the returned values are always floats. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 절대 값은 반환 된 값이 항상 부동입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a714cd42c4750db7daf108e375247bf95502ae46" translate="yes" xml:space="preserve">
          <source>The accumulate function is very similar to the reduce function in that the output and the second input both point to the output. The difference is that the second input points to memory one stride behind the current output pointer. Thus, the operation performed is</source>
          <target state="translated">누적 기능은 출력과 두 번째 입력이 모두 출력을 가리키는 점에서 감소 기능과 매우 유사합니다. 차이점은 두 번째 입력이 현재 출력 포인터 뒤에있는 메모리를 가리키는 점입니다. 따라서 수행되는 작업은</target>
        </trans-unit>
        <trans-unit id="09fde86411dc88385ee0c9001b20e47aa778341c" translate="yes" xml:space="preserve">
          <source>The accumulated values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">누적 된 값. 경우 &lt;code&gt;out&lt;/code&gt; 공급하고, &lt;code&gt;r&lt;/code&gt; 참조 인 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea47ba00873e187022bea737541efbc8a18ba099" translate="yes" xml:space="preserve">
          <source>The actual object to check.</source>
          <target state="translated">확인할 실제 객체.</target>
        </trans-unit>
        <trans-unit id="2c2156efeae8cdcc13e079cd68ed8ee62442ae55" translate="yes" xml:space="preserve">
          <source>The actual testing takes place with a Python script named:</source>
          <target state="translated">실제 테스트는 다음과 같은 Python 스크립트로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b137bb987f3be59004e7fe6c03cebc2b50e503bc" translate="yes" xml:space="preserve">
          <source>The addition of an &lt;code&gt;axis&lt;/code&gt; keyword argument to methods such as &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;Generator.choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; improves support for sampling from and shuffling multi-dimensional arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e611ef52ce3f87e2cae1cb595f38cf187d2711d5" translate="yes" xml:space="preserve">
          <source>The advanced indexes are all next to each other. For example &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; but &lt;em&gt;not&lt;/em&gt;&lt;code&gt;x[arr1, :, 1]&lt;/code&gt; since &lt;code&gt;1&lt;/code&gt; is an advanced index in this regard.</source>
          <target state="translated">고급 인덱스는 모두 서로 옆에 있습니다. 예를 들어 &lt;code&gt;x[..., arr1, arr2, :]&lt;/code&gt; 하지만 &lt;em&gt;하지 &lt;/em&gt; &lt;code&gt;x[arr1, :, 1]&lt;/code&gt; 사람 &lt;code&gt;1&lt;/code&gt; 이 점에서 고급 인덱스이다.</target>
        </trans-unit>
        <trans-unit id="31c1e1991e0db334efbc077fcf4425ba78851bf7" translate="yes" xml:space="preserve">
          <source>The advanced indexes are separated by a slice, &lt;code&gt;Ellipsis&lt;/code&gt; or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;. For example &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt;.</source>
          <target state="translated">고급 인덱스는 슬라이스, &lt;code&gt;Ellipsis&lt;/code&gt; 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 로 구분됩니다 . 예를 들어 &lt;code&gt;x[arr1, :, arr2]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0943937a225e08eb4e31b510a59e3603b58c132" translate="yes" xml:space="preserve">
          <source>The advantage of the hand-generated wrapper is that you have complete control over how the C-library gets used and called which can lead to a lean and tight interface with minimal over-head. The disadvantage is that you have to write, debug, and maintain C-code, although most of it can be adapted using the time-honored technique of &amp;ldquo;cutting-pasting-and-modifying&amp;rdquo; from other extension modules. Because, the procedure of calling out to additional C-code is fairly regimented, code-generation procedures have been developed to make this process easier. One of these code-generation techniques is distributed with NumPy and allows easy integration with Fortran and (simple) C code. This package, f2py, will be covered briefly in the next section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d764668c927e5f32ce22801332fbd537f1d04076" translate="yes" xml:space="preserve">
          <source>The advantage of this creation function is that one can guarantee the number of elements and the starting and end point, which arange() generally will not do for arbitrary start, stop, and step values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51620b35cf3af304da0134bf0e98ad6e2d38905c" translate="yes" xml:space="preserve">
          <source>The advantage of this version of reduce compared to the normal ufunc.reduce is that it makes use of the &lt;a href=&quot;tentative_numpy_tutorial#head-c43f3f81719d84f09ae2b33a22eaf50b26333db8&quot;&gt;Broadcasting Rules&lt;/a&gt; in order to avoid creating an argument array the size of the output times the number of vectors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbeaf56d095a4acc2c96fd5080608f5dcf659b8a" translate="yes" xml:space="preserve">
          <source>The advantages over random generation include tools to replay and share failures without requiring a fixed seed, reporting &lt;em&gt;minimal&lt;/em&gt; examples for each failure, and better-than-naive-random techniques for triggering bugs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e14666a8704d081387416d669f25517240f5f545" translate="yes" xml:space="preserve">
          <source>The aim of this document is to describe how to add new tools to SciPy.</source>
          <target state="translated">이 문서의 목적은 SciPy에 새로운 도구를 추가하는 방법을 설명하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ddbe83e4c507cabc5c6e4f89a6b5af846c612df5" translate="yes" xml:space="preserve">
          <source>The algorithm is carefully designed to eliminate a number of possible ways to collide. For example, if one only does one level of spawning, it is guaranteed that all states will be unique. But it&amp;rsquo;s easier to estimate the naive upper bound on a napkin and take comfort knowing that the probability is actually lower.</source>
          <target state="translated">알고리즘은 충돌 가능한 여러 가지 방법을 제거하도록 신중하게 설계되었습니다. 예를 들어, 한 레벨의 스폰 만 수행하는 경우 모든 상태가 고유해야합니다. 그러나 냅킨의 순한 상한을 추정하고 확률이 실제로 낮다는 것을 알고 편안하게 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b40688fb93dbcbc32e9b43e4ccf1abfa448a2d" translate="yes" xml:space="preserve">
          <source>The algorithm relies on computing the eigenvalues of the companion matrix &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">이 알고리즘은 컴패니언 행렬의 고유 값 계산에 의존합니다 &lt;a href=&quot;#r01a8f58ef25b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd22305ce6ff69cc69c0e35a34dfdaaddbe6b6d" translate="yes" xml:space="preserve">
          <source>The algorithm works by first finding a &amp;ldquo;running dimension&amp;rdquo;, along which the blocks will be extracted. Given an array of dimensions &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt;, e.g. if &lt;code&gt;buf_size&lt;/code&gt; is smaller than &lt;code&gt;d1&lt;/code&gt;, the first dimension will be used. If, on the other hand, &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; the second dimension will be used, and so on. Blocks are extracted along this dimension, and when the last block is returned the process continues from the next dimension, until all elements have been read.</source>
          <target state="translated">이 알고리즘은 블록이 추출 될 &quot;실행 치수&quot;를 먼저 찾아서 작동합니다. 예를 들어 &lt;code&gt;buf_size&lt;/code&gt; 가 &lt;code&gt;d1&lt;/code&gt; 보다 작은 경우 차원 배열 &lt;code&gt;(d1, d2, ..., dn)&lt;/code&gt; 주어지면 첫 번째 차원이 사용됩니다. 반면에 &lt;code&gt;d1 &amp;lt; buf_size &amp;lt; d1*d2&lt;/code&gt; 이면 두 번째 차원이 사용됩니다. 이 차원을 따라 블록이 추출되고 마지막 블록이 리턴되면 프로세스는 다음 요소부터 모든 요소를 ​​읽을 때까지 계속됩니다.</target>
        </trans-unit>
        <trans-unit id="bddd09a9de7b4e7a6ce50c8c2ab936314f5f7ae0" translate="yes" xml:space="preserve">
          <source>The angle of the ray intersecting the unit circle at the given &lt;code&gt;x&lt;/code&gt;-coordinate in radians [0, pi]. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">주어진 &lt;code&gt;x&lt;/code&gt; 좌표에서 단위 원과 교차하는 광선의 각도 ( 라디안 [0, pi]). &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a13da23a8343744c8c54019aa364c899333968f0" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be filled by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반 대각선은 &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; 을&lt;/a&gt; 사용하여 요소의 순서를 반대로하여 채울 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="900a13fc7d937db8f345df515885761fbb0acd80" translate="yes" xml:space="preserve">
          <source>The anti-diagonal can be obtained by reversing the order of elements using either &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt;&lt;code&gt;numpy.flipud&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt;&lt;code&gt;numpy.fliplr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반 대각선은 &lt;a href=&quot;numpy.flipud#numpy.flipud&quot;&gt; &lt;code&gt;numpy.flipud&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.fliplr#numpy.fliplr&quot;&gt; &lt;code&gt;numpy.fliplr&lt;/code&gt; 을&lt;/a&gt; 사용하여 요소의 순서를 반대로하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bdd6673496c6fd17d43bfb63694d67b1a23e7074" translate="yes" xml:space="preserve">
          <source>The approximate decimal resolution of this type, i.e., &lt;code&gt;10**-precision&lt;/code&gt;.</source>
          <target state="translated">이 유형의 대략적인 10 진수 해상도, 즉 &lt;code&gt;10**-precision&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a6b2d49779da2fb225e5136c9ad3c68e119d3fee" translate="yes" xml:space="preserve">
          <source>The approximate number of decimal digits to which this kind of float is precise.</source>
          <target state="translated">이러한 종류의 부동 소수점이 정확한 대략의 십진수입니다.</target>
        </trans-unit>
        <trans-unit id="179dbf39b5fae7c06c4d27f6dfe6017b20eda9b8" translate="yes" xml:space="preserve">
          <source>The argument is considered as a return variable. It is appended to the &lt;code&gt;&amp;lt;returned variables&amp;gt;&lt;/code&gt; list. Using &lt;code&gt;intent(out)&lt;/code&gt; sets &lt;code&gt;intent(hide)&lt;/code&gt; automatically, unless also &lt;code&gt;intent(in)&lt;/code&gt; or &lt;code&gt;intent(inout)&lt;/code&gt; were used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c118204e070c804541b682daff7d70c7213a6696" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input-only argument. It means that the value of the argument is passed to Fortran/C function and that function is expected not to change the value of an argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7586639cfc35e105e2ea737d69664cf533fb71d1" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inout)&lt;/code&gt; arguments can be only &amp;ldquo;contiguous&amp;rdquo; NumPy arrays with proper type and size. Here &amp;ldquo;contiguous&amp;rdquo; can be either in Fortran or C sense. The latter one coincides with the contiguous concept used in NumPy and is effective only if &lt;code&gt;intent(c)&lt;/code&gt; is used. Fortran contiguity is assumed by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958b7637686a26352441daf916242ddf2818e972" translate="yes" xml:space="preserve">
          <source>The argument is considered as an input/output or &lt;em&gt;in situ&lt;/em&gt; output argument. &lt;code&gt;intent(inplace)&lt;/code&gt; arguments must be NumPy arrays with proper size. If the type of an array is not &amp;ldquo;proper&amp;rdquo; or the array is non-contiguous then the array will be changed in-place to fix the type and make it contiguous.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f19b8026a1e189b122954edffa090fdbeb3a72f0" translate="yes" xml:space="preserve">
          <source>The argument is removed from the list of required or optional arguments. Typically &lt;code&gt;intent(hide)&lt;/code&gt; is used with &lt;code&gt;intent(out)&lt;/code&gt; or when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; completely determines the value of the argument like in the following example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898b40f4d53206c78d6c1d07150f357243064d8d" translate="yes" xml:space="preserve">
          <source>The argument is treated as a C scalar or C array argument. In the case of a scalar argument, its value is passed to C function as a C scalar argument (recall that Fortran scalar arguments are actually C pointer arguments). In the case of an array argument, the wrapper function is assumed to treat multidimensional arrays as C-contiguous arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f859808cd7ae59bcb9315c9be074383ed18866fa" translate="yes" xml:space="preserve">
          <source>The argument is treated as a junk of memory. No Fortran nor C contiguity checks are carried out. Using &lt;code&gt;intent(cache)&lt;/code&gt; makes sense only for array arguments, also in connection with &lt;code&gt;intent(hide)&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fe8c5bbb5b2bd70ddad0ccf0217bddc268f6835" translate="yes" xml:space="preserve">
          <source>The arguments &lt;code&gt;ngood&lt;/code&gt; and &lt;code&gt;nbad&lt;/code&gt; each must be less than &lt;code&gt;10**9&lt;/code&gt;. For extremely large arguments, the algorithm that is used to compute the samples &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; breaks down because of loss of precision in floating point calculations. For such large values, if &lt;code&gt;nsample&lt;/code&gt; is not also large, the distribution can be approximated with the binomial distribution, &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;ngood&lt;/code&gt; 및 &lt;code&gt;nbad&lt;/code&gt; 는 각각 &lt;code&gt;10**9&lt;/code&gt; 보다 작아야합니다 . 매우 큰 인수의 경우 샘플 &lt;a href=&quot;#r688e4aa3bfc3-4&quot; id=&quot;id1&quot;&gt;[4]&lt;/a&gt; 를 계산하는 데 사용되는 알고리즘 은 부동 소수점 계산의 정밀도 손실로 인해 분해됩니다. 이러한 큰 값의 경우 &lt;code&gt;nsample&lt;/code&gt; 이 크지 않은 경우 이항 분포 이항 분포 &lt;code&gt;binomial(n=nsample, p=ngood/(ngood + nbad))&lt;/code&gt; 분포를 근사 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2d355dbffda7b60d25c8fd14c77261de1c537b59" translate="yes" xml:space="preserve">
          <source>The arguments of the &lt;code&gt;configuration&lt;/code&gt; function specify the name of parent SciPy package (&lt;code&gt;parent_package&lt;/code&gt;) and the directory location of the main &lt;code&gt;setup.py&lt;/code&gt; script (&lt;code&gt;top_path&lt;/code&gt;). These arguments, along with the name of the current package, should be passed to the &lt;code&gt;Configuration&lt;/code&gt; constructor.</source>
          <target state="translated">&lt;code&gt;configuration&lt;/code&gt; 함수 의 인수는 상위 SciPy 패키지 이름 ( &lt;code&gt;parent_package&lt;/code&gt; ) 및 기본 &lt;code&gt;setup.py&lt;/code&gt; 스크립트 의 디렉토리 위치 ( &lt;code&gt;top_path&lt;/code&gt; )를 지정합니다. 이러한 인수는 현재 패키지의 이름과 함께 &lt;code&gt;Configuration&lt;/code&gt; 생성자 로 전달되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="5e50719893eed3edf2e32e25c59bbd130545cd4a" translate="yes" xml:space="preserve">
          <source>The arguments that &lt;code&gt;__array_finalize__&lt;/code&gt; receives differ for the three methods of instance creation above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b1212b40ba5f9b8205d7b64e2e9c20d35b415b3" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the elements along the axis divided by the number of elements.</source>
          <target state="translated">산술 평균은 축을 따라 요소의 합을 요소 수로 나눈 값입니다.</target>
        </trans-unit>
        <trans-unit id="149dc5ada110e245afebc011f82badc7bfaf2c21" translate="yes" xml:space="preserve">
          <source>The arithmetic mean is the sum of the non-NaN elements along the axis divided by the number of non-NaN elements.</source>
          <target state="translated">산술 평균은 축을 따라 비 NaN 요소의 합을 비 NaN 요소의 수로 나눈 값입니다.</target>
        </trans-unit>
        <trans-unit id="893ac85ca56066bc9e23a82ef1519d73c4482726" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent and &lt;code&gt;a&lt;/code&gt; can be diagonalized by a similarity transformation using &lt;code&gt;v&lt;/code&gt;, i.e, &lt;code&gt;inv(v) @ a @ v&lt;/code&gt; is diagonal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a686d6fd794f1b48b235aeae1a3e22a10c775aa4" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;v&lt;/code&gt; of eigenvectors may not be of maximum rank, that is, some of the columns may be linearly dependent, although round-off error may obscure that fact. If the eigenvalues are all different, then theoretically the eigenvectors are linearly independent. Likewise, the (complex-valued) matrix of eigenvectors &lt;code&gt;v&lt;/code&gt; is unitary if the matrix &lt;code&gt;a&lt;/code&gt; is normal, i.e., if &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt;, where &lt;code&gt;a.H&lt;/code&gt; denotes the conjugate transpose of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">고유 벡터 의 배열 &lt;code&gt;v&lt;/code&gt; 는 최대 순위가 아닐 수 있습니다. 즉, 반올림 오차가 그 사실을 모호하게 할 수 있지만 일부 열은 선형으로 종속 될 수 있습니다. 고유 값이 모두 다르면 이론적으로 고유 벡터는 선형 적으로 독립적입니다. 마찬가지로, 고유 벡터 &lt;code&gt;v&lt;/code&gt; 의 (복합 값) 행렬은 행렬 &lt;code&gt;a&lt;/code&gt; 가 정상인 경우, 즉 &lt;code&gt;dot(a, a.H) = dot(a.H, a)&lt;/code&gt; 인 경우에 단일 이며, 여기서 &lt;code&gt;a.H&lt;/code&gt; 는 &lt;code&gt;a&lt;/code&gt; 의 켤레 전치를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="539630988d5b7ef9eff53456e4a77b468fdbbd35" translate="yes" xml:space="preserve">
          <source>The array &lt;code&gt;x&lt;/code&gt; is prefilled with its filling value.</source>
          <target state="translated">배열 &lt;code&gt;x&lt;/code&gt; 는 충전 값으로 미리 채워져 있습니다.</target>
        </trans-unit>
        <trans-unit id="048ae46227673b90cff5c0388062d4ed48f2b030" translate="yes" xml:space="preserve">
          <source>The array assembled from the given blocks.</source>
          <target state="translated">주어진 블록으로 구성된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f6532b7ade94739e158787e37c1d9655afff859b" translate="yes" xml:space="preserve">
          <source>The array can be indexed using Python container-like syntax:</source>
          <target state="translated">배열은 Python 컨테이너와 같은 구문을 사용하여 색인을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b308d78b11f2c07c75c1db0756393dc3ae53a1" translate="yes" xml:space="preserve">
          <source>The array data-type or scalar for which the default fill value is returned.</source>
          <target state="translated">기본 채우기 값이 반환되는 배열 데이터 유형 또는 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3821c84ea0df179e936beb82ec9c4a845023032b" translate="yes" xml:space="preserve">
          <source>The array element of the current iteration.</source>
          <target state="translated">현재 반복의 배열 요소입니다.</target>
        </trans-unit>
        <trans-unit id="930ed301b34bfc297be655fe9a537d3e2971d137" translate="yes" xml:space="preserve">
          <source>The array flags cannot be set arbitrarily:</source>
          <target state="translated">배열 플래그는 임의로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="67bdbd5d8bcbe5caab95cc4d4f8dabba43280775" translate="yes" xml:space="preserve">
          <source>The array for which the string representation of the pickle is returned.</source>
          <target state="translated">피클의 문자열 표현이 반환되는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2a33c6111cdd8f36d42a5e94437f624d1b58746f" translate="yes" xml:space="preserve">
          <source>The array for which to count non-zeros.</source>
          <target state="translated">0이 아닌 값을 계산할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ceccbd318dae2746e4f8b98dac923588a6a52441" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 2-D.</source>
          <target state="translated">주어진 배열을 쌓아서 만든 배열은 최소한 2 차원입니다.</target>
        </trans-unit>
        <trans-unit id="2568bf2e437e715b60f945dc9695881ce8ef667f" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays, will be at least 3-D.</source>
          <target state="translated">주어진 배열을 쌓아서 만든 배열은 최소한 3D입니다.</target>
        </trans-unit>
        <trans-unit id="b2c061ec289a87d3c0d4e9e7c64e5126014d42ed" translate="yes" xml:space="preserve">
          <source>The array formed by stacking the given arrays.</source>
          <target state="translated">주어진 배열을 쌓아서 배열.</target>
        </trans-unit>
        <trans-unit id="8e505b1ebbfcf9d9aa6a8f699f88f4ba40304f40" translate="yes" xml:space="preserve">
          <source>The array from which values are copied.</source>
          <target state="translated">값이 복사되는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2d987760deb151bcafba733adc9b3a186c4d7f93" translate="yes" xml:space="preserve">
          <source>The array function protocol which allows array-like objects to hook into the NumPy API is currently enabled by default. This option exists since NumPy 1.16 and is enabled by default since NumPy 1.17. It can be disabled using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c8fb39bbbe950fa5ba32f6dec4764ff1752adf1" translate="yes" xml:space="preserve">
          <source>The array h contains the Householder reflectors that generate q along with r. The tau array contains scaling factors for the reflectors. In the deprecated &amp;lsquo;economic&amp;rsquo; mode only h is returned.</source>
          <target state="translated">배열 h에는 r과 함께 q를 생성하는 가정용 반사기가 포함되어 있습니다. tau 배열은 반사경의 스케일링 계수를 포함합니다. 더 이상 사용되지 않는 '경제적'모드에서는 h 만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2932d4203636051c0cde3cab914ac5caf308f90" translate="yes" xml:space="preserve">
          <source>The array interface (sometimes called array protocol) was created in 2005 as a means for array-like Python objects to re-use each other&amp;rsquo;s data buffers intelligently whenever possible. The homogeneous N-dimensional array interface is a default mechanism for objects to share N-dimensional array memory and information. The interface consists of a Python-side and a C-side using two attributes. Objects wishing to be considered an N-dimensional array in application code should support at least one of these attributes. Objects wishing to support an N-dimensional array in application code should look for at least one of these attributes and use the information provided appropriately.</source>
          <target state="translated">배열 인터페이스 (때때로 배열 프로토콜이라고도 함)는 배열 형 파이썬 객체가 가능할 때마다 서로의 데이터 버퍼를 지능적으로 재사용하는 수단으로 2005 년에 만들어졌습니다. 동종 N 차원 배열 인터페이스는 객체가 N 차원 배열 메모리와 정보를 공유하는 기본 메커니즘입니다. 인터페이스는 두 개의 속성을 사용하는 Python 측과 C 측으로 구성됩니다. 응용 프로그램 코드에서 N 차원 배열로 간주 되려는 개체는 이러한 특성 중 하나 이상을 지원해야합니다. 응용 프로그램 코드에서 N 차원 배열을 지원하려는 오브젝트는 이러한 속성 중 하나 이상을 찾아서 제공된 정보를 적절하게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3b7adbdac3eaf5c6305f1f61b91018f4287bec67" translate="yes" xml:space="preserve">
          <source>The array into which values are copied.</source>
          <target state="translated">값이 복사되는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="8a281d694c98742955f6444ee26a08d74603ea7a" translate="yes" xml:space="preserve">
          <source>The array is filled with a fill value before the string conversion.</source>
          <target state="translated">배열은 문자열 변환 전에 채우기 값으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="fba8708c42061e69f757d72f0e5d1d004653f4bc" translate="yes" xml:space="preserve">
          <source>The array is rotated in the plane defined by the axes. Axes must be different.</source>
          <target state="translated">축이 정의한 평면에서 배열이 회전합니다. 도끼가 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="9a1223a8243cbae9aaa7753c7ea500a550cf52c0" translate="yes" xml:space="preserve">
          <source>The array iterator encapsulates many of the key features in ufuncs, allowing user code to support features like output parameters, preservation of memory layouts, and buffering of data with the wrong alignment or type, without requiring difficult coding.</source>
          <target state="translated">배열 반복자는 ufuncs의 많은 주요 기능을 캡슐화하여 사용자 코드가 어려운 코딩 없이도 출력 매개 변수, 메모리 레이아웃 보존 및 잘못된 정렬 또는 유형으로 데이터 버퍼링과 같은 기능을 지원할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6e1241b8c7d132ea91621f870c2bd3aaf572b4c" translate="yes" xml:space="preserve">
          <source>The array may be recreated via &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt;, although this may sometimes lose precision.</source>
          <target state="translated">배열은 때때로 &lt;code&gt;a = np.array(a.tolist())&lt;/code&gt; 정밀도를 잃을 수 있지만 a = np.array (a.tolist ()) 를 통해 다시 생성 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1eee9d9d69514705c81523ac5b902691363a28a0" translate="yes" xml:space="preserve">
          <source>The array of UTC timestamps to format.</source>
          <target state="translated">포맷 할 UTC 타임 스탬프의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c75d57d539a00e02934380f0ab251d1c277b5e1c" translate="yes" xml:space="preserve">
          <source>The array of dates to process.</source>
          <target state="translated">처리 할 날짜 배열입니다.</target>
        </trans-unit>
        <trans-unit id="cc2f192e213603a4bcf402844b3339c10f79380e" translate="yes" xml:space="preserve">
          <source>The array of numbers for which the absolute values are required. If &lt;code&gt;x&lt;/code&gt; is a scalar, the result &lt;code&gt;y&lt;/code&gt; will also be a scalar.</source>
          <target state="translated">절대 값이 필요한 숫자의 배열입니다. 경우에 &lt;code&gt;x&lt;/code&gt; 는 스칼라이고, 결과 &lt;code&gt;y&lt;/code&gt; 또한 라 할 것이다.</target>
        </trans-unit>
        <trans-unit id="f9c4960d6bbbc8f2591cc039cfe68db4d8e24d90" translate="yes" xml:space="preserve">
          <source>The array of offsets, which is broadcast with &lt;code&gt;dates&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dates&lt;/code&gt; 와 함께 브로드 캐스트되는 오프셋 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="2d674fe1383c12f697c52fd3b5198eb57b81bcb7" translate="yes" xml:space="preserve">
          <source>The array of rounded numbers</source>
          <target state="translated">반올림 된 숫자의 배열</target>
        </trans-unit>
        <trans-unit id="202adb7679573040b63e561db69df0e93b9eb75e" translate="yes" xml:space="preserve">
          <source>The array of the end dates for counting, which are excluded from the count themselves.</source>
          <target state="translated">계산 종료 날짜의 배열로, 카운트 자체에서 제외됩니다.</target>
        </trans-unit>
        <trans-unit id="f508cbbca81c78d6c3819b4c01ca29622bef56f6" translate="yes" xml:space="preserve">
          <source>The array of the first dates for counting.</source>
          <target state="translated">계산할 첫 번째 날짜의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a4e03a6eeebaef72c6a7e32f280b123bbf142ff2" translate="yes" xml:space="preserve">
          <source>The array or list to be shuffled.</source>
          <target state="translated">섞을 배열 또는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="1f6abc9406bedaa275a3843a6290b585462b97a3" translate="yes" xml:space="preserve">
          <source>The array or matrix to be repeated.</source>
          <target state="translated">반복 할 배열 또는 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="53aead7fb32cb3de7311369b48d13d4953d0adc5" translate="yes" xml:space="preserve">
          <source>The array owns the memory it uses or borrows it from another object.</source>
          <target state="translated">배열은 사용하는 메모리를 소유하거나 다른 객체에서 빌려옵니다.</target>
        </trans-unit>
        <trans-unit id="8abf01fdd64396d234195c26c60e850e4a12a8d7" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="translated">배열 스칼라 오브젝트의 &lt;code&gt;array priority&lt;/code&gt; 는 &lt;a href=&quot;c-api.array#c.NPY_SCALAR_PRIORITY&quot;&gt; &lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt; &lt;/a&gt; (-1,000,000.0)입니다. 또한 &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; 속성 이 없습니다 (아직) . 그렇지 않으면 배열과 동일한 속성을 공유합니다.</target>
        </trans-unit>
        <trans-unit id="5774b39bb119ab7d3a197a6eee5e164f12892112" translate="yes" xml:space="preserve">
          <source>The array scalar objects have an &lt;code&gt;array priority&lt;/code&gt; of &lt;a href=&quot;c-api/array#c.NPY_SCALAR_PRIORITY&quot;&gt;&lt;code&gt;NPY_SCALAR_PRIORITY&lt;/code&gt;&lt;/a&gt; (-1,000,000.0). They also do not (yet) have a &lt;a href=&quot;generated/numpy.ndarray.ctypes#numpy.ndarray.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt; attribute. Otherwise, they share the same attributes as arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c0162c81e2783b3bcbb0dd799de5c3ba91aba6a" translate="yes" xml:space="preserve">
          <source>The array scalars also offer the same methods and attributes as arrays with the intent that the same code can be used to support arbitrary dimensions (including 0-dimensions). The array scalars are read-only (immutable) with the exception of the void scalar which can also be written to so that structured array field setting works more naturally (a[0][&amp;lsquo;f1&amp;rsquo;] = &lt;code&gt;value&lt;/code&gt; ).</source>
          <target state="translated">또한 배열 스칼라는 동일한 코드를 사용하여 임의의 차원 (0 차원 포함)을 지원할 수 있도록 배열과 동일한 방법과 속성을 제공합니다. 배열 스칼라는 구조화 된 배열 필드 설정이보다 자연스럽게 작동하도록 기록 될 수있는 void 스칼라를 제외하고 읽기 전용 (불변)입니다 (a [0] [ 'f1'] = &lt;code&gt;value&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d0afa5fdfdf427a8322c75c5712091eca91eabac" translate="yes" xml:space="preserve">
          <source>The array scalars offer a hierarchy of Python types that allow a one- to-one correspondence between the data-type stored in an array and the Python-type that is returned when an element is extracted from the array. An exception to this rule was made with object arrays. Object arrays are heterogeneous collections of arbitrary Python objects. When you select an item from an object array, you get back the original Python object (and not an object array scalar which does exist but is rarely used for practical purposes).</source>
          <target state="translated">배열 스칼라는 배열에 저장된 데이터 유형과 배열에서 요소를 추출 할 때 리턴되는 Python 유형 사이의 일대일 대응을 허용하는 Python 유형의 계층 구조를 제공합니다. 이 규칙에 대한 예외는 객체 배열에서 이루어졌습니다. 객체 배열은 임의의 파이썬 객체로 구성된 이기종 모음입니다. 객체 배열에서 항목을 선택하면 원래 Python 객체 (그리고 존재하지만 실제 용도로는 거의 사용되지 않는 객체 배열 스칼라가 아닙니다)를 다시 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="4e947f26c0ecf6d9ff639e9f27b5b5f852135d7e" translate="yes" xml:space="preserve">
          <source>The array to act on.</source>
          <target state="translated">작동 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7000ca786d20479930ea43aa17e050c42578abc2" translate="yes" xml:space="preserve">
          <source>The array to be pickled.</source>
          <target state="translated">피클 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="25694c63a056a35911c5654e87ce1708648d0cd3" translate="yes" xml:space="preserve">
          <source>The array to broadcast.</source>
          <target state="translated">브로드 캐스트 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="61fa35e69f8b8bb03ffef7462ad7cef9c9cdddeb" translate="yes" xml:space="preserve">
          <source>The array to mask. If not a MaskedArray instance (or if no array elements are masked). The result is a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (False). Must be a 2D array.</source>
          <target state="translated">마스크 할 배열입니다. MaskedArray 인스턴스가 아닌 경우 (또는 배열 요소가 마스크되지 않은 경우) 결과는 &lt;code&gt;mask&lt;/code&gt; 가 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (False)로 설정된 MaskedArray 입니다. 2D 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9a0afda668850edc1a593d4069db9a58418e2d74" translate="yes" xml:space="preserve">
          <source>The array to operate on. If not a MaskedArray instance (or if no array elements are masked), &lt;code&gt;x&lt;/code&gt; is interpreted as a MaskedArray with &lt;code&gt;mask&lt;/code&gt; set to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;. Must be a 2D array.</source>
          <target state="translated">작동 할 어레이입니다. MaskedArray 인스턴스가 아니거나 마스크 된 배열 요소가없는 경우 &lt;code&gt;x&lt;/code&gt; 함께 MaskedArray로 해석 &lt;code&gt;mask&lt;/code&gt; 로 설정 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; . 2D 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="da7df7a6420823a6b7e45bca218ba68631febc25" translate="yes" xml:space="preserve">
          <source>The array to pad.</source>
          <target state="translated">채울 배열입니다.</target>
        </trans-unit>
        <trans-unit id="8966af5b1934b124717f0c80ec9988807e784cf9" translate="yes" xml:space="preserve">
          <source>The array to perform in place operation on.</source>
          <target state="translated">적절한 작업을 수행 할 어레이입니다.</target>
        </trans-unit>
        <trans-unit id="1a2586a66b67a305c2797e7e06685302608f4ea4" translate="yes" xml:space="preserve">
          <source>The array whose axes should be reordered.</source>
          <target state="translated">축을 재정렬해야하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="81f5ca8ebafc1afb8a9d51589c5e138b4b807e19" translate="yes" xml:space="preserve">
          <source>The array(s) to be iterated over. Valid only before the iterator is closed.</source>
          <target state="translated">반복 할 배열입니다. 반복자가 닫히기 전에 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="8c52ea12181e4277b350926a7c51f79608004cd5" translate="yes" xml:space="preserve">
          <source>The array(s) to iterate over.</source>
          <target state="translated">반복 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ae34a0f5008cfcf7a204a6ae1b41350a0a8ffea9" translate="yes" xml:space="preserve">
          <source>The array-protocol typestring of this data-type object.</source>
          <target state="translated">이 데이터 유형 객체의 배열 프로토콜 유형 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="342be16484b97c95949f88958c455899735a9596" translate="yes" xml:space="preserve">
          <source>The arrays all have exactly the same shape.</source>
          <target state="translated">배열은 모두 정확히 같은 모양입니다.</target>
        </trans-unit>
        <trans-unit id="d48d7d91bb3512b8a648b512669295a09d607ddf" translate="yes" xml:space="preserve">
          <source>The arrays all have the same number of dimensions and the length of each dimensions is either a common length or 1.</source>
          <target state="translated">배열은 모두 같은 수의 차원을 가지며 각 차원의 길이는 공통 길이 또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="3b32b95e95ce590daa0a88406a7282f0b6f9ae1f" translate="yes" xml:space="preserve">
          <source>The arrays holding the elements to be compared. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">비교할 요소를 보유하는 배열입니다. 만약 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="b72974524c2659f265dc742386bd383e243bc4a6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the first axis. 1-D arrays must have the same length.</source>
          <target state="translated">배열은 첫 번째 축을 제외하고 모두 같은 모양이어야합니다. 1 차원 배열의 길이는 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="9548b85aa3e636c88bbbc65cfcdf4e6b5fff4585" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the second axis, except 1-D arrays which can be any length.</source>
          <target state="translated">배열은 길이가 될 수있는 1 차원 배열을 제외하고 두 번째 축을 제외하고 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="34736140b85990281116cda8321b303d602cfb2e" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape along all but the third axis. 1-D or 2-D arrays must have the same shape.</source>
          <target state="translated">배열은 세 번째 축을 제외하고 모두 같은 모양이어야합니다. 1D 또는 2D 배열의 모양은 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="250d7318b7910004f5ade9c6bf7fa2a62b2d0aa6" translate="yes" xml:space="preserve">
          <source>The arrays must have the same shape, except in the dimension corresponding to &lt;code&gt;axis&lt;/code&gt; (the first, by default).</source>
          <target state="translated">배열은 &lt;code&gt;axis&lt;/code&gt; 해당하는 차원 (기본적으로 첫 번째) 을 제외하고는 같은 모양이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="3650412314ab8d0d6cc595877979b22653a06cac" translate="yes" xml:space="preserve">
          <source>The arrays that have too few dimensions can have their shapes prepended with a dimension of length 1 to satisfy property 2.</source>
          <target state="translated">치수가 너무 적은 배열은 특성 2를 만족시키기 위해 길이가 1 인 치수를 앞에 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c7fb6624c1c578e967064538473cd4324bc56b1" translate="yes" xml:space="preserve">
          <source>The arrays to be added. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">추가 할 배열입니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="61831d63f8eb03ec54ea81f37b4edf92245e6861" translate="yes" xml:space="preserve">
          <source>The arrays to be subtracted from each other. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">서로 빼는 배열입니다. 만약 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="b989bf28be4c34813d52a00110756329cfab3199" translate="yes" xml:space="preserve">
          <source>The arrays to broadcast.</source>
          <target state="translated">브로드 캐스트 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="4bc127992ac15b346e5ebc50b22b2084cc253474" translate="yes" xml:space="preserve">
          <source>The available functions are defined in &amp;lt;numpy/npy_math.h&amp;gt; - please refer to this header when in doubt.</source>
          <target state="translated">사용 가능한 기능은 &amp;lt;numpy / npy_math.h&amp;gt;에 정의되어 있습니다. 의심스러운 경우이 헤더를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4c1200844d5256d1bf5c45cf0a767eb7723d9e5e" translate="yes" xml:space="preserve">
          <source>The average along the specified axis. When returned is &lt;code&gt;True&lt;/code&gt;, return a tuple with the average as the first element and the sum of the weights as the second element. The return type is &lt;code&gt;np.float64&lt;/code&gt; if &lt;code&gt;a&lt;/code&gt; is of integer type and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise. If returned, &lt;code&gt;sum_of_weights&lt;/code&gt; is always &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">지정된 축의 평균입니다. 반환 된 값이 &lt;code&gt;True&lt;/code&gt; 이면 평균이 첫 번째 요소이고 가중치의 합이 두 번째 요소 인 튜플을 반환합니다. &lt;code&gt;a&lt;/code&gt; 가 정수형이고 &lt;code&gt;float64&lt;/code&gt; 보다 작은 수레 인 경우 반환 유형은 &lt;code&gt;np.float64&lt;/code&gt; 이고 , 그렇지 않으면 입력 데이터 유형입니다. 반환되면 &lt;code&gt;sum_of_weights&lt;/code&gt; 는 항상 &lt;code&gt;float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="542875b084a7c351a7a1f8a6d2d600675ca4d2a7" translate="yes" xml:space="preserve">
          <source>The average squared deviation is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of the infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables. The standard deviation computed in this function is the square root of the estimated variance, so even with &lt;code&gt;ddof=1&lt;/code&gt;, it will not be an unbiased estimate of the standard deviation per se.</source>
          <target state="translated">평균 제곱 편차는 일반적으로 &lt;code&gt;x.sum() / N&lt;/code&gt; 으로 계산되며 여기서 &lt;code&gt;N = len(x)&lt;/code&gt; 입니다. 그러나 &lt;code&gt;ddof&lt;/code&gt; 를 지정하면 제수 &lt;code&gt;N - ddof&lt;/code&gt; 가 대신 사용됩니다. 표준 통계 관행에서 &lt;code&gt;ddof=1&lt;/code&gt; 은 무한 모집단의 분산에 대한 편견 추정치를 제공합니다. &lt;code&gt;ddof=0&lt;/code&gt; 은 정규 분포 변수에 대한 분산의 최대 우도 추정값을 제공합니다. 이 함수에서 계산 된 표준 편차는 추정 분산의 제곱근이므로 &lt;code&gt;ddof=1&lt;/code&gt; 하더라도 표준 편차 자체의 편견이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="21ebdcee890d352b954472165e15ea262b078aa8" translate="yes" xml:space="preserve">
          <source>The axes over which to compute the inverse fft. Default is the last two axes.</source>
          <target state="translated">역 fft를 계산할 축입니다. 기본값은 마지막 두 축입니다.</target>
        </trans-unit>
        <trans-unit id="3f6da36d69c95a72b5592c0677dd407fdc9cfa2c" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;v&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 가 추가 되는 축 입니다. 경우 &lt;code&gt;axis&lt;/code&gt; 주어지지 않는, 모두 및 &lt;code&gt;b&lt;/code&gt; 를 사용하기 전에 평평하고 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="071585631d8d75cc42162ae0da0a1b91474572d1" translate="yes" xml:space="preserve">
          <source>The axis along which &lt;code&gt;values&lt;/code&gt; are appended. If &lt;code&gt;axis&lt;/code&gt; is not given, both &lt;code&gt;arr&lt;/code&gt; and &lt;code&gt;values&lt;/code&gt; are flattened before use.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; 이 추가 되는 축 입니다. 경우 &lt;code&gt;axis&lt;/code&gt; 주어지지 않는, 모두 &lt;code&gt;arr&lt;/code&gt; 과 &lt;code&gt;values&lt;/code&gt; 사용하기 전에 평평하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="d25eb0541fd006d52dcbebc548c80309c583cc52" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. Default is 0.</source>
          <target state="translated">배열이 결합 될 축입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="ab324f8b42b072f0ce80303066858390de817e59" translate="yes" xml:space="preserve">
          <source>The axis along which the arrays will be joined. If axis is None, arrays are flattened before use. Default is 0.</source>
          <target state="translated">배열이 결합 될 축입니다. 축이 없음 인 경우 사용 전에 배열이 평평 해집니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b85856e591095eebb92c2f542dccaa68776b00c8" translate="yes" xml:space="preserve">
          <source>The axis along which the difference is taken, default is the last axis.</source>
          <target state="translated">차이를 취하는 축이며 기본값은 마지막 축입니다.</target>
        </trans-unit>
        <trans-unit id="848f8430ea7a17384babb0b6d388a2e2e8bda711" translate="yes" xml:space="preserve">
          <source>The axis along which the selection is performed. The default, 0, selects by row.</source>
          <target state="translated">선택이 수행되는 축입니다. 기본값 인 0은 행별로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="db9105950615faa8709d8dba888767b4f466811c" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the accumulation; default is zero.</source>
          <target state="translated">누적을 적용 할 축입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b45496da67ff059714d0b1ae6911029e831dd2fd" translate="yes" xml:space="preserve">
          <source>The axis along which to apply the reduceat.</source>
          <target state="translated">reduceat를 적용 할 축입니다.</target>
        </trans-unit>
        <trans-unit id="ef9dbd3a8e7509325fd10ad7183022f46facda83" translate="yes" xml:space="preserve">
          <source>The axis along which to delete the subarray defined by &lt;code&gt;obj&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;obj&lt;/code&gt; is applied to the flattened array.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 의해 정의 된 하위 배열을 삭제할 축 입니다. 경우 &lt;code&gt;axis&lt;/code&gt; 것도없고, &lt;code&gt;obj&lt;/code&gt; 평탄화 어레이에 적용된다.</target>
        </trans-unit>
        <trans-unit id="3c27f5e5d6b589ff51ec356603f9f33684d0e877" translate="yes" xml:space="preserve">
          <source>The axis along which to find the minima. Default is None, in which case the minimum value in the whole array is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5932d4cf836b6b58485bd9f15e2f20474363c36f" translate="yes" xml:space="preserve">
          <source>The axis along which to integrate.</source>
          <target state="translated">통합 할 축입니다.</target>
        </trans-unit>
        <trans-unit id="0011917dec1b66b996673fed4476058c1c23ee6e" translate="yes" xml:space="preserve">
          <source>The axis along which to repeat values. By default, use the flattened input array, and return a flat output array.</source>
          <target state="translated">값을 반복 할 축입니다. 기본적으로, 평평한 입력 배열을 사용하고 평평한 출력 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="407371d3199afc3105f3e75619a63b4981063028" translate="yes" xml:space="preserve">
          <source>The axis along which to split, default is 0.</source>
          <target state="translated">분할 할 축, 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="40f4cb16df8166b16f689cc3f6a27ceb034ca2a8" translate="yes" xml:space="preserve">
          <source>The axis currently being calculated.</source>
          <target state="translated">현재 계산중인 축입니다.</target>
        </trans-unit>
        <trans-unit id="779396c94c96c008627d39cce908fca96b699246" translate="yes" xml:space="preserve">
          <source>The axis in the result array along which the input arrays are stacked.</source>
          <target state="translated">입력 배열이 쌓이는 결과 배열의 축입니다.</target>
        </trans-unit>
        <trans-unit id="f53c3f1c70993fc128dae4ee501fb80cbace06f6" translate="yes" xml:space="preserve">
          <source>The axis in the result to store the samples. Relevant only if start or stop are array-like. By default (0), the samples will be along a new axis inserted at the beginning. Use -1 to get an axis at the end.</source>
          <target state="translated">샘플을 저장할 결과의 축입니다. 시작 또는 중지가 배열과 같은 경우에만 관련이 있습니다. 기본적으로 (0), 샘플은 처음에 삽입 된 새 축을 따릅니다. 끝에 축을 가져 오려면 -1을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5d9b30084a3b37c792a839c94c54a5cdb7a8cfce" translate="yes" xml:space="preserve">
          <source>The axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll.</source>
          <target state="translated">축이이 위치 앞에 놓일 때까지 롤링됩니다. 기본값 인 0은 &quot;완료&quot;롤이됩니다.</target>
        </trans-unit>
        <trans-unit id="bb67daef266f9ea49c20107e1bf4911d74a22608" translate="yes" xml:space="preserve">
          <source>The axis over which to select values. By default, the flattened input array is used.</source>
          <target state="translated">값을 선택할 축입니다. 기본적으로 평탄화 된 입력 배열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a2ce88413f2bc22b3ef2d3c9420680ad19eebe6" translate="yes" xml:space="preserve">
          <source>The axis to be rolled. The positions of the other axes do not change relative to one another.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0edfc48d57e03c356c790b28b9213c10fc98a8b" translate="yes" xml:space="preserve">
          <source>The axis to operate on. If None, &lt;code&gt;ar&lt;/code&gt; will be flattened. If an integer, the subarrays indexed by the given axis will be flattened and treated as the elements of a 1-D array with the dimension of the given axis, see the notes for more details. Object arrays or structured arrays that contain objects are not supported if the &lt;code&gt;axis&lt;/code&gt; kwarg is used. The default is None.</source>
          <target state="translated">작동 할 축입니다. None이면 &lt;code&gt;ar&lt;/code&gt; 이 평평 해집니다. 주어진 축에 의해 인덱스 된 서브 어레이가 정수인 경우, 주어진 축의 차원을 가진 1 차원 배열의 요소로 평탄화되고 처리됩니다. 자세한 내용은 참고를 참조하십시오. &lt;code&gt;axis&lt;/code&gt; kwarg를 사용하는 경우 객체를 포함하는 객체 배열 또는 구조화 된 배열은 지원되지 않습니다 . 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="b9493a9f29cafe569828c852de6864aa7f5d0ff6" translate="yes" xml:space="preserve">
          <source>The axis to roll backwards. The positions of the other axes do not change relative to one another.</source>
          <target state="translated">뒤로 롤할 축입니다. 다른 축의 위치는 서로에 대해 변하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="340d3fc196833339a77972eea60efcdfd52ba73c" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the destination array is treated as if a flattened 1d view had been created of it.</source>
          <target state="translated">1d 슬라이스를 취할 축입니다. axis가 None이면 대상 배열은 평면화 된 1d 뷰가 작성된 것처럼 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="a049beb1044c250e5951941014a3acba639cb49d" translate="yes" xml:space="preserve">
          <source>The axis to take 1d slices along. If axis is None, the input array is treated as if it had first been flattened to 1d, for consistency with &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1d 슬라이스를 취할 축입니다. axis가 None이면 입력 배열은 &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 와의 일관성을 위해 처음에 1d로 병합 된 것처럼 처리됩니다. .</target>
        </trans-unit>
        <trans-unit id="a5f8cd862df0c3dc198b03cdec5c823ff5bfd3ca" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f5f1b01f9d6c3c18ebf1e91b8c1b0eb06217c1" translate="yes" xml:space="preserve">
          <source>The axis which &lt;code&gt;x&lt;/code&gt; is shuffled along. Default is 0. It is only supported on &lt;code&gt;ndarray&lt;/code&gt; objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8262154fa6203f128694759e7e2ae715f81f6fa1" translate="yes" xml:space="preserve">
          <source>The base BitGenerator.state must be overridden by a subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98787e1071b5327d0b2e07537c81bb27588db08e" translate="yes" xml:space="preserve">
          <source>The base case for this recursion is a 0D array:</source>
          <target state="translated">이 재귀의 기본 사례는 0D 배열입니다.</target>
        </trans-unit>
        <trans-unit id="88d21dfd4e25736b7184078ba7f33b64bea753e0" translate="yes" xml:space="preserve">
          <source>The base of an array that owns its memory is None:</source>
          <target state="translated">메모리를 소유하는 배열의 기본은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="074b16b582d8ec2099beaee8dcbc987839646a35" translate="yes" xml:space="preserve">
          <source>The base of the log space. The step size between the elements in &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (or &lt;code&gt;log_base(samples)&lt;/code&gt;) is uniform. Default is 10.0.</source>
          <target state="translated">로그 공간의 기본입니다. &lt;code&gt;ln(samples) / ln(base)&lt;/code&gt; (또는 &lt;code&gt;log_base(samples)&lt;/code&gt; ) 의 요소 사이의 단계 크기 는 균일합니다. 기본값은 10.0입니다.</target>
        </trans-unit>
        <trans-unit id="535897fba7f592c8b7dd04c68596d9a31edf2e11" translate="yes" xml:space="preserve">
          <source>The bases in &lt;code&gt;x1&lt;/code&gt; raised to the exponents in &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 의 밑이 &lt;code&gt;x2&lt;/code&gt; 의 지수로 올랐습니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="707f28b031c35e2bf30d29bbd42946a1e8c7dc8c" translate="yes" xml:space="preserve">
          <source>The bases.</source>
          <target state="translated">기지.</target>
        </trans-unit>
        <trans-unit id="5bc92f7e413935d311df16000ae397f9e815d85b" translate="yes" xml:space="preserve">
          <source>The basic data element&amp;rsquo;s size in bytes</source>
          <target state="translated">기본 데이터 요소의 크기 (바이트)</target>
        </trans-unit>
        <trans-unit id="68fe9eda4da762f1f4d04299c59c07412dcd5a69" translate="yes" xml:space="preserve">
          <source>The basic slice syntax is &lt;code&gt;i:j:k&lt;/code&gt; where &lt;em&gt;i&lt;/em&gt; is the starting index, &lt;em&gt;j&lt;/em&gt; is the stopping index, and &lt;em&gt;k&lt;/em&gt; is the step (</source>
          <target state="translated">기본 슬라이스 구문은 &lt;code&gt;i:j:k&lt;/code&gt; 입니다. 여기서 &lt;em&gt;i&lt;/em&gt; 는 시작 색인이고, &lt;em&gt;j&lt;/em&gt; 는 중지 색인이며, &lt;em&gt;k&lt;/em&gt; 는 단계입니다 (</target>
        </trans-unit>
        <trans-unit id="aeeddb45e8f2002e147b881df220bd44abec802b" translate="yes" xml:space="preserve">
          <source>The basic type character codes are:</source>
          <target state="translated">기본 유형 문자 코드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="94f38793f86bdba698e5ca03402c847550f50738" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is a Chebyshev basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 체비 쇼프 기본 다항식 인 경우 컴패니언 행렬이 대칭이되도록 기본 다항식의 크기가 조정 됩니다. 이는 스케일링되지 않은 경우보다 더 나은 고유 값 추정을 제공하며 기본 다항식의 경우 &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; 를 사용 하여 고유 값을 사용하면 고유 값이 실제 값으로 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="fd443fcafad8cfc7235ab73b5edb8fa2361feb5f" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Hermite basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">기본 다항식은 다음과 같은 경우 컴패니언 행렬이 대칭이되도록 크기가 조정됩니다. &lt;code&gt;c&lt;/code&gt; 가 에르 미트 (Hermite) 기본 다항식 일 됩니다. 이것은 스케일되지 않은 경우보다 더 나은 고유 값 추정치를 제공하며 기본 다항식의 경우 &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; 를 사용 하여 고유 값을 사용하면 고유 값이 실제 값으로 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1520a86bfcd397936d59363e21a13733e7a71b7" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an HermiteE basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">기본 다항식은 다음과 같은 경우 컴패니언 행렬이 대칭이되도록 크기가 조정됩니다. &lt;code&gt;c&lt;/code&gt; 가 HermiteE 기본 다항식 인 됩니다. 이것은 스케일되지 않은 경우보다 더 나은 고유 값 추정치를 제공하며 기본 다항식의 경우 &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; 를 사용 하여 고유 값을 사용하면 고유 값이 실제 값으로 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="31e8496a7482cd5cd28cb680bd285957a80df61e" translate="yes" xml:space="preserve">
          <source>The basis polynomials are scaled so that the companion matrix is symmetric when &lt;code&gt;c&lt;/code&gt; is an Legendre basis polynomial. This provides better eigenvalue estimates than the unscaled case and for basis polynomials the eigenvalues are guaranteed to be real if &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt;&lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt;&lt;/a&gt; is used to obtain them.</source>
          <target state="translated">기본 다항식은 다음과 같은 경우 컴패니언 행렬이 대칭이되도록 크기가 조정됩니다. &lt;code&gt;c&lt;/code&gt; 가 Legendre 기본 다항식 인 됩니다. 이것은 스케일되지 않은 경우보다 더 나은 고유 값 추정치를 제공하며 기본 다항식의 경우 &lt;a href=&quot;numpy.linalg.eigvalsh#numpy.linalg.eigvalsh&quot;&gt; &lt;code&gt;numpy.linalg.eigvalsh&lt;/code&gt; &lt;/a&gt; 를 사용 하여 고유 값을 사용하면 고유 값이 실제 값으로 보장됩니다 .</target>
        </trans-unit>
        <trans-unit id="f437318ff72364f761b90a9b7cf38009e657db81" translate="yes" xml:space="preserve">
          <source>The behavior depends on the arguments in the following way.</source>
          <target state="translated">동작은 다음과 같은 방식으로 인수에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="52cedd9e4737e7d41b9c0573b9212f2735c44e68" translate="yes" xml:space="preserve">
          <source>The behavior of multi-field indexes changed from Numpy 1.15 to Numpy 1.16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c61d26e0bac97d24671e4708fc43eaa9dd53127" translate="yes" xml:space="preserve">
          <source>The behaviour of NumPy and Python integer types differs significantly for integer overflows and may confuse users expecting NumPy integers to behave similar to Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt;. Unlike NumPy, the size of Python&amp;rsquo;s &lt;code&gt;int&lt;/code&gt; is flexible. This means Python integers may expand to accommodate any integer and will not overflow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226707a677bb2dfd051d5e6d30579822a26a8454" translate="yes" xml:space="preserve">
          <source>The benchmark parameters etc. should not depend on which NumPy version is installed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a11e20913e7d4cf3019155d32cde05064b5abf" translate="yes" xml:space="preserve">
          <source>The benchmark suite should be importable with any NumPy version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2bdcfca6c07efc9e236b5653fc2391d3452350a" translate="yes" xml:space="preserve">
          <source>The best practice is to &lt;strong&gt;not&lt;/strong&gt; reseed a BitGenerator, rather to recreate a new one. This method is here for legacy reasons. This example demonstrates best practice.</source>
          <target state="translated">가장 좋은 방법은 &lt;strong&gt;&lt;/strong&gt; BitGenerator를 다시 시드 &lt;strong&gt;하지&lt;/strong&gt; 않고 새로운 것을 생성하는 것입니다. 이 방법은 레거시 이유로 여기에 있습니다. 이 예는 모범 사례를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c109a555c27db42b8f7688c8df998553f8ab7653" translate="yes" xml:space="preserve">
          <source>The best strategy to better understand the code base is to pick something you want to change and start reading the code to figure out how it works. When in doubt, you can ask questions on the mailing list. It is perfectly okay if your pull requests aren&amp;rsquo;t perfect, the community is always happy to help. As a volunteer project, things do sometimes get dropped and it&amp;rsquo;s totally fine to ping us if something has sat without a response for about two to four weeks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aae59e3eb6aeca266807eb2b03def986d4d70e96" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b917d701e1031f727f4614d1e3412a655c750b99" translate="yes" xml:space="preserve">
          <source>The best way to become familiar with the iterator is to look at its usage within the NumPy codebase itself. For example, here is a slightly tweaked version of the code for &lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt;&lt;code&gt;PyArray_CountNonzero&lt;/code&gt;&lt;/a&gt;, which counts the number of non-zero elements in an array.</source>
          <target state="translated">반복자에 익숙해지는 가장 좋은 방법은 NumPy 코드베이스 자체에서 사용법을 보는 것입니다. 예를 들어 다음은 약간 수정 된 버전의 코드입니다.&lt;a href=&quot;c-api.array#c.PyArray_CountNonzero&quot;&gt; &lt;code&gt;PyArray_CountNonzero&lt;/code&gt; &lt;/a&gt; 배열에서 0이 아닌 요소의 수를 세는 있습니다.</target>
        </trans-unit>
        <trans-unit id="de71d7b03048d0ddf7e9d872a2d91138dd227be5" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="translated">지정된 C 라이브러리와 링크하는 데 필요한 옵션을 인코딩하는 가장 좋은 방법은 &quot;libname.ini&quot;파일을 사용하고 &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt; 를 사용 하여 필요한 옵션을 검색하는 것입니다 (참조&lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt; &lt;code&gt;add_npy_pkg_config&lt;/code&gt; &lt;/a&gt; 입니다 (자세한 내용 add_npy_pkg_config).</target>
        </trans-unit>
        <trans-unit id="bd068dc6ad18c4bdc86034d17ab908d7b76c4670" translate="yes" xml:space="preserve">
          <source>The best way to encode the options required to link against the specified C libraries is to use a &amp;ldquo;libname.ini&amp;rdquo; file, and use &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; to retrieve the required options (see &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_npy_pkg_config&quot;&gt;&lt;code&gt;add_npy_pkg_config&lt;/code&gt;&lt;/a&gt; for more information).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1969d49698b808b6d276d97e5d8d4c69483e3b58" translate="yes" xml:space="preserve">
          <source>The bi-dimensional histogram of samples &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. Values in &lt;code&gt;x&lt;/code&gt; are histogrammed along the first dimension and values in &lt;code&gt;y&lt;/code&gt; are histogrammed along the second dimension.</source>
          <target state="translated">샘플 바이 차원 히스토그램이 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 의 값 은 첫 번째 차원을 따라 막대 그래프로 표시되며 &lt;code&gt;y&lt;/code&gt; 따라 히스토그램 화되고 y의 은 두 번째 차원을 따라 히스토그램 화됩니다.</target>
        </trans-unit>
        <trans-unit id="ccfae57716d7eef7191c06c0e81d2ccf59d9fed0" translate="yes" xml:space="preserve">
          <source>The biggest difficulty when writing extension modules is reference counting. It is an important reason for the popularity of f2py, weave, Cython, ctypes, etc&amp;hellip;. If you mis-handle reference counts you can get problems from memory-leaks to segmentation faults. The only strategy I know of to handle reference counts correctly is blood, sweat, and tears. First, you force it into your head that every Python variable has a reference count. Then, you understand exactly what each function does to the reference count of your objects, so that you can properly use DECREF and INCREF when you need them. Reference counting can really test the amount of patience and diligence you have towards your programming craft. Despite the grim depiction, most cases of reference counting are quite straightforward with the most common difficulty being not using DECREF on objects before exiting early from a routine due to some error. In second place, is the common error of not owning the reference on an object that is passed to a function or macro that is going to steal the reference ( &lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;https://docs.python.org/dev/c-api/tuple.html#c.PyTuple_SET_ITEM&quot;&gt;&lt;code&gt;PyTuple_SET_ITEM&lt;/code&gt;&lt;/a&gt;, and most functions that take &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; objects).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14050b2975e92118c403ebf94bd3985c0b813e9c" translate="yes" xml:space="preserve">
          <source>The bin edges along the first dimension.</source>
          <target state="translated">빈은 첫 번째 치수를 따라 가장자리입니다.</target>
        </trans-unit>
        <trans-unit id="4350d5e237c7d985f1cac8ee28f6158f7c836a6a" translate="yes" xml:space="preserve">
          <source>The bin edges along the second dimension.</source>
          <target state="translated">2 차원의 빈 가장자리.</target>
        </trans-unit>
        <trans-unit id="a2867162a2727e5c2d9c039d549ef3ce42449ec8" translate="yes" xml:space="preserve">
          <source>The bin specification:</source>
          <target state="translated">출력 함 사양 :</target>
        </trans-unit>
        <trans-unit id="60d93abeda71712ad2c6a79ef8adc26f40d2aa9b" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the interquartile range (IQR) and inversely proportional to cube root of a.size. Can be too conservative for small datasets, but is quite good for large datasets. The IQR is very robust to outliers.</source>
          <target state="translated">이진 폭은 사 분위 범위 (IQR)에 비례하고 a의 크기에 대한 세제곱근에 반비례합니다. 작은 데이터 세트에는 너무 보수적 일 수 있지만 큰 데이터 세트에는 아주 좋습니다. IQR은 특이 치에 대해 매우 견고합니다.</target>
        </trans-unit>
        <trans-unit id="fcdd8e437719df337fcbc4c74083d021a1773472" translate="yes" xml:space="preserve">
          <source>The binwidth is proportional to the standard deviation of the data and inversely proportional to cube root of &lt;code&gt;x.size&lt;/code&gt;. Can be too conservative for small datasets, but is quite good for large datasets. The standard deviation is not very robust to outliers. Values are very similar to the Freedman-Diaconis estimator in the absence of outliers.</source>
          <target state="translated">이진 폭은 데이터의 표준 편차에 비례하고 &lt;code&gt;x.size&lt;/code&gt; 의 세제곱근 에 반비례합니다 합니다. 작은 데이터 세트에는 너무 보수적 일 수 있지만 큰 데이터 세트에는 아주 좋습니다. 표준 편차는 특이 치에 대해 강력하지 않습니다. 특이 치가없는 경우 값은 Freedman-Diaconis 추정기와 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="4bfe7be4cfb5e7ee31495fab431c2ade90ea37b4" translate="yes" xml:space="preserve">
          <source>The bit generator instance used by the generator</source>
          <target state="translated">생성기에서 사용하는 비트 생성기 인스턴스</target>
        </trans-unit>
        <trans-unit id="1c9ceb11680f6c0c1b9aff1a5015653854b99511" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#random-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5d3462c76522066d7ff9beefce9a7effa7d1a7a" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython&lt;/a&gt;.</source>
          <target state="translated">비트 생성기는 &lt;a href=&quot;extending#randomgen-cython&quot;&gt;Cython을&lt;/a&gt; 통해 다운 스트림 프로젝트에서 사용될 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="bb60b63a1d593f422d320c08f605d5c913dee609" translate="yes" xml:space="preserve">
          <source>The bit generators can be used in downstream projects via Cython.</source>
          <target state="translated">비트 생성기는 Cython을 통해 다운 스트림 프로젝트에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e4e6fbd0cb3401b8c573dd3679e44e3f4f81dbf" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="translated">비트 폭 이름도 사용할 수 있습니다 (예 : &lt;a href=&quot;c-api.dtype#c.NPY_INT32&quot;&gt; &lt;code&gt;NPY_INT32&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_COMPLEX128&quot;&gt; &lt;code&gt;NPY_COMPLEX128&lt;/code&gt; &lt;/a&gt;원하는 경우 ).</target>
        </trans-unit>
        <trans-unit id="bc2ab75ee612016fcf37354aa06f319d50bc9810" translate="yes" xml:space="preserve">
          <source>The bit-width names can also be used (e.g. &lt;a href=&quot;dtype#c.NPY_INT32&quot;&gt;&lt;code&gt;NPY_INT32&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_COMPLEX128&quot;&gt;&lt;code&gt;NPY_COMPLEX128&lt;/code&gt;&lt;/a&gt; ) if desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d10a070991358c5aabcf2c4a0f8549725777dd" translate="yes" xml:space="preserve">
          <source>The bit-wise operators &amp;amp; and | are the proper way to perform element-by-element array comparisons. Be sure you understand the operator precedence: &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; is the proper syntax because &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; will result in an error due to the fact that &lt;code&gt;2 &amp;amp; a&lt;/code&gt; is evaluated first.</source>
          <target state="translated">비트 연산자 &amp;amp; &amp;amp; | 요소 별 배열 비교를 수행하는 올바른 방법입니다. 연산자 우선 순위를 이해해야합니다. &lt;code&gt;a &amp;gt; 2 &amp;amp; a &amp;lt; 5&lt;/code&gt; 는 &lt;code&gt;2 &amp;amp; a&lt;/code&gt; 가 먼저 평가 되므로 오류가 발생하기 때문에 &lt;code&gt;(a &amp;gt; 2) &amp;amp; (a &amp;lt; 5)&lt;/code&gt; 가 올바른 구문 입니다.</target>
        </trans-unit>
        <trans-unit id="023be86065ffa72daa5873059c9ec3d6c37210a4" translate="yes" xml:space="preserve">
          <source>The bits that are inherited for the parent data-type if these bits are set in any field of the data-type. Currently ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">이러한 비트가 데이터 유형의 필드에 설정된 경우 상위 데이터 유형에 대해 상속되는 비트입니다. 현재 ( &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="eec4adb38715609db3c28173012b3acac012a710" translate="yes" xml:space="preserve">
          <source>The broadcasting mechanism permits index arrays to be combined with scalars for other indices. The effect is that the scalar value is used for all the corresponding values of the index arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4cdfeeb979f5beeacca8e8ed28ded2c7c6f59236" translate="yes" xml:space="preserve">
          <source>The buffer size. If &lt;code&gt;buf_size&lt;/code&gt; is supplied, the maximum amount of data that will be read into memory is &lt;code&gt;buf_size&lt;/code&gt; elements. Default is None, which will read as many element as possible into memory.</source>
          <target state="translated">버퍼 크기 경우 &lt;code&gt;buf_size&lt;/code&gt; 공급되고, 메모리에 판독 될 데이터의 최대 양이다 &lt;code&gt;buf_size&lt;/code&gt; 소자. 기본값은 없음이며 가능한 많은 요소를 메모리로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2e41256de81634e573afba6a93755e0b3e1dcc73" translate="yes" xml:space="preserve">
          <source>The built-in scalar types are shown below. Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured (e.g. &lt;code&gt;int8&lt;/code&gt;, &lt;code&gt;float64&lt;/code&gt;, &lt;code&gt;complex128&lt;/code&gt;). Two aliases (&lt;code&gt;intp&lt;/code&gt; and &lt;code&gt;uintp&lt;/code&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided. The C-like names are associated with character codes, which are shown in the table. Use of the character codes, however, is discouraged.</source>
          <target state="translated">내장 스칼라 유형은 다음과 같습니다. 정수, 부동 및 복합 데이터 유형은 (대부분) C 파생 이름과 함께 비트 너비 규칙을 사용하여 사용할 수 있으므로 올바른 크기의 배열을 항상 보장 할 수 있습니다 (예 : &lt;code&gt;int8&lt;/code&gt; , &lt;code&gt;float64&lt;/code&gt; , &lt;code&gt;complex128&lt;/code&gt; ) . C 포인터를 보유하기에 충분히 큰 정수 유형을 가리키는 두 개의 별명 ​​( &lt;code&gt;intp&lt;/code&gt; 및 &lt;code&gt;uintp&lt;/code&gt; )도 제공됩니다. C와 유사한 이름은 표에 표시된 문자 코드와 연관됩니다. 그러나 문자 코드를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c0f5f929adb8df8a6adc766b8c78557ffdeb6dfb" translate="yes" xml:space="preserve">
          <source>The byte offset of element &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; in an array &lt;code&gt;a&lt;/code&gt; is:</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 에서 요소 &lt;code&gt;(i[0], i[1], ..., i[n])&lt;/code&gt; 의 바이트 오프셋 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e1d8f651723be5f774ab2e5c504d861c7a87264" translate="yes" xml:space="preserve">
          <source>The byte offsets of the fields within the structure and the total structure itemsize are determined automatically.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a157c5730d5626d8d468cb6666e1e8a306635908" translate="yes" xml:space="preserve">
          <source>The byte order of the data (which may not be the native byte order)</source>
          <target state="translated">데이터의 바이트 순서 (기본 바이트 순서가 아닐 수 있음)</target>
        </trans-unit>
        <trans-unit id="54750603ecbabb9e0fbfb396fe440127b1696b3c" translate="yes" xml:space="preserve">
          <source>The byteswapped array. If &lt;code&gt;inplace&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, this is a view to self.</source>
          <target state="translated">바이트 랩핑 된 배열. 경우 &lt;code&gt;inplace&lt;/code&gt; 있다 &lt;code&gt;True&lt;/code&gt; ,이 자체로도이다.</target>
        </trans-unit>
        <trans-unit id="50ca95011c00b72a055aafd7f7fd748d3ee5666f" translate="yes" xml:space="preserve">
          <source>The calculation based on the Einstein summation convention.</source>
          <target state="translated">아인슈타인 요약 규칙에 따른 계산.</target>
        </trans-unit>
        <trans-unit id="f28022cc3c759ea7fff9649dace591b586e47f2a" translate="yes" xml:space="preserve">
          <source>The call function takes two arguments. The first is a string describing the type of error (such as &amp;ldquo;divide by zero&amp;rdquo;, &amp;ldquo;overflow&amp;rdquo;, &amp;ldquo;underflow&amp;rdquo;, or &amp;ldquo;invalid value&amp;rdquo;), and the second is the status flag. The flag is a byte, whose four least-significant bits indicate the type of error, one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;invalid&amp;rdquo;:</source>
          <target state="translated">호출 함수는 두 개의 인수를 취합니다. 첫 번째는 오류 유형 (예 : &quot;0으로 나누기&quot;, &quot;오버플로&quot;, &quot;언더 플로&quot;또는 &quot;유효하지 않은 값&quot;)을 설명하는 문자열이고 두 번째는 상태 플래그입니다. 플래그는 바이트로, 가장 중요하지 않은 4 개의 비트는 오류 유형을 나타내며, &quot;나누기&quot;, &quot;오버&quot;, &quot;언더&quot;, &quot;유효하지 않음&quot;중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="65bfb33c8f536eca2e334a181b45563504281f94" translate="yes" xml:space="preserve">
          <source>The callable to test.</source>
          <target state="translated">테스트 할 호출 가능</target>
        </trans-unit>
        <trans-unit id="a3a1c9abf4ffccd45f5331c5f42edc1f3d2d1d9d" translate="yes" xml:space="preserve">
          <source>The callback function may also be explicitly set in the module. Then it is not necessary to pass the function in the argument list to the Fortran function. This may be desired if the Fortran function calling the python callback function is itself called by another Fortran function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="431e9b7795bdf48241d6bec5990fb4a0130d071a" translate="yes" xml:space="preserve">
          <source>The ceil of the scalar &lt;code&gt;x&lt;/code&gt; is the smallest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;gt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">스칼라 &lt;code&gt;x&lt;/code&gt; 의 ceil은 가장 작은 정수 &lt;code&gt;i&lt;/code&gt; 이므로 &lt;code&gt;i &amp;gt;= x&lt;/code&gt; 입니다. 종종 다음과 같이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="e9d3cf326f9a7a53ec955615e43eb638c61eb8ef" translate="yes" xml:space="preserve">
          <source>The ceiling of each element in &lt;code&gt;x&lt;/code&gt;, with &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; dtype. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">각 요소의 천장 &lt;code&gt;x&lt;/code&gt; 와, &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; DTYPE. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="39a8dcb488a9fc6fc34cf5a558688abf07d39d3f" translate="yes" xml:space="preserve">
          <source>The character representing the minimum-size type that was found.</source>
          <target state="translated">찾은 최소 크기 유형을 나타내는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="97cbe8e263bc4b6b77075dcb6bab028e565a01e7" translate="yes" xml:space="preserve">
          <source>The character to use for padding</source>
          <target state="translated">패딩에 사용할 문자</target>
        </trans-unit>
        <trans-unit id="6c4bf24ea0f35b24c677f85fded0fd7b09f23149" translate="yes" xml:space="preserve">
          <source>The character used to indicate the start of a comment. All the characters occurring on a line after a comment are discarded</source>
          <target state="translated">주석의 시작을 나타내는 데 사용되는 문자입니다. 주석 후 줄에 나오는 모든 문자는 삭제됩니다</target>
        </trans-unit>
        <trans-unit id="d85f382686a835461ae276491d1cc1f7d794fafc" translate="yes" xml:space="preserve">
          <source>The characteristic polynomial,</source>
          <target state="translated">다항식의 특징</target>
        </trans-unit>
        <trans-unit id="95fe0ca98cff261937758debf60dec87c78a570a" translate="yes" xml:space="preserve">
          <source>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is &amp;lsquo;#&amp;rsquo;.</source>
          <target state="translated">주석의 시작을 나타내는 데 사용되는 문자 또는 문자 목록. 없음은 의견이 없음을 의미합니다. 이전 버전과의 호환성을 위해 바이트 문자열은 'latin1'으로 디코딩됩니다. 기본값은 '#'입니다.</target>
        </trans-unit>
        <trans-unit id="16535da2d1a6378c09b05298f374b6373da93c3c" translate="yes" xml:space="preserve">
          <source>The choice and location of linked libraries such as BLAS and LAPACK as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3f50108009441cc91c801c6a0d50e7f118400f" translate="yes" xml:space="preserve">
          <source>The class defining the warning that &lt;code&gt;func&lt;/code&gt; is expected to throw.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 이 발생해야 한다는 경고를 정의하는 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="da74e7889b120a1d89220abab914f35b23ca6ac5" translate="yes" xml:space="preserve">
          <source>The clear choice to wrap Fortran code is &lt;a href=&quot;https://docs.scipy.org/doc/numpy/f2py/&quot;&gt;f2py&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3182c5f9b369539a27f1bc7716b92f10416add66" translate="yes" xml:space="preserve">
          <source>The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for these alternatives. For example, any of &amp;lsquo;&amp;gt;&amp;rsquo; or &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;brian&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">코드는 이러한 대안에 대해 &lt;code&gt;new_order&lt;/code&gt; 의 첫 글자를 대소 문자를 구분하지 않고 검사합니다 . 예를 들어 '&amp;gt;'또는 'B'또는 'b'또는 'brian'은 big-endian을 지정하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="80380a308ceba94a9432deb39fde76dbd31d736a" translate="yes" xml:space="preserve">
          <source>The code in the second example is more efficient than that in the first because broadcasting moves less memory around during the multiplication (&lt;code&gt;b&lt;/code&gt; is a scalar rather than an array).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b154e2d8d3173f85d365231f520eaf5d3d14ed4d" translate="yes" xml:space="preserve">
          <source>The code to produce the figures is part of the &lt;a href=&quot;http://www.astroml.org/book_figures/appendix/fig_broadcast_visual.html&quot;&gt;AstroML book&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d7fde77cc6d2864c99d7d852dc9654a8a2c232a" translate="yes" xml:space="preserve">
          <source>The coefficient array representing their sum.</source>
          <target state="translated">합계를 나타내는 계수 배열입니다.</target>
        </trans-unit>
        <trans-unit id="8877be945db0e0267ce25ed710aea10434e74470" translate="yes" xml:space="preserve">
          <source>The coefficient matrix of the coefficients &lt;code&gt;p&lt;/code&gt; is a Vandermonde matrix.</source>
          <target state="translated">계수 &lt;code&gt;p&lt;/code&gt; 의 계수 행렬 는 밴더 몬드 매트릭스이다.</target>
        </trans-unit>
        <trans-unit id="1749ca10e1fd82b0f81734b8e3040c222ba10138" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is 1 for monic polynomials in this form.</source>
          <target state="translated">마지막 항의 계수는이 형태의 음역 다항식에 대해 1입니다.</target>
        </trans-unit>
        <trans-unit id="7f518b8b3d036f3e65aa1004d0ce4c9fe4f469f2" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Chebyshev form.</source>
          <target state="translated">마지막 항의 계수는 체비 쇼프 형태의 음역 다항식에 대해 일반적으로 1이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c6e27aff7bd03298a7abe7cdd24c2851e78ffc19" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Hermite form.</source>
          <target state="translated">마지막 항의 계수는 은자 형태의 음역 다항식에 대해 일반적으로 1이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d8180193920e1d179284839e524518471959f55d" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in HermiteE form.</source>
          <target state="translated">마지막 항의 계수는 HermiteE 형태의 음역 다항식에 대해 일반적으로 1이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="870417532aa77b335abb3ff61d44b3280649b54a" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Laguerre form.</source>
          <target state="translated">마지막 항의 계수는 일반적으로 Laguerre 형태의 음역 다항식에 대해 1이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d2eb9fcb4c7fc816e015e2f1263164865a84ea2c" translate="yes" xml:space="preserve">
          <source>The coefficient of the last term is not generally 1 for monic polynomials in Legendre form.</source>
          <target state="translated">마지막 항의 계수는 일반적으로 Legendre 형식의 음역 다항식에 대해 1이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c0eab4462e93f35863c8383ff656ddde3733b00b" translate="yes" xml:space="preserve">
          <source>The coefficients are determined by multiplying together linear factors of the form &lt;code&gt;(x - r_i)&lt;/code&gt;, i.e.</source>
          <target state="translated">계수가 함께 직선 형태 인자를 곱함으로써 결정된다 &lt;code&gt;(x - r_i)&lt;/code&gt; , 즉</target>
        </trans-unit>
        <trans-unit id="96b42532f49d3b3a4358a0737c1292c860f167f7" translate="yes" xml:space="preserve">
          <source>The column &lt;code&gt;v[:, i]&lt;/code&gt; is the normalized eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;. Will return a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">열 &lt;code&gt;v[:, i]&lt;/code&gt; 는 고유 값 &lt;code&gt;w[i]&lt;/code&gt; 해당하는 정규화 된 고유 벡터 입니다. 경우 행렬 객체를 반환 &lt;code&gt;a&lt;/code&gt; 매트릭스 개체입니다.</target>
        </trans-unit>
        <trans-unit id="05afae6f6316038b8a077ed2d79753233c9700ab" translate="yes" xml:space="preserve">
          <source>The column dimension of the arrays for which the returned arrays will be valid. By default &lt;code&gt;m&lt;/code&gt; is taken equal to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">반환 된 배열이 유효한 배열의 열 차원입니다. 기본적으로 &lt;code&gt;m&lt;/code&gt; 은 &lt;code&gt;n&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="049227627bd4dfed2d2a3d0a02023afddf2ece4d" translate="yes" xml:space="preserve">
          <source>The columns of the output matrix are powers of the input vector. The order of the powers is determined by the &lt;code&gt;increasing&lt;/code&gt; boolean argument. Specifically, when &lt;code&gt;increasing&lt;/code&gt; is False, the &lt;code&gt;i&lt;/code&gt;-th output column is the input vector raised element-wise to the power of &lt;code&gt;N - i - 1&lt;/code&gt;. Such a matrix with a geometric progression in each row is named for Alexandre- Theophile Vandermonde.</source>
          <target state="translated">출력 행렬의 열은 입력 벡터의 거듭 제곱입니다. 거듭 제곱의 순서는 부울 인수 가 &lt;code&gt;increasing&lt;/code&gt; 결정됩니다 . 구체적으로 &lt;code&gt;increasing&lt;/code&gt; 가 거짓 인 경우, &lt;code&gt;i&lt;/code&gt; 번째 출력 열은 &lt;code&gt;N - i - 1&lt;/code&gt; 의 거듭 제곱으로 요소 단위로 올린 입력 벡터 입니다. 각 행에 기하학적 진행이있는 이러한 행렬의 이름은 Alexandre-Theophile Vandermonde입니다.</target>
        </trans-unit>
        <trans-unit id="fd5ff7ed1e1b0436ec4f4722206a381ca973b853" translate="yes" xml:space="preserve">
          <source>The command &lt;code&gt;make test&lt;/code&gt; will ensure that all of the test software is built and then run all three test scripts.</source>
          <target state="translated">&lt;code&gt;make test&lt;/code&gt; 명령 은 모든 테스트 소프트웨어가 빌드되었는지 확인한 다음 세 가지 테스트 스크립트를 모두 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e66bb28254c2c47afebe31be29c7f178c6baf9ce" translate="yes" xml:space="preserve">
          <source>The committee must agree on a resolution by consensus. If the group cannot reach consensus and deadlocks for over a week, the group will turn the matter over to the Steering Council for resolution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f296a348ca6c5f048bde7ff72475becfa99bfb54" translate="yes" xml:space="preserve">
          <source>The committee will never publicly discuss the issue; all public statements will be made by the chair of the Code of Conduct Committee or the NumPy Steering Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1da455687a62d6eecd2b4975d23b71811215c8f1" translate="yes" xml:space="preserve">
          <source>The committee will respond to any report as soon as possible, and at most within 72 hours.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b080620b2cb81b4501691bc62009a0f3cdee2b1d" translate="yes" xml:space="preserve">
          <source>The committee will then review the incident and determine, to the best of their ability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24aa155f0fb452987333532fc0871b6b96e25258" translate="yes" xml:space="preserve">
          <source>The common data type, which is the maximum of &lt;code&gt;array_types&lt;/code&gt; ignoring &lt;code&gt;scalar_types&lt;/code&gt;, unless the maximum of &lt;code&gt;scalar_types&lt;/code&gt; is of a different kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;). If the kind is not understood, then None is returned.</source>
          <target state="translated">최대 인 공통 데이터 유형 &lt;code&gt;array_types&lt;/code&gt; 무시 &lt;code&gt;scalar_types&lt;/code&gt; 가 최대 않는 &lt;code&gt;scalar_types&lt;/code&gt; 는 다른 종류 (이다 &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ). 종류가 이해되지 않으면 None이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6557c9bc2aa7a334ee156279cd2e6ed26882b290" translate="yes" xml:space="preserve">
          <source>The common fill value, or None.</source>
          <target state="translated">공통 채우기 값 또는 없음</target>
        </trans-unit>
        <trans-unit id="792a2de181f669c74b9db5a5aeebd6abe9c93185" translate="yes" xml:space="preserve">
          <source>The common situations in which you need to change byte ordering are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7c4929011c41aa057f46d2bc4e51aaccf9a85a1" translate="yes" xml:space="preserve">
          <source>The companion matrix for power series cannot be made symmetric by scaling the basis, so this function differs from those for the orthogonal polynomials.</source>
          <target state="translated">파워 시리즈의 컴패니언 매트릭스는 기본을 스케일링하여 대칭으로 만들 수 없으므로이 함수는 직교 다항식의 함수와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="50728cc7411772baf0d23ae9dab7a04fd085919c" translate="yes" xml:space="preserve">
          <source>The comparison of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; uses standard broadcasting, which means that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; need not have the same shape in order for &lt;code&gt;allclose(a, b)&lt;/code&gt; to evaluate to True. The same is true for &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;equal&lt;/code&gt;&lt;/a&gt; but not &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt;&lt;code&gt;array_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 비교 는 표준 방송을 사용하므로 &lt;code&gt;allclose(a, b)&lt;/code&gt; 가 True로 평가되기 위해 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 모양이 동일 할 필요는 없습니다 . 동일은 마찬가지입니다 &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;equal&lt;/code&gt; &lt;/a&gt; 하지만 &lt;a href=&quot;numpy.array_equal#numpy.array_equal&quot;&gt; &lt;code&gt;array_equal&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9a376f5659e4753c56a46ffbea586e1c5b762b" translate="yes" xml:space="preserve">
          <source>The complex conjugate of &lt;code&gt;x&lt;/code&gt;, with same dtype as &lt;code&gt;y&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 와 동일한 dtype을 갖는 &lt;code&gt;x&lt;/code&gt; 의 복소 공액 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d1ca0ff74dd3394813701dd385de23f306fa9c69" translate="yes" xml:space="preserve">
          <source>The complex conjugate of a complex number is obtained by changing the sign of its imaginary part.</source>
          <target state="translated">복소수의 복소수 복소수는 허수 부분의 부호를 변경하여 얻습니다.</target>
        </trans-unit>
        <trans-unit id="41eb6fa093181f73897902c7f0874292edf29e51" translate="yes" xml:space="preserve">
          <source>The compressed array.</source>
          <target state="translated">압축 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5eb5823a400c379807aed8ab125dee97f320721d" translate="yes" xml:space="preserve">
          <source>The concatenated array with any masked entries preserved.</source>
          <target state="translated">마스크 된 항목이 보존 된 연결된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a37868502a5a0d6add95945d1a64803e757adeaa" translate="yes" xml:space="preserve">
          <source>The concatenated array.</source>
          <target state="translated">연결된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3af59c1bb124d9d3dff66fb6d58de527a5027e82" translate="yes" xml:space="preserve">
          <source>The concept of a behaved segment is used in the description of the function pointers. A behaved segment is one that is aligned and in native machine byte-order for the data-type. The &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;setitem&lt;/code&gt; functions can (and must) deal with mis-behaved arrays. The other functions require behaved memory segments.</source>
          <target state="translated">동작 세그먼트의 개념은 함수 포인터의 설명에 사용됩니다. 동작 세그먼트는 데이터 유형에 대해 기본 머신 바이트 순서로 정렬 된 세그먼트입니다. &lt;code&gt;nonzero&lt;/code&gt; 이 아닌 , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; 및 &lt;code&gt;setitem&lt;/code&gt; 함수는 잘못 동작하는 배열을 처리 할 수 ​​있으며 처리해야합니다. 다른 기능에는 동작 메모리 세그먼트가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="46e686c81ff0f33a7ee42cbdb148b2206e722231" translate="yes" xml:space="preserve">
          <source>The condition number of &lt;code&gt;x&lt;/code&gt; is defined as the norm of &lt;code&gt;x&lt;/code&gt; times the norm of the inverse of &lt;code&gt;x&lt;/code&gt;&lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;; the norm can be the usual L2-norm (root-of-sum-of-squares) or one of a number of other matrix norms.</source>
          <target state="translated">의 조건 수 &lt;code&gt;x&lt;/code&gt; 의 표준으로 정의 &lt;code&gt;x&lt;/code&gt; 배의 역수의 표준 &lt;code&gt;x&lt;/code&gt; &lt;a href=&quot;#r611900c44d60-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; ; 규범은 일반적인 L2- 노름 (제곱근) 또는 다른 많은 행렬 규범 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7ed508e4defcab357510ceacda28d2924496cd06" translate="yes" xml:space="preserve">
          <source>The condition number of the matrix. May be infinite.</source>
          <target state="translated">행렬의 조건 번호입니다. 무한 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c901451fe41cf6f1482465c84b6a4c739cbccbff" translate="yes" xml:space="preserve">
          <source>The config file generated from &lt;code&gt;template&lt;/code&gt; is installed in the given install directory, using &lt;code&gt;subst_dict&lt;/code&gt; for variable substitution.</source>
          <target state="translated">&lt;code&gt;template&lt;/code&gt; 에서 생성 된 구성 파일 은 변수 대체를 위해 &lt;code&gt;subst_dict&lt;/code&gt; 를 사용하여 지정된 설치 디렉토리에 설치 됩니다.</target>
        </trans-unit>
        <trans-unit id="2fe0070d6ccb31708b92b4e4ed2caabdfe3d249d" translate="yes" xml:space="preserve">
          <source>The constants &lt;strong&gt;NPY_INTP&lt;/strong&gt; and &lt;strong&gt;NPY_UINTP&lt;/strong&gt; refer to an enumerated integer type that is large enough to hold a pointer on the platform. Index arrays should always be converted to &lt;strong&gt;NPY_INTP&lt;/strong&gt; , because the dimension of the array is of type npy_intp.</source>
          <target state="translated">상수 &lt;strong&gt;NPY_INTP&lt;/strong&gt; 및 &lt;strong&gt;NPY_UINTP&lt;/strong&gt; 는 플랫폼에서 포인터를 보유하기에 충분히 큰 열거 된 정수 유형을 나타냅니다. 배열 의 차원은 npy_intp 유형이므로 인덱스 배열은 항상 &lt;strong&gt;NPY_INTP&lt;/strong&gt; 로 변환해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fd8a200b77c06e1513f552e8d61858be6438182d" translate="yes" xml:space="preserve">
          <source>The constructed array.</source>
          <target state="translated">생성 된 배열.</target>
        </trans-unit>
        <trans-unit id="8c8c3ae23d3b8b9d4c2965f608e114605317b1d2" translate="yes" xml:space="preserve">
          <source>The constructed extension module is saved as &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; to the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1564bd8e09196ae3556506f90562583aff6d8fc2" translate="yes" xml:space="preserve">
          <source>The content of a modified version of &lt;code&gt;fib1.pyf&lt;/code&gt; (saved as &lt;code&gt;fib2.pyf&lt;/code&gt;) is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f12164e316c899cbeec8a520db14b994fa35a8e" translate="yes" xml:space="preserve">
          <source>The contiguous constraint applies only to the inner loop, successive inner loops may have arbitrary pointer changes.</source>
          <target state="translated">연속 구속 조건은 내부 루프에만 적용되며, 연속 내부 루프에는 임의의 포인터 변경이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a28f32d0e2528be0855bfa01e7539cc0e939d215" translate="yes" xml:space="preserve">
          <source>The convenience classes provided by the polynomial package are:</source>
          <target state="translated">다항식 패키지가 제공하는 편의 클래스는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="5a4e9570e8f8bcacc96f206106a01eefad39bd6f" translate="yes" xml:space="preserve">
          <source>The convert method can also convert domain and window:</source>
          <target state="translated">convert 메소드는 도메인과 창을 변환 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="60131768e228b843852dbff6de95273c5e8b7bcb" translate="yes" xml:space="preserve">
          <source>The converted data-type.</source>
          <target state="translated">변환 된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="1fc6b89fce1f12a34477c12a69d7cd751ad23c91" translate="yes" xml:space="preserve">
          <source>The convolution operator is often seen in signal processing, where it models the effect of a linear time-invariant system on a signal &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. In probability theory, the sum of two independent random variables is distributed according to the convolution of their individual distributions.</source>
          <target state="translated">컨볼 루션 연산자는 신호 처리에서 종종 보이며, 여기서 신호에 대한 선형시 불변 시스템의 효과를 모델링합니다 &lt;a href=&quot;#r95849f33d2b1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . 확률 이론에서 두 개의 독립적 인 랜덤 변수의 합은 개별 분포의 컨벌루션에 따라 분포됩니다.</target>
        </trans-unit>
        <trans-unit id="1b7a113f553d13745aed52a84f8c20493ad427e3" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="translated">&lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 구조체 의 좌표 멤버는 기본 배열이 C 연속적이지 않는 한 현재 Nd 카운터를 유지합니다.이 경우 좌표 계산이 무시 됩니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 의 인덱스 멤버 는 반복자의 현재 플랫 인덱스를 추적합니다. &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; 매크로에 의해 업데이트됩니다 .</target>
        </trans-unit>
        <trans-unit id="a60368fcddf184df8cd7ef5081ac979bc50c50f2" translate="yes" xml:space="preserve">
          <source>The coordinates member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; structure maintains the current N-d counter unless the underlying array is C-contiguous in which case the coordinate counting is by-passed. The index member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the current flat index of the iterator. It is updated by the &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; macro.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893c6dfe4a5a151e44d6687fac35fbd3b646a45a" translate="yes" xml:space="preserve">
          <source>The core dimensions are removed from all inputs and the remaining dimensions are broadcast together, defining the loop dimensions.</source>
          <target state="translated">코어 치수는 모든 입력에서 제거되고 나머지 치수는 함께 브로드 캐스트되어 루프 치수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="72b350bebf37a78a10162e24af07cb3168e9e839" translate="yes" xml:space="preserve">
          <source>The core of the ufunc is the &lt;a href=&quot;#c.PyUFuncObject&quot;&gt;&lt;code&gt;PyUFuncObject&lt;/code&gt;&lt;/a&gt; which contains all the information needed to call the underlying C-code loops that perform the actual work. While it is described here for completeness, it should be considered internal to NumPy and manipulated via &lt;code&gt;PyUFunc_*&lt;/code&gt; functions. The size of this structure is subject to change across versions of NumPy. To ensure compatibility:</source>
          <target state="translated">ufunc의 핵심은 실제 작업을 수행하는 기본 C 코드 루프를 호출하는 데 필요한 모든 정보를 포함 하는 &lt;a href=&quot;#c.PyUFuncObject&quot;&gt; &lt;code&gt;PyUFuncObject&lt;/code&gt; &lt;/a&gt; 입니다. 완전성을 위해 여기에 설명되어 있지만 NumPy 내부에있는 것으로 간주하고 &lt;code&gt;PyUFunc_*&lt;/code&gt; 함수 를 통해 조작해야합니다 . 이 구조의 크기는 NumPy 버전에 따라 변경 될 수 있습니다. 호환성을 보장하려면</target>
        </trans-unit>
        <trans-unit id="773b5bb85bcdc60b3e588df5ec27ee1692be9141" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the shape of the full signal &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b1507243ebb36968e1fec7c90425484cafd21a" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the length of the original data, as given by &lt;code&gt;n&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. By Hermitian symmetry, the value is thus treated as purely real. To avoid losing information, the correct length of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37beab5b2e24a56105c7c01133a885f5a78e9481" translate="yes" xml:space="preserve">
          <source>The correct interpretation of the hermitian input depends on the shape of the original data, as given by &lt;code&gt;s&lt;/code&gt;. This is because each input shape could correspond to either an odd or even length signal. By default, &lt;a href=&quot;#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; assumes an even output length which puts the last entry at the Nyquist frequency; aliasing with its symmetric counterpart. When performing the final complex to real transform, the last value is thus treated as purely real. To avoid losing information, the correct shape of the real input &lt;strong&gt;must&lt;/strong&gt; be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b4be14cc8fe5491309195ba608e3525321fc00" translate="yes" xml:space="preserve">
          <source>The correlation coefficient matrix of the variables.</source>
          <target state="translated">변수의 상관 계수 행렬.</target>
        </trans-unit>
        <trans-unit id="f4e710373f0588180cd5157b94f36ff64a509ad5" translate="yes" xml:space="preserve">
          <source>The corresponding angle in degrees. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 각도 (도)입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a2c63fcb50ab2a66bb9a9ad01ce9f4ff69c1d271" translate="yes" xml:space="preserve">
          <source>The corresponding angle in radians. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">라디안 단위의 해당 각도. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="1f2189e088542b025710d6c9de389530dc9fecea" translate="yes" xml:space="preserve">
          <source>The corresponding argument is a function provided by user. The signature of this so-called call-back function can be defined</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35b3b067b2fb40c400d505d2d253ac20a239da1" translate="yes" xml:space="preserve">
          <source>The corresponding argument is considered as a required one. This is default. You need to specify &lt;code&gt;required&lt;/code&gt; only if there is a need to disable automatic &lt;code&gt;optional&lt;/code&gt; setting when &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b483a77dd25e17d676f790b212de11141a0187e" translate="yes" xml:space="preserve">
          <source>The corresponding argument is moved to the end of &lt;code&gt;&amp;lt;optional
arguments&amp;gt;&lt;/code&gt; list. A default value for an optional argument can be specified &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt;, see &lt;code&gt;entitydecl&lt;/code&gt; definition. Note that the default value must be given as a valid C expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2babda63010514076aef395fac45645683b9564" translate="yes" xml:space="preserve">
          <source>The corresponding array scalar type is &lt;code&gt;int32&lt;/code&gt;.</source>
          <target state="translated">해당 배열 스칼라 유형은 &lt;code&gt;int32&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cd11fa4205dd5b33a3e2b183413534954599bad7" translate="yes" xml:space="preserve">
          <source>The corresponding cosine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 코사인 값 &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="6d98f6605847a59a64fcad02a0b3d4fdfd44ca3d" translate="yes" xml:space="preserve">
          <source>The corresponding degree values; if &lt;code&gt;out&lt;/code&gt; was supplied this is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 정도 값; &lt;code&gt;out&lt;/code&gt; 이 제공된 경우 이는 참조입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2584010810109879710934f24451582df80fa088" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic sine values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 쌍곡 사인 값. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2f46b05f80b785698faf42d321e3104fa7625e8a" translate="yes" xml:space="preserve">
          <source>The corresponding hyperbolic tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 쌍곡 탄젠트 값입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d9ca95035c9f509708b9e99487c1ebe9e3ab11bd" translate="yes" xml:space="preserve">
          <source>The corresponding radian values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 라디안 값. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="c1e4a7360c69977ad10edc5bee560d5ac06dcf90" translate="yes" xml:space="preserve">
          <source>The corresponding tangent values. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">해당 탄젠트 값 &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="794da0dacd34a3a537b8957b7fa2b5dd6a0fb954" translate="yes" xml:space="preserve">
          <source>The corresponding user-provided Python function are then:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0e664cdf4ef8fa1adefc68661d3976d497abf20" translate="yes" xml:space="preserve">
          <source>The corresponding variable is Fortran 90 allocatable array defined as Fortran 90 module data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48e42f957c48b62c124f0261112a23bae77caa2c" translate="yes" xml:space="preserve">
          <source>The corresponding variable is a parameter and it must have a fixed value. F2PY replaces all parameter occurrences by their corresponding values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2320966ba7c65e57cb9263bdefeef1fa1cb2d7e" translate="yes" xml:space="preserve">
          <source>The corresponding variable is considered as an array with given dimensions in &lt;code&gt;&amp;lt;arrayspec&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1763b6e0e62ea8d29f68696fab1bd4ea96474d4" translate="yes" xml:space="preserve">
          <source>The cost for a matrix multiplication can be calculated with the following function:</source>
          <target state="translated">행렬 곱셈의 비용은 다음 함수를 사용하여 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6933bada15117031adec212786a3dbdf77a91aff" translate="yes" xml:space="preserve">
          <source>The costs for the two different parenthesizations are as follows:</source>
          <target state="translated">서로 다른 두 괄호의 비용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71417050531966fa2bba7739241abcc4b67310e0" translate="yes" xml:space="preserve">
          <source>The counterclockwise angle from the positive real axis on the complex plane in the range &lt;code&gt;(-pi, pi]&lt;/code&gt;, with dtype as numpy.float64.</source>
          <target state="translated">범위 &lt;code&gt;(-pi, pi]&lt;/code&gt; 의 복소 평면에서 양의 실수 축에서 시계 반대 방향 각도dtype이 numpy.float64 인 .</target>
        </trans-unit>
        <trans-unit id="1b6aacea9be65b883730cfcba5386d3d1b9a0223" translate="yes" xml:space="preserve">
          <source>The cov input is used to compute a factor matrix A such that &lt;code&gt;A @ A.T = cov&lt;/code&gt;. This argument is used to select the method used to compute the factor matrix A. The default method &amp;lsquo;svd&amp;rsquo; is the slowest, while &amp;lsquo;cholesky&amp;rsquo; is the fastest but less robust than the slowest method. The method &lt;code&gt;eigh&lt;/code&gt; uses eigen decomposition to compute A and is faster than svd but slower than cholesky.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="703b92f1857fec3346f55e95a27ed079fdf918ac" translate="yes" xml:space="preserve">
          <source>The covariance matrix of the variables.</source>
          <target state="translated">변수의 공분산 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="f56bfc3801b5981a49e90ddd94a5011933b03e11" translate="yes" xml:space="preserve">
          <source>The cross product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; in</source>
          <target state="translated">의 외적 및 &lt;code&gt;b&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="430c46a913654deeda9ef3928a00e710ee9f7b73" translate="yes" xml:space="preserve">
          <source>The ctypes attribute of an ndarray is also endowed with additional attributes that may be convenient when passing additional information about the array into a ctypes function. The attributes &lt;strong&gt;data&lt;/strong&gt;, &lt;strong&gt;shape&lt;/strong&gt;, and &lt;strong&gt;strides&lt;/strong&gt; can provide ctypes compatible types corresponding to the data-area, the shape, and the strides of the array. The data attribute returns a &lt;code&gt;c_void_p&lt;/code&gt; representing a pointer to the data area. The shape and strides attributes each return an array of ctypes integers (or None representing a NULL pointer, if a 0-d array). The base ctype of the array is a ctype integer of the same size as a pointer on the platform. There are also methods &lt;code&gt;data_as({ctype})&lt;/code&gt;, &lt;code&gt;shape_as(&amp;lt;base ctype&amp;gt;)&lt;/code&gt;, and &lt;code&gt;strides_as(&amp;lt;base
ctype&amp;gt;)&lt;/code&gt;. These return the data as a ctype object of your choice and the shape/strides arrays using an underlying base type of your choice. For convenience, the &lt;code&gt;ctypeslib&lt;/code&gt; module also contains &lt;code&gt;c_intp&lt;/code&gt; as a ctypes integer data-type whose size is the same as the size of &lt;code&gt;c_void_p&lt;/code&gt; on the platform (its value is None if ctypes is not installed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d70737d8a9b599cea578eef90e469f4ec5cade8d" translate="yes" xml:space="preserve">
          <source>The cumulative product for each column (i.e., over the rows) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">각각의 컬럼 (즉, 행) 이상 누적 제품 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4974aaba8d216c55c50471b0bc56ddd6323d0ebc" translate="yes" xml:space="preserve">
          <source>The cumulative product for each row (i.e. over the columns) of &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">의 (열 이상 예) 각 행에 대한 누적 제품 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50631d91282d5f6763c8dcfd14a90d74339342d9" translate="yes" xml:space="preserve">
          <source>The current (1-d) index into the broadcasted result.</source>
          <target state="translated">브로드 캐스트 결과에 대한 현재 (1-d) 인덱스</target>
        </trans-unit>
        <trans-unit id="8c233acaa927b0b3ae6437f9077a3fae3621ed5f" translate="yes" xml:space="preserve">
          <source>The current 1-d index into the array.</source>
          <target state="translated">배열에 대한 현재 1 차원 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="2fbbd9d31a318df9bc191ffa89f350440a39a71f" translate="yes" xml:space="preserve">
          <source>The current Python interface to the &lt;code&gt;f2py&lt;/code&gt; module is not mature and may change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbb3baf8a681bbb5337a5050d23b30de4d838c39" translate="yes" xml:space="preserve">
          <source>The current error handler. If no handler was set through &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;None&lt;/code&gt; is returned.</source>
          <target state="translated">현재 오류 처리기 더 처리기를 통해 설정되어 있지 않은 경우 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;None&lt;/code&gt; 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67a8fb2d19e8571c91416871498dce96f7ad1021" translate="yes" xml:space="preserve">
          <source>The current info on building and releasing NumPy and SciPy is scattered in several places. It should be summarized in one place, updated, and where necessary described in more detail. The sections below list all places where useful info can be found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fcd1e82b97c62204928be3c1426e12c2f8f2093c" translate="yes" xml:space="preserve">
          <source>The current interface remains unchanged, and &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; can still be used to implement (specialized) ufuncs, consisting of scalar elementary functions.</source>
          <target state="translated">현재 인터페이스는 변경되지 않고 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 를 사용하여 스칼라 기본 함수로 구성된 (특화된) ufunc를 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ec2778c22d5d6f2fae8e55f79998855331eeed7" translate="yes" xml:space="preserve">
          <source>The current membership of the NumFOCUS Subcommittee is listed at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4809e84f7d3a9eb68e3d6e9384c7ac43b19e108c" translate="yes" xml:space="preserve">
          <source>The current version of the ndarray object (check to see if this variable is defined to guarantee the numpy/arrayobject.h header is being used).</source>
          <target state="translated">ndarray 객체의 현재 버전입니다 (numpy / arrayobject.h 헤더가 사용되고 있는지 확인하려면이 변수가 정의되어 있는지 확인하십시오).</target>
        </trans-unit>
        <trans-unit id="d02692cc2b9183733a0e1ac33e907e722f2cb651" translate="yes" xml:space="preserve">
          <source>The data actually stored in object arrays (&lt;em&gt;i.e.&lt;/em&gt;, arrays having dtype &lt;code&gt;object_&lt;/code&gt;) are references to Python objects, not the objects themselves. Hence, object arrays behave more like usual Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;lists&lt;/code&gt;&lt;/a&gt;, in the sense that their contents need not be of the same Python type.</source>
          <target state="translated">실제로 객체 배열에 저장된 데이터는 ( &lt;em&gt;즉&lt;/em&gt; , DTYPE 가진 배열 &lt;code&gt;object_&lt;/code&gt; 은 파이썬은 객체)가 아닌 자신을 객체에 대한 참조입니다. 따라서 객체 배열 은 내용이 동일한 Python 유형일 필요가 없다는 점에서 일반적인 Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;lists&lt;/code&gt; &lt;/a&gt; 과 비슷하게 동작 합니다.</target>
        </trans-unit>
        <trans-unit id="2b8f4fa1516918fd8297afcfb360ffa13708823d" translate="yes" xml:space="preserve">
          <source>The data and all elements are aligned appropriately for the hardware.</source>
          <target state="translated">데이터와 모든 요소는 하드웨어에 맞게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="3286aa81b485c3d7add58cb76776a5c44fcb4bf2" translate="yes" xml:space="preserve">
          <source>The data area and all array elements are aligned appropriately.</source>
          <target state="translated">데이터 영역과 모든 배열 요소가 적절하게 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c1365a86184a90bddcccd2199d804c180d307014" translate="yes" xml:space="preserve">
          <source>The data area can be written to.</source>
          <target state="translated">데이터 영역에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="539587e7a7889df8e80a73151cc3ac06f87c111c" translate="yes" xml:space="preserve">
          <source>The data area can be written to. Setting this to False locks the data, making it read-only. A view (slice, etc.) inherits WRITEABLE from its base array at creation time, but a view of a writeable array may be subsequently locked while the base array remains writeable. (The opposite is not true, in that a view of a locked array may not be made writeable. However, currently, locking a base object does not lock any views that already reference it, so under that circumstance it is possible to alter the contents of a locked array via a previously created writeable view onto it.) Attempting to change a non-writeable array raises a RuntimeError exception.</source>
          <target state="translated">데이터 영역에 쓸 수 있습니다. 이것을 False로 설정하면 데이터가 잠기므로 읽기 전용이됩니다. 뷰 (슬라이스 등)는 생성시 기본 배열에서 WRITEABLE을 상속하지만 이후에 기본 배열이 쓰기 가능한 상태로있는 동안 쓰기 가능한 배열의보기가 잠길 수 있습니다. 잠긴 배열의보기를 쓸 수 없다는 점에서 반대는 사실이 아닙니다. 그러나 현재 기본 개체를 잠그더라도 이미 참조하는 모든보기를 잠그지 않으므로 해당 상황에서 내용을 변경할 수 있습니다 쓰기 불가능한 배열을 변경하려고하면 RuntimeError 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dfe7ced9a654feaf927f01f408558bf43f63134c" translate="yes" xml:space="preserve">
          <source>The data area is in C-style contiguous order (last index varies the fastest).</source>
          <target state="translated">데이터 영역은 C 스타일의 연속 순서입니다 (마지막 인덱스는 가장 빠름).</target>
        </trans-unit>
        <trans-unit id="28271e4f2d83215b5c3293be14583eebd0638934" translate="yes" xml:space="preserve">
          <source>The data area is in Fortran-style contiguous order (first index varies the fastest).</source>
          <target state="translated">데이터 영역은 포트란 스타일의 연속 순서입니다 (첫 번째 인덱스가 가장 빠름).</target>
        </trans-unit>
        <trans-unit id="a2e621a0b9254b737a1faf535f1456a6f33c01ae" translate="yes" xml:space="preserve">
          <source>The data area is owned by this array.</source>
          <target state="translated">이 배열은 데이터 영역을 소유합니다.</target>
        </trans-unit>
        <trans-unit id="ca9e054ad351441ecdb18cea4952500858e11b12" translate="yes" xml:space="preserve">
          <source>The data area represents a (well-behaved) copy whose information should be transferred back to the original when &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">데이터 영역은 &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 일&lt;/a&gt; 때 정보를 원본으로 다시 전송해야하는 (잘 작동하는) 사본을 나타냅니다. 가 호출 가 .</target>
        </trans-unit>
        <trans-unit id="15eb3cf2a1c1abdf07a79e9fe9ea7b5a63c62afd" translate="yes" xml:space="preserve">
          <source>The data in the array is returned as a single string. This function is similar to &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt;, the difference being that &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; also returns information on the kind of array and its data type.</source>
          <target state="translated">배열의 데이터는 단일 문자열로 반환됩니다. 이 함수는 &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; 과 유사하지만 차이점은 &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; 또한 어레이의 종류 및 그 데이터 형식에 대한 정보를 반환한다.</target>
        </trans-unit>
        <trans-unit id="4cbbe8ca710f692f60ad1bfe0fc2af00b27f6fa9" translate="yes" xml:space="preserve">
          <source>The data in the same field can be heterogeneous, they will be promoted to the highest data type. This method is intended for creating smaller record arrays. If used to create large array without formats defined</source>
          <target state="translated">동일한 필드의 데이터는이기 종일 수 있으며 최고 데이터 유형으로 승격됩니다. 이 방법은 더 작은 레코드 배열을 만들기위한 것입니다. 형식을 정의하지 않고 큰 배열을 만드는 데 사용되는 경우</target>
        </trans-unit>
        <trans-unit id="f030fb38724d73d189a884d6cd4eaca4e1c69e90" translate="yes" xml:space="preserve">
          <source>The data is in a single, C-style contiguous segment.</source>
          <target state="translated">데이터는 단일 C 스타일 연속 세그먼트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f1d8da4b437441472e9916d9ae01c496d02e5d4" translate="yes" xml:space="preserve">
          <source>The data is in a single, Fortran-style contiguous segment.</source>
          <target state="translated">데이터는 단일 포트란 스타일의 연속 세그먼트에 있습니다.</target>
        </trans-unit>
        <trans-unit id="56a1a480524e7bf67ab594cb10c3c6101b00713c" translate="yes" xml:space="preserve">
          <source>The data of the resulting array will not be byteswapped, but will be interpreted correctly.</source>
          <target state="translated">결과 배열의 데이터는 바이트 랩핑되지 않지만 올바르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="b88d2dbaff9987ad87362817ef4a120d93a6244e" translate="yes" xml:space="preserve">
          <source>The data to be histogrammed.</source>
          <target state="translated">히스토그램 될 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="5386b778229b14d65914edc6d972b4efb28b5001" translate="yes" xml:space="preserve">
          <source>The data type object associated with the array can be found in the &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attribute:</source>
          <target state="translated">배열과 연관된 데이터 유형 오브젝트는 &lt;a href=&quot;generated/numpy.ndarray.dtype#numpy.ndarray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 속성 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c7886ffa6332318e280aa7625497d4df1ee7f24" translate="yes" xml:space="preserve">
          <source>The data type of &lt;code&gt;rep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; 의 데이터 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="4b822d3fbc39f811ebad48ba4194f76d214d3123" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="translated">이 플래그가있는 피연산자의 데이터 유형은 &lt;a href=&quot;c-api.dtype#c.NPY_BOOL&quot;&gt; &lt;code&gt;NPY_BOOL&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_MASK&quot;&gt; &lt;code&gt;NPY_MASK&lt;/code&gt; &lt;/a&gt; 또는 필드가 모두 유효한 마스크 dtype 인 struct dtype이어야합니다. 후자의 경우, 해당 배열의 각 필드에 마스크를 지정하므로 WRITEMASKED 인 구조체 피연산자와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba40ae5f60c6c9bf8317272fcf427a71c0e5f01a" translate="yes" xml:space="preserve">
          <source>The data type of an operand with this flag should be either &lt;a href=&quot;dtype#c.NPY_BOOL&quot;&gt;&lt;code&gt;NPY_BOOL&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_MASK&quot;&gt;&lt;code&gt;NPY_MASK&lt;/code&gt;&lt;/a&gt;, or a struct dtype whose fields are all valid mask dtypes. In the latter case, it must match up with a struct operand being WRITEMASKED, as it is specifying a mask for each field of that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11db59fda83e28216c250b45f855268127882d3e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format.</source>
          <target state="translated">배열의 데이터 유형입니다. 디폴트 : float. 이진 입력 데이터의 경우 데이터는 정확히이 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="7ef4dd0c7cf28c23f4cb2015d84e3c63ca538a1e" translate="yes" xml:space="preserve">
          <source>The data type of the array; default: float. For binary input data, the data must be in exactly this format. Most builtin numeric types are supported and extension types may be supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6121c8d9cd39c4f61e9ffef0d098e3b7d36639d6" translate="yes" xml:space="preserve">
          <source>The data type of the output of &lt;code&gt;vectorized&lt;/code&gt; is determined by calling the function with the first element of the input. This can be avoided by specifying the &lt;code&gt;otypes&lt;/code&gt; argument.</source>
          <target state="translated">&lt;code&gt;vectorized&lt;/code&gt; 출력의 데이터 유형은 입력의 첫 번째 요소로 함수를 호출하여 결정됩니다. &lt;code&gt;otypes&lt;/code&gt; 인수 를 지정하면이를 피할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc2814a7f847db35d30b7458174ec64d03a7e7a5" translate="yes" xml:space="preserve">
          <source>The data type of the view. The dtype size of the view can not be larger than that of the array itself.</source>
          <target state="translated">뷰의 데이터 유형입니다. 뷰의 dtype 크기는 배열 자체의 크기보다 클 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="99643c3f7e25f9a00992f90ee5d0bdd7cb79f63e" translate="yes" xml:space="preserve">
          <source>The data types of the values provided in &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt;&lt;code&gt;value&lt;/code&gt;&lt;/a&gt;. This may be different from the operand data types if buffering is enabled. Valid only before the iterator is closed.</source>
          <target state="translated">값의 데이터 유형에 제공된 &lt;a href=&quot;numpy.nditer.value#numpy.nditer.value&quot;&gt; &lt;code&gt;value&lt;/code&gt; &lt;/a&gt; . 버퍼링이 사용 가능한 경우 피연산자 데이터 유형과 다를 수 있습니다. 반복자가 닫히기 전에 만 유효합니다.</target>
        </trans-unit>
        <trans-unit id="9d016fef105a6db00651ac782a1c7e9c999e6600" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="translated">데이터 유형은 ndarray의 중요한 추상화입니다. 작업은 어레이에서 작동하는 데 필요한 주요 기능을 제공하기 위해 데이터 유형을 찾습니다. 이 기능은 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 의 'f'멤버가 가리키는 함수 포인터 목록에 제공됩니다 . 이러한 방식으로, &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 을 제공함으로써 데이터 유형의 수를 간단히 확장 할 수 있습니다 'f'멤버에 적절한 함수 포인터를 가진 구조를 . 내장 유형의 경우이 메커니즘을 우회하는 최적화가 있지만 데이터 유형 추상화의 요점은 새로운 데이터 유형을 추가 할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3bc7ca60ba414cbf4855ce7f1e99de3ef90f6929" translate="yes" xml:space="preserve">
          <source>The data-type is an important abstraction of the ndarray. Operations will look to the data-type to provide the key functionality that is needed to operate on the array. This functionality is provided in the list of function pointers pointed to by the &amp;lsquo;f&amp;rsquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure. In this way, the number of data-types can be extended simply by providing a &lt;a href=&quot;c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure with suitable function pointers in the &amp;lsquo;f&amp;rsquo; member. For built-in types there are some optimizations that by-pass this mechanism, but the point of the data- type abstraction is to allow new data-types to be added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58fbdafeaa8107e58c408c096a3cb8ca5d659d7" translate="yes" xml:space="preserve">
          <source>The data-type of the returned array.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="5c8d679fa5d2836b35d4e189ea3c3c42c4a9bfcc" translate="yes" xml:space="preserve">
          <source>The data-type used to interpret the file contents. Default is &lt;code&gt;uint8&lt;/code&gt;.</source>
          <target state="translated">파일 내용을 해석하는 데 사용되는 데이터 유형입니다. 기본값은 &lt;code&gt;uint8&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e1e17b816f5aa8d3b539033dd4f8579bd040ce7c" translate="yes" xml:space="preserve">
          <source>The data-type used to represent the intermediate results. Defaults to the data-type of the output array if such is provided, or the the data-type of the input array if no output array is provided.</source>
          <target state="translated">중간 결과를 나타내는 데 사용되는 데이터 유형입니다. 출력 배열이 제공되는 경우 기본적으로 출력 배열의 데이터 유형으로, 출력 배열이 제공되지 않은 경우 입력 배열의 데이터 유형으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="932e882a29033e270334b0a0ca27c7a0b749d38c" translate="yes" xml:space="preserve">
          <source>The data-type-descriptor object of the base-type.</source>
          <target state="translated">기본 유형의 데이터 유형 설명자 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="d6987a7425e0ff97a8320c32ec6abc8ee62f4f4d" translate="yes" xml:space="preserve">
          <source>The datatype determines which of &amp;lsquo;mergesort&amp;rsquo; or &amp;lsquo;timsort&amp;rsquo; is actually used, even if &amp;lsquo;mergesort&amp;rsquo; is specified. User selection at a finer scale is not currently available.</source>
          <target state="translated">데이터 유형은 'mergesort'가 지정되어 있어도 실제로 사용되는 'mergesort'또는 'timsort'중 어느 것을 결정합니다. 더 미세한 규모의 사용자 선택은 현재 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f8494cadb009486b1d5ee5b6a13352cbf85e331c" translate="yes" xml:space="preserve">
          <source>The datetime API is &lt;em&gt;experimental&lt;/em&gt; in 1.7.0, and may undergo changes in future versions of NumPy.</source>
          <target state="translated">datetime API는 1.7.0에서 &lt;em&gt;실험&lt;/em&gt; 중이며 이후 버전의 NumPy에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5a29e38fde2fbef6d304ea68f9f28e90e826577d" translate="yes" xml:space="preserve">
          <source>The datetime object represents a single moment in time. If two datetimes have different units, they may still be representing the same moment of time, and converting from a bigger unit like months to a smaller unit like days is considered a &amp;lsquo;safe&amp;rsquo; cast because the moment of time is still being represented exactly.</source>
          <target state="translated">datetime 객체는 단일 시점을 나타냅니다. 두 날짜 시간의 단위가 다른 경우에도 여전히 동일한 시간을 나타내는 것일 수 있으며, 월과 같은 더 큰 단위를 일과 같은 더 작은 단위로 변환하는 것은 여전히 ​​정확한 시점으로 표시되기 때문에 '안전한 캐스트'로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="96194d206533dca35ec887829a70fc8982e7d450" translate="yes" xml:space="preserve">
          <source>The datetime string parser in NumPy 1.6 is very liberal in what it accepts, and silently allows invalid input without raising errors. The parser in NumPy 1.7 is quite strict about only accepting ISO 8601 dates, with a few convenience extensions. 1.6 always creates microsecond (us) units by default, whereas 1.7 detects a unit based on the format of the string. Here is a comparison.:</source>
          <target state="translated">NumPy 1.6의 datetime 문자열 파서는 그것이 받아들이는 것에서 매우 자유롭고 오류를 일으키지 않고 유효하지 않은 입력을 자동으로 허용합니다. NumPy 1.7의 파서는 ISO 8601 날짜 만 받아들이는 것에 대해 매우 엄격하며 몇 가지 편의 확장 기능이 있습니다. 1.6은 기본적으로 항상 마이크로 초 (us) 단위를 생성하는 반면 1.7은 문자열 형식에 따라 단위를 감지합니다. 비교는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1369383d5a514fcfed8df04d6ed924de54d6f3b1" translate="yes" xml:space="preserve">
          <source>The datetime type works with many common NumPy functions, for example &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt;&lt;code&gt;arange&lt;/code&gt;&lt;/a&gt; can be used to generate ranges of dates.</source>
          <target state="translated">날짜 시간 유형은 많은 일반적인 NumPy 함수와 함께 작동합니다. 예를 들어 &lt;a href=&quot;generated/numpy.arange#numpy.arange&quot;&gt; &lt;code&gt;arange&lt;/code&gt; &lt;/a&gt; 는 날짜 범위를 생성하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d7f83834880a987611358eebe758ac593dc7d2" translate="yes" xml:space="preserve">
          <source>The decomposition is performed using LAPACK routine &lt;code&gt;_gesdd&lt;/code&gt;.</source>
          <target state="translated">분해는 LAPACK 루틴 &lt;code&gt;_gesdd&lt;/code&gt; 를 사용하여 수행됩니다 .</target>
        </trans-unit>
        <trans-unit id="e1516fc7b62e4a0344208958aa595053689db869" translate="yes" xml:space="preserve">
          <source>The decorated test &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">장식 시험 &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9657b7f30a96eb6a9709525e36cff8e84658cbb" translate="yes" xml:space="preserve">
          <source>The decorator itself is decorated with the &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; function in order to transmit function name, and various other metadata.</source>
          <target state="translated">데코레이터 자체는 함수 이름 및 기타 다양한 메타 데이터를 전송하기 위해 &lt;code&gt;nose.tools.make_decorator&lt;/code&gt; 함수로 장식되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4a37da8a9aa52a4088272dd54ccf6dae2a209ad8" translate="yes" xml:space="preserve">
          <source>The default &lt;code&gt;atol&lt;/code&gt; is not appropriate for comparing numbers that are much smaller than one (see Notes).</source>
          <target state="translated">기본 &lt;code&gt;atol&lt;/code&gt; 은 1보다 훨씬 작은 숫자를 비교하는 데 적합하지 않습니다 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="cb5293865f62263e0a19bbfa34c77f6486814f1d" translate="yes" xml:space="preserve">
          <source>The default __array_priority__ of matrix objects is 10.0, and therefore mixed operations with ndarrays always produce matrices.</source>
          <target state="translated">행렬 객체의 기본 __array_priority__는 10.0이므로 ndarray와의 혼합 연산은 항상 행렬을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="cd69cae26ca025156d4d72a557a24e650bb3e040" translate="yes" xml:space="preserve">
          <source>The default character, this is returned if none of the characters in &lt;code&gt;typechars&lt;/code&gt; matches a character in &lt;code&gt;typeset&lt;/code&gt;.</source>
          <target state="translated">기본 문자. &lt;code&gt;typechars&lt;/code&gt; 의 문자가 &lt;code&gt;typeset&lt;/code&gt; 의 문자와 일치 하지 않으면 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPy의 기본 데이터 유형은 &lt;code&gt;float_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">기본 데이터 형식 : &lt;code&gt;float_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">기본 채우기 값입니다.</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">기본 채우기 값은 입력 배열의 데이터 유형 또는 입력 스칼라 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday 기능의 기본값은 월요일부터 금요일 (일반 업무 일)까지만 유효합니다. 구현은 유효한 요일을 나타 내기 위해 7 개의 부울 플래그를 포함하는 &quot;weekmask&quot;를 기반으로합니다. 다른 유효한 요일 세트를 지정하는 사용자 정의 주 마스크가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">대부분의 작업에 대한 기본값은 인덱스가 범위를 벗어난 경우 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f01d70d1a58c31eb28ef483c3e412b7730114894" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">기본값은 현재 동작을 변경하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35460c572d36a32620dc9fa812780440e2fcffff" translate="yes" xml:space="preserve">
          <source>The default is to &lt;code&gt;'warn'&lt;/code&gt; for &lt;code&gt;invalid&lt;/code&gt;, &lt;code&gt;divide&lt;/code&gt;, and &lt;code&gt;overflow&lt;/code&gt; and &lt;code&gt;'ignore'&lt;/code&gt; for &lt;code&gt;underflow&lt;/code&gt;. But this can be changed, and it can be set individually for different kinds of exceptions. The different behaviors are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarray 객체의 기본 반복자는 시퀀스 유형의 기본 Python 반복기입니다. 따라서 배열 객체 자체가 반복자로 사용되는 경우 기본 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aac361851a1a42c7bb314d3f5e868ac753b52020" translate="yes" xml:space="preserve">
          <source>The default method is &amp;ldquo;marginals&amp;rdquo;. For some cases (e.g. when &lt;code&gt;colors&lt;/code&gt; contains relatively small integers), the &amp;ldquo;count&amp;rdquo; method can be significantly faster than the &amp;ldquo;marginals&amp;rdquo; method. If performance of the algorithm is important, test the two methods with typical inputs to decide which works best.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">기본 정규화에는 직접 변환의 배율이 조정되지 않으며 역 변환의 배율이</target>
        </trans-unit>
        <trans-unit id="294bd9e52acfdc133dee5d5ce445aefb23018ef1" translate="yes" xml:space="preserve">
          <source>The default order for the libraries are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">순위 부족을 감지하기위한 기본 임계 값은 &lt;code&gt;M&lt;/code&gt; 의 특이 값 크기에 대한 테스트입니다 . 기본적으로 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 보다 작은 특이 값을 순위 부족을 나타냅니다 (위에 정의 된 기호 사용). 이것이 MATLAB이 사용하는 알고리즘입니다 [1]. 또한 선형 최소 제곱에 대한 SVD 솔루션에 대한 논의 에서 &lt;em&gt;수치 레시피&lt;/em&gt; 에도 나타납니다 [2].</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">np.zero (shape)를 호출 할 때와 같이 dtype이 명시 적으로 지정되지 않은 경우 사용할 기본 유형입니다. 이것은 &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">기본 유효일은 월요일부터 금요일 ( &quot;영업일&quot;)입니다. busdaycalendar 객체는 주 단위로 유효한 요일과 항상 유효하지 않은 선택적 &quot;휴일&quot;날짜로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">기본값 ( 'S')은 현재 바이트 순서를 교체합니다. 이 코드는 위의 대안에 대해 &lt;code&gt;new_order&lt;/code&gt; 의 첫 글자를 대소 문자를 구분하지 않고 검사합니다 . 예를 들어, 'B'또는 'b'또는 'biggish'는 big-endian을 지정하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="86906072113e4cc2809d8408fb9acbe0a4443ef7" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;names&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. If we give any other value to the keyword, the new names will overwrite the field names we may have defined with the dtype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">해독제 정의 특성 :</target>
        </trans-unit>
        <trans-unit id="7a4397ef8c9f537d85068ef5bbb9a575412a21fb" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;C&lt;/code&gt; is the same as before, but for &lt;code&gt;D&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method returns an instance of class &lt;code&gt;C&lt;/code&gt; rather than &lt;code&gt;D&lt;/code&gt;. Note that the &lt;code&gt;__init__&lt;/code&gt; method of &lt;code&gt;D&lt;/code&gt; does not get called. In general, when the &lt;code&gt;__new__&lt;/code&gt; method returns an object of class other than the class in which it is defined, the &lt;code&gt;__init__&lt;/code&gt; method of that class is not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">고급 인덱싱 수단의 정의가 &lt;code&gt;x[(1,2,3),]&lt;/code&gt; 과 근본적으로 상이하다 &lt;code&gt;x[(1,2,3)]&lt;/code&gt; . 후자는 &lt;code&gt;x[1,2,3]&lt;/code&gt; 과 동일하며 기본 선택은 트리거하고 전자는 고급 인덱싱을 트리거합니다. 왜 이런 일이 발생하는지 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">위의 상관 정의는 고유하지 않으며 때로는 상관이 다르게 정의 될 수도 있습니다. 또 다른 일반적인 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="938e670c022b166026c1f3d97b60b6e6eed3f831" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; part is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1f4801e8c8f57fdee23b9a4f5485bae04f50607" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ed0cf6ae14e241898a603f2c9052eee0f3ff8c" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">시리즈의 정도.</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">종속 목록에는 확장 모듈의 소스가 의존하는 파일 또는 디렉토리의 경로가 포함됩니다. 종속 목록의 경로가 확장 모듈보다 최신이면 모듈이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8add200746bc778285c2910a22d91b2b8b258c85" translate="yes" xml:space="preserve">
          <source>The deprecated function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">t- 분포의 유도는 1908 년 윌리엄 고셋 (William Gosset)에 의해 더블린의 기네스 브루어리 (Guinness Brewery)에서 일하면서 처음 출판되었다. 독점적 인 문제로 인해 그는 가명으로 출판해야했기 때문에 학생이라는 이름을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">다항식의 미분</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">__array_struct__에서 반환 된 PyCObject의 desc 멤버가 지정되지 않았습니다. 일반적으로 배열을 노출시키는 것은 객체였습니다 (따라서 C 객체가 파괴 될 때 어레이에 대한 참조를 유지하고 파괴 할 수 있습니다). 이제 첫 번째 요소가 &quot;PyArrayInterface Version #&quot;이있는 문자열이고 두 번째 요소가 배열을 노출하는 객체 인 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">따라서 헤더의 네 번째 요소에 대한 설명은 다음과 같습니다. &quot;다음 4 바이트는 리틀 엔디안 부호없는 int를 형성합니다. 헤더 데이터 길이 HEADER_LEN.&quot;</target>
        </trans-unit>
        <trans-unit id="877e58bc0c85ccf0ef190f149115500e0d385da1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array The default, None, means</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">어레이, 예를 들어, 데이터에 대한 원하는 형태 &lt;code&gt;numpy.int8&lt;/code&gt; . 기본값은 &lt;code&gt;numpy.float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0a8a7651b0b383e3707246aaf8cd38e2e169098" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">배열의 원하는 데이터 유형입니다. 지정하지 않으면 유형이 순서대로 오브젝트를 보유하는 데 필요한 최소 유형으로 결정됩니다. 이 인수는 배열을 '업 캐스트'하는 데만 사용할 수 있습니다. 다운 캐스팅의 경우 .astype (t) 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">행렬에 대해 원하는 데이터 유형이며 기본값은 float입니다.</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">매트릭스에 대한 원하는 데이터 유형, 기본값은 np.float64입니다.</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">원하는 데이터 유형 기본적으로 데이터 유형은 &lt;code&gt;formats&lt;/code&gt; , &lt;code&gt;names&lt;/code&gt; , &lt;code&gt;titles&lt;/code&gt; , &lt;code&gt;aligned&lt;/code&gt; 및 &lt;code&gt;byteorder&lt;/code&gt; 에서 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">배열의 원하는 모양입니다. 경우 &lt;code&gt;mode == 'r'&lt;/code&gt; 이후 나머지 바이트의 수 &lt;code&gt;offset&lt;/code&gt; 의 바이트 크기의 배수가 아닌 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 를 지정해야합니다 &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; . 기본적으로 반환 된 배열은 파일 크기 및 데이터 유형에 따라 결정된 요소 수와 함께 1 차원입니다.</target>
        </trans-unit>
        <trans-unit id="c217d27d3179585b289f1730298cd76c28917559" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">반복자의 원하는 모양입니다. 이를 통해 다른 피연산자의 차원에 해당하지 않는 op_axes에 의해 매핑 된 차원으로 피연산자를 &lt;code&gt;allocate&lt;/code&gt; 하여 해당 차원에 대해 1이 아닌 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">원하는 예상 개체입니다.</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">결정자는 LAPACK 루틴 &lt;code&gt;z/dgetrf&lt;/code&gt; 를 사용하여 LU 인수 분해를 통해 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">2 차원 배열 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; 의 결정 요인 은 &lt;code&gt;ad - bc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">2 차원 배열 [[a, b], [c, d]]의 결정 요인은 ad-bc입니다.</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">정사각형 Vandermonde 행렬의 결정 요인은 입력 벡터 값의 차이의 곱입니다.</target>
        </trans-unit>
        <trans-unit id="60279460274321ba74cf96556a38bac9a87c73c6" translate="yes" xml:space="preserve">
          <source>The diagonal and diag functions return readonly views.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">사전에는 세 개의 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7980c83ed9b10778dab7b594015b0c4b8c1b820c" translate="yes" xml:space="preserve">
          <source>The dictionary has two required keys, &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo;, and four optional keys, &amp;lsquo;offsets&amp;rsquo;, &amp;lsquo;itemsize&amp;rsquo;, &amp;lsquo;aligned&amp;rsquo; and &amp;lsquo;titles&amp;rsquo;. The values for &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo; should respectively be a list of field names and a list of dtype specifications, of the same length. The optional &amp;lsquo;offsets&amp;rsquo; value should be a list of integer byte-offsets, one for each field within the structure. If &amp;lsquo;offsets&amp;rsquo; is not given the offsets are determined automatically. The optional &amp;lsquo;itemsize&amp;rsquo; value should be an integer describing the total size in bytes of the dtype, which must be large enough to contain all the fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">사전은 필드 이름 인 키로 색인화됩니다. 사전의 각 항목은 필드를 완전히 설명하는 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="fc72cbc84ea7846d80156db81f03031e6342d2d0" translate="yes" xml:space="preserve">
          <source>The dictionary with build information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88918f47eb3cf48e5a0737e099c91aa35bc38894" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;eps = 2**-52&lt;/code&gt;, approximately 2.22e-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1d6f22ac980a152a56489087bf48f813ef3afe4" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float less than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;epsneg = 2**-53&lt;/code&gt;, approximately 1.11e-16.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">요소 별 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 의 차이 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">배열의 연속 요소 간의 차이점</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">차이점들. 느슨하게, 이것은 &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">다양한 유형의 보간을 그래픽으로 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">비트 패킹이 수행되는 차원입니다. &lt;code&gt;None&lt;/code&gt; 은 평평한 배열의 포장을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">비트 언 패킹이 수행되는 차원입니다. &lt;code&gt;None&lt;/code&gt; 은 평평한 배열의 포장 풀기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">기본 함수의 각 입력 / 출력의 차원은 핵심 차원에 의해 정의됩니다 (제로 코어 차원은 스칼라 입력 / 출력에 해당). 코어 치수는 입력 / 출력 어레이의 마지막 치수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">출력의 차원은 다음 중 가장 큰 것과 같습니다. * 모든 입력의 차원 * 입력 목록이 중첩되는 깊이</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">코어 치수 이외의 치수를 &quot;루프&quot;치수라고합니다. 위의 예에서 이는 &lt;code&gt;(3, 5)&lt;/code&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">이터레이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">반환 된 배열의 크기는 음수가 아니어야합니다. 인수가 제공되지 않으면 단일 Python float가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 의 다음 표현 가능한 값을 찾을 방향 입니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">할인율입니다.</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">이산 컨벌루션 연산은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3ebfde94166d29a8529279eac1b981ebfd74c7" translate="yes" xml:space="preserve">
          <source>The distance between a value and the nearest adjacent number</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb9069c190fd0543a41e23dc5a8c21be130414b2" translate="yes" xml:space="preserve">
          <source>The docstring consists of a number of sections separated by headings (except for the deprecation warning). Each heading should be underlined in hyphens, and the section ordering should be consistent with the description below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">함수의 docstring입니다. 경우 &lt;code&gt;None&lt;/code&gt; , 문서화 문자열이 될 것입니다 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f20cb6df02e7c9d27955f240a3eb4c2a8d28a69" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If None, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">문서화 문자열은 입력 함수에서 지정하지 않으면 &lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt; 하기 위해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">doctest는 마치 &lt;code&gt;import numpy as np&lt;/code&gt; 실행 한 새로운 Python 인스턴스에있는 것처럼 실행 됩니다 . SciPy 서브 패키지의 일부인 테스트는 해당 서브 패키지를 이미 가져 왔습니다. 예를 들어 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 테스트의 경우 네임 스페이스는 &lt;code&gt;from scipy import linalg&lt;/code&gt; 에서 이미 실행 되도록 만들어 집니다.</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">doctests는 &lt;code&gt;test()&lt;/code&gt; 호출에 &lt;code&gt;doctests&lt;/code&gt; 인수를 추가하여 실행할 수 있습니다 . 예를 들어, numpy.lib에 대한 모든 테스트 (doctest 포함)를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">doctest는 &lt;code&gt;doctests&lt;/code&gt; 인수를 &lt;code&gt;test()&lt;/code&gt; 호출 에 추가하여 사용자 / 개발자가 실행할 수 있습니다 . 예를 들어, &lt;code&gt;numpy.lib&lt;/code&gt; 에 대한 모든 테스트 (doctest 포함)를 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8aa7b1eda9c3eb10663105fc5334308467be1f5" translate="yes" xml:space="preserve">
          <source>The documentation for NumPy distributed at &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; in html and pdf format is also built with &lt;code&gt;make dist&lt;/code&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt; for details on how to update &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b422de92d847bc36480d44f7ae27cfbb5060f6f" translate="yes" xml:space="preserve">
          <source>The documentation includes mathematical formulae with LaTeX formatting. A working LaTeX document production system (e.g. &lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt;) is required for the proper rendering of the LaTeX math in the documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="400ca1ed6dc999bcaec7408745f9b97e9991d699" translate="yes" xml:space="preserve">
          <source>The documentation is written in restructuredText, which is the format required by Sphinx, the tool most Python projects use to automatically build and link the documentation within the project. You can read the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">변환 된 계열의 도메인 값이 None이면 기본 도메인 &lt;code&gt;kind&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">그려진 샘플 (모양, 크기, alpha.ndim)</target>
        </trans-unit>
        <trans-unit id="3a196841b4dbf99e3d83d366571811ca5768d106" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;code&gt;(size, k)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 모양 &lt;em&gt;크기&lt;/em&gt; 의 그려진 샘플 . 그렇지 않은 경우 모양은 &lt;code&gt;(N,)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">그려진 샘플.</target>
        </trans-unit>
        <trans-unit id="7c49825e402bb2a6069cc023cee23e3ad1ab0d7c" translate="yes" xml:space="preserve">
          <source>The dtype object also has a dictionary-like attribute, &lt;code&gt;fields&lt;/code&gt;, whose keys are the field names (and &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt;, see below) and whose values are tuples containing the dtype and byte offset of each field.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">해야 DTYPE 개체, &lt;code&gt;datetime64&lt;/code&gt; 또는 &lt;code&gt;timedelta64&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">마스킹 된 배열의 dtype은 &lt;code&gt;arr&lt;/code&gt; 의 dtype과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1cb33880062e286521366b55fc98dd4daef4b644" translate="yes" xml:space="preserve">
          <source>The dtype of the output unstructured array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">변환 할 dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">변환 할 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="0d0946ed17f6fb426bc55c84df183c8474945340" translate="yes" xml:space="preserve">
          <source>The dummy argument is not used in this context and can be safely ignored. The &lt;em&gt;args&lt;/em&gt; argument contains all of the arguments passed in to the function as a tuple. You can do anything you want at this point, but usually the easiest way to manage the input arguments is to call &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses_to_C_variables&amp;hellip;) or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; (tuple, &amp;ldquo;name&amp;rdquo;, min, max, &amp;hellip;). A good description of how to use the first function is contained in the Python C-API reference manual under section 5.5 (Parsing arguments and building values). You should pay particular attention to the &amp;ldquo;O&amp;amp;&amp;rdquo; format which uses converter functions to go between the Python object and the C object. All of the other format functions can be (mostly) thought of as special cases of this general rule. There are several converter functions defined in the NumPy C-API that may be of use. In particular, the &lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; function is very useful to support arbitrary data-type specification. This function transforms any valid data-type Python object into a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object. Remember to pass in the address of the C-variables that should be filled in.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dcd01c48a9de1d18adee046a1ef49445b20e2304" translate="yes" xml:space="preserve">
          <source>The ease of implementing mathematical formulas that work on arrays is one of the things that make NumPy so widely used in the scientific Python community.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">상황을 이해하는 가장 쉬운 방법은 결과 형태로 생각하는 것입니다. 인덱싱 작업에는 기본 인덱싱에 의해 정의 된 부분 공간 (정수 제외)과 고급 인덱싱 부분의 부분 공간이라는 두 부분이 있습니다. 인덱스 조합의 두 가지 경우를 구별해야합니다.</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">다항식 기본 집합간에 변환을 수행하는 쉬운 방법은 클래스 인스턴스의 convert 메서드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ad876c221bb9757cd689d05f17e08510f826f3e" translate="yes" xml:space="preserve">
          <source>The edges retuned by &lt;code&gt;histogram`&lt;/code&gt; and &lt;code&gt;histogramdd&lt;/code&gt; now match the data float type</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 으로 전달할 가장자리</target>
        </trans-unit>
        <trans-unit id="d2d8a6b76e19500caa5bf07c8a328b68c38bc616" translate="yes" xml:space="preserve">
          <source>The editing workflow</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">방송의 효과.</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">고유 값은 LAPACK 루틴 &lt;code&gt;_syevd&lt;/code&gt; , &lt;code&gt;_heevd&lt;/code&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">고유 값은 오름차순으로 각각의 다중도에 따라 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">실제 대칭 또는 복잡한 Hermitian 행렬의 고유 값은 항상 실제입니다. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; (열) 고유 벡터 의 배열 &lt;code&gt;v&lt;/code&gt; 는 단일이고 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 방정식 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">고유 값은 각각 다중도에 따라 반복됩니다. 고유 값이 반드시 순서하지는 않습니다. 허수 부분이 0이 아닌 경우 결과 배열은 복소수 유형입니다.이 경우 실제 유형으로 캐스트됩니다. 경우 &lt;code&gt;a&lt;/code&gt; 진짜 얻어진 고유 실제 (0 허부)이거나 공액 쌍 발생할</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">고유 값은 각각 다중도에 따라 반복됩니다. 그것들은 반드시 순서대로 정렬 될 필요는 없으며 반드시 실제 행렬에 대해 실제적인 것도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">고유 값 / 고유 벡터는 LAPACK 루틴 &lt;code&gt;_syevd&lt;/code&gt; , &lt;code&gt;_heevd&lt;/code&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">모든 조건이 False로 평가 될 때 &lt;code&gt;output&lt;/code&gt; 삽입 된 요소 입니다.</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">이 데이터 유형 객체의 요소 크기입니다.</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">몫인 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; 의 요소 별 나머지입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">요소는 이진 값 (0 또는 1)입니다.</target>
        </trans-unit>
        <trans-unit id="4e3cc7c953fc2e3ea61645fad74045ef41161886" translate="yes" xml:space="preserve">
          <source>The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">의 요소 &lt;code&gt;a&lt;/code&gt; 이 인덱스 순서로 판독된다. 'C'는 마지막 축 색인이 가장 빠르게 변경되고 첫 번째 축 색인이 가장 느리게 변경되어 C와 같은 순서로 요소를 색인화하는 것을 의미합니다. 'F'는 첫 번째 색인이 가장 빠르게 변경되고 마지막 색인이 가장 느리게 변경되는 Fortran과 유사한 색인 순서로 요소를 색인화 함을 의미합니다. 'C'및 'F'옵션은 기본 배열의 메모리 레이아웃을 고려하지 않으며 축 인덱싱 순서 만 참조합니다. 'A'는 메모리에서 &lt;code&gt;m&lt;/code&gt; 이 Fortran &lt;em&gt;연속 인&lt;/em&gt; 경우 Fortran과 유사한 색인 순서로 요소를 읽고 그렇지 않으면 C와 같은 순서 를 읽는 것을 의미합니다 . 'K'는 보폭이 음수 일 때 데이터를 되 돌리는 것을 제외하고 메모리에서 발생하는 순서대로 요소를 읽는 것을 의미합니다. 기본적으로 'C'인덱스 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">의 요소 &lt;code&gt;a&lt;/code&gt; 이 인덱스 순서로 판독된다. 'C'는 마지막 축 인덱스가 가장 빠르게 변경되고 첫 번째 축 인덱스가 가장 느리게 변경되는 행 주요 C 스타일 순서로 요소를 인덱싱하는 것을 의미합니다. 'F'는 첫 번째 인덱스가 가장 빠르게 변경되고 마지막 인덱스가 가장 느리게 변경되는 경우, 주요한 포트란 스타일 순서로 요소를 인덱스하는 것을 의미합니다. 'C'및 'F'옵션은 기본 배열의 메모리 레이아웃을 고려하지 않으며 축 인덱싱 순서 만 참조합니다. 만약 'A'수단 번호순 포트란 형상의 요소를 읽어 &lt;code&gt;a&lt;/code&gt; 포트란 인 &lt;em&gt;연속이&lt;/em&gt;그렇지 않으면 C와 같은 순서로 메모리에 저장됩니다. 'K'는 보폭이 음수 일 때 데이터를 되 돌리는 것을 제외하고 메모리에서 발생하는 순서대로 요소를 읽는 것을 의미합니다. 기본적으로 'C'인덱스 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 의 요소는 이 색인 순서를 사용하여 읽습니다. 'C'는 마지막 축 색인이 가장 빠르게 변경되고 첫 번째 축 색인이 가장 느리게 변경되어 C와 같은 순서로 요소를 색인화하는 것을 의미합니다. 'F'는 첫 번째 색인이 가장 빠르게 변경되고 마지막 색인이 가장 느리게 변경되는 Fortran과 유사한 색인 순서로 요소를 색인화 함을 의미합니다. 'C'및 'F'옵션은 기본 배열의 메모리 레이아웃을 고려하지 않으며 축 인덱싱 순서 만 참조합니다. 'A'는 메모리에서 &lt;code&gt;m&lt;/code&gt; 이 Fortran &lt;em&gt;연속 인&lt;/em&gt; 경우 Fortran과 유사한 색인 순서로 요소를 읽고 그렇지 않으면 C와 같은 순서 를 읽는 것을 의미합니다 . 'K'는 보폭이 음수 일 때 데이터를 되 돌리는 것을 제외하고 메모리에서 발생하는 순서대로 요소를 읽는 것을 의미합니다. 기본적으로 'C'인덱스 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;a.T&lt;/code&gt; 의 요소는 모두 같은 순서, 즉 메모리에 저장된 순서로 순회하지만 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; 의 요소 는 다른 메모리에 저장되었으므로 다른 순서로 방문됩니다. 나열한 것.</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">모양 튜플의 요소는 해당 배열 차원의 길이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">이 구조의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3ccba03f1b5d3bd5cacb97014f1795b1e1620ff" translate="yes" xml:space="preserve">
          <source>The ellipsis syntax maybe used to indicate selecting in full any remaining unspecified dimensions. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">끝 &lt;code&gt;endpoint&lt;/code&gt; False로 설정되어 있지 않으면 시퀀스의 끝 값입니다 . 이 경우, 시퀀스는 마지막 &lt;code&gt;num + 1&lt;/code&gt; 균등 간격 샘플 을 제외한 나머지로 구성 되므로 &lt;code&gt;stop&lt;/code&gt; 가 제외됩니다. &lt;code&gt;endpoint&lt;/code&gt; 가 False 이면 단계 크기가 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">간격의 끝점은 선택적으로 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 를 작성하기위한 엔트로피 .</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">선택 가능한 크기의 ASCII 문자열에 대한 열거 값입니다. 주어진 배열 내에서 문자열의 최대 크기는 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">선택 가능한 크기의 UCS4 문자열에 대한 열거 값입니다. 주어진 배열 내에서 문자열의 최대 크기는 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">128 비트 / 16 바이트 복합 유형의 열거 값은 두 개의 NPY_DOUBLE 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16 비트 / 2 바이트 IEEE 754-2008 호환 부동 소수점 유형의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16 비트 / 2 바이트 부호있는 정수의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">부호없는 16 비트 / 2 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32 비트 / 4 바이트 IEEE 754 호환 부동 소수점 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32 비트 / 4 바이트 부호있는 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">부호없는 32 비트 / 4 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64 비트 / 8 바이트 IEEE 754 호환 부동 소수점 유형의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">64 비트 / 8 바이트 복합 유형의 열거 값은 두 개의 NPY_FLOAT 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64 비트 / 8 바이트 부호있는 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">부호없는 64 비트 / 8 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">선택 가능한 날짜 또는 시간 단위를 기준으로 날짜 또는 날짜 시간을 정밀도로 보유하는 데이터 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">선택 가능한 날짜 또는 시간 단위의 정수로 시간 길이를 보유하는 데이터 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">두 개의 NPY_LONGDOUBLE 값으로 구성된 플랫폼 별 복합 부동 소수점 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">플랫폼 특정 부동 소수점 유형의 열거 값은 NPY_DOUBLE 이상이지만 많은 플랫폼에서 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">(void *) 포인터와 크기가 같은 부호있는 정수 유형의 열거 값입니다. 모든 인덱스 배열에 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8 비트 / 1 바이트 부호있는 정수의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">부호없는 8 비트 / 1 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">(void *) 포인터와 크기가 같은 부호없는 정수 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">임의의 Python 객체에 대한 참조를위한 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">부울 유형의 열거 값으로 1 바이트로 저장됩니다. 값은 0과 1로만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마스크에 사용 된 유형의 열거 값입니다 (예 : &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; 반복자 플래그 사용). 이것은 &lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="470c7c6a0fdea0ae871ac319202aa3679b0d2b38" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">부동 소수점 데이터 유형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">정수 데이터 유형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f007c7cbd53c8448e809d2bc2019ae342707c904" translate="yes" xml:space="preserve">
          <source>The error also has additional information to help you troubleshoot:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">오류 마스크는 4 개의 부동 소수점 오류에 대한 처리 정보를 보유하는 단일 정수입니다. 각 오류 유형에 대한 정보는 정수의 3 비트에 포함됩니다. 8 진법으로 인쇄하면 &quot;무효&quot;, &quot;언더&quot;, &quot;오버&quot;및 &quot;분할&quot;이 어떤 순서로 설정되어 있는지 확인할 수 있습니다. 인쇄 된 문자열은</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">실패시 인쇄 할 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">오류 개체에는 NumPy의 오류 처리 동작을 정의하는 모든 정보가 포함됩니다. &lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt; 는 오류 처리 동작을 가져오고 설정하는 다른 함수 ( &lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; ) 에서 내부적으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">오류 개체에는 NumPy의 오류 처리 동작을 정의하는 모든 정보가 포함됩니다. &lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt; 는 오류 처리 동작을 설정하는 다른 함수 ( &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; ) 에서 내부적으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">오류 개체, [내부 numpy 버퍼 크기, 오류 마스크, 오류 콜백 함수]의 세 가지 요소가 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">이 평가는 일명 합성 부문 인 Clenshaw 재귀를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">평가에는 Horner의 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">느린 테스트의 정확한 정의는 주관적 및 하드웨어에 따라 다르지만 일반적으로 1 초 또는 2 초 이상이 필요한 개별 테스트는 느리게 레이블이 지정되어야합니다 (전체 제품군은 수천 개의 테스트로 구성되므로 1 초도 중요한).</target>
        </trans-unit>
        <trans-unit id="0fe09946a84bc00c7ff87cc3c4856ae88e30a696" translate="yes" xml:space="preserve">
          <source>The example also demonstrates Cython&amp;rsquo;s &amp;ldquo;typed memoryviews&amp;rdquo;, which are like NumPy arrays at the C level, in the sense that they are shaped and strided arrays that know their own extent (unlike a C array addressed through a bare pointer). The syntax &lt;code&gt;double complex[:]&lt;/code&gt; denotes a one-dimensional array (vector) of doubles, with arbitrary strides. A contiguous array of ints would be &lt;code&gt;int[::1]&lt;/code&gt;, while a matrix of floats would be &lt;code&gt;float[:, :]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3927b62f1cd7d72e0062722877a649b50aac359" translate="yes" xml:space="preserve">
          <source>The example code may be split across multiple lines, with each line after the first starting with &amp;lsquo;&amp;hellip; &amp;lsquo;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c6b68db229268c95185c669cea481b3a1f2e9b2" translate="yes" xml:space="preserve">
          <source>The examples may assume that &lt;code&gt;import numpy as np&lt;/code&gt; is executed before the example code in &lt;em&gt;numpy&lt;/em&gt;. Additional examples may make use of &lt;em&gt;matplotlib&lt;/em&gt; for plotting, but should import it explicitly, e.g., &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;. All other imports, including the demonstrated function, must be explicit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">위의 규칙에 대한 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea2c7bd23b14b815638891431083c6a5af9b6f5a" translate="yes" xml:space="preserve">
          <source>The execution will now stop at the corresponding C function and you can step through it as usual. A number of useful Python-specific commands are available. For example to see where in the Python code you are, use &lt;code&gt;py-list&lt;/code&gt;. For more details, see &lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb&lt;/a&gt;. Here are some commonly used commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">예상되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">예상되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">지수는 임의의 정수 또는 긴 정수, 양수, 음수 또는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eps&lt;/code&gt; 를 산출하는 지수입니다 .</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epsneg&lt;/code&gt; 를 생성하는 지수입니다 .</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하 분포의 연속 유사체입니다. 여기에는 많은 비바람에 대해 측정 된 빗방울의 크기 &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 위키 백과에 대한 페이지 요청 사이의 시간 &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; 과 같은 많은 일반적인 상황이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="379909a59d38e5f49bfe83c94188ec2a18000b03" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하 분포의 연속 유사체입니다. 여기에는 많은 비바람에 대해 측정 된 빗방울의 크기 &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 위키 백과에 대한 페이지 요청 사이의 시간 &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; 과 같은 많은 일반적인 상황이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d68d926a5db1e2f83fa605bc0a4678131d567b9" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">지수. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="4a0678b00019c9d465c7278be4782e4ae402fa1c" translate="yes" xml:space="preserve">
          <source>The expression within brackets in &lt;code&gt;b[i]&lt;/code&gt; is treated as an &lt;code&gt;i&lt;/code&gt; followed by as many instances of &lt;code&gt;:&lt;/code&gt; as needed to represent the remaining axes. NumPy also allows you to write this using dots as &lt;code&gt;b[i,...]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">추출 된 대각선 또는 구성된 대각선 배열.</target>
        </trans-unit>
        <trans-unit id="53a8a2b8a609081b147379c06e4ca152c3e8819c" translate="yes" xml:space="preserve">
          <source>The f2py method of linking compiled code is currently the most sophisticated and integrated approach. It allows clean separation of Python with compiled code while still allowing for separate distribution of the extension module. The only draw-back is that it requires the existence of a Fortran compiler in order for a user to install the code. However, with the existence of the free-compilers g77, gfortran, and g95, as well as high-quality commercial compilers, this restriction is not particularly onerous. In my opinion, Fortran is still the easiest way to write fast and clear code for scientific computing. It handles complex numbers, and multi-dimensional indexing in the most straightforward way. Be aware, however, that some Fortran compilers will not be able to optimize code as well as good hand- written C-code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="555daf4232eb1ce31031f68a76fe276dbf717736" translate="yes" xml:space="preserve">
          <source>The f2py program is written in Python and can be run from inside your code to compile Fortran code at runtime, as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06e74a78df99ca864f56978dd8124a3fb8da4ff4" translate="yes" xml:space="preserve">
          <source>The field names may be modified by assigning to the &lt;code&gt;names&lt;/code&gt; attribute using a sequence of strings of the same length.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">필드 이름은 &lt;code&gt;'col1, col2, col3'&lt;/code&gt; 형식으로 쉼표로 구분 된 문자열 또는 &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; 형식으로 문자열 목록 또는 튜플로 지정됩니다 . 빈 목록을 사용할 수 있으며,이 경우 기본 필드 이름 ( 'f0', 'f1',&amp;hellip;)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abdb8363ba033add56efe121cf142ecd7ff5e4f2" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">파일에 객체 배열이 포함되어 있지만 allow_pickle = False가 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">파일이이 모드에서 열립니다 :</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">배열 데이터 버퍼로 사용될 파일 이름 또는 파일 객체.</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">로드 할 파일 또는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 를 피클 할 파일 입니다. 문자열 인 경우 파일의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">읽을 파일입니다. 파일과 유사한 객체는 &lt;code&gt;seek()&lt;/code&gt; 및 &lt;code&gt;read()&lt;/code&gt; 메서드를 지원해야합니다 . 절인 파일을 사용하려면 파일과 같은 객체가 &lt;code&gt;readline()&lt;/code&gt; 메서드도 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">fill_value는 &lt;code&gt;value&lt;/code&gt; 로 설정되고 마스크는 가능한 경우 &lt;code&gt;nomask&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">채워진 배열.</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">마스크 배열의 채우기 값은 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">마스크 배열의 채우기 값은 스칼라입니다. 설정하면 데이터 유형에 따라 없음이 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 점이 False가 아닌 한 시퀀스의 최종 값입니다 . 이 경우 &lt;code&gt;num + 1&lt;/code&gt; 값은 로그 공간의 간격에 걸쳐 간격을두고 마지막 (길이 &lt;code&gt;num&lt;/code&gt; 시퀀스)을 제외한 모든 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">처음 6 바이트는 정확히 &lt;code&gt;\x93NUMPY&lt;/code&gt; 와 같은 마술 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 의 첫 번째 &lt;code&gt;nargs&lt;/code&gt; 요소는 스칼라 ufunc의 경우와 동일하게 유지됩니다. 다음 요소에는 모든 인수에 대한 모든 핵심 차원의 보폭이 순서대로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;depends&lt;/code&gt; , &lt;code&gt;sources&lt;/code&gt; 등 의 속성에 액세스하고 빌드 프로세스 중에 속성을 수정하는 데 유용한 Extension 인스턴스를 포함합니다 . 두 번째 인수는 디스크에 파일을 작성할 때 사용해야하는 빌드 디렉토리의 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">첫 번째 인수는 고정 크기 데이터 형식 개체로 변환 할 수있는 개체입니다. 두 번째 인수는이 유형의 원하는 모양입니다. shape 매개 변수가 1이면 데이터 유형 오브젝트는 고정 dtype과 같습니다. 경우 &lt;em&gt;형상&lt;/em&gt; 튜플, 새로운 DTYPE는 소정 형상의 서브 어레이를 정의한다.</target>
        </trans-unit>
        <trans-unit id="8dca1bab679e35ad504daad1a00ee24ea2d780cc" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object used to be equivalent to fixed dtype. This behaviour is deprecated since NumPy 1.17 and will raise an error in the future. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb3620809413337a1b624decfe7e8c4e4d1dcd2" translate="yes" xml:space="preserve">
          <source>The first argument is the newly created sub-type. The second argument (if not NULL) is the &amp;ldquo;parent&amp;rdquo; array (if the array was created using slicing or some other operation where a clearly-distinguishable parent is present). This routine can do anything it wants to. It should return a -1 on error and 0 otherwise.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">첫 번째 인수는 크기가 0 인 유연한 데이터 형식 개체로 변환되는 개체 여야하며 두 번째 인수는 원하는 항목 크기를 제공하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">첫 번째 배열은 주사위를 10 번 던지는 결과를 보여주고, 두 번째 배열은 주사위를 20 번 던지는 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">첫 번째 주장은 예외를 제기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">날짜 또는 그 이후의 첫 영업일 :</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">날짜 이후의 첫 영업일 :</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">첫 번째 문자는 데이터 종류를 지정하고 나머지 문자는 유니 코드를 제외하고 항목 당 바이트 수를 지정합니다 (유니 코드는 문자 수로 해석 됨). 항목 크기가 기존 유형과 일치해야합니다. 그렇지 않으면 오류가 발생합니다. 지원되는 종류는</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">첫 번째 차이는 주어진 축을 따라 &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; 주어지며 &lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; 를&lt;/a&gt; 재귀 적 으로 사용하여 더 큰 차이를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">첫 번째 요소 인 &lt;em&gt;field_name&lt;/em&gt; 은 필드 이름입니다 ( &lt;code&gt;''&lt;/code&gt; 인 경우 표준 필드 이름 &lt;code&gt;'f#'&lt;/code&gt; 가 지정됨). 필드 이름은 첫 번째 문자열이 &quot;제목&quot;(문자열 또는 유니 코드 문자열 일 수 있음)이거나 임의의 개체가 될 수있는 필드의 메타 데이터 인 두 개의 문자열 일 수도 있습니다. 유효한 파이썬 식별자 여야하는 &quot;이름&quot;</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">첫 번째 예는 &lt;code&gt;p&lt;/code&gt; 를 한 번 통합하고 두 번째 예는 p를 두 번 통합합니다. 기본적으로 적분의 하한과 적분 상수는 0이지만 둘 다 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">첫 번째 양식이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="efb03ce57a81f162cb7b4a2a4999809358d24fef" translate="yes" xml:space="preserve">
          <source>The first integer is the first byte of the array, the second integer is just past the last byte of the array. If &lt;code&gt;a&lt;/code&gt; is not contiguous it will not use every byte between the (&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;) values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19fd42d2f3f6ab1e3a2844cd4d5055ea1cbf31a0" translate="yes" xml:space="preserve">
          <source>The first is the use of the &lt;code&gt;ndarray.__new__&lt;/code&gt; method for the main work of object initialization, rather then the more usual &lt;code&gt;__init__&lt;/code&gt; method. The second is the use of the &lt;code&gt;__array_finalize__&lt;/code&gt; method to allow subclasses to clean up after the creation of views and new instances from templates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774 년부터 Laplace의 제 1 법칙에 따르면 오류의 빈도는 오류의 절대 크기의 지수 함수로 표현 될 수 있으며, 이는 Laplace 분포를 초래합니다. 경제 및 건강 과학의 많은 문제에서이 분포는 표준 가우스 분포보다 데이터를 더 잘 모델링하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">첫 번째 출력은 위치 또는 키워드 매개 변수로 제공 될 수 있습니다. 키워드 'out'인수는 위치 인수와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첫 번째 매개 변수 arr은 ndarray 또는 서브 클래스 여야합니다. 파라미터는, &lt;em&gt;플래그&lt;/em&gt; : 배열이 가질 수있는 가능한 비트 플래그의 조합으로 이루어진 정수이어야 &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a463555884e9f663755cbacb732bc60283f30e4e" translate="yes" xml:space="preserve">
          <source>The first rule of broadcasting is that if all input arrays do not have the same number of dimensions, a &amp;ldquo;1&amp;rdquo; will be repeatedly prepended to the shapes of the smaller arrays until all the arrays have the same number of dimensions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">나열된 첫 번째 서명 &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; 은 하드 코딩 된 차원을 가진 1 차원 배열을위한 것입니다. 마찬가지로 &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; 는 하드 코딩 된 차원을 가진 2 차원 배열 용이며 3 차원에도 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">먼저 스레드 별 전역 사전에서 버퍼 크기, 오류 마스크 및 관련 오류 개체에 대한 현재 값을 조회합니다. 오류 마스크의 상태는 오류 조건이 발견 될 때 발생하는 상황을 제어합니다. 하드웨어 오류 플래그 검사는 각 1D 루프가 실행 된 후에 만 ​​수행됩니다. 즉, 단일 1-D 루프가 수행되도록 입력 및 출력 배열이 연속적이고 올바른 유형 인 경우 배열의 모든 요소가 계산 될 때까지 플래그를 확인할 수 없습니다. 스레드 별 사전에서 이러한 값을 찾으려면 아주 작은 배열을 제외하고는 무시되는 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">가장 먼저 이해해야 할 것은 2 차원 배열을 인덱싱하는 두 가지 상충되는 규칙이 있다는 것입니다. 행렬 표기법은 첫 번째 인덱스를 사용하여 어떤 행이 선택되고 있는지 나타내고 두 번째 인덱스는 어떤 열이 선택되었는지 나타냅니다. 이것은 사람들이 일반적으로 첫 번째 인덱스가 x 위치 (즉, 열)를 나타내고 두 번째 인덱스가 y 위치 (즉, 행)를 나타내는 이미지에 대한 기하학적 지향적 컨벤션과 반대입니다. 이것만으로도 많은 혼란이 발생합니다. 매트릭스 지향 사용자와 이미지 지향 사용자는 인덱싱과 관련하여 두 가지 다른 것을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="43a31061c48404a506dd1e24e7517ade62790639" translate="yes" xml:space="preserve">
          <source>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example, &lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; evaluates &lt;code&gt;100 * 10 ** 8&lt;/code&gt; correctly for 64-bit integers, but gives 1874919424 (incorrect) for a 32-bit integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">플래그 멤버는 데이터를 해석하는 방법을 나타내는 5 비트와 인터페이스를 해석하는 방법을 나타내는 1 비트로 구성 될 수 있습니다. 데이터 비트는 &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200) 및 &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400)입니다. 최종 플래그 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800)은이 구조에 arrdescr 필드가 있는지 여부를 나타냅니다. 이 플래그가 없으면 필드에 액세스하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">반환되는 가변형 배열에는 두 개의 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd686ab267e11ccd8dcbb950337101a32f2aa2c7" translate="yes" xml:space="preserve">
          <source>The float printing routines use an accurate but much more computationally demanding algorithm to compute the number of digits after the decimal point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">부동 소수점 예외는 IEEE 754 표준 &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">바닥 분할 연산자 &lt;code&gt;//&lt;/code&gt; 는 Python 2.2에서 &lt;code&gt;//&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 또는 동등한 연산자 로 추가되었습니다 . 의 기본 바닥 나눗셈 연산 &lt;code&gt;/&lt;/code&gt; 는 과 진정한 사업부로 대체 될 수 &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
