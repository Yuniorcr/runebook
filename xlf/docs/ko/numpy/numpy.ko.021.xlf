<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="25cbadfbabe4aec8c49a2fe4ad5d41f89ab2957d" translate="yes" xml:space="preserve">
          <source>Use the indices of the non-zero elements as an index array to extract these elements:</source>
          <target state="translated">0이 아닌 요소의 인덱스를 인덱스 배열로 사용하여 다음 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="053906d6c11e234d0523bc070994cf48c59e8878" translate="yes" xml:space="preserve">
          <source>Use the library &lt;code&gt;&amp;lt;libname&amp;gt;&lt;/code&gt; when linking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a989636199f4d3c95f768797df44dd326f52d3" translate="yes" xml:space="preserve">
          <source>Use the same sections as outlined above (all except &lt;code&gt;Returns&lt;/code&gt; are applicable). The constructor (&lt;code&gt;__init__&lt;/code&gt;) should also be documented here, the &lt;strong&gt;Parameters&lt;/strong&gt; section of the docstring details the constructors parameters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcbe93ff8f6462c82dd7a279518d76404badb4f2" translate="yes" xml:space="preserve">
          <source>Use the same sections as outlined for functions where applicable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91b5ae96e69a49c5a6862c6b40c4da95f9ee09c6" translate="yes" xml:space="preserve">
          <source>Use these sparingly, as they do not look very good in text terminals and are not often necessary. One situation in which a warning can be useful is for marking a known bug that is not yet fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fce2d931323b452a238b3e2d786e8a8211d7c7e3" translate="yes" xml:space="preserve">
          <source>Used as an alias of &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; and vica versa.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd6f1513bb6f3e4a98050539792c7f3cbaf760a6" translate="yes" xml:space="preserve">
          <source>Used as-is.</source>
          <target state="translated">있는 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="86d25879dd6e8e65f51cfd2c9e310da0aa3fb93c" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It decrements the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. Normal return value is 0. A -1 is returned if an error occurs.</source>
          <target state="translated">Python 객체가 포함 된 배열 &lt;em&gt;op에&lt;/em&gt; 사용됩니다 . &lt;em&gt;op&lt;/em&gt; 의 데이터 유형에 따라 배열의 모든 객체의 참조 카운트를 감소시킵니다 . 정상 반환 값은 0입니다. 오류가 발생하면 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12676328e0f8258da10db691bf737e9cd286a726" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It increments the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">Python 객체가 포함 된 배열 &lt;em&gt;op에&lt;/em&gt; 사용됩니다 . &lt;em&gt;op&lt;/em&gt; 의 데이터 유형에 따라 배열의 모든 객체의 참조 카운트를 증가시킵니다 . 오류가 발생하면 -1이 반환되고, 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a13b41ea5661dcbc4d05b7183bc9d474dd67bb8" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1500692edf9e6d67bd590cb2e6428fecab9820c" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array. Returns a copy of the array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 . 배열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="054ce70cbf81d2356ba6ae20aa8fb864ef13bf9e" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="df1278433c263cdbbd69170e679d3f52bb78e816" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;constant&amp;rsquo;. The values to set the padded values for each axis.</source>
          <target state="translated">'일정한'에서 사용됩니다. 각 축에 대해 채워진 값을 설정하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="465b8fcd19cd5e2ed77adff74f2ff5a3fc18db79" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;linear_ramp&amp;rsquo;. The values used for the ending value of the linear_ramp and that will form the edge of the padded array.</source>
          <target state="translated">'linear_ramp'에서 사용됩니다. linear_ramp의 끝 값에 사용되는 값으로 채워진 배열의 가장자리를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="d71d6f65b16e9b35cb9fcf9b7569838936b2caa2" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;maximum&amp;rsquo;, &amp;lsquo;mean&amp;rsquo;, &amp;lsquo;median&amp;rsquo;, and &amp;lsquo;minimum&amp;rsquo;. Number of values at edge of each axis used to calculate the statistic value.</source>
          <target state="translated">'최대 값', '평균값', '중간 값'및 '최소값'에 사용됩니다. 통계 값을 계산하는 데 사용되는 각 축의 가장자리에있는 값의 수입니다.</target>
        </trans-unit>
        <trans-unit id="4325f42e7e418215aac0a73c897c39904b4d0a1e" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;reflect&amp;rsquo;, and &amp;lsquo;symmetric&amp;rsquo;. The &amp;lsquo;even&amp;rsquo; style is the default with an unaltered reflection around the edge value. For the &amp;lsquo;odd&amp;rsquo; style, the extended part of the array is created by subtracting the reflected values from two times the edge value.</source>
          <target state="translated">'반사'및 '대칭'에 사용됩니다. '짝수'스타일은 가장자리 값을 기준으로 변경되지 않은 반사의 기본값입니다. 'odd'스타일의 경우 가장자리 값의 두 배에서 반사 된 값을 빼서 배열의 확장 부분을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6a848d84f0829fb89fe0a4c3ff31da438ec74574" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7f1793a4a4b44dd1933f922f757d629d3be5a3" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">loop-&amp;gt; obj가 true가 아닌 경우 ( &lt;em&gt;즉,&lt;/em&gt; 이것은 OBJECT 배열 루프가 아님) Python GIL을 해제하기 위해 범용 함수 코드에서 사용됩니다 . 변수 선언 영역에서 &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="10031fc1a49c2cbba6bbb424956b8667cda6fefa" translate="yes" xml:space="preserve">
          <source>Used in universal function code to re-acquire the Python GIL if it was released (because loop-&amp;gt;obj was not true).</source>
          <target state="translated">일반 함수 코드에서 사용되어 파이썬 GIL이 릴리스 된 경우 (loop-&amp;gt; obj가 true가 아니기 때문에) 다시 획득합니다.</target>
        </trans-unit>
        <trans-unit id="c23b41a6c14497a2fa2fb894918e5ebdff35b118" translate="yes" xml:space="preserve">
          <source>Used to construct the convolution operator.</source>
          <target state="translated">컨볼 루션 연산자를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c64c33615821368bc9743122d8a6c96ff848fe" translate="yes" xml:space="preserve">
          <source>Used to fill the array with data.</source>
          <target state="translated">배열을 데이터로 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ead00318903d57eb423777b76455ee4a052f86f" translate="yes" xml:space="preserve">
          <source>Used to select only certain elements from a sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b06029f962bdaa60d205631cac84f36f3e29d6f" translate="yes" xml:space="preserve">
          <source>Useful functions in &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 에서 유용한 기능</target>
        </trans-unit>
        <trans-unit id="7dc863346a17f843606dc78b7fd5eaa70c18759a" translate="yes" xml:space="preserve">
          <source>Useful math constants</source>
          <target state="translated">유용한 수학 상수</target>
        </trans-unit>
        <trans-unit id="d7e7cae700d3c37685c439282d2378cb79df959c" translate="yes" xml:space="preserve">
          <source>Useful to regain the GIL in situations where it was released using the BEGIN form of this macro.</source>
          <target state="translated">이 매크로의 BEGIN 형식을 사용하여 릴리스 된 상황에서 GIL을 다시 얻는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8cef70f655bb7cdb9d1c581e3560341cb090e5c3" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d580b2c9b4825f08cb2691c40cd94404df444f3e" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop. Equivalent to</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt; 에 루프 실행 중 Python 인터프리터가 필요할 수있는 임의의 Python 객체가없는 경우에만 GIL을 해제하는 데 유용합니다 . 에 해당</target>
        </trans-unit>
        <trans-unit id="2978535fda1f10395442e618746112da0bb87d3a" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;loop_size&lt;/em&gt; exceeds a minimum threshold, currently set to 500. Should be matched with a &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt;&lt;code&gt;NPY_END_THREADS&lt;/code&gt;&lt;/a&gt; to regain the GIL.</source>
          <target state="translated">&lt;em&gt;loop_size&lt;/em&gt; 가 현재 500으로 설정된 최소 임계 값을 초과하는 경우에만 GIL을 해제하는 데 유용합니다 . GIL을 다시 얻으려면 &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt; &lt;code&gt;NPY_END_THREADS&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="377ee38d9430016857a7ac84277e93d26f665af8" translate="yes" xml:space="preserve">
          <source>User-defined BLAS detection order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01d8c2fd752b3823aa5ae01359574a0ac7005a6d" translate="yes" xml:space="preserve">
          <source>User-defined LAPACK detection order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feb130415c58c07804dd84fa00fab56690d584a4" translate="yes" xml:space="preserve">
          <source>User-defined data-types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77352cf9f5e0b55e17c69c67b2dd7ed545a9424a" translate="yes" xml:space="preserve">
          <source>User-defined types now need to implement &lt;code&gt;__str__&lt;/code&gt; and &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd331bef50cb48757824818608d12be462d6034d" translate="yes" xml:space="preserve">
          <source>Users looking to manipulate tabular data, such as stored in csv files, may find other pydata projects more suitable, such as xarray, pandas, or DataArray. These provide a high-level interface for tabular data analysis and are better optimized for that use. For instance, the C-struct-like memory layout of structured arrays in numpy can lead to poor cache behavior in comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2637443926c71ce03a091c2e95bf9b5610348992" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; as a first string argument creates a matrix.</source>
          <target state="translated">'r'또는 'c'를 첫 번째 문자열 인수로 사용하면 행렬이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="65fcf8542af4dfa98c8e336c7ebb663b2e96f530" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; one can quickly construct index arrays that will index the cross product. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; returns the array &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; one을 사용 하면 교차 곱을 인덱싱 할 인덱스 배열을 빠르게 구성 할 수 있습니다. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; 는 배열 &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32ece8fbb6c1ed850bf1c3c8fb0f4d5a7300c2c0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with **kwds, the arrays are saved with the keyword names.</source>
          <target state="translated">** kwds와 함께 &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; 를 사용 하면 배열이 키워드 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8c36d4099fe15bc91bbfe91acb74cd64e75d6b3f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with *args, the arrays are saved with default names.</source>
          <target state="translated">* args와 함께 &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; 를 사용 하면 배열이 기본 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a65056bb65a5824d8a28541dbacefafbcbe064d0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../reference/generated/numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcbf246bed1356ef5a4f7a84e0efa6276b04144" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;arr.reshape()&lt;/code&gt; will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you&amp;rsquo;ll need to make sure that your new array also has a total of 12 elements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05ea485672c370249efc13cf02206fa0079194e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;intent(inout)&lt;/code&gt; is generally not recommended, use &lt;code&gt;intent(in,out)&lt;/code&gt; instead. See also &lt;code&gt;intent(inplace)&lt;/code&gt; attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d44e140015f4a842157d0c38e650d4d90f0d7d32" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;intent(inplace)&lt;/code&gt; is generally not recommended either. For example, when slices have been taken from an &lt;code&gt;intent(inplace)&lt;/code&gt; argument then after in-place changes, slices data pointers may point to unallocated memory area.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b0a1a12d91b1a55351df033aec60b12c39daa72" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;np.newaxis&lt;/code&gt; will increase the dimensions of your array by one dimension when used once. This means that a &lt;strong&gt;1D&lt;/strong&gt; array will become a &lt;strong&gt;2D&lt;/strong&gt; array, a &lt;strong&gt;2D&lt;/strong&gt; array will become a &lt;strong&gt;3D&lt;/strong&gt; array, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="191982a04357e09366b8b88accf4a58472233372" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;runtests.py&lt;/code&gt; is the recommended approach to running tests. There are also a number of alternatives to it, for example in-place build or installing to a virtualenv. See the FAQ below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f797cc0ae3c70b42806d8484c2173341138aa334" translate="yes" xml:space="preserve">
          <source>Using Eclipse/PyDev with Anaconda/conda Python (or environments)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f4523c954e2a9e31bfb34aa3f197069ed09884a" translate="yes" xml:space="preserve">
          <source>Using F2PY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5ca717d067542a1c5fc904dd82ea349b1543085" translate="yes" xml:space="preserve">
          <source>Using F2PY bindings in Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="805e17bb02b4c971b82b3da2b45fde14cdb9678e" translate="yes" xml:space="preserve">
          <source>Using NumPy C-API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7bc452a9834b5876e355900cc35464401d0f74" translate="yes" xml:space="preserve">
          <source>Using PyCharm with Anaconda/conda Python</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9863374b5764d5e46c1682602eaea50268a1efa" translate="yes" xml:space="preserve">
          <source>Using Python as glue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f2e5d63438a571f3123ef33ae03e1d5f2864e48" translate="yes" xml:space="preserve">
          <source>Using Python from &lt;code&gt;conda&lt;/code&gt; (Anaconda)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e43089c0ec4ca3358f03ef23a9043bc3004dbaed" translate="yes" xml:space="preserve">
          <source>Using VSCode with Anaconda/conda Python (or environments)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4ecb91f09183edc4f23a5cc314556ac8c1af3c8" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">유연한 &lt;code&gt;dtype&lt;/code&gt; 사용 .</target>
        </trans-unit>
        <trans-unit id="cfac66afdbdc20a411f9f9f200f87cdcbe870cdd" translate="yes" xml:space="preserve">
          <source>Using a view to convert an array to a recarray:</source>
          <target state="translated">뷰를 사용하여 배열을 recarray로 변환 :</target>
        </trans-unit>
        <trans-unit id="a4fb72e0c5f0602466b0b452237f4e23496663cc" translate="yes" xml:space="preserve">
          <source>Using an External Loop</source>
          <target state="translated">외부 루프 사용</target>
        </trans-unit>
        <trans-unit id="f210f428b873c49c7b2b57aa15cfa3164fde53af" translate="yes" xml:space="preserve">
          <source>Using an instance of &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, and upon exiting it is reset to what it was before.</source>
          <target state="translated">컨텍스트 관리자로 &lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하면 해당 컨텍스트의 명령문이 알려진 오류 처리 동작으로 실행될 수 있습니다. 컨텍스트에 들어가면 오류 처리는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; 로&lt;/a&gt; 설정 되며 종료시 이전 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fe8e1d4770589cbebb7564eb13c83317ecba70" translate="yes" xml:space="preserve">
          <source>Using an ndpointer class in the argtypes method can make it significantly safer to call a C function using ctypes and the data- area of an ndarray. You may still want to wrap the function in an additional Python wrapper to make it user-friendly (hiding some obvious arguments and making some arguments output arguments). In this process, the &lt;code&gt;requires&lt;/code&gt; function in NumPy may be useful to return the right kind of array from a given input.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7af0c7a348040b3b4ff1744a0608d17163c9138e" translate="yes" xml:space="preserve">
          <source>Using array-protocol type strings:</source>
          <target state="translated">배열 프로토콜 유형 문자열 사용 :</target>
        </trans-unit>
        <trans-unit id="fd7054fa064ad2611d4b7d00df8240d7735e3c37" translate="yes" xml:space="preserve">
          <source>Using array-scalar type:</source>
          <target state="translated">배열 스칼라 타입 사용하기 :</target>
        </trans-unit>
        <trans-unit id="03a2b430abf28e746816ea1cff1b193db00a94c9" translate="yes" xml:space="preserve">
          <source>Using comma-separated field formats. The shape is (2,3):</source>
          <target state="translated">쉼표로 구분 된 필드 형식 사용 모양은 (2,3)입니다.</target>
        </trans-unit>
        <trans-unit id="e282c417933d97d3a53a56d481d1f405a74c7c0d" translate="yes" xml:space="preserve">
          <source>Using complex sequences:</source>
          <target state="translated">복잡한 시퀀스 사용하기 :</target>
        </trans-unit>
        <trans-unit id="eb191c9fcdc8ee9e52364b3acea1bba66afa1818" translate="yes" xml:space="preserve">
          <source>Using ctypes is a powerful way to connect Python with arbitrary C-code. Its advantages for extending Python include</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e522c98bd807e94f2ab9fc3a1975ce203f287e" translate="yes" xml:space="preserve">
          <source>Using dictionaries. Two fields named &amp;lsquo;gender&amp;rsquo; and &amp;lsquo;age&amp;rsquo;:</source>
          <target state="translated">사전 사용. '성별'과 '나이'라는 두 필드 :</target>
        </trans-unit>
        <trans-unit id="af330b02f13d207e5fac3c22b8c9bdbaab36afee" translate="yes" xml:space="preserve">
          <source>Using dtype = None</source>
          <target state="translated">dtype = None 사용</target>
        </trans-unit>
        <trans-unit id="00ac7fffb347ca02e4efcd6c4f0a66db988cde12" translate="yes" xml:space="preserve">
          <source>Using missing and filling values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d2131672fafcfdf449f29b29350743e40c17d69" translate="yes" xml:space="preserve">
          <source>Using months for the unit:</source>
          <target state="translated">단위에 개월 사용 :</target>
        </trans-unit>
        <trans-unit id="68007c19f643deebacff69bbb71fb357fa3f341a" translate="yes" xml:space="preserve">
          <source>Using non-symbol-suffixed 64-bit BLAS/LAPACK in a program that also uses 32-bit BLAS/LAPACK can cause crashes under certain conditions (e.g. with embedded Python interpreters on Linux).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f696379652fe6905a66fc5fd2b9273fa2471296" translate="yes" xml:space="preserve">
          <source>Using numpy.i</source>
          <target state="translated">numpy.i 사용</target>
        </trans-unit>
        <trans-unit id="e8111da9fdc8286f7fa1decedd3c62fdfaa40d28" translate="yes" xml:space="preserve">
          <source>Using numpy.ma</source>
          <target state="translated">numpy.ma 사용</target>
        </trans-unit>
        <trans-unit id="fca1ba2673c50c8d4a43a28f5b4401d362ff3c79" translate="yes" xml:space="preserve">
          <source>Using numpy.random.binomial may change the RNG state vs. numpy &amp;lt; 1.9</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03252764a2ca129ee8f53a1ebcd3c94ffd3382b7" translate="yes" xml:space="preserve">
          <source>Using poly1d objects:</source>
          <target state="translated">poly1d 객체 사용 :</target>
        </trans-unit>
        <trans-unit id="79eb3bbcb08c7d6704be86d77b0727b917270b3d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute matrix norms:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 행렬 규범 계산 :</target>
        </trans-unit>
        <trans-unit id="9e684f49459c0d5aba4c5f2579aeb17add74610d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute vector norms:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 벡터 규범 계산 :</target>
        </trans-unit>
        <trans-unit id="0049dd8bb80b8109d30cf294edeebc9226866484" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;copy&lt;/code&gt; method will make a complete copy of the array and its data (a &lt;em&gt;deep copy&lt;/em&gt;). To use this on your array, you could run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ba36c2f053a06ac3abc3a930f4a1d05aada052" translate="yes" xml:space="preserve">
          <source>Using the Convenience Classes</source>
          <target state="translated">편의 클래스 사용</target>
        </trans-unit>
        <trans-unit id="1bd2966f639ab87086919a9a710a3ff850eadf79" translate="yes" xml:space="preserve">
          <source>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In &lt;em&gt;implicit&lt;/em&gt; mode &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; computes these values.</source>
          <target state="translated">아인슈타인 합산 규칙을 ​​사용하면 많은 일반적인 다차원 선형 대수 배열 연산을 간단한 방식으로 표현할 수 있습니다. 에서 &lt;em&gt;암시 적&lt;/em&gt; 모드 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; 이 값을 계산한다.</target>
        </trans-unit>
        <trans-unit id="75da2a462c666654f41a122b8cf7201ccca6f453" translate="yes" xml:space="preserve">
          <source>Using the casting rules</source>
          <target state="translated">캐스팅 규칙 사용</target>
        </trans-unit>
        <trans-unit id="a7a6cb5aa0103dc18935f9ad693972e0008b2a2f" translate="yes" xml:space="preserve">
          <source>Using the object looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e2a18ad6df592872579dd4bbee44818b7034db3" translate="yes" xml:space="preserve">
          <source>Using these #defines you can use the C-API in multiple files for a single extension module. In each file you must define &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to some name that will hold the C-API (&lt;em&gt;e.g.&lt;/em&gt; myextension_ARRAY_API). This must be done &lt;strong&gt;before&lt;/strong&gt; including the numpy/arrayobject.h file. In the module initialization routine you call &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;. In addition, in the files that do not have the module initialization sub_routine define &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; prior to including numpy/arrayobject.h.</source>
          <target state="translated">이러한 #defines를 사용하면 단일 확장 모듈에 대해 여러 파일에서 C-API를 사용할 수 있습니다. 각 파일에서 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 C-API를 보유 할 이름으로 정의해야합니다 ( &lt;em&gt;예 :&lt;/em&gt; myextension_ARRAY_API). numpy / arrayobject.h 파일을 포함시키기 &lt;strong&gt;전에&lt;/strong&gt; 수행해야 합니다. 모듈 초기화 루틴에서 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 . 또한 모듈 초기화 하위 _ 루틴이없는 파일에서 NO_IMPORT_ARRAY를 정의 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; NumPy와 / arrayobject.h 포함하기 전에.</target>
        </trans-unit>
        <trans-unit id="315900bdae1d95768693f5caf49a459c0e9247e8" translate="yes" xml:space="preserve">
          <source>Using this result to index &lt;code&gt;a&lt;/code&gt; is equivalent to using the mask directly:</source>
          <target state="translated">이 결과를 사용하여 &lt;code&gt;a&lt;/code&gt; 를 색인화 하는 것은 마스크를 직접 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b3c55a8f302db1fd2b8e30d4741e13199d60cd0" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;), will be about</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1e207983fdf75c13618b12af3dac2cc9b09a86a" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;), will be about</source>
          <target state="translated">이 체계를 사용하면, 유도하는 스트림의 수를 알면 충돌 확률의 상한을 추정 할 수 있습니다. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; 는 기본적으로&lt;/a&gt; 시드와 스폰 트리 경로의 입력을 128 비트 풀로 해시합니다. 비수 적으로 추정 된 풀에 충돌이있을 확률은 대략 &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81f2b8dfbfc71c96c12b186f5770d7cbd6cb20f2" translate="yes" xml:space="preserve">
          <source>Using tuples. &lt;code&gt;int&lt;/code&gt; is a fixed type, 3 the field&amp;rsquo;s shape. &lt;code&gt;void&lt;/code&gt; is a flexible type, here of size 10:</source>
          <target state="translated">튜플 사용. &lt;code&gt;int&lt;/code&gt; 는 고정 된 유형이며, 3 필드의 모양입니다. &lt;code&gt;void&lt;/code&gt; 는 크기 10의 유연한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="824f10f86cbfa339b11bf5f57f7a0ce042086b4a" translate="yes" xml:space="preserve">
          <source>Using via &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6043061ff0da53be43d1b2e098be1b0520525dba" translate="yes" xml:space="preserve">
          <source>Using via numpy.distutils</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73888fb9a3aa49066395d1b7748b2f3a75b9907a" translate="yes" xml:space="preserve">
          <source>Using virtualenvs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8b4345a7cc12338d15d1fb67d9e4a4feb23426" translate="yes" xml:space="preserve">
          <source>Usually denoted</source>
          <target state="translated">일반적으로 표시</target>
        </trans-unit>
        <trans-unit id="9efea8253bd046afd804470a677e434b3a6392ca" translate="yes" xml:space="preserve">
          <source>Usually there is no need to worry about how the arrays are stored in memory and whether the wrapped functions, being either Fortran or C functions, assume one or another storage order. F2PY automatically ensures that wrapped functions get arguments with proper storage order; the corresponding algorithm is designed to make copies of arrays only when absolutely necessary. However, when dealing with very large multidimensional input arrays with sizes close to the size of the physical memory in your computer, then a care must be taken to use always proper-contiguous and proper type arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04880c31a806536e09375a28b6393c4ae89b3000" translate="yes" xml:space="preserve">
          <source>Usually, defining a dtype is sufficient to define how the sequence of strings must be converted. However, some additional control may sometimes be required. For example, we may want to make sure that a date in a format &lt;code&gt;YYYY/MM/DD&lt;/code&gt; is converted to a &lt;code&gt;datetime&lt;/code&gt; object, or that a string like &lt;code&gt;xx%&lt;/code&gt; is properly converted to a float between 0 and 1. In such cases, we should define conversion functions with the &lt;code&gt;converters&lt;/code&gt; arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5abc30aa6f2b926c1472fe22071db5adb16a0bc" translate="yes" xml:space="preserve">
          <source>Usually, however, adding the &lt;code&gt;tests/&lt;/code&gt; directory to the python path isn&amp;rsquo;t desirable. Instead it would better to invoke the test straight from the module &lt;code&gt;xxx&lt;/code&gt;. To this end, simply place the following lines at the end of your package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt; file:</source>
          <target state="translated">그러나 일반적으로 python 경로에 &lt;code&gt;tests/&lt;/code&gt; 디렉토리를 추가하는 것은 바람직하지 않습니다. 대신 &lt;code&gt;xxx&lt;/code&gt; 모듈에서 직접 테스트를 호출하는 것이 좋습니다 . 이를 위해 패키지의 &lt;code&gt;__init__.py&lt;/code&gt; 파일 끝에 다음 줄을 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="6be23322b56766a1db9b8621387497e594f16d2d" translate="yes" xml:space="preserve">
          <source>Utility classes and functions for the polynomial modules.</source>
          <target state="translated">다항식 모듈의 유틸리티 클래스 및 함수</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="d00ce61cfc8e3df435adebc36c2fa866be4f94a4" translate="yes" xml:space="preserve">
          <source>Valid dtype for all arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c5b11cbfd943ab04293f9f062d297257b4ba0e8" translate="yes" xml:space="preserve">
          <source>Validating names</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3522db33c6e586ed6f52f3af3bea08c2509cdaed" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed.</source>
          <target state="translated">마스크 된 배열에 유효하지 않은 항목이 없음을 나타내는 값입니다. 마스크가 필요하지 않은 경우 계산 속도를 높이기 위해 &lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c7830f6acd0062d2809fbc11f2bfb2e8aedd16" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed. It is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b9ec234c1eee91fedfeaba35509216217fe21cd" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;operands&lt;/code&gt; at current iteration. Normally, this is a tuple of array scalars, but if the flag &lt;code&gt;external_loop&lt;/code&gt; is used, it is a tuple of one dimensional arrays.</source>
          <target state="translated">현재 반복에서 &lt;code&gt;operands&lt;/code&gt; 값입니다 . 일반적으로 이것은 배열 스칼라의 튜플이지만 &lt;code&gt;external_loop&lt;/code&gt; 플래그 를 사용하면 1 차원 배열의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="d866e0938fcfdf12b88042317593d4295facb33c" translate="yes" xml:space="preserve">
          <source>Value to be placed in field.</source>
          <target state="translated">필드에 배치 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4ba37300f6a7d1d653bfd085d1c3e62828c53205" translate="yes" xml:space="preserve">
          <source>Value to be used to fill NaN values. If no value is passed then NaN values will be replaced with 0.0.</source>
          <target state="translated">NaN 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 NaN 값이 0.0으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="73822c64a61d90da64aca29978cabf65524aa150" translate="yes" xml:space="preserve">
          <source>Value to be used to fill negative infinity values. If no value is passed then negative infinity values will be replaced with a very small (or negative) number.</source>
          <target state="translated">음의 무한대 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 음의 무한대 값이 매우 작은 (또는 음수) 숫자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f4796b06e4cb3d07bcdfe89591ec37b878b0609f" translate="yes" xml:space="preserve">
          <source>Value to be used to fill positive infinity values. If no value is passed then positive infinity values will be replaced with a very large number.</source>
          <target state="translated">양의 무한대 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 양의 무한대 값이 매우 큰 숫자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f7cccdf775f458dbd65351fa14dd9eb110134681" translate="yes" xml:space="preserve">
          <source>Value to be written on the diagonal, its type must be compatible with that of the array a.</source>
          <target state="translated">대각선에 쓰여질 값. 그 타입은 배열의 타입과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="715dcdd8f6ff522d4658e491027e9aae31a8b5e6" translate="yes" xml:space="preserve">
          <source>Value to format.</source>
          <target state="translated">형식화 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="3d3e32ccc4b0ab4e1f0dc806d286fb59b6c443d6" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt;, default is &lt;code&gt;fp[-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt; 대해 반환 할 값 입니다. 기본값은 &lt;code&gt;fp[-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26d4865cbe90216e1386cb06fe27a2a8a2fdea6f" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt;, default is &lt;code&gt;fp[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt; 대해 반환 할 값 입니다. 기본값은 &lt;code&gt;fp[0]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7a5e0e3824dade99c632ba9171e408c2ecc5e00" translate="yes" xml:space="preserve">
          <source>Value used for fixing invalid data. Default is None, in which case the &lt;code&gt;a.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">유효하지 않은 데이터를 수정하는 데 사용되는 값입니다. 기본값은 없음이며,이 경우 &lt;code&gt;a.fill_value&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69ddc9b73f581b3343b0affbf7e4377d672439b1" translate="yes" xml:space="preserve">
          <source>Value used internally for the masked values. If &lt;code&gt;fill_value&lt;/code&gt; is not None, it supersedes &lt;code&gt;endwith&lt;/code&gt;.</source>
          <target state="translated">마스크 된 값에 내부적으로 사용되는 값입니다. &lt;code&gt;fill_value&lt;/code&gt; 가 None이 아닌 경우 &lt;code&gt;endwith&lt;/code&gt; 로 대체 됩니다 .</target>
        </trans-unit>
        <trans-unit id="328663db0b3aba67f0d82903937cd9193c3e207c" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values when necessary. If None, a default based on the data-type is used.</source>
          <target state="translated">필요한 경우 마스크 된 값을 채우는 데 사용되는 값입니다. 없음 인 경우 데이터 유형을 기반으로하는 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac07a9705ce80720af8585478b1d81e8b7b8b456" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="86e71cf73f1d7bc170999262699205370f1f93e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;MaskedArray.fill_value&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 기본값은 None이며,이 경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19866b65a013a0eb3c733fc479da8433fc02a5f3" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of maximum_fill_value(self._data) is used instead.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 maximum_fill_value (self._data)의 출력이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0a58c6eeb18776376a78bc0a9866ce44b1ad27" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of minimum_fill_value(self._data) is used instead.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 minimum_fill_value (self._data)의 출력이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="752e711d9ae184609f9efa220ffeb98e2623ff23" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;code&gt;minimum_fill_value&lt;/code&gt;.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 없음 인 경우 &lt;code&gt;minimum_fill_value&lt;/code&gt; 출력을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94b3fde97e6b1196d461cd6d1087f12e6dea54b2" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of maximum_fill_value().</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 maximum_fill_value ()의 출력을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eddd55b4550fcb347a1d6bf73a696e1497719104" translate="yes" xml:space="preserve">
          <source>Values are appended to a copy of this array.</source>
          <target state="translated">이 배열의 사본에 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="24421420351a973d79bcca3d2ef0e453017e616f" translate="yes" xml:space="preserve">
          <source>Values are generated within the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (in other words, the interval including &lt;code&gt;start&lt;/code&gt; but excluding &lt;code&gt;stop&lt;/code&gt;). For integer arguments the function is equivalent to the Python built-in &lt;code&gt;range&lt;/code&gt; function, but returns an ndarray rather than a list.</source>
          <target state="translated">반 개방 간격 &lt;code&gt;[start, stop)&lt;/code&gt; 내에서 값이 생성됩니다 (즉, &lt;code&gt;start&lt;/code&gt; 를 포함 하지만 &lt;code&gt;stop&lt;/code&gt; 을 제외한 간격 ). 정수 인수의 경우 함수는 Python 내장 &lt;code&gt;range&lt;/code&gt; 함수와 동일하지만 목록이 아닌 ndarray를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="38b38aff8e14ce007107a5b62d7837a43399e916" translate="yes" xml:space="preserve">
          <source>Values at which the weight function will be computed.</source>
          <target state="translated">가중치 함수가 계산 될 값입니다.</target>
        </trans-unit>
        <trans-unit id="8afc1edfb8d26a9a4bac7610a9a2ed43bc17c240" translate="yes" xml:space="preserve">
          <source>Values from which to choose. &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt; need to be broadcastable to some shape.</source>
          <target state="translated">선택할 값입니다. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;condition&lt;/code&gt; 은 어떤 형태로도 방송 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="55fd9fa348e62e91b8d05086f74314a1ab640581" translate="yes" xml:space="preserve">
          <source>Values in &lt;code&gt;i&lt;/code&gt; of less than 0 are treated as 0 (which yields an empty string).</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 보다 작은 i 의 값은 0으로 처리됩니다 (빈 문자열 생성).</target>
        </trans-unit>
        <trans-unit id="c01309d65a99b72623b37f6cd9a8f8ab7021db81" translate="yes" xml:space="preserve">
          <source>Values of the dictionary are strings or sequence of strings. The corresponding keys can be column indices (integers) or column names (strings). In addition, the special key &lt;code&gt;None&lt;/code&gt; can be used to define a default applicable to all columns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0da0f066601a2a9367e697b89519e6b0c50e33e" translate="yes" xml:space="preserve">
          <source>Values to change the sign of.</source>
          <target state="translated">부호를 변경할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4158750ed1844d81234e02100fb4f6a0ce246137" translate="yes" xml:space="preserve">
          <source>Values to find the next representable value of.</source>
          <target state="translated">다음으로 표현 가능한 값을 찾는 값입니다.</target>
        </trans-unit>
        <trans-unit id="beb9a9be5bcba10dec2aa7359c7898f16a9d7ca8" translate="yes" xml:space="preserve">
          <source>Values to find the spacing of.</source>
          <target state="translated">간격을 찾을 값입니다.</target>
        </trans-unit>
        <trans-unit id="3b61fff151ba4cdc5d10abd1dbdd04d94f432686" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">값으로 삽입 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19b54e21994fdcbd2ab01d7104b74c970245cfe1" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;arr&lt;/code&gt;. If the type of &lt;code&gt;values&lt;/code&gt; is different from that of &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; is converted to the type of &lt;code&gt;arr&lt;/code&gt;. &lt;code&gt;values&lt;/code&gt; should be shaped so that &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; is legal.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 에 삽입 할 값 입니다. &lt;code&gt;values&lt;/code&gt; 의 유형이 &lt;code&gt;arr&lt;/code&gt; 과 다른 경우 &lt;code&gt;values&lt;/code&gt; 은 &lt;code&gt;arr&lt;/code&gt; 유형으로 변환됩니다 . &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; 이 유효 하도록 &lt;code&gt;values&lt;/code&gt; 을 형성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="817bf23706b268004f4bf56ee98317c1ad7d150d" translate="yes" xml:space="preserve">
          <source>Values to place in &lt;code&gt;a&lt;/code&gt; at target indices. If &lt;code&gt;v&lt;/code&gt; is shorter than &lt;code&gt;ind&lt;/code&gt; it will be repeated as necessary.</source>
          <target state="translated">값에 배치 대상 인덱스에서. 경우 &lt;code&gt;v&lt;/code&gt; 보다 짧은 &lt;code&gt;ind&lt;/code&gt; 은 필요에 따라 반복됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9be9f0fa346eb48800661efe4c9cdccf0a4d68a" translate="yes" xml:space="preserve">
          <source>Values to place in self._data copy at target indices.</source>
          <target state="translated">대상 인덱스에서 self._data 사본에 배치 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="81f73f98efd45554f2765f8a372cd020b7023051" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &amp;ldquo;a&amp;rdquo; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &amp;ldquo;a&amp;rdquo; except along axis.</source>
          <target state="translated">차이를 수행하기 전에 축을 따라 &quot;a&quot;를 추가하거나 추가 할 값입니다. 스칼라 값은 축 방향으로 길이가 1이고 다른 모든 축을 따라 입력 배열의 모양으로 배열로 확장됩니다. 그렇지 않으면 치수와 모양이 축을 제외하고&amp;ldquo;a&amp;rdquo;와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e169e71a4b3659a2db1d8c19b6c033e97b1e36f" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &lt;code&gt;a&lt;/code&gt; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &lt;code&gt;a&lt;/code&gt; except along axis.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="462c5daaa1bebf27712ab1f9e6dff7991b7d4f2b" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;mask&lt;/code&gt; is True. If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it will be repeated.</source>
          <target state="translated">값에 넣어 곳 &lt;code&gt;mask&lt;/code&gt; True입니다. 경우 &lt;code&gt;values&lt;/code&gt; 보다 작은 이 반복됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25e7a819f368d39546137552cf420f108ade4ace" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt;. Only the first N elements are used, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;. If &lt;code&gt;vals&lt;/code&gt; is smaller than N, it will be repeated, and if elements of &lt;code&gt;a&lt;/code&gt; are to be masked, this sequence must be non-empty.</source>
          <target state="translated">값에 넣어 . 첫 번째 N 요소 만 사용되며 여기서 N은 &lt;code&gt;mask&lt;/code&gt; 의 True 값 수입니다 . 경우 &lt;code&gt;vals&lt;/code&gt; N보다 작은 경우는 반복 될 것이고, 요소 경우 &lt;code&gt;a&lt;/code&gt; 마스킹되어야하고,이 시퀀스는 비어 있어야한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60bd6b681e5d46e176fd602e7f740408a4b90a97" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix for powers.</source>
          <target state="translated">힘을위한 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="6401e380553d40526975bfbedfb18608ca5c00ad" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="ae6e82d94a52ea695163be06dc24993156d990a5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Hermite series.</source>
          <target state="translated">Hermite 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="a2d6130252c264087c83a0456898053f5cce8c9b" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Legendre series.</source>
          <target state="translated">Legendre 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="5d2bf93649140d94c435a78c84579d541c1303f5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of given degree.</source>
          <target state="translated">주어진 정도의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="315c420145ba2a2de3ef508e657b666b667d7db9" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix. If &lt;code&gt;increasing&lt;/code&gt; is False, the first column is &lt;code&gt;x^(N-1)&lt;/code&gt;, the second &lt;code&gt;x^(N-2)&lt;/code&gt; and so forth. If &lt;code&gt;increasing&lt;/code&gt; is True, the columns are &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt;.</source>
          <target state="translated">방데 몬드 행렬. 만약 &lt;code&gt;increasing&lt;/code&gt; 거짓이고, 첫 번째 열은 &lt;code&gt;x^(N-1)&lt;/code&gt; , 제 &lt;code&gt;x^(N-2)&lt;/code&gt; 등. 경우 &lt;code&gt;increasing&lt;/code&gt; 참이고, 열은 &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fb0e847303b2656c561914c6c1fadfb2178ba16" translate="yes" xml:space="preserve">
          <source>Variable names are displayed in typewriter font, obtained by using &lt;code&gt;\mathtt{var}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef7476851367ab64af3bc4c81c52e5e1e6857c25" translate="yes" xml:space="preserve">
          <source>Variables in Numpy which control and describe alignment</source>
          <target state="translated">정렬을 제어하고 설명하는 Numpy의 변수</target>
        </trans-unit>
        <trans-unit id="2a1f6fba473be39ef3c80a51eed0db143c77f764" translate="yes" xml:space="preserve">
          <source>Variance while not ignoring NaNs</source>
          <target state="translated">NaN을 무시하지 않는 동안의 차이</target>
        </trans-unit>
        <trans-unit id="8676fa65ac8cfd04cdda1d2741f1f3486c926b70" translate="yes" xml:space="preserve">
          <source>Various continuous integration (CI) services are triggered after each PR update to build the code, run unit tests, measure code coverage and check coding style of your branch. The CI tests must pass before your PR can be merged. If CI fails, you can find out why by clicking on the &amp;ldquo;failed&amp;rdquo; icon (red cross) and inspecting the build and test log. To avoid overuse and waste of this resource, &lt;a href=&quot;development_environment#recommended-development-setup&quot;&gt;test your work&lt;/a&gt; locally before committing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47604fcededf37e9515dbd4dd1f0e8ae5e2d23c4" translate="yes" xml:space="preserve">
          <source>Various fields have standard formats for array data. The following lists the ones with known python libraries to read them and return numpy arrays (there may be others for which it is possible to read and convert to numpy arrays so check the last section as well)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407b9055a29b3862ad6596884f933fb2e3b90801" translate="yes" xml:space="preserve">
          <source>Various windows</source>
          <target state="translated">다양한 창</target>
        </trans-unit>
        <trans-unit id="a77d3d622bb695acc100256fe700b0a21c995057" translate="yes" xml:space="preserve">
          <source>Vector Quantization J. Makhoul, S. Roucos, and H. Gish, &amp;ldquo;Vector Quantization in Speech Coding,&amp;rdquo; Proc. IEEE, vol. 73, pp. 1551-1587, Nov. 1985.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d5df32cb3f2a3be9fd3df5321700c5dfe41670" translate="yes" xml:space="preserve">
          <source>Vector Stacking</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690a0d6330a132cb4527e3e44d7a2347c9a06b3a" translate="yes" xml:space="preserve">
          <source>Vector cross product(s).</source>
          <target state="translated">교차 제품 벡터.</target>
        </trans-unit>
        <trans-unit id="28cb052426ac62f08e613cbe9ac7789542c3593f" translate="yes" xml:space="preserve">
          <source>Vector cross-product.</source>
          <target state="translated">교차 제품 벡터.</target>
        </trans-unit>
        <trans-unit id="0fe94b620577959abe98d342c3396c44b95bc9ac" translate="yes" xml:space="preserve">
          <source>Vector inner and outer products, &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;numpy.inner&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;numpy.outer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">벡터 내부 및 외부 제품 &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;numpy.inner&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;numpy.outer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc155524d5d2ad1522cc08f2291c52dc38dcecf1" translate="yes" xml:space="preserve">
          <source>Vector inner products:</source>
          <target state="translated">벡터 내부 제품 :</target>
        </trans-unit>
        <trans-unit id="7b8a7176d65340f9da0fa7937d046de8633e6685" translate="yes" xml:space="preserve">
          <source>Vector outer product:</source>
          <target state="translated">벡터 외부 제품 :</target>
        </trans-unit>
        <trans-unit id="acae4c791d04e4455a560ff6e41306cbb57dcf51" translate="yes" xml:space="preserve">
          <source>Vector(s) with the singular values, within each vector sorted in descending order. The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">내림차순으로 정렬 된 각 벡터 내에서 특이 값을 가진 벡터입니다. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원은 입력 &lt;code&gt;a&lt;/code&gt; 와 크기가 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5acfbe842fd0541792480526462188b04dde53" translate="yes" xml:space="preserve">
          <source>Vector, vector returns the scalar inner product, but neither argument is complex-conjugated:</source>
          <target state="translated">벡터, 벡터는 스칼라 내부 곱을 반환하지만 인수가 복잡하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d24d62baa6df1c0e53e6c0f85d62c2190886f5dd" translate="yes" xml:space="preserve">
          <source>Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just &amp;ldquo;behind the scenes&amp;rdquo; in optimized, pre-compiled C code. Vectorized code has many advantages, among which are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6ec9d2e3c00c48eca40b4ca66a3c4d474b90630" translate="yes" xml:space="preserve">
          <source>Vectorized function.</source>
          <target state="translated">벡터화 기능.</target>
        </trans-unit>
        <trans-unit id="72db9853411ecb8ab44d24a7ecaed3ef15eeb780" translate="yes" xml:space="preserve">
          <source>Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56a92946aff3755099c7d26b356bbca785b0c03f" translate="yes" xml:space="preserve">
          <source>Verbosity value for test outputs, in the range 1-10. Default is 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bfe5238ce1d36e9bfcb089f4f57728d117a113e" translate="yes" xml:space="preserve">
          <source>Verify the mean and the variance:</source>
          <target state="translated">평균과 분산을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="51eea7cbb443c92981917f3f8bfdb384f15a6153" translate="yes" xml:space="preserve">
          <source>Version of this function that preserves the shape of ar1.</source>
          <target state="translated">ar1의 모양을 유지하는이 함수의 버전.</target>
        </trans-unit>
        <trans-unit id="224aeb6086ba7022d83156756ac873c6ff737642" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 유형의 일반 NumPy 배열과 비교 클래스는 다음 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a21f850c092874207e85425f1992b2d1d4a0daef" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 유형의 일반 NumPy 배열과 비교 클래스는 다음 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8dff4805e231cae5fc82f2b66c5c75ea9b76e2a9" translate="yes" xml:space="preserve">
          <source>Very little support for C++ code and its different library-calling conventions. You will probably need a C wrapper around C++ code to use with ctypes (or just use Boost.Python instead).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c127fa63d626c5390ae1bdab993f5e47e3ded50c" translate="yes" xml:space="preserve">
          <source>Very often, it is desirable to iterate over several arrays at the same time. The universal functions are an example of this kind of behavior. If all you want to do is iterate over arrays with the same shape, then simply creating several iterator objects is the standard procedure. For example, the following code iterates over two arrays assumed to be the same shape and size (actually obj1 just has to have at least as many total elements as does obj2):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba00ebd75f3175e23b4f09615b45ef3560ac5818" translate="yes" xml:space="preserve">
          <source>View based and advanced indexing is mixed. In this case the view based indexing defines a collection of subarrays that are combined by the advanced indexing. For example, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; is created by vertically stacking the subarrays &lt;code&gt;arr[1, :]&lt;/code&gt;, &lt;code&gt;arr[2,:]&lt;/code&gt;, and &lt;code&gt;arr[3, :]&lt;/code&gt;.</source>
          <target state="translated">뷰 기반 및 고급 인덱싱이 혼합되어 있습니다. 이 경우 뷰 기반 인덱싱은 고급 인덱싱에 의해 결합 된 하위 배열의 컬렉션을 정의합니다. 예를 들어, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; 는 하위 배열 &lt;code&gt;arr[1, :]&lt;/code&gt; , &lt;code&gt;arr[2,:]&lt;/code&gt; , &lt;code&gt;arr[3, :]&lt;/code&gt; 을 세로로 쌓아서 만듭니다 . 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a9c88862eb9a71fc0e8a80b619b8e3f7d2d2d42e" translate="yes" xml:space="preserve">
          <source>View casting</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56880c7be840a348e75d7f5abcf907eb8bf9c7d5" translate="yes" xml:space="preserve">
          <source>View casting - casting an existing ndarray as a given subclass</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2ca30abe686b95f053f55957fa5266ab07dca0a" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least three dimensions.</source>
          <target state="translated">입력을 3 차원 이상의 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="45fb889525ea027b940786067638d779d675de17" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least two dimensions.</source>
          <target state="translated">입력 값을 2 차원 이상의 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="6e4fbf98b4a2f11308bf6ec449635485ea8cdb89" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased by one.</source>
          <target state="translated">보기 차원의 수는 하나씩 증가. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1435a6e88e9cfdd34dddec8e0ea3d664de355e82" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf2e6fd5608dfcde8e1d428501030442d53386c" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt;, with axes suitably permuted.</source>
          <target state="translated">의보기 축이 적절히 순열과 함께. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d2e5a4061b7a0c16fd366760c98d172091bc5e" translate="yes" xml:space="preserve">
          <source>View or Shallow Copy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="690413363bd8aafde5497bc7e1d13a4d8e5f2372" translate="yes" xml:space="preserve">
          <source>View the array as a record array:</source>
          <target state="translated">배열을 레코드 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="aea7dff1c7bb5f575c10f755c8f2b7c22ca00476" translate="yes" xml:space="preserve">
          <source>Viewing Structured Arrays Containing Objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d42abd80c44b454ac926e28ee7856a84a169a3" translate="yes" xml:space="preserve">
          <source>Viewing array data using a different type and dtype:</source>
          <target state="translated">다른 유형과 dtype을 사용하여 배열 데이터보기 :</target>
        </trans-unit>
        <trans-unit id="e4585378f90f92f4cace47440b8fa755fd8680a6" translate="yes" xml:space="preserve">
          <source>Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it&amp;rsquo;s important to be aware of this - modifying data in a view also modifies the original array!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30c8756fc6d8ab2295389484bbe9c6879a472d3c" translate="yes" xml:space="preserve">
          <source>Views of arrays in Fortran order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59879f373c87da4a2c95c0412230c3555cfc240e" translate="yes" xml:space="preserve">
          <source>Views returned from einsum are now writeable whenever the input array is writeable. For example, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; will now have the same effect as &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; will return a writeable view of the diagonal of a 2D array.</source>
          <target state="translated">입력 배열을 쓸 수있을 때마다 einsum에서 반환 된 뷰를 쓸 수 있습니다. 예를 들어, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; 는 이제 &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 와 동일한 효과를 갖습니다. , ㅏ) 2D 배열의 대각선에 대한 쓰기 가능한보기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="212733d972db48c77aaab9351402436eae4fd2ff" translate="yes" xml:space="preserve">
          <source>Views share data:</source>
          <target state="translated">조회수는 데이터를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c9d8f3fc365bae8c1e0312cb68b7341a485aec6e" translate="yes" xml:space="preserve">
          <source>Views that change the dtype size (bytes per entry) should normally be avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</source>
          <target state="translated">dtype 크기 (항목 당 바이트 수)를 변경하는 뷰는 슬라이스, 조옮김, 포트 순서 지정 등으로 정의 된 배열에서는 일반적으로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="56b0a8ac25b1950e1419116b1fa18ea25ea62bb3" translate="yes" xml:space="preserve">
          <source>Violent threats or language directed against another person.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43e46231e2e4425940323040c2be47d46f02e331" translate="yes" xml:space="preserve">
          <source>Virtualenv</source>
          <target state="translated">Virtualenv</target>
        </trans-unit>
        <trans-unit id="2e7e7becfbd2f76f4c7a1cf2e451eb461ef24b08" translate="yes" xml:space="preserve">
          <source>Virtualenv is a very useful tool to keep several versions of packages around. It is also used in the Paver script to build the docs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="3cd2f9e2b1f25c2f5e7b93f7ce911077d7d964a4" translate="yes" xml:space="preserve">
          <source>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery, &amp;ldquo;Numerical Recipes (3rd edition)&amp;rdquo;, Cambridge University Press, 2007, page 795.</source>
          <target state="translated">WH Press, SA Teukolsky, WT Vetterling 및 BP Flannery,&amp;ldquo;Numerical Recipes (3 판)&amp;rdquo;, Cambridge University Press, 2007, 795 페이지.</target>
        </trans-unit>
        <trans-unit id="e9c669c28770b602c0d3307e40af975f3d6ab286" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 425.</source>
          <target state="translated">WH Press, BP Flannery, SA Teukolsky 및 WT Vetterling,&amp;ldquo;수치 레시피&amp;rdquo;, Cambridge University Press, 1986 년, 425 페이지.</target>
        </trans-unit>
        <trans-unit id="dbd0b2fdf754a4d650097a931842e3ce01d68c23" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 429.</source>
          <target state="translated">WH Press, BP Flannery, SA Teukolsky 및 WT Vetterling,&amp;ldquo;수치 레시피&amp;rdquo;, Cambridge University Press, 1986, 429 페이지.</target>
        </trans-unit>
        <trans-unit id="4d8b44b86ac9762795ccf1eb37bf4871143a380a" translate="yes" xml:space="preserve">
          <source>WRITEABLE (W) the data area can be written to;</source>
          <target state="translated">쓰기 가능 (W) 데이터 영역에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dcab075be566e2b98d550a936f8cae5ce9422f" translate="yes" xml:space="preserve">
          <source>WRITEABLE / W</source>
          <target state="translated">쓰기 가능 / W</target>
        </trans-unit>
        <trans-unit id="73fb58e7589a9ff67f327a9e1cfb0abcae369bb5" translate="yes" xml:space="preserve">
          <source>WRITEABLE can only be set &lt;code&gt;True&lt;/code&gt; if the array owns its own memory or the ultimate owner of the memory exposes a writeable buffer interface or is a string.</source>
          <target state="translated">WRITEABLE은 어레이가 자체 메모리를 소유하거나 메모리의 최종 소유자가 쓰기 가능한 버퍼 인터페이스를 노출하거나 문자열 인 경우 에만 &lt;code&gt;True&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ca2fe3e818dba5a5804a5bb3a831dd89c500d7a" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced by .base). When the C-API function PyArray_ResolveWritebackIfCopy is called, the base array will be updated with the contents of this array.</source>
          <target state="translated">WRITEBACKIFCOPY (X)이 배열은 다른 배열 (.base로 참조)의 복사본입니다. C-API 함수 PyArray_ResolveWritebackIfCopy가 호출되면 기본 배열이이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="3b243b9b37eb143e3a1ec8091e9c80e424b7cb17" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY / X</source>
          <target state="translated">WRITEBACKIFCOPY / X</target>
        </trans-unit>
        <trans-unit id="09fcb82609179c1f7885c137f520c527fdcb1905" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">WRITEBACKIFCOPY는 &lt;code&gt;False&lt;/code&gt; 로만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd7081253d772e7a32e41421d2cdf6a9cabced2" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, &amp;ldquo;A Statistical Distribution Function of Wide Applicability&amp;rdquo;, Journal Of Applied Mechanics ASME Paper 1951.</source>
          <target state="translated">Waloddi Weibull,&amp;ldquo;광범위한 적용 성의 통계 분포 함수&amp;rdquo;, 응용 역학 저널 ASME 논문 1951.</target>
        </trans-unit>
        <trans-unit id="db8ff1d3b42b8d1fe40e88e8148de81cccee175c" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, Royal Technical University, Stockholm, 1939 &amp;ldquo;A Statistical Theory Of The Strength Of Materials&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</source>
          <target state="translated">1939 년 스톡홀름 왕립 기술 대학교 Waloddi Weibull,&amp;ldquo;재료의 강도에 관한 통계 이론&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</target>
        </trans-unit>
        <trans-unit id="f1346bf7169c446f1eec32708e49a903284d1169" translate="yes" xml:space="preserve">
          <source>Warn when saving a dtype with metadata</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="4754f4fe525f9c37d19fda1322550a0b26e13158" translate="yes" xml:space="preserve">
          <source>Warning class to filter</source>
          <target state="translated">필터링 할 경고 클래스</target>
        </trans-unit>
        <trans-unit id="f88a191846138392ad4758d4ff77a36f017f6d00" translate="yes" xml:space="preserve">
          <source>Warning objects</source>
          <target state="translated">경고 객체</target>
        </trans-unit>
        <trans-unit id="bb630d84baa9f5fb3c8c438ee6064e7457d1688d" translate="yes" xml:space="preserve">
          <source>Warning on casting complex to real</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37361059464af82221d16eb1a2018e9694f9cd57" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and is not a datatype description compatible with &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">경고 :이 속성은 &lt;code&gt;__array_interface__&lt;/code&gt; 에 특별히 존재하며 np.dtype 과 호환되는 데이터 유형 설명이 &lt;code&gt;np.dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53dd2d8a36d40ea4bb66f08310fbbcb2e7533b5f" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and passing it directly to &lt;code&gt;np.dtype&lt;/code&gt; will not accurately reconstruct some dtypes (e.g., scalar and subarray dtypes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67f63aaa6eb093a2b8631aeb7aa1f1f56dd3fc86" translate="yes" xml:space="preserve">
          <source>Warning: This functionality does &lt;strong&gt;not&lt;/strong&gt; consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, taken from &lt;code&gt;a&lt;/code&gt; as they are laid out in memory, disregarding strides and axes. (This is in case the new shape is smaller. For larger, see above.) This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.</source>
          <target state="translated">경고 :이 기능은 축을 개별적으로 고려 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 즉 보간 / 외삽 법이 적용되지 않습니다. 그것은 보폭과 축을 무시하고 메모리에 배치 된 &lt;code&gt;a&lt;/code&gt; 에서 가져온 필요한 수의 요소로 반환 배열을 채 웁니다 . (이것은 새로운 모양이 더 작은 경우에 해당됩니다. 더 큰 것은 위를 참조하십시오.) 따라서이 기능은 이미지 나 각 축이 별개의 개별 엔티티를 나타내는 데이터의 크기를 조정하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="60f5d88ea293a20258ae77bd080550b12d5b3d82" translate="yes" xml:space="preserve">
          <source>Warns</source>
          <target state="translated">Warns</target>
        </trans-unit>
        <trans-unit id="6fcbb55cbf3a317fd9e559a46404d4ffc0901e5d" translate="yes" xml:space="preserve">
          <source>Warns:</source>
          <target state="translated">Warns:</target>
        </trans-unit>
        <trans-unit id="2877e71e929aa29b0e79a512d385261189d70371" translate="yes" xml:space="preserve">
          <source>Wave heights tend to follow a Rayleigh distribution. If the mean wave height is 1 meter, what fraction of waves are likely to be larger than 3 meters?</source>
          <target state="translated">파도 높이는 레일리 분포를 따르는 경향이 있습니다. 평균 파고가 1 미터 인 경우 파동의 3 분의 1보다 큰 파편의 비율은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="58cd26b5bf632fda361651c5bed4615a24ac5c34" translate="yes" xml:space="preserve">
          <source>We are thankful to the groups behind the following documents, from which we drew content and inspiration:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87d1583437d12a714a66434e88f0db3dd9eec3f0" translate="yes" xml:space="preserve">
          <source>We build 32- and 64-bit wheels on Windows. Windows 7, 8 and 10 are supported. We build NumPy using the &lt;a href=&quot;https://mingwpy.github.io&quot;&gt;mingw-w64 toolchain&lt;/a&gt; on Appveyor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52a53769f72b3e9d74a22d9793d68e7e1c952be3" translate="yes" xml:space="preserve">
          <source>We build all our wheels on cloud infrastructure - so this list of compilers is for information and debugging builds locally. See the &lt;code&gt;.travis.yml&lt;/code&gt; and &lt;code&gt;appveyor.yml&lt;/code&gt; scripts in the &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;numpy wheels&lt;/a&gt; repo for the definitive source of the build recipes. Packages that are available using pip are noted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffd71ee5e18a21e4fac71c59e3fce6abfaf692e" translate="yes" xml:space="preserve">
          <source>We build and ship &lt;a href=&quot;https://www.python.org/dev/peps/pep-0513&quot;&gt;manylinux1&lt;/a&gt; wheels for NumPy. Many Linux distributions include their own binary builds of NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a47a01a930577b3f6fd6bc57c66f9caa61248a" translate="yes" xml:space="preserve">
          <source>We build source releases in both .zip and .tar.gz formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fdab75def7d856cf227160207c1857877a95de" translate="yes" xml:space="preserve">
          <source>We can access the elements in the array using square brackets. When you&amp;rsquo;re accessing elements, remember that indexing in NumPy starts at 0. That means that if you want to access the first element in your array, you&amp;rsquo;ll be accessing element &amp;ldquo;0&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72895573c71234a77f8f78e60c8d2a3fa9071512" translate="yes" xml:space="preserve">
          <source>We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d199611fe572f9a604421aeb87fed868192644af" translate="yes" xml:space="preserve">
          <source>We can begin with a chain dot example. In this case, it is optimal to contract the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; tensors first as represented by the first element of the path &lt;code&gt;(1, 2)&lt;/code&gt;. The resulting tensor is added to the end of the contraction and the remaining contraction &lt;code&gt;(0, 1)&lt;/code&gt; is then completed.</source>
          <target state="translated">우리는 체인 도트 예제로 시작할 수 있습니다. 이 경우 경로의 첫 번째 요소 &lt;code&gt;(1, 2)&lt;/code&gt; 로 표시되는대로 &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 텐서를 먼저 수축시키는 것이 가장 좋습니다. 결과 텐서가 수축의 끝에 추가되고 나머지 수축 &lt;code&gt;(0, 1)&lt;/code&gt; 이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c24b2dc7e2cf1c2ee15a3b856c501da4eb664f2c" translate="yes" xml:space="preserve">
          <source>We can convert to a numpy array using &lt;a href=&quot;../reference/generated/numpy.array#numpy.array&quot;&gt;&lt;code&gt;numpy.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;, which will call its &lt;code&gt;__array__&lt;/code&gt; method to obtain a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="679a2f0f20fc2e3fa05b5f20a0ca536c32a5eeaa" translate="yes" xml:space="preserve">
          <source>We can get a finer control on the conversion of missing values with the &lt;code&gt;filling_values&lt;/code&gt; optional argument. Like &lt;code&gt;missing_values&lt;/code&gt;, this argument accepts different kind of values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a6a3c1aa8ab5615ae93578f83c6c2bc137c427" translate="yes" xml:space="preserve">
          <source>We can now compute the mean of the dataset, without taking the invalid data into account:</source>
          <target state="translated">이제 유효하지 않은 데이터를 고려하지 않고 데이터 세트의 평균을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c82ab011abc5da0365af1d671286d5b3b09bbe" translate="yes" xml:space="preserve">
          <source>We can overwrite this default with the &lt;code&gt;defaultfmt&lt;/code&gt; argument, that takes any format string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07dfd0de116a4118d2e8d7ab1e0ba4c4055ce110" translate="yes" xml:space="preserve">
          <source>We can replace the maximum values with:</source>
          <target state="translated">최대 값을 다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a512625d0cb7e17ddcfbaaf190c6f0c94959ed" translate="yes" xml:space="preserve">
          <source>We can reset the function to the default:</source>
          <target state="translated">기능을 기본값으로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b52b8758d686451191a4e1193e567d392d717d53" translate="yes" xml:space="preserve">
          <source>We can rewrite the line equation as &lt;code&gt;y = Ap&lt;/code&gt;, where &lt;code&gt;A = [[x 1]]&lt;/code&gt; and &lt;code&gt;p = [[m], [c]]&lt;/code&gt;. Now use &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt; to solve for &lt;code&gt;p&lt;/code&gt;:</source>
          <target state="translated">선 방정식을 &lt;code&gt;y = Ap&lt;/code&gt; 로 다시 작성할 수 있습니다 . 여기서 &lt;code&gt;A = [[x 1]]&lt;/code&gt; 및 &lt;code&gt;p = [[m], [c]]&lt;/code&gt; 입니다. 이제 &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;p&lt;/code&gt; 를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="9280da38538a3f969f230f09cea0b4dbc319a8ef" translate="yes" xml:space="preserve">
          <source>We can see the image using the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow&quot;&gt;&lt;code&gt;matplotlib.pyplot.imshow&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcf794d24d8964269b87153ebb1affba96ff631d" translate="yes" xml:space="preserve">
          <source>We can sort either by using sort directly, or argsort and this function</source>
          <target state="translated">sort를 직접 사용하거나 argsort와이 함수를 사용하여 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c8b935f50d33884f474e4109b428a56eb6fe6366" translate="yes" xml:space="preserve">
          <source>We can use a different method other than the default to factorize cov: &amp;gt;&amp;gt;&amp;gt; y = rng.multivariate_normal(mean, cov, (3, 3), method=&amp;rsquo;cholesky&amp;rsquo;) &amp;gt;&amp;gt;&amp;gt; y.shape (3, 3, 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23502bd41157dbb482cc4d93fe154b6f35759b68" translate="yes" xml:space="preserve">
          <source>We can verify this, approximating the derivative with &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt;:</source>
          <target state="translated">우리는 이것을 &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt; 근사값을 근사화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1edbc1babc558648a370766b66d6bf09ff4d2327" translate="yes" xml:space="preserve">
          <source>We chose our default threshold because it is in wide use. Other thresholds are possible. For example, elsewhere in the 2007 edition of &lt;em&gt;Numerical recipes&lt;/em&gt; there is an alternative threshold of &lt;code&gt;S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt;. The authors describe this threshold as being based on &amp;ldquo;expected roundoff error&amp;rdquo; (p 71).</source>
          <target state="translated">기본 임계 값은 널리 사용되므로 기본 임계 값을 선택했습니다. 다른 임계 값도 가능합니다. 예를 들어, 2007 년판 &lt;em&gt;수치 레시피&lt;/em&gt; 의 다른 곳에 는 &lt;code&gt;S.max() * np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt; 의 대체 임계 값이 있습니다 . * np.sqrt (m + n + 1.) . 저자는이 임계 값을 &quot;예상 반올림 오류&quot;(p 71)에 기반한 것으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="81b92d4d0e0bfcb2ba46a1a8b9dd4a22e1691631" translate="yes" xml:space="preserve">
          <source>We could also have used the &lt;a href=&quot;../reference/generated/numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;numpy.allclose&lt;/code&gt;&lt;/a&gt; function to make sure the reconstructed product is, in fact, &lt;em&gt;close&lt;/em&gt; to our original matrix (the difference between the two arrays is small):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba993fff071da05f22748cefa6f6b8ad24e53b" translate="yes" xml:space="preserve">
          <source>We could have implemented:</source>
          <target state="translated">우리는 다음을 구현할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="37a18e023d482a1a5f3f0844c696551b9f7ca294" translate="yes" xml:space="preserve">
          <source>We currently support Python 3.6-3.8 on Windows, OSX, and Linux</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a1c0a83c857f695d91b773fe8da038b7dff7fd" translate="yes" xml:space="preserve">
          <source>We currently use &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; for generating the API and reference documentation for NumPy. You will need Sphinx &amp;gt;= 2.2.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59bec2d1c76c534a2fc4afd9318e87ce91e937b9" translate="yes" xml:space="preserve">
          <source>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</source>
          <target state="translated">기본적으로 OS에서 수집 한 엔트로피를 사용하여 128 비트 정수를 사용합니다. 이것은 우리가 numpy에있는 모든 생성기를 초기화하기에 좋은 양의 엔트로피입니다. 일반적으로 32 비트 미만의 작은 시드를 사용하지 않는 것이 좋습니다. 더 큰 상태 공간을 인스턴스화하기 위해 작은 시드 세트 만 사용하면 도달 할 수없는 초기 상태가 있음을 의미합니다. 모든 사람이 그러한 가치를 사용한다면 이것은 약간의 편견을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="dc787d0b25c896acc068b7c607665544c0350ae5" translate="yes" xml:space="preserve">
          <source>We do as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c39690106b67e736bf72e53ea7082db75a8ca14" translate="yes" xml:space="preserve">
          <source>We expect the arccos of 1 to be 0, and of -1 to be pi:</source>
          <target state="translated">우리는 1의 arccos가 0이고 -1의 pi가 pi 일 것으로 예상합니다 :</target>
        </trans-unit>
        <trans-unit id="44f2a9cfd92075d83d3f564752917c6115d7836b" translate="yes" xml:space="preserve">
          <source>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</source>
          <target state="translated">우리는 arctan 0은 0, 1은 pi / 4가 될 것으로 예상합니다 :</target>
        </trans-unit>
        <trans-unit id="b30e48f7bd5611b7e5063995e5e3d8d0377a6a59" translate="yes" xml:space="preserve">
          <source>We finally give an example of a full ufunc, with inner loops for half-floats, floats, doubles, and long doubles. As in the previous sections we first give the .c file and then the corresponding setup.py file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60136b35f0997a97a43dcb76040b0f18f3536c81" translate="yes" xml:space="preserve">
          <source>We have 10 degrees of freedom, so is the sample mean within 95% of the recommended value?</source>
          <target state="translated">우리는 10 자유도를 가지고 있으므로 표본 평균이 권장 값의 95 % 이내입니까?</target>
        </trans-unit>
        <trans-unit id="e5235dd026426cf863204463534241d25f8524b9" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e23f0ad561893af23edd41efd72f4bd368c5b95" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리는 numpy 함수를 (일반화 된) Ufunc로 다시 구현하려고합니다.이 경우 &lt;code&gt;__array_ufunc__&lt;/code&gt; 메소드 로 대체 될 수 있습니다 . 주요 후보는 &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; 이며, 현재 Ufunc는 아니지만 일반화 된 Ufuncs로 비교적 쉽게 다시 작성할 수 있습니다. &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 와 같은 함수에서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="1293e5317149027712d90c363de09ae292d438a7" translate="yes" xml:space="preserve">
          <source>We know how to recognize missing data, but we still need to provide a value for these missing entries. By default, this value is determined from the expected dtype according to this table:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f8e06849ef9bab23d7db3a10be02e06887dd75e" translate="yes" xml:space="preserve">
          <source>We know that it is painfully common for internet communication to start at or devolve into obvious and flagrant abuse. We also recognize that sometimes people may have a bad day, or be unaware of some of the guidelines in this Code of Conduct. Please keep this in mind when deciding on how to respond to a breach of this Code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3d95188759c6e8c19362be20ce93f51fbaea853" translate="yes" xml:space="preserve">
          <source>We know that it is painfully common for internet communication to start at or devolve into obvious and flagrant abuse. We will deal quickly with clear and severe breaches like personal threats, violent, sexist or racist language.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7544e988af826e0fbccd6c4b63e19df859cd38a" translate="yes" xml:space="preserve">
          <source>We make something where they don&amp;rsquo;t match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="781a6efc97caaf1a36d25f937ebe769fa9a9b591" translate="yes" xml:space="preserve">
          <source>We may also want to keep track of the occurrence of missing data by constructing a boolean mask, with &lt;code&gt;True&lt;/code&gt; entries where data was missing and &lt;code&gt;False&lt;/code&gt; otherwise. To do that, we just have to set the optional argument &lt;code&gt;usemask&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt; (the default is &lt;code&gt;False&lt;/code&gt;). The output array will then be a &lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d343b0827c2326d2e2dfa15e06ce5fa3d4c2f432" translate="yes" xml:space="preserve">
          <source>We may sometimes need to define the column names from the data itself. In that case, we must use the &lt;code&gt;names&lt;/code&gt; keyword with a value of &lt;code&gt;True&lt;/code&gt;. The names will then be read from the first line (after the &lt;code&gt;skip_header&lt;/code&gt; ones), even if the line is commented out:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4d639f7ac01ada7c421e46e5c0c6852fa788e6e" translate="yes" xml:space="preserve">
          <source>We might want to use an &lt;code&gt;ndarray&lt;/code&gt; to access these integers. In that case, we can create an array around this memory, and tell numpy that there are two integers, and that they are 16 bit and big-endian:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="072334154bb34d89af6df6dd9ad4c673bc66d42c" translate="yes" xml:space="preserve">
          <source>We mostly follow the standard Python style conventions as described here:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81decf25be5fe15c427b84c45168043bb0f3933" translate="yes" xml:space="preserve">
          <source>We need to keep in mind that &lt;code&gt;defaultfmt&lt;/code&gt; is used only if some names are expected but not defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="380361f0524609518a908c9433a3d7c3dd0b0e84" translate="yes" xml:space="preserve">
          <source>We need to keep in mind that by default, &lt;code&gt;dtype=float&lt;/code&gt;. A float is therefore expected for the second column. However, the strings &lt;code&gt;' 2.3%'&lt;/code&gt; and &lt;code&gt;' 78.9%'&lt;/code&gt; cannot be converted to float and we end up having &lt;code&gt;np.nan&lt;/code&gt; instead. Let&amp;rsquo;s now use a converter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3cf3455d01dd7db3c5c070359dd30cf5e39de43" translate="yes" xml:space="preserve">
          <source>We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.</source>
          <target state="translated">우리는이 동작이 체계적이지 않을 수도 있고, 마스킹 된 데이터가 경우에 따라 작업의 영향을받을 수 있으므로 사용자는이 데이터가 변경되지 않은 상태로 남아 있으면 안된다고 강조해야합니다.</target>
        </trans-unit>
        <trans-unit id="70c4b47019e4c41b3daf6bed7ca28bdcaf2fd573" translate="yes" xml:space="preserve">
          <source>We only give the C code as the setup.py file is exactly the same as the setup.py file in &lt;a href=&quot;#example-numpy-ufunc-for-one-dtype&quot;&gt;Example NumPy ufunc for one dtype&lt;/a&gt;, except that the line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58ff07099c06b392c411860c04ae360c63b97582" translate="yes" xml:space="preserve">
          <source>We only show a few blocks for clarity:</source>
          <target state="translated">명확성을 위해 몇 가지 블록 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="673c3f49f8ee0b4069fb17ea81837a33f48d70f3" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt;&lt;code&gt;isin&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#numpy.in1d&quot;&gt;&lt;code&gt;in1d&lt;/code&gt;&lt;/a&gt; for new code.</source>
          <target state="translated">새 코드 에는 &lt;a href=&quot;#numpy.in1d&quot;&gt; &lt;code&gt;in1d&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt; &lt;code&gt;isin&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cf93137d5dc17f96b6bf02cdfd69394699568873" translate="yes" xml:space="preserve">
          <source>We recommend using dtype objects instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca33c6b93a76db017c3cdc61675ace9bc2b416c" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt; extensions for files saved in this format. This is by no means a requirement; applications may wish to use these file formats but use an extension specific to the application. In the absence of an obvious alternative, however, we suggest using &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt;.</source>
          <target state="translated">이 형식으로 저장된 파일 에는 &lt;code&gt;.npy&lt;/code&gt; 및 &lt;code&gt;.npz&lt;/code&gt; 확장자를 사용하는 것이 좋습니다 . 이것은 결코 요구 사항이 아닙니다. 응용 프로그램은 이러한 파일 형식을 사용하지만 응용 프로그램에 맞는 확장명을 사용할 수 있습니다. 그러나 확실한 대안이 없으면 &lt;code&gt;.npy&lt;/code&gt; 및 &lt;code&gt;.npz&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="2d2b661adfc63aa8859c127667d479a970f43ef4" translate="yes" xml:space="preserve">
          <source>We run a ufunc on an instance of our new array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44aaad76397b012d2d13a57d62118fcba214a475" translate="yes" xml:space="preserve">
          <source>We strive to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33c0514953dd33becf83ed3bc37cb8f06826d505" translate="yes" xml:space="preserve">
          <source>We then define a new test case class for each supported data type with a short definition such as:</source>
          <target state="translated">그런 다음 지원되는 각 데이터 유형에 대해 다음과 같은 간단한 정의를 사용하여 새 테스트 사례 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0935f73910a1bfd402810a3c2528dcf47c85a9da" translate="yes" xml:space="preserve">
          <source>We understand that email is a difficult medium and can be isolating. Receiving criticism over email, without personal contact, can be particularly painful. This makes it especially important to keep an atmosphere of open-minded respect of the views of others. It also means that we must be transparent in our actions, and that we will do everything in our power to make sure that all our members are treated fairly and with sympathy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad180c1380373588b422b6f9367e1dfa995335a7" translate="yes" xml:space="preserve">
          <source>We use the algorithm published by Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and referenced by Abramowitz and Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;, for which the function domain is partitioned into the two intervals [0,8] and (8,inf), and Chebyshev polynomial expansions are employed in each interval. Relative error on the domain [0,30] using IEEE arithmetic is documented &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; as having a peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</source>
          <target state="translated">우리 Clenshaw 발행 알고리즘을 사용하여 &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 아브라모 위츠와 Stegun 의해 참조 된 &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; 기능 영역에는 두 구간 [0,8] 및 (8, INF)로 분할되는이, 및 체비 셰프 다항식 전개는에 채용 각 간격. IEEE 산술을 사용하는 도메인 [0,30]의 상대 오류 는 1.4e-16의 rms (n = 30000)로 5.8e-16의 피크를 갖는 것으로 문서화되어 있습니다 &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d53c78c1f4b5630c6b07b51b68a31292300c983" translate="yes" xml:space="preserve">
          <source>We use the same Fortran 77 code as in previous example but now we&amp;rsquo;ll pretend that F2PY was not able to guess the signatures of call-back arguments correctly. First, we create an initial signature file &lt;code&gt;callback2.pyf&lt;/code&gt; using F2PY:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0523fb6c3b4aea424494446d21b54e60300c1ae" translate="yes" xml:space="preserve">
          <source>We wait until this point to push the tag because it is public and should not be changed after it has been pushed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9afbb264decb0b7e5bd769fa476b27d49621056" translate="yes" xml:space="preserve">
          <source>We will deal with the domain and window when we get to fitting, for the moment we ignore them and run through the basic algebraic and arithmetic operations.</source>
          <target state="translated">우리는 우리가 적합 할 때 도메인과 창을 다룰 것입니다. 우리는 그것들을 무시하고 기본 대수 및 산술 연산을 수행하는 순간입니다.</target>
        </trans-unit>
        <trans-unit id="4c1bac40e83eb84eced242b32b6de4090c9d63d5" translate="yes" xml:space="preserve">
          <source>We will investigate and respond to all complaints. The NumPy Code of Conduct Committee and the NumPy Steering Committee (if involved) will protect the identity of the reporter, and treat the content of complaints as confidential (unless the reporter agrees otherwise).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a83f39578a9a665e3a205bff08ec0d259c697975" translate="yes" xml:space="preserve">
          <source>We will use NumPy&amp;rsquo;s linear algebra module, &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, to perform the operations in this tutorial. Most of the linear algebra functions in this module can also be found in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;, and users are encouraged to use the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy&quot;&gt;&lt;code&gt;scipy&lt;/code&gt;&lt;/a&gt; module for real-world applications. However, it is currently not possible to apply linear algebra operations to n-dimensional arrays using the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt; module. For more information on this, check the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html&quot;&gt;scipy.linalg Reference&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a72786c4fe5d6bfb5f753a25b0cbc3ef629d6d" translate="yes" xml:space="preserve">
          <source>We wish to mark the fourth entry as invalid. The easiest is to create a masked array:</source>
          <target state="translated">네 번째 항목을 유효하지 않은 것으로 표시하려고합니다. 가장 쉬운 방법은 마스크 배열을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2678a6cb2f01328bc5e5792424e05e77b5265e7c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll do a simple outer product, placing the dimensions of the first operand before the dimensions of the second operand. The &lt;code&gt;op_axes&lt;/code&gt; parameter needs one list of axes for each operand, and provides a mapping from the iterator&amp;rsquo;s axes to the axes of the operand.</source>
          <target state="translated">첫 번째 피연산자의 치수를 두 번째 피연산자의 치수 앞에 배치하여 간단한 외부 곱을 수행합니다. &lt;code&gt;op_axes&lt;/code&gt; 의 매개 변수는 각 피연산자에 축 하나 개의 목록을 필요로하고, 피연산자의 축에 반복자의 축에서의 매핑을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ced2186a63444cfbd458cebaed4de6214b500394" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show how this works by creating a function &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt;&lt;code&gt;square&lt;/code&gt;&lt;/a&gt; which squares its input. Let&amp;rsquo;s start with a minimal function definition excluding &amp;lsquo;out&amp;rsquo; parameter support.</source>
          <target state="translated">입력을 제곱 하는 함수 &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt; &lt;code&gt;square&lt;/code&gt; &lt;/a&gt; 을 만들어서 이것이 어떻게 작동하는지 보여 드리겠습니다 . 'out'매개 변수 지원을 제외한 최소 함수 정의부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="0d014927573cadb3b0b374c9809c25adaa8d709f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. The invert or bit-wise NOT of 13 is then:</source>
          <target state="translated">13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시되는 것을 보았습니다 . 13의 반전 또는 비트 NOT은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08e02d58d5e7e09402e352c84d20a516011f20f4" translate="yes" xml:space="preserve">
          <source>Website design and development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5117721c82b02552e432ea3720cde40d7059ad" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite polynomials.</source>
          <target state="translated">은자 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="95800a204e1bbd4903f4870d8343853257206077" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite_e polynomials.</source>
          <target state="translated">Hermite_e 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="5f860b19432a865263496fdce430b1e33571bfe5" translate="yes" xml:space="preserve">
          <source>Weight function of the Laguerre polynomials.</source>
          <target state="translated">Laguerre 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="79be08f88c623301ce3bc873b7c9affda9625a90" translate="yes" xml:space="preserve">
          <source>Weight function of the Legendre polynomials.</source>
          <target state="translated">Legendre 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="c74e4e7c5caf95682fb65872b5814741f06c7fac" translate="yes" xml:space="preserve">
          <source>Weighted average</source>
          <target state="translated">가중 평균</target>
        </trans-unit>
        <trans-unit id="d8f6b85e664320ad22c47352d13059c9a94e57ff" translate="yes" xml:space="preserve">
          <source>Weighted average.</source>
          <target state="translated">가중 평균.</target>
        </trans-unit>
        <trans-unit id="50616113e0953b16858a840423f52798108ba636" translate="yes" xml:space="preserve">
          <source>Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2).</source>
          <target state="translated">샘플 포인트의 y 좌표에 적용 할 가중치입니다. 가우스 불확실성의 경우 1 / 시그마 (1 / 시그마 ** 2 아님)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5a7070233023bbad210855f921220f6a37969ec7" translate="yes" xml:space="preserve">
          <source>Weights, array of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">가중치는 &lt;code&gt;x&lt;/code&gt; 와 동일한 모양의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="946476c654c11a5e92f8b55850bb98a1263ad96b" translate="yes" xml:space="preserve">
          <source>Weights. If not None the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">무게. 그렇지 않은 경우 적합치에 대한 각 점 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 의 기여도는 &lt;code&gt;w[i]&lt;/code&gt; 가중치가 적용됩니다 . 이상적으로 가중치는 제품 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 오차가 모두 동일한 분산을 갖도록 선택됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="1c25ee55e973a0ac3876804d2f28cc0929f53254" translate="yes" xml:space="preserve">
          <source>Weights. If not None, the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">무게. None이 아닌 경우, 각 점 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 의 적합치에 대한 가중치는 &lt;code&gt;w[i]&lt;/code&gt; 됩니다. 이상적으로 가중치는 제품 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 오차가 모두 동일한 분산을 갖도록 선택됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="890907bf4b6e9a3c2721945116f4521c292ba997" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;이분 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44532eacfd8a477fb8d811692e1a730faf373cda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Cauchy Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;Cauchy Distribution.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce6b4d0490f5c6c29f7bd660e93014a010601e88" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Gamma Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;감마 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="250b4512032938435df06c099254026086b0b46d" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Hypergeometric Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;고도 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="403ee22c6c9f5dfb6128b5015952af83dc7fe1f5" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Laplace Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;라플라스 배포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c85ee5175b40c6661962e1c4dcdc7232b8e5568a" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Logistic Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;물류 유통&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1938577c4f79d7fadb65a22f0b9b9cba0e6904e" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Negative Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;음 이항 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed9cdcffdd5a34db501b8269560f163da34bcfda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Noncentral F-Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;비 중앙 F- 배포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6786c23a16b57cae22a2a2fe8c5eef583bfac0cc" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Poisson Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;포아송 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1415ce102e6420c0e0f61ef322d348a5f507" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Sinc Function.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;Sinc Function.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d56f530182243e33b481a1e9052be8e6b37f719d" translate="yes" xml:space="preserve">
          <source>Welcome to NumPy!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abaf546091bcd48cd855fade4a2162266fa33ab0" translate="yes" xml:space="preserve">
          <source>Welcome to the absolute beginner&amp;rsquo;s guide to NumPy! If you have comments or suggestions, please don&amp;rsquo;t hesitate to reach out!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97cc607ac7fcfde11c85a5379ce211093f48fda9" translate="yes" xml:space="preserve">
          <source>Welcome! This is the documentation for NumPy 1.19.0, last updated Jun 29, 2020.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fef717821661f9806ec19067704e1d37a6e1a47" translate="yes" xml:space="preserve">
          <source>What are the least-squares-best &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;y0&lt;/code&gt; in &lt;code&gt;y = y0 + mx&lt;/code&gt; for the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points and you&amp;rsquo;ll see that it should be y0 = 0, m = 1.) The answer is provided by solving the over-determined matrix equation &lt;code&gt;Ax = b&lt;/code&gt;, where:</source>
          <target state="translated">{(0,1), (1,0), (1,2), (2,1)} 데이터에 대해 &lt;code&gt;y = y0 + mx&lt;/code&gt; 에서 최소 제곱이 가장 좋은 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;y0&lt;/code&gt; 은 무엇입니까? (점을 그래프로 표시하면 y0 = 0, m = 1이어야 함을 알 수 있습니다.) 답은 과도하게 결정된 행렬 방정식 &lt;code&gt;Ax = b&lt;/code&gt; 를 해결하여 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e9b892da0c44e54a5a3d94ba212b74404ec1950" translate="yes" xml:space="preserve">
          <source>What can be converted to a data-type object is described below:</source>
          <target state="translated">데이터 형식 개체로 변환 할 수있는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f1eadc1a60d1383bbd27a5874b7f7b346ec84b4" translate="yes" xml:space="preserve">
          <source>What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files in Python 3, which includes npy/npz files containing object arrays. Values other than &amp;lsquo;latin1&amp;rsquo;, &amp;lsquo;ASCII&amp;rsquo;, and &amp;lsquo;bytes&amp;rsquo; are not allowed, as they can corrupt numerical data. Default: &amp;lsquo;ASCII&amp;rsquo;</source>
          <target state="translated">Python 2 문자열을 읽을 때 사용할 인코딩 Python 3에서 객체 배열을 포함하는 npy / npz 파일을 포함하는 Python 2 생성 된 절인 파일을로드 할 때만 유용합니다. 'latin1', 'ASCII'및 'bytes'이외의 값은 숫자 데이터를 손상시킬 수 있으므로 허용되지 않습니다. 기본값 : 'ASCII'</target>
        </trans-unit>
        <trans-unit id="a414efd43aeae99e0f66cba2afec4195fe86ff0f" translate="yes" xml:space="preserve">
          <source>What happened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d026aa92cb632a0008d65ec665e66cb82db19d44" translate="yes" xml:space="preserve">
          <source>What is NumPy?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e1fa581e9e916507b4446a529a092d8e86437db" translate="yes" xml:space="preserve">
          <source>What is a masked array?</source>
          <target state="translated">마스크 배열이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9751e6648cb276739f841dae292a17853fcae611" translate="yes" xml:space="preserve">
          <source>What is an array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437c59796bebb67cae1bb453196d12e5dabd418f" translate="yes" xml:space="preserve">
          <source>What is compared are values, not types. So an int (1) and an array of length one can evaluate as True:</source>
          <target state="translated">비교되는 것은 유형이 아니라 값입니다. 따라서 int (1)과 길이가 1 인 배열은 True로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad7f91a8e7927b564b105b1d3081b63dcc31aef" translate="yes" xml:space="preserve">
          <source>What is described below is a recommended workflow with Git.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5bea1d13da31e58211ad4c35c1a02b82b3ae53f" translate="yes" xml:space="preserve">
          <source>What is released</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed5c56f4637ad63b06ae7f91c4fda9c76b610d6b" translate="yes" xml:space="preserve">
          <source>What is tested is whether the input has a non-zero imaginary part, not if the input type is complex.</source>
          <target state="translated">테스트 된 것은 입력 유형이 복잡한 경우가 아니라 입력에 0이 아닌 허수 부분이 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="010a5d0834f679e03164332d6d50425424fc97f8" translate="yes" xml:space="preserve">
          <source>What is the amortization schedule for a 1 year loan of $2500 at 8.24% interest per year compounded monthly?</source>
          <target state="translated">매월 복리로 지급되는 연간 8.24 %의 이자율로 $ 2500의 1 년 대출 상환 일정은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="59aacf2a72313a7cde0de3da40cb764e30627fa7" translate="yes" xml:space="preserve">
          <source>What is the future value after 10 years of saving $100 now, with an additional monthly savings of $100. Assume the interest rate is 5% (annually) compounded monthly?</source>
          <target state="translated">10 년 동안 $ 100를 절약 한 후의 미래 가치는 $ 100의 추가 월간 절약입니다. 이자율이 매월 5 % (연간) 복리라고 가정합니까?</target>
        </trans-unit>
        <trans-unit id="68f86a620521000717f405763a7c2c87aeacd919" translate="yes" xml:space="preserve">
          <source>What is the monthly payment needed to pay off a $200,000 loan in 15 years at an annual interest rate of 7.5%?</source>
          <target state="translated">15 년 동안 연간 7.5 %의 이자율로 20 만 달러의 대출을 상환하는 데 필요한 월별 지불금은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="bd55b3638089456ad2fcd33f8ddb002a9ff2afef" translate="yes" xml:space="preserve">
          <source>What is the present value (e.g., the initial investment) of an investment that needs to total $15692.93 after 10 years of saving $100 every month? Assume the interest rate is 5% (annually) compounded monthly.</source>
          <target state="translated">매월 $ 100를 절약 한 후 10 년 동안 총 $ 15692.93이 필요한 투자의 현재 가치 (예 : 초기 투자)는 얼마입니까? 이자율이 매월 5 % (연간) 복리라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="80bbcabaec75450b003887ef27bbf523c85b5a9f" translate="yes" xml:space="preserve">
          <source>What is the right way to index multi-dimensional arrays? Before you jump to conclusions about the one and true way to index multi-dimensional arrays, it pays to understand why this is a confusing issue. This section will try to explain in detail how numpy indexing works and why we adopt the convention we do for images, and when it may be appropriate to adopt other conventions.</source>
          <target state="translated">다차원 배열을 인덱싱하는 올바른 방법은 무엇입니까? 다차원 배열을 인덱스하는 하나의 진정한 방법에 대한 결론으로 ​​넘어 가기 전에 이것이 왜 혼란스러운 문제인지 이해해야합니다. 이 섹션에서는 numpy 인덱싱 작동 방식과 이미지에 대한 규칙을 채택하는 이유 및 다른 규칙을 채택하는 것이 적절한시기에 대해 자세히 설명하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c8f9b6ad9828683b0bae9bbc812741ce15ef2e1e" translate="yes" xml:space="preserve">
          <source>What makes this work so well is that &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; can contain one or a thousand values. They only need to be the same size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e27b294bbb4cb3c1e3ee88822cc65d21f2416881" translate="yes" xml:space="preserve">
          <source>What results is the construction of a new array where each value of the index array selects one row from the array being indexed and the resultant array has the resulting shape (number of index elements, size of row).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bd771107f7afe976fc592b463f0e0c3505ed432" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New or Different</source>
          <target state="translated">새로운 점 또는 다른 점</target>
        </trans-unit>
        <trans-unit id="2feeca88895960783f7c2e153b1e528ad57119f7" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the difference between a Python list and a NumPy array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f2949fbd884fd2e87977bc6442d7541c249e9bc" translate="yes" xml:space="preserve">
          <source>What’s New or Different</source>
          <target state="translated">새로운 점 또는 다른 점</target>
        </trans-unit>
        <trans-unit id="7c1df74199c25c42832661082d6ca6ac9e56b175" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</source>
          <target state="translated">휠러, DA, E. Rathke 및 R. Weir (Eds.) (2009, 5 월). Office 응용 프로그램 용 Open Document 형식 (OpenDocument) v1.2, Part 2 : 재 계산 된 수식 (OpenFormula) 형식-주석이 달린 버전, 초안 12. 구조화 된 정보 표준 (OASIS)의 발전을위한 조직. 미국 메사추세츠 빌리 카 [ODT 문서]. 이용 가능 : &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ? wg_abbrev = office-formulaOpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="030c83d2119f52206dbf3733046b420a1749a0e1" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</source>
          <target state="translated">휠러, DA, E. Rathke 및 R. Weir (Eds.) (2009, 5 월). Office 응용 프로그램 용 Open Document 형식 (OpenDocument) v1.2, Part 2 : 재 계산 된 수식 (OpenFormula) 형식-주석이 달린 버전, 초안 12. 구조화 된 정보 표준 (OASIS)의 발전을위한 조직. 미국 메사추세츠 빌리 카 [ODT 문서]. 이용 가능 : &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="45e561a630c53e04980638c8d4e86ae0087886be" translate="yes" xml:space="preserve">
          <source>Wheels</source>
          <target state="translated">Wheels</target>
        </trans-unit>
        <trans-unit id="28b30ef805c7fb044e119b47e7ac08078b5b70cf" translate="yes" xml:space="preserve">
          <source>When &amp;lsquo;decimals&amp;rsquo; is negative, it specifies the number of positions to the left of the decimal point. The real and imaginary parts of complex numbers are rounded separately. Nothing is done if the array is not of float type and &amp;lsquo;decimals&amp;rsquo; is greater than or equal to 0.</source>
          <target state="translated">'소수'가 음수이면 소수점 왼쪽의 위치 수를 지정합니다. 복소수의 실수 부와 허수 부는 따로 반올림됩니다. 배열이 부동 유형이 아니고 '소수'가 0보다 크거나 같으면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f209cff1399437b00b7cd0ee8730d177efc65293" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is specified, the typical inner loop construct is as follows.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 가&lt;/a&gt; 지정되면, 전형적인 내부 루프 구조는 다음이다.</target>
        </trans-unit>
        <trans-unit id="e3bd2b595c2ff9c9cbf3b48defe560bc708bb864" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt; 이 호출 될 때</target>
        </trans-unit>
        <trans-unit id="62e74c933581584a63ff5ff51eb96f98ecf99dc0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.masked_array.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d17005044d622bf07127624dd5d1775dbe22cd5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not a valid dtype for a structured array.</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 구조화 된 배열에 대한 유효 DTYPE 아니다.</target>
        </trans-unit>
        <trans-unit id="105e60976ea8fbfb90203db8ab4a0a320369170d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;A = rfft(a)&lt;/code&gt; and fs is the sampling frequency, &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</source>
          <target state="translated">경우 &lt;code&gt;A = rfft(a)&lt;/code&gt; 및 FS 샘플링 주파수이며, &lt;code&gt;A[0]&lt;/code&gt; 에르 미트 대칭으로 인한 진짜 제로 주파수 용어 0 * FS 함유한다.</target>
        </trans-unit>
        <trans-unit id="fb065328be54e2c3569cb5f58bbc8287bcb1fb7d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; is called, the array pointed to by base will be updated with the contents of this array.</source>
          <target state="translated">&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 가 호출 되면 base 가 가리키는 배열이이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6087c2287fac970fe48c994c66e9668908c28aae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a = 1&lt;/code&gt;, the Weibull distribution reduces to the exponential distribution.</source>
          <target state="translated">경우 &lt;code&gt;a = 1&lt;/code&gt; ,와 이블 분포는 지수 분포를 감소시킨다.</target>
        </trans-unit>
        <trans-unit id="3234eec63d682a68b39f821bda537d5249018389" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a 2D array, it is factorized as &lt;code&gt;u @ np.diag(s) @ vh
= (u * s) @ vh&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; are 2D unitary arrays and &lt;code&gt;s&lt;/code&gt; is a 1D array of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s singular values. When &lt;code&gt;a&lt;/code&gt; is higher-dimensional, SVD is applied in stacked mode as explained below.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 2 차원 어레이가로 인수 분해된다 &lt;code&gt;u @ np.diag(s) @ vh = (u * s) @ vh&lt;/code&gt; 여기서 &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;vh&lt;/code&gt; 2D 단일 배열하고 &lt;code&gt;s&lt;/code&gt; 의 1 차원 배열 의 특이 값 . &lt;code&gt;a&lt;/code&gt; 가 더 높은 차원 일 때 , SVD는 아래 설명 된 바와 같이 스택 모드로 적용됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40bcbe29998f385e3a1059191be0f61338a8c763" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a structured array, this argument specifies which fields to compare first, second, and so on. This list does not need to include all of the fields.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 구조적 배열 필드 인수 지정이 먼저 제 등과 비교한다. 이 목록은 모든 필드를 포함 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c171b92b4bddf9c8ebd2e75ee317f0b5fe3e94eb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드이 인수 지정 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수 있으며, 모든 필드가 지정 될 필요는 없지만, 불특정 필드 여전히에서 사용될 관계를 깨기 위해 dtype에 나타나는 순서.</target>
        </trans-unit>
        <trans-unit id="78f75090c501ced3a2b9ede8c30345a037a7c202" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드이 인수 지정 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수 있으며, 모든 필드가 지정되어야하지만, 불특정 필드가 여전히 사용될 것이다 관계를 깨기 위해 dtype에 나타나는 순서.</target>
        </trans-unit>
        <trans-unit id="2cd3e98c67109375f859806b9beef061a4ef694a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string. Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드 인수 지정이 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수있다. 모든 필드를 지정할 필요는 없지만 지정되지 않은 필드는 dtype에 나타난 순서대로 계속 사용되어 관계를 끊습니다.</target>
        </trans-unit>
        <trans-unit id="b2ce72a40e12e2d7dda3e8c60930788493a39d27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. Not all fields need be specified.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드 인수 지정이 모든 필드가 지정 될 필요가없는 등의 초 먼저 비교한다.</target>
        </trans-unit>
        <trans-unit id="ffd5f3ded394e20ded56e4169ae0a349c97ccd8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;arange&lt;/code&gt; is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function &lt;code&gt;linspace&lt;/code&gt; that receives as an argument the number of elements that we want, instead of the step:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9212747ec3985b5dbc30be906a85b9cd4a58814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axes&lt;/code&gt; is integer_like, the sequence for evaluation will be: first the -Nth axis in &lt;code&gt;a&lt;/code&gt; and 0th axis in &lt;code&gt;b&lt;/code&gt;, and the -1th axis in &lt;code&gt;a&lt;/code&gt; and Nth axis in &lt;code&gt;b&lt;/code&gt; last.</source>
          <target state="translated">경우 &lt;code&gt;axes&lt;/code&gt; 처음에 -Nth 축 : integer_like이며, 평가 용 시퀀스 것이다 및 0 차의 축 &lt;code&gt;b&lt;/code&gt; 과의 축 -1th 및 제 N은 축에 &lt;code&gt;b&lt;/code&gt; 마지막. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e5c01c245527cc066079729775f892bf5a93e0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axis&lt;/code&gt; is specified, &lt;code&gt;values&lt;/code&gt; must have the correct shape.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 지정되고, &lt;code&gt;values&lt;/code&gt; 올바른 모양을 가지고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="91b3e386bc1245c3b6fdcb369364554e159e0d4a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;callstatement&lt;/code&gt; statement is used then F2PY may not generate proper prototypes for Fortran/C functions (because &lt;code&gt;&amp;lt;C-expr&amp;gt;&lt;/code&gt; may contain any function calls and F2PY has no way to determine what should be the proper prototype). With this statement you can explicitly specify the arguments of the corresponding prototype:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a3f207a74aef7083c1eb02bef5c64216a30b6fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;condition&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt; contain masked values.</source>
          <target state="translated">때 &lt;code&gt;condition&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 는 마스크 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3581744e88f263225956bbed713e5c867c6bf74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;copy=False&lt;/code&gt; and a copy is made for other reasons, the result is the same as if &lt;code&gt;copy=True&lt;/code&gt;, with some exceptions for &lt;code&gt;A&lt;/code&gt;, see the Notes section. The default order is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">때 &lt;code&gt;copy=False&lt;/code&gt; 및 사본이 다른 이유로 만들어진 것처럼, 결과는 동일 &lt;code&gt;copy=True&lt;/code&gt; , 일부의 예외를 제외하고 , 노트 섹션을 참조하십시오. 기본 순서는 'K'입니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ae66e35c85b2fe34abaa8efd6e58beb3b3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 or when an inappropriate &lt;code&gt;size&lt;/code&gt; (e.g. &lt;code&gt;size=-1&lt;/code&gt;) is given.</source>
          <target state="translated">경우 &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 인 경우, 부적절한 &lt;code&gt;size&lt;/code&gt; (예 : &lt;code&gt;size=-1&lt;/code&gt; ) 주어진다.</target>
        </trans-unit>
        <trans-unit id="6647686e555ae4abe6c033723e872acfb1bd3153" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; independent random variables, each with standard normal distributions (mean 0, variance 1), are squared and summed, the resulting distribution is chi-square (see Notes). This distribution is often used in hypothesis testing.</source>
          <target state="translated">경우 &lt;code&gt;df&lt;/code&gt; 표준 정규 분포와 독립된 확률 변수 각 (평균 0, 분산 1)를 제곱하여 합산되며, 결과적인 분포는 (주 참조) 치 정사각형이다. 이 분포는 종종 가설 검정에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef591edbbf8bac21872c8b29394eee7a7391694c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dtype=None&lt;/code&gt;, the type of each column is determined iteratively from its data. We start by checking whether a string can be converted to a boolean (that is, if the string matches &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; in lower cases); then whether it can be converted to an integer, then to a float, then to a complex and eventually to a string. This behavior may be changed by modifying the default mapper of the &lt;code&gt;StringConverter&lt;/code&gt; class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7138161ba09f963f4c9ef09529d5db9dce6e9c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;equal_nan&lt;/code&gt; is True, complex values with nan components are considered equal if either the real &lt;em&gt;or&lt;/em&gt; the imaginary components are nan.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffb0cfba1c0d31cbfd6e3e6d57d32a4b67d07be0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition.</source>
          <target state="translated">때 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; , 값 &lt;code&gt;low&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; , 결과가 공식적으로 정의되지 않은되고 결국 오류가 발생 할 수있다, 즉 불평등 조건을 만족 인수를 통과 할 때 작동하는이 기능에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c038afaac1cec1ca1939f072442e623790bdaa5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition. The &lt;code&gt;high&lt;/code&gt; limit may be included in the returned array of floats due to floating-point rounding in the equation &lt;code&gt;low + (high-low) * random_sample()&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9aa8b45107567c376fa7741eff97cb12f0255ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;normed&lt;/code&gt; is True, then the returned histogram is the sample density, defined such that the sum over bins of the product &lt;code&gt;bin_value * bin_area&lt;/code&gt; is 1.</source>
          <target state="translated">경우 &lt;code&gt;normed&lt;/code&gt; 참이된다 후 리턴 히스토그램은 제품의 빈들을 통해 합되도록 정의 샘플 밀도이다 &lt;code&gt;bin_value * bin_area&lt;/code&gt; 1이다.</target>
        </trans-unit>
        <trans-unit id="d3c1a253c347320a48abee4b8144700cbe11dedb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;op[i]&lt;/code&gt; is NULL, the requested data type &lt;code&gt;op_dtypes[i]&lt;/code&gt; may be NULL as well, in which case it is automatically generated from the dtypes of the arrays which are flagged as readable. The rules for generating the dtype are the same is for UFuncs. Of special note is handling of byte order in the selected dtype. If there is exactly one input, the input&amp;rsquo;s dtype is used as is. Otherwise, if more than one input dtypes are combined together, the output will be in native byte order.</source>
          <target state="translated">경우 &lt;code&gt;op[i]&lt;/code&gt; NULL 인, 요청 된 데이터 타입 &lt;code&gt;op_dtypes[i]&lt;/code&gt; 그것이 자동적으로 판독하는 플래그 배열의 dtypes로부터 발생되는 경우뿐만 아니라 NULL 일 수있다. dtype 생성 규칙은 UFunc의 규칙과 동일합니다. 선택된 dtype에서 바이트 순서를 처리하는 것이 특히 중요합니다. 정확히 하나의 입력이 있으면 입력의 dtype이 그대로 사용됩니다. 그렇지 않으면, 둘 이상의 입력 dtype이 함께 결합되면 출력은 기본 바이트 순서가됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2b29bdbe08a7c3e8ddf1683de5150728b2dbef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;A&amp;rsquo;, it will preserve the array&amp;rsquo;s &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo; ordering:</source>
          <target state="translated">때 &lt;code&gt;order&lt;/code&gt; 'A', 그것은 배열의 'C'또는 'F'순서를 유지한다 :</target>
        </trans-unit>
        <trans-unit id="6b8f346f1161f4e387f8b7fce9c3c4eab735e268" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;K&amp;rsquo;, it will preserve orderings that are neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo;, but won&amp;rsquo;t reverse axes:</source>
          <target state="translated">때 &lt;code&gt;order&lt;/code&gt; 'K', 그것은 어느 쪽도 'C'나 'F'없는 순서 부를 유지하지만 것입니다하지 않습니다 반대 축 :</target>
        </trans-unit>
        <trans-unit id="08a648e9a0d7c320ff7a951bdd5b53abf89293b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p&lt;/code&gt; cannot be converted to a rank-1 array.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 랭크 1 배열로 변환 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="e45ca1a69513367d482121e776e438a0bc2c1c76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;path&lt;/code&gt; is an URL, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; will return True if it&amp;rsquo;s either stored locally in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory, or is a valid remote URL. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; does not discriminate between the two, the file is accessible if it exists in either location.</source>
          <target state="translated">때 &lt;code&gt;path&lt;/code&gt; URL이, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 가 중 하나에 로컬로 저장되어있는 경우 True를 반환합니다 &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리, 또는 유효한 원격 URL입니다. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 는이 둘을 구별하지 않으며, 파일이 어느 위치에 있는지 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d6d2d2a499c808880c721a0e1b19db64d43932" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;seed&lt;/code&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, a new &lt;code&gt;BitGenerator&lt;/code&gt; and &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; will be instantiated each time. This function does not manage a default global instance.</source>
          <target state="translated">시 &lt;code&gt;seed&lt;/code&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 새로운 &lt;code&gt;BitGenerator&lt;/code&gt; 및 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 마다 인스턴스화됩니다. 이 기능은 기본 전역 인스턴스를 관리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11aa8349ecf313cc611177c175cba7ab95aa1209" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;start &amp;lt;= axis&lt;/code&gt;, the axis is rolled back until it lies in this position. When &lt;code&gt;start &amp;gt; axis&lt;/code&gt;, the axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll. The following table describes how negative values of &lt;code&gt;start&lt;/code&gt; are interpreted:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="548ec80d9148e8694deef2af35ec844cd9f8fe80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;writemasked&lt;/code&gt; flag is used, and this operand is buffered, this changes how data is copied from the buffer into the array. A masked copying routine is used, which only copies the elements in the buffer for which &lt;code&gt;writemasked&lt;/code&gt; returns true from the corresponding element in the ARRAYMASK operand.</source>
          <target state="translated">경우 &lt;code&gt;writemasked&lt;/code&gt; 플래그가 사용되며,이 피연산자는, 데이터가 어레이로 상기 버퍼로 복사하는 방법이 변화를 완충한다. ARRAYMASK 피연산자의 해당 요소에서 &lt;code&gt;writemasked&lt;/code&gt; 가 true를 리턴 하는 버퍼의 요소 만 복사하는 마스크 된 복사 루틴이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e06542a52ac6a1f85d560afb9efd573db44bd48f" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, the result order is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;prototype&lt;/em&gt; is a fortran array, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt; otherwise. When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the result order matches that of &lt;em&gt;prototype&lt;/em&gt;, even when the axes of &lt;em&gt;prototype&lt;/em&gt; aren&amp;rsquo;t in C or Fortran order.</source>
          <target state="translated">되면 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 이&lt;/a&gt; 결과 순서는 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;시제품&lt;/em&gt; 포트란 배열이다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; 그렇지. 되면 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 결과 순서가 일치의 &lt;em&gt;원형&lt;/em&gt; 의 축 때에도 &lt;em&gt;프로토 타입&lt;/em&gt; C 또는 포트란 위해서는 아니다.</target>
        </trans-unit>
        <trans-unit id="e7033d51e081041b1a2d922760ea9482eb361bec" translate="yes" xml:space="preserve">
          <source>When F2PY finds a line with F2PY directive, the directive is first replaced by 5 spaces and then the line is reread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad9397f3e6e3e4c72dcb47695405ed9d0b6444eb" translate="yes" xml:space="preserve">
          <source>When NumPy is built, information about system configuration is recorded, and is made available for extension modules using NumPy&amp;rsquo;s C API. These are mostly defined in &lt;code&gt;numpyconfig.h&lt;/code&gt; (included in &lt;code&gt;ndarrayobject.h&lt;/code&gt;). The public symbols are prefixed by &lt;code&gt;NPY_*&lt;/code&gt;. NumPy also offers some functions for querying information about the platform in use.</source>
          <target state="translated">NumPy가 빌드되면 시스템 구성에 대한 정보가 기록되고 NumPy의 C API를 사용하여 확장 모듈에 사용 가능합니다. 이들은 대부분에 정의되어 &lt;code&gt;numpyconfig.h&lt;/code&gt; (에 포함 &lt;code&gt;ndarrayobject.h&lt;/code&gt; ). 퍼블릭 심볼 앞에는 &lt;code&gt;NPY_*&lt;/code&gt; 가 붙습니다 . NumPy는 사용중인 플랫폼에 대한 정보를 쿼리하기위한 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f9eebd0d248f1a6803fb5b3cabe894035e7a712b" translate="yes" xml:space="preserve">
          <source>When True, trailing zeros are removed from the inputs. When False, the inputs are passed through intact.</source>
          <target state="translated">True이면 입력에서 후행 0이 제거됩니다. False이면 입력이 그대로 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="97a14729b31bf94d828802c225db2f870571e19a" translate="yes" xml:space="preserve">
          <source>When a &lt;em&gt;casting&lt;/em&gt; error occurs during assignment (for example updating a numerical array using a sequence of strings), the array being assigned to may end up in an unpredictable partially updated state. However, if any other error (such as an out of bounds index) occurs, the array will remain unchanged.</source>
          <target state="translated">할당 중 &lt;em&gt;캐스팅&lt;/em&gt; 오류가 발생 하면 (예 : 문자열 시퀀스를 사용하여 숫자 형 배열 업데이트) 할당 된 배열이 예기치 않은 부분적으로 업데이트 된 상태가 될 수 있습니다. 그러나 범위를 벗어난 인덱스와 같은 다른 오류가 발생하면 배열은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e61114b95ee070856965d70e916fd6711963caa8" translate="yes" xml:space="preserve">
          <source>When a NumPy array, that is Fortran contiguous and has a dtype corresponding to presumed Fortran type, is used as an input array argument, then its C pointer is directly passed to Fortran.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d0060f5095733a108d2028d216426111947fd92" translate="yes" xml:space="preserve">
          <source>When a broadcasting error occurs, the iterator raises an exception which includes the input shapes to help diagnose the problem.</source>
          <target state="translated">브로드 캐스팅 오류가 발생하면 반복자가 문제를 진단하는 데 도움이되는 입력 모양이 포함 된 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="811ec8a0586d1ac674df53f06017026b62d3d8b5" translate="yes" xml:space="preserve">
          <source>When a member of the Code of Conduct committee becomes aware of a clear and severe breach, they will do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb6f21e3a640b767ac7aa4f3739c198a4f93da24" translate="yes" xml:space="preserve">
          <source>When a memmap causes a file to be created or extended beyond its current size in the filesystem, the contents of the new part are unspecified. On systems with POSIX filesystem semantics, the extended part will be filled with zero bytes.</source>
          <target state="translated">memmap으로 인해 파일이 파일 시스템에서 현재 크기 이상으로 작성되거나 확장되면 새 부품의 내용이 지정되지 않습니다. POSIX 파일 시스템 시맨틱이있는 시스템에서 확장 부분은 0 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7aea5877fc6d970c99b779ec7ae2a444e7ff36a4" translate="yes" xml:space="preserve">
          <source>When a parameter can only assume one of a fixed set of values, those values can be listed in braces, with the default appearing first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b87e186d194de6f9d4cd9e098a815eab1dbc5b7" translate="yes" xml:space="preserve">
          <source>When a recording filter is added, matching warnings are stored in the &lt;code&gt;log&lt;/code&gt; attribute as well as in the list returned by &lt;code&gt;record&lt;/code&gt;.</source>
          <target state="translated">기록 필터를 추가하면 일치하는 경고가 &lt;code&gt;log&lt;/code&gt; 속성과 &lt;code&gt;record&lt;/code&gt; 가 반환 한 목록에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3862b7e9fa0724ebb3b8d0fa3f7b6e962081ab4" translate="yes" xml:space="preserve">
          <source>When a report is sent to the committee they will immediately reply to the reporter to confirm receipt. This reply must be sent within 72 hours, and the group should strive to respond much quicker than that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba1de10f5ac1f9d67feabe34568ca76340334549" translate="yes" xml:space="preserve">
          <source>When a ufunc is called, many things must be done. The information collected from these setup operations is stored in a loop-object. This loop object is a C-structure (that could become a Python object but is not initialized as such because it is only used internally). This loop object has the layout needed to be used with PyArray_Broadcast so that the broadcasting can be handled in the same way as it is handled in other sections of code.</source>
          <target state="translated">ufunc가 호출되면 많은 작업을 수행해야합니다. 이러한 설정 작업에서 수집 된 정보는 루프 개체에 저장됩니다. 이 루프 객체는 C 구조입니다 (파이썬 객체가 될 수는 있지만 내부적으로 만 사용되므로 초기화되지는 않습니다). 이 루프 객체는 PyArray_Broadcast와 함께 사용하여 다른 코드 섹션에서 처리되는 것과 같은 방식으로 브로드 캐스트를 처리 할 수있는 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bed1032321553c178be0f4aa76322e048587c74c" translate="yes" xml:space="preserve">
          <source>When a view is desired in as many cases as possible, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; may be preferable.</source>
          <target state="translated">가능한 많은 경우에 관점이 요구되는 경우, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; 이 바람직 할 수있다.</target>
        </trans-unit>
        <trans-unit id="3d973a2064387ee8231885f5fb66b3c4832468fa" translate="yes" xml:space="preserve">
          <source>When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is &lt;code&gt;False&lt;/code&gt;) or the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; (if the corresponding entry of the mask is &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">명명 된 필드가없는 마스킹 된 배열의 단일 항목에 액세스 할 때 출력은 스칼라 (마스크의 해당 항목이 &lt;code&gt;False&lt;/code&gt; 인 경우 )이거나 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 특수 값 ( 마스크 의 해당 항목이 &lt;code&gt;True&lt;/code&gt; 인 경우 )입니다.</target>
        </trans-unit>
        <trans-unit id="06a15d5053f26aa57bf4b46b8d10d7192f9bc439" translate="yes" xml:space="preserve">
          <source>When accessing a slice, the output is a masked array whose &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; attribute is a view of the original data, and whose mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (if there was no invalid entries in the original array) or a view of the corresponding slice of the original mask. The view is required to ensure propagation of any modification of the mask to the original.</source>
          <target state="translated">슬라이스에 액세스 할 때 출력은 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 속성이 원래 데이터의보기이고 마스크가 마스크가 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (원래 배열에 유효하지 않은 항목이없는 경우) 마스크의 해당 배열의 마스크 된 배열입니다. 마스크. 마스크 수정 사항을 원본으로 전파하려면 뷰가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4d92b7829e88a948fb9eb65ffcf73c11643904a9" translate="yes" xml:space="preserve">
          <source>When added within a context, filters are only added inside the context and will be forgotten when the context is exited.</source>
          <target state="translated">컨텍스트 내에서 추가되면 필터는 컨텍스트 내에서만 추가되며 컨텍스트가 종료 될 때 잊혀집니다.</target>
        </trans-unit>
        <trans-unit id="9541e02340938d50efa6e54249172d0ce37841bb" translate="yes" xml:space="preserve">
          <source>When adding the &amp;lsquo;out&amp;rsquo; parameter, we have to explicitly provide those flags, because if someone passes in an array as &amp;lsquo;out&amp;rsquo;, the iterator will default to &amp;lsquo;readonly&amp;rsquo;, and our inner loop would fail. The reason &amp;lsquo;readonly&amp;rsquo; is the default for input arrays is to prevent confusion about unintentionally triggering a reduction operation. If the default were &amp;lsquo;readwrite&amp;rsquo;, any broadcasting operation would also trigger a reduction, a topic which is covered later in this document.</source>
          <target state="translated">'out'매개 변수를 추가 할 때 누군가가 'out'으로 배열을 전달하면 반복자는 기본적으로 'readonly'로 설정되고 내부 루프가 실패하므로 플래그를 명시 적으로 제공해야합니다. '읽기 전용'이 입력 배열의 기본값 인 이유는 의도하지 않게 축소 작업을 트리거하는 것에 대한 혼동을 방지하기위한 것입니다. 기본값이 '읽기'인 경우 모든 브로드 캐스트 작업은이 문서의 뒷부분에서 다루는 주제 인 축소를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="4db060a24fc0c2ce0739cc8fe613a0f3bd607af5" translate="yes" xml:space="preserve">
          <source>When advanced indices are next to each other transposing may be necessary. All necessary transposing is handled by &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; and has to be handled by the caller unless &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; is asked to allocate the result.</source>
          <target state="translated">고급 지수가 나란히 배치되면 조옮김이 필요할 수 있습니다. 필요한 모든 이조에 의해 처리됩니다 &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; 및 않는 호출자에 의해 처리되어야한다 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 이 결과를 할당하도록 요청한다.</target>
        </trans-unit>
        <trans-unit id="d51d0efd85b1005294bf85e6a8973d000ac30965" translate="yes" xml:space="preserve">
          <source>When all weights along axis are zero. See &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt;&lt;code&gt;numpy.ma.average&lt;/code&gt;&lt;/a&gt; for a version robust to this type of error.</source>
          <target state="translated">축을 따라 모든 가중치가 0 일 때. 이 유형의 오류에 강력한 버전 은 &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt; &lt;code&gt;numpy.ma.average&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b89455b8b1550525cbe82d65bea2d7c4ae5a2baa" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f93d8039436724f69d84838e7be89d226d23fc" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">배열 인 경우 각 행은 &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt; 와 같은 D 차원 공간의 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="74f6a2bdb1716e78ebe330a0020c810a9f33a7a2" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d8732b0393645ea59279b9ddb8a309ed548c77" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">array_like 인 경우 각 요소는 단일 좌표의 값 목록입니다 &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt; 예 : histogramgramdd ((X, Y, Z))) .</target>
        </trans-unit>
        <trans-unit id="c37c33974afb82f0204264e74c8f9fe0fca4a425" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="355be91097240a30b4454a31696bf68a0b258227" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">축이 지정되면 축으로 인덱스 된 하위 배열이 정렬됩니다. 이것은 지정된 축을 배열의 첫 번째 차원으로 만든 다음 하위 순서를 C 순서로 병합하여 수행됩니다. 평면화 된 하위 배열은 레이블이 지정된 각 요소를 가진 구조화 된 유형으로 간주되며 다른 1 차원 배열과 동일한 방식으로 처리 할 수있는 구조화 된 유형의 1 차원 배열로 끝납니다. 결과적으로 평탄화 된 하위 배열이 첫 번째 요소로 시작하여 사전 순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6b69f1e4103645c38ed661fd82fe69ef3f4b8546" translate="yes" xml:space="preserve">
          <source>When an ellipsis (&lt;code&gt;...&lt;/code&gt;) is present but has no size (i.e. replaces zero &lt;code&gt;:&lt;/code&gt;) the result will still always be an array. A view if no advanced index is present, otherwise a copy.</source>
          <target state="translated">생략 부호 ( &lt;code&gt;...&lt;/code&gt; )가 있지만 크기가없는 경우 (예 &lt;code&gt;:&lt;/code&gt; 0을 대체하는 경우 ) 결과는 항상 배열입니다. 고급 색인이없는 경우보기, 그렇지 않으면 사본.</target>
        </trans-unit>
        <trans-unit id="a6d6a3b6d360dde7b2d4e12e9485e974a0d7c19d" translate="yes" xml:space="preserve">
          <source>When an extension module is written, compiled, and installed to somewhere in the Python path (sys.path), the code can then be imported into Python as if it were a standard python file. It will contain objects and methods that have been defined and compiled in C code. The basic steps for doing this in Python are well-documented and you can find more information in the documentation for Python itself available online at &lt;a href=&quot;https://www.python.org&quot;&gt;www.python.org&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4c4fe16d2ce5d90f03758ae48eb086b0f73e4f" translate="yes" xml:space="preserve">
          <source>When an input date falls on the weekend or a holiday, &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; first applies a rule to roll the date to a valid business day, then applies the offset. The default rule is &amp;lsquo;raise&amp;rsquo;, which simply raises an exception. The rules most typically used are &amp;lsquo;forward&amp;rsquo; and &amp;lsquo;backward&amp;rsquo;.</source>
          <target state="translated">입력 날짜가 주말 또는 공휴일 인 경우 &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; 은&lt;/a&gt; 먼저 규칙을 적용하여 날짜를 유효한 영업일로 롤링 한 다음 오프셋을 적용합니다. 기본 규칙은 '상승'이며, 이는 단순히 예외를 발생시킵니다. 가장 일반적으로 사용되는 규칙은 '전달'및 '뒤로'입니다.</target>
        </trans-unit>
        <trans-unit id="64e5ff0649d57b71884c5f5309f3367e78576ca8" translate="yes" xml:space="preserve">
          <source>When applied to masked arrays, this function drops the mask information if the &lt;code&gt;to_begin&lt;/code&gt; and/or &lt;code&gt;to_end&lt;/code&gt; parameters are used.</source>
          <target state="translated">마스크 배열에 적용될 때,이 함수는 &lt;code&gt;to_begin&lt;/code&gt; 및 / 또는 &lt;code&gt;to_end&lt;/code&gt; 매개 변수가 사용되는 경우 마스크 정보를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="15d1d9494e1bc6589dcc00277cd9b509332d208c" translate="yes" xml:space="preserve">
          <source>When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d9940340bbe50ab427886c71fa9ffd19149804" translate="yes" xml:space="preserve">
          <source>When assigning to fields which are subarrays, the assigned value will first be broadcast to the shape of the subarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9f55c2f275cd5eebce400c5d632f8721b4b827a" translate="yes" xml:space="preserve">
          <source>When axis is not None, this function does the same thing as &amp;ldquo;fancy&amp;rdquo; indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; is equivalent to &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt;.</source>
          <target state="translated">axis가 None이 아닌 경우,이 함수는 &quot;fancy&quot;인덱싱 (배열을 사용한 어레이 인덱싱)과 동일한 기능을 수행합니다. 그러나 주어진 축을 따라 요소가 필요한 경우 사용하기가 더 쉬울 수 있습니다. &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; 과 같은 호출 은 &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt; :::: indices, ...]와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="98c8d4285d8be1f6c2247d830229aff2863b6c70" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</source>
          <target state="translated">버퍼링이 활성화되면 임시 버퍼의 크기를 제어합니다. 기본값은 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="16e4f331a390aab5d5358796f242e2ca6c555d93" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this allows the size of the inner loop to grow when buffering isn&amp;rsquo;t necessary. This option is best used if you&amp;rsquo;re doing a straight pass through all the data, rather than anything with small cache-friendly arrays of temporary values for each inner loop.</source>
          <target state="translated">버퍼링이 활성화되면 버퍼링이 필요하지 않을 때 내부 루프의 크기가 커질 수 있습니다. 이 옵션은 각 내부 루프에 대해 캐시 친화적 인 임시 값의 작은 배열이 아닌 모든 데이터를 직선 통과하는 경우에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b51f6738b373830fc8b3cc055c675ac17c018d38" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this also switches to a special buffering mode which reduces the loop length as necessary to not trample on values being reduced.</source>
          <target state="translated">버퍼링이 활성화되면 감소되는 값을 짓밟 지 않도록 루프 길이를 줄이는 특수 버퍼링 모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="41819020a24f8ece45999c2f5c36e5cb1be0993f" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this delays allocation of the buffers until &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; or another reset function is called. This flag exists to avoid wasteful copying of buffer data when making multiple copies of a buffered iterator for multi-threaded iteration.</source>
          <target state="translated">버퍼링이 활성화되면 &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt; 또는 다른 재설정 기능이 호출 될 때까지 버퍼 할당이 지연 됩니다. 이 플래그는 다중 스레드 반복을 위해 버퍼 된 반복기의 여러 사본을 작성할 때 버퍼 데이터의 낭비적인 복사를 피하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="4659cc673583a700172b8a1a2788271c0236c929" translate="yes" xml:space="preserve">
          <source>When building Python packages containing Fortran sources, then one can choose different Fortran compilers by using &lt;code&gt;build_ext&lt;/code&gt; command option &lt;code&gt;--fcompiler=&amp;lt;Vendor&amp;gt;&lt;/code&gt;. Here &lt;code&gt;&amp;lt;Vendor&amp;gt;&lt;/code&gt; can be one of the following names:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f21f4d61950661d3a1581fb7fc069996b1dddfdd" translate="yes" xml:space="preserve">
          <source>When building an extension module, a combination of the following macros may be required for non-gcc Fortran compilers:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="230c13e7258bcd1f717539097a4dd43ccf64c97d" translate="yes" xml:space="preserve">
          <source>When calculating the power of an experiment (power = probability of rejecting the null hypothesis when a specific alternative is true) the non-central F statistic becomes important. When the null hypothesis is true, the F statistic follows a central F distribution. When the null hypothesis is not true, then it follows a non-central F statistic.</source>
          <target state="translated">실험의 검정력을 계산할 때 (검정력 = 특정 대안이 참일 때 귀무 가설을 기각 할 확률) 비 중앙 F 통계량이 중요해집니다. 귀무 가설이 참이면 F 통계량은 중심 F 분포를 따릅니다. 귀무 가설이 참이 아닌 경우 중앙이 아닌 F 통계량을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5a88371e6c71e0713242640efaf4aa0aa5e85f64" translate="yes" xml:space="preserve">
          <source>When called from the explicit constructor, &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4c9c09668cb4fc50a86156b0582de19cfc0aea" translate="yes" xml:space="preserve">
          <source>When called from view casting, &lt;code&gt;obj&lt;/code&gt; can be an instance of any subclass of ndarray, including our own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfd9e1642e1e1ff8048cf3528d0f05bb78c463a" translate="yes" xml:space="preserve">
          <source>When called in new-from-template, &lt;code&gt;obj&lt;/code&gt; is another instance of our own subclass, that we might use to update the new &lt;code&gt;self&lt;/code&gt; instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67a93e8e91305afaf6fc0532016e5191c667e052" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt;.</source>
          <target state="translated">제로 d 배열 또는 스칼라에서 호출되면 &lt;code&gt;nonzero(a)&lt;/code&gt; 는 &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="05271cb09f7d75c6bfb61cf24594f89c89131399" translate="yes" xml:space="preserve">
          <source>When called with only scalars, &lt;code&gt;np.block&lt;/code&gt; is equivalent to an ndarray call. So &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; is equivalent to &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt;.</source>
          <target state="translated">스칼라로 호출 할 때, &lt;code&gt;np.block&lt;/code&gt; 는 ndarray 호출하는 것과 동일합니다. 따라서 &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; 은 &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3fc5492e5904c93f3605a33709fbb0c2bb0c5b" translate="yes" xml:space="preserve">
          <source>When casting from complex to float or int. To avoid this, one should use &lt;code&gt;a.real.astype(t)&lt;/code&gt;.</source>
          <target state="translated">complex에서 float 또는 int로 캐스팅 할 때. 이를 피하려면 &lt;code&gt;a.real.astype(t)&lt;/code&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d77d44055e40bb5dab3ddffb7c979aaad7a40365" translate="yes" xml:space="preserve">
          <source>When coding custom algorithms, and sometimes when wrapping existing C libraries, some familiarity with C is required. In particular, when using C memory management (&lt;code&gt;malloc&lt;/code&gt; and friends), it&amp;rsquo;s easy to introduce memory leaks. However, just compiling a Python module renamed to &lt;code&gt;.pyx&lt;/code&gt; can already speed it up, and adding a few type declarations can give dramatic speedups in some code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b0aeecc6c945df228976af6d76ace4f58298a37" translate="yes" xml:space="preserve">
          <source>When considering potential Members, the Council will look at candidates with a comprehensive view of their contributions. This will include but is not limited to code, code review, infrastructure work, mailing list and chat participation, community help/building, education and outreach, design work, etc. We are deliberately not setting arbitrary quantitative metrics (like &amp;ldquo;100 commits in this repo&amp;rdquo;) to avoid encouraging behavior that plays to the metrics rather than the project&amp;rsquo;s overall well-being. We want to encourage a diverse array of backgrounds, viewpoints and talents in our team, which is why we explicitly do not define code as the sole metric on which council membership will be evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3afb0a37a10edd1baec0a1dc8d2095269323f16d" translate="yes" xml:space="preserve">
          <source>When creating a 0-d array from an array scalar use &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; instead of the standard copy from an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">배열 스칼라에서 0-d 배열을 만들 때는 배열 스칼라 의 표준 복사본 대신 &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; 을 사용하십시오. 데이터 유형과 함께 배열 스칼라를 정의하지 않은 경우 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8887c1561ce70af56f037b9ba953356547c232a4" translate="yes" xml:space="preserve">
          <source>When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, that corresponds roughly to the boolean &lt;code&gt;False&lt;/code&gt;. Trying to set an element of &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception, as a boolean does not support item assignment.</source>
          <target state="translated">구조화되지 않은 단순한 데이터 유형으로 새 마스크 배열을 작성할 때 마스크는 초기에 특수 값 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; 로&lt;/a&gt; 설정되며, 이는 부울 &lt;code&gt;False&lt;/code&gt; 와 대략 일치 합니다. 부울은 항목 할당을 지원하지 않으므로 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 요소를 설정하려고 하면 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외 가 발생하여 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="4e6d2af630e30f862a489ba6df45674126eb3cd4" translate="yes" xml:space="preserve">
          <source>When creating an array of datetimes from a string, it is still possible to automatically select the unit from the inputs, by using the datetime type with generic units.</source>
          <target state="translated">문자열에서 날짜 시간 배열을 만들 때 일반 단위와 함께 날짜 시간 유형을 사용하여 입력에서 단위를 자동으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac49ba1355f1db42e6af84f03eb57484c54f1f5d" translate="yes" xml:space="preserve">
          <source>When cross-compiling with numpy distutils, it might be necessary to use modified npy-pkg-config files. Using the default/generated files will link with the host libraries (i.e. libnpymath.a). For cross-compilation you of-course need to link with target libraries, while using the host Python installation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f67c8b0b4f5cc7d1d888ed98b880f842ee42d75" translate="yes" xml:space="preserve">
          <source>When either of the dimensions compared is one, the other is used. In other words, dimensions with size 1 are stretched or &amp;ldquo;copied&amp;rdquo; to match the other.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36a5c7d333e9c484967d9590699c121ae8287b5d" translate="yes" xml:space="preserve">
          <source>When either of the elements is masked, the result is masked as well, but the underlying boolean data are still set, with self and other considered equal if both are masked, and unequal otherwise.</source>
          <target state="translated">요소 중 하나가 마스킹되면 결과도 마스킹되지만 기본 부울 데이터는 여전히 설정되며, 둘 중 하나가 마스킹 된 경우 자체 및 기타가 동일하게 간주되고 그렇지 않으면 동일하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2c15c829ea1146c460c63d87fff55a43784eaa99" translate="yes" xml:space="preserve">
          <source>When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n &amp;lt;=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case.</source>
          <target state="translated">랜덤 표본을 사용하여 모집단에서 비율의 표준 오차를 추정 할 때, 정규 분포는 곱 p * n &amp;lt;= 5 (여기서 p = 모집단 비율 추정치, n = 표본 개수)가 아니면 잘 작동합니다. 이항 분포가 대신 사용됩니다. 예를 들어, 15 명 샘플은 왼손잡이 4 명, 오른 손잡이 11 명을 보여줍니다. 그런 다음 p = 4/15 = 27 %입니다. 0.27 * 15 = 4이므로이 경우 이항 분포를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="09930c9cc0372480cd647d7e9b5ec7bd58cefab8" translate="yes" xml:space="preserve">
          <source>When fewer indices are provided than the number of axes, the missing indices are considered complete slices&lt;code&gt;:&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b79bfc37b770b9a9d472063cecf571e647616c67" translate="yes" xml:space="preserve">
          <source>When fid is a file object, array contents are directly written to the file, bypassing the file object&amp;rsquo;s &lt;code&gt;write&lt;/code&gt; method. As a result, tofile cannot be used with files objects supporting compression (e.g., GzipFile) or file-like objects that do not support &lt;code&gt;fileno()&lt;/code&gt; (e.g., BytesIO).</source>
          <target state="translated">fid가 파일 객체 인 경우 파일 내용의 &lt;code&gt;write&lt;/code&gt; 메서드를 무시하고 배열 내용이 파일에 직접 기록됩니다 . 결과적으로 tofile은 압축을 지원하는 파일 객체 (예 : GzipFile) 또는 &lt;code&gt;fileno()&lt;/code&gt; 지원하지 않는 파일과 같은 객체 (예 : BytesIO) 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="aefa8c4cd90708b249d563eead9370ff301bdaf2" translate="yes" xml:space="preserve">
          <source>When finished:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8650f4614cacd7afc4a45f34e856756be0c8acc" translate="yes" xml:space="preserve">
          <source>When forcing an iteration order, we observed that the external loop option may provide the elements in smaller chunks because the elements can&amp;rsquo;t be visited in the appropriate order with a constant stride. When writing C code, this is generally fine, however in pure Python code this can cause a significant reduction in performance.</source>
          <target state="translated">반복 순서를 강제 할 때, 요소가 일정한 보폭으로 적절한 순서로 방문 될 수 없기 때문에 외부 루프 옵션이 요소를 더 작은 청크로 제공 할 수 있음을 관찰했습니다. C 코드를 작성할 때 일반적으로 문제는 없지만 순수 Python 코드에서는 성능이 크게 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fcc2c9e602ae36838f0ffe9f9889f2373533f4" translate="yes" xml:space="preserve">
          <source>When giving examples, we will use the following conventions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f35ea57e8d85acee84ee1ddb5c53faafa07f0d16" translate="yes" xml:space="preserve">
          <source>When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the &lt;strong&gt;docstring&lt;/strong&gt;. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in &lt;code&gt;help()&lt;/code&gt; function that can help you access this information. This means that nearly any time you need more information, you can use &lt;code&gt;help()&lt;/code&gt; to quickly find the information that you need.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9b252a9e3ddb6a4daaa0819da4dce1d5c66c848" translate="yes" xml:space="preserve">
          <source>When matplotlib is imported in the example, the Example code will be wrapped in &lt;code&gt;matplotlib&amp;rsquo;s Sphinx `plot&lt;/code&gt; directive &amp;lt;&lt;a href=&quot;http://matplotlib.org/sampledoc/extensions.html&quot;&gt;http://matplotlib.org/sampledoc/extensions.html&lt;/a&gt;&amp;gt;`_. When matplotlib is not explicitly imported, &lt;code&gt; plot::&lt;/code&gt; can be used directly if &lt;a href=&quot;https://matplotlib.org/api/sphinxext_plot_directive_api.html#module-matplotlib.sphinxext.plot_directive&quot;&gt;&lt;code&gt;matplotlib.sphinxext.plot_directive&lt;/code&gt;&lt;/a&gt; is loaded as a Sphinx extension in &lt;code&gt;conf.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d35b37d44b28508587e123d157336a91b6e8c01f" translate="yes" xml:space="preserve">
          <source>When multiple arrays are involved in an operation, you may want to use the same broadcasting rules that the math operations (&lt;em&gt;i.e.&lt;/em&gt; the ufuncs) use. This can be done easily using the &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;. This is the object returned from the Python command numpy.broadcast and it is almost as easy to use from C. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIterNew&quot;&gt;&lt;code&gt;PyArray_MultiIterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt; ) is used (with &lt;code&gt;n&lt;/code&gt; input objects in place of &lt;code&gt;...&lt;/code&gt; ). The input objects can be arrays or anything that can be converted into an array. A pointer to a PyArrayMultiIterObject is returned. Broadcasting has already been accomplished which adjusts the iterators so that all that needs to be done to advance to the next element in each array is for PyArray_ITER_NEXT to be called for each of the inputs. This incrementing is automatically performed by &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_NEXT&quot;&gt;&lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt; ) macro (which can handle a multiterator &lt;code&gt;obj&lt;/code&gt; as either a &lt;code&gt;PyArrayMultiObject *&lt;/code&gt; or a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt;). The data from input number &lt;code&gt;i&lt;/code&gt; is available using &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_DATA&quot;&gt;&lt;code&gt;PyArray_MultiIter_DATA&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; ) and the total (broadcasted) size as &lt;code&gt;PyArray_MultiIter_SIZE&lt;/code&gt; ( &lt;code&gt;obj&lt;/code&gt;). An example of using this feature follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f72cd33b97d536492271e1edd9154022c923bc" translate="yes" xml:space="preserve">
          <source>When multiple examples are provided, they should be separated by blank lines. Comments explaining the examples should have blank lines both above and below them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4c339ad493bfce465346e967265bb9c039f51a" translate="yes" xml:space="preserve">
          <source>When one of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; is a scalar and the other is array_like, the function checks that each element of the array_like object is equal to the scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb53e9a562d149565801498a40e0d889c5c04ae" translate="yes" xml:space="preserve">
          <source>When one of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is a scalar and the other is array_like, the function checks that each element of the array_like object is equal to the scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63eda21eb7811aeacc325fcf56f657d21ccc05f4" translate="yes" xml:space="preserve">
          <source>When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are &lt;em&gt;not&lt;/em&gt; preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead.</source>
          <target state="translated">연결할 하나 이상의 배열이 MaskedArray 인 경우이 함수는 ndarray 대신 MaskedArray 객체를 반환하지만 입력 마스크는 유지 &lt;em&gt;되지 않습니다&lt;/em&gt; . MaskedArray가 입력으로 예상되는 경우 대신 마스크 배열 모듈에서 ma.concatenate 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eccfc4e1a7be21e04b2017257495e340f746e64f" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is a shorthand for &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt;. Using &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt; directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되는 경우이 함수는 &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt; 의 약어입니다 . 서브 클래스에서 올바르게 작동하므로 &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 직접 사용 하는 것이 좋습니다. 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8419db09cea322048fba5bff5f136770a8b6713" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되면이 함수는 &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 것과 같습니다 . 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="a83dea336fc44b86e10fe7d04631005f6869d53b" translate="yes" xml:space="preserve">
          <source>When opening the saved &lt;code&gt;.npz&lt;/code&gt; file with &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; a &lt;code&gt;NpzFile&lt;/code&gt; object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the &lt;code&gt;.files&lt;/code&gt; attribute), and for the arrays themselves.</source>
          <target state="translated">저장된 &lt;code&gt;.npz&lt;/code&gt; 파일을 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;NpzFile&lt;/code&gt; 객체가 반환됩니다. 이것은 배열 목록 ( &lt;code&gt;.files&lt;/code&gt; 속성 사용)과 배열 자체에 대해 쿼리 할 수있는 사전과 유사한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="db678ddd8c249ca5b7124cc39a503e60a8883bd8" translate="yes" xml:space="preserve">
          <source>When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db500670e369fb09767346f1ee93c96337acfc4a" translate="yes" xml:space="preserve">
          <source>When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions and works its way forward. Two dimensions are compatible when</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="991db5cc5ea188509eab7bddbbcf6ec194a1d9e5" translate="yes" xml:space="preserve">
          <source>When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26e6b9fa52377f35e02d57b8c33d212f74b50ae3" translate="yes" xml:space="preserve">
          <source>When order is &amp;lsquo;A&amp;rsquo; and &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is an array in neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo; order, and a copy is forced by a change in dtype, then the order of the result is not necessarily &amp;lsquo;C&amp;rsquo; as expected. This is likely a bug.</source>
          <target state="translated">order가 'A'이고 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 가 'C'또는 'F'순서가 아닌 배열이고 dtype의 변경으로 인해 사본이 강제 실행되는 경우 결과 순서가 반드시 'C'인 것은 아닙니다. 이것은 버그 일 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="5be535caa0bb6516144fc1de604b8372d3c9991d" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0))</source>
          <target state="translated">지불 기한 ( '시작'(1) 또는 '종료'(0))</target>
        </trans-unit>
        <trans-unit id="9149bcf3649f5259f262c786b3a7a6478a7a8e0f" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0)). Defaults to {&amp;lsquo;end&amp;rsquo;, 0}.</source>
          <target state="translated">지불 기한 ( '시작'(1) 또는 '종료'(0)). 기본값은 { 'end', 0}입니다.</target>
        </trans-unit>
        <trans-unit id="6642df63420a359718ac20ea567420cbe3b18377" translate="yes" xml:space="preserve">
          <source>When performance is important for manipulating many business dates with one particular choice of weekmask and holidays, there is an object &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; which stores the data necessary in an optimized form.</source>
          <target state="translated">특정 주 마스크 및 휴일 중 하나를 선택하여 많은 비즈니스 날짜를 조작하는 데 성능이 중요한 경우, 필요한 데이터를 최적화 된 형식으로 저장 하는 오브젝트 &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt; &lt;code&gt;busdaycalendar&lt;/code&gt; &lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd00b76d3636aeca15fb36d92b84ae47d7409ff3" translate="yes" xml:space="preserve">
          <source>When positive infinity and negative infinity are present:</source>
          <target state="translated">양의 무한대와 음의 무한대가 존재할 때 :</target>
        </trans-unit>
        <trans-unit id="bfd35400824f4bd78ecd5a9fec6a8610574752f0" translate="yes" xml:space="preserve">
          <source>When referring to an entirely different module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b81236c338b918002d5b76ae218758bcc0c4f094" translate="yes" xml:space="preserve">
          <source>When referring to functions in the same sub-module, no prefix is needed, and the tree is searched upwards for a match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de7c6f732a621082b328f0e10ba6ebce8f1a6e6b" translate="yes" xml:space="preserve">
          <source>When saving dictionaries, the dictionary keys become filenames inside the ZIP archive. Therefore, keys should be valid filenames. E.g., avoid keys that begin with &lt;code&gt;/&lt;/code&gt; or contain &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a563656ae79c2922818f2a82bafe22a75de09b5e" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;madvise&lt;/code&gt; NumPy will typically use hugepages for a performance boost. This behaviour can be modified by setting the environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57212127eb9536990cda5db105b01bdf8367e735" translate="yes" xml:space="preserve">
          <source>When spaces are used as delimiters, or when no delimiter has been given as input, there should not be any missing data between two fields.</source>
          <target state="translated">공백이 분리 문자로 사용되거나 분리 문자가 입력으로 제공되지 않은 경우 두 필드 사이에 누락 된 데이터가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="4370d934ab543968b812927b0ca16a2cbda45f5d" translate="yes" xml:space="preserve">
          <source>When specifying a target using &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, or &lt;code&gt;--python&lt;/code&gt;, additional arguments may be forwarded to the target embedded by &lt;code&gt;runtests.py&lt;/code&gt; by passing the extra arguments after a bare &lt;code&gt;--&lt;/code&gt;. For example, to run a test method with the &lt;code&gt;--pdb&lt;/code&gt; flag forwarded to the target, run the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5db3a5e4bce528f298ed2c8c86e1143611c165" translate="yes" xml:space="preserve">
          <source>When storing a multi-byte value in memory as a sequence of bytes, the sequence addresses/sends/stores the least significant byte first (lowest address) and the most significant byte last (highest address). Common in x86 processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea57d2031842d794e355da55aa4d649b5ca424d5" translate="yes" xml:space="preserve">
          <source>When storing a multi-byte value in memory as a sequence of bytes, the sequence addresses/sends/stores the most significant byte first (lowest address) and the least significant byte last (highest address). Common in micro-processors and used for transmission of data over network protocols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c6d6090a315dc06167791d55632ca0e61a0eb7f" translate="yes" xml:space="preserve">
          <source>When studying hypothesis tests that assume normality, seeing how the tests perform on data from a Cauchy distribution is a good indicator of their sensitivity to a heavy-tailed distribution, since the Cauchy looks very much like a Gaussian distribution, but with heavier tails.</source>
          <target state="translated">정규성을 가정하는 가설 검정을 연구 할 때 Cauchy 분포가 가우시안 분포와 매우 유사하지만 꼬리가 무거 우기 때문에 Cauchy 분포의 데이터에서 검정이 어떻게 수행되는지는 꼬리 꼬리 분포에 대한 민감도를 나타내는 좋은 지표입니다.</target>
        </trans-unit>
        <trans-unit id="4d6b9c752dcf618e14ab373ad09afb2c5aaf1513" translate="yes" xml:space="preserve">
          <source>When sub-classing &lt;code&gt;ndarray&lt;/code&gt; or creating duck-types that mimic the &lt;code&gt;ndarray&lt;/code&gt; interface, it is your responsibility to decide how aligned your APIs will be with those of numpy. For convenience, many numpy functions that have a corresponding &lt;code&gt;ndarray&lt;/code&gt; method (e.g., &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt;, &lt;code&gt;reshape&lt;/code&gt;) work by checking if the first argument to a function has a method of the same name. If it exists, the method is called instead of coercing the arguments to a numpy array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83471109ed39b7eca8654b0b5b56f710df2f0ed6" translate="yes" xml:space="preserve">
          <source>When success (0 return value) is returned, either out_arr is filled with a non-NULL PyArrayObject and the rest of the parameters are untouched, or out_arr is filled with NULL, and the rest of the parameters are filled.</source>
          <target state="translated">성공 (0 반환 값)이 반환되면 out_arr은 NULL이 아닌 PyArrayObject로 채워지고 나머지 매개 변수는 변경되지 않거나 out_arr은 NULL로 채워지고 나머지 매개 변수는 채워집니다.</target>
        </trans-unit>
        <trans-unit id="c5848cbfcc751d6fb624a1cce409c076b5cc5302" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;external_loop&amp;rdquo; was not used during construction, but is desired, this modifies the iterator to behave as if the flag was specified.</source>
          <target state="translated">&quot;external_loop&quot;가 구성 중에 사용되지 않았지만 원하는 경우 플래그가 지정된 것처럼 반복자가 동작하도록 수정합니다.</target>
        </trans-unit>
        <trans-unit id="a1da80e9817b29febb418ac2727dd8feb1e9ca57" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;multi_index&amp;rdquo; flag was specified, this removes it, allowing the internal iteration structure to be optimized further.</source>
          <target state="translated">&quot;multi_index&quot;플래그가 지정되면이를 제거하여 내부 반복 구조를 추가로 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea45d329df78eba717c22414db760106850fd424" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is specified an array of appropriate size is returned.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 키워드가 지정되어 적당한 크기의 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="3fdd0f5189c6dc8a23dfca9586f442b975510baf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is used an array is returned.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 키워드가 사용되는 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="53c50ce51f38684cf2835cdea8b4002b8bbf92a8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;c_index&lt;/code&gt; or &lt;code&gt;f_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed and &lt;code&gt;has_index&lt;/code&gt; is False.</source>
          <target state="translated">때 &lt;code&gt;c_index&lt;/code&gt; 또는 &lt;code&gt;f_index&lt;/code&gt; 플래그가 사용 된 경우이 속성은 인덱스에 대한 액세스를 제공합니다. 액세스하고 &lt;code&gt;has_index&lt;/code&gt; 가 False 이면 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="76706b5098ca6b382b941c090b506c3f0587d432" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;multi_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed accessed and &lt;code&gt;has_multi_index&lt;/code&gt; is False.</source>
          <target state="translated">때 &lt;code&gt;multi_index&lt;/code&gt; 의 플래그가 사용 된 경우이 속성은 인덱스에 대한 액세스를 제공합니다. 액세스하고 &lt;code&gt;has_multi_index&lt;/code&gt; 가 False 이면 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ac5d59cc3a2303eaecb29429bf707b0c3c3bedde" translate="yes" xml:space="preserve">
          <source>When the DFT is computed for purely real input, the output is Hermitian-symmetric, i.e. the negative frequency terms are just the complex conjugates of the corresponding positive-frequency terms, and the negative-frequency terms are therefore redundant. This function does not compute the negative frequency terms, and the length of the transformed axis of the output is therefore &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">순수 실제 입력에 대해 DFT를 계산할 때 출력은 허미 시안 대칭입니다. 즉, 음의 주파수 항은 해당 양의 주파수 항의 복소수 복소수이므로 음의 주파수 항은 중복됩니다. 이 함수는 음의 주파수 항을 계산하지 않으므로 출력의 변환 된 축 길이는 &lt;code&gt;n//2 + 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b75d1885e8ca13361f9bec6a445a1ba51b9a5271" translate="yes" xml:space="preserve">
          <source>When the committee (or a committee member) receives a report, they will first determine whether the report is about a clear and severe breach (as defined below). If so, immediate action needs to be taken in addition to the regular report handling process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3d4a45bb9288ccb26e83539df4a7489dddcf142" translate="yes" xml:space="preserve">
          <source>When the data type of &lt;code&gt;a&lt;/code&gt; is longdouble or clongdouble, item() returns a scalar array object because there is no available Python scalar that would not lose information. Void arrays return a buffer object for item(), unless fields are defined, in which case a tuple is returned.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 데이터 유형 이 longdouble 또는 clongdouble 인 경우 item ()은 정보를 잃지 않는 사용 가능한 Python 스칼라가 없으므로 스칼라 배열 객체를 반환합니다. 무효 배열은 필드가 정의되어 있지 않으면 튜플이 반환되지 않는 한 item ()에 대한 버퍼 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d7c5ae7d2e5fed7aeaee002bc1ee17b1c24ba0a" translate="yes" xml:space="preserve">
          <source>When the dimension of the vector(s) in &lt;code&gt;a&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt; does not equal 2 or 3.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 및 / 또는 &lt;code&gt;b&lt;/code&gt; 의 벡터 치수가 2 또는 3이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="dd1fba0c6bb426cf1f952081182426781d82c79b" translate="yes" xml:space="preserve">
          <source>When the error handling for a floating-point error (one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, or &amp;ldquo;invalid&amp;rdquo;) is set to &amp;lsquo;call&amp;rsquo; or &amp;lsquo;log&amp;rsquo;, the function that is called or the log instance that is written to is returned by &lt;a href=&quot;#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;. This function or log instance has been set with &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 오류 ( &quot;divide&quot;, &quot;over&quot;, &quot;under&quot;또는 &quot;invalid&quot;중 하나)에 대한 오류 처리가 호출 된 함수 또는 로그 인스턴스 인 'call'또는 'log'로 설정된 경우 작성된 것은 &lt;a href=&quot;#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; 에&lt;/a&gt; 의해 리턴됩니다 . 이 함수 또는 로그 인스턴스는 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3a105e739e37e79639871fe00f74a7608f41e18f" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is used, the code needs to know the parameters for doing the inner loop. These functions provide that information.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 플래그 가 사용될 때 코드는 내부 루프를 수행하기위한 매개 변수를 알아야합니다. 이러한 기능은 해당 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3b33dbd60831369f7fef62a2b038dc2ad278fa8" translate="yes" xml:space="preserve">
          <source>When the flags attribute is retrieved from Python, a special builtin object of this type is constructed. This special type makes it easier to work with the different flags by accessing them as attributes or by accessing them as if the object were a dictionary with the flag names as entries.</source>
          <target state="translated">flags 속성이 Python에서 검색되면이 유형의 특수 내장 객체가 생성됩니다. 이 특수 유형을 사용하면 다른 플래그를 속성으로 액세스하거나 오브젝트가 플래그 이름을 항목으로 사용하는 사전 인 것처럼 액세스하여 다른 플래그로 작업하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6997b127e257f2d9de0f0028a03e8903521c7172" translate="yes" xml:space="preserve">
          <source>When the index consists of as many integer arrays as the array being indexed has dimensions, the indexing is straight forward, but different from slicing.</source>
          <target state="translated">인덱스가 생성되는 배열의 크기만큼 인덱스가 정수 배열로 구성된 경우 인덱스는 간단하지만 슬라이싱과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="74a8e0eaba5b1fd886e8897754dffe2e69872867" translate="yes" xml:space="preserve">
          <source>When the indexed array &lt;code&gt;a&lt;/code&gt; is multidimensional, a single array of indices refers to the first dimension of &lt;code&gt;a&lt;/code&gt;. The following example shows this behavior by converting an image of labels into a color image using a palette.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3539c51a85d030896869c59fab4a3546a18e92e" translate="yes" xml:space="preserve">
          <source>When the input &lt;code&gt;a&lt;/code&gt; is a time-domain signal and &lt;code&gt;A = fft(a)&lt;/code&gt;, &lt;code&gt;np.abs(A)&lt;/code&gt; is its amplitude spectrum and &lt;code&gt;np.abs(A)**2&lt;/code&gt; is its power spectrum. The phase spectrum is obtained by &lt;code&gt;np.angle(A)&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;a&lt;/code&gt; 가 시간 영역 신호이고 &lt;code&gt;A = fft(a)&lt;/code&gt; 경우 &lt;code&gt;np.abs(A)&lt;/code&gt; 는 진폭 스펙트럼이고 &lt;code&gt;np.abs(A)**2&lt;/code&gt; 는 전력 스펙트럼입니다. 위상 스펙트럼은 &lt;code&gt;np.angle(A)&lt;/code&gt; 의해 얻어진다 .</target>
        </trans-unit>
        <trans-unit id="1367f160bbb5fedd65e0cbb76f7f60e11a8156e2" translate="yes" xml:space="preserve">
          <source>When the input and output arrays are aligned and of the correct type, but the striding is not uniform (non-contiguous and 2-D or larger), then a second looping structure is employed for the calculation. This approach converts all of the iterators for the input and output arguments to iterate over all but the largest dimension. The inner loop is then handled by the underlying 1-D computational loop. The outer loop is a standard iterator loop on the converted iterators. The hardware error flags are checked after each 1-D loop is completed.</source>
          <target state="translated">입력 및 출력 배열이 정렬되고 올바른 유형이지만 스 트래 딩이 균일하지 않은 경우 (비 연속 및 2D 이상) 계산에 두 번째 루핑 구조가 사용됩니다. 이 방법은 입력 및 출력 인수에 대한 모든 반복자를 가장 큰 차원을 제외한 모든 반복에서 반복하도록 변환합니다. 그런 다음 내부 루프는 기본 1 차원 계산 루프에 의해 처리됩니다. 외부 루프는 변환 된 반복자의 표준 반복자 루프입니다. 하드웨어 오류 플래그는 각 1D 루프가 완료된 후에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="34e3c1c18b6a533eb7d5554f7595a67b84951780" translate="yes" xml:space="preserve">
          <source>When the input is purely real, its transform is Hermitian, i.e., the component at frequency</source>
          <target state="translated">입력이 순수하게 실제 인 경우, 변환은 에르 미트 (Hermitian), 즉 주파수 성분</target>
        </trans-unit>
        <trans-unit id="52b34b95d5e176ad47f62260446b195804a6cada" translate="yes" xml:space="preserve">
          <source>When the length of 1D &lt;code&gt;weights&lt;/code&gt; is not the same as the shape of &lt;code&gt;a&lt;/code&gt; along axis.</source>
          <target state="translated">1 차원의 길이 때 &lt;code&gt;weights&lt;/code&gt; 의 형태와 동일하지 축을 따라. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1eaf8889fe184a62b6fd5a964889299281ae31" translate="yes" xml:space="preserve">
          <source>When the nested list is two levels deep, this allows block matrices to be constructed from their components.</source>
          <target state="translated">중첩 목록의 깊이가 두 수준 인 경우 구성 요소에서 블록 행렬을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f5bbbcfb6705ce5d9a02195d69308545da2c5f" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">선택적인 키 &lt;em&gt;오프셋&lt;/em&gt; 및 &lt;em&gt;제목&lt;/em&gt; 이 제공되면 해당 값은 각각 &lt;em&gt;이름&lt;/em&gt; 및 &lt;em&gt;형식&lt;/em&gt; 목록 과 동일한 길이의 목록이어야 합니다. &lt;em&gt;옵셋&lt;/em&gt; 값 (한정 바이트 오프셋의 목록 &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; 그동안, 각 필드의) &lt;em&gt;타이틀의&lt;/em&gt; 값은 각 필드를위한 타이틀리스트 (인 &lt;code&gt;None&lt;/code&gt; 어떤 타이틀 해당 필드 소망하지 않으면 사용할 수 없다). &lt;em&gt;제목은&lt;/em&gt; 어떤 수 있습니다 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 개체 및 필드에 다른 항목 제목에 의해 키가 및 추가 튜플 구성원으로 제목을 포함 동일한 필드 튜플을 참조 사전 추가합니다.</target>
        </trans-unit>
        <trans-unit id="fe8737aa96b92cabf0904a91af144d1939eed308" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (None can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c89441828aa0daf46fb0989feeaa96e8f46c4c3" translate="yes" xml:space="preserve">
          <source>When the result of an advanced indexing operation has no elements but an individual index is out of bounds, whether or not an &lt;code&gt;IndexError&lt;/code&gt; is raised is undefined (e.g. &lt;code&gt;x[[], [123]]&lt;/code&gt; with &lt;code&gt;123&lt;/code&gt; being out of bounds).</source>
          <target state="translated">고급 인덱싱 동작의 결과에 요소가 없지만 개별 인덱스가 있는지의 여부, 범위를 벗어나면 &lt;code&gt;IndexError&lt;/code&gt; 상승이 정의된다 (예를 들면 &lt;code&gt;x[[], [123]]&lt;/code&gt; 와 &lt;code&gt;123&lt;/code&gt; 범위 외인 임).</target>
        </trans-unit>
        <trans-unit id="a8285d0cb4c35abac624d1adebd2fa89972bd5bd" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;), there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb9d5c54f477f497096e6733fd299984beb835c4" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;, there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">변수에 이름이 지정되면 (유연한 dtype 또는 &lt;code&gt;names&lt;/code&gt; 포함 ) 파일에 헤더가 없어야합니다 (그렇지 않으면 ValueError 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="545b6ed903baa5a5144eaa7b81c5d5357b7f3721" translate="yes" xml:space="preserve">
          <source>When the wheels have all been successfully built, download them using the &lt;code&gt;wheel-uploader&lt;/code&gt; in the &lt;code&gt;terryfy&lt;/code&gt; repository. The terryfy repository may be cloned from &lt;a href=&quot;https://github.com/MacPython/terryfy&quot;&gt;https://github.com/MacPython/terryfy&lt;/a&gt; if you don&amp;rsquo;t already have it. The wheels can also be uploaded using the &lt;code&gt;wheel-uploader&lt;/code&gt;, but we prefer to download all the wheels to the &lt;code&gt;../numpy/release/installers&lt;/code&gt; directory and upload later using &lt;code&gt;twine&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce6824829e37ca585156c8e8abdeb7e7047b4a6" translate="yes" xml:space="preserve">
          <source>When there is at least one slice (&lt;code&gt;:&lt;/code&gt;), ellipsis (&lt;code&gt;...&lt;/code&gt;) or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; in the index (or the array has more dimensions than there are advanced indexes), then the behaviour can be more complicated. It is like concatenating the indexing result for each advanced index element</source>
          <target state="translated">(가 적어도 하나 개의 조각 인 경우 &lt;code&gt;:&lt;/code&gt; ), 줄임표 ( &lt;code&gt;...&lt;/code&gt; ) 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 인덱스에 (또는 배열이 고급 인덱스가보다 더 많은 차원이), 다음 동작은 더 복잡 할 수 있습니다. 각 고급 색인 요소에 대한 색인 결과를 연결하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7fc05435c156ef19015ca040276948a66576f250" translate="yes" xml:space="preserve">
          <source>When there is more than one axis to sum over - and they are not the last (first) axes of &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) - the argument &lt;code&gt;axes&lt;/code&gt; should consist of two sequences of the same length, with the first axis to sum over given first in both sequences, the second axis second, and so forth.</source>
          <target state="translated">합산 할 축이 두 개 이상이고 축이 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 의 마지막 (첫 번째) 축이 아닌 경우 인수 &lt;code&gt;axes&lt;/code&gt; 동일한 길이의 두 시퀀스로 구성되어야합니다. 두 시퀀스, 두 번째 축 두 번째 등.</target>
        </trans-unit>
        <trans-unit id="aca72761c1059e14a576d5243f55b005214eb5e7" translate="yes" xml:space="preserve">
          <source>When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array. Thus, taking the diagonal as &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; produces a view (changed in version 1.10.0).</source>
          <target state="translated">피연산자가 하나만 있고 축이 합산되지 않고 출력 매개 변수가 제공되지 않으면 새 배열 대신 피연산자에 대한 뷰가 반환됩니다. 따라서 대각선을 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 사용하면 뷰가 생성됩니다 (버전 1.10.0에서 변경됨).</target>
        </trans-unit>
        <trans-unit id="d6560fa9a8a1164ba82db1ff6a46fb84089bde5d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true 인 경우 결과 문자 &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 에는 8 비트 문자 만 false 인 경우 유니 코드 문자가 포함될 수 있습니다. 유니 코드가 &lt;code&gt;None&lt;/code&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="65b8be94d25ee5071fb62b957f74c26a7a160de6" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a283e044d3ebfd4430bd993011e5610365921585" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true 인 경우 결과 문자 &lt;code&gt;chararray&lt;/code&gt; 에는 8 비트 문자 만 false 인 경우 유니 코드 문자가 포함될 수 있습니다. 유니 코드가 &lt;code&gt;None&lt;/code&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="f2245dda0193d47132d217a15baacd8d95efb40d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d546b1cbadc8d553f3a2c608a6a9f37844d1cc07" translate="yes" xml:space="preserve">
          <source>When two or more input parameters have exactly the same type, shape and description, they can be combined:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec3e52986ad6366d7a0f302f7264cd3302d4a4d7" translate="yes" xml:space="preserve">
          <source>When used as a command line tool, &lt;code&gt;f2py&lt;/code&gt; has three major modes, distinguished by the usage of &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-h&lt;/code&gt; switches:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2f6bc6ae79777087ef9f135d7de551097f22c0d" translate="yes" xml:space="preserve">
          <source>When used inside &lt;code&gt;&amp;lt;routine signature&amp;gt;&lt;/code&gt;, then given C code will be inserted to the corresponding wrapper function just after declaring variables but before any C statements. So, &lt;code&gt;usercode&lt;/code&gt; follow-up can contain both declarations and C statements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="596f3568b1167a9a713a0235333d3a0c34a92814" translate="yes" xml:space="preserve">
          <source>When used inside &lt;code&gt;python module&lt;/code&gt; block, then given C code will be inserted to generated C/API source just before wrapper function definitions. Here you can define arbitrary C functions to be used in initialization of optional arguments, for example. If &lt;code&gt;usercode&lt;/code&gt; is used twice inside &lt;code&gt;python
module&lt;/code&gt; block then the second multiline block is inserted after the definition of external routines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e1b4b5cbc8b59436318942fdcb6ca6f33e723e" translate="yes" xml:space="preserve">
          <source>When used inside the first &lt;code&gt;interface&lt;/code&gt; block, then given C code will be inserted at the end of the initialization function of the extension module. Here you can modify extension modules dictionary. For example, for defining additional variables etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="436bc3d73aa6565d86aefabb54c9292e559b97a5" translate="yes" xml:space="preserve">
          <source>When used interactively with an object, &lt;code&gt;np.info(obj)&lt;/code&gt; is equivalent to &lt;code&gt;help(obj)&lt;/code&gt; on the Python prompt or &lt;code&gt;obj?&lt;/code&gt; on the IPython prompt.</source>
          <target state="translated">객체와 대화식으로 사용할 때 &lt;code&gt;np.info(obj)&lt;/code&gt; 는 Python 프롬프트 또는 &lt;code&gt;obj?&lt;/code&gt; 의 &lt;code&gt;help(obj)&lt;/code&gt; 와 동일 합니까? IPython 프롬프트에서.</target>
        </trans-unit>
        <trans-unit id="59366ede5c94f784128a0963e5498e4128255217" translate="yes" xml:space="preserve">
          <source>When used with arrays as arguments, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are similar to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f0905c43c5dc57dbedbc6c77600c829150dde0" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; in combination with the numpy conventions, you should use the &lt;code&gt;numpydoc&lt;/code&gt; extension so that your docstrings will be handled correctly. For example, Sphinx will extract the &lt;code&gt;Parameters&lt;/code&gt; section from your docstring and convert it into a field list. Using &lt;code&gt;numpydoc&lt;/code&gt; will also avoid the reStructuredText errors produced by plain Sphinx when it encounters numpy docstring conventions like section headers (e.g. &lt;code&gt;-------------&lt;/code&gt;) that sphinx does not expect to find in docstrings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d8af6e4436a72ae5774609dfe31b0219205b6b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;distutils&lt;/code&gt;, for example in &lt;code&gt;setup.py&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8bcdc54785df618c23c01dc97dc1468fe9c49c4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;jumped&lt;/code&gt;, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; as it would overlap with &lt;code&gt;blocked_rng[1]&lt;/code&gt;. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with &lt;code&gt;range(10, 20)&lt;/code&gt;, otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.</source>
          <target state="translated">&lt;code&gt;jumped&lt;/code&gt; 를 사용할 때 이미 사용 된 스트림으로 점프하지 않도록주의해야합니다. 위의 예에서 나중에 &lt;code&gt;blocked_rng[1]&lt;/code&gt; 과 겹치 &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; 나중에 blocking_rng [0] .jumped () 를 사용할 수 없습니다 . 독립 스트림과 마찬가지로 여기서 주요 프로세스가 점프하여 10 개 이상의 스트림을 분리하려면 &lt;code&gt;range(10, 20)&lt;/code&gt; 로 시작해야합니다 . 그렇지 않으면 동일한 스트림을 다시 생성합니다. 반면에 스트림을 신중하게 구성하면 겹치지 않는 스트림이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="724bc629cdbfec6a4e5af9a220d38930424c297d" translate="yes" xml:space="preserve">
          <source>When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt;&lt;code&gt;numpy.linspace&lt;/code&gt;&lt;/a&gt; for these cases.</source>
          <target state="translated">정수가 아닌 단계 (예 : 0.1)를 사용하는 경우 결과가 종종 일치하지 않습니다. 이 경우 &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt; &lt;code&gt;numpy.linspace&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27718ed960a95a721b47ff1931021ed4073bbe48" translate="yes" xml:space="preserve">
          <source>When using a string for &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; it is possible to get multiple results.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 문자열을 사용 하면 여러 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4483d4c2e345ca8073aa1a9817270cc3cdb40e82" translate="yes" xml:space="preserve">
          <source>When using a subclass (especially one which manipulates its shape), the default &lt;code&gt;ndarray.__setitem__&lt;/code&gt; behaviour will call &lt;code&gt;__getitem__&lt;/code&gt; for &lt;em&gt;basic&lt;/em&gt; indexing but not for &lt;em&gt;advanced&lt;/em&gt; indexing. For such a subclass it may be preferable to call &lt;code&gt;ndarray.__setitem__&lt;/code&gt; with a &lt;em&gt;base class&lt;/em&gt; ndarray view on the data. This &lt;em&gt;must&lt;/em&gt; be done if the subclasses &lt;code&gt;__getitem__&lt;/code&gt; does not return views.</source>
          <target state="translated">서브 클래스 (특히 모양을 조작하는 서브 클래스)를 사용하는 경우 기본 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 비헤이비어는 &lt;em&gt;기본&lt;/em&gt; 인덱싱에 대해서는 &lt;code&gt;__getitem__&lt;/code&gt; 을 호출 하지만 &lt;em&gt;고급&lt;/em&gt; 인덱싱 에는 사용하지 않습니다 . 이러한 서브 클래스의 경우 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 을 호출하는 것이 좋습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; , 데이터에&lt;em&gt; 기본 클래스&lt;/em&gt; ndarray보기로 . 이 &lt;em&gt;있어야&lt;/em&gt; 하위 클래스 경우 수행 할 수 &lt;code&gt;__getitem__&lt;/code&gt; 뷰를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc311b69f41b3e0c41508f3b081d2280ad7970ec" translate="yes" xml:space="preserve">
          <source>When using broadcasting with uint64 dtypes, the maximum value (2**64) cannot be represented as a standard integer type. The high array (or low if high is None) must have object dtype, e.g., array([2**64]).</source>
          <target state="translated">uint64 dtype으로 브로드 캐스트를 사용하는 경우 최대 값 (2 ** 64)을 표준 정수 유형으로 나타낼 수 없습니다. 상위 배열 (또는 상위가 없음 인 경우 하위)에는 배열 ([2 ** 64])과 같은 개체 dtype이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="23e3eec66bc7d3437b52c086371fd6ea153ed9c6" translate="yes" xml:space="preserve">
          <source>When using pytest as a target (the default), you can &lt;a href=&quot;https://docs.pytest.org/en/latest/usage.html#specifying-tests-selecting-tests&quot;&gt;match test names using python operators&lt;/a&gt; by passing the &lt;code&gt;-k&lt;/code&gt; argument to pytest:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c04978427f46ec116ad24550bbf1c67bfbb16f61" translate="yes" xml:space="preserve">
          <source>When using signed integer types the result is the two&amp;rsquo;s complement of the result for the unsigned type:</source>
          <target state="translated">부호있는 정수 유형을 사용할 때 결과는 부호없는 유형에 대한 결과의 2의 보수입니다.</target>
        </trans-unit>
        <trans-unit id="453da0e9bd45f20742c660821d0bef0203dd876c" translate="yes" xml:space="preserve">
          <source>When using the first form of dictionary-based specification, the titles may be supplied as an extra &lt;code&gt;'titles'&lt;/code&gt; key as described above. When using the second (discouraged) dictionary-based specification, the title can be supplied by providing a 3-element tuple &lt;code&gt;(datatype, offset, title)&lt;/code&gt; instead of the usual 2-element tuple:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fefd781e401a9acf4994aa658770a54631a31aac" translate="yes" xml:space="preserve">
          <source>When using the iterator in multi-threaded code or in code not holding the Python GIL, care must be taken to only call functions which are safe in that context. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt;&lt;code&gt;NpyIter_Copy&lt;/code&gt;&lt;/a&gt; cannot be safely called without the Python GIL, because it increments Python references. The &lt;code&gt;Reset*&lt;/code&gt; and some other functions may be safely called by passing in the &lt;code&gt;errmsg&lt;/code&gt; parameter as non-NULL, so that the functions will pass back errors through it instead of setting a Python exception.</source>
          <target state="translated">다중 스레드 코드 또는 Python GIL을 포함하지 않는 코드에서 반복자를 사용할 때는 해당 컨텍스트에서 안전한 함수 만 호출하도록주의해야합니다. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt; &lt;code&gt;NpyIter_Copy&lt;/code&gt; &lt;/a&gt; 는 Python 참조를 증가시키기 때문에 Python GIL없이 안전하게 호출 할 수 없습니다. &lt;code&gt;Reset*&lt;/code&gt; 및 다른 기능은 안전하게 전달하여 호출 할 수 있습니다 &lt;code&gt;errmsg&lt;/code&gt; 기능이 파이썬 예외를 설정하는 대신 그것을 통해 오류를 다시 전달합니다 그래서, 비 NULL과 같은 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="88e2c9415b727957007e5109caacd82ffe84043d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;C('hello')&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method gets its own class as first argument, and the passed argument, which is the string &lt;code&gt;'hello'&lt;/code&gt;. After python calls &lt;code&gt;__new__&lt;/code&gt;, it usually (see below) calls our &lt;code&gt;__init__&lt;/code&gt; method, with the output of &lt;code&gt;__new__&lt;/code&gt; as the first argument (now a class instance), and the passed arguments following.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80e0c3e3144afbdbfb1503b2b31fd233cbb9bcb1" translate="yes" xml:space="preserve">
          <source>When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we don&amp;rsquo;t.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e0e93c50be29a8db34812f3b063181378aab17d0" translate="yes" xml:space="preserve">
          <source>When working along a given axis, a slice along that axis is returned in &lt;code&gt;output&lt;/code&gt; for each index where &lt;code&gt;condition&lt;/code&gt; evaluates to True. When working on a 1-D array, &lt;a href=&quot;#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 축을 따라 작업 할 때 해당 축을 따라 슬라이스 가 &lt;code&gt;condition&lt;/code&gt; 이 True로 평가 되는 각 인덱스에 대해 &lt;code&gt;output&lt;/code&gt; 으로 반환됩니다 . 1 차원 배열에서 작업 할 때 &lt;a href=&quot;#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7d7c565731670a0f048fc0a67ffb9fb36e062b00" translate="yes" xml:space="preserve">
          <source>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt;, mandating a few conventions so that it is possible to do this.</source>
          <target state="translated">struct dtype과 같은 다른 dtype으로 구성된 더 복잡한 dtype으로 작업 할 때 dtype을 조작하는 내부 루프를 만들려면 추가 데이터가 필요합니다. NumPy는 struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; 를 통해이&lt;/a&gt; 아이디어를 지원하며 ,이를 수행 할 수 있도록 몇 가지 규칙을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="dccc69e8b88626650c84c98fbaee8d5823372b3a" translate="yes" xml:space="preserve">
          <source>When working with very large arrays on modern Linux kernels, you can experience a significant speedup when &lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html&quot;&gt;transparent hugepage&lt;/a&gt; is used. The current system policy for transparent hugepages can be seen by:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37deec6852814cd475cf2ac8609e4771e7e23ff2" translate="yes" xml:space="preserve">
          <source>When you break a long expression at a binary operator, the operator goes at the end of the previous line, e.g.,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e44c90082df7337355379f5ec7bbacbbcd47fdf0" translate="yes" xml:space="preserve">
          <source>When you edit dependence relations that were initially generated by F2PY, be careful not to break the dependence relations of other relevant variables. Another thing to watch out is cyclic dependencies. F2PY is able to detect cyclic dependencies when constructing wrappers and it complains if any are found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="656c7a0b5e4bb86f29ff26d5f3ecacd14ae91bd4" translate="yes" xml:space="preserve">
          <source>When you feel your work is finished, you can create a pull request (PR). Github has a nice help page that outlines the process for &lt;a href=&quot;https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request&quot;&gt;filing pull requests&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57465a3d673d3ee14218ee57f56504a3d7049d2f" translate="yes" xml:space="preserve">
          <source>When you have a set of &amp;ldquo;ready&amp;rdquo; changes in a feature branch ready for NumPy&amp;rsquo;s &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;maintenance&lt;/code&gt; branches, you can push them to &lt;code&gt;upstream&lt;/code&gt; as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df9284875f70d664e11ddef3155365522e76bf5c" translate="yes" xml:space="preserve">
          <source>When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff118b2f38b6fa40b704c3319ca967dd7a981fb4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flatten&lt;/code&gt;, changes to your new array won&amp;rsquo;t change the parent array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa9ed3a1aa18ac3b534d99cdc2037422344dc84" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;%apply&lt;/code&gt; directive, as is usually necessary to use &lt;code&gt;numpy.i&lt;/code&gt;, it will remain in effect until you tell &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; that it shouldn&amp;rsquo;t be. If the arguments to the functions or methods that you are wrapping have common names, such as &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt;, these typemaps may get applied in situations you do not expect or want. Therefore, it is always a good idea to add a &lt;code&gt;%clear&lt;/code&gt; directive after you are done with a specific typemap:</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;%apply&lt;/code&gt; 등의 사용에 일반적으로 필요하다, 지시 &lt;code&gt;numpy.i&lt;/code&gt; 당신이 말할 때까지 효력이 유지됩니다 &lt;a href=&quot;http://www.swig.org&quot;&gt;꿀꺽 꿀꺽를&lt;/a&gt; 가되어서는 안된다는. 줄 바꿈하는 함수 또는 메소드에 대한 인수에 &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;vector&lt;/code&gt; 와 같은 공통 이름 이있는 경우 이러한 유형 맵은 예상하지 않거나 원하지 않는 상황에 적용될 수 있습니다. 따라서 특정 유형 맵을 사용한 후에 는 &lt;code&gt;%clear&lt;/code&gt; 지시문 을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c9161d14b7fe0e0123346d805be6e656205c9a99" translate="yes" xml:space="preserve">
          <source>When you want to discard all changes and go back to the last commit in the repo, use one of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89f82c7a5bbe0891c1df2aa46cbdf990d1794aa1" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; != PyArray_GetNDArrayCVersion, the extension has to be recompiled (ABI incompatibility).</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; ! = PyArray_GetNDArrayCVersion 일 때마다 확장을 다시 컴파일해야합니다 (ABI 비 호환성).</target>
        </trans-unit>
        <trans-unit id="3e2b99bc93c54f0bc24f4acf841fece1023b07a0" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, it also changes the name of the variable holding the C-API, which defaults to &lt;code&gt;PyArray_API&lt;/code&gt;, to whatever the macro is #defined to.</source>
          <target state="translated">&lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 때마다 이 C-API를 보유한 변수의 이름도 변경됩니다 (기본값은 &lt;code&gt;PyArray_API&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="934b37ef17a0c4c0c83c595fef5a62578238ee15" translate="yes" xml:space="preserve">
          <source>Whenever a data-type is required in a NumPy function or method, either a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or something that can be converted to one can be supplied. Such conversions are done by the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor:</source>
          <target state="translated">NumPy 함수 또는 메소드에서 데이터 유형이 필요할 때마다 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 오브젝트 또는 변환 할 수있는 것을 제공 할 수 있습니다. 이러한 변환은 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다. 생성자에 .</target>
        </trans-unit>
        <trans-unit id="80254bc9efba4102e15f18db7d8295d8697a0360" translate="yes" xml:space="preserve">
          <source>Whenever a writeable operand has fewer elements than the full iteration space, that operand is undergoing a reduction. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object requires that any reduction operand be flagged as read-write, and only allows reductions when &amp;lsquo;reduce_ok&amp;rsquo; is provided as an iterator flag.</source>
          <target state="translated">쓰기 가능한 피연산자가 전체 반복 공간보다 적은 수의 요소를 가질 때마다 해당 피연산자는 축소됩니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 목적은 'reduce_ok'는 반복자 플래그로서 제공되는 경우, 감소 연산만을 판독 - 기록으로 플래그 될가 감소를 허용해야.</target>
        </trans-unit>
        <trans-unit id="090346f0957607fc5beeda4f38e177d1918c4444" translate="yes" xml:space="preserve">
          <source>Where True, yield &lt;code&gt;x&lt;/code&gt;, otherwise yield &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">True이면 &lt;code&gt;x&lt;/code&gt; 를 산출 하고 그렇지 않으면 yield &lt;code&gt;y&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="6a5eb067bd3fe81e1af9c383f00cfc0ba136e903" translate="yes" xml:space="preserve">
          <source>Where people expect that the 1st location will be incremented by 3. In fact, it will only be incremented by 1. The reason is because a new array is extracted from the original (as a temporary) containing the values at 1, 1, 3, 1, then the value 1 is added to the temporary, and then the temporary is assigned back to the original array. Thus the value of the array at x[1]+1 is assigned to x[1] three times, rather than being incremented 3 times.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34d448bd986c4660db094fa15ea808d4305175ff" translate="yes" xml:space="preserve">
          <source>Where references like [1] appear in a tables within a numpydoc docstring, the table markup will be broken by numpydoc processing. See &lt;a href=&quot;https://github.com/numpy/numpydoc/issues/130&quot;&gt;numpydoc issue #130&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58703967453c474e94cf57585adb3b2a50448ed" translate="yes" xml:space="preserve">
          <source>Where the library can be found.</source>
          <target state="translated">도서관을 찾을 수있는 곳.</target>
        </trans-unit>
        <trans-unit id="54df46f7307aa74c464486f1ea35cde9a77febe6" translate="yes" xml:space="preserve">
          <source>Where to install the npy-pkg config file, relatively to the current package path.</source>
          <target state="translated">현재 패키지 경로에 상대적으로 npy-pkg 구성 파일을 설치할 위치</target>
        </trans-unit>
        <trans-unit id="93d30f1df70c77ec829a136f4d8b2ef0c3b96d94" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt; or not.</source>
          <target state="translated">&lt;code&gt;arg1&lt;/code&gt; 이 &lt;code&gt;arg2&lt;/code&gt; 의 서브 클래스 인지 여부 여부.</target>
        </trans-unit>
        <trans-unit id="4cf13fb8eefba779715af0f3f14fe972d84fd59d" translate="yes" xml:space="preserve">
          <source>Whether automatically cast the type of the field to the maximum.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ded38313492e3b9340e10eb5e7bd8c5c0bea96c" translate="yes" xml:space="preserve">
          <source>Whether iteration requires access to the Python API, for example if one of the operands is an object array.</source>
          <target state="translated">예를 들어 피연산자 중 하나가 객체 배열 인 경우 반복에 Python API에 대한 액세스가 필요한지 여부</target>
        </trans-unit>
        <trans-unit id="08ba3ba6d86470ddcf5c7c987a831ffff108d8b4" translate="yes" xml:space="preserve">
          <source>Whether masked data are propagated (True) or set to 0 (False) for the computation. Default is False. Propagating the mask means that if a masked value appears in a row or column, the whole row or column is considered masked.</source>
          <target state="translated">계산을 위해 마스크 된 데이터가 전파되는지 (True) 또는 0 (False)으로 설정되는지 여부 기본값은 거짓입니다. 마스크를 전파한다는 것은 마스크 된 값이 행이나 열에 나타나면 전체 행이나 열이 마스크 된 것으로 간주됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="942b421e5894c463ded7c95650a67b6fe3cd084e" translate="yes" xml:space="preserve">
          <source>Whether masked data should be discarded or considered as duplicates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8637ce438fa1d406f7ec1653600c39aad46d9db8" translate="yes" xml:space="preserve">
          <source>Whether masked values in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are considered equal (True) or not (False). They are considered equal by default.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 마스킹 된 값 이 같은지 (True) 또는 아닌지 (False)로 간주 되는지 여부 기본적으로 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6867499c63cb6abaeab85ff30463c9432618d2ee" translate="yes" xml:space="preserve">
          <source>Whether masked values in a or b are considered equal (True) or not (False).</source>
          <target state="translated">a 또는 b의 마스크 된 값이 동일한 것으로 간주되는지 (True) 아닌지 (False).</target>
        </trans-unit>
        <trans-unit id="288daa4940dd3020af5ede621755e8ef6fcd2c3a" translate="yes" xml:space="preserve">
          <source>Whether missing values (if any) should be treated as the largest values (True) or the smallest values (False) When the array contains unmasked values at the same extremes of the datatype, the ordering of these values and the masked values is undefined.</source>
          <target state="translated">결 측값 (있는 경우)을 가장 큰 값 (True) 또는 가장 작은 값 (False)으로 처리해야하는지 여부 배열에 데이터 유형의 동일한 극단에 마스크되지 않은 값이 포함 된 경우 이러한 값과 마스크 된 값의 순서는 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7da3b2e79fc5148bb637715841cccf76fc788e07" translate="yes" xml:space="preserve">
          <source>Whether missing values (if any) should be treated as the largest values (True) or the smallest values (False) When the array contains unmasked values sorting at the same extremes of the datatype, the ordering of these values and the masked values is undefined.</source>
          <target state="translated">결 측값 (있는 경우)을 가장 큰 값 (True) 또는 가장 작은 값 (False)으로 처리해야하는지 여부 배열에 데이터 유형의 동일한 극단에 정렬 된 마스킹되지 않은 값이 포함 된 경우 이러한 값의 순서와 마스킹 된 값은 정의되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a6481db2a658331329f9aef51a26603d0843b05c" translate="yes" xml:space="preserve">
          <source>Whether or not an array is byte-swapped is determined by the data-type of the array. Native byte-order arrays are always requested by &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt;&lt;code&gt;PyArray_FROM_OTF&lt;/code&gt;&lt;/a&gt; and so there is no need for a &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; flag in the requirements argument. There is also no way to get a byte-swapped array from this routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec0eb17948661387af03eedbd16c0982b256d2ca" translate="yes" xml:space="preserve">
          <source>Whether or not there are iterations left.</source>
          <target state="translated">반복이 남아 있는지 여부</target>
        </trans-unit>
        <trans-unit id="6c6ce4cbc91d3e04017743bd327936e59b4be559" translate="yes" xml:space="preserve">
          <source>Whether or not to compute &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; in addition to &lt;code&gt;s&lt;/code&gt;. True by default.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 외에 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;vh&lt;/code&gt; 를 계산할지 여부 입니다. 기본적으로 true입니다.</target>
        </trans-unit>
        <trans-unit id="34608785e0c8e6698e050294c20a41fc581a7a43" translate="yes" xml:space="preserve">
          <source>Whether the array data is Fortran-contiguous or not. Since Fortran-contiguous arrays are a common form of non-C-contiguity, we allow them to be written directly to disk for efficiency.</source>
          <target state="translated">배열 데이터가 연속적인지 여부. 포트란 연속 배열은 비 C 연속성의 일반적인 형태이므로 효율성을 위해 디스크에 직접 기록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7b87db28e0b29fd77663f2df3cc4a859b46d1b1" translate="yes" xml:space="preserve">
          <source>Whether the array is to interpreted as C-order or Fortran-order.</source>
          <target state="translated">배열이 C 순서 또는 포트란 순서로 해석되는지 여부</target>
        </trans-unit>
        <trans-unit id="944c20a06f71d4591f2972a6198b951c5988e169" translate="yes" xml:space="preserve">
          <source>Whether the buffer is read-only</source>
          <target state="translated">버퍼가 읽기 전용인지 여부</target>
        </trans-unit>
        <trans-unit id="4f5043b4a62f84c7d0a89c1a7427fe7e0a42c45d" translate="yes" xml:space="preserve">
          <source>Whether the iteration over the operands is finished or not.</source>
          <target state="translated">피연산자에 대한 반복이 완료되었는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="13a09493df9f77aae557913a37ecafb9bbcd240e" translate="yes" xml:space="preserve">
          <source>Whether the mask is shared between masked arrays can be seen from the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask&quot;&gt;&lt;code&gt;sharedmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;#numpy.ma.MaskedArray.unshare_mask&quot;&gt;&lt;code&gt;unshare_mask&lt;/code&gt;&lt;/a&gt; ensures the mask is not shared. A copy of the mask is only made if it was shared.</source>
          <target state="translated">마스크가 마스크 된 어레이간에 마스크가 공유되는지 여부는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.sharedmask&quot;&gt; &lt;code&gt;sharedmask&lt;/code&gt; &lt;/a&gt; 특성 에서 볼 수 있습니다 . &lt;a href=&quot;#numpy.ma.MaskedArray.unshare_mask&quot;&gt; &lt;code&gt;unshare_mask&lt;/code&gt; &lt;/a&gt; 는 마스크가 공유되지 않도록합니다. 마스크 사본은 공유 된 경우에만 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="340b1de921c9745845d275ad69b116e9e6d7cce7" translate="yes" xml:space="preserve">
          <source>Whether the mask is shared between masked arrays can be seen from the &lt;a href=&quot;numpy.ma.masked_array.sharedmask#numpy.ma.masked_array.sharedmask&quot;&gt;&lt;code&gt;sharedmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;#numpy.ma.masked_array.unshare_mask&quot;&gt;&lt;code&gt;unshare_mask&lt;/code&gt;&lt;/a&gt; ensures the mask is not shared. A copy of the mask is only made if it was shared.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db7611d744e4dcdca549d1fbd74911098f577c62" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to True.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; 세트&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 를 True로.</target>
        </trans-unit>
        <trans-unit id="b8f17f77435a0793df30f7927fd68842a3c16557" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to False.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 설정합니다 를 False로 .</target>
        </trans-unit>
        <trans-unit id="a13aa0b6af557159a253f9e361f23d8056f7cd7c" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;numpy.ma.masked_array.hardmask#numpy.ma.masked_array.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;numpy.ma.masked_array.hardmask#numpy.ma.masked_array.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to True.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58bb97d73903bba4379881dfe21651d2944e9e4f" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;a href=&quot;numpy.ma.masked_array.hardmask#numpy.ma.masked_array.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; property. &lt;a href=&quot;numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;a href=&quot;numpy.ma.masked_array.hardmask#numpy.ma.masked_array.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; to False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3e122a9b529992b197b46b09923f9ca3bd360b" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;code&gt;hardmask&lt;/code&gt; property. &lt;a href=&quot;#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt; sets &lt;code&gt;hardmask&lt;/code&gt; to True.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;code&gt;hardmask&lt;/code&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;hardmask&lt;/code&gt; 설정합니다 를 True로 .</target>
        </trans-unit>
        <trans-unit id="01426ffe48ebece03a2678d8f2d6adc220725bf0" translate="yes" xml:space="preserve">
          <source>Whether the mask of a masked array is hard or soft is determined by its &lt;code&gt;hardmask&lt;/code&gt; property. &lt;a href=&quot;#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; sets &lt;code&gt;hardmask&lt;/code&gt; to False.</source>
          <target state="translated">마스크 배열의 마스크가 하드인지 소프트인지는 &lt;code&gt;hardmask&lt;/code&gt; 속성에 의해 결정됩니다 . &lt;a href=&quot;#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;hardmask&lt;/code&gt; 설정합니다 를 False로 .</target>
        </trans-unit>
        <trans-unit id="138446419a6b818b440bdbf047003a998807c2e8" translate="yes" xml:space="preserve">
          <source>Whether the names should be case-sensitive (&lt;code&gt;case_sensitive=True&lt;/code&gt;), converted to upper case (&lt;code&gt;case_sensitive=False&lt;/code&gt; or &lt;code&gt;case_sensitive='upper'&lt;/code&gt;) or to lower case (&lt;code&gt;case_sensitive='lower'&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee9da79319e6c0e3169d3748cede2f00813142ab" translate="yes" xml:space="preserve">
          <source>Whether the output should be stored in row-major (C-style) or column-major (Fortran-style) order in memory.</source>
          <target state="translated">출력을 메모리에서 행 메이저 (C 스타일) 또는 열 메이저 (Fortran 스타일) 순서로 저장해야하는지 여부</target>
        </trans-unit>
        <trans-unit id="92d233bcb4830096541e589ec9f4a1ebacbac55b" translate="yes" xml:space="preserve">
          <source>Whether the sample is shuffled when sampling without replacement. Default is True, False provides a speedup.</source>
          <target state="translated">교체하지 않고 샘플링 할 때 샘플이 섞여 있는지 여부 기본값은 True이고 False는 속도 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="da175c30578215af592bdb3c0536af196e7c720a" translate="yes" xml:space="preserve">
          <source>Whether the sample is with or without replacement</source>
          <target state="translated">시료가 교체 유무에 관계없이</target>
        </trans-unit>
        <trans-unit id="56d0390af16d5fd75c7929234de623abb71d3a3f" translate="yes" xml:space="preserve">
          <source>Whether this event constitutes a Code of Conduct violation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8abcd0ba2e0e0b4eb15c921a63cd2223ac9df3e8" translate="yes" xml:space="preserve">
          <source>Whether this is an ongoing situation, and there is a threat to anyone&amp;rsquo;s physical safety.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7a933f70353e3ad1ecdef0da587770caa9c5376" translate="yes" xml:space="preserve">
          <source>Whether to automatically strip white spaces from the variables.</source>
          <target state="translated">변수에서 공백을 자동으로 제거할지 여부</target>
        </trans-unit>
        <trans-unit id="442a6c8414200886a8391269e4fbd9de7abf0966" translate="yes" xml:space="preserve">
          <source>Whether to collapse a mask full of False to &lt;code&gt;nomask&lt;/code&gt;.</source>
          <target state="translated">False로 가득 찬 마스크를 &lt;code&gt;nomask&lt;/code&gt; 로 축소할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="4050a74967f8f69856c2fbd0e3e619300a40e0f0" translate="yes" xml:space="preserve">
          <source>Whether to collapse a mask full of False to nomask</source>
          <target state="translated">마스크로 False로 가득 찬 마스크를 축소할지 여부</target>
        </trans-unit>
        <trans-unit id="62176ff771859dd4204e465857618db43d4b9e20" translate="yes" xml:space="preserve">
          <source>Whether to collapse nested fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c052f30967f49a9b943b88084eb17b8a3c940aea" translate="yes" xml:space="preserve">
          <source>Whether to combine &lt;code&gt;mask&lt;/code&gt; with the mask of the input data, if any (True), or to use only &lt;code&gt;mask&lt;/code&gt; for the output (False). Default is True.</source>
          <target state="translated">마스크를 입력 데이터의 &lt;code&gt;mask&lt;/code&gt; 와 결합하는지 (있는 경우) 또는 출력에 &lt;code&gt;mask&lt;/code&gt; 만 사용하는지 (False). 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="eddff56e50fafc8cb9b530fe24b021eae68e3c92" translate="yes" xml:space="preserve">
          <source>Whether to compare NaN&amp;rsquo;s as equal. If True, NaN&amp;rsquo;s in &lt;code&gt;a&lt;/code&gt; will be considered equal to NaN&amp;rsquo;s in &lt;code&gt;b&lt;/code&gt; in the output array.</source>
          <target state="translated">NaN을 동일한 지 비교할지 여부 참이면에 낸의 &lt;code&gt;a&lt;/code&gt; 에서 낸의 동등한 것으로 간주된다 &lt;code&gt;b&lt;/code&gt; 출력 배열된다.</target>
        </trans-unit>
        <trans-unit id="02ebb4bc09961e4bbbe5be1fe036d0ee044eabeb" translate="yes" xml:space="preserve">
          <source>Whether to compare NaN&amp;rsquo;s as equal. If the dtype of a1 and a2 is complex, values will be considered equal if either the real or the imaginary component of a given value is &lt;code&gt;nan&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10fe679c9d66f1cf6761f7d27d834a6040161f28" translate="yes" xml:space="preserve">
          <source>Whether to copy the input data (True), or to use a reference instead. Default is False.</source>
          <target state="translated">입력 데이터를 복사할지 (True) 또는 참조를 대신 사용할지 여부 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="5fe509663979cfcace796559b2e65ed21543a41a" translate="yes" xml:space="preserve">
          <source>Whether to create a copy of &lt;code&gt;x&lt;/code&gt; (True) or to replace values in-place (False). The in-place operation only occurs if casting to an array does not require a copy. Default is True.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 사본을 작성할지 (True) 또는 내부 값을 대체 할 것인지 (False). 인플레 이스 작업은 어레이로 캐스트 할 때 사본이 필요하지 않은 경우에만 발생합니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="7cae43f7fc0aea2ec3356f28a33a3a863498b88e" translate="yes" xml:space="preserve">
          <source>Whether to create an aligned memory layout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3a38e23cd94158d3fb92938c528fabce71a1cc" translate="yes" xml:space="preserve">
          <source>Whether to force compression of an empty mask. Default is True.</source>
          <target state="translated">빈 마스크를 강제로 압축할지 여부입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="954b794bdd577e9151cce4c13b30b4547a80cce1" translate="yes" xml:space="preserve">
          <source>Whether to force the output to be a &lt;code&gt;pure&lt;/code&gt; ndarray (False) or to return a subclass of ndarray if appropriate (True, default).</source>
          <target state="translated">출력을 &lt;code&gt;pure&lt;/code&gt; 것으로 강제할지 여부 ndarray (False) 적절한 경우 ndarray의 서브 클래스를 리턴할지 여부 (True, default).</target>
        </trans-unit>
        <trans-unit id="e3b6a28cf1ae69fa2745e3bf0096fffb2681b0f4" translate="yes" xml:space="preserve">
          <source>Whether to import sub-modules in packages. Default is True.</source>
          <target state="translated">패키지에서 하위 모듈을 가져올 지 여부 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="560758d583a48f61c5f8c924a74ada989d313f2e" translate="yes" xml:space="preserve">
          <source>Whether to raise an AssertionError when a doctest fails. Default is True.</source>
          <target state="translated">doctest가 실패한 경우 AssertionError 발생 여부입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="9da66ee12a4e35260c8d865d944cf7e0c6ffd0fb" translate="yes" xml:space="preserve">
          <source>Whether to re-generate the docstring cache. Default is False.</source>
          <target state="translated">docstring 캐시를 다시 생성할지 여부. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="f98f2fb6c72df675129c76f9bce42592bdfab4fb" translate="yes" xml:space="preserve">
          <source>Whether to return a MaskedArray (or MaskedRecords is &lt;code&gt;asrecarray==True&lt;/code&gt;) or a ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2c4419241a17141e2305c4b8dcba97409a61c9" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of &lt;code&gt;m&lt;/code&gt; (True) or &lt;code&gt;m&lt;/code&gt; itself (False).</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; (True) 또는 &lt;code&gt;m&lt;/code&gt; 자체 (False) 의 사본을 리턴할지 여부</target>
        </trans-unit>
        <trans-unit id="d8e552974363003f8c300f894365cd71e993d9cb" translate="yes" xml:space="preserve">
          <source>Whether to return a copy of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여부는 사본으로 돌아갑니다 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17b6d3614fb6aec6828495e1dc6c9f3e3cb25114" translate="yes" xml:space="preserve">
          <source>Whether to return a masked array or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4e9ec2ff1473fe325d2ab7b74109d36f9b95a7" translate="yes" xml:space="preserve">
          <source>Whether to return a recarray (MaskedRecords) or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="537dd9c43929ac61e1b91f77cf8f252cc29ca2c7" translate="yes" xml:space="preserve">
          <source>Whether to return a recarray (or MaskedRecords if &lt;code&gt;usemask==True&lt;/code&gt;) or just a flexible-type ndarray.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a99566bf50e4cbe34436592687ae3a066ec1520e" translate="yes" xml:space="preserve">
          <source>Whether to return a recarray or a mrecarray (&lt;code&gt;asrecarray=True&lt;/code&gt;) or a plain ndarray or masked array with flexible dtype. The default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="037c91325bbf0eb3057c152573c6cd848efe298f" translate="yes" xml:space="preserve">
          <source>Whether to return a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; if possible (True) or a plain &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;. Default is True.</source>
          <target state="translated">여부는의 서브 클래스 반환 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 가능 (참) 경우 또는 일반 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 을&lt;/a&gt; . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="bdbbe0cbc16b25af4b5214a715ea3e1431bb785c" translate="yes" xml:space="preserve">
          <source>Whether to return the indices of the duplicated values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ae760f9c4f41fa0fbb26a77403a1c22ab55b573" translate="yes" xml:space="preserve">
          <source>Whether to show the sign for positive values.</source>
          <target state="translated">양수 부호를 표시할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="1b8be26bfc8b0e89327240212310466b2cf75c4c" translate="yes" xml:space="preserve">
          <source>Whether to shrink &lt;code&gt;m&lt;/code&gt; to &lt;code&gt;nomask&lt;/code&gt; if all its values are False.</source>
          <target state="translated">모든 값이 False 인 경우 &lt;code&gt;m&lt;/code&gt; 을 &lt;code&gt;nomask&lt;/code&gt; 로 축소할지 여부 입니다.</target>
        </trans-unit>
        <trans-unit id="3178cfeee0adef6924aedc74760260f82717be37" translate="yes" xml:space="preserve">
          <source>Whether to shrink the output to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; if all its values are False. Defaults to True.</source>
          <target state="translated">출력을 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 로 축소할지 여부모든 값이 False 인 경우 입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="d9db91db6f9220d3637c22a670ce2fece1ba8892" translate="yes" xml:space="preserve">
          <source>Whether to store matrix in C- or Fortran-contiguous order, default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">행렬을 C- 또는 Fortran-contiguous 순서로 저장할지 여부는 기본값이 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="f47e8ef32095f56286465eeec2aded155a972a62" translate="yes" xml:space="preserve">
          <source>Whether to store multi-dimensional data in row-major (C-style) or column-major (Fortran-style) order in memory.</source>
          <target state="translated">다차원 데이터를 행 전공 (C 스타일) 또는 열 전공 (Fortran 스타일) 순서로 메모리에 저장할지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="91845ffd71912999afe1ae31aecba568b6c77126" translate="yes" xml:space="preserve">
          <source>Whether to store multidimensional data in C- or Fortran-contiguous (row- or column-wise) order in memory.</source>
          <target state="translated">다차원 데이터를 메모리에 C- 순 또는 연속-순 (행 또는 열 방향) 순서로 저장할지 여부</target>
        </trans-unit>
        <trans-unit id="dab7c3794a646540de7acd62a59e0fb24a52ca93" translate="yes" xml:space="preserve">
          <source>Whether to store the result in C- or Fortran-contiguous order, default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">결과를 C- 또는 Fortran-contiguous 순서로 저장할지 여부는 기본값이 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="bfc4130ee9478e47e13d28dd5c7bbedd301de36f" translate="yes" xml:space="preserve">
          <source>Whether to use a copy of &lt;code&gt;a&lt;/code&gt; (True) or to fix &lt;code&gt;a&lt;/code&gt; in place (False). Default is True.</source>
          <target state="translated">여부는 사본 사용하는 (true)를하거나 해결하기 위해 &lt;code&gt;a&lt;/code&gt; 장소 (거짓)에서. 기본값은 True입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aebefd02adf3850b379921c027ca5f73a9e89812" translate="yes" xml:space="preserve">
          <source>Whether to use a hard mask or not. With a hard mask, masked values cannot be unmasked. Default is False.</source>
          <target state="translated">하드 마스크 사용 여부 하드 마스크를 사용하면 마스크 된 값을 마스크 해제 할 수 없습니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="5e961f550eaad97e3dafff75ba96d8df26719652" translate="yes" xml:space="preserve">
          <source>Whether to use row-major (&amp;lsquo;C&amp;rsquo;) or column-major (&amp;lsquo;FORTRAN&amp;rsquo;) memory representation. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">행 메이저 ( 'C') 또는 열 메이저 ( 'FORTRAN') 메모리 표현 사용 여부 기본값은 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="cc497678cbe7ddcd1c3ae01eed475a06c838ec4e" translate="yes" xml:space="preserve">
          <source>Whether to use row-major (C-style) or column-major (Fortran-style) memory representation. Defaults to &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">행 메이저 (C 스타일) 또는 열 메이저 (Fortran 스타일) 메모리 표현 사용 여부 기본값은 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="25195d8226c7af7ee557736e882797435cd7c507" translate="yes" xml:space="preserve">
          <source>Which columns to read, with 0 being the first. For example, &lt;code&gt;usecols = (1, 4, 5)&lt;/code&gt; will extract the 2nd, 5th and 6th columns.</source>
          <target state="translated">읽을 열 (첫 번째 0) 예를 들어, &lt;code&gt;usecols = (1, 4, 5)&lt;/code&gt; 는 2, 5, 6 번째 열을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="ef9e92c2b540fbcf01177bb037dde03eb96de271" translate="yes" xml:space="preserve">
          <source>Which columns to read, with 0 being the first. For example, &lt;code&gt;usecols = (1,4,5)&lt;/code&gt; will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.</source>
          <target state="translated">읽을 열 (첫 번째 0) 예를 들어, &lt;code&gt;usecols = (1,4,5)&lt;/code&gt; 는 2, 5, 6 번째 열을 추출합니다. 기본값 인 None은 모든 열을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="fbd4eaea9ffb1459ac3fe81052e7c99556134589" translate="yes" xml:space="preserve">
          <source>Which creates a shared_library named code.so in the current directory. On Windows don&amp;rsquo;t forget to either add &lt;code&gt;__declspec(dllexport)&lt;/code&gt; in front of void on the line preceding each function definition, or write a &lt;code&gt;code.def&lt;/code&gt; file that lists the names of the functions to be exported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13f9686c4e3a41f3f30b2ea464209b867b694965" translate="yes" xml:space="preserve">
          <source>Which gives more easily comparable results than using separate bins for each histogram:</source>
          <target state="translated">각 히스토그램에 별도의 빈을 사용하는 것보다 훨씬 쉬운 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a1a80f0fc41db0ca1b3afb508f48229204eeb48b" translate="yes" xml:space="preserve">
          <source>Which gives the polynomial &lt;code&gt;p&lt;/code&gt; in Chebyshev form. This works because</source>
          <target state="translated">체비 쇼프 형태 의 다항식 &lt;code&gt;p&lt;/code&gt; 를 제공합니다 . 이것은 작동하기 때문에</target>
        </trans-unit>
        <trans-unit id="4677fdc512f0b2c82debb07e465be34f22e7fdd0" translate="yes" xml:space="preserve">
          <source>While Python is a great language and a pleasure to code in, its dynamic nature results in overhead that can cause some code ( &lt;em&gt;i.e.&lt;/em&gt; raw computations inside of for loops) to be up 10-100 times slower than equivalent code written in a static compiled language. In addition, it can cause memory usage to be larger than necessary as temporary arrays are created and destroyed during computation. For many types of computing needs, the extra slow-down and memory consumption can often not be spared (at least for time- or memory- critical portions of your code). Therefore one of the most common needs is to call out from Python code to a fast, machine-code routine (e.g. compiled using C/C++ or Fortran). The fact that this is relatively easy to do is a big reason why Python is such an excellent high-level language for scientific and engineering programming.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="559b97a21645e20b96438fa99ddc59b3a9a0af7c" translate="yes" xml:space="preserve">
          <source>While a C-style and Fortran-style contiguous array, which has the corresponding flags set, can be addressed with the above strides, the actual strides may be different. This can happen in two cases:</source>
          <target state="translated">대응하는 플래그 세트를 갖는 C- 스타일 및 포트란-스타일 연속 배열은 상기 보폭으로 처리 될 수 있지만, 실제 보폭은 다를 수있다. 이것은 두 가지 경우에 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="31b1b02b8719fc4aef9008c2ae820a7865ef1587" translate="yes" xml:space="preserve">
          <source>While the default data type is floating point (&lt;code&gt;np.float64&lt;/code&gt;), you can explicitly specify which data type you want using the &lt;code&gt;dtype&lt;/code&gt; keyword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90e66f4e6fa5110e8476c65e7c15355fd96a8c2f" translate="yes" xml:space="preserve">
          <source>While the ndarray object is designed to allow rapid computation in Python, it is also designed to be general-purpose and satisfy a wide- variety of computational needs. As a result, if absolute speed is essential, there is no replacement for a well-crafted, compiled loop specific to your application and hardware. This is one of the reasons that numpy includes f2py so that an easy-to-use mechanisms for linking (simple) C/C++ and (arbitrary) Fortran code directly into Python are available. You are encouraged to use and improve this mechanism. The purpose of this section is not to document this tool but to document the more basic steps to writing an extension module that this tool depends on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1df1b5a0658c69d8a413e038e320119a5eacba2" translate="yes" xml:space="preserve">
          <source>While the nonzero values can be obtained with &lt;code&gt;a[nonzero(a)]&lt;/code&gt;, it is recommended to use &lt;code&gt;x[x.astype(bool)]&lt;/code&gt; or &lt;code&gt;x[x != 0]&lt;/code&gt; instead, which will correctly handle 0-d arrays.</source>
          <target state="translated">0이 아닌 값은 &lt;code&gt;a[nonzero(a)]&lt;/code&gt; 로 얻을 수 있지만 &lt;code&gt;x[x.astype(bool)]&lt;/code&gt; 또는 &lt;code&gt;x[x != 0]&lt;/code&gt; 을 사용하는 것이 좋습니다 . 배열을 올바르게 처리 대신 .</target>
        </trans-unit>
        <trans-unit id="95abe15b68efd387eb8c7edc6a4c57dd87ccf623" translate="yes" xml:space="preserve">
          <source>While we&amp;rsquo;re at it, let&amp;rsquo;s also introduce the &amp;lsquo;no_broadcast&amp;rsquo; flag, which will prevent the output from being broadcast. This is important, because we only want one input value for each output. Aggregating more than one input value is a reduction operation which requires special handling. It would already raise an error because reductions must be explicitly enabled in an iterator flag, but the error message that results from disabling broadcasting is much more understandable for end-users. To see how to generalize the square function to a reduction, look at the sum of squares function in the section about Cython.</source>
          <target state="translated">우리가 그 동안, 출력이 방송되는 것을 막는 'no_broadcast'플래그도 소개하겠습니다. 각 출력에 대해 하나의 입력 값만 원하므로 중요합니다. 둘 이상의 입력 값을 집계하는 것은 특별한 처리가 필요한 축소 작업입니다. 반복자 플래그에서 축소를 명시 적으로 활성화해야하기 때문에 이미 오류가 발생하지만 브로드 캐스트 비활성화로 인한 오류 메시지는 최종 사용자에게 훨씬 이해하기 쉽습니다. 제곱 함수를 축소로 일반화하는 방법을 보려면 Cython 관련 섹션에서 제곱합 함수를보십시오.</target>
        </trans-unit>
        <trans-unit id="fdf453fd16b5200319b11da91be27d0c70481271" translate="yes" xml:space="preserve">
          <source>White spaces are ignored.</source>
          <target state="translated">공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="22dce6bca851893db69d37c56a8bc235318a963f" translate="yes" xml:space="preserve">
          <source>Who Else Uses NumPy?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695c34413853a0a8946e80017d6dc886095f0264" translate="yes" xml:space="preserve">
          <source>Who are the responsible party(ies).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31b504f4db86b2c606040985beea7e292d8749f2" translate="yes" xml:space="preserve">
          <source>Why is NumPy Fast?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7da3ad366450168b425d91b2ecc5364e5b9f6133" translate="yes" xml:space="preserve">
          <source>Why is There a Second File?</source>
          <target state="translated">왜 두 번째 파일이 있습니까?</target>
        </trans-unit>
        <trans-unit id="617b3271b5b69fcf3df8ec039eca36a1dd4b4fb8" translate="yes" xml:space="preserve">
          <source>Why use &lt;code&gt;__new__&lt;/code&gt; rather than just the usual &lt;code&gt;__init__&lt;/code&gt;? Because in some cases, as for ndarray, we want to be able to return an object of some other class. Consider the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5faa59dd442eb9f9b067a10198b95685727452a" translate="yes" xml:space="preserve">
          <source>Width of string to left-fill elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 왼쪽 채우기 요소에 &lt;code&gt;a&lt;/code&gt; 문자열 너비입니다 .</target>
        </trans-unit>
        <trans-unit id="a87a9df3bc292d00475af99a19cfb5bace676377" translate="yes" xml:space="preserve">
          <source>Wikipedia page: &lt;a href=&quot;https://en.wikipedia.org/wiki/Trapezoidal_rule&quot;&gt;https://en.wikipedia.org/wiki/Trapezoidal_rule&lt;/a&gt;</source>
          <target state="translated">Wikipedia 페이지 : &lt;a href=&quot;https://en.wikipedia.org/wiki/Trapezoidal_rule&quot;&gt;https://en.wikipedia.org/wiki/Trapezoidal_rule&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f57f881086e09b1ae09664bdf831c36a611c6436" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Binomial distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Binomial_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;이항 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Binomial_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06cf28156832f9d8c24f1184dfe95f4c17b24eb4" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Cauchy distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy_distribution&quot;&gt;https://en.wikipedia.org/wiki/Cauchy_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;코시 배포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Cauchy_distribution&quot;&gt;https://en.wikipedia.org/wiki/Cauchy_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5f4dafaf375cb5ca788c45f1e6be90dcf059029c" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Convolution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;https://en.wikipedia.org/wiki/Convolution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;컨볼 루션&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Convolution&quot;&gt;https://en.wikipedia.org/wiki/Convolution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="aefec7a4eb1a5aecabb180014fe85015da54a986" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Curve fitting&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;https://en.wikipedia.org/wiki/Curve_fitting&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;곡선 피팅&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Curve_fitting&quot;&gt;https://en.wikipedia.org/wiki/Curve_fitting&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ceebe5e149c9b6f7b481dab32a8b80c5a5e67177" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Dirichlet distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_distribution&quot;&gt;https://en.wikipedia.org/wiki/Dirichlet_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Dirichlet distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Dirichlet_distribution&quot;&gt;https://en.wikipedia.org/wiki/Dirichlet_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c274fb3e94d194d553ba10a5c9ba49ab92ab9ab3" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Exponential distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;https://en.wikipedia.org/wiki/Exponential_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;지수 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_distribution&quot;&gt;https://en.wikipedia.org/wiki/Exponential_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0748ca7a20f6367685397b634c58b22d1101a55" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Exponential function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt;https://en.wikipedia.org/wiki/Exponential_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;지수 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_function&quot;&gt; https://en.wikipedia.org/wiki/Exponential_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="450a7618a7ae64b3deba48000f4698be90e329a4" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;F-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/F-distribution&quot;&gt;https://en.wikipedia.org/wiki/F-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;F- 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/F-distribution&quot;&gt;https://en.wikipedia.org/wiki/F-&lt;/a&gt; 배포</target>
        </trans-unit>
        <trans-unit id="17b148f03642613eb714110e8ca6f8c433f95ee5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Gamma distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_distribution&quot;&gt;https://en.wikipedia.org/wiki/Gamma_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;감마 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Gamma_distribution&quot;&gt;https://en.wikipedia.org/wiki/Gamma_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="607958a0e56c238af4c16a4ba8a36ed9dd6aae60" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot;&gt;https://en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;하이퍼 볼릭 기능&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hyperbolic_function&quot;&gt;https://en.wikipedia.org/wiki/Hyperbolic_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b2ed497979708d30048971b5f912f3a976a07c07" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Hypergeometric distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergeometric_distribution&quot;&gt;https://en.wikipedia.org/wiki/Hypergeometric_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;고도 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Hypergeometric_distribution&quot;&gt;https://en.wikipedia.org/wiki/Hypergeometric_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f6c41ede2dc056083c46b6379a06aec4ce640792" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse Gaussian distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&quot;&gt;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 가우스 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&quot;&gt;https://en.wikipedia.org/wiki/Inverse_Gaussian_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c81f68efd7be19a13fb16b9d3ede8e0916b2b3ba" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arccosh&quot;&gt;https://en.wikipedia.org/wiki/Arccosh&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 쌍곡 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arccosh&quot;&gt;https://en.wikipedia.org/wiki/Arccosh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="788ea2b2b4739c5aba7340cb8614d021cf776477" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arcsinh&quot;&gt;https://en.wikipedia.org/wiki/Arcsinh&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;역 쌍곡 함수&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arcsinh&quot;&gt;https://en.wikipedia.org/wiki/Arcsinh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7afed20bd82634dc688b205c679d736b6a3ca9fd" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Inverse hyperbolic function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arctanh&quot;&gt;https://en.wikipedia.org/wiki/Arctanh&lt;/a&gt;</source>
          <target state="translated">위키 백과, &quot;역 쌍곡 함수&quot;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Arctanh&quot;&gt; https://en.wikipedia.org/wiki/Arctanh&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cbf65d4c8a1edb6485c9090716aa502b1cad498" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Laplace distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_distribution&quot;&gt;https://en.wikipedia.org/wiki/Laplace_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;라플라스 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_distribution&quot;&gt;https://en.wikipedia.org/wiki/Laplace_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a5dafa467113c3ca3efc06f2332310e05c7a2741" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logarithm&amp;rdquo;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;대수&amp;rdquo;. &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithm&quot;&gt;https://en.wikipedia.org/wiki/Logarithm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c49c2d4eec5ab9e21b7777f19f27c237fceb82c5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logarithmic distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithmic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logarithmic_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;대수 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logarithmic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logarithmic_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78ccdc5f379af6bc4c7ea04cc13613370465bc4d" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Logistic-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logistic_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;물류 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Logistic_distribution&quot;&gt;https://en.wikipedia.org/wiki/Logistic_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4c3fd20f148f2b77555334569014216015267361" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Negative binomial distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Negative_binomial_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;음 이항 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Negative_binomial_distribution&quot;&gt;https://en.wikipedia.org/wiki/Negative_binomial_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="785913c64c1118d2e5699ad155c8010ddb5608e2" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Noncentral F-distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_F-distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_F-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;비 중앙 F- 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_F-distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_F-&lt;/a&gt; 배포</target>
        </trans-unit>
        <trans-unit id="290d1f296088408d1c3d2c95c7a7428e7d2c6df3" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Noncentral chi-squared distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;비 중앙 카이 제곱 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&quot;&gt;https://en.wikipedia.org/wiki/Noncentral_chi-squared_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f54672c52ce6e2a5669a3fc7c140d35832003af5" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Normal distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;https://en.wikipedia.org/wiki/Normal_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;일반 배포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Normal_distribution&quot;&gt;https://en.wikipedia.org/wiki/Normal_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="47b80170417ddd59eaf50cda77d4edfc322816d8" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Pareto distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Pareto_distribution&quot;&gt;https://en.wikipedia.org/wiki/Pareto_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Pareto distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Pareto_distribution&quot;&gt;https://en.wikipedia.org/wiki/Pareto_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d689426c6cd7a9b7cf6ef5d58b51175bf540f33b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Poisson distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;https://en.wikipedia.org/wiki/Poisson_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;포아송 분포&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_distribution&quot;&gt;https://en.wikipedia.org/wiki/Poisson_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8adc5c562751b6b393b3aa2c35d2e2c7be11d14b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Poisson process&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_process&quot;&gt;https://en.wikipedia.org/wiki/Poisson_process&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;포아송 프로세스&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Poisson_process&quot;&gt;https://en.wikipedia.org/wiki/Poisson_process&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5ca57768f5ed62a15abd4e259a3842bfc684623e" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Polynomial interpolation&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;https://en.wikipedia.org/wiki/Polynomial_interpolation&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;다항식 보간&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Polynomial_interpolation&quot;&gt;https://en.wikipedia.org/wiki/Polynomial_interpolation&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ca489fd77451dbec195b0cb37e2326fd572ee535" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Rayleigh distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rayleigh_distribution&quot;&gt;https://en.wikipedia.org/wiki/Rayleigh_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Rayleigh 배포판&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Rayleigh_distribution&quot;&gt;https://en.wikipedia.org/wiki/Rayleigh_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="56ead22f9041996687e49f69c8aa068b4de6264b" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Sinc function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;https://en.wikipedia.org/wiki/Sinc_function&lt;/a&gt;</source>
          <target state="translated">위키피디아,&amp;ldquo;Sinc function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Sinc_function&quot;&gt;https://en.wikipedia.org/wiki/Sinc_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bdeeaa545061fb4a54e4c2ef8adfce392d92d540" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Student&amp;rsquo;s t-distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Student's_t-distribution&quot;&gt;https://en.wikipedia.org/wiki/Student&amp;rsquo;s_t-distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;학생의 t- 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Student's_t-distribution&quot;&gt;https://en.wikipedia.org/wiki/Student's_t-&lt;/a&gt; 분포</target>
        </trans-unit>
        <trans-unit id="890688a22e8725c7cf1acbafe1abacdd0f27f3f0" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Triangular distribution&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_distribution&quot;&gt;https://en.wikipedia.org/wiki/Triangular_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;삼각 분포&amp;rdquo; &lt;a href=&quot;https://en.wikipedia.org/wiki/Triangular_distribution&quot;&gt;https://en.wikipedia.org/wiki/Triangular_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3d2b813725fc8f5761f54e225edc22f4a2afa8f7" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Two&amp;rsquo;s complement&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;https://en.wikipedia.org/wiki/Two&amp;rsquo;s_complement&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;두 가지 보완 요소&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Two's_complement&quot;&gt;https://en.wikipedia.org/wiki/Two's_complement&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ecbb6d74623f82d0937cf4a5246298d1b6f5e329" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Weibull distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;https://en.wikipedia.org/wiki/Weibull_distribution&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;Weibull distribution&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Weibull_distribution&quot;&gt;https://en.wikipedia.org/wiki/Weibull_distribution&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98885a7cf6a7f9d6ba5424eda905db3584405b75" translate="yes" xml:space="preserve">
          <source>Wikipedia, &amp;ldquo;Window function&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;https://en.wikipedia.org/wiki/Window_function&lt;/a&gt;</source>
          <target state="translated">Wikipedia,&amp;ldquo;창 기능&amp;rdquo;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Window_function&quot;&gt;https://en.wikipedia.org/wiki/Window_function&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="49c2c96ddc19c930b5486ff7f81f0ce35e375ba2" translate="yes" xml:space="preserve">
          <source>Will install data-files to the locations:</source>
          <target state="translated">위치에 데이터 파일을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="0c6212fef9bffd0b18c4eb2da8c005e9e5030130" translate="yes" xml:space="preserve">
          <source>Will need to add this in Python exposure</source>
          <target state="translated">파이썬 노출에 이것을 추가해야합니다</target>
        </trans-unit>
        <trans-unit id="77b99d58f8024a3322642cff8a7f3229ae7fe238" translate="yes" xml:space="preserve">
          <source>Window for the returned series. If None the class window is used. The default is None.</source>
          <target state="translated">반환 된 시리즈의 창입니다. 없음 인 경우 클래스 창이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="cec65d78532248828b5443e4752a3df7fc4931aa" translate="yes" xml:space="preserve">
          <source>Window functions</source>
          <target state="translated">창 기능</target>
        </trans-unit>
        <trans-unit id="e640f561d38642c76bd680b6e8d0ccf0fad3f32d" translate="yes" xml:space="preserve">
          <source>Window length.</source>
          <target state="translated">창 길이.</target>
        </trans-unit>
        <trans-unit id="42e8204afc5c4121e8aabab0c8c2df383aac93dd" translate="yes" xml:space="preserve">
          <source>Window shape</source>
          <target state="translated">창 모양</target>
        </trans-unit>
        <trans-unit id="ef32d19ad6db1a011986e848a81515a21a4878bf" translate="yes" xml:space="preserve">
          <source>Window to use for the returned series. The default value is the default class domain</source>
          <target state="translated">반환 된 시리즈에 사용할 창입니다. 기본값은 기본 클래스 도메인입니다.</target>
        </trans-unit>
        <trans-unit id="092e83dcd0b17c063ad8bac69729a61bcd90390f" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.chebyshev.chebyshev.domain#numpy.polynomial.chebyshev.Chebyshev.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.chebyshev.chebyshev.domain#numpy.polynomial.chebyshev.Chebyshev.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="26cbe48bc40af2be9b95617385514366c179f8c5" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.hermite.hermite.domain#numpy.polynomial.hermite.Hermite.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.hermite.hermite.domain#numpy.polynomial.hermite.Hermite.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="e22365565e3904f47ab3840e3c565f4c9730ed9d" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.hermite_e.hermitee.domain#numpy.polynomial.hermite_e.HermiteE.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.hermite_e.hermitee.domain#numpy.polynomial.hermite_e.HermiteE.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="9ae30d11df20bd6d7701709f6c7a07d9a4c0c35b" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.laguerre.laguerre.domain#numpy.polynomial.laguerre.Laguerre.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [0, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.laguerre.laguerre.domain#numpy.polynomial.laguerre.Laguerre.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [0, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="f003de753cd9362865426af3e4947b5f99fe6dc8" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.legendre.legendre.domain#numpy.polynomial.legendre.Legendre.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.legendre.legendre.domain#numpy.polynomial.legendre.Legendre.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="88febbc72ccac8a306fb0efe81d8a0b92e99d8f9" translate="yes" xml:space="preserve">
          <source>Window, see &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.domain#numpy.polynomial.polynomial.Polynomial.domain&quot;&gt;&lt;code&gt;domain&lt;/code&gt;&lt;/a&gt; for its use. The default value is [-1, 1].</source>
          <target state="translated">창, &lt;a href=&quot;numpy.polynomial.polynomial.polynomial.domain#numpy.polynomial.polynomial.Polynomial.domain&quot;&gt; &lt;code&gt;domain&lt;/code&gt; &lt;/a&gt; 사용을 참조하십시오 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="3a11c9632c71bf466541bc0b135a1a92817671b6" translate="yes" xml:space="preserve">
          <source>Windows 98, Python 2.1.1. Idle 0.8</source>
          <target state="translated">Windows 98, Python 2.1.1. 유휴 0.8</target>
        </trans-unit>
        <trans-unit id="838d226af82740a98f0145b002fc6c84c21c7131" translate="yes" xml:space="preserve">
          <source>Windows Me Python 2.3(EE), Idle 1.0, PyCrust 0.7.2 Python 2.1.1 Idle 0.8</source>
          <target state="translated">Windows Me Python 2.3 (EE), 유휴 1.0, PyCrust 0.7.2 Python 2.1.1 유휴 0.8</target>
        </trans-unit>
        <trans-unit id="2d2f4a4fca6daeabadddf9bee05651305943de5c" translate="yes" xml:space="preserve">
          <source>Windows XP, Python 2.3.3</source>
          <target state="translated">윈도우 XP, 파이썬 2.3.3</target>
        </trans-unit>
        <trans-unit id="5a8d5a3a8e3ea63c9e1686fc793d226b8e269fca" translate="yes" xml:space="preserve">
          <source>Windows builds use the &lt;a href=&quot;https://mingwpy.github.io&quot;&gt;mingw-w64 toolchain&lt;/a&gt;;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0c85b48bfec29caf52b4700eb4512e9e2980af" translate="yes" xml:space="preserve">
          <source>Windows: 32-bit and 64-bit wheels built using Appveyor;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da15a9c19d58f2c4da712f0cc0618069c85b20a3" translate="yes" xml:space="preserve">
          <source>With &lt;a href=&quot;../reference/generated/numpy.savetxt#numpy.savetxt&quot;&gt;&lt;code&gt;savetxt&lt;/code&gt;&lt;/a&gt;, you can specify headers, footers, comments, and more.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd8127e25ea95e0575d8982f425efe9325056bce" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Generator.integers&lt;/code&gt;, you can generate random integers from low (remember that this is inclusive with NumPy) to high (exclusive). You can set &lt;code&gt;endpoint=True&lt;/code&gt; to make the high number inclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f4eb492be6190ac8266dfa1122d297c822b3bf" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;intent(hide)&lt;/code&gt; or &lt;code&gt;optional&lt;/code&gt; attributes specified and using a wrapper function without specifying the callback argument in argument list then call-back function is looked in the namespace of F2PY generated extension module where it can be set as a module attribute by a user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915e5fc79ca95b662b950c7a602693802648922" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;np.reshape&lt;/code&gt;, you can specify a few optional parameters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad51d8d6c50eba333fa3e657d7d2ea1d24b4116" translate="yes" xml:space="preserve">
          <source>With Matplotlib, you have access to an enormous number of visualization options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32efd2d58393af190f568a67689ea6a3e549d28a" translate="yes" xml:space="preserve">
          <source>With a context manager:</source>
          <target state="translated">컨텍스트 관리자를 사용하여 :</target>
        </trans-unit>
        <trans-unit id="f3558ac1d15b5a57abf53ea4474761a5d8cd7257" translate="yes" xml:space="preserve">
          <source>With a higher dimensional array the split is still along the first axis.</source>
          <target state="translated">더 높은 차원의 배열에서 분할은 여전히 ​​첫 번째 축을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ee544b31e6fafc07fbb87de84c67e07d54295002" translate="yes" xml:space="preserve">
          <source>With a higher dimensional array the split is still along the second axis.</source>
          <target state="translated">더 높은 차원의 배열에서 분할은 여전히 ​​두 번째 축을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="ab0ad2552c2290da0b4beaf3ab8b39ed880b7892" translate="yes" xml:space="preserve">
          <source>With a list of depth 1, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; can be used as &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">깊이 1 목록을 사용하면 &lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 을 &lt;a href=&quot;numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 으로 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="4a6ca14b02d06fe44564f452a8db5dc0b8887f51" translate="yes" xml:space="preserve">
          <source>With a list of depth 2, &lt;a href=&quot;#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; can be used in place of &lt;a href=&quot;numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">깊이 2의 목록 으로 &lt;a href=&quot;numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; 을&lt;/a&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5f9ff7e20abf4e4beec43f72205b5efc96b3cabc" translate="yes" xml:space="preserve">
          <source>With a similar procedure the forward/backward approximations used for boundaries can be derived.</source>
          <target state="translated">유사한 절차를 통해 경계에 사용되는 순방향 / 역방향 근사값을 도출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07af3a8001dd5a2cff9dc94ccf6ded3daafa9ec6" translate="yes" xml:space="preserve">
          <source>With instances:</source>
          <target state="translated">인스턴스의 경우 :</target>
        </trans-unit>
        <trans-unit id="98601db3737fbbb6544e879545b48b394db52bb5" translate="yes" xml:space="preserve">
          <source>With optional &lt;code&gt;start&lt;/code&gt;, test beginning at that position. With optional &lt;code&gt;end&lt;/code&gt;, stop comparing at that position.</source>
          <target state="translated">선택적인 &lt;code&gt;start&lt;/code&gt; 로 해당 위치에서 시작하여 테스트하십시오. 선택적 &lt;code&gt;end&lt;/code&gt; 를 사용하면 해당 위치에서 비교를 중지하십시오.</target>
        </trans-unit>
        <trans-unit id="432a947727f183556cdf77d6e3797bb503e0a762" translate="yes" xml:space="preserve">
          <source>With these definitions, an Institutional Partner is any recognized legal entity in the United States or elsewhere that employs at least 1 Institutional Contributor of Institutional Council Member. Institutional Partners can be for-profit or non-profit entities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2d93c630b90cc0cf1d738f44caa66baf4d85928" translate="yes" xml:space="preserve">
          <source>With types:</source>
          <target state="translated">유형으로 :</target>
        </trans-unit>
        <trans-unit id="5297c5a4978350f9e16a1aab9a51984e592036fa" translate="yes" xml:space="preserve">
          <source>Within a compiled Python module, &lt;code&gt;import_array()&lt;/code&gt; should only get called once. This could be in a C/C++ file that you have written and is linked to the module. If this is the case, then none of your interface files should &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; or call &lt;code&gt;import_array()&lt;/code&gt;. Or, this initialization call could be in a wrapper file generated by &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; from an interface file that has the &lt;code&gt;%init&lt;/code&gt; block as above. If this is the case, and you have more than one &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file, then only one interface file should &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; and call &lt;code&gt;import_array()&lt;/code&gt;.</source>
          <target state="translated">컴파일 된 파이썬 모듈 내에서 &lt;code&gt;import_array()&lt;/code&gt; 는 한 번만 호출되어야합니다. 이것은 작성한 C / C ++ 파일에있을 수 있으며 모듈에 링크되어 있습니다. 이 경우 &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; 또는 &lt;code&gt;import_array()&lt;/code&gt; 호출하는 인터페이스 파일이 없습니다 . 또는이 초기화 호출은 위와 같이 &lt;code&gt;%init&lt;/code&gt; 블록 이있는 인터페이스 파일에서 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG에&lt;/a&gt; 의해 생성 된 랩퍼 파일에있을 수 있습니다 . 이 경우 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 인터페이스 파일 이 둘 이상인 경우 하나의 인터페이스 파일 만 &lt;code&gt;#define SWIG_FILE_WITH_INIT&lt;/code&gt; 를 수행 하고 &lt;code&gt;import_array()&lt;/code&gt; 호출 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="42a24f4738db07788648f7de55bbb8493bc76610" translate="yes" xml:space="preserve">
          <source>Within these test methods, &lt;code&gt;assert_()&lt;/code&gt; and related functions are used to test whether a certain assumption is valid. If the assertion fails, the test fails. Note that the Python builtin &lt;code&gt;assert&lt;/code&gt; should not be used, because it is stripped during compilation with &lt;code&gt;-O&lt;/code&gt;.</source>
          <target state="translated">이 테스트 방법 내에서 &lt;code&gt;assert_()&lt;/code&gt; 및 관련 함수는 특정 가정이 유효한지 테스트하는 데 사용됩니다. 어설 션이 실패하면 테스트가 실패합니다. Python 내장 &lt;code&gt;assert&lt;/code&gt; 는 &lt;code&gt;-O&lt;/code&gt; 로 컴파일하는 동안 제거되므로 사용하지 않아야합니다 .</target>
        </trans-unit>
        <trans-unit id="0bf68fec54dbd7c575b675c0f5ecb37ef3c52771" translate="yes" xml:space="preserve">
          <source>Without a mask, the missing value will be filled with something, depending on what its corresponding type:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2729aa84fd8dbce5d8f5065881c86da559d3b68c" translate="yes" xml:space="preserve">
          <source>Without the &lt;code&gt;np.ix_&lt;/code&gt; call or only the diagonal elements would be selected.</source>
          <target state="translated">&lt;code&gt;np.ix_&lt;/code&gt; 호출이 없으면 대각선 요소 만 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="c9d58767cd4150ffea0b74d98e5d21e09369f5e3" translate="yes" xml:space="preserve">
          <source>Work in progress. Basic linear algebra to be included here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb6d460982da286faa01241fe0e8688fe713d131" translate="yes" xml:space="preserve">
          <source>Working on the flattened array does not return slices along an axis but selects elements.</source>
          <target state="translated">병합 된 배열에서 작업해도 축을 따라 슬라이스가 반환되지 않지만 요소가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="18f9309c3cd6c825d39b8b49605118cbab7b4c08" translate="yes" xml:space="preserve">
          <source>Working with mathematical formulas</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20669d5d64b568db66a362c01f09d0be2912bdf7" translate="yes" xml:space="preserve">
          <source>Works only with 2-D arrays at the moment.</source>
          <target state="translated">현재 2D 배열에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="10b18b3520a07a5cef88cf768f74798c3a76c969" translate="yes" xml:space="preserve">
          <source>Wrapper around &lt;code&gt;cPickle.load&lt;/code&gt; which accepts either a file-like object or a filename.</source>
          <target state="translated">파일과 유사한 객체 또는 파일 이름을 허용하는 &lt;code&gt;cPickle.load&lt;/code&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="9462c7fa9fecb835eb7e04e6564736baefd4da76" translate="yes" xml:space="preserve">
          <source>Wrapper functions to more user-friendly calling of certain math functions whose output data-type is different than the input data-type in certain domains of the input.</source>
          <target state="translated">랩퍼 함수는 출력 데이터 유형이 입력의 특정 도메인에서 입력 데이터 유형과 다른 특정 수학 함수를보다 사용자 친화적으로 호출 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="9ef9ae984284213ba399a55caa175126af51b14e" translate="yes" xml:space="preserve">
          <source>Wrapping Fortran or C functions to Python using F2PY consists of the following steps:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3455d09d842fa89e3426820a565b99b12203bd" translate="yes" xml:space="preserve">
          <source>Wraps an index to the valid range if it is out of bounds.</source>
          <target state="translated">범위를 벗어난 경우 인덱스를 유효한 범위로 래핑합니다.</target>
        </trans-unit>
        <trans-unit id="7a347606df979a4d48c841a72544818a00c72b80" translate="yes" xml:space="preserve">
          <source>Wraps the numpy array and sets the mask according to context.</source>
          <target state="translated">numpy 배열을 랩핑하고 컨텍스트에 따라 마스크를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="e18273e50d37416e99772f5cab31d35dc76b18b6" translate="yes" xml:space="preserve">
          <source>Write any changes in the array to the file on disk.</source>
          <target state="translated">어레이의 변경 사항을 디스크의 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="17ca7c9b94fb6b9ea51995accba9353b9d7605ae" translate="yes" xml:space="preserve">
          <source>Write array to a file as text or binary (default).</source>
          <target state="translated">배열을 텍스트 또는 이진 (기본값)으로 파일에 씁니다.</target>
        </trans-unit>
        <trans-unit id="b0ef5a1f165fa86b8ee546df97daa724c33481fa" translate="yes" xml:space="preserve">
          <source>Write data to memmap array:</source>
          <target state="translated">memmap 배열에 데이터 쓰기 :</target>
        </trans-unit>
        <trans-unit id="39de007639c1cf0174274b49579ea3af01d9afca" translate="yes" xml:space="preserve">
          <source>Write the contents of &lt;em&gt;self&lt;/em&gt; to the file pointer &lt;em&gt;fp&lt;/em&gt; in C-style contiguous fashion. Write the data as binary bytes if &lt;em&gt;sep&lt;/em&gt; is the string &amp;ldquo;&amp;rdquo;or &lt;code&gt;NULL&lt;/code&gt;. Otherwise, write the contents of &lt;em&gt;self&lt;/em&gt; as text using the &lt;em&gt;sep&lt;/em&gt; string as the item separator. Each item will be printed to the file. If the &lt;em&gt;format&lt;/em&gt; string is not &lt;code&gt;NULL&lt;/code&gt; or &amp;ldquo;&amp;rdquo;, then it is a Python print statement format string showing how the items are to be written.</source>
          <target state="translated">C 스타일 연속 방식 으로 &lt;em&gt;자체&lt;/em&gt; 내용을 파일 포인터 &lt;em&gt;fp&lt;/em&gt; 에 씁니다 . &lt;em&gt;sep&lt;/em&gt; 가 문자열&amp;ldquo;&amp;rdquo;또는 &lt;code&gt;NULL&lt;/code&gt; 인 경우 데이터를 이진 바이트로 씁니다 . 그렇지 않으면, &lt;em&gt;sep&lt;/em&gt; 문자열을 항목 구분 기호로 사용하여 &lt;em&gt;self&lt;/em&gt; 의 내용을 텍스트로 작성하십시오 . 각 항목이 파일로 인쇄됩니다. 경우 &lt;em&gt;형식&lt;/em&gt; 문자열이 아닌 &lt;code&gt;NULL&lt;/code&gt; 또는 &quot;&quot;다음은 항목이 기록 될 방법을 보여주는 파이썬 인쇄 문 형식 문자열입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="6c365fce32144380f0457057b029153143df4f1f" translate="yes" xml:space="preserve">
          <source>Writeable flag of C-API wrapped arrays</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="427fe64590307fe90e0ed3c7002e9d59f551f75b" translate="yes" xml:space="preserve">
          <source>Writeable keyword argument for &lt;code&gt;as_strided&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d00c80b2825b910b28f217d40888491f74cea96" translate="yes" xml:space="preserve">
          <source>Writeable returned arrays (since version 1.10.0):</source>
          <target state="translated">쓰기 가능한 반환 배열 (버전 1.10.0부터) :</target>
        </trans-unit>
        <trans-unit id="197f0e3d3c3e05cccf3208160a3555c70f66258d" translate="yes" xml:space="preserve">
          <source>Writing NumPy arrays to files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b9177a1f4610d4e348b555b88bf30f53e0383" translate="yes" xml:space="preserve">
          <source>Writing an extension module</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c3bf8fb2ea06db30fe5350590bb97d5b64d0bc1" translate="yes" xml:space="preserve">
          <source>Writing benchmarks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65f92e1986e8f85d7778ff39887ed018803befa" translate="yes" xml:space="preserve">
          <source>Writing custom array containers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8df331347211aebb4040fc654e8d39cec0f7787f" translate="yes" xml:space="preserve">
          <source>Writing technical documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ebe08ad44f2f2a207e761b2763be6cc2be06253" translate="yes" xml:space="preserve">
          <source>Writing tests for the &lt;code&gt;numpy.i&lt;/code&gt;&lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file is a combinatorial headache. At present, 12 different data types are supported, each with 74 different argument signatures, for a total of 888 typemaps supported &amp;ldquo;out of the box&amp;rdquo;. Each of these typemaps, in turn, might require several unit tests in order to verify expected behavior for both proper and improper inputs. Currently, this results in more than 1,000 individual unit tests executed when &lt;code&gt;make test&lt;/code&gt; is run in the &lt;code&gt;numpy/tools/swig&lt;/code&gt; subdirectory.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 인터페이스 파일에 대한 테스트 작성 은 조합 두통입니다. 현재 12 개의 서로 다른 데이터 유형이 지원되며 각각 74 개의 서로 다른 인수 서명이 지원되어 &quot;즉시&quot;지원되는 총 888 개의 유형 맵이 있습니다. 이러한 각 유형 맵에는 올바른 입력과 부적절한 입력 모두에 대해 예상되는 동작을 확인하기 위해 여러 단위 테스트가 필요할 수 있습니다. 현재 &lt;code&gt;numpy/tools/swig&lt;/code&gt; 서브 디렉토리 에서 &lt;code&gt;make test&lt;/code&gt; 를 실행할 때 1,000 개가 넘는 개별 단위 테스트가 실행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2816eea6d2ca27dc13489d1d22deb06f1c29fb32" translate="yes" xml:space="preserve">
          <source>Writing the commit message</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebee068a6bbb2b626411eaf7fd90b5ceb9e67c66" translate="yes" xml:space="preserve">
          <source>Writing to the result of &lt;code&gt;numpy.broadcast_arrays&lt;/code&gt; will warn</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecfd6c8b6bdc8850ec5e6c24472a391088658d3" translate="yes" xml:space="preserve">
          <source>Writing typemaps can be a bit nonintuitive. If you have specific questions about writing &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemaps for NumPy, the developers of &lt;code&gt;numpy.i&lt;/code&gt; do monitor the &lt;a href=&quot;mailto:Numpy-discussion%40python.org&quot;&gt;Numpy-discussion&lt;/a&gt; and &lt;a href=&quot;mailto:Swig-user%40lists.sourceforge.net&quot;&gt;Swig-user&lt;/a&gt; mail lists.</source>
          <target state="translated">타입 맵 작성은 약간 직관적이지 않을 수 있습니다. NumPy 용 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG 유형&lt;/a&gt; 맵 작성에 대한 특정 질문이있는 경우 &lt;code&gt;numpy.i&lt;/code&gt; 개발자 는 &lt;a href=&quot;mailto:Numpy-discussion%40python.org&quot;&gt;Numpy-discussion&lt;/a&gt; 및 &lt;a href=&quot;mailto:Swig-user%40lists.sourceforge.net&quot;&gt;Swig-user&lt;/a&gt; 메일 목록을 모니터 합니다.</target>
        </trans-unit>
        <trans-unit id="67b3075df8e687d02e42240f00e9c97b2d568182" translate="yes" xml:space="preserve">
          <source>Writing your own tests</source>
          <target state="translated">자신 만의 테스트 작성</target>
        </trans-unit>
        <trans-unit id="d413bc13e5a3684c16168d045c65e08c472bd899" translate="yes" xml:space="preserve">
          <source>Writing your own ufunc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="906b1e2537b7a59648d2378a60c2b5ab4b446170" translate="yes" xml:space="preserve">
          <source>XXX: I just obtained these values empirically</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23eb4d3f4155395a74e9d534f97ff4c1908f5aac" translate="yes" xml:space="preserve">
          <source>Y</source>
          <target state="translated">Y</target>
        </trans-unit>
        <trans-unit id="3e44498549b3ccfc159cdee6bdb9318868914b00" translate="yes" xml:space="preserve">
          <source>Yet another possibility is to use any of the following functions:</source>
          <target state="translated">또 다른 가능성은 다음 기능 중 하나를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="881f60e93d520cc9c2597264d824b1a04946803a" translate="yes" xml:space="preserve">
          <source>Yet, we have to &lt;em&gt;build&lt;/em&gt; a house before it exists:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59fbe76f39839efb6c5b691e1b2b5256f482c50b" translate="yes" xml:space="preserve">
          <source>You already have your own forked copy of the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; repository, by following &lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;, &lt;a href=&quot;gitwash/development_setup#set-up-fork&quot;&gt;Set up your fork&lt;/a&gt;, you have configured &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; by following &lt;a href=&quot;gitwash/configure_git#configure-git&quot;&gt;Git configuration&lt;/a&gt;, and have linked the upstream repository as explained in &lt;a href=&quot;gitwash/development_setup#linking-to-upstream&quot;&gt;Linking your repository to the upstream repo&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00eb290eb607af17a427008cd0df7020db925634" translate="yes" xml:space="preserve">
          <source>You can &amp;ldquo;test run&amp;rdquo; the new documentation in a browser to make sure the links work:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77839705742503276b6ae229dcc3f770d8625b34" translate="yes" xml:space="preserve">
          <source>You can access and modify individual fields of a structured array by indexing with the field name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e4cda34004c0b0283cc5d19ef4967039dda6a9e" translate="yes" xml:space="preserve">
          <source>You can add an axis at index position 0 with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebcf08c273e379725ba3c03f7dbf5125d70db1c" translate="yes" xml:space="preserve">
          <source>You can add the arrays together with the plus sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c8b2d15539f2fe59ff95576c13822e6dc13c97b" translate="yes" xml:space="preserve">
          <source>You can aggregate all the values in a matrix and you can aggregate them across columns or rows using the &lt;code&gt;axis&lt;/code&gt; parameter:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a3c1bcf70f6a7368f40947c84aaebd7c765c17" translate="yes" xml:space="preserve">
          <source>You can aggregate matrices the same way you aggregated vectors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237f9fca73b96863dad607a904e1d0df2385cdad" translate="yes" xml:space="preserve">
          <source>You can also expand an array by inserting a new axis at a specified position with &lt;code&gt;np.expand_dims&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2dd1c35daf50a20134f87a7ce8e57e5c3ceac4f3" translate="yes" xml:space="preserve">
          <source>You can also get f2py to compile add.f and also compile its produced extension module leaving only a shared-library extension file that can be imported from Python:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96352e42690860acf17aa1a27a4a270b4c0831fe" translate="yes" xml:space="preserve">
          <source>You can also look at the &lt;a href=&quot;https://github.com/blog/39-say-hello-to-the-network-graph-visualizer&quot;&gt;network graph visualizer&lt;/a&gt; for your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282c4f97ad9fcd8ed55a4a8ee354250a844bfb56" translate="yes" xml:space="preserve">
          <source>You can also make use of the logical operators &lt;strong&gt;&amp;amp;&lt;/strong&gt; and &lt;strong&gt;|&lt;/strong&gt; in order to return boolean values that specify whether or not the values in an array fulfill a certain condition. This can be useful with arrays that contain names or other categorical values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4a5fe8b97704af411fc68344f43f8175b5a17c2" translate="yes" xml:space="preserve">
          <source>You can also put the common two last lines into an extension-local header file as long as you make sure that NO_IMPORT_ARRAY is #defined before #including that file.</source>
          <target state="translated">해당 파일을 포함하기 전에 NO_IMPORT_ARRAY가 # 정의되어 있는지 확인하는 한 공통 두 줄을 확장-로컬 헤더 파일에 넣을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2c7a514bb765af4c0f18932e407e9116ccc75a9" translate="yes" xml:space="preserve">
          <source>You can also reverse the column at index position 1 (the second column):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c47550288816bfc7042c2dcdbf49371a30912fc7" translate="yes" xml:space="preserve">
          <source>You can also reverse the contents of only one column or row. For example, you can reverse the contents of the row at index position 1 (the second row):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c89799be221d2c9e96c99b9f246abd7f544a3e35" translate="yes" xml:space="preserve">
          <source>You can also save your array with the NumPy &lt;code&gt;savetxt&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4ba4cc9227f10a44933bdf77a3096f97d9f5f23" translate="yes" xml:space="preserve">
          <source>You can also select, for example, numbers that are equal to or greater than 5, and use that condition to index an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="752bbae56b5fc445187410f0f6a25c6c5e8c7b48" translate="yes" xml:space="preserve">
          <source>You can also stack two existing arrays, both vertically and horizontally. Let&amp;rsquo;s say you have two arrays, &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5bdd1d6f2605746dfa5444603a80a8e39ed12e" translate="yes" xml:space="preserve">
          <source>You can also start the product with a value other than one:</source>
          <target state="translated">다음 이외의 값으로 제품을 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9238d7ca5ba3e22758c44fc16cfa76bade93b524" translate="yes" xml:space="preserve">
          <source>You can also start the sum with a value other than zero:</source>
          <target state="translated">0 이외의 값으로 합계를 시작할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="43992aec09e45c50ca9653d65e659c7e092c2a3a" translate="yes" xml:space="preserve">
          <source>You can also use &lt;a href=&quot;../reference/c-api/array#c.PyArrayIter_Check&quot;&gt;&lt;code&gt;PyArrayIter_Check&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt; ) to ensure you have an iterator object and &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_RESET&quot;&gt;&lt;code&gt;PyArray_ITER_RESET&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;iter&lt;/code&gt; ) to reset an iterator object back to the beginning of the array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ccb624e067361a21a322987057a6b2251b60e37" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;.transpose&lt;/code&gt; to reverse or change the axes of an array according to the values you specify.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac3d777648f5ec3ef1ae8e36503188b848922325" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;np.linspace()&lt;/code&gt; to create an array with values that are spaced linearly in a specified interval:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3aa6540779ad8ab4d81b4e53e5a83928241b43a" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;np.nonzero()&lt;/code&gt; to print the elements in an array that are less than 5 with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ef7353d852cd371f57e27ca42cd7bb34a1f070" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;np.nonzero()&lt;/code&gt; to select elements or indices from an array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4d8b024f7fd32afc4d6ac9b62bcc081732f5262" translate="yes" xml:space="preserve">
          <source>You can also use &lt;code&gt;ones()&lt;/code&gt;, &lt;code&gt;zeros()&lt;/code&gt;, and &lt;code&gt;random()&lt;/code&gt; to create a 2D array if you give them a tuple describing the dimensions of the matrix:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0508f13fcfc5d4d4f4197384c0c76abecb7ede11" translate="yes" xml:space="preserve">
          <source>You can also use indexing with arrays as a target to assign to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6a6ee70ba30827e52ff4b44c9680907b623c5f1" translate="yes" xml:space="preserve">
          <source>You can check that the above works by doing some tests; for example, inquiring about maximum and minimum values for this array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbae01da7fe0ab4f2d4dfea82533b37281dc1510" translate="yes" xml:space="preserve">
          <source>You can check whether this option was enabled when your NumPy was built by looking at the value of &lt;code&gt;np.ones((10,1),
order='C').flags.f_contiguous&lt;/code&gt;. If this is &lt;code&gt;True&lt;/code&gt;, then your NumPy has relaxed strides checking enabled.</source>
          <target state="translated">&lt;code&gt;np.ones((10,1), order='C').flags.f_contiguous&lt;/code&gt; 의 값을 확인하여 NumPy를 빌드 할 때이 옵션이 활성화되었는지 확인할 수 있습니다 . 이것이 &lt;code&gt;True&lt;/code&gt; 이면 NumPy에서 보폭 점검이 활성화 된 것입니다.</target>
        </trans-unit>
        <trans-unit id="fe0afd9f0ce26d4a6f9c3a70ea220cbcab2e663a" translate="yes" xml:space="preserve">
          <source>You can concatenate them with &lt;code&gt;np.concatenate()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b01806fc3711f6e062a40c836a2e4ff4c619a03c" translate="yes" xml:space="preserve">
          <source>You can concatenate them with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd4eede6548034f569b1dbaaa5d82af6fae75d2c" translate="yes" xml:space="preserve">
          <source>You can copy out the numpy/core/lib/npy-pkg-config directory, add a pkgdir value to the .ini files and set NPY_PKG_CONFIG_PATH environment variable to point to the directory with the modified npy-pkg-config files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf631609d9ad3a3be35567a5fc91badfdcb1e34f" translate="yes" xml:space="preserve">
          <source>You can create a new array from a section of your array any time by specifying where you want to slice your array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f31cea59b1e43f33f7c2fbd9d2de6a5a9de225c9" translate="yes" xml:space="preserve">
          <source>You can create an array with a range of elements:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f727d609d02021feb25c56ec5c7d4115e505da2" translate="yes" xml:space="preserve">
          <source>You can do all this with &lt;code&gt;slice()&lt;/code&gt; plus a few special objects, but there&amp;rsquo;s a lot to remember and this version is simpler because it uses the standard array indexing syntax.</source>
          <target state="translated">&lt;code&gt;slice()&lt;/code&gt; 와 몇 가지 특수 객체를 사용 하여이 모든 작업을 수행 할 수 있지만 기억해야 할 것이 많으며이 버전은 표준 배열 인덱싱 구문을 사용하기 때문에 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="5baf46913d5b2195b4f107095bd793625fa95842" translate="yes" xml:space="preserve">
          <source>You can do these arithmetic operations on matrices of different sizes, but only if one matrix has only one column or one row. In this case, NumPy will use its broadcast rules for the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d172f1e6eacc137cdecc574b47f944d3853d107" translate="yes" xml:space="preserve">
          <source>You can do this automatically using the &lt;code&gt;wheel-uploader&lt;/code&gt; script from &lt;a href=&quot;https://github.com/MacPython/terryfy&quot;&gt;https://github.com/MacPython/terryfy&lt;/a&gt;. Here is the recommended incantation for downloading all the Windows, Manylinux, OSX wheels and uploading to PyPI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c3d2c0245b4b7321ec5c2ca8eeee38ba0ad8e7" translate="yes" xml:space="preserve">
          <source>You can easily print all of the values in the array that are less than 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c63f33a9113ffa6279f9b313654b4abb853aa2e" translate="yes" xml:space="preserve">
          <source>You can easily reverse only the &lt;em&gt;rows&lt;/em&gt; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee6ef35316335a7f1cb11120168c98209d725a17" translate="yes" xml:space="preserve">
          <source>You can easily save it as a .csv file with the name &amp;ldquo;new_file.csv&amp;rdquo; like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82504198a2e983dc31c81d0f6dc83440d487c0e7" translate="yes" xml:space="preserve">
          <source>You can easily save your dataframe with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39be9a99e649b46efd47c1047b3ed1ee3dd34d76" translate="yes" xml:space="preserve">
          <source>You can easily use create a new array from a section of an existing array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51adde44a6a18def3f2148c58a74d0ae15f40b43" translate="yes" xml:space="preserve">
          <source>You can edit this file directly or you can use the &lt;code&gt;git config --global&lt;/code&gt; command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="535e7d83a0f12ecc49312cf2783284d9e2baf7c7" translate="yes" xml:space="preserve">
          <source>You can even use this notation for object methods and objects themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857a3e3d8c565a0a807995e6a2a380421127866a" translate="yes" xml:space="preserve">
          <source>You can explicitly convert a 1D array with either a row vector or a column vector using &lt;code&gt;np.newaxis&lt;/code&gt;. For example, you can convert a 1D array to a row vector by inserting an axis along the first dimension:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd190ae92f562a96f20ce99a02b9ac7ab128e4c8" translate="yes" xml:space="preserve">
          <source>You can find all of the installation details in the &lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;Installation&lt;/a&gt; section at &lt;a href=&quot;https://www.scipy.org&quot;&gt;SciPy&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdb9e7ae57ffac28af422f704a853be72766092f" translate="yes" xml:space="preserve">
          <source>You can find larger planned and in-progress documentation improvement ideas &lt;a href=&quot;https://github.com/orgs/numpy/projects/2&quot;&gt;at our GitHub project&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d25b50e70c597602f22d56000431ce6c81fbbbbd" translate="yes" xml:space="preserve">
          <source>You can find the unique elements in an array easily with &lt;code&gt;np.unique&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64a20c17cabe71b9adc6b2c4871ae4565e9a4af0" translate="yes" xml:space="preserve">
          <source>You can find unique values with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79ef56c8153fa2d24dc577d3e3a0d47ca828d769" translate="yes" xml:space="preserve">
          <source>You can generate a 2 x 4 array of random integers between 0 and 4 with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74c28c5a8bb3004bf7dc11f9275ff87a6627fca1" translate="yes" xml:space="preserve">
          <source>You can get these on your own machine with (e.g) &lt;code&gt;git help push&lt;/code&gt; or (same thing) &lt;code&gt;git push --help&lt;/code&gt;, but, for convenience, here are the online manual pages for some common commands:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11c41f32976f77408fe3afa43f6236aa2549ca0d" translate="yes" xml:space="preserve">
          <source>You can have standard vectors or row/column vectors if you like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3e24545eb2cdf1492fbe6a370874d4d2e482730" translate="yes" xml:space="preserve">
          <source>You can index and slice NumPy arrays in the same ways you can slice Python lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3c985751eeed6dac2e78c9a7702d8c0bef18d7e8" translate="yes" xml:space="preserve">
          <source>You can look at the following example to see how to use boolean indexing to generate an image of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Mandelbrot_set&quot;&gt;Mandelbrot set&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9537b5cf6ada6aee9b0e48c656db4298fbb1ca" translate="yes" xml:space="preserve">
          <source>You can obtain information about the function:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9ed554e08c6a0f3f56e82961f904108ee6fc5a8" translate="yes" xml:space="preserve">
          <source>You can pass Python lists of lists to create a 2-D array (or &amp;ldquo;matrix&amp;rdquo;) to represent them in NumPy.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c33e63092f2c81ef7ef464c8978156a4abec7928" translate="yes" xml:space="preserve">
          <source>You can pass the &lt;code&gt;return_counts&lt;/code&gt; argument in &lt;code&gt;np.unique()&lt;/code&gt; along with your array to get the frequency count of unique values in a NumPy array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dc811f9e51cddee6cdcd6b73d03c1376a565596" translate="yes" xml:space="preserve">
          <source>You can quickly and easily load your saved text file using &lt;code&gt;loadtxt()&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd99805037851e24542e0c190c949f7441fdb05e" translate="yes" xml:space="preserve">
          <source>You can quickly sort the numbers in ascending order with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbabee0d2a8ad11c2e5d1a9374dba3d5de22c5c5" translate="yes" xml:space="preserve">
          <source>You can reach another level of information by reading the source code of the object you&amp;rsquo;re interested in. Using a double question mark (&lt;code&gt;??&lt;/code&gt;) allows you to access the source code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="525e57a42eaa3f05d626e2a1e78e1405cd0f56c6" translate="yes" xml:space="preserve">
          <source>You can report issues to the NumPy Code of Conduct committee, at &lt;a href=&quot;mailto:numpy-conduct%40googlegroups.com&quot;&gt;numpy-conduct@googlegroups.com&lt;/a&gt;. Currently, the committee consists of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="411581b4a2c33f96f2e50370cca530bb14494a68" translate="yes" xml:space="preserve">
          <source>You can reverse it with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91c836df02cbd1f82e91ec4724342db42d32dc07" translate="yes" xml:space="preserve">
          <source>You can reverse the content in all of the rows and all of the columns with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58f703b8270c8a067823a77d7af5bf7887ff76f" translate="yes" xml:space="preserve">
          <source>You can run examples as doctests using:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca40d20f8092fec5dfdca584f23e5b003136ab53" translate="yes" xml:space="preserve">
          <source>You can save a NumPy array as a plain text file like a &lt;strong&gt;.csv&lt;/strong&gt; or &lt;strong&gt;.txt&lt;/strong&gt; file with &lt;code&gt;np.savetxt&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="638da3aef28233421c8588fb61e4dfac171499ee" translate="yes" xml:space="preserve">
          <source>You can save it as &amp;ldquo;filename.npy&amp;rdquo; with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="13c816c29bd6c6d8cea0adad71c911999f0f8043" translate="yes" xml:space="preserve">
          <source>You can see that we have selected only the first &lt;code&gt;k&lt;/code&gt; components of the last axis for &lt;code&gt;Sigma&lt;/code&gt; (this means that we have used only the first &lt;code&gt;k&lt;/code&gt; columns of each of the three matrices in the stack), and that we have selected only the first &lt;code&gt;k&lt;/code&gt; components in the second-to-last axis of &lt;code&gt;Vt&lt;/code&gt; (this means we have selected only the first &lt;code&gt;k&lt;/code&gt; rows from every matrix in the stack &lt;code&gt;Vt&lt;/code&gt; and all columns). If you are unfamiliar with the ellipsis syntax, it is a placeholder for other axes. For more details, see the documentation on &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;Indexing&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa597ab231ed849826c68828e374dfe531ab8bfd" translate="yes" xml:space="preserve">
          <source>You can select elements that are divisible by 2:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b64cb650b0721919b112892ec7540fa3bec8f6" translate="yes" xml:space="preserve">
          <source>You can specify on which axis you want the aggregation function to be computed. For example, you can find the minimum value within each column by specifying &lt;code&gt;axis=0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f8d7cd5b1c8277145559102abee3f2cfb118c0" translate="yes" xml:space="preserve">
          <source>You can split an array into several smaller arrays using &lt;code&gt;hsplit&lt;/code&gt;. You can specify either the number of equally shaped arrays to return or the columns &lt;em&gt;after&lt;/em&gt; which the division should occur.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1737c7d22dd82b8a49628f21daf3b7f42db2f600" translate="yes" xml:space="preserve">
          <source>You can stack them vertically with &lt;code&gt;vstack&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="359027a8fcd07ccbd6d51b7568b15e7088674160" translate="yes" xml:space="preserve">
          <source>You can sum the columns with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e198e975b5d6fbfd387d7792f57d05cf99229ac" translate="yes" xml:space="preserve">
          <source>You can sum the rows with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f8dcdc8f58eab438163b027ae1026e44d575bec" translate="yes" xml:space="preserve">
          <source>You can tell Numpy to use 64-bit BLAS/LAPACK libraries by setting the environment variable:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8032e81ac40a6f0f1a73b54a1b7839b994061479" translate="yes" xml:space="preserve">
          <source>You can think of reshaping as first raveling the array (using the given index order), then inserting the elements from the raveled array into the new array using the same kind of index ordering as was used for the raveling.</source>
          <target state="translated">주어진 인덱스 순서를 사용하여 배열을 먼저 래블 링 한 다음 래블 링에 사용 된 것과 동일한 종류의 인덱스 순서를 사용하여 래블 된 배열의 요소를 새 배열에 삽입하는 것으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e107150be46c6b7a2ed7f15bfecabb650a4f4c5d" translate="yes" xml:space="preserve">
          <source>You can transpose your array with &lt;code&gt;arr.transpose()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39ce4271e318082bcec3fc33c2529d0ffba9e99a" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;flatten&lt;/code&gt; to flatten your array into a 1D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2665766d0c0d10f2c049bfca0a5d2ba9b8e78f7c" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;np.expand_dims&lt;/code&gt; to add an axis at index position 1 with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3357dc9f6b41aea3aa6691cc31b9c4dd502c9267" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;np.load()&lt;/code&gt; to reconstruct your array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="918c24145c112510b6d979f3bb91283ee6145456" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;np.newaxis&lt;/code&gt; and &lt;code&gt;np.expand_dims&lt;/code&gt; to increase the dimensions of your existing array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="582146c1d768f4228d4d49948b0b6a07949fe966" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;np.newaxis&lt;/code&gt; to add a new axis:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec69deeefd01eed5f7356a6b5d80438d8d1eb727" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;np.nonzero()&lt;/code&gt; to print the indices of elements that are, for example, less than 5:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3156b813541089f8aa43cd9e531951bf582e15" translate="yes" xml:space="preserve">
          <source>You can use &lt;code&gt;reshape()&lt;/code&gt; to reshape your array. For example, you can reshape this array to an array with three rows and two columns:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1a526e2dfcefc7502bbfe7d5198a1cfd393800" translate="yes" xml:space="preserve">
          <source>You can use an initial value to compute the maximum of an empty slice, or to initialize it to a different value:</source>
          <target state="translated">초기 값을 사용하여 빈 슬라이스의 최대 값을 계산하거나 다른 값으로 초기화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a7f9c80832526780727f107f820703eff6333a" translate="yes" xml:space="preserve">
          <source>You can use arbitrary &lt;code&gt;&amp;lt;routine name&amp;gt;&lt;/code&gt; for a given Fortran/C function. Then you have to specify &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; with this statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d0bef869069e40769f21f1de600d0fc6d747dfa" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;initial&lt;/code&gt; keyword argument to initialize the reduction with a different value, and &lt;code&gt;where&lt;/code&gt; to select specific elements to include:</source>
          <target state="translated">당신이 사용할 수있는 &lt;code&gt;initial&lt;/code&gt; , 그리고 다른 값으로 감소를 초기화하는 키워드 인수를 &lt;code&gt;where&lt;/code&gt; 포함하는 특정 요소를 선택합니다 :</target>
        </trans-unit>
        <trans-unit id="23efac0b995d6e93a4035bff800bd00ab008b4c3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;view&lt;/code&gt; method to create a new array object that looks at the same data as the original array (a &lt;em&gt;shallow copy&lt;/em&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fa0d476f571316eb9194c7c7392edcc2d88959" translate="yes" xml:space="preserve">
          <source>You can use the code in &lt;code&gt;numpy.i&lt;/code&gt; to write your own typemaps. For example, if you had a five-dimensional array as a function argument, you could cut-and-paste the appropriate four-dimensional typemaps into your interface file. The modifications for the fourth dimension would be trivial.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 코드를 사용 하여 고유 한 유형 맵을 작성할 수 있습니다. 예를 들어 함수 인수로 5 차원 배열이있는 경우 적절한 4 차원 유형 맵을 잘라내어 인터페이스 파일에 붙여 넣을 수 있습니다. 네 번째 차원의 수정은 사소한 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee6cd9ad018d09a66b4b552d8d32fda830dc2b2b" translate="yes" xml:space="preserve">
          <source>You can visualize it this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a25a3e7f332f999168a07a6595359aa81fadc1bd" translate="yes" xml:space="preserve">
          <source>You can visualize your array this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ad9ee5f8f5d203d9af008ef1a29a03c8cf55b38" translate="yes" xml:space="preserve">
          <source>You can, of course, do more than just addition!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d315d7e61c47b4d65f430fab5f0eebfd96cdc410" translate="yes" xml:space="preserve">
          <source>You cannot build extension modules with this function, that is, using &lt;code&gt;-c&lt;/code&gt; is not allowed. Use &lt;code&gt;compile&lt;/code&gt; command instead</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc82621089986951aa67f2243064c2c3dc5658df" translate="yes" xml:space="preserve">
          <source>You could also implement the reduce as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce58363fd85bb854ab09669ee6f5c2f4477e67d0" translate="yes" xml:space="preserve">
          <source>You could create a Pandas dataframe</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc55f5f061c21889fbee03345308fce9d6cd1563" translate="yes" xml:space="preserve">
          <source>You have to use &lt;code&gt;--set-upstream&lt;/code&gt; for each new branch that you create.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="751135e5dcfd64fe181d4032a7968478893af08b" translate="yes" xml:space="preserve">
          <source>You may also need to switch the dimensions of a matrix. This can happen when, for example, you have a model that expects a certain input shape that is different from your dataset. This is where the &lt;code&gt;reshape&lt;/code&gt; method can be useful. You simply need to pass in the new dimensions that you want for the matrix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c888e18d08dec9ae3d9fa98ee787e808245f065" translate="yes" xml:space="preserve">
          <source>You may also want to have easy access to all pull requests sent to the NumPy repository:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa28650cb9c8a94633060dcb80be22a67fdaf333" translate="yes" xml:space="preserve">
          <source>You may also want to make sure that your editor of choice is used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0cb574f3d373b89a7c21d2c97860f79643815e" translate="yes" xml:space="preserve">
          <source>You may also want to register low-level ufunc loops for your data-type so that an ndarray of your data-type can have math applied to it seamlessly. Registering a new loop with exactly the same arg_types signature, silently replaces any previously registered loops for that data-type.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7050d9d1fdb3bbac0ba025f332165a7313a2c595" translate="yes" xml:space="preserve">
          <source>You may have a correctly specified array dtype, but you need the array to have the opposite byte order in memory, and you want the dtype to match so the array values make sense. In this case you just do both of the previous operations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc93d11c84f3cf0c80dc19552fbebbaec3165a7a" translate="yes" xml:space="preserve">
          <source>You may include some math:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98e9f88bd4a89aebe54d98a979717885fd9d0412" translate="yes" xml:space="preserve">
          <source>You may use slicing to set values in the array, but (unlike lists) you can never grow the array. The size of the value to be set in &lt;code&gt;x[obj] = value&lt;/code&gt; must be (broadcastable) to the same shape as &lt;code&gt;x[obj]&lt;/code&gt;.</source>
          <target state="translated">슬라이싱을 사용하여 배열에 값을 설정할 수 있지만 목록과 달리 배열을 늘릴 수는 없습니다. 값의 크기를 설정한다 &lt;code&gt;x[obj] = value&lt;/code&gt; 과 동일한 형상 (캐스트 가능한)이어야 &lt;code&gt;x[obj]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="953ce32a13466f3c18c7daad4b9f88ea1d2c5786" translate="yes" xml:space="preserve">
          <source>You may want to allow builtin (and other user-defined) data-types to be cast automatically to your data-type. In order to make this possible, you must register a casting function with the data-type you want to be able to cast from. This requires writing low-level casting functions for each conversion you want to support and then registering these functions with the data-type descriptor. A low-level casting function has the signature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e38d04c287113098b3a4cbd709911d025d4509" translate="yes" xml:space="preserve">
          <source>You may want to take a section of your array or specific array elements to use in further analysis or additional operations. To do that, you&amp;rsquo;ll need to subset, slice, and/or index your arrays.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c09ca0043df118c7d46ae9f54f1af08b9fd4e55b" translate="yes" xml:space="preserve">
          <source>You might occasionally hear an array referred to as a &amp;ldquo;ndarray,&amp;rdquo; which is shorthand for &amp;ldquo;N-dimensional array.&amp;rdquo; An N-dimensional array is simply an array with any number of dimensions. You might also hear &lt;strong&gt;1-D&lt;/strong&gt;, or one-dimensional array, &lt;strong&gt;2-D&lt;/strong&gt;, or two-dimensional array, and so on. The NumPy &lt;code&gt;ndarray&lt;/code&gt; class is used to represent both matrices and vectors. A &lt;strong&gt;vector&lt;/strong&gt; is an array with a single dimension (there&amp;rsquo;s no difference between row and column vectors), while a &lt;strong&gt;matrix&lt;/strong&gt; refers to an array with two dimensions. For &lt;strong&gt;3-D&lt;/strong&gt; or higher dimensional arrays, the term &lt;strong&gt;tensor&lt;/strong&gt; is also commonly used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50b94c625d2f8ec709ed8784bad70dc63767a95c" translate="yes" xml:space="preserve">
          <source>You might run into some conflicts cherry picking here. These are resolved the same way as merge/rebase conflicts. Except here you can use &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-blame.html&quot;&gt;git blame&lt;/a&gt; to see the difference between master and the backported branch to make sure nothing gets screwed up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9946ceacebb206bc39fdb0ab02e7ae2fd4130a" translate="yes" xml:space="preserve">
          <source>You might want to do this if you need the data in memory to be a certain ordering. For example you might be writing the memory out to a file that needs a certain byte ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135c8b6e87a57f29b421c9f6622548e64c5c181b" translate="yes" xml:space="preserve">
          <source>You might well benefit from some aliases to common commands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6cadaf59551ba845503a005299c5c807cc4a0a" translate="yes" xml:space="preserve">
          <source>You must have shared-libraries of your code (no static libraries).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f72c989cc6f569ebbcaf3dc420d3b1a100bb4f" translate="yes" xml:space="preserve">
          <source>You need to do this only once. The instructions here are very similar to the instructions at &lt;a href=&quot;http://help.github.com/forking/&quot;&gt;http://help.github.com/forking/&lt;/a&gt; - please see that page for more detail. We&amp;rsquo;re repeating some of it here just to give the specifics for the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; project, and to suggest some default names.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59e40ad02adcd2c691240b758a6d5e9b9fe95316" translate="yes" xml:space="preserve">
          <source>You now have a copy of the code tree in the new &lt;code&gt;numpy&lt;/code&gt; directory. If this doesn&amp;rsquo;t work you can try the alternative read-only url:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d82a2ce6cf2dc0d704ac1ff16739b75bf2b960c" translate="yes" xml:space="preserve">
          <source>You should be able to run this command assuming your search-path is set-up properly. This command will produce an extension module named addmodule.c in the current directory. This extension module can now be compiled and used from Python just like any other extension module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3568ae4f766e37d7c5effd4c8f672ee7bd5f8ce" translate="yes" xml:space="preserve">
          <source>You should note that, while included in the table for completeness, the &amp;lsquo;S&amp;rsquo;, &amp;lsquo;U&amp;rsquo;, and &amp;lsquo;V&amp;rsquo; types cannot be operated on by ufuncs. Also, note that on a 32-bit system the integer types may have different sizes, resulting in a slightly altered table.</source>
          <target state="translated">완전성을 위해 표에 포함되어 있지만 'S', 'U'및 'V'유형은 ufunc에 의해 조작 될 수 없습니다. 또한 32 비트 시스템에서 정수 유형의 크기가 다를 수 있으므로 테이블이 약간 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48e2566d73e02efbbc4b632bf5542ec3c76e7927" translate="yes" xml:space="preserve">
          <source>You should upload the wheels first, and the source formats last, to make sure that pip users don&amp;rsquo;t accidentally get a source install when they were expecting a binary wheel.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f94ae48a7f12ec74a463a4d1b3c1e155565e461" translate="yes" xml:space="preserve">
          <source>You should upload your public gpg key to github, so that the tag will appear &amp;ldquo;verified&amp;rdquo; there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5dfeab052b2a1f77650e75e63cd47d30c89d3e" translate="yes" xml:space="preserve">
          <source>You then need to configure your account to allow write access - see the &lt;code&gt;Generating SSH keys&lt;/code&gt; help on &lt;a href=&quot;https://help.github.com&quot;&gt;github help&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f357b2fe6ddb759961311e43e7970103d0b441f0" translate="yes" xml:space="preserve">
          <source>You will also need to add the tests directory in the configuration section of your setup.py:</source>
          <target state="translated">setup.py의 구성 섹션에 tests 디렉토리를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="e6a2d166af691548288af8a6c8b8422e8888e7ff" translate="yes" xml:space="preserve">
          <source>You will need Cython for building the binaries. Cython compiles the &lt;code&gt;.pyx&lt;/code&gt; files in the NumPy distribution to &lt;code&gt;.c&lt;/code&gt; files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60c5c8338d5ce273cc0c97b17a9b0c03f3cdfef9" translate="yes" xml:space="preserve">
          <source>You will need a personal access token &lt;a href=&quot;https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/&quot;&gt;https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/&lt;/a&gt; so that scripts can access the github NumPy repository.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f2ad787d36eeaf353182285e56b32b7dd3f0a6d" translate="yes" xml:space="preserve">
          <source>You will need to have Latex installed for this, inclusive of support for Greek letters. For example, on Ubuntu xenial &lt;code&gt;texlive-lang-greek&lt;/code&gt; and &lt;code&gt;cm-super&lt;/code&gt; are needed. Also &lt;code&gt;latexmk&lt;/code&gt; is needed on non-Windows systems.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="415b6aea89a48afb144b14ce0c80902b0ffbaf9f" translate="yes" xml:space="preserve">
          <source>You will need write permission for numpy-wheels in order to trigger wheel builds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216a02cebcf00a1b32e4ce807da6752227f99dbc" translate="yes" xml:space="preserve">
          <source>You will, at some point, want to save your arrays to disk and load them back without having to re-run the code. Fortunately, there are several ways to save and load objects with NumPy. The ndarray objects can be saved to and loaded from the disk files with &lt;code&gt;loadtxt&lt;/code&gt; and &lt;code&gt;savetxt&lt;/code&gt; functions that handle normal text files, &lt;code&gt;load&lt;/code&gt; and &lt;code&gt;save&lt;/code&gt; functions that handle NumPy binary files with a &lt;strong&gt;.npy&lt;/strong&gt; file extension, and a &lt;code&gt;savez&lt;/code&gt; function that handles NumPy files with a &lt;strong&gt;.npz&lt;/strong&gt; file extension.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b7b74c10de119d207f3d55f6aca0d065a7b12c2" translate="yes" xml:space="preserve">
          <source>Your NumPy version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2af06179f1b8740f992cc77cae66af896533cdbc" translate="yes" xml:space="preserve">
          <source>Your Python version</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940843b0141e7785b2af30902bf00aeaed17ff7c" translate="yes" xml:space="preserve">
          <source>Your array has 2 axes. The first axis has a length of 2 and the second axis has a length of 3.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65606e148ee4a2cdae9cd01bdb2428ea4938c95f" translate="yes" xml:space="preserve">
          <source>Your collaborators can then commit directly into that repo with the usual:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79b0006a3de24b4b7dc6ff2cd7d352f84f3e4b76" translate="yes" xml:space="preserve">
          <source>Your config file should now look something like (from &lt;code&gt;$ cat .git/config&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="521de696e9a3419886283bc12ee7028ed6d2ec64" translate="yes" xml:space="preserve">
          <source>Your data and dtype endianness don&amp;rsquo;t match, and you want to change the dtype so that it matches the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8e64747c17b40a4b5d00783d37da934474788f" translate="yes" xml:space="preserve">
          <source>Your data and dtype endianness don&amp;rsquo;t match, and you want to swap the data so that they match the dtype</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ed0a2c588bf7e44fda3064d79e5f46f92a82610" translate="yes" xml:space="preserve">
          <source>Your data and dtype endianness match, but you want the data swapped and the dtype to reflect this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7febce3ef062310b05f44f84bd0843f7e336a1" translate="yes" xml:space="preserve">
          <source>Your personal &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; configurations are saved in the &lt;code&gt;.gitconfig&lt;/code&gt; file in your home directory. Here is an example &lt;code&gt;.gitconfig&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="909f99a779adb66a76fc53ab56c7dd1caf35d0fd" translate="yes" xml:space="preserve">
          <source>Z</source>
          <target state="translated">Z</target>
        </trans-unit>
        <trans-unit id="1e16810e3242991af56a001ed6a884d632c200f8" translate="yes" xml:space="preserve">
          <source>Zero matrix of given shape, dtype, and order.</source>
          <target state="translated">주어진 모양, dtype 및 순서의 제로 행렬.</target>
        </trans-unit>
        <trans-unit id="e45e696eb3d4f02d39791369c3d3958a76ab90d1" translate="yes" xml:space="preserve">
          <source>Zero matrix.</source>
          <target state="translated">제로 매트릭스.</target>
        </trans-unit>
        <trans-unit id="d5dc63474aa23584e657281af8b854e50d810b87" translate="yes" xml:space="preserve">
          <source>Zero padding. Outside bounds values will be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc9379a72db3a8937472e62bd1e9326e04e14e35" translate="yes" xml:space="preserve">
          <source>Zero-padding, analogously with &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, is performed by appending zeros to the input along the specified dimension. Although this is the common approach, it might lead to surprising results. If another form of zero padding is desired, it must be performed before &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 제로 패딩 은 지정된 치수를 따라 입력에 0을 추가하여 수행됩니다. 이것이 일반적인 접근법이지만 놀라운 결과를 초래할 수 있습니다. 다른 형태의 제로 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt; 를 호출 하기 전에 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="64a64c98f6885c75110c036526d556b9a4c44be0" translate="yes" xml:space="preserve">
          <source>Zero-padding, analogously with &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, is performed by appending zeros to the input along the specified dimension. Although this is the common approach, it might lead to surprising results. If another form of zero padding is desired, it must be performed before &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 제로 패딩 은 지정된 치수를 따라 입력에 0을 추가하여 수행됩니다. 이것이 일반적인 접근법이지만 놀라운 결과를 초래할 수 있습니다. 다른 형태의 제로 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; 을 호출 하기 전에 수행해야합니다 .</target>
        </trans-unit>
        <trans-unit id="517f56a81e423e64373bd116eb0759a041c8ad2f" translate="yes" xml:space="preserve">
          <source>Zeros are returned for slices that are all-NaN or empty.</source>
          <target state="translated">all-NaN이거나 비어있는 슬라이스에 대해서는 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acacd887197bd2babb7be61e73a56d1f99561e0f" translate="yes" xml:space="preserve">
          <source>Zipf, G. K., &amp;ldquo;Selected Studies of the Principle of Relative Frequency in Language,&amp;rdquo; Cambridge, MA: Harvard Univ. Press, 1932.</source>
          <target state="translated">Zipf, GK, &quot;언어의 상대적 주파수 원리에 대한 선택된 연구&quot;, 케임브리지, MA : Harvard Univ. 1932 년을 누르십시오.</target>
        </trans-unit>
        <trans-unit id="ed86773f64d57f9b3c7ee4020ed0f191241f3769" translate="yes" xml:space="preserve">
          <source>[ 1678 AD, 2262 AD]</source>
          <target state="translated">[AD 1678 AD, 2262 AD]</target>
        </trans-unit>
        <trans-unit id="402b4dc5670a23bc318ab3cb00cdc7fa9f64de7f" translate="yes" xml:space="preserve">
          <source>[ 1969 AD, 1970 AD]</source>
          <target state="translated">[1969 AD, 1970 AD]</target>
        </trans-unit>
        <trans-unit id="bd183430653087be5ae12502c45fc000d3da0d92" translate="yes" xml:space="preserve">
          <source>[ 2.9e8 BC, 2.9e8 AD]</source>
          <target state="translated">[2.9e8 BC, 2.9e8 AD]</target>
        </trans-unit>
        <trans-unit id="dc7f3e791b46510c11bbde8e0bb893651cf79bee" translate="yes" xml:space="preserve">
          <source>[1.0e15 BC, 1.0e15 AD]</source>
          <target state="translated">[1.0e15 BC, 1.0e15 AD]</target>
        </trans-unit>
        <trans-unit id="06a7557ae8ce0cfbe48cae36c42a5043941673e5" translate="yes" xml:space="preserve">
          <source>[1.7e13 BC, 1.7e13 AD]</source>
          <target state="translated">[1.7e13 BC, 1.7e13 AD]</target>
        </trans-unit>
        <trans-unit id="d122eae6bae0b58d08b1fd88854423fb5b4631e6" translate="yes" xml:space="preserve">
          <source>[1.7e17 BC, 1.7e17 AD]</source>
          <target state="translated">[1.7e17 BC, 1.7e17 AD]</target>
        </trans-unit>
        <trans-unit id="af9678a88e0692bf413856f430540a50579b7921" translate="yes" xml:space="preserve">
          <source>[2.5e16 BC, 2.5e16 AD]</source>
          <target state="translated">[2.5e16 BC, 2.5e16 AD]</target>
        </trans-unit>
        <trans-unit id="fb54cef9abe0ffb09a025ee28bfe888680b86ee0" translate="yes" xml:space="preserve">
          <source>[2.9e11 BC, 2.9e11 AD]</source>
          <target state="translated">[2.9e11 BC, 2.9e11 AD]</target>
        </trans-unit>
        <trans-unit id="9b1e4a9e31badd5faa858bd32af6c4bab33690b0" translate="yes" xml:space="preserve">
          <source>[290301 BC, 294241 AD]</source>
          <target state="translated">[290301 BC, 294241 AD]</target>
        </trans-unit>
        <trans-unit id="2212219fa92d0d55a2e83f844d81d7dc4a36dd7d" translate="yes" xml:space="preserve">
          <source>[7.6e17 BC, 7.6e17 AD]</source>
          <target state="translated">[7.6e17 BC, 7.6e17 AD]</target>
        </trans-unit>
        <trans-unit id="7855213bc11a8db7fc6daa3f131f06c9977a3960" translate="yes" xml:space="preserve">
          <source>[9.2e18 BC, 9.2e18 AD]</source>
          <target state="translated">[9.2e18 BC, 9.2e18 AD]</target>
        </trans-unit>
        <trans-unit id="faf24ac10ab74f225b601311df4355d76763fa97" translate="yes" xml:space="preserve">
          <source>[CT]</source>
          <target state="translated">[CT]</target>
        </trans-unit>
        <trans-unit id="7d2f4bdb1926f2cbbdd65bcf6b74603f5acdf8c8" translate="yes" xml:space="preserve">
          <source>[G]</source>
          <target state="translated">[G]</target>
        </trans-unit>
        <trans-unit id="3d6c6c6111149819e43b6089c9a7b9c8a2431938" translate="yes" xml:space="preserve">
          <source>[NR]</source>
          <target state="translated">[NR]</target>
        </trans-unit>
        <trans-unit id="1b8941d3b1d081473898f4b2e4a8ff850cc6de82" translate="yes" xml:space="preserve">
          <source>[R5cc1f1f25381-1]</source>
          <target state="translated">[R5cc1f1f25381-1]</target>
        </trans-unit>
        <trans-unit id="0c4d5826769047e816879e0f7216ecf388ea499b" translate="yes" xml:space="preserve">
          <source>[Re860718f5533-1]</source>
          <target state="translated">[Re860718f5533-1]</target>
        </trans-unit>
        <trans-unit id="6b6f9491cb308db36a45d25a8dcf1db55932e083" translate="yes" xml:space="preserve">
          <source>[WRW]</source>
          <target state="translated">[WRW]</target>
        </trans-unit>
        <trans-unit id="ff244a354c248341a7c0c68812d2513231ccfc0a" translate="yes" xml:space="preserve">
          <source>__abs__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c4b5bf4744a7442f73005c1fe439a869d4912cf" translate="yes" xml:space="preserve">
          <source>__add__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6678ac2d33e0e869b460789a44fcc1898b470174" translate="yes" xml:space="preserve">
          <source>__and__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d11e11f5da3e629ed021ca7c69b3e1560e48dc7" translate="yes" xml:space="preserve">
          <source>__array__() (numpy.class method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3897c72013a6887de9a1de9869c3e948fd9696d2" translate="yes" xml:space="preserve">
          <source>__array_data__</source>
          <target state="translated">__array_data__</target>
        </trans-unit>
        <trans-unit id="81f5d0f249cae6e54a5453d7972fcd0943accd0e" translate="yes" xml:space="preserve">
          <source>__array_descr__</source>
          <target state="translated">__array_descr__</target>
        </trans-unit>
        <trans-unit id="71c1674de3ef7b1b98cc9d6fe1997049bf59be3a" translate="yes" xml:space="preserve">
          <source>__array_finalize__ (ndarray attribute)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f36773cdfd15c6cb88da726f7af67270582d5e8" translate="yes" xml:space="preserve">
          <source>__array_finalize__() (numpy.class method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea410ff45968c207a24de940975e7ab4957e592" translate="yes" xml:space="preserve">
          <source>__array_function__() (numpy.class method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0a201183273449f8bd82be2d062468aa25df323" translate="yes" xml:space="preserve">
          <source>__array_interface__</source>
          <target state="translated">__array_interface__</target>
        </trans-unit>
        <trans-unit id="5e8cd5fbc938886a9b24f4ad582e1858af233bd3" translate="yes" xml:space="preserve">
          <source>__array_interface__ (built-in variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a9ff3eb9a1e79e8a4cdf02304244a5327adcb47" translate="yes" xml:space="preserve">
          <source>__array_mask__</source>
          <target state="translated">__array_mask__</target>
        </trans-unit>
        <trans-unit id="ac7e7fcdcffb075d0e09e72d92d910d4b9351cdb" translate="yes" xml:space="preserve">
          <source>__array_offset__</source>
          <target state="translated">__array_offset__</target>
        </trans-unit>
        <trans-unit id="9c741cad077927490ce59ac67b73a774e6f89174" translate="yes" xml:space="preserve">
          <source>__array_prepare__() (numpy.class method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="706e28500d6f6f91b4ccffa7a37375935df27ebf" translate="yes" xml:space="preserve">
          <source>__array_priority__ (ndarray attribute)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="238f299c155456fe6a848580f0ef9d3e6bb2a8de" translate="yes" xml:space="preserve">
          <source>__array_shape__</source>
          <target state="translated">__array_shape__</target>
        </trans-unit>
        <trans-unit id="2f3678a5595fd628d8dfae6d631c1ae1fb6ef8da" translate="yes" xml:space="preserve">
          <source>__array_strides__</source>
          <target state="translated">__array_strides__</target>
        </trans-unit>
        <trans-unit id="a6b58a1617079ec0d71beb11f7ad2a32fbc5e31b" translate="yes" xml:space="preserve">
          <source>__array_struct__ (C variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa0ad955aed8601e1764fbffe3d43f4a00fe14f0" translate="yes" xml:space="preserve">
          <source>__array_typestr__</source>
          <target state="translated">__array_typestr__</target>
        </trans-unit>
        <trans-unit id="fe002ec6f40f1ef39f555bc8098b8ae17664e460" translate="yes" xml:space="preserve">
          <source>__array_ufunc__() (numpy.class method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9314342a46890bf2effc2cd0ca7ae9d86fbab2ab" translate="yes" xml:space="preserve">
          <source>__array_wrap__ (ndarray attribute)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7119e49dd617e61e14c792d40e73cfaea33b58e9" translate="yes" xml:space="preserve">
          <source>__array_wrap__() (numpy.class method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7db20120a72ce06d646b6c6dcd5425b26c3e5960" translate="yes" xml:space="preserve">
          <source>__bool__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="742d6d7ad7e950adf0baeb3840475b9697d5247f" translate="yes" xml:space="preserve">
          <source>__call__() (numpy.errstate method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f6ad5a08ff5c43656e00a478c5d881e4d9bde2" translate="yes" xml:space="preserve">
          <source>__complex__() (numpy.ndarray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61d9f3d63c64e0c9246b6b0759acaa297a1b63f8" translate="yes" xml:space="preserve">
          <source>__contains__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21b97c4598a5c0f08b4e43cb110d60055e0a0d83" translate="yes" xml:space="preserve">
          <source>__copy__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a34abc5b8589cb006e5abec3e19f45834f3e0e" translate="yes" xml:space="preserve">
          <source>__deepcopy__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a0a2759a904d07b0a7f6382ee4cb135c42fa55" translate="yes" xml:space="preserve">
          <source>__delitem__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5f06b8d2741eb0c9a9ecfd96f7b29f8d327af99" translate="yes" xml:space="preserve">
          <source>__div__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b169bb83bc3ef64127b9f9631edac78b95e2d9c" translate="yes" xml:space="preserve">
          <source>__divmod__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1071dfb4883bb317f4e15ad7285cdfb11590aa50" translate="yes" xml:space="preserve">
          <source>__eq__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c6cd4c9dd6a2fae960042d008df97b84cc1a6b1" translate="yes" xml:space="preserve">
          <source>__float__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2adcf577bd06d86d393f4b6f82348f709b3f8e" translate="yes" xml:space="preserve">
          <source>__floordiv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6e6576e79eed92b062f178480f9c2e44357d26" translate="yes" xml:space="preserve">
          <source>__ge__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80c999b96cc2bf42febefc3267bbe623bb9a52fc" translate="yes" xml:space="preserve">
          <source>__getitem__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e67304b2966a9b24180761c372d7eb62eeca03d" translate="yes" xml:space="preserve">
          <source>__getstate__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee5a3430f0fc150d7881667230bccd9504f8ee6a" translate="yes" xml:space="preserve">
          <source>__gt__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="204154f473ba4a7a760c5ad53c9c1bfd3f780935" translate="yes" xml:space="preserve">
          <source>__iadd__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44c25ee9237277db9c3dc3837dd82885f32e9fc8" translate="yes" xml:space="preserve">
          <source>__iand__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b055ab67a5399205f992368c23e87a148e6bbc" translate="yes" xml:space="preserve">
          <source>__idiv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12b013739c6f2ab8fb38abdf48c556c9bdf72b74" translate="yes" xml:space="preserve">
          <source>__ifloordiv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2d0a20aaef82c1babb5e3f281fe1652445774c47" translate="yes" xml:space="preserve">
          <source>__ilshift__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ca6ec10e7e5c3ac6eed2fb2cd7983e511913fe0" translate="yes" xml:space="preserve">
          <source>__imod__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcfdd1ea7808e804d0d2de3b684e5a40b37c73f" translate="yes" xml:space="preserve">
          <source>__imul__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3179c7957be9626d543af54227ef33447db811f" translate="yes" xml:space="preserve">
          <source>__int__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0dcc5bfffa92fe686ee5601d0a55f2cbe2e7e00b" translate="yes" xml:space="preserve">
          <source>__invert__() (numpy.ndarray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f323a0176a30dc3806b3599ffb801b61f49118fc" translate="yes" xml:space="preserve">
          <source>__ior__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a6fd1b32704d7df8f2c671be50224b0ddfd417" translate="yes" xml:space="preserve">
          <source>__ipow__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac284929d6d2841bfb35a4fc881ba98436475838" translate="yes" xml:space="preserve">
          <source>__irshift__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb8d45f2d79b80bca777b8b65a1856160e35d3a7" translate="yes" xml:space="preserve">
          <source>__isub__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b97aded6fce6da14ed1886d654538a1d7346166" translate="yes" xml:space="preserve">
          <source>__itruediv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f20873859cc72218063eb2e99f7b3c635fc1ccd7" translate="yes" xml:space="preserve">
          <source>__ixor__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ab3b0671db0345ffc637119c88027677042a2e0" translate="yes" xml:space="preserve">
          <source>__le__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9db981374fe27550138235e60768f22b6087d62" translate="yes" xml:space="preserve">
          <source>__len__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8f86a204e8f36c3b1605f234d01078ebd148b7d" translate="yes" xml:space="preserve">
          <source>__lshift__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e27c1e077f869be7cdb6f17caf4c2c4a42f50ef" translate="yes" xml:space="preserve">
          <source>__lt__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c72867d9219621c6d7aebcdaf258be66c2e7606" translate="yes" xml:space="preserve">
          <source>__matmul__() (numpy.ndarray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46bca0791556e71757947e4ae551298c9d9d302b" translate="yes" xml:space="preserve">
          <source>__mod__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44df3a889306e1d1dad4c705432c35ffa9dc253c" translate="yes" xml:space="preserve">
          <source>__mul__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edd530853ee5c7448a61802ef2a7bb2f316160d" translate="yes" xml:space="preserve">
          <source>__ne__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5d965082672e1ab3fccd5a35532509bcb204b3d" translate="yes" xml:space="preserve">
          <source>__neg__() (numpy.ndarray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="874bc1e2d2304a0c375c91f465e9606decc5489c" translate="yes" xml:space="preserve">
          <source>__new__() (numpy.ma.MaskedArray static method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2bc0efd8d9d9a7c9de047094bcea8ea3b6016f4" translate="yes" xml:space="preserve">
          <source>__or__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2c492f3eb1f3fb77459cd594dbb68e47052569d" translate="yes" xml:space="preserve">
          <source>__pos__() (numpy.ndarray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56ed35d1abe325c67368c19e29ec90342247a382" translate="yes" xml:space="preserve">
          <source>__pow__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d5fff8a498554189fe8f227b7b8fdd3ac26b033" translate="yes" xml:space="preserve">
          <source>__radd__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d47b34763f0ab824f7faa9c38739259d9776ba95" translate="yes" xml:space="preserve">
          <source>__rand__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e87f9e2f2c5840cec279964e71d7abfcf560d0" translate="yes" xml:space="preserve">
          <source>__rdivmod__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8f51120e253e84c609118bd38acc582cef0a098" translate="yes" xml:space="preserve">
          <source>__reduce__() (numpy.dtype method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e0aa284749252147e3e1f6388777dc57b0de5d9" translate="yes" xml:space="preserve">
          <source>__repr__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28754dd8ed99e36f8650c5c8c3991d308f1c4f57" translate="yes" xml:space="preserve">
          <source>__rfloordiv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f7b8ba6a95412da6684ff730f2a3413dbf233cc" translate="yes" xml:space="preserve">
          <source>__rlshift__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f4d58b4bb7931bfa7e3af8c43dfc1b22589f7d8" translate="yes" xml:space="preserve">
          <source>__rmod__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e22a0ceb1f0d9fc1df49d219bf644ece8f8cba1" translate="yes" xml:space="preserve">
          <source>__rmul__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b38ea4e037bea2f469a4a53c5b3edfaaeafd86bb" translate="yes" xml:space="preserve">
          <source>__ror__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e32731356df615e055546fab7e9b727d861d2bfe" translate="yes" xml:space="preserve">
          <source>__rpow__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f00839bb558300f64207e3b84e7e892be7e23e" translate="yes" xml:space="preserve">
          <source>__rrshift__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d012262378a0000ebe51f98742e1a14c7546a2c" translate="yes" xml:space="preserve">
          <source>__rshift__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee7f010f4d4bd19b27dc403b07e4628d9460acd3" translate="yes" xml:space="preserve">
          <source>__rsub__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc7e68badecf4937067508042a8240feaafc178f" translate="yes" xml:space="preserve">
          <source>__rtruediv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7160c7d2860a0049df61a7a8ae4cfa33f241764" translate="yes" xml:space="preserve">
          <source>__rxor__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4912ee41d6cd83bd9e53dccd3c74fb2aa6c5cfd" translate="yes" xml:space="preserve">
          <source>__setitem__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb35b9d3e836a4e0fedf974ad62a85aab0abb72c" translate="yes" xml:space="preserve">
          <source>__setmask__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91fcd479e5d18721e18563cb76b63c6dc180b643" translate="yes" xml:space="preserve">
          <source>__setstate__() (numpy.dtype method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3cb50b03eb52dbbae73b53cf1916f25adaaad8" translate="yes" xml:space="preserve">
          <source>__str__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b414bde8ee1935d20f07da3bcb2184daa7ebeef" translate="yes" xml:space="preserve">
          <source>__sub__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="140c3cde666eea556cdfd3011d31cb407d2266af" translate="yes" xml:space="preserve">
          <source>__truediv__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07b1823cae9ddb58ae30758105a74c411063c5f0" translate="yes" xml:space="preserve">
          <source>__xor__() (numpy.ma.MaskedArray method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0edc0e5b0babe606fdece95d661f1a734b04a296" translate="yes" xml:space="preserve">
          <source>a (C variable)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96401488135b817c2f1747197a83525ae296049e" translate="yes" xml:space="preserve">
          <source>a (fixed) payment, &lt;a href=&quot;numpy.pmt#numpy.pmt&quot;&gt;&lt;code&gt;pmt&lt;/code&gt;&lt;/a&gt;, paid either</source>
          <target state="translated">A (고정) 지급, &lt;a href=&quot;numpy.pmt#numpy.pmt&quot;&gt; &lt;code&gt;pmt&lt;/code&gt; &lt;/a&gt; , 중 지급</target>
        </trans-unit>
        <trans-unit id="d5166cddbf23a08b5074c2edc9aec3c68a5f3663" translate="yes" xml:space="preserve">
          <source>a 1-D array of 624 unsigned integer keys.</source>
          <target state="translated">부호없는 624 개의 정수 키로 구성된 1 차원 배열</target>
        </trans-unit>
        <trans-unit id="e95c05fdf3a7626457c027e91f7b377539d00b22" translate="yes" xml:space="preserve">
          <source>a 1-D array of 624 unsigned integers &lt;code&gt;keys&lt;/code&gt;.</source>
          <target state="translated">624 개의 부호없는 정수 &lt;code&gt;keys&lt;/code&gt; 구성된 1 차원 배열 .</target>
        </trans-unit>
        <trans-unit id="72fdfe6550961319f36cdd5e343cde12faf15445" translate="yes" xml:space="preserve">
          <source>a 1-d view of scalar</source>
          <target state="translated">스칼라의 1 차원 모습</target>
        </trans-unit>
        <trans-unit id="74f70982e8ed106bd95f08838212248bb41b2355" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;,</source>
          <target state="translated">&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="8f21ea65027d34d0f525219a53334dc35cb5bbea" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;chararray&lt;/code&gt;,</source>
          <target state="translated">&lt;code&gt;chararray&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="cb4065b0f0de4de8cc6afb691ce3365727df08a4" translate="yes" xml:space="preserve">
          <source>a Python str or unicode object,</source>
          <target state="translated">파이썬 str 또는 유니 코드 객체</target>
        </trans-unit>
        <trans-unit id="753cc1b7cdb86a0a582f834f17fe8e4f8e20365f" translate="yes" xml:space="preserve">
          <source>a binary string for the data</source>
          <target state="translated">데이터의 이진 문자열</target>
        </trans-unit>
        <trans-unit id="7be660f83fa27f597e95280a8283a2c0611d9749" translate="yes" xml:space="preserve">
          <source>a binary string for the mask.</source>
          <target state="translated">마스크의 이진 문자열</target>
        </trans-unit>
        <trans-unit id="da3d248ac1b46ab9b40ccba358d7b76cb5f95a1a" translate="yes" xml:space="preserve">
          <source>a binary string with the data (or a list if &amp;lsquo;a&amp;rsquo; is an object array)</source>
          <target state="translated">데이터가 포함 된 이진 문자열 (또는 'a'가 객체 배열 인 경우 목록)</target>
        </trans-unit>
        <trans-unit id="23ba6abbcb5fde1985a0ccafa389ab00c97b60c5" translate="yes" xml:space="preserve">
          <source>a comma-separated string, such as &lt;code&gt;dtype=&quot;i4,f8,|U3&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f30c34fa91e5fe02fcaaa600112ca2401559232" translate="yes" xml:space="preserve">
          <source>a description of what conditions (if any) would convince the vetoer to withdraw their veto.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75a0b11cb8353626ce9f617e11df2761570b96e8" translate="yes" xml:space="preserve">
          <source>a dictionary</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="704f270fcdda892dcd7da2499a02cbe197238d4e" translate="yes" xml:space="preserve">
          <source>a dictionary with two keys &lt;code&gt;'names'&lt;/code&gt; and &lt;code&gt;'formats'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165258a094d59f96169a00b9e5b85c293cfac672" translate="yes" xml:space="preserve">
          <source>a flat iterator on the array.</source>
          <target state="translated">배열의 플랫 반복자</target>
        </trans-unit>
        <trans-unit id="38fa2b975a8b6b4a3d3bf21a07ac779da6179bf8" translate="yes" xml:space="preserve">
          <source>a float &lt;code&gt;cached_gaussian&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 &lt;code&gt;cached_gaussian&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c6b35fc604217468fc6d89abf074eb38712618f" translate="yes" xml:space="preserve">
          <source>a full string specifying every real and imaginary part, e.g. &lt;code&gt;&amp;lsquo; %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej&amp;rsquo;&lt;/code&gt; for 3 columns</source>
          <target state="translated">모든 실수 및 허수 부분을 지정하는 전체 문자열 (예 : 3 개의 열에 대해 &lt;code&gt;&amp;lsquo; %.4e %+.4ej %.4e %+.4ej %.4e %+.4ej&amp;rsquo;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a967621935781dbcc252b4a8b7d96f97a3cfb15" translate="yes" xml:space="preserve">
          <source>a future value, &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">미래 가치, &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="62e19c74a71f45e1129086651da5d9eac4640584" translate="yes" xml:space="preserve">
          <source>a future value, &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; (e.g., 0)</source>
          <target state="translated">미래 가치 &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; &lt;/a&gt; (예 : 0)</target>
        </trans-unit>
        <trans-unit id="1753c0d76b344c4afe3b81d53fc356b2c9ebe4fe" translate="yes" xml:space="preserve">
          <source>a list of length 1, 2, or 3 specifying the ufunc buffer-size, the error mode integer, and the error call-back function. Normally, these values are looked up in a thread-specific dictionary. Passing them here circumvents that look up and uses the low-level specification provided for the error mode. This may be useful, for example, as an optimization for calculations requiring many ufunc calls on small arrays in a loop.</source>
          <target state="translated">ufunc 버퍼 크기, 오류 모드 정수 및 오류 콜백 함수를 지정하는 길이 1, 2 또는 3의 목록 일반적으로 이러한 값은 스레드 별 사전에서 조회됩니다. 여기에 전달하면 오류 모드에 제공된 저수준 사양을 찾아서 사용하지 않아도됩니다. 예를 들어, 루프에서 작은 배열에 대해 많은 ufunc 호출이 필요한 계산을 최적화하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdf1b7e7c1011d591cfbd0af0815aff32260a794" translate="yes" xml:space="preserve">
          <source>a list of length 3 specifying the ufunc buffer-size, the error mode integer, and the error call-back function. Normally, these values are looked up in a thread-specific dictionary. Passing them here circumvents that look up and uses the low-level specification provided for the error mode. This may be useful, for example, as an optimization for calculations requiring many ufunc calls on small arrays in a loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a016fa87293ad87bf7d20c139907d4294ea1c51" translate="yes" xml:space="preserve">
          <source>a list of specifiers, one per column - in this case, the real and imaginary part must have separate specifiers, e.g. &lt;code&gt;[&amp;lsquo;%.3e + %.3ej&amp;rsquo;, &amp;lsquo;(%.15e%+.15ej)&amp;rsquo;]&lt;/code&gt; for 2 columns</source>
          <target state="translated">&lt;code&gt;[&amp;lsquo;%.3e + %.3ej&amp;rsquo;, &amp;lsquo;(%.15e%+.15ej)&amp;rsquo;]&lt;/code&gt; 하나씩 지정자 목록-이 경우 실제 및 가상 부분에는 별도의 지정자가 있어야합니다 (예 : 2 개의 열에 대해 [ '% .3e + % .3ej', '(% .15e % +. 15ej)']).</target>
        </trans-unit>
        <trans-unit id="754b3f88fe33809498963069c46fb70a1dd37618" translate="yes" xml:space="preserve">
          <source>a local file.</source>
          <target state="translated">로컬 파일</target>
        </trans-unit>
        <trans-unit id="22e45aa7e27532a97050bec76c57f40005681c13" translate="yes" xml:space="preserve">
          <source>a powerful N-dimensional &lt;a href=&quot;reference/arrays#arrays&quot;&gt;array object&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ca4cb12a95fc655dfb15fbc902c4327211a0f3f" translate="yes" xml:space="preserve">
          <source>a present value, &lt;a href=&quot;numpy.pv#numpy.pv&quot;&gt;&lt;code&gt;pv&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">현재 가치, &lt;a href=&quot;numpy.pv#numpy.pv&quot;&gt; &lt;code&gt;pv&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1b5254931af84f023d149f4ef57b6e3483f413e" translate="yes" xml:space="preserve">
          <source>a present value, &lt;a href=&quot;numpy.pv#numpy.pv&quot;&gt;&lt;code&gt;pv&lt;/code&gt;&lt;/a&gt; (e.g., an amount borrowed)</source>
          <target state="translated">현재 가치 &lt;a href=&quot;numpy.pv#numpy.pv&quot;&gt; &lt;code&gt;pv&lt;/code&gt; &lt;/a&gt; (예 : 차용 된 금액)</target>
        </trans-unit>
        <trans-unit id="3f700e7c94c2cf78162bf09d2c7b35da27688852" translate="yes" xml:space="preserve">
          <source>a remote URL that has been downloaded and stored locally in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory.</source>
          <target state="translated">&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리 에 로컬로 다운로드 및 저장된 원격 URL</target>
        </trans-unit>
        <trans-unit id="8177c15205bb62fb37d25bf262fbb7d33cc77467" translate="yes" xml:space="preserve">
          <source>a remote URL that has not been downloaded, but is valid and accessible.</source>
          <target state="translated">다운로드되지 않았지만 유효하고 액세스 가능한 원격 URL</target>
        </trans-unit>
        <trans-unit id="fc18023e5beeb34cfd63a03735997fa403d6779a" translate="yes" xml:space="preserve">
          <source>a sequence of strings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581fbb7fd07105b5fb313725adb67250478b41d1" translate="yes" xml:space="preserve">
          <source>a sequence of tuples &lt;code&gt;(name, type)&lt;/code&gt;, such as &lt;code&gt;dtype=[('A', int), ('B', float)]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb7fb34c341acd589894b7cb9e258fc160dbe4fc" translate="yes" xml:space="preserve">
          <source>a sequence of types, such as &lt;code&gt;dtype=(int, float, float)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="665aa4dfa862dbce7e767c7639de941c068720d2" translate="yes" xml:space="preserve">
          <source>a sequence of values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e4908db613729ad16f59838856c8fc6378cb91a" translate="yes" xml:space="preserve">
          <source>a single specifier, &lt;code&gt;fmt=&amp;rsquo;%.4e&amp;rsquo;&lt;/code&gt;, resulting in numbers formatted like &lt;code&gt;&amp;lsquo; (%s+%sj)&amp;rsquo; % (fmt, fmt)&lt;/code&gt;</source>
          <target state="translated">단일 지정자 &lt;code&gt;fmt=&amp;rsquo;%.4e&amp;rsquo;&lt;/code&gt; , &lt;code&gt;&amp;lsquo; (%s+%sj)&amp;rsquo; % (fmt, fmt)&lt;/code&gt; 와 같은 형식의 숫자</target>
        </trans-unit>
        <trans-unit id="e920b8da955e5127e310279497efec15b98dd973" translate="yes" xml:space="preserve">
          <source>a single type, such as &lt;code&gt;dtype=float&lt;/code&gt;. The output will be 2D with the given dtype, unless a name has been associated with each column with the use of the &lt;code&gt;names&lt;/code&gt; argument (see below). Note that &lt;code&gt;dtype=float&lt;/code&gt; is the default for &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db9b14f123723ffb6a1c7625cfec338c91b7eb35" translate="yes" xml:space="preserve">
          <source>a single value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d621d0c0165fe844bdafa02ee3f44142e8347621" translate="yes" xml:space="preserve">
          <source>a string or a comma-separated string</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f0357554cfbce37a16e4d5a7d774ab825a16e0" translate="yes" xml:space="preserve">
          <source>a tuple giving the shape of the data</source>
          <target state="translated">데이터의 형태를 제공하는 튜플</target>
        </trans-unit>
        <trans-unit id="5a7e14c9afd05529942ab7c758fc5563081473ff" translate="yes" xml:space="preserve">
          <source>a typecode for the data</source>
          <target state="translated">데이터의 타입 코드</target>
        </trans-unit>
        <trans-unit id="2df379fb536f11677668023fe688e8a742e548d0" translate="yes" xml:space="preserve">
          <source>absolute (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4909bcee736f21faba4c4b4db99ca3259c9745b0" translate="yes" xml:space="preserve">
          <source>absolute(&lt;code&gt;a&lt;/code&gt; - &lt;code&gt;b&lt;/code&gt;) &amp;lt;= (&lt;code&gt;atol&lt;/code&gt; + &lt;code&gt;rtol&lt;/code&gt; * absolute(&lt;code&gt;b&lt;/code&gt;))</source>
          <target state="translated">절대 ( &lt;code&gt;a&lt;/code&gt; - &lt;code&gt;b&lt;/code&gt; ) &amp;lt;= ( &lt;code&gt;atol&lt;/code&gt; + &lt;code&gt;rtol&lt;/code&gt; * 절대 ( &lt;code&gt;b&lt;/code&gt; ))</target>
        </trans-unit>
        <trans-unit id="5e5215351c5a9435d5468e209f4ae4f89865d695" translate="yes" xml:space="preserve">
          <source>abspath() (numpy.DataSource method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c5768a77fb7c528c79cc85ec1625cb0c08d6c4" translate="yes" xml:space="preserve">
          <source>access element in second row, fifth column</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c3d3c4a6fc9f317a1315e03d8ba62adba671f6f" translate="yes" xml:space="preserve">
          <source>access last element in the 1xn matrix &lt;code&gt;a&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da612b00046cfa57f5be01bb44f03c97ee5fcb20" translate="yes" xml:space="preserve">
          <source>accumulate</source>
          <target state="translated">accumulate</target>
        </trans-unit>
        <trans-unit id="34bf564c6974fe414e320272397007672183b5ad" translate="yes" xml:space="preserve">
          <source>accumulate() (numpy.ufunc method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0243b68a17b26311e55f3b2d09ecde950910d82" translate="yes" xml:space="preserve">
          <source>accumulate, ufunc</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf4af5674a567955ee1b6d6ccdd05687486f3828" translate="yes" xml:space="preserve">
          <source>acknowledge report is received</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58d1bbce297de3c304a9fefc3b483181872a5c6b" translate="yes" xml:space="preserve">
          <source>add</source>
          <target state="translated">add</target>
        </trans-unit>
        <trans-unit id="6ace1c5836b39cd04d5f5385b3207b598d700c15" translate="yes" xml:space="preserve">
          <source>add (in module numpy)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86dd47ccbe562e2b1411af1bea7a7949de431be1" translate="yes" xml:space="preserve">
          <source>add a release note to the &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; directory, following the instructions and format in the &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96719c763dccc81364d3257cacab29af4b7d83a4" translate="yes" xml:space="preserve">
          <source>add() (in module numpy.char)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b59bfab0854033aead66d1b6faf7f43e0ee041" translate="yes" xml:space="preserve">
          <source>add_data_dir()</source>
          <target state="translated">add_data_dir()</target>
        </trans-unit>
        <trans-unit id="a31b71499e9386602eb7e0e5f273c05c0ac5ed45" translate="yes" xml:space="preserve">
          <source>add_data_dir() (numpy.distutils.misc_util.Configuration method)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9200d797d00907bd4a67510f47960da2cec4c889" translate="yes" xml:space="preserve">
          <source>add_data_files()</source>
          <target state="translated">add_data_files()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
