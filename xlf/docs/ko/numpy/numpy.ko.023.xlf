<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="7f0e6c0ce58755cae988a618ed26819ae121acf3" translate="yes" xml:space="preserve">
          <source>The scipy implementation is recommended over this function: it is a proper ufunc written in C, and more than an order of magnitude faster.</source>
          <target state="translated">scipy 구현은이 기능보다 권장됩니다. C로 작성된 적절한 ufunc이며, 10 배 이상 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="678645818896e353218894b08bcbb6e53102fa78" translate="yes" xml:space="preserve">
          <source>The scipy.org should be a PR at &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;. The file that needs modification is &lt;code&gt;www/index.rst&lt;/code&gt;. Search for &lt;code&gt;News&lt;/code&gt;.</source>
          <target state="translated">scipy.org는 &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt; 에서 PR이어야합니다 . 수정이 필요한 파일은 &lt;code&gt;www/index.rst&lt;/code&gt; 입니다. &lt;code&gt;News&lt;/code&gt; 검색합니다 .</target>
        </trans-unit>
        <trans-unit id="076d96a74fdcb13373554cd33f5faa0a5c841024" translate="yes" xml:space="preserve">
          <source>The second argument passed in to the Py_InitModule function is a structure that makes it easy to to define functions in the module. In the example given above, the mymethods structure would have been defined earlier in the file (usually right before the init{name} subroutine) to:</source>
          <target state="translated">Py_InitModule 함수에 전달 된 두 번째 인수는 모듈에서 함수를 쉽게 정의 할 수있는 구조입니다. 위에 주어진 예에서 mymethods 구조는 파일의 초기에 (일반적으로 init {name} 서브 루틴 바로 앞) 다음과 같이 정의되었을 것입니다.</target>
        </trans-unit>
        <trans-unit id="f1d1e93a16e6953d6dc31578f1bc0e4185a42885" translate="yes" xml:space="preserve">
          <source>The second element, &lt;em&gt;field_dtype&lt;/em&gt;, can be anything that can be interpreted as a data-type.</source>
          <target state="translated">두 번째 요소 인 &lt;em&gt;field_dtype&lt;/em&gt; 은 데이터 유형으로 해석 될 수있는 모든 요소 가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ebced32cc87e2c3435e9151b36d6b3c2cfaf845" translate="yes" xml:space="preserve">
          <source>The second is to set the error-handler to &amp;lsquo;log&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Floating-point errors then trigger a call to the &amp;lsquo;write&amp;rsquo; method of the provided object.</source>
          <target state="translated">두 번째는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; 을&lt;/a&gt; 사용하여 오류 처리기를 'log'로 설정하는 것 입니다. 부동 소수점 오류는 제공된 객체의 'write'메소드에 대한 호출을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="6f31ccc451074791f12a3d0394615bd3d0e3cdd2" translate="yes" xml:space="preserve">
          <source>The second issue to understand is how indices correspond to the order the array is stored in memory. In Fortran the first index is the most rapidly varying index when moving through the elements of a two dimensional array as it is stored in memory. If you adopt the matrix convention for indexing, then this means the matrix is stored one column at a time (since the first index moves to the next row as it changes). Thus Fortran is considered a Column-major language. C has just the opposite convention. In C, the last index changes most rapidly as one moves through the array as stored in memory. Thus C is a Row-major language. The matrix is stored by rows. Note that in both cases it presumes that the matrix convention for indexing is being used, i.e., for both Fortran and C, the first index is the row. Note this convention implies that the indexing convention is invariant and that the data order changes to keep that so.</source>
          <target state="translated">이해해야 할 두 번째 문제는 배열이 메모리에 저장된 순서와 인덱스가 어떻게 일치하는지입니다. 포트란에서 첫 번째 인덱스는 메모리에 저장되어있는 2 차원 배열의 요소를 이동할 때 가장 빠르게 변하는 인덱스입니다. 인덱싱에 매트릭스 규칙을 채택하면 매트릭스가 한 번에 한 열씩 저장됨을 의미합니다 (첫 번째 인덱스는 변경 될 때 다음 행으로 이동하기 때문에). 따라서 포트란은 열 주요 언어로 간주됩니다. C는 반대의 규칙을 가지고 있습니다. C에서 마지막 인덱스는 메모리에 저장된 배열을 통해 이동할 때 가장 빠르게 변경됩니다. 따라서 C는 행 주요 언어입니다. 행렬은 행별로 저장됩니다. 두 경우 모두 색인에 대한 행렬 규칙이 사용되는 것으로 가정합니다. 즉, 포트란과 C 모두에 대해 첫 번째 색인은 행입니다.이 규칙은 인덱싱 규칙이 변하지 않으며 데이터 순서가 변경되도록 변경됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="453559558db2eb56414a46dbdb5de2376ea80083" translate="yes" xml:space="preserve">
          <source>The second rule of broadcasting ensures that arrays with a size of 1 along a particular dimension act as if they had the size of the array with the largest shape along that dimension. The value of the array element is assumed to be the same along that dimension for the &amp;ldquo;broadcast&amp;rdquo; array.</source>
          <target state="translated">두 번째 브로드 캐스팅 규칙은 특정 차원을 따라 크기가 1 인 배열이 해당 차원을 따라 가장 큰 모양을 가진 배열 크기를 가진 것처럼 작동하도록합니다. 배열 요소의 값은 &quot;브로드 캐스트&quot;배열의 해당 차원을 따라 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="df98d64a8c2e83a203df1c7d9ac9de7f5c519eeb" translate="yes" xml:space="preserve">
          <source>The second through seventh row contain summary data that is of a different type than that which we are going to examine, so we will need to exclude that from the data with which we will work.</source>
          <target state="translated">두 번째부터 일곱 번째 행에는 검토 할 데이터와 다른 유형의 요약 데이터가 포함되어 있으므로 작업 할 데이터에서 해당 데이터를 제외해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="fe0109b90f8697e3f57d897bca8c421d8285d2b1" translate="yes" xml:space="preserve">
          <source>The second way is to upload the PKG_INFO file inside the sdist dir in the web interface of PyPI. The source tarball can also be uploaded through this interface.</source>
          <target state="translated">두 번째 방법은 PyPI 웹 인터페이스의 sdist dir 안에 PKG_INFO 파일을 업로드하는 것입니다. 이 인터페이스를 통해 소스 tarball을 업로드 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aabd3a3162d932dde5dce5c1f8c9f863c647d1b" translate="yes" xml:space="preserve">
          <source>The second way of indexing with booleans is more similar to integer indexing; for each dimension of the array we give a 1D boolean array selecting the slices we want:</source>
          <target state="translated">부울을 사용하여 인덱싱하는 두 번째 방법은 정수 인덱싱과 더 유사합니다. 배열의 각 차원에 대해 원하는 슬라이스를 선택하는 1D 부울 배열을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="66a3455570bd434e86d6f052ed9b9a1d4a2c4251" translate="yes" xml:space="preserve">
          <source>The sections of a function&amp;rsquo;s docstring are:</source>
          <target state="translated">함수의 독 스트링 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8eb125eefbda7190ce972cb7d8270d5ae89dc7b7" translate="yes" xml:space="preserve">
          <source>The self.paths(&amp;hellip;) method is applied to all lists that may contain paths.</source>
          <target state="translated">self.paths (&amp;hellip;) 메소드는 경로를 포함 할 수있는 모든 목록에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="8c7148486ba5b770e99fd7463ec63c216dee7366" translate="yes" xml:space="preserve">
          <source>The separation between elements for each dimension (the &amp;lsquo;stride&amp;rsquo;). This does not have to be a multiple of the element size</source>
          <target state="translated">각 차원의 요소 간 분리 ( '보도'). 이것은 요소 크기의 배수 일 필요는 없습니다</target>
        </trans-unit>
        <trans-unit id="9cd2ff64b895aeb8d0b16f3694ac2aea08560437" translate="yes" xml:space="preserve">
          <source>The series in this context are finite sums of the corresponding polynomial basis functions multiplied by coefficients. For instance, a power series looks like</source>
          <target state="translated">이 맥락에서 시리즈는 계수를 곱한 해당 다항식 기본 함수의 유한 합입니다. 예를 들어 파워 시리즈는</target>
        </trans-unit>
        <trans-unit id="9285a776c2a659ee75e7938ac17b155070381205" translate="yes" xml:space="preserve">
          <source>The series instance to be converted.</source>
          <target state="translated">변환 할 시리즈 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="89a518ad1f6d727d2464d8f222f198c518f126e6" translate="yes" xml:space="preserve">
          <source>The series is reduced to degree &lt;code&gt;deg&lt;/code&gt; by discarding the high order terms. The value of &lt;code&gt;deg&lt;/code&gt; must be a non-negative integer.</source>
          <target state="translated">이 계열은 고차 항을 버림으로써 도 ( &lt;code&gt;deg&lt;/code&gt; )로 줄어 듭니다 . &lt;code&gt;deg&lt;/code&gt; 의 값은 음이 아닌 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="adbbacc122f5859d958a7eb7009d4955c1c2c537" translate="yes" xml:space="preserve">
          <source>The series is reduced to length &lt;code&gt;size&lt;/code&gt; by discarding the high degree terms. The value of &lt;code&gt;size&lt;/code&gt; must be a positive integer.</source>
          <target state="translated">계열은 높은 수준의 용어를 삭제하여 길이 &lt;code&gt;size&lt;/code&gt; 로 줄어 듭니다 . &lt;code&gt;size&lt;/code&gt; 값은 양의 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="38262a9c7d66cebff5a42640a9df021a775761be" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt;&lt;code&gt;codecs&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">사용 가능한 코덱 세트는 Python 표준 라이브러리에서 제공되며 런타임시 확장 될 수 있습니다. 자세한 내용은 &lt;a href=&quot;https://docs.python.org/dev/library/codecs.html#module-codecs&quot;&gt; &lt;code&gt;codecs&lt;/code&gt; &lt;/a&gt; 모듈을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a717e3302b8636b7790364bffe6b5a183f3f6e7f" translate="yes" xml:space="preserve">
          <source>The set of available codecs comes from the Python standard library, and may be extended at runtime. For more information, see the codecs module.</source>
          <target state="translated">사용 가능한 코덱 세트는 Python 표준 라이브러리에서 제공되며 런타임시 확장 될 수 있습니다. 자세한 내용은 코덱 모듈을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f3119f479b7378be171f9e5461ebc7ae89470f50" translate="yes" xml:space="preserve">
          <source>The set of characters that the returned character is chosen from. The default set is &amp;lsquo;GDFgdf&amp;rsquo;.</source>
          <target state="translated">반환 된 문자가 선택된 문자 세트입니다. 기본 설정은 'GDFgdf'입니다.</target>
        </trans-unit>
        <trans-unit id="a3a4541aef2e0618e33ebd5e18d9c022d28bcaa8" translate="yes" xml:space="preserve">
          <source>The set of functions that convert the data of a column to a value. The converters can also be used to provide a default value for missing data: &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt;.</source>
          <target state="translated">열의 데이터를 값으로 변환하는 함수 세트입니다. 변환기를 사용하여 누락 된 데이터에 대한 기본값을 제공 할 수도 있습니다. &lt;code&gt;converters = {3: lambda s: float(s or 0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e26f5391f4384da7c676eb1e9d468550abb0eb1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt;, but handled as a special case in PyArray_ResultType.</source>
          <target state="translated">int 값 세트는 비트 수가 동일한 유형에 대한 uint 값의 서브 세트가 아니며, &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; 에&lt;/a&gt; 반영되지 않지만 PyArray_ResultType 에서 특수한 경우로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="e76841686484db8628455fd162b8197749bc84c1" translate="yes" xml:space="preserve">
          <source>The set of int values is not a subset of the uint values for types with the same number of bits, something not reflected in &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt;, but handled as a special case in &lt;a href=&quot;#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">int 값 세트는 비트 수가 동일한 유형에 대한 uint 값의 서브 세트가 아니며 &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; 에&lt;/a&gt; 반영되지 않지만 &lt;a href=&quot;#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; 의 특수한 경우로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="561107923e2d5ef74733b059316312382b1f95e9" translate="yes" xml:space="preserve">
          <source>The set of strings corresponding to missing data.</source>
          <target state="translated">누락 된 데이터에 해당하는 문자열 세트입니다.</target>
        </trans-unit>
        <trans-unit id="3c3fdff23bd130c5708b43d7769884cc7638d9dc" translate="yes" xml:space="preserve">
          <source>The set of values to be used as default when the data are missing.</source>
          <target state="translated">데이터가 없을 때 기본값으로 사용되는 값 세트입니다.</target>
        </trans-unit>
        <trans-unit id="40c5a46b247f5eb179525001f8ba092f80c0ed2a" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">세 가지 방법 모두에 대한 설정 함수는 &lt;code&gt;construct_reduce&lt;/code&gt; 입니다. 이 함수는 축소 루프 객체를 만들고 루프를 완료하는 데 필요한 매개 변수로 채 웁니다. 모든 메소드는 2 입력을 받고 1 출력을 리턴하는 ufunc에서만 작동합니다. 따라서 [ &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; 의 서명을 가정하여 기본 1 차원 루프가 선택됩니다. ] . &lt;code&gt;otype&lt;/code&gt; 요청 된 축소 데이터 유형입니다. 그런 다음 (스레드 당) 글로벌 스토리지에서 버퍼 크기 및 오류 처리가 검색됩니다. 잘못 정렬되었거나 데이터 유형이 잘못된 작은 배열의 경우 버퍼되지 않은 코드 섹션이 사용되도록 복사가 이루어집니다. 그런 다음 루핑 전략이 선택됩니다. 배열에 1 개의 요소 또는 0 개의 요소가있는 경우 간단한 루핑 방법이 선택됩니다. 배열이 잘못 정렬되지 않았고 올바른 데이터 유형이있는 경우 스트라이드 루핑이 선택됩니다. 그렇지 않으면 버퍼 된 루핑을 수행해야합니다. 그런 다음 루핑 매개 변수가 설정되고 리턴 배열이 구성됩니다. 출력 배열은 방법이 축소, 누적 또는 축소인지에 따라 다른 모양입니다. 출력 배열이 이미 제공되어 있으면 모양이 확인됩니다. 출력 배열이 C 인접하지 않고 정렬 된 경우올바른 데이터 유형 인 경우 WRITEBACKIFCOPY 플래그가 설정된 임시 사본이 작성됩니다. 이런 식으로, 메소드는 잘 동작하는 출력 배열로 작업 할 수 있지만 결과는 실제 출력 배열로 다시 복사됩니다.&lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt;함수가 완료되면 PyArray_ResolveWritebackIfCopy 가 호출됩니다. 마지막으로 이터레이터는 올바른 축을 반복하도록 설정되고 (방법에 제공된 축의 값에 따라) 설정 루틴이 실제 계산 루틴으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="26040668927e88fa78277a9dd0406a200dc72c4f" translate="yes" xml:space="preserve">
          <source>The setup function for all three methods is &lt;code&gt;construct_reduce&lt;/code&gt;. This function creates a reducing loop object and fills it with parameters needed to complete the loop. All of the methods only work on ufuncs that take 2-inputs and return 1 output. Therefore, the underlying 1-D loop is selected assuming a signature of [ &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt;, &lt;code&gt;otype&lt;/code&gt; ] where &lt;code&gt;otype&lt;/code&gt; is the requested reduction data-type. The buffer size and error handling is then retrieved from (per-thread) global storage. For small arrays that are mis-aligned or have incorrect data-type, a copy is made so that the un-buffered section of code is used. Then, the looping strategy is selected. If there is 1 element or 0 elements in the array, then a simple looping method is selected. If the array is not mis-aligned and has the correct data-type, then strided looping is selected. Otherwise, buffered looping must be performed. Looping parameters are then established, and the return array is constructed. The output array is of a different shape depending on whether the method is reduce, accumulate, or reduceat. If an output array is already provided, then it&amp;rsquo;s shape is checked. If the output array is not C-contiguous, aligned, and of the correct data type, then a temporary copy is made with the WRITEBACKIFCOPY flag set. In this way, the methods will be able to work with a well-behaved output array but the result will be copied back into the true output array when &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at function completion. Finally, iterators are set up to loop over the correct axis (depending on the value of axis provided to the method) and the setup routine returns to the actual computation routine.</source>
          <target state="translated">세 가지 방법 모두에 대한 설정 함수는 &lt;code&gt;construct_reduce&lt;/code&gt; 입니다. 이 함수는 감소 루프 객체를 생성하고 루프를 완료하는 데 필요한 매개 변수로 채 웁니다. 모든 메서드는 2 개의 입력을 받고 1 개의 출력을 반환하는 ufunc에서만 작동합니다. 따라서 기본 1D 루프는 [ &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; , &lt;code&gt;otype&lt;/code&gt; ] 의 시그니처를 가정하여 선택됩니다 . 여기서 &lt;code&gt;otype&lt;/code&gt; 요청 된 축소 데이터 유형입니다. 그런 다음 (스레드 당) 전역 저장소에서 버퍼 크기 및 오류 처리를 검색합니다. 잘못 정렬되었거나 데이터 유형이 잘못된 작은 배열의 경우 버퍼링되지 않은 코드 섹션이 사용되도록 복사본이 만들어집니다. 그런 다음 루핑 전략이 선택됩니다. 배열에 1 개 요소 또는 0 개 요소가있는 경우 간단한 루핑 방법이 선택됩니다. 배열이 잘못 정렬되지 않았고 올바른 데이터 유형이 있으면 strided 루핑이 선택됩니다. 그렇지 않으면 버퍼링 된 루핑을 수행해야합니다. 그런 다음 루핑 매개 변수가 설정되고 반환 배열이 구성됩니다. 출력 배열은 방법이 reduce, accumulate 또는 reduceat인지에 따라 다른 모양입니다. 출력 배열이 이미 제공된 경우 모양이 확인됩니다. 출력 배열이 C- 연속이 아닌 경우 정렬됩니다.올바른 데이터 유형의 경우 WRITEBACKIFCOPY 플래그 세트로 임시 사본이 작성됩니다. 이런 식으로 메서드는 제대로 작동하는 출력 배열로 작업 할 수 있지만 결과는 다음과 같은 경우 실제 출력 배열로 다시 복사됩니다.&lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 는 함수 완료시 호출됩니다. 마지막으로 반복기가 올바른 축 (메소드에 제공된 축 값에 따라 다름)을 반복하도록 설정되고 설정 루틴이 실제 계산 루틴으로 돌아갑니다.</target>
        </trans-unit>
        <trans-unit id="780e857a060059f3e4636a17060f123b8f85b3b2" translate="yes" xml:space="preserve">
          <source>The shape (always C-style contiguous) of the sub-array as a Python tuple.</source>
          <target state="translated">하위 배열의 모양 (항상 C 스타일 연속)은 Python 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="9bd591fada3b4117c12a2a1f4d689c069ec359b8" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;a&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">의 형상 및 데이터 타입 &lt;code&gt;a&lt;/code&gt; 반환 된 배열이 동일한 속성을 정의한다.</target>
        </trans-unit>
        <trans-unit id="ea4fdc5d91eb3f313e977fbfd63ada0a25a66896" translate="yes" xml:space="preserve">
          <source>The shape and data-type of &lt;code&gt;prototype&lt;/code&gt; define these same attributes of the returned array.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; 의 모양과 데이터 유형은 반환 된 배열의 동일한 속성을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="de0758f703e3713cedaff1b24e8618c254649ffe" translate="yes" xml:space="preserve">
          <source>The shape of an array can be changed with various commands. Note that the following three commands all return a modified array, but do not change the original array:</source>
          <target state="translated">배열의 모양은 다양한 명령으로 변경할 수 있습니다. 다음 세 명령은 모두 수정 된 배열을 반환하지만 원래 배열을 변경하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="55cbdf85b9592ec5dbddfd31ccd2c86de9452ccc" translate="yes" xml:space="preserve">
          <source>The shape of array into which the indices from &lt;code&gt;multi_index&lt;/code&gt; apply.</source>
          <target state="translated">&lt;code&gt;multi_index&lt;/code&gt; 의 인덱스가 적용 되는 배열의 모양입니다 .</target>
        </trans-unit>
        <trans-unit id="86ea4631bc5657813d3aa6a6102c3531d8908358" translate="yes" xml:space="preserve">
          <source>The shape of each output is determined from the loop dimensions plus the output&amp;rsquo;s core dimensions</source>
          <target state="translated">각 출력의 모양은 루프 치수와 출력의 코어 치수에 따라 결정됩니다</target>
        </trans-unit>
        <trans-unit id="345c4787e4fcac13ce0e228d7aa0f85b31312232" translate="yes" xml:space="preserve">
          <source>The shape of the array if we are creating a new file in &amp;ldquo;write&amp;rdquo; mode, in which case this parameter is required. Otherwise, this parameter is ignored and is thus optional.</source>
          <target state="translated">&quot;쓰기&quot;모드에서 새 파일을 만드는 경우 배열의 모양.이 경우이 매개 변수가 필요합니다. 그렇지 않으면이 매개 변수는 무시되므로 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="432cd297e760e974a03d449cad5f33c7ccb0d645" translate="yes" xml:space="preserve">
          <source>The shape of the array is preserved, but the elements are reordered.</source>
          <target state="translated">배열의 모양은 유지되지만 요소의 순서는 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="fb341212b6f41ae91b019292b043b6094616b784" translate="yes" xml:space="preserve">
          <source>The shape of the array to be iterated over.</source>
          <target state="translated">반복 할 배열의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="a015ba13ffb4171bac494c802f272bfb87417c5d" translate="yes" xml:space="preserve">
          <source>The shape of the array to use for unraveling &lt;code&gt;indices&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;indices&lt;/code&gt; 를 풀기 위해 사용할 배열의 모양 .</target>
        </trans-unit>
        <trans-unit id="9865a6cbf282f8b0812325650b93441342efdd22" translate="yes" xml:space="preserve">
          <source>The shape of the array.</source>
          <target state="translated">배열의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="634c22963834ab0f96135fc087ba541ef29a9351" translate="yes" xml:space="preserve">
          <source>The shape of the broadcasted result (only &lt;code&gt;nd&lt;/code&gt; slots are used).</source>
          <target state="translated">방송 결과의 모양 ( &lt;code&gt;nd&lt;/code&gt; 슬롯 만 사용됨).</target>
        </trans-unit>
        <trans-unit id="b35ba9f7409c5e79b96888dfb9fe12c59d8276ca" translate="yes" xml:space="preserve">
          <source>The shape of the desired array.</source>
          <target state="translated">원하는 배열의 모양입니다.</target>
        </trans-unit>
        <trans-unit id="f8fd7f6a4e1f2e482a2f6d64364dd79594585ba9" translate="yes" xml:space="preserve">
          <source>The shape of the gamma distribution. Must be non-negative.</source>
          <target state="translated">감마 분포의 모양. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="40d55544c4b29b3e5cccb47aa9255a7413094e32" translate="yes" xml:space="preserve">
          <source>The shape of the grid.</source>
          <target state="translated">격자 모양.</target>
        </trans-unit>
        <trans-unit id="666be679bea4cf4401944751286d85ef9bcbd1ab" translate="yes" xml:space="preserve">
          <source>The shape of the new array. Defaults to &lt;code&gt;x.shape&lt;/code&gt;.</source>
          <target state="translated">새 배열의 모양입니다. 기본값은 &lt;code&gt;x.shape&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="91c1116d9a62d56b653126b73ba2224a6c45b6f9" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; array.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">출력의 모양은 &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 의 크기에 따라 다르며 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 보다 클 수 있습니다 ( &lt;code&gt;len(indices) &amp;gt; array.shape[axis]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="be82fcdcf7279745a92907a11f17b40fb49cfa8e" translate="yes" xml:space="preserve">
          <source>The shape of the output depends on the size of &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt;, and may be larger than &lt;code&gt;a&lt;/code&gt; (this happens if &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt;).</source>
          <target state="translated">출력의 모양은 &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 의 크기에 따라 달라지며 &lt;code&gt;a&lt;/code&gt; 보다 클 수 있습니다 (이 경우 &lt;code&gt;len(indices) &amp;gt; a.shape[axis]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="fed05fc9900417f6dd9d3b1246dc76a2025a600b" translate="yes" xml:space="preserve">
          <source>The shape of the result consists of the non-contracted axes of the first tensor, followed by the non-contracted axes of the second.</source>
          <target state="translated">결과의 모양은 첫 번째 텐서의 비축 약 축과 두 번째 텐서의 비축 약 축으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="dac69f494ba7fae89ed73806775a3c39622a5622" translate="yes" xml:space="preserve">
          <source>The shape of the return value is described above.</source>
          <target state="translated">리턴 값의 모양은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e988320cd7cc6c4a6c3dd57d84589dcf99664d33" translate="yes" xml:space="preserve">
          <source>The shape of the returned array is described above.</source>
          <target state="translated">반환 된 배열의 모양은 위에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b10de911cd8ce2a5b2b31e29ac9a30a0aac3857" translate="yes" xml:space="preserve">
          <source>The shape of the returned matrix is &lt;code&gt;x.shape + (order,)&lt;/code&gt;, where</source>
          <target state="translated">반환 된 행렬의 모양은 &lt;code&gt;x.shape + (order,)&lt;/code&gt; . 여기서</target>
        </trans-unit>
        <trans-unit id="80077b48358a43ab7ec659d3d5fde9d46b95fb86" translate="yes" xml:space="preserve">
          <source>The shape parameter must be given if converting from a ctypes POINTER. The shape parameter is ignored if converting from a ctypes array</source>
          <target state="translated">ctypes POINTER에서 변환 할 경우 shape 매개 변수를 제공해야합니다. ctypes 배열에서 변환하는 경우 shape 매개 변수가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fd56dfcd2507095f44b621f1654fe8bcd97f2720" translate="yes" xml:space="preserve">
          <source>The shape property is usually used to get the current shape of an array, but may also be used to reshape the array in-place by assigning a tuple of array dimensions to it. As with &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, one of the new shape dimensions can be -1, in which case its value is inferred from the size of the array and the remaining dimensions. Reshaping an array in-place will fail if a copy is required.</source>
          <target state="translated">shape 속성은 일반적으로 배열의 현재 모양을 얻는 데 사용되지만 배열 차원의 튜플을 배열로 제자리에 재구성하는 데 사용될 수도 있습니다. &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 새로운 모양 차원 중 하나는 -1 일 수 있으며,이 경우 값은 배열의 크기와 나머지 차원에서 추론됩니다. 복사본이 필요한 경우 배열을 제자리에서 재구성 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="80c5a27079e0e5c1026de7841cb52daa2c677404" translate="yes" xml:space="preserve">
          <source>The shapes of x, y, and the condition are broadcast together:</source>
          <target state="translated">x, y 및 조건의 모양은 함께 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="052d67151c1ebcb6fedc9c36859ec35b9f5a3388" translate="yes" xml:space="preserve">
          <source>The shapes to be broadcast against each other.</source>
          <target state="translated">서로에 대해 방송 할 모양입니다.</target>
        </trans-unit>
        <trans-unit id="18b788b2f85a3ae45e9f183bcbf59e96d87edbee" translate="yes" xml:space="preserve">
          <source>The shifted array.</source>
          <target state="translated">시프트 된 배열</target>
        </trans-unit>
        <trans-unit id="a03c5ad272b253bf040f55b1c50d0da307be8ac5" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x2&lt;/code&gt; is copied to &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">의 부호 &lt;code&gt;x2&lt;/code&gt; 복사됩니다 &lt;code&gt;x1&lt;/code&gt; . 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="9a96a866f0e16363f3d77343ed89edc57a089b06" translate="yes" xml:space="preserve">
          <source>The sign of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 부호 . &lt;code&gt;x&lt;/code&gt; 이면 스칼라입니다. 가 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="39e50e1c53e79cf4e2679a1929a8b236a790ceb1" translate="yes" xml:space="preserve">
          <source>The signature defines &amp;ldquo;core&amp;rdquo; dimensionality of input and output variables, and thereby also defines the contraction of the dimensions. The signature is represented by a string of the following format:</source>
          <target state="translated">서명은 입력 및 출력 변수의 &quot;핵심&quot;차원을 정의하고 차원의 축소도 정의합니다. 서명은 다음 형식의 문자열로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="077a1bbb529dbf66c684eb23b600d5d4d40598cf" translate="yes" xml:space="preserve">
          <source>The signature determines how the dimensions of each input/output array are split into core and loop dimensions:</source>
          <target state="translated">서명은 각 입력 / 출력 배열의 차원이 코어 및 루프 차원으로 분할되는 방식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="b9b7ac7b939268ddc59ac1f05c9ebd5e07bf4b21" translate="yes" xml:space="preserve">
          <source>The signature file is saved to &lt;code&gt;fib1.pyf&lt;/code&gt; (see &lt;code&gt;-h&lt;/code&gt; flag) and its contents is shown below.</source>
          <target state="translated">서명 파일은 &lt;code&gt;fib1.pyf&lt;/code&gt; ( &lt;code&gt;-h&lt;/code&gt; 플래그 참조 )에 저장 되며 그 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f03fcdecb4ad7904d6d08273575b7efc1ecd0bcc" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_finalize__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; 의 서명은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="51657129c6ecba9775cfcd86518eea063cc02856" translate="yes" xml:space="preserve">
          <source>The signature of &lt;code&gt;__array_ufunc__&lt;/code&gt; is:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; 의 서명은 다음 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7eceedf301ec9322c1f2e0e1b62bac4ce44cf0b3" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran block data has the following structure:</source>
          <target state="translated">Fortran 블록 데이터의 서명은 다음과 같은 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="07cca1f52e338494fc6137e9ab73032ffedaab99" translate="yes" xml:space="preserve">
          <source>The signature of a Fortran routine has the following structure:</source>
          <target state="translated">Fortran 루틴의 서명은 다음과 같은 구조를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="29c6d5e035a62abf39bca07984559eb4c2eed470" translate="yes" xml:space="preserve">
          <source>The simplest and fastest estimator. Only takes into account the data size.</source>
          <target state="translated">가장 간단하고 빠른 추정기. 데이터 크기 만 고려합니다.</target>
        </trans-unit>
        <trans-unit id="f68339a598fdad0949b432ba0f071db76d4162b2" translate="yes" xml:space="preserve">
          <source>The simplest case of indexing with &lt;em&gt;N&lt;/em&gt; integers returns an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; representing the corresponding item. As in Python, all indices are zero-based: for the &lt;em&gt;i&lt;/em&gt;-th index</source>
          <target state="translated">&lt;em&gt;N 개의&lt;/em&gt; 정수로 인덱싱하는 가장 간단한 경우 는 해당 항목을 나타내는 &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;배열 스칼라를&lt;/a&gt; 반환합니다 . 파이썬에서와 같이, 모든 인덱스는 0부터 시작합니다 : &lt;em&gt;i&lt;/em&gt; 번째 인덱스</target>
        </trans-unit>
        <trans-unit id="7ff2686b623caae27117f3c5885c7d6ae7623a3a" translate="yes" xml:space="preserve">
          <source>The simplest way to assign values to a structured array is using python tuples. Each assigned value should be a tuple of length equal to the number of fields in the array, and not a list or array as these will trigger numpy&amp;rsquo;s broadcasting rules. The tuple&amp;rsquo;s elements are assigned to the successive fields of the array, from left to right:</source>
          <target state="translated">구조화 된 배열에 값을 할당하는 가장 간단한 방법은 파이썬 튜플을 사용하는 것입니다. 할당 된 각 값은 numpy의 브로드 캐스팅 규칙을 트리거하므로 목록이나 배열이 아닌 배열의 필드 수와 동일한 길이의 튜플이어야합니다. 튜플의 요소는 왼쪽에서 오른쪽으로 배열의 연속 필드에 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="082b93c290be349a4bf83756ecca01f8d723b944" translate="yes" xml:space="preserve">
          <source>The simplest way to create a record array is with &lt;code&gt;numpy.rec.array&lt;/code&gt;:</source>
          <target state="translated">레코드 배열을 만드는 가장 간단한 방법은 &lt;code&gt;numpy.rec.array&lt;/code&gt; 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="47091f34475faaaa1ba4de46a8ad6549a8d5a1f2" translate="yes" xml:space="preserve">
          <source>The simulation of a C-style array is not complete for 2-d and 3-d arrays. For example, the simulated arrays of pointers cannot be passed to subroutines expecting specific, statically-defined 2-d and 3-d arrays. To pass to functions requiring those kind of inputs, you must statically define the required array and copy data.</source>
          <target state="translated">C 스타일 배열의 시뮬레이션은 2 차원 및 3 차원 배열에 대해 완전하지 않습니다. 예를 들어, 시뮬레이션 된 포인터 배열은 정적으로 정의 된 특정 2 차원 및 3 차원 배열을 기대하는 서브 루틴으로 전달 될 수 없습니다. 이러한 종류의 입력이 필요한 함수에 전달하려면 필요한 배열을 정적으로 정의하고 데이터를 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="51abf12252a4d92a90b52830906a8c2bd4002537" translate="yes" xml:space="preserve">
          <source>The sinc function is</source>
          <target state="translated">sinc 함수는</target>
        </trans-unit>
        <trans-unit id="ca8287ab64739fe1883b42785585fd67081d297d" translate="yes" xml:space="preserve">
          <source>The sinc function is used in various signal processing applications, including in anti-aliasing, in the construction of a Lanczos resampling filter, and in interpolation.</source>
          <target state="translated">sinc 함수는 앤티 앨리어싱, Lanczos 리샘플링 필터 구성 및 보간 등 다양한 신호 처리 응용 프로그램에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="237e09976f401d9a2f1baabe777a697734eddddd" translate="yes" xml:space="preserve">
          <source>The sine is one of the fundamental functions of trigonometry (the mathematical study of triangles). Consider a circle of radius 1 centered on the origin. A ray comes in from the</source>
          <target state="translated">사인은 삼각법 (삼각형의 수학 연구)의 기본 기능 중 하나입니다. 원점을 중심으로 반경 1의 원을 고려하십시오. 광선은</target>
        </trans-unit>
        <trans-unit id="eeee63a3a1e6205f2e90fb5ed65d351e3798fee5" translate="yes" xml:space="preserve">
          <source>The sine of each element of x. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">x의 각 원소의 사인입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="b9c09c4d5914f0dda5c0b150c5f3b90e766bd841" translate="yes" xml:space="preserve">
          <source>The single threaded call directly uses the BitGenerator.</source>
          <target state="translated">단일 스레드 호출은 BitGenerator를 직접 사용합니다.</target>
        </trans-unit>
        <trans-unit id="4e52363a0d1aff84bc0a45f224b49ba218e2396a" translate="yes" xml:space="preserve">
          <source>The situation with numpy makes this issue yet more complicated. The internal machinery of numpy arrays is flexible enough to accept any ordering of indices. One can simply reorder indices by manipulating the internal stride information for arrays without reordering the data at all. NumPy will know how to map the new index order to the data without moving the data.</source>
          <target state="translated">numpy의 상황은이 문제를 더욱 복잡하게 만듭니다. numpy 배열의 내부 기계는 인덱스 순서를 수용 할 수있을만큼 유연합니다. 데이터의 순서를 바꾸지 않고 배열의 내부 보폭 정보를 조작하여 인덱스의 순서를 간단히 바꿀 수 있습니다. NumPy는 데이터를 이동하지 않고 새로운 인덱스 순서를 데이터에 매핑하는 방법을 알고 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d5ab6e4dc0fec0528be17bc5d4e3ad5f3c1a900" translate="yes" xml:space="preserve">
          <source>The size in each dimension of the output shape is the maximum of all the input sizes in that dimension.</source>
          <target state="translated">출력 모양의 각 차원의 크기는 해당 차원의 모든 입력 크기의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="9a3ff85912460f4dce83d9377238c987b64400fb" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array can be passed as individual parameters or as the elements of a tuple.</source>
          <target state="translated">배열의 각 차원 크기는 개별 매개 변수 또는 튜플의 요소로 전달 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f600bd12887e2a8896ddc5bed9d6833c21b9000" translate="yes" xml:space="preserve">
          <source>The size of each dimension of the array.</source>
          <target state="translated">배열의 각 차원의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="53e85438a85fb68e962963fce436f922d4bad0ac" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt;&lt;code&gt;uint32&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt;&lt;code&gt;uint64&lt;/code&gt;&lt;/a&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt;&lt;code&gt;uint64&lt;/code&gt;&lt;/a&gt; will draw twice as many bits as &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt;&lt;code&gt;uint32&lt;/code&gt;&lt;/a&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">각 단어의 크기입니다. 이것은 &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt; &lt;code&gt;uint32&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt; &lt;code&gt;uint64&lt;/code&gt; &lt;/a&gt; 중 하나 여야합니다 . 문자열 ( &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; , &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; )은 괜찮습니다. &lt;a href=&quot;../../../arrays.scalars#numpy.uint64&quot;&gt; &lt;code&gt;uint64&lt;/code&gt; &lt;/a&gt; 를 요청 하면 동일한 &lt;code&gt;n_words&lt;/code&gt; 에 대해 &lt;a href=&quot;../../../arrays.scalars#numpy.uint32&quot;&gt; &lt;code&gt;uint32&lt;/code&gt; &lt;/a&gt; 보다 두 배 많은 비트가 그려 집니다 . 이것은 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 배열 로 표현하는 BitGenerator` 의 편의입니다 .</target>
        </trans-unit>
        <trans-unit id="bcfaa2928c38d19614d82820fec94f09b6747c0f" translate="yes" xml:space="preserve">
          <source>The size of each word. This should only be either &lt;code&gt;uint32&lt;/code&gt; or &lt;code&gt;uint64&lt;/code&gt;. Strings (&lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt;, &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt;) are fine. Note that requesting &lt;code&gt;uint64&lt;/code&gt; will draw twice as many bits as &lt;code&gt;uint32&lt;/code&gt; for the same &lt;code&gt;n_words&lt;/code&gt;. This is a convenience for &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; arrays.</source>
          <target state="translated">각 단어의 크기입니다. &lt;code&gt;uint32&lt;/code&gt; 또는 &lt;code&gt;uint64&lt;/code&gt; 여야합니다 . 문자열 ( &lt;code&gt;&amp;lsquo;uint32&amp;rsquo;&lt;/code&gt; , &lt;code&gt;&amp;lsquo;uint64&amp;rsquo;&lt;/code&gt; )이 좋습니다. &lt;code&gt;uint64&lt;/code&gt; 를 요청 하면 동일한 &lt;code&gt;n_words&lt;/code&gt; 에 대해 &lt;code&gt;uint32&lt;/code&gt; 보다 두 배 많은 비트가 그려 집니다 . 이것은 &lt;code&gt;BitGenerator`s that express their states as `uint64&lt;/code&gt; 배열 로 표현하는 BitGenerator 's 의 편의입니다 .</target>
        </trans-unit>
        <trans-unit id="28a984c9bdd908f87770bb977436d6a66f4306a1" translate="yes" xml:space="preserve">
          <source>The size of the array minus 1 in each dimension.</source>
          <target state="translated">각 차원에서 배열의 크기에서 1을 뺀 값입니다.</target>
        </trans-unit>
        <trans-unit id="c41c1278613c7ed690de9865ed90f9449e9899a0" translate="yes" xml:space="preserve">
          <source>The size of the arrays for which the returned indices will be valid.</source>
          <target state="translated">반환 된 인덱스가 유효한 배열의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="d186d8343ee709824ee3589500ce1f21e3851f01" translate="yes" xml:space="preserve">
          <source>The size of the dtype element in bytes.</source>
          <target state="translated">dtype 요소의 크기 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="b0386b240ebd0571b8a05df9bc4fa0aef34289c1" translate="yes" xml:space="preserve">
          <source>The size, along each dimension, of the arrays for which the returned indices can be used.</source>
          <target state="translated">반환 된 인덱스를 사용할 수있는 배열의 각 차원에 따른 크기입니다.</target>
        </trans-unit>
        <trans-unit id="14747cd54a2f3abe194636cc52acff3e4c5bb985" translate="yes" xml:space="preserve">
          <source>The slice is a &lt;em&gt;view&lt;/em&gt; onto the original &lt;code&gt;c_arr&lt;/code&gt; data. So, when we take a view from the ndarray, we return a new ndarray, of the same class, that points to the data in the original.</source>
          <target state="translated">슬라이스는 원래 &lt;code&gt;c_arr&lt;/code&gt; 데이터 에 대한 &lt;em&gt;보기&lt;/em&gt; 입니다. 따라서 ndarray에서 뷰를 가져 오면 원본의 데이터를 가리키는 동일한 클래스의 새 ndarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="eb79b94dc729ec0da33bab5d4cd377a2401e89f0" translate="yes" xml:space="preserve">
          <source>The smaller object to check.</source>
          <target state="translated">확인할 작은 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ebb19de9c6970f0b74d4dc788893b77a8ab0bd68" translate="yes" xml:space="preserve">
          <source>The smallest positive floating point number with full precision (see Notes).</source>
          <target state="translated">완전한 정밀도를 가진 가장 작은 양의 부동 소수점 숫자입니다 (주 참조).</target>
        </trans-unit>
        <trans-unit id="c2b26e02affe13f7769ad145c9ef05f90265c054" translate="yes" xml:space="preserve">
          <source>The smallest positive power of the base (2) that causes overflow.</source>
          <target state="translated">오버플로를 유발하는베이스 (2)의 최소 양의 힘.</target>
        </trans-unit>
        <trans-unit id="52e11ee8daa6593b3d750ee5dc32dda2fcbf193b" translate="yes" xml:space="preserve">
          <source>The smallest positive usable number. Type of &lt;code&gt;tiny&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">사용 가능한 최소 양수 &lt;code&gt;tiny&lt;/code&gt; 타입 적절한 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="af2a8dd9510ac11ca6b963d4ee773dcefbea79aa" translate="yes" xml:space="preserve">
          <source>The smallest representable number, typically &lt;code&gt;-max&lt;/code&gt;.</source>
          <target state="translated">표현할 수있는 가장 작은 수, 일반적으로 &lt;code&gt;-max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a159db5ccf6a60aac5543438bfb54acff104da1e" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 + eps != 1.0&lt;/code&gt;. Type of &lt;code&gt;eps&lt;/code&gt; is an appropriate floating point type.</source>
          <target state="translated">&lt;code&gt;1.0 + eps != 1.0&lt;/code&gt; 과 같이 표현 가능한 가장 작은 양수 입니다. &lt;code&gt;eps&lt;/code&gt; 의 유형은 적절한 부동 소수점 유형입니다.</target>
        </trans-unit>
        <trans-unit id="d9321ebdb39683114ce6992ea6b9cc620e5ef480" translate="yes" xml:space="preserve">
          <source>The smallest representable positive number such that &lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1.0 - epsneg != 1.0&lt;/code&gt; 과 같은 가장 작은 표현 가능한 양수 입니다.</target>
        </trans-unit>
        <trans-unit id="528bc510a2ddc52e9f705a28a08910ff17c4b364" translate="yes" xml:space="preserve">
          <source>The smart way</source>
          <target state="translated">현명한 방법</target>
        </trans-unit>
        <trans-unit id="fdf4e6a27441f2bc059f1e2263f51d77fbf6e55a" translate="yes" xml:space="preserve">
          <source>The so-called F2PY directives allow using F2PY signature file constructs also in Fortran 77/90 source codes. With this feature you can skip (almost) completely intermediate signature file generations and apply F2PY directly to Fortran source codes.</source>
          <target state="translated">소위 F2PY 지시문을 사용하면 Fortran 77/90 소스 코드에서도 F2PY 서명 파일 구조를 사용할 수 있습니다. 이 기능을 사용하면 (거의) 완전한 중간 서명 파일 생성을 건너 뛰고 F2PY를 Fortran 소스 코드에 직접 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fff36344b5ce01b9f9447846bf8f8d0ca8bf20cf" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Chebyshev series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Chebyshev 계열 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="d7b342b5e308288dae8bce1f9ff3a83bc7ae73a3" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Hermite series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Hermite 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="e858f502931c190b84210ff73e4892a2231f8dea" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the HermiteE series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">솔루션은 HermiteE 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다. 가중 제곱 오차의 합을 최소화하는</target>
        </trans-unit>
        <trans-unit id="cac2b42634eddb5565b046dffc57149ff94fb5e5" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Laguerre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Laguerre 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="acc0f8a9120be725868622995211f9656fc88e64" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the Legendre series &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 Legendre 시리즈 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="132408df155a153e982d44f873f2076aed312f9a" translate="yes" xml:space="preserve">
          <source>The solution is the coefficients of the polynomial &lt;code&gt;p&lt;/code&gt; that minimizes the sum of the weighted squared errors</source>
          <target state="translated">해는 가중 제곱 오차의 합을 최소화하는 다항식 &lt;code&gt;p&lt;/code&gt; 의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="727489824facdfd8e793d7820b6d48d439e20ed1" translate="yes" xml:space="preserve">
          <source>The solution minimizes the squared error</source>
          <target state="translated">이 솔루션은 제곱 오차를 최소화합니다</target>
        </trans-unit>
        <trans-unit id="905babbec7af7dc86acc47da182cc43822ce2de5" translate="yes" xml:space="preserve">
          <source>The solution will be to either:</source>
          <target state="translated">해결책은 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ea7110277074b52a752297c7e2a8351687eb1a36" translate="yes" xml:space="preserve">
          <source>The solutions are computed using LAPACK routine &lt;code&gt;_gesv&lt;/code&gt;.</source>
          <target state="translated">솔루션은 LAPACK 루틴 &lt;code&gt;_gesv&lt;/code&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="2324f65c28650d2bb749a64e0d6878a8a423096e" translate="yes" xml:space="preserve">
          <source>The sort order for complex numbers is lexicographic. If both the real and imaginary parts are non-nan then the order is determined by the real parts except when they are equal, in which case the order is determined by the imaginary parts.</source>
          <target state="translated">복소수의 정렬 순서는 사전 식입니다. 실수 부와 허수 부가 모두 난이 아닌 경우, 순서는 동일 할 때를 제외하고 실수 부에서 결정되며,이 경우 순서는 허수 부에 의해 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="94fa27637cf0004fe36c14f580e547f6911b6110" translate="yes" xml:space="preserve">
          <source>The sorted unique values.</source>
          <target state="translated">정렬 된 고유 값</target>
        </trans-unit>
        <trans-unit id="c380c0b74f7e3ca7cbe5b2bb1b45003f6fb70837" translate="yes" xml:space="preserve">
          <source>The sorting algorithm used.</source>
          <target state="translated">사용 된 정렬 알고리즘.</target>
        </trans-unit>
        <trans-unit id="e03d33ebb9f3232a066dd4b0991b32cb56211358" translate="yes" xml:space="preserve">
          <source>The source and destination arrays during assignment.</source>
          <target state="translated">할당 중 소스 및 대상 배열.</target>
        </trans-unit>
        <trans-unit id="2132b1a1146e5e5ced071e842080bf9a009b6944" translate="yes" xml:space="preserve">
          <source>The source array.</source>
          <target state="translated">소스 배열</target>
        </trans-unit>
        <trans-unit id="f3a4e63ab5a7b2b3732df5942d36a724d124f0ea" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python.</source>
          <target state="translated">소스 코드는 Python으로 작성된 객체에 대해서만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cf16b74745b78ed96effaeceb909805fb279ce98" translate="yes" xml:space="preserve">
          <source>The source code is only returned for objects written in Python. Many functions and classes are defined in C and will therefore not return useful information.</source>
          <target state="translated">소스 코드는 Python으로 작성된 객체에 대해서만 반환됩니다. 많은 함수와 클래스는 C로 정의되므로 유용한 정보를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="809a1cfd22069f38c46105c92eebf5c576bb4207" translate="yes" xml:space="preserve">
          <source>The source string can be any valid Fortran code. If you want to save the extension-module source code then a suitable file-name can be provided by the &lt;code&gt;source_fn&lt;/code&gt; keyword to the compile function.</source>
          <target state="translated">소스 문자열은 유효한 Fortran 코드 일 수 있습니다. 확장 모듈 소스 코드를 저장하려면 적절한 파일 이름을 &lt;code&gt;source_fn&lt;/code&gt; 키워드로 컴파일 함수에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd5904ef77ea8bffca88dd379e736043b3ab2537" translate="yes" xml:space="preserve">
          <source>The spacing between sample points when &lt;code&gt;x&lt;/code&gt; is None. The default is 1.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 없음 인 경우 샘플 포인트 사이의 간격 입니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="f3c0291e43c18442ce997268f6d827c51450c140" translate="yes" xml:space="preserve">
          <source>The spacing of values of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값의 간격입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="90f7163cd42de5312873857f6e49d754d0181393" translate="yes" xml:space="preserve">
          <source>The specific algorithm used is as follows.</source>
          <target state="translated">사용되는 특정 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="87dcde88b185fa2a9572c4ddf0c6760b6d6e72a4" translate="yes" xml:space="preserve">
          <source>The specified line is given by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">지정된 행은 &lt;code&gt;off + scl*x&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="80beaa85dfa05c582a58cbd93778b4e21b5c2873" translate="yes" xml:space="preserve">
          <source>The square root of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 제곱근입니다 . 경우 &lt;code&gt;x&lt;/code&gt; 는 스칼라, 그래서입니다 &lt;code&gt;out&lt;/code&gt; 그렇지 않으면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6ffe340425612aa0e424be1bcdd9b7a397555dd0" translate="yes" xml:space="preserve">
          <source>The stacked array has one more dimension than the input arrays.</source>
          <target state="translated">스택 형 배열은 입력 배열보다 차원이 하나 더 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5df163136221ee565809e31a5ec5ce477690b37" translate="yes" xml:space="preserve">
          <source>The standard array can have 24 different data types (and has some support for adding your own types). These data types all have an enumerated type, an enumerated type-character, and a corresponding array scalar Python type object (placed in a hierarchy). There are also standard C typedefs to make it easier to manipulate elements of the given data type. For the numeric types, there are also bit-width equivalent C typedefs and named typenumbers that make it easier to select the precision desired.</source>
          <target state="translated">표준 배열에는 24 가지 데이터 형식이있을 수 있으며 고유 한 형식을 추가 할 수 있습니다. 이러한 데이터 타입은 모두 열거 타입, 열거 타입 문자 및 해당 배열 스칼라 파이썬 타입 객체 (계층 구조로 배치됨)를 갖습니다. 주어진 데이터 유형의 요소를보다 쉽게 ​​조작 할 수 있도록 표준 C typedef도 있습니다. 숫자 유형의 경우 비트 폭에 해당하는 C typedef와 명명 된 typenumber가 있으므로 원하는 정밀도를 쉽게 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45b18b5cfbbed3fbae9c681cc6f3c1fa70483591" translate="yes" xml:space="preserve">
          <source>The standard casting rules ensure that a scalar cannot up-cast an array unless the scalar is of a fundamentally different kind of data (i.e. under a different hierarchy in the data type hierarchy) then the array:</source>
          <target state="translated">표준 캐스팅 규칙은 스칼라가 기본적으로 다른 종류의 데이터가 아닌 경우 (즉, 데이터 유형 계층의 다른 계층 구조) 배열이 아닌 한 스칼라가 배열을 업 캐스트 할 수 없도록합니다.</target>
        </trans-unit>
        <trans-unit id="3b087bfb5ae783fa5041fbcb80716e85b4cfcd9d" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">표준 편차는 평균과의 제곱 편차 평균의 &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; 예 : std = sqrt (mean (abs (x-x.mean ()) ** 2))) .</target>
        </trans-unit>
        <trans-unit id="57c54b3c6804893f71da6c87373c7bbb983d07a9" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean, i.e., &lt;code&gt;std = sqrt(mean(x))&lt;/code&gt;, where &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt;.</source>
          <target state="translated">표준 편차는 평균으로부터의 제곱 편차 평균의 제곱근입니다. 즉, &lt;code&gt;std = sqrt(mean(x))&lt;/code&gt; , 여기서 &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f057ac9f65af78fe632de7c8031e6f6e2ae80dc" translate="yes" xml:space="preserve">
          <source>The standard deviation is the square root of the average of the squared deviations from the mean: &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt;.</source>
          <target state="translated">표준 편차는 평균과의 제곱 편차 평균의 제곱근입니다 : &lt;code&gt;std = sqrt(mean(abs(x - x.mean())**2))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9194bef8dfee2642aab9789d8b2c457a98f783af" translate="yes" xml:space="preserve">
          <source>The standard rules of sequence slicing apply to basic slicing on a per-dimension basis (including using a step index). Some useful concepts to remember include:</source>
          <target state="translated">시퀀스 슬라이싱의 표준 규칙은 차원 별 (단계 인덱스 사용 포함) 기본 슬라이싱에 적용됩니다. 기억해야 할 유용한 개념은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="903735d28aa358318c996f0fbe6f9bd887af58b8" translate="yes" xml:space="preserve">
          <source>The start of the data within the data buffer (an offset relative to the beginning of the data buffer).</source>
          <target state="translated">데이터 버퍼 내에서 데이터의 시작 (데이터 버퍼의 시작에 대한 오프셋)</target>
        </trans-unit>
        <trans-unit id="df2af17caf9f66a81db3bc6a51eb1b52d78258be" translate="yes" xml:space="preserve">
          <source>The start of type numbers used for Custom Data types.</source>
          <target state="translated">사용자 지정 데이터 형식에 사용되는 형식 번호의 시작입니다.</target>
        </trans-unit>
        <trans-unit id="e63c738294e147bc42d8454a2cacbd481d845725" translate="yes" xml:space="preserve">
          <source>The starting value for this product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 제품의 시작 값입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b49e967087e1769cf1a280ea97d2d8fd93d40ef9" translate="yes" xml:space="preserve">
          <source>The starting value of the sequence.</source>
          <target state="translated">시퀀스의 시작 값입니다.</target>
        </trans-unit>
        <trans-unit id="be3a2f4f7af9d19db4503332628441741d474403" translate="yes" xml:space="preserve">
          <source>The state of the returned big generator is jumped as-if 2**(128 * jumps) random numbers have been generated.</source>
          <target state="translated">리턴 된 큰 생성기의 상태는 2 ** (128 * 점프) 난수가 생성 된 것처럼 점프됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0543dedf6d1409b4f87e0823027e644cab05a9" translate="yes" xml:space="preserve">
          <source>The step size is phi-1 when multiplied by 2**128 where phi is the golden ratio.</source>
          <target state="translated">단계 크기는 2 ** 128을 곱하면 phi-1이며 여기서 phi는 황금비입니다.</target>
        </trans-unit>
        <trans-unit id="ed6404a00884e4a1c814b4fe32b4f8e4142164f0" translate="yes" xml:space="preserve">
          <source>The steps are:</source>
          <target state="translated">단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="da99252ecc9a954c9ea523c42dd589060111b276" translate="yes" xml:space="preserve">
          <source>The strides of the array. How many bytes needed to jump to the next element in each dimension.</source>
          <target state="translated">배열의 보폭. 각 차원에서 다음 요소로 이동하는 데 필요한 바이트 수</target>
        </trans-unit>
        <trans-unit id="6bea4f23f51bf1c5c1b134b3c31652eb62271512" translate="yes" xml:space="preserve">
          <source>The strides of the new array. Defaults to &lt;code&gt;x.strides&lt;/code&gt;.</source>
          <target state="translated">새로운 배열의 보폭. 기본값은 &lt;code&gt;x.strides&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0e7d4c32101a82d4a575c51fa47c579d84a90ccb" translate="yes" xml:space="preserve">
          <source>The string character corresponding to the scalar type.</source>
          <target state="translated">스칼라 유형에 해당하는 문자열 문자입니다.</target>
        </trans-unit>
        <trans-unit id="280cdfd9e5006321af13d97ed1dea840dc6157dc" translate="yes" xml:space="preserve">
          <source>The string representation of a structured datatype is shown in the &amp;ldquo;list of tuples&amp;rdquo; form if possible, otherwise numpy falls back to using the more general dictionary form.</source>
          <target state="translated">구조화 된 데이터 유형의 문자열 표현은 가능한 경우 &quot;튜플 목록&quot;형식으로 표시됩니다. 그렇지 않으면 numpy가보다 일반적인 사전 형식을 사용하는 것으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="56e3689374848f3f51b64947b16bec4c3ea61c9e" translate="yes" xml:space="preserve">
          <source>The string representation of an array.</source>
          <target state="translated">배열의 문자열 표현.</target>
        </trans-unit>
        <trans-unit id="3e6678ed1379ae4a29d74cf130ddd533a3d54faa" translate="yes" xml:space="preserve">
          <source>The string representation of the floating point value</source>
          <target state="translated">부동 소수점 값의 문자열 표현</target>
        </trans-unit>
        <trans-unit id="a73fe28c8757ab0f0da0e2f4243de7dc56a5b482" translate="yes" xml:space="preserve">
          <source>The string separating numbers in the data; extra whitespace between elements is also ignored.</source>
          <target state="translated">데이터에서 숫자를 구분하는 문자열입니다. 요소 사이의 추가 공백도 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3dd7799be74e76e0df59b70e60e88893f1e79944" translate="yes" xml:space="preserve">
          <source>The string to load.</source>
          <target state="translated">로드 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="fe1a3737165141949913fff90aaf8e13cf8c53af" translate="yes" xml:space="preserve">
          <source>The string to test for equality against the expected string.</source>
          <target state="translated">예상 문자열과의 동등성을 테스트 할 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="abd4042bc9b171ded494b956ae5b9d9577f995c1" translate="yes" xml:space="preserve">
          <source>The string used to separate values. By default, any consecutive whitespaces act as delimiter. An integer or sequence of integers can also be provided as width(s) of each field.</source>
          <target state="translated">값을 구분하는 데 사용되는 문자열입니다. 기본적으로 모든 연속 공백은 구분 기호로 작동합니다. 정수 또는 정수 시퀀스는 또한 각 필드의 폭으로 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af52fb130d33fe69945cefb6f52e5cf4ca3f8766" translate="yes" xml:space="preserve">
          <source>The string used to separate values. For backwards compatibility, byte strings will be decoded as &amp;lsquo;latin1&amp;rsquo;. The default is whitespace.</source>
          <target state="translated">값을 구분하는 데 사용되는 문자열입니다. 이전 버전과의 호환성을 위해 바이트 문자열은 'latin1'으로 디코딩됩니다. 기본값은 공백입니다.</target>
        </trans-unit>
        <trans-unit id="9d54c543599ad13e3bb6b6bb26859ee068b06992" translate="yes" xml:space="preserve">
          <source>The strings produced by the Python float.hex method can be used as input for floats.</source>
          <target state="translated">Python float.hex 메소드에 의해 생성 된 문자열은 float의 입력으로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e980753b02b50913c2b5e0d5a5fa0dd49eac85d" translate="yes" xml:space="preserve">
          <source>The structured dtype of the output array</source>
          <target state="translated">출력 배열의 구조화 된 dtype</target>
        </trans-unit>
        <trans-unit id="05daa592464e6166b985d1ccf981f505cab14119" translate="yes" xml:space="preserve">
          <source>The sub-arrays whose main diagonals we just obtained; note that each corresponds to fixing the right-most (column) axis, and that the diagonals are &amp;ldquo;packed&amp;rdquo; in rows.</source>
          <target state="translated">우리가 방금 얻은 주요 대각선의 하위 배열; 각각은 가장 오른쪽 (열) 축 고정에 해당하며 대각선은 행으로 &quot;포장&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="032fe52a10dbbb96d8d2155ebf017c5a37d540fb" translate="yes" xml:space="preserve">
          <source>The sub-diagonal at and below which the array is filled. &lt;code&gt;k&lt;/code&gt; = 0 is the main diagonal, while &lt;code&gt;k&lt;/code&gt; &amp;lt; 0 is below it, and &lt;code&gt;k&lt;/code&gt; &amp;gt; 0 is above. The default is 0.</source>
          <target state="translated">배열이 채워지는 하위 대각선 at와 그 아래. &lt;code&gt;k&lt;/code&gt; = 0은 주 대각선이고 &lt;code&gt;k&lt;/code&gt; &amp;lt;0은 그 아래에 있고 &lt;code&gt;k&lt;/code&gt; &amp;gt; 0은 위에 있습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="8e6c361139d8c7c0ac565e0bf2e23b72d7fed91d" translate="yes" xml:space="preserve">
          <source>The subarrays &lt;code&gt;grid[k]&lt;/code&gt; contains the N-D array of indices along the &lt;code&gt;k-th&lt;/code&gt; axis. Explicitly:</source>
          <target state="translated">서브 어레이 &lt;code&gt;grid[k]&lt;/code&gt; 는 &lt;code&gt;k-th&lt;/code&gt; 축을 따라 ND 인덱스 배열을 포함합니다 . 명시 적으로 :</target>
        </trans-unit>
        <trans-unit id="c73621fe8c8d7b0663f28b8d7e7772440297f53c" translate="yes" xml:space="preserve">
          <source>The subscripts string is a comma-separated list of subscript labels, where each label refers to a dimension of the corresponding operand. Whenever a label is repeated it is summed, so &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;np.inner(a,b)&lt;/code&gt;&lt;/a&gt;. If a label appears only once, it is not summed, so &lt;code&gt;np.einsum('i', a)&lt;/code&gt; produces a view of &lt;code&gt;a&lt;/code&gt; with no changes. A further example &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; describes traditional matrix multiplication and is equivalent to &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;np.matmul(a,b)&lt;/code&gt;&lt;/a&gt;. Repeated subscript labels in one operand take the diagonal. For example, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; is equivalent to &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;np.trace(a)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첨자 문자열은 쉼표로 구분 된 첨자 레이블 목록입니다. 여기서 각 레이블은 해당 피연산자의 차원을 나타냅니다. 레이블이 반복 될 때마다 레이블이 합산되므로 &lt;code&gt;np.einsum('i,i', a, b)&lt;/code&gt; 는 &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;np.inner(a,b)&lt;/code&gt; &lt;/a&gt; . 레이블은 한 번만 나타날 경우 그래서, 그것은 합산되지 &lt;code&gt;np.einsum('i', a)&lt;/code&gt; 의 전망 생산 변경하지 있습니다. &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 의 다른 예 는 전통적인 행렬 곱셈을 설명하며 &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;np.matmul(a,b)&lt;/code&gt; &lt;/a&gt; . 한 피연산자의 반복 첨자 레이블은 대각선을 사용합니다. 예를 들어, &lt;code&gt;np.einsum('ii', a)&lt;/code&gt; 는 &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;np.trace(a)&lt;/code&gt; &lt;/a&gt; 와 같습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67e5fbff128f593f5baf173c69fe839b3262add2" translate="yes" xml:space="preserve">
          <source>The substring to search for.</source>
          <target state="translated">검색 할 하위 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="965c999c4a333ea7538f32117fa173b48c1340d4" translate="yes" xml:space="preserve">
          <source>The sum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 의 합은 요소 별입니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="6ad40e475222ea9afc0452e8c7fd45129517c8c0" translate="yes" xml:space="preserve">
          <source>The sum of an empty array is the neutral element 0:</source>
          <target state="translated">빈 배열의 합은 중립 요소 0입니다.</target>
        </trans-unit>
        <trans-unit id="d51acbb68e0ec9e47200775b381bf1325a23c32a" translate="yes" xml:space="preserve">
          <source>The sum of the inputs. If either input is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">입력의 합입니다. 입력이 poly1d 객체이면 출력도 poly1d 객체입니다. 그렇지 않으면 다항식 계수의 1D 배열이 최고에서 최저까지입니다.</target>
        </trans-unit>
        <trans-unit id="a83a6a324c47c50fcc7b05d36f9de3513626990f" translate="yes" xml:space="preserve">
          <source>The suppression behavior is selected with the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 동작으로 억제 동작이 선택됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac5e9039faffaa312745861609180dbee345923d" translate="yes" xml:space="preserve">
          <source>The symbol suffix avoids the symbol name clashes between 32-bit and 64-bit BLAS/LAPACK libraries.</source>
          <target state="translated">기호 접미사는 32 비트 및 64 비트 BLAS / LAPACK 라이브러리 간의 기호 이름 충돌을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="d22d2ca3e9d62707042d4e5eab8a754482cb7bf9" translate="yes" xml:space="preserve">
          <source>The syntax of signature files is presented below.</source>
          <target state="translated">서명 파일의 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="dc008fb51ab0096c0ab2810136d6a94b39d8b6ae" translate="yes" xml:space="preserve">
          <source>The syntax specification for signature files (.pyf files) is borrowed from the Fortran 90/95 language specification. Almost all Fortran 90/95 standard constructs are understood, both in free and fixed format (recall that Fortran 77 is a subset of Fortran 90/95). F2PY introduces also some extensions to Fortran 90/95 language specification that help designing Fortran to Python interface, make it more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="translated">서명 파일 (.pyf 파일)에 대한 구문 사양은 Fortran 90/95 언어 사양에서 차용되었습니다. 거의 모든 Fortran 90/95 표준 구성은 자유 형식과 고정 형식 모두에서 이해됩니다 (Fortran 77은 Fortran 90/95의 하위 집합입니다). F2PY는 또한 Fortran을 Python 인터페이스로 설계하는 데 도움이되는 Fortran 90/95 언어 사양의 일부 확장을 도입하여보다 &quot;Pythonic&quot;으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="4cac57b443c7e139444cef039c708d06cc974fbe" translate="yes" xml:space="preserve">
          <source>The t test is based on an assumption that the data come from a Normal distribution. The t test provides a way to test whether the sample mean (that is the mean calculated from the data) is a good estimate of the true mean.</source>
          <target state="translated">t 검정은 데이터가 정규 분포에서 나온 것으로 가정합니다. t 검정은 표본 평균 (데이터에서 계산 된 평균)이 실제 평균의 적절한 추정값인지 여부를 테스트하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="09daeca7b9767c35345c4b41aa696722f6d0ab8e" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB expressions. These are similar expressions, not equivalents. For details, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;documentation&lt;/a&gt;.</source>
          <target state="translated">아래 표는 몇 가지 일반적인 MATLAB 표현식에 대한 대략적인 등가물을 제공합니다. 이것들은 동등한 표현이 아니라 비슷한 표현입니다. 자세한 내용은 &lt;a href=&quot;../reference/index#reference&quot;&gt;설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9a7fcb5dad38e6ecd0517ba513e487ccaccafb31" translate="yes" xml:space="preserve">
          <source>The table below gives rough equivalents for some common MATLAB&amp;reg; expressions. &lt;strong&gt;These are not exact equivalents&lt;/strong&gt;, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.</source>
          <target state="translated">아래 표는 몇 가지 일반적인 MATLAB&amp;reg; 표현식에 대한 대략적인 등가물을 제공합니다. &lt;strong&gt;이것들은 정확히 동등한&lt;/strong&gt; 것은 아니지만 올바른 방향으로 나아 가기위한 힌트로 받아 들여야합니다. 자세한 내용은 NumPy 함수에 대한 내장 문서를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="1feedf873323b1df0d515f29065f1cceac91a5f6" translate="yes" xml:space="preserve">
          <source>The template language blocks are delimited by &lt;code&gt;/**begin repeat&lt;/code&gt; and &lt;code&gt;/**end repeat**/&lt;/code&gt; lines, which may also be nested using consecutively numbered delimiting lines such as &lt;code&gt;/**begin repeat1&lt;/code&gt; and &lt;code&gt;/**end repeat1**/&lt;/code&gt;:</source>
          <target state="translated">템플릿 언어 블록은 &lt;code&gt;/**begin repeat&lt;/code&gt; 및 &lt;code&gt;/**end repeat**/&lt;/code&gt; 행으로 구분되며, &lt;code&gt;/**begin repeat1&lt;/code&gt; 및 &lt;code&gt;/**end repeat1**/&lt;/code&gt; 과 같이 연속적으로 번호가 지정된 구분선을 사용하여 중첩 될 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a419cbcd05b123b547d845ae2a3bfd3fd96fc50" translate="yes" xml:space="preserve">
          <source>The tensor dot product of the input.</source>
          <target state="translated">입력의 텐서 도트 곱.</target>
        </trans-unit>
        <trans-unit id="babafa633a1d5ffe1e85308352efa2b576e666e1" translate="yes" xml:space="preserve">
          <source>The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are, however, cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation.</source>
          <target state="translated">브로드 캐스팅이라는 용어는 산술 연산 중에 numpy가 다른 모양의 배열을 처리하는 방법을 설명합니다. 특정 제약 조건에 따라 더 작은 배열은 더 큰 배열에 &quot;브로드 캐스트&quot;되어 호환되는 모양을 갖습니다. 브로드 캐스팅은 배열 작업을 벡터화하는 수단을 제공하여 Python 대신 C에서 루핑이 발생하도록합니다. 불필요한 데이터 복사본을 만들지 않고이를 수행하며 일반적으로 효율적인 알고리즘 구현으로 이어집니다. 그러나 방송이 메모리를 비효율적으로 사용하여 계산 속도를 늦추기 때문에 좋지 않은 생각이있는 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0567674780e936db24c51c4154cb1e7bb19a5fb1" translate="yes" xml:space="preserve">
          <source>The test can also be inverted:</source>
          <target state="translated">테스트는 반전 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a043640318788c216d9c35c72474b86e64a58875" translate="yes" xml:space="preserve">
          <source>The test is equivalent to &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; (note that &lt;code&gt;allclose&lt;/code&gt; has different default values). It compares the difference between &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; to &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt;.</source>
          <target state="translated">테스트는 &lt;code&gt;allclose(actual, desired, rtol, atol)&lt;/code&gt; ( &lt;code&gt;allclose&lt;/code&gt; 는 다른 기본값 을 가짐 ). &lt;code&gt;actual&lt;/code&gt; 와 &lt;code&gt;desired&lt;/code&gt; 차이 를 &lt;code&gt;atol + rtol * abs(desired)&lt;/code&gt; 와 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="d949a99e166ed49b879032942f22bd239ac73b6e" translate="yes" xml:space="preserve">
          <source>The test is marked as skipped if &lt;code&gt;SkipMyTest&lt;/code&gt; evaluates to nonzero, and the message in verbose test output is the second argument given to &lt;code&gt;skipif&lt;/code&gt;. Similarly, a test can be marked as a known failure by using &lt;code&gt;xfail&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;SkipMyTest&lt;/code&gt; 가 0이 아닌 것으로 평가 되면 테스트는 건너 뛴 것으로 표시되며 자세한 테스트 출력의 메시지는 &lt;code&gt;skipif&lt;/code&gt; 에 제공된 두 번째 인수 입니다. 마찬가지로 &lt;code&gt;xfail&lt;/code&gt; 을 사용하여 테스트를 알려진 실패로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7223f3e04a5764585f35605ea5b6d016c41f2fa7" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring &lt;a href=&quot;#numpy.test&quot;&gt;&lt;code&gt;numpy.test&lt;/code&gt;&lt;/a&gt; for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">테스트 방법은 두 개 이상의 인수를 취할 수 있습니다. 첫 번째 &lt;code&gt;label&lt;/code&gt; 은 테스트해야 할 항목을 지정하는 문자열이고 두 번째 &lt;code&gt;verbose&lt;/code&gt; 는 출력 상세 수준을 제공하는 정수입니다. 자세한 내용은 docstring &lt;a href=&quot;#numpy.test&quot;&gt; &lt;code&gt;numpy.test&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;label&lt;/code&gt; 의 기본값 은 'fast'이며 표준 테스트를 실행합니다. 'full'문자열은 실행 속도가 느린 것으로 확인 된 테스트를 포함하여 전체 테스트 배터리를 실행합니다. 경우 &lt;code&gt;verbose&lt;/code&gt; 적은 1 또는, 테스트는 실행되는 테스트에 대한 정보 메시지를 표시합니다; 그러나 1보다 크면 테스트는 누락 된 테스트에 대한 경고도 제공합니다. 따라서 모든 테스트를 실행하고 테스트가없는 모듈에 대한 메시지를 받으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="85bd6917449fe181340a2938e0dac494fbfea5fe" translate="yes" xml:space="preserve">
          <source>The test method may take two or more arguments; the first, &lt;code&gt;label&lt;/code&gt; is a string specifying what should be tested and the second, &lt;code&gt;verbose&lt;/code&gt; is an integer giving the level of output verbosity. See the docstring for numpy.test for details. The default value for &lt;code&gt;label&lt;/code&gt; is &amp;lsquo;fast&amp;rsquo; - which will run the standard tests. The string &amp;lsquo;full&amp;rsquo; will run the full battery of tests, including those identified as being slow to run. If &lt;code&gt;verbose&lt;/code&gt; is 1 or less, the tests will just show information messages about the tests that are run; but if it is greater than 1, then the tests will also provide warnings on missing tests. So if you want to run every test and get messages about which modules don&amp;rsquo;t have tests:</source>
          <target state="translated">테스트 방법은 두 개 이상의 인수를 취할 수 있습니다. 첫 번째, &lt;code&gt;label&lt;/code&gt; 은 테스트 대상을 지정하는 문자열이고 두 번째, &lt;code&gt;verbose&lt;/code&gt; 는 출력 상세 수준을 제공하는 정수입니다. 자세한 내용은 numpy.test에 대한 docstring을 참조하십시오. &lt;code&gt;label&lt;/code&gt; 의 기본값 은 'fast'입니다. 표준 테스트가 실행됩니다. 문자열 'full'은 실행 속도가 느린 것으로 확인 된 테스트를 포함하여 전체 테스트 배터리를 실행합니다. 경우 &lt;code&gt;verbose&lt;/code&gt; 적은 1 또는, 테스트는 실행되는 테스트에 대한 정보 메시지를 표시합니다; 그러나 1보다 크면 테스트는 누락 된 테스트에 대한 경고도 제공합니다. 따라서 모든 테스트를 실행하고 테스트가없는 모듈에 대한 메시지를 얻으려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="03733f354e779af14d028cdbdf0476c16657d14e" translate="yes" xml:space="preserve">
          <source>The test to label as slow.</source>
          <target state="translated">레이블을 느리게 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="28bda9f13cb5fd35de4d1871d5d1a6b158a05b66" translate="yes" xml:space="preserve">
          <source>The test verifies identical shapes and that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">테스트는 동일한 모양과 &lt;code&gt;actual&lt;/code&gt; 및 &lt;code&gt;desired&lt;/code&gt; 요소가 충족 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="a7fabe2aaa71feebc60270bd4d75ad9164f05bed" translate="yes" xml:space="preserve">
          <source>The test verifies that the elements of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; satisfy.</source>
          <target state="translated">이 테스트는 &lt;code&gt;actual&lt;/code&gt; 및 &lt;code&gt;desired&lt;/code&gt; 요소가 충족 되는지 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="bf9247f40709953bae5128ab011a3c6a23e1bb6b" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points &lt;code&gt;(x, y, z)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; must have the same shape. If any of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">3 차원 계열은 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 에서 평가되며 , 여기서 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 는 동일한 모양을 가져야합니다. 임의의 경우 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 또는 &lt;code&gt;z&lt;/code&gt; 목록 또는 튜플, 그것은 먼저, 그렇지 않으면 그대로 방치하고 ndarray가 아닌 경우는 스칼라로 취급 ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="ababec7c614f8cc809a5f4b9df993b70ee13a8f8" translate="yes" xml:space="preserve">
          <source>The three dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt;,`y`, or &lt;code&gt;z&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">3 차원 계열은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 데카르트 곱의 점에서 평가됩니다 . 경우 &lt;code&gt;x&lt;/code&gt; `y`, 또는 &lt;code&gt;z&lt;/code&gt; 목록 또는 튜플, 그것은 먼저 그것이 ndarray하지 않으면, 그렇지 않으면 그것은 스칼라로 처리되어, 변경되지 않은 상태로되고, ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="3f792b485609224acbb4d7367551edb56b3d1d82" translate="yes" xml:space="preserve">
          <source>The three division operators are all defined; &lt;code&gt;div&lt;/code&gt; is active by default, &lt;code&gt;truediv&lt;/code&gt; is active when &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt;&lt;code&gt;__future__&lt;/code&gt;&lt;/a&gt; division is in effect.</source>
          <target state="translated">세 개의 구분 연산자가 모두 정의되어 있습니다. &lt;code&gt;div&lt;/code&gt; 는 기본적으로 활성화되어 있으며 &lt;a href=&quot;https://docs.python.org/dev/library/__future__.html#module-__future__&quot;&gt; &lt;code&gt;__future__&lt;/code&gt; &lt;/a&gt; 나누기가 유효한 경우 &lt;code&gt;truediv&lt;/code&gt; 가 활성화됩니다 .</target>
        </trans-unit>
        <trans-unit id="6953aff01d51815d13e09f72484f920fa7369db2" translate="yes" xml:space="preserve">
          <source>The thresholds above deal with floating point roundoff error in the calculation of the SVD. However, you may have more information about the sources of error in &lt;code&gt;M&lt;/code&gt; that would make you consider other tolerance values to detect &lt;em&gt;effective&lt;/em&gt; rank deficiency. The most useful measure of the tolerance depends on the operations you intend to use on your matrix. For example, if your data come from uncertain measurements with uncertainties greater than floating point epsilon, choosing a tolerance near that uncertainty may be preferable. The tolerance may be absolute if the uncertainties are absolute rather than relative.</source>
          <target state="translated">위의 임계 값은 SVD 계산에서 부동 소수점 반올림 오류를 처리합니다. 그러나 &lt;em&gt;유효&lt;/em&gt; 순위 부족 을 탐지하기 위해 다른 공차 값을 고려할 수 있는 &lt;code&gt;M&lt;/code&gt; 의 오차 원인에 대한 자세한 정보 가있을 수 있습니다 . 가장 유용한 공차 측정은 매트릭스에서 사용하려는 작업에 따라 다릅니다. 예를 들어, 데이터가 부동 소수점 엡실론보다 큰 불확실성을 가진 불확실한 측정에서 나온 경우, 그 불확실성에 가까운 공차를 선택하는 것이 좋습니다. 불확실성이 상대적인 것이 아니라 절대적인 경우 허용 오차는 절대적 일 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="64c20447e1e6f9694ec0f7bb75ec43f4f4cb6058" translate="yes" xml:space="preserve">
          <source>The tiled output array.</source>
          <target state="translated">타 일식 출력 배열</target>
        </trans-unit>
        <trans-unit id="8bc4b16e1cf995efdf33020e8a2b8f7760d88f9e" translate="yes" xml:space="preserve">
          <source>The time required to produce using multiple threads can be compared to the time required to generate using a single thread.</source>
          <target state="translated">여러 스레드를 사용하여 생성하는 데 필요한 시간을 단일 스레드를 사용하여 생성하는 데 필요한 시간을 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcdefbec5fdfd59d604b41a08eaf1010ff1f9f3b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">아래 타이밍은 특정 분포에서 1 개의 임의 값을 생성하는 시간 (ns)입니다. 원래 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 생성기는 더 빠른 생성기의 출력과 동일하게하기 위해 2 개의 32 비트 값이 필요하기 때문에 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="343a5bcbcad72b541893cb8c8e45cc7f466bba8b" translate="yes" xml:space="preserve">
          <source>The timings below are the time in ns to produce 1 random value from a specific distribution. The original &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; generator is much slower since it requires 2 32-bit values to equal the output of the faster generators.</source>
          <target state="translated">아래의 타이밍은 특정 분포에서 1 개의 임의 값을 생성하는 시간 (ns)입니다. 원래 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 생성기는 더 빠른 생성기의 출력과 같도록 2 개의 32 비트 값이 필요하므로 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="1d2c30ac9be07be723e9ef95eaf137f9bc73af0a" translate="yes" xml:space="preserve">
          <source>The tolerance values are positive, typically very small numbers. The relative difference (&lt;code&gt;rtol&lt;/code&gt; * abs(&lt;code&gt;b&lt;/code&gt;)) and the absolute difference &lt;code&gt;atol&lt;/code&gt; are added together to compare against the absolute difference between &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">공차 값은 양수이며 일반적으로 매우 작은 수입니다. 상대 차이 ( &lt;code&gt;rtol&lt;/code&gt; * abs ( &lt;code&gt;b&lt;/code&gt; ))와 절대 차이 &lt;code&gt;atol&lt;/code&gt; 이 함께 더해 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 절대 차이를 비교합니다 .</target>
        </trans-unit>
        <trans-unit id="52a51aeadfd53cc309968068f2e1965d359a3909" translate="yes" xml:space="preserve">
          <source>The total broadcasted size.</source>
          <target state="translated">방송 된 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="df3d0e81279bb92508eaea005084a0b02573f0f5" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt;&lt;code&gt;NPY_MAXARGS&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">총 인수 수 ( &lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt; ). &lt;a href=&quot;array#c.NPY_MAXARGS&quot;&gt; &lt;code&gt;NPY_MAXARGS&lt;/code&gt; &lt;/a&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="1470f5efa816c498ec2cdd99dd6bc7fe2a058b68" translate="yes" xml:space="preserve">
          <source>The total number of arguments (&lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt;). This must be less than &lt;code&gt;NPY_MAXARGS&lt;/code&gt;.</source>
          <target state="translated">총 인수 수 ( &lt;em&gt;nin&lt;/em&gt; + &lt;em&gt;nout&lt;/em&gt; ). &lt;code&gt;NPY_MAXARGS&lt;/code&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="af0d1953b87871e5f5c2cfb05eba9aaf99050200" translate="yes" xml:space="preserve">
          <source>The total number of built-in NumPy types. The enumeration covers the range from 0 to NPY_NTYPES-1.</source>
          <target state="translated">내장 된 NumPy 유형의 총 수 열거는 0에서 NPY_NTYPES-1까지의 범위를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="abe92a5e4aa66a77153ec46749bbd30d898eb468" translate="yes" xml:space="preserve">
          <source>The total number of masked elements (axis=None) or the number of masked elements along each slice of the given axis.</source>
          <target state="translated">주어진 축의 각 슬라이스를 따라 마스크 된 요소의 총 수 (축 = 없음) 또는 마스크 된 요소의 수입니다.</target>
        </trans-unit>
        <trans-unit id="7423c677797c62eaba11c700e763c8330a87769e" translate="yes" xml:space="preserve">
          <source>The total payment is made up of payment against principal plus interest.</source>
          <target state="translated">총 지불은 원금과이자에 대한 지불로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="b7226d44903c768f342634b37f3cd2cbe870d83c" translate="yes" xml:space="preserve">
          <source>The total size of the underlying array.</source>
          <target state="translated">기본 배열의 총 크기입니다.</target>
        </trans-unit>
        <trans-unit id="b17ef49a2b827517f40e328c2cdae6675b6f65d6" translate="yes" xml:space="preserve">
          <source>The transform for real input is performed over the last transformation axis, as by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, then the transform over the remaining axes is performed as by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;. The order of the output is as for &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt; for the remaining transformation axes.</source>
          <target state="translated">실제 입력에 대한 변환은 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 에 의해 마지막 변환 축에 대해 수행 된 다음 나머지 축에 대한 변환은 &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; 에&lt;/a&gt; 의해 수행됩니다 . 출력 순서에 관해서이다 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 및에 대해, 최종 변환 축 &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; 나머지 변환 축의.</target>
        </trans-unit>
        <trans-unit id="85975e151b66ed8086ffe0edc17f692849490b8d" translate="yes" xml:space="preserve">
          <source>The transpose of a C-ordered array is a FORTRAN-ordered array.</source>
          <target state="translated">C 순서 배열의 조옮김은 FORTRAN 순서 배열입니다.</target>
        </trans-unit>
        <trans-unit id="be8d0d980a1c43a49c10382a49da454ce905c4ef" translate="yes" xml:space="preserve">
          <source>The transposed array.</source>
          <target state="translated">전치 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ded8f77d9cba6691688303bd624c72d17c97324f" translate="yes" xml:space="preserve">
          <source>The tree in &lt;code&gt;numpy&lt;/code&gt; will now have the latest changes from the initial repository.</source>
          <target state="translated">이제 &lt;code&gt;numpy&lt;/code&gt; 의 트리에 초기 저장소의 최신 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="362e7b5f1deb8afe588bc61b11c57a486aa6b58d" translate="yes" xml:space="preserve">
          <source>The triangular distribution is a continuous probability distribution with lower limit left, peak at mode, and upper limit right. Unlike the other distributions, these parameters directly define the shape of the pdf.</source>
          <target state="translated">삼각 분포는 하한이 왼쪽이고, 피크가 모드이며 상한이 오른쪽 인 연속 확률 분포입니다. 다른 분포와 달리이 매개 변수는 pdf의 모양을 직접 정의합니다.</target>
        </trans-unit>
        <trans-unit id="1d2039a815b5ec90474a824463e862d2894a1c82" translate="yes" xml:space="preserve">
          <source>The triangular distribution is often used in ill-defined problems where the underlying distribution is not known, but some knowledge of the limits and mode exists. Often it is used in simulations.</source>
          <target state="translated">삼각 분포는 기본 분포가 알려져 있지 않지만 한계와 모드에 대한 지식이 존재하는 잘못 정의 된 문제에서 종종 사용됩니다. 종종 시뮬레이션에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a93dc1adb33729debf6e5480c2814c2157666fd" translate="yes" xml:space="preserve">
          <source>The triangular window, with the maximum value normalized to one (the value one appears only if the number of samples is odd), with the first and last samples equal to zero.</source>
          <target state="translated">최대 값이 1로 정규화 된 삼각형 창 (샘플 수가 홀수 인 경우에만 값 1이 나타남)은 첫 번째 샘플과 마지막 샘플이 0입니다.</target>
        </trans-unit>
        <trans-unit id="24e66129ed79808afe1e2c37f4c9f61c91ca2839" translate="yes" xml:space="preserve">
          <source>The true value of &lt;code&gt;exp(1e-10) - 1&lt;/code&gt; is &lt;code&gt;1.00000000005e-10&lt;/code&gt; to about 32 significant digits. This example shows the superiority of expm1 in this case.</source>
          <target state="translated">&lt;code&gt;exp(1e-10) - 1&lt;/code&gt; 의 실제 값 은 &lt;code&gt;1.00000000005e-10&lt;/code&gt; 에서 약 32 자리 유효 숫자입니다. 이 예는이 경우 expm1의 우수성을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="973da8e077b17711228349d2b08c7d0d4f2d3661" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="0cef9d8907fc4d88debbd9a6424b4425ec58e68f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of the last axis transformed will be &lt;code&gt;s[-1]//2+1&lt;/code&gt;, while the remaining transformed axes will have lengths according to &lt;code&gt;s&lt;/code&gt;, or unchanged from the input.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 . 변환 된 마지막 축의 길이는 &lt;code&gt;s[-1]//2+1&lt;/code&gt; 이고 나머지 변환 된 축의 길이는 &lt;code&gt;s&lt;/code&gt; 에 따라 또는 입력에서 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c91d131105a38ed60b366938edb9bb82399cba7" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 .</target>
        </trans-unit>
        <trans-unit id="879b9a05c20a089a225b78254a5b2e292b149d60" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or by a combination of &lt;code&gt;s&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt;, as explained in the parameters section above. The length of each transformed axis is as given by the corresponding element of &lt;code&gt;s&lt;/code&gt;, or the length of the input in every axis except for the last one if &lt;code&gt;s&lt;/code&gt; is not given. In the final transformed axis the length of the output when &lt;code&gt;s&lt;/code&gt; is not given is &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the final transformed axis of the input. To get an odd number of output points in the final axis, &lt;code&gt;s&lt;/code&gt; must be specified.</source>
          <target state="translated">절단 또는 제로 패딩 된 입력 은 위의 매개 변수 섹션에 설명 된대로 &lt;code&gt;axes&lt;/code&gt; 또는 &lt;code&gt;s&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 의 조합으로 표시된 축을 따라 변환됩니다 . 변환 된 각 축의 길이는 &lt;code&gt;s&lt;/code&gt; 의 해당 요소 또는 &lt;code&gt;s&lt;/code&gt; 를 지정하지 않은 경우 마지막 축을 제외한 모든 축의 입력 길이에 의해 지정됩니다. 최종 변환 축에서 &lt;code&gt;s&lt;/code&gt; 가 주어지지 않을 때 의 출력 길이 는 &lt;code&gt;2*(m-1)&lt;/code&gt; 이며, 여기서 &lt;code&gt;m&lt;/code&gt; 은 입력의 최종 변환 축의 길이입니다. 최종 축에서 홀수 개의 출력 점을 얻으려면 &lt;code&gt;s&lt;/code&gt; 를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="933c6e0a0fb2fd7449c8d46cb7e6572b1c3279dd" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axes indicated by &lt;code&gt;axes&lt;/code&gt;, or the last two axes if &lt;code&gt;axes&lt;/code&gt; is not given.</source>
          <target state="translated">축을 따라 변환 절단 또는 제로 패딩 입력에 의해 나타낸 &lt;code&gt;axes&lt;/code&gt; 있으면, 마지막 두 축의 &lt;code&gt;axes&lt;/code&gt; 주어지지 않는다.</target>
        </trans-unit>
        <trans-unit id="bdca2715ebaff6edc1c47e7d7cb69eb535ec549b" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다.</target>
        </trans-unit>
        <trans-unit id="f4095a8db5d8ecd4ba9c0d3227d91d6c6751102f" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. If &lt;code&gt;n&lt;/code&gt; is even, the length of the transformed axis is &lt;code&gt;(n/2)+1&lt;/code&gt;. If &lt;code&gt;n&lt;/code&gt; is odd, the length is &lt;code&gt;(n+1)/2&lt;/code&gt;.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 경우 &lt;code&gt;n&lt;/code&gt; 이 짝수, 변환 축의 길이는 &lt;code&gt;(n/2)+1&lt;/code&gt; . 경우 &lt;code&gt;n&lt;/code&gt; 이 홀수이고, 길이는 &lt;code&gt;(n+1)/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="210fa87b6170797ddb3ab263d911a488e3f1f97e" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 변환 된 축의 길이는 &lt;code&gt;n//2 + 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1026feb255ba9e4ae695f12a04d60bbc57c49ac5" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified.</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 변환 된 축의 길이는 &lt;code&gt;n&lt;/code&gt; 이거나, &lt;code&gt;n&lt;/code&gt; 을 지정하지 않으면 &lt;code&gt;2*(m-1)&lt;/code&gt; 입니다. 여기서 &lt;code&gt;m&lt;/code&gt; 은 입력의 변환 된 축의 길이입니다. 홀수 개의 출력 포인트를 얻으려면 &lt;code&gt;n&lt;/code&gt; 을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="785f913e97e6f2c077e366a11b3d02d03922b2c4" translate="yes" xml:space="preserve">
          <source>The truncated or zero-padded input, transformed along the axis indicated by &lt;code&gt;axis&lt;/code&gt;, or the last one if &lt;code&gt;axis&lt;/code&gt; is not specified. The length of the transformed axis is &lt;code&gt;n&lt;/code&gt;, or, if &lt;code&gt;n&lt;/code&gt; is not given, &lt;code&gt;2*m - 2&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the transformed axis of the input. To get an odd number of output points, &lt;code&gt;n&lt;/code&gt; must be specified, for instance as &lt;code&gt;2*m - 1&lt;/code&gt; in the typical case,</source>
          <target state="translated">축으로 표시되는 &lt;code&gt;axis&lt;/code&gt; 따라 변형 되거나 &lt;code&gt;axis&lt;/code&gt; 이 지정되지 않은 경우 마지막 입력을 따라 변환되거나 잘림 이없는 입력입니다. 변환 된 축의 길이는 &lt;code&gt;n&lt;/code&gt; 이거나, &lt;code&gt;n&lt;/code&gt; 이 지정되지 않은 경우 &lt;code&gt;2*m - 2&lt;/code&gt; 여기서 &lt;code&gt;m&lt;/code&gt; 은 입력의 변환 된 축의 길이입니다. 홀수의 출력 포인트를 얻으려면 &lt;code&gt;n&lt;/code&gt; 을 지정해야합니다 (예 : 일반적인 경우 &lt;code&gt;2*m - 1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="890cb80542174800559555fcc8928d47ac767144" translate="yes" xml:space="preserve">
          <source>The truncated value of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 각 요소가 잘린 값입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d225104697ad1c2e4adc5e266a19505669d514fa" translate="yes" xml:space="preserve">
          <source>The truncated value of the scalar &lt;code&gt;x&lt;/code&gt; is the nearest integer &lt;code&gt;i&lt;/code&gt; which is closer to zero than &lt;code&gt;x&lt;/code&gt; is. In short, the fractional part of the signed number &lt;code&gt;x&lt;/code&gt; is discarded.</source>
          <target state="translated">스칼라의 절단 값 &lt;code&gt;x&lt;/code&gt; 정수에 가장 가까운 &lt;code&gt;i&lt;/code&gt; 가까운 제로보다 인 &lt;code&gt;x&lt;/code&gt; 이다. 간단히 말하면, 부호있는 숫자 &lt;code&gt;x&lt;/code&gt; 의 소수 부분 은 폐기됩니다.</target>
        </trans-unit>
        <trans-unit id="7473e98cdd8b9577d457a4ec3ae00062b1e0d1c1" translate="yes" xml:space="preserve">
          <source>The tuple &lt;code&gt;args&lt;/code&gt; and dict &lt;code&gt;kwargs&lt;/code&gt; are directly passed on from the original call.</source>
          <target state="translated">튜플 &lt;code&gt;args&lt;/code&gt; 및 dict &lt;code&gt;kwargs&lt;/code&gt; 는 원래 호출에서 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="8a95ef02498e39d8be9ecf72e13e2817e4a11b13" translate="yes" xml:space="preserve">
          <source>The tuple returned from &lt;code&gt;__array_interface__['data']&lt;/code&gt; used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">&lt;code&gt;__array_interface__['data']&lt;/code&gt; 에서 반환 된 튜플 은 16 진수 문자열 이었습니다 (이제 정수 또는 긴 정수).</target>
        </trans-unit>
        <trans-unit id="462bd3332737c1c0e3c136e2df99165ffa307b94" translate="yes" xml:space="preserve">
          <source>The tuple returned from __array_interface__[&amp;lsquo;data&amp;rsquo;] used to be a hex-string (now it is an integer or a long integer).</source>
          <target state="translated">__array_interface __ [ 'data']에서 반환 된 튜플은 16 진 문자열 (이제 정수 또는 긴 정수)이었습니다.</target>
        </trans-unit>
        <trans-unit id="ac07e35413d52171420d0546afbc516e4675dfc6" translate="yes" xml:space="preserve">
          <source>The two arrays are of the same length, so there is only one position where they completely overlap:</source>
          <target state="translated">두 배열의 길이는 동일하므로 완전히 겹치는 위치는 하나뿐입니다.</target>
        </trans-unit>
        <trans-unit id="a1576896c14768083aa4b0494018f6de168f9aa6" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and if it isn&amp;rsquo;t an ndarray it is treated as a scalar.</source>
          <target state="translated">2 차원 계열은 점 &lt;code&gt;(x, y)&lt;/code&gt; 에서 평가되며 , 여기서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 같은 모양을 가져야합니다. 경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플, 그것은 먼저, 그렇지 않으면 그대로 방치하고 ndarray가 아닌 경우는 스칼라로 취급 ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="2eba9ab6dc5fc4a672b7a559261dcf61c08663b7" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points &lt;code&gt;(x, y)&lt;/code&gt;, where &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; must have the same shape. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2 차원 계열은 점 &lt;code&gt;(x, y)&lt;/code&gt; 에서 평가되며 , 여기서 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 는 같은 모양을 가져야합니다. 경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플은, 그것은 먼저 ndarray가 아닌 경우, 그렇지 않으면 그것은 스칼라로 처리되어, 변경되지 않은 상태로되고, ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="0688b7907322e12f298dd8f02d187105297d15b2" translate="yes" xml:space="preserve">
          <source>The two dimensional series is evaluated at the points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; or &lt;code&gt;y&lt;/code&gt; is a list or tuple, it is first converted to an ndarray, otherwise it is left unchanged and, if it isn&amp;rsquo;t an ndarray, it is treated as a scalar.</source>
          <target state="translated">2 차원 계열은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 데카르트 곱의 점에서 평가됩니다 . 경우에는 &lt;code&gt;x&lt;/code&gt; 또는 &lt;code&gt;y&lt;/code&gt; 목록 또는 튜플은, 그것은 먼저 ndarray가 아닌 경우, 그렇지 않으면 그것은 스칼라로 처리되어, 변경되지 않은 상태로되고, ndarray로 변환된다.</target>
        </trans-unit>
        <trans-unit id="d4aa44f129ba54b421bffe3762821ce4945dce60" translate="yes" xml:space="preserve">
          <source>The two domains that determine the map. Each must (successfully) convert to 1-d arrays containing precisely two values.</source>
          <target state="translated">지도를 결정하는 두 도메인 각각은 (성공적으로) 정확히 두 개의 값을 포함하는 1 차원 배열로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="0027adc4d9c51b047c70705863099ef3efdd05ff" translate="yes" xml:space="preserve">
          <source>The two methods do not return the same sequence of variates.</source>
          <target state="translated">두 메서드는 동일한 변수 시퀀스를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="810d0511d5cc6182785b949cef8752429de415c1" translate="yes" xml:space="preserve">
          <source>The two&amp;rsquo;s complement is returned when the input number is negative and width is specified:</source>
          <target state="translated">입력 숫자가 음수이고 너비가 지정되면 2의 보수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="584450aea06b04e9037daf43c6af1e81a83e775a" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 2 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="9b11970984391ed9339a62d69846a84202600584" translate="yes" xml:space="preserve">
          <source>The two-dimensional FFT.</source>
          <target state="translated">2 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="93378f6188f826db256b9d6c37c0794ddd0149ba" translate="yes" xml:space="preserve">
          <source>The two-dimensional example we created using Fortran is just as easy to write in Cython:</source>
          <target state="translated">Fortran을 사용하여 만든 2 차원 예제는 Cython에서 작성하는 것만큼이나 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="cc89089001cef3c7a737f8de3b95a6b67d11a175" translate="yes" xml:space="preserve">
          <source>The two-dimensional inverse FFT.</source>
          <target state="translated">2 차원 역 FFT.</target>
        </trans-unit>
        <trans-unit id="9f5faf584fb30081780464310b34017103e73128" translate="yes" xml:space="preserve">
          <source>The type above can either refer to an actual Python type (e.g. &lt;code&gt;int&lt;/code&gt;), or describe the type of the variable in more detail, e.g. &lt;code&gt;(N,) ndarray&lt;/code&gt; or &lt;code&gt;array_like&lt;/code&gt;.</source>
          <target state="translated">위의 유형은 실제 Python 유형 (예 : &lt;code&gt;int&lt;/code&gt; )을 참조하거나 변수 유형을 더 자세히 설명 할 수 있습니다 (예 : &lt;code&gt;(N,) ndarray&lt;/code&gt; 또는 &lt;code&gt;array_like&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="66cebb62b229032f20fef01d3cd3e2d8c08b92d1" translate="yes" xml:space="preserve">
          <source>The type object used to instantiate a scalar of this data-type.</source>
          <target state="translated">이 데이터 형식의 스칼라를 인스턴스화하는 데 사용되는 형식 개체입니다.</target>
        </trans-unit>
        <trans-unit id="6e4f0a20a4e71ba4f55f61f65f81013f324f6ce9" translate="yes" xml:space="preserve">
          <source>The type of the array can also be explicitly specified at creation time:</source>
          <target state="translated">배열 유형은 생성시 명시 적으로 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="fa0bd68b05131d508a3464e6044d68f87729d81c" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">데이터의 유형은 &lt;a href=&quot;#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; 속성을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4e723834a8970a250a2a2d214449437cb2b1463f" translate="yes" xml:space="preserve">
          <source>The type of the data can be accessed through the &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">데이터 유형은 &lt;a href=&quot;numpy.ma.masked_array.baseclass#numpy.ma.masked_array.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; 속성을 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55666432b4662cbbcca855eedc915c8dbb074f43" translate="yes" xml:space="preserve">
          <source>The type of the data is described by the following &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; attributes:</source>
          <target state="translated">데이터 유형은 다음 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 속성으로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="7c7e8530225fc135f4d9b6eea552288840993321" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. Even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt;&lt;code&gt;iscomplexobj&lt;/code&gt;&lt;/a&gt; evaluates to True.</source>
          <target state="translated">값이 아닌 입력 유형이 확인됩니다. 입력에 허수 부가 0 인 경우에도 &lt;a href=&quot;#numpy.iscomplexobj&quot;&gt; &lt;code&gt;iscomplexobj&lt;/code&gt; &lt;/a&gt; 는 True로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="1a2c8e641184f0940417186c9bd1b40520bec6a6" translate="yes" xml:space="preserve">
          <source>The type of the input is checked, not the value. So even if the input has an imaginary part equal to zero, &lt;a href=&quot;#numpy.isrealobj&quot;&gt;&lt;code&gt;isrealobj&lt;/code&gt;&lt;/a&gt; evaluates to False if the data type is complex.</source>
          <target state="translated">값이 아닌 입력 유형이 확인됩니다. 따라서 입력에 허수 부가 0 인 경우 &lt;a href=&quot;#numpy.isrealobj&quot;&gt; &lt;code&gt;isrealobj&lt;/code&gt; &lt;/a&gt; 는 데이터 유형이 복잡한 경우 False로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="ea61e4d42852a1b3d6a2054bbf717a4dcd45c615" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">출력 배열의 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 주어지지 않는, 다른 입력 인수의 데이터 유형을 추론.</target>
        </trans-unit>
        <trans-unit id="32f8e95967dee5b6024af49a6833df8b96400b41" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, the data type is inferred from &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The inferred dtype will never be an integer; &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is chosen even if the arguments would produce an array of integers.</source>
          <target state="translated">출력 배열의 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 제공되지 않으며, 데이터 유형에서 유추 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; . 추론 된 dtype은 절대 정수가 아닙니다. 인수가 정수 배열을 생성하더라도 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="b4f2b2af4ea00b9069f29f29630cfed5b29605d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not given, the data type is inferred from &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;. The inferred type will never be an integer; &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; is chosen even if the arguments would produce an array of integers.</source>
          <target state="translated">출력 배열의 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 제공되지 않으며, 데이터 유형에서 유추 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; . 추론 된 유형은 정수가 될 수 없습니다. 인수가 정수 배열을 생성하더라도 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 가 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="2c73d98907158f7fb67c4efa759cdbb5f806f2d4" translate="yes" xml:space="preserve">
          <source>The type of the output array. If &lt;code&gt;dtype&lt;/code&gt; is not given, infer the data type from the other input arguments.</source>
          <target state="translated">출력 배열의 유형입니다. 경우 &lt;code&gt;dtype&lt;/code&gt; 주어지지 않는, 다른 입력 인수의 데이터 유형을 추론.</target>
        </trans-unit>
        <trans-unit id="a61a6b8f22a17e9cfb7771cdc6f2f0f745c54b06" translate="yes" xml:space="preserve">
          <source>The type of the result will depend on the encoding specified.</source>
          <target state="translated">결과 유형은 지정된 인코딩에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9f964988f963b226cae3c6098e96762218b96f31" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. By default, the dtype of &lt;code&gt;a&lt;/code&gt; is used. An exception is when &lt;code&gt;a&lt;/code&gt; has an integer type with less precision than the platform (u)intp. In that case, the default will be either (u)int32 or (u)int64 depending on whether the platform is 32 or 64 bits. For inexact inputs, dtype must be inexact.</source>
          <target state="translated">반환 된 배열 및 요소가 합산 된 누산기의 유형입니다. 기본적으로 &lt;code&gt;a&lt;/code&gt; 의 dtype 이 사용됩니다. &lt;code&gt;a&lt;/code&gt; 가 플랫폼 (u) intp보다 정밀도가 낮은 정수 유형을 갖는 경우 는 예외입니다 . 이 경우 플랫폼이 32 비트인지 64 비트인지에 따라 기본값은 (u) int32 또는 (u) int64입니다. 부정확 한 입력의 경우 dtype이 정확하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="fae2388276bf4adee2baf6958155240f0239ec9b" translate="yes" xml:space="preserve">
          <source>The type of the returned array and of the accumulator in which the elements are summed. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">반환 된 배열 및 요소가 합산 된 누산기의 유형입니다. &lt;code&gt;a&lt;/code&gt; 가 기본 플랫폼 정수보다 정밀도가 낮은 정수 dtype을 갖지 않는 한 &lt;code&gt;a&lt;/code&gt; 의 dtype이 기본적으로 사용됩니다 . 이 경우 &lt;code&gt;a&lt;/code&gt; 가 서명되면 플랫폼 정수가 사용되고 &lt;code&gt;a&lt;/code&gt; 가 서명되지 않으면 플랫폼 정수와 동일한 정밀도의 부호없는 정수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bd79c4b3d3f0f1be1ec3ce5a1aa5d47271e61a5b" translate="yes" xml:space="preserve">
          <source>The type of the returned array, as well as of the accumulator in which the elements are multiplied. The dtype of &lt;code&gt;a&lt;/code&gt; is used by default unless &lt;code&gt;a&lt;/code&gt; has an integer dtype of less precision than the default platform integer. In that case, if &lt;code&gt;a&lt;/code&gt; is signed then the platform integer is used while if &lt;code&gt;a&lt;/code&gt; is unsigned then an unsigned integer of the same precision as the platform integer is used.</source>
          <target state="translated">반환 된 배열의 유형과 요소가 곱해지는 누산기의 유형입니다. &lt;code&gt;a&lt;/code&gt; 가 기본 플랫폼 정수보다 정밀도가 낮은 정수 dtype을 갖지 않는 한 &lt;code&gt;a&lt;/code&gt; 의 dtype이 기본적으로 사용됩니다 . 이 경우 &lt;code&gt;a&lt;/code&gt; 가 서명되면 플랫폼 정수가 사용되고 &lt;code&gt;a&lt;/code&gt; 가 서명되지 않으면 플랫폼 정수와 동일한 정밀도의 부호없는 정수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e3a7bb2863553d52f83413fb23d739a7fea567ae" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data type of the output array if this is provided, or the data type of the input array if no output array is provided.</source>
          <target state="translated">중간 결과를 나타내는 데 사용되는 유형입니다. 출력 배열이 제공되는 경우 기본적으로 출력 배열의 데이터 유형이거나 출력 배열이 제공되지 않은 경우 입력 배열의 데이터 유형이 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="f46b668fbc5ae74dc471bbfdc9b1c8b2040c3ed5" translate="yes" xml:space="preserve">
          <source>The type used to represent the intermediate results. Defaults to the data-type of the output array if this is provided, or the data-type of the input array if no output array is provided.</source>
          <target state="translated">중간 결과를 나타내는 데 사용되는 유형입니다. 출력 배열이 제공되는 경우 출력 배열의 데이터 유형으로 설정되거나 출력 배열이 제공되지 않은 경우 입력 배열의 데이터 유형으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="3d1a1953424d5a7364adfc318f2ceeb8ef42f6ff" translate="yes" xml:space="preserve">
          <source>The typemap directives provided by &lt;code&gt;numpy.i&lt;/code&gt; for arrays of different data types, say &lt;code&gt;double&lt;/code&gt; and &lt;code&gt;int&lt;/code&gt;, and dimensions of different types, say &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;, are identical to one another except for the C and NumPy type specifications. The typemaps are therefore implemented (typically behind the scenes) via a macro:</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 에서 제공하는 다른 데이터 유형 ( &lt;code&gt;double&lt;/code&gt; 및 &lt;code&gt;int&lt;/code&gt; ) 및 다른 유형 ( &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; )의 배열에 대해 typenum 지시문 은 C 및 NumPy 유형 스펙을 제외하고 서로 동일합니다. 따라서 타입 맵은 매크로를 통해 (일반적으로 장면 뒤에서) 구현됩니다.</target>
        </trans-unit>
        <trans-unit id="dff7b3c37fb51796f178f8cb67e96939e35d8847" translate="yes" xml:space="preserve">
          <source>The typemap signatures are largely differentiated on the name given to the buffer pointer. Names with &lt;code&gt;FARRAY&lt;/code&gt; are for Fortran-ordered arrays, and names with &lt;code&gt;ARRAY&lt;/code&gt; are for C-ordered (or 1D arrays).</source>
          <target state="translated">타입 맵 시그니처는 버퍼 포인터에 주어진 이름에서 크게 차별화됩니다. &lt;code&gt;FARRAY&lt;/code&gt; 가있는 이름 은 포트란 순서의 배열이고 &lt;code&gt;ARRAY&lt;/code&gt; 가있는 이름 은 C 순서 (또는 1D 배열)입니다.</target>
        </trans-unit>
        <trans-unit id="d316f93b51d10bd2681fb7336deed9067a473d1a" translate="yes" xml:space="preserve">
          <source>The typemaps from &lt;code&gt;numpy.i&lt;/code&gt; are responsible for the following lines of code: 12&amp;ndash;20, 25 and 30. Line 10 parses the input to the &lt;code&gt;rms&lt;/code&gt; function. From the format string &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt;, we can see that the argument list is expected to be a single Python object (specified by the &lt;code&gt;O&lt;/code&gt; before the colon) and whose pointer is stored in &lt;code&gt;obj0&lt;/code&gt;. A number of functions, supplied by &lt;code&gt;numpy.i&lt;/code&gt;, are called to make and check the (possible) conversion from a generic Python object to a NumPy array. These functions are explained in the section &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt;, but hopefully their names are self-explanatory. At line 12 we use &lt;code&gt;obj0&lt;/code&gt; to construct a NumPy array. At line 17, we check the validity of the result: that it is non-null and that it has a single dimension of arbitrary length. Once these states are verified, we extract the data buffer and length in lines 19 and 20 so that we can call the underlying C function at line 22. Line 25 performs memory management for the case where we have created a new array that is no longer needed.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 의 유형 맵은 12&amp;ndash;20, 25 및 30 코드 행을 담당합니다. 10 행은 입력을 &lt;code&gt;rms&lt;/code&gt; 함수 로 구문 분석합니다 . 형식 문자열 &lt;code&gt;&quot;O:rms&quot;&lt;/code&gt; 에서 인수 목록이 단일 Python 객체 ( 콜론 앞에 &lt;code&gt;O&lt;/code&gt; 로 지정됨 )이고 포인터가 &lt;code&gt;obj0&lt;/code&gt; 에 저장되어 있음을 알 수 있습니다. &lt;code&gt;numpy.i&lt;/code&gt; 에서 제공하는 많은 함수 가 호출되어 일반 Python 객체에서 NumPy 배열로의 (가능한) 변환을 확인합니다. 이 함수들은 &lt;a href=&quot;#helper-functions&quot;&gt;Helper Functions&lt;/a&gt; 섹션에 설명되어 있지만 그 이름은 자명하다. 12 행에서 &lt;code&gt;obj0&lt;/code&gt; 을 사용 합니다NumPy 배열을 구성합니다. 17 행에서 결과의 유효성을 검사합니다. 결과가 널이 아니며 임의의 단일 길이를가집니다. 이러한 상태가 확인되면 라인 19와 라인 20에서 데이터 버퍼와 길이를 추출하여 라인 22에서 기본 C 함수를 호출 할 수 있습니다. 라인 25는 더 이상 새로운 배열을 생성하지 않은 경우 메모리 관리를 수행합니다. 필요합니다.</target>
        </trans-unit>
        <trans-unit id="94a9db34d902a4524ad7871b0441ea5be9c4a8b8" translate="yes" xml:space="preserve">
          <source>The typical looping construct is as follows.</source>
          <target state="translated">일반적인 루핑 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="93f339cfb377248f9f368c97945ac549c08d48eb" translate="yes" xml:space="preserve">
          <source>The ufunc object is implemented by creation of the &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt;. It is a very simple type that implements only basic getattribute behavior, printing behavior, and has call behavior which allows these objects to act like functions. The basic idea behind the ufunc is to hold a reference to fast 1-dimensional (vector) loops for each data type that supports the operation. These one-dimensional loops all have the same signature and are the key to creating a new ufunc. They are called by the generic looping code as appropriate to implement the N-dimensional function. There are also some generic 1-d loops defined for floating and complexfloating arrays that allow you to define a ufunc using a single scalar function (&lt;em&gt;e.g.&lt;/em&gt; atanh).</source>
          <target state="translated">ufunc 오브젝트의 생성에 의해 구현된다 &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; &lt;/a&gt; . 기본 getattribute 동작, 인쇄 동작 만 구현하고 이러한 객체가 함수처럼 작동하도록하는 호출 동작을 갖는 매우 간단한 유형입니다. ufunc의 기본 개념은 연산을 지원하는 각 데이터 유형에 대해 빠른 1 차원 (벡터) 루프에 대한 참조를 유지하는 것입니다. 이 1 차원 루프는 모두 동일한 서명을 가지며 새로운 ufunc를 작성하는 데 핵심입니다. 그것들은 N 차원 함수를 구현하기에 적절하게 일반 루핑 코드에 의해 호출됩니다. 단일 스칼라 함수 ( &lt;em&gt;예 :&lt;/em&gt; atanh) 를 사용하여 ufunc를 정의 할 수있는 부동 및 복소수 부동 배열에 대해 정의 된 일반적인 1 차원 루프도 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf8db1044487cf17b16ec5dfd6f051754480a0fd" translate="yes" xml:space="preserve">
          <source>The ufunc still returns its output(s) even if you use the optional output argument(s).</source>
          <target state="translated">선택적 출력 인수를 사용하더라도 ufunc는 여전히 출력을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a13b64ddac2c6f9c4757f678876470a35b9dd260" translate="yes" xml:space="preserve">
          <source>The umath module is a computer-generated C-module that creates many ufuncs. It provides a great many examples of how to create a universal function. Creating your own ufunc that will make use of the ufunc machinery is not difficult either. Suppose you have a function that you want to operate element-by-element over its inputs. By creating a new ufunc you will obtain a function that handles</source>
          <target state="translated">umath 모듈은 많은 ufunc를 생성하는 컴퓨터 생성 C 모듈입니다. 범용 함수를 만드는 방법에 대한 많은 예를 제공합니다. ufunc 기계를 사용할 고유 한 ufunc를 만드는 것도 어렵지 않습니다. 입력에 대해 요소별로 연산하려는 함수가 있다고 가정합니다. 새로운 ufunc를 생성하면 다음을 처리하는 함수를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a59f16e305808090335d01a0996ae1722a21eee6" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;+&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.positive&lt;/code&gt; on ndarrays.</source>
          <target state="translated">단항 &lt;code&gt;+&lt;/code&gt; 연산자는 &lt;code&gt;np.positive&lt;/code&gt; 에서 np.positive 의 약자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3520cc99bc38dec23789298886ad1bf0cd8d3a9e" translate="yes" xml:space="preserve">
          <source>The unary &lt;code&gt;-&lt;/code&gt; operator can be used as a shorthand for &lt;code&gt;np.negative&lt;/code&gt; on ndarrays.</source>
          <target state="translated">단항 &lt;code&gt;-&lt;/code&gt; 연산자에 대한 속기로 사용할 수 있습니다 &lt;code&gt;np.negative&lt;/code&gt; ndarrays합니다.</target>
        </trans-unit>
        <trans-unit id="6d199d62fee4302579457e386e4a80ba73f82400" translate="yes" xml:space="preserve">
          <source>The underlying data of a masked array can be accessed in several ways:</source>
          <target state="translated">마스크 배열의 기본 데이터는 여러 가지 방법으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="11e8796701c0b67707f7be52c1081d9ae533b8cd" translate="yes" xml:space="preserve">
          <source>The underlying file descriptor is closed when exiting the &amp;lsquo;with&amp;rsquo; block.</source>
          <target state="translated">'with'블록을 종료하면 기본 파일 설명자가 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="8a7d26eedaa6e3c6ca58f22a4d3a1445aae9ed58" translate="yes" xml:space="preserve">
          <source>The upper-triangular matrix.</source>
          <target state="translated">상단 삼각 행렬.</target>
        </trans-unit>
        <trans-unit id="4d3a2d4644c583ea8315d7ff8cedb605a3b103a4" translate="yes" xml:space="preserve">
          <source>The usage of &lt;code&gt;fib1.fib&lt;/code&gt; in Python is very similar to using &lt;code&gt;FIB&lt;/code&gt; in Fortran. However, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python indicates a poor style as there is no safety mechanism in Python with respect to wrong argument types. When using Fortran or C, compilers naturally discover any type mismatches during compile time but in Python the types must be checked in runtime. So, using &lt;em&gt;in situ&lt;/em&gt; output arguments in Python may cause difficult to find bugs, not to mention that the codes will be less readable when all required type checks are implemented.</source>
          <target state="translated">의 사용 &lt;code&gt;fib1.fib&lt;/code&gt; 파이썬에서 사용하여 매우 유사하다 &lt;code&gt;FIB&lt;/code&gt; 를 포트란. 그러나 Python &lt;em&gt;에서 in situ&lt;/em&gt; 출력 인수를 사용 하는 것은 잘못된 인수 유형과 관련하여 Python에 안전 메커니즘이 없기 때문에 잘못된 스타일을 나타냅니다. Fortran 또는 C를 사용할 때 컴파일러는 컴파일 시간 동안 모든 유형 불일치를 자연스럽게 발견하지만 Python에서는 런타임에서 유형을 확인해야합니다. 따라서 Python &lt;em&gt;에서 in situ&lt;/em&gt; 출력 인수를 사용 하면 모든 필수 유형 검사가 구현 될 때 코드의 가독성이 떨어질뿐만 아니라 버그를 찾기가 어려울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4cb9fef2603ca49b4b7d883decd87bdc8eb544d" translate="yes" xml:space="preserve">
          <source>The use of random number generation is an important part of the configuration and evaluation of many numerical and machine learning algorithms. Whether you need to randomly initialize weights in an artificial neural network, split data into random sets, or randomly shuffle your dataset, being able to generate random numbers (actually, repeatable pseudo-random numbers) is essential.</source>
          <target state="translated">난수 생성의 사용은 많은 수치 및 기계 학습 알고리즘의 구성 및 평가에서 중요한 부분입니다. 인공 신경망에서 가중치를 무작위로 초기화해야하는지, 데이터를 무작위 세트로 분할해야하는지, 데이터 세트를 무작위로 셔플해야하는지 여부에 관계없이 난수 (실제로 반복 가능한 의사 난수)를 생성 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="638520b9fcb56661a86b8addd734b2116df46c53" translate="yes" xml:space="preserve">
          <source>The use of this form of specification is discouraged, but documented here because older numpy code may use it. The keys of the dictionary are the field names and the values are tuples specifying type and offset:</source>
          <target state="translated">이 형식의 사양을 사용하는 것은 권장되지 않지만 이전 numpy 코드에서 사용할 수 있으므로 여기에 문서화되어 있습니다. 사전의 키는 필드 이름이고 값은 유형과 오프셋을 지정하는 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="4fb07adf94a9c0d15c6277e214f78bd8de82a95e" translate="yes" xml:space="preserve">
          <source>The user always has the option of converting to a normal &lt;code&gt;numpy.ndarray&lt;/code&gt; with &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt; and using standard numpy from there.</source>
          <target state="translated">사용자는 항상 &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; &lt;/a&gt; 를 사용하여 일반 &lt;code&gt;numpy.ndarray&lt;/code&gt; 로 변환하고 거기에서 표준 numpy를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c853de173592dd7ca97d9f29062998fe65a116cb" translate="yes" xml:space="preserve">
          <source>The user should always check the final report through the build log to verify the enabled features.</source>
          <target state="translated">사용자는 항상 빌드 로그를 통해 최종 보고서를 확인하여 활성화 된 기능을 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="8fcd141d1c403551e053ceda2314596f85b55796" translate="yes" xml:space="preserve">
          <source>The usual caution for verifying equality with floating point numbers is advised.</source>
          <target state="translated">부동 소수점 숫자와의 동등성을 확인하기위한 일반적인주의가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="6f6231b1c986a1cae99123ebb4b0aec8cf8b789f" translate="yes" xml:space="preserve">
          <source>The usual companion matrix of the Laguerre polynomials is already symmetric when &lt;code&gt;c&lt;/code&gt; is a basis Laguerre polynomial, so no scaling is applied.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 가 기본 Laguerre 다항식 인 경우 Laguerre 다항식의 일반적인 컴패니언 행렬은 이미 대칭 이므로 스케일링이 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab74e1cb912398a285a4b8e03a0b11ad44100129" translate="yes" xml:space="preserve">
          <source>The validation process for the requsted optimizations when it comes to &lt;code&gt;--cpu-baseline&lt;/code&gt; isn&amp;rsquo;t strict. For example, if the user requested &lt;code&gt;AVX2&lt;/code&gt; but the compiler doesn&amp;rsquo;t support it then we just skip it and return the maximum optimization that the compiler can handle depending on the implied features of &lt;code&gt;AVX2&lt;/code&gt;, let us assume &lt;code&gt;AVX&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;--cpu-baseline&lt;/code&gt; 과 관련하여 필요한 최적화에 대한 유효성 검사 프로세스 는 엄격하지 않습니다. 예를 들어 사용자가 &lt;code&gt;AVX2&lt;/code&gt; 를 요청 했지만 컴파일러가이를 지원하지 않는 경우이를 건너 뛰고 &lt;code&gt;AVX2&lt;/code&gt; 의 암시 적 기능에 따라 컴파일러가 처리 할 수있는 최대 최적화를 반환합니다 . &lt;code&gt;AVX&lt;/code&gt; 라고 가정하겠습니다 .</target>
        </trans-unit>
        <trans-unit id="1624b44eda9b54e7f0bf73b95d72ca30534e15ac" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;--cpu-baseline&lt;/code&gt; will be treated as &amp;ldquo;native&amp;rdquo; if compiler native flag &lt;code&gt;-march=native&lt;/code&gt; or &lt;code&gt;-xHost&lt;/code&gt; or &lt;code&gt;QxHost&lt;/code&gt; is enabled through environment variable &lt;code&gt;CFLAGS&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;--cpu-baseline&lt;/code&gt; 의 값은 컴파일러 기본 플래그 &lt;code&gt;-march=native&lt;/code&gt; 또는 &lt;code&gt;-xHost&lt;/code&gt; 또는 &lt;code&gt;QxHost&lt;/code&gt; 가 환경 변수 &lt;code&gt;CFLAGS&lt;/code&gt; 를 통해 활성화 된 경우 &quot;native&quot;로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f5374a35aef1f1111ab75965c88b8c317b197461" translate="yes" xml:space="preserve">
          <source>The value of &lt;em&gt;newendian&lt;/em&gt; is one of these macros:</source>
          <target state="translated">&lt;em&gt;newendian&lt;/em&gt; 의 값은 다음 매크로 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="f77acab0966818b5a377ef30b38be521ef7f7b59" translate="yes" xml:space="preserve">
          <source>The value of the function when x1 is 0. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">x1이 0 일 때 함수의 값입니다. &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 인 경우 공통 모양 (출력 모양이 됨)으로 브로드 캐스트 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="03d358ce11030b4d51f9879722053df717a3fe53" translate="yes" xml:space="preserve">
          <source>The value of this argument is typically a dictionary with column indices or column names as keys and a conversion functions as values. These conversion functions can either be actual functions or lambda functions. In any case, they should accept only a string as input and output only a single element of the wanted type.</source>
          <target state="translated">이 인수의 값은 일반적으로 열 인덱스 또는 열 이름을 키로 사용하고 변환 함수를 값으로 사용하는 사전입니다. 이러한 변환 함수는 실제 함수 또는 람다 함수일 수 있습니다. 어떤 경우 든 입력으로 문자열 만 허용하고 원하는 유형의 단일 요소 만 출력해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3e9e5da5ef1ee5aadaa824ae3c6fd2914c94c23" translate="yes" xml:space="preserve">
          <source>The value of this attribute is used to determine what type of object to return in situations where there is more than one possibility for the Python type of the returned object. Subclasses inherit a default value of 0.0 for this attribute.</source>
          <target state="translated">이 속성의 값은 리턴 된 오브젝트의 Python 유형에 대해 둘 이상의 가능성이있는 상황에서 리턴 할 오브젝트 유형을 판별하는 데 사용됩니다. 서브 클래스는이 속성에 대해 기본값 0.0을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="8bcc816a3b6323731b656c466ec0a5744f30e87e" translate="yes" xml:space="preserve">
          <source>The value to convert. Positive and negative values are handled.</source>
          <target state="translated">변환 할 값입니다. 양수 및 음수 값이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="32b4c5a64bc9a7f3fa379e6006c427acc72a2601" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다 (기본적으로 없음). None이면 배열 의 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 속성이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="de21d1a60175f56eb618a4e1b78157f5a0b80498" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다 (기본적으로 없음). None이면이 인수는 전달 된 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 에서 유추 되거나 아래 참고에서 설명하는대로 원래 배열이없는 경우에 유추 됩니다.</target>
        </trans-unit>
        <trans-unit id="46bea3445bf9a264b60905faf1d0effc77e2e249" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다 (기본적으로 없음). None이면이 인수는 전달 된 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 에서 유추 되거나 아래 참고에서 설명하는대로 원래 배열이없는 경우에 유추 됩니다.</target>
        </trans-unit>
        <trans-unit id="a8455fb8033504388eae171a33ad0ef930322f1e" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries (None by default). If None, then this argument is inferred from the passed &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, or in its absence the original array, as discussed in the notes below.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다 (기본적으로 없음). None이면이 인수는 전달 된 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 에서 유추 되거나 아래 참고에서 설명하는대로 원래 배열이없는 경우에 유추 됩니다.</target>
        </trans-unit>
        <trans-unit id="2e873302c473555951f6bce102181f00086c301d" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다. 스칼라 또는 비스 칼라일 수 있습니다. 스칼라가 아닌 경우 결과 ndarray는 입력 배열을 통해 브로드 캐스트 가능해야합니다. 기본값은 None이며,이 경우 배열 의 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 속성이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1880e242040c0aab4362eb1a0863297a32bd5f4b" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Can be scalar or non-scalar. If non-scalar, the resulting ndarray must be broadcastable over input array. Default is None, in which case, the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; attribute of the array is used instead.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다. 스칼라 또는 비스 칼라일 수 있습니다. 스칼라가 아닌 경우 결과 ndarray는 입력 배열을 통해 브로드 캐스트 가능해야합니다. 기본값은 None이며,이 경우 배열 의 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 속성이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="11b1837d34a4ca9f6b2279399c10c60d4b55936a" translate="yes" xml:space="preserve">
          <source>The value to use for invalid entries. Default is None.</source>
          <target state="translated">유효하지 않은 항목에 사용할 값입니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="54be798891264cab731a931b04ea9772cdab541c" translate="yes" xml:space="preserve">
          <source>The value to use for the &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt;&lt;code&gt;identity&lt;/code&gt;&lt;/a&gt; attribute of the resulting object. If specified, this is equivalent to setting the underlying C &lt;code&gt;identity&lt;/code&gt; field to &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. If omitted, the identity is set to &lt;code&gt;PyUFunc_None&lt;/code&gt;. Note that this is _not_ equivalent to setting the identity to &lt;code&gt;None&lt;/code&gt;, which implies the operation is reorderable.</source>
          <target state="translated">결과 개체 의 &lt;a href=&quot;numpy.ufunc.identity#numpy.ufunc.identity&quot;&gt; &lt;code&gt;identity&lt;/code&gt; &lt;/a&gt; 속성에 사용할 값 입니다. 지정된 경우 이는 기본 C &lt;code&gt;identity&lt;/code&gt; 필드를 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 로 설정하는 것과 동일합니다 . 생략하면 ID가 &lt;code&gt;PyUFunc_None&lt;/code&gt; 으로 설정됩니다 . 이것은 ID를 &lt;code&gt;None&lt;/code&gt; 으로 설정하는 것과 동일 하지 _ 아니다. 이는 작업 순서를 변경할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="adfb1baad553fefd1bd16dad3fa307f22463d54c" translate="yes" xml:space="preserve">
          <source>The value where the peak of the distribution occurs. The value must fulfill the condition &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt;.</source>
          <target state="translated">분포의 피크가 발생하는 값입니다. 값은 &lt;code&gt;left &amp;lt;= mode &amp;lt;= right&lt;/code&gt; 조건을 충족해야합니다 .</target>
        </trans-unit>
        <trans-unit id="686c0ef41d4f40d919659043042cba31d0a83ddd" translate="yes" xml:space="preserve">
          <source>The value whose minimal data type is to be found.</source>
          <target state="translated">최소 데이터 유형을 찾을 값입니다.</target>
        </trans-unit>
        <trans-unit id="ec08073e01c06623c4f6388732ecfb40030e861d" translate="yes" xml:space="preserve">
          <source>The value with which to start the reduction. If the ufunc has no identity or the dtype is object, this defaults to None - otherwise it defaults to ufunc.identity. If &lt;code&gt;None&lt;/code&gt; is given, the first element of the reduction is used, and an error is thrown if the reduction is empty.</source>
          <target state="translated">축소를 시작하는 데 사용되는 값입니다. ufunc에 ID가 없거나 dtype이 object 인 경우 기본값은 None입니다. 그렇지 않으면 기본값은 ufunc.identity입니다. 경우 &lt;code&gt;None&lt;/code&gt; 주어지지, 감소의 첫 번째 요소는 사용하고, 감소가 비어있는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c02e60b2cf88beea9b6213b9d1e3b2c17ab885eb" translate="yes" xml:space="preserve">
          <source>The value(s) whose arccos is (are) required.</source>
          <target state="translated">arccos가 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="183fa270f0d1fa6f702a51a2364673ed5612bfd2" translate="yes" xml:space="preserve">
          <source>The value(s) whose arcsin is (are) required.</source>
          <target state="translated">arcsin이 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="1d4cd85936bff2c0840b52fb0d1f9b2b867275e7" translate="yes" xml:space="preserve">
          <source>The value(s) whose arctanh is (are) required.</source>
          <target state="translated">arctanh가 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="d21864f90829a08fd0ce039dcaefd6c6c1041816" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base 10 is (are) required.</source>
          <target state="translated">로그 밑 수가 10 인 값은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="3a56b30d194880ee472ad588027f66ef7c7510ff" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base 2 is (are) required.</source>
          <target state="translated">로그 밑 수가 2 인 값은 필수입니다.</target>
        </trans-unit>
        <trans-unit id="bfb30aa30026604ddea308e1175db0c56c2dbb97" translate="yes" xml:space="preserve">
          <source>The value(s) whose log base &lt;code&gt;n&lt;/code&gt; is (are) required.</source>
          <target state="translated">로그 밑이 &lt;code&gt;n&lt;/code&gt; 인 값 이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="b2591ea528e39e4354f5f1d5877efb3bad7380af" translate="yes" xml:space="preserve">
          <source>The value(s) whose log is (are) required.</source>
          <target state="translated">로그가 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="930e3ad8c3851bb30a80a559ca4a2af60560b1ff" translate="yes" xml:space="preserve">
          <source>The values &lt;code&gt;ar1[in1d]&lt;/code&gt; are in &lt;code&gt;ar2&lt;/code&gt;.</source>
          <target state="translated">값은 &lt;code&gt;ar1[in1d]&lt;/code&gt; 에 &lt;code&gt;ar2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4cb91abe1a0f589bcf1ee9ebaba06339dc294dc" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;ar1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; 의 각 값을 테스트 할 값입니다 .</target>
        </trans-unit>
        <trans-unit id="55096101173292ac6a418aa55429cc3cfcc3d718" translate="yes" xml:space="preserve">
          <source>The values against which to test each value of &lt;code&gt;element&lt;/code&gt;. This argument is flattened if it is an array or array_like. See notes for behavior with non-array-like parameters.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 의 각 값을 테스트 할 값입니다 . 이 인수는 배열이거나 array_like 인 경우 병합됩니다. 배열이 아닌 매개 변수의 동작에 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="10fa1bca5c63978c522a37d289203eb7633c9fb5" translate="yes" xml:space="preserve">
          <source>The values in the rank-1 array &lt;code&gt;p&lt;/code&gt; are coefficients of a polynomial. If the length of &lt;code&gt;p&lt;/code&gt; is n+1 then the polynomial is described by:</source>
          <target state="translated">순위 -1 배열 &lt;code&gt;p&lt;/code&gt; 의 값은 다항식의 계수입니다. &lt;code&gt;p&lt;/code&gt; 의 길이 가 n + 1이면 다항식은 다음과 같이 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="427b2ca25633b731d69a885f7ebcb443f1d11f04" translate="yes" xml:space="preserve">
          <source>The values in the result follow so-called &amp;ldquo;standard&amp;rdquo; order: If &lt;code&gt;A =
fft(a, n)&lt;/code&gt;, then &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term (the sum of the signal), which is always purely real for real inputs. Then &lt;code&gt;A[1:n/2]&lt;/code&gt; contains the positive-frequency terms, and &lt;code&gt;A[n/2+1:]&lt;/code&gt; contains the negative-frequency terms, in order of decreasingly negative frequency. For an even number of input points, &lt;code&gt;A[n/2]&lt;/code&gt; represents both positive and negative Nyquist frequency, and is also purely real for real input. For an odd number of input points, &lt;code&gt;A[(n-1)/2]&lt;/code&gt; contains the largest positive frequency, while &lt;code&gt;A[(n+1)/2]&lt;/code&gt; contains the largest negative frequency. The routine &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; returns an array giving the frequencies of corresponding elements in the output. The routine &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; shifts transforms and their frequencies to put the zero-frequency components in the middle, and &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; undoes that shift.</source>
          <target state="translated">결과의 값은 소위 &quot;표준&quot;순서를 따릅니다. &lt;code&gt;A = fft(a, n)&lt;/code&gt; 인 경우 &lt;code&gt;A[0]&lt;/code&gt; 에는 주파수가 제로인 항 (신호의 합)이 포함됩니다. 입력. 그런 다음 &lt;code&gt;A[1:n/2]&lt;/code&gt; 에는 양의 주파수 항이 포함되고 &lt;code&gt;A[n/2+1:]&lt;/code&gt; 에는 음의 주파수 항이 내림차순으로 포함됩니다. 짝수의 입력 포인트에 대해 &lt;code&gt;A[n/2]&lt;/code&gt; 는 양수 및 음수 나이 퀴 스트 주파수를 나타내며 실제 입력에도 순수하게 적용됩니다. 홀수 개의 입력 포인트의 경우 &lt;code&gt;A[(n-1)/2]&lt;/code&gt; 에 가장 큰 양의 주파수가 포함되고 &lt;code&gt;A[(n+1)/2]&lt;/code&gt; 에 가장 큰 음의 주파수가 포함됩니다. 루틴 &lt;code&gt;np.fft.fftfreq(n)&lt;/code&gt; 은 출력에서 ​​해당 요소의 주파수를 제공하는 배열을 반환합니다. 루틴 &lt;code&gt;np.fft.fftshift(A)&lt;/code&gt; 변환과 해당 주파수를 이동하여 주파수가 0 인 성분을 중간에 배치하고 &lt;code&gt;np.fft.ifftshift(A)&lt;/code&gt; 해당 이동을 취소합니다.</target>
        </trans-unit>
        <trans-unit id="049629d5662346c69d1da68173623b07fbd3ce2f" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;R&lt;/code&gt; are between -1 and 1, inclusive.</source>
          <target state="translated">&lt;code&gt;R&lt;/code&gt; 의 값은 -1과 1 사이입니다.</target>
        </trans-unit>
        <trans-unit id="9be1b3aaf13595cf59a1cfa63bbe9d63fd300725" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;x1&lt;/code&gt; with the sign of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">의 값 &lt;code&gt;x1&lt;/code&gt; 의 기호 &lt;code&gt;x2&lt;/code&gt; . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="0b6f0a3f189dc33bd74c3b4b3649d7d6ee49f75c" translate="yes" xml:space="preserve">
          <source>The values of the histogram. See &lt;code&gt;density&lt;/code&gt; and &lt;code&gt;weights&lt;/code&gt; for a description of the possible semantics.</source>
          <target state="translated">히스토그램의 값. 가능한 의미론에 대한 설명은 &lt;code&gt;density&lt;/code&gt; 와 &lt;code&gt;weights&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="94c9275f5f339f7a7296146a88f4dacc4958d420" translate="yes" xml:space="preserve">
          <source>The values of the multidimension polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">점의 다차원 다항식의 값은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 해당 값의 3 배로 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="000e1e6aea9b8f07ac10536f42598c0ea9bb0313" translate="yes" xml:space="preserve">
          <source>The values of the multidimensional polynomial on points formed with triples of corresponding values from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">점의 다차원 다항식의 값은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 해당 값의 3 배로 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="04875120c52fa413c52d82fe0fc8626bcc9f10c7" translate="yes" xml:space="preserve">
          <source>The values of the time series of cash flows. The (fixed) time interval between cash flow &amp;ldquo;events&amp;rdquo; must be the same as that for which &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is given (i.e., if &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is per year, then precisely a year is understood to elapse between each cash flow event). By convention, investments or &amp;ldquo;deposits&amp;rdquo; are negative, income or &amp;ldquo;withdrawals&amp;rdquo; are positive; &lt;code&gt;values&lt;/code&gt; must begin with the initial investment, thus &lt;code&gt;values[0]&lt;/code&gt; will typically be negative.</source>
          <target state="translated">시계열 현금 흐름의 값. 현금 흐름 &quot;사건&quot;사이의 (고정 된) 시간 간격은 &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 가 주어진 것과 동일해야합니다 (즉, 연간 &lt;a href=&quot;numpy.rate#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 인 경우 각 현금 흐름 이벤트 사이에 정확히 1 년이 경과하는 것으로 이해됩니다). 통상적으로 투자 또는&amp;ldquo;예금&amp;rdquo;은 음수, 소득 또는&amp;ldquo;인출&amp;rdquo;은 양수입니다. &lt;code&gt;values&lt;/code&gt; 은 초기 투자로 시작해야하므로 &lt;code&gt;values[0]&lt;/code&gt; 은 일반적으로 음수입니다.</target>
        </trans-unit>
        <trans-unit id="1a3aeed326405c6ff97973ff76e3c1ac5b78c950" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 대응하는 값 쌍으로 형성된 점에서의 2 차원 체비 쇼프 계열의 값 .</target>
        </trans-unit>
        <trans-unit id="d500e0f26328b27b56cc6ea280ce335971a39a93" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Chebyshev series at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 데카르트 곱의 점에서 2 차원 체비 쇼프 계열의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="118ceee048eeb019cc7036790e58ad86a6694410" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional Legendre series at points formed from pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 대응하는 값 쌍으로 형성된 점에서의 2 차원 Legendre 시리즈의 값 .</target>
        </trans-unit>
        <trans-unit id="75bce5c26e8d20f2a28b76fe4bee99ba20e34131" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points formed with pairs of corresponding values from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">점에서 2 차원 다항식의 값은 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 해당 값 쌍으로 형성됩니다 .</target>
        </trans-unit>
        <trans-unit id="fb47214ec0ab61ed4f83b6664e41c0aa8a83d3ed" translate="yes" xml:space="preserve">
          <source>The values of the two dimensional polynomial at points in the Cartesian product of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 의 데카르트 곱의 점에서 2 차원 다항식의 값입니다 .</target>
        </trans-unit>
        <trans-unit id="7d3e958b62535b85e2d7d32e34bc42123eb7d409" translate="yes" xml:space="preserve">
          <source>The values reported are normalized relative to the speed of MT19937 in each table. A value of 100 indicates that the performance matches the MT19937. Higher values indicate improved performance. These values cannot be compared across tables.</source>
          <target state="translated">보고 된 값은 각 표에서 MT19937의 속도와 관련하여 정규화됩니다. 값이 100이면 성능이 MT19937과 일치 함을 나타냅니다. 값이 클수록 성능이 향상되었음을 나타냅니다. 이 값은 테이블에서 비교할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d8a3da63b70322018b836bf5f65f57d16d3ac651" translate="yes" xml:space="preserve">
          <source>The values whose cube-roots are required.</source>
          <target state="translated">큐브 뿌리가 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="b42bae2bd42a8c9e82a7332d1979f8a09c759feb" translate="yes" xml:space="preserve">
          <source>The values whose square-roots are required.</source>
          <target state="translated">제곱근이 필요한 값입니다.</target>
        </trans-unit>
        <trans-unit id="187833930bd2cba800be6e8dd52776f374cc2f1c" translate="yes" xml:space="preserve">
          <source>The variable obtained by summing the squares of &lt;code&gt;df&lt;/code&gt; independent, standard normally distributed random variables:</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 독립, 표준 정규 분포 랜덤 변수 의 제곱을 합하여 얻은 변수 :</target>
        </trans-unit>
        <trans-unit id="fddb7e65a48e5500c69e424836450e7732656827" translate="yes" xml:space="preserve">
          <source>The variable used in the string representation of &lt;code&gt;p&lt;/code&gt; can be modified, using the &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; parameter:</source>
          <target state="translated">&lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; 매개 변수를 사용하여 &lt;code&gt;p&lt;/code&gt; 의 문자열 표현에 사용 된 변수를 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="032af5a223b6a82b2905b5c850f693e8fec137cd" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt;.</source>
          <target state="translated">분산은 평균과의 제곱 편차 평균, 즉 &lt;code&gt;var = mean(abs(x - x.mean())**2)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4bc052e3f44988f0e29422c1a7d1c9ad7fd6f4a4" translate="yes" xml:space="preserve">
          <source>The variance is the average of the squared deviations from the mean, i.e., &lt;code&gt;var = mean(x)&lt;/code&gt;, where &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt;.</source>
          <target state="translated">분산은 평균으로부터의 제곱 편차의 평균입니다. 즉, &lt;code&gt;var = mean(x)&lt;/code&gt; , 여기서 &lt;code&gt;x = abs(a - a.mean())**2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="598bba43a5fa13ecb982a04e1ac2dcfa3fb5a79a" translate="yes" xml:space="preserve">
          <source>The various character codes indicating certain types are also part of an enumerated list. References to type characters (should they be needed at all) should always use these enumerations. The form of them is &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; can be</source>
          <target state="translated">특정 유형을 나타내는 다양한 문자 코드도 열거 된 목록의 일부입니다. 유형 문자에 대한 참조 (모두 필요해야 함)는 항상이 열거를 사용해야합니다. 형식은 &lt;code&gt;NPY_{NAME}LTR&lt;/code&gt; 이며 &lt;code&gt;{NAME}&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="d2bf21ee585f4c470168bc467b8b8760de8826fd" translate="yes" xml:space="preserve">
          <source>The various routines in the Polynomial package all deal with series whose coefficients go from degree zero upward, which is the &lt;em&gt;reverse order&lt;/em&gt; of the Poly1d convention. The easy way to remember this is that indexes correspond to degree, i.e., coef[i] is the coefficient of the term of degree i.</source>
          <target state="translated">다항식 패키지의 다양한 루틴은 모두 계수가 0에서 위로 올라가는 시리즈를 처리 합니다. 이는 Poly1d 규칙 의 &lt;em&gt;역순&lt;/em&gt; 입니다. 이것을 기억하는 쉬운 방법은 지수가도에 해당한다는 것입니다. 즉, coef [i]는도 i의 항의 계수입니다.</target>
        </trans-unit>
        <trans-unit id="40dcb2f33f2d122b10f89906b0fa578dee7f50c3" translate="yes" xml:space="preserve">
          <source>The various selection algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The available algorithms have the following properties:</source>
          <target state="translated">다양한 선택 알고리즘은 평균 속도, 최악의 성능, 작업 공간 크기 및 안정적인지 여부를 특징으로합니다. 안정적인 정렬은 동일한 키를 가진 항목을 동일한 상대 순서로 유지합니다. 사용 가능한 알고리즘에는 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc8322a9b3a11e0738c1dc848dd44452ebdc9f34" translate="yes" xml:space="preserve">
          <source>The various sorting algorithms are characterized by their average speed, worst case performance, work space size, and whether they are stable. A stable sort keeps items with the same key in the same relative order. The four algorithms implemented in NumPy have the following properties:</source>
          <target state="translated">다양한 정렬 알고리즘은 평균 속도, 최악의 성능, 작업 공간 크기 및 안정적인지 여부를 특징으로합니다. 안정적인 정렬은 동일한 키를 가진 항목을 동일한 상대 순서로 유지합니다. NumPy에서 구현 된 네 가지 알고리즘은 다음과 같은 속성을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="909b1eaadbbd85f2064b83f98f4324e7aba0802c" translate="yes" xml:space="preserve">
          <source>The vdot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;) function handles complex numbers differently than dot(&lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;). If the first argument is complex the complex conjugate of the first argument is used for the calculation of the dot product.</source>
          <target state="translated">vdot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ) 함수는 복소수를 dot ( &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; ) 와 다르게 처리합니다 . 첫 번째 인수가 복잡한 경우 첫 번째 인수의 복합 켤레가 내적 계산에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f8aeebbf639e209f314766460959c079ab13f5dd" translate="yes" xml:space="preserve">
          <source>The version 1.0 format only allowed the array header to have a total size of 65535 bytes. This can be exceeded by structured arrays with a large number of columns. The version 2.0 format extends the header size to 4 GiB. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; will automatically save in 2.0 format if the data requires it, else it will always use the more compatible 1.0 format.</source>
          <target state="translated">버전 1.0 형식은 배열 헤더의 총 크기가 65535 바이트 일 수만있었습니다. 많은 수의 열이있는 구조화 된 배열이이를 초과 할 수 있습니다. 버전 2.0 형식은 헤더 크기를 4GiB로 확장합니다. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; 는 데이터에 필요한 경우 자동으로 2.0 형식으로 저장합니다. 그렇지 않으면 항상 호환되는 1.0 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7a92769f6aa86193f32ae6d12aa9581114703198" translate="yes" xml:space="preserve">
          <source>The version 2 interface was very similar. The differences were largely aesthetic. In particular:</source>
          <target state="translated">버전 2 인터페이스는 매우 유사했습니다. 그 차이는 크게 미적이었습니다. 특히:</target>
        </trans-unit>
        <trans-unit id="73bb55ce329b913976b213535f9642d82795177e" translate="yes" xml:space="preserve">
          <source>The version numbering of these formats is independent of NumPy version numbering. If the format is upgraded, the code in &lt;code&gt;numpy.io&lt;/code&gt; will still be able to read and write Version 1.0 files.</source>
          <target state="translated">이러한 형식의 버전 번호는 NumPy 버전 번호와 무관합니다. 형식이 업그레이드되면 &lt;code&gt;numpy.io&lt;/code&gt; 의 코드 는 여전히 버전 1.0 파일을 읽고 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d465b2400649c410304e54f051f7d49aa970de97" translate="yes" xml:space="preserve">
          <source>The von Mises distribution (also known as the circular normal distribution) is a continuous probability distribution on the unit circle. It may be thought of as the circular analogue of the normal distribution.</source>
          <target state="translated">von Mises 분포 (원형 정규 분포라고도 함)는 단위 원에 대한 연속 확률 분포입니다. 정규 분포의 원형 유사체로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="08a316a93b85a841b11a6055717875d0502f2c60" translate="yes" xml:space="preserve">
          <source>The von Mises is named for Richard Edler von Mises, who was born in Austria-Hungary, in what is now the Ukraine. He fled to the United States in 1939 and became a professor at Harvard. He worked in probability theory, aerodynamics, fluid mechanics, and philosophy of science.</source>
          <target state="translated">폰 미제스는 오스트리아-헝가리에서 태어난 리차드에 들러 폰 미제스 (Richard Edler von Mises)의 이름을 딴 것으로 우크라이나의 이름을 딴 것입니다. 그는 1939 년 미국으로 도망가 하버드에서 교수가되었습니다. 그는 확률 이론, 공기 역학, 유체 역학 및 과학 철학에서 일했습니다.</target>
        </trans-unit>
        <trans-unit id="c66491ff606b4dc91911613d519dc8370dc0d225" translate="yes" xml:space="preserve">
          <source>The warnings can be turned off by</source>
          <target state="translated">다음과 같은 방법으로 경고를 끌 수 있습니다</target>
        </trans-unit>
        <trans-unit id="a3b6182c6d54b721f88f41929f57467a3fff8892" translate="yes" xml:space="preserve">
          <source>The weight function at &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 가중치 함수 .</target>
        </trans-unit>
        <trans-unit id="88ba21dce5f8f071e2673c0f1f06439caa2807d7" translate="yes" xml:space="preserve">
          <source>The weight function is</source>
          <target state="translated">무게 기능은</target>
        </trans-unit>
        <trans-unit id="308836c1d8a38528ab14ca4524532677c1153f22" translate="yes" xml:space="preserve">
          <source>The weight function of the Chebyshev polynomials.</source>
          <target state="translated">체비 쇼프 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="adb5d593e92bd3e7a619595dc278c8d8865de5f1" translate="yes" xml:space="preserve">
          <source>The wheels and source should be uploaded to PyPI.</source>
          <target state="translated">휠과 소스는 PyPI에 업로드되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8a75026ea8d79cfa948ad8144c46e90db33a682b" translate="yes" xml:space="preserve">
          <source>The wheels, once built, appear at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy&lt;/a&gt;</source>
          <target state="translated">일단 제작 된 바퀴는 &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy에&lt;/a&gt; 나타납니다.</target>
        </trans-unit>
        <trans-unit id="9b231b3ccfadec2079a40387b8d56e7ec8b9bb3d" translate="yes" xml:space="preserve">
          <source>The window of the converted series. If the value is None, the default window of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">변환 된 시리즈의 창입니다. 값이 None이면 기본 &lt;code&gt;kind&lt;/code&gt; 창이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1da2fe6ad3abf125b431351fbdd12b7a74edc3f3" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if &lt;code&gt;M&lt;/code&gt; is odd).</source>
          <target state="translated">최대 값이 1로 정규화 된 창입니다 (1 은 &lt;code&gt;M&lt;/code&gt; 이 홀수 인 경우에만 나타남 ).</target>
        </trans-unit>
        <trans-unit id="48ac736d93f8e7e8643c8e0f7b0c321855533edd" translate="yes" xml:space="preserve">
          <source>The window, with the maximum value normalized to one (the value one appears only if the number of samples is odd).</source>
          <target state="translated">최대 값이 1로 정규화 된 창 (샘플 수가 홀수 인 경우에만 값 1이 나타남)</target>
        </trans-unit>
        <trans-unit id="523eb308fcdc8d9a4d1dacdeabc03bc7b0a18f42" translate="yes" xml:space="preserve">
          <source>The word &amp;ldquo;non-zero&amp;rdquo; is in reference to the Python 2.x built-in method &lt;code&gt;__nonzero__()&lt;/code&gt; (renamed &lt;code&gt;__bool__()&lt;/code&gt; in Python 3.x) of Python objects that tests an object&amp;rsquo;s &amp;ldquo;truthfulness&amp;rdquo;. For example, any number is considered truthful if it is nonzero, whereas any string is considered truthful if it is not the empty string. Thus, this function (recursively) counts how many elements in &lt;code&gt;a&lt;/code&gt; (and in sub-arrays thereof) have their &lt;code&gt;__nonzero__()&lt;/code&gt; or &lt;code&gt;__bool__()&lt;/code&gt; method evaluated to &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&quot;0이 아닌&quot;이라는 단어 는 객체의 &quot;진실성&quot;을 테스트하는 Python 객체 의 Python 2.x 내장 메소드 &lt;code&gt;__nonzero__()&lt;/code&gt; ( Python 3.x에서 &lt;code&gt;__bool__()&lt;/code&gt; 으로 변경됨 )를 나타냅니다. 예를 들어, 숫자가 0이 아니면 임의의 숫자는 진실한 것으로 간주되고 빈 문자열이 아닌 경우 모든 문자열은 진실한 것으로 간주됩니다. 많은 요소들이 어떻게 따라서,이 함수 재귀 카운트 (및 그 서브 어레이에서) 자신이 &lt;code&gt;__nonzero__()&lt;/code&gt; 또는 &lt;code&gt;__bool__()&lt;/code&gt; 에 따라 평가 방법 &lt;code&gt;True&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3f383c240aa5414ebaced6e3034416ca7d1b6af" translate="yes" xml:space="preserve">
          <source>The wrap option affects only tall matrices:</source>
          <target state="translated">줄 바꿈 옵션은 키가 큰 행렬에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="fc81c936c38ae025ba8146e1222f7da14b956b1d" translate="yes" xml:space="preserve">
          <source>The x-coordinate sequence is expected to be increasing, but this is not explicitly enforced. However, if the sequence &lt;code&gt;xp&lt;/code&gt; is non-increasing, interpolation results are meaningless.</source>
          <target state="translated">x 좌표 시퀀스가 ​​증가 할 것으로 예상되지만 명시 적으로 적용되지는 않습니다. 그러나 시퀀스 &lt;code&gt;xp&lt;/code&gt; 가 증가하지 않으면 보간 결과는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f30f1b95441858e7d3037adb27c5185133726d2e" translate="yes" xml:space="preserve">
          <source>The x-coordinates at which to evaluate the interpolated values.</source>
          <target state="translated">보간 된 값을 평가할 x 좌표입니다.</target>
        </trans-unit>
        <trans-unit id="98e412a8d1f1dc441497184c5505f308bf594274" translate="yes" xml:space="preserve">
          <source>The x-coordinates of the data points, must be increasing if argument &lt;code&gt;period&lt;/code&gt; is not specified. Otherwise, &lt;code&gt;xp&lt;/code&gt; is internally sorted after normalizing the periodic boundaries with &lt;code&gt;xp = xp % period&lt;/code&gt;.</source>
          <target state="translated">인수 &lt;code&gt;period&lt;/code&gt; 지정하지 않으면 데이터 포인트의 x 좌표가 증가해야 합니다. 그렇지 않으면 &lt;code&gt;xp = xp % period&lt;/code&gt; 주기 경계를 정규화 한 후 &lt;code&gt;xp&lt;/code&gt; 가 내부적으로 정렬 됩니다 .</target>
        </trans-unit>
        <trans-unit id="5fb42b6312c1e1cea4c01b6bb567b8d84d30c4b2" translate="yes" xml:space="preserve">
          <source>The y-coordinates of the data points, same length as &lt;code&gt;xp&lt;/code&gt;.</source>
          <target state="translated">데이터 포인트의 y 좌표와 같은 길이 &lt;code&gt;xp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0716cf4800278ada150f876e9ddcae3c99250b13" translate="yes" xml:space="preserve">
          <source>Their are two basic approaches to calling compiled code: writing an extension module that is then imported to Python using the import command, or calling a shared-library subroutine directly from Python using the &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; module. Writing an extension module is the most common method.</source>
          <target state="translated">컴파일 된 코드를 호출하는 두 가지 기본 접근 방식은 import 명령을 사용하여 Python으로 가져온 확장 모듈을 작성하거나 &lt;a href=&quot;https://docs.python.org/3/library/ctypes.html&quot;&gt;ctypes&lt;/a&gt; 모듈을 사용하여 Python에서 직접 공유 라이브러리 서브 루틴을 호출하는 것 입니다. 확장 모듈을 작성하는 것이 가장 일반적인 방법입니다.</target>
        </trans-unit>
        <trans-unit id="13617ef6d1ed670620e3eee1fe6521faed558f33" translate="yes" xml:space="preserve">
          <source>Their contents are described below.</source>
          <target state="translated">그 내용은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67a14bba38674d133aa6326e1d56a5430227ffd" translate="yes" xml:space="preserve">
          <source>Then modify it as follows</source>
          <target state="translated">그런 다음 다음과 같이 수정하십시오.</target>
        </trans-unit>
        <trans-unit id="629d9c8c7e969c90c99e3fcb123c3c923c445b2e" translate="yes" xml:space="preserve">
          <source>Then set your name and email:</source>
          <target state="translated">그런 다음 이름과 이메일을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="18de376fec5af9b24c105e03578c15d330983aed" translate="yes" xml:space="preserve">
          <source>Then you can obtain a lot of useful information (first details about &lt;code&gt;a&lt;/code&gt; itself, followed by the docstring of &lt;code&gt;ndarray&lt;/code&gt; of which &lt;code&gt;a&lt;/code&gt; is an instance):</source>
          <target state="translated">그런 다음 (약 첫째 자세한 유용한 정보를 많이 얻을 수 있습니다 의 문서화 문자열 뒤에 자체 &lt;code&gt;ndarray&lt;/code&gt; 있는 &lt;code&gt;a&lt;/code&gt; 인스턴스입니다) : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="beca14a81e09ec62e1fbfc41746f56a23c04a2b2" translate="yes" xml:space="preserve">
          <source>Then, I can compile the extension module using:</source>
          <target state="translated">그런 다음 다음을 사용하여 확장 모듈을 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="daa5af99f0618068c146112b2487469ac95f27c4" translate="yes" xml:space="preserve">
          <source>Then, all the HTML files will be generated in &lt;code&gt;doc/build/html/&lt;/code&gt;. Since the documentation is based on docstrings, the appropriate version of numpy must be installed in the host python used to run sphinx.</source>
          <target state="translated">그런 다음 모든 HTML 파일이 &lt;code&gt;doc/build/html/&lt;/code&gt; 생성됩니다 . 문서는 독 스트링을 기반으로하므로 스핑크스를 실행하는 데 사용되는 호스트 Python에 적절한 버전의 numpy를 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="7bbaffa25ddeac5ba58545ce47397f8a88d6c19f" translate="yes" xml:space="preserve">
          <source>Then, create a new branch based on the master branch of the upstream repository:</source>
          <target state="translated">그런 다음 업스트림 저장소의 마스터 분기를 기반으로 새 분기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a64f3ff6d48531fcbe93b1b844e9cc7950b3eeb4" translate="yes" xml:space="preserve">
          <source>Then, go to your forked repository github page, say &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt;</source>
          <target state="translated">그런 다음 분기 된 저장소 github 페이지로 이동하여 &lt;code&gt;https://github.com/your-user-name/numpy&lt;/code&gt; 라고 말합니다.</target>
        </trans-unit>
        <trans-unit id="2304d640a16ae9bfebc931161006126d186e787e" translate="yes" xml:space="preserve">
          <source>Then:</source>
          <target state="translated">Then:</target>
        </trans-unit>
        <trans-unit id="2a2d6eb0d79238cba7c8636b58f3ce6ad4b5b344" translate="yes" xml:space="preserve">
          <source>There are 4 relevant uses of the word &lt;code&gt;align&lt;/code&gt; used in numpy:</source>
          <target state="translated">numpy에 사용 된 &lt;code&gt;align&lt;/code&gt; 이라는 단어의 4 가지 관련 용도가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d627a19c8c5bea4de4ec9dd15face492281b6f90" translate="yes" xml:space="preserve">
          <source>There are 5 basic numerical types representing booleans (bool), integers (int), unsigned integers (uint) floating point (float) and complex. Those with numbers in their name indicate the bitsize of the type (i.e. how many bits are needed to represent a single value in memory). Some types, such as &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;intp&lt;/code&gt;, have differing bitsizes, dependent on the platforms (e.g. 32-bit vs. 64-bit machines). This should be taken into account when interfacing with low-level code (such as C or Fortran) where the raw memory is addressed.</source>
          <target state="translated">부울 (bool), 정수 (int), 부호없는 정수 (uint) 부동 소수점 (float) 및 복합을 나타내는 5 가지 기본 숫자 유형이 있습니다. 이름에 숫자가있는 것은 유형의 비트 크기 (즉, 메모리에서 단일 값을 나타내는 데 필요한 비트 수)를 나타냅니다. &lt;code&gt;int&lt;/code&gt; 및 &lt;code&gt;intp&lt;/code&gt; 와 같은 일부 유형 은 플랫폼에 따라 비트 크기가 다릅니다 (예 : 32 비트 대 64 비트 시스템). 원시 메모리가 처리되는 저수준 코드 (예 : C 또는 Fortran)와 인터페이스 할 때이 점을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="17bb2653ac2aa7153e927fc1353ff32c9d0fadd9" translate="yes" xml:space="preserve">
          <source>There are 5 general mechanisms for creating arrays:</source>
          <target state="translated">배열을 만드는 데는 5 가지 일반적인 메커니즘이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a7e737fa7ec2df18d82d046fe4547a421ecb3b7" translate="yes" xml:space="preserve">
          <source>There are 6 (binary) flags that describe the memory area used by the data buffer. These constants are defined in &lt;code&gt;arrayobject.h&lt;/code&gt; and determine the bit-position of the flag. Python exposes a nice attribute- based interface as well as a dictionary-like interface for getting (and, if appropriate, setting) these flags.</source>
          <target state="translated">데이터 버퍼가 사용하는 메모리 영역을 나타내는 6 (바이너리) 플래그가 있습니다. 이 상수는 &lt;code&gt;arrayobject.h&lt;/code&gt; 에 정의되어 있으며 플래그의 비트 위치를 결정합니다. 파이썬은 멋진 속성 기반 인터페이스와 이러한 플래그를 가져 오기 (및 적절한 경우)하기위한 사전과 유사한 인터페이스를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="92880b58f6bd9442d0573770c5bcc16b810e1cdc" translate="yes" xml:space="preserve">
          <source>There are &lt;code&gt;num&lt;/code&gt; equally spaced samples in the closed interval &lt;code&gt;[start, stop]&lt;/code&gt; or the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (depending on whether &lt;code&gt;endpoint&lt;/code&gt; is True or False).</source>
          <target state="translated">종료 간격 &lt;code&gt;[start, stop]&lt;/code&gt; 또는 반 개방 간격 &lt;code&gt;[start, stop)&lt;/code&gt; 에는 동일 간격의 샘플 수가 &lt;code&gt;num&lt;/code&gt; ( &lt;code&gt;endpoint&lt;/code&gt; 점이 True인지 False 인지에 따라 다름 )입니다.</target>
        </trans-unit>
        <trans-unit id="8269e59da4433043c91490542198a44ae2a7bd22" translate="yes" xml:space="preserve">
          <source>There are a few commonly reported issues depending on your system/setup. If none of the following tips help you, please be sure to note the following:</source>
          <target state="translated">시스템 / 설정에 따라 일반적으로보고되는 몇 가지 문제가 있습니다. 다음 팁 중 어느 것도 도움이되지 않는 경우 다음 사항에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="c1df47117b7e4e6ae3cadbfbaa9a3f7c95c99296" translate="yes" xml:space="preserve">
          <source>There are a few situations where masked arrays can be more useful than just eliminating the invalid entries of an array:</source>
          <target state="translated">마스킹 된 배열이 배열의 유효하지 않은 항목을 제거하는 것보다 더 유용 할 수있는 몇 가지 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f20349ffc92d6259aa973ed6765d972938b14bd" translate="yes" xml:space="preserve">
          <source>There are a number of ways to assign values to a structured array: Using python tuples, using scalar values, or using other structured arrays.</source>
          <target state="translated">구조화 배열에 값을 할당하는 방법에는 여러 가지가 있습니다. 파이썬 튜플 사용, 스칼라 값 사용 또는 기타 구조화 배열 사용.</target>
        </trans-unit>
        <trans-unit id="aabadb6a5aa99979671de060b5cf5eb2bfdc73b8" translate="yes" xml:space="preserve">
          <source>There are a variety of approaches one can use. If the file has a relatively simple format then one can write a simple I/O library and use the numpy fromfile() function and .tofile() method to read and write numpy arrays directly (mind your byteorder though!) If a good C or C++ library exists that read the data, one can wrap that library with a variety of techniques though that certainly is much more work and requires significantly more advanced knowledge to interface with C or C++.</source>
          <target state="translated">사용할 수있는 다양한 접근 방식이 있습니다. 파일의 형식이 비교적 간단한 경우 간단한 I / O 라이브러리를 작성하고 numpy fromfile () 함수 및 .tofile () 메서드를 사용하여 numpy 배열을 직접 읽고 쓸 수 있습니다. 또는 데이터를 읽는 C ++ 라이브러리가 존재하는 경우, 훨씬 더 많은 작업이 필요하고 C 또는 C ++와의 인터페이스에 훨씬 더 많은 고급 지식이 필요하지만 다양한 기술로 해당 라이브러리를 래핑 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6009b813cfbdbc400ba73901cd26bc8dc165215e" translate="yes" xml:space="preserve">
          <source>There are also typedefs for signed integers, unsigned integers, floating point, and complex floating point types of specific bit- widths. The available type names are</source>
          <target state="translated">부호있는 정수, 부호없는 정수, 부동 소수점 및 특정 비트 너비의 복합 부동 소수점 유형에 대한 typedef도 있습니다. 사용 가능한 유형 이름은</target>
        </trans-unit>
        <trans-unit id="2cd3e7355c4c3985bff39b5837a16202e8c1540c" translate="yes" xml:space="preserve">
          <source>There are currently more than 60 universal functions defined in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; on one or more types, covering a wide variety of operations. Some of these ufuncs are called automatically on arrays when the relevant infix notation is used (&lt;em&gt;e.g.&lt;/em&gt;, &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add(a, b)&lt;/code&gt;&lt;/a&gt; is called internally when &lt;code&gt;a + b&lt;/code&gt; is written and &lt;em&gt;a&lt;/em&gt; or &lt;em&gt;b&lt;/em&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;). Nevertheless, you may still want to use the ufunc call in order to use the optional output argument(s) to place the output(s) in an object (or objects) of your choice.</source>
          <target state="translated">현재 하나 이상의 유형 에 대해 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 로&lt;/a&gt; 정의 된 60 개 이상의 범용 함수 가 있으며 다양한 작업을 포함합니다. 관련 중위 표기법을 사용하는 경우 이러한 ufuncs 중 일부는 배열에 자동으로 호출된다 ( &lt;em&gt;예를 들어&lt;/em&gt; , &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add(a, b)&lt;/code&gt; &lt;/a&gt; 경우 내부적으로 호출 &lt;code&gt;a + b&lt;/code&gt; 작성되고 또는 &lt;em&gt;b는&lt;/em&gt; 입니다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; ). 그럼에도 불구하고, 선택적인 출력 인수를 사용하여 원하는 객체에 출력을 배치하기 위해 ufunc 호출을 계속 사용할 수 있습니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="775b5ff21441ff77356a90016945326f51981b32" translate="yes" xml:space="preserve">
          <source>There are fairly common issues when using PyCharm together with Anaconda, please see the &lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm support&lt;/a&gt;</source>
          <target state="translated">Anaconda와 함께 PyCharm을 사용할 때 매우 일반적인 문제가 있습니다. &lt;a href=&quot;https://www.jetbrains.com/help/pycharm/conda-support-creating-conda-virtual-environment.html&quot;&gt;PyCharm 지원을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="63abd249d8d4c496fdec07d0a25a5469a4e4f4df" translate="yes" xml:space="preserve">
          <source>There are formulas for writing useful documents, and four formulas cover nearly everything. There are four formulas because there are four categories of document &amp;ndash; &lt;code&gt;tutorial&lt;/code&gt;, &lt;code&gt;how-to guide&lt;/code&gt;, &lt;code&gt;explanation&lt;/code&gt;, and &lt;code&gt;reference&lt;/code&gt;. The insight that docs divide up this way belongs to Daniele Procida, who goes on &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;in this short article&lt;/a&gt; to explain the differences and reveal the formulas. When you begin a document or propose one, have in mind which of these types it will be.</source>
          <target state="translated">유용한 문서를 작성하기위한 공식이 있으며 네 가지 공식이 거의 모든 것을 다룹니다. &lt;code&gt;tutorial&lt;/code&gt; , &lt;code&gt;how-to guide&lt;/code&gt; , &lt;code&gt;explanation&lt;/code&gt; 및 &lt;code&gt;reference&lt;/code&gt; 네 가지 범주의 문서가 있기 때문에 네 가지 공식이 있습니다 . 문서가 이러한 방식으로 나뉘는 통찰력은 Daniele Procida의 것입니다. Daniele Procida &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;는이 짧은 기사&lt;/a&gt; 에서 차이점을 설명하고 공식을 공개합니다. 문서를 시작하거나 제안 할 때 어떤 유형이 될지 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="3438358c09e82d3e17ac10e9485821f710c7159e" translate="yes" xml:space="preserve">
          <source>There are libraries that can be used to generate arrays for special purposes and it isn&amp;rsquo;t possible to enumerate all of them. The most common uses are use of the many array generation functions in random that can generate arrays of random values, and some utility functions to generate special matrices (e.g. diagonal).</source>
          <target state="translated">특수 목적으로 배열을 생성하는 데 사용할 수있는 라이브러리가 있으며 모두 열거 할 수는 없습니다. 가장 일반적인 용도는 무작위 값의 배열을 생성 할 수있는 많은 배열 생성 함수와 특수 행렬 (예 : 대각선)을 생성하는 일부 유틸리티 함수를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c69a32040141b3969da2a2cbb310c56f38084713" translate="yes" xml:space="preserve">
          <source>There are lots of examples of how to use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; throughout the NumPy source code. The standard usage is like this:</source>
          <target state="translated">NumPy 소스 코드 전체에서 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 을 사용하는 방법에 대한 많은 예제가 있습니다. 표준 사용법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="68b9dbbab83df5d12e3f17adf9850959d4114286" translate="yes" xml:space="preserve">
          <source>There are many C or C++ array/NumPy array situations not covered by a simple &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; and subsequent &lt;code&gt;%apply&lt;/code&gt; directives.</source>
          <target state="translated">간단한 &lt;code&gt;%include &quot;numpy.i&quot;&lt;/code&gt; 및 후속 &lt;code&gt;%apply&lt;/code&gt; 지시문으로 다루지 않는 많은 C 또는 C ++ 배열 / NumPy 배열 상황이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db56cb5ed387c40b2bc60fa8c76803719afb40fe" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://try.github.io/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://try.github.io/&quot;&gt;git&lt;/a&gt; 을 배우는 데 도움이되는 많은 온라인 자습서가 있습니다 . 특정 git 워크 플로에 대한 토론은 &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; 및 &lt;a href=&quot;https://mail.python.org/pipermail/ipython-dev/2010-October/005632.html&quot;&gt;ipython git workflow&lt;/a&gt; 에 대한 토론을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="a3c7bbd8e8aff936bd091f138c70193c9efdefe3" translate="yes" xml:space="preserve">
          <source>There are many online tutorials to help you &lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;learn git&lt;/a&gt;. For discussions of specific git workflows, see these discussions on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt;, and &lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git workflow&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://www.atlassian.com/git/tutorials/&quot;&gt;git&lt;/a&gt; 을 배우는 데 도움이되는 많은 온라인 자습서가 있습니다 . 특정 git 워크 플로에 대한 토론은 &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; 및 &lt;a href=&quot;http://mail.python.org/pipermail/ipython-dev/2010-October/006746.html&quot;&gt;ipython git workflow&lt;/a&gt; 에 대한 토론을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="4e7a362f552d6539941413dc2279097986613078" translate="yes" xml:space="preserve">
          <source>There are many ways of working with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;; here are some posts on the rules of thumb that other projects have come up with:</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; 작업에는 여러 가지 방법이 있습니다 . 다음은 다른 프로젝트에서 제안한 경험 규칙에 대한 몇 가지 게시물입니다.</target>
        </trans-unit>
        <trans-unit id="850bf20dccfb45fbea5bb3bf4cc123a24de9ce74" translate="yes" xml:space="preserve">
          <source>There are many ways to define the DFT, varying in the sign of the exponent, normalization, etc. In this implementation, the DFT is defined as</source>
          <target state="translated">지수, 정규화 등의 부호가 다른 DFT를 정의하는 방법에는 여러 가지가 있습니다.이 구현에서 DFT는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="76da8844fec054fd5276e6ad85d740b68fcb82e8" translate="yes" xml:space="preserve">
          <source>There are no general requirements on the return value from &lt;code&gt;__array_function__&lt;/code&gt;, although most sensible implementations should probably return array(s) with the same type as one of the function&amp;rsquo;s arguments.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 의 반환 값에 대한 일반적인 요구 사항은 없지만 대부분의 현명한 구현은 함수의 인수 중 하나와 동일한 유형의 배열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="06faa5c6fcba06f9dd8ca92063029df6a41e4c58" translate="yes" xml:space="preserve">
          <source>There are often instances where we want NumPy to initialize the values of an array. NumPy offers functions like &lt;code&gt;ones()&lt;/code&gt; and &lt;code&gt;zeros()&lt;/code&gt;, and the &lt;code&gt;random.Generator&lt;/code&gt; class for random number generation for that. All you need to do is pass in the number of elements you want it to generate:</source>
          <target state="translated">NumPy가 배열의 값을 초기화하기를 원하는 경우가 종종 있습니다. NumPy와는 같은 기능을 제공하는 &lt;code&gt;ones()&lt;/code&gt; 와 &lt;code&gt;zeros()&lt;/code&gt; 및 &lt;code&gt;random.Generator&lt;/code&gt; 의 그것을위한 난수 생성을위한 클래스입니다. 생성 할 요소의 수를 전달하기 만하면됩니다.</target>
        </trans-unit>
        <trans-unit id="95381d820ed4d179172c69e3a1efc8e39007df94" translate="yes" xml:space="preserve">
          <source>There are only integer array indices so that no subarray exists.</source>
          <target state="translated">하위 배열이 존재하지 않도록 정수 배열 인덱스 만 있습니다.</target>
        </trans-unit>
        <trans-unit id="115526010a225042aa40f787fc2f47f797982daf" translate="yes" xml:space="preserve">
          <source>There are other points in the use of ndarrays where we need such views, such as copying arrays (&lt;code&gt;c_arr.copy()&lt;/code&gt;), creating ufunc output arrays (see also &lt;a href=&quot;#array-wrap&quot;&gt;__array_wrap__ for ufuncs and other functions&lt;/a&gt;), and reducing methods (like &lt;code&gt;c_arr.mean()&lt;/code&gt;).</source>
          <target state="translated">배열 복사 ( &lt;code&gt;c_arr.copy()&lt;/code&gt; ), ufunc 출력 배열 생성 ( &lt;a href=&quot;#array-wrap&quot;&gt;ufuncs 및 기타 함수에 대해서는 __array_wrap__&lt;/a&gt; 참조 ), 메서드 감소 (예 : &lt;code&gt;c_arr.mean()&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="72e1214b4766467e55cb3f8f030a4456afbf45a2" translate="yes" xml:space="preserve">
          <source>There are other wrapping situations in which &lt;code&gt;numpy.i&lt;/code&gt; may be helpful when you encounter them.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 가 발생할 때 도움이 될 수있는 다른 래핑 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="318856ec210de70f7b88df3c75c2a12aaa8c93b2" translate="yes" xml:space="preserve">
          <source>There are pros and cons to using both:</source>
          <target state="translated">둘 다 사용하는 데는 장단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f83bfa0078610ce5c1a2e851fa86300b3de47263" translate="yes" xml:space="preserve">
          <source>There are several disadvantages of using Cython:</source>
          <target state="translated">Cython을 사용하면 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c928426bd7e5582ef0057cd443cd0554ec0f93c" translate="yes" xml:space="preserve">
          <source>There are several examples of using the multi-iterator in the NumPy source code as it makes N-dimensional broadcasting-code very simple to write. Browse the source for more examples.</source>
          <target state="translated">NumPy 소스 코드에서 다중 반복자를 사용하는 몇 가지 예가 있습니다. N- 차원 방송 코드를 작성하기가 매우 간단합니다. 더 많은 예제를 보려면 소스를 찾아보십시오.</target>
        </trans-unit>
        <trans-unit id="27bf18c3e68f395d5dcf853e32e810c666f7a43d" translate="yes" xml:space="preserve">
          <source>There are several requirements for a shared library that can be used with ctypes that are platform specific. This guide assumes you have some familiarity with making a shared library on your system (or simply have a shared library available to you). Items to remember are:</source>
          <target state="translated">플랫폼 별 ctypes와 함께 사용할 수있는 공유 라이브러리에 대한 몇 가지 요구 사항이 있습니다. 이 가이드는 사용자가 시스템에서 공유 라이브러리를 만드는 데 어느 정도 익숙하다고 가정합니다 (또는 단순히 공유 라이브러리를 사용할 수 있음). 기억해야 할 항목은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b82ec3b39568bfec9a11840bdb7b6ec4c84323cc" translate="yes" xml:space="preserve">
          <source>There are several ways to construct a masked array.</source>
          <target state="translated">마스크 배열을 구성하는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4a7e4b025b48bc40d3703a29b57ae48e3043f29" translate="yes" xml:space="preserve">
          <source>There are several ways to create arrays.</source>
          <target state="translated">배열을 만드는 방법에는 여러 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ffbc541dfd45825fd321c5ec3bdf633ecc4c702b" translate="yes" xml:space="preserve">
          <source>There are some informational attributes that universal functions possess. None of the attributes can be set.</source>
          <target state="translated">범용 함수에는 몇 가지 정보 속성이 있습니다. 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="25b081aeb44044a8abafdf90f986afb1775ac9ea" translate="yes" xml:space="preserve">
          <source>There are sometimes issues reported on Raspberry Pi setups when installing using &lt;code&gt;pip3 install&lt;/code&gt; (or &lt;code&gt;pip&lt;/code&gt; install). These will typically mention:</source>
          <target state="translated">&lt;code&gt;pip3 install&lt;/code&gt; (또는 &lt;code&gt;pip&lt;/code&gt; 설치) 를 사용하여 설치할 때 Raspberry Pi 설정에보고 된 문제가 가끔 있습니다 . 일반적으로 다음을 언급합니다.</target>
        </trans-unit>
        <trans-unit id="014e04d63bbb11cf7242b7931500c73711d0520d" translate="yes" xml:space="preserve">
          <source>There are standard variable types for each of the numeric data types and the bool data type. Some of these are already available in the C-specification. You can create variables in extension code with these types.</source>
          <target state="translated">각 숫자 데이터 유형 및 부울 데이터 유형에 대한 표준 변수 유형이 있습니다. 이들 중 일부는 이미 C 사양에서 사용 가능합니다. 이러한 유형의 확장 코드에서 변수를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d266f8d3fc00db82d70a1cf8a8ecaaaa80431033" translate="yes" xml:space="preserve">
          <source>There are three independent testing frameworks supported, for one-, two-, and three-dimensional arrays respectively. For one-dimensional arrays, there are two C++ files, a header and a source, named:</source>
          <target state="translated">1 차원, 2 차원 및 3 차원 배열 각각에 대해 3 가지 독립적 인 테스트 프레임 워크가 지원됩니다. 1 차원 배열의 경우 헤더와 소스라는 두 가지 C ++ 파일이 있습니다.</target>
        </trans-unit>
        <trans-unit id="a98d06ff6365cb9b94028f7c87529f8503c9281a" translate="yes" xml:space="preserve">
          <source>There are three methods of ufuncs that require calculation similar to the general-purpose ufuncs. These are reduce, accumulate, and reduceat. Each of these methods requires a setup command followed by a loop. There are four loop styles possible for the methods corresponding to no-elements, one-element, strided-loop, and buffered- loop. These are the same basic loop styles as implemented for the general purpose function call except for the no-element and one- element cases which are special-cases occurring when the input array objects have 0 and 1 elements respectively.</source>
          <target state="translated">범용 ufunc와 유사한 계산이 필요한 ufunc의 세 가지 방법이 있습니다. 이들은 축소, 누적 및 축소입니다. 이러한 각 방법에는 설정 명령과 루프가 필요합니다. 비 요소, 하나의 요소, 스트라이드 루프 및 버퍼 루프에 해당하는 방법에는 네 가지 루프 스타일이 있습니다. 이들은 입력 배열 객체가 각각 0과 1 개의 요소를 가질 때 발생하는 특수한 경우 인 비 요소 및 단일 요소 경우를 제외하고 범용 함수 호출에 대해 구현 된 것과 동일한 기본 루프 스타일입니다.</target>
        </trans-unit>
        <trans-unit id="79149af5bd80302b7d9a0d00bba8113083202d98" translate="yes" xml:space="preserve">
          <source>There are three steps to the process.</source>
          <target state="translated">프로세스에는 세 단계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="30d692f23dd01af5033268a8ed1b02fd45c32c1c" translate="yes" xml:space="preserve">
          <source>There are three strategies implemented that can be used to produce repeatable pseudo-random numbers across multiple processes (local or distributed).</source>
          <target state="translated">여러 프로세스 (로컬 또는 분산)에서 반복 가능한 의사 난수를 생성하는 데 사용할 수있는 세 가지 전략이 구현되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9dfb3a62923157363de4f21bfcb4cc89da91a3e2" translate="yes" xml:space="preserve">
          <source>There are three use-cases related to memory alignment in numpy (as of 1.14):</source>
          <target state="translated">numpy의 메모리 정렬과 관련된 세 가지 사용 사례가 있습니다 (1.14 기준).</target>
        </trans-unit>
        <trans-unit id="1878e6ac9e299677e2b59b09c76f88c728c9412d" translate="yes" xml:space="preserve">
          <source>There are times when it is important to visit the elements of an array in a specific order, irrespective of the layout of the elements in memory. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides an &lt;code&gt;order&lt;/code&gt; parameter to control this aspect of iteration. The default, having the behavior described above, is order=&amp;rsquo;K&amp;rsquo; to keep the existing order. This can be overridden with order=&amp;rsquo;C&amp;rsquo; for C order and order=&amp;rsquo;F&amp;rsquo; for Fortran order.</source>
          <target state="translated">메모리의 요소 레이아웃에 관계없이 특정 순서로 배열의 요소를 방문하는 것이 중요한 경우가 있습니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 목적은 제공 &lt;code&gt;order&lt;/code&gt; 반복의 이러한 양태를 제어하는 파라미터. 위에서 설명한 동작을 갖는 기본값은 기존 주문을 유지하기 위해 order = 'K'입니다. C 주문의 경우 order = 'C', Fortran 주문의 경우 order = 'F'로 대체 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8bcb408782f4cab8808f9329f353388438a050d8" translate="yes" xml:space="preserve">
          <source>There are times when it is necessary to treat an array as a different data type than it is stored as. For instance, one may want to do all computations on 64-bit floats, even if the arrays being manipulated are 32-bit floats. Except when writing low-level C code, it&amp;rsquo;s generally better to let the iterator handle the copying or buffering instead of casting the data type yourself in the inner loop.</source>
          <target state="translated">어레이를 저장된 것과 다른 데이터 유형으로 취급해야하는 경우가 있습니다. 예를 들어, 조작되는 어레이가 32 비트 플로트 인 경우에도 64 비트 플로트에서 모든 계산을 수행 할 수 있습니다. 저수준 C 코드를 작성할 때를 제외하고 일반적으로 내부 루프에서 데이터 유형을 직접 캐스팅하는 대신 반복자가 복사 또는 버퍼링을 처리하도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="49296589bf54025f71f98956452ad22438eb00b7" translate="yes" xml:space="preserve">
          <source>There are times when you might want to carry out an operation between an array and a single number (also called &lt;em&gt;an operation between a vector and a scalar&lt;/em&gt;) or between arrays of two different sizes. For example, your array (we&amp;rsquo;ll call it &amp;ldquo;data&amp;rdquo;) might contain information about distance in miles but you want to convert the information to kilometers. You can perform this operation with:</source>
          <target state="translated">배열과 단일 숫자 &lt;em&gt;사이 (벡터와 스칼라 사이의 연산&lt;/em&gt; 이라고도 함 ) 또는 두 가지 크기 의 배열 사이에서 연산을 수행하려는 경우가 있습니다 . 예를 들어, 배열 ( &quot;데이터&quot;라고 함)에는 거리에 대한 정보 (마일)가 포함될 수 있지만 정보를 킬로미터로 변환하려고합니다. 다음을 사용하여이 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52cac18f5846d7a58eabeae3e5d687453dc981d9" translate="yes" xml:space="preserve">
          <source>There are two Timedelta units (&amp;lsquo;Y&amp;rsquo;, years and &amp;lsquo;M&amp;rsquo;, months) which are treated specially, because how much time they represent changes depending on when they are used. While a timedelta day unit is equivalent to 24 hours, there is no way to convert a month unit into days, because different months have different numbers of days.</source>
          <target state="translated">특별히 취급되는 두 개의 Timedelta 단위 ( 'Y', 연도 및 'M', 월)가 있습니다. 사용 시간에 따라 시간이 얼마나 변하는 지 나타냅니다. 타임 델타 일 단위는 24 시간에 해당하지만 달마다 다른 일 수가 있으므로 월 단위를 일로 변환 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="47ec50226de8d5ba6a84cfb19309924a297ce7ae" translate="yes" xml:space="preserve">
          <source>There are two aspects to the machinery that ndarray uses to support views and new-from-template in subclasses.</source>
          <target state="translated">ndarray가 서브 클래스에서 뷰 및 템플릿에서 새로운 것을 지원하기 위해 사용하는 기계에는 두 가지 측면이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ced97d88ae2c849acfa28a2cee713cefa36672d2" translate="yes" xml:space="preserve">
          <source>There are two major new types: the ndarray ( &lt;a href=&quot;#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; ) and the ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt;&lt;code&gt;PyUFunc_Type&lt;/code&gt;&lt;/a&gt; ). Additional types play a supportive role: the &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; . The &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt;&lt;code&gt;PyArrayIter_Type&lt;/code&gt;&lt;/a&gt; is the type for a flat iterator for an ndarray (the object that is returned when getting the flat attribute). The &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt;&lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt;&lt;/a&gt; is the type of the object returned when calling &lt;code&gt;broadcast&lt;/code&gt; (). It handles iteration and broadcasting over a collection of nested sequences. Also, the &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt;&lt;code&gt;PyArrayDescr_Type&lt;/code&gt;&lt;/a&gt; is the data-type-descriptor type whose instances describe the data. Finally, there are 21 new scalar-array types which are new Python scalars corresponding to each of the fundamental data types available for arrays. An additional 10 other types are place holders that allow the array scalars to fit into a hierarchy of actual Python types.</source>
          <target state="translated">ndarray (: 두 가지 새로운 유형이 있습니다 &lt;a href=&quot;#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; )와 ufunc ( &lt;a href=&quot;#c.PyUFunc_Type&quot;&gt; &lt;code&gt;PyUFunc_Type&lt;/code&gt; 는&lt;/a&gt; ). 추가 유형은 &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt; 과 같은 지원 역할을 합니다 . &lt;a href=&quot;#c.PyArrayIter_Type&quot;&gt; &lt;code&gt;PyArrayIter_Type&lt;/code&gt; 는&lt;/a&gt; ndarray (평면 속성을 가져올 때 반환되는 개체)에 대한 평면 반복자의 유형입니다. &lt;a href=&quot;#c.PyArrayMultiIter_Type&quot;&gt; &lt;code&gt;PyArrayMultiIter_Type&lt;/code&gt; 이&lt;/a&gt; 호출 할 때 개체의 형식을 반환 &lt;code&gt;broadcast&lt;/code&gt; (). 중첩 시퀀스 컬렉션을 통한 반복 및 브로드 캐스트를 처리합니다. 또한 &lt;a href=&quot;#c.PyArrayDescr_Type&quot;&gt; &lt;code&gt;PyArrayDescr_Type&lt;/code&gt; &lt;/a&gt;인스턴스가 데이터를 설명하는 데이터 유형 설명자 유형입니다. 마지막으로, 배열에 사용 가능한 각 기본 데이터 유형에 해당하는 새로운 Python 스칼라 인 21 개의 새로운 스칼라 배열 유형이 있습니다. 배열 스칼라를 실제 파이썬 유형의 계층 구조에 맞출 수있는 다른 10 개의 다른 유형이 자리 표시 자입니다.</target>
        </trans-unit>
        <trans-unit id="c37fba99ab33d4532607fe9319066dc8a4405878" translate="yes" xml:space="preserve">
          <source>There are two mechanisms which allow this to be done, temporary copies and buffering mode. With temporary copies, a copy of the entire array is made with the new data type, then iteration is done in the copy. Write access is permitted through a mode which updates the original array after all the iteration is complete. The major drawback of temporary copies is that the temporary copy may consume a large amount of memory, particularly if the iteration data type has a larger itemsize than the original one.</source>
          <target state="translated">이 작업을 수행 할 수있는 두 가지 메커니즘, 임시 복사 및 버퍼링 모드가 있습니다. 임시 사본을 사용하면 전체 배열의 사본이 새 데이터 유형으로 작성되고 사본에서 반복이 수행됩니다. 모든 반복이 완료된 후 원래 배열을 업데이트하는 모드를 통해 쓰기 액세스가 허용됩니다. 임시 사본의 주요 단점은 특히 반복 데이터 유형의 항목 크기가 원래 항목보다 큰 경우 임시 사본이 많은 양의 메모리를 소비 할 수 있다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bbd0e93d84494368770e6b417effb4b358f4babd" translate="yes" xml:space="preserve">
          <source>There are two modes of creating an array using &lt;code&gt;__new__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; 를 사용하여 배열을 만드는 두 가지 모드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e95a2d13ee09be4667ba99a7e23d783a62c61eb8" translate="yes" xml:space="preserve">
          <source>There are two popular ways to flatten an array: &lt;code&gt;.flatten()&lt;/code&gt; and &lt;code&gt;.ravel()&lt;/code&gt;. The primary difference between the two is that the new array created using &lt;code&gt;ravel()&lt;/code&gt; is actually a reference to the parent array (i.e., a &amp;ldquo;view&amp;rdquo;). This means that any changes to the new array will affect the parent array as well. Since &lt;code&gt;ravel&lt;/code&gt; does not create a copy, it&amp;rsquo;s memory efficient.</source>
          <target state="translated">배열을 평면화하는 두 가지 인기있는 방법이 있습니다 : &lt;code&gt;.flatten()&lt;/code&gt; 및 &lt;code&gt;.ravel()&lt;/code&gt; . 둘 사이의 주요 차이점은 &lt;code&gt;ravel()&lt;/code&gt; 사용하여 만든 새 배열 이 실제로 부모 배열에 대한 참조 (즉, &quot;뷰&quot;)라는 것입니다. 즉, 새 어레이에 대한 변경 사항은 상위 어레이에도 영향을 미칩니다. &lt;code&gt;ravel&lt;/code&gt; 은 복사본을 생성하지 않기 때문에 메모리 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="97769fec67515ece6f805db56bd64883845242d0" translate="yes" xml:space="preserve">
          <source>There are two types of proper-contiguous NumPy arrays:</source>
          <target state="translated">적절한 연속 NumPy 배열에는 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="0373fb682b5018f30be6571b2e08840bdbbdebff" translate="yes" xml:space="preserve">
          <source>There are two ways to capture floating-point error messages. The first is to set the error-handler to &amp;lsquo;call&amp;rsquo;, using &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;. Then, set the function to call using this function.</source>
          <target state="translated">부동 소수점 오류 메시지를 캡처하는 두 가지 방법이 있습니다. 첫 번째는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; 을&lt;/a&gt; 사용하여 오류 처리기를 'call'으로 설정하는 것 입니다. 그런 다음이 기능을 사용하여 호출 할 기능을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="7822fba8682a2c5b4fec5101c082332701ec52bb" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">(떨어져 구조화 유형의 구성에서 효율적으로 새로운 배열 스칼라 유형을 정의하는 방법에는 두 가지가 있습니다 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes을&lt;/a&gt; 내장 스칼라 유형에서) : 한 가지 방법은 단순히 서브 클래스입니다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 관심있는 방법을 덮어 씁니다. 이것은 어느 정도 작동하지만 내부적으로 특정 동작은 배열의 데이터 유형에 의해 수정됩니다. 배열의 데이터 유형을 완전히 사용자 정의하려면 새 데이터 유형을 정의하고 NumPy에 등록해야합니다. 이러한 새로운 유형은 &lt;a href=&quot;c-api#c-api&quot;&gt;NumPy C-API를&lt;/a&gt; 사용하여 C에서만 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c78474a57486cf4a85d9232cd27ee1937bd696d" translate="yes" xml:space="preserve">
          <source>There are two ways to effectively define a new array scalar type (apart from composing structured types &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtypes&lt;/a&gt; from the built-in scalar types): One way is to simply subclass the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and overwrite the methods of interest. This will work to a degree, but internally certain behaviors are fixed by the data type of the array. To fully customize the data type of an array you need to define a new data-type, and register it with NumPy. Such new types can only be defined in C, using the &lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API&lt;/a&gt;.</source>
          <target state="translated">새 배열 스칼라 유형을 효과적으로 정의하는 두 가지 방법이 있습니다 ( 내장 된 스칼라 유형에서 구조화 된 유형 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;dtype&lt;/a&gt; 을 구성하는 것과는 별개로 ). 한 가지 방법은 단순히 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱하고 관심있는 메소드를 덮어 쓰는 것입니다. 이것은 어느 정도 작동하지만 내부적으로 특정 동작은 배열의 데이터 유형에 의해 고정됩니다. 배열의 데이터 유형을 완전히 사용자 정의하려면 새 데이터 유형을 정의하고 NumPy에 등록해야합니다. 이러한 새로운 유형은 &lt;a href=&quot;c-api/index#c-api&quot;&gt;NumPy C-API를&lt;/a&gt; 사용하여 C에서만 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cedb91ab21e9adb6003c75e29f535939f4382660" translate="yes" xml:space="preserve">
          <source>There are two ways to update the source release on PyPI, the first one is:</source>
          <target state="translated">PyPI에서 소스 릴리스를 업데이트하는 방법에는 두 가지가 있습니다. 첫 번째 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="07256ff1dd075c50fc2daea66eb388157aacb269" translate="yes" xml:space="preserve">
          <source>There are two ways to use the interface: A Python side and a C-side. Both are separate attributes.</source>
          <target state="translated">인터페이스를 사용하는 두 가지 방법이 있습니다 : 파이썬 측과 C 측. 둘 다 별도의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="b03a9c50082003b4ef01f90e63c960011178dda8" translate="yes" xml:space="preserve">
          <source>There has been no consistent prefix for NumPy public functions, but they all begin with a prefix of some sort, followed by an underscore, and are in camel case: &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt;, &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;. In the future the names should be of the form &lt;code&gt;Npy*_PublicFunction&lt;/code&gt;, where the star is something appropriate.</source>
          <target state="translated">NumPy 공용 함수에 대해 일관된 접두사가 없지만 모두 일종의 접두사로 시작하고 밑줄이 뒤 따르며 낙타의 경우 &lt;code&gt;PyArray_DescrAlignConverter&lt;/code&gt; , &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 입니다. 앞으로 이름은 &lt;code&gt;Npy*_PublicFunction&lt;/code&gt; 형식 이어야하며 , 여기서 별은 적절한 것입니다.</target>
        </trans-unit>
        <trans-unit id="dde43af7d13c44f94f0d79c46e9390e7c8216335" translate="yes" xml:space="preserve">
          <source>There is a Python type for each of the different built-in data types that can be present in the array Most of these are simple wrappers around the corresponding data type in C. The C-names for these types are &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; where &lt;code&gt;{TYPE}&lt;/code&gt; can be</source>
          <target state="translated">배열에 존재할 수있는 각각의 다른 내장 데이터 유형에 대해 Python 유형이 있습니다. 이들 중 대부분은 C의 해당 데이터 유형을 둘러싼 단순 랩퍼입니다.이 유형의 C 이름은 &lt;code&gt;Py{TYPE}ArrType_Type&lt;/code&gt; . &lt;code&gt;{TYPE}&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="07c5411b83a37216eb927b90741cd5630b9b2108" translate="yes" xml:space="preserve">
          <source>There is a clear distinction between element-wise operations and linear algebra operations.</source>
          <target state="translated">요소 별 연산과 선형 대수 연산 사이에는 분명한 차이가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0d05d2bbb1d4347eb1dace6314a1a3b989e2daa" translate="yes" xml:space="preserve">
          <source>There is a fragment for converting a Python integer to a C &lt;code&gt;long&lt;/code&gt;. There is a different fragment that converts a Python integer to a C &lt;code&gt;int&lt;/code&gt;, that calls the routine defined in the &lt;code&gt;long&lt;/code&gt; fragment. We can make the changes we want here by changing the definition for the &lt;code&gt;long&lt;/code&gt; fragment. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; determines the active definition for a fragment using a &amp;ldquo;first come, first served&amp;rdquo; system. That is, we need to define the fragment for &lt;code&gt;long&lt;/code&gt; conversions prior to &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; doing it internally. &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; allows us to do this by putting our fragment definitions in the file &lt;code&gt;pyfragments.swg&lt;/code&gt;. If we were to put the new fragment definitions in &lt;code&gt;numpy.i&lt;/code&gt;, they would be ignored.</source>
          <target state="translated">파이썬 정수를 C &lt;code&gt;long&lt;/code&gt; 으로 변환하기위한 프래그먼트가 있습니다 . &lt;code&gt;long&lt;/code&gt; 정수에 정의 된 루틴을 호출 하는 Python 정수를 C &lt;code&gt;int&lt;/code&gt; 로 변환하는 다른 단편이 있습니다. &lt;code&gt;long&lt;/code&gt; 프래그먼트에 대한 정의를 변경하여 여기서 원하는대로 변경할 수 있습니다 . &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는&amp;ldquo;선착순&amp;rdquo;시스템을 사용하여 조각에 대한 활성 정의를 결정합니다. 즉, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 가 내부적으로 수행 하기 전에 &lt;code&gt;long&lt;/code&gt; 변환을 위한 프래그먼트를 정의해야합니다 . &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG를&lt;/a&gt; 사용하면 조각 정의를 &lt;code&gt;pyfragments.swg&lt;/code&gt; 파일에 넣어이 작업을 수행 할 수 있습니다 . 새로운 프래그먼트 정의를 &lt;code&gt;numpy.i&lt;/code&gt; 이면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d31593a379a881f2302877c7bf40c8ae65305ffb" translate="yes" xml:space="preserve">
          <source>There is a general need for looping over not only functions on scalars but also over functions on vectors (or arrays). This concept is realized in NumPy by generalizing the universal functions (ufuncs). In regular ufuncs, the elementary function is limited to element-by-element operations, whereas the generalized version (gufuncs) supports &amp;ldquo;sub-array&amp;rdquo; by &amp;ldquo;sub-array&amp;rdquo; operations. The Perl vector library PDL provides a similar functionality and its terms are re-used in the following.</source>
          <target state="translated">스칼라의 함수뿐만 아니라 벡터 (또는 배열)의 함수에 대해서도 반복이 필요합니다. 이 개념은 NumPy에서 범용 함수 (ufunc)를 일반화함으로써 실현됩니다. 일반 ufunc에서 기본 기능은 요소 별 연산으로 제한되는 반면 일반화 된 버전 (gufuncs)은 &quot;서브 어레이&quot;연산으로 &quot;서브 어레이&quot;를 지원합니다. Perl 벡터 라이브러리 PDL은 유사한 기능을 제공하며 그 용어는 다음에서 재사용됩니다.</target>
        </trans-unit>
        <trans-unit id="16ce9fcfde9d0ef11eba9dffd6932b4fb7fe6e10" translate="yes" xml:space="preserve">
          <source>There is a list of enumerated types defined providing the basic 24 data types plus some useful generic names. Whenever the code requires a type number, one of these enumerated types is requested. The types are all called &lt;code&gt;NPY_{NAME}&lt;/code&gt;:</source>
          <target state="translated">기본 24 데이터 유형과 유용한 일반 이름을 제공하도록 정의 된 열거 유형 목록이 있습니다. 코드에 유형 번호가 필요할 때마다 열거 된 유형 중 하나가 요청됩니다. 유형은 모두 &lt;code&gt;NPY_{NAME}&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="fd095b1a939a3168566a681ecc0b30a59e81e682" translate="yes" xml:space="preserve">
          <source>There is a small difference between &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt; &lt;code&gt;mini&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;numpy.ma.min#numpy.ma.min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; 사이에는 약간의 차이가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="426d6a71d6ada6c4fe36711b0bf2acc4eb8a1d92" translate="yes" xml:space="preserve">
          <source>There is a subarray but it has exactly one element. This case can be handled as if there is no subarray, but needs some care during setup.</source>
          <target state="translated">하위 배열이 있지만 정확히 하나의 요소가 있습니다. 이 경우는 하위 배열이없는 것처럼 처리 할 수 ​​있지만 설정하는 동안 약간의주의가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="a1e2cb9284c447866f4fcfbd5e36a19034ca7940" translate="yes" xml:space="preserve">
          <source>There is also a &amp;ldquo;flat&amp;rdquo; in-place array for situations in which you would like to modify or process each element, regardless of the number of dimensions. One example is a &amp;ldquo;quantization&amp;rdquo; function that quantizes each element of an array in-place, be it 1D, 2D or whatever. This form checks for continuity but allows either C or Fortran ordering.</source>
          <target state="translated">차원 수에 관계없이 각 요소를 수정하거나 처리하려는 상황에 맞는 &quot;평평한&quot;인플레 이스 배열도 있습니다. 한 가지 예는 배열의 각 요소를 1D, 2D 등 어떤 위치에서나 양자화하는 &quot;양자화&quot;함수입니다. 이 양식은 연속성을 확인하지만 C 또는 Fortran 주문을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="42d7ce17e767848814f251a3d945724bdcad4394" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">이 C API를 사용하는 사람들에게 흥미로울 수있는 &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;배열 반복에&lt;/a&gt; 대한 소개 가이드 가 있습니다. 많은 경우에 C 반복 코드를 작성하기 전에 Python에서 반복자를 만들어 아이디어를 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="89b73fe8185f285d3a10cd617f08eb8cadb40473" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt; which may be of interest for those using this C API. In many instances, testing out ideas by creating the iterator in Python is a good idea before writing the C iteration code.</source>
          <target state="translated">이 C API를 사용하는 사람들이 관심을 가질 수있는 &lt;a href=&quot;arrays.nditer#arrays-nditer&quot;&gt;배열 반복에&lt;/a&gt; 대한 소개 안내서 가 있습니다. 많은 경우, C 반복 코드를 작성하기 전에 Python에서 반복자를 작성하여 아이디어를 테스트하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="606a479ef2292dc711e91c789c67dff3002d3e8e" translate="yes" xml:space="preserve">
          <source>There is an ongoing effort to improve the API. It is important in this effort to ensure that code that compiles for NumPy 1.X continues to compile for NumPy 1.X. At the same time, certain API&amp;rsquo;s will be marked as deprecated so that future-looking code can avoid these API&amp;rsquo;s and follow better practices.</source>
          <target state="translated">API를 개선하기위한 지속적인 노력이 있습니다. 이 노력에서 NumPy 1.X 용으로 컴파일되는 코드가 NumPy 1.X 용으로 계속 컴파일되도록하는 것이 중요합니다. 동시에, 특정 API는 더 이상 사용되지 않는 것으로 표시되어 미래의 코드에서 이러한 API를 피하고 더 나은 방법을 따를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d9dbfa834497f6482a194ae6bc42d9b31e1c027" translate="yes" xml:space="preserve">
          <source>There is exactly one function that must be defined in your C-code in order for Python to use it as an extension module. The function must be called init{name} where {name} is the name of the module from Python. This function must be declared so that it is visible to code outside of the routine. Besides adding the methods and constants you desire, this subroutine must also contain calls like &lt;code&gt;import_array()&lt;/code&gt; and/or &lt;code&gt;import_ufunc()&lt;/code&gt; depending on which C-API is needed. Forgetting to place these commands will show itself as an ugly segmentation fault (crash) as soon as any C-API subroutine is actually called. It is actually possible to have multiple init{name} functions in a single file in which case multiple modules will be defined by that file. However, there are some tricks to get that to work correctly and it is not covered here.</source>
          <target state="translated">Python이 확장 모듈로 사용하려면 C 코드에 정의해야하는 함수가 정확히 하나 있습니다. 함수는 init {name}으로 호출되어야합니다. 여기서 {name}은 Python의 모듈 이름입니다. 이 함수는 루틴 외부의 코드에서 볼 수 있도록 선언되어야합니다. 원하는 메서드와 상수를 추가하는 것 외에도이 서브 루틴에는 &lt;code&gt;import_array()&lt;/code&gt; 및 / 또는 &lt;code&gt;import_ufunc()&lt;/code&gt; 와 같은 호출도 포함되어야합니다.필요한 C-API에 따라 다릅니다. 이러한 명령을 입력하지 않으면 C-API 서브 루틴이 실제로 호출되는 즉시 추악한 세그멘테이션 오류 (충돌)로 표시됩니다. 실제로 단일 파일에 여러 개의 init {name} 함수가있을 수 있습니다.이 경우 해당 파일에 여러 모듈이 정의됩니다. 그러나 제대로 작동하도록하는 몇 가지 트릭이 있으며 여기서는 다루지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c951415e0655e2f1d542beb400e29df172840589" translate="yes" xml:space="preserve">
          <source>There is more than one definition of sign in common use for complex numbers. The definition used here is equivalent to</source>
          <target state="translated">복소수에 일반적으로 사용되는 부호에 대한 정의가 두 개 이상 있습니다. 여기에 사용 된 정의는</target>
        </trans-unit>
        <trans-unit id="81f07ae1e9b8a43b5991326dbec6dd373febf78b" translate="yes" xml:space="preserve">
          <source>There is no need to use &lt;code&gt;intent(c)&lt;/code&gt; for one-dimensional arrays, no matter if the wrapped function is either a Fortran or a C function. This is because the concepts of Fortran- and C contiguity overlap in one-dimensional cases.</source>
          <target state="translated">래핑 된 함수가 Fortran 또는 C 함수인지에 관계없이 1 차원 배열에 대해 &lt;code&gt;intent(c)&lt;/code&gt; 를 사용할 필요가 없습니다 . 이는 Fortran 및 C 연속성의 개념이 1 차원 케이스에서 겹치기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="b1c5400df70c93e783da6a5dac7fee87f2f1e727" translate="yes" xml:space="preserve">
          <source>There is no standard way in Python distutils to create a standard shared library (an extension module is a &amp;ldquo;special&amp;rdquo; shared library Python understands) in a cross-platform manner. Thus, a big disadvantage of ctypes at the time of writing this book is that it is difficult to distribute in a cross-platform manner a Python extension that uses ctypes and includes your own code which should be compiled as a shared library on the users system.</source>
          <target state="translated">파이썬 distutils에서 표준 공유 라이브러리 (확장 모듈은 파이썬이 이해하는 &quot;특별한&quot;공유 라이브러리입니다)를 크로스 플랫폼 방식으로 만드는 표준 방법이 없습니다. 따라서이 책을 쓰는 시점에서 ctypes의 큰 단점은 ctypes를 사용하고 사용자 시스템에서 공유 라이브러리로 컴파일해야하는 자체 코드를 포함하는 Python 확장을 크로스 플랫폼 방식으로 배포하기가 어렵다는 것입니다. .</target>
        </trans-unit>
        <trans-unit id="54b0268bf735345a9f64350e8e77b1a81c8688d9" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt;&lt;code&gt;intp&lt;/code&gt;&lt;/a&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">하나의 인덱싱 배열이 있으며 할당 배열과 마찬가지로 간단하게 반복 할 수 있습니다. 예를 들어 연속적 일 수 있습니다. 또한 인덱싱 배열은 &lt;a href=&quot;arrays.scalars#numpy.intp&quot;&gt; &lt;code&gt;intp&lt;/code&gt; &lt;/a&gt; 유형이어야하며 할당의 값 배열은 올바른 유형이어야합니다. 이것은 순전히 빠른 길입니다.</target>
        </trans-unit>
        <trans-unit id="23297908101e96f4ab7052c44ca172ce18526477" translate="yes" xml:space="preserve">
          <source>There is one indexing array and it, as well as the assignment array, can be iterated trivially. For example they may be contiguous. Also the indexing array must be of &lt;code&gt;intp&lt;/code&gt; type and the value array in assignments should be of the correct type. This is purely a fast path.</source>
          <target state="translated">하나의 인덱싱 배열이 있으며 할당 배열과 마찬가지로 배열을 간단하게 반복 할 수 있습니다. 예를 들어 연속적 일 수 있습니다. 또한 인덱싱 배열은 &lt;code&gt;intp&lt;/code&gt; 형식이어야하고 할당의 값 배열은 올바른 형식이어야합니다. 이것은 순전히 빠른 길입니다.</target>
        </trans-unit>
        <trans-unit id="d8fac7ab155f3d88da854276783ffad458c19c82" translate="yes" xml:space="preserve">
          <source>There is one notable exception to this behavior: if the optional argument &lt;code&gt;names=True&lt;/code&gt;, the first commented line will be examined for names.</source>
          <target state="translated">이 동작에는 한 가지 주목할만한 예외가 있습니다. 선택적 인수 &lt;code&gt;names=True&lt;/code&gt; 이면 주석 처리 된 첫 번째 줄에서 이름을 검사합니다.</target>
        </trans-unit>
        <trans-unit id="df9a641fbd94988d395fb4542afcc38f2bd13355" translate="yes" xml:space="preserve">
          <source>There must be at least 1 argument, and define the last argument as &lt;em&gt;item&lt;/em&gt;. Then, &lt;code&gt;a.itemset(*args)&lt;/code&gt; is equivalent to but faster than &lt;code&gt;a[args] = item&lt;/code&gt;. The item should be a scalar value and &lt;code&gt;args&lt;/code&gt; must select a single item in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">최소한 하나의 인수가 있어야하며 마지막 인수를 &lt;em&gt;item&lt;/em&gt; 으로 정의하십시오 . 그러면 &lt;code&gt;a.itemset(*args)&lt;/code&gt; 는 &lt;code&gt;a[args] = item&lt;/code&gt; 과 동일하지만 빠릅니다 . 항목은 스칼라 값 이어야 하고 &lt;code&gt;args&lt;/code&gt; 는 배열 &lt;code&gt;a&lt;/code&gt; 에서 단일 항목을 선택해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d9bdbeac0f4a4a2c09a4382d5b665ee480b88e7d" translate="yes" xml:space="preserve">
          <source>There was no &lt;code&gt;__array_interface__&lt;/code&gt; attribute instead all of the keys (except for version) in the &lt;code&gt;__array_interface__&lt;/code&gt; dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">&lt;code&gt;__array_interface__&lt;/code&gt; 사전 에있는 모든 키 (버전 제외) 대신 &lt;code&gt;__array_interface__&lt;/code&gt; 속성 이 없었 습니다 . 따라서 Python 측 정보를 얻으려면 속성에 별도로 액세스해야했습니다.</target>
        </trans-unit>
        <trans-unit id="bc33808ec0ca031cf8b9c1fdd7c9278c78f0db38" translate="yes" xml:space="preserve">
          <source>There was no __array_interface__ attribute instead all of the keys (except for version) in the __array_interface__ dictionary were their own attribute: Thus to obtain the Python-side information you had to access separately the attributes:</source>
          <target state="translated">__array_interface__ 사전에 __array_interface__ 속성이 없었습니다. __array_interface__ 사전의 모든 키 (버전 제외)는 자체 속성이었습니다. 따라서 파이썬 측 정보를 얻으려면 별도로 속성에 액세스해야했습니다.</target>
        </trans-unit>
        <trans-unit id="1d3ca63c0d0c4fb92d45d132b89354f4e2a0e2fc" translate="yes" xml:space="preserve">
          <source>There will not be anything &lt;em&gt;wrong&lt;/em&gt; with the results, per se; even a seed of 0 is perfectly fine thanks to the processing that &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; does. If you just need &lt;em&gt;some&lt;/em&gt; fixed value for unit tests or debugging, feel free to use whatever seed you like. But if you want to make inferences from the results or publish them, drawing from a larger set of seeds is good practice.</source>
          <target state="translated">결과 자체에는 아무런 &lt;em&gt;문제&lt;/em&gt; 가 없습니다 . &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 의 처리 덕분에 0의 시드조차도 완벽하게 괜찮습니다 . 그냥 필요한 경우 &lt;em&gt;일부&lt;/em&gt; 단위 테스트 나 디버깅에 대한 고정 값을, 같은 어떤 씨앗 당신을 사용하여 주시기 바랍니다. 그러나 결과에서 추론을하거나 결과를 게시하려면 더 큰 종자 세트를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="1a33a5d0a80b8b553aad5ef6b8b9d3cf3a744293" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps the you made several false starts you would like the posterity not to see.</source>
          <target state="translated">커밋에 부끄러운 오타가 있습니까? 또는 몇 번의 잘못된 출발을 한 후 후손이 보지 않기를 원할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7586899d52e7cb2e4afcaa41a1d9614a067b4661" translate="yes" xml:space="preserve">
          <source>There&amp;rsquo;s an embarrassing typo in a commit you made? Or perhaps you made several false starts you would like the posterity not to see.</source>
          <target state="translated">커밋에 부끄러운 오타가 있습니까? 아니면 후손이 보지 않기를 바라는 몇 번의 잘못된 출발을했을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="de5a5e9111615649ff06d77b214a9aa4744c2e9e" translate="yes" xml:space="preserve">
          <source>These Boolean-valued flags affect how numpy interprets the memory area used by &lt;code&gt;a&lt;/code&gt; (see Notes below). The ALIGNED flag can only be set to True if the data is actually aligned according to the type. The WRITEBACKIFCOPY and (deprecated) UPDATEIFCOPY flags can never be set to True. The flag WRITEABLE can only be set to True if the array owns its own memory, or the ultimate owner of the memory exposes a writeable buffer interface, or is a string. (The exception for string is made so that unpickling can be done without copying memory.)</source>
          <target state="translated">이 부울 값 플래그는 numpy가 &lt;code&gt;a&lt;/code&gt; 에서 사용하는 메모리 영역을 해석하는 방법에 영향을줍니다 (아래 참고 참조). 데이터가 실제로 유형에 따라 정렬 된 경우에만 ALIGNED 플래그를 True로 설정할 수 있습니다. WRITEBACKIFCOPY 및 (더 이상 사용되지 않는) UPDATEIFCOPY 플래그는 True로 설정할 수 없습니다. WRITEABLE 플래그는 배열에 자체 메모리가 있거나 메모리의 최종 소유자가 쓰기 가능한 버퍼 인터페이스를 표시하거나 문자열 인 경우에만 True로 설정할 수 있습니다. (문자열에 대한 예외는 메모리 복사없이 산 세척을 수행 할 수 있도록 만들어졌습니다.)</target>
        </trans-unit>
        <trans-unit id="a6788920c31464c6803c23f30203598688f71c50" translate="yes" xml:space="preserve">
          <source>These additional dependencies for building the documentation are listed in &lt;code&gt;doc_requirements.txt&lt;/code&gt; and can be conveniently installed with:</source>
          <target state="translated">문서 작성을위한 이러한 추가 종속성은 &lt;code&gt;doc_requirements.txt&lt;/code&gt; 에 나열되며 다음을 사용 하여 편리하게 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7faf38a4c03dd7b8b5f6a940a17e52f4253526ca" translate="yes" xml:space="preserve">
          <source>These all achieve the same result:</source>
          <target state="translated">이것들은 모두 같은 결과를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ca33633bc8f8738d475e05fabdb7eda73e305c81" translate="yes" xml:space="preserve">
          <source>These are defined for &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128, and 256 and provide the maximum (minimum) value of the corresponding (unsigned) integer type. Note: the actual integer type may not be available on all platforms (i.e. 128-bit and 256-bit integers are rare).</source>
          <target state="translated">이들은 &lt;code&gt;{bits}&lt;/code&gt; = 8, 16, 32, 64, 128 및 256에 대해 정의되며 해당 (부호없는) 정수 유형의 최대 (최소) 값을 제공합니다. 참고 : 모든 플랫폼에서 실제 정수 유형을 사용할 수있는 것은 아닙니다 (예 : 128 비트 및 256 비트 정수는 드 rare니다).</target>
        </trans-unit>
        <trans-unit id="e68165dfdce046a2deae960fcc7bcd8c7c8919ea" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt; type or &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bytes&quot;&gt;&lt;code&gt;bytes&lt;/code&gt;&lt;/a&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이들은 &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt; 유형 또는 &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt; 유형 의 향상된 배열입니다 . 이러한 배열은 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 에서 상속 되지만 (브로드 캐스팅) 요소별로 연산 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 를 특별히 정의합니다 . 이러한 작업은 문자 유형 의 표준 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 없습니다 . 또한 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 에는 모든 표준 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#bytes&quot;&gt; &lt;code&gt;bytes&lt;/code&gt; &lt;/a&gt; ) 메서드가 있으며 요소별로 실행됩니다. chararray를 만드는 가장 쉬운 방법은 &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt; 를 사용 하는 &lt;em&gt;것입니다.&lt;/em&gt;str 또는 unicode 데이터 유형의 ndarray입니다. 그러나 chararray는 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt; 생성자 또는 &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ddb00a13475a7300c7d1510545ce91de444184f" translate="yes" xml:space="preserve">
          <source>These are enhanced arrays of either &lt;code&gt;string_&lt;/code&gt; type or &lt;code&gt;unicode_&lt;/code&gt; type. These arrays inherit from the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, but specially-define the operations &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, and &lt;code&gt;%&lt;/code&gt; on a (broadcasting) element-by-element basis. These operations are not available on the standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; of character type. In addition, the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; has all of the standard &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; (and &lt;code&gt;unicode&lt;/code&gt;) methods, executing them on an element-by-element basis. Perhaps the easiest way to create a chararray is to use &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;self.view(chararray)&lt;/code&gt;&lt;/a&gt; where &lt;em&gt;self&lt;/em&gt; is an ndarray of str or unicode data-type. However, a chararray can also be created using the &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;numpy.chararray&lt;/code&gt;&lt;/a&gt; constructor, or via the &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt;&lt;code&gt;numpy.char.array&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">이들은 &lt;code&gt;string_&lt;/code&gt; type 또는 &lt;code&gt;unicode_&lt;/code&gt; type 의 확장 배열입니다 . 이 배열은 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 로부터 상속 받지만 (브로드 캐스팅) 요소별로 &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;%&lt;/code&gt; 작업을 특별히 정의합니다 . 이러한 조작은 문자 유형 의 표준 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 에서 사용할 수 없습니다 . 또한 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 에는 모든 표준 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; (및 &lt;code&gt;unicode&lt;/code&gt; ) 메소드가 있으며 요소별로 실행됩니다. 아마도 chararray를 만드는 가장 쉬운 방법은 &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;self.view(chararray)&lt;/code&gt; &lt;/a&gt; 를 사용 하는 &lt;em&gt;것입니다.&lt;/em&gt;str 또는 유니 코드 데이터 유형의 ndarray입니다. 그러나 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;numpy.chararray&lt;/code&gt; &lt;/a&gt; 생성자를 사용하거나 &lt;a href=&quot;generated/numpy.core.defchararray.array#numpy.core.defchararray.array&quot;&gt; &lt;code&gt;numpy.char.array&lt;/code&gt; &lt;/a&gt; 함수 를 통해 chararray를 만들 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5c5d09f4ce60946e76740852fd56ca7c8c49e5bd" translate="yes" xml:space="preserve">
          <source>These are roughly ordered from least-to-most precision.</source>
          <target state="translated">이것들은 대략 가장 작은 것부터 가장 작은 것까지 순서가 정해져 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ce5765c6141294e2d5121321badaf2a8b57c10d" translate="yes" xml:space="preserve">
          <source>These are some detailed notes, which are not of importance for day to day indexing (in no particular order):</source>
          <target state="translated">다음은 세부적인 참고 사항으로, 일일 인덱싱에는 중요하지 않습니다 (특별한 순서는 아님).</target>
        </trans-unit>
        <trans-unit id="3f20305498e715f2e7a95c2c0aa48306a2b1d79a" translate="yes" xml:space="preserve">
          <source>These are the arrays for the operation.</source>
          <target state="translated">이들은 조작을위한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7a1ac004102d237171aefc6abd621531cd490cc4" translate="yes" xml:space="preserve">
          <source>These are the constants and functions for accessing the ufunc C-API from extension modules in precisely the same way as the array C-API can be accessed. The &lt;code&gt;import_ufunc&lt;/code&gt; () function must always be called (in the initialization subroutine of the extension module). If your extension module is in one file then that is all that is required. The other two constants are useful if your extension module makes use of multiple files. In that case, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to something unique to your code and then in source files that do not contain the module initialization function but still need access to the UFUNC API, define &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to the same name used previously and also define &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt;&lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이들은 배열 C-API에 액세스 할 수있는 것과 정확히 같은 방식으로 확장 모듈에서 ufunc C-API에 액세스하기위한 상수 및 함수입니다. &lt;code&gt;import_ufunc&lt;/code&gt; () 함수는 항상 (확장 모듈의 초기화 서브 루틴) 호출해야합니다. 확장 모듈이 하나의 파일에 있으면 필요한 것입니다. 다른 두 상수는 확장 모듈이 여러 파일을 사용하는 경우 유용합니다. 이 경우 &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 코드에 고유 한 것으로 정의한 다음 모듈 초기화 기능을 포함하지 않지만 여전히 UFUNC API에 액세스해야하는 소스 파일에서 &lt;a href=&quot;#c.PY_UFUNC_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_UFUNC_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 이전에 사용한 것과 동일한 이름으로 정의하고 NO_IMPORT_UFUNC 를 정의 &lt;a href=&quot;#c.NO_IMPORT_UFUNC&quot;&gt; &lt;code&gt;NO_IMPORT_UFUNC&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0aaea1e5f2c4b6d0e0dc28a8aa40e102fa58beb" translate="yes" xml:space="preserve">
          <source>These are the indices that would allow you to access the upper triangular part of any 3x3 array:</source>
          <target state="translated">다음은 3x3 배열의 상단 삼각형 부분에 액세스 할 수있는 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="38bc2b8e25d17f4fb4231aea381549f2e431c561" translate="yes" xml:space="preserve">
          <source>These are the instructions if you just want to follow the latest &lt;em&gt;NumPy&lt;/em&gt; source, but you don&amp;rsquo;t need to do any development for now. If you do want to contribute a patch (excellent!) or do more extensive NumPy development, see &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="translated">이것은 최신 &lt;em&gt;NumPy&lt;/em&gt; 소스 를 따르고 싶지만 지금은 개발할 필요가없는 경우의 지침 입니다. 패치를 제공하거나 (탁월합니다!) 더 광범위한 NumPy 개발을 수행하려면 &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;개발 워크 플로를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="43efdc6f451764645e6025c80a5a83f304f68569" translate="yes" xml:space="preserve">
          <source>These are typically used in situations where in C/C++, you would allocate a(n) array(s) on the heap, and call the function to fill the array(s) values. In Python, the arrays are allocated for you and returned as new array objects.</source>
          <target state="translated">이들은 일반적으로 C / C ++에서 힙에 a (n) 배열을 할당하고 함수를 호출하여 배열 값을 채우는 상황에서 사용됩니다. 파이썬에서는 배열이 할당되어 새로운 배열 객체로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f04a7bcc6ce293328ac2b1079d0f95ad7b19da67" translate="yes" xml:space="preserve">
          <source>These are written in doctest format, and should illustrate how to use the function.</source>
          <target state="translated">이들은 doctest 형식으로 작성되었으며 함수 사용 방법을 설명해야합니다.</target>
        </trans-unit>
        <trans-unit id="a93c5dc49de55891886f179425b788a1c6ad1b35" translate="yes" xml:space="preserve">
          <source>These arrays are views on the original arrays. They are typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location. If you need to write to the arrays, make copies first. While you can set the &lt;code&gt;writable&lt;/code&gt; flag True, writing to a single output value may end up changing more than one location in the output array.</source>
          <target state="translated">이 배열은 원래 배열의보기입니다. 그것들은 일반적으로 인접하지 않습니다. 또한, 방송 된 어레이의 하나 이상의 요소는 단일 메모리 위치를 지칭 할 수있다. 배열에 쓰려면 먼저 복사하십시오. &lt;code&gt;writable&lt;/code&gt; 플래그를 True로 설정할 수 있지만 단일 출력 값에 쓰면 출력 배열에서 둘 이상의 위치가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95e5069d3636251c2ff01dcc947b04bbf8ba1923" translate="yes" xml:space="preserve">
          <source>These behaviors can be set for all kinds of errors or specific ones:</source>
          <target state="translated">이러한 동작은 모든 종류의 오류 또는 특정 오류에 대해 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f0acac4ec85b4b4bd7ae1e0ff5a3f9603fcfbc3" translate="yes" xml:space="preserve">
          <source>These constants are used in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; (and its macro forms) to specify desired properties of the new array.</source>
          <target state="translated">이 상수는 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; (및 해당 매크로 형식)에서 새 배열의 원하는 속성을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3d245bb5214c903868626d468b5ef8607e3f9a4a" translate="yes" xml:space="preserve">
          <source>These cover almost the whole array (two diagonals right of the main one):</source>
          <target state="translated">여기에는 거의 전체 배열이 포함됩니다 (주 배열의 오른쪽 두 대각선).</target>
        </trans-unit>
        <trans-unit id="f7e900132de2199b00f5d74615e0a1848ce14490" translate="yes" xml:space="preserve">
          <source>These cover only a small part of the whole array (two diagonals right of the main one):</source>
          <target state="translated">이것들은 전체 배열의 작은 부분 (주된 것의 오른쪽에 두 개의 대각선) 만 포함합니다.</target>
        </trans-unit>
        <trans-unit id="1adc6f5a53325e3aa2e7cccdff9469027b73b4ce" translate="yes" xml:space="preserve">
          <source>These documents are intended as an introductory overview of NumPy and its features. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">이 문서는 NumPy 및 그 기능에 대한 소개 개요를 제공하기위한 것입니다. 패키지에 포함 된 함수 및 클래스에 대한 자세한 참조 문서는 &lt;a href=&quot;../reference/index#reference&quot;&gt;API 참조를 참조&lt;/a&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="ca02dca00e56b01dd5323ec3c2c51c9bba04e9a2" translate="yes" xml:space="preserve">
          <source>These documents are intended as recipes to common tasks using NumPy. For detailed reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">이 문서는 NumPy를 사용하는 일반적인 작업에 대한 레시피로 작성되었습니다. 패키지에 포함 된 함수 및 클래스에 대한 자세한 참조 문서는 &lt;a href=&quot;../reference/index#reference&quot;&gt;API 참조를 참조&lt;/a&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="ad1b854bfa000aee75512c8df139be2e2841e0fd" translate="yes" xml:space="preserve">
          <source>These documents are intended to explain in detail the concepts and techniques used in NumPy. For the reference documentation of the functions and classes contained in the package, see the &lt;a href=&quot;../reference/index#reference&quot;&gt;API reference&lt;/a&gt;.</source>
          <target state="translated">이 문서는 NumPy에서 사용되는 개념과 기술을 자세히 설명하기위한 것입니다. 패키지에 포함 된 함수 및 클래스에 대한 참조 문서는 &lt;a href=&quot;../reference/index#reference&quot;&gt;API 참조를 참조&lt;/a&gt; 하세요.</target>
        </trans-unit>
        <trans-unit id="63868acfbf699fe963e728a55308e7d3a9b22eb9" translate="yes" xml:space="preserve">
          <source>These examples illustrate the low-level &lt;a href=&quot;#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; constructor. Refer to the &lt;code&gt;See Also&lt;/code&gt; section above for easier ways of constructing an ndarray.</source>
          <target state="translated">이 예제는 저수준 &lt;a href=&quot;#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 생성자를 보여줍니다. ndarray를 구성하는보다 쉬운 방법은 위 의 &lt;code&gt;See Also&lt;/code&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8a348b17d2fb1b33a90b7baa8a557d9af808a018" translate="yes" xml:space="preserve">
          <source>These function all require integer arguments and they manipulate the bit-pattern of those arguments.</source>
          <target state="translated">이 함수는 모두 정수 인수를 필요로하며 해당 인수의 비트 패턴을 조작합니다.</target>
        </trans-unit>
        <trans-unit id="d7e647d09c10f9f4521e851e5661f2624622c65e" translate="yes" xml:space="preserve">
          <source>These functions along with a minimal setup file are included in the examples folder.</source>
          <target state="translated">최소 설정 파일과 함께이 기능은 예제 폴더에 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="47c8ad5dd0ea816b255a3666826ae66a37ff3a15" translate="yes" xml:space="preserve">
          <source>These functions and macros provide easy access to elements of the ndarray from C. These work for all arrays. You may need to take care when accessing the data in the array, however, if it is not in machine byte-order, misaligned, or not writeable. In other words, be sure to respect the state of the flags unless you know what you are doing, or have previously guaranteed an array that is writeable, aligned, and in machine byte-order using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. If you wish to handle all types of arrays, the copyswap function for each type is useful for handling misbehaved arrays. Some platforms (e.g. Solaris) do not like misaligned data and will crash if you de-reference a misaligned pointer. Other platforms (e.g. x86 Linux) will just work more slowly with misaligned data.</source>
          <target state="translated">이 함수와 매크로를 사용하면 C에서 ndarray 요소에 쉽게 액세스 할 수 있습니다. 이러한 기능 및 매크로는 모든 어레이에서 작동합니다. 그러나 머신의 바이트 순서가 아니거나 정렬이 잘못되었거나 쓰기가 불가능한 경우 어레이의 데이터에 액세스 할 때주의해야합니다. 즉, 수행중인 작업을 알지 못하거나 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 를&lt;/a&gt; 사용하여 쓰기 가능, 정렬 및 기계 바이트 순서로 배열을 보장하지 않는 한 플래그의 상태를 존중해야합니다 . 모든 유형의 배열을 처리하려는 경우 각 유형의 copyswap 기능은 잘못 작동하는 배열을 처리하는 데 유용합니다. 일부 플랫폼 (예 : Solaris)은 잘못 정렬 된 데이터를 좋아하지 않으며 잘못 정렬 된 포인터를 역 참조하면 충돌합니다. 다른 플랫폼 (예 : x86 Linux)은 잘못 정렬 된 데이터에서 더 느리게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a0b164307df93568d43c0a9ad269b4dbe393e0e6" translate="yes" xml:space="preserve">
          <source>These functions are included here because they are used at least once in the array object&amp;rsquo;s methods. The function returns -1 (without setting a Python Error) if one of the objects being assigned is not callable.</source>
          <target state="translated">이 함수는 배열 객체의 메소드에서 적어도 한 번 사용되기 때문에 여기에 포함됩니다. 할당 된 객체 중 하나를 호출 할 수없는 경우 함수는 -1 (Python Error 설정하지 않고)을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8de7e7b6b1e1ede303832d725868059c022d2d0a" translate="yes" xml:space="preserve">
          <source>These functions are very similar to functions without keyword arguments. The only difference is that the function signature is:</source>
          <target state="translated">이러한 함수는 키워드 인수가없는 함수와 매우 유사합니다. 유일한 차이점은 함수 서명이 다음과 같다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="474e0e7c22745c37837977d2aed3d481ae32dc24" translate="yes" xml:space="preserve">
          <source>These identities allow a Chebyshev series to be expressed as a finite, symmetric Laurent series. In this module, this sort of Laurent series is referred to as a &amp;ldquo;z-series.&amp;rdquo;</source>
          <target state="translated">이러한 동일성을 통해 Chebyshev 시리즈를 유한 대칭 Laurent 시리즈로 표현할 수 있습니다. 이 모듈에서는 이러한 종류의 Laurent 시리즈를 &quot;z 시리즈&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="21ed26c6390b302396f6eeab85800f1a745f670f" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">이러한 매크로는 액세스 &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 의&lt;/a&gt; 구조 구성원과에 정의되어 &lt;code&gt;ndarraytypes.h&lt;/code&gt; . 입력 인수 &lt;em&gt;도착&lt;/em&gt; , 임의의 것일 수 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; A와 직접 해석 가능하다 &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; (의 인스턴스 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 과 서브 타입).</target>
        </trans-unit>
        <trans-unit id="a58240a1702d16b3630637ee0890f803946e53fd" translate="yes" xml:space="preserve">
          <source>These macros access the &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members and are defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt;. The input argument, &lt;em&gt;arr&lt;/em&gt;, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and itssub-types).</source>
          <target state="translated">이러한 매크로는 액세스 &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 의&lt;/a&gt; 구조 구성원과에 정의되어 &lt;code&gt;ndarraytypes.h&lt;/code&gt; . 입력 인수 &lt;em&gt;arr&lt;/em&gt; 은 &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 및 해당 하위 유형 의 모든 인스턴스) 로 직접 해석 할 수있는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13b269cced89ab6392bc06c8030f96e4b737c057" translate="yes" xml:space="preserve">
          <source>These macros all access the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; structure members. The input argument, arr, can be any &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that is directly interpretable as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; (any instance of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and its sub-types).</source>
          <target state="translated">이 매크로는 모두 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 구조 멤버에 액세스합니다 . 입력 인수 arr 은 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 및 해당 하위 유형 의 모든 인스턴스) 로 직접 해석 가능한 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11ea008c03805b7a8b457a794a3fc2be74133b50" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined to the python-defined &lt;a href=&quot;#c.WITH_THREADS&quot;&gt;&lt;code&gt;WITH_THREADS&lt;/code&gt;&lt;/a&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined to be 0.</source>
          <target state="translated">이러한 매크로는 확장 모듈을 컴파일하는 동안 &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 가 True로 평가되는 경우에만 의미가 있습니다. 그렇지 않으면 이러한 매크로는 공백과 동일합니다. Python은 각 Python 프로세스에 대해 단일 GIL (Global Interpreter Lock)을 사용하므로 한 번에 단일 스레드 만 실행할 수 있습니다 (다중 CPU 시스템에서도). 계산하는 데 시간이 걸릴 수있는 컴파일 된 함수를 호출 할 때 (업데이트 된 전역 변수와 같은 다른 스레드에 대한 부작용이 없음) 시간이 많이 걸리는 계산이 수행되는 동안 다른 Python 스레드가 실행될 수 있도록 GIL을 해제해야합니다. . 이는 두 그룹의 매크로를 사용하여 수행 할 수 있습니다. 일반적으로 그룹의 하나의 매크로가 코드 블록에서 사용되는 경우 모두 동일한 코드 블록에서 사용되어야합니다. 현재 &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt;환경 변수 &lt;code&gt;NPY_NOSMP&lt;/code&gt; 가 설정되어 있지 않으면 &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 가 0으로 정의 되지 않는 한 파이썬 정의 &lt;a href=&quot;#c.WITH_THREADS&quot;&gt; &lt;code&gt;WITH_THREADS&lt;/code&gt; &lt;/a&gt; 상수 로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0b21dcbffd2b61b3d3ee30959d3bc33fc08a9c74" translate="yes" xml:space="preserve">
          <source>These macros are only meaningful if &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; evaluates True during compilation of the extension module. Otherwise, these macros are equivalent to whitespace. Python uses a single Global Interpreter Lock (GIL) for each Python process so that only a single thread may execute at a time (even on multi-cpu machines). When calling out to a compiled function that may take time to compute (and does not have side-effects for other threads like updated global variables), the GIL should be released so that other Python threads can run while the time-consuming calculations are performed. This can be accomplished using two groups of macros. Typically, if one macro in a group is used in a code block, all of them must be used in the same code block. Currently, &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to the python-defined &lt;code&gt;WITH_THREADS&lt;/code&gt; constant unless the environment variable &lt;code&gt;NPY_NOSMP&lt;/code&gt; is set in which case &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined to be 0.</source>
          <target state="translated">이러한 매크로는 확장 모듈을 컴파일하는 동안 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 가 True로 평가되는 경우에만 의미가 있습니다. 그렇지 않으면이 매크로는 공백과 같습니다. Python은 각 Python 프로세스마다 단일 GIL (Global Interpreter Lock)을 사용하므로 한 번에 하나의 스레드 만 실행할 수 있습니다 (멀티 CPU 시스템에서도). 계산하는 데 시간이 걸리고 업데이트 된 전역 변수와 같은 다른 스레드에 대한 부작용이없는 컴파일 된 함수를 호출 할 때 시간이 많이 걸리는 계산이 수행되는 동안 다른 Python 스레드가 실행될 수 있도록 GIL을 해제해야합니다. . 이는 두 그룹의 매크로를 사용하여 수행 할 수 있습니다. 일반적으로 그룹의 매크로 하나가 코드 블록에 사용되는 경우 모두 동일한 코드 블록에 사용해야합니다. 현재 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 환경 변수 &lt;code&gt;NPY_NOSMP&lt;/code&gt; 가 설정되어 있지 않으면 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 가 0으로 정의 되지 않는 한 파이썬 정의 &lt;code&gt;WITH_THREADS&lt;/code&gt; 상수 에 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="729c9787f60d8418994cdb90a7bff93ed76bf569" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt;. The system malloc is used when &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt; is 0, if &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt;&lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;&lt;/a&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">이러한 매크로는 상수 &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt; 에 따라 다른 메모리 할당자를 사용 합니다. 시스템 malloc은 &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt; 이 0 일 때 사용되며 , &lt;a href=&quot;#c.NPY_USE_PYMEM&quot;&gt; &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; &lt;/a&gt; 이 1이면 Python 메모리 할당자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="da2fff533a172874c502697494e5cdbf3a7c39b3" translate="yes" xml:space="preserve">
          <source>These macros use different memory allocators, depending on the constant &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt;. The system malloc is used when &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 0, if &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; is 1, then the Python memory allocator is used.</source>
          <target state="translated">이 매크로는 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 상수에 따라 다른 메모리 할당자를 사용 합니다. 시스템 malloc은 &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 이 0 일 때 사용되며 , &lt;code&gt;NPY_USE_PYMEM&lt;/code&gt; 이 1이면 Python 메모리 할당자가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="512de4565bde2a4a800d6eb7f4ecd21ece637307" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">이 멤버는 모두 &lt;em&gt;src&lt;/em&gt; 에서 &lt;em&gt;dest로&lt;/em&gt; 데이터를 복사 하고 표시된 경우 &lt;em&gt;스왑&lt;/em&gt; 하는 함수에 대한 포인터 입니다. arr의 값은 유연한 ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ) 배열 에만 사용 되며 &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 에서 얻습니다 . 두 번째 함수는 단일 값을 복사하는 반면 첫 번째 함수는 제공된 보폭으로 n 값을 반복합니다. 이 함수는 잘못 동작 한 &lt;em&gt;src&lt;/em&gt; 데이터를 처리 할 수 ​​있습니다 . 경우 &lt;em&gt;SRC는&lt;/em&gt; NULL입니다 다음, 복사는 수행되지 않습니다. 경우 &lt;em&gt;스왑은&lt;/em&gt; 0, 다음 더 byteswapping는 발생하지 않는다. &lt;em&gt;dest&lt;/em&gt; 와 &lt;em&gt;src로&lt;/em&gt; 가정합니다&lt;em&gt;&lt;/em&gt;겹치지 마십시오. 중복되는 경우 &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;)를 먼저 사용하고 그 뒤에 NULL 값이 &lt;code&gt;src&lt;/code&gt; 인 &lt;code&gt;copyswap(n)&lt;/code&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a72dfa72e903b9f6c19523d338aa7b21c3b5f83" translate="yes" xml:space="preserve">
          <source>These members are both pointers to functions to copy data from &lt;em&gt;src&lt;/em&gt; to &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;swap&lt;/em&gt; if indicated. The value of arr is only used for flexible ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ) arrays (and is obtained from &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; ). The second function copies a single value, while the first loops over n values with the provided strides. These functions can deal with misbehaved &lt;em&gt;src&lt;/em&gt; data. If &lt;em&gt;src&lt;/em&gt; is NULL then no copy is performed. If &lt;em&gt;swap&lt;/em&gt; is 0, then no byteswapping occurs. It is assumed that &lt;em&gt;dest&lt;/em&gt; and &lt;em&gt;src&lt;/em&gt; do not overlap. If they overlap, then use &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) first followed by &lt;code&gt;copyswap(n)&lt;/code&gt; with NULL valued &lt;code&gt;src&lt;/code&gt;.</source>
          <target state="translated">이 멤버는 모두 &lt;em&gt;src&lt;/em&gt; 에서 &lt;em&gt;dest로&lt;/em&gt; 데이터를 복사 하고 표시된 경우 &lt;em&gt;스왑&lt;/em&gt; 하는 함수에 대한 포인터 입니다. arr 값은 유연한 ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ) 배열 에만 사용됩니다 (그리고 &lt;code&gt;arr-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 에서 가져옴 ). 두 번째 함수는 단일 값을 복사하는 반면 첫 번째 함수는 제공된 스트라이드를 사용하여 n 개의 값을 반복합니다. 이러한 함수는 잘못 작동하는 &lt;em&gt;src&lt;/em&gt; 데이터를 처리 할 수 ​​있습니다 . 경우 &lt;em&gt;SRC는&lt;/em&gt; NULL입니다 다음, 복사는 수행되지 않습니다. 경우 &lt;em&gt;스왑은&lt;/em&gt; 0, 다음 더 byteswapping는 발생하지 않는다. 그것은 가정이 &lt;em&gt;이명 령&lt;/em&gt; 및 &lt;em&gt;SRC&lt;/em&gt;겹치지 마십시오. 겹치는 경우 먼저 &lt;code&gt;memmove&lt;/code&gt; (&amp;hellip;) 를 사용 하고 NULL 값 &lt;code&gt;src&lt;/code&gt; 와 함께 &lt;code&gt;copyswap(n)&lt;/code&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="d6721252244f80ca68ee960086197a2ea6f31616" translate="yes" xml:space="preserve">
          <source>These numbers in the previous line represent (0, 0) to machine precision</source>
          <target state="translated">이전 줄의이 숫자는 (0, 0)을 기계 정밀도로 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dc06d74801540c694b86fd1603123c1d29a31d44" translate="yes" xml:space="preserve">
          <source>These options determine the way floating point numbers, arrays and other NumPy objects are displayed.</source>
          <target state="translated">이 옵션은 부동 소수점 숫자, 배열 및 기타 NumPy 객체가 표시되는 방식을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="c7caafe15667a4da0d6093971259ebc7a46a9f78" translate="yes" xml:space="preserve">
          <source>These pages describe a general &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; and &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; workflow.</source>
          <target state="translated">이 페이지는 일반적인 &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; 및 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 워크 플로를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="df150acba8d3f0417e81ddcccc29e42e2e807db8" translate="yes" xml:space="preserve">
          <source>These paths both use the same machinery. We make the distinction here, because they result in different input to your methods. Specifically, &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; means you have created a new instance of your array type from any potential subclass of ndarray. &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt; means you have created a new instance of your class from a pre-existing instance, allowing you - for example - to copy across attributes that are particular to your subclass.</source>
          <target state="translated">이 경로는 모두 동일한 기계를 사용합니다. 우리는 여기에서 구별합니다. 왜냐하면 그들은 당신의 방법에 다른 입력을 가져 오기 때문입니다. 특히 &lt;a href=&quot;#view-casting&quot;&gt;뷰 캐스팅&lt;/a&gt; 은 ndarray의 잠재적 인 하위 클래스에서 배열 유형의 새 인스턴스를 생성했음을 의미합니다. &lt;a href=&quot;#new-from-template&quot;&gt;템플릿에서 새로 만들기&lt;/a&gt; 는 기존 인스턴스에서 클래스의 새 인스턴스를 만들었 음을 의미합니다. 예를 들어 하위 클래스에 특정한 속성간에 복사 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcba0fcabfaea90dcbb4dedc9f83dbe704fc9440" translate="yes" xml:space="preserve">
          <source>These pointers are different from the pointers accepted by &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;, because the direction along some axes may have been reversed.</source>
          <target state="translated">이 포인터는 &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; 가 허용하는 포인터와 다릅니다. 일부 축의 방향이 바뀌었을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2936192ef68f1082cb1baded7a4cc1332510cdca" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">이러한 속성을 함께 사용하면 일반적인 사용자 제공 시드를 간단한 증분 카운터와 함께 안전하게 혼합하여 (매우 높은 확률로) 서로 독립적 인 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 상태 를 얻을 수 있습니다. 우리는 이것을 사용하기 쉽고 오용하기 어려운 API로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="43a8a14f212cc60aa00fe9447268d1975d32ef40" translate="yes" xml:space="preserve">
          <source>These properties together mean that we can safely mix together the usual user-provided seed with simple incrementing counters to get &lt;code&gt;BitGenerator&lt;/code&gt; states that are (to very high probability) independent of each other. We can wrap this together into an API that is easy to use and difficult to misuse.</source>
          <target state="translated">이러한 속성을 함께 사용하면 일반적인 사용자 제공 시드를 간단한 증분 카운터와 안전하게 혼합하여 서로 매우 독립적 인 &lt;code&gt;BitGenerator&lt;/code&gt; 상태 를 얻을 수 있습니다. 우리는 이것을 사용하기 쉽고 잘못 사용하기 어려운 API로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6a12c973c6b3912e3652bb2e3ed402ca4234700" translate="yes" xml:space="preserve">
          <source>These tools have been found useful by others using Python and so are included here. They are discussed separately because they are either older ways to do things now handled by f2py, Cython, or ctypes (SWIG, PyFort) or because I don&amp;rsquo;t know much about them (SIP, Boost). I have not added links to these methods because my experience is that you can find the most relevant link faster using Google or some other search engine, and any links provided here would be quickly dated. Do not assume that just because it is included in this list, I don&amp;rsquo;t think the package deserves your attention. I&amp;rsquo;m including information about these packages because many people have found them useful and I&amp;rsquo;d like to give you as many options as possible for tackling the problem of easily integrating your code.</source>
          <target state="translated">이러한 도구는 Python을 사용하는 다른 사람들에게 유용하다는 것을 알게되었으며 여기에 포함되어 있습니다. 그것들은 이제 f2py, Cython 또는 ctypes (SWIG, PyFort)에 의해 처리되는 오래된 방법이기 때문에 또는 그들에 대해 많이 알지 못하기 때문에 (SIP, Boost) 별도로 논의됩니다. 내 경험에 따르면 Google 또는 다른 검색 엔진을 사용하여 가장 관련성이 높은 링크를 더 빨리 찾을 수 있고 여기에 제공된 모든 링크의 날짜가 빠르게 표시 될 수 있기 때문에 이러한 방법에 대한 링크를 추가하지 않았습니다. 이 목록에 포함되어 있다고해서 패키지에주의를 기울일 가치가 없다고 생각하지 마십시오. 많은 사람들이 유용하다고 생각했기 때문에 이러한 패키지에 대한 정보를 포함하고 있으며 코드를 쉽게 통합하는 문제를 해결하기 위해 가능한 한 많은 옵션을 제공하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="f0fbc806872e828602fd0c760ad7240ac769262d" translate="yes" xml:space="preserve">
          <source>These two macros are similar and obtain the pointer to the data-buffer for the array. The first macro can (and should be) assigned to a particular pointer where the second is for generic processing. If you have not guaranteed a contiguous and/or aligned array then be sure you understand how to access the data in the array to avoid memory and/or alignment problems.</source>
          <target state="translated">이 두 매크로는 비슷하며 배열의 데이터 버퍼에 대한 포인터를 얻습니다. 첫 번째 매크로는 두 번째가 일반 처리를위한 특정 포인터에 할당 될 수 있습니다. 연속 및 / 또는 정렬 된 어레이를 보장하지 않은 경우 메모리 및 / 또는 정렬 문제를 피하기 위해 어레이의 데이터에 액세스하는 방법을 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="e28f8dd7e1d385fa1bfc87cb75abfbb7c4a8ade7" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">이러한 유형 이름은 C-API의 일부이므로 확장 C 코드에서 만들 수 있습니다. 도있다 &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; 과 &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; 플랫폼에 대한 포인터를 저장할 수있는 정수 유형 중 하나에 대한 간단한 대체합니다. 이러한 스칼라 객체의 구조는 C 코드에 노출되지 않습니다. 함수 &lt;a href=&quot;array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt; (...)이 배열과 스칼라 함수에서 C 형 값을 추출하는 데 사용할 수 &lt;a href=&quot;array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; 을&lt;/a&gt; (...)은 C 값으로부터 스칼라 어레이를 구성 할 수있다.</target>
        </trans-unit>
        <trans-unit id="be4a900566749a67d476933d0258a41ade60543e" translate="yes" xml:space="preserve">
          <source>These type names are part of the C-API and can therefore be created in extension C-code. There is also a &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; and a &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; that are simple substitutes for one of the integer types that can hold a pointer on the platform. The structure of these scalar objects is not exposed to C-code. The function &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt;&lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt;&lt;/a&gt; (..) can be used to extract the C-type value from the array scalar and the function &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt;&lt;code&gt;PyArray_Scalar&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can be used to construct an array scalar from a C-value.</source>
          <target state="translated">이 형식 이름은 C-API의 일부이므로 확장 C 코드로 만들 수 있습니다. 도있다 &lt;code&gt;PyIntpArrType_Type&lt;/code&gt; 과 &lt;code&gt;PyUIntpArrType_Type&lt;/code&gt; 플랫폼에 대한 포인터를 저장할 수있는 정수 유형 중 하나에 대한 간단한 대체합니다. 이 스칼라 객체의 구조는 C 코드에 노출되지 않습니다. 함수 &lt;a href=&quot;c-api.array#c.PyArray_ScalarAsCtype&quot;&gt; &lt;code&gt;PyArray_ScalarAsCtype&lt;/code&gt; &lt;/a&gt; (...)이 배열과 스칼라 함수에서 C 형 값을 추출하는 데 사용할 수 &lt;a href=&quot;c-api.array#c.PyArray_Scalar&quot;&gt; &lt;code&gt;PyArray_Scalar&lt;/code&gt; 을&lt;/a&gt; (...)은 C 값으로부터 스칼라 어레이를 구성 할 수있다.</target>
        </trans-unit>
        <trans-unit id="39c33e43ad465d1114668c2913272d120aead183" translate="yes" xml:space="preserve">
          <source>These typemaps now check to make sure that the &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; arguments use native byte ordering. If not, an exception is raised.</source>
          <target state="translated">이러한 유형 맵은 이제 &lt;code&gt;INPLACE_ARRAY&lt;/code&gt; 인수가 기본 바이트 순서를 사용 하는지 확인합니다 . 그렇지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="afffd3e5751f118e6c4a8e5fa416a0de7397d2ff" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;a&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;a&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;b&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">이 값의 사본에 추가됩니다 . 이것은 정확한 형상 (동일 형상이어야 제외 &lt;code&gt;axis&lt;/code&gt; ). 경우 &lt;code&gt;axis&lt;/code&gt; 지정되지 않은, &lt;code&gt;b&lt;/code&gt; 어떤 모양이 될 수 있으며, 사용하기 전에 평평하게됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612fafedc61071a5e61db03c65c0f553ab91df63" translate="yes" xml:space="preserve">
          <source>These values are appended to a copy of &lt;code&gt;arr&lt;/code&gt;. It must be of the correct shape (the same shape as &lt;code&gt;arr&lt;/code&gt;, excluding &lt;code&gt;axis&lt;/code&gt;). If &lt;code&gt;axis&lt;/code&gt; is not specified, &lt;code&gt;values&lt;/code&gt; can be any shape and will be flattened before use.</source>
          <target state="translated">이 값은 &lt;code&gt;arr&lt;/code&gt; 사본에 추가됩니다 . 올바른 모양이어야합니다 ( &lt;code&gt;axis&lt;/code&gt; 제외하고 &lt;code&gt;arr&lt;/code&gt; 과 동일한 모양 ). 경우 &lt;code&gt;axis&lt;/code&gt; 지정되지 않은 &lt;code&gt;values&lt;/code&gt; 어떤 모양이 될 수 있으며, 사용하기 전에 평평하게됩니다.</target>
        </trans-unit>
        <trans-unit id="d11f3f9e08bc59771682cf52bbe126f37d2ff215" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = True</source>
          <target state="translated">이 값은 &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = True 인 경우에만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c265d10397c2203b05e143772f5cfb33ffa2cf8c" translate="yes" xml:space="preserve">
          <source>These values are only returned if &lt;code&gt;full&lt;/code&gt; = True</source>
          <target state="translated">이 값은 &lt;code&gt;full&lt;/code&gt; = True 인 경우에만 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="94c85fa0224cf9a04b1b6ccf08fcebfe46c06507" translate="yes" xml:space="preserve">
          <source>These values will be element-wise interpolated into the string.</source>
          <target state="translated">이 값은 요소별로 문자열에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="dd5e6abec4e1ccbc6948e611e796f2af804c4524" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of NumPy. Many NumPy functions return arrays, not matrices.</source>
          <target state="translated">NumPy의 표준 벡터 / 행렬 / 텐서 유형입니다. 많은 NumPy 함수는 행렬이 아닌 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8f43e0b4384b8a2ab0accbd750c1e3d8364a7037" translate="yes" xml:space="preserve">
          <source>They are the standard vector/matrix/tensor type of numpy. Many numpy functions return arrays, not matrices.</source>
          <target state="translated">numpy의 표준 벡터 / 행렬 / 텐서 유형입니다. 많은 numpy 함수는 행렬이 아닌 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="509dc829f5043c117345f356b056cfc2f0e4fe76" translate="yes" xml:space="preserve">
          <source>They support multidimensional array algebra that is supported in MATLAB</source>
          <target state="translated">MATLAB에서 지원되는 다차원 배열 대수를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="d528fd04772fea95a1dd88b443f26490baf33962" translate="yes" xml:space="preserve">
          <source>Things are a little bit more tricky when combining reduction and allocated operands. Before iteration is started, any reduction operand must be initialized to its starting values. Here&amp;rsquo;s how we can do this, taking sums along the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">축소 피연산자와 할당 피연산자를 결합 할 때 상황이 조금 더 까다로워집니다. 반복이 시작되기 전에 모든 축소 피연산자가 시작 값으로 초기화되어야합니다. 다음은 &lt;code&gt;a&lt;/code&gt; 의 마지막 축을 따라 합계를 취하는 방법 입니다.</target>
        </trans-unit>
        <trans-unit id="4d8c3ebfdc398f463f36600d7ef80c9d888a357d" translate="yes" xml:space="preserve">
          <source>Things become more complex when multidimensional arrays are indexed, particularly with multidimensional index arrays. These tend to be more unusual uses, but they are permitted, and they are useful for some problems. We&amp;rsquo;ll start with the simplest multidimensional case (using the array y from the previous examples):</source>
          <target state="translated">특히 다차원 인덱스 배열의 경우 다차원 배열이 인덱싱 될 때 상황이 더 복잡해집니다. 이들은 더 비정상적인 용도로 사용되는 경향이 있지만 허용되며 일부 문제에 유용합니다. 가장 간단한 다차원 사례부터 시작하겠습니다 (이전 예제의 y 배열 사용).</target>
        </trans-unit>
        <trans-unit id="998943208ea6deef89245cfe0875a67c35f9b773" translate="yes" xml:space="preserve">
          <source>Think of &lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt;&lt;code&gt;multi_dot&lt;/code&gt;&lt;/a&gt; as:</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.multi_dot&quot;&gt; &lt;code&gt;multi_dot&lt;/code&gt; &lt;/a&gt; 을 다음과 같이 생각하십시오 .</target>
        </trans-unit>
        <trans-unit id="80d13b605601d6c6ca920c19b73c5be17b635404" translate="yes" xml:space="preserve">
          <source>This 2-d averaging filter runs quickly because the loop is in C and the pointer computations are done only as needed. If the code above is compiled as a module &lt;code&gt;image&lt;/code&gt;, then a 2-d image, &lt;code&gt;img&lt;/code&gt;, can be filtered using this code very quickly using:</source>
          <target state="translated">이 2 차원 평균화 필터는 루프가 C에 있고 포인터 계산이 필요한 경우에만 수행되기 때문에 빠르게 실행됩니다. 위의 코드가 모듈 &lt;code&gt;image&lt;/code&gt; 로 컴파일 된 경우 다음을 사용하여이 코드를 사용하여 2 차원 이미지 &lt;code&gt;img&lt;/code&gt; 를 매우 빠르게 필터링 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e4e675f0444c2be3f07e89468e7d677b6986ce7" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;.wav&lt;/code&gt; example is for illustration; to read a &lt;code&gt;.wav&lt;/code&gt; file in real life, use Python&amp;rsquo;s built-in module &lt;a href=&quot;https://docs.python.org/dev/library/wave.html#module-wave&quot;&gt;&lt;code&gt;wave&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 &lt;code&gt;.wav&lt;/code&gt; 예제는 설명을위한 것입니다. 실생활에서 &lt;code&gt;.wav&lt;/code&gt; 파일 을 읽으 려면 Python의 내장 모듈 &lt;a href=&quot;https://docs.python.org/dev/library/wave.html#module-wave&quot;&gt; &lt;code&gt;wave&lt;/code&gt; 를 사용하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="269959a51cb8489ddd62f29ffab3f7d5a6b40d53" translate="yes" xml:space="preserve">
          <source>This Chapter attempts to explain the logic behind some of the new pieces of code. The purpose behind these explanations is to enable somebody to be able to understand the ideas behind the implementation somewhat more easily than just staring at the code. Perhaps in this way, the algorithms can be improved on, borrowed from, and/or optimized by more people.</source>
          <target state="translated">이 장에서는 새로운 코드 일부의 논리를 설명하려고합니다. 이 설명의 목적은 누군가 코드를 쳐다 보는 것보다 구현의 아이디어를 좀 더 쉽게 이해할 수 있도록하는 것입니다. 아마도 이런 식으로, 알고리즘은 더 많은 사람들에 의해 개선, 빌리거나 및 / 또는 최적화 될 수있다.</target>
        </trans-unit>
        <trans-unit id="d6d4a7a2f523794d0b16e4b9b049698c812e64fd" translate="yes" xml:space="preserve">
          <source>This Subcommittee shall NOT make decisions about the direction, scope or technical direction of the Project.</source>
          <target state="translated">이 소위원회는 프로젝트의 방향, 범위 또는 기술적 방향에 대한 결정을 내리지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e344df267f24877e3c878787dee0c7157b282950" translate="yes" xml:space="preserve">
          <source>This Subcommittee will have 5 members, 4 of whom will be current Council Members and 1 of whom will be external to the Steering Council. No more than 2 Subcommittee Members can report to one person through employment or contracting work (including the reportee, i.e. the reportee + 1 is the max). This avoids effective majorities resting on one person.</source>
          <target state="translated">이 소위원회는 5 명의 위원으로 구성되며, 그중 4 명은 현위원회 위원이되고, 그 중 1 명은 운영위원회 외부에있게됩니다. 2 명 이하의 소위원회 위원이 고용 또는 계약 업무를 통해 한 사람에게보고 할 수 있습니다 (보고자 포함, 즉보고자 + 1이 최대 값임). 이것은 한 사람에게 효과적인 다수의 휴식을 피합니다.</target>
        </trans-unit>
        <trans-unit id="d8eb7804ceb212518c04178ca9353c5652cddc34" translate="yes" xml:space="preserve">
          <source>This address may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. The value itself may change during iteration, in particular if buffering is enabled. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">이 주소는 반복 루프 전에 캐시 될 수 있으며 &lt;code&gt;iternext&lt;/code&gt; 를 호출 해도 변경되지 않습니다. 버퍼링이 활성화 된 경우 반복 중에 값 자체가 변경 될 수 있습니다. 이 함수는 Python GIL을 유지하지 않고도 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a02ab6384a4ff5cc117cc0360cf322a65257b07" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">이 고급 인덱싱은 obj가 비교 연산자에서 반환 될 수있는 부울 유형의 배열 개체 일 때 발생합니다. 단일 부울 인덱스 배열은 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; 와 거의 동일합니다 . 여기서 위에서 설명한대로 &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;obj&lt;/em&gt; 의 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 요소를 표시하는 정수 인덱스 배열 의 튜플 (길이 &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt; )을 반환합니다 . 그러나 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 때 더 빠릅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="2dacb6ef0aabe4e0449ac2f7d6e826edb424af8c" translate="yes" xml:space="preserve">
          <source>This advanced indexing occurs when obj is an array object of Boolean type, such as may be returned from comparison operators. A single boolean index array is practically identical to &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; where, as described above, &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; returns a tuple (of length &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;obj.ndim&lt;/code&gt;&lt;/a&gt;) of integer index arrays showing the &lt;code&gt;True&lt;/code&gt; elements of &lt;em&gt;obj&lt;/em&gt;. However, it is faster when &lt;code&gt;obj.shape == x.shape&lt;/code&gt;.</source>
          <target state="translated">이 고급 색인 작성은 obj가 비교 연산자에서 리턴 될 수있는 것과 같이 부울 유형의 배열 오브젝트 인 경우 발생합니다. 단일 부울 인덱스 배열은 &lt;code&gt;x[obj.nonzero()]&lt;/code&gt; 와 실질적으로 동일합니다. 위에서 설명한 것처럼 &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; 는 &lt;em&gt;obj&lt;/em&gt; 의 &lt;code&gt;True&lt;/code&gt; 요소를 나타내는 정수 인덱스 배열 의 튜플 (길이 &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;obj.ndim&lt;/code&gt; &lt;/a&gt; )을 반환합니다 . 그러나 &lt;code&gt;obj.shape == x.shape&lt;/code&gt; 때 더 빠릅니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="710121ccc37af7c57d603d19a46f2cadc801d4ee" translate="yes" xml:space="preserve">
          <source>This allows multithreading to fill large arrays in chunks using suitable BitGenerators in parallel.</source>
          <target state="translated">이를 통해 멀티 스레딩은 적절한 BitGenerator를 병렬로 사용하여 큰 배열을 청크로 채울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af03503ddeac7c1214ea6c40abe67021cd6a3a66" translate="yes" xml:space="preserve">
          <source>This allows you to import the in-place built NumPy &lt;em&gt;from the repo base directory only&lt;/em&gt;. If you want the in-place build to be visible outside that base dir, you need to point your &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable to this directory. Some IDEs (&lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt; for example) have utilities to manage &lt;code&gt;PYTHONPATH&lt;/code&gt;. On Linux and OSX, you can run the command:</source>
          <target state="translated">이를 통해 &lt;em&gt;repo 기본 디렉토리에서만&lt;/em&gt; 내부 빌드 NumPy를 가져올 수 있습니다 . 인플레 이스 빌드가 해당 기본 디렉토리 외부에 표시되도록 &lt;code&gt;PYTHONPATH&lt;/code&gt; 환경 변수가이 디렉토리 를 가리켜 야합니다 . 일부 IDE ( 예 : &lt;a href=&quot;https://www.spyder-ide.org/&quot;&gt;Spyder&lt;/a&gt; )에는 &lt;code&gt;PYTHONPATH&lt;/code&gt; 를 관리하는 유틸리티가 있습니다 . Linux 및 OSX에서는 다음 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a10be423c319c36683d60f03c4235ea58ef43ca" translate="yes" xml:space="preserve">
          <source>This also works for functions and other objects that &lt;strong&gt;you&lt;/strong&gt; create. Just remember to include a docstring with your function using a string literal (&lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; or &lt;code&gt;''' '''&lt;/code&gt; around your documentation).</source>
          <target state="translated">이것은 또한 기능 및 기타 목적을 위해 작동 &lt;strong&gt;당신이&lt;/strong&gt; 만들 수 있습니다. 문자열 리터럴 ( 문서 주위에 &lt;code&gt;&quot;&quot;&quot; &quot;&quot;&quot;&lt;/code&gt; 또는 &lt;code&gt;''' '''&lt;/code&gt; 사용하여 함수에 독 스트링을 포함하는 것을 잊지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="43700c3e2d90a58545492f544e16be4440930810" translate="yes" xml:space="preserve">
          <source>This also works in more dimensions, e.g.</source>
          <target state="translated">이것은 또한 더 많은 차원에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="d1c39c0afd071dc6e571fc8d1273c278aad6faa3" translate="yes" xml:space="preserve">
          <source>This also works with 2D arrays! If you start with this array:</source>
          <target state="translated">이것은 2D 배열에서도 작동합니다! 이 어레이로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d160c6be16a498bbc805a56a17ad9724ae3c358b" translate="yes" xml:space="preserve">
          <source>This applies type promotion to all the inputs, using the NumPy rules for combining scalars and arrays, to determine the output type of a set of operands. This is the same result type that ufuncs produce. The specific algorithm used is as follows.</source>
          <target state="translated">이는 스칼라와 배열 결합을위한 NumPy 규칙을 사용하여 피연산자 세트의 출력 유형을 판별하기 위해 모든 입력에 유형 승격을 적용합니다. 이것은 ufuncs가 생성하는 것과 동일한 결과 유형입니다. 사용되는 특정 알고리즘은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2e8bc0cbcc5f069a41dc6497b9c0a909fd514a44" translate="yes" xml:space="preserve">
          <source>This approach to the array interface allows for faster access to an array using only one attribute lookup and a well-defined C-structure.</source>
          <target state="translated">어레이 인터페이스에 대한이 접근 방식은 하나의 속성 조회와 잘 정의 된 C 구조 만 사용하여 어레이에 더 빠르게 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b2cfa3868ca6d5d3eec71f613d2a281e952e696d" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">인터페이스에 대한이 접근 방식은 &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 속성을 가진 객체로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="3505c6babbf93b992cced9994459f797fa18ee9a" translate="yes" xml:space="preserve">
          <source>This approach to the interface consists of the object having an &lt;a href=&quot;#object.__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">인터페이스에 대한이 접근 방식은 &lt;a href=&quot;#object.__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 속성을 가진 객체로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="e27c7321ec2c09e2c1e41b0fb7ac933d7973957f" translate="yes" xml:space="preserve">
          <source>This arrangement allow for very flexible use of arrays. One thing that it allows is simple changes of the metadata to change the interpretation of the array buffer. Changing the byteorder of the array is a simple change involving no rearrangement of the data. The shape of the array can be changed very easily without changing anything in the data buffer or any data copying at all</source>
          <target state="translated">이 배열은 어레이를 매우 유연하게 사용할 수있게합니다. 배열 버퍼의 해석을 변경하기 위해 메타 데이터를 간단하게 변경하면됩니다. 배열의 바이트 순서를 변경하는 것은 데이터를 재 배열하지 않는 간단한 변경입니다. 데이터 버퍼의 데이터를 변경하거나 데이터를 복사하지 않고도 어레이의 모양을 매우 쉽게 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="13b0f80cc0af4acb749cdb54d3ae94021e334ad5" translate="yes" xml:space="preserve">
          <source>This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">이 어레이 생성 루틴을 사용하면 기존 어레이의 모양 및 메모리 레이아웃과 일치하는 새 어레이를 편리하게 생성 할 수 있으므로 레이아웃 및 / 또는 데이터 유형이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ad81be881df54f2faa5255b14c490a53a2cd92" translate="yes" xml:space="preserve">
          <source>This array is a copy of some other array. The C-API function PyArray_ResolveWritebackIfCopy must be called before deallocating to the base array will be updated with the contents of this array.</source>
          <target state="translated">이 배열은 다른 배열의 복사본입니다. 기본 배열에 할당 해제하기 전에 C-API 함수 PyArray_ResolveWritebackIfCopy를 호출해야이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="9975deeda2df7b42c75df625b9b5fc69426c2203" translate="yes" xml:space="preserve">
          <source>This array is stored in memory as 40 bytes, one after the other (known as a contiguous block of memory). The strides of an array tell us how many bytes we have to skip in memory to move to the next position along a certain axis. For example, we have to skip 4 bytes (1 value) to move to the next column, but 20 bytes (5 values) to get to the same position in the next row. As such, the strides for the array &lt;code&gt;x&lt;/code&gt; will be &lt;code&gt;(20, 4)&lt;/code&gt;.</source>
          <target state="translated">이 배열은 40 바이트 단위로 메모리에 저장됩니다 (연속 메모리 블록이라고 함). 배열의 보폭은 특정 축을 따라 다음 위치로 이동하기 위해 메모리에서 건너 뛰어야하는 바이트 수를 나타냅니다. 예를 들어 다음 열로 이동하려면 4 바이트 (1 값)를 건너 뛰고 다음 행에서 같은 위치에 도달하려면 20 바이트 (5 개 값)를 건너 뛰어야합니다. 이와 같이, 배열을위한 진보 &lt;code&gt;x&lt;/code&gt; 것 &lt;code&gt;(20, 4)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38cb8241a835a683d594eee86aed4e56e6c6635d" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">이 배열은 모든 &lt;a href=&quot;../generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt; 피연산자 의 마스크입니다 . 코드는 선택한 ARRAYMASK 피연산자가 True 인 요소 만 &lt;code&gt;writemasked&lt;/code&gt; 을 나타내는 writemasked 플래그를 사용합니다 . 일반적으로 반복자는이를 시행하지 않으며, 약속을 따르기 위해 반복을 수행하는 코드에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ed5fe179d122dc6d0ff4af8af1bf207796107b0" translate="yes" xml:space="preserve">
          <source>This array is the mask for all &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;writemasked&lt;/code&gt;&lt;/a&gt; operands. Code uses the &lt;code&gt;writemasked&lt;/code&gt; flag which indicates that only elements where the chosen ARRAYMASK operand is True will be written to. In general, the iterator does not enforce this, it is up to the code doing the iteration to follow that promise.</source>
          <target state="translated">이 배열은 모든 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;writemasked&lt;/code&gt; &lt;/a&gt; 마스크 피연산자 의 마스크입니다 . 코드는 선택된 ARRAYMASK 피연산자가 True 인 요소 만 &lt;code&gt;writemasked&lt;/code&gt; 을 나타내는 쓰기 마스크 된 플래그를 사용합니다 . 일반적으로 반복자는 이것을 강제하지 않으며, 그 약속을 따르기 위해 반복을 수행하는 코드에 달려 있습니다.</target>
        </trans-unit>
        <trans-unit id="da76cf9484436ae5f595cbe33ce62d99eee348ae" translate="yes" xml:space="preserve">
          <source>This array is used in computing an N-d index from a 1-d index. It contains needed products of the dimensions.</source>
          <target state="translated">이 배열은 1-d 인덱스에서 Nd 인덱스를 계산하는 데 사용됩니다. 필요한 치수의 제품이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2950d768bc15bd8305b22a36aa90ddcbd53411a1" translate="yes" xml:space="preserve">
          <source>This array method can be conveniently chained:</source>
          <target state="translated">이 배열 방법은 편리하게 연결될 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="cd59928fafb5b8b3afd2257d5348ff12e61a3751" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is the number of choices, unless &lt;code&gt;mode=wrap&lt;/code&gt; or &lt;code&gt;mode=clip&lt;/code&gt;, in which cases any integers are permissible.</source>
          <target state="translated">이 배열에는 &lt;code&gt;[0, n-1]&lt;/code&gt; 정수가 포함되어야합니다 . 여기서 &lt;code&gt;mode=wrap&lt;/code&gt; 또는 &lt;code&gt;mode=clip&lt;/code&gt; 이 아닌 경우 정수가 허용되는 경우를 제외하고 &lt;code&gt;n&lt;/code&gt; 은 선택 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="2801e85aeaae18790917a73e502d7026a3a34d08" translate="yes" xml:space="preserve">
          <source>This array must contain integers in &lt;code&gt;[0, n-1]&lt;/code&gt;, where n is the number of choices.</source>
          <target state="translated">이 배열은 &lt;code&gt;[0, n-1]&lt;/code&gt; 정수를 포함해야합니다 . 여기서 n은 선택 수입니다.</target>
        </trans-unit>
        <trans-unit id="7231182809746ea9e4a7a5bcc665f806413fd373" translate="yes" xml:space="preserve">
          <source>This assumes that you have forked &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org&lt;/a&gt;:</source>
          <target state="translated">이것은 &lt;a href=&quot;https://github.com/scipy/scipy.org&quot;&gt;https://github.com/scipy/scipy.org를&lt;/a&gt; 분기했다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="3397e055cb40235a1ae2818b229475b2582745a3" translate="yes" xml:space="preserve">
          <source>This attribute allows simple but flexible determination of which sub- type should be considered &amp;ldquo;primary&amp;rdquo; when an operation involving two or more sub-types arises. In operations where different sub-types are being used, the sub-type with the largest &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute will determine the sub-type of the output(s). If two sub- types have the same &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; then the sub-type of the first argument determines the output. The default &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute returns a value of 0.0 for the base ndarray type and 1.0 for a sub-type. This attribute can also be defined by objects that are not sub-types of the ndarray and can be used to determine which &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method should be called for the return output.</source>
          <target state="translated">이 속성을 사용하면 두 개 이상의 하위 유형을 포함하는 작업이 발생할 때 어떤 하위 유형이 &quot;기본&quot;으로 간주되어야하는지 간단하지만 유연하게 결정할 수 있습니다. 다른 하위 유형이 사용되는 작업에서 가장 큰 &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 속성을 가진 하위 유형이 출력의 하위 유형을 결정합니다. 두 개의 하위 유형이 동일한 &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 를 갖는 경우 첫 번째 인수의 하위 유형이 출력을 결정합니다. 기본 &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 속성은 기본 ndarray 유형에 대해 0.0 값을 반환하고 하위 유형에 대해 1.0을 반환합니다. 이 속성은 ndarray의 하위 유형이 아닌 객체에 의해 정의 될 수도 있으며 반환 출력을 위해 호출되어야 하는 &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 메소드 를 결정하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a1937d99c6f34bca77e93395a42e2a63ca828dcf" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;buffer interface&lt;/a&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">이 속성은 데이터를 공유하는 데 사용될 &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;버퍼 인터페이스&lt;/a&gt; 를 노출하는 객체 일 수도 있습니다 . 이 키가 없으면 (또는 None을 반환), 메모리 공유는 객체 자체의 버퍼 인터페이스를 통해 수행됩니다. 이 경우 오프셋 키를 사용하여 버퍼의 시작을 나타낼 수 있습니다. 메모리 영역을 보호하려면 배열 인터페이스를 노출하는 객체에 대한 참조를 새 객체에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="19820dc6931f03b4ce34d1e382ce5208e82ba583" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt;&lt;code&gt;buffer interface&lt;/code&gt;&lt;/a&gt; which will be used to share the data. If this key is not present (or returns &lt;code&gt;None&lt;/code&gt;), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">이 속성은 데이터를 공유하는 데 사용될 &lt;a href=&quot;https://docs.python.org/dev/c-api/objbuffer.html#c.PyObject_AsCharBuffer&quot;&gt; &lt;code&gt;buffer interface&lt;/code&gt; &lt;/a&gt; 를 노출하는 객체 일 수도 있습니다 . 이 키가 존재하지 않거나 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 객체 자체의 버퍼 인터페이스를 통해 메모리 공유가 수행됩니다. 이 경우 오프셋 키를 사용하여 버퍼의 시작을 나타낼 수 있습니다. 메모리 영역을 확보하려면 어레이 인터페이스를 노출하는 객체에 대한 참조를 새 객체로 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="357acc58797c34ec7ee3526baa5d4678b200c571" translate="yes" xml:space="preserve">
          <source>This attribute can also be an object exposing the &lt;code&gt;buffer interface&lt;/code&gt; which will be used to share the data. If this key is not present (or returns None), then memory sharing will be done through the buffer interface of the object itself. In this case, the offset key can be used to indicate the start of the buffer. A reference to the object exposing the array interface must be stored by the new object if the memory area is to be secured.</source>
          <target state="translated">이 속성은 데이터를 공유하는 데 사용될 &lt;code&gt;buffer interface&lt;/code&gt; 를 노출하는 객체 일 수도 있습니다 . 이 키가 없으면 (또는 None을 반환), 메모리 공유는 객체 자체의 버퍼 인터페이스를 통해 수행됩니다. 이 경우 오프셋 키를 사용하여 버퍼의 시작을 나타낼 수 있습니다. 메모리 영역을 보호하려면 배열 인터페이스를 노출하는 객체에 대한 참조를 새 객체에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="99486092092808fe1a7a3c63950908fb38dd3c25" translate="yes" xml:space="preserve">
          <source>This attribute creates an object that makes it easier to use arrays when calling shared libraries with the ctypes module. The returned object has, among others, data, shape, and strides attributes (see Notes below) which themselves return ctypes objects that can be used as arguments to a shared library.</source>
          <target state="translated">이 속성은 ctypes 모듈로 공유 라이브러리를 호출 할 때 배열을보다 쉽게 ​​사용할 수있는 객체를 만듭니다. 반환 된 객체는 특히 공유 라이브러리에 대한 인수로 사용할 수있는 ctypes 객체를 반환하는 data, shape 및 strides 속성 (아래 참고 참조)을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="94f279541eccc23ec8d58b2be974fecc119fa4c7" translate="yes" xml:space="preserve">
          <source>This basic behavior can be augmented by passing a 2-tuple in as the file argument. The first element of the tuple should specify the relative path (under the package install directory) where the remaining sequence of files should be installed to (it has nothing to do with the file-names in the source distribution). The second element of the tuple is the sequence of files that should be installed. The files in this sequence can be filenames, relative paths, or absolute paths. For absolute paths the file will be installed in the top-level package installation directory (regardless of the first argument). Filenames and relative path names will be installed in the package install directory under the path name given as the first element of the tuple.</source>
          <target state="translated">이 기본 동작은 파일 인수로 2 개의 튜플을 전달하여 기능을 보강 할 수 있습니다. 튜플의 첫 번째 요소는 나머지 파일 시퀀스를 설치해야하는 상대 경로 (패키지 설치 디렉토리 아래)를 지정해야합니다 (소스 배포의 파일 이름과 관련이 없음). 튜플의 두 번째 요소는 설치해야하는 파일 시퀀스입니다. 이 순서의 파일은 파일 이름, 상대 경로 또는 절대 경로 일 수 있습니다. 절대 경로의 경우 파일은 첫 번째 인수에 관계없이 최상위 패키지 설치 디렉토리에 설치됩니다. 파일 이름과 상대 경로 이름은 패키지 설치 디렉토리에 튜플의 첫 번째 요소로 지정된 경로 이름 아래에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="38d8b59be8238ec40cd52d11a1691c2db5ac9b19" translate="yes" xml:space="preserve">
          <source>This broadcasting can also be achieved using the function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방송은 &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 기능을 사용하여 달성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="040d755c45914cdad7e449ca2485bc004cd21eb5" translate="yes" xml:space="preserve">
          <source>This bug causes Python before 3.4 to not reliably show warnings again after they have been ignored once (even within catch_warnings). It means that no &amp;ldquo;ignore&amp;rdquo; filter can be used easily, since following tests might need to see the warning. Additionally it allows easier specificity for testing warnings and can be nested.</source>
          <target state="translated">이 버그로 인해 3.4 이전의 Python은 한 번 무시 된 후에도 catch_warnings에서도 경고를 다시 표시하지 않습니다. 다음 테스트에서 경고를 확인해야 할 수 있으므로 &quot;무시&quot;필터를 쉽게 사용할 수 없습니다. 또한 경고 테스트를보다 쉽게 ​​수행 할 수 있으며 중첩 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b97776ec43283f6527b6b56ee297ecb07c0e7a5e" translate="yes" xml:space="preserve">
          <source>This builds NumPy first, so the first time it may take a few minutes. If you specify &lt;code&gt;-n&lt;/code&gt;, the tests are run against the version of NumPy (if any) found on current PYTHONPATH.</source>
          <target state="translated">이렇게하면 NumPy가 먼저 빌드되므로 처음에는 몇 분 정도 걸릴 수 있습니다. &lt;code&gt;-n&lt;/code&gt; 을 지정 하면 현재 PYTHONPATH에있는 NumPy 버전 (있는 경우)에 대해 테스트가 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="25f8c2b712d454554ccb3b1572df7e3d85a8d6a8" translate="yes" xml:space="preserve">
          <source>This can be done via &lt;em&gt;interactive rebasing&lt;/em&gt;.</source>
          <target state="translated">이것은 &lt;em&gt;대화식 리베이스&lt;/em&gt; 를 통해 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d1ccaf9367b320b45fde18f5d1b6d26c14c28d1" translate="yes" xml:space="preserve">
          <source>This can be used on multidimensional arrays too:</source>
          <target state="translated">다차원 배열에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4619f696b33e2f5aafe4335faf3807d265baaeed" translate="yes" xml:space="preserve">
          <source>This can have multiple paragraphs.</source>
          <target state="translated">여기에는 여러 단락이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b0866e6d60c935d1c1a437309972ddf022e2bfb" translate="yes" xml:space="preserve">
          <source>This chapter will review many of the tools that are available for the purpose of accessing code written in other compiled languages. There are many resources available for learning to call other compiled libraries from Python and the purpose of this Chapter is not to make you an expert. The main goal is to make you aware of some of the possibilities so that you will know what to &amp;ldquo;Google&amp;rdquo; in order to learn more.</source>
          <target state="translated">이 장에서는 다른 컴파일 된 언어로 작성된 코드에 액세스 할 목적으로 사용할 수있는 많은 도구를 검토합니다. 파이썬에서 다른 컴파일 된 라이브러리를 호출하는 방법을 배우는 데 사용할 수있는 많은 리소스가 있으며이 장의 목적은 여러분을 전문가로 만드는 것이 아닙니다. 주요 목표는 몇 가지 가능성을 인식하여 자세한 내용을 알아보기 위해 &quot;Google&quot;에 대해 알 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f7b07ef80d0cc13652d9fe61895de6904fd8ef60" translate="yes" xml:space="preserve">
          <source>This class implements the special methods for almost all of Python&amp;rsquo;s builtin operators defined in the &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt;&lt;code&gt;operator&lt;/code&gt;&lt;/a&gt; module, including comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, etc.) and arithmetic (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, etc.), by deferring to the &lt;code&gt;__array_ufunc__&lt;/code&gt; method, which subclasses must implement.</source>
          <target state="translated">이 클래스 는 &lt;code&gt;__array_ufunc__&lt;/code&gt; 메소드를 연기 하여 비교 ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; 등) 및 산술 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; 등)을 포함 하여 &lt;a href=&quot;https://docs.python.org/dev/library/operator.html#module-operator&quot;&gt; &lt;code&gt;operator&lt;/code&gt; &lt;/a&gt; 모듈에 정의 된 거의 모든 Python 내장 연산자에 대한 특수 메소드를 구현합니다 . 어떤 서브 클래스가 구현해야하는지</target>
        </trans-unit>
        <trans-unit id="4c89b01b7f4a0346b82c2ab3f988792b632fe09a" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">이 클래스는 numarray 이전 버전과의 호환성을 위해 제공됩니다. 새로운 코드 (numarray 호환성과 관련이 없음)는 &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt; &lt;code&gt;string_&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;unicode_&lt;/code&gt; &lt;/a&gt; 유형의 배열을 사용해야하며 대신 빠른 벡터화 된 문자열 연산을 위해 &lt;code&gt;numpy.char&lt;/code&gt; 의 자유 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="cbc453ece1fc4bcfba8a214ebb68dae3ad49689e" translate="yes" xml:space="preserve">
          <source>This class is provided for numarray backward-compatibility. New code (not concerned with numarray compatibility) should use arrays of type &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt; and use the free functions in &lt;code&gt;numpy.char&lt;/code&gt; for fast vectorized string operations instead.</source>
          <target state="translated">이 클래스는 numarray 하위 호환성을 위해 제공됩니다. 새로운 코드 (numarray 호환성과 관련이없는)는 &lt;code&gt;string_&lt;/code&gt; 또는 &lt;code&gt;unicode_&lt;/code&gt; 유형의 배열을 사용해야하며 대신 빠른 벡터화 된 문자열 연산을 위해 &lt;code&gt;numpy.char&lt;/code&gt; 의 무료 함수를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="817afa6aa8358446cc6150c81d202fd10664d253" translate="yes" xml:space="preserve">
          <source>This class isn&amp;rsquo;t very useful, because it has the same constructor as the bare ndarray object, including passing in buffers and shapes and so on. We would probably prefer the constructor to be able to take an already formed ndarray from the usual numpy calls to &lt;code&gt;np.array&lt;/code&gt; and return an object.</source>
          <target state="translated">이 클래스는 버퍼 및 모양 전달 등을 포함하여 베어 ndarray 객체와 동일한 생성자를 가지고 있기 때문에 그다지 유용하지 않습니다. 우리는 생성자가 np.array에 대한 일반적인 numpy 호출에서 이미 형성된 ndarray를 &lt;code&gt;np.array&lt;/code&gt; 객체를 반환 할 수있는 것을 선호 할 것입니다 .</target>
        </trans-unit>
        <trans-unit id="547d58e17f08661cffe0028727466b3bfecb1f09" translate="yes" xml:space="preserve">
          <source>This class may at some point be turned into a factory function which returns a view into an mmap buffer.</source>
          <target state="translated">이 클래스는 어떤 시점에서 뷰를 mmap 버퍼로 리턴하는 팩토리 함수로 바뀔 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f0e2bd2c54e1831a429118c49099c40d4fc6a31" translate="yes" xml:space="preserve">
          <source>This code can be compiled and linked into an extension module named filter using:</source>
          <target state="translated">이 코드는 다음을 사용하여 필터라는 확장 모듈로 컴파일 및 링크 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="051a76f1d3dcebdcceb5b6a498f248ede74e08da" translate="yes" xml:space="preserve">
          <source>This code has a significant amount of error handling. Note the &lt;code&gt;SWIG_fail&lt;/code&gt; is a macro for &lt;code&gt;goto fail&lt;/code&gt;, referring to the label at line 28. If the user provides the wrong number of arguments, this will be caught at line 10. If construction of the NumPy array fails or produces an array with the wrong number of dimensions, these errors are caught at line 17. And finally, if an error is detected, memory is still managed correctly at line 30.</source>
          <target state="translated">이 코드에는 상당한 양의 오류 처리 기능이 있습니다. 메모 &lt;code&gt;SWIG_fail&lt;/code&gt; 을 위한 매크로입니다 &lt;code&gt;goto fail&lt;/code&gt; 라인 (28) 사용자가 인수의 잘못된 번호를 제공하는 경우에 라벨을 참조, 이것은 라인 NumPy와 배열의 건설에 오류가 발생하거나 잘못된 배열을 생성하는 경우 (10)에 잡힐 것 차원의 수에 따라 이러한 오류는 17 행에서 발견됩니다. 마지막으로 오류가 감지되면 30 행에서 메모리가 여전히 올바르게 관리됩니다.</target>
        </trans-unit>
        <trans-unit id="3999b914a2658c99b5fe639f3ab379867f2570ac" translate="yes" xml:space="preserve">
          <source>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment and goals. Please try to follow this code in spirit as much as in letter, to create a friendly and productive environment that enriches the surrounding community.</source>
          <target state="translated">이 코드는 완전하거나 완전하지 않습니다. 그것은 협력적이고 공유 된 환경과 목표에 대한 우리의 공통된 이해를 증류하는 역할을합니다. 주변 지역 사회를 풍요롭게하는 친절하고 생산적인 환경을 만들기 위해이 코드를 편지만큼이나 정신적으로 따르도록 노력하십시오.</target>
        </trans-unit>
        <trans-unit id="dc2f712a7c05e996ac3e38345d45b7f3d7e23038" translate="yes" xml:space="preserve">
          <source>This code loads the shared library named &lt;code&gt;code.{ext}&lt;/code&gt; located in the same path as this file. It then adds a return type of void to the functions contained in the library. It also adds argument checking to the functions in the library so that ndarrays can be passed as the first three arguments along with an integer (large enough to hold a pointer on the platform) as the fourth argument.</source>
          <target state="translated">이 코드 는이 파일과 동일한 경로에있는 &lt;code&gt;code.{ext}&lt;/code&gt; 라는 공유 라이브러리를로드 합니다. 그런 다음 라이브러리에 포함 된 함수에 void 반환 유형을 추가합니다. 또한 라이브러리의 함수에 인수 검사를 추가하여 ndarray가 네 번째 인수로 정수 (플랫폼에서 포인터를 보유 할만큼 충분히 큼)와 함께 처음 세 인수로 전달 될 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="533c867c6a351c2be81a48161bc93203ea12c76d" translate="yes" xml:space="preserve">
          <source>This code of conduct applies to all spaces managed by the NumPy project, including all public and private mailing lists, issue trackers, wikis, blogs, Twitter, and any other communication channel used by our community. The NumPy project does not organise in-person events, however events related to our community should have a code of conduct similar in spirit to this one.</source>
          <target state="translated">이 행동 강령은 모든 공개 및 비공개 메일 링리스트, 이슈 트래커, 위키, 블로그, Twitter 및 커뮤니티에서 사용하는 기타 커뮤니케이션 채널을 포함하여 NumPy 프로젝트에서 관리하는 모든 공간에 적용됩니다. NumPy 프로젝트는 대면 이벤트를 조직하지 않지만, 우리 커뮤니티와 관련된 이벤트는 이와 유사한 행동 강령을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="cff208b4a7eacc934c607e5c41003491618977d7" translate="yes" xml:space="preserve">
          <source>This code of conduct should be honored by everyone who participates in the NumPy community formally or informally, or claims any affiliation with the project, in any project-related activities and especially when representing the project, in any role.</source>
          <target state="translated">이 행동 강령은 NumPy 커뮤니티에 공식 또는 비공식적으로 참여하거나 프로젝트, 프로젝트 관련 활동, 특히 프로젝트를 대표 할 때 어떤 역할로든 관련이 있다고 주장하는 모든 사람이 존중해야합니다.</target>
        </trans-unit>
        <trans-unit id="0f194434e38b3846c0fd28dc955d7908e8501694" translate="yes" xml:space="preserve">
          <source>This command builds (see &lt;code&gt;-c&lt;/code&gt; flag, execute &lt;code&gt;python -m numpy.f2py&lt;/code&gt; without arguments to see the explanation of command line options) an extension module &lt;code&gt;fib1.so&lt;/code&gt; (see &lt;code&gt;-m&lt;/code&gt; flag) to the current directory. Now, in Python the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; is accessible via &lt;code&gt;fib1.fib&lt;/code&gt;:</source>
          <target state="translated">이 명령은 현재 디렉토리에 확장 모듈 &lt;code&gt;fib1.so&lt;/code&gt; ( &lt;code&gt;-m&lt;/code&gt; 플래그 참조 )를 빌드합니다 ( &lt;code&gt;-c&lt;/code&gt; 플래그 참조, 인수없이 &lt;code&gt;python -m numpy.f2py&lt;/code&gt; 실행 ). 이제 Python에서 Fortran 서브 루틴 &lt;code&gt;FIB&lt;/code&gt; 는 &lt;code&gt;fib1.fib&lt;/code&gt; 를 통해 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ac9bee6274aa8d66ef375e679babd25ee76812a2" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a Python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="translated">이 명령은 현재 디렉토리에 add. {ext}라는 파일을 남깁니다 (여기서 {ext}는 플랫폼의 Python 확장 모듈에 적합한 확장입니다. 즉, pyd &lt;em&gt;등&lt;/em&gt; ). 그런 다음이 모듈을 Python에서 가져올 수 있습니다. 여기에는 add (zadd, cadd, dadd, sadd)의 각 서브 루틴에 대한 메소드가 포함됩니다. 각 메서드의 독 스트링에는 모듈 메서드를 호출하는 방법에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbb1615a9d0e074d0b52d81da555b5659d5320b3" translate="yes" xml:space="preserve">
          <source>This command leaves a file named add.{ext} in the current directory (where {ext} is the appropriate extension for a python extension module on your platform &amp;mdash; so, pyd, &lt;em&gt;etc.&lt;/em&gt; ). This module may then be imported from Python. It will contain a method for each subroutine in add (zadd, cadd, dadd, sadd). The docstring of each method contains information about how the module method may be called:</source>
          <target state="translated">이 명령은 현재 디렉토리에 add. {ext}라는 파일을 남깁니다 (여기서 {ext}는 플랫폼의 Python 확장 모듈에 적합한 확장입니다. 즉, pyd &lt;em&gt;등&lt;/em&gt; ). 그런 다음이 모듈을 Python에서 가져올 수 있습니다. 여기에는 add (zadd, cadd, dadd, sadd)의 각 서브 루틴에 대한 메소드가 포함됩니다. 각 메서드의 독 스트링에는 모듈 메서드를 호출하는 방법에 대한 정보가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8208674ec726acd6f311802a0a4f9952791f4b6" translate="yes" xml:space="preserve">
          <source>This command leaves the file add.pyf in the current directory. The section of this file corresponding to zadd is:</source>
          <target state="translated">이 명령은 현재 디렉토리에 add.pyf 파일을 남깁니다. zadd에 해당하는이 파일의 섹션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e0a485b84958d1031e7018c2536aa8e72a66489" translate="yes" xml:space="preserve">
          <source>This condition is broadcast over the input. At locations where the condition is True, the &lt;code&gt;out&lt;/code&gt; array will be set to the ufunc result. Elsewhere, the &lt;code&gt;out&lt;/code&gt; array will retain its original value. Note that if an uninitialized &lt;code&gt;out&lt;/code&gt; array is created via the default &lt;code&gt;out=None&lt;/code&gt;, locations within it where the condition is False will remain uninitialized.</source>
          <target state="translated">이 상태는 입력을 통해 브로드 캐스트됩니다. 조건이 True 인 위치에서는 &lt;code&gt;out&lt;/code&gt; 배열이 ufunc 결과로 설정됩니다. 다른 경우, &lt;code&gt;out&lt;/code&gt; 배열은 원래 값을 유지합니다. 초기화되지 않은 &lt;code&gt;out&lt;/code&gt; 배열이 default &lt;code&gt;out=None&lt;/code&gt; 을 통해 생성 되면 조건이 False 인 배열 내의 위치는 초기화되지 않은 상태로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="ee4c6c49dffb551e0984368af8f98c122bd3ccfb" translate="yes" xml:space="preserve">
          <source>This constructor can be compared to &lt;code&gt;empty&lt;/code&gt;: it creates a new record array but does not fill it with data. To create a record array from data, use one of the following methods:</source>
          <target state="translated">이 생성자는 &lt;code&gt;empty&lt;/code&gt; 와 비교할 수 있습니다 . 새 레코드 배열을 작성하지만 데이터로 채우지는 않습니다. 데이터에서 레코드 배열을 작성하려면 다음 방법 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="33c942d2092f2a81aa60d19a082d10077f5b892d" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">이 생성자 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;buffer&lt;/code&gt; ( &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; 포함&lt;/a&gt; )를 사용하여 배열을 만듭니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음으로 새로운 배열 구축 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;C 순서&quot;모두 않는 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 및 &lt;code&gt;order='Fortran'&lt;/code&gt; 사례하는, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.strides.html#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;포트란 순서&quot;이다.</target>
        </trans-unit>
        <trans-unit id="953bdd8047346bccedc501390c7ed7305dc6711a" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">이 생성자 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;buffer&lt;/code&gt; ( &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; 포함&lt;/a&gt; )를 사용하여 배열을 만듭니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음으로 새로운 배열 구축 &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;C 순서&quot;모두 않는 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 및 &lt;code&gt;order='F'&lt;/code&gt; 사례하는, &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;포트란 순서&quot;이다.</target>
        </trans-unit>
        <trans-unit id="244906121f35fcb6808baef572df1faf5ecac2b9" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='Fortran'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">이 생성자 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;buffer&lt;/code&gt; ( &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; 포함&lt;/a&gt; )를 사용하여 배열을 만듭니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음으로 새로운 배열 구축 &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;C 순서&quot;모두 않는 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 및 &lt;code&gt;order='Fortran'&lt;/code&gt; 사례하는, &lt;a href=&quot;numpy.char.chararray.strides#numpy.char.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;포트란 순서&quot;이다.</target>
        </trans-unit>
        <trans-unit id="472735a82ef7af1ec4165da8f5b7c128444159de" translate="yes" xml:space="preserve">
          <source>This constructor creates the array, using &lt;code&gt;buffer&lt;/code&gt; (with &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt;) if it is not &lt;code&gt;None&lt;/code&gt;. If &lt;code&gt;buffer&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then constructs a new array with &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; in &amp;ldquo;C order&amp;rdquo;, unless both &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; and &lt;code&gt;order='F'&lt;/code&gt;, in which case &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; is in &amp;ldquo;Fortran order&amp;rdquo;.</source>
          <target state="translated">이 생성자 는 &lt;code&gt;None&lt;/code&gt; 이 아닌 경우 &lt;code&gt;buffer&lt;/code&gt; ( &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; 포함&lt;/a&gt; )를 사용하여 배열을 만듭니다 . 경우 &lt;code&gt;buffer&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; 다음으로 새로운 배열 구축 &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;C 순서&quot;모두 않는 &lt;code&gt;len(shape) &amp;gt;= 2&lt;/code&gt; 및 &lt;code&gt;order='F'&lt;/code&gt; 사례하는, &lt;a href=&quot;numpy.chararray.strides#numpy.chararray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; &quot;포트란 순서&quot;이다.</target>
        </trans-unit>
        <trans-unit id="25eee032d6ea1636789f057c08bed3526280036b" translate="yes" xml:space="preserve">
          <source>This could then be registered to convert doubles to floats using the code:</source>
          <target state="translated">그런 다음 코드를 사용하여 double을 float로 변환하도록 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5986918bf935c1ed16d4421ab17b1ade1eafe40" translate="yes" xml:space="preserve">
          <source>This declares that the corresponding argument depends on the values of variables in the list &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt;. For example, &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; may use the values of other arguments. Using information given by &lt;code&gt;depend(..)&lt;/code&gt; attributes, F2PY ensures that arguments are initialized in a proper order. If &lt;code&gt;depend(..)&lt;/code&gt; attribute is not used then F2PY determines dependence relations automatically. Use &lt;code&gt;depend()&lt;/code&gt; to disable dependence relations generated by F2PY.</source>
          <target state="translated">이는 해당 인수가 &lt;code&gt;&amp;lt;names&amp;gt;&lt;/code&gt; 목록의 변수 값에 따라 달라짐을 선언합니다 . 예를 들어, &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; 은 다른 인수의 값을 사용할 수 있습니다. Depend &lt;code&gt;depend(..)&lt;/code&gt; 속성이 제공하는 정보를 사용하여 F2PY는 인수가 적절한 순서로 초기화되도록합니다. 경우에 &lt;code&gt;depend(..)&lt;/code&gt; 속성 F2PY 자동 의존 관계를 판정 한 후 사용되지 않는다. F2PY에 의해 생성 된 종속성 관계를 비활성화하려면 dependent &lt;code&gt;depend()&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c221f7f1dff9c4b5017181532f28da44b16fcb82" translate="yes" xml:space="preserve">
          <source>This decorator can be used to filter DeprecationWarning&amp;rsquo;s, to avoid printing them during the test suite run, while checking that the test actually raises a DeprecationWarning.</source>
          <target state="translated">이 데코레이터는 DeprecationWarning을 필터링하여 테스트 스위트 실행 중에 인쇄를 피하고 테스트에서 실제로 DeprecationWarning이 발생하는지 확인하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50d52a319d15baa1479e649a743cee7e5d09023b" translate="yes" xml:space="preserve">
          <source>This decorator can&amp;rsquo;t use the nose namespace, because it can be called from a non-test module. See also &lt;code&gt;istest&lt;/code&gt; and &lt;code&gt;nottest&lt;/code&gt; in &lt;code&gt;nose.tools&lt;/code&gt;.</source>
          <target state="translated">이 데코레이터는 테스트되지 않은 모듈에서 호출 할 수 있기 때문에 nose 네임 스페이스를 사용할 수 없습니다. 참조 &lt;code&gt;istest&lt;/code&gt; 및 &lt;code&gt;nottest&lt;/code&gt; 에 &lt;code&gt;nose.tools&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67fd7e1d7456c74a698475b7f144fadff01137fb" translate="yes" xml:space="preserve">
          <source>This default iterator selects a sub-array of dimension</source>
          <target state="translated">이 기본 반복자는 차원의 하위 배열을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="cfb9c1da992a1d1aaddfb397e6c91ff1039b17da" translate="yes" xml:space="preserve">
          <source>This default threshold is designed to detect rank deficiency accounting for the numerical errors of the SVD computation. Imagine that there is a column in &lt;code&gt;M&lt;/code&gt; that is an exact (in floating point) linear combination of other columns in &lt;code&gt;M&lt;/code&gt;. Computing the SVD on &lt;code&gt;M&lt;/code&gt; will not produce a singular value exactly equal to 0 in general: any difference of the smallest SVD value from 0 will be caused by numerical imprecision in the calculation of the SVD. Our threshold for small SVD values takes this numerical imprecision into account, and the default threshold will detect such numerical rank deficiency. The threshold may declare a matrix &lt;code&gt;M&lt;/code&gt; rank deficient even if the linear combination of some columns of &lt;code&gt;M&lt;/code&gt; is not exactly equal to another column of &lt;code&gt;M&lt;/code&gt; but only numerically very close to another column of &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">이 기본 임계 값은 SVD 계산의 숫자 오류에 대한 순위 부족 계산을 감지하도록 설계되었습니다. 의 컬럼이 있다는 상상 &lt;code&gt;M&lt;/code&gt; 다른 열의 선형 조합 (부동 소수점) 정확한 인 &lt;code&gt;M&lt;/code&gt; 이 . &lt;code&gt;M&lt;/code&gt; 에서 SVD를 계산하면 일반적으로 정확히 0과 같은 특이 값이 생성되지 않습니다. SVD 계산에서 숫자와의 차이가 0에서 가장 작은 SVD 값의 차이로 인해 발생합니다. 작은 SVD 값에 대한 임계 값은이 수치 부정확성을 고려하며 기본 임계 값은 이러한 수치 순위 결함을 감지합니다. 매트릭스 선언 할 수있다 임계 &lt;code&gt;M&lt;/code&gt; 의 랭크가 결핍 된 경우에도 일부 열의 선형 조합 &lt;code&gt;M&lt;/code&gt; 정확히의 다른 열 같지 않은 &lt;code&gt;M&lt;/code&gt; 매우 가까이의 또 다른 컬럼 만 숫자 만 &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0285819f9fc91ea6c1e91e579241c01b00956ba" translate="yes" xml:space="preserve">
          <source>This design was retracted almost immediately after it was proposed, in &amp;lt;&lt;a href=&quot;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&quot;&gt;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&lt;/a&gt;&amp;gt;. Despite 14 years of documentation to the contrary, at no point was it valid to assume that &lt;code&gt;__array_interface__&lt;/code&gt; capsules held this tuple content.</source>
          <target state="translated">이 디자인은 &amp;lt; &lt;a href=&quot;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&quot;&gt;https://mail.python.org/pipermail/numpy-discussion/2006-June/020995.html&lt;/a&gt; &amp;gt; 에서 제안 된 직후 철회되었습니다 . 반대로 14 년의 문서화에도 불구하고 &lt;code&gt;__array_interface__&lt;/code&gt; 캡슐이이 튜플 콘텐츠를 보유 하고 있다고 가정하는 것은 타당하지 않았습니다 .</target>
        </trans-unit>
        <trans-unit id="b6968499a16ad7614bdea90ae8f3aad570e0c60e" translate="yes" xml:space="preserve">
          <source>This document describes the syntax and best practices for docstrings used with the numpydoc extension for &lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt;.</source>
          <target state="translated">이 문서는 &lt;a href=&quot;http://sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 용 numpydoc 확장과 함께 사용되는 독 스트링의 구문과 권장 사항을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="b45b65ecc52b644a63152b28ad1bde6a3a5e1f70" translate="yes" xml:space="preserve">
          <source>This document gives coding conventions for the C code comprising the C implementation of NumPy. Note, rules are there to be broken. Two good reasons to break a particular rule:</source>
          <target state="translated">이 문서는 NumPy의 C 구현을 구성하는 C 코드에 대한 코딩 규칙을 제공합니다. 규칙은 깨질 수 있습니다. 특정 규칙을 어기는 두 가지 이유 :</target>
        </trans-unit>
        <trans-unit id="8c3b557b3201940ffcbe7e57b7ac3945729bb630" translate="yes" xml:space="preserve">
          <source>This document itself was written in ReStructuredText. &lt;a href=&quot;#example&quot;&gt;An example&lt;/a&gt; of the format shown here is available.</source>
          <target state="translated">이 문서 자체는 ReStructuredText로 작성되었습니다. 여기에 표시된 형식 &lt;a href=&quot;#example&quot;&gt;의 예&lt;/a&gt; 를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2007e99c49141c98bee8b2f4b8b703b1ff66930c" translate="yes" xml:space="preserve">
          <source>This does not compute the usual correlation: if op2 is larger than op1, the arguments are swapped, and the conjugate is never taken for complex arrays. See PyArray_Correlate2 for the usual signal processing correlation.</source>
          <target state="translated">이는 일반적인 상관 관계를 계산하지 않습니다. op2가 op1보다 크면 인수가 바뀌고 복합 배열에 대해 켤레가 사용되지 않습니다. 일반적인 신호 처리 상관 관계는 PyArray_Correlate2를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac0e7432126a7d32cb5b22ed347524b29026575" translate="yes" xml:space="preserve">
          <source>This enables the iterator to reason about data dependency, possibly avoiding unnecessary copies.</source>
          <target state="translated">이를 통해 반복자가 데이터 종속성에 대해 추론하여 불필요한 사본을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fb73eae3981c0a0cbcb09d6d3ccfc761b4660a9a" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation.</source>
          <target state="translated">이 예제에서는 Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt; 를 사용하여 여러 스레드를 사용하여 배열을 채 웁니다. 스레드는 수명이 길기 때문에 반복 호출이 스레드 생성으로 인한 추가 오버 헤드를 필요로하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ff3d50ffaaf1fbc724fd92676a9a6bf2dd386440" translate="yes" xml:space="preserve">
          <source>This example makes use of Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt;&lt;code&gt;concurrent.futures&lt;/code&gt;&lt;/a&gt; to fill an array using multiple threads. Threads are long-lived so that repeated calls do not require any additional overheads from thread creation. The underlying BitGenerator is &lt;code&gt;PCG64&lt;/code&gt; which is fast, has a long period and supports using &lt;code&gt;PCG64.jumped&lt;/code&gt; to return a new generator while advancing the state. The random numbers generated are reproducible in the sense that the same seed will produce the same outputs.</source>
          <target state="translated">이 예제는 Python 3 &lt;a href=&quot;https://docs.python.org/dev/library/concurrent.futures.html#module-concurrent.futures&quot;&gt; &lt;code&gt;concurrent.futures&lt;/code&gt; &lt;/a&gt; 을 사용하여 여러 스레드를 사용하여 배열을 채 웁니다. 스레드는 오래 지속되므로 반복 호출에는 스레드 작성으로 인한 추가 오버 헤드가 필요하지 않습니다. 기본 BitGenerator는 &lt;code&gt;PCG64&lt;/code&gt; 이며, 속도가 빠르고, 오랜 기간이 있으며 , 상태를 진행하면서 새 생성기를 반환하기 위해 &lt;code&gt;PCG64.jumped&lt;/code&gt; 를 사용할 수 있습니다. 생성 된 난수는 동일한 시드가 동일한 출력을 생성한다는 의미에서 재현 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40004ca036e22114daf23d8e12216a484254a12b" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;converters&lt;/code&gt; can be used to convert a field with a trailing minus sign into a negative number.</source>
          <target state="translated">이 예제는 &lt;code&gt;converters&lt;/code&gt; 를 사용하여 후행 마이너스 기호가있는 필드를 음수로 변환하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="b788d751d6a8b5a6ea3f2e12485a26037e6ed998" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce Box-Muller normals using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">이 예제는 순수한 파이썬 구현을 사용하여 numba를 사용하여 Box-Muller 법선을 생성하는 방법을 보여줍니다. 난수는 &lt;code&gt;ctypes.next_double&lt;/code&gt; 로 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="c43d650067bf3f7811ad3426eb67449ba8f8d778" translate="yes" xml:space="preserve">
          <source>This example shows how numba can be used to produce gaussian samples using a pure Python implementation which is then compiled. The random numbers are provided by &lt;code&gt;ctypes.next_double&lt;/code&gt;.</source>
          <target state="translated">이 예제는 컴파일 된 순수 Python 구현을 사용하여 numba를 사용하여 가우스 샘플을 생성하는 방법을 보여줍니다. 난수는 &lt;code&gt;ctypes.next_double&lt;/code&gt; 에 의해 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="21f8a7f3cdbbf2fa9d3bdab5400251540901f919" translate="yes" xml:space="preserve">
          <source>This example shows how to create a ufunc for a structured array dtype. For the example we show a trivial ufunc for adding two arrays with dtype &amp;lsquo;u8,u8,u8&amp;rsquo;. The process is a bit different from the other examples since a call to &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;&lt;/a&gt; doesn&amp;rsquo;t fully register ufuncs for custom dtypes and structured array dtypes. We need to also call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt;&lt;/a&gt; to finish setting up the ufunc.</source>
          <target state="translated">이 예제는 구조화 된 배열 dtype에 대한 ufunc를 만드는 방법을 보여줍니다. 예를 들어 dtype 'u8, u8, u8'을 사용하여 두 개의 배열을 추가하는 간단한 ufunc를 보여줍니다. 이 프로세스는 &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_FromFuncAndData&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 에&lt;/a&gt; 대한 호출이 사용자 정의 dtype 및 구조화 된 배열 dtype에 대한 ufunc를 완전히 등록하지 않기 때문에 다른 예제와 약간 다릅니다 . &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForDescr&quot;&gt; &lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt; &lt;/a&gt; 설정을 완료하려면 PyUFunc_RegisterLoopForDescr 도 호출해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f7280fcf983a91daf5dc16e89c6643dc47e38c1" translate="yes" xml:space="preserve">
          <source>This example shows that a negative value can be returned when the input is an array of signed integers.</source>
          <target state="translated">이 예제는 입력이 부호있는 정수 배열 일 때 음수 값이 반환 될 수 있음을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="15659709a5e32bf1f77ae2078941bf91dc0f1586" translate="yes" xml:space="preserve">
          <source>This example uses a temporary file so that doctest doesn&amp;rsquo;t write files to your directory. You would use a &amp;lsquo;normal&amp;rsquo; filename.</source>
          <target state="translated">이 예제는 임시 파일을 사용하므로 doctest는 디렉토리에 파일을 쓰지 않습니다. '일반적인'파일 이름을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="c6a6109259025b3790be906b9d5fd08b4a7ddd22" translate="yes" xml:space="preserve">
          <source>This explanation of &lt;code&gt;fmt&lt;/code&gt; is not complete, for an exhaustive specification see &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fmt&lt;/code&gt; 에 대한이 설명은 완전하지 않습니다. 전체 사양은 &lt;a href=&quot;#r672d4d5b6143-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c6f060f066c80d886f242a9ad00dc6b69ec16949" translate="yes" xml:space="preserve">
          <source>This feature lets you make local decisions about when and how to split up streams without coordination between processes. You do not have to preallocate space to avoid overlapping or request streams from a common global service. This general &amp;ldquo;tree-hashing&amp;rdquo; scheme is &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;not unique to numpy&lt;/a&gt; but not yet widespread. Python has increasingly-flexible mechanisms for parallelization available, and this scheme fits in very well with that kind of use.</source>
          <target state="translated">이 기능을 사용하면 프로세스 간 조정없이 스트림을 분할 할시기와 방법에 대한 로컬 결정을 내릴 수 있습니다. 공통 글로벌 서비스의 겹침 또는 요청 스트림을 피하기 위해 공간을 사전 할당 할 필요는 없습니다. 이 일반적인 &quot;트리 해싱&quot;체계는 &lt;a href=&quot;https://www.iro.umontreal.ca/~lecuyer/myftp/papers/parallel-rng-imacs.pdf&quot;&gt;numpy에는 고유&lt;/a&gt; 하지 않지만 아직 널리 퍼져 있지는 않습니다. 파이썬은 점점 더 유연한 병렬화 메커니즘을 사용할 수 있으며,이 체계는 이러한 종류의 사용에 매우 적합합니다.</target>
        </trans-unit>
        <trans-unit id="1eaab0e05e888941195d61599512548e7a521f9d" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.14.5 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.14.5 by the correct version.</source>
          <target state="translated">이 파일에는 azure에서 빌드하고 anaconda.org에 업로드하기 위해 수정 된 Linux의 NumPy 1.14.5 릴리스에 대한 연습이 포함되어 있습니다. 명령은 명령 줄에 복사 할 수 있지만 1.14.5를 올바른 버전으로 바꾸어야합니다.</target>
        </trans-unit>
        <trans-unit id="ce7f900d77aa58f2ad5d408dd151ca95c6ec2123" translate="yes" xml:space="preserve">
          <source>This file contains a walkthrough of the NumPy 1.19.0 release on Linux, modified for building on azure and uploading to anaconda.org The commands can be copied into the command line, but be sure to replace 1.19.0 by the correct version.</source>
          <target state="translated">이 파일에는 azure에서 빌드하고 anaconda.org에 업로드하기 위해 수정 된 Linux의 NumPy 1.19.0 릴리스에 대한 연습이 포함되어 있습니다. 명령은 명령 줄에 복사 할 수 있지만 1.19.0을 올바른 버전으로 바꾸어야합니다.</target>
        </trans-unit>
        <trans-unit id="bbd2bf0596d8530c916e2a9e88d889eff818ebc6" translate="yes" xml:space="preserve">
          <source>This file gives an overview of what is necessary to build binary releases for NumPy.</source>
          <target state="translated">이 파일은 NumPy 용 바이너리 릴리스를 빌드하는 데 필요한 사항에 대한 개요를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="482a4249cfca9480f9fad090626bdeb4f2b9945b" translate="yes" xml:space="preserve">
          <source>This file is installed to the package installation directory.</source>
          <target state="translated">이 파일은 패키지 설치 디렉토리에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="53df6470e0b1cc077e937e47a1974181b9abe4c8" translate="yes" xml:space="preserve">
          <source>This flag can only be used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; when &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; is enabled. This is because without buffering, the inner loop is always the size of the innermost iteration dimension, and allowing it to get cut up would require special handling, effectively making it more like the buffered version.</source>
          <target state="translated">이 플래그는 사용할 수 있습니다 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 때 &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; 이&lt;/a&gt; 활성화됩니다. 버퍼링이 없으면 내부 루프는 항상 가장 안쪽 반복 차원의 크기이므로 잘라 내기 위해서는 특별한 처리가 필요하므로 효과적으로 버퍼링 된 버전과 비슷해집니다.</target>
        </trans-unit>
        <trans-unit id="b15ae805eec5e668ba73f9b0b01c1bc16e63444d" translate="yes" xml:space="preserve">
          <source>This flag has effect only if &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; is enabled on the iterator.</source>
          <target state="translated">이 플래그는 &lt;code&gt;NPY_ITER_COPY_IF_OVERLAP&lt;/code&gt; 가 반복자에서 사용 가능한 경우에만 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="9da2bfdfbda0e7663b5a969172c32a000741b205" translate="yes" xml:space="preserve">
          <source>This flag is incompatible with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 플래그는 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 와 호환되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f18364f6e6e63625675c7a8e617237459cb62263" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">기본 배열이 &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; 인 경우이&lt;/a&gt; 플래그는 true 입니다. 가능한 경우 계산을 단순화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dded0adeb2bd9373f814af71190afe223e5d417b" translate="yes" xml:space="preserve">
          <source>This flag is true if the underlying array is &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;. It is used to simplify calculations when possible.</source>
          <target state="translated">기본 배열이 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; 인 경우이&lt;/a&gt; 플래그는 true 입니다. 가능한 경우 계산을 단순화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bd5458653c4b0d4b9801dcf72f3813b331fc2dd" translate="yes" xml:space="preserve">
          <source>This flag is useful for arrays that must be in C-contiguous order and aligned. These kinds of arrays are usually input arrays for some algorithm.</source>
          <target state="translated">이 플래그는 C 연속 순서로 정렬되어야하는 배열에 유용합니다. 이러한 종류의 배열은 일반적으로 일부 알고리즘의 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="174700adc5b2ef69a266d85c159fde8b55bae281" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that is in C-contiguous order, is aligned, and can be written to as well. Such an array is usually returned as output (although normally such output arrays are created from scratch).</source>
          <target state="translated">이 플래그는 C- 연속적인 순서로 정렬되고 기록 될 수있는 배열을 지정하는 데 유용합니다. 이러한 배열은 일반적으로 출력으로 반환됩니다 (일반적으로 이러한 출력 배열은 처음부터 생성됨).</target>
        </trans-unit>
        <trans-unit id="5677601b0eb842974f94991fa89b82f29f0accae" translate="yes" xml:space="preserve">
          <source>This flag is useful to specify an array that will be used for both input and output. &lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; must be called before &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; at the end of the interface routine to write back the temporary data into the original array passed in. Use of the &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags requires that the input object is already an array (because other objects cannot be automatically updated in this fashion). If an error occurs use &lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; (obj) on an array with these flags set. This will set the underlying base array writable without causing the contents to be copied back into the original array.</source>
          <target state="translated">이 플래그는 입력과 출력 모두에 사용될 배열을 지정하는 데 유용합니다. &lt;a href=&quot;../reference/c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 는 전달 된 원래 배열에 임시 데이터를 다시 쓰려면 인터페이스 루틴의 끝에서 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; 전에 호출되어야합니다 . &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그를 사용하려면 입력 개체가 이미 배열이어야합니다 (다른 개체를 자동으로 업데이트 할 수 없기 때문). 이 방식으로). 오류가 발생하면 이러한 플래그가 설정된 배열에서 &lt;a href=&quot;../reference/c-api/array#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; (obj)를 사용 하십시오 . 이렇게하면 내용이 원래 배열로 다시 복사되지 않고 기본 기본 배열이 쓰기 가능하도록 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e07be9168d02cb1629420a221f75d6ebada0e23c" translate="yes" xml:space="preserve">
          <source>This flag only affects writing from the buffer back to the array. This means that if the operand is also &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt;, code doing iteration can write to this operand to control which elements will be untouched and which ones will be modified. This is useful when the mask should be a combination of input masks.</source>
          <target state="translated">이 플래그는 버퍼에서 어레이로의 쓰기에만 영향을줍니다. 즉, 피연산자가 &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; 인&lt;/a&gt; 경우 반복을 수행하는 코드는이 피연산자에 기록하여 어떤 요소가 손대지 않고 수정 될 요소를 제어 할 수 있습니다. 마스크가 입력 마스크의 조합이어야하는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="61e9f59feb262d0f073bfa393f7c68aa5599a46b" translate="yes" xml:space="preserve">
          <source>This form also makes it possible to specify struct dtypes with overlapping fields, functioning like the &amp;lsquo;union&amp;rsquo; type in C. This usage is discouraged, however, and the union mechanism is preferred.</source>
          <target state="translated">이 형식을 사용하면 C에서 'union'유형처럼 ​​작동하는 겹치는 필드로 struct dtype을 지정할 수 있습니다. 그러나 이러한 사용법은 권장되지 않으며 공용 메커니즘이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="0d302c80ebc9e23237f250ea17213abaf97a46db" translate="yes" xml:space="preserve">
          <source>This form is discouraged because Python dictionaries do not preserve order in Python versions before Python 3.6, and the order of the fields in a structured dtype has meaning. &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; may be specified by using a 3-tuple, see below.</source>
          <target state="translated">이 형식은 Python 사전이 Python 3.6 이전의 Python 버전에서 순서를 유지하지 않고 구조화 된 dtype의 필드 순서에 의미가 있기 때문에 권장되지 않습니다. &lt;a href=&quot;#titles&quot;&gt;필드 제목&lt;/a&gt; 은 3- 튜플을 사용하여 지정할 수 있습니다. 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eee7324318b68cf58364fb2712f6b7aa7bb3937e" translate="yes" xml:space="preserve">
          <source>This forms part of the old polynomial API. Since version 1.4, the new polynomial API defined in &lt;a href=&quot;../routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt; is preferred. A summary of the differences can be found in the &lt;a href=&quot;../routines.polynomials&quot;&gt;transition guide&lt;/a&gt;.</source>
          <target state="translated">이것은 이전 다항식 API의 일부를 형성합니다. 버전 1.4부터 &lt;a href=&quot;../routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 에&lt;/a&gt; 정의 된 새로운 다항식 API 가 선호됩니다. 차이점에 대한 요약은 &lt;a href=&quot;../routines.polynomials&quot;&gt;전환 가이드&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55ceb45713d06ac7d3696f87a18d50201d0b6641" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;obj&lt;/code&gt; and sets it as the base property of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">이 함수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;obj&lt;/code&gt; 에&lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔쳐 &lt;/strong&gt; &lt;code&gt;arr&lt;/code&gt; 의 기본 속성으로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d09c0732b811d51b99b90004b51ceb77de43b711" translate="yes" xml:space="preserve">
          <source>This function &lt;strong&gt;steals a reference&lt;/strong&gt; to &lt;code&gt;op&lt;/code&gt; and makes sure that &lt;code&gt;op&lt;/code&gt; is a base-class ndarray. It special cases array scalars, but otherwise calls &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;op&lt;/code&gt;, NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;, NULL).</source>
          <target state="translated">이 함수 &lt;strong&gt;는 &lt;/strong&gt; &lt;code&gt;op&lt;/code&gt; 에&lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔치고 &lt;/strong&gt; &lt;code&gt;op&lt;/code&gt; 가 기본 클래스 ndarray 인지 확인합니다 . 특수한 경우 배열 스칼라이지만 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 를&lt;/a&gt; 호출 합니다 ( &lt;code&gt;op&lt;/code&gt; , NULL, 0, 0, &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt; , NULL).</target>
        </trans-unit>
        <trans-unit id="39a0c64e238756c013e69a01cf344f4e1849a8a1" translate="yes" xml:space="preserve">
          <source>This function accepts but discards arguments &lt;code&gt;bias&lt;/code&gt; and &lt;code&gt;ddof&lt;/code&gt;. This is for backwards compatibility with previous versions of this function. These arguments had no effect on the return values of the function and can be safely ignored in this and previous versions of numpy.</source>
          <target state="translated">이 함수는 인수 &lt;code&gt;bias&lt;/code&gt; 및 &lt;code&gt;ddof&lt;/code&gt; 를 받아들이지 만 버립니다 . 이것은이 기능의 이전 버전과의 호환성을위한 것입니다. 이러한 인수는 함수의 반환 값에 영향을 미치지 않았으며이 버전 및 이전 버전의 numpy에서는 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="f2fa4598ed049a537ca6f0801826008a1fe6bde0" translate="yes" xml:space="preserve">
          <source>This function aims to be a fast reader for simply formatted files. The &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function provides more sophisticated handling of, e.g., lines with missing values.</source>
          <target state="translated">이 기능은 단순히 형식이 지정된 파일의 빠른 리더가되는 것을 목표로합니다. &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 함수는 결 측값 이있는 행을 보다 정교하게 처리합니다.</target>
        </trans-unit>
        <trans-unit id="ff21c5d7fbe80ce59f5b300cd13fc6a4fc144e9d" translate="yes" xml:space="preserve">
          <source>This function allows one set of bins to be computed, and reused across multiple histograms:</source>
          <target state="translated">이 함수를 사용하면 하나의 구간 세트를 계산하고 여러 히스토그램에서 재사용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a2a88415c2050cb4cd9564db4ec54b1d4908d16" translate="yes" xml:space="preserve">
          <source>This function allows the user to register a 1-d loop with an already- created ufunc to be used whenever the ufunc is called with any of its input arguments as the user-defined data-type. This is needed in order to make ufuncs work with built-in data-types. The data-type must have been previously registered with the numpy system. The loop is passed in as &lt;em&gt;function&lt;/em&gt;. This loop can take arbitrary data which should be passed in as &lt;em&gt;data&lt;/em&gt;. The data-types the loop requires are passed in as &lt;em&gt;arg_types&lt;/em&gt; which must be a pointer to memory at least as large as ufunc-&amp;gt;nargs.</source>
          <target state="translated">이 함수를 사용하면 ufunc를 입력 인수와 함께 사용자 정의 데이터 유형으로 호출 할 때마다 이미 작성된 ufunc와 함께 1-d 루프를 등록 할 수 있습니다. ufunc가 내장 데이터 유형과 작동하도록하기 위해 필요합니다. 데이터 유형은 이전에 numpy 시스템에 등록되어 있어야합니다. 루프는 &lt;em&gt;function으로&lt;/em&gt; 전달됩니다 . 이 루프로 전달되어야 할 임의의 데이터를 가지고 &lt;em&gt;데이터&lt;/em&gt; . 루프에 필요한 데이터 유형은 &lt;em&gt;arg_types&lt;/em&gt; 로 전달되며 , 최소한 ufunc-&amp;gt; nargs만큼 큰 메모리에 대한 포인터 여야합니다.</target>
        </trans-unit>
        <trans-unit id="f1576babab462c2253d07a719792b0ff878bb525" translate="yes" xml:space="preserve">
          <source>This function allows you to alter the tp_str and tp_repr methods of the array object to any Python function. Thus you can alter what happens for all arrays when str(arr) or repr(arr) is called from Python. The function to be called is passed in as &lt;em&gt;op&lt;/em&gt;. If &lt;em&gt;repr&lt;/em&gt; is non-zero, then this function will be called in response to repr(arr), otherwise the function will be called in response to str(arr). No check on whether or not &lt;em&gt;op&lt;/em&gt; is callable is performed. The callable passed in to &lt;em&gt;op&lt;/em&gt; should expect an array argument and should return a string to be printed.</source>
          <target state="translated">이 함수를 사용하면 배열 객체의 tp_str 및 tp_repr 메소드를 Python 함수로 변경할 수 있습니다. 따라서 str (arr) 또는 repr (arr)가 Python에서 호출 될 때 모든 배열에서 발생하는 상황을 변경할 수 있습니다. 호출 할 함수는 &lt;em&gt;op&lt;/em&gt; 로 전달됩니다 . 경우 &lt;em&gt;에 repr가&lt;/em&gt; 제로가 아닌,이 기능은 달리 함수가 STR (도착)에 응답하여 호출 될 것이다에 repr (도착)에 응답하여 호출 될 것이다. &lt;em&gt;op&lt;/em&gt; 호출 가능 여부에 대한 점검 이 수행 되지 않습니다 . &lt;em&gt;op에&lt;/em&gt; 전달 된 콜 러블 은 배열 인수를 예상하고 인쇄 할 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="3bb2d31f5b88cf1b316b3ceb02135e04993b15e9" translate="yes" xml:space="preserve">
          <source>This function assigns from the old to the new array by name, so the value of a field in the output array is the value of the field with the same name in the source array. This has the effect of creating a new ndarray containing only the fields &amp;ldquo;required&amp;rdquo; by the required_dtype.</source>
          <target state="translated">이 함수는 이름으로 이전 배열에서 새 배열로 할당하므로 출력 배열의 필드 값은 소스 배열에서 동일한 이름을 가진 필드의 값입니다. 이는 required_dtype에서 &quot;필수&quot;필드 만 포함하는 새 ndarray를 만드는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="12c8f95658bf6b7edc09d3adda4d0c4816cea136" translate="yes" xml:space="preserve">
          <source>This function behaves like PyUFunc_RegisterLoopForType above, except that it allows the user to register a 1-d loop using PyArray_Descr objects instead of dtype type num values. This allows a 1-d loop to be registered for structured array data-dtypes and custom data-types instead of scalar data-types.</source>
          <target state="translated">이 함수는 사용자가 dtype type num 값 대신 PyArray_Descr 객체를 사용하여 1-d 루프를 등록 할 수 있다는 점을 제외하고는 위의 PyUFunc_RegisterLoopForType과 같이 작동합니다. 이를 통해 스칼라 데이터 유형 대신 구조화 된 배열 데이터 유형 및 사용자 정의 데이터 유형에 1-d 루프를 등록 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6245a8e454db1361715a92d11f03ae0bff098bc" translate="yes" xml:space="preserve">
          <source>This function can be exponentially slow for some inputs, unless &lt;code&gt;max_work&lt;/code&gt; is set to a finite number or &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt;. If in doubt, use &lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt;&lt;code&gt;numpy.may_share_memory&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 &lt;code&gt;max_work&lt;/code&gt; 가 유한 수 또는 &lt;code&gt;MAY_SHARE_BOUNDS&lt;/code&gt; 로 설정 되지 않는 한 일부 입력에 대해 기하 급수적으로 느려질 수 있습니다 . 의심스러운 경우 사용 &lt;a href=&quot;numpy.may_share_memory#numpy.may_share_memory&quot;&gt; &lt;code&gt;numpy.may_share_memory&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="71ac25efd0c9fb7e70f813509afc2d6139c57b07" translate="yes" xml:space="preserve">
          <source>This function changes the fill value of the masked array &lt;code&gt;a&lt;/code&gt; in place. If &lt;code&gt;a&lt;/code&gt; is not a masked array, the function returns silently, without doing anything.</source>
          <target state="translated">이 함수는 마스크 배열 &lt;code&gt;a&lt;/code&gt; 의 채우기 값을 제자리에서 변경합니다 . &lt;code&gt;a&lt;/code&gt; 가 마스킹 된 배열이 아닌 경우 함수는 아무 작업도하지 않고 자동으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="dc2a1bc44c01911d64ceae9284770c887ff15ab1" translate="yes" xml:space="preserve">
          <source>This function checks to see if &lt;em&gt;arr&lt;/em&gt; is a 0-dimensional array and, if so, returns the appropriate array scalar. It should be used whenever 0-dimensional arrays could be returned to Python.</source>
          <target state="translated">이 함수는 &lt;em&gt;arr&lt;/em&gt; 이 0 차원 배열인지 확인하고, 그렇다면 적절한 배열 스칼라를 반환합니다. 0 차원 배열을 파이썬으로 반환 할 때마다 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e0d86a376dbbcdcd20b9ab0ced8ac2eae8ffe8a" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;N&lt;/em&gt;-dimensional discrete Fourier Transform over any number of axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT).</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform) 를 사용하여 &lt;em&gt;M&lt;/em&gt; 차원 배열의 여러 축에 대해 &lt;em&gt;N&lt;/em&gt; 차원 이산 푸리에 변환을 계산합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f34d917f1e7128a56a07b81dc929875f904b8a8c" translate="yes" xml:space="preserve">
          <source>This function computes the &lt;em&gt;n&lt;/em&gt;-dimensional discrete Fourier Transform over any axes in an &lt;em&gt;M&lt;/em&gt;-dimensional array by means of the Fast Fourier Transform (FFT). By default, the transform is computed over the last two axes of the input array, i.e., a 2-dimensional FFT.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform) 를 사용하여 &lt;em&gt;M&lt;/em&gt; 차원 배열의 모든 축에 대해 &lt;em&gt;n&lt;/em&gt; 차원 이산 푸리에 변환을 계산합니다 . 기본적으로 변환은 입력 배열의 마지막 두 축, 즉 2 차원 FFT에 대해 계산됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b8915bccc6bfc2e5b959f002fb985788d011a64f" translate="yes" xml:space="preserve">
          <source>This function computes the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional real array by means of the Fast Fourier Transform (FFT). By default, all axes are transformed, with the real transform performed over the last axis, while the remaining transforms are complex.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 실수 배열의 여러 축에 대해 N 차원 이산 푸리에 변환을 계산합니다. 기본적으로 모든 축은 마지막 축에 대해 실제 변환이 수행되고 나머지 변환은 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="b8c7b22438d176337766fd2e49c4b7cfc3e07bab" translate="yes" xml:space="preserve">
          <source>This function computes the correlation as generally defined in signal processing texts:</source>
          <target state="translated">이 함수는 신호 처리 텍스트에 일반적으로 정의 된 상관 관계를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cd6ec7a4da9a308e6c6acab0d22d9735b9865d50" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the 2-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; to within numerical accuracy. By default, the inverse transform is computed over the last two axes of the input array.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 배열의 여러 축에 대해 2 차원 이산 푸리에 변환의 역을 계산합니다. 즉, &lt;code&gt;ifft2(fft2(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. 기본적으로 역변환은 입력 배열의 마지막 두 축에 대해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="1a4ebaf525beaf877d17151690d3a34bb9c59baf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform for real input over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; to within numerical accuracy. (The &lt;code&gt;a.shape&lt;/code&gt; is necessary like &lt;code&gt;len(a)&lt;/code&gt; is for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, and for the same reason.)</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 배열의 여러 축에 대한 실제 입력에 대해 N 차원 이산 푸리에 변환의 역을 계산합니다. 즉, &lt;code&gt;irfftn(rfftn(a), a.shape) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. ( &lt;code&gt;len(a)&lt;/code&gt; 가 &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; 와 같은 이유로 a. &lt;code&gt;a.shape&lt;/code&gt; 이 필요 합니다.)</target>
        </trans-unit>
        <trans-unit id="0c7a0cee522d4ce9c957b628834b82e1d28defa5" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the N-dimensional discrete Fourier Transform over any number of axes in an M-dimensional array by means of the Fast Fourier Transform (FFT). In other words, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; to within numerical accuracy. For a description of the definitions and conventions used, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)를 사용하여 M 차원 배열의 여러 축에 대해 N 차원 이산 푸리에 변환의 역을 계산합니다. 즉, &lt;code&gt;ifftn(fftn(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. 사용 된 정의 및 규칙에 대한 설명은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b2f9d73633ea8b8eb82a0685fcd08ea3505d9a66" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform of real input computed by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; to within numerical accuracy. (See Notes below for why &lt;code&gt;len(a)&lt;/code&gt; is necessary here.)</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; 로&lt;/a&gt; 계산 된 실제 입력 의 1 차원 &lt;em&gt;n-&lt;/em&gt; 포인트 이산 푸리에 변환의 역을 계산합니다 . 즉, &lt;code&gt;irfft(rfft(a), len(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. ( 여기서 &lt;code&gt;len(a)&lt;/code&gt; 가 필요한 이유는 아래 참고 사항을 참조 하십시오.)</target>
        </trans-unit>
        <trans-unit id="82bfb7db090395ddadcdd09fad9b5160012346cf" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 로 계산 된 1 차원 &lt;em&gt;n&lt;/em&gt; 점 이산 푸리에 변환 의 역을 계산합니다 . 즉, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; 는 수치 정확도 이내입니다. 알고리즘 및 정의에 대한 일반적인 설명은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="35acba32b3eea01535885b216d423da5ad809ed9" translate="yes" xml:space="preserve">
          <source>This function computes the inverse of the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier transform computed by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;. In other words, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; to within numerical accuracy. For a general description of the algorithm and definitions, see &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수 는 &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 로 계산 된 1 차원 &lt;em&gt;n-&lt;/em&gt; 포인트 이산 푸리에 변환 의 역을 계산합니다 . 즉, &lt;code&gt;ifft(fft(a)) == a&lt;/code&gt; 에서 숫자 정확도 내에 있습니다. 알고리즘 및 정의에 대한 일반적인 설명은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ad9d7d69d57ac9facd5b4f82ac6ba6f908913a31" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) of a real-valued array by means of an efficient algorithm called the Fast Fourier Transform (FFT).</source>
          <target state="translated">이 함수는 FFT (Fast Fourier Transform)라고하는 효율적인 알고리즘을 통해 실수 배열 의 1 차원 &lt;em&gt;n&lt;/em&gt; 포인트 이산 푸리에 변환 (DFT)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="68ec181d19ee1190284573e044b4ba392f94f385" translate="yes" xml:space="preserve">
          <source>This function computes the one-dimensional &lt;em&gt;n&lt;/em&gt;-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT].</source>
          <target state="translated">이 함수 는 효율적인 고속 푸리에 변환 (FFT) 알고리즘 [CT]을 사용 하여 1 차원 &lt;em&gt;n&lt;/em&gt; 포인트 이산 푸리에 변환 (DFT)을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="30a498de56241e50f5fd1a10939273e87357615d" translate="yes" xml:space="preserve">
          <source>This function continues to be supported for backward compatibility, but you should prefer &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt;. The &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt;&lt;code&gt;moveaxis&lt;/code&gt;&lt;/a&gt; function was added in NumPy 1.11.</source>
          <target state="translated">이 기능은 이전 버전과의 호환성을 위해 계속 지원되지만 &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt; 를 선호해야합니다 . 이동 &lt;a href=&quot;numpy.moveaxis#numpy.moveaxis&quot;&gt; &lt;code&gt;moveaxis&lt;/code&gt; &lt;/a&gt; 기능은 NumPy 1.11에 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="307209890a37b51bcd317c1d8679c25cf8cf32dc" translate="yes" xml:space="preserve">
          <source>This function creates a new neighborhood iterator from an existing iterator. The neighborhood will be computed relatively to the position currently pointed by &lt;em&gt;iter&lt;/em&gt;, the bounds define the shape of the neighborhood iterator, and the mode argument the boundaries handling mode.</source>
          <target state="translated">이 함수는 기존 이터레이터에서 새 네이버 이터레이터를 만듭니다. 이웃은 현재 &lt;em&gt;iter가&lt;/em&gt; 가리키는 위치에 상대적으로 계산됩니다.&lt;em&gt;&lt;/em&gt; , 경계는 이웃 반복기의 모양을 정의하며 모드 인수는 경계 처리 모드입니다.</target>
        </trans-unit>
        <trans-unit id="33522609896e19e2c62ce4cc185c0f8e169d65db" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt;&lt;code&gt;zeros_like&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt;&lt;code&gt;ones_like&lt;/code&gt;&lt;/a&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">이 함수는 반환 된 배열을 초기화 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그렇게하려면 대신 &lt;a href=&quot;numpy.zeros_like#numpy.zeros_like&quot;&gt; &lt;code&gt;zeros_like&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.ones_like#numpy.ones_like&quot;&gt; &lt;code&gt;ones_like&lt;/code&gt; 를&lt;/a&gt; 사용하십시오. 배열 값을 설정하는 함수보다 약간 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0decc5010e2e82ceb19b7a45f9d7da5f4f237524" translate="yes" xml:space="preserve">
          <source>This function does &lt;em&gt;not&lt;/em&gt; initialize the returned array; to do that use &lt;code&gt;zeros_like&lt;/code&gt; or &lt;code&gt;ones_like&lt;/code&gt; instead. It may be marginally faster than the functions that do set the array values.</source>
          <target state="translated">이 함수는 반환 된 배열을 초기화 하지 &lt;em&gt;않습니다&lt;/em&gt; . 그렇게하려면 대신 &lt;code&gt;zeros_like&lt;/code&gt; 또는 &lt;code&gt;ones_like&lt;/code&gt; 를 사용하십시오. 배열 값을 설정하는 함수보다 약간 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="960581e2e13399cd79a7bf3c883aeb7b8d2e979d" translate="yes" xml:space="preserve">
          <source>This function does not check the contents of the input, only that the type is MaskType. In particular, this function returns False if the mask has a flexible dtype.</source>
          <target state="translated">이 함수는 입력 내용을 확인하지 않고 유형이 MaskType 만됩니다. 특히이 함수는 마스크에 유연한 dtype이있는 경우 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a232150acd8a12e027d94aeed56f5ff4aae9f46" translate="yes" xml:space="preserve">
          <source>This function does not enforce that the blocks lie on a fixed grid. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; is not restricted to arrays of the form:</source>
          <target state="translated">이 기능은 블록이 고정 그리드에 놓 이도록 강제하지 않습니다. &lt;code&gt;np.block([[a, b], [c, d]])&lt;/code&gt; 는 다음 형식의 배열로 제한되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dc40074e04bdcad2b344dd285961cdc7ff85df9" translate="yes" xml:space="preserve">
          <source>This function does not losslessly round-trip in either direction.</source>
          <target state="translated">이 기능은 어느 방향으로도 손실없이 왕복하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b71c712d42350c6a8a0c257c490e077558876dad" translate="yes" xml:space="preserve">
          <source>This function encapsulates the broadcasting rules. The &lt;em&gt;mit&lt;/em&gt; container should already contain iterators for all the arrays that need to be broadcast. On return, these iterators will be adjusted so that iteration over each simultaneously will accomplish the broadcasting. A negative number is returned if an error occurs.</source>
          <target state="translated">이 기능은 브로드 캐스트 규칙을 캡슐화합니다. &lt;em&gt;MIT의&lt;/em&gt; 컨테이너는 이미 필요가 방송 될하는 모든 배열에 대한 반복자를 포함해야합니다. 돌아 왔을 때,이 반복자는 각각의 반복이 방송을 달성하도록 조정될 것이다. 오류가 발생하면 음수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9bf48997cebca64928a72fe75ea6eb1ebc70dbfb" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, AssertionError is not raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">이 함수는 NaN이 &quot;정상&quot;숫자 인 것처럼 NaN 비교를 처리합니다. 즉, 두 개체가 같은 위치에 NaN이있는 경우 AssertionError가 발생하지 않습니다. 이것은 NaN에 대한 IEEE 표준과 대조적입니다. 즉, NaN은 어떤 것과 비교해도 False를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="b02f77dc9fbab1956d3050387654fd71594ea916" translate="yes" xml:space="preserve">
          <source>This function handles NaN comparisons as if NaN was a &amp;ldquo;normal&amp;rdquo; number. That is, no assertion is raised if both objects have NaNs in the same positions. This is in contrast to the IEEE standard on NaNs, which says that NaN compared to anything must return False.</source>
          <target state="translated">이 함수는 NaN이 &quot;정상&quot;숫자 인 것처럼 NaN 비교를 처리합니다. 즉, 두 개체의 NaN이 같은 위치에 있으면 어설 션이 발생하지 않습니다. 이는 NaN의 IEEE 표준과 달리 NaN은 다른 것과 비교하여 False를 반환해야한다고 말합니다.</target>
        </trans-unit>
        <trans-unit id="d5f910d97d6aeb7075f641616a02d523dd4438a4" translate="yes" xml:space="preserve">
          <source>This function has been deprecated. Use randint instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않습니다. 대신 randint를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="77fe5df00c0c7c8132af4661573c5a4cca000d13" translate="yes" xml:space="preserve">
          <source>This function has to be used with extreme care, see notes.</source>
          <target state="translated">이 기능은 매우주의해서 사용해야합니다. 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eade9f90c736ff6d6151ab5c5bf1151931416ec5" translate="yes" xml:space="preserve">
          <source>This function instead copies &amp;ldquo;by field name&amp;rdquo;, such that fields in the dst are assigned from the identically named field in the src. This applies recursively for nested structures. This is how structure assignment worked in numpy &amp;gt;= 1.6 to &amp;lt;= 1.13.</source>
          <target state="translated">대신이 함수는 &quot;필드 이름 별&quot;을 복사하여 dst의 필드가 src의 동일하게 명명 된 필드에서 할당되도록합니다. 이것은 중첩 된 구조에 대해 재귀 적으로 적용됩니다. 이것이 구조 할당이 numpy&amp;gt; = 1.6에서 &amp;lt;= 1.13까지 작동하는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="965a01bc9232ab2e9c3c470747ee3c2312761abb" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes.</source>
          <target state="translated">이 함수는 tobytes의 호환성 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="a3014854fc3aff1db547e25e4accc358bdc45e8a" translate="yes" xml:space="preserve">
          <source>This function is a compatibility alias for tobytes. Despite its name it returns bytes not strings.</source>
          <target state="translated">이 함수는 tobytes의 호환성 별칭입니다. 이름에도 불구하고 문자열이 아닌 바이트를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5bced6280c853e5763696660107e62b1e9050b26" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 0.</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;mask_rowcols&lt;/code&gt; 와 &lt;code&gt;axis&lt;/code&gt; 0 같다.</target>
        </trans-unit>
        <trans-unit id="892aad8c63a29b7082fcd31d81f9eafb9d342e8e" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;mask_rowcols&lt;/code&gt; with &lt;code&gt;axis&lt;/code&gt; equal to 1.</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;mask_rowcols&lt;/code&gt; 와 &lt;code&gt;axis&lt;/code&gt; (1)과 동일.</target>
        </trans-unit>
        <trans-unit id="ebac1dd8653756fd79c832147de01fce0d7f87ae" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x != value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 으로, &lt;code&gt;condition&lt;/code&gt; = (X! = 값).</target>
        </trans-unit>
        <trans-unit id="ab411b054ab6959d52991c7253cba72df24e6757" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt; value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (x&amp;gt; 값).</target>
        </trans-unit>
        <trans-unit id="bf30dbf11727720fe8d30e29bf375cde077485f8" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;gt;= value).</source>
          <target state="translated">이 기능에 대한 바로 가기입니다 &lt;code&gt;masked_where&lt;/code&gt; 으로, &lt;code&gt;condition&lt;/code&gt; = (x&amp;gt; = 값).</target>
        </trans-unit>
        <trans-unit id="af1053b8f0ec97d05015f270566c5b82959272a7" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt; value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (X &amp;lt;값).</target>
        </trans-unit>
        <trans-unit id="f9189002c6a19182c690d1c6efc00b46a33f7232" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x &amp;lt;= value).</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (X &amp;lt;= 값).</target>
        </trans-unit>
        <trans-unit id="f46637928627180e5c802e1527edd637c13a58b6" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = (x == value). For floating point arrays, consider using &lt;code&gt;masked_values(x, value)&lt;/code&gt;.</source>
          <target state="translated">이 기능의 바로 가기 인 &lt;code&gt;masked_where&lt;/code&gt; 와, &lt;code&gt;condition&lt;/code&gt; = (X == 값). 부동 소수점 배열의 경우 &lt;code&gt;masked_values(x, value)&lt;/code&gt; 사용을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4434dee55a64bbfebaafbec40077ada7cc2e4b4" translate="yes" xml:space="preserve">
          <source>This function is a shortcut to &lt;code&gt;masked_where&lt;/code&gt;, with &lt;code&gt;condition&lt;/code&gt; = ~(np.isfinite(a)). Any pre-existing mask is conserved. Only applies to arrays with a dtype where NaNs or infs make sense (i.e. floating point types), but accepts any array_like object.</source>
          <target state="translated">이 기능에 대한 바로 가기입니다 &lt;code&gt;masked_where&lt;/code&gt; 과 &lt;code&gt;condition&lt;/code&gt; = ~ (np.isfinite의 (a)). 기존 마스크는 보존됩니다. NaN 또는 infs가 의미가있는 (즉, 부동 소수점 유형) dtype을 가진 배열에만 적용되지만 array_like 객체를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="f28b126f5c6b2ce96d11bc92753f383ad4cd6485" translate="yes" xml:space="preserve">
          <source>This function is able to return one of eight different matrix norms, or one of an infinite number of vector norms (described below), depending on the value of the &lt;code&gt;ord&lt;/code&gt; parameter.</source>
          <target state="translated">이 함수는 &lt;code&gt;ord&lt;/code&gt; 매개 변수 의 값에 따라 8 개의 서로 다른 행렬 규범 중 하나 또는 무한한 수의 벡터 규범 중 하나를 반환 할 수 있습니다 (아래 설명 참조) .</target>
        </trans-unit>
        <trans-unit id="c1758140bc8fa9fd28fc8bc131c3f6321c42d5db" translate="yes" xml:space="preserve">
          <source>This function is capable of returning the condition number using one of seven different norms, depending on the value of &lt;code&gt;p&lt;/code&gt; (see Parameters below).</source>
          <target state="translated">이 함수는 &lt;code&gt;p&lt;/code&gt; 값에 따라 7 가지 표준 중 하나를 사용하여 조건 번호를 반환 할 수 있습니다 (아래 매개 변수 참조).</target>
        </trans-unit>
        <trans-unit id="7f257a627b846a11d8d82d4b0986234672c8d024" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; 인수 에 따라 마스크 된 값이 같거나 (기본값) 같지 &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 점을 제외하고 allclose 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="dd8713725fce28207d278a6136fdd184217d0bb8" translate="yes" xml:space="preserve">
          <source>This function is equivalent to &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; except that masked values are treated as equal (default) or unequal, depending on the &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; 인수 에 따라 마스크 된 값이 같거나 (기본값) 같지 않은 것으로 처리 &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 점을 제외 하면 allclose 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="a3debc8695bd72584953abb12e719fb90548f7dd" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 &quot;compressed&quot;메서드를 호출하는 것과 같습니다 . 자세한 내용 은 &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;MaskedArray.compressed&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5a91f899ffc50b531674413c041bb92c6104a7d" translate="yes" xml:space="preserve">
          <source>This function is equivalent to calling the &amp;ldquo;compressed&amp;rdquo; method of a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;ma.MaskedArray&lt;/code&gt;&lt;/a&gt;, see &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt;&lt;code&gt;ma.MaskedArray.compressed&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;ma.MaskedArray&lt;/code&gt; &lt;/a&gt; 의 &quot;compressed&quot;메서드를 호출하는 것과 동일합니다 . 자세한 내용 은 &lt;a href=&quot;numpy.ma.maskedarray.compressed#numpy.ma.MaskedArray.compressed&quot;&gt; &lt;code&gt;ma.MaskedArray.compressed&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="614f9af44de8bf025b95f7feb6cfbfad93376ecb" translate="yes" xml:space="preserve">
          <source>This function is equivalent to tuple axis arguments to reorderable ufuncs with keepdims=True. Tuple axis arguments to ufuncs have been available since version 1.7.0.</source>
          <target state="translated">이 함수는 keepdims = True 인 튜플 축 인수와 재정렬 가능한 ufunc에 해당합니다. ufunc에 대한 튜플 축 인수는 버전 1.7.0부터 사용 가능합니다.</target>
        </trans-unit>
        <trans-unit id="3c5d87f95304bba4f22f4f3bc79a0366620caeda" translate="yes" xml:space="preserve">
          <source>This function is exactly equivalent to &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt; 와 정확히 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="0a042d76cb2129f19b61e5085381910d8b99bdbc" translate="yes" xml:space="preserve">
          <source>This function is intended to be used in EXTERNAL_LOOP mode only, and will produce some wrong answers when that mode is not enabled.</source>
          <target state="translated">이 기능은 EXTERNAL_LOOP 모드에서만 사용되도록 고안되었으며 해당 모드가 활성화되어 있지 않은 경우 잘못된 응답을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="d3aeb8a347cc701a9fec8946ae6c740c1103bc20" translate="yes" xml:space="preserve">
          <source>This function is not defined for complex-valued arguments; for the so-called argument of complex values, use &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt;&lt;code&gt;angle&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 복소수 인수에 대해 정의되지 않았습니다. 소위 복잡한 값의 인수에는 &lt;a href=&quot;numpy.angle#numpy.angle&quot;&gt; &lt;code&gt;angle&lt;/code&gt; 을&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="42c780622358a45155401477993b5d9d0b335549" translate="yes" xml:space="preserve">
          <source>This function is not designed to work with integers.</source>
          <target state="translated">이 함수는 정수와 함께 작동하도록 설계되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ea62cc16ec217ef39d7f7c8e5969148da37fd3a3" translate="yes" xml:space="preserve">
          <source>This function is not implemented yet.</source>
          <target state="translated">이 기능은 아직 구현되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b2f9356116ad7b6b9ba74a0d07b768457fca53e0" translate="yes" xml:space="preserve">
          <source>This function is obsolete and, because of changes due to relaxed stride checking, its return value for the same array may differ for versions of NumPy &amp;gt;= 1.10.0 and previous versions. If you only want to check if an array is Fortran contiguous use &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; instead.</source>
          <target state="translated">이 기능은 더 이상 사용되지 않으며 보폭 점검으로 인한 변경으로 인해 동일한 어레이에 대한 반환 값이 NumPy&amp;gt; = 1.10.0 버전과 이전 버전에서 다를 수 있습니다. 배열이 포트란 연속인지 만 확인하려면 &lt;code&gt;a.flags.f_contiguous&lt;/code&gt; 를 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="258358cbdd467c9c344ce8e3f9c85d0cd7f428e4" translate="yes" xml:space="preserve">
          <source>This function is similar to &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt;, but only suitable for object arrays: for floating point, use &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt;&lt;code&gt;masked_values&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; &lt;/a&gt; 와 유사 하지만 객체 배열에만 적합합니다. 부동 소수점의 경우 대신 &lt;a href=&quot;numpy.ma.masked_values#numpy.ma.masked_values&quot;&gt; &lt;code&gt;masked_values&lt;/code&gt; 를&lt;/a&gt; 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="42e4240c2bc84555a7f741757d674e8c82e565ad" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; 으로&lt;/a&gt; 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="f3e20de601f3ca24a5ff2472df08d779de8dd632" translate="yes" xml:space="preserve">
          <source>This function is superceded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="223dd6fd50941f5cca2c485c95e8e5dc687d05fb" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt;&lt;code&gt;PyArray_MinScalarType&lt;/code&gt;&lt;/a&gt; and/or &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#c.PyArray_MinScalarType&quot;&gt; &lt;code&gt;PyArray_MinScalarType&lt;/code&gt; &lt;/a&gt; 및 / 또는 &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; 으로&lt;/a&gt; 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc0b6a66579ee7b8e064413a2fb5429da45dba58" translate="yes" xml:space="preserve">
          <source>This function is superseded by &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt;&lt;code&gt;PyArray_ResultType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;a href=&quot;#c.PyArray_ResultType&quot;&gt; &lt;code&gt;PyArray_ResultType&lt;/code&gt; &lt;/a&gt; 으로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="5b1ff7898f391050d07732317e1b4b4bc976ee58" translate="yes" xml:space="preserve">
          <source>This function is symmetric, but rarely associative.</source>
          <target state="translated">이 기능은 대칭이지만 연관성이 거의 없습니다.</target>
        </trans-unit>
        <trans-unit id="fb34e601302a103a0946045a1719e9ad4309bf62" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;numpy.diag&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 기능의 상당 &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; &lt;/a&gt; 참조 고려 마스크 값을 얻어 &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;numpy.diag&lt;/code&gt; 를&lt;/a&gt; 세부 사항.</target>
        </trans-unit>
        <trans-unit id="762735a831cc238bcd6be4852c06ac0013225a54" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; that takes masked values into account. Note that &lt;code&gt;strict&lt;/code&gt; and &lt;code&gt;out&lt;/code&gt; are in different position than in the method version. In order to maintain compatibility with the corresponding method, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">이 함수는 마스크 된 값을 고려한 &lt;a href=&quot;numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 참고 것을 &lt;code&gt;strict&lt;/code&gt; 하고 &lt;code&gt;out&lt;/code&gt; 방법 버전과 다른 위치에 있습니다. 해당 메소드와의 호환성을 유지하려면 선택적 인수를 키워드로만 처리하는 것이 좋습니다. 어떤 시점에서는 필수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b3449fce446ccae1d5ae6c6d55107b82701f20fd" translate="yes" xml:space="preserve">
          <source>This function is the equivalent of &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; that takes masked values into account, see &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt;&lt;code&gt;numpy.ediff1d&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이 기능의 상당 &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt; 참조 고려 마스크 값을 얻어 &lt;a href=&quot;numpy.ediff1d#numpy.ediff1d&quot;&gt; &lt;code&gt;numpy.ediff1d&lt;/code&gt; &lt;/a&gt; 세부 사항.</target>
        </trans-unit>
        <trans-unit id="fc125d9cdb2114a10df5933b4e6f500d1c08539d" translate="yes" xml:space="preserve">
          <source>This function is used to simplify access to fields nested in other fields.</source>
          <target state="translated">이 함수는 다른 필드에 중첩 된 필드에 대한 액세스를 단순화하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="48492051f92b9e0c98dfd72175da1464af62c22d" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the maximum of an array with a given dtype.</source>
          <target state="translated">이 함수는 주어진 dtype으로 최대 배열을 가져 오기에 적합한 채우기 값을 계산하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="eeb9d1e68f6032230d3ff5e76ccad6bac584a6b3" translate="yes" xml:space="preserve">
          <source>This function is useful for calculating a fill value suitable for taking the minimum of an array with a given dtype.</source>
          <target state="translated">이 함수는 주어진 dtype으로 배열의 최소값을 취하는 데 적합한 채우기 값을 계산하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="514144ea48299b81c7b15dfcf631d31668bd3186" translate="yes" xml:space="preserve">
          <source>This function is useful for determining a common type that two or more arrays can be converted to. It only works for non-flexible array types as no itemsize information is passed. The &lt;em&gt;mintype&lt;/em&gt; argument represents the minimum type acceptable, and &lt;em&gt;op&lt;/em&gt; represents the object that will be converted to an array. The return value is the enumerated typenumber that represents the data-type that &lt;em&gt;op&lt;/em&gt; should have.</source>
          <target state="translated">이 기능은 둘 이상의 배열을 변환 할 수있는 공통 유형을 결정하는 데 유용합니다. itemize 정보가 전달되지 않으므로 비 유연한 배열 유형에서만 작동합니다. &lt;em&gt;mintype의&lt;/em&gt; 인수는 최소 허용 형 나타내고, &lt;em&gt;OP는&lt;/em&gt; 배열로 변환 될 객체를 나타낸다. 반환 값은 &lt;em&gt;op에&lt;/em&gt; 있어야 하는 데이터 형식을 나타내는 열거 된 형식 번호입니다 .</target>
        </trans-unit>
        <trans-unit id="66ea2fa9dfd3553ca39f3787970de46499229028" translate="yes" xml:space="preserve">
          <source>This function is useful to be sure that an array with the correct flags is returned for passing to compiled code (perhaps through ctypes).</source>
          <target state="translated">이 함수는 컴파일 된 코드 (아마 ctypes를 통해)에 전달하기 위해 올바른 플래그를 가진 배열이 반환되도록하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e9b1bcfe6f895f9426e7973caf7f080e53d5b02" translate="yes" xml:space="preserve">
          <source>This function is very similar to &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; above, but has an extra &lt;em&gt;identity_value&lt;/em&gt; argument, to define an arbitrary identity for the ufunc when &lt;code&gt;identity&lt;/code&gt; is passed as &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;.</source>
          <target state="translated">이 함수는 위의 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 와 매우 유사 하지만 , &lt;code&gt;identity&lt;/code&gt; 가 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 로 전달 될 때 ufunc에 대한 임의의 ID를 정의하기 위해 추가 &lt;em&gt;identity_value&lt;/em&gt; 인수 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6ae878f05630a69160b11c652744c88c73b83f7" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">이 함수는 위의 PyUFunc_FromFuncAndData와 매우 유사하지만 &lt;a href=&quot;c-api.generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;일반화 된 범용 함수&lt;/a&gt; 를 정의하기 위한 추가 &lt;em&gt;서명&lt;/em&gt; 인수가 있습니다 . 요소 별 작업을 중심으로 ufunc가 작성되는 방식과 유사하게 gufuncs는 하위 배열 별 하위 작업 을 중심으로 작동하며 하위 배열을 정의하는 &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;시그니처&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7d7c3c059d66b50ac25de48e14a9110e6ed62010" translate="yes" xml:space="preserve">
          <source>This function is very similar to PyUFunc_FromFuncAndData above, but has an extra &lt;em&gt;signature&lt;/em&gt; argument, to define a &lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;generalized universal functions&lt;/a&gt;. Similarly to how ufuncs are built around an element-by-element operation, gufuncs are around subarray-by-subarray operations, the &lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; defining the subarrays to operate on.</source>
          <target state="translated">이 함수는 위의 PyUFunc_FromFuncAndData와 매우 유사하지만 &lt;a href=&quot;generalized-ufuncs#c-api-generalized-ufuncs&quot;&gt;일반화 된 범용 함수&lt;/a&gt; 를 정의하기 위한 추가 &lt;em&gt;서명&lt;/em&gt; 인수가 있습니다 . 요소 별 연산을 중심으로 ufunc를 구축하는 방법과 유사하게, gufuncs는 하위 배열 별 연산, 작동 할 하위 배열을 정의하는 &lt;a href=&quot;generalized-ufuncs#details-of-signature&quot;&gt;서명&lt;/a&gt; 을 중심으로합니다.</target>
        </trans-unit>
        <trans-unit id="0dc77b4e140ac75bc9ac3e89d41f38fc73185d22" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.block#numpy.block&quot;&gt;&lt;code&gt;block&lt;/code&gt;&lt;/a&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">이 기능은 최대 3 차원 배열에 가장 적합합니다. 예를 들어 높이 (첫 번째 축), 너비 (두 번째 축) 및 r / g / b 채널 (세 번째 축)이있는 픽셀 데이터의 경우 &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.stack#numpy.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.block#numpy.block&quot;&gt; &lt;code&gt;block&lt;/code&gt; &lt;/a&gt; 기능 은보다 일반적인 스택 및 연결 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f7b019770de00d4d47b09eabe135d2ae721a995a" translate="yes" xml:space="preserve">
          <source>This function makes most sense for arrays with up to 3 dimensions. For instance, for pixel-data with a height (first axis), width (second axis), and r/g/b channels (third axis). The functions &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt;&lt;code&gt;stack&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;block&lt;/code&gt; provide more general stacking and concatenation operations.</source>
          <target state="translated">이 기능은 최대 3 차원 배열에 가장 적합합니다. 예를 들어 높이 (첫 번째 축), 너비 (두 번째 축) 및 r / g / b 채널 (세 번째 축)이있는 픽셀 데이터의 경우 &lt;a href=&quot;numpy.ma.concatenate#numpy.ma.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.ma.stack#numpy.ma.stack&quot;&gt; &lt;code&gt;stack&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;block&lt;/code&gt; 기능 은보다 일반적인 스택 및 연결 작업을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f15e5fa1742619380116b3f34a00c85d55366c55" translate="yes" xml:space="preserve">
          <source>This function may also be used as a decorator.</source>
          <target state="translated">이 함수는 데코레이터로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d585b637d27940cc37d90ebf4940a9aa2e521b5d" translate="yes" xml:space="preserve">
          <source>This function may be safely called without holding the Python GIL.</source>
          <target state="translated">이 함수는 Python GIL을 유지하지 않고도 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd200e9dfe3f17be99d159e426b6fa9331db61ec" translate="yes" xml:space="preserve">
          <source>This function may only be called if the iterator is tracking a multi-index and if &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt; was used to prevent an axis from being iterated in reverse order.</source>
          <target state="translated">이 함수는 반복자가 다중 인덱스를 추적하고 축이 역순으로 반복되는 것을 방지하기 위해 &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt; 를 사용한 경우에만 호출 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6ca18036fbf762cae2043baf8ac3fa8494d28495" translate="yes" xml:space="preserve">
          <source>This function must be called in the initialization section of a module that will make use of the C-API. It imports the module where the function-pointer table is stored and points the correct variable to it.</source>
          <target state="translated">이 함수는 C-API를 사용할 모듈의 초기화 섹션에서 호출해야합니다. 함수 포인터 테이블이 저장된 모듈을 가져오고 올바른 변수를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="cf5ee49acb54388d21032f90f2de16dca9ddb6c3" translate="yes" xml:space="preserve">
          <source>This function must take two arguments, &lt;code&gt;func(a, axis)&lt;/code&gt;.</source>
          <target state="translated">이 함수는 &lt;code&gt;func(a, axis)&lt;/code&gt; 두 가지 인수를 가져야합니다 .</target>
        </trans-unit>
        <trans-unit id="dba1259c24481a4a54d81a8fdecff9fadce8f02f" translate="yes" xml:space="preserve">
          <source>This function only shuffles the array along the first axis of a multi-dimensional array. The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">이 기능은 다차원 배열의 첫 번째 축을 따라 배열을 섞습니다. 하위 배열의 순서는 변경되지만 내용은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="68ca7042b267a7f2923f8a89cc886956d3a640a1" translate="yes" xml:space="preserve">
          <source>This function provides greater precision than &lt;code&gt;exp(x) - 1&lt;/code&gt; for small values of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">이 기능을보다 정밀 제공 &lt;code&gt;exp(x) - 1&lt;/code&gt; 작은 값 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40a3f0ad0a26c2dcd1667ccf5fd0beae55099939" translate="yes" xml:space="preserve">
          <source>This function reads from the system entropy pool and so samples are not reproducible. In particular, it does &lt;em&gt;NOT&lt;/em&gt; make use of a BitGenerator, and so &lt;code&gt;seed&lt;/code&gt; and setting &lt;code&gt;state&lt;/code&gt; have no effect.</source>
          <target state="translated">이 기능은 시스템 엔트로피 풀에서 읽으므로 샘플을 재현 할 수 없습니다. 특히, 않습니다 &lt;em&gt;하지&lt;/em&gt; BitGenerator의 사용을하고, 그래서 &lt;code&gt;seed&lt;/code&gt; 및 설정 &lt;code&gt;state&lt;/code&gt; 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2db0a89599aa1f9e0af20f69fdc08455be79db8b" translate="yes" xml:space="preserve">
          <source>This function returns True if &lt;code&gt;x&lt;/code&gt; is an instance of MaskedArray and returns False otherwise. Any object is accepted as input.</source>
          <target state="translated">이 함수는 &lt;code&gt;x&lt;/code&gt; 가 MaskedArray의 인스턴스 이면 True를 반환하고 그렇지 않으면 False를 반환합니다. 모든 개체가 입력으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="326a3290cbe737031cbcfe2c255c104d77bb6d98" translate="yes" xml:space="preserve">
          <source>This function returns a (C-style) contiguous and behaved function array from any nested sequence or array interface exporting object, &lt;em&gt;op&lt;/em&gt;, of (non-flexible) type given by the enumerated &lt;em&gt;typenum&lt;/em&gt;, of minimum depth &lt;em&gt;min_depth&lt;/em&gt;, and of maximum depth &lt;em&gt;max_depth&lt;/em&gt;. Equivalent to a call to &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements set to &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and the type_num member of the type argument set to &lt;em&gt;typenum&lt;/em&gt;.</source>
          <target state="translated">이 함수는 열거 된 &lt;em&gt;typenum&lt;/em&gt; , 최소 깊이 &lt;em&gt;min_depth&lt;/em&gt; 및 최대 깊이 &lt;em&gt;max_depth에서&lt;/em&gt; 주어진 (유연하지 않은) 유형의 중첩 시퀀스 또는 배열 인터페이스 내보내기 객체 &lt;em&gt;op&lt;/em&gt; 에서 (C 스타일) 연속적이고 동작하는 함수 배열을 &lt;em&gt;반환&lt;/em&gt; 합니다. 요구 사항 이 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 로 설정되고 유형 인수의 type_num 멤버 가 &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; 설정된 PyArray_FromAny 에 대한 호출 과 &lt;em&gt;같습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cd99a05c88fddf54e9c57ac9cd52857632e3d1f8" translate="yes" xml:space="preserve">
          <source>This function returns a boolean ndarray with all entries False, that can be used in common mask manipulations. If a complex dtype is specified, the type of each field is converted to a boolean type.</source>
          <target state="translated">이 함수는 공통 마스크 조작에 사용될 수있는 모든 항목 False와 함께 부울 ndarray를 리턴합니다. 복합 dtype을 지정하면 각 필드의 유형이 부울 유형으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="02eca326759cd81f17376a545937c3d2382a2a50" translate="yes" xml:space="preserve">
          <source>This function returns a well-behaved C-style contiguous array from any nested sequence or array-interface exporting object. The minimum number of dimensions the array can have is given by &lt;code&gt;min_depth&lt;/code&gt; while the maximum is &lt;code&gt;max_depth&lt;/code&gt;. This is equivalent to call &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; with requirements &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 중첩 된 시퀀스 또는 배열 인터페이스 내보내기 개체에서 제대로 작동하는 C 스타일 연속 배열을 반환합니다. 배열이 가질 수있는 최소 차원 수는 &lt;code&gt;min_depth&lt;/code&gt; 로 지정되고 최대 값은 &lt;code&gt;max_depth&lt;/code&gt; 입니다. 이것은 호출하는 것과 같습니다 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 을&lt;/a&gt; 요구 &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e7626c8e43009c9d0e23e7f2d941b6cb967b32" translate="yes" xml:space="preserve">
          <source>This function returns the absolute values (positive magnitude) of the data in &lt;code&gt;x&lt;/code&gt;. Complex values are not handled, use &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt;&lt;code&gt;absolute&lt;/code&gt;&lt;/a&gt; to find the absolute values of complex data.</source>
          <target state="translated">이 함수는 &lt;code&gt;x&lt;/code&gt; 의 데이터 절대 값 (양의 크기)을 반환합니다 . 복소 값은, 사용하는 처리되지 않은 &lt;a href=&quot;numpy.absolute#numpy.absolute&quot;&gt; &lt;code&gt;absolute&lt;/code&gt; &lt;/a&gt; 복잡한 데이터의 절대 값을 찾을 것이다.</target>
        </trans-unit>
        <trans-unit id="89fee3e999f1c558b74709781bf21911d5dc8fa4" translate="yes" xml:space="preserve">
          <source>This function returns the value</source>
          <target state="translated">이 함수는 값을 반환합니다</target>
        </trans-unit>
        <trans-unit id="1cc55e517c256ea42c557b8b54e3efb3b6cafcb6" translate="yes" xml:space="preserve">
          <source>This function returns the values:</source>
          <target state="translated">이 함수는 값을 반환합니다 :</target>
        </trans-unit>
        <trans-unit id="a6d07b33b778389f427bd3ca9fc11f04feb25982" translate="yes" xml:space="preserve">
          <source>This function should accept 1-D arrays. It is applied to 1-D slices of &lt;code&gt;arr&lt;/code&gt; along the specified axis.</source>
          <target state="translated">이 함수는 1 차원 배열을 받아 들여야합니다. 지정된 축을 따라 1 차원 &lt;code&gt;arr&lt;/code&gt; 조각에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="5cfabdc0232ab8cc8ac575fbc0d4dec6b2dd7bf7" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;arr&lt;/em&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;arr에&lt;/em&gt; 대한 참조를 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="3ceff3d1be740072d08fa441617d883813e56f19" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL.</source>
          <target state="translated">이 함수 는 NULL이 아닌 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="37fa48e8e102e5c7fe97151e437a12d635c87f86" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt; if it is not NULL. This array creation routine allows for the convenient creation of a new array matching an existing array&amp;rsquo;s shapes and memory layout, possibly changing the layout and/or data type.</source>
          <target state="translated">이 함수 는 NULL이 아닌 경우 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 . 이 배열 생성 루틴을 사용하면 기존 배열의 모양 및 메모리 레이아웃과 일치하는 새 배열을 편리하게 생성하여 레이아웃 및 / 또는 데이터 유형을 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8281b58eb98855581eef0364cfa182f403baf433" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 .</target>
        </trans-unit>
        <trans-unit id="71bb778b3ae86d2314883f6bdb50a6590499183c" translate="yes" xml:space="preserve">
          <source>This function steals a reference to &lt;em&gt;descr&lt;/em&gt;. The easiest way to get one is using &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 &lt;em&gt;descr에&lt;/em&gt; 대한 참조를 훔칩니다 . 하나를 얻는 가장 쉬운 방법은 &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; 을&lt;/a&gt; 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="f6d42633714a13d2a78f3f69e93cf9d52e8a857e" translate="yes" xml:space="preserve">
          <source>This function supports both indexing conventions through the indexing keyword argument. Giving the string &amp;lsquo;ij&amp;rsquo; returns a meshgrid with matrix indexing, while &amp;lsquo;xy&amp;rsquo; returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N) for &amp;lsquo;ij&amp;rsquo; indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for &amp;lsquo;xy&amp;rsquo; indexing and (M, N, P) for &amp;lsquo;ij&amp;rsquo; indexing. The difference is illustrated by the following code snippet:</source>
          <target state="translated">이 함수는 indexing 키워드 인수를 통해 두 가지 색인 규칙을 모두 지원합니다. 'ij'문자열을 제공하면 행렬 색인이 포함 된 meshgrid가 반환되고 'xy'가 데카르트 색인이 포함 된 meshgrid가 반환됩니다. 길이 M과 N의 입력을 가진 2 차원의 경우, 출력은 'xy'인덱싱의 경우 모양 (N, M) 및 'ij'인덱싱의 경우 (M, N) 모양입니다. 길이 M, N 및 P의 입력이있는 3 차원 경우 출력은 'xy'인덱싱의 경우 (N, M, P) 모양이고 'ij'인덱싱의 경우 (M, N, P) 모양입니다. 차이점은 다음 코드 스 니펫으로 설명됩니다.</target>
        </trans-unit>
        <trans-unit id="e857d76db9c7bac209f1715cec1437cf523540d8" translate="yes" xml:space="preserve">
          <source>This function swaps half-spaces for all axes listed (defaults to all). Note that &lt;code&gt;y[0]&lt;/code&gt; is the Nyquist component only if &lt;code&gt;len(x)&lt;/code&gt; is even.</source>
          <target state="translated">이 기능은 나열된 모든 축에 대해 반 공백을 바꿉니다 (기본값은 모두). 참고로 &lt;code&gt;y[0]&lt;/code&gt; 에만 성분 인 나이키 스트 &lt;code&gt;len(x)&lt;/code&gt; 짝수이다.</target>
        </trans-unit>
        <trans-unit id="a7870153b27cca4d6c02a86ec8c830b616e4b3c3" translate="yes" xml:space="preserve">
          <source>This function takes N 1-D sequences and returns N outputs with N dimensions each, such that the shape is 1 in all but one dimension and the dimension with the non-unit shape value cycles through all N dimensions.</source>
          <target state="translated">이 함수는 N 1-D 시퀀스를 가져 와서 각각 N 차원의 N 출력을 반환하여 모양이 1 차원을 제외하고 모두 1이고 비 단위 모양 값이있는 차원이 모든 N 차원을 순환합니다.</target>
        </trans-unit>
        <trans-unit id="b4e43f62f7a361a5fb222fc70fbd3c26bd5104e6" translate="yes" xml:space="preserve">
          <source>This function takes a multi-iterator object that has been previously &amp;ldquo;broadcasted,&amp;rdquo; finds the dimension with the smallest &amp;ldquo;sum of strides&amp;rdquo; in the broadcasted result and adapts all the iterators so as not to iterate over that dimension (by effectively making them of length-1 in that dimension). The corresponding dimension is returned unless &lt;em&gt;mit&lt;/em&gt; -&amp;gt;nd is 0, then -1 is returned. This function is useful for constructing ufunc-like routines that broadcast their inputs correctly and then call a strided 1-d version of the routine as the inner-loop. This 1-d version is usually optimized for speed and for this reason the loop should be performed over the axis that won&amp;rsquo;t require large stride jumps.</source>
          <target state="translated">이 함수는 이전에 &quot;브로드 캐스트 된&quot;다중 반복자 객체를 가져와 브로드 캐스트 된 결과에서 가장 작은 &quot;보폭&quot;이있는 차원을 찾은 다음 해당 반복자를 효과적으로 반복하여 해당 반복자에 대해 반복하지 않도록 모든 반복자를 조정합니다. 해당 차원의 길이 -1). &lt;em&gt;mit-&lt;/em&gt; &amp;gt; nd가 0이 아니면 대응하는 차원이 리턴되고 -1이 리턴됩니다. 이 함수는 입력을 올바르게 브로드 캐스트 한 후 루틴의 스 트레이딩 된 1 차원 버전을 내부 루프로 호출하는 ufunc와 같은 루틴을 구성하는 데 유용합니다. 이 1-d 버전은 일반적으로 속도에 최적화되어 있기 때문에 큰 보폭이 필요하지 않은 축에 대해 루프를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="102958a161ae2e87757cf73f96956c3988a66269" translate="yes" xml:space="preserve">
          <source>This function uses the same algorithm as the builtin python &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt;&lt;code&gt;bisect.bisect_left&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='left'&lt;/code&gt;) and &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt;&lt;code&gt;bisect.bisect_right&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;side='right'&lt;/code&gt;) functions, which is also vectorized in the &lt;code&gt;v&lt;/code&gt; argument.</source>
          <target state="translated">이 함수는 내장 파이썬 &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_left&quot;&gt; &lt;code&gt;bisect.bisect_left&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;side='left'&lt;/code&gt; ) 및 &lt;a href=&quot;https://docs.python.org/dev/library/bisect.html#bisect.bisect_right&quot;&gt; &lt;code&gt;bisect.bisect_right&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;side='right'&lt;/code&gt; ) 함수 와 동일한 알고리즘을 사용 하며 &lt;code&gt;v&lt;/code&gt; 인수로 도 벡터화됩니다 .</target>
        </trans-unit>
        <trans-unit id="f4a094c15ea96c9120e1bb02da934b3ab9299caa" translate="yes" xml:space="preserve">
          <source>This function will not demote complex to float or anything to boolean, but will demote a signed integer to an unsigned integer when the scalar value is positive.</source>
          <target state="translated">이 함수는 복소수를 부동 소수점 이하로 강등 시키거나 부울 값으로 강등하지 않지만 스칼라 값이 양수이면 부호있는 정수를 부호없는 정수로 강등시킵니다.</target>
        </trans-unit>
        <trans-unit id="e431cb683c0bc7c35e7633e888e952e4559756e5" translate="yes" xml:space="preserve">
          <source>This function will not preserve masking of MaskedArray inputs.</source>
          <target state="translated">이 함수는 MaskedArray 입력의 마스킹을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a9b1f287c173d330577d2300449ee4dfd3daa91" translate="yes" xml:space="preserve">
          <source>This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수는 ma.array와 같은 &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt; 서브 클래스에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="b6a52abd835e7532e9891ffc574fd5f4220e58bc" translate="yes" xml:space="preserve">
          <source>This function works similarly to &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt;&lt;code&gt;PyArray_ObjectType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except it handles flexible arrays. The &lt;em&gt;mintype&lt;/em&gt; argument can have an itemsize member and the &lt;em&gt;outtype&lt;/em&gt; argument will have an itemsize member at least as big but perhaps bigger depending on the object &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">이 함수 는 유연한 배열을 처리한다는 점을 제외하고 &lt;a href=&quot;#c.PyArray_ObjectType&quot;&gt; &lt;code&gt;PyArray_ObjectType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 과 유사하게 작동 합니다. &lt;em&gt;mintype의&lt;/em&gt; 인수는 itemsize 멤버를 가질 수 있고, &lt;em&gt;outtype의&lt;/em&gt; 인수는 큰 그러나 아마 더 큰는 개체에 따라 같은 적어도 itemsize 회원해야합니다 &lt;em&gt;영업 이익&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="24bfcaf02c26210c6ce475ff904488dd4e86859f" translate="yes" xml:space="preserve">
          <source>This functionality can be obtained via &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt;&lt;code&gt;diag_indices&lt;/code&gt;&lt;/a&gt;, but internally this version uses a much faster implementation that never constructs the indices and uses simple slicing.</source>
          <target state="translated">이 기능은 &lt;a href=&quot;numpy.diag_indices#numpy.diag_indices&quot;&gt; &lt;code&gt;diag_indices&lt;/code&gt; &lt;/a&gt; 를 통해 얻을 수 있지만 내부적으로이 버전은 인덱스를 구성하지 않고 간단한 슬라이싱을 사용하는 훨씬 빠른 구현을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8df0c373fc062bf47c7c593de18498c118dd2c34" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object that takes one argument. The first argument in &lt;em&gt;args&lt;/em&gt; is the method whose function is called, the second argument in &lt;em&gt;args&lt;/em&gt; is the argument passed to the function. The output of the function is stored in the third entry of &lt;em&gt;args&lt;/em&gt;.</source>
          <target state="translated">이 범용 1-d 코어 함수는 &lt;em&gt;func&lt;/em&gt; 가 하나의 인수를 취하는 입력 객체의 메소드를 나타내는 문자열 이라고 가정합니다 . 첫 번째 인수 &lt;em&gt;인수는&lt;/em&gt; 그 함수 호출, 두 번째 인자 인 방법 &lt;em&gt;인수가&lt;/em&gt; 함수에 전달 된 인자이다. 함수의 출력은 &lt;em&gt;args&lt;/em&gt; 의 세 번째 항목에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="71fb70d934e71392e5b977e3d5908e6d14ba65f1" translate="yes" xml:space="preserve">
          <source>This general purpose 1-d core function assumes that &lt;em&gt;func&lt;/em&gt; is a string representing a method of the input object. For each iteration of the loop, the Python object is extracted from the array and its &lt;em&gt;func&lt;/em&gt; method is called returning the result to the output array.</source>
          <target state="translated">이 범용 1-d 코어 함수는 &lt;em&gt;func&lt;/em&gt; 가 입력 객체의 메서드를 나타내는 문자열 이라고 가정 합니다. 루프가 반복 될 때마다 Python 객체가 배열에서 추출되고 &lt;em&gt;func&lt;/em&gt; 메소드가 호출되어 결과를 출력 배열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ebe1403d50c0fdb0002abff6822f498479faa88e" translate="yes" xml:space="preserve">
          <source>This geometrical property can be seen in two dimensions by plotting generated data-points:</source>
          <target state="translated">이 기하학적 특성은 생성 된 데이터 포인트를 플롯하여 2 차원에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1dc7a565ca8eeac49fa065474eb2fca785df357" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data pointers. If &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; was not specified, each data pointer points to the current data item of the iterator. If no inner iteration was specified, it points to the first data item of the inner loop.</source>
          <target state="translated">이것은 &lt;code&gt;nop&lt;/code&gt; 데이터 포인터에 대한 포인터를 돌려줍니다 . 경우 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 는&lt;/a&gt; 반복자의 현재 데이터 항목에 각 데이터 포인터 포인트를 지정되지 않았습니다. 내부 반복이 지정되지 않은 경우 내부 루프의 첫 번째 데이터 항목을 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="ad9e42c674af93de7c3d00b721f840bb2a3ba388" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; data type Descrs for the objects being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the Descrs.</source>
          <target state="translated">이는 반복되는 오브젝트에 대한 &lt;code&gt;nop&lt;/code&gt; 데이터 유형 Descrs에 대한 포인터를 제공합니다 . 결과는 &lt;code&gt;iter&lt;/code&gt; 를 가리 키 므로 호출자는 Descrs에 대한 참조를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="04484c93294b17e48ec0072eb06cb15b6ce824d8" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the &lt;code&gt;nop&lt;/code&gt; operand PyObjects that are being iterated. The result points into &lt;code&gt;iter&lt;/code&gt;, so the caller does not gain any references to the PyObjects.</source>
          <target state="translated">이것은 반복되는 &lt;code&gt;nop&lt;/code&gt; 피연산자 PyObject에 대한 포인터를 제공합니다 . 결과는 &lt;code&gt;iter&lt;/code&gt; 를 가리 키 므로 호출자는 PyObject에 대한 참조를 얻지 못합니다.</target>
        </trans-unit>
        <trans-unit id="de4914e9685130ac5234ec503748e2bb51b5d569" translate="yes" xml:space="preserve">
          <source>This gives back a pointer to the index being tracked, or NULL if no index is being tracked. It is only useable if one of the flags &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt; were specified during construction.</source>
          <target state="translated">추적중인 인덱스에 대한 포인터를 반환하거나, 추적중인 인덱스가 없으면 NULL을 반환합니다. 구성 중에 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; 플래그 중 하나 가 지정된 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76e1c3a277ebfaa2cffaf967d76cec0c7e8df194" translate="yes" xml:space="preserve">
          <source>This gives back a reference to a new ndarray view, which is a view into the i-th object in the array &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt;, whose dimensions and strides match the internal optimized iteration pattern. A C-order iteration of this view is equivalent to the iterator&amp;rsquo;s iteration order.</source>
          <target state="translated">그러면 NpyIter_GetOperandArray 배열의 i 번째 객체에 대한 뷰인 새로운 ndarray 뷰에 대한 참조가 제공 &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; , 치수 및 보폭은 내부 최적화 된 반복 패턴과 일치합니다. 이 뷰의 C 순서 반복은 반복자의 반복 순서와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5203e44570d99c05fcfa2df4337f300e46c186be" translate="yes" xml:space="preserve">
          <source>This group is used to call code that may take some time but does not use any Python C-API calls. Thus, the GIL should be released during its calculation.</source>
          <target state="translated">이 그룹은 시간이 걸리지 만 Python C-API 호출을 사용하지 않는 코드를 호출하는 데 사용됩니다. 따라서 계산 중에 GIL을 해제해야합니다.</target>
        </trans-unit>
        <trans-unit id="5bcd38e59fd6cf93688e83d10245c536ddb55a3a" translate="yes" xml:space="preserve">
          <source>This group is used to re-acquire the Python GIL after it has been released. For example, suppose the GIL has been released (using the previous calls), and then some path in the code (perhaps in a different subroutine) requires use of the Python C-API, then these macros are useful to acquire the GIL. These macros accomplish essentially a reverse of the previous three (acquire the LOCK saving what state it had) and then re-release it with the saved state.</source>
          <target state="translated">이 그룹은 Python GIL이 릴리스 된 후 다시 획득하는 데 사용됩니다. 예를 들어, 이전 호출을 사용하여 GIL이 릴리스 된 다음 코드의 일부 경로 (아마 다른 서브 루틴의 경로)에 Python C-API를 사용해야한다고 가정하면 이러한 매크로는 GIL을 얻는 데 유용합니다. 이 매크로는 본질적으로 이전 세 가지의 역순을 달성하고 (LOCK 상태를 저장 한 상태로 확보) 저장된 상태로 다시 릴리스합니다.</target>
        </trans-unit>
        <trans-unit id="4ba46b0017074bb74d18814c42399e783717828c" translate="yes" xml:space="preserve">
          <source>This guide is an overview and explains the important features; details are found in &lt;a href=&quot;../reference/index#reference&quot;&gt;NumPy Reference&lt;/a&gt;.</source>
          <target state="translated">이 가이드는 개요이며 중요한 기능을 설명합니다. 자세한 내용은 &lt;a href=&quot;../reference/index#reference&quot;&gt;NumPy Reference&lt;/a&gt; 에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c9e84e903bf2e483b137abd67c279312344ab01" translate="yes" xml:space="preserve">
          <source>This guide will help you decide what to contribute and how to submit it to the official NumPy documentation.</source>
          <target state="translated">이 가이드는 기여할 내용과 공식 NumPy 문서에 제출하는 방법을 결정하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="22e8bed5de814991ce18d8f44ecb60dc6c28da78" translate="yes" xml:space="preserve">
          <source>This info dict can then be used as input to a &lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">이 정보 딕셔너리는 &lt;a href=&quot;../distutils#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 인스턴스 에 대한 입력으로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="594238b01d9d524cb6fb409e28f8c563967eda11" translate="yes" xml:space="preserve">
          <source>This information will be collected in writing, and whenever possible the group&amp;rsquo;s deliberations will be recorded and retained (i.e. chat transcripts, email discussions, recorded conference calls, summaries of voice conversations, etc).</source>
          <target state="translated">이 정보는 서면으로 수집되며 가능할 때마다 그룹의 심의가 기록되고 보관됩니다 (예 : 채팅 기록, 이메일 토론, 녹음 된 회의 통화, 음성 대화 요약 등).</target>
        </trans-unit>
        <trans-unit id="11fb823e6d137af2611381a853679838cd294872" translate="yes" xml:space="preserve">
          <source>This interface describes homogeneous arrays in the sense that each item of the array has the same &amp;ldquo;type&amp;rdquo;. This type can be very simple or it can be a quite arbitrary and complicated C-like structure.</source>
          <target state="translated">이 인터페이스는 배열의 각 항목이 동일한 &quot;유형&quot;을 갖는다는 의미에서 동종 배열을 설명합니다. 이 유형은 매우 단순하거나 매우 임의적이고 복잡한 C 형 구조 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="669065ebaf0e163f0816c64449775393f24910fd" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt;&lt;code&gt;numpy.flatiter&lt;/code&gt;&lt;/a&gt; instance, which acts similarly to, but is not a subclass of, Python&amp;rsquo;s built-in iterator object.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.flatiter#numpy.flatiter&quot;&gt; &lt;code&gt;numpy.flatiter&lt;/code&gt; &lt;/a&gt; 인스턴스로, 파이썬 내장 반복자 객체와 유사하게 작동하지만 하위 클래스는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="c616752b11f5b5590e848100c7afe1eff6eb31fb" translate="yes" xml:space="preserve">
          <source>This is a convenience function for quick storage of array data. Information on endianness and precision is lost, so this method is not a good choice for files intended to archive data or transport data between machines with different endianness. Some of these problems can be overcome by outputting the data as text files, at the expense of speed and file size.</source>
          <target state="translated">이것은 어레이 데이터의 빠른 저장을위한 편리한 기능입니다. 엔디안 및 정밀도에 대한 정보가 손실되므로이 방법은 엔디안이 다른 시스템간에 데이터를 아카이브하거나 데이터를 전송하려는 파일에는 적합하지 않습니다. 이러한 문제 중 일부는 속도와 파일 크기를 희생하면서 데이터를 텍스트 파일로 출력하여 극복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e143678de16b85b14841ff12151066d84f46e8b0" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Matlab에서 코드를 이식하는 사용자를위한 편리한 함수이며 &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; 을&lt;/a&gt; 래핑 합니다. 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하며, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="7a6640731207cc17f5b282e72b4960d28e172178" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Matlab에서 코드를 이식하는 사용자를위한 편리한 함수이며 &lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; 을&lt;/a&gt; 래핑 합니다. 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하며, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="e91ed9ba3b995348d0b712c7cd0f68c854820dd9" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Matlab에서 코드를 이식하는 사용자를위한 편리한 함수이며 &lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; 을&lt;/a&gt; 래핑 합니다 . 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하며, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="637f2f7f4587e6fab14f3bc29737254f8ece5452" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Matlab에서 코드를 이식하는 사용자를위한 편리한 함수이며 &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; 을&lt;/a&gt; 래핑 합니다 . 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하며, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="aebce3c953e4d7a8aa40a69097fcdae621194f4a" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.random_sample&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 Matlab에서 코드를 포팅하는 사용자를위한 편리한 기능이며 &lt;code&gt;numpy.random.random_sample&lt;/code&gt; 을 래핑 합니다 . 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하는데, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="8a8395276aef2b1c09ac3507c06c6aeae1c56edd" translate="yes" xml:space="preserve">
          <source>This is a convenience function for users porting code from Matlab, and wraps &lt;code&gt;numpy.random.standard_normal&lt;/code&gt;. That function takes a tuple to specify the size of the output, which is consistent with other NumPy functions like &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;numpy.zeros&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt;&lt;code&gt;numpy.ones&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 Matlab에서 코드를 포팅하는 사용자를위한 편리한 기능이며 &lt;code&gt;numpy.random.standard_normal&lt;/code&gt; 을 래핑 합니다 . 이 함수는 출력 크기를 지정하기 위해 튜플을 사용하는데, 이는 &lt;a href=&quot;../../generated/numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;numpy.zeros&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../generated/numpy.ones#numpy.ones&quot;&gt; &lt;code&gt;numpy.ones&lt;/code&gt; &lt;/a&gt; 와 같은 다른 NumPy 함수 와 일치 합니다.</target>
        </trans-unit>
        <trans-unit id="14bed771c7ecf5fb5c7f3988c3e80ea720b90d56" translate="yes" xml:space="preserve">
          <source>This is a convenience, legacy function.</source>
          <target state="translated">이것은 편리한 레거시 기능입니다.</target>
        </trans-unit>
        <trans-unit id="8386d98dd4fd3fd3372da264e738d2eec8c472de" translate="yes" xml:space="preserve">
          <source>This is a default converter for output arrays given to functions. If &lt;em&gt;obj&lt;/em&gt; is &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;NULL&lt;/code&gt;, then &lt;em&gt;*address&lt;/em&gt; will be &lt;code&gt;NULL&lt;/code&gt; but the call will succeed. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; ( &lt;em&gt;obj&lt;/em&gt;) is TRUE then it is returned in &lt;em&gt;*address&lt;/em&gt; without incrementing its reference count.</source>
          <target state="translated">이것은 함수에 주어진 출력 배열을위한 기본 변환기입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 있다 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;NULL&lt;/code&gt; , 다음 &lt;em&gt;* 주소는&lt;/em&gt; 것입니다 &lt;code&gt;NULL&lt;/code&gt; 하지만 호출이 성공합니다. 경우 &lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;obj가&lt;/em&gt; ) 다음 TRUE 인 것이 반환된다 &lt;em&gt;* 어드레스&lt;/em&gt; 의 참조 카운트를 증가없이.</target>
        </trans-unit>
        <trans-unit id="ebf6bd0b70f0575c64ee3df5fdd00ac441de460d" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 copysign: return x with the same sign as y. Works for any value, including inf and nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">이것은 C99 copysign에 해당하는 함수입니다. y와 같은 부호를 가진 x를 리턴하십시오. inf와 nan을 포함한 모든 가치에 적용됩니다. 단일 및 확장 정밀도는 접미사 f 및 l과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c5d9b74232b5b43fdac1227d638313277afa572" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to C99 nextafter: return next representable floating point value from x in the direction of y. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">이것은 다음에 C99에 해당하는 함수입니다. x에서 y의 방향으로 다음 표현 가능한 부동 소수점 값을 반환합니다. 단일 및 확장 정밀도는 접미사 f 및 l과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6cef9e65ee084ca1f09a67a21a4b3ef4b9523383" translate="yes" xml:space="preserve">
          <source>This is a function equivalent to Fortran intrinsic. Return distance between x and next representable floating point value from x, e.g. spacing(1) == eps. spacing of nan and +/- inf return nan. Single and extended precisions are available with suffix f and l.</source>
          <target state="translated">이것은 Fortran 내장 함수와 동등한 기능입니다. x와 x에서 표현할 수있는 다음 부동 소수점 값 사이의 거리를 반환합니다 (예 : spacing (1) == eps). nan의 간격과 +/- inf return nan. 단일 및 확장 정밀도는 접미사 f 및 l과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f691a7cca2d5bab9d5322a451f5071b060431b18" translate="yes" xml:space="preserve">
          <source>This is a function pointer for getting the current iterator multi-index, returned by &lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt;&lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_GetGetMultiIndex&quot;&gt; &lt;code&gt;NpyIter_GetGetMultiIndex&lt;/code&gt; 에&lt;/a&gt; 의해 반환 된 현재 반복자 다중 인덱스를 가져 오기위한 함수 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="afe9f9d9e5612f0c43f0b6f2ab1ddbf98d2077ed" translate="yes" xml:space="preserve">
          <source>This is a function pointer for the iteration loop, returned by &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 에&lt;/a&gt; 의해 반환되는 반복 루프에 대한 함수 포인터입니다 .</target>
        </trans-unit>
        <trans-unit id="682e5efdefc09e15bb711f19c6e22c6512c8e3c9" translate="yes" xml:space="preserve">
          <source>This is a list of flags for each operand. At minimum, one of &lt;code&gt;readonly&lt;/code&gt;, &lt;code&gt;readwrite&lt;/code&gt;, or &lt;code&gt;writeonly&lt;/code&gt; must be specified.</source>
          <target state="translated">각 피연산자에 대한 플래그 목록입니다. 최소한 &lt;code&gt;readonly&lt;/code&gt; , &lt;code&gt;readwrite&lt;/code&gt; 또는 &lt;code&gt;writeonly&lt;/code&gt; 중 하나를 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="daee1c27087ebe5008ffab37bf86e6cef5520692" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isfinite: works for single, double and extended precision, and return a non 0 value is x is neither a NaN nor an infinity.</source>
          <target state="translated">이것은 매크로이며 C99 isfinite와 같습니다. 단정도, 배정도 및 확장 정밀도에 적용되며 0이 아닌 값을 반환하면 x는 NaN도 무한대도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="80381bd72606c65ade88008349bbceb47f771261" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isinf: works for single, double and extended precision, and return a non 0 value is x is infinite (positive and negative).</source>
          <target state="translated">이것은 매크로이며 C99 isinf와 같습니다. 단정도, 배정도 및 확장 정밀도에 적용되며 0이 아닌 값을 반환하면 x는 무한대 (양수 및 음수)입니다.</target>
        </trans-unit>
        <trans-unit id="0a2766c5fc1ee9982025de76ae4aa9f68ecd22db" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 isnan: works for single, double and extended precision, and return a non 0 value is x is a NaN.</source>
          <target state="translated">이것은 매크로이며 C99 isnan과 같습니다. 단정도, 배정도 및 확장 정밀도에 대해 작동하며 0이 아닌 값을 반환하면 x는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="ba072edcddb8314e48393832fd145a168df5e278" translate="yes" xml:space="preserve">
          <source>This is a macro, and is equivalent to C99 signbit: works for single, double and extended precision, and return a non 0 value is x has the signbit set (that is the number is negative).</source>
          <target state="translated">이것은 매크로이며 C99 부호와 같습니다. 단정도, 배정도 및 확장 정밀도에 대해 작동하며 0이 아닌 값을 반환하면 x에 부호 비트가 설정되어 있습니다 (숫자가 음수 임).</target>
        </trans-unit>
        <trans-unit id="90bdfe8753787f61c5537ce6dde698f20d3651a1" translate="yes" xml:space="preserve">
          <source>This is a quick overview of algebra and arrays in NumPy. It demonstrates how n-dimensional (</source>
          <target state="translated">NumPy의 대수 및 배열에 대한 간략한 개요입니다. n 차원 (</target>
        </trans-unit>
        <trans-unit id="e912c91523a3cdb66f72696d355ab45d0a9a414f" translate="yes" xml:space="preserve">
          <source>This is a relatively robust method to compare two arrays whose amplitude is variable.</source>
          <target state="translated">이것은 진폭이 가변적 인 두 어레이를 비교하는 비교적 강력한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="f9e98f643e268bceb892d520470f87f06bd3ffa1" translate="yes" xml:space="preserve">
          <source>This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="daaf8424b18b172abdada56262484be0114cb050" translate="yes" xml:space="preserve">
          <source>This is a setup.py file for the above code. As before, the module can be build via calling python setup.py build at the command prompt, or installed to site-packages via python setup.py install.</source>
          <target state="translated">위 코드의 setup.py 파일입니다. 이전과 마찬가지로 명령 프롬프트에서 python setup.py build를 호출하여 모듈을 빌드하거나 python setup.py install을 통해 사이트 패키지에 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b6ff4b3ee0d226dd43f100afc9a5e9fc743a95d" translate="yes" xml:space="preserve">
          <source>This is a simple way to build up arrays quickly. There are two use cases.</source>
          <target state="translated">이것은 어레이를 빠르게 구축하는 간단한 방법입니다. 두 가지 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf246dfc26ef7aa2b64da9e4b03eace45db2857" translate="yes" xml:space="preserve">
          <source>This is a special flag that is set if this array represents a copy made because a user required certain flags in &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; and a copy had to be made of some other array (and the user asked for this flag to be set in such a situation). The base attribute then points to the &amp;ldquo;misbehaved&amp;rdquo; array (which is set read_only). :c:func`PyArray_ResolveWritebackIfCopy` will copy its contents back to the &amp;ldquo;misbehaved&amp;rdquo; array (casting if necessary) and will reset the &amp;ldquo;misbehaved&amp;rdquo; array to &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;. If the &amp;ldquo;misbehaved&amp;rdquo; array was not &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to begin with then &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; would have returned an error because &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; would not have been possible.</source>
          <target state="translated">이것은 사용자가 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 에서 특정 플래그를 요구 하고 다른 배열로 복사해야 했기 때문에이 배열이 사본을 나타내는 경우 설정되는 특수 플래그입니다 (그리고 사용자는 이러한 상황에서이 플래그를 설정하도록 요청했습니다) . 그런 다음 기본 속성은 &quot;misbehaved&quot;배열 (read_only로 설정 됨)을 가리 킵니다. : c : func`PyArray_ResolveWritebackIfCopy`는 내용을&amp;ldquo;misbehaved&amp;rdquo;배열로 다시 복사하고 (필요한 경우 캐스팅)&amp;ldquo;misbehaved&amp;rdquo;배열을 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; 로&lt;/a&gt; 재설정합니다 . 은 &quot;추문&quot;배열이 아닌 경우 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 다음으로 시작하는 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 이&lt;/a&gt; 때문에 오류를 반환 것 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; 이&lt;/a&gt; 불가능했을 것입니다.</target>
        </trans-unit>
        <trans-unit id="d494bbd6ea4e55e23b6320030cf19b92084fb2cb" translate="yes" xml:space="preserve">
          <source>This is a very flexible function; &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt;&lt;code&gt;array_repr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt;&lt;code&gt;array_str&lt;/code&gt;&lt;/a&gt; are using &lt;a href=&quot;#numpy.array2string&quot;&gt;&lt;code&gt;array2string&lt;/code&gt;&lt;/a&gt; internally so keywords with the same name should work identically in all three functions.</source>
          <target state="translated">이것은 매우 유연한 기능입니다. &lt;a href=&quot;numpy.array_repr#numpy.array_repr&quot;&gt; &lt;code&gt;array_repr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.array_str#numpy.array_str&quot;&gt; &lt;code&gt;array_str&lt;/code&gt; 이&lt;/a&gt; 사용하는 &lt;a href=&quot;#numpy.array2string&quot;&gt; &lt;code&gt;array2string&lt;/code&gt; &lt;/a&gt; 같은 이름이 세 가지 기능에서 동일하게 작동합니다 내부적으로 그렇게 키워드.</target>
        </trans-unit>
        <trans-unit id="4a20d6c5e13bf5949cf2f01fed00be4a85ee83c8" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dump&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;cPickle.dump&lt;/code&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="72c0baacc027dca1b05db754f60ee813fa6dbfcf" translate="yes" xml:space="preserve">
          <source>This is a wrapper around &lt;code&gt;cPickle.dumps&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;cPickle.dumps&lt;/code&gt; 주위의 래퍼 입니다.</target>
        </trans-unit>
        <trans-unit id="b6ae9c5b7de866ac0dd1b4b58c7a54bd18149043" translate="yes" xml:space="preserve">
          <source>This is almost the same as the result of PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting), but it also handles a special case arising because the set of uint values is not a subset of the int values for types with the same number of bits.</source>
          <target state="translated">이것은 PyArray_CanCastTypeTo (PyArray_MinScalarType (arr), totype, cast)의 결과와 거의 동일하지만 uint 값 집합이 같은 수의 유형에 대한 int 값의 하위 집합이 아니기 때문에 발생하는 특수한 경우도 처리합니다. 비트.</target>
        </trans-unit>
        <trans-unit id="06d558ced35712eb9368208c693942a96aac9510" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 &lt;a href=&quot;generated/numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="6be9e8aa17773bdb0efb0eec1cc4294398d93d4d" translate="yes" xml:space="preserve">
          <source>This is an alias of &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;. See &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt; for the complete documentation.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt; 의 별칭입니다 . 전체 문서는 &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="abef17cd5a41150617b797dd34026cad2a72bcf3" translate="yes" xml:space="preserve">
          <source>This is an example of a func specialized for addition of doubles returning doubles.</source>
          <target state="translated">복식 복식 복식의 추가에 특화된 펑크의 예입니다.</target>
        </trans-unit>
        <trans-unit id="8d1fbd89490e7598a40d0ab430364ea01d0cff36" translate="yes" xml:space="preserve">
          <source>This is an interface to the LAPACK routines &lt;code&gt;dgeqrf&lt;/code&gt;, &lt;code&gt;zgeqrf&lt;/code&gt;, &lt;code&gt;dorgqr&lt;/code&gt;, and &lt;code&gt;zungqr&lt;/code&gt;.</source>
          <target state="translated">이것은 LAPACK 루틴 &lt;code&gt;dgeqrf&lt;/code&gt; , &lt;code&gt;zgeqrf&lt;/code&gt; , &lt;code&gt;dorgqr&lt;/code&gt; 및 &lt;code&gt;zungqr&lt;/code&gt; 에 대한 인터페이스 입니다.</target>
        </trans-unit>
        <trans-unit id="944d000b70e8d3d375939368b9ee8662949fdd56" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional array. It is the object returned from the flat attribute of an ndarray. It is also used extensively throughout the implementation internals to loop over an N-dimensional array. The tp_as_mapping interface is implemented so that the iterator object can be indexed (using 1-d indexing), and a few methods are implemented through the tp_methods table. This object implements the next method and can be used anywhere an iterator can be used in Python.</source>
          <target state="translated">이것은 N 차원 배열을 쉽게 반복 할 수있는 반복자 객체입니다. ndarray의 flat 속성에서 반환 된 객체입니다. 또한 N- 차원 배열을 반복하기 위해 구현 내부에서 광범위하게 사용됩니다. tp_as_mapping 인터페이스는 반복자 객체를 색인화 (1-d 색인화 사용) 할 수 있도록 구현되며 tp_methods 테이블을 통해 몇 가지 메소드가 구현됩니다. 이 객체는 다음 메소드를 구현하며 파이썬에서 반복자가 사용될 수있는 곳이라면 어디에서나 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39877197a88959914be74b4d252daeba988b0567" translate="yes" xml:space="preserve">
          <source>This is an iterator object that makes it easy to loop over an N-dimensional neighborhood.</source>
          <target state="translated">이것은 N 차원 이웃을 쉽게 반복 할 수있는 반복자 객체입니다.</target>
        </trans-unit>
        <trans-unit id="ed4488f4638f84c1e1e4b827cf0b8579c8c851e4" translate="yes" xml:space="preserve">
          <source>This is an opaque pointer type for the iterator. Access to its contents can only be done through the iterator API.</source>
          <target state="translated">이터레이터에 대한 불투명 포인터 유형입니다. 컨텐츠에 대한 액세스는 반복자 API를 통해서만 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b4c12ec7da04774c2971488c28da077dd954ab73" translate="yes" xml:space="preserve">
          <source>This is defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;</source>
          <target state="translated">이것은 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt; , &lt;strong&gt;SHORT&lt;/strong&gt; , &lt;strong&gt;INT&lt;/strong&gt; , &lt;strong&gt;LONG&lt;/strong&gt; , &lt;strong&gt;LONGLONG&lt;/strong&gt; , &lt;strong&gt;INTP에 대해 정의됩니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1cb38ad4a8a5f0f7eaad9358f9b24fff730b48c2" translate="yes" xml:space="preserve">
          <source>This is defined for all defined for &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt;, &lt;strong&gt;UBYTE&lt;/strong&gt;, &lt;strong&gt;SHORT&lt;/strong&gt;, &lt;strong&gt;USHORT&lt;/strong&gt;, &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;LONG&lt;/strong&gt;, &lt;strong&gt;ULONG&lt;/strong&gt;, &lt;strong&gt;LONGLONG&lt;/strong&gt;, &lt;strong&gt;ULONGLONG&lt;/strong&gt;, &lt;strong&gt;INTP&lt;/strong&gt;, &lt;strong&gt;UINTP&lt;/strong&gt;</source>
          <target state="translated">이것은 &lt;code&gt;{type}&lt;/code&gt; = &lt;strong&gt;BYTE&lt;/strong&gt; , &lt;strong&gt;UBYTE&lt;/strong&gt; , &lt;strong&gt;SHORT&lt;/strong&gt; , &lt;strong&gt;USHORT&lt;/strong&gt; , &lt;strong&gt;INT에&lt;/strong&gt; 정의 된 모든 항목에 대해 정의됩니다 .&lt;strong&gt; UINT&lt;/strong&gt; , &lt;strong&gt;LONG&lt;/strong&gt; , &lt;strong&gt;ULONG&lt;/strong&gt; , &lt;strong&gt;LONGLONG&lt;/strong&gt; , &lt;strong&gt;ULONGLONG&lt;/strong&gt; , &lt;strong&gt;INTP&lt;/strong&gt; , &lt;strong&gt;UINTP에&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e53b90b8b35ae60046587f59e89f7b60e6df85a" translate="yes" xml:space="preserve">
          <source>This is different from &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;, which does not use cPickle but loads the NumPy binary .npy format.</source>
          <target state="translated">이것은 다른 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt; 의 cPickle하지만로드 NumPy와 바이너리 .npy 형식을 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ad4d2eb9b0ee11d28c4e5a349ba480c6768dfc79" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt; and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 의 다음 사용과 동일하지만 &lt;code&gt;ii&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각을 튜플 인덱스로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f5170749efab413ba3776c33568562d9c4634a7d" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">이는 다음 &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 사용과 동일하지만 &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각 을 인덱스 튜플로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="f723a36a0fdceaf5add767f4dfa10dbdef0cf27e" translate="yes" xml:space="preserve">
          <source>This is equivalent to (but faster than) the following use of &lt;code&gt;ndindex&lt;/code&gt; and &lt;code&gt;s_&lt;/code&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">이는 다음 &lt;code&gt;ndindex&lt;/code&gt; 및 &lt;code&gt;s_&lt;/code&gt; 사용과 동일하지만 &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각 을 인덱스 튜플로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="9623032760a445ce084ed7cad1f49c8e81cbc730" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt;. If &lt;code&gt;condition&lt;/code&gt; is boolean &lt;code&gt;np.extract&lt;/code&gt; is equivalent to &lt;code&gt;arr[condition]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;np.compress(ravel(condition), ravel(arr))&lt;/code&gt; . &lt;code&gt;condition&lt;/code&gt; 이 부울 인 경우 &lt;code&gt;np.extract&lt;/code&gt; 는 &lt;code&gt;arr[condition]&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="270d637e7c2130210ad3ee654e7e3067ac01221d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt;&lt;code&gt;compress_rowcols&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이것은 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; 와 동일합니다 . 자세한 내용 은 &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt; &lt;code&gt;compress_rowcols&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="512416aca8fa4fb317d305f7a3902a8f4f57268d" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">이것은 &lt;code&gt;np.ma.compress_rowcols(a, 0)&lt;/code&gt; 와 동일합니다 . 자세한 내용 은 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6ffd133d65cdedb57e33b341f8909e0c883dd56" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt;&lt;code&gt;compress_rowcols&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">이것은 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; 와 동일합니다 . 자세한 내용 은 &lt;a href=&quot;numpy.ma.compress_rowcols#numpy.ma.compress_rowcols&quot;&gt; &lt;code&gt;compress_rowcols&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="1aabefa5df0b67ecae64f8e5a2fb2a4d5dd2e5ee" translate="yes" xml:space="preserve">
          <source>This is equivalent to &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt;, see &lt;code&gt;extras.compress_rowcols&lt;/code&gt; for details.</source>
          <target state="translated">이는 &lt;code&gt;np.ma.compress_rowcols(a, 1)&lt;/code&gt; 과 &lt;code&gt;extras.compress_rowcols&lt;/code&gt; 합니다. 자세한 내용 은 extras.compress_rowcols 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2e12dd8fc795d33b8f8bcabb847c3e158c738c5e" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt;&lt;code&gt;vsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 1 차원 배열 후 첫 번째 축을 따라 연결하는 것과 같습니다. &lt;code&gt;(N,)&lt;/code&gt; 이 &lt;code&gt;(1,N)&lt;/code&gt; 으로 재구성 된 . &lt;a href=&quot;numpy.vsplit#numpy.vsplit&quot;&gt; &lt;code&gt;vsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="8a1612db7b39849ef3a6bd08b64bed8c3240f816" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the first axis after 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;vsplit&lt;/code&gt;.</source>
          <target state="translated">이것은 1 차원 배열 후 첫 번째 축을 따라 연결하는 것과 같습니다. &lt;code&gt;(N,)&lt;/code&gt; 이 &lt;code&gt;(1,N)&lt;/code&gt; 으로 재구성 된 . &lt;code&gt;vsplit&lt;/code&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e9676c88264ef3cd76556860f143548d10e94eb6" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 첫 번째 축을 따라 연결되는 1 차원 배열을 제외하고 두 번째 축을 따라 연결하는 것과 같습니다. &lt;a href=&quot;numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a5b26fca5a2a732affc24a30a8305bc7f4ee4d" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the second axis, except for 1-D arrays where it concatenates along the first axis. Rebuilds arrays divided by &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이는 첫 번째 축을 따라 연결되는 1 차원 배열을 제외하고 두 번째 축을 따라 연결하는 것과 같습니다. &lt;a href=&quot;numpy.ma.hsplit#numpy.ma.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="5f3f85e2c1a9f572b9f43cddeb78f8794cecabcf" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt;&lt;code&gt;dsplit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 2 차원 형상 배열 &lt;code&gt;(M,N)&lt;/code&gt; 이 &lt;code&gt;(M,N,1)&lt;/code&gt; 로 재 형성 되고 1 차원 형상 배열 &lt;code&gt;(N,)&lt;/code&gt; 이 다음으로 재 형성된 후 3 번째 축을 따라 연결되는 것과 같습니다. &lt;code&gt;(1,N,1)&lt;/code&gt; . &lt;a href=&quot;numpy.dsplit#numpy.dsplit&quot;&gt; &lt;code&gt;dsplit&lt;/code&gt; &lt;/a&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="5c6f9c31ab715a660b4d23dc2f49389f45ea5bda" translate="yes" xml:space="preserve">
          <source>This is equivalent to concatenation along the third axis after 2-D arrays of shape &lt;code&gt;(M,N)&lt;/code&gt; have been reshaped to &lt;code&gt;(M,N,1)&lt;/code&gt; and 1-D arrays of shape &lt;code&gt;(N,)&lt;/code&gt; have been reshaped to &lt;code&gt;(1,N,1)&lt;/code&gt;. Rebuilds arrays divided by &lt;code&gt;dsplit&lt;/code&gt;.</source>
          <target state="translated">이것은 2 차원 형상 배열 &lt;code&gt;(M,N)&lt;/code&gt; 이 &lt;code&gt;(M,N,1)&lt;/code&gt; 로 재 형성 되고 1 차원 형상 배열 &lt;code&gt;(N,)&lt;/code&gt; 이 다음으로 재 형성된 후 3 번째 축을 따라 연결되는 것과 같습니다. &lt;code&gt;(1,N,1)&lt;/code&gt; . &lt;code&gt;dsplit&lt;/code&gt; 으로 나눈 배열을 다시 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="d218a0a3e8c4c5860255504a9ba19c22b6fab14a" translate="yes" xml:space="preserve">
          <source>This is equivalent to np.nonzero(np.ravel(a))[0].</source>
          <target state="translated">이것은 np.nonzero (np.ravel (a)) [0]과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c1506fb5159fec603ce600935782977e9cc4a640" translate="yes" xml:space="preserve">
          <source>This is equivalent to the &lt;code&gt;density&lt;/code&gt; argument, but produces incorrect results for unequal bin widths. It should not be used.</source>
          <target state="translated">이것은 &lt;code&gt;density&lt;/code&gt; 인수 하지만 너비가 다른 빈 너비에 대해 잘못된 결과를 생성합니다. 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="59cfbae4022883700bb27212977a0aea4a1ca893" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">이것은 ptr 멤버까지 파이썬의 버퍼 객체 구조와 같습니다. 32 비트 플랫폼에서 ( &lt;em&gt;즉&lt;/em&gt; , &lt;a href=&quot;c-api.config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; 인&lt;/a&gt; 경우) == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; 인 경우 ) len 멤버는 버퍼 오브젝트의 동등한 멤버와도 일치합니다. 일반적인 단일 세그먼트 메모리 청크를 나타내는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4854fe34aab22a7dfbbaf3a63f41795215d42fdd" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;a href=&quot;config#c.NPY_SIZEOF_INTP&quot;&gt;&lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;&lt;/a&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">이것은 ptr 멤버까지 파이썬의 버퍼 객체 구조와 동일합니다. 32 비트 플랫폼 ( &lt;em&gt;즉&lt;/em&gt; , &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;a href=&quot;config#c.NPY_SIZEOF_INTP&quot;&gt; &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; &lt;/a&gt; )에서 len 멤버는 버퍼 개체의 동등한 멤버와도 일치합니다. 일반적인 단일 세그먼트 메모리 청크를 나타내는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0f80c76f4b696fc66848fb5ef4ea2fb36f89e0f9" translate="yes" xml:space="preserve">
          <source>This is equivalent to the buffer object structure in Python up to the ptr member. On 32-bit platforms (&lt;em&gt;i.e.&lt;/em&gt; if &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt;&lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt;), the len member also matches an equivalent member of the buffer object. It is useful to represent a generic single-segment chunk of memory.</source>
          <target state="translated">이것은 ptr 멤버까지 파이썬의 버퍼 객체 구조와 동일합니다. 32 비트 플랫폼 ( &lt;em&gt;즉&lt;/em&gt; , &lt;a href=&quot;config#c.NPY_SIZEOF_INT&quot;&gt; &lt;code&gt;NPY_SIZEOF_INT&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;NPY_SIZEOF_INTP&lt;/code&gt; )에서 len 멤버는 버퍼 개체의 동등한 멤버와도 일치합니다. 일반적인 단일 세그먼트 메모리 청크를 나타내는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="0c4a19f41f357e975c7ecf272280bda06a0a7837" translate="yes" xml:space="preserve">
          <source>This is equivalent to:</source>
          <target state="translated">이것은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="71a0da6263af85d6d95df709a66cce1cab814a13" translate="yes" xml:space="preserve">
          <source>This is for output arrays, and requires that the flag &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt;&lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt;&lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt;&lt;/a&gt; be set. If &lt;code&gt;op[i]&lt;/code&gt; is NULL, creates a new array with the final broadcast dimensions, and a layout matching the iteration order of the iterator.</source>
          <target state="translated">이것은 출력 배열을위한 것이며, &lt;a href=&quot;#c.NPY_ITER_WRITEONLY&quot;&gt; &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_READWRITE&quot;&gt; &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; &lt;/a&gt; 플래그를 설정해야합니다. 경우 &lt;code&gt;op[i]&lt;/code&gt; NULL 인 최종 방송 치수 새로운 배열 및 반복기의 반복 순서와 일치하는 레이아웃을 생성한다.</target>
        </trans-unit>
        <trans-unit id="e43476e1c5b08d4915c75da838fbd060f4d5522a" translate="yes" xml:space="preserve">
          <source>This is how subclasses of the ndarray class are able to return views that preserve the class type. When taking a view, the standard ndarray machinery creates the new ndarray object with something like:</source>
          <target state="translated">이것이 ndarray 클래스의 하위 클래스가 클래스 유형을 보존하는 뷰를 반환 할 수있는 방법입니다. 보기를 할 때 표준 ndarray 기계는 다음과 같은 새로운 ndarray 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="271064c73ce5e7dc4de339611f7b4db1a780a7f2" translate="yes" xml:space="preserve">
          <source>This is implemented using the &lt;code&gt;_geev&lt;/code&gt; LAPACK routines which compute the eigenvalues and eigenvectors of general square arrays.</source>
          <target state="translated">이것은 일반 정사각형 배열의 고유 값과 고유 벡터를 계산 하는 &lt;code&gt;_geev&lt;/code&gt; LAPACK 루틴을 사용하여 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="caec4ff4a054237a51c7a499531b302398f70bf8" translate="yes" xml:space="preserve">
          <source>This is indicated in the documentation via input parameter specifications such as &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt;. This means that if for instance given an input array &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt;, it is interpreted as a &amp;ldquo;stack&amp;rdquo; of N matrices, each of size M-by-M. Similar specification applies to return values, for instance the determinant has &lt;code&gt;det : (...)&lt;/code&gt; and will in this case return an array of shape &lt;code&gt;det(a).shape == (N,)&lt;/code&gt;. This generalizes to linear algebra operations on higher-dimensional arrays: the last 1 or 2 dimensions of a multidimensional array are interpreted as vectors or matrices, as appropriate for each operation.</source>
          <target state="translated">이것은 문서 &lt;code&gt;a : (..., M, M) array_like&lt;/code&gt; 와 같은 입력 매개 변수 스펙을 통해 표시됩니다 . 예를 들어 입력 배열에 &lt;code&gt;a.shape == (N, M, M)&lt;/code&gt; 을 부여하면 크기가 각각 MxM 인 N 행렬의 &quot;스택&quot;으로 해석됩니다. 예를 들어, 결정자가 &lt;code&gt;det : (...)&lt;/code&gt; 가지고 &lt;code&gt;det(a).shape == (N,)&lt;/code&gt; 경우 det (a) .shape == (N,) 모양의 배열을 반환합니다 . 이는 고차원 배열에서 선형 대수 연산을 일반화합니다. 다차원 배열의 마지막 1 차원 또는 2 차원은 각 연산에 ​​적합하게 벡터 또는 행렬로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="142401db7b88684f56ec37cbd8f1ca65b6bf6771" translate="yes" xml:space="preserve">
          <source>This is intended for working with source directories that are in an SVN repository.</source>
          <target state="translated">이것은 SVN 저장소에있는 소스 디렉토리로 작업하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="2fa46c7f117cac1c645f428d7403c2f212b4011c" translate="yes" xml:space="preserve">
          <source>This is like the builtin &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#issubclass&quot;&gt;&lt;code&gt;issubclass&lt;/code&gt;&lt;/a&gt;, but for &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이것은 내장 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#issubclass&quot;&gt; &lt;code&gt;issubclass&lt;/code&gt; &lt;/a&gt; 와 비슷하지만 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 의 경우입니다.</target>
        </trans-unit>
        <trans-unit id="f497c1d2afa9510500c0e5d52cafff444023b2a6" translate="yes" xml:space="preserve">
          <source>This is needed by all Python objects. It consists of (at least) a reference count member ( &lt;code&gt;ob_refcnt&lt;/code&gt; ) and a pointer to the typeobject ( &lt;code&gt;ob_type&lt;/code&gt; ). (Other elements may also be present if Python was compiled with special options see Include/object.h in the Python source tree for more information). The ob_type member points to a Python type object.</source>
          <target state="translated">이것은 모든 파이썬 객체에 필요합니다. 이는 (적어도) 참조 횟수 부재 (구성 &lt;code&gt;ob_refcnt&lt;/code&gt; ) 및 typeobject 포인터 ( &lt;code&gt;ob_type&lt;/code&gt; ). (파이썬이 특수 옵션으로 컴파일 된 경우 다른 요소도 존재할 수 있습니다. 자세한 내용은 파이썬 소스 트리에서 Include / object.h를 참조하십시오). ob_type 멤버는 Python 타입 객체를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="1833467ed646c8f15235c25f8dda305acdfb6a3c" translate="yes" xml:space="preserve">
          <source>This is not a comprehensive &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; reference. It&amp;rsquo;s tailored to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; hosting service. You may well find better or quicker ways of getting stuff done with &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt;, but these should get you started.</source>
          <target state="translated">이것은 포괄적 인 &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; 참조 가 아닙니다 . &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 호스팅 서비스에 맞게 조정되었습니다 . &lt;a href=&quot;https://git-scm.com/&quot;&gt;git으로&lt;/a&gt; 작업을 수행하는 더 좋고 더 빠른 방법을 찾을 수 있지만 시작하는 데 도움이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="d2a35d83e287759b7b772b39fa92c000861d127f" translate="yes" xml:space="preserve">
          <source>This is often used when a function returns multiple values:</source>
          <target state="translated">함수가 여러 값을 반환 할 때 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="daec8aebc5133f38a1a0c690c98645fa0bf3cd6e" translate="yes" xml:space="preserve">
          <source>This is particularly useful for evaluating functions of multiple dimensions on a regular grid.</source>
          <target state="translated">이것은 일반 그리드에서 여러 차원의 함수를 평가하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="26d53d8ee495c7f638b914dab0d30642c949b736" translate="yes" xml:space="preserve">
          <source>This is presumably the most common case of large array creation. The details, of course, depend greatly on the format of data on disk and so this section can only give general pointers on how to handle various formats.</source>
          <target state="translated">이것은 아마도 대규모 어레이 생성의 가장 일반적인 경우 일 것입니다. 물론 세부 사항은 디스크의 데이터 형식에 따라 크게 달라 지므로이 섹션에서는 다양한 형식을 처리하는 방법에 대한 일반적인 지침 만 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd8997d00c105166c9b4b9f773f5d0cdd6fa01f2" translate="yes" xml:space="preserve">
          <source>This is raised when an binary operation is passed Poly objects with different domains.</source>
          <target state="translated">이진 작업에 도메인이 다른 Poly 객체가 전달 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e57f721854d8f362e4016c48c315f6301f247f80" translate="yes" xml:space="preserve">
          <source>This is really &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt; with different defaults. For more details see &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt;&lt;code&gt;irfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 기본값 이 &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; &lt;/a&gt; 실제로 중요하지 않습니다 . 자세한 내용은 &lt;a href=&quot;numpy.fft.irfftn#numpy.fft.irfftn&quot;&gt; &lt;code&gt;irfftn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed9f359368f007790ca5657cc8ec4082492a200b" translate="yes" xml:space="preserve">
          <source>This is really just &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt; with different default behavior. For more details see &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 실제로 다른 기본 동작으로 &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 입니다. 자세한 내용은 &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="77938c782ff5f0e5fde7cba046a7d880a01771f8" translate="yes" xml:space="preserve">
          <source>This is reasonable enough, but watch out if you want to use Python&amp;rsquo;s &lt;code&gt;+=&lt;/code&gt; construct, as it may not do what you expect:</source>
          <target state="translated">이것은 충분히 합리적이지만 Python의 &lt;code&gt;+=&lt;/code&gt; 구문 을 사용하려는 경우 예상 한대로 작동하지 않을 수 있으므로주의하십시오.</target>
        </trans-unit>
        <trans-unit id="5ef26806f6ea74b6485ab483c2778eff715e4572" translate="yes" xml:space="preserve">
          <source>This is short-hand for &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt;, which is useful because of its common occurrence. In particular, arrays will be stacked along their last axis after being upgraded to at least 2-D with 1&amp;rsquo;s post-pended to the shape (column vectors made out of 1-D arrays).</source>
          <target state="translated">이것은 &lt;code&gt;np.r_['-1,2,0', index expression]&lt;/code&gt; 이며, 일반적으로 발생하기 때문에 유용합니다. 특히, 배열은 모양 (1 차원 배열로 이루어진 열 벡터)에 1을 포스트 보류 한 상태에서 최소 2 차원으로 업그레이드 한 후 마지막 축을 따라 쌓입니다.</target>
        </trans-unit>
        <trans-unit id="1c88394abdc65a1b05a8dd5d8683693375531a89" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) except you specify the data-type descriptor with &lt;em&gt;type_num&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt;, where &lt;em&gt;type_num&lt;/em&gt; corresponds to a builtin (or user-defined) type. If the type always has the same number of bytes, then itemsize is ignored. Otherwise, itemsize specifies the particular size of this array.</source>
          <target state="translated">이 유사하다 &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; 당신이 가진 데이터 형 기술자 지정 제외 (...) &lt;em&gt;type_num&lt;/em&gt; 및 &lt;em&gt;itemsize을&lt;/em&gt; 여기서 &lt;em&gt;type_num의&lt;/em&gt; 내장 명령 (또는 사용자 정의) 유형에 해당합니다. 유형이 항상 같은 수의 바이트를 갖는 경우 itemsize는 무시됩니다. 그렇지 않으면 itemsize는이 배열의 특정 크기를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ed43500d52b0e3a9d4bae70ddb5bfbe100ff1dd8" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt;&lt;code&gt;logspace&lt;/code&gt;&lt;/a&gt;, but with endpoints specified directly. Each output sample is a constant multiple of the previous.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.logspace#numpy.logspace&quot;&gt; &lt;code&gt;logspace&lt;/code&gt; &lt;/a&gt; 와 비슷 하지만 엔드 포인트가 직접 지정되었습니다. 각 출력 샘플은 이전의 일정한 배수입니다.</target>
        </trans-unit>
        <trans-unit id="c5fcd33629df929b0bdb1a57cfbe776ef13fe120" translate="yes" xml:space="preserve">
          <source>This is similar to &lt;code&gt;apply_along_axis&lt;/code&gt;, but treats the fields of a structured array as an extra axis. The fields are all first cast to a common type following the type-promotion rules from &lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;numpy.result_type&lt;/code&gt;&lt;/a&gt; applied to the field&amp;rsquo;s dtypes.</source>
          <target state="translated">이는 &lt;code&gt;apply_along_axis&lt;/code&gt; 와 유사 하지만 구조화 된 배열의 필드를 추가 축으로 취급합니다. 필드는 필드의 dtype에 적용된 &lt;a href=&quot;../reference/generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;numpy.result_type&lt;/code&gt; &lt;/a&gt; 의 유형 승격 규칙에 따라 먼저 공통 유형으로 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="852b3e753a1b8cdcb6346c93877a110d2d715f72" translate="yes" xml:space="preserve">
          <source>This is similar to choose or select, except that functions are evaluated on elements of &lt;code&gt;x&lt;/code&gt; that satisfy the corresponding condition from &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; 의 해당 조건을 만족하는 &lt;code&gt;x&lt;/code&gt; 의 요소에 대해 함수가 평가된다는 점을 제외하면 선택 또는 선택과 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="2c3a50a4a39023a7aa06d7ec91f3ecdac2409160" translate="yes" xml:space="preserve">
          <source>This is the &amp;ldquo;average&amp;rdquo; periodically compounded rate of return that gives a net present value of 0.0; for a more complete explanation, see Notes below.</source>
          <target state="translated">이는 순 현재 가치 0.0을 제공하는 &quot;평균&quot;주기적으로 복합 수익률입니다. 자세한 설명은 아래 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0dbc891d865ae88284f9bfa0a0edbf0c765484c8" translate="yes" xml:space="preserve">
          <source>This is the 1-d core function used by the dynamic ufuncs created by umath.frompyfunc(function, nin, nout). In this case &lt;em&gt;func&lt;/em&gt; is a pointer to a &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt;&lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt;&lt;/a&gt; structure which has definition</source>
          <target state="translated">이것은 umath.frompyfunc (function, nin, nout)에 의해 생성 된 동적 ufunc에 의해 사용되는 1 차원 핵심 함수입니다. 이 경우 &lt;em&gt;func&lt;/em&gt; 은 정의가 있는 &lt;a href=&quot;#c.PyUFunc_PyFuncData&quot;&gt; &lt;code&gt;PyUFunc_PyFuncData&lt;/code&gt; &lt;/a&gt; 구조에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="692a8cf195747eb5dfe92c87d684aef132c27f68" translate="yes" xml:space="preserve">
          <source>This is the NumPy implementation of the C library function fmod, the remainder has the same sign as the dividend &lt;code&gt;x1&lt;/code&gt;. It is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function and should not be confused with the Python modulus operator &lt;code&gt;x1 % x2&lt;/code&gt;.</source>
          <target state="translated">이것은 C 라이브러리 함수 fmod의 NumPy 구현이며 나머지는 피제수 &lt;code&gt;x1&lt;/code&gt; 과 동일한 부호를 갖습니다 . Matlab (TM) &lt;code&gt;rem&lt;/code&gt; 함수와 동일하며 Python 모듈러스 연산자 &lt;code&gt;x1 % x2&lt;/code&gt; 와 혼동해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f70c1d8b15029e4bba377d8eb228f8ad3621041" translate="yes" xml:space="preserve">
          <source>This is the code that handles the situation whenever the input and/or output arrays are either misaligned or of the wrong data-type (including being byte-swapped) from what the underlying 1-D loop expects. The arrays are also assumed to be non-contiguous. The code works very much like the strided-loop except for the inner 1-D loop is modified so that pre-processing is performed on the inputs and post- processing is performed on the outputs in bufsize chunks (where bufsize is a user-settable parameter). The underlying 1-D computational loop is called on data that is copied over (if it needs to be). The setup code and the loop code is considerably more complicated in this case because it has to handle:</source>
          <target state="translated">이것은 입력 및 / 또는 출력 배열이 잘못 정렬되거나 기본 1-D 루프가 기대하는 것과 잘못된 데이터 유형 (바이트 스왑 포함)이 될 때마다 상황을 처리하는 코드입니다. 또한 배열은 비 연속적인 것으로 가정합니다. 이 코드는 내부 1D 루프가 수정되어 입력에서 사전 처리가 수행되고 사후 처리가 bufsize 청크 (출력이 bufsize가 사용자 설정 가능)로 수행되는 것을 제외하고는 strided-loop와 매우 유사하게 작동합니다. 매개 변수). 기본 1D 계산 루프는 복사해야하는 데이터에 대해 호출됩니다 (필요한 경우). 이 경우 설정 코드와 루프 코드는 다음을 처리해야하기 때문에 상당히 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="97fdbbb09a00c84ec3c672ccc77676c7df568ed7" translate="yes" xml:space="preserve">
          <source>This is the docstring for the example.py module. Modules names should have short, all-lowercase names. The module name may have underscores if this improves readability.</source>
          <target state="translated">이것은 example.py 모듈의 독 스트링입니다. 모듈 이름은 모두 소문자로 된 짧은 이름이어야합니다. 가독성이 향상되면 모듈 이름에 밑줄이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="938b03b0272fe214e0bd4545d8c331ea33459bae" translate="yes" xml:space="preserve">
          <source>This is the exact same method signature for &lt;code&gt;np.sum&lt;/code&gt;, so now if a user calls &lt;code&gt;np.sum&lt;/code&gt; on this object, numpy will call the object&amp;rsquo;s own &lt;code&gt;sum&lt;/code&gt; method and pass in these arguments enumerated above in the signature, and no errors will be raised because the signatures are completely compatible with each other.</source>
          <target state="translated">이것은 &lt;code&gt;np.sum&lt;/code&gt; 에 대한 동일한 메서드 서명 이므로 이제 사용자 가이 개체에 대해 &lt;code&gt;np.sum&lt;/code&gt; 을 호출하면 numpy는 개체의 자체 &lt;code&gt;sum&lt;/code&gt; 메서드를 호출 하고 서명에서 위에 열거 된 이러한 인수를 전달하며 오류가 발생하지 않습니다. 서명이 서로 완전히 호환되기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="754ab86dfdc616fd9f3289ae80c9fb161f6f47b6" translate="yes" xml:space="preserve">
          <source>This is the main array creation function. Most new arrays are created with this flexible function.</source>
          <target state="translated">이것이 주요 어레이 생성 기능입니다. 대부분의 새로운 어레이는이 유연한 기능으로 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="ae96a364309b5dfa1ba1a5f179699cc1e3ea0752" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method of &lt;em&gt;op&lt;/em&gt; and is only used if the array is constructed that way. Almost always this parameter is &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">중첩 된 시퀀스 또는 배열 인터페이스를 노출하는 객체 &lt;em&gt;op&lt;/em&gt; 에서 배열을 얻는 데 사용되는 주요 함수 입니다. 매개 변수를 사용하면 필요한 &lt;em&gt;dtype&lt;/em&gt; , 최소 ( &lt;em&gt;min_depth&lt;/em&gt; ) 및 최대 ( &lt;em&gt;max_depth&lt;/em&gt; ) 차원의 허용 가능한 수 및 배열에 대한 기타 &lt;em&gt;요구 사항&lt;/em&gt; 을 &lt;em&gt;지정할&lt;/em&gt; 수 있습니다. 이 함수 는 dtype 인수에 &lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔칩니다.&lt;/strong&gt; 이는 원하는 데이터 유형 (필수 바이트 순서 포함)을 나타내는 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 여야 합니다. &lt;em&gt;DTYPE의&lt;/em&gt; 인자 일 수있다 &lt;code&gt;NULL&lt;/code&gt; 데이터 타입 (및 바이트 순서)이 허용되는 것을 나타낸다. 하지 않는 한 &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt; &lt;code&gt;flags&lt;/code&gt; 존재이 호출은 객체에서 데이터 유형을 안전하게 얻을 수없는 경우 오류를 생성합니다. 당신이 사용하려는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 에 대한 &lt;em&gt;DTYPE&lt;/em&gt; 와 배열이 다음 사용 notswapped되어 있는지 확인 &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; 을&lt;/a&gt; . 깊이 매개 변수 중 하나의 값이 0이면 매개 변수가 무시됩니다. &lt;em&gt;요구 사항&lt;/em&gt; 인수 를 얻기 위해 다음 배열 플래그를 추가 할 수 있습니다 ( &lt;em&gt;예 :&lt;/em&gt; | 사용) . 코드가 일반 ( &lt;em&gt;예 :&lt;/em&gt; 스트라이드, 바이트 스왑 또는 정렬되지 않은 배열)을 처리 할 수있는 경우 &lt;em&gt;요구 사항&lt;/em&gt; 은 0 일 수 있습니다. 또한 이미 배열이 아닌 경우 (또는 배열 인터페이스를 표시하지 않는 경우) 새 배열이 생성됩니다 ( 그리고 &lt;em&gt;op&lt;/em&gt; 에서 채워&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt; 연산&lt;/em&gt;&lt;em&gt;&lt;/em&gt;순서 프로토콜을 사용하여 ). 새로운 배열은 플래그 멤버로 &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; 를 갖 습니다 . &lt;em&gt;컨텍스트&lt;/em&gt; 인자는에 전달 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 방법 &lt;em&gt;OP&lt;/em&gt; 어레이 그렇게 구성되는 경우에만 사용된다. 거의 항상이 매개 변수는 &lt;code&gt;NULL&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4ef891de4e312961f5d43ee05c17aa291119de54" translate="yes" xml:space="preserve">
          <source>This is the main function used to obtain an array from any nested sequence, or object that exposes the array interface, &lt;em&gt;op&lt;/em&gt;. The parameters allow specification of the required &lt;em&gt;dtype&lt;/em&gt;, the minimum (&lt;em&gt;min_depth&lt;/em&gt;) and maximum (&lt;em&gt;max_depth&lt;/em&gt;) number of dimensions acceptable, and other &lt;em&gt;requirements&lt;/em&gt; for the array. This function &lt;strong&gt;steals a reference&lt;/strong&gt; to the dtype argument, which needs to be a &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure indicating the desired data-type (including required byteorder). The &lt;em&gt;dtype&lt;/em&gt; argument may be &lt;code&gt;NULL&lt;/code&gt;, indicating that any data-type (and byteorder) is acceptable. Unless &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; is present in &lt;code&gt;flags&lt;/code&gt;, this call will generate an error if the data type cannot be safely obtained from the object. If you want to use &lt;code&gt;NULL&lt;/code&gt; for the &lt;em&gt;dtype&lt;/em&gt; and ensure the array is notswapped then use &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt;. A value of 0 for either of the depth parameters causes the parameter to be ignored. Any of the following array flags can be added (&lt;em&gt;e.g.&lt;/em&gt; using |) to get the &lt;em&gt;requirements&lt;/em&gt; argument. If your code can handle general (&lt;em&gt;e.g.&lt;/em&gt; strided, byte-swapped, or unaligned arrays) then &lt;em&gt;requirements&lt;/em&gt; may be 0. Also, if &lt;em&gt;op&lt;/em&gt; is not already an array (or does not expose the array interface), then a new array will be created (and filled from &lt;em&gt;op&lt;/em&gt; using the sequence protocol). The new array will have &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt;&lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt;&lt;/a&gt; as its flags member. The &lt;em&gt;context&lt;/em&gt; argument is unused.</source>
          <target state="translated">중첩 시퀀스 또는 배열 인터페이스 &lt;em&gt;op&lt;/em&gt; 를 노출하는 객체에서 배열을 가져 오는 데 사용되는 기본 함수 입니다. 매개 변수를 사용하면 필요한 &lt;em&gt;dtype&lt;/em&gt; , 허용 가능한 최소 ( &lt;em&gt;min_depth&lt;/em&gt; ) 및 최대 ( &lt;em&gt;max_depth&lt;/em&gt; ) 차원 수 및 배열에 대한 기타 &lt;em&gt;요구 사항&lt;/em&gt; 을 &lt;em&gt;지정할&lt;/em&gt; 수 있습니다. 이 함수 는 원하는 데이터 유형 (필수 바이트 순서 포함)을 나타내는 &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 여야하는 dtype 인수에 &lt;strong&gt;대한 참조&lt;/strong&gt; 를 &lt;strong&gt;훔칩니다&lt;/strong&gt; . &lt;em&gt;DTYPE의&lt;/em&gt; 인자 일 수있다 &lt;code&gt;NULL&lt;/code&gt; 데이터 타입 (및 바이트 순서)이 허용되는 것을 나타낸다. 하지 않는 한 &lt;a href=&quot;#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt;&lt;em&gt;&lt;/em&gt;이 &lt;code&gt;flags&lt;/code&gt; 에있는 경우이 호출은 객체에서 데이터 유형을 안전하게 가져올 수없는 경우 오류를 생성합니다. 당신이 사용하려는 경우 &lt;code&gt;NULL&lt;/code&gt; 을 에 대한 &lt;em&gt;DTYPE&lt;/em&gt; 와 배열이 다음 사용 notswapped되어 있는지 확인 &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; 을&lt;/a&gt; . 깊이 매개 변수 중 하나의 값이 0이면 매개 변수가 무시됩니다. 다음 배열 플래그 중 하나를 추가 ( &lt;em&gt;예 :&lt;/em&gt; | 사용)하여 &lt;em&gt;요구 사항&lt;/em&gt; 인수 를 가져올 수 있습니다. 코드가 일반 ( &lt;em&gt;예 :&lt;/em&gt; strided, byte-swapped 또는 unaligned 배열)을 처리 할 수있는 경우 &lt;em&gt;요구 사항&lt;/em&gt; 은 0이 될 수 있습니다. 또한 &lt;em&gt;op&lt;/em&gt;이미 배열이 아닌 경우 (또는 배열 인터페이스를 노출하지 않음) 새 배열이 생성 되고 시퀀스 프로토콜을 사용하여 &lt;em&gt;op&lt;/em&gt; 에서 채워집니다 . 새 배열에는 플래그 멤버로 &lt;a href=&quot;#c.NPY_ARRAY_DEFAULT&quot;&gt; &lt;code&gt;NPY_ARRAY_DEFAULT&lt;/code&gt; &lt;/a&gt; 가 있습니다 . &lt;em&gt;컨텍스트&lt;/em&gt; 인수는 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0edcab26afcb3f2afd03c8c948c52b8fae9f82e5" translate="yes" xml:space="preserve">
          <source>This is the manual followed by NumPy&amp;rsquo;s Code of Conduct Committee. It&amp;rsquo;s used when we respond to an issue to make sure we&amp;rsquo;re consistent and fair.</source>
          <target state="translated">이것은 NumPy의 행동 강령위원회가 따르는 매뉴얼입니다. 일관성 있고 공정한지 확인하기 위해 문제에 응답 할 때 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5ec8c6b5a6fa5ea604ca73fde0faa7f48e61f60d" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;. For details see &lt;a href=&quot;numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; 의 마스크 배열 버전입니다 . 자세한 내용은 &lt;a href=&quot;numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5b5fdafede3bb67234ee18c22a5b997e8095961" translate="yes" xml:space="preserve">
          <source>This is the masked array version of &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;lib.index_tricks.RClass&lt;/code&gt; 의 마스크 배열 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="bf3cf3ae9cebee8b7306a5e44915e23de00facf1" translate="yes" xml:space="preserve">
          <source>This is the masked equivalent of the &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt;&lt;code&gt;numpy.resize&lt;/code&gt;&lt;/a&gt; function. The new array is filled with repeated copies of &lt;code&gt;x&lt;/code&gt; (in the order that the data are stored in memory). If &lt;code&gt;x&lt;/code&gt; is masked, the new array will be masked, and the new mask will be a repetition of the old one.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.resize#numpy.resize&quot;&gt; &lt;code&gt;numpy.resize&lt;/code&gt; &lt;/a&gt; 함수에 해당하는 마스크 입니다. 새 어레이는 &lt;code&gt;x&lt;/code&gt; 의 반복 된 사본으로 채워집니다 (데이터가 메모리에 저장된 순서대로). 경우 &lt;code&gt;x&lt;/code&gt; 마스크, 새로운 배열은 마스크되고, 새로운 마스크는 이전의 반복 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="0cb42e32affa717b335b3825c72824c3d8e04997" translate="yes" xml:space="preserve">
          <source>This is the most flexible form of specification since it allows control over the byte-offsets of the fields and the itemsize of the structure.</source>
          <target state="translated">이것은 필드의 바이트 오프셋과 구조의 항목 화를 제어 할 수 있기 때문에 가장 유연한 형식의 사양입니다.</target>
        </trans-unit>
        <trans-unit id="e638e46153cb5bd9d2b2cfadb202d5a4f7f60071" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt;, but it returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">이것은 &lt;a href=&quot;numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; 과 동일 하지만 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 객체를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="b28c44c91a00424416f03ba6b4985acf74627eb2" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; 가&lt;/a&gt; 반환 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="22b8e33a3b4d40024b90c85a13a94be90c9158a1" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; would return an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; 가&lt;/a&gt; 반환 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1090f814c7b352e9c36a05ce2322d963cddbde3" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; 가&lt;/a&gt; ndarray을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="74e44d918d1f15516605ec010845ff539cc17530" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt;, but returns a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object where &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; would return an ndarray.</source>
          <target state="translated">이것은과 동일 &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; 하지만 반환 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 개체 &lt;a href=&quot;numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; 가&lt;/a&gt; ndarray을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="124e720446d4f3612122d427a64991837042df14" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">이것과 동일 &lt;a href=&quot;numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; 곳을 제외 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 가&lt;/a&gt; 반환 될 것이다하는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 이 아닌 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="a0acdb03a11a0405720f9b33ec10bd3e67d6e4fa" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">이것과 동일 &lt;a href=&quot;numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; 곳을 제외 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 가&lt;/a&gt; 반환 될 것이다하는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 이 아닌 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="1b894bff66f53b91713c65daaeb95b50cb72fdfc" translate="yes" xml:space="preserve">
          <source>This is the same as &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt;&lt;code&gt;ndarray.var&lt;/code&gt;&lt;/a&gt;, except that where an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; would be returned, a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; object is returned instead.</source>
          <target state="translated">이것과 동일 &lt;a href=&quot;numpy.ndarray.var#numpy.ndarray.var&quot;&gt; &lt;code&gt;ndarray.var&lt;/code&gt; &lt;/a&gt; 곳을 제외 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 가&lt;/a&gt; 반환 될 것이다하는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 이 아닌 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="d6c0a4b3ef29201f690f9b9b88a69b8608d63748" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_nextafter and npy_nextafterf described in the low-level floating point section.</source>
          <target state="translated">이는 하위 수준 부동 소수점 섹션에 설명 된 npy_nextafter 및 npy_nextafterf와 같은 반 정밀도 부동 소수점과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="5a28a11e64cd4476f1fd45344cb04aff7bece602" translate="yes" xml:space="preserve">
          <source>This is the same for half-precision float as npy_spacing and npy_spacingf described in the low-level floating point section.</source>
          <target state="translated">이는 하위 수준 부동 소수점 섹션에 설명 된 npy_spacing 및 npy_spacingf와 같은 반 정밀도 부동 소수점과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="69592e67862b42a94f582425221058b3b2e662f2" translate="yes" xml:space="preserve">
          <source>This is the same polynomial as obtained by:</source>
          <target state="translated">이것은 다음과 같은 다항식입니다.</target>
        </trans-unit>
        <trans-unit id="8f841f69094513c4d7f4558bcdd113fb62e5f1f7" translate="yes" xml:space="preserve">
          <source>This is the simplest case of all. The ufunc is executed by calling the underlying 1-D loop exactly once. This is possible only when we have aligned data of the correct type (including byte-order) for both input and output and all arrays have uniform strides (either contiguous, 0-D, or 1-D). In this case, the 1-D computational loop is called once to compute the calculation for the entire array. Note that the hardware error flags are only checked after the entire calculation is complete.</source>
          <target state="translated">이것은 가장 간단한 경우입니다. ufunc는 기본 1-D 루프를 정확히 한 번 호출하여 실행됩니다. 이것은 입력과 출력 모두에 대해 올바른 유형 (바이트 순서 포함)의 데이터를 정렬하고 모든 배열에 균일 한 보폭 (연속, 0-D 또는 1-D)이있는 경우에만 가능합니다. 이 경우 전체 배열에 대한 계산을 계산하기 위해 1D 계산 루프가 한 번 호출됩니다. 하드웨어 오류 플래그는 전체 계산이 완료된 후에 만 ​​확인됩니다.</target>
        </trans-unit>
        <trans-unit id="963cd66868f04208a7a1c2183e363716e0ef0cf2" translate="yes" xml:space="preserve">
          <source>This is the type which exposes the iterator to Python. Currently, no API is exposed which provides access to the values of a Python-created iterator. If an iterator is created in Python, it must be used in Python and vice versa. Such an API will likely be created in a future version.</source>
          <target state="translated">이것은 반복자를 파이썬에 노출시키는 유형입니다. 현재 Python으로 작성된 반복자의 값에 액세스 할 수있는 API가 노출되어 있지 않습니다. 반복자가 Python으로 작성된 경우 Python에서 반복자를 사용해야합니다. 이러한 API는 향후 버전에서 생성 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="4b42439256132aabca2f53b261c973f7c679d369" translate="yes" xml:space="preserve">
          <source>This is useful for setting up an accumulation loop, for example. The iterator can first be created with all the dimensions, including the accumulation axis, so that the output gets created correctly. Then, the accumulation axis can be removed, and the calculation done in a nested fashion.</source>
          <target state="translated">예를 들어 누적 루프를 설정하는 데 유용합니다. 반복자는 누적 축을 포함한 모든 차원으로 생성되어 출력이 올바르게 생성 될 수 있습니다. 그런 다음 누적 축을 제거하고 계산을 중첩 방식으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5300cb088270de52a08527e24f73ff59ea30c2bb" translate="yes" xml:space="preserve">
          <source>This is useful in a setup.py script for adding sub-packages to a package.</source>
          <target state="translated">이는 패키지에 하위 패키지를 추가하기 위해 setup.py 스크립트에서 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6e4aa46e2220dff2f0d0703b94a0af6befef5473" translate="yes" xml:space="preserve">
          <source>This is wonderful because the function writer doesn&amp;rsquo;t have to manually propagate infs or nans.</source>
          <target state="translated">함수 작성자가 infs 또는 nans를 수동으로 전파 할 필요가 없기 때문에 이것은 훌륭합니다.</target>
        </trans-unit>
        <trans-unit id="82959a96175cd052449eddf58c5c4610e0b21bd3" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to look up values in the latter. These slices can be different lengths.</source>
          <target state="translated">이는 인덱스 및 데이터 배열에서 지정된 축을 따라 일치하는 일치하는 1d 슬라이스를 반복하며 후자를 사용하여 후자를 찾습니다. 이 슬라이스는 길이가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c175a7e11a936be20457fa33dc8778b062c8741" translate="yes" xml:space="preserve">
          <source>This iterates over matching 1d slices oriented along the specified axis in the index and data arrays, and uses the former to place values into the latter. These slices can be different lengths.</source>
          <target state="translated">이는 인덱스 및 데이터 배열에서 지정된 축을 따라 정렬 된 일치하는 1d 슬라이스를 반복하며 전자를 사용하여 값을 후자에 배치합니다. 이 슬라이스는 길이가 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d9086a3e8f6e523e455adb859a4bc6cbea3019a" translate="yes" xml:space="preserve">
          <source>This iterator returns elements of the array to be iterated over in &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt; one by one. It is similar to &lt;code&gt;flatiter&lt;/code&gt;.</source>
          <target state="translated">이 반복자는 배열의 요소를 &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; 에서&lt;/a&gt; 하나씩 반복하여 반환합니다 . &lt;code&gt;flatiter&lt;/code&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="f3aa62850b827d280ac62636d6a8e3df18a980ad" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">이것은 &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt; 값을 반환합니다 . &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt; 은 API가 변경 될 때마다 변경됩니다 (예 : 함수가 추가됨). 변경된 값이 항상 재 컴파일 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="9621dd1cff206294072ec88c5bdff12776a1ac23" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; changes whenever a backward incompatible change at the ABI level. Because it is in the C-API, however, comparing the output of this function from the value defined in the current header gives a way to test if the C-API has changed thus requiring a re-compilation of extension modules that use the C-API. This is automatically checked in the function &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이것은 단지 &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; 값을 리턴합니다 . &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; 은 ABI 수준에서 이전 버전과 호환되지 않을 때마다 변경됩니다. 그러나 C-API에 있기 때문에 현재 헤더에 정의 된 값과이 함수의 출력을 비교하면 C-API가 변경되었는지 테스트하여 C를 사용하는 확장 모듈을 다시 컴파일해야합니다. -API. 이것은 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 함수에서 자동으로 확인됩니다 .</target>
        </trans-unit>
        <trans-unit id="75e16e673218df8f16a0a1029a429a437c420b9d" translate="yes" xml:space="preserve">
          <source>This just returns the value &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;. &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; changes whenever the API changes (e.g. a function is added). A changed value does not always require a recompile.</source>
          <target state="translated">이것은 단지 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 값을 리턴합니다 . &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 은 API가 변경 될 때마다 변경됩니다 (예 : 함수 추가). 변경된 값이 항상 재 컴파일을 요구하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="57131d2cbf8754e0c0045e65c405a8ff98703b38" translate="yes" xml:space="preserve">
          <source>This macro is defined to +inf.</source>
          <target state="translated">이 매크로는 + inf로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8ca63ad5bc4e1dded64f0ca2a056ab5d5c7f090f" translate="yes" xml:space="preserve">
          <source>This macro is defined to -1.0.</source>
          <target state="translated">이 매크로는 -1.0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b30ee77ae33429489972a6d1172613ede0e766a9" translate="yes" xml:space="preserve">
          <source>This macro is defined to -inf.</source>
          <target state="translated">이 매크로는 -inf로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="b8842c8583817136af82824b8e5fdbb3f9c76f6e" translate="yes" xml:space="preserve">
          <source>This macro is defined to 1.0.</source>
          <target state="translated">이 매크로는 1.0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="bd01732ce89574cb085cbbd769f60ac683ce37ab" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN (Not a Number), and is guaranteed to have the signbit unset (&amp;lsquo;positive&amp;rsquo; NaN). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 NaN (숫자가 아님)으로 정의되며 부호 비트가 설정되지 않은 ( '긍정적 인'NaN) 보장됩니다. 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="305a7f44534276994ed187e38461a42eaeb6b275" translate="yes" xml:space="preserve">
          <source>This macro is defined to a NaN value, guaranteed to have its sign bit unset.</source>
          <target state="translated">이 매크로는 NaN 값으로 정의되며 부호 비트가 설정되지 않았 음을 보장합니다.</target>
        </trans-unit>
        <trans-unit id="15a2136199da842d310792facc84af7246036426" translate="yes" xml:space="preserve">
          <source>This macro is defined to a positive inf. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 긍정적 인 정보로 정의됩니다. 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5ea17d1f0932fffe7fa9472293549c952ff5b71" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero (that is with the sign bit set). The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 음의 0으로 정의됩니다 (즉, 부호 비트가 설정되어 있음). 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ffbdfd1fb5a238c0e6b132bd7b25e886a8862b" translate="yes" xml:space="preserve">
          <source>This macro is defined to negative zero.</source>
          <target state="translated">이 매크로는 음의 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="6499719d1e23e1af1e93848438b61bc7bf9fb167" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero.</source>
          <target state="translated">이 매크로는 양의 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="c804fcf19685f98f19d42c1dc7c110945817d41e" translate="yes" xml:space="preserve">
          <source>This macro is defined to positive zero. The corresponding single and extension precision macro are available with the suffix F and L.</source>
          <target state="translated">이 매크로는 양의 0으로 정의됩니다. 해당 단일 및 확장 정밀도 매크로는 접미사 F 및 L과 함께 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c35e4d492b4b66e88cf91e279bf815b9c6ef74c" translate="yes" xml:space="preserve">
          <source>This manual contains many examples of use, usually prefixed with the Python prompt &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (which is not a part of the example code). The examples assume that you have first entered:</source>
          <target state="translated">이 설명서에는 일반적으로 Python 프롬프트 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; (예제 코드의 일부가 아님)가 접두사로 붙은 많은 사용 예가 포함되어 있습니다 . 예제에서는 다음을 처음 입력했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fc87f3907c86c15e0fab69c802c5a342d7203e00" translate="yes" xml:space="preserve">
          <source>This may be clearer with an example.</source>
          <target state="translated">이것은 예를 통해 더 명확해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bc3434d0927f2e6cdc4fb04c1ef64578863b34f8" translate="yes" xml:space="preserve">
          <source>This may be used to read an existing file or create a new one.</source>
          <target state="translated">기존 파일을 읽거나 새 파일을 만드는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb4ec39a1dbea334a71074f67fa1cd07017f1cdf" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;a href=&quot;#c.NpyIter_RemoveAxis&quot;&gt;&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt;&lt;/a&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">피연산자 축을 어떤 방식으로 일치시키고 &lt;a href=&quot;#c.NpyIter_RemoveAxis&quot;&gt; &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; &lt;/a&gt; 로 제거하여 수동으로 처리 할 때 사용할 수 있습니다 . 축을 제거하기 전에이 함수를 호출하면 수동 처리를위한 보폭을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c451240677ff61c1a609e49bd0f07f461a99c611" translate="yes" xml:space="preserve">
          <source>This may be used when you want to match up operand axes in some fashion, then remove them with &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; to handle their processing manually. By calling this function before removing the axes, you can get the strides for the manual processing.</source>
          <target state="translated">이것은 어떤 방식으로 피연산자 축을 일치시키고 &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 로 제거하여 처리를 수동으로 처리 할 때 사용할 수 있습니다 . 축을 제거하기 전에이 기능을 호출하면 수동 처리를위한 보폭을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="272240144b37c5af402b352038a269eb5d08f543" translate="yes" xml:space="preserve">
          <source>This may mainly help you if you are not running the python and/or NumPy version you are expecting to run.</source>
          <target state="translated">이것은 실행하고자하는 파이썬 및 / 또는 NumPy 버전을 실행하지 않는 경우 주로 도움이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c92d427e914a0dd599016040f8fd75a2d48dc062" translate="yes" xml:space="preserve">
          <source>This means that (i) we want to edit the commit message for &lt;code&gt;13d7934&lt;/code&gt;, and (ii) collapse the last three commits into one. Now we save and quit the editor.</source>
          <target state="translated">이것은 (i) &lt;code&gt;13d7934&lt;/code&gt; 에 대한 커밋 메시지를 편집 하고 (ii) 마지막 세 커밋을 하나로 축소 한다는 것을 의미합니다 . 이제 편집기를 저장하고 종료합니다.</target>
        </trans-unit>
        <trans-unit id="c9eb6e1f385480cd888cdacc62c2f757c4de3926" translate="yes" xml:space="preserve">
          <source>This mechanism should support all compilers and it doesn&amp;rsquo;t require any compiler-specific extension, but at the same time it is adds a few steps to normal compilation that are explained as follows:</source>
          <target state="translated">이 메커니즘은 모든 컴파일러를 지원해야하며 컴파일러 관련 확장이 필요하지 않지만 동시에 다음과 같이 설명되는 일반 컴파일에 몇 가지 단계가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="85b5c517a58e8aeec834229928a8cecac10d6dff" translate="yes" xml:space="preserve">
          <source>This member allows array objects to have weak references (using the weakref module).</source>
          <target state="translated">이 멤버는 배열 객체가 약한 참조를 가질 수 있도록합니다 (weakref 모듈 사용).</target>
        </trans-unit>
        <trans-unit id="ed18bc4ba4db4fad433f89f2b494c6f4723892b5" translate="yes" xml:space="preserve">
          <source>This member is used to hold a pointer to another Python object that is related to this array. There are two use cases:</source>
          <target state="translated">이 멤버는이 배열과 관련된 다른 Python 객체에 대한 포인터를 보유하는 데 사용됩니다. 두 가지 사용 사례가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d7f481ab5f8b1d226ed9ed47a9904d6a830df77" translate="yes" xml:space="preserve">
          <source>This member points to an element in the ndarray indicated by the index.</source>
          <target state="translated">이 멤버는 인덱스로 표시된 ndarray의 요소를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="74643da87d06b0da62bc7a9a046a5adf218ab99e" translate="yes" xml:space="preserve">
          <source>This method directly exposes the the raw underlying pseudo-random number generator. All values are returned as unsigned 64-bit values irrespective of the number of bits produced by the PRNG.</source>
          <target state="translated">이 방법은 원시 기본 의사 난수 생성기를 직접 노출합니다. 모든 값은 PRNG에 의해 생성 된 비트 수에 관계없이 부호없는 64 비트 값으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d818e6497cca20e6d8e8f1bc817ba9a89c8a342e" translate="yes" xml:space="preserve">
          <source>This method does nothing, except raise a ValueError exception. A masked array does not own its data and therefore cannot safely be resized in place. Use the &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt;&lt;code&gt;numpy.ma.resize&lt;/code&gt;&lt;/a&gt; function instead.</source>
          <target state="translated">이 메소드는 ValueError 예외를 발생시키는 것 외에는 아무 것도 수행하지 않습니다. 마스크 된 어레이는 데이터를 소유하지 않으므로 안전하게 크기를 조정할 수 없습니다. 대신 &lt;a href=&quot;numpy.ma.resize#numpy.ma.resize&quot;&gt; &lt;code&gt;numpy.ma.resize&lt;/code&gt; &lt;/a&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="9518a02e6b8dc4cd7e3170e82e29518e38adcb79" translate="yes" xml:space="preserve">
          <source>This method does the heavy lifting for the &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; method. It takes all the same arguments, for details see &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 방법은 &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 방법에 대한 무거운 작업을 수행합니다 . 자세한 내용은 &lt;a href=&quot;numpy.testing.tester.test#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f55c9dffed1c2a6b5a2a9bf81f22b788e98f67b4" translate="yes" xml:space="preserve">
          <source>This method is called whenever the system internally allocates a new array from &lt;em&gt;obj&lt;/em&gt;, where &lt;em&gt;obj&lt;/em&gt; is a subclass (subtype) of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. It can be used to change attributes of &lt;em&gt;self&lt;/em&gt; after construction (so as to ensure a 2-d matrix for example), or to update meta-information from the &amp;ldquo;parent.&amp;rdquo; Subclasses inherit a default implementation of this method that does nothing.</source>
          <target state="translated">이 메소드는 시스템이 내부적으로 &lt;em&gt;obj&lt;/em&gt; 에서 새 배열을 할당 할 때마다 호출됩니다 . 여기서 &lt;em&gt;obj&lt;/em&gt; 는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 (하위 유형)입니다 . 구성 후 (예를 들어 2 차원 행렬을 보장하기 위해) &lt;em&gt;자체&lt;/em&gt; 속성을 변경 하거나 &quot;부모&quot;에서 메타 정보를 업데이트 하는 데 사용할 수 있습니다 . 서브 클래스는 아무것도하지 않는이 메소드의 기본 구현을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="5957d72b0ca4a0dc20466e5e727abd34e77443e1" translate="yes" xml:space="preserve">
          <source>This method is difficult to implement safely and may be deprecated in future releases of NumPy.</source>
          <target state="translated">이 방법은 안전하게 구현하기 어렵고 향후 NumPy 릴리스에서 더 이상 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7aaa9616f6dcdd0184bee8a152bd13d1e550b310" translate="yes" xml:space="preserve">
          <source>This method is for backward compatibility only: do not use.</source>
          <target state="translated">이 방법은 이전 버전과의 호환성을 위해서만 사용하십시오 : 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="0ecb5e08ef8d16754216c422058e3a81999abee2" translate="yes" xml:space="preserve">
          <source>This method removes any overlaps and reorders the fields in memory so they have increasing byte offsets, and adds or removes padding bytes depending on the &lt;code&gt;align&lt;/code&gt; option, which behaves like the &lt;code&gt;align&lt;/code&gt; option to &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">이 메서드는 겹치는 부분을 제거하고 메모리의 필드를 재정렬하여 바이트 오프셋 을 &lt;code&gt;np.dtype&lt;/code&gt; 대한 &lt;code&gt;align&lt;/code&gt; 옵션 처럼 작동 하는 &lt;code&gt;align&lt;/code&gt; 옵션 에 따라 패딩 바이트를 추가하거나 제거합니다 .</target>
        </trans-unit>
        <trans-unit id="83e657ddca83d2881d8a63d1d77710e25b3d7e94" translate="yes" xml:space="preserve">
          <source>This method scans files named __version__.py, &amp;lt;packagename&amp;gt;_version.py, version.py, and __svn_version__.py for string variables version, __version__, and &amp;lt;packagename&amp;gt;_version, until a version number is found.</source>
          <target state="translated">이 메소드는 버전 번호를 찾을 때까지 문자열 변수 version, __version__ 및 &amp;lt;packagename&amp;gt; _version에 대해 __version__.py, &amp;lt;packagename&amp;gt; _version.py, version.py 및 __svn_version__.py라는 파일을 스캔합니다.</target>
        </trans-unit>
        <trans-unit id="f89805770623a7cfcc87bb87063713e7dd822816" translate="yes" xml:space="preserve">
          <source>This module contains all functions in the &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; namespace, with the following replacement functions that return &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrices&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 모듈에는 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; 네임 스페이스의 모든 함수가 포함되어 있으며 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;generated/numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrices&lt;/code&gt; &lt;/a&gt; 을 반환하는 다음 대체 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="265d65d83193df044b48a623f0d3f0dda63b008d" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Chebyshev series, including a &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt;&lt;code&gt;Chebyshev&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.chebyshev.chebyshev#numpy.polynomial.chebyshev.Chebyshev&quot;&gt; &lt;code&gt;Chebyshev&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Chebyshev 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;부모&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0c12fd4ebad36a4626d24020b78132a2c170962" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt;&lt;code&gt;Hermite&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.hermite.hermite#numpy.polynomial.hermite.Hermite&quot;&gt; &lt;code&gt;Hermite&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Hermite 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="009a1c885b932c48bc61dd45e0e34c3c31b1f286" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with HermiteE series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 HermiteE 시리즈를 처리하는 데 유용한 여러 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="68d5327723a8c86e153df7ff9955c4a06be0ce20" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Hermite_e series, including a &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt;&lt;code&gt;HermiteE&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.hermite_e.hermitee#numpy.polynomial.hermite_e.HermiteE&quot;&gt; &lt;code&gt;HermiteE&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Hermite_e 시리즈를 처리하는 데 유용한 여러 객체 (대부분 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;부모&quot;하위 패키지 인 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 독 스트링에&lt;/a&gt; 있습니다.)</target>
        </trans-unit>
        <trans-unit id="0d0299f154387dc04b7a01cfe822909405b30805" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Laguerre series, including a &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt;&lt;code&gt;Laguerre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.laguerre.laguerre#numpy.polynomial.laguerre.Laguerre&quot;&gt; &lt;code&gt;Laguerre&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Laguerre 시리즈를 처리하는 데 유용한 여러 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; &lt;/a&gt; 의 문서 문자열에 있습니다.</target>
        </trans-unit>
        <trans-unit id="97167a7dd7012c05d960d350608d944b8fc4844a" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Legendre series, including a &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt;&lt;code&gt;Legendre&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.legendre.legendre#numpy.polynomial.legendre.Legendre&quot;&gt; &lt;code&gt;Legendre&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 Legendre 시리즈를 처리하는 데 유용한 많은 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="27218660297bbc1672326aa7fc0091aba0aa4b36" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with Polynomial series, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with such polynomials is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 다항식 시리즈를 처리하는 데 유용한 여러 객체 (주로 함수)를 제공합니다 . (이 모듈이 그러한 다항식을 어떻게 표현하고 작동하는지에 대한 일반적인 정보는 &quot;상위&quot;서브 패키지 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 docstring에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ab4c28fb83b693800bce3d9c0cb03cd8615a6cd" translate="yes" xml:space="preserve">
          <source>This module provides a number of objects (mostly functions) useful for dealing with polynomials, including a &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt;&lt;code&gt;Polynomial&lt;/code&gt;&lt;/a&gt; class that encapsulates the usual arithmetic operations. (General information on how this module represents and works with polynomial objects is in the docstring for its &amp;ldquo;parent&amp;rdquo; sub-package, &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt;&lt;code&gt;numpy.polynomial&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">이 모듈은 일반적인 산술 연산을 캡슐화 하는 &lt;a href=&quot;generated/numpy.polynomial.polynomial.polynomial#numpy.polynomial.polynomial.Polynomial&quot;&gt; &lt;code&gt;Polynomial&lt;/code&gt; &lt;/a&gt; 클래스를 포함하여 다항식 을 처리하는 데 유용한 여러 객체 (대부분 함수)를 제공합니다 . (이 모듈이 어떻게 다항식 객체를 나타내고 작동하는지에 대한 일반적인 정보는 &quot;부모&quot;하위 패키지 인 &lt;a href=&quot;routines.polynomials.package#module-numpy.polynomial&quot;&gt; &lt;code&gt;numpy.polynomial&lt;/code&gt; 의 독 스트링에&lt;/a&gt; 있습니다.)</target>
        </trans-unit>
        <trans-unit id="6505e2a54b4c90d04c624c70346ad867092f98b2" translate="yes" xml:space="preserve">
          <source>This module provides: error and warning objects; a polynomial base class; and some routines used in both the &lt;code&gt;polynomial&lt;/code&gt; and &lt;code&gt;chebyshev&lt;/code&gt; modules.</source>
          <target state="translated">이 모듈은 오류 및 경고 객체를 제공합니다. 다항식 기본 클래스; &lt;code&gt;polynomial&lt;/code&gt; 과 &lt;code&gt;chebyshev&lt;/code&gt; 모듈 모두에 사용되는 일부 루틴 .</target>
        </trans-unit>
        <trans-unit id="a2e1ca0b050299a02c26006ffc538095c291c293" translate="yes" xml:space="preserve">
          <source>This module shows use of the &lt;code&gt;cimport&lt;/code&gt; statement to load the definitions from the &lt;code&gt;numpy.pxd&lt;/code&gt; header that ships with Cython. It looks like NumPy is imported twice; &lt;code&gt;cimport&lt;/code&gt; only makes the NumPy C-API available, while the regular &lt;code&gt;import&lt;/code&gt; causes a Python-style import at runtime and makes it possible to call into the familiar NumPy Python API.</source>
          <target state="translated">이 모듈은 &lt;code&gt;cimport&lt;/code&gt; 문을 사용 하여 Cython과 함께 제공 되는 &lt;code&gt;numpy.pxd&lt;/code&gt; 헤더 에서 정의를로드하는 방법을 보여줍니다 . NumPy가 두 번 가져온 것 같습니다. &lt;code&gt;cimport&lt;/code&gt; 는 NumPy C-API 만 사용할 수 있도록하는 반면, 일반 &lt;code&gt;import&lt;/code&gt; 오기는 런타임에 Python 스타일 가져 오기를 수행하고 익숙한 NumPy Python API를 호출 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="6f02b8e116f7a7bed4ba561da0ffe80943392202" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Chebyshev series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Chebyshev 계열을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="a628eacd0f4bb9dd57ff71e63c578eed78e261b5" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Hermite series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Hermite 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="9ab2b6eda8208cc86132d50e5e53a2cf2e15859d" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Laguerre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Laguerre 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="23eb81bc9bb7a5f0cbd08a18f3b739c712c791cf" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the Legendre series for &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 &lt;code&gt;off + scl*x&lt;/code&gt; 대한 Legendre 시리즈를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="d92e37a5c688f24c68244c7cd58f9c4410908a50" translate="yes" xml:space="preserve">
          <source>This module&amp;rsquo;s representation of the linear polynomial &lt;code&gt;off +
scl*x&lt;/code&gt;.</source>
          <target state="translated">이 모듈은 선형 다항식 &lt;code&gt;off + scl*x&lt;/code&gt; 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cce1c3ab116538df151878b9366f2e0db3802d6b" translate="yes" xml:space="preserve">
          <source>This needs to be done after all installers are downloaded, but before the pavement file is updated for continued development:</source>
          <target state="translated">이 작업은 모든 설치 프로그램을 다운로드 한 후 계속 개발하기 위해 포장 파일을 업데이트하기 전에 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5151a066bb85cc108b39c4156d9c6c1e5f15d97" translate="yes" xml:space="preserve">
          <source>This obeys the structured array assignment rules described above. For example, this means that one can swap the values of two fields using appropriate multi-field indexes:</source>
          <target state="translated">이것은 위에서 설명한 구조화 된 배열 할당 규칙을 따릅니다. 예를 들어, 이는 적절한 다중 필드 색인을 사용하여 두 필드의 값을 바꿀 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1c93b1abaa0ee7234b376edaae74a000aa2ccbab" translate="yes" xml:space="preserve">
          <source>This object is no longer compatible with &lt;code&gt;np.sum&lt;/code&gt; because if you call &lt;code&gt;np.sum&lt;/code&gt;, it will pass in unexpected arguments &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt;, causing a TypeError to be raised.</source>
          <target state="translated">이 객체는 더 이상 호환되지 않습니다 &lt;code&gt;np.sum&lt;/code&gt; 당신이 호출하는 경우 때문에 &lt;code&gt;np.sum&lt;/code&gt; 을 , 예기치 않은 인수로 전달됩니다 &lt;code&gt;out&lt;/code&gt; 와 &lt;code&gt;keepdims&lt;/code&gt; TypeError가가 발생하는 원인.</target>
        </trans-unit>
        <trans-unit id="b628f2a020e67ee402c9861512476edcb4af1ebf" translate="yes" xml:space="preserve">
          <source>This object is now compatible with &lt;code&gt;np.sum&lt;/code&gt; again because any extraneous arguments (i.e. keywords that are not &lt;code&gt;axis&lt;/code&gt; or &lt;code&gt;dtype&lt;/code&gt;) will be hidden away in the &lt;code&gt;**unused_kwargs&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;np.sum&lt;/code&gt; 객체는 &lt;code&gt;**unused_kwargs&lt;/code&gt; 매개 변수 에서 모든 외부 인수 (예 : &lt;code&gt;axis&lt;/code&gt; 또는 &lt;code&gt;dtype&lt;/code&gt; 이 아닌 키워드 )가 숨겨 지므로 np.sum 과 다시 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="75a22002edc0d8d423cb72bfe9efb4e65f38427c" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">이는 주문 매개 변수에 대해 &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 지정된 경우에만 반복기에 영향을줍니다 . 기본적으로 &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 를 사용하면 반복기는 보폭이 음수 인 축을 반전하여 메모리가 정방향으로 이동합니다. 이렇게하면이 단계가 비활성화됩니다. 축의 기본 메모리 순서를 사용하고 싶지만 축이 반전되지 않도록하려면이 플래그를 사용하십시오. 예를 들어 이것은 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 의 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="eaa2fd8c1567b66e551b17269b1ebbbc61f96243" translate="yes" xml:space="preserve">
          <source>This only affects the iterator when &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is specified for the order parameter. By default with &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the iterator reverses axes which have negative strides, so that memory is traversed in a forward direction. This disables this step. Use this flag if you want to use the underlying memory-ordering of the axes, but don&amp;rsquo;t want an axis reversed. This is the behavior of &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt;, for instance.</source>
          <target state="translated">주문 매개 변수에 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 지정된 경우에만 반복자에 영향을줍니다 . 기본적으로 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 을 사용하면 반복자는 음수 보폭을 갖는 축을 반전시켜 메모리가 순방향으로 이동합니다. 이 단계는 비활성화됩니다. 축의 기본 메모리 순서를 사용하지만 축을 반전시키지 않으려면이 플래그를 사용하십시오. 예를 들어 이것은 &lt;code&gt;numpy.ravel(a, order='K')&lt;/code&gt; 의 동작입니다 .</target>
        </trans-unit>
        <trans-unit id="dfc0d7340cbb0038d2b37c47d460673f198c8e36" translate="yes" xml:space="preserve">
          <source>This operation, dividing an array by a scalar, works because of NumPy&amp;rsquo;s &lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;broadcasting rules&lt;/a&gt;). (Note that in real-world applications, it would be better to use, for example, the &lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt;&lt;code&gt;img_as_float&lt;/code&gt;&lt;/a&gt; utility function from &lt;code&gt;scikit-image&lt;/code&gt;).</source>
          <target state="translated">배열을 스칼라로 나누는이 작업은 NumPy의 &lt;a href=&quot;theory.broadcasting#array-broadcasting-in-numpy&quot;&gt;브로드 캐스팅 규칙&lt;/a&gt; 때문에 작동합니다 . (실제 응용 프로그램에서는 &lt;code&gt;scikit-image&lt;/code&gt; 의 &lt;a href=&quot;https://scikit-image.org/docs/stable/api/skimage.html#skimage.img_as_float&quot;&gt; &lt;code&gt;img_as_float&lt;/code&gt; &lt;/a&gt; 유틸리티 함수 를 사용하는 것이 더 좋습니다 .)</target>
        </trans-unit>
        <trans-unit id="c162c5fa5c56025420698950fd9023cbce377364" translate="yes" xml:space="preserve">
          <source>This option is deprecated. Use &lt;code&gt;usercode&lt;/code&gt; statement to specify C code snippets directly in signature files.</source>
          <target state="translated">이 옵션은 더 이상 사용되지 않습니다. 사용 &lt;code&gt;usercode&lt;/code&gt; 의 문은 서명 파일에서 직접 C 코드 조각을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="ae6b1796953475091b5cdaeb39e4d7e996e315e6" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired percentile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">이 선택적 매개 변수는 원하는 백분위 수가 두 데이터 포인트 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 사이에있을 때 사용할 보간 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="002fb17667dbbd628eca51b6e4ff99f2217649e0" translate="yes" xml:space="preserve">
          <source>This optional parameter specifies the interpolation method to use when the desired quantile lies between two data points &lt;code&gt;i &amp;lt; j&lt;/code&gt;:</source>
          <target state="translated">이 선택적 매개 변수는 원하는 Quantile이 두 데이터 포인트 &lt;code&gt;i &amp;lt; j&lt;/code&gt; 사이에있을 때 사용할 보간 방법을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="c342edf9966c2e18280c4d355db707b32be4bff5" translate="yes" xml:space="preserve">
          <source>This package was developed independently of NumPy and was integrated in version 1.17.0. The original repo is at &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen&lt;/a&gt;.</source>
          <target state="translated">이 패키지는 NumPy와 독립적으로 개발되었으며 버전 1.17.0에 통합되었습니다. 원래 저장소는 &lt;a href=&quot;https://github.com/bashtage/randomgen&quot;&gt;https://github.com/bashtage/randomgen에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="c427139240278bee81f47cf48768438afbe39755" translate="yes" xml:space="preserve">
          <source>This page describes the numpy-specific API for accessing the contents of a numpy array from other C extensions. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt;&lt;code&gt;The Revised Buffer Protocol&lt;/code&gt;&lt;/a&gt; introduces similar, standardized API to Python 2.6 and 3.0 for any extension module to use. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt;&amp;rsquo;s buffer array support uses the &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API; see the &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy tutorial&lt;/a&gt;. Cython provides a way to write code that supports the buffer protocol with Python versions older than 2.6 because it has a backward-compatible implementation utilizing the array interface described here.</source>
          <target state="translated">이 페이지에서는 다른 C 확장에서 numpy 배열의 내용에 액세스하기위한 numpy 특정 API에 대해 설명합니다. &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-1&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; &amp;ndash; &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#c.PyObject_GetBuffer&quot;&gt; &lt;code&gt;The Revised Buffer Protocol&lt;/code&gt; &lt;/a&gt; 은 모든 확장 모듈이 사용할 수 있도록 유사한 표준 API를 Python 2.6 및 3.0에 도입했습니다. &lt;a href=&quot;http://cython.org/&quot;&gt;Cython&lt;/a&gt; 의 버퍼 배열 지원은 &lt;a href=&quot;https://www.python.org/dev/peps/pep-3118&quot; id=&quot;index-2&quot;&gt;&lt;strong&gt;PEP 3118&lt;/strong&gt;&lt;/a&gt; API를 사용합니다 . &lt;a href=&quot;https://github.com/cython/cython/wiki/tutorials-numpy&quot;&gt;Cython numpy 튜토리얼을&lt;/a&gt; 참조하십시오 . Cython은 여기에 설명 된 배열 인터페이스를 사용하여 이전 버전과 호환되는 구현이 있으므로 2.6 이전의 Python 버전에서 버퍼 프로토콜을 지원하는 코드를 작성하는 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4df30a5dfa3e83d5a58c4b3babfef2e8f4555a00" translate="yes" xml:space="preserve">
          <source>This page documents the API for the iterator. The iterator is named &lt;code&gt;NpyIter&lt;/code&gt; and functions are named &lt;code&gt;NpyIter_*&lt;/code&gt;.</source>
          <target state="translated">이 페이지는 이터레이터의 API를 설명합니다. 반복자의 이름은 &lt;code&gt;NpyIter&lt;/code&gt; 이고 함수의 이름은 &lt;code&gt;NpyIter_*&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f3ed57ed2270d94087c1c0c02f79e8407d0327af" translate="yes" xml:space="preserve">
          <source>This page tackles common applications; for the full collection of I/O routines, see &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;Input and output&lt;/a&gt;.</source>
          <target state="translated">이 페이지는 일반적인 응용 프로그램을 다룹니다. I / O 루틴의 전체 컬렉션은 &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;입력 및 출력을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ef493fa5f7ddfcfa2e56b59880c2ca13b04b480" translate="yes" xml:space="preserve">
          <source>This plot is not so readable since the lines seem to be over each other, so let&amp;rsquo;s summarize in a more elaborate plot. We&amp;rsquo;ll plot the real data when available, and show the cubic fit for unavailable data, using this fit to compute an estimate to the observed number of cases on January 28th 2020, 7 days after the beginning of the records:</source>
          <target state="translated">이 플롯은 선이 서로 겹쳐있는 것처럼 보이기 때문에 읽기 어렵 기 때문에 좀 더 정교한 플롯으로 요약 해 보겠습니다. 사용 가능한 경우 실제 데이터를 플로팅하고 사용할 수없는 데이터에 대한 3 차 적합도를 표시합니다.이 적합도를 사용하여 레코드 시작 7 일 후인 2020 년 1 월 28 일에 관찰 된 케이스 수에 대한 추정치를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b79e823ebc32815d2b3460b90e34d0a2f9bed7dc" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it.</source>
          <target state="translated">이 포인터는 반복 루프 전에 캐싱 될 수 있으며 &lt;code&gt;iternext&lt;/code&gt; 를 호출 해도 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="484a465c1e928c7fbd45d4d74c7fee12a21c59d4" translate="yes" xml:space="preserve">
          <source>This pointer may be cached before the iteration loop, calling &lt;code&gt;iternext&lt;/code&gt; will not change it. This function may be safely called without holding the Python GIL.</source>
          <target state="translated">이 포인터는 반복 루프 전에 캐싱 될 수 있으며 &lt;code&gt;iternext&lt;/code&gt; 를 호출 해도 변경되지 않습니다. 이 함수는 Python GIL을 유지하지 않고도 안전하게 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb65fa9e55962767929fe75ece2f7703e6ac5b10" translate="yes" xml:space="preserve">
          <source>This produces the correct answer, but if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; each contain millions of numbers, we will pay the price for the inefficiencies of looping in Python. We could accomplish the same task much more quickly in C by writing (for clarity we neglect variable declarations and initializations, memory allocation, etc.)</source>
          <target state="translated">이것은 정답을 산출하지만 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에 각각 수백만 개의 숫자가 포함되어 있으면 Python에서 루프의 비 효율성에 대한 대가를 지불 할 것입니다. 우리는 쓰기를 통해 C에서 훨씬 더 빠르게 동일한 작업을 수행 할 수 있습니다 (명확성을 위해 변수 선언 및 초기화, 메모리 할당 등을 무시합니다).</target>
        </trans-unit>
        <trans-unit id="fc50269460cb12e12865cbec85480d4b3e10a0a9" translate="yes" xml:space="preserve">
          <source>This property can be very useful in assignments:</source>
          <target state="translated">이 속성은 할당에서 매우 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af7b379b2fcb530df7b5c66e85d1051773a408df" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 프로퍼티는이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 허수 부분에 대한 뷰 입니다.</target>
        </trans-unit>
        <trans-unit id="00b60d7136524e649c297d22303044023139f2d1" translate="yes" xml:space="preserve">
          <source>This property is a view on the imaginary part of this &lt;code&gt;MaskedArray&lt;/code&gt;.</source>
          <target state="translated">이 속성은이 &lt;code&gt;MaskedArray&lt;/code&gt; 의 가상 부분에 대한 뷰 입니다.</target>
        </trans-unit>
        <trans-unit id="9c2a714f693725c88c94ac2607ed6abee0322d99" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성은이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 실제 부분에 대한 뷰 입니다.</target>
        </trans-unit>
        <trans-unit id="a4989179ebd897375fad9fc4e97f158afedfb6f9" translate="yes" xml:space="preserve">
          <source>This property is a view on the real part of this &lt;code&gt;MaskedArray&lt;/code&gt;.</source>
          <target state="translated">이 속성은이 &lt;code&gt;MaskedArray&lt;/code&gt; 의 실제 부분에 대한 뷰 입니다.</target>
        </trans-unit>
        <trans-unit id="56ae11e0e5ca2982f115765c5eb4aa5c0c2cf88d" translate="yes" xml:space="preserve">
          <source>This reallocates space for the data area if necessary.</source>
          <target state="translated">필요한 경우 데이터 영역에 대한 공간을 재 할당합니다.</target>
        </trans-unit>
        <trans-unit id="3875a2efa104b3c26f06d6992550d8f8f4acd93f" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see also &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;NumPy User Guide&lt;/a&gt;.</source>
          <target state="translated">이 참조 설명서는 NumPy에 포함 된 기능, 모듈 및 객체를 설명하고 해당 기능 및 기능에 대해 설명합니다. NumPy 사용 방법을 배우려면 NumPy 사용 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/index.html#user&quot;&gt;설명서&lt;/a&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6b66394de331bbd119ed305c44c97cddcc296f65" translate="yes" xml:space="preserve">
          <source>This reference manual details functions, modules, and objects included in NumPy, describing what they are and what they do. For learning how to use NumPy, see the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;complete documentation&lt;/a&gt;.</source>
          <target state="translated">이 참조 매뉴얼은 NumPy에 포함 된 기능, 모듈 및 개체를 자세히 설명하고 그 기능과 기능을 설명합니다. NumPy 사용 방법을 배우려면 &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;전체 설명서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="49d7d34fc7b59b4f57a8fc699678974df3138f8f" translate="yes" xml:space="preserve">
          <source>This returns a tuple of indices that can be used to access the main diagonal of an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; dimensions and shape (n, n, &amp;hellip;, n). For &lt;code&gt;a.ndim = 2&lt;/code&gt; this is the usual diagonal, for &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; this is the set of indices to access &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; for &lt;code&gt;i = [0..n-1]&lt;/code&gt;.</source>
          <target state="translated">이것은 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 차원과 모양 (n, n,&amp;hellip;, n)을 가진 배열 &lt;code&gt;a&lt;/code&gt; 의 주 대각선에 접근하는데 사용될 수있는 인덱스 튜플을 반환합니다 . 들면 &lt;code&gt;a.ndim = 2&lt;/code&gt; 이 들어 보통 대각선 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 이 액세스 인덱스들의 집합 인 &lt;code&gt;a[i, i, ..., i]&lt;/code&gt; 에 대해 &lt;code&gt;i = [0..n-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445408c5f27be1f1d331536d4e933a74a8f78cb0" translate="yes" xml:space="preserve">
          <source>This returns the base object of the array. In most cases, this means the object which owns the memory the array is pointing at.</source>
          <target state="translated">배열의 기본 개체를 반환합니다. 대부분의 경우 이는 어레이가 가리키는 메모리를 소유 한 객체를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="86f639de88fe17b751b6b11b662442ef7819d4d2" translate="yes" xml:space="preserve">
          <source>This routine simply adds the elements in two contiguous arrays and places the result in a third. The memory for all three arrays must be provided by the calling routine. A very basic interface to this routine can be automatically generated by f2py:</source>
          <target state="translated">이 루틴은 단순히 두 개의 연속 배열에 요소를 추가하고 결과를 세 번째에 배치합니다. 세 배열 모두에 대한 메모리는 호출 루틴에 의해 제공되어야합니다. 이 루틴에 대한 매우 기본적인 인터페이스는 f2py에 의해 자동으로 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a52ed8eb1e1cedf938d67a58ab208207008af6c7" translate="yes" xml:space="preserve">
          <source>This routine succeeds where ordinary &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; does not:</source>
          <target state="translated">이 루틴은 일반적인 &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 가없는 경우에 성공합니다 .</target>
        </trans-unit>
        <trans-unit id="9bca535321764a180aeb878b90cecb0b41abe3ad" translate="yes" xml:space="preserve">
          <source>This rule helps you anticipate how a vector will be printed, and conversely how to find the index of any of the printed elements. For instance, in the example, the last two values of 8&amp;rsquo;s index must be 0 and 2. Since 8 appears in the second of the two 2x3&amp;rsquo;s, the first index must be 1:</source>
          <target state="translated">이 규칙은 벡터가 인쇄되는 방법과 반대로 인쇄 된 요소의 색인을 찾는 방법을 예상하는 데 도움이됩니다. 예를 들어, 예에서 8 인덱스의 마지막 두 값은 0과 2 여야합니다. 8이 두 2x3 중 두 번째에 나타나므로 첫 번째 인덱스는 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="bb5cd927267b8c85989f3387ce0a0d2359a4663d" translate="yes" xml:space="preserve">
          <source>This saves all the overhead involved in interpreting the Python code and manipulating Python objects, but at the expense of the benefits gained from coding in Python. Furthermore, the coding work required increases with the dimensionality of our data. In the case of a 2-D array, for example, the C code (abridged as before) expands to</source>
          <target state="translated">이렇게하면 Python 코드를 해석하고 Python 객체를 조작하는 데 관련된 모든 오버 헤드가 절약되지만 Python으로 코딩하여 얻을 수있는 이점은 줄어 듭니다. 또한 필요한 코딩 작업은 데이터의 차원에 따라 증가합니다. 예를 들어 2 차원 배열의 경우 C 코드 (이전처럼 요약)는 다음과 같이 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="eb7064b0e5d0b37eaed95ef4ac40f47e88476c2d" translate="yes" xml:space="preserve">
          <source>This scheme does require that you avoid reusing stream IDs. This may require coordination between the parallel processes.</source>
          <target state="translated">이 체계에서는 스트림 ID를 재사용하지 않아야합니다. 병렬 프로세스간에 조정이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1aa4791ff179e31578c8776ff4ea075ff10d4756" translate="yes" xml:space="preserve">
          <source>This section and the next describe in detail how to set up git for working with the NumPy source code. If you have git already set up, skip to &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;Development workflow&lt;/a&gt;.</source>
          <target state="translated">이 섹션과 다음 섹션에서는 NumPy 소스 코드 작업을 위해 git을 설정하는 방법에 대해 자세히 설명합니다. git이 이미 설정되어있는 경우 &lt;a href=&quot;../development_workflow#development-workflow&quot;&gt;개발 워크 플로로&lt;/a&gt; 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="e071a3347f38c194bd96c7f6d94e6b8f7990250d" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;a href=&quot;c-api/array#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">이 섹션에서는 세 가지 실행 유형 각각에 대해 기본 범용 함수 계산 루프를 설정하고 실행하는 방법에 대해 설명합니다. 컴파일 중에 &lt;a href=&quot;c-api/array#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 가 정의 된 경우 객체 배열이 포함되지 않는 한 루프를 호출하기 전에 Python GIL (Global Interpreter Lock)이 해제됩니다. 오류 조건을 처리하기 위해 필요한 경우 다시 획득합니다. 하드웨어 오류 플래그는 1-D 루프가 완료된 후에 만 ​​확인됩니다.</target>
        </trans-unit>
        <trans-unit id="d2295424cf2146c8c588e01472068b4499bd8664" translate="yes" xml:space="preserve">
          <source>This section describes how the basic universal function computation loop is setup and executed for each of the three different kinds of execution. If &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; is defined during compilation, then as long as no object arrays are involved, the Python Global Interpreter Lock (GIL) is released prior to calling the loops. It is re-acquired if necessary to handle error conditions. The hardware error flags are checked only after the 1-D loop is completed.</source>
          <target state="translated">이 섹션에서는 기본 범용 함수 계산 루프가 세 가지 다른 종류의 실행 각각에 대해 설정되고 실행되는 방법에 대해 설명합니다. 컴파일 중에 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 가 정의 되면 오브젝트 배열이 포함되지 않는 한 루프를 호출하기 전에 Python GIL (Global Interpreter Lock)이 해제됩니다. 필요한 경우 오류 조건을 처리하기 위해 다시 확보됩니다. 하드웨어 오류 플래그는 1-D 루프가 완료된 후에 만 ​​확인됩니다.</target>
        </trans-unit>
        <trans-unit id="36d38a5b23b654b48926d888ff2f70f4fd6663ca" translate="yes" xml:space="preserve">
          <source>This section describes the governance and leadership model of The Project.</source>
          <target state="translated">이 섹션에서는 The Project의 거버넌스 및 리더십 모델을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="387c13e7d204cf584e66117f50223922b47b0d67" translate="yes" xml:space="preserve">
          <source>This section should be used judiciously, i.e., only for errors that are non-obvious or have a large chance of getting raised.</source>
          <target state="translated">이 섹션은 명확하지 않거나 발생할 가능성이 큰 오류에 대해서만 신중하게 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf292081ef6e3f6d3a2a86d3bb95335c9be71e92" translate="yes" xml:space="preserve">
          <source>This section should use the &lt;code&gt;deprecated&lt;/code&gt; Sphinx directive instead of an underlined section header.</source>
          <target state="translated">이 섹션에서는 밑줄이있는 섹션 헤더 대신 &lt;code&gt;deprecated&lt;/code&gt; Sphinx 지시문을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a9b94d3eaea207d20a5173591fa4612902baa5c" translate="yes" xml:space="preserve">
          <source>This section will not cover means of replicating, joining, or otherwise expanding or mutating existing arrays. Nor will it cover creating object arrays or structured arrays. Both of those are covered in their own sections.</source>
          <target state="translated">이 섹션에서는 기존 어레이를 복제, 결합 또는 확장 또는 변경하는 방법에 대해서는 다루지 않습니다. 객체 배열이나 구조화 된 배열을 만드는 것도 다루지 않습니다. 두 가지 모두 자체 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="9a18449ed2fc82d845556e8871f21b5f905f1f97" translate="yes" xml:space="preserve">
          <source>This should be read together with the general directions in &lt;code&gt;releasing&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;releasing&lt;/code&gt; 의 일반적인 지침과 함께 읽어야합니다 .</target>
        </trans-unit>
        <trans-unit id="af85e32a0a54092009ceae627c9327451013292e" translate="yes" xml:space="preserve">
          <source>This should not be confused with:</source>
          <target state="translated">이것은 다음과 혼동해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="281bd1fc18f2200e68ef811b640b0f24111b0170" translate="yes" xml:space="preserve">
          <source>This simply has the effect of switching the definitions of &lt;code&gt;arg1&lt;/code&gt; and &lt;code&gt;arg2&lt;/code&gt; in lines 3 and 4 of the generated code above, and their assignments in lines 19 and 20.</source>
          <target state="translated">이것은 단순히 위의 생성 된 코드의 3 행과 4 행에서 &lt;code&gt;arg1&lt;/code&gt; 과 &lt;code&gt;arg2&lt;/code&gt; 의 정의 와 19 행과 20 행에서 지정 을 전환하는 효과가 있습니다.</target>
        </trans-unit>
        <trans-unit id="54a1fbc955c54345f701059c4adac18f9144af8f" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">이 단일 모듈은 단일 위치에서 numpy 테스트에 대한 모든 공통 기능을 제공해야 &lt;a href=&quot;../dev/development_environment#development-environment&quot;&gt;테스트 스크립트&lt;/a&gt; 가 가져 와서 바로 작동 할 수 있습니다. 배경 정보는 &lt;a href=&quot;testing#testing-guidelines&quot;&gt;테스트 지침을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d5f0ce6428ed7ce9a3f007ac820d6ad83fbe35d9" translate="yes" xml:space="preserve">
          <source>This single module should provide all the common functionality for numpy tests in a single location, so that &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;test scripts&lt;/a&gt; can just import it and work right away. For background, see the &lt;a href=&quot;testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">이 단일 모듈은 단일 위치에서 numpy 테스트에 대한 모든 공통 기능을 제공하므로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/dev/development_environment.html#development-environment&quot;&gt;테스트 스크립트&lt;/a&gt; 가이를 가져 와서 바로 작동 할 수 있습니다. 배경은 &lt;a href=&quot;testing#testing-guidelines&quot;&gt;테스트 지침을&lt;/a&gt; 참조하십시오</target>
        </trans-unit>
        <trans-unit id="e97f89b724acb7f31f3f94df4fb5ca630be7277b" translate="yes" xml:space="preserve">
          <source>This sort of mutation is not allowed by the types. Users who want to write statically typed code should insted use the &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;numpy.ndarray.view&lt;/code&gt;&lt;/a&gt; method to create a view of the array with a different dtype.</source>
          <target state="translated">이러한 종류의 돌연변이는 유형별로 허용되지 않습니다. 정적으로 형식화 된 코드를 작성하려는 사용자는 &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;numpy.ndarray.view&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 다른 dtype으로 배열보기를 만들어야합니다.</target>
        </trans-unit>
        <trans-unit id="feb22e5bb35e33b30ed01dab66654627fe20956a" translate="yes" xml:space="preserve">
          <source>This specifies the &amp;ldquo;intention&amp;rdquo; of the corresponding argument. &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; is a comma separated list of the following keys:</source>
          <target state="translated">이는 해당 인수의 &quot;의도&quot;를 지정합니다. &lt;code&gt;&amp;lt;intentspec&amp;gt;&lt;/code&gt; 은 다음 키의 쉼표로 구분 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5e999bfd9ee7986bb74545207acc796f3e46abd8" translate="yes" xml:space="preserve">
          <source>This specifies which warnings to configure as &amp;lsquo;raise&amp;rsquo; instead of being shown once during the test execution. Valid strings are:</source>
          <target state="translated">테스트 실행 중에 한 번 표시되는 대신 '발생'으로 구성 할 경고를 지정합니다. 유효한 문자열은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="355c08a8b685b52031d6593cc7642f8973231125" translate="yes" xml:space="preserve">
          <source>This step is only needed for final releases and can be skipped for pre-releases. &lt;code&gt;make merge-doc&lt;/code&gt; clones the &lt;code&gt;numpy/doc&lt;/code&gt; repo into &lt;code&gt;doc/build/merge&lt;/code&gt; and updates it with the new documentation:</source>
          <target state="translated">이 단계는 최종 릴리스에만 필요하며 사전 릴리스의 경우 건너 뛸 수 있습니다. &lt;code&gt;make merge-doc&lt;/code&gt; 은 &lt;code&gt;numpy/doc&lt;/code&gt; 저장소를 &lt;code&gt;doc/build/merge&lt;/code&gt; 에 복제 하고 새 문서로 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="f04c1b598b018608346e9a082214a1abd34ac499" translate="yes" xml:space="preserve">
          <source>This string will be used as the marker for missing data for all the columns</source>
          <target state="translated">이 문자열은 모든 열의 누락 된 데이터에 대한 마커로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d96875a0b29939a3e2bb067cb066089a92949861" translate="yes" xml:space="preserve">
          <source>This structure is very useful when shape and/or strides information is supposed to be interpreted. The structure is:</source>
          <target state="translated">이 구조는 모양 및 / 또는 보폭 정보가 해석 될 때 매우 유용합니다. 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f5377b9ec1ee34b1b46afca48f12d70eda083569" translate="yes" xml:space="preserve">
          <source>This style allows passing in the &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt;&lt;code&gt;fields&lt;/code&gt;&lt;/a&gt; attribute of a data-type object.</source>
          <target state="translated">이 스타일을 사용 하면 데이터 유형 객체 의 &lt;a href=&quot;generated/numpy.dtype.fields#numpy.dtype.fields&quot;&gt; &lt;code&gt;fields&lt;/code&gt; &lt;/a&gt; 속성을 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8baa5c3fa91f9d82d5f372676363ca92358b6704" translate="yes" xml:space="preserve">
          <source>This style does not accept &lt;em&gt;align&lt;/em&gt; in the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor as it is assumed that all of the memory is accounted for by the array interface description.</source>
          <target state="translated">이 스타일은 모든 메모리가 배열 인터페이스 설명에 의해 설명되는 것으로 가정 되므로 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 생성자 에서 &lt;em&gt;정렬&lt;/em&gt; 을 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="63b067d6a5e8e9587ae90576ba34210d81e53f6b" translate="yes" xml:space="preserve">
          <source>This style has two required and three optional keys. The &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; keys are required. Their respective values are equal-length lists with the field names and the field formats. The field names must be strings and the field formats can be any object accepted by &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">이 스타일에는 2 개의 필수 키와 3 개의 선택적 키가 있습니다. &lt;em&gt;이름&lt;/em&gt; 과 &lt;em&gt;형식의&lt;/em&gt; 키가 필요합니다. 각각의 값은 필드 이름과 필드 형식을 가진 길이가 같은 목록입니다. 필드 이름은 문자열이어야하며 필드 형식은 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 생성자가 허용하는 모든 개체 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9fd39c592746d75bfe12bf10bab5bf15e715d323" translate="yes" xml:space="preserve">
          <source>This subclass of ndarray has some unpleasant interactions with some operations, because it doesn&amp;rsquo;t quite fit properly as a subclass. An alternative to using this subclass is to create the &lt;code&gt;mmap&lt;/code&gt; object yourself, then create an ndarray with ndarray.__new__ directly, passing the object created in its &amp;lsquo;buffer=&amp;rsquo; parameter.</source>
          <target state="translated">이 ndarray 서브 클래스는 서브 클래스로 제대로 맞지 않기 때문에 일부 작업과 불쾌한 상호 작용을합니다. 이 서브 클래스를 사용하는 대안은 &lt;code&gt;mmap&lt;/code&gt; 객체를 직접 생성 한 다음 ndarray .__ new__로 직접 ndarray를 생성하여 'buffer ='매개 변수로 생성 된 객체를 전달하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="8a52b4cb6a8af65abce36bb79c9c41aa8777063c" translate="yes" xml:space="preserve">
          <source>This tells you that you are currently on the &lt;code&gt;master&lt;/code&gt; branch, and that you also have a &lt;code&gt;remote&lt;/code&gt; connection to &lt;code&gt;origin/master&lt;/code&gt;. What remote repository is &lt;code&gt;remote/origin&lt;/code&gt;? Try &lt;code&gt;git remote -v&lt;/code&gt; to see the URLs for the remote. They will point to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; fork.</source>
          <target state="translated">이것은 현재 &lt;code&gt;master&lt;/code&gt; 브랜치에 있고 &lt;code&gt;origin/master&lt;/code&gt; 에 대한 &lt;code&gt;remote&lt;/code&gt; 연결 도 가지고 있음을 알려줍니다 . &lt;code&gt;remote/origin&lt;/code&gt; 은 어떤 원격 저장소입니까 ? &lt;code&gt;git remote -v&lt;/code&gt; 의 URL을 보려면 git remote -v 를 시도 하십시오. 그들은 당신의 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 포크를 가리킬 것 입니다.</target>
        </trans-unit>
        <trans-unit id="49e089f7d3412f57a533b95b4289e1725ee616b3" translate="yes" xml:space="preserve">
          <source>This template converter will replicate all &lt;strong&gt;function&lt;/strong&gt; and &lt;strong&gt;subroutine&lt;/strong&gt; blocks in the file with names that contain &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; according to the rules in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;. The number of comma-separated words in &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; determines the number of times the block is repeated. What these words are indicates what that repeat rule, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo;, should be replaced with in each block. All of the repeat rules in a block must contain the same number of comma-separated words indicating the number of times that block should be repeated. If the word in the repeat rule needs a comma, leftarrow, or rightarrow, then prepend it with a backslash &amp;lsquo; &amp;lsquo;. If a word in the repeat rule matches &amp;lsquo; \&amp;lt;index&amp;gt;&amp;rsquo; then it will be replaced with the &amp;lt;index&amp;gt;-th word in the same repeat specification. There are two forms for the repeat rule: named and short.</source>
          <target state="translated">이 템플릿 변환기는 모든 &lt;strong&gt;기능&lt;/strong&gt; 과 &lt;strong&gt;서브 루틴을&lt;/strong&gt; 복제합니다&lt;strong&gt;&lt;/strong&gt;'&amp;lt;&amp;hellip;&amp;gt;'의 규칙에 따라 이름이 '&amp;lt;&amp;hellip;&amp;gt;'인 파일의 블록. '&amp;lt;&amp;hellip;&amp;gt;'에서 쉼표로 구분 된 단어의 수는 블록이 반복되는 횟수를 결정합니다. 이 단어들은 반복 규칙 '&amp;lt;&amp;hellip;&amp;gt;'이 각 블록에서 대체되어야하는 것을 나타냅니다. 블록의 모든 반복 규칙에는 블록을 반복해야하는 횟수를 나타내는 동일한 수의 쉼표로 구분 된 단어가 포함되어야합니다. 반복 규칙의 단어에 쉼표, 왼쪽 화살표 또는 오른쪽 화살표가 필요한 경우 백 슬래시 ''를 앞에 추가하십시오. 반복 규칙의 단어가 '\ &amp;lt;index&amp;gt;'와 일치하면 동일한 반복 사양에서 &amp;lt;index&amp;gt; 번째 단어로 바뀝니다. 반복 규칙에는 named와 short라는 두 가지 형식이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b0c224585cc04560ef8f7427d408f831662e6b0" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of NumPy and want to understand how masked arrays and the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module can be used in practice.</source>
          <target state="translated">이 튜토리얼은 NumPy에 대한 기본적인 이해가 있고 마스킹 된 배열과 &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; 모듈이 실제로 어떻게 사용될 수 있는지 이해하고자하는 사람들을위한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="e17f08578fff4f4b7f45b2cc421b1a2466a7ddfd" translate="yes" xml:space="preserve">
          <source>This tutorial is for people who have a basic understanding of linear algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="translated">이 튜토리얼은 NumPy의 선형 대수 및 배열에 대한 기본적인 이해가 있고 n 차원 (</target>
        </trans-unit>
        <trans-unit id="1f4e248732bbeee435a6603f84a77d8416a7d7b4" translate="yes" xml:space="preserve">
          <source>This tutorial is intended as a quick overview of algebra and arrays in NumPy and want to understand how n-dimensional (</source>
          <target state="translated">이 튜토리얼은 NumPy의 대수 및 배열에 대한 간략한 개요를 제공하며 n 차원 (</target>
        </trans-unit>
        <trans-unit id="f3fb6c8e0c4b1a20c93f451ff612ab566979e83c" translate="yes" xml:space="preserve">
          <source>This type provides an iterator that encapsulates the concept of broadcasting. It allows</source>
          <target state="translated">이 유형은 브로드 캐스트 개념을 캡슐화하는 반복자를 제공합니다. 그것은 허용</target>
        </trans-unit>
        <trans-unit id="1cc43cfc53c5139a19951c354fea30226e0f77c2" translate="yes" xml:space="preserve">
          <source>This updates your feature branch with changes from the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repo. If you do not absolutely need to do this, try to avoid doing it, except perhaps when you are finished. The first step will be to update the remote repository with new commits from upstream:</source>
          <target state="translated">이렇게하면 업스트림 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github 리포지토리의&lt;/a&gt; 변경 사항으로 기능 브랜치가 업데이트됩니다 . 이 작업을 반드시 수행 할 필요가 없으면 작업이 완료된 경우를 제외하고는 수행하지 않도록하십시오. 첫 번째 단계는 업스트림의 새 커밋으로 원격 저장소를 업데이트하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fedc2274acc4b818673988228fa9cde0f7271aad" translate="yes" xml:space="preserve">
          <source>This usage is discouraged, because it is ambiguous with the other dict-based construction method. If you have a field called &amp;lsquo;names&amp;rsquo; and a field called &amp;lsquo;formats&amp;rsquo; there will be a conflict.</source>
          <target state="translated">이 사용법은 다른 dict-based 건설 방법과 모호하기 때문에 권장하지 않습니다. 'names'라는 필드와 'formats'라는 필드가 있으면 충돌이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="57872c5abdb149b7d4963cf4f155c74d4913dff4" translate="yes" xml:space="preserve">
          <source>This version replaces the ASCII string (which in practice was latin1) with a utf8-encoded string, so supports structured types with any unicode field names.</source>
          <target state="translated">이 버전은 ASCII 문자열 (실제로 latin1 임)을 utf8로 인코딩 된 문자열로 대체하므로 유니 코드 필드 이름으로 구조화 된 유형을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="edc2f7bd6317d38177dd997f322c5b71aa234a4f" translate="yes" xml:space="preserve">
          <source>This view has the same dtype and itemsize as the indexed field, so it is typically a non-structured array, except in the case of nested structures.</source>
          <target state="translated">이 뷰에는 인덱싱 된 필드와 동일한 dtype 및 itemsize가 있으므로 일반적으로 중첩 된 구조의 경우를 제외하고 구조화되지 않은 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f66a767f0f656eca452c102d2e2bcfa75e3b2eec" translate="yes" xml:space="preserve">
          <source>This way of working helps to keep work well organized and the history as clear as possible.</source>
          <target state="translated">이러한 작업 방식은 작업을 잘 정리하고 역사를 가능한 한 명확하게 유지하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="bd10a8b1d06600ccbaab74bb218a771768eae1ee" translate="yes" xml:space="preserve">
          <source>This will ask for your key PGP passphrase, in order to sign the built source packages.</source>
          <target state="translated">빌드 된 소스 패키지에 서명하기 위해 키 PGP 암호를 요청합니다.</target>
        </trans-unit>
        <trans-unit id="3b6efd49b695f694142bfb54798d0f3fc1890e14" translate="yes" xml:space="preserve">
          <source>This will be a new view object if possible; otherwise, it will be a copy. Note there is no guarantee of the &lt;em&gt;memory layout&lt;/em&gt; (C- or Fortran- contiguous) of the returned array.</source>
          <target state="translated">가능한 경우 새로운 뷰 객체가됩니다. 그렇지 않으면 사본이됩니다. 반환 된 배열 의 &lt;em&gt;메모리 레이아웃&lt;/em&gt; (C 또는 Fortran-contiguous)은 보장되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="8a5efb1ea8118b8207bdfa5a6ca70f84b9755cf3" translate="yes" xml:space="preserve">
          <source>This will be the default for all columns</source>
          <target state="translated">모든 열의 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="6ee2bb240a6f906f9c6caaca502a22c771c78509" translate="yes" xml:space="preserve">
          <source>This will compile numpy on 4 CPUs and install it into the specified prefix. to perform a parallel in-place build, run:</source>
          <target state="translated">이것은 4 개의 CPU에서 numpy를 컴파일하고 지정된 접두사에 설치합니다. 병렬 내부 빌드를 수행하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="82de4d27fe00c2e50e0f9b4ff494406f1e8a2a9f" translate="yes" xml:space="preserve">
          <source>This will create a report in &lt;code&gt;build/coverage&lt;/code&gt;, which can be viewed with:</source>
          <target state="translated">이렇게하면 &lt;code&gt;build/coverage&lt;/code&gt; 에 보고서가 생성 되며 다음과 같이 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8933167843c02b6efd0369f05c57b0cadbffbc22" translate="yes" xml:space="preserve">
          <source>This will install the file foo.ini into the directory package_dir/lib, and the foo.ini file will be generated from foo.ini.in, where each &lt;code&gt;@version@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict['version']&lt;/code&gt;. The dictionary has an additional prefix substitution rule automatically added, which contains the install prefix (since this is not easy to get from setup.py). npy-pkg-config files can also be installed at the same location as used for numpy, using the path returned from &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; function.</source>
          <target state="translated">그러면 foo.ini 파일이 package_dir / lib 디렉토리에 설치되고 foo.ini 파일이 foo.ini.in에서 생성됩니다. 여기서 각 &lt;code&gt;@version@&lt;/code&gt; 은 &lt;code&gt;subst_dict['version']&lt;/code&gt; 로 바뀝니다 . 사전에는 추가 접두사 대체 규칙이 자동으로 추가되는데, 여기에는 설치 접두사가 들어 있습니다 (setup.py에서 쉽게 얻을 수 없기 때문에). npy-pkg-config 파일은 &lt;code&gt;get_npy_pkg_dir&lt;/code&gt; 함수 에서 반환 된 경로를 사용하여 numpy에 사용 된 것과 동일한 위치에 설치할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="520884ce9a07e1b7b3267f965a90c87f51ddd2d6" translate="yes" xml:space="preserve">
          <source>This will open an editor with the following text in it:</source>
          <target state="translated">그러면 다음 텍스트가 포함 된 편집기가 열립니다.</target>
        </trans-unit>
        <trans-unit id="939c7c1369b63ae063d5f436c52d25c44b07c327" translate="yes" xml:space="preserve">
          <source>This will produce an extension module named filter.so in the current directory with a method named dfilter2d that returns a filtered version of the input.</source>
          <target state="translated">그러면 입력의 필터링 된 버전을 반환하는 dfilter2d라는 메서드를 사용하여 현재 디렉터리에 filter.so라는 확장 모듈이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="da4b4079ec57ef48d099df7ab2d17f04629ceaf5" translate="yes" xml:space="preserve">
          <source>This will work with MSVC, which otherwise chokes on very long strings.</source>
          <target state="translated">이것은 MSVC에서 작동하며 그렇지 않으면 매우 긴 문자열에서 질식합니다.</target>
        </trans-unit>
        <trans-unit id="09f5f63667326a5abebdc8b9ee9a7240e62a05f5" translate="yes" xml:space="preserve">
          <source>This will write the settings into your git configuration file, which should now contain a user section with your name and email:</source>
          <target state="translated">이렇게하면 설정이 git 구성 파일에 기록되며, 이제 이름과 이메일이 포함 된 사용자 섹션이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="00582fa3dde2e164fba27e484b480804eaaba584" translate="yes" xml:space="preserve">
          <source>This works for both standard installs and in-place builds, i.e. the &lt;code&gt;@prefix@&lt;/code&gt; refer to the source directory for in-place builds.</source>
          <target state="translated">이는 표준 설치 및 전체 빌드에서 모두 작동합니다. 즉, &lt;code&gt;@prefix@&lt;/code&gt; 는 전체 빌드 의 소스 디렉토리를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8dbc0909265236a8e2f517b68e39944b2e4da272" translate="yes" xml:space="preserve">
          <source>Those can be useful for precise floating point comparison.</source>
          <target state="translated">이것들은 정확한 부동 소수점 비교에 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae29a3649bad434c98c44c18fb3c7ec696b132a3" translate="yes" xml:space="preserve">
          <source>Those who want really good performance out of their low level operations should strongly consider directly using the iteration API provided in C, but for those who are not comfortable with C or C++, Cython is a good middle ground with reasonable performance tradeoffs. For the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object, this means letting the iterator take care of broadcasting, dtype conversion, and buffering, while giving the inner loop to Cython.</source>
          <target state="translated">낮은 수준의 작업에서 실제로 우수한 성능을 원하는 사람은 C에서 제공하는 반복 API를 직접 사용하는 것이 좋습니다. 그러나 C 또는 C ++에 익숙하지 않은 사람에게는 Cython은 합리적인 성능 균형을 유지하는 좋은 중간 지점입니다. 에 대한 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 객체 사이 썬의 내부 루프를 제공하면서, 방송, DTYPE 변환 및 버퍼링의 반복자 돌봐셔서이 의미합니다.</target>
        </trans-unit>
        <trans-unit id="69a5e45c8dfd90560d7c862ef6ebab38e4725ee6" translate="yes" xml:space="preserve">
          <source>Though the demonstrated way of wrapping Fortran routines to Python is very straightforward, it has several drawbacks (see the comments above). These drawbacks are due to the fact that there is no way that F2PY can determine what is the actual intention of one or the other argument, is it input or output argument, or both, or something else. So, F2PY conservatively assumes that all arguments are input arguments by default.</source>
          <target state="translated">Fortran 루틴을 Python으로 래핑하는 시연 된 방법은 매우 간단하지만 몇 가지 단점이 있습니다 (위의 주석 참조). 이러한 단점은 F2PY가 하나 또는 다른 인수의 실제 의도, 입력 또는 출력 인수 또는 둘 다 또는 다른 것을 결정할 수있는 방법이 없다는 사실에 기인합니다. 따라서 F2PY는 모든 인수가 기본적으로 입력 인수라고 보수적으로 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4ea9f95f9e9b92d3d1f748e1eafd1b88bb106fab" translate="yes" xml:space="preserve">
          <source>Though we welcome people fluent in all languages, NumPy development is conducted in English.</source>
          <target state="translated">모든 언어에 능통 한 사람들을 환영하지만 NumPy 개발은 영어로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="98cd6421fe23fe93d73ba2b3eea2e1d452707c95" translate="yes" xml:space="preserve">
          <source>Thread safe f2py callback functions</source>
          <target state="translated">스레드로부터 안전한 f2py 콜백 함수</target>
        </trans-unit>
        <trans-unit id="35e557dff981ec6af1be9c041d1715ad421f55bd" translate="yes" xml:space="preserve">
          <source>Threading support</source>
          <target state="translated">스레딩 지원</target>
        </trans-unit>
        <trans-unit id="2d3ac6352887bde0f838813d8ea2d7bd7a567c2f" translate="yes" xml:space="preserve">
          <source>Three common use cases are:</source>
          <target state="translated">세 가지 일반적인 사용 사례는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cfe35da7de09a2e27452780257d1fa8fced9ae75" translate="yes" xml:space="preserve">
          <source>Three ways to wrap - getting started</source>
          <target state="translated">포장하는 세 가지 방법-시작하기</target>
        </trans-unit>
        <trans-unit id="987f8885750fc51202cc3964c96525b26400aa8c" translate="yes" xml:space="preserve">
          <source>Three-by-two array of random numbers from [-5, 0):</source>
          <target state="translated">[-5, 0)의 난수로 구성된 3x2 배열 :</target>
        </trans-unit>
        <trans-unit id="648f2b8e04236f9ba0d33739777255491d46f3b0" translate="yes" xml:space="preserve">
          <source>Threshold below which SVD values are considered zero. If &lt;code&gt;tol&lt;/code&gt; is None, and &lt;code&gt;S&lt;/code&gt; is an array with singular values for &lt;code&gt;M&lt;/code&gt;, and &lt;code&gt;eps&lt;/code&gt; is the epsilon value for datatype of &lt;code&gt;S&lt;/code&gt;, then &lt;code&gt;tol&lt;/code&gt; is set to &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt;.</source>
          <target state="translated">어떤 SVD 값 이하의 임계 값은 0으로 간주됩니다. 경우 &lt;code&gt;tol&lt;/code&gt; 없음없고, &lt;code&gt;S&lt;/code&gt; 는 에 대한 특이 값을 갖는 배열 &lt;code&gt;M&lt;/code&gt; 및 &lt;code&gt;eps&lt;/code&gt; 의 데이터 유형에 대한 엡실론 값 &lt;code&gt;S&lt;/code&gt; 후 &lt;code&gt;tol&lt;/code&gt; 로 설정 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a18ce980b9b6a0af6ba5335aa5043a3f61a2139" translate="yes" xml:space="preserve">
          <source>Throw a dice 20 times:</source>
          <target state="translated">주사위를 20 번 던지십시오 :</target>
        </trans-unit>
        <trans-unit id="e8597c496d58a52fd023424932f79f11d89743f4" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;a href=&quot;../reference/generated/numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;numpy.ndarray.item&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">따라서 튜플은 네이티브 Python 정수가 numpy의 정수 형식과 동일한 것처럼 numpy의 구조화 된 유형에 해당하는 네이티브 Python으로 간주 될 수 있습니다. 구조화 된 스칼라는 &lt;a href=&quot;../reference/generated/numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;numpy.ndarray.item&lt;/code&gt; &lt;/a&gt; 을 호출하여 튜플로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6c62c18ed666f3768ae228e6da435d58941de5d" translate="yes" xml:space="preserve">
          <source>Thus, tuples might be thought of as the native Python equivalent to numpy&amp;rsquo;s structured types, much like native python integers are the equivalent to numpy&amp;rsquo;s integer types. Structured scalars may be converted to a tuple by calling &lt;code&gt;ndarray.item&lt;/code&gt;:</source>
          <target state="translated">따라서 튜플은 네이티브 Python 정수가 numpy의 정수 형식과 동일한 것처럼 numpy의 구조화 된 유형에 해당하는 네이티브 Python으로 간주 될 수 있습니다. 구조화 된 스칼라는 &lt;code&gt;ndarray.item&lt;/code&gt; 을 호출하여 튜플로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="699ce8b0c5a25495e7df7b31eb754f06f5937265" translate="yes" xml:space="preserve">
          <source>Tile an array.</source>
          <target state="translated">배열을 바둑판 식으로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="9478b387e78ee7ed878f28def0d9d737a40db3cf" translate="yes" xml:space="preserve">
          <source>Tiling arrays</source>
          <target state="translated">타일 ​​배열</target>
        </trans-unit>
        <trans-unit id="ae9e32a7bf76d858a6643fb3d615f4e6b741df45" translate="yes" xml:space="preserve">
          <source>Time span (absolute)</source>
          <target state="translated">시간 범위 (절대)</target>
        </trans-unit>
        <trans-unit id="83a0b67f984af7843f2cd5f9c4c4a4937a96b824" translate="yes" xml:space="preserve">
          <source>Time span (relative)</source>
          <target state="translated">시간 범위 (상대)</target>
        </trans-unit>
        <trans-unit id="f427901653e2f16331f232b03616db8d30b0bf3e" translate="yes" xml:space="preserve">
          <source>Timedelta</source>
          <target state="translated">Timedelta</target>
        </trans-unit>
        <trans-unit id="4c953c5dc449ee95c79ccb8a9c6463f3dce00860" translate="yes" xml:space="preserve">
          <source>Timedelta64</source>
          <target state="translated">Timedelta64</target>
        </trans-unit>
        <trans-unit id="a836f04893b4c22a5902f8a189928c3d93f72795" translate="yes" xml:space="preserve">
          <source>Timezone information to use when displaying the datetime. If &amp;lsquo;UTC&amp;rsquo;, end with a Z to indicate UTC time. If &amp;lsquo;local&amp;rsquo;, convert to the local timezone first, and suffix with a +-#### timezone offset. If a tzinfo object, then do as with &amp;lsquo;local&amp;rsquo;, but use the specified timezone.</source>
          <target state="translated">날짜 / 시간을 표시 할 때 사용할 시간대 정보. 'UTC'이면 UTC 시간을 나타 내기 위해 Z로 끝납니다. 'local'인 경우 먼저 현지 시간대로 변환하고 +-#### 시간대 오프셋으로 접미어를 변환하십시오. tzinfo 오브젝트 인 경우 'local'과 동일하게 수행하지만 지정된 시간대를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="73a38ab3a76b2ed7df0194513c7633ac39221da4" translate="yes" xml:space="preserve">
          <source>Timing of individual tests with &lt;code&gt;nose-timer&lt;/code&gt; (which needs to be installed). If True, time tests and report on all of them. If an integer (say &lt;code&gt;N&lt;/code&gt;), report timing results for &lt;code&gt;N&lt;/code&gt; slowest tests.</source>
          <target state="translated">&lt;code&gt;nose-timer&lt;/code&gt; 사용한 개별 테스트 타이밍 (설치해야 함). 참이면 시간 테스트를하고 모두에 대해보고합니다. 정수 (예 : &lt;code&gt;N&lt;/code&gt; ) 인 경우 가장 느린 &lt;code&gt;N&lt;/code&gt; 개의 테스트에 대한 타이밍 결과를보고 합니다.</target>
        </trans-unit>
        <trans-unit id="661d4063b8ec8980f63428513015c42d7d7a39d4" translate="yes" xml:space="preserve">
          <source>Timings</source>
          <target state="translated">Timings</target>
        </trans-unit>
        <trans-unit id="535904f7958066905a2c6d516287e9eeaaa0c6e1" translate="yes" xml:space="preserve">
          <source>Timsort and radix sort have replaced mergesort for stable sorting</source>
          <target state="translated">안정적인 정렬을 위해 Timsort 및 기수 정렬이 mergesort를 대체했습니다.</target>
        </trans-unit>
        <trans-unit id="18696f01e06a1b84af54b40680c306637cf01d64" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For details of timsort, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">Timsort는 이미 또는 거의 정렬 된 데이터의 성능을 향상시키기 위해 추가되었습니다. 임의의 데이터에서 timsort는 mergesort와 거의 동일합니다. 이 옵션은 안정적인 정렬에 사용되는 반면, 퀵 정렬은 여전히 ​​선택되지 않은 경우 기본 정렬입니다. timsort에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt를&lt;/a&gt; 참조하십시오 . 'mergesort'및 'stable'은 정수 데이터 유형의 기수 정렬에 맵핑됩니다. 기수 정렬은 O (n log n) 대신 O (n) 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="4c9ab7d1647422ac2345aafe56b9ec321ff2ddfd" translate="yes" xml:space="preserve">
          <source>Timsort is added for better performance on already or nearly sorted data. On random data timsort is almost identical to mergesort. It is now used for stable sort while quicksort is still the default sort if none is chosen. For timsort details, refer to &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt&lt;/a&gt;. &amp;lsquo;mergesort&amp;rsquo; and &amp;lsquo;stable&amp;rsquo; are mapped to radix sort for integer data types. Radix sort is an O(n) sort instead of O(n log n).</source>
          <target state="translated">이미 또는 거의 정렬 된 데이터에서 더 나은 성능을 위해 Timsort가 추가되었습니다. 무작위 데이터에서 timsort는 mergesort와 거의 동일합니다. 이제는 안정된 정렬에 사용되지만 선택되지 않은 경우 빠른 정렬이 여전히 기본 정렬입니다. timsort 세부 사항은 &lt;a href=&quot;https://github.com/python/cpython/blob/3.7/Objects/listsort.txt&quot;&gt;CPython listsort.txt를&lt;/a&gt; 참조하십시오 . 'mergesort'및 'stable'은 정수 데이터 유형에 대한 기수 정렬에 매핑됩니다. 기수 정렬은 O (n log n) 대신 O (n) 정렬입니다.</target>
        </trans-unit>
        <trans-unit id="d19ceca501465c339e3bcf2bc0d8ff02bb697d6c" translate="yes" xml:space="preserve">
          <source>Tip</source>
          <target state="translated">Tip</target>
        </trans-unit>
        <trans-unit id="e4a5f9b37a824ec47658f0ce1a5ad5ba55b84339" translate="yes" xml:space="preserve">
          <source>Tip: &lt;code&gt;entry&lt;/code&gt; statement can be used to describe the signature of an arbitrary routine allowing F2PY to generate a number of wrappers from only one routine block signature. There are few restrictions while doing this: &lt;code&gt;fortranname&lt;/code&gt; cannot be used, &lt;code&gt;callstatement&lt;/code&gt; and &lt;code&gt;callprotoargument&lt;/code&gt; can be used only if they are valid for all entry routines, etc.</source>
          <target state="translated">팁 : &lt;code&gt;entry&lt;/code&gt; 문을 사용하여 임의 루틴의 서명을 설명 할 수 있으므로 F2PY가 하나의 루틴 블록 서명에서만 여러 래퍼를 생성 할 수 있습니다. 이 작업을 수행하는 동안 몇 가지 제한 사항이 있습니다. &lt;code&gt;fortranname&lt;/code&gt; 을 사용할 수없고, &lt;code&gt;callstatement&lt;/code&gt; 및 &lt;code&gt;callprotoargument&lt;/code&gt; 는 모든 항목 루틴에 대해 유효한 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e96f3984eaaf637764ee32773288dabcc604bf6b" translate="yes" xml:space="preserve">
          <source>Tips &amp;amp; Tricks</source>
          <target state="translated">팁 &amp;amp; 트릭</target>
        </trans-unit>
        <trans-unit id="caa39d36bfce368de59fb6b06774c2bd179f06cf" translate="yes" xml:space="preserve">
          <source>Title case words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">제목 대소 문자는 대문자로 시작하고 나머지 대소 문자는 모두 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="45c41172aa1c58d7ba017f081fcd4e2ace4e86f0" translate="yes" xml:space="preserve">
          <source>Title that is printed in the string representation of &lt;a href=&quot;#numpy.MachAr&quot;&gt;&lt;code&gt;MachAr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.MachAr&quot;&gt; &lt;code&gt;MachAr&lt;/code&gt; &lt;/a&gt; 의 문자열 표현으로 인쇄 된 제목입니다 .</target>
        </trans-unit>
        <trans-unit id="20fb23c1b6aaaab924d80202c9bd41b9e867e2de" translate="yes" xml:space="preserve">
          <source>To Cython-ize this function, we replace the inner loop (y[&amp;hellip;] += x*x) with Cython code that&amp;rsquo;s specialized for the float64 dtype. With the &amp;lsquo;external_loop&amp;rsquo; flag enabled, the arrays provided to the inner loop will always be one-dimensional, so very little checking needs to be done.</source>
          <target state="translated">이 함수를 Cython-ize하기 위해 내부 루프 (y [&amp;hellip;] + = x * x)를 float64 dtype에 특화된 Cython 코드로 바꿉니다. 'external_loop'플래그를 사용하면 내부 루프에 제공되는 배열은 항상 1 차원이므로 검사가 거의 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="36e086a6bd3eb648c4aebbd467026f4cd1c91bb0" translate="yes" xml:space="preserve">
          <source>To achieve a behaviour similar to the basic slicing above, broadcasting can be used. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; can help with this broadcasting. This is best understood with an example.</source>
          <target state="translated">위의 기본 슬라이싱과 유사한 동작을 달성하기 위해 브로드 캐스트를 사용할 수 있습니다. &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 기능 은이 방송에 도움이 될 수 있습니다. 이것은 예제를 통해 가장 잘 이해됩니다.</target>
        </trans-unit>
        <trans-unit id="157492b79c5123115a363aac40a6322c3b4d23a2" translate="yes" xml:space="preserve">
          <source>To achieve what we want, we will make the following changes to it:</source>
          <target state="translated">원하는 것을 달성하기 위해 다음과 같이 변경합니다.</target>
        </trans-unit>
        <trans-unit id="d82eff9778b88421c109607c96725b336dc7bcf8" translate="yes" xml:space="preserve">
          <source>To actually build the binaries after everything is set up correctly, the release.sh script can be used. For details of the build process itself, it is best to read the pavement.py script.</source>
          <target state="translated">모든 것이 올바르게 설정된 후 실제로 바이너리를 빌드하려면 release.sh 스크립트를 사용할 수 있습니다. 빌드 프로세스 자체에 대한 자세한 내용은 pavement.py 스크립트를 읽는 것이 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c76b68b96c698129b0e21483e667a083f4f8f28a" translate="yes" xml:space="preserve">
          <source>To add the rows or the columns in a 2D array, you would specify the axis.</source>
          <target state="translated">2D 배열에 행 또는 열을 추가하려면 축을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="3f0b09a56b5f5cb6866275af7bae4ae9b88cd546" translate="yes" xml:space="preserve">
          <source>To add titles when using the list-of-tuples form of dtype specification, the field name may be specified as a tuple of two strings instead of a single string, which will be the field&amp;rsquo;s title and field name respectively. For example:</source>
          <target state="translated">dtype 사양의 튜플 목록 형식을 사용할 때 제목을 추가하려면 필드 이름을 단일 문자열 대신 두 문자열의 튜플 (각각 필드의 제목 및 필드 이름)으로 지정할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="03c09cbfb1aed4718ffc26452a3968e86a1cd3bc" translate="yes" xml:space="preserve">
          <source>To allow the datetime to be used in contexts where only certain days of the week are valid, NumPy includes a set of &amp;ldquo;busday&amp;rdquo; (business day) functions.</source>
          <target state="translated">NumPy에는 특정 요일 만 유효한 상황에서 날짜 시간을 사용할 수 있도록 &quot;버스 데이&quot;(업무 일) 기능 세트가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="846af85fcfe300adce4c3f84895144d6dc4a75b5" translate="yes" xml:space="preserve">
          <source>To be completed.</source>
          <target state="translated">완료합니다.</target>
        </trans-unit>
        <trans-unit id="f6ad91f78d6c9353549254a135a4c203ecca9427" translate="yes" xml:space="preserve">
          <source>To be consistent with surrounding code that also breaks it (maybe for historic reasons) &amp;ndash; although this is also an opportunity to clean up someone else&amp;rsquo;s mess.</source>
          <target state="translated">(아마도 역사적 이유 때문일 수도 있음) 주변 코드와 일관성을 유지하기 위해-다른 사람의 엉망진창을 정리할 수있는 기회이기도합니다.</target>
        </trans-unit>
        <trans-unit id="172099588df066f08374020a56522cb6cad0b84f" translate="yes" xml:space="preserve">
          <source>To become eligible to join the Steering Council, an individual must be a Project Contributor who has produced contributions that are substantial in quality and quantity, and sustained over at least one year. Potential Council Members are nominated by existing Council members, and become members following consensus of the existing Council members, and confirmation that the potential Member is interested and willing to serve in that capacity. The Council will be initially formed from the set of existing Core Developers who, as of late 2015, have been significantly active over the last year.</source>
          <target state="translated">운영위원회에 가입 할 자격이 되려면 개인이 품질과 수량면에서 상당한 기여를하고 최소 1 년 이상 지속 된 프로젝트 기여자 여야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 잠재적위원회 위원은 기존위원회 구성원에 의해 지명되며, 기존위원회 구성원의 합의에 따라 구성원이되며, 잠재적 구성원이 그 역할에 관심이 있고 기꺼이 봉사 할 의사가 있음을 확인합니다. 위원회는 처음에 2015 년 말 기준으로 작년에 크게 활동 한 기존 핵심 개발자 세트로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="85134bce24b996ec39a48245eda44b01d4da42e0" translate="yes" xml:space="preserve">
          <source>To begin to make use of the new data-type, you need to first define a new Python type to hold the scalars of your new data-type. It should be acceptable to inherit from one of the array scalars if your new type has a binary compatible layout. This will allow your new data type to have the methods and attributes of array scalars. New data- types must have a fixed memory size (if you want to define a data-type that needs a flexible representation, like a variable-precision number, then use a pointer to the object as the data-type). The memory layout of the object structure for the new Python type must be PyObject_HEAD followed by the fixed-size memory needed for the data- type. For example, a suitable structure for the new Python type is:</source>
          <target state="translated">새 데이터 유형을 사용하려면 먼저 새 데이터 유형의 스칼라를 보유 할 새 Python 유형을 정의해야합니다. 새 유형에 이진 호환 레이아웃이있는 경우 배열 스칼라 중 하나에서 상속하는 것이 허용되어야합니다. 이렇게하면 새 데이터 유형이 배열 스칼라의 메서드와 속성을 가질 수 있습니다. 새로운 데이터 유형은 고정 된 메모리 크기를 가져야합니다 (가변 정밀도 숫자와 같이 유연한 표현이 필요한 데이터 유형을 정의하려면 데이터 유형으로 객체에 대한 포인터를 사용하십시오). 새로운 파이썬 유형에 대한 객체 구조의 메모리 레이아웃은 데이터 유형에 필요한 고정 크기 메모리가 뒤 따르는 PyObject_HEAD 여야합니다. 예를 들어, 새로운 Python 유형에 적합한 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c381239eecf186cabc8bbf33e7f7340c36dd415" translate="yes" xml:space="preserve">
          <source>To build an extension module, use</source>
          <target state="translated">확장 모듈을 빌드하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="262ab678dba163772e713fb5aa569cad52138f55" translate="yes" xml:space="preserve">
          <source>To build any extension modules for Python, you&amp;rsquo;ll need a C compiler. Various NumPy modules use FORTRAN 77 libraries, so you&amp;rsquo;ll also need a FORTRAN 77 compiler installed.</source>
          <target state="translated">Python 용 확장 모듈을 빌드하려면 C 컴파일러가 필요합니다. 다양한 NumPy 모듈은 FORTRAN 77 라이브러리를 사용하므로 FORTRAN 77 컴파일러도 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="e7e5cfb4630032e513b61c1b673be491694cda68" translate="yes" xml:space="preserve">
          <source>To build docs, run &lt;code&gt;make&lt;/code&gt; from the &lt;code&gt;doc&lt;/code&gt; directory. &lt;code&gt;make help&lt;/code&gt; lists all targets. For example, to build the HTML documentation, you can run:</source>
          <target state="translated">문서를 빌드하려면 &lt;code&gt;doc&lt;/code&gt; 디렉토리 에서 &lt;code&gt;make&lt;/code&gt; 를 실행 하십시오 . &lt;code&gt;make help&lt;/code&gt; 는 모든 대상을 나열합니다. 예를 들어 HTML 문서를 빌드하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0116b47532b1c9e3e3765cf9819856a98d018b60" translate="yes" xml:space="preserve">
          <source>To build the PDF documentation, do instead:</source>
          <target state="translated">PDF 문서를 작성하려면 대신 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="06915cfab63303daaadd53bd88f46eb60701ce38" translate="yes" xml:space="preserve">
          <source>To build the development version of NumPy and run tests, spawn interactive shells with the Python import paths properly set up etc., do one of:</source>
          <target state="translated">NumPy의 개발 버전을 빌드하고 테스트를 실행하려면 Python 가져 오기 경로가 올바르게 설정된 대화 형 셸을 생성하고 다음 중 하나를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="62e6dd105e1e44140e34cc1b1405df856709feb0" translate="yes" xml:space="preserve">
          <source>To build the final approximation matrix, we must understand how multiplication across different axes works.</source>
          <target state="translated">최종 근사 행렬을 작성하려면 서로 다른 축에서 곱셈이 어떻게 작동하는지 이해해야합니다.</target>
        </trans-unit>
        <trans-unit id="9057f4f734687a0b8a5f3961b0c067a8d6921992" translate="yes" xml:space="preserve">
          <source>To change the dimensions of an array, you can omit one of the sizes which will then be deduced automatically:</source>
          <target state="translated">배열의 크기를 변경하려면 자동으로 추론되는 크기 중 하나를 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59e2711afc65081105d063104c0dfaff7b844b23" translate="yes" xml:space="preserve">
          <source>To commit the staged files into the local copy of your repo, do &lt;code&gt;git
commit&lt;/code&gt;. At this point, a text editor will open up to allow you to write a commit message. Read the &lt;a href=&quot;#writing-the-commit-message&quot;&gt;commit message section&lt;/a&gt; to be sure that you are writing a properly formatted and sufficiently detailed commit message. After saving your message and closing the editor, your commit will be saved. For trivial commits, a short commit message can be passed in through the command line using the &lt;code&gt;-m&lt;/code&gt; flag. For example, &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt;.</source>
          <target state="translated">준비된 파일을 저장소의 로컬 사본에 커밋하려면 &lt;code&gt;git commit&lt;/code&gt; 합니다. 이 시점에서 커밋 메시지를 작성할 수있는 텍스트 편집기가 열립니다. &lt;a href=&quot;#writing-the-commit-message&quot;&gt;커밋 메시지 섹션&lt;/a&gt; 을 읽고 적절하게 형식이 지정되고 충분히 상세한 커밋 메시지를 작성하고 있는지 확인하십시오. 메시지를 저장하고 편집기를 닫으면 커밋이 저장됩니다. 사소한 커밋의 경우 &lt;code&gt;-m&lt;/code&gt; 플래그를 사용하여 명령 줄을 통해 짧은 커밋 메시지를 전달할 수 있습니다 . 예를 들어, &lt;code&gt;git commit -am &quot;ENH: Some message&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e713f5c0c4fc2dee368727d5468ec1ab8e8b8170" translate="yes" xml:space="preserve">
          <source>To construct an extension module, use</source>
          <target state="translated">확장 모듈을 구성하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4163e693f0e52983099e011b7813c35728efe745" translate="yes" xml:space="preserve">
          <source>To contribute code or documentation, you first need</source>
          <target state="translated">코드 또는 문서를 제공하려면 먼저</target>
        </trans-unit>
        <trans-unit id="1d3a9fa41ffe14d77bbc445c74fe6fd7a66d7a2d" translate="yes" xml:space="preserve">
          <source>To convert the type of an array, use the .astype() method (preferred) or the type itself as a function. For example:</source>
          <target state="translated">배열 유형을 변환하려면 .astype () 메서드 (권장) 또는 유형 자체를 함수로 사용합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="982c13e7b2d67cdbdf6848604f9d8f779a4cdca3" translate="yes" xml:space="preserve">
          <source>To create a NumPy array, you can use the function &lt;code&gt;np.array()&lt;/code&gt;.</source>
          <target state="translated">NumPy 배열을 만들려면 &lt;code&gt;np.array()&lt;/code&gt; 함수를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8941cedf9a3b3622178e2a604f85c6f9966d6beb" translate="yes" xml:space="preserve">
          <source>To create a masked array where all values close to 1.e20 are invalid, we would do:</source>
          <target state="translated">1.e20에 가까운 모든 값이 유효하지 않은 마스크 배열을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="e67f8cba1a223a6d273b67fa4a3d036f127fda38" translate="yes" xml:space="preserve">
          <source>To create a sub-type, a similar procedure must be followed except only behaviors that are different require new entries in the type- object structure. All other entries can be NULL and will be filled in by &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; with appropriate functions from the parent type(s). In particular, to create a sub-type in C follow these steps:</source>
          <target state="translated">하위 유형을 만들려면 다른 동작에만 유형 개체 구조에 새 항목이 필요하다는 점을 제외하고는 유사한 절차를 따라야합니다. 다른 모든 항목은 NULL 일 수 있으며 &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt; 에 의해 부모 유형의 적절한 함수 로 채워집니다 . 특히 C에서 하위 유형을 작성하려면 다음 단계를 따르십시오.</target>
        </trans-unit>
        <trans-unit id="fdf86d74a7427ac0a22c6f0a9b96d12080099d0c" translate="yes" xml:space="preserve">
          <source>To create an array with the second element invalid, we would do:</source>
          <target state="translated">두 번째 요소가 유효하지 않은 배열을 만들려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="27de4fde4d9713bb683ffd50eb85f9b3570fc745" translate="yes" xml:space="preserve">
          <source>To create sequences of numbers, NumPy provides the &lt;code&gt;arange&lt;/code&gt; function which is analogous to the Python built-in &lt;code&gt;range&lt;/code&gt;, but returns an array.</source>
          <target state="translated">숫자 시퀀스를 생성하기 위해 NumPy는 Python 내장 &lt;code&gt;range&lt;/code&gt; 와 유사한 &lt;code&gt;arange&lt;/code&gt; 함수를 제공 하지만 배열을 반환합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
