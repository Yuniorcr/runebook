<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="a9f67bac25f1e9fa1addb151018aeaf9def3b945" translate="yes" xml:space="preserve">
          <source>The default data type in NumPy is &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">NumPy의 기본 데이터 유형은 &lt;code&gt;float_&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="50b3a1f2cd19d600f3d2675b9e6ec25082ab0d35" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;a href=&quot;arrays.scalars#numpy.float_&quot;&gt;&lt;code&gt;float_&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본 데이터 유형 : &lt;a href=&quot;arrays.scalars#numpy.float_&quot;&gt; &lt;code&gt;float_&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1cb916c2a199dec22e3c7d35ff5ca943ade2af02" translate="yes" xml:space="preserve">
          <source>The default data type: &lt;code&gt;float_&lt;/code&gt;.</source>
          <target state="translated">기본 데이터 형식 : &lt;code&gt;float_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="585140e706eb572d257d276596c7c62733d99ac8" translate="yes" xml:space="preserve">
          <source>The default fill value.</source>
          <target state="translated">기본 채우기 값입니다.</target>
        </trans-unit>
        <trans-unit id="a6dbb84bde95674721b5026ade7be2a1d41460db" translate="yes" xml:space="preserve">
          <source>The default filling value depends on the datatype of the input array or the type of the input scalar:</source>
          <target state="translated">기본 채우기 값은 입력 배열의 데이터 유형 또는 입력 스칼라 유형에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d172f7f7da97c607ca46d821dc996e8763c04a60" translate="yes" xml:space="preserve">
          <source>The default for busday functions is that the only valid days are Monday through Friday (the usual business days). The implementation is based on a &amp;ldquo;weekmask&amp;rdquo; containing 7 Boolean flags to indicate valid days; custom weekmasks are possible that specify other sets of valid days.</source>
          <target state="translated">busday 기능의 기본값은 월요일부터 금요일 (일반 업무 일)까지만 유효합니다. 구현은 유효한 요일을 나타 내기 위해 7 개의 부울 플래그를 포함하는 &quot;weekmask&quot;를 기반으로합니다. 다른 유효한 요일 세트를 지정하는 사용자 정의 주 마스크가 가능합니다.</target>
        </trans-unit>
        <trans-unit id="b9e6f3b39a9841c2072fe28c903a4873d59b58cf" translate="yes" xml:space="preserve">
          <source>The default for most operations, raises an exception if an index is out of bounds.</source>
          <target state="translated">대부분의 작업에 대한 기본값은 인덱스가 범위를 벗어난 경우 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="b1071130df37f1589932b92836294305fd9d0ff9" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the Fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="translated">기본 인터페이스는 Fortran 코드를 Python으로 매우 문자 그대로 번역 한 것입니다. Fortran 배열 인수는 이제 NumPy 배열이어야하며 정수 인수는 정수 여야합니다. 인터페이스는 모든 인수를 필요한 유형 (및 모양)으로 변환하려고 시도하고 실패하면 오류를 발행합니다. 그러나 인수의 의미론에 대해 전혀 알지 못하기 때문에 (예 : C는 출력이고 n은 실제로 배열 크기와 일치해야 함) Python을 충돌시킬 수있는 방식으로이 함수를 남용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f01d70d1a58c31eb28ef483c3e412b7730114894" translate="yes" xml:space="preserve">
          <source>The default interface is a very literal translation of the fortran code into Python. The Fortran array arguments must now be NumPy arrays and the integer argument should be an integer. The interface will attempt to convert all arguments to their required types (and shapes) and issue an error if unsuccessful. However, because it knows nothing about the semantics of the arguments (such that C is an output and n should really match the array sizes), it is possible to abuse this function in ways that can cause Python to crash. For example:</source>
          <target state="translated">기본 인터페이스는 포트란 코드를 Python으로 매우 문자 그대로 번역 한 것입니다. Fortran 배열 인수는 이제 NumPy 배열이어야하며 정수 인수는 정수 여야합니다. 인터페이스는 모든 인수를 필요한 유형 (및 모양)으로 변환하려고 시도하고 실패하면 오류를 발행합니다. 그러나 인수의 의미론에 대해 전혀 알지 못하기 때문에 (예 : C는 출력이고 n은 실제로 배열 크기와 일치해야 함) Python을 충돌시킬 수있는 방식으로이 함수를 남용 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0b3aadfe669f7dc7282a8bf3bc7021b967d5f363" translate="yes" xml:space="preserve">
          <source>The default is not to change the current behavior.</source>
          <target state="translated">기본값은 현재 동작을 변경하지 않는 것입니다.</target>
        </trans-unit>
        <trans-unit id="35460c572d36a32620dc9fa812780440e2fcffff" translate="yes" xml:space="preserve">
          <source>The default is to &lt;code&gt;'warn'&lt;/code&gt; for &lt;code&gt;invalid&lt;/code&gt;, &lt;code&gt;divide&lt;/code&gt;, and &lt;code&gt;overflow&lt;/code&gt; and &lt;code&gt;'ignore'&lt;/code&gt; for &lt;code&gt;underflow&lt;/code&gt;. But this can be changed, and it can be set individually for different kinds of exceptions. The different behaviors are:</source>
          <target state="translated">기본값은 &lt;code&gt;invalid&lt;/code&gt; , &lt;code&gt;divide&lt;/code&gt; 및 &lt;code&gt;overflow&lt;/code&gt; &lt;code&gt;'warn'&lt;/code&gt; 경우 'warn' 이고 &lt;code&gt;underflow&lt;/code&gt; 의 경우 &lt;code&gt;'ignore'&lt;/code&gt; 입니다 . 그러나 이것은 변경할 수 있으며 다른 종류의 예외에 대해 개별적으로 설정할 수 있습니다. 다른 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="13f5430198109332da2b945e817fa963554a0039" translate="yes" xml:space="preserve">
          <source>The default iterator of an ndarray object is the default Python iterator of a sequence type. Thus, when the array object itself is used as an iterator. The default behavior is equivalent to:</source>
          <target state="translated">ndarray 객체의 기본 반복자는 시퀀스 유형의 기본 Python 반복기입니다. 따라서 배열 객체 자체가 반복자로 사용되는 경우 기본 동작은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aac361851a1a42c7bb314d3f5e868ac753b52020" translate="yes" xml:space="preserve">
          <source>The default method is &amp;ldquo;marginals&amp;rdquo;. For some cases (e.g. when &lt;code&gt;colors&lt;/code&gt; contains relatively small integers), the &amp;ldquo;count&amp;rdquo; method can be significantly faster than the &amp;ldquo;marginals&amp;rdquo; method. If performance of the algorithm is important, test the two methods with typical inputs to decide which works best.</source>
          <target state="translated">기본 방법은 &quot;marginals&quot;입니다. 경우에 따라 (예 : &lt;code&gt;colors&lt;/code&gt; 에 상대적으로 작은 정수가 포함 된 경우 ) &quot;count&quot;방법이 &quot;marginals&quot;방법보다 훨씬 빠를 수 있습니다. 알고리즘의 성능이 중요한 경우 일반적인 입력으로 두 가지 방법을 테스트하여 가장 적합한 방법을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="d0a1e3c85492f9a28cfa2d6a52018d6303212281" translate="yes" xml:space="preserve">
          <source>The default normalization has the direct transforms unscaled and the inverse transforms are scaled by</source>
          <target state="translated">기본 정규화에는 직접 변환의 배율이 조정되지 않으며 역 변환의 배율이</target>
        </trans-unit>
        <trans-unit id="294bd9e52acfdc133dee5d5ce445aefb23018ef1" translate="yes" xml:space="preserve">
          <source>The default order for the libraries are:</source>
          <target state="translated">라이브러리의 기본 순서는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d79f5666dde2a74098ca71f007435f35059e5b3e" translate="yes" xml:space="preserve">
          <source>The default threshold to detect rank deficiency is a test on the magnitude of the singular values of &lt;code&gt;M&lt;/code&gt;. By default, we identify singular values less than &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; as indicating rank deficiency (with the symbols defined above). This is the algorithm MATLAB uses [1]. It also appears in &lt;em&gt;Numerical recipes&lt;/em&gt; in the discussion of SVD solutions for linear least squares [2].</source>
          <target state="translated">순위 부족을 감지하기위한 기본 임계 값은 &lt;code&gt;M&lt;/code&gt; 의 특이 값 크기에 대한 테스트입니다 . 기본적으로 &lt;code&gt;S.max() * max(M.shape) * eps&lt;/code&gt; 보다 작은 특이 값을 순위 부족을 나타냅니다 (위에 정의 된 기호 사용). 이것이 MATLAB이 사용하는 알고리즘입니다 [1]. 또한 선형 최소 제곱에 대한 SVD 솔루션에 대한 논의 에서 &lt;em&gt;수치 레시피&lt;/em&gt; 에도 나타납니다 [2].</target>
        </trans-unit>
        <trans-unit id="fabcee56c3086c9123fae22826809a0d986ec9e3" translate="yes" xml:space="preserve">
          <source>The default type to use when no dtype is explicitly specified, for example when calling np.zero(shape). This is equivalent to &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt;&lt;code&gt;NPY_DOUBLE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">np.zero (shape)를 호출 할 때와 같이 dtype이 명시 적으로 지정되지 않은 경우 사용할 기본 유형입니다. 이것은 &lt;a href=&quot;#c.NPY_DOUBLE&quot;&gt; &lt;code&gt;NPY_DOUBLE&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a62d7fdf404d547735e1b655e9c601557613abc2" translate="yes" xml:space="preserve">
          <source>The default valid days are Monday through Friday (&amp;ldquo;business days&amp;rdquo;). A busdaycalendar object can be specified with any set of weekly valid days, plus an optional &amp;ldquo;holiday&amp;rdquo; dates that always will be invalid.</source>
          <target state="translated">기본 유효일은 월요일부터 금요일 ( &quot;영업일&quot;)입니다. busdaycalendar 객체는 주 단위로 유효한 요일과 항상 유효하지 않은 선택적 &quot;휴일&quot;날짜로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0b43ef4693453ebdb4d72174da4b3e8ae831417" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order.</source>
          <target state="translated">기본값 ( 'S')은 현재 바이트 순서를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="203757e2bdf5bbe5e651d506c476783cf6e50edd" translate="yes" xml:space="preserve">
          <source>The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">기본값 ( 'S')은 현재 바이트 순서를 교체합니다. 이 코드는 위의 대안에 대해 &lt;code&gt;new_order&lt;/code&gt; 의 첫 글자를 대소 문자를 구분하지 않고 검사합니다 . 예를 들어, 'B'또는 'b'또는 'biggish'는 big-endian을 지정하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="86906072113e4cc2809d8408fb9acbe0a4443ef7" translate="yes" xml:space="preserve">
          <source>The default value of &lt;code&gt;names&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;. If we give any other value to the keyword, the new names will overwrite the field names we may have defined with the dtype:</source>
          <target state="translated">&lt;code&gt;names&lt;/code&gt; 의 기본값 은 &lt;code&gt;None&lt;/code&gt; 입니다. 키워드에 다른 값을 지정하면 새 이름이 dtype으로 정의한 필드 이름을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="19a5ab6c7c39a905e845eb64d8df075515c15636" translate="yes" xml:space="preserve">
          <source>The defining property of the antiderivative:</source>
          <target state="translated">해독제 정의 특성 :</target>
        </trans-unit>
        <trans-unit id="7a4397ef8c9f537d85068ef5bbb9a575412a21fb" translate="yes" xml:space="preserve">
          <source>The definition of &lt;code&gt;C&lt;/code&gt; is the same as before, but for &lt;code&gt;D&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method returns an instance of class &lt;code&gt;C&lt;/code&gt; rather than &lt;code&gt;D&lt;/code&gt;. Note that the &lt;code&gt;__init__&lt;/code&gt; method of &lt;code&gt;D&lt;/code&gt; does not get called. In general, when the &lt;code&gt;__new__&lt;/code&gt; method returns an object of class other than the class in which it is defined, the &lt;code&gt;__init__&lt;/code&gt; method of that class is not called.</source>
          <target state="translated">&lt;code&gt;C&lt;/code&gt; 의 정의는 이전과 동일하지만 &lt;code&gt;D&lt;/code&gt; 의 경우 &lt;code&gt;__new__&lt;/code&gt; 메서드는 &lt;code&gt;D&lt;/code&gt; 대신 &lt;code&gt;C&lt;/code&gt; 클래스의 인스턴스를 반환합니다 . &lt;code&gt;D&lt;/code&gt; 의 &lt;code&gt;__init__&lt;/code&gt; 메서드는 호출되지 않습니다. 일반적으로 &lt;code&gt;__new__&lt;/code&gt; 메서드가 정의 된 클래스가 아닌 다른 클래스의 객체를 반환 할 때 해당 클래스의 &lt;code&gt;__init__&lt;/code&gt; 메서드는 호출되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a1b5640a64fc73d8755c0223b335feaa121479d8" translate="yes" xml:space="preserve">
          <source>The definition of advanced indexing means that &lt;code&gt;x[(1,2,3),]&lt;/code&gt; is fundamentally different than &lt;code&gt;x[(1,2,3)]&lt;/code&gt;. The latter is equivalent to &lt;code&gt;x[1,2,3]&lt;/code&gt; which will trigger basic selection while the former will trigger advanced indexing. Be sure to understand why this occurs.</source>
          <target state="translated">고급 인덱싱 수단의 정의가 &lt;code&gt;x[(1,2,3),]&lt;/code&gt; 과 근본적으로 상이하다 &lt;code&gt;x[(1,2,3)]&lt;/code&gt; . 후자는 &lt;code&gt;x[1,2,3]&lt;/code&gt; 과 동일하며 기본 선택은 트리거하고 전자는 고급 인덱싱을 트리거합니다. 왜 이런 일이 발생하는지 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="61496dee2f3816bd693a7ce0398282c8ea47a960" translate="yes" xml:space="preserve">
          <source>The definition of correlation above is not unique and sometimes correlation may be defined differently. Another common definition is:</source>
          <target state="translated">위의 상관 정의는 고유하지 않으며 때로는 상관이 다르게 정의 될 수도 있습니다. 또 다른 일반적인 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="938e670c022b166026c1f3d97b60b6e6eed3f831" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;argument/variable type declaration&amp;gt;&lt;/code&gt; 부분 의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1f4801e8c8f57fdee23b9a4f5485bae04f50607" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;common block statement&amp;gt;&lt;/code&gt; 부분 의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d5ed0cf6ae14e241898a603f2c9052eee0f3ff8c" translate="yes" xml:space="preserve">
          <source>The definition of the &lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; part is</source>
          <target state="translated">&lt;code&gt;&amp;lt;use statement&amp;gt;&lt;/code&gt; 부분 의 정의는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e5f33fe407bab51cea8bacccfd88b8a5036810dc" translate="yes" xml:space="preserve">
          <source>The degree of the series.</source>
          <target state="translated">시리즈의 정도.</target>
        </trans-unit>
        <trans-unit id="155faa0de8c44a325761ca30fe7a5e7dbf74e6e4" translate="yes" xml:space="preserve">
          <source>The depends list contains paths to files or directories that the sources of the extension module depend on. If any path in the depends list is newer than the extension module, then the module will be rebuilt.</source>
          <target state="translated">종속 목록에는 확장 모듈의 소스가 의존하는 파일 또는 디렉토리의 경로가 포함됩니다. 종속 목록의 경로가 확장 모듈보다 최신이면 모듈이 다시 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="8add200746bc778285c2910a22d91b2b8b258c85" translate="yes" xml:space="preserve">
          <source>The deprecated function.</source>
          <target state="translated">더 이상 사용되지 않는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="63644093036e4f3b360649808afd2f026edeffe7" translate="yes" xml:space="preserve">
          <source>The derivation of the t-distribution was first published in 1908 by William Gosset while working for the Guinness Brewery in Dublin. Due to proprietary issues, he had to publish under a pseudonym, and so he used the name Student.</source>
          <target state="translated">t- 분포의 유도는 1908 년 윌리엄 고셋 (William Gosset)에 의해 더블린의 기네스 브루어리 (Guinness Brewery)에서 일하면서 처음 출판되었다. 독점적 인 문제로 인해 그는 가명으로 출판해야했기 때문에 학생이라는 이름을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="7db2e5319fb072c88d575bc92b04bca324abdb47" translate="yes" xml:space="preserve">
          <source>The derivative of the polynomial</source>
          <target state="translated">다항식의 미분</target>
        </trans-unit>
        <trans-unit id="e38da7322eec5dfeb19db7a40e7e799054f3e9fa" translate="yes" xml:space="preserve">
          <source>The desc member of the PyCObject returned from __array_struct__ was not specified. Usually, it was the object exposing the array (so that a reference to it could be kept and destroyed when the C-object was destroyed). Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">__array_struct__에서 반환 된 PyCObject의 desc 멤버가 지정되지 않았습니다. 일반적으로 배열을 노출시키는 것은 객체였습니다 (따라서 C 객체가 파괴 될 때 어레이에 대한 참조를 유지하고 파괴 할 수 있습니다). 이제 첫 번째 요소가 &quot;PyArrayInterface Version #&quot;이있는 문자열이고 두 번째 요소가 배열을 노출하는 객체 인 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="d7dbcb2541cf001d7b26e25e4170575fd900c8ee" translate="yes" xml:space="preserve">
          <source>The description of the fourth element of the header therefore has become: &amp;ldquo;The next 4 bytes form a little-endian unsigned int: the length of the header data HEADER_LEN.&amp;rdquo;</source>
          <target state="translated">따라서 헤더의 네 번째 요소에 대한 설명은 다음과 같습니다. &quot;다음 4 바이트는 리틀 엔디안 부호없는 int를 형성합니다. 헤더 데이터 길이 HEADER_LEN.&quot;</target>
        </trans-unit>
        <trans-unit id="877e58bc0c85ccf0ef190f149115500e0d385da1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array The default, None, means</source>
          <target state="translated">배열에 대해 원하는 데이터 유형 기본값 없음은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="35a7d4b1a08d0cc477bdaa0f984f65c664ce2e77" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;a href=&quot;../arrays.scalars#numpy.int8&quot;&gt;&lt;code&gt;numpy.int8&lt;/code&gt;&lt;/a&gt;. Default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;numpy.float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에 대해 원하는 데이터 유형 (예 : &lt;a href=&quot;../arrays.scalars#numpy.int8&quot;&gt; &lt;code&gt;numpy.int8&lt;/code&gt; )&lt;/a&gt; . 기본값은 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;numpy.float64&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f4a52cabb32fca3b74ad0388e9c1cbe1cf8d25b1" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array, e.g., &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">어레이, 예를 들어, 데이터에 대한 원하는 형태 &lt;code&gt;numpy.int8&lt;/code&gt; . 기본값은 &lt;code&gt;numpy.float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a0a8a7651b0b383e3707246aaf8cd38e2e169098" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence.</source>
          <target state="translated">배열에 대해 원하는 데이터 유형입니다. 지정되지 않은 경우 유형은 시퀀스에서 객체를 보유하는 데 필요한 최소 유형으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f7534f7cefc524ae1e988328a3c98ad10f344592" translate="yes" xml:space="preserve">
          <source>The desired data-type for the array. If not given, then the type will be determined as the minimum type required to hold the objects in the sequence. This argument can only be used to &amp;lsquo;upcast&amp;rsquo; the array. For downcasting, use the .astype(t) method.</source>
          <target state="translated">배열의 원하는 데이터 유형입니다. 지정하지 않으면 유형이 순서대로 오브젝트를 보유하는 데 필요한 최소 유형으로 결정됩니다. 이 인수는 배열을 '업 캐스트'하는 데만 사용할 수 있습니다. 다운 캐스팅의 경우 .astype (t) 메소드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="50dd3f94578e7376ef4b1fc5b09b342ebb1fed2e" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is float.</source>
          <target state="translated">행렬에 대해 원하는 데이터 유형이며 기본값은 float입니다.</target>
        </trans-unit>
        <trans-unit id="07d678da86d17478a0143d6947f08f3fa51a5f65" translate="yes" xml:space="preserve">
          <source>The desired data-type for the matrix, default is np.float64.</source>
          <target state="translated">매트릭스에 대한 원하는 데이터 유형, 기본값은 np.float64입니다.</target>
        </trans-unit>
        <trans-unit id="d07509f4b4964e751a91c8805000083d2ee4926c" translate="yes" xml:space="preserve">
          <source>The desired data-type. By default, the data-type is determined from &lt;code&gt;formats&lt;/code&gt;, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;titles&lt;/code&gt;, &lt;code&gt;aligned&lt;/code&gt; and &lt;code&gt;byteorder&lt;/code&gt;.</source>
          <target state="translated">원하는 데이터 유형 기본적으로 데이터 유형은 &lt;code&gt;formats&lt;/code&gt; , &lt;code&gt;names&lt;/code&gt; , &lt;code&gt;titles&lt;/code&gt; , &lt;code&gt;aligned&lt;/code&gt; 및 &lt;code&gt;byteorder&lt;/code&gt; 에서 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3c998f357ef80cf65beb1c4220aff1c69081dd53" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">배열의 원하는 모양입니다. 경우 &lt;code&gt;mode == 'r'&lt;/code&gt; 이후 나머지 바이트의 수 &lt;code&gt;offset&lt;/code&gt; 의 바이트 크기의 배수가 아닌 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 를 지정해야합니다 &lt;a href=&quot;numpy.memmap.shape#numpy.memmap.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; . 기본적으로 반환 된 배열은 파일 크기 및 데이터 유형에 따라 결정된 요소 수와 함께 1 차원입니다.</target>
        </trans-unit>
        <trans-unit id="c217d27d3179585b289f1730298cd76c28917559" translate="yes" xml:space="preserve">
          <source>The desired shape of the array. If &lt;code&gt;mode == 'r'&lt;/code&gt; and the number of remaining bytes after &lt;code&gt;offset&lt;/code&gt; is not a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, you must specify &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. By default, the returned array will be 1-D with the number of elements determined by file size and data-type.</source>
          <target state="translated">원하는 배열 모양입니다. 경우 &lt;code&gt;mode == 'r'&lt;/code&gt; 이후 나머지 바이트의 수 &lt;code&gt;offset&lt;/code&gt; 의 바이트 크기의 배수가 아닌 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 를 지정해야합니다 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; . 기본적으로 반환되는 배열은 파일 크기 및 데이터 유형에 따라 결정되는 요소 수를 가진 1-D입니다.</target>
        </trans-unit>
        <trans-unit id="cdd86af715375b55e1d483d875bf1753af5d922f" translate="yes" xml:space="preserve">
          <source>The desired shape of the iterator. This allows &lt;code&gt;allocate&lt;/code&gt; operands with a dimension mapped by op_axes not corresponding to a dimension of a different operand to get a value not equal to 1 for that dimension.</source>
          <target state="translated">반복자의 원하는 모양입니다. 이를 통해 다른 피연산자의 차원에 해당하지 않는 op_axes에 의해 매핑 된 차원으로 피연산자를 &lt;code&gt;allocate&lt;/code&gt; 하여 해당 차원에 대해 1이 아닌 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84971317bba10bc74f9aaf650dccf1acca028d13" translate="yes" xml:space="preserve">
          <source>The desired, expected object.</source>
          <target state="translated">원하는 예상 개체입니다.</target>
        </trans-unit>
        <trans-unit id="40c65673e654df212bffc77b7c4cf508b802ea94" translate="yes" xml:space="preserve">
          <source>The determinant is computed via LU factorization using the LAPACK routine &lt;code&gt;z/dgetrf&lt;/code&gt;.</source>
          <target state="translated">결정자는 LAPACK 루틴 &lt;code&gt;z/dgetrf&lt;/code&gt; 를 사용하여 LU 인수 분해를 통해 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="94f9591a378d3f5d467509648f89e89bcee5af83" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; is &lt;code&gt;ad - bc&lt;/code&gt;:</source>
          <target state="translated">2 차원 배열 &lt;code&gt;[[a, b], [c, d]]&lt;/code&gt; 의 결정 요인 은 &lt;code&gt;ad - bc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67af8ebad34e1dbafff04ba3dd64dccd7934523b" translate="yes" xml:space="preserve">
          <source>The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</source>
          <target state="translated">2 차원 배열 [[a, b], [c, d]]의 결정 요인은 ad-bc입니다.</target>
        </trans-unit>
        <trans-unit id="e56bde2e38a2da31d0e2d0f24b802753579a52ca" translate="yes" xml:space="preserve">
          <source>The determinant of a square Vandermonde matrix is the product of the differences between the values of the input vector:</source>
          <target state="translated">정사각형 Vandermonde 행렬의 결정 요인은 입력 벡터 값의 차이의 곱입니다.</target>
        </trans-unit>
        <trans-unit id="60279460274321ba74cf96556a38bac9a87c73c6" translate="yes" xml:space="preserve">
          <source>The diagonal and diag functions return readonly views.</source>
          <target state="translated">대각선 및 diag 함수는 읽기 전용보기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="34c13c034ad3086185d61530fb01b7940b4e4527" translate="yes" xml:space="preserve">
          <source>The dictionary contains three keys:</source>
          <target state="translated">사전에는 세 개의 키가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7980c83ed9b10778dab7b594015b0c4b8c1b820c" translate="yes" xml:space="preserve">
          <source>The dictionary has two required keys, &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo;, and four optional keys, &amp;lsquo;offsets&amp;rsquo;, &amp;lsquo;itemsize&amp;rsquo;, &amp;lsquo;aligned&amp;rsquo; and &amp;lsquo;titles&amp;rsquo;. The values for &amp;lsquo;names&amp;rsquo; and &amp;lsquo;formats&amp;rsquo; should respectively be a list of field names and a list of dtype specifications, of the same length. The optional &amp;lsquo;offsets&amp;rsquo; value should be a list of integer byte-offsets, one for each field within the structure. If &amp;lsquo;offsets&amp;rsquo; is not given the offsets are determined automatically. The optional &amp;lsquo;itemsize&amp;rsquo; value should be an integer describing the total size in bytes of the dtype, which must be large enough to contain all the fields.</source>
          <target state="translated">사전에는 '이름'과 '형식'이라는 두 개의 필수 키와 'offsets', 'itemsize', 'aligned'및 'titles'라는 4 개의 선택적 키가 있습니다. 'names'및 'formats'의 값은 각각 동일한 길이의 필드 이름 목록과 dtype 사양 목록이어야합니다. 선택적 'offsets'값은 구조 내의 각 필드에 대해 하나씩 정수 바이트 오프셋 목록이어야합니다. '오프셋'이 제공되지 않으면 오프셋이 자동으로 결정됩니다. 선택적 'itemsize'값은 dtype의 전체 크기 (바이트)를 설명하는 정수 여야하며, 모든 필드를 포함 할 수있을만큼 충분히 커야합니다.</target>
        </trans-unit>
        <trans-unit id="bd944e951e9799c3343f288ae6c347a06ac11e23" translate="yes" xml:space="preserve">
          <source>The dictionary is indexed by keys that are the names of the fields. Each entry in the dictionary is a tuple fully describing the field:</source>
          <target state="translated">사전은 필드 이름 인 키로 색인화됩니다. 사전의 각 항목은 필드를 완전히 설명하는 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="fc72cbc84ea7846d80156db81f03031e6342d2d0" translate="yes" xml:space="preserve">
          <source>The dictionary with build information.</source>
          <target state="translated">빌드 정보가있는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="88918f47eb3cf48e5a0737e099c91aa35bc38894" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float larger than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;eps = 2**-52&lt;/code&gt;, approximately 2.22e-16.</source>
          <target state="translated">1.0과 1.0보다 큰 다음으로 가장 작은 표현 가능한 부동 소수점 사이의 차이입니다. 예를 들어, IEEE-754 표준의 64 비트 이진 부동의 경우 &lt;code&gt;eps = 2**-52&lt;/code&gt; , 약 2.22e-16입니다.</target>
        </trans-unit>
        <trans-unit id="c1d6f22ac980a152a56489087bf48f813ef3afe4" translate="yes" xml:space="preserve">
          <source>The difference between 1.0 and the next smallest representable float less than 1.0. For example, for 64-bit binary floats in the IEEE-754 standard, &lt;code&gt;epsneg = 2**-53&lt;/code&gt;, approximately 1.11e-16.</source>
          <target state="translated">1.0과 다음으로 가장 작은 표현 가능한 부동 소수점 사이의 차이는 1.0보다 작습니다. 예를 들어, IEEE-754 표준의 64 비트 이진 부동의 경우 &lt;code&gt;epsneg = 2**-53&lt;/code&gt; , 약 1.11e-16입니다.</target>
        </trans-unit>
        <trans-unit id="162f606f6e0310c46fbb8198beb3cd00b92c6224" translate="yes" xml:space="preserve">
          <source>The difference of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">요소 별 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 의 차이 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="07942ea7f660d79ad7e6e73de1169306977fb28a" translate="yes" xml:space="preserve">
          <source>The differences between consecutive elements of an array.</source>
          <target state="translated">배열의 연속 요소 간의 차이점</target>
        </trans-unit>
        <trans-unit id="f62761da3d9dc37e999ceb43677343bc26056903" translate="yes" xml:space="preserve">
          <source>The differences. Loosely, this is &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt;.</source>
          <target state="translated">차이점들. 느슨하게, 이것은 &lt;code&gt;ary.flat[1:] - ary.flat[:-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e2f3cc77955898f687e1a89336e253a34038e978" translate="yes" xml:space="preserve">
          <source>The different types of interpolation can be visualized graphically:</source>
          <target state="translated">다양한 유형의 보간을 그래픽으로 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0f5b79f9447070c03232c2c0b7664e2645b9b9cd" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-packing is done. &lt;code&gt;None&lt;/code&gt; implies packing the flattened array.</source>
          <target state="translated">비트 패킹이 수행되는 차원입니다. &lt;code&gt;None&lt;/code&gt; 은 평평한 배열의 포장을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="dfa565d5af13bd83cac275f338d5f2b3b4b7544c" translate="yes" xml:space="preserve">
          <source>The dimension over which bit-unpacking is done. &lt;code&gt;None&lt;/code&gt; implies unpacking the flattened array.</source>
          <target state="translated">비트 언 패킹이 수행되는 차원입니다. &lt;code&gt;None&lt;/code&gt; 은 평평한 배열의 포장 풀기를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="db3013243a57c5e7a96cffb61f2f631ca09ac6ac" translate="yes" xml:space="preserve">
          <source>The dimensionality of each input/output of an elementary function is defined by its core dimensions (zero core dimensions correspond to a scalar input/output). The core dimensions are mapped to the last dimensions of the input/output arrays.</source>
          <target state="translated">기본 함수의 각 입력 / 출력의 차원은 핵심 차원에 의해 정의됩니다 (제로 코어 차원은 스칼라 입력 / 출력에 해당). 코어 치수는 입력 / 출력 어레이의 마지막 치수에 매핑됩니다.</target>
        </trans-unit>
        <trans-unit id="bbd2ce0767215831bee7913f7b1f8113fac9632a" translate="yes" xml:space="preserve">
          <source>The dimensionality of the output is equal to the greatest of: * the dimensionality of all the inputs * the depth to which the input list is nested</source>
          <target state="translated">출력의 차원은 다음 중 가장 큰 것과 같습니다. * 모든 입력의 차원 * 입력 목록이 중첩되는 깊이</target>
        </trans-unit>
        <trans-unit id="169b189aee12891e66fa6116bc6ee28490426b80" translate="yes" xml:space="preserve">
          <source>The dimensions beyond the core dimensions are called &amp;ldquo;loop&amp;rdquo; dimensions. In the above example, this corresponds to &lt;code&gt;(3, 5)&lt;/code&gt;.</source>
          <target state="translated">코어 치수 이외의 치수를 &quot;루프&quot;치수라고합니다. 위의 예에서 이는 &lt;code&gt;(3, 5)&lt;/code&gt; 해당합니다 .</target>
        </trans-unit>
        <trans-unit id="f513b3b85fff0b6f84da786029bafd05ba0e618b" translate="yes" xml:space="preserve">
          <source>The dimensions of the iterator.</source>
          <target state="translated">이터레이터의 크기입니다.</target>
        </trans-unit>
        <trans-unit id="5ecf20054a40c0975aa34c7a074c143c2ad5eb76" translate="yes" xml:space="preserve">
          <source>The dimensions of the returned array, must be non-negative. If no argument is given a single Python float is returned.</source>
          <target state="translated">반환 된 배열의 크기는 음수가 아니어야합니다. 인수가 제공되지 않으면 단일 Python float가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="1962b62fe3553b6c10eaad6d82d38bd0027b1eca" translate="yes" xml:space="preserve">
          <source>The direction where to look for the next representable value of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 의 다음 표현 가능한 값을 찾을 방향 입니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="712dcab95da2336dfeef7d45bac02b258dccf977" translate="yes" xml:space="preserve">
          <source>The discount rate.</source>
          <target state="translated">할인율입니다.</target>
        </trans-unit>
        <trans-unit id="0706686baa5fd5b913d978e6a5e5bd325098b037" translate="yes" xml:space="preserve">
          <source>The discrete convolution operation is defined as</source>
          <target state="translated">이산 컨벌루션 연산은 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="0c3ebfde94166d29a8529279eac1b981ebfd74c7" translate="yes" xml:space="preserve">
          <source>The distance between a value and the nearest adjacent number</source>
          <target state="translated">값과 가장 가까운 인접 숫자 사이의 거리</target>
        </trans-unit>
        <trans-unit id="eb9069c190fd0543a41e23dc5a8c21be130414b2" translate="yes" xml:space="preserve">
          <source>The docstring consists of a number of sections separated by headings (except for the deprecation warning). Each heading should be underlined in hyphens, and the section ordering should be consistent with the description below.</source>
          <target state="translated">독 스트링은 제목으로 구분 된 여러 섹션으로 구성됩니다 (지원 중단 경고 제외). 각 제목은 하이픈으로 밑줄을 쳐야하며 섹션 순서는 아래 설명과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="12a1ae320e29367bfe14ad50414fe949007c38e7" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If &lt;code&gt;None&lt;/code&gt;, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">함수의 docstring입니다. 경우 &lt;code&gt;None&lt;/code&gt; , 문서화 문자열이 될 것입니다 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f20cb6df02e7c9d27955f240a3eb4c2a8d28a69" translate="yes" xml:space="preserve">
          <source>The docstring for the function. If None, the docstring will be the &lt;code&gt;pyfunc.__doc__&lt;/code&gt;.</source>
          <target state="translated">함수의 독 스트링입니다. None이면 &lt;code&gt;pyfunc.__doc__&lt;/code&gt; 은 pyfunc .__ doc__가 됩니다.</target>
        </trans-unit>
        <trans-unit id="72a23a7f9d3c84d9ccb7d9d4e76905cf07195965" translate="yes" xml:space="preserve">
          <source>The docstring is taken from the input function to &lt;a href=&quot;#numpy.vectorize&quot;&gt;&lt;code&gt;vectorize&lt;/code&gt;&lt;/a&gt; unless it is specified:</source>
          <target state="translated">문서화 문자열은 입력 함수에서 지정하지 않으면 &lt;a href=&quot;#numpy.vectorize&quot;&gt; &lt;code&gt;vectorize&lt;/code&gt; &lt;/a&gt; 하기 위해 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="023ac00b221ccc43e93743f0d35932950774168c" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a NumPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;numpy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from numpy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">doctest는 &lt;code&gt;import numpy as np&lt;/code&gt; 를 실행 한 새로운 Python 인스턴스에있는 것처럼 실행 됩니다 . NumPy 하위 패키지의 일부인 테스트는 해당 하위 패키지를 이미 가져 왔습니다. 예를 들어 &lt;code&gt;numpy/linalg/tests/&lt;/code&gt; 경우 네임 스페이스는 &lt;code&gt;from numpy import linalg&lt;/code&gt; 에서 이미 실행 된 것처럼 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="82bd10e4e262158659ec5e27575297c3e33fb51b" translate="yes" xml:space="preserve">
          <source>The doctests are run as if they are in a fresh Python instance which has executed &lt;code&gt;import numpy as np&lt;/code&gt;. Tests that are part of a SciPy subpackage will have that subpackage already imported. E.g. for a test in &lt;code&gt;scipy/linalg/tests/&lt;/code&gt;, the namespace will be created such that &lt;code&gt;from scipy import linalg&lt;/code&gt; has already executed.</source>
          <target state="translated">doctest는 마치 &lt;code&gt;import numpy as np&lt;/code&gt; 실행 한 새로운 Python 인스턴스에있는 것처럼 실행 됩니다 . SciPy 서브 패키지의 일부인 테스트는 해당 서브 패키지를 이미 가져 왔습니다. 예를 들어 &lt;code&gt;scipy/linalg/tests/&lt;/code&gt; 테스트의 경우 네임 스페이스는 &lt;code&gt;from scipy import linalg&lt;/code&gt; 에서 이미 실행 되도록 만들어 집니다.</target>
        </trans-unit>
        <trans-unit id="4e34de0083248d68455464ce3b6cb6cff4a615e4" translate="yes" xml:space="preserve">
          <source>The doctests can be run by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call; for example, to run all tests (including doctests) for numpy.lib:</source>
          <target state="translated">doctests는 &lt;code&gt;test()&lt;/code&gt; 호출에 &lt;code&gt;doctests&lt;/code&gt; 인수를 추가하여 실행할 수 있습니다 . 예를 들어, numpy.lib에 대한 모든 테스트 (doctest 포함)를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="914dd900bd888e0ac2a856c709956c6c77b685df" translate="yes" xml:space="preserve">
          <source>The doctests can be run by the user/developer by adding the &lt;code&gt;doctests&lt;/code&gt; argument to the &lt;code&gt;test()&lt;/code&gt; call. For example, to run all tests (including doctests) for &lt;code&gt;numpy.lib&lt;/code&gt;:</source>
          <target state="translated">doctest는 &lt;code&gt;doctests&lt;/code&gt; 인수를 &lt;code&gt;test()&lt;/code&gt; 호출 에 추가하여 사용자 / 개발자가 실행할 수 있습니다 . 예를 들어, &lt;code&gt;numpy.lib&lt;/code&gt; 에 대한 모든 테스트 (doctest 포함)를 실행하려면 다음을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="f8aa7b1eda9c3eb10663105fc5334308467be1f5" translate="yes" xml:space="preserve">
          <source>The documentation for NumPy distributed at &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; in html and pdf format is also built with &lt;code&gt;make dist&lt;/code&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt; for details on how to update &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; 에서 html 및 pdf 형식으로 배포 된 NumPy 문서 도 &lt;code&gt;make dist&lt;/code&gt; 로 빌드됩니다 . &lt;a href=&quot;https://numpy.org/doc&quot;&gt;https://numpy.org/doc&lt;/a&gt; 업데이트 방법에 대한 자세한 내용 은 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/doc/HOWTO_RELEASE.rst.txt&quot;&gt;HOWTO RELEASE&lt;/a&gt; 를 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="5b422de92d847bc36480d44f7ae27cfbb5060f6f" translate="yes" xml:space="preserve">
          <source>The documentation includes mathematical formulae with LaTeX formatting. A working LaTeX document production system (e.g. &lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt;) is required for the proper rendering of the LaTeX math in the documentation.</source>
          <target state="translated">설명서에는 LaTeX 형식의 수학 공식이 포함되어 있습니다. 문서 에서 LaTeX 수학을 올바르게 렌더링하려면 작동하는 LaTeX 문서 제작 시스템 (예 : &lt;a href=&quot;https://www.tug.org/texlive/&quot;&gt;texlive&lt;/a&gt; )이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="400ca1ed6dc999bcaec7408745f9b97e9991d699" translate="yes" xml:space="preserve">
          <source>The documentation is written in restructuredText, which is the format required by Sphinx, the tool most Python projects use to automatically build and link the documentation within the project. You can read the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt; for more information.</source>
          <target state="translated">문서는 대부분의 Python 프로젝트가 프로젝트 내에서 문서를 자동으로 빌드하고 연결하는 데 사용하는 도구 인 Sphinx에서 요구하는 형식 인 restructuredText로 작성되었습니다. 자세한 내용 은 &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;빠른 reStructuredText 가이드&lt;/a&gt; 또는 &lt;a href=&quot;http://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText 입문서&lt;/a&gt; 를 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b01857d163ce7be746891e6a1ddb4df8d280228b" translate="yes" xml:space="preserve">
          <source>The domain of the converted series. If the value is None, the default domain of &lt;code&gt;kind&lt;/code&gt; is used.</source>
          <target state="translated">변환 된 계열의 도메인 값이 None이면 기본 도메인 &lt;code&gt;kind&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3910d27792e65700eaf0cb459a12293f622c5605" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape (size, alpha.ndim).</source>
          <target state="translated">그려진 샘플 (모양, 크기, alpha.ndim)</target>
        </trans-unit>
        <trans-unit id="3a196841b4dbf99e3d83d366571811ca5768d106" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;code&gt;(size, k)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;(size, k)&lt;/code&gt; 모양의 그려진 샘플 .</target>
        </trans-unit>
        <trans-unit id="caba47af25cacb65ea654dc8b3910b7df6c6afc4" translate="yes" xml:space="preserve">
          <source>The drawn samples, of shape &lt;em&gt;size&lt;/em&gt;, if that was provided. If not, the shape is &lt;code&gt;(N,)&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 모양 &lt;em&gt;크기&lt;/em&gt; 의 그려진 샘플 . 그렇지 않은 경우 모양은 &lt;code&gt;(N,)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="40b0e929b6fe8b38b46b38ce838182fe7c7332dc" translate="yes" xml:space="preserve">
          <source>The drawn samples.</source>
          <target state="translated">그려진 샘플.</target>
        </trans-unit>
        <trans-unit id="7c49825e402bb2a6069cc023cee23e3ad1ab0d7c" translate="yes" xml:space="preserve">
          <source>The dtype object also has a dictionary-like attribute, &lt;code&gt;fields&lt;/code&gt;, whose keys are the field names (and &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt;, see below) and whose values are tuples containing the dtype and byte offset of each field.</source>
          <target state="translated">dtype 객체에는 또한 키가 필드 이름 (및 &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; , 아래 참조)이고 값이 각 필드의 dtype 및 바이트 오프셋을 포함하는 튜플 인 사전과 같은 속성 인 &lt;code&gt;fields&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6189579f1415b7585848cd7c90a8ab21f324db6" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt;&lt;code&gt;datetime64&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;timedelta64&lt;/code&gt;&lt;/a&gt; type.</source>
          <target state="translated">해야 DTYPE 개체, &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt; &lt;code&gt;datetime64&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;timedelta64&lt;/code&gt; &lt;/a&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="aa44e17b8461776ae7df4f43d6abddd8f6a24f76" translate="yes" xml:space="preserve">
          <source>The dtype object, which must be a &lt;code&gt;datetime64&lt;/code&gt; or &lt;code&gt;timedelta64&lt;/code&gt; type.</source>
          <target state="translated">해야 DTYPE 개체, &lt;code&gt;datetime64&lt;/code&gt; 또는 &lt;code&gt;timedelta64&lt;/code&gt; 유형입니다.</target>
        </trans-unit>
        <trans-unit id="8fb6faafe66ffccb238a2fd43e44c5a7f5fbd5ca" translate="yes" xml:space="preserve">
          <source>The dtype of the masked array matches the dtype of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">마스킹 된 배열의 dtype은 &lt;code&gt;arr&lt;/code&gt; 의 dtype과 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1cb33880062e286521366b55fc98dd4daef4b644" translate="yes" xml:space="preserve">
          <source>The dtype of the output unstructured array.</source>
          <target state="translated">출력 구조화되지 않은 배열의 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="a55d71e165e1e48cb124a8472e43c4880e17aca7" translate="yes" xml:space="preserve">
          <source>The dtype to convert</source>
          <target state="translated">변환 할 dtype</target>
        </trans-unit>
        <trans-unit id="5ecd0c1cb739e638a2efc7fc65026ccc752fcf9a" translate="yes" xml:space="preserve">
          <source>The dtype to convert.</source>
          <target state="translated">변환 할 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="0d0946ed17f6fb426bc55c84df183c8474945340" translate="yes" xml:space="preserve">
          <source>The dummy argument is not used in this context and can be safely ignored. The &lt;em&gt;args&lt;/em&gt; argument contains all of the arguments passed in to the function as a tuple. You can do anything you want at this point, but usually the easiest way to manage the input arguments is to call &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses_to_C_variables&amp;hellip;) or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; (tuple, &amp;ldquo;name&amp;rdquo;, min, max, &amp;hellip;). A good description of how to use the first function is contained in the Python C-API reference manual under section 5.5 (Parsing arguments and building values). You should pay particular attention to the &amp;ldquo;O&amp;amp;&amp;rdquo; format which uses converter functions to go between the Python object and the C object. All of the other format functions can be (mostly) thought of as special cases of this general rule. There are several converter functions defined in the NumPy C-API that may be of use. In particular, the &lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; function is very useful to support arbitrary data-type specification. This function transforms any valid data-type Python object into a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object. Remember to pass in the address of the C-variables that should be filled in.</source>
          <target state="translated">더미 인수는이 컨텍스트에서 사용되지 않으며 무시해도됩니다. &lt;em&gt;인수의&lt;/em&gt; 인수는 터플로 함수에 전달 된 모든 인수가 포함되어 있습니다. 이 시점에서 원하는 것은 무엇이든 할 수 있지만 일반적으로 입력 인수를 관리하는 가장 쉬운 방법은 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; (args, format_string, addresses_to_C_variables&amp;hellip;) 또는 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt; &lt;code&gt;PyArg_UnpackTuple&lt;/code&gt; 을 호출하는 것입니다.&lt;/a&gt;(튜플, &quot;이름&quot;, 최소, 최대,&amp;hellip;). 첫 번째 함수를 사용하는 방법에 대한 좋은 설명은 섹션 5.5 (인수 구문 분석 및 값 빌드)의 Python C-API 참조 매뉴얼에 포함되어 있습니다. Python 객체와 C 객체 사이를 이동하기 위해 변환기 함수를 사용하는 &quot;O &amp;amp;&quot;형식에 특히주의해야합니다. 다른 모든 형식 함수는 (대부분)이 일반 규칙의 특수한 경우로 생각할 수 있습니다. 사용할 수있는 NumPy C-API에 정의 된 몇 가지 변환기 기능이 있습니다. 특히 &lt;a href=&quot;../reference/c-api/array#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt; 함수는 임의의 데이터 유형 사양을 지원하는 데 매우 유용합니다. 이 함수는 유효한 데이터 유형 Python 객체를 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; 객체 로 변환 합니다. 입력해야하는 C- 변수의 주소를 전달하는 것을 잊지 마십시오.</target>
        </trans-unit>
        <trans-unit id="dcd01c48a9de1d18adee046a1ef49445b20e2304" translate="yes" xml:space="preserve">
          <source>The ease of implementing mathematical formulas that work on arrays is one of the things that make NumPy so widely used in the scientific Python community.</source>
          <target state="translated">배열에서 작동하는 수학 공식을 쉽게 구현할 수 있다는 점은 NumPy가 과학적 Python 커뮤니티에서 널리 사용되는 이유 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="0624587fa2f7d6454c0f9d5829dab19d01e4bd1b" translate="yes" xml:space="preserve">
          <source>The easiest way to understand the situation may be to think in terms of the result shape. There are two parts to the indexing operation, the subspace defined by the basic indexing (excluding integers) and the subspace from the advanced indexing part. Two cases of index combination need to be distinguished:</source>
          <target state="translated">상황을 이해하는 가장 쉬운 방법은 결과 형태로 생각하는 것입니다. 인덱싱 작업에는 기본 인덱싱에 의해 정의 된 부분 공간 (정수 제외)과 고급 인덱싱 부분의 부분 공간이라는 두 부분이 있습니다. 인덱스 조합의 두 가지 경우를 구별해야합니다.</target>
        </trans-unit>
        <trans-unit id="f92b730683a3cb47168faa379ee22ac3235eed0f" translate="yes" xml:space="preserve">
          <source>The easy way to do conversions between polynomial basis sets is to use the convert method of a class instance.</source>
          <target state="translated">다항식 기본 집합간에 변환을 수행하는 쉬운 방법은 클래스 인스턴스의 convert 메서드를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ad876c221bb9757cd689d05f17e08510f826f3e" translate="yes" xml:space="preserve">
          <source>The edges retuned by &lt;code&gt;histogram`&lt;/code&gt; and &lt;code&gt;histogramdd&lt;/code&gt; now match the data float type</source>
          <target state="translated">&lt;code&gt;histogram`&lt;/code&gt; 및 &lt;code&gt;histogramdd&lt;/code&gt; 에 의해 다시 조정 된 에지가 이제 데이터 부동 유형과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="2fc5d8b78173f52a2c49af3f59f052a25e59fb4f" translate="yes" xml:space="preserve">
          <source>The edges to pass into &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 으로 전달할 가장자리</target>
        </trans-unit>
        <trans-unit id="d2d8a6b76e19500caa5bf07c8a328b68c38bc616" translate="yes" xml:space="preserve">
          <source>The editing workflow</source>
          <target state="translated">편집 워크 플로우</target>
        </trans-unit>
        <trans-unit id="b6f1be0a37063a8a4026cc94c7cf86f62cf5bdd8" translate="yes" xml:space="preserve">
          <source>The effect of broadcasting.</source>
          <target state="translated">방송의 효과.</target>
        </trans-unit>
        <trans-unit id="a34abd23a6e4bdf2596a3b4673affad53721777d" translate="yes" xml:space="preserve">
          <source>The eigenvalues are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">고유 값은 LAPACK 루틴 &lt;code&gt;_syevd&lt;/code&gt; , &lt;code&gt;_heevd&lt;/code&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="7701e5ef9799c4995d19bac48ad9fa82db4dc5c5" translate="yes" xml:space="preserve">
          <source>The eigenvalues in ascending order, each repeated according to its multiplicity.</source>
          <target state="translated">고유 값은 오름차순으로 각각의 다중도에 따라 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="af42e28434cbe95fe6890df4d996c2c99e9b2481" translate="yes" xml:space="preserve">
          <source>The eigenvalues of real symmetric or complex Hermitian matrices are always real. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; The array &lt;code&gt;v&lt;/code&gt; of (column) eigenvectors is unitary and &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt;.</source>
          <target state="translated">실제 대칭 또는 복잡한 Hermitian 행렬의 고유 값은 항상 실제입니다. &lt;a href=&quot;#rc702e98a756a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; (열) 고유 벡터 의 배열 &lt;code&gt;v&lt;/code&gt; 는 단일이고 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 방정식 &lt;code&gt;dot(a, v[:, i]) = w[i] * v[:, i]&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="2ff4d23698273b360b1d6366e444e95ea540f28f" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. The eigenvalues are not necessarily ordered. The resulting array will be of complex type, unless the imaginary part is zero in which case it will be cast to a real type. When &lt;code&gt;a&lt;/code&gt; is real the resulting eigenvalues will be real (0 imaginary part) or occur in conjugate pairs</source>
          <target state="translated">고유 값은 각각 다중도에 따라 반복됩니다. 고유 값이 반드시 순서하지는 않습니다. 허수 부분이 0이 아닌 경우 결과 배열은 복소수 유형입니다.이 경우 실제 유형으로 캐스트됩니다. 경우 &lt;code&gt;a&lt;/code&gt; 진짜 얻어진 고유 실제 (0 허부)이거나 공액 쌍 발생할</target>
        </trans-unit>
        <trans-unit id="9cfc7ae7c9df4df4270a01f781a7985d0061b823" translate="yes" xml:space="preserve">
          <source>The eigenvalues, each repeated according to its multiplicity. They are not necessarily ordered, nor are they necessarily real for real matrices.</source>
          <target state="translated">고유 값은 각각 다중도에 따라 반복됩니다. 그것들은 반드시 순서대로 정렬 될 필요는 없으며 반드시 실제 행렬에 대해 실제적인 것도 아닙니다.</target>
        </trans-unit>
        <trans-unit id="fedbdf07c41c58b01420971d15b808683a8a1612" translate="yes" xml:space="preserve">
          <source>The eigenvalues/eigenvectors are computed using LAPACK routines &lt;code&gt;_syevd&lt;/code&gt;, &lt;code&gt;_heevd&lt;/code&gt;.</source>
          <target state="translated">고유 값 / 고유 벡터는 LAPACK 루틴 &lt;code&gt;_syevd&lt;/code&gt; , &lt;code&gt;_heevd&lt;/code&gt; 를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="672eac8f0267740479f9ff389b02d40f57b3ff35" translate="yes" xml:space="preserve">
          <source>The element inserted in &lt;code&gt;output&lt;/code&gt; when all conditions evaluate to False.</source>
          <target state="translated">모든 조건이 False로 평가 될 때 &lt;code&gt;output&lt;/code&gt; 삽입 된 요소 입니다.</target>
        </trans-unit>
        <trans-unit id="c154db2e01512028a28319b3317262699278c799" translate="yes" xml:space="preserve">
          <source>The element size of this data-type object.</source>
          <target state="translated">이 데이터 유형 객체의 요소 크기입니다.</target>
        </trans-unit>
        <trans-unit id="100849a009dc981ce005b4c12bbdd30342f43ac6" translate="yes" xml:space="preserve">
          <source>The element-wise remainder of the quotient &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">몫인 &lt;code&gt;floor_divide(x1, x2)&lt;/code&gt; 의 요소 별 나머지입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="55f57b3f397334c809b04b980612f0a5ab349a62" translate="yes" xml:space="preserve">
          <source>The elements are binary-valued (0 or 1).</source>
          <target state="translated">요소는 이진 값 (0 또는 1)입니다.</target>
        </trans-unit>
        <trans-unit id="4e3cc7c953fc2e3ea61645fad74045ef41161886" translate="yes" xml:space="preserve">
          <source>The elements in a NumPy array are all required to be of the same data type, and thus will be the same size in memory. The exception: one can have arrays of (Python, including NumPy) objects, thereby allowing for arrays of different sized elements.</source>
          <target state="translated">NumPy 배열의 요소는 모두 동일한 데이터 유형이어야하므로 메모리에서 동일한 크기가됩니다. 예외 : 하나는 (NumPy를 포함한 Python) 객체의 배열을 가질 수 있으므로 크기가 다른 요소의 배열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="18d658a71c2e23e5ce04fb215c6cdc657f3c41d2" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">의 요소 &lt;code&gt;a&lt;/code&gt; 이 인덱스 순서로 판독된다. 'C'는 마지막 축 색인이 가장 빠르게 변경되고 첫 번째 축 색인이 가장 느리게 변경되어 C와 같은 순서로 요소를 색인화하는 것을 의미합니다. 'F'는 첫 번째 색인이 가장 빠르게 변경되고 마지막 색인이 가장 느리게 변경되는 Fortran과 유사한 색인 순서로 요소를 색인화 함을 의미합니다. 'C'및 'F'옵션은 기본 배열의 메모리 레이아웃을 고려하지 않으며 축 인덱싱 순서 만 참조합니다. 'A'는 메모리에서 &lt;code&gt;m&lt;/code&gt; 이 Fortran &lt;em&gt;연속 인&lt;/em&gt; 경우 Fortran과 유사한 색인 순서로 요소를 읽고 그렇지 않으면 C와 같은 순서 를 읽는 것을 의미합니다 . 'K'는 보폭이 음수 일 때 데이터를 되 돌리는 것을 제외하고 메모리에서 발생하는 순서대로 요소를 읽는 것을 의미합니다. 기본적으로 'C'인덱스 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="27ccf6e9acce055e532ad81d9bdd8638f9a4a262" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;a&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in row-major, C-style order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in column-major, Fortran-style order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;a&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">의 요소 &lt;code&gt;a&lt;/code&gt; 이 인덱스 순서로 판독된다. 'C'는 마지막 축 인덱스가 가장 빠르게 변경되고 첫 번째 축 인덱스가 가장 느리게 변경되는 행 주요 C 스타일 순서로 요소를 인덱싱하는 것을 의미합니다. 'F'는 첫 번째 인덱스가 가장 빠르게 변경되고 마지막 인덱스가 가장 느리게 변경되는 경우, 주요한 포트란 스타일 순서로 요소를 인덱스하는 것을 의미합니다. 'C'및 'F'옵션은 기본 배열의 메모리 레이아웃을 고려하지 않으며 축 인덱싱 순서 만 참조합니다. 만약 'A'수단 번호순 포트란 형상의 요소를 읽어 &lt;code&gt;a&lt;/code&gt; 포트란 인 &lt;em&gt;연속이&lt;/em&gt;그렇지 않으면 C와 같은 순서로 메모리에 저장됩니다. 'K'는 보폭이 음수 일 때 데이터를 되 돌리는 것을 제외하고 메모리에서 발생하는 순서대로 요소를 읽는 것을 의미합니다. 기본적으로 'C'인덱스 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8bfe90d8bb9b3a44603b03bac0e42210874e7808" translate="yes" xml:space="preserve">
          <source>The elements of &lt;code&gt;m&lt;/code&gt; are read using this index order. &amp;lsquo;C&amp;rsquo; means to index the elements in C-like order, with the last axis index changing fastest, back to the first axis index changing slowest. &amp;lsquo;F&amp;rsquo; means to index the elements in Fortran-like index order, with the first index changing fastest, and the last index changing slowest. Note that the &amp;lsquo;C&amp;rsquo; and &amp;lsquo;F&amp;rsquo; options take no account of the memory layout of the underlying array, and only refer to the order of axis indexing. &amp;lsquo;A&amp;rsquo; means to read the elements in Fortran-like index order if &lt;code&gt;m&lt;/code&gt; is Fortran &lt;em&gt;contiguous&lt;/em&gt; in memory, C-like order otherwise. &amp;lsquo;K&amp;rsquo; means to read the elements in the order they occur in memory, except for reversing the data when strides are negative. By default, &amp;lsquo;C&amp;rsquo; index order is used.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 의 요소는 이 색인 순서를 사용하여 읽습니다. 'C'는 마지막 축 색인이 가장 빠르게 변경되고 첫 번째 축 색인이 가장 느리게 변경되어 C와 같은 순서로 요소를 색인화하는 것을 의미합니다. 'F'는 첫 번째 색인이 가장 빠르게 변경되고 마지막 색인이 가장 느리게 변경되는 Fortran과 유사한 색인 순서로 요소를 색인화 함을 의미합니다. 'C'및 'F'옵션은 기본 배열의 메모리 레이아웃을 고려하지 않으며 축 인덱싱 순서 만 참조합니다. 'A'는 메모리에서 &lt;code&gt;m&lt;/code&gt; 이 Fortran &lt;em&gt;연속 인&lt;/em&gt; 경우 Fortran과 유사한 색인 순서로 요소를 읽고 그렇지 않으면 C와 같은 순서 를 읽는 것을 의미합니다 . 'K'는 보폭이 음수 일 때 데이터를 되 돌리는 것을 제외하고 메모리에서 발생하는 순서대로 요소를 읽는 것을 의미합니다. 기본적으로 'C'인덱스 순서가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d7a05ea4e76ed025da3efb7e37c3722ae9fddb" translate="yes" xml:space="preserve">
          <source>The elements of both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;a.T&lt;/code&gt; get traversed in the same order, namely the order they are stored in memory, whereas the elements of &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; get visited in a different order because they have been put into a different memory layout.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;a.T&lt;/code&gt; 의 요소는 모두 같은 순서, 즉 메모리에 저장된 순서로 순회하지만 &lt;code&gt;a.T.copy(order=&amp;rsquo;C&amp;rsquo;)&lt;/code&gt; 의 요소 는 다른 메모리에 저장되었으므로 다른 순서로 방문됩니다. 나열한 것.</target>
        </trans-unit>
        <trans-unit id="7c09282fb5ba8925fe26507ed54970dbeacf3bc3" translate="yes" xml:space="preserve">
          <source>The elements of the shape tuple give the lengths of the corresponding array dimensions.</source>
          <target state="translated">모양 튜플의 요소는 해당 배열 차원의 길이를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d08dc6baf6d1de4ff7af87aa1f35d18925c1f47b" translate="yes" xml:space="preserve">
          <source>The elements of this structure are:</source>
          <target state="translated">이 구조의 요소는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c3ccba03f1b5d3bd5cacb97014f1795b1e1620ff" translate="yes" xml:space="preserve">
          <source>The ellipsis syntax maybe used to indicate selecting in full any remaining unspecified dimensions. For example:</source>
          <target state="translated">생략 부호 구문은 지정되지 않은 나머지 차원을 모두 선택하는 것을 나타내는 데 사용될 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="d0777cee700edf703f03cd8f123c44ac46b607f9" translate="yes" xml:space="preserve">
          <source>The end value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is set to False. In that case, the sequence consists of all but the last of &lt;code&gt;num + 1&lt;/code&gt; evenly spaced samples, so that &lt;code&gt;stop&lt;/code&gt; is excluded. Note that the step size changes when &lt;code&gt;endpoint&lt;/code&gt; is False.</source>
          <target state="translated">끝 &lt;code&gt;endpoint&lt;/code&gt; False로 설정되어 있지 않으면 시퀀스의 끝 값입니다 . 이 경우, 시퀀스는 마지막 &lt;code&gt;num + 1&lt;/code&gt; 균등 간격 샘플 을 제외한 나머지로 구성 되므로 &lt;code&gt;stop&lt;/code&gt; 가 제외됩니다. &lt;code&gt;endpoint&lt;/code&gt; 가 False 이면 단계 크기가 변경됩니다 .</target>
        </trans-unit>
        <trans-unit id="61c8a67ac747d5eb7d80852565d6317e805901a1" translate="yes" xml:space="preserve">
          <source>The endpoint of the interval can optionally be excluded.</source>
          <target state="translated">간격의 끝점은 선택적으로 제외 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c70e4957abd94f2cb0f87772d68554c90cbe5b2" translate="yes" xml:space="preserve">
          <source>The entropy for creating a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 를 작성하기위한 엔트로피 .</target>
        </trans-unit>
        <trans-unit id="0807164c2e58b526f47d2a17d970242e2786a8ed" translate="yes" xml:space="preserve">
          <source>The enumeration value for ASCII strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">선택 가능한 크기의 ASCII 문자열에 대한 열거 값입니다. 주어진 배열 내에서 문자열의 최대 크기는 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4486c486e9b2ccc0519632048cae0af33e6f2bea" translate="yes" xml:space="preserve">
          <source>The enumeration value for UCS4 strings of a selectable size. The strings have a fixed maximum size within a given array.</source>
          <target state="translated">선택 가능한 크기의 UCS4 문자열에 대한 열거 값입니다. 주어진 배열 내에서 문자열의 최대 크기는 고정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ceb80d4c945347bb465d428088d951fae89cf7e9" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 128-bit/16-byte complex type made up of two NPY_DOUBLE values.</source>
          <target state="translated">128 비트 / 16 바이트 복합 유형의 열거 값은 두 개의 NPY_DOUBLE 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="022dd3242a4f7ab9f354ab53434df9783dde262d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte IEEE 754-2008 compatible floating point type.</source>
          <target state="translated">16 비트 / 2 바이트 IEEE 754-2008 호환 부동 소수점 유형의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="54200391c747968ffe444d868d0f00fe22c905a7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte signed integer.</source>
          <target state="translated">16 비트 / 2 바이트 부호있는 정수의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="24e698054b91536d27ff27c354d21704b0ff5fa7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 16-bit/2-byte unsigned integer.</source>
          <target state="translated">부호없는 16 비트 / 2 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="48c93b25a09888099a2fa0e8cc423bbdd97aec51" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">32 비트 / 4 바이트 IEEE 754 호환 부동 소수점 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="0767688f1013b974d66b67bec323cce162186c28" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte signed integer.</source>
          <target state="translated">32 비트 / 4 바이트 부호있는 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="61e002f4aaa6d35ff73356572d5e52edd07749bc" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 32-bit/4-byte unsigned integer.</source>
          <target state="translated">부호없는 32 비트 / 4 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="13bb2de2cc37c2d6613c3c408dc1f6c1a04bcaf7" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte IEEE 754 compatible floating point type.</source>
          <target state="translated">64 비트 / 8 바이트 IEEE 754 호환 부동 소수점 유형의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="712e85738302795b01166defaa51ce15d788398b" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte complex type made up of two NPY_FLOAT values.</source>
          <target state="translated">64 비트 / 8 바이트 복합 유형의 열거 값은 두 개의 NPY_FLOAT 값으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="6fcce91d25d23bb25fdb72e7335d026c8e38fbfa" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte signed integer.</source>
          <target state="translated">64 비트 / 8 바이트 부호있는 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="d2fd87ac5f2fe419cf576e3d1240b873a7fd353f" translate="yes" xml:space="preserve">
          <source>The enumeration value for a 64-bit/8-byte unsigned integer.</source>
          <target state="translated">부호없는 64 비트 / 8 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="7aee8554ea2f116b0ced362cc168497aed3b5e7d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds dates or datetimes with a precision based on selectable date or time units.</source>
          <target state="translated">선택 가능한 날짜 또는 시간 단위를 기준으로 날짜 또는 날짜 시간을 정밀도로 보유하는 데이터 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="81373e1b16d0b1374953b29f2c2ce84e5c1e7ca6" translate="yes" xml:space="preserve">
          <source>The enumeration value for a data type which holds lengths of times in integers of selectable date or time units.</source>
          <target state="translated">선택 가능한 날짜 또는 시간 단위의 정수로 시간 길이를 보유하는 데이터 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="025565ff9d1efa7089189ec4ae9c78d4afba6baf" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific complex floating point type which is made up of two NPY_LONGDOUBLE values.</source>
          <target state="translated">두 개의 NPY_LONGDOUBLE 값으로 구성된 플랫폼 별 복합 부동 소수점 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="02ee59a76dc8246cf577894e400f4aef4b3c2cdb" translate="yes" xml:space="preserve">
          <source>The enumeration value for a platform-specific floating point type which is at least as large as NPY_DOUBLE, but larger on many platforms.</source>
          <target state="translated">플랫폼 특정 부동 소수점 유형의 열거 값은 NPY_DOUBLE 이상이지만 많은 플랫폼에서 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="12bd9d6078665b062a610e653e29b9b8b5cd0f4d" translate="yes" xml:space="preserve">
          <source>The enumeration value for a signed integer type which is the same size as a (void *) pointer. This is the type used by all arrays of indices.</source>
          <target state="translated">(void *) 포인터와 크기가 같은 부호있는 정수 유형의 열거 값입니다. 모든 인덱스 배열에 사용되는 유형입니다.</target>
        </trans-unit>
        <trans-unit id="1915b2aac968e6b707b08a802a86e659f6b7b54c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte signed integer.</source>
          <target state="translated">8 비트 / 1 바이트 부호있는 정수의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="e2cde6e55c74a7eec76c04ac7971b58aabed014c" translate="yes" xml:space="preserve">
          <source>The enumeration value for an 8-bit/1-byte unsigned integer.</source>
          <target state="translated">부호없는 8 비트 / 1 바이트 정수의 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="3bc60c39b304a6beb211c263d892c90730d59bf2" translate="yes" xml:space="preserve">
          <source>The enumeration value for an unsigned integer type which is the same size as a (void *) pointer.</source>
          <target state="translated">(void *) 포인터와 크기가 같은 부호없는 정수 유형의 열거 값입니다.</target>
        </trans-unit>
        <trans-unit id="00cb2e716adb7d63188da00709d01e2a11b34089" translate="yes" xml:space="preserve">
          <source>The enumeration value for references to arbitrary Python objects.</source>
          <target state="translated">임의의 Python 객체에 대한 참조를위한 열거 형 값입니다.</target>
        </trans-unit>
        <trans-unit id="dbec8c6917cdb1fb9cc672eba6fd415b762d7774" translate="yes" xml:space="preserve">
          <source>The enumeration value for the boolean type, stored as one byte. It may only be set to the values 0 and 1.</source>
          <target state="translated">부울 유형의 열거 값으로 1 바이트로 저장됩니다. 값은 0과 1로만 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f6d7694b75b473ad222039c05e89641ad1c019cb" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마스크에 사용 된 유형의 열거 값입니다 (예 : &lt;a href=&quot;c-api.iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; 반복자 플래그 사용). 이것은 &lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="470c7c6a0fdea0ae871ac319202aa3679b0d2b38" translate="yes" xml:space="preserve">
          <source>The enumeration value of the type used for masks, such as with the &lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; iterator flag. This is equivalent to &lt;a href=&quot;#c.NPY_UINT8&quot;&gt;&lt;code&gt;NPY_UINT8&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;iterator#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; 반복기 플래그 와 같이 마스크에 사용되는 유형의 열거 형 값입니다 . 이것은 &lt;a href=&quot;#c.NPY_UINT8&quot;&gt; &lt;code&gt;NPY_UINT8&lt;/code&gt; &lt;/a&gt; 과 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="60104b59eca7223d2be466212e148860409e987c" translate="yes" xml:space="preserve">
          <source>The equivalent for floating point data types.</source>
          <target state="translated">부동 소수점 데이터 유형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="4e36288c483218b6153f62263e1c19e0918537e1" translate="yes" xml:space="preserve">
          <source>The equivalent for integer data types.</source>
          <target state="translated">정수 데이터 유형에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="f007c7cbd53c8448e809d2bc2019ae342707c904" translate="yes" xml:space="preserve">
          <source>The error also has additional information to help you troubleshoot:</source>
          <target state="translated">오류에는 문제 해결에 도움이되는 추가 정보도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c428e56ed9d259c349566498573b0b72cf82c45" translate="yes" xml:space="preserve">
          <source>The error mask is a single integer that holds the treatment information on all four floating point errors. The information for each error type is contained in three bits of the integer. If we print it in base 8, we can see what treatment is set for &amp;ldquo;invalid&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, and &amp;ldquo;divide&amp;rdquo; (in that order). The printed string can be interpreted with</source>
          <target state="translated">오류 마스크는 4 개의 부동 소수점 오류에 대한 처리 정보를 보유하는 단일 정수입니다. 각 오류 유형에 대한 정보는 정수의 3 비트에 포함됩니다. 8 진법으로 인쇄하면 &quot;무효&quot;, &quot;언더&quot;, &quot;오버&quot;및 &quot;분할&quot;이 어떤 순서로 설정되어 있는지 확인할 수 있습니다. 인쇄 된 문자열은</target>
        </trans-unit>
        <trans-unit id="6236f64a81230ccb9458bf1fe006ba3279baed6f" translate="yes" xml:space="preserve">
          <source>The error message to be printed in case of failure.</source>
          <target state="translated">실패시 인쇄 할 오류 메시지입니다.</target>
        </trans-unit>
        <trans-unit id="46e36d39518380daadad6b1e62b8973365b854c8" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.geterrobj&quot;&gt;&lt;code&gt;geterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that get and set error handling behavior (&lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt;&lt;code&gt;geterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">오류 개체에는 NumPy의 오류 처리 동작을 정의하는 모든 정보가 포함됩니다. &lt;a href=&quot;#numpy.geterrobj&quot;&gt; &lt;code&gt;geterrobj&lt;/code&gt; &lt;/a&gt; 는 오류 처리 동작을 가져오고 설정하는 다른 함수 ( &lt;a href=&quot;numpy.geterr#numpy.geterr&quot;&gt; &lt;code&gt;geterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.geterrcall#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; ) 에서 내부적으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="d7bceac49145568dab2a83ccab3ab1eea9b12faf" translate="yes" xml:space="preserve">
          <source>The error object contains all information that defines the error handling behavior in NumPy. &lt;a href=&quot;#numpy.seterrobj&quot;&gt;&lt;code&gt;seterrobj&lt;/code&gt;&lt;/a&gt; is used internally by the other functions that set error handling behavior (&lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">오류 개체에는 NumPy의 오류 처리 동작을 정의하는 모든 정보가 포함됩니다. &lt;a href=&quot;#numpy.seterrobj&quot;&gt; &lt;code&gt;seterrobj&lt;/code&gt; &lt;/a&gt; 는 오류 처리 동작을 설정하는 다른 함수 ( &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; ) 에서 내부적으로 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="717ffb083d9a010e39e00d26ae4cbb3686fdec82" translate="yes" xml:space="preserve">
          <source>The error object, a list containing three elements: [internal numpy buffer size, error mask, error callback function].</source>
          <target state="translated">오류 개체, [내부 numpy 버퍼 크기, 오류 마스크, 오류 콜백 함수]의 세 가지 요소가 포함 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="9f5b3632192f41c961bfe841ce3532fd1faa0967" translate="yes" xml:space="preserve">
          <source>The evaluation uses Clenshaw recursion, aka synthetic division.</source>
          <target state="translated">이 평가는 일명 합성 부문 인 Clenshaw 재귀를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9a7486fe20eefd44f8d5d46a29c17743d8baf71d" translate="yes" xml:space="preserve">
          <source>The evaluation uses Horner&amp;rsquo;s method.</source>
          <target state="translated">평가에는 Horner의 방법이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="db5640fe4648623a565ed032ffc116fcc6e293bd" translate="yes" xml:space="preserve">
          <source>The exact definition of a slow test is obviously both subjective and hardware-dependent, but in general any individual test that requires more than a second or two should be labeled as slow (the whole suite consists of thousands of tests, so even a second is significant).</source>
          <target state="translated">느린 테스트의 정확한 정의는 주관적 및 하드웨어에 따라 다르지만 일반적으로 1 초 또는 2 초 이상이 필요한 개별 테스트는 느리게 레이블이 지정되어야합니다 (전체 제품군은 수천 개의 테스트로 구성되므로 1 초도 중요한).</target>
        </trans-unit>
        <trans-unit id="0fe09946a84bc00c7ff87cc3c4856ae88e30a696" translate="yes" xml:space="preserve">
          <source>The example also demonstrates Cython&amp;rsquo;s &amp;ldquo;typed memoryviews&amp;rdquo;, which are like NumPy arrays at the C level, in the sense that they are shaped and strided arrays that know their own extent (unlike a C array addressed through a bare pointer). The syntax &lt;code&gt;double complex[:]&lt;/code&gt; denotes a one-dimensional array (vector) of doubles, with arbitrary strides. A contiguous array of ints would be &lt;code&gt;int[::1]&lt;/code&gt;, while a matrix of floats would be &lt;code&gt;float[:, :]&lt;/code&gt;.</source>
          <target state="translated">이 예제는 또한 C 레벨에서 NumPy 배열과 같은 Cython의 &quot;타입 화 된 메모리 뷰&quot;를 보여줍니다. 이는 자체 범위를 알고있는 형태 및 스트라이드 배열이라는 점에서 (베어 포인터를 통해 주소가 지정된 C 배열과는 달리) 의미합니다. &lt;code&gt;double complex[:]&lt;/code&gt; 구문 은 임의의 스트라이드가있는 double의 1 차원 배열 (벡터)을 나타냅니다. 연속 된 int 배열은 &lt;code&gt;int[::1]&lt;/code&gt; 이고 &lt;code&gt;float[:, :]&lt;/code&gt; 행렬은 float [:, :] 입니다.</target>
        </trans-unit>
        <trans-unit id="d3927b62f1cd7d72e0062722877a649b50aac359" translate="yes" xml:space="preserve">
          <source>The example code may be split across multiple lines, with each line after the first starting with &amp;lsquo;&amp;hellip; &amp;lsquo;:</source>
          <target state="translated">예제 코드는 '&amp;hellip;'로 시작하는 첫 번째 줄 뒤에 각 줄을 사용하여 여러 줄로 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8115e6a09b482f0c6358ae004c18cbcff8dc56e9" translate="yes" xml:space="preserve">
          <source>The example header was dynamically generated by gcc on an X86 machine. The compiler supports &lt;code&gt;--cpu-baseline=&quot;sse sse2 sse3&quot;&lt;/code&gt; and &lt;code&gt;--cpu-dispatch=&quot;ssse3 sse41&quot;&lt;/code&gt;, and the result is below.</source>
          <target state="translated">예제 헤더는 X86 시스템에서 gcc에 의해 동적으로 생성되었습니다. 컴파일러는 &lt;code&gt;--cpu-baseline=&quot;sse sse2 sse3&quot;&lt;/code&gt; 및 &lt;code&gt;--cpu-dispatch=&quot;ssse3 sse41&quot;&lt;/code&gt; 을 지원하며 결과는 아래와 같습니다.</target>
        </trans-unit>
        <trans-unit id="3c6b68db229268c95185c669cea481b3a1f2e9b2" translate="yes" xml:space="preserve">
          <source>The examples may assume that &lt;code&gt;import numpy as np&lt;/code&gt; is executed before the example code in &lt;em&gt;numpy&lt;/em&gt;. Additional examples may make use of &lt;em&gt;matplotlib&lt;/em&gt; for plotting, but should import it explicitly, e.g., &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt;. All other imports, including the demonstrated function, must be explicit.</source>
          <target state="translated">예제는 가정 할 수있다 &lt;code&gt;import numpy as np&lt;/code&gt; 의 예제 코드 전에 실행됩니다 &lt;em&gt;NumPy와&lt;/em&gt; . 추가 예제는 플로팅을 위해 &lt;em&gt;matplotlib&lt;/em&gt; 를 사용할 수 있지만 명시 적으로 가져와야합니다 (예 : &lt;code&gt;import matplotlib.pyplot as plt&lt;/code&gt; ) . 시연 된 기능을 포함하여 다른 모든 가져 오기는 명시 적이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4a28216e8d502daba2aa9f77ed97bda4ac746a41" translate="yes" xml:space="preserve">
          <source>The exceptions to the above rules are given below:</source>
          <target state="translated">위의 규칙에 대한 예외는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ea2c7bd23b14b815638891431083c6a5af9b6f5a" translate="yes" xml:space="preserve">
          <source>The execution will now stop at the corresponding C function and you can step through it as usual. A number of useful Python-specific commands are available. For example to see where in the Python code you are, use &lt;code&gt;py-list&lt;/code&gt;. For more details, see &lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb&lt;/a&gt;. Here are some commonly used commands:</source>
          <target state="translated">이제 해당 C 함수에서 실행이 중지되며 평소와 같이 단계별로 실행할 수 있습니다. 여러 유용한 Python 관련 명령을 사용할 수 있습니다. 예를 들어 Python 코드에서 현재 위치를 확인하려면 &lt;code&gt;py-list&lt;/code&gt; 를 사용 하십시오 . 자세한 내용은 &lt;a href=&quot;https://wiki.python.org/moin/DebuggingWithGdb&quot;&gt;DebuggingWithGdb를&lt;/a&gt; 참조하십시오 . 다음은 일반적으로 사용되는 몇 가지 명령입니다.</target>
        </trans-unit>
        <trans-unit id="8953035a1ae2630eb8257139de6a8432deef2d8b" translate="yes" xml:space="preserve">
          <source>The expected object.</source>
          <target state="translated">예상되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="ec4e2a0cf38710bdb603b5d339066519f8b6c301" translate="yes" xml:space="preserve">
          <source>The expected string.</source>
          <target state="translated">예상되는 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="59f101f805e4afd5d4f5aac41091912e82f52cce" translate="yes" xml:space="preserve">
          <source>The exponent can be any integer or long integer, positive, negative, or zero.</source>
          <target state="translated">지수는 임의의 정수 또는 긴 정수, 양수, 음수 또는 0 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48bfe58fce3c9524a47514144118fc15384f8ce9" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;eps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;eps&lt;/code&gt; 를 산출하는 지수입니다 .</target>
        </trans-unit>
        <trans-unit id="8728d1625b1f4800f5da44ea73eddec8a90b29f7" translate="yes" xml:space="preserve">
          <source>The exponent that yields &lt;code&gt;epsneg&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;epsneg&lt;/code&gt; 를 생성하는 지수입니다 .</target>
        </trans-unit>
        <trans-unit id="3d2aac84d1e998e3af66433136551e2122fcd6db" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하 분포의 연속 유사체입니다. 여기에는 많은 비바람에 대해 측정 된 빗방울의 크기 &lt;a href=&quot;#r0dbb9b01ef9c-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 위키 백과에 대한 페이지 요청 사이의 시간 &lt;a href=&quot;#r0dbb9b01ef9c-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; 과 같은 많은 일반적인 상황이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="379909a59d38e5f49bfe83c94188ec2a18000b03" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하학적 분포의 연속적인 유사체입니다. 많은 폭풍우에서 측정 된 빗방울의 크기 &lt;a href=&quot;#r3cbd6af2d0d3-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 Wikipedia &lt;a href=&quot;#r3cbd6af2d0d3-2&quot; id=&quot;id3&quot;&gt;[2]에&lt;/a&gt; 대한 페이지 요청 사이의 시간 과 같은 많은 일반적인 상황을 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="ae0234d51209697de2e3092417cea04cdd633ab5" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하 분포의 연속 유사체입니다. 여기에는 많은 비바람에 대해 측정 된 빗방울의 크기 &lt;a href=&quot;#rcf497e7bc958-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 위키 백과에 대한 페이지 요청 사이의 시간 &lt;a href=&quot;#rcf497e7bc958-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt; 과 같은 많은 일반적인 상황이 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d68d926a5db1e2f83fa605bc0a4678131d567b9" translate="yes" xml:space="preserve">
          <source>The exponential distribution is a continuous analogue of the geometric distribution. It describes many common situations, such as the size of raindrops measured over many rainstorms &lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt;, or the time between page requests to Wikipedia &lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">지수 분포는 기하학적 분포의 연속적인 유사체입니다. 많은 폭풍우에서 측정 된 빗방울의 크기 &lt;a href=&quot;#rcfd3e98ffb09-1&quot; id=&quot;id2&quot;&gt;[1]&lt;/a&gt; 또는 Wikipedia &lt;a href=&quot;#rcfd3e98ffb09-2&quot; id=&quot;id3&quot;&gt;[2]에&lt;/a&gt; 대한 페이지 요청 사이의 시간 과 같은 많은 일반적인 상황을 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="33ed180d63f4fd6bda2a99808d388e4ba0b2acb0" translate="yes" xml:space="preserve">
          <source>The exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">지수. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="4a0678b00019c9d465c7278be4782e4ae402fa1c" translate="yes" xml:space="preserve">
          <source>The expression within brackets in &lt;code&gt;b[i]&lt;/code&gt; is treated as an &lt;code&gt;i&lt;/code&gt; followed by as many instances of &lt;code&gt;:&lt;/code&gt; as needed to represent the remaining axes. NumPy also allows you to write this using dots as &lt;code&gt;b[i,...]&lt;/code&gt;.</source>
          <target state="translated">대괄호 내의 식 &lt;code&gt;b[i]&lt;/code&gt; 로 취급되는 &lt;code&gt;i&lt;/code&gt; 의 인스턴스로 하였다 &lt;code&gt;:&lt;/code&gt; 나머지 축을 나타내는 데 필요한. NumPy를 사용하면 점을 사용하여 &lt;code&gt;b[i,...]&lt;/code&gt; 로 작성할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="330beb4f458d2c8c447ab8cdae27158e06bf7cb9" translate="yes" xml:space="preserve">
          <source>The extracted diagonal or constructed diagonal array.</source>
          <target state="translated">추출 된 대각선 또는 구성된 대각선 배열.</target>
        </trans-unit>
        <trans-unit id="53a8a2b8a609081b147379c06e4ca152c3e8819c" translate="yes" xml:space="preserve">
          <source>The f2py method of linking compiled code is currently the most sophisticated and integrated approach. It allows clean separation of Python with compiled code while still allowing for separate distribution of the extension module. The only draw-back is that it requires the existence of a Fortran compiler in order for a user to install the code. However, with the existence of the free-compilers g77, gfortran, and g95, as well as high-quality commercial compilers, this restriction is not particularly onerous. In my opinion, Fortran is still the easiest way to write fast and clear code for scientific computing. It handles complex numbers, and multi-dimensional indexing in the most straightforward way. Be aware, however, that some Fortran compilers will not be able to optimize code as well as good hand- written C-code.</source>
          <target state="translated">컴파일 된 코드를 연결하는 f2py 방법은 현재 가장 정교하고 통합 된 접근 방식입니다. 확장 모듈의 별도 배포를 허용하면서 컴파일 된 코드로 Python을 깔끔하게 분리 할 수 ​​있습니다. 유일한 단점은 사용자가 코드를 설치하려면 Fortran 컴파일러가 있어야한다는 것입니다. 그러나 무료 컴파일러 g77, gfortran 및 g95와 고품질 상용 컴파일러가 있으므로 이러한 제한은 특별히 부담스럽지 않습니다. 제 생각에 Fortran은 과학 컴퓨팅을위한 빠르고 명확한 코드를 작성하는 가장 쉬운 방법입니다. 가장 간단한 방법으로 복소수 및 다차원 인덱싱을 처리합니다. 그러나 일부 Fortran 컴파일러는 수작업으로 작성된 좋은 C 코드뿐만 아니라 코드를 최적화 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="555daf4232eb1ce31031f68a76fe276dbf717736" translate="yes" xml:space="preserve">
          <source>The f2py program is written in Python and can be run from inside your code to compile Fortran code at runtime, as follows:</source>
          <target state="translated">f2py 프로그램은 Python으로 작성되었으며 다음과 같이 코드 내부에서 실행되어 런타임에 Fortran 코드를 컴파일 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="06e74a78df99ca864f56978dd8124a3fb8da4ff4" translate="yes" xml:space="preserve">
          <source>The field names may be modified by assigning to the &lt;code&gt;names&lt;/code&gt; attribute using a sequence of strings of the same length.</source>
          <target state="translated">필드 이름은 동일한 길이의 문자열 시퀀스를 사용하여 &lt;code&gt;names&lt;/code&gt; 속성 에 할당하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c76b262eba97deb65c7a5b3c9fb6314561e8e763" translate="yes" xml:space="preserve">
          <source>The field names, either specified as a comma-separated string in the form &lt;code&gt;'col1, col2, col3'&lt;/code&gt;, or as a list or tuple of strings in the form &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt;. An empty list can be used, in that case default field names (&amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, &amp;hellip;) are used.</source>
          <target state="translated">필드 이름은 &lt;code&gt;'col1, col2, col3'&lt;/code&gt; 형식으로 쉼표로 구분 된 문자열 또는 &lt;code&gt;['col1', 'col2', 'col3']&lt;/code&gt; 형식으로 문자열 목록 또는 튜플로 지정됩니다 . 빈 목록을 사용할 수 있으며,이 경우 기본 필드 이름 ( 'f0', 'f1',&amp;hellip;)이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="abdb8363ba033add56efe121cf142ecd7ff5e4f2" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="translated">&lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; 파일 은 최종 변경 사항 및 기여자 목록을 반영하도록 업데이트되어야합니다. 이 텍스트는 다음에 의해 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e585d8ab818b06a0b3f2cb8c9a47272f794e8c3d" translate="yes" xml:space="preserve">
          <source>The file &lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; should be updated to reflect the final list of changes and contributors. This text can be generated by:</source>
          <target state="translated">&lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; 파일 은 최종 변경 사항 및 기여자 목록을 반영하도록 업데이트되어야합니다. 이 텍스트는 다음에 의해 생성 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0a3f62236ba0b0b8ce93c2fc463e81343db95a91" translate="yes" xml:space="preserve">
          <source>The file contains an object array, but allow_pickle=False given.</source>
          <target state="translated">파일에 객체 배열이 포함되어 있지만 allow_pickle = False가 지정되었습니다.</target>
        </trans-unit>
        <trans-unit id="cd858c6c51a98e96ec8ac35aea8fe45863b797ca" translate="yes" xml:space="preserve">
          <source>The file is opened in this mode:</source>
          <target state="translated">파일이이 모드에서 열립니다 :</target>
        </trans-unit>
        <trans-unit id="5b33f093bafabe18517ca8ac91b17b43d100f40c" translate="yes" xml:space="preserve">
          <source>The file name or file object to be used as the array data buffer.</source>
          <target state="translated">배열 데이터 버퍼로 사용될 파일 이름 또는 파일 객체.</target>
        </trans-unit>
        <trans-unit id="26bdea2d86889049bdd7c48c4150155a14c6f9d5" translate="yes" xml:space="preserve">
          <source>The file or file name to load.</source>
          <target state="translated">로드 할 파일 또는 파일 이름입니다.</target>
        </trans-unit>
        <trans-unit id="410bba1d09731e6c1884743045c51541ebe57e5e" translate="yes" xml:space="preserve">
          <source>The file to pickle &lt;code&gt;a&lt;/code&gt; to. If a string, the full path to the file.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 를 피클 할 파일 입니다. 문자열 인 경우 파일의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="48b7a50cb95566779f051ba6cb8275f9d03a7f05" translate="yes" xml:space="preserve">
          <source>The file to read. File-like objects must support the &lt;code&gt;seek()&lt;/code&gt; and &lt;code&gt;read()&lt;/code&gt; methods. Pickled files require that the file-like object support the &lt;code&gt;readline()&lt;/code&gt; method as well.</source>
          <target state="translated">읽을 파일입니다. 파일과 유사한 객체는 &lt;code&gt;seek()&lt;/code&gt; 및 &lt;code&gt;read()&lt;/code&gt; 메서드를 지원해야합니다 . 절인 파일을 사용하려면 파일과 같은 객체가 &lt;code&gt;readline()&lt;/code&gt; 메서드도 지원해야 합니다.</target>
        </trans-unit>
        <trans-unit id="68f5b58fd976e02c0c3bbbefcb6355b0422acf86" translate="yes" xml:space="preserve">
          <source>The fill_value is set to &lt;code&gt;value&lt;/code&gt; and the mask is set to &lt;code&gt;nomask&lt;/code&gt; if possible.</source>
          <target state="translated">fill_value는 &lt;code&gt;value&lt;/code&gt; 로 설정되고 마스크는 가능한 경우 &lt;code&gt;nomask&lt;/code&gt; 로 설정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ac0cc14c76ce415edde3f9c0f5c15cc239b98f83" translate="yes" xml:space="preserve">
          <source>The filled array.</source>
          <target state="translated">채워진 배열.</target>
        </trans-unit>
        <trans-unit id="02297c05ffd69a001bc553284a8c48319db02e69" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar.</source>
          <target state="translated">마스크 배열의 채우기 값은 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="104abb4185415b9595a8eb2fd00671acf84e203a" translate="yes" xml:space="preserve">
          <source>The filling value of the masked array is a scalar. When setting, None will set to a default based on the data type.</source>
          <target state="translated">마스크 배열의 채우기 값은 스칼라입니다. 설정하면 데이터 유형에 따라 없음이 기본값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="0bd5aa8a98810899514ee710bc2579712901ebe5" translate="yes" xml:space="preserve">
          <source>The final value of the sequence, unless &lt;code&gt;endpoint&lt;/code&gt; is False. In that case, &lt;code&gt;num + 1&lt;/code&gt; values are spaced over the interval in log-space, of which all but the last (a sequence of length &lt;code&gt;num&lt;/code&gt;) are returned.</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 점이 False가 아닌 한 시퀀스의 최종 값입니다 . 이 경우 &lt;code&gt;num + 1&lt;/code&gt; 값은 로그 공간의 간격에 걸쳐 간격을두고 마지막 (길이 &lt;code&gt;num&lt;/code&gt; 시퀀스)을 제외한 모든 값 이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="5b6f2d1ecce5ed0ec2d0e715086fccc9259a6627" translate="yes" xml:space="preserve">
          <source>The first 6 bytes are a magic string: exactly &lt;code&gt;\x93NUMPY&lt;/code&gt;.</source>
          <target state="translated">처음 6 바이트는 정확히 &lt;code&gt;\x93NUMPY&lt;/code&gt; 와 같은 마술 문자열 입니다.</target>
        </trans-unit>
        <trans-unit id="df3f3dac6a267f56fafa2c760b8d38d59413267f" translate="yes" xml:space="preserve">
          <source>The first &lt;code&gt;nargs&lt;/code&gt; elements of &lt;code&gt;steps&lt;/code&gt; remain the same as for scalar ufuncs. The following elements contain the strides of all core dimensions for all arguments in order.</source>
          <target state="translated">&lt;code&gt;steps&lt;/code&gt; 의 첫 번째 &lt;code&gt;nargs&lt;/code&gt; 요소는 스칼라 ufunc의 경우와 동일하게 유지됩니다. 다음 요소에는 모든 인수에 대한 모든 핵심 차원의 보폭이 순서대로 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9577dc8ae8dc3d75fe0e9351485a971c104657b" translate="yes" xml:space="preserve">
          <source>The first argument contains the Extension instance that can be useful to access its attributes like &lt;code&gt;depends&lt;/code&gt;, &lt;code&gt;sources&lt;/code&gt;, etc. lists and modify them during the building process. The second argument gives a path to a build directory that must be used when creating files to a disk.</source>
          <target state="translated">첫 번째 인수는 &lt;code&gt;depends&lt;/code&gt; , &lt;code&gt;sources&lt;/code&gt; 등 의 속성에 액세스하고 빌드 프로세스 중에 속성을 수정하는 데 유용한 Extension 인스턴스를 포함합니다 . 두 번째 인수는 디스크에 파일을 작성할 때 사용해야하는 빌드 디렉토리의 경로를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="98f417ae094b593aad4f373856f9d75fc3caadf1" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object is equivalent to fixed dtype. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">첫 번째 인수는 고정 크기 데이터 형식 개체로 변환 할 수있는 개체입니다. 두 번째 인수는이 유형의 원하는 모양입니다. shape 매개 변수가 1이면 데이터 유형 오브젝트는 고정 dtype과 같습니다. 경우 &lt;em&gt;형상&lt;/em&gt; 튜플, 새로운 DTYPE는 소정 형상의 서브 어레이를 정의한다.</target>
        </trans-unit>
        <trans-unit id="8dca1bab679e35ad504daad1a00ee24ea2d780cc" translate="yes" xml:space="preserve">
          <source>The first argument is any object that can be converted into a fixed-size data-type object. The second argument is the desired shape of this type. If the shape parameter is 1, then the data-type object used to be equivalent to fixed dtype. This behaviour is deprecated since NumPy 1.17 and will raise an error in the future. If &lt;em&gt;shape&lt;/em&gt; is a tuple, then the new dtype defines a sub-array of the given shape.</source>
          <target state="translated">첫 번째 인수는 고정 크기 데이터 유형 객체로 변환 할 수있는 모든 객체입니다. 두 번째 인수는이 유형의 원하는 모양입니다. shape 매개 변수가 1이면 데이터 유형 객체는 고정 dtype과 동일했습니다. 이 동작은 NumPy 1.17부터 사용되지 않으며 향후 오류가 발생할 것입니다. 경우 &lt;em&gt;형상&lt;/em&gt; 튜플, 새로운 DTYPE는 소정 형상의 서브 어레이를 정의한다.</target>
        </trans-unit>
        <trans-unit id="ddb3620809413337a1b624decfe7e8c4e4d1dcd2" translate="yes" xml:space="preserve">
          <source>The first argument is the newly created sub-type. The second argument (if not NULL) is the &amp;ldquo;parent&amp;rdquo; array (if the array was created using slicing or some other operation where a clearly-distinguishable parent is present). This routine can do anything it wants to. It should return a -1 on error and 0 otherwise.</source>
          <target state="translated">첫 번째 인수는 새로 생성 된 하위 유형입니다. 두 번째 인수 (NULL이 아닌 경우)는 &quot;부모&quot;배열 (분할 분할 또는 명확하게 구분할 수있는 부모가있는 다른 작업을 사용하여 배열을 만든 경우)입니다. 이 루틴은 원하는 모든 것을 할 수 있습니다. 오류시 -1을 반환하고 그렇지 않으면 0을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a0c10acae5d14d1b06af72f8c3df392eea96371" translate="yes" xml:space="preserve">
          <source>The first argument must be an object that is converted to a zero-sized flexible data-type object, the second argument is an integer providing the desired itemsize.</source>
          <target state="translated">첫 번째 인수는 크기가 0 인 유연한 데이터 형식 개체로 변환되는 개체 여야하며 두 번째 인수는 원하는 항목 크기를 제공하는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="4ab185078e9e031c6680e1f1eab45ad50f864a10" translate="yes" xml:space="preserve">
          <source>The first array shows the outcomes of throwing the dice 10 times, and the second shows the outcomes from throwing the dice 20 times.</source>
          <target state="translated">첫 번째 배열은 주사위를 10 번 던지는 결과를 보여주고, 두 번째 배열은 주사위를 20 번 던지는 결과를 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="251cc7294c3d03a290266d04d53995289d0bed50" translate="yes" xml:space="preserve">
          <source>The first assert does not raise an exception:</source>
          <target state="translated">첫 번째 주장은 예외를 제기하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0135e65581d52468c8b55907d113ce790f408aef" translate="yes" xml:space="preserve">
          <source>The first business day on or after a date:</source>
          <target state="translated">날짜 또는 그 이후의 첫 영업일 :</target>
        </trans-unit>
        <trans-unit id="034408f6ac73256e0eb3a019833e3b1d26d2adb1" translate="yes" xml:space="preserve">
          <source>The first business day strictly after a date:</source>
          <target state="translated">날짜 이후의 첫 영업일 :</target>
        </trans-unit>
        <trans-unit id="d4d700653c3699a51205d4e8a1ce2d74d29df2ba" translate="yes" xml:space="preserve">
          <source>The first character specifies the kind of data and the remaining characters specify the number of bytes per item, except for Unicode, where it is interpreted as the number of characters. The item size must correspond to an existing type, or an error will be raised. The supported kinds are</source>
          <target state="translated">첫 번째 문자는 데이터 종류를 지정하고 나머지 문자는 유니 코드를 제외하고 항목 당 바이트 수를 지정합니다 (유니 코드는 문자 수로 해석 됨). 항목 크기가 기존 유형과 일치해야합니다. 그렇지 않으면 오류가 발생합니다. 지원되는 종류는</target>
        </trans-unit>
        <trans-unit id="fce5520747cac508bb51c31e51bc43340f4f28dc" translate="yes" xml:space="preserve">
          <source>The first difference is given by &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; along the given axis, higher differences are calculated by using &lt;a href=&quot;#numpy.diff&quot;&gt;&lt;code&gt;diff&lt;/code&gt;&lt;/a&gt; recursively.</source>
          <target state="translated">첫 번째 차이는 주어진 축을 따라 &lt;code&gt;out[i] = a[i+1] - a[i]&lt;/code&gt; 주어지며 &lt;a href=&quot;#numpy.diff&quot;&gt; &lt;code&gt;diff&lt;/code&gt; 를&lt;/a&gt; 재귀 적 으로 사용하여 더 큰 차이를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="1992d313d31d556125405ecacbe1299d290ec7b7" translate="yes" xml:space="preserve">
          <source>The first element of the &lt;code&gt;__array_interface__[&quot;data&quot;]&lt;/code&gt; tuple must be an integer</source>
          <target state="translated">&lt;code&gt;__array_interface__[&quot;data&quot;]&lt;/code&gt; 튜플 의 첫 번째 요소 는 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a9df17052dacee8cafb40ea7e55b18075cf5de14" translate="yes" xml:space="preserve">
          <source>The first element, &lt;em&gt;field_name&lt;/em&gt;, is the field name (if this is &lt;code&gt;''&lt;/code&gt; then a standard field name, &lt;code&gt;'f#'&lt;/code&gt;, is assigned). The field name may also be a 2-tuple of strings where the first string is either a &amp;ldquo;title&amp;rdquo; (which may be any string or unicode string) or meta-data for the field which can be any object, and the second string is the &amp;ldquo;name&amp;rdquo; which must be a valid Python identifier.</source>
          <target state="translated">첫 번째 요소 인 &lt;em&gt;field_name&lt;/em&gt; 은 필드 이름입니다 ( &lt;code&gt;''&lt;/code&gt; 인 경우 표준 필드 이름 &lt;code&gt;'f#'&lt;/code&gt; 가 지정됨). 필드 이름은 첫 번째 문자열이 &quot;제목&quot;(문자열 또는 유니 코드 문자열 일 수 있음)이거나 임의의 개체가 될 수있는 필드의 메타 데이터 인 두 개의 문자열 일 수도 있습니다. 유효한 파이썬 식별자 여야하는 &quot;이름&quot;</target>
        </trans-unit>
        <trans-unit id="67d77719eacdaf274558e4a616994274e8d068b0" translate="yes" xml:space="preserve">
          <source>The first example integrates &lt;code&gt;p&lt;/code&gt; once, the second example integrates it twice. By default, the lower bound of the integration and the integration constant are 0, but both can be specified.:</source>
          <target state="translated">첫 번째 예는 &lt;code&gt;p&lt;/code&gt; 를 한 번 통합하고 두 번째 예는 p를 두 번 통합합니다. 기본적으로 적분의 하한과 적분 상수는 0이지만 둘 다 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="311abfb54dbdf5d2ba16af23aef0589cc8d8cc86" translate="yes" xml:space="preserve">
          <source>The first form should be preferred.</source>
          <target state="translated">첫 번째 양식이 선호되어야합니다.</target>
        </trans-unit>
        <trans-unit id="efb03ce57a81f162cb7b4a2a4999809358d24fef" translate="yes" xml:space="preserve">
          <source>The first integer is the first byte of the array, the second integer is just past the last byte of the array. If &lt;code&gt;a&lt;/code&gt; is not contiguous it will not use every byte between the (&lt;code&gt;low&lt;/code&gt;, &lt;code&gt;high&lt;/code&gt;) values.</source>
          <target state="translated">첫 번째 정수는 배열의 첫 번째 바이트이고 두 번째 정수는 배열의 마지막 바이트 바로 지난 것입니다. 경우 &lt;code&gt;a&lt;/code&gt; 인접 아니다 이것은 (모든 바이트 사이 사용하지 않는 &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;high&lt;/code&gt; ) 값.</target>
        </trans-unit>
        <trans-unit id="19fd42d2f3f6ab1e3a2844cd4d5055ea1cbf31a0" translate="yes" xml:space="preserve">
          <source>The first is the use of the &lt;code&gt;ndarray.__new__&lt;/code&gt; method for the main work of object initialization, rather then the more usual &lt;code&gt;__init__&lt;/code&gt; method. The second is the use of the &lt;code&gt;__array_finalize__&lt;/code&gt; method to allow subclasses to clean up after the creation of views and new instances from templates.</source>
          <target state="translated">첫 번째는 객체 초기화의 주요 작업에 &lt;code&gt;ndarray.__new__&lt;/code&gt; 메서드를 사용하는 것입니다 . 보다 일반적인 &lt;code&gt;__init__&lt;/code&gt; 메서드를 사용하는 것입니다. 두 번째는 &lt;code&gt;__array_finalize__&lt;/code&gt; 메서드를 사용하여 템플릿에서 뷰와 새 인스턴스를 만든 후 하위 클래스를 정리할 수 있도록하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="eb41b42b24f210f1f4be6981685ada6a1cb54412" translate="yes" xml:space="preserve">
          <source>The first law of Laplace, from 1774, states that the frequency of an error can be expressed as an exponential function of the absolute magnitude of the error, which leads to the Laplace distribution. For many problems in economics and health sciences, this distribution seems to model the data better than the standard Gaussian distribution.</source>
          <target state="translated">1774 년부터 Laplace의 제 1 법칙에 따르면 오류의 빈도는 오류의 절대 크기의 지수 함수로 표현 될 수 있으며, 이는 Laplace 분포를 초래합니다. 경제 및 건강 과학의 많은 문제에서이 분포는 표준 가우스 분포보다 데이터를 더 잘 모델링하는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="f7deea27a398e3cec5cdd6f79c6e53fb0be11445" translate="yes" xml:space="preserve">
          <source>The first output can be provided as either a positional or a keyword parameter. Keyword &amp;lsquo;out&amp;rsquo; arguments are incompatible with positional ones.</source>
          <target state="translated">첫 번째 출력은 위치 또는 키워드 매개 변수로 제공 될 수 있습니다. 키워드 'out'인수는 위치 인수와 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6c26c4fe0578c2071a8b45fe1c269e9b84d2d403" translate="yes" xml:space="preserve">
          <source>The first parameter, arr, must be an ndarray or subclass. The parameter, &lt;em&gt;flags&lt;/em&gt;, should be an integer consisting of bitwise combinations of the possible flags an array can have: &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첫 번째 매개 변수 arr은 ndarray 또는 서브 클래스 여야합니다. 파라미터는, &lt;em&gt;플래그&lt;/em&gt; : 배열이 가질 수있는 가능한 비트 플래그의 조합으로 이루어진 정수이어야 &lt;a href=&quot;#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef7e5035a4cae33d8eaceb23fe8e3a39e676894" translate="yes" xml:space="preserve">
          <source>The first row is a header line that (mostly) describes the data in each column that follow in the rows below, and beginning in the fourth column, the header is the date of the observation.</source>
          <target state="translated">첫 번째 행은 (대부분) 아래 행에있는 각 열의 데이터를 설명하는 헤더 행이며 네 번째 열에서 시작하는 헤더는 관찰 날짜입니다.</target>
        </trans-unit>
        <trans-unit id="a463555884e9f663755cbacb732bc60283f30e4e" translate="yes" xml:space="preserve">
          <source>The first rule of broadcasting is that if all input arrays do not have the same number of dimensions, a &amp;ldquo;1&amp;rdquo; will be repeatedly prepended to the shapes of the smaller arrays until all the arrays have the same number of dimensions.</source>
          <target state="translated">브로드 캐스팅의 첫 번째 규칙은 모든 입력 배열의 차원 수가 같지 않은 경우 모든 배열의 차원 수가 같을 때까지 작은 배열의 모양 앞에 &quot;1&quot;이 반복적으로 추가된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a8639bf3cb0cf6544a568d7a40bcc68d44fbb8c9" translate="yes" xml:space="preserve">
          <source>The first signature listed, &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; is for one-dimensional arrays with hard-coded dimensions. Likewise, &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; is for two-dimensional arrays with hard-coded dimensions, and similarly for three-dimensional.</source>
          <target state="translated">나열된 첫 번째 서명 &lt;code&gt;( DATA_TYPE IN_ARRAY[ANY] )&lt;/code&gt; 은 하드 코딩 된 차원을 가진 1 차원 배열을위한 것입니다. 마찬가지로 &lt;code&gt;( DATA_TYPE IN_ARRAY2[ANY][ANY] )&lt;/code&gt; 는 하드 코딩 된 차원을 가진 2 차원 배열 용이며 3 차원에도 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="21bc00ee1c8a15912cb2e713abebe2d2f93cd1e7" translate="yes" xml:space="preserve">
          <source>The first thing done is to look-up in the thread-specific global dictionary the current values for the buffer-size, the error mask, and the associated error object. The state of the error mask controls what happens when an error condition is found. It should be noted that checking of the hardware error flags is only performed after each 1-D loop is executed. This means that if the input and output arrays are contiguous and of the correct type so that a single 1-D loop is performed, then the flags may not be checked until all elements of the array have been calculated. Looking up these values in a thread- specific dictionary takes time which is easily ignored for all but very small arrays.</source>
          <target state="translated">먼저 스레드 별 전역 사전에서 버퍼 크기, 오류 마스크 및 관련 오류 개체에 대한 현재 값을 조회합니다. 오류 마스크의 상태는 오류 조건이 발견 될 때 발생하는 상황을 제어합니다. 하드웨어 오류 플래그 검사는 각 1D 루프가 실행 된 후에 만 ​​수행됩니다. 즉, 단일 1-D 루프가 수행되도록 입력 및 출력 배열이 연속적이고 올바른 유형 인 경우 배열의 모든 요소가 계산 될 때까지 플래그를 확인할 수 없습니다. 스레드 별 사전에서 이러한 값을 찾으려면 아주 작은 배열을 제외하고는 무시되는 시간이 걸립니다.</target>
        </trans-unit>
        <trans-unit id="eec0cb9e2856c8840ae3269c16ee7eee2770a458" translate="yes" xml:space="preserve">
          <source>The first thing to understand is that there are two conflicting conventions for indexing 2-dimensional arrays. Matrix notation uses the first index to indicate which row is being selected and the second index to indicate which column is selected. This is opposite the geometrically oriented-convention for images where people generally think the first index represents x position (i.e., column) and the second represents y position (i.e., row). This alone is the source of much confusion; matrix-oriented users and image-oriented users expect two different things with regard to indexing.</source>
          <target state="translated">가장 먼저 이해해야 할 것은 2 차원 배열을 인덱싱하는 두 가지 상충되는 규칙이 있다는 것입니다. 행렬 표기법은 첫 번째 인덱스를 사용하여 어떤 행이 선택되고 있는지 나타내고 두 번째 인덱스는 어떤 열이 선택되었는지 나타냅니다. 이것은 사람들이 일반적으로 첫 번째 인덱스가 x 위치 (즉, 열)를 나타내고 두 번째 인덱스가 y 위치 (즉, 행)를 나타내는 이미지에 대한 기하학적 지향적 컨벤션과 반대입니다. 이것만으로도 많은 혼란이 발생합니다. 매트릭스 지향 사용자와 이미지 지향 사용자는 인덱싱과 관련하여 두 가지 다른 것을 기대합니다.</target>
        </trans-unit>
        <trans-unit id="bf8fd843050316faeec1058499245d59f374d012" translate="yes" xml:space="preserve">
          <source>The first through third rows and fifth through ninth columns of a 2D array, &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">2D 배열 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3724db84918ba9464ddbe8344f5b3bc2ec94ad64" translate="yes" xml:space="preserve">
          <source>The first two of these are conveniences which resemble the names of the builtin types, in the same style as &lt;a href=&quot;#numpy.bool_&quot;&gt;&lt;code&gt;bool_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 중 첫 번째 두 사람은 같은 스타일에, 내장 유형의 이름을 유사 편의 있습니다 &lt;a href=&quot;#numpy.bool_&quot;&gt; &lt;code&gt;bool_&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;int_&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="43a31061c48404a506dd1e24e7517ade62790639" translate="yes" xml:space="preserve">
          <source>The fixed size of NumPy numeric types may cause overflow errors when a value requires more memory than available in the data type. For example, &lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;numpy.power&lt;/code&gt;&lt;/a&gt; evaluates &lt;code&gt;100 * 10 ** 8&lt;/code&gt; correctly for 64-bit integers, but gives 1874919424 (incorrect) for a 32-bit integer.</source>
          <target state="translated">NumPy 숫자 유형의 고정 된 크기는 값이 데이터 유형에서 사용 가능한 것보다 더 많은 메모리를 필요로 할 때 오버 플로우 오류를 유발할 수 있습니다. 예를 들어 &lt;a href=&quot;../reference/generated/numpy.power#numpy.power&quot;&gt; &lt;code&gt;numpy.power&lt;/code&gt; &lt;/a&gt; 는 64 비트 정수에 대해 &lt;code&gt;100 * 10 ** 8&lt;/code&gt; 올바르게 평가 하지만 32 비트 정수에 대해서는 1874919424 (잘못된)를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="00dceab341e446e82fd4facf33583ffedc7bd940" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;a href=&quot;c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (0x1), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (0x2), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), and &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400). A final flag &lt;a href=&quot;#c.NPY_ARR_HAS_DESCR&quot;&gt;&lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt;&lt;/a&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">flags 멤버는 데이터 해석 방법을 보여주는 5 비트와 인터페이스 해석 방법을 보여주는 1 비트로 구성 될 수 있습니다. 데이터 비트는 &lt;a href=&quot;c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (0x1), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (0x2), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; (0x100), &lt;a href=&quot;c-api/array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt; (0x200) 및 &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; (0x400)입니다. 최종 플래그 &lt;a href=&quot;#c.NPY_ARR_HAS_DESCR&quot;&gt; &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; &lt;/a&gt; (0x800)은이 구조에 arrdescr 필드가 있는지 여부를 나타냅니다. 이 플래그가 없으면 필드에 액세스 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dae27e752e6250bcf53dd15428c26bfc6c4aff24" translate="yes" xml:space="preserve">
          <source>The flags member may consist of 5 bits showing how the data should be interpreted and one bit showing how the Interface should be interpreted. The data-bits are &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200), and &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400). A final flag &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800) indicates whether or not this structure has the arrdescr field. The field should not be accessed unless this flag is present.</source>
          <target state="translated">플래그 멤버는 데이터를 해석하는 방법을 나타내는 5 비트와 인터페이스를 해석하는 방법을 나타내는 1 비트로 구성 될 수 있습니다. 데이터 비트는 &lt;code&gt;CONTIGUOUS&lt;/code&gt; (0x1), &lt;code&gt;FORTRAN&lt;/code&gt; (0x2), &lt;code&gt;ALIGNED&lt;/code&gt; (0x100), &lt;code&gt;NOTSWAPPED&lt;/code&gt; (0x200) 및 &lt;code&gt;WRITEABLE&lt;/code&gt; (0x400)입니다. 최종 플래그 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; (0x800)은이 구조에 arrdescr 필드가 있는지 여부를 나타냅니다. 이 플래그가 없으면 필드에 액세스하면 안됩니다.</target>
        </trans-unit>
        <trans-unit id="80d94b3bc99b1a4e8e2a1a02a0e27c0ae964964b" translate="yes" xml:space="preserve">
          <source>The flexible type array that is returned will have two fields:</source>
          <target state="translated">반환되는 가변형 배열에는 두 개의 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="bd686ab267e11ccd8dcbb950337101a32f2aa2c7" translate="yes" xml:space="preserve">
          <source>The float printing routines use an accurate but much more computationally demanding algorithm to compute the number of digits after the decimal point.</source>
          <target state="translated">부동 인쇄 루틴은 정확하지만 훨씬 더 계산이 필요한 알고리즘을 사용하여 소수점 뒤의 자릿수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9b521c71cd9d32371a352dcf94d2ff132ccb79f4" translate="yes" xml:space="preserve">
          <source>The floating-point exceptions are defined in the IEEE 754 standard &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">부동 소수점 예외는 IEEE 754 표준 &lt;a href=&quot;#r4cab4292821f-1&quot; id=&quot;id1&quot;&gt;[1]에&lt;/a&gt; 정의되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="25cd839f1fa0397dfd8a073d288328126b03cd06" translate="yes" xml:space="preserve">
          <source>The floor division operator &lt;code&gt;//&lt;/code&gt; was added in Python 2.2 making &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; equivalent operators. The default floor division operation of &lt;code&gt;/&lt;/code&gt; can be replaced by true division with &lt;code&gt;from
__future__ import division&lt;/code&gt;.</source>
          <target state="translated">바닥 분할 연산자 &lt;code&gt;//&lt;/code&gt; 는 Python 2.2에서 &lt;code&gt;//&lt;/code&gt; 및 &lt;code&gt;/&lt;/code&gt; 또는 동등한 연산자 로 추가되었습니다 . 의 기본 바닥 나눗셈 연산 &lt;code&gt;/&lt;/code&gt; 는 과 진정한 사업부로 대체 될 수 &lt;code&gt;from __future__ import division&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e26997b358814cca7850a49e412f8a41b34dbe5" translate="yes" xml:space="preserve">
          <source>The floor of each element in &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 각 요소의 바닥입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="eaacb373a79b18f285bd66c2cf0778d5b163c8e7" translate="yes" xml:space="preserve">
          <source>The floor of the scalar &lt;code&gt;x&lt;/code&gt; is the largest integer &lt;code&gt;i&lt;/code&gt;, such that &lt;code&gt;i &amp;lt;= x&lt;/code&gt;. It is often denoted as</source>
          <target state="translated">스칼라 &lt;code&gt;x&lt;/code&gt; 의 바닥은 가장 큰 정수 &lt;code&gt;i&lt;/code&gt; 이므로 &lt;code&gt;i &amp;lt;= x&lt;/code&gt; 입니다. 종종 다음과 같이 표시됩니다</target>
        </trans-unit>
        <trans-unit id="837a298621c37ae4f32158adfb48d3ae2b900f73" translate="yes" xml:space="preserve">
          <source>The fmax is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">fmax는 x1과 x2가 NaN이 아닌 경우 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르며 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="9192d9bcf4b5d5fc29087b97fc9fad549a45ccf6" translate="yes" xml:space="preserve">
          <source>The fmin is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1과 x2가 NaN이 아닌 경우 fmin은 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르고 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="359ddc84e42e1145c1875abe172377b5b248a4ef" translate="yes" xml:space="preserve">
          <source>The following &lt;code&gt;git config --global&lt;/code&gt; commands:</source>
          <target state="translated">다음 &lt;code&gt;git config --global&lt;/code&gt; 명령 :</target>
        </trans-unit>
        <trans-unit id="518aa4775940c5975015df6bdff3bbfdd8f78874" translate="yes" xml:space="preserve">
          <source>The following aliases originate from Python 2, and it is recommended that they not be used in new code.</source>
          <target state="translated">다음 별칭은 Python 2에서 비롯되었으며 새 코드에서 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="2933db06c5f57c543942f5ed02bb77ea787c4725" translate="yes" xml:space="preserve">
          <source>The following attributes are used by F2PY:</source>
          <target state="translated">다음 속성은 F2PY에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="26c655f10b13c11e712f57319bac1772cdc5526b" translate="yes" xml:space="preserve">
          <source>The following attributes contain information about the memory layout of the array:</source>
          <target state="translated">다음 속성은 배열의 메모리 레이아웃에 대한 정보를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="245831b050a7f252080c114fea4739c32457bc6e" translate="yes" xml:space="preserve">
          <source>The following code allows us to look at the call sequences and arguments:</source>
          <target state="translated">다음 코드를 사용하면 호출 시퀀스와 인수를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b09df459a0ad4a5d7d6218f92cc55900d726085b" translate="yes" xml:space="preserve">
          <source>The following comparison does not raise an exception. There are NaNs in the inputs, but they are in the same positions.</source>
          <target state="translated">다음 비교는 예외를 일으키지 않습니다. 입력에 NaN이 있지만 동일한 위치에 있습니다.</target>
        </trans-unit>
        <trans-unit id="25c3aeb47ccb54f3895f28756398a03c01d886f7" translate="yes" xml:space="preserve">
          <source>The following corresponds to the usual functions except that nans are excluded from the results:</source>
          <target state="translated">다음은 nan이 결과에서 제외된다는 점을 제외하고는 일반적인 기능에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="367c359a19964728c01ac0e57fac7d66168d5b07" translate="yes" xml:space="preserve">
          <source>The following data types are &lt;strong&gt;flexible&lt;/strong&gt;: they have no predefined size and the data they describe can be of different length in different arrays. (In the character codes &lt;code&gt;#&lt;/code&gt; is an integer denoting how many elements the data type consists of.)</source>
          <target state="translated">다음 데이터 유형은 &lt;strong&gt;융통성이 있습니다&lt;/strong&gt; . 사전 정의 된 크기가 없으며 설명하는 데이터의 길이가 서로 다른 배열 일 수 있습니다. 문자 코드에서 &lt;code&gt;#&lt;/code&gt; 은 데이터 유형으로 구성되는 요소 수를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="87cc18e3bbbb39d0641f0c5e5f7aaba73b3bfa17" translate="yes" xml:space="preserve">
          <source>The following example checks that &lt;code&gt;a * a+ * a == a&lt;/code&gt; and &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt;:</source>
          <target state="translated">다음 예제는 &lt;code&gt;a * a+ * a == a&lt;/code&gt; 및 &lt;code&gt;a+ * a * a+ == a+&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da726617ef56fc847d878f222531de4392ef5079" translate="yes" xml:space="preserve">
          <source>The following example demonstrates that operations on this particular dtype requires Python C-API.</source>
          <target state="translated">다음 예제는이 특정 dtype에 대한 조작에 Python C-API가 필요하다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="bff8fe87ad1b3faab42fa78be47af40e14a3cdee" translate="yes" xml:space="preserve">
          <source>The following example illustrates how to add user-defined variables to a F2PY generated extension module. Given the following signature file</source>
          <target state="translated">다음 예제는 F2PY 생성 확장 모듈에 사용자 정의 변수를 추가하는 방법을 보여줍니다. 다음 서명 파일이 주어지면</target>
        </trans-unit>
        <trans-unit id="601636ce271dc6c59652a4b9ca1697d0ffc34977" translate="yes" xml:space="preserve">
          <source>The following example shows how you might write a wrapper that accepts two input arguments (that will be converted to an array) and an output argument (that must be an array). The function returns None and updates the output array. Note the updated use of WRITEBACKIFCOPY semantics for NumPy v1.14 and above</source>
          <target state="translated">다음 예제는 두 개의 입력 인수 (배열로 변환 됨)와 출력 인수 (배열이어야 함)를 허용하는 래퍼를 작성하는 방법을 보여줍니다. 이 함수는 None을 반환하고 출력 배열을 업데이트합니다. NumPy v1.14 이상에 대한 WRITEBACKIFCOPY 의미 체계의 업데이트 된 사용에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="cec08f779bf34d2ddbd6e93821079202c9a0f6c2" translate="yes" xml:space="preserve">
          <source>The following features aren&amp;rsquo;t supported by x86::Intel Compiler: &lt;strong&gt;XOP FMA4&lt;/strong&gt;</source>
          <target state="translated">다음 기능은 x86에서 지원되지 않습니다 :: 인텔 컴파일러 : &lt;strong&gt;XOP FMA4&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d6c191fcaf6a1f21a70ff57080f8689e6ba2fd60" translate="yes" xml:space="preserve">
          <source>The following features aren&amp;rsquo;t supported by x86::Microsoft Visual C/C++: &lt;strong&gt;AVX512_KNL AVX512_KNM&lt;/strong&gt;</source>
          <target state="translated">다음 기능은 x86에서 지원되지 않습니다 :: Microsoft Visual C / C ++ : &lt;strong&gt;AVX512_KNL AVX512_KNM&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9274fe878c5628b41be8c56553474b2bf993bdb4" translate="yes" xml:space="preserve">
          <source>The following import conventions are used throughout the NumPy source and documentation:</source>
          <target state="translated">다음 가져 오기 규칙은 NumPy 소스 및 문서 전체에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a11277817c1922ff80f9328abde5fde7dba14c8" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[:, np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;x[:, np.newaxis]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9a4cf52932022adac50e43fe76bc932e82c5751" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;x[np.newaxis, :]&lt;/code&gt; 또는 &lt;code&gt;x[np.newaxis]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7cc30376235469e66891b8aa9bb0978b2dc2799" translate="yes" xml:space="preserve">
          <source>The following is equivalent to &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; or &lt;code&gt;x[np.newaxis]&lt;/code&gt;:</source>
          <target state="translated">다음은 &lt;code&gt;x[np.newaxis,:]&lt;/code&gt; 또는 &lt;code&gt;x[np.newaxis]&lt;/code&gt; 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b1e13d507d651c25d5c30d03b160ce21c4df709" translate="yes" xml:space="preserve">
          <source>The following is probably true, given that 0.6 is roughly twice the standard deviation:</source>
          <target state="translated">0.6이 표준 편차의 약 2 배인 경우 다음 사항에 해당됩니다.</target>
        </trans-unit>
        <trans-unit id="abb45d568d4c1dc6b1960772da10fbcd2d6bd4ca" translate="yes" xml:space="preserve">
          <source>The following keys are allowed:</source>
          <target state="translated">다음과 같은 키가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c7e7738746294a7939f873df246ce33769c08494" translate="yes" xml:space="preserve">
          <source>The following math constants are available in &lt;code&gt;npy_math.h&lt;/code&gt;. Single and extended precision are also available by adding the &lt;code&gt;f&lt;/code&gt; and &lt;code&gt;l&lt;/code&gt; suffixes respectively.</source>
          <target state="translated">&lt;code&gt;npy_math.h&lt;/code&gt; 에서 다음 수학 상수를 사용할 수 있습니다 . &lt;code&gt;f&lt;/code&gt; 및 &lt;code&gt;l&lt;/code&gt; 접미사를 각각 추가하여 단 ​​정밀도 및 확장 정밀도도 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="18400fc6ad0ef15f4b4b9f40c34d77a0b29576fd" translate="yes" xml:space="preserve">
          <source>The following methods can be used to access information about the mask or to manipulate the mask.</source>
          <target state="translated">마스크에 대한 정보에 액세스하거나 마스크를 조작하는 데 다음 방법을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7a27e2b2ff01b711d127c91926b8f2614c9b919" translate="yes" xml:space="preserve">
          <source>The following methods implement the pickle protocol:</source>
          <target state="translated">다음 방법은 피클 프로토콜을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="ebfae704e1370f3e45632884fb2aa5f3e6615469" translate="yes" xml:space="preserve">
          <source>The following new &lt;code&gt;distutils&lt;/code&gt; commands are defined:</source>
          <target state="translated">다음과 같은 새로운 &lt;code&gt;distutils&lt;/code&gt; 명령이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="3e142b98cf4f076b7f9b0cce4a8911bba92433dc" translate="yes" xml:space="preserve">
          <source>The following norms can be calculated:</source>
          <target state="translated">다음과 같은 규범을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d6f7c16ce7db4761de0d3a2abd525b89c4146e9" translate="yes" xml:space="preserve">
          <source>The following predefined named repeat rules are available:</source>
          <target state="translated">다음과 같은 미리 정의 된 명명 된 반복 규칙을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de855448328b5e9f80cc8ce9168a701f985757d7" translate="yes" xml:space="preserve">
          <source>The following rules apply:</source>
          <target state="translated">다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="cb0a5d55704a6c767182c6ac613e21ec8fe0f334" translate="yes" xml:space="preserve">
          <source>The following sections list commonly reported issues depending on your setup. If you have an issue/solution that you think should appear please open a NumPy issue so that it will be added.</source>
          <target state="translated">다음 섹션에는 설정에 따라 일반적으로보고되는 문제가 나열되어 있습니다. 나타나야한다고 생각하는 문제 / 솔루션이있는 경우 NumPy 문제를 열어 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="35ff8f470befc9ac72d0ecaaff54cadb612acf70" translate="yes" xml:space="preserve">
          <source>The following steps are repeated for the beta(s), release candidates(s) and the final release.</source>
          <target state="translated">베타, 릴리스 후보 및 최종 릴리스에 대해 다음 단계가 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="673282ba4caddc15d3834a42815a47f56a4e3e0c" translate="yes" xml:space="preserve">
          <source>The following subsections provide more details about the differences.</source>
          <target state="translated">다음 하위 섹션에서는 차이점에 대한 자세한 내용을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="24372c47ac89c648eaea091804415a70512b9c0d" translate="yes" xml:space="preserve">
          <source>The following table summarizes the behaviors of the methods.</source>
          <target state="translated">다음 표에는 메서드의 동작이 요약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c06e0f256f2589491136501e9e87069b307e9c76" translate="yes" xml:space="preserve">
          <source>The following tables show the current supported optimizations sorted from the lowest to the highest interest.</source>
          <target state="translated">다음 표에는 현재 지원되는 최적화가 가장 낮은 관심도에서 가장 높은 관심도 순으로 정렬되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2238114e4622f64961aa457707939beca3d22430" translate="yes" xml:space="preserve">
          <source>The form of each element of the files sequence is very flexible allowing many combinations of where to get the files from the package and where they should ultimately be installed on the system. The most basic usage is for an element of the files argument sequence to be a simple filename. This will cause that file from the local path to be installed to the installation path of the self.name package (package path). The file argument can also be a relative path in which case the entire relative path will be installed into the package directory. Finally, the file can be an absolute path name in which case the file will be found at the absolute path name but installed to the package path.</source>
          <target state="translated">파일 시퀀스의 각 요소 형태는 매우 유연하여 패키지에서 파일을 가져올 위치와 궁극적으로 시스템에 설치해야하는 위치를 다양하게 조합 할 수 있습니다. 가장 기본적인 사용법은 파일 인수 시퀀스의 요소가 간단한 파일 이름이되는 것입니다. 이로 인해 로컬 경로의 파일이 self.name 패키지의 설치 경로 (패키지 경로)에 설치됩니다. 파일 인수는 상대 경로 일 수도 있으며,이 경우 전체 상대 경로가 패키지 디렉토리에 설치됩니다. 마지막으로, 파일은 절대 경로 이름 일 수 있으며,이 경우 파일은 절대 경로 이름에 있지만 패키지 경로에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="7343176dc74f7dbd7af11c9825b614f0b44c3446" translate="yes" xml:space="preserve">
          <source>The formal syntax of signatures is as follows:</source>
          <target state="translated">서명의 공식 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9dfcbb2acec4cf5d146ee3b9671f0f8af54935b6" translate="yes" xml:space="preserve">
          <source>The format description, either specified as a string with comma-separated format descriptions in the form &lt;code&gt;'f8, i4, a5'&lt;/code&gt;, or a list of format description strings in the form &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt;.</source>
          <target state="translated">형식 설명은 &lt;code&gt;'f8, i4, a5'&lt;/code&gt; 형식의 쉼표로 구분 된 형식 설명이있는 문자열로 지정 되거나 &lt;code&gt;['f8', 'i4', 'a5']&lt;/code&gt; 형식의 형식 설명 문자열 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="8d7571d646719e6a89afce2ffa8ca97d9a9e64da" translate="yes" xml:space="preserve">
          <source>The format is that required by the &amp;lsquo;descr&amp;rsquo; key in the &lt;code&gt;__array_interface__&lt;/code&gt; attribute.</source>
          <target state="translated">형식은 &lt;code&gt;__array_interface__&lt;/code&gt; 속성 의 'descr'키에 필요한 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="8a1e4bed9460777336f2b104636d1f996f032590" translate="yes" xml:space="preserve">
          <source>The format of these binary file types is documented in &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">이 이진 파일 형식의 형식은 &lt;a href=&quot;generated/numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 에&lt;/a&gt; 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab7733aff55a201beeb5e33bad2c1efefa91a712" translate="yes" xml:space="preserve">
          <source>The forward 2-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt;&lt;code&gt;ifft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">정방향 2 차원 FFT로, &lt;a href=&quot;#numpy.fft.ifft2&quot;&gt; &lt;code&gt;ifft2&lt;/code&gt; &lt;/a&gt; 는 역입니다.</target>
        </trans-unit>
        <trans-unit id="0bd56e9c9eb1ee54cf6d17ca53e59f27e56218bd" translate="yes" xml:space="preserve">
          <source>The forward &lt;em&gt;n&lt;/em&gt;-dimensional FFT, of which &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">정방향 &lt;em&gt;n&lt;/em&gt; 차원 FFT이며,이 중 &lt;a href=&quot;#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; 은 역입니다.</target>
        </trans-unit>
        <trans-unit id="aeabce19c51398cd914249fe750519a8327c3674" translate="yes" xml:space="preserve">
          <source>The forward n-dimensional FFT of real input, of which &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">이는 실제 입력의 전방 N 차원 FFT &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; 가&lt;/a&gt; 역이다.</target>
        </trans-unit>
        <trans-unit id="09a0fbb085d0fd26ff5f14cab85195f81b750c9f" translate="yes" xml:space="preserve">
          <source>The forward two-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft2&quot;&gt;&lt;code&gt;irfft2&lt;/code&gt;&lt;/a&gt; is the inverse.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.irfft2&quot;&gt; &lt;code&gt;irfft2&lt;/code&gt; &lt;/a&gt; 가 역인 실수 입력의 순방향 2 차원 FFT입니다 .</target>
        </trans-unit>
        <trans-unit id="86b261d0d21cfe3b6b89e72eae8348c6f9559d44" translate="yes" xml:space="preserve">
          <source>The foundations of Project governance are:</source>
          <target state="translated">프로젝트 거버넌스의 기초는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="61a4038ee203c584eee7f06e34f73b9e221966a9" translate="yes" xml:space="preserve">
          <source>The four core distributions (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;) all allow existing arrays to be filled using the &lt;code&gt;out&lt;/code&gt; keyword argument. Existing arrays need to be contiguous and well-behaved (writable and aligned). Under normal circumstances, arrays created using the common constructors such as &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;numpy.empty&lt;/code&gt;&lt;/a&gt; will satisfy these requirements.</source>
          <target state="translated">네 가지 핵심 분포 ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; )는 모두 &lt;code&gt;out&lt;/code&gt; 키워드 인수 를 사용하여 기존 배열을 채울 수 있습니다 . 기존 어레이는 연속적이고 올바르게 작동해야합니다 (쓰기 가능 및 정렬). 일반적인 상황에서 &lt;a href=&quot;../generated/numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;numpy.empty&lt;/code&gt; &lt;/a&gt; 와 같은 공통 생성자를 사용하여 생성 된 배열 은 이러한 요구 사항을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="4e18095a7950042b568262a2f1c7ea1be5258e8f" translate="yes" xml:space="preserve">
          <source>The four values listed above correspond to the number of columns in your array. With a four-column array, you will get four values as your result.</source>
          <target state="translated">위에 나열된 4 개의 값은 배열의 열 수에 해당합니다. 4 열 배열을 사용하면 결과로 4 개의 값을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b6b0ab0e6259043a789c7cdf6069c9981b5ed51" translate="yes" xml:space="preserve">
          <source>The fourth-order derivative of a 3rd-order polynomial is zero:</source>
          <target state="translated">3 차 다항식의 4 차 미분 값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="61efc608056775e101326edefdfb5b3e50b42207" translate="yes" xml:space="preserve">
          <source>The fractional and integral parts are negative if the given number is negative.</source>
          <target state="translated">주어진 숫자가 음수이면 분수 및 정수 부분은 음수입니다.</target>
        </trans-unit>
        <trans-unit id="8a03fbb591756592459d393e8bbc5d2c3b77111d" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt; can always be used to reproduce the old behavior, as it will return a packed copy of the structured array. The code above, for example, can be replaced with:</source>
          <target state="translated">&lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt; 함수 는 구조화 된 배열의 압축 된 복사본을 반환하므로 항상 이전 동작을 재현하는 데 사용할 수 있습니다. 예를 들어 위의 코드는 다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a275d8e4e1eb223479714f496979856366e2451a" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt; 함수 는 numpy의 기본 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 로 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="3162acb71296218159c712934b3730fe102cab75" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;#numpy.random.default_rng&quot;&gt;&lt;code&gt;numpy.random.default_rng&lt;/code&gt;&lt;/a&gt; will instantiate a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; with numpy&amp;rsquo;s default &lt;code&gt;BitGenerator&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.default_rng&quot;&gt; &lt;code&gt;numpy.random.default_rng&lt;/code&gt; &lt;/a&gt; 함수 는 numpy의 기본 &lt;code&gt;BitGenerator&lt;/code&gt; 로 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 를 인스턴스화합니다 .</target>
        </trans-unit>
        <trans-unit id="2a8219757277659dda8af10246595348c539cf3e" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt;&lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;multi&lt;/code&gt; ) can be used to take a multi-iterator object and adjust all the iterators so that iteration does not take place over the largest dimension (it makes that dimension of size 1). The code being looped over that makes use of the pointers will very-likely also need the strides data for each of the iterators. This information is stored in multi-&amp;gt;iters[i]-&amp;gt;strides.</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/array#c.PyArray_RemoveSmallest&quot;&gt; &lt;code&gt;PyArray_RemoveSmallest&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;multi&lt;/code&gt; ) 함수를 사용하여 다중 반복기 객체를 가져 와서 가장 큰 차원에서 반복이 발생하지 않도록 모든 반복기를 조정할 수 있습니다 (크기가 1 인 차원을 만듭니다). 포인터를 사용하는 반복되는 코드는 각 반복기에 대한 strides 데이터가 필요할 가능성이 매우 높습니다. 이 정보는 multi-&amp;gt; iters [i]-&amp;gt; stride에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="9aca3baefb770d49123ec449717dbfcad5a619a9" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt;&lt;code&gt;column_stack&lt;/code&gt;&lt;/a&gt; stacks 1D arrays as columns into a 2D array. It is equivalent to &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; only for 2D arrays:</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.column_stack#numpy.column_stack&quot;&gt; &lt;code&gt;column_stack&lt;/code&gt; &lt;/a&gt; 함수는 1D 배열을 2D 배열에 열로 쌓습니다. 2D 배열의 경우에만 &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 과 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="ada915777af34962f5a155b7336d9374672697e6" translate="yes" xml:space="preserve">
          <source>The function &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; allows you to apply offsets specified in business days to datetimes with a unit of &amp;lsquo;D&amp;rsquo; (day).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; &lt;/a&gt; 기능을 사용하면 업무 일에 지정된 오프셋을 'D'(일) 단위로 날짜 시간에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b326cd579834eae17571b08e2103d37d7f1ef376" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;gun&lt;/code&gt; may return any number of objects as a tuple. Then following rules are applied:</source>
          <target state="translated">함수 &lt;code&gt;gun&lt;/code&gt; 은 여러 개체를 튜플로 반환 할 수 있습니다. 그런 다음 다음 규칙이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="23e4e84916821d7380bf310d4fe3bd37497cc290" translate="yes" xml:space="preserve">
          <source>The function &lt;code&gt;zeros&lt;/code&gt; creates an array full of zeros, the function &lt;code&gt;ones&lt;/code&gt; creates an array full of ones, and the function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. By default, the dtype of the created array is &lt;code&gt;float64&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;zeros&lt;/code&gt; 함수는 0으로 가득 찬 배열을 만들고 1 함수는 &lt;code&gt;ones&lt;/code&gt; 가득 찬 배열을 만들고 &lt;code&gt;empty&lt;/code&gt; 함수 는 초기 내용이 무작위이며 메모리 상태에 따라 달라지는 배열을 만듭니다. 기본적으로 생성 된 배열의 dtype은 &lt;code&gt;float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="96d8a0725df6e95677a6e264d7cb37fa566a8b73" translate="yes" xml:space="preserve">
          <source>The function assumes that the number of dimensions of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are the same, if necessary prepending the smallest with ones. If &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; and &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt;, the Kronecker product has shape &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt;. The elements are products of elements from &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, organized explicitly by:</source>
          <target state="translated">이 함수는 필요한 경우 가장 작은 것 앞에 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 치수 수가 같다고 가정 합니다. 경우 &lt;code&gt;a.shape = (r0,r1,..,rN)&lt;/code&gt; 하고 &lt;code&gt;b.shape = (s0,s1,&amp;hellip;,sN)&lt;/code&gt; 는 크로네 커 제품 형상을 갖는다 &lt;code&gt;(r0*s0, r1*s1, &amp;hellip;, rN*SN)&lt;/code&gt; . 요소는 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소로 구성된 제품으로 다음 과 같이 명시 적으로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="af59a6369749b3cb0f9764af498a65709d68b13e" translate="yes" xml:space="preserve">
          <source>The function has a mean of</source>
          <target state="translated">이 함수의 평균은</target>
        </trans-unit>
        <trans-unit id="054f865aa3416e437e5f93f6d6b344a94ea0192f" translate="yes" xml:space="preserve">
          <source>The function has its peak (the mode) at</source>
          <target state="translated">함수의 피크 (모드)가</target>
        </trans-unit>
        <trans-unit id="6069aba02c2ff9e33d0e7ae153f4ba83da37a833" translate="yes" xml:space="preserve">
          <source>The function has its peak at the mean, and its &amp;ldquo;spread&amp;rdquo; increases with the standard deviation (the function reaches 0.607 times its maximum at</source>
          <target state="translated">이 함수는 평균에서 피크를 가지며 표준 편차에 따라 &quot;스프레드&quot;가 증가합니다 (이 함수는</target>
        </trans-unit>
        <trans-unit id="3aafd01a0784838ff12d9b42abaea56f0c51d8d3" translate="yes" xml:space="preserve">
          <source>The function has zeroes where the angle is a multiple of</source>
          <target state="translated">이 함수는 각도가 배수 인 0을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="8224b60c460c6d30ff461ee22df630041e59b82c" translate="yes" xml:space="preserve">
          <source>The function is accessed as an attribute of or an item from the loaded shared-library. Thus, if &lt;code&gt;./mylib.so&lt;/code&gt; has a function named &lt;code&gt;cool_function1&lt;/code&gt;, I could access this function either as:</source>
          <target state="translated">함수는로드 된 공유 라이브러리의 속성 또는 항목으로 액세스됩니다. 경우에 따라서, &lt;code&gt;./mylib.so&lt;/code&gt; 는 함수 이름이 &lt;code&gt;cool_function1&lt;/code&gt; 을 , 나도이 기능으로 액세스 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="fafbcce3a94cb5de2e94d10e8bc93622f1a9c81d" translate="yes" xml:space="preserve">
          <source>The function is also useful for computing some kinds of days like holidays. In Canada and the U.S., Mother&amp;rsquo;s day is on the second Sunday in May, which can be computed with a custom weekmask.</source>
          <target state="translated">이 함수는 휴일과 같은 며칠을 계산할 때도 유용합니다. 캐나다와 미국에서 어머니의 날은 5 월 둘째 주 일요일이며, 맞춤 주 마스크로 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="67cb306690132e9cba2500b1fa7de5410b4f5260" translate="yes" xml:space="preserve">
          <source>The function is applied to both the _data and the _mask, if any.</source>
          <target state="translated">이 함수는 _data 및 _mask (있는 경우) 모두에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="da183d0fc1832c644fcb348cf07cf8e31326309a" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">이 함수는 N 개의 매개 변수로 호출되며, 여기서 N은 &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 의 순위입니다 . 각 매개 변수는 특정 축을 따라 변하는 배열의 좌표를 나타냅니다. 예를 들어, &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;(2, 2)&lt;/code&gt; 이면 매개 변수는 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 및 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f3d30cf3098994de825e7f6bde3ab7173788815" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">이 함수는 N 개의 매개 변수를 사용하여 호출됩니다. 여기서 N은 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 의 순위입니다 . 각 매개 변수는 특정 축을 따라 변하는 배열의 좌표를 나타냅니다. 예를 들어 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;(2, 2)&lt;/code&gt; 이면 매개 변수는 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 및 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d612a9af75e269601691ae7eb90f682a5b996713" translate="yes" xml:space="preserve">
          <source>The function is called with N parameters, where N is the rank of &lt;code&gt;shape&lt;/code&gt;. Each parameter represents the coordinates of the array varying along a specific axis. For example, if &lt;code&gt;shape&lt;/code&gt; were &lt;code&gt;(2, 2)&lt;/code&gt;, then the parameters would be &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; and &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</source>
          <target state="translated">이 함수는 N 개의 매개 변수로 호출되며, 여기서 N은 &lt;code&gt;shape&lt;/code&gt; 의 순위입니다 . 각 매개 변수는 특정 축을 따라 변하는 배열의 좌표를 나타냅니다. 예를 들어, &lt;code&gt;shape&lt;/code&gt; 가 &lt;code&gt;(2, 2)&lt;/code&gt; 이면 매개 변수는 &lt;code&gt;array([[0, 0], [1, 1]])&lt;/code&gt; 및 &lt;code&gt;array([[0, 1], [0, 1]])&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5020746e9a28c81bea9ebded1052af0dc8ae2dc6" translate="yes" xml:space="preserve">
          <source>The function is included as an argument to the python function call to the Fortran subroutine even though it was &lt;em&gt;not&lt;/em&gt; in the Fortran subroutine argument list. The &amp;ldquo;external&amp;rdquo; refers to the C function generated by f2py, not the python function itself. The python function must be supplied to the C function.</source>
          <target state="translated">기능은 그것이 비록 포트란 서브 루틴 파이썬 함수 호출에 인수로 포함 &lt;em&gt;하지&lt;/em&gt; 포트란 서브 루틴 인수 목록에서. &quot;외부&quot;는 파이썬 함수 자체가 아니라 f2py에 의해 생성 된 C 함수를 나타냅니다. 파이썬 함수는 C 함수에 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="8addd0f39cba25bd912a60b0fb5434bfd595dbe3" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData clone functions. These functions should never set the Python exception on error, because they may be called from a multi-threaded context.</source>
          <target state="translated">NpyAuxData 복제 함수의 함수 포인터 유형입니다. 이러한 함수는 다중 스레드 컨텍스트에서 호출 될 수 있으므로 오류시 Python 예외를 설정해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="167c7a543d8ccb24656ce9a1687449c4ecfb1950" translate="yes" xml:space="preserve">
          <source>The function pointer type for NpyAuxData free functions.</source>
          <target state="translated">NpyAuxData 프리 함수에 대한 함수 포인터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="a328f1fcd0be371ed7460c86c4fd60c08690a1c3" translate="yes" xml:space="preserve">
          <source>The function returns the coefficients of the polynomial</source>
          <target state="translated">이 함수는 다항식의 계수를 반환합니다</target>
        </trans-unit>
        <trans-unit id="56ed9dbe32b58078e6c4979647428ecdfd02c355" translate="yes" xml:space="preserve">
          <source>The function signature is normally found by introspection and displayed by the help function. For some functions (notably those written in C) the signature is not available, so we have to specify it as the first line of the docstring:</source>
          <target state="translated">함수 시그니처는 일반적으로 인트로 스펙 션에 의해 발견되고 도움말 함수에 의해 표시됩니다. 일부 함수 (특히 C로 작성된 함수)의 경우 서명을 사용할 수 없으므로 독 스트링의 첫 번째 줄로 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="f0b123a5d43604d228ff7e22be71c876bc3f213f" translate="yes" xml:space="preserve">
          <source>The function that is called when x and y are omitted</source>
          <target state="translated">x와 y가 생략 될 때 호출되는 함수</target>
        </trans-unit>
        <trans-unit id="292f9d908dc66f70e34640d48dac32f92d8211ec" translate="yes" xml:space="preserve">
          <source>The function to be approximated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">근사 할 함수입니다. &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; 형식의 단일 변수 함수 여야합니다. 여기서 &lt;code&gt;a, b, c...&lt;/code&gt; 는 &lt;code&gt;args&lt;/code&gt; 매개 변수에 전달 된 추가 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="e68506a39d4f1164408a473e0014c02732a65744" translate="yes" xml:space="preserve">
          <source>The function to be deprecated.</source>
          <target state="translated">더 이상 사용되지 않는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1ed24e8ca86c415e0834a63e6e6d562c0814371f" translate="yes" xml:space="preserve">
          <source>The function to be interpolated. It must be a function of a single variable of the form &lt;code&gt;f(x, a, b, c...)&lt;/code&gt;, where &lt;code&gt;a, b, c...&lt;/code&gt; are extra arguments passed in the &lt;code&gt;args&lt;/code&gt; parameter.</source>
          <target state="translated">보간 할 함수입니다. &lt;code&gt;f(x, a, b, c...)&lt;/code&gt; 형식의 단일 변수 함수 여야합니다. 여기서 &lt;code&gt;a, b, c...&lt;/code&gt; 는 &lt;code&gt;args&lt;/code&gt; 매개 변수에 전달 된 추가 인수 입니다.</target>
        </trans-unit>
        <trans-unit id="dd5723a1284c8aa8946aa81b4b7601e07d26020c" translate="yes" xml:space="preserve">
          <source>The functionality is based on &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt;&lt;code&gt;os.path.abspath&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기능은 &lt;a href=&quot;https://docs.python.org/dev/library/os.path.html#os.path.abspath&quot;&gt; &lt;code&gt;os.path.abspath&lt;/code&gt; 를&lt;/a&gt; 기반으로 합니다.</target>
        </trans-unit>
        <trans-unit id="e6e850d04a35d82db7e5c340cdd654a0e7af1cfd" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superceded by iterator &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">이 기능 은 1.6에 도입 된 반복자 &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; , 플래그 &lt;a href=&quot;c-api.iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt; 또는 모든 피연산자에 대해 동일한 dtype 매개 변수로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="a07514d8b8d140f4e03babf46c4ca643c0f5e565" translate="yes" xml:space="preserve">
          <source>The functionality this provides is largely superseded by iterator &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt; introduced in 1.6, with flag &lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt; or with the same dtype parameter for all operands.</source>
          <target state="translated">이 기능이 제공하는 기능은 주로 1.6에 도입 된 반복자 &lt;a href=&quot;iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; , 플래그 &lt;a href=&quot;iterator#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt; 또는 모든 피연산자에 대해 동일한 dtype 매개 변수로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="2962953aa600a37ce10b761bfc967d43ddef0e3d" translate="yes" xml:space="preserve">
          <source>The functions are named with the following conventions:</source>
          <target state="translated">함수는 다음 규칙에 따라 이름이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="9e207dc9abcf693e32399f76b884fbb8a9e3545f" translate="yes" xml:space="preserve">
          <source>The functions called to implement many arithmetic special methods for arrays can be modified using &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에 대한 많은 산술 특수 메소드를 구현하기 위해 호출되는 함수는 &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; 를&lt;/a&gt; 사용하여 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d8d64b72fb018cdee0e3f01b29eae167f558f81" translate="yes" xml:space="preserve">
          <source>The functions in the shared library are available as attributes of the ctypes library object (returned from &lt;code&gt;ctypeslib.load_library&lt;/code&gt;) or as items using &lt;code&gt;lib['func_name']&lt;/code&gt; syntax. The latter method for retrieving a function name is particularly useful if the function name contains characters that are not allowable in Python variable names.</source>
          <target state="translated">공유 라이브러리의 함수는 ctypes 라이브러리 객체의 속성 ( &lt;code&gt;ctypeslib.load_library&lt;/code&gt; 에서 반환 됨 ) 또는 &lt;code&gt;lib['func_name']&lt;/code&gt; 구문을 사용하는 항목으로 사용할 수 있습니다. 함수 이름을 검색하는 후자의 방법은 함수 이름에 Python 변수 이름에서 허용되지 않는 문자가 포함 된 경우 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="df46d6188871c9afe4dd8663a289bd38fe7112b3" translate="yes" xml:space="preserve">
          <source>The functions without &amp;ldquo;standard&amp;rdquo; in their name require additional parameters to describe the distributions.</source>
          <target state="translated">이름에 &quot;standard&quot;가없는 함수는 분포를 설명하기위한 추가 매개 변수가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="780f3f42d3ad6d900b31dca5cc39ba44b8433b34" translate="yes" xml:space="preserve">
          <source>The future value is computed by solving the equation:</source>
          <target state="translated">미래 가치는 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="35263bdc6b8f9ed76c3ffddda6ddc106a35e30ef" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for arrays that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">이득은 상당하며 크기가 적당히 큰 어레이의 경우에도 확장이 합리적입니다. 어레이 생성 오버 헤드로 인해 기존 어레이를 사용하지 않는 호출과 비교할 때 이득이 훨씬 더 큽니다.</target>
        </trans-unit>
        <trans-unit id="f54d15f1fff04aaad23c1e30a6699255a7286273" translate="yes" xml:space="preserve">
          <source>The gains are substantial and the scaling is reasonable even for large that are only moderately large. The gains are even larger when compared to a call that does not use an existing array due to array creation overhead.</source>
          <target state="translated">이득은 상당하며 규모가 적당히 큰 경우에도 스케일링이 합리적입니다. 어레이 생성 오버 헤드로 인해 기존 어레이를 사용하지 않는 호출에 비해 이득이 훨씬 큽니다.</target>
        </trans-unit>
        <trans-unit id="3a2348245b14000fc86ba9addf452f0058449713" translate="yes" xml:space="preserve">
          <source>The general concept of broadcasting is also available from Python using the &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt;&lt;code&gt;broadcast&lt;/code&gt;&lt;/a&gt; iterator. This object takes</source>
          <target state="translated">브로드 캐스트의 일반적인 개념은 브로드 &lt;a href=&quot;generated/numpy.broadcast#numpy.broadcast&quot;&gt; &lt;code&gt;broadcast&lt;/code&gt; &lt;/a&gt; 반복자를 사용하여 Python에서도 사용할 수 있습니다 . 이 개체는</target>
        </trans-unit>
        <trans-unit id="a9641437007836c208f74db848ac79bd7c6780e6" translate="yes" xml:space="preserve">
          <source>The generated file will have the following content:</source>
          <target state="translated">생성 된 파일의 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a2d632f87330613da9716d5bfa0297beb555f76a" translate="yes" xml:space="preserve">
          <source>The generated header &lt;code&gt;_cpu_dispatch.h&lt;/code&gt; contains all the definitions and headers of instruction-sets for the required optimizations that have been validated during the previous step.</source>
          <target state="translated">생성 된 헤더 &lt;code&gt;_cpu_dispatch.h&lt;/code&gt; 에는 이전 단계에서 검증 된 필수 최적화에 대한 명령어 세트의 모든 정의와 헤더가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="49bcb642346cc566dc284f1407822db3afdb919f" translate="yes" xml:space="preserve">
          <source>The generated header takes the name of the dispatch-able source after excluding the extension and replace it with &amp;lsquo;&lt;strong&gt;.h&lt;/strong&gt;&amp;rsquo;, for example assume we have a dispatch-able source called &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; and contains the following:</source>
          <target state="translated">생성 된 헤더는 확장자를 제외한 후 디스패치 가능 소스의 이름을 취하고이를 ' &lt;strong&gt;.h&lt;/strong&gt; '로 &lt;strong&gt;바꿉니다. 예&lt;/strong&gt; 를 들어 &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; 라는 디스패치 가능 소스 가 있고 다음을 포함 한다고 가정 합니다.</target>
        </trans-unit>
        <trans-unit id="1a1433c2f9219adfdc1717ee54946e456e115a63" translate="yes" xml:space="preserve">
          <source>The generated random samples</source>
          <target state="translated">생성 된 랜덤 샘플</target>
        </trans-unit>
        <trans-unit id="770d667a086582311721a20b1950124d0ed2b0b8" translate="yes" xml:space="preserve">
          <source>The generic hierarchical type objects convert to corresponding type objects according to the associations:</source>
          <target state="translated">일반 계층 유형 오브젝트는 연관에 따라 해당 유형 오브젝트로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="7b9da9a1e497b53c1498ef8728ff28c753a44590" translate="yes" xml:space="preserve">
          <source>The given decorator is applied to all public methods of &lt;code&gt;cls&lt;/code&gt; that are matched by the regular expression &lt;code&gt;testmatch&lt;/code&gt; (&lt;code&gt;testmatch.search(methodname)&lt;/code&gt;). Methods that are private, i.e. start with an underscore, are ignored.</source>
          <target state="translated">주어진 데코레이터는 정규식 &lt;code&gt;testmatch&lt;/code&gt; ( &lt;code&gt;testmatch.search(methodname)&lt;/code&gt; ) 와 일치하는 모든 공개 &lt;code&gt;cls&lt;/code&gt; 메소드에 적용됩니다 . 개인용 (즉, 밑줄로 시작) 메소드는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d15ec8784a28b893c0b85001548e5baae80372c7" translate="yes" xml:space="preserve">
          <source>The gradient is computed using second order accurate central differences in the interior points and either first or second order accurate one-sides (forward or backwards) differences at the boundaries. The returned gradient hence has the same shape as the input array.</source>
          <target state="translated">구배는 내부 점에서의 2 차 정확한 중심 차이 및 경계에서의 1 차 또는 2 차 정확한 단측 (앞 또는 뒤로) 차이를 사용하여 계산된다. 반환 된 그래디언트는 입력 배열과 모양이 같습니다.</target>
        </trans-unit>
        <trans-unit id="a65f99b3266fd22231848816001d9a126ae0a24e" translate="yes" xml:space="preserve">
          <source>The graph has a strange shape from January 24th to February 1st. It would be interesing to know where this data comes from. If we look at the &lt;code&gt;locations&lt;/code&gt; array we extracted from the &lt;code&gt;.csv&lt;/code&gt; file, we can see that we have two columns, where the first would contain regions and the second would contain the name of the country. However, only the first few rows contain data for the the first column (province names in China). Following that, we only have country names. So it would make sense to group all the data from China into a single row. For this, we&amp;rsquo;ll select from the &lt;code&gt;nbcases&lt;/code&gt; array only the rows for which the second entry of the &lt;code&gt;locations&lt;/code&gt; array corresponds to China. Next, we&amp;rsquo;ll use the &lt;a href=&quot;../reference/generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt; function to sum all the selected rows (&lt;code&gt;axis=0&lt;/code&gt;):</source>
          <target state="translated">그래프는 1 월 24 일부터 2 월 1 일까지 이상한 모양입니다. 이 데이터의 출처를 아는 것은 흥미로울 것입니다. 우리가 보면 &lt;code&gt;locations&lt;/code&gt; 우리가에서 추출한 배열 &lt;code&gt;.csv&lt;/code&gt; 파일, 우리는 우리가 처음이 지역을 포함하는 것이며, 두 번째는 국가의 이름을 포함 할 두 개의 열을 가지고 있음을 알 수있다. 그러나 처음 몇 행에만 첫 번째 열 (중국의 성 이름)에 대한 데이터가 포함됩니다. 그 다음에는 국가 이름 만 있습니다. 따라서 중국의 모든 데이터를 단일 행으로 그룹화하는 것이 합리적입니다. 이를 위해 &lt;code&gt;nbcases&lt;/code&gt; 배열에서 &lt;code&gt;locations&lt;/code&gt; 배열 의 두 번째 항목이 중국에 해당하는 행만 선택합니다 . 다음으로 &lt;a href=&quot;../reference/generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; 을&lt;/a&gt; 사용합니다 .선택한 모든 행을 합산하는 함수 ( &lt;code&gt;axis=0&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="2b74e85f5516f60e3dbf421bf49f69c39506c265" translate="yes" xml:space="preserve">
          <source>The greatest common divisor</source>
          <target state="translated">최대 공약수</target>
        </trans-unit>
        <trans-unit id="1335775c2defd62ddac3bf62f622a970f395fc71" translate="yes" xml:space="preserve">
          <source>The greatest common divisor of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">입력 절대 값의 최대 공약수 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="1ffad58d21fbb0c889485660c6a73c057db064f2" translate="yes" xml:space="preserve">
          <source>The header file &amp;lt;numpy/halffloat.h&amp;gt; provides functions to work with IEEE 754-2008 16-bit floating point values. While this format is not typically used for numerical computations, it is useful for storing values which require floating point but do not need much precision. It can also be used as an educational tool to understand the nature of floating point round-off error.</source>
          <target state="translated">헤더 파일 &amp;lt;numpy / halffloat.h&amp;gt;는 IEEE 754-2008 16 비트 부동 소수점 값과 작동하는 기능을 제공합니다. 이 형식은 일반적으로 숫자 계산에 사용되지 않지만 부동 소수점은 필요하지만 정밀도는 많이 필요하지 않은 값을 저장하는 데 유용합니다. 부동 소수점 반올림 오류의 특성을 이해하기위한 교육 도구로도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d730bb14ffcab30f2844567d44182ca5b3af1815" translate="yes" xml:space="preserve">
          <source>The header of a typical SciPy &lt;code&gt;__init__.py&lt;/code&gt; is:</source>
          <target state="translated">일반적인 SciPy &lt;code&gt;__init__.py&lt;/code&gt; 의 헤더 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="881c9d2e47b4057e556e6ff5df02bfb9e5dee04c" translate="yes" xml:space="preserve">
          <source>The highest precision data type of the same kind (&lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt;&lt;code&gt;dtype.kind&lt;/code&gt;&lt;/a&gt;) as &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;t&lt;/code&gt; 와 동일한 종류 ( &lt;a href=&quot;numpy.dtype.kind#numpy.dtype.kind&quot;&gt; &lt;code&gt;dtype.kind&lt;/code&gt; &lt;/a&gt; ) 의 최고 정밀도 데이터 형식입니다 .</target>
        </trans-unit>
        <trans-unit id="f28aa2c9365c3014c1b3133bf8c0527b1b6cd92f" translate="yes" xml:space="preserve">
          <source>The hyperbolic cosine describes the shape of a hanging cable:</source>
          <target state="translated">쌍곡 코사인은 매달린 케이블의 모양을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5dfe11baf5c84767b263b0b9280dd1d13ec6b531" translate="yes" xml:space="preserve">
          <source>The hypotenuse of the triangle(s). This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">삼각형의 빗변. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="b1216f6dc1a8f133c88cabe04669f3d387166a72" translate="yes" xml:space="preserve">
          <source>The idea is to consider all but the first &lt;code&gt;k&lt;/code&gt; singular values in &lt;code&gt;Sigma&lt;/code&gt; (which are the same as in &lt;code&gt;s&lt;/code&gt;) as zeros, keeping &lt;code&gt;U&lt;/code&gt; and &lt;code&gt;Vt&lt;/code&gt; intact, and computing the product of these matrices as the approximation.</source>
          <target state="translated">아이디어는 &lt;code&gt;Sigma&lt;/code&gt; 에서 처음 &lt;code&gt;k&lt;/code&gt; 개의 특이 값을 제외한 모든 값 ( &lt;code&gt;s&lt;/code&gt; 에서와 동일 함 )을 0으로 간주하고 &lt;code&gt;U&lt;/code&gt; 와 &lt;code&gt;Vt&lt;/code&gt; 를 그대로 유지하고 이러한 행렬의 곱을 근사값으로 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a77669c9a72d14b0f58a0186d231f3894219b608" translate="yes" xml:space="preserve">
          <source>The identity array is a square array with ones on the main diagonal.</source>
          <target state="translated">항등 배열은 주 대각선을 가진 정사각형 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2bf1c25d751d392b46c1da854b9e2214e84ecbda" translate="yes" xml:space="preserve">
          <source>The identity value.</source>
          <target state="translated">아이덴티티 값.</target>
        </trans-unit>
        <trans-unit id="a3a4e04cbf529a826b2105546fd57be959a238a1" translate="yes" xml:space="preserve">
          <source>The imaginary component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">복잡한 주장의 허구 적 구성 요소. 경우 &lt;code&gt;val&lt;/code&gt; 진짜의 종류 &lt;code&gt;val&lt;/code&gt; 출력에 사용됩니다. &lt;code&gt;val&lt;/code&gt; 에 복잡한 요소가 있으면 반환 된 유형은 float입니다.</target>
        </trans-unit>
        <trans-unit id="7286bf711b04d53845d16cb5a31eaaaaa02757bf" translate="yes" xml:space="preserve">
          <source>The imaginary part of the array.</source>
          <target state="translated">배열의 허수 부.</target>
        </trans-unit>
        <trans-unit id="9bc674154d61adacb44dda1d44c441449cdf2af6" translate="yes" xml:space="preserve">
          <source>The imaginary part of the masked array.</source>
          <target state="translated">마스크 배열의 허수 부.</target>
        </trans-unit>
        <trans-unit id="bd9a2e20c2b901c483b54cb2f5a477f6cf2e7630" translate="yes" xml:space="preserve">
          <source>The imaginary part of the scalar.</source>
          <target state="translated">스칼라의 허수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="fd6e842a69d72f29a0581eb97a936eaef8759475" translate="yes" xml:space="preserve">
          <source>The implementation of the tests that produce this information.</source>
          <target state="translated">이 정보를 생성하는 테스트 구현.</target>
        </trans-unit>
        <trans-unit id="aee088812e30b5da0a5df1b95d7c39c9c1258247" translate="yes" xml:space="preserve">
          <source>The implementations of multiplication, division, integration, and differentiation use the algebraic identities &lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;:</source>
          <target state="translated">곱셈, 나눗셈, 적분, 미분의 구현은 대수적 정체성을 사용합니다 &lt;a href=&quot;#r3f3efff98d00-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="1e2ea421bf4e67c223dedefb366e2029ced79732" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. If &lt;code&gt;weights&lt;/code&gt; is complex, the imaginary parts are ignored.</source>
          <target state="translated">평균 계산에서 각 요소의 중요성. 가중치 배열은 1 차원 (이 경우 길이는 주어진 축의 크기 여야 함 )이거나 &lt;code&gt;a&lt;/code&gt; 와 같은 모양 일 &lt;code&gt;a&lt;/code&gt; 있습니다. &lt;code&gt;weights=None&lt;/code&gt; 인 경우 &lt;code&gt;a&lt;/code&gt; 의 모든 데이터 는 가중치가 1과 같다고 가정합니다. &lt;code&gt;weights&lt;/code&gt; 가 복잡한 경우 허수 부분은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8b1442547658f9bd4727b8dd9df733953ec22b3e" translate="yes" xml:space="preserve">
          <source>The importance that each element has in the computation of the average. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="translated">평균 계산에서 각 요소가 갖는 중요성. 가중치 어레이 중 1-D (이 경우 그 길이의 크기 여야 할 수 로서 소정 축을 따라) 또는 동일한 형상 &lt;code&gt;a&lt;/code&gt; . 경우 &lt;code&gt;weights=None&lt;/code&gt; 다음의 모든 데이터 &lt;code&gt;a&lt;/code&gt; 가중치를 갖는 것으로 가정되지 않은 한 동일. 1-D 계산은 다음과 같습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0f3bacce4854001ee5a2b2337e74219eceafb03" translate="yes" xml:space="preserve">
          <source>The include statement is inserted just before the wrapper functions. This feature enables using arbitrary C functions (defined in &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt;) in F2PY generated wrappers.</source>
          <target state="translated">include 문은 래퍼 함수 바로 앞에 삽입됩니다. 이 기능을 사용하면 F2PY 생성 래퍼에서 임의의 C 함수 ( &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt; 에 정의 됨 )를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e99cfec9384fa0ceb0f339e2c89b3b94a829c5f" translate="yes" xml:space="preserve">
          <source>The included BitGenerators are:</source>
          <target state="translated">포함 된 BitGenerator는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="22391c7101fab8760afe729b1932a0c59fad5983" translate="yes" xml:space="preserve">
          <source>The included generators can be used in parallel, distributed applications in one of three ways:</source>
          <target state="translated">포함 된 생성기는 다음 세 가지 방법 중 하나로 병렬 분산 응용 프로그램에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d9680eef1c6da704d4a94f1afb86f59c497487e" translate="yes" xml:space="preserve">
          <source>The index array consisting of the values 3, 3, 1 and 8 correspondingly create an array of length 4 (same as the index array) where each index is replaced by the value the index array has in the array being indexed.</source>
          <target state="translated">값 3, 3, 1 및 8로 구성된 인덱스 배열은 길이 4 (인덱스 배열과 동일)의 배열을 생성합니다. 여기서 각 인덱스는 인덱스 배열에서 인덱스 배열이 갖는 값으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="c31840bf8111dd67b394647308aa4678f4427cf3" translate="yes" xml:space="preserve">
          <source>The index is tracked by the iterator object itself, and accessible through the &lt;code&gt;index&lt;/code&gt; or &lt;code&gt;multi_index&lt;/code&gt; properties, depending on what was requested. The examples below show printouts demonstrating the progression of the index:</source>
          <target state="translated">인덱스는 반복기 객체 자체에 의해 추적되며 요청 된 항목에 따라 &lt;code&gt;index&lt;/code&gt; 또는 &lt;code&gt;multi_index&lt;/code&gt; 속성을 통해 액세스 할 수 있습니다 . 아래 예는 색인의 진행 상황을 보여주는 인쇄물을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="b00c25ebce056fd05b5bde5e2e04470c497a8460" translate="yes" xml:space="preserve">
          <source>The index syntax is very powerful but limiting when dealing with a variable number of indices. For example, if you want to write a function that can handle arguments with various numbers of dimensions without having to write special case code for each number of possible dimensions, how can that be done? If one supplies to the index a tuple, the tuple will be interpreted as a list of indices. For example (using the previous definition for the array z):</source>
          <target state="translated">인덱스 구문은 매우 강력하지만 다양한 수의 인덱스를 처리 할 때 제한적입니다. 예를 들어, 가능한 차원 수마다 특별한 코드를 작성하지 않고도 다양한 차원의 인수를 처리 할 수있는 함수를 작성하려는 경우 어떻게 수행 할 수 있습니까? 인덱스에 튜플을 제공하면 튜플은 인덱스 목록으로 해석됩니다. 예를 들어 (배열 z에 대한 이전 정의 사용) :</target>
        </trans-unit>
        <trans-unit id="2c2a3bfa2d0e12fb3599b918fb58fa555ca8de7c" translate="yes" xml:space="preserve">
          <source>The indexed result.</source>
          <target state="translated">인덱스 결과.</target>
        </trans-unit>
        <trans-unit id="03743182a2227ccf2811c37150a243244da1cf36" translate="yes" xml:space="preserve">
          <source>The indexing works on the flattened target array. &lt;a href=&quot;#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt; is roughly equivalent to:</source>
          <target state="translated">인덱싱은 평탄화 된 대상 배열에서 작동합니다. &lt;a href=&quot;#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; 은 대략 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="59838ac2347062b68deb1ef0e067a09f0f1f12f7" translate="yes" xml:space="preserve">
          <source>The indices can be used as an index into an array.</source>
          <target state="translated">인덱스는 배열에 대한 인덱스로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="41bdc266e504f1b3636c2cdbc5a9368b53208f9c" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array.</source>
          <target state="translated">삼각형의 인덱스. 반환 된 튜플에는 배열의 한 차원을 따라 인덱스가있는 두 개의 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="083f53a10046b877a4d17cdf8a047cadb142a0a5" translate="yes" xml:space="preserve">
          <source>The indices for the triangle. The returned tuple contains two arrays, each with the indices along one dimension of the array. Can be used to slice a ndarray of shape(&lt;code&gt;n&lt;/code&gt;, &lt;code&gt;n&lt;/code&gt;).</source>
          <target state="translated">삼각형의 인덱스. 반환 된 튜플에는 배열의 한 차원을 따라 인덱스가있는 두 개의 배열이 포함됩니다. 모양의 ndarray ( &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; ) 를 슬라이스하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="313bb1645ee0bcc96011930b78001b8efa601b2f" translate="yes" xml:space="preserve">
          <source>The indices of first and last non-masked value in the array. Returns None if all values are masked.</source>
          <target state="translated">배열에서 마스크되지 않은 첫 번째 값과 마지막 값의 인덱스입니다. 모든 값이 마스크 된 경우 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="02de7d9422fcf4d3bd70015e02df12b6de819fce" translate="yes" xml:space="preserve">
          <source>The indices of the current iteration.</source>
          <target state="translated">현재 반복의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="caeefd07d81c974d4f02d2a7cd29c00df5d3e970" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar1&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar1&lt;/code&gt; 의 공통 값이 처음 나타나는 인덱스입니다 . &lt;code&gt;return_indices&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="d03a2050722c8950165a7a42c8f8fbec16c8b478" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the common values in &lt;code&gt;ar2&lt;/code&gt;. Only provided if &lt;code&gt;return_indices&lt;/code&gt; is True.</source>
          <target state="translated">&lt;code&gt;ar2&lt;/code&gt; 의 공통 값이 처음 나타나는 인덱스입니다 . &lt;code&gt;return_indices&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="dba5b2feac59133a263255144aa942786b75991f" translate="yes" xml:space="preserve">
          <source>The indices of the first occurrences of the unique values in the original array. Only provided if &lt;code&gt;return_index&lt;/code&gt; is True.</source>
          <target state="translated">원래 배열에서 고유 한 값이 처음 나타나는 인덱스입니다. &lt;code&gt;return_index&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="a4f376a3994ea66b3e8fe543f1059936c2c097d7" translate="yes" xml:space="preserve">
          <source>The indices of the matched values can be obtained with &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">일치하는 값의 인덱스는 &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 값으로 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="43a87c99c2b28bd6cf46e8003a99b97203e9c8c1" translate="yes" xml:space="preserve">
          <source>The indices of the values to extract.</source>
          <target state="translated">추출 할 값의 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="6ca413808a0cb47ebd7eb463c61ac12f6ed3fe9d" translate="yes" xml:space="preserve">
          <source>The indices to reconstruct the original array from the unique array. Only provided if &lt;code&gt;return_inverse&lt;/code&gt; is True.</source>
          <target state="translated">고유 한 배열에서 원래 배열을 재구성하는 인덱스입니다. &lt;code&gt;return_inverse&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="76cdf05ced9d0285381afd071b2e4305a0c8b8a1" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays whose dimensions are the same as arr.</source>
          <target state="translated">인덱스는 치수가 arr과 동일한 정사각형 배열에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="b73635c48b132fb2b59a6aa95f3cc03ac517b9fa" translate="yes" xml:space="preserve">
          <source>The indices will be valid for square arrays.</source>
          <target state="translated">인덱스는 정사각형 배열에 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2408a7bae27e18b5f16ce6bfc6c2e9edbdf96e75" translate="yes" xml:space="preserve">
          <source>The info dict contains the necessary options to use the C library.</source>
          <target state="translated">정보 사전에는 C 라이브러리를 사용하는 데 필요한 옵션이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a162a1581bd9df0f0c132b54dd0bc2b023b7fbc" translate="yes" xml:space="preserve">
          <source>The initialized generator object.</source>
          <target state="translated">초기화 된 생성기 개체입니다.</target>
        </trans-unit>
        <trans-unit id="b17807d1d3d4b02432b9a563a71fb115959130d3" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; as a float ndarray.</source>
          <target state="translated">플로트 ndarray로 입력 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="223b4394f2d166cb77455c12d7788790c3301749" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;a&lt;/code&gt; in Fortran, or column-major, order.</source>
          <target state="translated">Fortran 또는 열 주요 순서 의 입력 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75fd22e41868bea41cd02857931f82382a569f45" translate="yes" xml:space="preserve">
          <source>The input &lt;code&gt;seed&lt;/code&gt; is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">입력 &lt;code&gt;seed&lt;/code&gt; &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 에 의해 처리되어 키를 생성합니다. 카운터는 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="528560fa701c687c766a152165432c7d1064754a" translate="yes" xml:space="preserve">
          <source>The input array</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="c14ffcb4fd955aec9b7bdb6f4e9b85112587e6c8" translate="yes" xml:space="preserve">
          <source>The input array needs to be of integer dtype, otherwise a TypeError is raised:</source>
          <target state="translated">입력 배열은 정수 dtype이어야합니다. 그렇지 않으면 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="8ffb9fe9f3741ba95404f548e61803acdf79b642" translate="yes" xml:space="preserve">
          <source>The input array with invalid entries fixed.</source>
          <target state="translated">유효하지 않은 항목이있는 입력 배열이 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="729e431a614c3f0d0d957b108e3ad1877caf7dd5" translate="yes" xml:space="preserve">
          <source>The input array&amp;rsquo;s mask is modified by this function.</source>
          <target state="translated">이 함수에 의해 입력 배열의 마스크가 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="2bcc0bcc75499b8aa5923f648739bb1e1c9c5f2a" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">길이가 1 인 차원의 일부 또는 전부가 제거 된 입력 배열입니다. 이것은 항상 자체 또는으로보기 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9c1757f1f00139c3d32d32875dc4cdee7e7573b" translate="yes" xml:space="preserve">
          <source>The input array, but with all or a subset of the dimensions of length 1 removed. This is always &lt;code&gt;a&lt;/code&gt; itself or a view into &lt;code&gt;a&lt;/code&gt;. Note that if all axes are squeezed, the result is a 0d array and not a scalar.</source>
          <target state="translated">입력 배열이지만 길이 1 차원의 전체 또는 하위 집합이 제거되었습니다. 이것은 항상 자체 또는으로보기 . 모든 축이 압축되면 결과는 스칼라가 아닌 0d 배열입니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3b9eebd6f3c2dccb825ca1eb5d3b6fff39eb990c" translate="yes" xml:space="preserve">
          <source>The input array.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="a8dbbfb64079646cc26f949474f62f6d5a8bdb10" translate="yes" xml:space="preserve">
          <source>The input arrays are the coefficients (including any coefficients equal to zero) of the &amp;ldquo;numerator&amp;rdquo; (dividend) and &amp;ldquo;denominator&amp;rdquo; (divisor) polynomials, respectively.</source>
          <target state="translated">입력 배열은 각각 &quot;분자&quot;(배당) 및 &quot;분모&quot;(제수) 다항식의 계수 (0과 같은 계수 포함)입니다.</target>
        </trans-unit>
        <trans-unit id="a4fe0b89df27127c64e2d6a838fb7376eb328411" translate="yes" xml:space="preserve">
          <source>The input can be of any type and shape.</source>
          <target state="translated">입력은 임의의 유형 및 형상 일 수있다.</target>
        </trans-unit>
        <trans-unit id="0756c557e9cd622a4b4a6242d6e56ce5652e83a5" translate="yes" xml:space="preserve">
          <source>The input data type is preserved, list/tuple in means list/tuple out.</source>
          <target state="translated">입력 데이터 유형이 유지됩니다. list / tuple in은 list / tuple out을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="7e65fba32b4c379aee34d72564b929f364329962" translate="yes" xml:space="preserve">
          <source>The input data type. This can be a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; object or an object that is convertible to a &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 데이터 타입. 이것은이 될 수 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 객체 나에 변환 가능한 객체 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8769eb794f5a03165931ba8181e41168fd7a696f" translate="yes" xml:space="preserve">
          <source>The input domain.</source>
          <target state="translated">입력 도메인</target>
        </trans-unit>
        <trans-unit id="8cece683eb84b1c6561cdb1ebf8cbf9f503e743a" translate="yes" xml:space="preserve">
          <source>The input is expected to be in the form returned by &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, i.e. the real zero-frequency term followed by the complex positive frequency terms in order of increasing frequency. Since the discrete Fourier Transform of real input is Hermitian-symmetric, the negative frequency terms are taken to be the complex conjugates of the corresponding positive frequency terms.</source>
          <target state="translated">입력은 &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 형태 , 즉 주파수가 증가하는 순서로 복소수 양수 항이 따르는 실제 제로 주파수 항이됩니다. 실수 입력의 이산 푸리에 변환은 허미 시안-대칭이므로, 음의 주파수 항은 해당 양의 주파수 항의 복소 공액으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6f9750084d20ac908a43842756c2b861e3f42c50" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">입력 시드는 &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 에 의해 처리되어 전체 상태를 채 웁니다. 첫 번째 요소는 가장 중요한 비트 만 설정되도록 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="a8974905180f39b4ffd2915ed945588ac5ab3b98" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">입력 시드는 &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 에 의해 처리되어 두 값을 모두 생성합니다. 증분은 독립적으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="9c7b1d5b6198e399c073a141f7cd1b6b8febb604" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">입력 시드는 &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 에 의해 처리되어 처음 3 개의 값을 생성 한 다음 &lt;code&gt;SFC64&lt;/code&gt; 알고리즘이 혼합을 위해 몇 번 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="8d2a5838e3e88200b2eb57081e0d55983a6951c5" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to fill the whole state. The first element is reset such that only its most significant bit is set.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 전체 상태를 채 웁니다. 첫 번째 요소는 최상위 비트 만 설정되도록 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="b59429801bb072b95be274b2cab8c79cb4d9a0af" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate both values. The increment is not independently settable.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 두 값을 모두 생성합니다. 증분은 독립적으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="837326b6e18d83ecb217345cd40ecfada7f873f1" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the first 3 values, then the &lt;code&gt;SFC64&lt;/code&gt; algorithm is iterated a small number of times to mix.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 처음 3 개의 값을 생성 한 다음 &lt;code&gt;SFC64&lt;/code&gt; 알고리즘을 약간 반복하여 혼합합니다.</target>
        </trans-unit>
        <trans-unit id="df03e47997abce099faab26366e6f5795a2b583f" translate="yes" xml:space="preserve">
          <source>The input seed is processed by &lt;code&gt;SeedSequence&lt;/code&gt; to generate the key. The counter is set to 0.</source>
          <target state="translated">입력 시드는 &lt;code&gt;SeedSequence&lt;/code&gt; 에 의해 처리되어 키를 생성합니다. 카운터는 0으로 설정되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee2b41f2ea30e39cb3d7552711a0b3d766641ddc" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">입력은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 가 반환하는 것과 동일한 방식으로 정렬되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="9065e71c46c758a421d1a5608c4e7515cdea0b0c" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, i.e.,</source>
          <target state="translated">입력은 &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 것과 같은 방식으로 정렬되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="14cd4f07dbbafbca343da6b376f0bb96ca0ebb1e" translate="yes" xml:space="preserve">
          <source>The input should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. as for &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; for the final transformation axis, and as for &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt;&lt;code&gt;ifftn&lt;/code&gt;&lt;/a&gt; along all the other axes.</source>
          <target state="translated">에 의해 반환되는대로 입력은 동일한 방식으로 정렬되어야 &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 관해서 즉 &lt;a href=&quot;numpy.fft.irfft#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; 및에 대해, 최종 변환 축 &lt;a href=&quot;numpy.fft.ifftn#numpy.fft.ifftn&quot;&gt; &lt;code&gt;ifftn&lt;/code&gt; &lt;/a&gt; 모든 다른 축을 따라.</target>
        </trans-unit>
        <trans-unit id="44801963410659f1459e257160aa0d4b1ef39ba2" translate="yes" xml:space="preserve">
          <source>The input value(s).</source>
          <target state="translated">입력 값.</target>
        </trans-unit>
        <trans-unit id="519628f03d9ba5d6ae3260f3b709f32afd6fac80" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt;&lt;code&gt;fft2&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in the low-order corner of the two axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of both axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 입력 은 &lt;a href=&quot;numpy.fft.fft2#numpy.fft.fft2&quot;&gt; &lt;code&gt;fft2&lt;/code&gt; &lt;/a&gt; 에 의해 반환되는 것과 같은 방식으로 정렬되어야합니다 . 즉, 두 축의 하위 코너에 0 주파수에 대한 용어가 있어야합니다. 축, 축 중간의 나이 퀴 스트 주파수에 대한 항, 양 축의 후반에 음수 주파수 항이 감소하는 음수 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="572b4f9e26edc1e967cf68e0ade8b40ff905e225" translate="yes" xml:space="preserve">
          <source>The input, analogously to &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;, should be ordered in the same way as is returned by &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, i.e. it should have the term for zero frequency in all axes in the low-order corner, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 와 유사하게 입력 은 &lt;a href=&quot;numpy.fft.fftn#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; 에서 반환 된 것과 같은 방식으로 정렬되어야합니다 . 즉, 하위 코너의 모든 축에서 주파수가 0 인 용어, 모든 축의 전반에서 양의 주파수 용어가 있어야합니다. , 감소하는 음의 주파수 순으로 모든 축의 중간에있는 나이키 스트 주파수에 대한 항과 모든 축의 후반에 음의 주파수 항에 대한 항을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c971acf535ef1a0fc093a548ed92e5c2192bc129" translate="yes" xml:space="preserve">
          <source>The integer base(s) in which the log is taken.</source>
          <target state="translated">로그를 취하는 정수 밑입니다.</target>
        </trans-unit>
        <trans-unit id="700a52e4f937c0dcc3e7f0a408095f8426dc542f" translate="yes" xml:space="preserve">
          <source>The integer value of flags.</source>
          <target state="translated">플래그의 정수 값입니다.</target>
        </trans-unit>
        <trans-unit id="0d58354ed5e0735b3768fbb2adf71637dbdf3f49" translate="yes" xml:space="preserve">
          <source>The integration constants default to zero, but can be specified:</source>
          <target state="translated">적분 상수는 기본적으로 0이지만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8cfb0f4ba349fe08f791a3f4e9c32e0be770fb0" translate="yes" xml:space="preserve">
          <source>The intent directive, intent(out) is used to tell f2py that &lt;code&gt;c&lt;/code&gt; is an output variable and should be created by the interface before being passed to the underlying code. The intent(hide) directive tells f2py to not allow the user to specify the variable, &lt;code&gt;n&lt;/code&gt;, but instead to get it from the size of &lt;code&gt;a&lt;/code&gt;. The depend( &lt;code&gt;a&lt;/code&gt; ) directive is necessary to tell f2py that the value of n depends on the input a (so that it won&amp;rsquo;t try to create the variable n until the variable a is created).</source>
          <target state="translated">인 텐트 지시문 인 intent (out)는 &lt;code&gt;c&lt;/code&gt; 가 출력 변수이고 기본 코드로 전달되기 전에 인터페이스에 의해 생성되어야 함을 f2py에게 알리는 데 사용됩니다 . 사용자가 변수를 지정하는 것을 허용하지 의도 (숨기기) 지시어는 f2py을 알려줍니다 &lt;code&gt;n&lt;/code&gt; , 대신의 크기에서 그것을 얻을 수 . Depend ( &lt;code&gt;a&lt;/code&gt; ) 지시문은 n의 값이 입력 a에 의존한다는 것을 f2py에게 알리기 위해 필요합니다 (변수 a가 생성 될 때까지 변수 n을 생성하려고 시도하지 않습니다). &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fef0aef07474fa13f32cd7e44f96fd84d9e33ac9" translate="yes" xml:space="preserve">
          <source>The interface definition file (.pyf) is how you can fine-tune the interface between Python and Fortran. There is decent documentation for f2py found in the numpy/f2py/docs directory where-ever NumPy is installed on your system (usually under site-packages). There is also more information on using f2py (including how to use it to wrap C codes) at &lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt; under the &amp;ldquo;Interfacing With Other Languages&amp;rdquo; heading.</source>
          <target state="translated">인터페이스 정의 파일 (.pyf)은 Python과 Fortran 간의 인터페이스를 미세 조정할 수있는 방법입니다. 시스템에 NumPy가 설치된 numpy / f2py / docs 디렉토리 (보통 사이트 패키지 아래)에 f2py에 대한 적절한 문서가 있습니다. &lt;a href=&quot;https://scipy-cookbook.readthedocs.io&quot;&gt;https://scipy-cookbook.readthedocs.io&lt;/a&gt; 의 &quot;Interfacing With Other Languages&quot;제목 아래에 f2py 사용에 대한 자세한 정보 (C 코드를 래핑하는 데 사용하는 방법 포함)도 있습니다.</target>
        </trans-unit>
        <trans-unit id="a5987614ed3add49e80f0f100dd67a16f44fe90c" translate="yes" xml:space="preserve">
          <source>The interpolated values, same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">보간 된 값으로 &lt;code&gt;x&lt;/code&gt; 와 같은 모양 입니다.</target>
        </trans-unit>
        <trans-unit id="c7907bef880fafa82932152f51dbb34029c0604c" translate="yes" xml:space="preserve">
          <source>The inverse &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; is also known as &lt;code&gt;acos&lt;/code&gt; or cos^-1.</source>
          <target state="translated">역 &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;acos&lt;/code&gt; 또는 cos ^ -1 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="ec2dceba2b532e6fed6c11da573a946f40425e79" translate="yes" xml:space="preserve">
          <source>The inverse DFT is defined as</source>
          <target state="translated">역 DFT는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="8495a1f69fb848ed573ead2789554fd370f64138" translate="yes" xml:space="preserve">
          <source>The inverse Gaussian distribution was first studied in relationship to Brownian motion. In 1956 M.C.K. Tweedie used the name inverse Gaussian because there is an inverse relationship between the time to cover a unit distance and distance covered in unit time.</source>
          <target state="translated">역 가우시안 분포는 브라운 운동과 관련하여 처음 연구되었습니다. 1956 년 MCK Tweedie는 단위 거리를 커버하는 시간과 단위 시간을 커버하는 거리 사이에 역의 관계가 있기 때문에 역 가우시안이라는 이름을 사용했습니다.</target>
        </trans-unit>
        <trans-unit id="fa59414aa20d4f47a4881cb0d68d8dadceab9bea" translate="yes" xml:space="preserve">
          <source>The inverse cosine(s) of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array object is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 역 코사인 입니다. 경우에 &lt;code&gt;x&lt;/code&gt; 는 스칼라이고, 그렇다 &lt;code&gt;out&lt;/code&gt; 달리 배열 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="68560eb00ac6299a73ce699655a0c6fd4e05a46a" translate="yes" xml:space="preserve">
          <source>The inverse function.</source>
          <target state="translated">역함수.</target>
        </trans-unit>
        <trans-unit id="fe2bbafffa2c0c536b90659aca2befdd2f2ba17e" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic sine is also known as &lt;code&gt;asinh&lt;/code&gt; or &lt;code&gt;sinh^-1&lt;/code&gt;.</source>
          <target state="translated">역 쌍곡 사인은 &lt;code&gt;asinh&lt;/code&gt; 또는 &lt;code&gt;sinh^-1&lt;/code&gt; 로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a141e357fc6a95097873c345fcfc1ca43237a09" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent is also known as &lt;code&gt;atanh&lt;/code&gt; or &lt;code&gt;tanh^-1&lt;/code&gt;.</source>
          <target state="translated">역 쌍곡 탄젠트는 &lt;code&gt;atanh&lt;/code&gt; 또는 &lt;code&gt;tanh^-1&lt;/code&gt; 로도 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="553056619b9eeee97e1c078e300256a83649a37f" translate="yes" xml:space="preserve">
          <source>The inverse hyperbolic tangent(s) of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 역 쌍곡 탄젠트 입니다. 경우 &lt;code&gt;x&lt;/code&gt; 는 스칼라이었다 그렇습니다 &lt;code&gt;out&lt;/code&gt; 그렇지 않으면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="aed0ee03d4e87b9fedd1788aca12c58fdfb391c4" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="0b353ae768e12e71d0fa6bfe266dc15cf5490d90" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftn&quot;&gt;&lt;code&gt;fftn&lt;/code&gt;&lt;/a&gt;, the inverse &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">의 역 &lt;a href=&quot;#numpy.fft.fftn&quot;&gt; &lt;code&gt;fftn&lt;/code&gt; &lt;/a&gt; , 역 &lt;em&gt;N&lt;/em&gt; 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="c086c016e117d897d4f2eb057744861a76634688" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; 의 역함 .</target>
        </trans-unit>
        <trans-unit id="9c2cb38b9631386379f4eeff7af3bee02f4b9bd5" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="13314fd29e0fae4ac48c552fa0a549b05087d956" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 의 반대입니다 .</target>
        </trans-unit>
        <trans-unit id="ff66e88345498b6e91d7444ef284a6ddd3ab7bea" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;, i.e. the inverse of the n-dimensional FFT of real input.</source>
          <target state="translated">&lt;a href=&quot;#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 의 역 , 즉 실제 입력의 n 차원 FFT의 역.</target>
        </trans-unit>
        <trans-unit id="4d74143e09328ea010bc57b6540cfb8051fcdf5e" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 의 역 .</target>
        </trans-unit>
        <trans-unit id="9e5b2a4471d9b30f761353eccfa786e46a0a43ee" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; 의 역함 .</target>
        </trans-unit>
        <trans-unit id="f58d6b52f1a134a30d097dc36ab0b6c772a15466" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt;&lt;code&gt;cos&lt;/code&gt;&lt;/a&gt; so that, if &lt;code&gt;y = cos(x)&lt;/code&gt;, then &lt;code&gt;x = arccos(y)&lt;/code&gt;.</source>
          <target state="translated">의 역 &lt;a href=&quot;numpy.cos#numpy.cos&quot;&gt; &lt;code&gt;cos&lt;/code&gt; &lt;/a&gt; 되도록하는 경우 &lt;code&gt;y = cos(x)&lt;/code&gt; 다음 &lt;code&gt;x = arccos(y)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55a9d6743075a74b179dcc12407ef1436ea7bf25" translate="yes" xml:space="preserve">
          <source>The inverse of &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;. Although identical for even-length &lt;code&gt;x&lt;/code&gt;, the functions differ by one sample for odd-length &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; &lt;/a&gt; 의 역함 . 짝수 길이 &lt;code&gt;x&lt;/code&gt; 에 대해서는 동일하지만 함수는 홀수 &lt;code&gt;x&lt;/code&gt; 에 대해 하나의 샘플만큼 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="2b74e3f8abd785dde93a2e8dda9f5c04957251f7" translate="yes" xml:space="preserve">
          <source>The inverse of tan, so that if &lt;code&gt;y = tan(x)&lt;/code&gt; then &lt;code&gt;x = arctan(y)&lt;/code&gt;.</source>
          <target state="translated">tan의 역수이므로 &lt;code&gt;y = tan(x)&lt;/code&gt; 이면 &lt;code&gt;x = arctan(y)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7167a352b20dee7e079ce80d9af1a1aba672dc81" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT of real input.</source>
          <target state="translated">실수 입력 의 &lt;em&gt;n&lt;/em&gt; 차원 FFT의 역수 .</target>
        </trans-unit>
        <trans-unit id="c880c78696b367269e70a1f53424d9f97028c767" translate="yes" xml:space="preserve">
          <source>The inverse of the &lt;em&gt;n&lt;/em&gt;-dimensional FFT.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 차원 FFT 의 역수 .</target>
        </trans-unit>
        <trans-unit id="f53fd91fa9c77430f006f0266202a3482a70bbcc" translate="yes" xml:space="preserve">
          <source>The inverse of the one-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 1 차원 FFT의 역수.</target>
        </trans-unit>
        <trans-unit id="3905252dc05b002d9515309faf3f78f1dbb4c5f8" translate="yes" xml:space="preserve">
          <source>The inverse of the two-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 2 차원 FFT의 역수.</target>
        </trans-unit>
        <trans-unit id="80593089870dd83ea035aa88fb44d2f41784516a" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding entries of length one</source>
          <target state="translated">역 연산, 길이가 1 인 항목 추가</target>
        </trans-unit>
        <trans-unit id="3423775348fb08030d24725c90e7b0f2bd7d7c47" translate="yes" xml:space="preserve">
          <source>The inverse operation, adding singleton dimensions</source>
          <target state="translated">싱글 톤 치수를 추가하는 역 연산</target>
        </trans-unit>
        <trans-unit id="aa766ce77746577ed5c08c35ec888672cda564ff" translate="yes" xml:space="preserve">
          <source>The inverse operation, removing singleton dimensions</source>
          <target state="translated">싱글 톤 치수를 제거하는 역 연산</target>
        </trans-unit>
        <trans-unit id="61a85cd6779e9d5a8b6211c3c235036b15ffb999" translate="yes" xml:space="preserve">
          <source>The inverse sine is also known as &lt;code&gt;asin&lt;/code&gt; or sin^{-1}.</source>
          <target state="translated">역 사인은 &lt;code&gt;asin&lt;/code&gt; 또는 sin ^ {-1} 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="bfedf779c5c4bd6b17ab80b12a0d79168ab5aaa7" translate="yes" xml:space="preserve">
          <source>The inverse sine of each element in &lt;code&gt;x&lt;/code&gt;, in radians and in the closed interval &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; , 라디안 및 닫힌 간격 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; 의 각 요소에 대한 역 사인 값 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="07d977535bf5ffed042d449d14c2b30422676d24" translate="yes" xml:space="preserve">
          <source>The inverse sine(s) of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array object is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 역 사인 입니다. 경우에 &lt;code&gt;x&lt;/code&gt; 는 스칼라이고, 그렇다 &lt;code&gt;out&lt;/code&gt; 달리 배열 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="9c1a84044c9dab08c09d55a04b2b48623b8d59b6" translate="yes" xml:space="preserve">
          <source>The inverse tangent is also known as &lt;code&gt;atan&lt;/code&gt; or tan^{-1}.</source>
          <target state="translated">역 탄젠트는 &lt;code&gt;atan&lt;/code&gt; 또는 tan ^ {-1} 이라고도 합니다.</target>
        </trans-unit>
        <trans-unit id="6981525643a6c5c7fc9e1e7dde681f16ce56e65e" translate="yes" xml:space="preserve">
          <source>The inverse two-dimensional FFT.</source>
          <target state="translated">역 2 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="bdb5ead908952013fac6606928f3a4c8d7370b91" translate="yes" xml:space="preserve">
          <source>The irrational number &lt;code&gt;e&lt;/code&gt; is also known as Euler&amp;rsquo;s number. It is approximately 2.718281, and is the base of the natural logarithm, &lt;code&gt;ln&lt;/code&gt; (this means that, if</source>
          <target state="translated">비이성적 인 숫자 &lt;code&gt;e&lt;/code&gt; 는 오일러 숫자라고도합니다. 약 2.718281이며 자연 로그의 기초 인 &lt;code&gt;ln&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="3dd3b5ec09656689d6b02dda587489104a598f1e" translate="yes" xml:space="preserve">
          <source>The iterator flag &amp;ldquo;delay_bufalloc&amp;rdquo; is there to allow iterator-allocated reduction operands to exist together with buffering. When this flag is set, the iterator will leave its buffers uninitialized until it receives a reset, after which it will be ready for regular iteration. Here&amp;rsquo;s how the previous example looks if we also enable buffering.</source>
          <target state="translated">반복자 플래그&amp;ldquo;delay_bufalloc&amp;rdquo;는 반복자 할당 감소 피연산자가 버퍼링과 함께 존재할 수 있도록합니다. 이 플래그가 설정되면, 반복자는 재설정을 수신 할 때까지 버퍼를 초기화되지 않은 상태로두고 그 후에 정기적 인 반복을 준비합니다. 버퍼링을 활성화하면 이전 예제의 모습입니다.</target>
        </trans-unit>
        <trans-unit id="83edec37e4aaff5eef637f7c874f4dba22293c2c" translate="yes" xml:space="preserve">
          <source>The iterator holds a reference to iter</source>
          <target state="translated">반복자는 반복자에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="ffb4fa1555c6cc08c5edb304e11089604a5e4b03" translate="yes" xml:space="preserve">
          <source>The iterator layout is an internal detail, and user code only sees an incomplete struct.</source>
          <target state="translated">반복자 레이아웃은 내부 세부 사항이며 사용자 코드는 불완전한 구조체 만 보입니다.</target>
        </trans-unit>
        <trans-unit id="5cd3a081c57ba646ed11444a9ba92c76e9cd9145" translate="yes" xml:space="preserve">
          <source>The iterator object &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;, introduced in NumPy 1.6, provides many flexible ways to visit all the elements of one or more arrays in a systematic fashion. This page introduces some basic ways to use the object for computations on arrays in Python, then concludes with how one can accelerate the inner loop in Cython. Since the Python exposure of &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is a relatively straightforward mapping of the C array iterator API, these ideas will also provide help working with array iteration from C or C++.</source>
          <target state="translated">NumPy 1.6에 도입 된 반복자 객체 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 는 체계적인 방식으로 하나 이상의 배열의 모든 요소를 ​​방문 할 수있는 여러 가지 유연한 방법을 제공합니다. 이 페이지는 파이썬에서 배열에 대한 계산을 위해 객체를 사용하는 몇 가지 기본 방법을 소개 한 다음 Cython에서 내부 루프를 가속화하는 방법으로 마무리합니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 의 Python 노출은 C 배열 반복자 API의 비교적 간단한 매핑이므로 이러한 아이디어는 C 또는 C ++의 배열 반복 작업에 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="c7cde3e3f66c5a8b8cc8bfff4db276cc023c595e" translate="yes" xml:space="preserve">
          <source>The iterator uses NumPy&amp;rsquo;s casting rules to determine whether a specific conversion is permitted. By default, it enforces &amp;lsquo;safe&amp;rsquo; casting. This means, for example, that it will raise an exception if you try to treat a 64-bit float array as a 32-bit float array. In many cases, the rule &amp;lsquo;same_kind&amp;rsquo; is the most reasonable rule to use, since it will allow conversion from 64 to 32-bit float, but not from float to int or from complex to float.</source>
          <target state="translated">반복자는 NumPy의 캐스팅 규칙을 사용하여 특정 변환이 허용되는지 여부를 결정합니다. 기본적으로 '안전한'캐스팅이 적용됩니다. 예를 들어, 64 비트 부동 소수점 배열을 32 비트 부동 소수점 배열로 취급하려고하면 예외가 발생합니다. 대부분의 경우 'same_kind'규칙은 64 비트에서 32 비트 부동 소수점으로 변환 할 수 있지만 float에서 int로 또는 복소수에서 부동 소수점으로 변환 할 수 없으므로 사용하기에 가장 적합한 규칙입니다.</target>
        </trans-unit>
        <trans-unit id="cacf8c06cd15c0c88c5430d945ba0f2cf7ba5182" translate="yes" xml:space="preserve">
          <source>The ix_() function</source>
          <target state="translated">ix_ () 함수</target>
        </trans-unit>
        <trans-unit id="bfb129467dcc5458e92314d1dc23bfece4b4c9b2" translate="yes" xml:space="preserve">
          <source>The jump size is</source>
          <target state="translated">점프 크기는</target>
        </trans-unit>
        <trans-unit id="ce335f317c6680914a491bd8a7fe70c41740c803" translate="yes" xml:space="preserve">
          <source>The jump step is computed using a modified version of Matsumoto&amp;rsquo;s implementation of Horner&amp;rsquo;s method. The step polynomial is precomputed to perform 2**128 steps. The jumped state has been verified to match the state produced using Matsumoto&amp;rsquo;s original code.</source>
          <target state="translated">점프 단계는 Matsumoto의 Horner 방법 구현의 수정 된 버전을 사용하여 계산됩니다. 단계 다항식은 2 ** 128 단계를 수행하도록 미리 계산됩니다. 점프 된 상태는 Matsumoto의 원래 코드를 사용하여 생성 된 상태와 일치하는 것으로 확인되었습니다.</target>
        </trans-unit>
        <trans-unit id="342e9169764fb77c1b214a706155105da1218b49" translate="yes" xml:space="preserve">
          <source>The key should be either a string or a sequence of string corresponding to the fields used to join the array. An exception is raised if the &lt;code&gt;key&lt;/code&gt; field cannot be found in the two input arrays. Neither &lt;code&gt;r1&lt;/code&gt; nor &lt;code&gt;r2&lt;/code&gt; should have any duplicates along &lt;code&gt;key&lt;/code&gt;: the presence of duplicates will make the output quite unreliable. Note that duplicates are not looked for by the algorithm.</source>
          <target state="translated">키는 배열을 결합하는 데 사용되는 필드에 해당하는 문자열 또는 문자열 시퀀스 여야합니다. 두 개의 입력 배열에서 &lt;code&gt;key&lt;/code&gt; 필드를 찾을 수 없으면 예외가 발생 합니다. &lt;code&gt;r1&lt;/code&gt; 과 &lt;code&gt;r2&lt;/code&gt; 모두 &lt;code&gt;key&lt;/code&gt; 따라 중복 된 항목이 없어야합니다. 중복 항목이 있으면 출력이 매우 불안정 해집니다. 중복은 알고리즘에 의해 검색되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1697c380f1179f3bbb3a86f4d75a8de0b46efbc6" translate="yes" xml:space="preserve">
          <source>The keys are:</source>
          <target state="translated">열쇠는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e784f79f4b595daae262ce721526297b147bf52d" translate="yes" xml:space="preserve">
          <source>The keywords mainly represent the additional optimizations configured through &lt;code&gt;--cpu-dispatch&lt;/code&gt;, but it can also represent other options such as:</source>
          <target state="translated">키워드는 주로 &lt;code&gt;--cpu-dispatch&lt;/code&gt; 를 통해 구성된 추가 최적화를 나타내지 만 다음과 같은 다른 옵션을 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b094a8a56c283a1dca9080c127defb8dc7eabacc" translate="yes" xml:space="preserve">
          <source>The kind of integer data type to get information about.</source>
          <target state="translated">정보를 얻는 정수 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="41c3ca93d5f02dccd969da26a833b72af9110c68" translate="yes" xml:space="preserve">
          <source>The kwds argument holds a Python dictionary whose keys are the names of the keyword arguments and whose values are the corresponding keyword-argument values. This dictionary can be processed however you see fit. The easiest way to handle it, however, is to replace the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (args, format_string, addresses&amp;hellip;) function with a call to &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt;&lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt;&lt;/a&gt; (args, kwds, format_string, char *kwlist[], addresses&amp;hellip;). The kwlist parameter to this function is a &lt;code&gt;NULL&lt;/code&gt; -terminated array of strings providing the expected keyword arguments. There should be one string for each entry in the format_string. Using this function will raise a TypeError if invalid keyword arguments are passed in.</source>
          <target state="translated">kwds 인수는 키가 키워드 인수의 이름이고 값이 해당 키워드 인수 값인 Python 사전을 보유합니다. 이 사전은 처리 할 수 ​​있지만 적합하다고 생각합니다. 그러나이를 처리하는 가장 쉬운 방법은 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; (args, format_string, addresses&amp;hellip;) 함수를 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTupleAndKeywords&quot;&gt; &lt;code&gt;PyArg_ParseTupleAndKeywords&lt;/code&gt; &lt;/a&gt; (args, kwds, format_string, char * kwlist [], addresses&amp;hellip;)에 대한 호출로 바꾸는 것 입니다. 이 함수에 대한 kwlist 매개 변수 는 예상되는 키워드 인수를 제공 하는 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자열 배열입니다. format_string의 각 항목에 대해 하나의 문자열이 있어야합니다. 이 함수를 사용하면 잘못된 키워드 인수가 전달되면 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d80fbf99f1073ba593f4b530d71e8ae5f9ae88a1" translate="yes" xml:space="preserve">
          <source>The larger object to compare.</source>
          <target state="translated">비교할 더 큰 객체.</target>
        </trans-unit>
        <trans-unit id="3b1d6d882f09df5877abb8ef200d99a4552edbcc" translate="yes" xml:space="preserve">
          <source>The largest representable number.</source>
          <target state="translated">가장 큰 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="8c04ea0c745fb65e3a5c6b4d6a06693d11870a3e" translate="yes" xml:space="preserve">
          <source>The last dimension of the input array is converted into a structure, with number of field-elements equal to the size of the last dimension of the input array. By default all output fields have the input array&amp;rsquo;s dtype, but an output structured dtype with an equal number of fields-elements can be supplied instead.</source>
          <target state="translated">입력 배열의 마지막 차원은 입력 배열의 마지막 차원 크기와 동일한 필드 요소 수를 갖는 구조로 변환됩니다. 기본적으로 모든 출력 필드에는 입력 배열의 dtype이 있지만 동일한 수의 fields-elements가있는 출력 구조화 된 dtype이 대신 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2abbd596290a88e6d12f22ea12675111b689f0a9" translate="yes" xml:space="preserve">
          <source>The last is an instance of freezing a core dimension and can be used to improve ufunc performance</source>
          <target state="translated">마지막은 핵심 차원을 동결시키는 인스턴스이며 ufunc 성능을 향상시키는 데 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="64a2253d0a7bf7afbe6eb3cddc1d5520d0b0c60a" translate="yes" xml:space="preserve">
          <source>The last one giving only the first elements because of the extra dimension. Compare &lt;code&gt;rowsum.nonzero()&lt;/code&gt; to understand this example.</source>
          <target state="translated">추가 차원으로 인해 첫 번째 요소 만 제공하는 마지막 요소입니다. 이 예제를 이해하려면 &lt;code&gt;rowsum.nonzero()&lt;/code&gt; 를 비교하십시오 .</target>
        </trans-unit>
        <trans-unit id="d08df5e86170609b57051ef10f9fb3e1c3868c9f" translate="yes" xml:space="preserve">
          <source>The last thing that must be done to finish the extension module is to actually write the code that performs the desired functions. There are two kinds of functions: those that don&amp;rsquo;t accept keyword arguments, and those that do.</source>
          <target state="translated">확장 모듈을 완성하기 위해해야 ​​할 마지막 일은 실제로 원하는 기능을 수행하는 코드를 작성하는 것입니다. 두 가지 종류의 함수가 있습니다. 키워드 인수를 허용하지 않는 함수와 허용하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="d5e8d86c6819b2227ff0ab7cafe1755645c6727d" translate="yes" xml:space="preserve">
          <source>The last two are characteristics of ndarrays - in order to support things like array slicing. The complications of subclassing ndarray are due to the mechanisms numpy has to support these latter two routes of instance creation.</source>
          <target state="translated">마지막 두 가지는 배열 슬라이싱과 같은 것을 지원하기 위해 ndarray의 특성입니다. ndarray 서브 클래 싱의 복잡성은 numpy가이 두 가지 인스턴스 생성 경로를 지원해야하는 메커니즘 때문입니다.</target>
        </trans-unit>
        <trans-unit id="2e8784c819189f431349d4282dd8265432f3285b" translate="yes" xml:space="preserve">
          <source>The latter group of &lt;code&gt;{NAME}s&lt;/code&gt; corresponds to letters used in the array interface typestring specification.</source>
          <target state="translated">&lt;code&gt;{NAME}s&lt;/code&gt; 후자 그룹은 배열 인터페이스 유형 문자열 스펙에 사용 된 문자에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="376520c70f9d3809d519d1143cc58d7f446c8008" translate="yes" xml:space="preserve">
          <source>The leading organization of technical writers, &lt;a href=&quot;https://www.writethedocs.org/&quot;&gt;Write the Docs&lt;/a&gt;, holds conferences, hosts learning resources, and runs a Slack channel.</source>
          <target state="translated">기술 작가의 선두 조직인 &lt;a href=&quot;https://www.writethedocs.org/&quot;&gt;Write the Docs&lt;/a&gt; 는 컨퍼런스를 개최하고 학습 리소스를 주최하고 Slack 채널을 운영합니다.</target>
        </trans-unit>
        <trans-unit id="34445ad4113f33f26d89f86d8eb17d5993aa2b33" translate="yes" xml:space="preserve">
          <source>The leftmost and rightmost edges of the bins along each dimension (if not specified explicitly in the &lt;code&gt;bins&lt;/code&gt; parameters): &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt;. All values outside of this range will be considered outliers and not tallied in the histogram.</source>
          <target state="translated">각 차원을 따라 빈의 가장 왼쪽과 오른쪽 가장자리 ( &lt;code&gt;bins&lt;/code&gt; 매개 변수에 명시 적으로 지정되지 않은 경우 ) : &lt;code&gt;[[xmin, xmax], [ymin, ymax]]&lt;/code&gt; . 이 범위를 벗어나는 모든 값은 특이 치로 간주되며 히스토그램에서 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7a57cb0c41d71bfde5dfe132d9a4c3e502a05b10" translate="yes" xml:space="preserve">
          <source>The length of &lt;code&gt;condlist&lt;/code&gt; must correspond to that of &lt;code&gt;funclist&lt;/code&gt;. If one extra function is given, i.e. if &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt;, then that extra function is the default value, used wherever all conditions are false.</source>
          <target state="translated">의 길이 &lt;code&gt;condlist&lt;/code&gt; 은 의 일치해야합니다 &lt;code&gt;funclist&lt;/code&gt; . 하나의 추가 함수 &lt;code&gt;len(funclist) == len(condlist) + 1&lt;/code&gt; 예 : len (funclist) == len (condlist) + 1)가 제공 되면 해당 추가 함수가 기본값이며 모든 조건이 false 인 경우 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fda9f4dafa3b1f4f0bc8667197c7c2f74ba12e70" translate="yes" xml:space="preserve">
          <source>The length of docstring lines should be kept to 75 characters to facilitate reading the docstrings in text terminals.</source>
          <target state="translated">독 스트링 줄의 길이는 텍스트 터미널에서 독 스트링을 쉽게 읽을 수 있도록 75 자로 유지되어야합니다.</target>
        </trans-unit>
        <trans-unit id="081176014231d93ecc67e47d02d500051aeaedf5" translate="yes" xml:space="preserve">
          <source>The length of one element in bytes.</source>
          <target state="translated">한 요소의 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="74e1dfe5bb68b99490ab8db3a4549a897ab92285" translate="yes" xml:space="preserve">
          <source>The length of the list of integers. It is assumed safe to access &lt;em&gt;ptr&lt;/em&gt; [0] to &lt;em&gt;ptr&lt;/em&gt; [len-1].</source>
          <target state="translated">정수 목록의 길이입니다. &lt;em&gt;ptr&lt;/em&gt; [0]에서 &lt;em&gt;ptr&lt;/em&gt; [len-1] 에 액세스하는 것이 안전하다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="c7170d6904bad30d46bd752038c157844edf21e6" translate="yes" xml:space="preserve">
          <source>The length of the prefix and suffix strings are used to respectively align and wrap the output. An array is typically printed as:</source>
          <target state="translated">접두사 및 접미사 문자열의 길이는 각각 출력을 정렬하고 줄 바꿈하는 데 사용됩니다. 배열은 일반적으로 다음과 같이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="2a29e90467961f11261cb34c5ec7868485d4aa81" translate="yes" xml:space="preserve">
          <source>The length of the resulting strings</source>
          <target state="translated">결과 문자열의 길이</target>
        </trans-unit>
        <trans-unit id="bd80f84b161ca3d681912061b09ff3df6041ed39" translate="yes" xml:space="preserve">
          <source>The length of the returned string if &lt;code&gt;num&lt;/code&gt; is positive, or the length of the two&amp;rsquo;s complement if &lt;code&gt;num&lt;/code&gt; is negative, provided that &lt;code&gt;width&lt;/code&gt; is at least a sufficient number of bits for &lt;code&gt;num&lt;/code&gt; to be represented in the designated form.</source>
          <target state="translated">반환되는 문자열의 길이는 경우 &lt;code&gt;num&lt;/code&gt; 양수 또는 2의 보수의 길이 경우 &lt;code&gt;num&lt;/code&gt; 이 제공 음수 &lt;code&gt;width&lt;/code&gt; 의 비트 적어도 충분한 개수 &lt;code&gt;num&lt;/code&gt; 지정된 형태로 표현된다.</target>
        </trans-unit>
        <trans-unit id="f135e192b37267c7b20efc3238404265e3e1b9c0" translate="yes" xml:space="preserve">
          <source>The length of the scalar in bytes.</source>
          <target state="translated">스칼라의 길이 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="63e0949a7b519952c49eb749b0448baf6c2dcdf9" translate="yes" xml:space="preserve">
          <source>The length of the segment in bytes.</source>
          <target state="translated">바이트 단위의 세그먼트 길이</target>
        </trans-unit>
        <trans-unit id="b0af5a70b649c99b0be522e1c0ad6114744383d4" translate="yes" xml:space="preserve">
          <source>The length of the span is the range of a 64-bit integer times the length of the date or unit. For example, the time span for &amp;lsquo;W&amp;rsquo; (week) is exactly 7 times longer than the time span for &amp;lsquo;D&amp;rsquo; (day), and the time span for &amp;lsquo;D&amp;rsquo; (day) is exactly 24 times longer than the time span for &amp;lsquo;h&amp;rsquo; (hour).</source>
          <target state="translated">범위의 길이는 64 비트 정수의 범위에 날짜 또는 단위 길이를 곱한 값입니다. 예를 들어, 'W'(주)의 시간 범위는 'D'(일)의 시간 범위보다 정확히 7 배 길고 'D'(일)의 시간 범위는 시간 범위보다 정확히 24 배 길다 'h'(시간).</target>
        </trans-unit>
        <trans-unit id="c92e142a9e3623399b64df009d94b4d034da17ea" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 + 0*z**2 + 0*z + 0.</source>
          <target state="translated">위의 줄은 z ** 3 + 0 * z ** 2 + 0 * z + 0을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b578e5e67f3e586204e4994bbe5c88c656a6cae7" translate="yes" xml:space="preserve">
          <source>The line above represents z**3 - z/4</source>
          <target state="translated">위의 줄은 z ** 3-z / 4를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="cb5275e91dcecc0c6dc816bc9710e92658bd3377" translate="yes" xml:space="preserve">
          <source>The linear map &lt;code&gt;offset + scale*x&lt;/code&gt; that maps the domain &lt;code&gt;old&lt;/code&gt; to the domain &lt;code&gt;new&lt;/code&gt; is applied to the points &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;old&lt;/code&gt; 도메인을 &lt;code&gt;new&lt;/code&gt; 도메인에 매핑하는 선형 맵 &lt;code&gt;offset + scale*x&lt;/code&gt; 가 포인트 &lt;code&gt;x&lt;/code&gt; 에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="2428c8d989723853883bd2c4d45c041f6e455adf" translate="yes" xml:space="preserve">
          <source>The list &lt;code&gt;x&lt;/code&gt; contains 4 items, each which can be accessed individually:</source>
          <target state="translated">목록 &lt;code&gt;x&lt;/code&gt; 에는 4 개의 항목이 포함되어 있으며 각 항목은 개별적으로 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="647499d1a98b89607edcd5f783a0adb1c730bbde" translate="yes" xml:space="preserve">
          <source>The list of arrays from which the output elements are taken. It has to be of the same length as &lt;code&gt;condlist&lt;/code&gt;.</source>
          <target state="translated">출력 요소를 가져 오는 배열 목록입니다. &lt;code&gt;condlist&lt;/code&gt; 와 길이가 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="529e159ac14f2e5a4bfd821c54e94a56730b5c46" translate="yes" xml:space="preserve">
          <source>The list of conditions which determine from which array in &lt;code&gt;choicelist&lt;/code&gt; the output elements are taken. When multiple conditions are satisfied, the first one encountered in &lt;code&gt;condlist&lt;/code&gt; is used.</source>
          <target state="translated">선택 목록의 어떤 배열에서 출력 요소를 가져 &lt;code&gt;choicelist&lt;/code&gt; 를 결정하는 조건 목록입니다 . 여러 조건이 충족되면 &lt;code&gt;condlist&lt;/code&gt; 에서 처음 발견 된 조건 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a85b3c79db62cd35117edd96a90c46599648e8f3" translate="yes" xml:space="preserve">
          <source>The list of field names of a structured datatype can be found in the &lt;code&gt;names&lt;/code&gt; attribute of the dtype object:</source>
          <target state="translated">구조화 된 데이터 유형의 필드 이름 목록은 dtype 객체 의 &lt;code&gt;names&lt;/code&gt; 속성 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="92c329f0ce8c711e6636f92601cc50d421b9b226" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of masked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">슬라이스에서, 마스킹 요소의 각각에 대한 연속적인 영역 일 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="88a36ffbba49be32da3baf6bb43ea7e384cf3381" translate="yes" xml:space="preserve">
          <source>The list of slices, one for each continuous region of unmasked elements in &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">슬라이스의 목록에서 마스킹 요소들 각각에 대한 연속적인 영역 일 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a7251af1a3271825930cf9fcd1d817e4c55bd823" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">소스 목록에는 패턴 &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 함수 ( '소스 생성기')가 포함될 수 있습니다 . &lt;code&gt;funcname&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 소스가 생성되지 않습니다. 또한 모든 소스 생성기를 처리 한 후 &lt;code&gt;Extension&lt;/code&gt; 인스턴스에 소스가 없으면 확장 모듈이 빌드되지 않습니다. 이는 확장 모듈을 조건부로 정의하기 위해 권장되는 방법입니다. 소스 생성 기능에 의해 호출되는 &lt;code&gt;build_src&lt;/code&gt; 의 의 명령 &lt;code&gt;numpy.distutils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70ba9a25afcb1723906c4b12dfd6f0a126515e6c" translate="yes" xml:space="preserve">
          <source>The list of sources may contain functions (&amp;lsquo;source generators&amp;rsquo;) with a pattern &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return
&amp;lt;source(s) or None&amp;gt;&lt;/code&gt;. If &lt;code&gt;funcname&lt;/code&gt; returns &lt;code&gt;None&lt;/code&gt;, no sources are generated. And if the &lt;code&gt;Extension&lt;/code&gt; instance has no sources after processing all source generators, no extension module will be built. This is the recommended way to conditionally define extension modules. Source generator functions are called by the &lt;code&gt;build_src&lt;/code&gt; sub-command of &lt;code&gt;numpy.distutils&lt;/code&gt;.</source>
          <target state="translated">소스 목록에는 &lt;code&gt;def &amp;lt;funcname&amp;gt;(ext, build_dir): return &amp;lt;source(s) or None&amp;gt;&lt;/code&gt; 패턴이있는 함수 ( '소스 생성기')가 포함될 수 있습니다 . &lt;code&gt;funcname&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 을 반환 하면 소스가 생성되지 않습니다. 그리고 모든 소스 생성기를 처리 한 후 &lt;code&gt;Extension&lt;/code&gt; 인스턴스에 소스가 없으면 확장 모듈이 빌드되지 않습니다. 확장 모듈을 조건부로 정의하는 데 권장되는 방법입니다. 소스 생성 기능에 의해 호출되는 &lt;code&gt;build_src&lt;/code&gt; 의 의 하위 명령 &lt;code&gt;numpy.distutils&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e86e6b1dfd4d026f3bb365ed0394b538f40e1c2c" translate="yes" xml:space="preserve">
          <source>The location of the mode of the distribution. Default is 0.</source>
          <target state="translated">배포 모드의 위치입니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="c828d9667ddc1c799350af57ae54e489e27f09a4" translate="yes" xml:space="preserve">
          <source>The log base 10 of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array object is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 밑이 10 인 로그 입니다. 경우에 &lt;code&gt;x&lt;/code&gt; 는 스칼라이고, 그렇다 &lt;code&gt;out&lt;/code&gt; 달리 배열 객체가 반환된다.</target>
        </trans-unit>
        <trans-unit id="d10e6ebe0b7c221ce4f14d1d0c1caa877512f1e8" translate="yes" xml:space="preserve">
          <source>The log base 2 of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 밑이 2 인 로그 입니다. 경우 &lt;code&gt;x&lt;/code&gt; 는 스칼라, 그래서입니다 &lt;code&gt;out&lt;/code&gt; 그렇지 않으면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="87f861a99c70448b2c7eae628fc0d66e23cdacad" translate="yes" xml:space="preserve">
          <source>The log base &lt;code&gt;n&lt;/code&gt; of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 로그 밑수 &lt;code&gt;n&lt;/code&gt; 입니다 . 경우 &lt;code&gt;x&lt;/code&gt; 는 스칼라, 그래서입니다 &lt;code&gt;out&lt;/code&gt; 그렇지 않으면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e0bd870e67f108672284e786e066e2248a62a253" translate="yes" xml:space="preserve">
          <source>The log of the &lt;code&gt;x&lt;/code&gt; value(s). If &lt;code&gt;x&lt;/code&gt; was a scalar, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 값 의 로그입니다 . 경우 &lt;code&gt;x&lt;/code&gt; 는 스칼라, 그래서입니다 &lt;code&gt;out&lt;/code&gt; 그렇지 않으면 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f922a603661ce7b289c8f2d5dd79d3f8d12f2d5b" translate="yes" xml:space="preserve">
          <source>The log series distribution is frequently used to represent species richness and occurrence, first proposed by Fisher, Corbet, and Williams in 1943 [2]. It may also be used to model the numbers of occupants seen in cars [3].</source>
          <target state="translated">로그 계열 분포는 1943 년 Fisher, Corbet 및 Williams가 처음 제안한 종의 풍부함과 발생을 나타내는 데 자주 사용됩니다 [2]. 자동차에서 보이는 탑승자 수를 모델링하는 데 사용될 수도 있습니다 [3].</target>
        </trans-unit>
        <trans-unit id="23451df0ca8ba5d5bfbdca9cf8c2255b108c68ac" translate="yes" xml:space="preserve">
          <source>The logarithm to the base 10 of &lt;code&gt;x&lt;/code&gt;, element-wise. NaNs are returned where x is negative. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑이 10 인 로그는 요소 별입니다. x가 음수이면 NaN이 반환됩니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="4d6739be6bf6c7545bc1a71d692001820b9d7cac" translate="yes" xml:space="preserve">
          <source>The logic behind those functions in more than two dimensions can be strange.</source>
          <target state="translated">2 차원 이상에서 이러한 기능의 논리는 이상 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8615daefc462d9e38519ed036e0e283940da95b" translate="yes" xml:space="preserve">
          <source>The lower and upper range of the bins. If not provided, range is simply &lt;code&gt;(a.min(), a.max())&lt;/code&gt;. Values outside the range are ignored. The first element of the range must be less than or equal to the second. &lt;code&gt;range&lt;/code&gt; affects the automatic bin computation as well. While bin width is computed to be optimal based on the actual data within &lt;code&gt;range&lt;/code&gt;, the bin count will fill the entire range including portions containing no data.</source>
          <target state="translated">출력 함의 하한 및 상한 범위 제공되지 않으면 범위는 단순히 &lt;code&gt;(a.min(), a.max())&lt;/code&gt; 입니다. 범위를 벗어난 값은 무시됩니다. 범위의 첫 번째 요소는 두 번째보다 작거나 같아야합니다. &lt;code&gt;range&lt;/code&gt; 는 자동 빈 계산에도 영향을줍니다. &lt;code&gt;range&lt;/code&gt; 너비는 range 내의 실제 데이터를 기반으로 최적으로 계산되지만 구간 개수는 데이터가없는 부분을 포함하여 전체 범위를 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="6456e48a0250380ada9bfcdc5cd3014ca07e5eb0" translate="yes" xml:space="preserve">
          <source>The lower bound for the top 1% of the samples is :</source>
          <target state="translated">샘플의 상위 1 %에 대한 하한은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4e9276b72baca62196e481978e6fcfbd0f0274c3" translate="yes" xml:space="preserve">
          <source>The lower bound of the definite integral.</source>
          <target state="translated">명확한 적분의 하한.</target>
        </trans-unit>
        <trans-unit id="37caf12cbe44bfdef1d91bca2e93d01e775cf201" translate="yes" xml:space="preserve">
          <source>The lower bound of the integral. (Default: 0)</source>
          <target state="translated">적분의 하한. (기본값 : 0)</target>
        </trans-unit>
        <trans-unit id="a76f1d77a96a5b462f5fae8acc24fa2aae62620a" translate="yes" xml:space="preserve">
          <source>The lowest common multiple</source>
          <target state="translated">최저 공배수</target>
        </trans-unit>
        <trans-unit id="87d6bfa25ac3b02d4e51aa1f4135cd735f016c13" translate="yes" xml:space="preserve">
          <source>The lowest common multiple of the absolute value of the inputs This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">입력 절대 값의 최소 공배수 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="5279b869b28ed9fc7a9edd7c369e695d6cb90bbb" translate="yes" xml:space="preserve">
          <source>The main difference between &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; is that &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; operates in-place, while &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; returns a copy.</source>
          <target state="translated">주요 차이점 &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; 는&lt;/a&gt; 점이다 &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; 는&lt;/a&gt; 동안, 자리에서 작동 &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; 는&lt;/a&gt; 카피를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="6767713cd6108661a0803484e7289fe42459ebb5" translate="yes" xml:space="preserve">
          <source>The main feature of the &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module is the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, which is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;. The class, its attributes and methods are described in more details in the &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray class&lt;/a&gt; section.</source>
          <target state="translated">의 가장 큰 특징 &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈이다 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 의&lt;/a&gt; 클래스의 하위 클래스 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 이&lt;/a&gt; . 클래스, 속성 및 메소드는 &lt;a href=&quot;maskedarray.baseclass#maskedarray-baseclass&quot;&gt;MaskedArray 클래스&lt;/a&gt; 섹션 에 자세히 설명되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52a36a5301780b2d55c316deba861004a7e6a2e2" translate="yes" xml:space="preserve">
          <source>The main page for the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy Documentation&lt;/a&gt; lists several categories. The documents mentioned there live in different places.</source>
          <target state="translated">&lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;NumPy 문서&lt;/a&gt; 의 메인 페이지 에는 여러 범주가 나열되어 있습니다. 거기에 언급 된 문서는 다른 곳에 살고 있습니다.</target>
        </trans-unit>
        <trans-unit id="48a467f7e54add76d93e3f038ba1d5a3c08c31d6" translate="yes" xml:space="preserve">
          <source>The main routine for obtaining an array from any Python object that can be converted to an array is &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt;. This function is very flexible with many input arguments. Several macros make it easier to use the basic function. &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt;&lt;code&gt;PyArray_FROM_OTF&lt;/code&gt;&lt;/a&gt; is arguably the most useful of these macros for the most common uses. It allows you to convert an arbitrary Python object to an array of a specific builtin data-type ( &lt;em&gt;e.g.&lt;/em&gt; float), while specifying a particular set of requirements ( &lt;em&gt;e.g.&lt;/em&gt; contiguous, aligned, and writeable). The syntax is</source>
          <target state="translated">배열로 변환 할 수있는 모든 Python 객체에서 배열을 가져 오는 주요 루틴은 &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 입니다. 이 함수는 많은 입력 인수로 매우 유연합니다. 여러 매크로를 사용하면 기본 기능을 더 쉽게 사용할 수 있습니다. &lt;a href=&quot;../reference/c-api/array#c.PyArray_FROM_OTF&quot;&gt; &lt;code&gt;PyArray_FROM_OTF&lt;/code&gt; &lt;/a&gt; 는 가장 일반적인 용도로 이러한 매크로 중 가장 유용합니다. 임의의 Python 객체를 특정 내장 데이터 유형 ( &lt;em&gt;예 :&lt;/em&gt; float) 의 배열로 변환하는 동시에 특정 요구 사항 집합 ( &lt;em&gt;예 :&lt;/em&gt; 연속, 정렬 및 쓰기 가능) 을 지정할 수 있습니다. 구문은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a6437cd8dced244085d75f5d4ec1f2af95ca5d9" translate="yes" xml:space="preserve">
          <source>The main way to control how the sequences of strings we have read from the file are converted to other types is to set the &lt;code&gt;dtype&lt;/code&gt; argument. Acceptable values for this argument are:</source>
          <target state="translated">파일에서 읽은 문자열 시퀀스를 다른 유형으로 변환하는 방법을 제어하는 ​​주된 방법은 &lt;code&gt;dtype&lt;/code&gt; 인수 를 설정하는 것 입니다. 이 인수에 허용되는 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b863f0a577a40cd3794882f4e85002ecea6308b0" translate="yes" xml:space="preserve">
          <source>The mantissas &lt;code&gt;x1&lt;/code&gt; and twos exponents &lt;code&gt;x2&lt;/code&gt; are used to construct floating point numbers &lt;code&gt;x1 * 2**x2&lt;/code&gt;.</source>
          <target state="translated">가수 &lt;code&gt;x1&lt;/code&gt; 및 2 개의 지수 &lt;code&gt;x2&lt;/code&gt; 는 부동 소수점 숫자 &lt;code&gt;x1 * 2**x2&lt;/code&gt; 를 구성하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1288609b08eeb3cc92c01ebf371043c8f0d81962" translate="yes" xml:space="preserve">
          <source>The map &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; maps the first domain to the second.</source>
          <target state="translated">맵 &lt;code&gt;L(x) = offset + scale*x&lt;/code&gt; 는 첫 번째 도메인을 두 번째 도메인에 매핑합니다.</target>
        </trans-unit>
        <trans-unit id="fd5781bc4f89018e0fb9cd14ef3f3c125e3d74bb" translate="yes" xml:space="preserve">
          <source>The mapping function is defined by &lt;code&gt;off + scl*x&lt;/code&gt;.</source>
          <target state="translated">맵핑 기능은 &lt;code&gt;off + scl*x&lt;/code&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="f0d7698b06a0aedcc32f911c787189d531c3eac9" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 이 유효한 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 마스크가 손실됩니다 !</target>
        </trans-unit>
        <trans-unit id="813174aba4a83655c04e53a7f1ff5c50cdefaed0" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;ma.MaskedArray&lt;/code&gt;&lt;/a&gt; !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 이 유효한 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;ma.MaskedArray&lt;/code&gt; &lt;/a&gt; 가 아니면 마스크가 손실됩니다 !</target>
        </trans-unit>
        <trans-unit id="649d4874d06fb274533beb59f5f2cd10f5dc2b95" translate="yes" xml:space="preserve">
          <source>The mask is lost if &lt;code&gt;out&lt;/code&gt; is not a valid MaskedArray !</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 이 유효한 MaskedArray가 아닌 경우 마스크가 손실됩니다 !</target>
        </trans-unit>
        <trans-unit id="f9bf54dc7bd5e650858bf619f77da75fc06bf1f6" translate="yes" xml:space="preserve">
          <source>The mask of a masked array is accessible through its &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; attribute. We must keep in mind that a &lt;code&gt;True&lt;/code&gt; entry in the mask indicates an &lt;em&gt;invalid&lt;/em&gt; data.</source>
          <target state="translated">마스크 배열의 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt; 는 마스크 속성을 통해 액세스 할 수 있습니다 . 마스크 의 &lt;code&gt;True&lt;/code&gt; 항목은 &lt;em&gt;유효하지 않은&lt;/em&gt; 데이터를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="5f7d748f7e23f2629a7257e1d7501357c2ce872d" translate="yes" xml:space="preserve">
          <source>The mask of a masked array view is also a view rather than a copy</source>
          <target state="translated">마스킹 된 배열보기의 마스크는 복사본이 아닌보기이기도합니다.</target>
        </trans-unit>
        <trans-unit id="136b0641a8efd21e297d96cb868071b555117d7d" translate="yes" xml:space="preserve">
          <source>The masked arrays for which to compare fill values.</source>
          <target state="translated">채우기 값을 비교할 마스크 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6a7c669e8d49f546a924fb9ea3a27606961c98f7" translate="yes" xml:space="preserve">
          <source>The matmul function implements the semantics of the &lt;code&gt;@&lt;/code&gt; operator introduced in Python 3.5 following PEP465.</source>
          <target state="translated">matmul 함수는 PEP465 에 이어 Python 3.5에 도입 된 &lt;code&gt;@&lt;/code&gt; 연산자 의 의미를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="b0018603311d83d5ccf5c07dff4523d1ca410b48" translate="yes" xml:space="preserve">
          <source>The matrix class is a Python subclass of the ndarray and can be used as a reference for how to construct your own subclass of the ndarray. Matrices can be created from other matrices, strings, and anything else that can be converted to an &lt;code&gt;ndarray&lt;/code&gt; . The name &amp;ldquo;mat &amp;ldquo;is an alias for &amp;ldquo;matrix &amp;ldquo;in NumPy.</source>
          <target state="translated">행렬 클래스는 ndarray의 Python 하위 클래스이며 ndarray의 자체 하위 클래스를 구성하는 방법에 대한 참조로 사용할 수 있습니다. 행렬은 다른 행렬, 문자열 및 &lt;code&gt;ndarray&lt;/code&gt; 로 변환 할 수있는 다른 항목으로 만들 수 있습니다 . &amp;ldquo;mat&amp;rdquo;이라는 이름은 NumPy에서&amp;ldquo;matrix&amp;rdquo;의 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="5f8d7cfa51bd7c57bbf7e03577a1825ff994845e" translate="yes" xml:space="preserve">
          <source>The matrix of random values with shape given by &lt;code&gt;*args&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;*args&lt;/code&gt; 로 주어진 모양을 가진 임의의 값의 행렬 .</target>
        </trans-unit>
        <trans-unit id="608aa6eae8f7f68c13529cd8bd42452f015b4b90" translate="yes" xml:space="preserve">
          <source>The matrix product of the inputs. This is a scalar only when both x1, x2 are 1-d vectors.</source>
          <target state="translated">입력 값의 행렬 곱입니다. 이것은 x1, x2가 모두 1-d 벡터 인 경우에만 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="c658bc86aaba588a6a002ba9982fdea6c89bc9cc" translate="yes" xml:space="preserve">
          <source>The matrix whose condition number is sought.</source>
          <target state="translated">조건 번호를 찾는 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="c8c3ef8c7c85bd35de6e1deb7b50a36e856e51b4" translate="yes" xml:space="preserve">
          <source>The matrix, but as a (1, N) matrix if it had shape (N, 1).</source>
          <target state="translated">행렬이지만 모양이 (N, 1) 인 경우 (1, N) 행렬로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="d2f91514f11b147277135520b0867d5d6ef7f638" translate="yes" xml:space="preserve">
          <source>The maximum is equivalent to &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are nans, but it is faster and does proper broadcasting.</source>
          <target state="translated">x1과 x2가 모두 nans 인 경우 최대 값은 &lt;code&gt;np.where(x1 &amp;gt;= x2, x1, x2)&lt;/code&gt; 와 동일하지만 더 빠르며 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b9ec29a01437d2db772a9e55518ff6e61467f369" translate="yes" xml:space="preserve">
          <source>The maximum number of array arguments that can be used in functions.</source>
          <target state="translated">함수에서 사용할 수있는 배열 인수의 최대 수입니다.</target>
        </trans-unit>
        <trans-unit id="d4b71803b063354491818e9ff7d7f91cb1c1ba7e" translate="yes" xml:space="preserve">
          <source>The maximum number of dimensions allowed in arrays.</source>
          <target state="translated">배열에 허용되는 최대 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="aff70196c900f17cb2833a4c90eb4869b491b830" translate="yes" xml:space="preserve">
          <source>The maximum number of rows to read. Must not be used with skip_footer at the same time. If given, the value must be at least 1. Default is to read the entire file.</source>
          <target state="translated">읽을 최대 행 수입니다. skip_footer와 동시에 사용해서는 안됩니다. 주어진 경우 값은 1 이상이어야합니다. 기본값은 전체 파일을 읽는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd4584d425d2919fbb0f9bcabce0ec35c9487dde" translate="yes" xml:space="preserve">
          <source>The maximum number of unit in the last place for tolerance (see Notes). Default is 1.</source>
          <target state="translated">공차에 대한 마지막 위치의 최대 단위 수입니다 (주 참조). 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="3cded325e7f85dbd01c8e732779ef69a0c4dfb37" translate="yes" xml:space="preserve">
          <source>The maximum number of units in the last place that elements of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can differ. Default is 1.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 요소가 다를 수 있는 마지막 위치의 최대 단위 수입니다 . 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="4d9efaa03fd6ffe081e389f0039d71a839a20c3f" translate="yes" xml:space="preserve">
          <source>The maximum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">요소 별 최대 &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="9686cc88755d232ce34c0c727b2433fe545075f6" translate="yes" xml:space="preserve">
          <source>The maximum representable value.</source>
          <target state="translated">표현 가능한 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="0b24f05221f4af03e40635809a9e83b6c24ab35f" translate="yes" xml:space="preserve">
          <source>The maximum value along a given axis.</source>
          <target state="translated">주어진 축을 따라 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="fda69f03e934be306357e5eceaea53c34ff9559a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최대 값은 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="7815283b9ba6a866678fcbb140334dc5a033015a" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 주어진 축을 따라 배열의 최대 값입니다.</target>
        </trans-unit>
        <trans-unit id="d4de50ed13c4c863bfa3e8deacb7e5bde93f23df" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최대 값은 NaN을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="7ea2e2a635f47e2f3d7b25aa79029eb57056d0e6" translate="yes" xml:space="preserve">
          <source>The maximum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최대 값으로, NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="1062669c35965744b7646a80587bb754273c0111" translate="yes" xml:space="preserve">
          <source>The maximum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">출력 요소의 최대 값 빈 슬라이스에서 계산할 수 있도록 있어야합니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4217fb4da5a1a61065cf374f0d2db5e29f625661" translate="yes" xml:space="preserve">
          <source>The mean is a coordinate in N-dimensional space, which represents the location where samples are most likely to be generated. This is analogous to the peak of the bell curve for the one-dimensional or univariate normal distribution.</source>
          <target state="translated">평균은 샘플이 생성 될 가능성이 가장 높은 위치를 나타내는 N 차원 공간의 좌표입니다. 이것은 1 차원 또는 일 변량 정규 분포에 대한 종 곡선의 피크와 유사합니다.</target>
        </trans-unit>
        <trans-unit id="3afbef537c228c554c040f21270cfff32d76c2bc" translate="yes" xml:space="preserve">
          <source>The mean is normally calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">평균은 일반적으로 &lt;code&gt;x.sum() / N&lt;/code&gt; 으로 계산되며 , 여기서 &lt;code&gt;N = len(x)&lt;/code&gt; 입니다. 그러나 &lt;code&gt;ddof&lt;/code&gt; 가 지정되면 약수 &lt;code&gt;N - ddof&lt;/code&gt; 가 대신 사용됩니다. 표준 통계 실습에서 &lt;code&gt;ddof=1&lt;/code&gt; 은 가정 무한 모집단의 분산에 대한 편견 추정치를 제공합니다. &lt;code&gt;ddof=0&lt;/code&gt; 은 정규 분포 변수에 대한 분산의 최대 우도 추정값을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0055abb9b767358fbd1b30a2e475c3c5171aa230" translate="yes" xml:space="preserve">
          <source>The mean is typically calculated as &lt;code&gt;x.sum() / N&lt;/code&gt;, where &lt;code&gt;N = len(x)&lt;/code&gt;. If, however, &lt;code&gt;ddof&lt;/code&gt; is specified, the divisor &lt;code&gt;N - ddof&lt;/code&gt; is used instead. In standard statistical practice, &lt;code&gt;ddof=1&lt;/code&gt; provides an unbiased estimator of the variance of a hypothetical infinite population. &lt;code&gt;ddof=0&lt;/code&gt; provides a maximum likelihood estimate of the variance for normally distributed variables.</source>
          <target state="translated">평균은 일반적으로 &lt;code&gt;x.sum() / N&lt;/code&gt; 으로 계산되며 여기서 &lt;code&gt;N = len(x)&lt;/code&gt; 입니다. 그러나 &lt;code&gt;ddof&lt;/code&gt; 가 지정되면 제수 &lt;code&gt;N - ddof&lt;/code&gt; 가 대신 사용됩니다. 표준 통계 관행에서 &lt;code&gt;ddof=1&lt;/code&gt; 은 가상 무한 모집단의 분산에 대한 편향되지 않은 추정량을 제공합니다. &lt;code&gt;ddof=0&lt;/code&gt; 은 정규 분포 변수에 대한 분산의 최대 가능도 추정치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="6de47f27b421a49095ff1b82a99c964834e4c682" translate="yes" xml:space="preserve">
          <source>The mechanism we use to accomplish this goal may be unfamiliar for those who are not experienced with the cultural norms around free/open-source software development. We provide a summary here, and highly recommend that all Contributors additionally read &lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;Chapter 4: Social and Political Infrastructure&lt;/a&gt; of Karl Fogel&amp;rsquo;s classic &lt;em&gt;Producing Open Source Software&lt;/em&gt;, and in particular the section on &lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;Consensus-based Democracy&lt;/a&gt;, for a more detailed discussion.</source>
          <target state="translated">이 목표를 달성하기 위해 사용하는 메커니즘은 무료 / 오픈 소스 소프트웨어 개발에 대한 문화적 규범에 익숙하지 않은 사람들에게는 익숙하지 않을 수 있습니다. 여기에 요약을 제공하고 모든 기여자는 추가로 &lt;a href=&quot;http://producingoss.com/en/producingoss.html#social-infrastructure&quot;&gt;4 장 :&lt;/a&gt; Karl Fogel의 고전적인 &lt;em&gt;Producing 오픈 소스 소프트웨어&lt;/em&gt; 의 사회 및 정치 인프라 , 특히 &lt;a href=&quot;http://producingoss.com/en/producingoss.html#consensus-democracy&quot;&gt;합의 기반 민주주의&lt;/a&gt; 섹션을 읽어 더 자세한 논의를 할 것을 적극 권장합니다 .</target>
        </trans-unit>
        <trans-unit id="530a7cbb36983f7e2dde0f52c1c905d90e12e910" translate="yes" xml:space="preserve">
          <source>The mediator will engage with all the parties and seek a resolution that is satisfactory to all. Upon completion, the mediator will provide a report (vetted by all parties to the process) to the Committee, with recommendations on further steps. The Committee will then evaluate these results (whether satisfactory resolution was achieved or not) and decide on any additional action deemed necessary.</source>
          <target state="translated">중재자는 모든 당사자와 협력하여 모두에게 만족스러운 해결책을 모색합니다. 완료되면 중재자는 추가 단계에 대한 권장 사항과 함께 보고서 (프로세스의 모든 당사자가 검토 함)를위원회에 제공합니다. 그런 다음위원회는 이러한 결과를 평가하고 (만족스러운 해결책이 달성되었는지 여부) 필요하다고 간주되는 추가 조치를 결정할 것입니다.</target>
        </trans-unit>
        <trans-unit id="476855af021420263dd600a85590e6b055b087d3" translate="yes" xml:space="preserve">
          <source>The members are</source>
          <target state="translated">멤버들은</target>
        </trans-unit>
        <trans-unit id="f25c150719f0aed3ef8299c88981d255d24f240e" translate="yes" xml:space="preserve">
          <source>The members of this structure are</source>
          <target state="translated">이 구조의 멤버는</target>
        </trans-unit>
        <trans-unit id="a80fc0f190e501871954ac9917a55a8bb93998fb" translate="yes" xml:space="preserve">
          <source>The memmap object can be used anywhere an ndarray is accepted. Given a memmap &lt;code&gt;fp&lt;/code&gt;, &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; returns &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">memmap 객체는 ndarray가 허용되는 모든 곳에서 사용할 수 있습니다. memmap의 주어 &lt;code&gt;fp&lt;/code&gt; , &lt;code&gt;isinstance(fp, numpy.ndarray)&lt;/code&gt; 반환 &lt;code&gt;True&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="afefc9cb88d75583ea623e16ea1f8cf60770f93a" translate="yes" xml:space="preserve">
          <source>The memory layout of an advanced indexing result is optimized for each indexing operation and no particular memory order can be assumed.</source>
          <target state="translated">고급 인덱싱 결과의 메모리 레이아웃은 각 인덱싱 작업에 대해 최적화되며 특정 메모리 순서는 가정 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="76384eb2a7d5d22bbc5978606ad7f8f1173b53b8" translate="yes" xml:space="preserve">
          <source>The memory layout of structured datatypes allows fields at arbitrary byte offsets. This means the fields can be separated by padding bytes, their offsets can be non-monotonically increasing, and they can overlap.</source>
          <target state="translated">구조화 된 데이터 유형의 메모리 레이아웃은 임의의 바이트 오프셋에서 필드를 허용합니다. 이는 패딩 바이트로 필드를 분리 할 수 ​​있고 오프셋이 비단 조적으로 증가 할 수 있으며 겹칠 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="5905e557d4f8798f2a63eb67ada3f5b47bd6cef3" translate="yes" xml:space="preserve">
          <source>The memory model for an ndarray admits arbitrary strides in each dimension to advance to the next element of the array. Often, however, you need to interface with code that expects a C-contiguous or a Fortran-contiguous memory layout. In addition, an ndarray can be misaligned (the address of an element is not at an integral multiple of the size of the element) which can cause your program to crash (or at least work more slowly) if you try and dereference a pointer into the array data. Both of these problems can be solved by converting the Python object into an array that is more &amp;ldquo;well-behaved&amp;rdquo; for your specific usage.</source>
          <target state="translated">ndarray에 대한 메모리 모델은 배열의 다음 요소로 진행하기 위해 각 차원에서 임의의 보폭을 허용합니다. 그러나 종종 C- 연속 또는 포트란-연속 메모리 레이아웃을 예상하는 코드와 인터페이스해야합니다. 또한 ndarray가 잘못 정렬 될 수 있습니다 (요소의 주소가 요소 크기의 정수 배수가 아님). 배열 데이터. 이 두 가지 문제는 Python 객체를 특정 용도에 대해보다 &quot;잘 작동하는&quot;배열로 변환하여 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92b75295665b751d736ee479f2ab0aea99cdf067" translate="yes" xml:space="preserve">
          <source>The memory-mapped array.</source>
          <target state="translated">메모리 매핑 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="aca17bd9cdf5246e194be60887f21d5d2d2f6e20" translate="yes" xml:space="preserve">
          <source>The merged result.</source>
          <target state="translated">병합 된 결과.</target>
        </trans-unit>
        <trans-unit id="26a8810bfd14aaec21beb6c6ecd19faf3719cc1e" translate="yes" xml:space="preserve">
          <source>The metadata field can be set using any dictionary at data-type creation. NumPy currently has no uniform approach to propagating metadata; although some array operations preserve it, there is no guarantee that others will.</source>
          <target state="translated">메타 데이터 필드는 데이터 유형 생성시 모든 사전을 사용하여 설정할 수 있습니다. NumPy는 현재 메타 데이터 전파에 대한 통일 된 접근 방식이 없습니다. 일부 어레이 작업이이를 보존하지만 다른 작업이 보존된다는 보장은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b0b87bb043302905b55e9cdd6e1fad28731aa89a" translate="yes" xml:space="preserve">
          <source>The method &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; treats the &lt;code&gt;axis&lt;/code&gt; parameter similar to how &lt;a href=&quot;../generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;numpy.sort&lt;/code&gt;&lt;/a&gt; treats it. Each slice along the given axis is shuffled independently of the others. Compare the following example of the use of &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; to the above example of &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt; 메소드 는 &lt;a href=&quot;../generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;numpy.sort&lt;/code&gt; 가&lt;/a&gt; 처리 하는 방법과 유사하게 &lt;code&gt;axis&lt;/code&gt; 매개 변수를 처리합니다. 주어진 축을 따라 각 슬라이스는 다른 슬라이스와 독립적으로 섞입니다. 의 사용 다음 예 비교 &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt; 의 위의 예에 &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7df7fe557cb7d0b2f7c1ec9ba89a3700046e049a" translate="yes" xml:space="preserve">
          <source>The method should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">메소드는 조작 결과 또는 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 를&lt;/a&gt; 리턴해야합니다. 요청 된 조작이 구현되지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="a4edd76a8cc0cb5a2a3b89a3543cae8f78bd75ba" translate="yes" xml:space="preserve">
          <source>The method uses the following property for computation: let</source>
          <target state="translated">이 메소드는 계산에 다음 특성을 사용합니다. let</target>
        </trans-unit>
        <trans-unit id="8c60b9f793967b9c55fe7d2d399c3c3c894ad07d" translate="yes" xml:space="preserve">
          <source>The methods for randomly permuting a sequence are</source>
          <target state="translated">시퀀스를 무작위로 순열하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ad0d254fa1824d11c17af544fbf486dd80c358ac" translate="yes" xml:space="preserve">
          <source>The methods to estimate the optimal number of bins are well founded in literature, and are inspired by the choices R provides for histogram visualisation. Note that having the number of bins proportional to</source>
          <target state="translated">최적의 빈 수를 추정하는 방법은 문헌에 잘 나와 있으며 R이 히스토그램 시각화에 제공하는 선택에서 영감을 얻었습니다. 빈 개수에 비례하여</target>
        </trans-unit>
        <trans-unit id="3d7963e1ce4d80720f0895da566be576ac9149e1" translate="yes" xml:space="preserve">
          <source>The minimal data type.</source>
          <target state="translated">최소 데이터 유형</target>
        </trans-unit>
        <trans-unit id="24db4b82ce9f82692c92a9ac46d90c6b64d6bb97" translate="yes" xml:space="preserve">
          <source>The minimum is equivalent to &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; when neither x1 nor x2 are NaNs, but it is faster and does proper broadcasting.</source>
          <target state="translated">최소값은 &lt;code&gt;np.where(x1 &amp;lt;= x2, x1, x2)&lt;/code&gt; x1과 x2가 NaN이 아닌 경우 와 동일하지만 더 빠르고 적절한 브로드 캐스트를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="830a82f2ffde76e612c1dc506f1272bc14c9b4a2" translate="yes" xml:space="preserve">
          <source>The minimum of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 최소값은 요소 별입니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="f7a8e12ffb3a7b028e99ec9cbaae32de38a438d0" translate="yes" xml:space="preserve">
          <source>The minimum representable value.</source>
          <target state="translated">표현 가능한 최소값.</target>
        </trans-unit>
        <trans-unit id="78d2dd7cf3cdcedef397cc8cfe35854b295317af" translate="yes" xml:space="preserve">
          <source>The minimum value along a given axis.</source>
          <target state="translated">주어진 축을 따라 최소값.</target>
        </trans-unit>
        <trans-unit id="7e0b0cb52a1bf19ef3e6bff0be136a12d77ae7e7" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignores NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최소값은 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="d9e2b0a11e46ec4c3892cf8fdab488270aa4c95b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 주어진 축을 따라 배열의 최소값입니다.</target>
        </trans-unit>
        <trans-unit id="77d53ae61484ff6af896adddf96d0d76b8331b4b" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagates NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최소값은 NaN을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="f3f970ad0b31d892cafa6b5a21e637a9f0353aee" translate="yes" xml:space="preserve">
          <source>The minimum value of an array along a given axis, propagating any NaNs.</source>
          <target state="translated">주어진 축을 따라 배열의 최소값으로, NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="9ae224843f4578886c03cad9e1377c9c95d0f44e" translate="yes" xml:space="preserve">
          <source>The minimum value of an output element. Must be present to allow computation on empty slice. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">출력 요소의 최소값입니다. 빈 슬라이스에서 계산할 수 있도록 있어야합니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3270f0c455d0c0204b07f58b497a95a1d399a02b" translate="yes" xml:space="preserve">
          <source>The mode in which to open the file; the default is &amp;lsquo;r+&amp;rsquo;. In addition to the standard file modes, &amp;lsquo;c&amp;rsquo; is also accepted to mean &amp;ldquo;copy on write.&amp;rdquo; See &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt; for the available mode strings.</source>
          <target state="translated">파일을 여는 모드입니다. 기본값은 'r +'입니다. 표준 파일 모드 외에도 'c'는 &quot;기록 중 복사&quot;를 의미하는 것으로도 허용됩니다. 사용 가능한 모드 문자열 은 &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; &lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d437e19520a89179e90a54d1512529a938dad3c6" translate="yes" xml:space="preserve">
          <source>The mode should be one of:</source>
          <target state="translated">모드는 다음 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="2ec84546189af066d8b391b45bfecb14d0737c14" translate="yes" xml:space="preserve">
          <source>The modified Bessel function evaluated at each of the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">수정 된 Bessel 함수는 &lt;code&gt;x&lt;/code&gt; 의 각 요소에서 평가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="852847496df2ea03e82e7e539f1768f78993a6b8" translate="yes" xml:space="preserve">
          <source>The more common 2-parameter Weibull, including a scale parameter</source>
          <target state="translated">척도 모수를 포함하여보다 일반적인 2 모수 Weibull</target>
        </trans-unit>
        <trans-unit id="ec8c35dc12f2bc0af45e628c14f8329c8c69aba9" translate="yes" xml:space="preserve">
          <source>The most basic task that can be done with the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; is to visit every element of an array. Each element is provided one by one using the standard Python iterator interface.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 로 수행 할 수있는 가장 기본적인 작업 은 배열의 모든 요소를 ​​방문하는 것입니다. 각 요소는 표준 Python 반복자 인터페이스를 사용하여 하나씩 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d496ee7436ae1753a08460be49874cd0a97104de" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units.</source>
          <target state="translated">날짜 / 시간을 생성하는 가장 기본적인 방법은 ISO 8601 날짜 또는 날짜 / 시간 형식의 문자열입니다. 내부 스토리지 단위는 문자열 형식에서 자동으로 선택되며 &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;날짜 단위&lt;/a&gt; 또는 &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;시간 단위 &lt;/a&gt;일 수 있습니다 . 날짜 단위는 년 ( 'Y'), 월 ( 'M'), 주 ( 'W') 및 일 ( 'D')이며 시간 단위는 시간 ( 'h'), 분 ( 'm' ), 초 ( 's'), 밀리 초 ( 'ms') 및 추가 SI- 접두사 초 기반 단위입니다.</target>
        </trans-unit>
        <trans-unit id="3f0f24060330e42125d74f607b6b6b61511b55b5" translate="yes" xml:space="preserve">
          <source>The most basic way to create datetimes is from strings in ISO 8601 date or datetime format. The unit for internal storage is automatically selected from the form of the string, and can be either a &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;date unit&lt;/a&gt; or a &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;time unit&lt;/a&gt;. The date units are years (&amp;lsquo;Y&amp;rsquo;), months (&amp;lsquo;M&amp;rsquo;), weeks (&amp;lsquo;W&amp;rsquo;), and days (&amp;lsquo;D&amp;rsquo;), while the time units are hours (&amp;lsquo;h&amp;rsquo;), minutes (&amp;lsquo;m&amp;rsquo;), seconds (&amp;lsquo;s&amp;rsquo;), milliseconds (&amp;lsquo;ms&amp;rsquo;), and some additional SI-prefix seconds-based units. The datetime64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo;, in any combination of lowercase/uppercase letters, for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="translated">날짜 / 시간을 만드는 가장 기본적인 방법은 ISO 8601 날짜 또는 날짜 / 시간 형식의 문자열을 사용하는 것입니다. 내부 저장 단위는 문자열 형식에서 자동으로 선택되며 &lt;a href=&quot;#arrays-dtypes-dateunits&quot;&gt;날짜 단위&lt;/a&gt; 또는 &lt;a href=&quot;#arrays-dtypes-timeunits&quot;&gt;시간 단위 &lt;/a&gt;일 수 있습니다 . 날짜 단위는 년 ( 'Y'), 월 ( 'M'), 주 ( 'W'), 일 ( 'D')이고 시간 단위는시 ( 'h'), 분 ( 'm')입니다. ), 초 ( 's'), 밀리 초 ( 'ms') 및 일부 추가 SI 접두사 초 기반 단위. datetime64 데이터 유형은 &quot;Not A Time&quot;값에 대해 소문자 / 대문자 조합의 &quot;NAT&quot;문자열도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="66cbaf133a9d7fa2f2885d6f3bc9c4d230706591" translate="yes" xml:space="preserve">
          <source>The most common use of this function is to build a block matrix</source>
          <target state="translated">이 함수의 가장 일반적인 용도는 블록 행렬을 만드는 것입니다</target>
        </trans-unit>
        <trans-unit id="d15c9fb7581762b1e666994a9299d27d87d30396" translate="yes" xml:space="preserve">
          <source>The most natural way one can think of for boolean indexing is to use boolean arrays that have &lt;em&gt;the same shape&lt;/em&gt; as the original array:</source>
          <target state="translated">부울 인덱싱에 대해 생각할 수있는 가장 자연스러운 방법 은 원래 배열 &lt;em&gt;과 모양이 같은&lt;/em&gt; 부울 배열을 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="9781573736aca31c85fa33ce77a1caad972dd370" translate="yes" xml:space="preserve">
          <source>The most negative power of the base (2) consistent with there being no leading 0&amp;rsquo;s in the mantissa.</source>
          <target state="translated">가수 (mantissa)에 선행 0이없는 것과 일치하는베이스 (2)의 가장 부정적인 힘.</target>
        </trans-unit>
        <trans-unit id="fb15b7417ee56d15205cea48f990a823be057c87" translate="yes" xml:space="preserve">
          <source>The multidimensional histogram of sample x. See normed and weights for the different possible semantics.</source>
          <target state="translated">샘플 x의 다차원 히스토그램. 가능한 다른 의미론에 대해서는 표준 및 가중치를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8be5b73af053c4fe54ab6b95a4f36c70767b3576" translate="yes" xml:space="preserve">
          <source>The multinomial distribution is a multivariate generalization of the binomial distribution. Take an experiment with one of &lt;code&gt;p&lt;/code&gt; possible outcomes. An example of such an experiment is throwing a dice, where the outcome can be 1 through 6. Each sample drawn from the distribution represents &lt;code&gt;n&lt;/code&gt; such experiments. Its values, &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt;, represent the number of times the outcome was &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">다항 분포는 이항 분포의 다변량 일반화입니다. 가능한 &lt;code&gt;p&lt;/code&gt; 가지 결과 중 하나를 사용하여 실험 해보십시오 . 이러한 실험 예는 결과가 1 분포로부터 그려 각 샘플을 나타내는 제 통해 할 수있는 주사위 던지고 &lt;code&gt;n&lt;/code&gt; 이러한 실험. 그 값은 &lt;code&gt;X_i = [X_0, X_1, ..., X_p]&lt;/code&gt; , 결과가되는 횟수를 나타내는 &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e35df9de409e360898297beb49d42cda54d84d4" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Hermite polynomials in the form</source>
          <target state="translated">곱셈은 ​​Hermite 다항식의 재귀 관계를 형식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="5d48b11de72371fe59540d3a1093cd7c7ef9026d" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Laguerre polynomials in the form</source>
          <target state="translated">곱셈은 ​​Laguerre 다항식의 재귀 관계를 형식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1da9d21187f4507f9a0b400fa81210b7d7adb8cd" translate="yes" xml:space="preserve">
          <source>The multiplication uses the recursion relationship for Legendre polynomials in the form</source>
          <target state="translated">곱셈은 ​​Legendre 다항식의 재귀 관계를 형식으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="28fc83b7bf97d866e44dde49fafcb06224f49002" translate="yes" xml:space="preserve">
          <source>The multithreaded random number generator can be used to fill an array. The &lt;code&gt;values&lt;/code&gt; attributes shows the zero-value before the fill and the random value after.</source>
          <target state="translated">멀티 스레드 난수 생성기를 사용하여 배열을 채울 수 있습니다. &lt;code&gt;values&lt;/code&gt; 방송을 충전 후의 랜덤 값 전 제로 값 속성.</target>
        </trans-unit>
        <trans-unit id="b9bbb85b9ae78b76721288cfcfe9a4008f15e026" translate="yes" xml:space="preserve">
          <source>The multivariate hypergeometric distribution is a generalization of the hypergeometric distribution.</source>
          <target state="translated">다변량 초기 하 분포는 초기 하 분포의 일반화입니다.</target>
        </trans-unit>
        <trans-unit id="4747005456762b666a88180df9655da6422f2a03" translate="yes" xml:space="preserve">
          <source>The multivariate normal, multinormal or Gaussian distribution is a generalization of the one-dimensional normal distribution to higher dimensions. Such a distribution is specified by its mean and covariance matrix. These parameters are analogous to the mean (average or &amp;ldquo;center&amp;rdquo;) and variance (standard deviation, or &amp;ldquo;width,&amp;rdquo; squared) of the one-dimensional normal distribution.</source>
          <target state="translated">다변량 정규, 다 정규 또는 가우시안 분포는 1 차원 정규 분포를 더 높은 차원으로 일반화합니다. 이러한 분포는 평균 및 공분산 행렬로 지정됩니다. 이 모수는 1 차원 정규 분포의 평균 (평균 또는 &quot;중심&quot;) 및 분산 (표준 편차 또는 &quot;폭&quot;제곱)과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="a8b77cd2da64c5a2ad3fe22e334603fd46922d44" translate="yes" xml:space="preserve">
          <source>The mymethods must be an array (usually statically declared) of PyMethodDef structures which contain method names, actual C-functions, a variable indicating whether the method uses keyword arguments or not, and docstrings. These are explained in the next section. If you want to add constants to the module, then you store the returned value from Py_InitModule which is a module object. The most general way to add items to the module is to get the module dictionary using PyModule_GetDict(module). With the module dictionary, you can add whatever you like to the module manually. An easier way to add objects to the module is to use one of three additional Python C-API calls that do not require a separate extraction of the module dictionary. These are documented in the Python documentation, but repeated here for convenience:</source>
          <target state="translated">mymethods는 메서드 이름, 실제 C 함수, 메서드가 키워드 인수를 사용하는지 여부를 나타내는 변수 및 독 스트링을 포함하는 PyMethodDef 구조의 배열 (일반적으로 정적으로 선언 됨)이어야합니다. 이에 대해서는 다음 섹션에서 설명합니다. 모듈에 상수를 추가하려면 모듈 객체 인 Py_InitModule에서 반환 된 값을 저장합니다. 모듈에 항목을 추가하는 가장 일반적인 방법은 PyModule_GetDict (module)를 사용하여 모듈 사전을 가져 오는 것입니다. 모듈 사전을 사용하면 원하는 것을 모듈에 수동으로 추가 할 수 있습니다. 모듈에 객체를 추가하는 더 쉬운 방법은 모듈 사전을 별도로 추출 할 필요가없는 세 가지 추가 Python C-API 호출 중 하나를 사용하는 것입니다. 이것들은 Python 문서에 문서화되어 있지만 편의를 위해 여기에서 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="acd94e258d3a5164d9494ffb8bffe2f44669511c" translate="yes" xml:space="preserve">
          <source>The n-dimensional FFT.</source>
          <target state="translated">n 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="6c60f6d35e1563484077efd2da3ec7438c9b55d8" translate="yes" xml:space="preserve">
          <source>The n-dimensional array</source>
          <target state="translated">n 차원 배열</target>
        </trans-unit>
        <trans-unit id="3b220f6b818351a33b819aef741ffc069011f1f9" translate="yes" xml:space="preserve">
          <source>The n-dimensional inverse FFT.</source>
          <target state="translated">n 차원 역 FFT.</target>
        </trans-unit>
        <trans-unit id="1aa43b3f9d99cab445704b967fccc316e94d1d57" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt;&lt;code&gt;datetime64&lt;/code&gt;&lt;/a&gt;, which results in a &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;timedelta64&lt;/code&gt;&lt;/a&gt; output array.</source>
          <target state="translated">n 번째 차이. 출력의 모양은 차원이 &lt;code&gt;n&lt;/code&gt; 만큼 작은 &lt;code&gt;axis&lt;/code&gt; 따라가는 것을 제외하고 는 &lt;code&gt;a&lt;/code&gt; 와 동일 합니다 . 출력 유형은의 두 요소 간의 차이 유형과 동일 &lt;code&gt;a&lt;/code&gt; . 이 유형과 동일 대부분의 경우이다. 주목할만한 예외는 &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt; &lt;code&gt;datetime64&lt;/code&gt; &lt;/a&gt; 이며, 결과적으로 &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;timedelta64&lt;/code&gt; &lt;/a&gt; 출력 배열이 생성됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e1700cb4660502cb99b1ba6b83abc787863343a8" translate="yes" xml:space="preserve">
          <source>The n-th differences. The shape of the output is the same as &lt;code&gt;a&lt;/code&gt; except along &lt;code&gt;axis&lt;/code&gt; where the dimension is smaller by &lt;code&gt;n&lt;/code&gt;. The type of the output is the same as the type of the difference between any two elements of &lt;code&gt;a&lt;/code&gt;. This is the same as the type of &lt;code&gt;a&lt;/code&gt; in most cases. A notable exception is &lt;code&gt;datetime64&lt;/code&gt;, which results in a &lt;code&gt;timedelta64&lt;/code&gt; output array.</source>
          <target state="translated">n 번째 차이점. 출력의 모양과 동일 따라 제외 &lt;code&gt;axis&lt;/code&gt; 치수가 작아 인 &lt;code&gt;n&lt;/code&gt; . 출력 유형은 &lt;code&gt;a&lt;/code&gt; 의 두 요소 간 차이 유형과 동일 합니다 . 이 유형과 동일 대부분의 경우이다. 주목할만한 예외는 &lt;code&gt;datetime64&lt;/code&gt; 이며 &lt;code&gt;timedelta64&lt;/code&gt; 출력 배열이됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bbebdf33e8d96895ad0ed5b9400d54086fef2b67" translate="yes" xml:space="preserve">
          <source>The name &lt;code&gt;colors&lt;/code&gt; comes from a common description of the distribution: it is the probability distribution of the number of marbles of each color selected without replacement from an urn containing marbles of different colors; &lt;code&gt;colors[i]&lt;/code&gt; is the number of marbles in the urn with color &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">이름 &lt;code&gt;colors&lt;/code&gt; 은 분포에 대한 일반적인 설명에서 비롯됩니다. 이것은 다른 색상의 구슬이 들어있는 항아리에서 교체하지 않고 선택한 각 색상의 구슬 수에 대한 확률 분포입니다. &lt;code&gt;colors[i]&lt;/code&gt; 는 색상이 &lt;code&gt;i&lt;/code&gt; 인 항아리의 구슬 개수입니다 .</target>
        </trans-unit>
        <trans-unit id="0669ec99aeb2d5368091f67cb13b60ba81e67528" translate="yes" xml:space="preserve">
          <source>The name of an encoding</source>
          <target state="translated">인코딩 이름</target>
        </trans-unit>
        <trans-unit id="da19f645db8ba8aaf5c7216ec7214ec27975bb88" translate="yes" xml:space="preserve">
          <source>The name of each column, e.g. &lt;code&gt;('x', 'y', 'z')&lt;/code&gt;.</source>
          <target state="translated">각 열의 이름입니다 &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; 예 : ( 'x', 'y', 'z')) .</target>
        </trans-unit>
        <trans-unit id="a2c5edd467b851569da4a2dda38a270ee36e54ad" translate="yes" xml:space="preserve">
          <source>The name of the compiled python module</source>
          <target state="translated">컴파일 된 파이썬 모듈의 이름</target>
        </trans-unit>
        <trans-unit id="cdc28be1ffb28a0940808960df363c803c7e10be" translate="yes" xml:space="preserve">
          <source>The name of the file on disk. This may &lt;em&gt;not&lt;/em&gt; be a file-like object.</source>
          <target state="translated">디스크에있는 파일의 이름입니다. 이것은 파일과 같은 객체 가 &lt;em&gt;아닐&lt;/em&gt; 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9271935a282dc40ee28d57c245df327643e67b9" translate="yes" xml:space="preserve">
          <source>The name of the function comes from the acronym for &amp;lsquo;peak to peak&amp;rsquo;.</source>
          <target state="translated">함수의 이름은 '피크 투 피크'의 약어에서 비롯됩니다.</target>
        </trans-unit>
        <trans-unit id="d407bb92d1b152453450af784d89f7deb9d12336" translate="yes" xml:space="preserve">
          <source>The name of the function to be deprecated. Default is None, in which case the name of &lt;code&gt;func&lt;/code&gt; is used.</source>
          <target state="translated">더 이상 사용되지 않을 함수의 이름입니다. 기본값은 None이며,이 경우 &lt;code&gt;func&lt;/code&gt; 의 이름 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="557578e757afec167650b8145d79c9de1775e751" translate="yes" xml:space="preserve">
          <source>The name of the module to test.</source>
          <target state="translated">테스트 할 모듈의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="bb2cb1a8dd236bcfb532f7c48c470cce2101b1ff" translate="yes" xml:space="preserve">
          <source>The name of the polynomial variable</source>
          <target state="translated">다항식 변수의 이름</target>
        </trans-unit>
        <trans-unit id="48bd936a95b9da34fbbddac207b9c61cefe6e361" translate="yes" xml:space="preserve">
          <source>The name of the ufunc.</source>
          <target state="translated">ufunc의 이름입니다.</target>
        </trans-unit>
        <trans-unit id="8afcf394e9ae5bb9fa899425c9a8ba31df0dd746" translate="yes" xml:space="preserve">
          <source>The name sinc is short for &amp;ldquo;sine cardinal&amp;rdquo; or &amp;ldquo;sinus cardinalis&amp;rdquo;.</source>
          <target state="translated">sinc라는 이름은 &quot;사인 추기경&quot;또는 &quot;sinus cardinalis&quot;의 약어입니다.</target>
        </trans-unit>
        <trans-unit id="429822cfcff1010e8a45d7946ea2696aeb70a3d1" translate="yes" xml:space="preserve">
          <source>The names are ordered according to increasing byte offset. This can be used, for example, to walk through all of the named fields in offset order.</source>
          <target state="translated">바이트 오프셋 증가에 따라 이름이 정렬됩니다. 예를 들어, 이름 지정된 모든 필드를 오프셋 순서로 탐색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a9858df5c4f15a9862586b51516cf4a9f5358fd8" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;a href=&quot;../arrays.scalars#numpy.float_&quot;&gt;&lt;code&gt;numpy.float_&lt;/code&gt;&lt;/a&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">c 코드의 유형 이름은 c 명명 규칙을 더 가깝게 따릅니다. 이러한 유형의 Python 이름은 Python 규칙을 따릅니다. 따라서 &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 는 C에서 32 비트 부동 소수점을 선택하지만 Python의 &lt;a href=&quot;../arrays.scalars#numpy.float_&quot;&gt; &lt;code&gt;numpy.float_&lt;/code&gt; &lt;/a&gt; 는 64 비트 double에 해당합니다. 비트 너비 이름은 명확성을 위해 Python과 C 모두에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d89404c184de8cb612b9ba60ba8159aea12d80ca" translate="yes" xml:space="preserve">
          <source>The names for the types in c code follows c naming conventions more closely. The Python names for these types follow Python conventions. Thus, &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; picks up a 32-bit float in C, but &lt;code&gt;numpy.float_&lt;/code&gt; in Python corresponds to a 64-bit double. The bit-width names can be used in both Python and C for clarity.</source>
          <target state="translated">C 코드에서 유형의 이름은 c 명명 규칙을보다 밀접하게 따릅니다. 이러한 유형의 Python 이름은 Python 규칙을 따릅니다. 따라서 &lt;a href=&quot;#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 는 C에서 32 비트 부동 소수점을 선택하지만 Python의 &lt;code&gt;numpy.float_&lt;/code&gt; 는 64 비트 double에 해당합니다. 비트 폭 이름은 명확성을 위해 Python과 C 모두에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7042a6f0e554df217f55061c01efbcd355c420f8" translate="yes" xml:space="preserve">
          <source>The names of the fields are given with the &lt;code&gt;names&lt;/code&gt; arguments, the corresponding values with the &lt;code&gt;data&lt;/code&gt; arguments. If a single field is appended, &lt;code&gt;names&lt;/code&gt;, &lt;code&gt;data&lt;/code&gt; and &lt;code&gt;dtypes&lt;/code&gt; do not have to be lists but just values.</source>
          <target state="translated">필드의 &lt;code&gt;names&lt;/code&gt; 은 이름 인수 와 함께 제공되며 해당 값은 &lt;code&gt;data&lt;/code&gt; 인수 와 함께 제공 됩니다. 단일 필드가 추가되면 &lt;code&gt;names&lt;/code&gt; , &lt;code&gt;data&lt;/code&gt; 및 &lt;code&gt;dtypes&lt;/code&gt; 는 목록 일 필요가없고 값일뿐입니다.</target>
        </trans-unit>
        <trans-unit id="be2b0c55353c6ed87f255a0400693d129089b164" translate="yes" xml:space="preserve">
          <source>The native NumPy indexing type is &lt;code&gt;intp&lt;/code&gt; and may differ from the default integer array type. &lt;code&gt;intp&lt;/code&gt; is the smallest data type sufficient to safely index any array; for advanced indexing it may be faster than other types.</source>
          <target state="translated">기본 NumPy 인덱싱 유형은 &lt;code&gt;intp&lt;/code&gt; 이며 기본 정수 배열 유형과 다를 수 있습니다. &lt;code&gt;intp&lt;/code&gt; 는 배열을 안전하게 색인하기에 충분한 가장 작은 데이터 유형입니다. 고급 인덱싱의 경우 다른 유형보다 빠를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="762cb1cca826c6e2247cb37d4810072af245272b" translate="yes" xml:space="preserve">
          <source>The natural log of the absolute value of the determinant.</source>
          <target state="translated">결정 요인의 절대 값에 대한 자연 로그입니다.</target>
        </trans-unit>
        <trans-unit id="b3888cd1c7265c4b4a7bad4003632b69982812b1" translate="yes" xml:space="preserve">
          <source>The natural logarithm &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is the inverse of the exponential function, so that &lt;code&gt;log(exp(x)) = x&lt;/code&gt;. The natural logarithm is logarithm in base &lt;a href=&quot;../constants#numpy.e&quot;&gt;&lt;code&gt;e&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자연 &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 는 지수 함수의 역수이므로 &lt;code&gt;log(exp(x)) = x&lt;/code&gt; 입니다. 자연 로그는 밑 &lt;a href=&quot;../constants#numpy.e&quot;&gt; &lt;code&gt;e&lt;/code&gt; 의&lt;/a&gt; 로그입니다 .</target>
        </trans-unit>
        <trans-unit id="133131ae7b63a1c0b2c215fb536c3aee797a1a49" translate="yes" xml:space="preserve">
          <source>The natural logarithm of &lt;code&gt;x&lt;/code&gt;, element-wise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">요소 별 &lt;code&gt;x&lt;/code&gt; 의 자연 로그입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="79018bd215ed2a4de07a7be8acb4bd00eb575cb1" translate="yes" xml:space="preserve">
          <source>The nditer can no longer be iterated once either &lt;code&gt;close&lt;/code&gt; is called or its context is exited.</source>
          <target state="translated">&lt;code&gt;close&lt;/code&gt; 가 호출되거나 컨텍스트가 종료 되면 nditer를 더 이상 반복 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fba110cc07d7918f904cb2219cd75774f5e101fe" translate="yes" xml:space="preserve">
          <source>The nditer will then yield writeable buffer arrays which you may modify. However, because the nditer must copy this buffer data back to the original array once iteration is finished, you must signal when the iteration is ended, by one of two methods. You may either:</source>
          <target state="translated">그러면 nditer는 수정할 수있는 쓰기 가능한 버퍼 배열을 생성합니다. 그러나 nditer는 반복이 완료되면이 버퍼 데이터를 원래 배열로 다시 복사해야하므로 반복이 종료되면 두 가지 방법 중 하나로 신호를 보내야합니다. 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="36c9f1e0a0257851539d48df01a2ed2f053f22d7" translate="yes" xml:space="preserve">
          <source>The new array is formed from the data in the old array, repeated if necessary to fill out the required number of elements. The data are repeated in the order that they are stored in memory.</source>
          <target state="translated">새로운 배열은 기존 배열의 데이터로 구성되며 필요한 수의 요소를 채우는 데 필요한 경우 반복됩니다. 데이터는 메모리에 저장된 순서대로 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="a04e3c53d25194cf3b0ad0e57f30edc1bdcf03db" translate="yes" xml:space="preserve">
          <source>The new array will have a new last dimension equal in size to the number of field-elements of the input array. If not supplied, the output datatype is determined from the numpy type promotion rules applied to all the field datatypes.</source>
          <target state="translated">새 배열은 입력 배열의 필드 요소 수와 크기가 동일한 새 마지막 차원을 갖습니다. 제공되지 않는 경우 출력 데이터 유형은 모든 필드 데이터 유형에 적용된 numpy 유형 승격 규칙에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="f97568b5d149f57d8764f77c287f9f2fe46a132b" translate="yes" xml:space="preserve">
          <source>The new behavior as of Numpy 1.16 leads to extra &amp;ldquo;padding&amp;rdquo; bytes at the location of unindexed fields compared to 1.15. You will need to update any code which depends on the data having a &amp;ldquo;packed&amp;rdquo; layout. For instance code such as:</source>
          <target state="translated">Numpy 1.16의 새로운 동작은 1.15에 비해 인덱싱되지 않은 필드의 위치에 추가 &quot;패딩&quot;바이트를 발생시킵니다. &quot;패킹 된&quot;레이아웃을 가진 데이터에 의존하는 모든 코드를 업데이트해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 예를 들면 다음과 같은 코드입니다.</target>
        </trans-unit>
        <trans-unit id="1e027640aca67041dbf9c118ab74b0f73d41441e" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">새 인프라는 &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 개체 에서 난수를 생성하는 다른 접근 방식을 사용 합니다. 난수 생성은 비트 생성기와 난수 생성기의 두 가지 구성 요소로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="5d98e8d2c80f824b8ece662a9850103c0477cac7" translate="yes" xml:space="preserve">
          <source>The new infrastructure takes a different approach to producing random numbers from the &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; object. Random number generation is separated into two components, a bit generator and a random generator.</source>
          <target state="translated">새로운 인프라는 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 객체 에서 난수를 생성하는 다른 접근 방식을 취 합니다. 난수 생성은 비트 생성기와 임의 생성기의 두 가지 구성 요소로 구분됩니다.</target>
        </trans-unit>
        <trans-unit id="125105242ec81f06cd25f403baeb3cf1e8d9cd77" translate="yes" xml:space="preserve">
          <source>The new interface has docstring:</source>
          <target state="translated">새 인터페이스에는 독 스트링이 있습니다.</target>
        </trans-unit>
        <trans-unit id="86aae80fcd76b7ce0d8ebf83a57b3d06b3426d61" translate="yes" xml:space="preserve">
          <source>The new keyword argument interface and &lt;code&gt;excluded&lt;/code&gt; argument support further degrades performance.</source>
          <target state="translated">새로운 키워드 인수 인터페이스와 &lt;code&gt;excluded&lt;/code&gt; 인수 지원은 성능을 더욱 저하시킵니다.</target>
        </trans-unit>
        <trans-unit id="d86ea97e67bbca694f01bcdba7b94c4f6336cda1" translate="yes" xml:space="preserve">
          <source>The new name for the function. Default is None, in which case the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated. If given, the deprecation message is that &lt;code&gt;old_name&lt;/code&gt; is deprecated and &lt;code&gt;new_name&lt;/code&gt; should be used instead.</source>
          <target state="translated">함수의 새 이름입니다. 기본값은 None이며,이 경우 더 이상 사용되지 않는 메시지는 &lt;code&gt;old_name&lt;/code&gt; 이 더 이상 사용되지 않는다는 것 입니다. 만약 주어지면, deprecation 메시지는 &lt;code&gt;old_name&lt;/code&gt; 은 deprecated되고 &lt;code&gt;new_name&lt;/code&gt; 은 대신 사용되어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="55a87f3b341973ae0ced92b1f1a3e3e7074aa9e8" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer is supplied, then the result will be a 1-D array of that length.</source>
          <target state="translated">새로운 모양은 원래 모양과 호환되어야합니다. 정수가 제공되면 결과는 해당 길이의 1 차원 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="691ae079d9ba62e9263b39950b26bbea5ce21d52" translate="yes" xml:space="preserve">
          <source>The new shape should be compatible with the original shape. If an integer, then the result will be a 1-D array of that length. One shape dimension can be -1. In this case, the value is inferred from the length of the array and remaining dimensions.</source>
          <target state="translated">새로운 모양은 원래 모양과 호환되어야합니다. 정수이면 결과는 해당 길이의 1 차원 배열이됩니다. 하나의 모양 차원은 -1 일 수 있습니다. 이 경우 값은 배열의 길이와 나머지 차원에서 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="5388ec77c34409cb3cbd101b8eec670a3d1a1fdf" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the major version number of the file format, e.g. &lt;code&gt;\x01&lt;/code&gt;.</source>
          <target state="translated">다음 1 바이트는 부호없는 바이트입니다. 파일 형식의 주 버전 번호입니다 (예 : &lt;code&gt;\x01&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="728636cfde682c4ca8ef5825e1a61b87b60f117f" translate="yes" xml:space="preserve">
          <source>The next 1 byte is an unsigned byte: the minor version number of the file format, e.g. &lt;code&gt;\x00&lt;/code&gt;. Note: the version of the file format is not tied to the version of the numpy package.</source>
          <target state="translated">다음 1 바이트는 부호없는 바이트입니다. 파일 형식의 부 버전 번호입니다 (예 : &lt;code&gt;\x00&lt;/code&gt; . 참고 : 파일 형식 버전은 numpy 패키지 버전과 연결되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="87a88c47d7bd9a05055f3613db15f890d4b10172" translate="yes" xml:space="preserve">
          <source>The next 2 bytes form a little-endian unsigned short int: the length of the header data HEADER_LEN.</source>
          <target state="translated">다음 2 바이트는 리틀 엔디안 부호없는 short int를 형성합니다. 헤더 데이터 길이 HEADER_LEN.</target>
        </trans-unit>
        <trans-unit id="c0777c38aebc3061e6b58d63a6472bc19821f955" translate="yes" xml:space="preserve">
          <source>The next HEADER_LEN bytes form the header data describing the array&amp;rsquo;s format. It is an ASCII string which contains a Python literal expression of a dictionary. It is terminated by a newline (&lt;code&gt;\n&lt;/code&gt;) and padded with spaces (&lt;code&gt;\x20&lt;/code&gt;) to make the total of &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; be evenly divisible by 64 for alignment purposes.</source>
          <target state="translated">다음 HEADER_LEN 바이트는 배열 형식을 설명하는 헤더 데이터를 형성합니다. 사전의 Python 리터럴 표현식을 포함하는 ASCII 문자열입니다. 줄 바꿈 ( &lt;code&gt;\n&lt;/code&gt; ) 으로 끝나고 공백 ( &lt;code&gt;\x20&lt;/code&gt; )으로 &lt;code&gt;len(magic string) + 2 + len(length) + HEADER_LEN&lt;/code&gt; 정렬 목적으로 len (magic string) + 2 + len (length) + HEADER_LEN의 합계 를 64로 균등하게 나눌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="af4ca037dcfe75d78dee9fbf52e144a1bd398782" translate="yes" xml:space="preserve">
          <source>The next floating point value after x1 towards x2</source>
          <target state="translated">x1 이후 x2를 향한 다음 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="82fde05cc761629191474fcaee36452854b7c17c" translate="yes" xml:space="preserve">
          <source>The next representable values of &lt;code&gt;x1&lt;/code&gt; in the direction of &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x2&lt;/code&gt; 방향으로 &lt;code&gt;x1&lt;/code&gt; 의 다음 표현 가능한 값 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="4935ecbe795efbe6b2d076bc80d266ef9b3d3b31" translate="yes" xml:space="preserve">
          <source>The next step depends on the type of index which was found. If all dimensions are indexed with an integer a scalar is returned or set. A single boolean indexing array will call specialized boolean functions. Indices containing an ellipsis or slice but no advanced indexing will always create a view into the old array by calculating the new strides and memory offset. This view can then either be returned or, for assignments, filled using &lt;code&gt;PyArray_CopyObject&lt;/code&gt;. Note that &lt;code&gt;PyArray_CopyObject&lt;/code&gt; may also be called on temporary arrays in other branches to support complicated assignments when the array is of object dtype.</source>
          <target state="translated">다음 단계는 찾은 색인 유형에 따라 다릅니다. 모든 차원이 정수로 색인화되면 스칼라가 리턴되거나 설정됩니다. 단일 부울 인덱싱 배열은 특수한 부울 함수를 호출합니다. 줄임표 나 슬라이스를 포함하지만 고급 인덱싱은 포함하지 않은 인덱스는 항상 새로운 보폭과 메모리 오프셋을 계산하여 이전 배열에 대한 뷰를 만듭니다. 그런 다음이 뷰를 반환하거나 할당을 위해 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; 를 사용하여 채울 수 있습니다. 배열이 객체 dtype 인 경우 복잡한 할당을 지원하기 위해 다른 분기의 임시 배열에서 &lt;code&gt;PyArray_CopyObject&lt;/code&gt; 를 호출 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdf75a3a6e21cea0d77ec634980ca032f5eeb858" translate="yes" xml:space="preserve">
          <source>The next table presents the performance in percentage relative to values generated by the legacy generator, &lt;code&gt;RandomState(MT19937())&lt;/code&gt;. The overall performance was computed using a geometric mean.</source>
          <target state="translated">다음 표는 레거시 생성기 &lt;code&gt;RandomState(MT19937())&lt;/code&gt; 의해 생성 된 값에 대한 성능을 백분율로 나타냅니다 . 전반적인 성능은 기하 평균을 사용하여 계산되었습니다.</target>
        </trans-unit>
        <trans-unit id="e979bd0b63198c55de3690f43140859bad90f54c" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original Fortran code. Thus, if I modify the source code to contain:</source>
          <target state="translated">멋진 인터페이스는 원래 Fortran 코드에 특수 주석으로 변수 지시문을 배치하여 자동으로 생성 할 수도 있습니다. 따라서 다음을 포함하도록 소스 코드를 수정하면</target>
        </trans-unit>
        <trans-unit id="5462948418f50794d8b059e0adf72cefb6356af5" translate="yes" xml:space="preserve">
          <source>The nice interface can also be generated automatically by placing the variable directives as special comments in the original fortran code. Thus, if I modify the source code to contain:</source>
          <target state="translated">멋진 인터페이스는 원본 포트란 코드에 특수 주석으로 변수 지시문을 배치하여 자동으로 생성 할 수도 있습니다. 따라서 다음을 포함하도록 소스 코드를 수정하면</target>
        </trans-unit>
        <trans-unit id="0153c9bc357a3afb289f46e1296cad96a6ebfe64" translate="yes" xml:space="preserve">
          <source>The noncentral</source>
          <target state="translated">비 중심</target>
        </trans-unit>
        <trans-unit id="007f1b9babda9d4c7b56259360ff2b4902c7689b" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">정규 분포는 본질적으로 종종 발생합니다. 예를 들어, 각각 고유 한 분포를 갖는 다수의 작은 무작위 교란에 의해 영향을받는 일반적으로 발생하는 샘플 분포를 설명합니다 &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2acd5981a8ea796b96e83bb6555be4413ecc4212" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">정규 분포는 자연에서 자주 발생합니다. 예를 들어, 각기 고유 한 분포를 가진 다수의 작은 무작위 교란에 의해 영향을받는 일반적으로 발생하는 샘플 분포를 설명합니다 &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edcb775700a94ba4ed282cab54aed1dcf6bc2923" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">정규 분포는 본질적으로 종종 발생합니다. 예를 들어, 각각 고유 한 분포를 갖는 다수의 작은 무작위 교란에 의해 영향을받는 일반적으로 발생하는 샘플 분포를 설명합니다 &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e795cd0114f2e83de16303b01c212b1bae08ff6" translate="yes" xml:space="preserve">
          <source>The normal distributions occurs often in nature. For example, it describes the commonly occurring distribution of samples influenced by a large number of tiny, random disturbances, each with its own unique distribution &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">정규 분포는 자연에서 자주 발생합니다. 예를 들어, 각기 고유 한 분포를 가진 다수의 작은 무작위 교란에 의해 영향을받는 일반적으로 발생하는 샘플 분포를 설명합니다 &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="966686da674deab5a174046b2e8990436c2787f9" translate="yes" xml:space="preserve">
          <source>The normal, exponential and gamma generators use 256-step Ziggurat methods which are 2-10 times faster than NumPy&amp;rsquo;s default implementation in &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt;&lt;code&gt;standard_exponential&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt;&lt;code&gt;standard_gamma&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정규, 지수 및 감마 생성기는 &lt;a href=&quot;generated/numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.standard_exponential#numpy.random.Generator.standard_exponential&quot;&gt; &lt;code&gt;standard_exponential&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;generated/numpy.random.generator.standard_gamma#numpy.random.Generator.standard_gamma&quot;&gt; &lt;code&gt;standard_gamma&lt;/code&gt; &lt;/a&gt; 에서 NumPy의 기본 구현보다 2-10 배 빠른 256 단계 Ziggurat 메소드를 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="725e48eaa30d1b2cbd58c002507d29063f93ce22" translate="yes" xml:space="preserve">
          <source>The normalized (unit &amp;ldquo;length&amp;rdquo;) eigenvectors, such that the column &lt;code&gt;v[:,i]&lt;/code&gt; is the eigenvector corresponding to the eigenvalue &lt;code&gt;w[i]&lt;/code&gt;.</source>
          <target state="translated">열 &lt;code&gt;v[:,i]&lt;/code&gt; 가 고유 값 &lt;code&gt;w[i]&lt;/code&gt; 대응하는 고유 벡터가되도록 정규화 된 (단위 &quot;길이&quot;) 고유 벡터 .</target>
        </trans-unit>
        <trans-unit id="3299e827c6aa0d2d0f05fb49e420b7948a6917ca" translate="yes" xml:space="preserve">
          <source>The normed arguments of &lt;code&gt;histogramdd&lt;/code&gt; and &lt;code&gt;histogram2d&lt;/code&gt; have been renamed</source>
          <target state="translated">&lt;code&gt;histogramdd&lt;/code&gt; 및 &lt;code&gt;histogram2d&lt;/code&gt; 의 표준 인수 이름이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="4a2bc0ba793eb9bb3e0347a0cebea0eac0618ee5" translate="yes" xml:space="preserve">
          <source>The nuclear norm is the sum of the singular values.</source>
          <target state="translated">핵 규범은 특이 값의 합입니다.</target>
        </trans-unit>
        <trans-unit id="fb33d48b0d271638a6f54e06bd5c7431683a4b77" translate="yes" xml:space="preserve">
          <source>The number 13 has the binaray representation &lt;code&gt;00001101&lt;/code&gt;. Likewise, 16 is represented by &lt;code&gt;00010000&lt;/code&gt;. The bit-wise OR of 13 and 16 is then &lt;code&gt;000111011&lt;/code&gt;, or 29:</source>
          <target state="translated">숫자 13은 binaray 표현 &lt;code&gt;00001101&lt;/code&gt; 을 갖습니다 . 마찬가지로 16은 &lt;code&gt;00010000&lt;/code&gt; 으로 표시됩니다. . 13과 16의 비트 단위 OR은 &lt;code&gt;000111011&lt;/code&gt; 또는 29입니다.</target>
        </trans-unit>
        <trans-unit id="9301b88af54fb2d08827d44439e6252ad34f0666" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise AND of 13 and 17 is therefore &lt;code&gt;000000001&lt;/code&gt;, or 1:</source>
          <target state="translated">숫자 13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시됩니다 . 마찬가지로 17은 &lt;code&gt;00010001&lt;/code&gt; 로 표시됩니다 . . 따라서 13과 17의 비트 AND는 &lt;code&gt;000000001&lt;/code&gt; 또는 1입니다.</target>
        </trans-unit>
        <trans-unit id="5dd5ca9f1bd4e589a273ee53560b9a52127f59e7" translate="yes" xml:space="preserve">
          <source>The number 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. Likewise, 17 is represented by &lt;code&gt;00010001&lt;/code&gt;. The bit-wise XOR of 13 and 17 is therefore &lt;code&gt;00011100&lt;/code&gt;, or 28:</source>
          <target state="translated">숫자 13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시됩니다 . 마찬가지로 17은 &lt;code&gt;00010001&lt;/code&gt; 로 표시됩니다 . . 따라서 13과 17의 비트 XOR은 &lt;code&gt;00011100&lt;/code&gt; 또는 28입니다.</target>
        </trans-unit>
        <trans-unit id="d78115c4219b81e0960ff03256ee289bd93dfe48" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;a @ v = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">숫자 &lt;code&gt;w&lt;/code&gt; 는 &lt;code&gt;a @ v = w * v&lt;/code&gt; 와 같은 벡터 &lt;code&gt;v&lt;/code&gt; 가 &lt;code&gt;a&lt;/code&gt; 경우 a 의 고유 값입니다 . 따라서, 어레이 , &lt;code&gt;w&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 방정식을 만족 &lt;code&gt;a @ v[:,i] = w[i] * v[:,i]&lt;/code&gt; 를 들어 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dafcbdde76f7395561c97c3255cdf449984b5af3" translate="yes" xml:space="preserve">
          <source>The number &lt;code&gt;w&lt;/code&gt; is an eigenvalue of &lt;code&gt;a&lt;/code&gt; if there exists a vector &lt;code&gt;v&lt;/code&gt; such that &lt;code&gt;dot(a,v) = w * v&lt;/code&gt;. Thus, the arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;w&lt;/code&gt;, and &lt;code&gt;v&lt;/code&gt; satisfy the equations &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; for</source>
          <target state="translated">숫자 &lt;code&gt;w&lt;/code&gt; 는 &lt;code&gt;dot(a,v) = w * v&lt;/code&gt; 와 같은 벡터 &lt;code&gt;v&lt;/code&gt; 가 존재 &lt;code&gt;a&lt;/code&gt; 경우 a 의 고유 값입니다 . 따라서 배열 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;w&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 는 방정식을 만족시킵니다. &lt;code&gt;dot(a[:,:], v[:,i]) = w[i] * v[:,i]&lt;/code&gt; 에 대한</target>
        </trans-unit>
        <trans-unit id="1bb66b4a14636c387bd7dac27c6170702e129db5" translate="yes" xml:space="preserve">
          <source>The number of arguments.</source>
          <target state="translated">인수의 수</target>
        </trans-unit>
        <trans-unit id="2746ed3dbbfae3f48c36fec89fbf1da59232f7b4" translate="yes" xml:space="preserve">
          <source>The number of array dimensions.</source>
          <target state="translated">배열 차원의 수입니다.</target>
        </trans-unit>
        <trans-unit id="50f26fa4113f32c300038f926f58c5de950b657e" translate="yes" xml:space="preserve">
          <source>The number of arrays that need to be broadcast to the same shape.</source>
          <target state="translated">같은 모양으로 브로드 캐스트해야하는 어레이 수입니다.</target>
        </trans-unit>
        <trans-unit id="cd1c13079fc7462745575ad6cadd5c1655d5fd8f" translate="yes" xml:space="preserve">
          <source>The number of base units in a step.</source>
          <target state="translated">단계의 기본 단위 수입니다.</target>
        </trans-unit>
        <trans-unit id="ddeea3732f7461b0e4b46d4155abe0931176b591" translate="yes" xml:space="preserve">
          <source>The number of bins (of size 1) is one larger than the largest value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;minlength&lt;/code&gt; is specified, there will be at least this number of bins in the output array (though it will be longer if necessary, depending on the contents of &lt;code&gt;x&lt;/code&gt;). Each bin gives the number of occurrences of its index value in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;weights&lt;/code&gt; is specified the input array is weighted by it, i.e. if a value &lt;code&gt;n&lt;/code&gt; is found at position &lt;code&gt;i&lt;/code&gt;, &lt;code&gt;out[n] += weight[i]&lt;/code&gt; instead of &lt;code&gt;out[n] += 1&lt;/code&gt;.</source>
          <target state="translated">빈의 수 (크기 1)는 &lt;code&gt;x&lt;/code&gt; 의 가장 큰 값보다 하나 더 큽니다 . 경우 &lt;code&gt;minlength&lt;/code&gt; 지정되어, (필요한 경우 그것의 내용에 따라 더 길어질 수 있지만 출력 배열 빈들 중 적어도이 수있을 것이다 &lt;code&gt;x&lt;/code&gt; ). 각 구간은 &lt;code&gt;x&lt;/code&gt; 의 색인 값 발생 횟수를 제공합니다 . 경우 &lt;code&gt;weights&lt;/code&gt; 지정 값이있는 경우, 입력 배열은, 그것에 의해, 즉 가중 &lt;code&gt;n&lt;/code&gt; 위치에서 발견되는 &lt;code&gt;i&lt;/code&gt; , &lt;code&gt;out[n] += weight[i]&lt;/code&gt; 대신 &lt;code&gt;out[n] += 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961981b3d06507afe179094c308682fa430fda0e" translate="yes" xml:space="preserve">
          <source>The number of bins for all dimensions (nx=ny=&amp;hellip;=bins).</source>
          <target state="translated">모든 차원에 대한 구간 수 (nx = ny =&amp;hellip; = bins).</target>
        </trans-unit>
        <trans-unit id="180a01cbfbe39044df94a38205c151e4055dfaef" translate="yes" xml:space="preserve">
          <source>The number of bins for each dimension (nx, ny, &amp;hellip; =bins)</source>
          <target state="translated">각 차원의 빈 수 (nx, ny,&amp;hellip; = bins)</target>
        </trans-unit>
        <trans-unit id="ef8032cee94538f0c3d6bbb995bbf06ce4b1a135" translate="yes" xml:space="preserve">
          <source>The number of bins is only proportional to cube root of &lt;code&gt;a.size&lt;/code&gt;. It tends to overestimate the number of bins and it does not take into account data variability.</source>
          <target state="translated">빈의 수는 &lt;code&gt;a.size&lt;/code&gt; 의 세제곱근에 비례합니다. . 빈 수를 과대 평가하는 경향이 있으며 데이터 변동성을 고려하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c7ac04dd9e94e09e580f7718e7797190217f2db" translate="yes" xml:space="preserve">
          <source>The number of bins is the base 2 log of &lt;code&gt;a.size&lt;/code&gt;. This estimator assumes normality of data and is too conservative for larger, non-normal datasets. This is the default method in R&amp;rsquo;s &lt;code&gt;hist&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;a.size&lt;/code&gt; 는 a.size 의 기본 2 로그입니다 . 이 추정기는 데이터의 정규성을 가정하며 더 큰 비정규 데이터 세트에는 너무 보수적입니다. 이것이 R의 &lt;code&gt;hist&lt;/code&gt; 방법 의 기본 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="ec49cbff29de9e7b90f0c2a06cd3039e0f213a48" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent including its sign and bias.</source>
          <target state="translated">부호 및 바이어스를 포함하여 지수의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="ffbebedcdf5bf4f1593520cffb80749e6f34262c" translate="yes" xml:space="preserve">
          <source>The number of bits in the exponent portion of the floating point representation.</source>
          <target state="translated">부동 소수점 표현의 지수 부분에있는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="96302b58629afe268f2042e560d43721a3fc2867" translate="yes" xml:space="preserve">
          <source>The number of bits in the mantissa.</source>
          <target state="translated">가수의 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="792cc1a58f0a3a46d19118877b6d13c493cb98ec" translate="yes" xml:space="preserve">
          <source>The number of bits occupied by the type.</source>
          <target state="translated">유형이 차지하는 비트 수입니다.</target>
        </trans-unit>
        <trans-unit id="b307f502028d1a8e478a9e28dfcf2d36c5fe0bca" translate="yes" xml:space="preserve">
          <source>The number of bits required to generate a simulated value differs from the number of bits generated by the underlying RNG. For example, two 16-bit integer values can be simulated from a single draw of a 32-bit RNG.</source>
          <target state="translated">시뮬레이션 된 값을 생성하는 데 필요한 비트 수는 기본 RNG에 의해 생성 된 비트 수와 다릅니다. 예를 들어, 32 비트 RNG의 단일 드로우에서 두 개의 16 비트 정수 값을 시뮬레이션 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5b028aff9079ccf79e60389c0ccd1c2bd52c5a13" translate="yes" xml:space="preserve">
          <source>The number of build jobs can also be specified via the environment variable &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt;.</source>
          <target state="translated">빌드 작업 수는 환경 변수 &lt;code&gt;NPY_NUM_BUILD_JOBS&lt;/code&gt; 를 통해 지정할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c523c9c933fe391fb48ef56ebd3c154a68738ed9" translate="yes" xml:space="preserve">
          <source>The number of bytes each item in the array requires.</source>
          <target state="translated">배열의 각 항목에 필요한 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="accc8d694cc26b9e63438cb6cbca5878ebb2f8ff" translate="yes" xml:space="preserve">
          <source>The number of bytes into the field at which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 을 배치 할 필드의 바이트 수입니다 .</target>
        </trans-unit>
        <trans-unit id="a1bc94a2ea241fcb184442f81754fe01e618cf6a" translate="yes" xml:space="preserve">
          <source>The number of characters per line for the purpose of inserting line breaks (default 75).</source>
          <target state="translated">줄 바꿈을 삽입하기위한 줄당 문자 수입니다 (기본값 : 75).</target>
        </trans-unit>
        <trans-unit id="e62a5487dfe8294b0662475991a8ef49d96aaa30" translate="yes" xml:space="preserve">
          <source>The number of children already spawned. Only pass this if reconstructing a &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; from a serialized form.</source>
          <target state="translated">이미 생성 된 어린이 수입니다. 직렬화 된 양식에서 &lt;a href=&quot;#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 를 재구성하는 경우에만이를 전달하십시오 .</target>
        </trans-unit>
        <trans-unit id="51818f09691484990d73679da97e27bd0b748a81" translate="yes" xml:space="preserve">
          <source>The number of dimensions and the size of each dimension</source>
          <target state="translated">차원의 수와 각 차원의 크기</target>
        </trans-unit>
        <trans-unit id="20f7440820740cd73bd8bc73940f9eb0da1ec572" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the array.</source>
          <target state="translated">배열의 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="d4b953d2df6296d252217619c918790078f1f070" translate="yes" xml:space="preserve">
          <source>The number of dimensions in the broadcasted result.</source>
          <target state="translated">브로드 캐스트 된 결과의 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="16045283fd37589fa60a5d2a0d49dd57ac83ac40" translate="yes" xml:space="preserve">
          <source>The number of dimensions.</source>
          <target state="translated">차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="cf23530c90606a0534a47544a2bf03555320f356" translate="yes" xml:space="preserve">
          <source>The number of each type of item in the collection from which a sample is drawn. The values in &lt;code&gt;colors&lt;/code&gt; must be nonnegative. To avoid loss of precision in the algorithm, &lt;code&gt;sum(colors)&lt;/code&gt; must be less than &lt;code&gt;10**9&lt;/code&gt; when &lt;code&gt;method&lt;/code&gt; is &amp;ldquo;marginals&amp;rdquo;.</source>
          <target state="translated">샘플을 가져온 컬렉션의 각 항목 유형 수입니다. &lt;code&gt;colors&lt;/code&gt; 값은 음수가 아니어야합니다. 알고리즘의 정밀도 손실을 방지하려면 &lt;code&gt;method&lt;/code&gt; 가 &quot;marginals&quot; &lt;code&gt;10**9&lt;/code&gt; 때 &lt;code&gt;sum(colors)&lt;/code&gt; 은 10 ** 9 미만이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="6aad0168a8285a1a3006caa27029c5241a1ba31b" translate="yes" xml:space="preserve">
          <source>The number of elements in the gentype.</source>
          <target state="translated">gentype의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="3a0a0191ab6889929bc691e4ea5f7b01d6f77c2e" translate="yes" xml:space="preserve">
          <source>The number of elements to unpack along &lt;code&gt;axis&lt;/code&gt;, provided as a way of undoing the effect of packing a size that is not a multiple of eight. A non-negative number means to only unpack &lt;code&gt;count&lt;/code&gt; bits. A negative number means to trim off that many bits from the end. &lt;code&gt;None&lt;/code&gt; means to unpack the entire array (the default). Counts larger than the available number of bits will add zero padding to the output. Negative counts must not exceed the available number of bits.</source>
          <target state="translated">8의 배수가 아닌 크기를 패킹하는 효과를 취소하는 방법으로 제공되는 &lt;code&gt;axis&lt;/code&gt; 따라 패킹 해제 할 요소의 수입니다 . 음수가 아닌 숫자는 &lt;code&gt;count&lt;/code&gt; 비트의 압축을 풉니 다 . 음수는 끝에서 많은 비트를 잘라내는 것을 의미합니다. &lt;code&gt;None&lt;/code&gt; 은 전체 배열의 압축을 풉니 다 (기본값). 사용 가능한 비트 수보다 큰 카운트는 출력에 제로 패딩을 추가합니다. 음수는 사용 가능한 비트 수를 초과해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="9762b9c4461b4320b651627cdc827d526c1d8a36" translate="yes" xml:space="preserve">
          <source>The number of floating-point types</source>
          <target state="translated">부동 소수점 유형의 수</target>
        </trans-unit>
        <trans-unit id="5f79b76db3c0063c4dbecc42a7851ca0e7d61297" translate="yes" xml:space="preserve">
          <source>The number of input arguments.</source>
          <target state="translated">입력 인수의 수</target>
        </trans-unit>
        <trans-unit id="5f16430ff4bbbb029090f84ca5392fa4a978dcbf" translate="yes" xml:space="preserve">
          <source>The number of inputs.</source>
          <target state="translated">입력 수</target>
        </trans-unit>
        <trans-unit id="ad3ac53999da2a535168ea7e917e83fb83c41419" translate="yes" xml:space="preserve">
          <source>The number of integrations to perform.</source>
          <target state="translated">수행 할 통합 수입니다.</target>
        </trans-unit>
        <trans-unit id="f51beaacf43aeefc0899893a53af8824382a26f0" translate="yes" xml:space="preserve">
          <source>The number of items selected. &lt;code&gt;nsample&lt;/code&gt; must not be greater than &lt;code&gt;sum(colors)&lt;/code&gt;.</source>
          <target state="translated">선택한 항목 수입니다. &lt;code&gt;nsample&lt;/code&gt; 은 &lt;code&gt;sum(colors)&lt;/code&gt; 보다 클 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="fb27416d0d8fd4a79bebfa578ec630568a0908f0" translate="yes" xml:space="preserve">
          <source>The number of items to read from &lt;em&gt;iterable&lt;/em&gt;. The default is -1, which means all data is read.</source>
          <target state="translated">&lt;em&gt;iterable&lt;/em&gt; 에서 읽을 항목 수입니다 . 기본값은 -1이며 모든 데이터를 읽습니다.</target>
        </trans-unit>
        <trans-unit id="59d7f6376949b026c4f59178cb450cda4e03c50d" translate="yes" xml:space="preserve">
          <source>The number of iterator operands.</source>
          <target state="translated">반복자 피연산자의 수입니다.</target>
        </trans-unit>
        <trans-unit id="906dbe82e1bcf21f6f38450b28f60987840c67b3" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the beginning of the file.</source>
          <target state="translated">파일의 시작 부분에서 건너 뛸 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="1f9e5bb5bb6065f40b3b5f1acf92ad15826aa414" translate="yes" xml:space="preserve">
          <source>The number of lines to skip at the end of the file.</source>
          <target state="translated">파일 끝에서 건너 뛸 행 수입니다.</target>
        </trans-unit>
        <trans-unit id="36ce98d71e68fb1757547c834a0c7900df88883d" translate="yes" xml:space="preserve">
          <source>The number of numerical NumPy types - of which there are 18 total - on which the ufunc can operate.</source>
          <target state="translated">ufunc가 작동 할 수있는 숫자 NumPy 유형의 수는 총 18 개입니다.</target>
        </trans-unit>
        <trans-unit id="9d9f649df57a2efc7c5d1837c8cce03f4ddffe4d" translate="yes" xml:space="preserve">
          <source>The number of objects returned by &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 가 반환 한 객체 수입니다 .</target>
        </trans-unit>
        <trans-unit id="cd1491ebeebfc5761455718746328a874537820d" translate="yes" xml:space="preserve">
          <source>The number of output arguments.</source>
          <target state="translated">출력 인수의 수</target>
        </trans-unit>
        <trans-unit id="bb79176b795c17c39b28af054f09df09e008175b" translate="yes" xml:space="preserve">
          <source>The number of outputs.</source>
          <target state="translated">출력 수</target>
        </trans-unit>
        <trans-unit id="1f9d3b6c33190d8820407a65c8dfbe71f2fb41db" translate="yes" xml:space="preserve">
          <source>The number of periods &lt;code&gt;nper&lt;/code&gt; is computed by solving the equation:</source>
          <target state="translated">주기 &lt;code&gt;nper&lt;/code&gt; 는 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="9f00991307aeed3ff212ec1f19aa64c4d4a70887" translate="yes" xml:space="preserve">
          <source>The number of places by which elements are shifted. If a tuple, then &lt;code&gt;axis&lt;/code&gt; must be a tuple of the same size, and each of the given axes is shifted by the corresponding number. If an int while &lt;code&gt;axis&lt;/code&gt; is a tuple of ints, then the same value is used for all given axes.</source>
          <target state="translated">요소가 이동하는 장소의 수입니다. 튜플 인 경우 &lt;code&gt;axis&lt;/code&gt; 동일한 크기의 튜플이어야하며 지정된 각 축은 해당 숫자만큼 이동합니다. int while &lt;code&gt;axis&lt;/code&gt; 이 int 의 튜플 인 경우 모든 주어진 축에 동일한 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1c87f40038faffc87024cc0b95bb28f19f5ea872" translate="yes" xml:space="preserve">
          <source>The number of repetitions for each element. &lt;code&gt;repeats&lt;/code&gt; is broadcasted to fit the shape of the given axis.</source>
          <target state="translated">각 요소의 반복 횟수입니다. &lt;code&gt;repeats&lt;/code&gt; 주어진 축의 모양에 맞게 이 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="4fedda7271f10f5b28b1a15e8ad961405e48dbc3" translate="yes" xml:space="preserve">
          <source>The number of repetitions of &lt;code&gt;A&lt;/code&gt; along each axis.</source>
          <target state="translated">각 축을 따라 &lt;code&gt;A&lt;/code&gt; 반복 횟수입니다 .</target>
        </trans-unit>
        <trans-unit id="1e0a0e5cb024809c54b4083f3e0a5bc9d1d9a145" translate="yes" xml:space="preserve">
          <source>The number of supported data types for the ufunc. This number specifies how many different 1-d loops (of the builtin data types) are available.</source>
          <target state="translated">ufunc에 지원되는 데이터 유형 수입니다. 이 숫자는 사용 가능한 여러 가지 1 차원 루프 (내장 데이터 유형)를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="d384dcdb010cb83d633476edabf26a7cd5dcb98d" translate="yes" xml:space="preserve">
          <source>The number of times &lt;code&gt;a&lt;/code&gt; is repeated along the first and second axes.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 제 1 및 제 2 축을 따라 반복되는 횟수 .</target>
        </trans-unit>
        <trans-unit id="84ea540c48d087fa8db5ec94e472c5f5f973f2f5" translate="yes" xml:space="preserve">
          <source>The number of times each of the unique values comes up in the original array. Only provided if &lt;code&gt;return_counts&lt;/code&gt; is True.</source>
          <target state="translated">고유 값 각각이 원래 배열에 나타나는 횟수입니다. &lt;code&gt;return_counts&lt;/code&gt; 가 True 인 경우에만 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="27ba063589e5e81b80624f4103b1f5b28059f11a" translate="yes" xml:space="preserve">
          <source>The number of times values are differenced. If zero, the input is returned as-is.</source>
          <target state="translated">횟수 값이 다릅니다. 0이면 입력이 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9f0b88f6fb636dd892bff0b33b009c20d79ffb03" translate="yes" xml:space="preserve">
          <source>The number of types.</source>
          <target state="translated">유형의 수</target>
        </trans-unit>
        <trans-unit id="fddf10cce5774b681c3f0ad6691bdd384810c58d" translate="yes" xml:space="preserve">
          <source>The number of variates to generate, either an integer or a tuple holding the shape of the array of variates. If the given size is, e.g., &lt;code&gt;(k, m)&lt;/code&gt;, then &lt;code&gt;k * m&lt;/code&gt; variates are drawn, where one variate is a vector of length &lt;code&gt;len(colors)&lt;/code&gt;, and the return value has shape &lt;code&gt;(k, m, len(colors))&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is an integer, the output has shape &lt;code&gt;(size, len(colors))&lt;/code&gt;. Default is None, in which case a single variate is returned as an array with shape &lt;code&gt;(len(colors),)&lt;/code&gt;.</source>
          <target state="translated">생성 할 변량의 수로, 정수 또는 변량 배열의 형태를 유지하는 튜플입니다. 주어진 크기가 &lt;code&gt;(k, m)&lt;/code&gt; 이면 &lt;code&gt;k * m&lt;/code&gt; 변수가 그려집니다. 여기서 하나의 변수는 길이가 &lt;code&gt;len(colors)&lt;/code&gt; 인 벡터이고 반환 값은 &lt;code&gt;(k, m, len(colors))&lt;/code&gt; . 경우 &lt;code&gt;size&lt;/code&gt; 정수이고, 출력은 형상을 갖는다 &lt;code&gt;(size, len(colors))&lt;/code&gt; . 기본값은 None입니다.이 경우 단일 변량은 모양이 &lt;code&gt;(len(colors),)&lt;/code&gt; 인 배열로 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="87e16add792d15ef1991805fd1807bc3c93accb5" translate="yes" xml:space="preserve">
          <source>The numerical data we wish to work with begins at column 4, row 8, and extends from there to the rightmost column and the lowermost row.</source>
          <target state="translated">작업하려는 숫자 데이터는 4 열, 8 행에서 시작하여 가장 오른쪽 열과 가장 아래 행까지 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="8a67e415f6489cfd59cc7656bd025411ca29912b" translate="yes" xml:space="preserve">
          <source>The numpy array shares the memory with the ctypes object.</source>
          <target state="translated">numpy 배열은 ctypes 객체와 메모리를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="d790ce3a56f19101368186a47de94f2e3aed2abb" translate="yes" xml:space="preserve">
          <source>The numpy core math library (&amp;lsquo;npymath&amp;rsquo;) is a first step in this direction. This library contains most math-related C99 functionality, which can be used on platforms where C99 is not well supported. The core math functions have the same API as the C99 ones, except for the npy_* prefix.</source>
          <target state="translated">numpy 핵심 수학 라이브러리 ( 'npymath')는이 방향의 첫 번째 단계입니다. 이 라이브러리에는 대부분의 수학 관련 C99 기능이 포함되어 있으며 C99가 제대로 지원되지 않는 플랫폼에서 사용할 수 있습니다. 핵심 수학 함수는 npy_ * 접두사를 제외하고 C99 함수와 동일한 API를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="6064ebb13dec03f1de88e5067059d7a27df68911" translate="yes" xml:space="preserve">
          <source>The numpy documentation also depends on the &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; sphinx extension as well as an external sphinx theme. These extensions are included as git submodules and must be initialized before building the docs. From the &lt;code&gt;doc/&lt;/code&gt; directory:</source>
          <target state="translated">numpy 문서는 &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/&quot;&gt;numpydoc&lt;/a&gt; 스핑크스 확장과 외부 스핑크스 테마 에도 의존합니다 . 이러한 확장은 git 하위 모듈로 포함되며 문서를 빌드하기 전에 초기화해야합니다. 로부터 &lt;code&gt;doc/&lt;/code&gt; 디렉토리 :</target>
        </trans-unit>
        <trans-unit id="c633caa71d9888760198001cce3d8210c7c275af" translate="yes" xml:space="preserve">
          <source>The numpy.i file for swig is Python 3 only.</source>
          <target state="translated">swig 용 numpy.i 파일은 Python 3 전용입니다.</target>
        </trans-unit>
        <trans-unit id="d91b51f2620c8e0f1fabe752803d49bce22176fb" translate="yes" xml:space="preserve">
          <source>The numpy.ma module</source>
          <target state="translated">numpy.ma 모듈</target>
        </trans-unit>
        <trans-unit id="2cbe93e7df3a43f9ae71da4b89814ed8fa49c0d4" translate="yes" xml:space="preserve">
          <source>The numpy/core/include/numpy/numpyconfig.h will need a new NPY_X_Y_API_VERSION macro, where X and Y are the major and minor version numbers of the release. The value given to that macro only needs to be increased from the previous version if some of the functions or macros in the include files were deprecated.</source>
          <target state="translated">numpy / core / include / numpy / numpyconfig.h에는 새로운 NPY_X_Y_API_VERSION 매크로가 필요합니다. 여기서 X와 Y는 릴리스의 주 및 부 버전 번호입니다. 해당 매크로에 제공된 값은 포함 파일의 일부 기능 또는 매크로가 더 이상 사용되지 않는 경우 이전 버전에서 증가해야합니다.</target>
        </trans-unit>
        <trans-unit id="2fff5784e4a4fb8eb59dd23392ddf836510aaeb1" translate="yes" xml:space="preserve">
          <source>The numpydoc docstring guide</source>
          <target state="translated">numpydoc 독 스트링 가이드</target>
        </trans-unit>
        <trans-unit id="dbd675a4d044f8874d7c67d632da0258490296eb" translate="yes" xml:space="preserve">
          <source>The object can be any Python object convertible to an ndarray. If the object is already (a subclass of) the ndarray that satisfies the requirements then a new reference is returned. Otherwise, a new array is constructed. The contents of &lt;em&gt;obj&lt;/em&gt; are copied to the new array unless the array interface is used so that data does not have to be copied. Objects that can be converted to an array include: 1) any nested sequence object, 2) any object exposing the array interface, 3) any object with an &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method (which should return an ndarray), and 4) any scalar object (becomes a zero-dimensional array). Sub-classes of the ndarray that otherwise fit the requirements will be passed through. If you want to ensure a base-class ndarray, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt;&lt;/a&gt; in the requirements flag. A copy is made only if necessary. If you want to guarantee a copy, then pass in &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt;&lt;/a&gt; to the requirements flag.</source>
          <target state="translated">객체는 ndarray로 변환 할 수있는 모든 Python 객체 일 수 있습니다. 객체가 이미 요구 사항을 충족하는 ndarray (의 하위 클래스) 인 경우 새 참조가 반환됩니다. 그렇지 않으면 새 배열이 생성됩니다. 데이터를 복사 할 필요가 없도록 배열 인터페이스를 사용하지 않는 한 &lt;em&gt;obj&lt;/em&gt; 의 내용은 새 배열로 복사됩니다. 배열로 변환 할 수있는 객체는 다음과 같습니다. 1) 중첩 된 시퀀스 객체, 2) 배열 인터페이스를 노출하는 객체, 3) &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 메서드 ( ndarray 를 반환해야 함)가있는 객체, 4) 모든 스칼라 객체 (가 됨) 0 차원 배열). 그렇지 않으면 요구 사항에 맞는 ndarray의 하위 클래스가 통과됩니다. 기본 클래스 ndarray를 보장하려면 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSUREARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSUREARRAY&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오.요구 사항 플래그에서. 필요한 경우에만 사본이 만들어집니다. 복사본을 보장 하려면 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_ENSURECOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_ENSURECOPY&lt;/code&gt; &lt;/a&gt; 를 요구 사항 플래그에 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="a12e93df39508259f846e57ebebd07dec5405cd4" translate="yes" xml:space="preserve">
          <source>The object of which the type is returned.</source>
          <target state="translated">형식이 반환되는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="892e730df208b39897e2c0d1b1cca7fbb8ae1420" translate="yes" xml:space="preserve">
          <source>The object to be converted to a type-and-requirement-satisfying array.</source>
          <target state="translated">형식 및 요구 사항 충족 배열로 변환 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="bfbfb146acae6cf5d1e2df4b8b0cf4b046d06226" translate="yes" xml:space="preserve">
          <source>The object to check.</source>
          <target state="translated">확인할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="0f3ea496874fb4613c3a9be9c6a176f4f24c9e54" translate="yes" xml:space="preserve">
          <source>The object to iterate over.</source>
          <target state="translated">반복 할 객체입니다.</target>
        </trans-unit>
        <trans-unit id="52a504743f31bcad27f2c05d142802d7b1946829" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt; items does not return an &lt;a href=&quot;#numpy.object_&quot;&gt;&lt;code&gt;object_&lt;/code&gt;&lt;/a&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">&lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt; 항목을 포함하는 배열 은 항목 액세스시 &lt;a href=&quot;#numpy.object_&quot;&gt; &lt;code&gt;object_&lt;/code&gt; &lt;/a&gt; 개체를 반환하지 않고 대신 배열 항목이 참조하는 실제 개체를 반환 하므로 개체 유형도 특별 합니다.</target>
        </trans-unit>
        <trans-unit id="45971228cf20d163b0ca1b27e71b0f9a03bee868" translate="yes" xml:space="preserve">
          <source>The object type is also special because an array containing &lt;code&gt;object_&lt;/code&gt; items does not return an &lt;code&gt;object_&lt;/code&gt; object on item access, but instead returns the actual object that the array item refers to.</source>
          <target state="translated">&lt;code&gt;object_&lt;/code&gt; items를 포함하는 배열 은 항목 액세스시 &lt;code&gt;object_&lt;/code&gt; 오브젝트를 리턴하지 않고 대신 배열 항목이 참조하는 실제 오브젝트를 리턴 하므로 오브젝트 유형도 특별 합니다.</target>
        </trans-unit>
        <trans-unit id="74fb22be6dfa85b139cc4a823d71b842fbca772d" translate="yes" xml:space="preserve">
          <source>The object which calculated these parameters and holds more detailed information.</source>
          <target state="translated">이러한 파라미터를 계산하고보다 자세한 정보를 보유한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="12dc58a76790d493cfd5ba208610a891b0f1c28f" translate="yes" xml:space="preserve">
          <source>The object will be converted to the desired type only if it can be done without losing precision. Otherwise &lt;code&gt;NULL&lt;/code&gt; will be returned and an error raised. Use &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt;&lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt;&lt;/a&gt; in the requirements flag to override this behavior.</source>
          <target state="translated">객체는 정밀도를 잃지 않고 수행 할 수있는 경우에만 원하는 유형으로 변환됩니다. 그렇지 않으면 &lt;code&gt;NULL&lt;/code&gt; 이 반환되고 오류가 발생합니다. 이 동작을 재정의하려면 요구 사항 플래그에서 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_FORCECAST&quot;&gt; &lt;code&gt;NPY_ARRAY_FORCECAST&lt;/code&gt; &lt;/a&gt; 를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="d7678b3e9676e0762f7a3c623921af222c12ff2c" translate="yes" xml:space="preserve">
          <source>The obvious fix for this situation is to change the dtype so it gives the correct endianness:</source>
          <target state="translated">이 상황에 대한 확실한 수정은 올바른 엔디안을 제공하도록 dtype을 변경하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="29b86a58a4365210dddb9297096eac1156c7d098" translate="yes" xml:space="preserve">
          <source>The offset (in bytes) from the file&amp;rsquo;s current position. Defaults to 0. Only permitted for binary files.</source>
          <target state="translated">파일의 현재 위치로부터의 오프셋 (바이트)입니다. 기본값은 0입니다. 이진 파일에만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="93c773e560e0498af231d1a157163977066e3d8a" translate="yes" xml:space="preserve">
          <source>The old error handler.</source>
          <target state="translated">이전 오류 처리기</target>
        </trans-unit>
        <trans-unit id="1ec4554bb191ce258f048e411e4e87d29267fb91" translate="yes" xml:space="preserve">
          <source>The old iterator API includes functions like PyArrayIter_Check, PyArray_Iter* and PyArray_ITER_*. The multi-iterator array includes PyArray_MultiIter*, PyArray_Broadcast, and PyArray_RemoveSmallest. The new iterator design replaces all of this functionality with a single object and associated API. One goal of the new API is that all uses of the existing iterator should be replaceable with the new iterator without significant effort. In 1.6, the major exception to this is the neighborhood iterator, which does not have corresponding features in this iterator.</source>
          <target state="translated">이전 반복자 API에는 PyArrayIter_Check, PyArray_Iter * 및 PyArray_ITER_ *와 같은 함수가 포함되어 있습니다. 다중 반복자 배열에는 PyArray_MultiIter *, PyArray_Broadcast 및 PyArray_RemoveSmallest가 포함됩니다. 새로운 반복자 디자인은이 모든 기능을 단일 객체 및 관련 API로 대체합니다. 새로운 API의 목표 중 하나는 기존 반복기의 모든 사용을 큰 노력없이 새 반복기로 교체 할 수 있어야한다는 것입니다. 1.6에서 이것에 대한 주요 예외는 이터레이터에 해당하는 기능이없는 이웃 이터레이터입니다.</target>
        </trans-unit>
        <trans-unit id="5bba457e9d70db346759d26e013499c6bff97b55" translate="yes" xml:space="preserve">
          <source>The one-dimensional (forward) FFT, of which &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the inverse</source>
          <target state="translated">1 차원 (앞으로) FFT로, &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 가 역인 경우</target>
        </trans-unit>
        <trans-unit id="5483bbe6b4a2f84418c3aa21133c4c7676377fcb" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT for real input.</source>
          <target state="translated">실제 입력에 대한 1 차원 FFT입니다.</target>
        </trans-unit>
        <trans-unit id="b13835d03a9daf8c507b45bfab105cd08fae35d5" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of general (complex) input.</source>
          <target state="translated">일반 (복잡한) 입력의 1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="0cd037d8b0e459e2ea7f7abda9a2074a96ea80a2" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input, of which &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt; is inverse.</source>
          <target state="translated">실제 입력의 1 차원 FFT는 &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; &lt;/a&gt; 와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="9fbd4ce083fd828af7518629c69fc1b51be085ea" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="5c18581fbbf72b4741168098a1d9545410236f6d" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT, with definitions and conventions used.</source>
          <target state="translated">정의 및 규칙이 사용 된 1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="cb7777bd048622e7012600d71666f63fa7ceb74f" translate="yes" xml:space="preserve">
          <source>The one-dimensional FFT.</source>
          <target state="translated">1 차원 FFT.</target>
        </trans-unit>
        <trans-unit id="225306f7f184d0b92b85104fd4b6b278cc44c9a3" translate="yes" xml:space="preserve">
          <source>The one-dimensional inverse FFT.</source>
          <target state="translated">1 차원 역 FFT.</target>
        </trans-unit>
        <trans-unit id="ba7c728a6936b18871796d8f180aab8013101b39" translate="yes" xml:space="preserve">
          <source>The only constraint on &lt;code&gt;weights&lt;/code&gt; is that &lt;code&gt;sum(weights)&lt;/code&gt; must not be 0.</source>
          <target state="translated">&lt;code&gt;weights&lt;/code&gt; 에 대한 유일한 제약 은 &lt;code&gt;sum(weights)&lt;/code&gt; 가 0이 아니어야한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ff0f1129172422a9679a73fc5e8d6a883951639f" translate="yes" xml:space="preserve">
          <source>The only mandatory argument of &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is the source of the data. It can be a string, a list of strings, a generator or an open file-like object with a &lt;code&gt;read&lt;/code&gt; method, for example, a file or &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt;&lt;code&gt;io.StringIO&lt;/code&gt;&lt;/a&gt; object. If a single string is provided, it is assumed to be the name of a local or remote file. If a list of strings or a generator returning strings is provided, each string is treated as one line in a file. When the URL of a remote file is passed, the file is automatically downloaded to the current directory and opened.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 의 유일한 필수 인수 는 데이터 소스입니다. 문자열, 문자열 목록, 생성기 또는 &lt;code&gt;read&lt;/code&gt; 메서드가 있는 열린 파일 류 객체 ( 예 : 파일 또는 &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.StringIO&quot;&gt; &lt;code&gt;io.StringIO&lt;/code&gt; &lt;/a&gt; 객체)가 될 수 있습니다. 단일 문자열이 제공되면 로컬 또는 원격 파일의 이름으로 간주됩니다. 문자열 목록 또는 문자열을 반환하는 생성기가 제공되면 각 문자열은 파일에서 한 줄로 처리됩니다. 원격 파일의 URL이 전달되면 파일이 자동으로 현재 디렉토리에 다운로드되어 열립니다.</target>
        </trans-unit>
        <trans-unit id="a3bf399916e3e501d883fea808c4310d7579f09c" translate="yes" xml:space="preserve">
          <source>The operand &lt;code&gt;+&lt;/code&gt; is only added for nominal reasons, For example: &lt;code&gt;--cpu-basline= &quot;min avx2&quot;&lt;/code&gt; is equivalent to &lt;code&gt;--cpu-basline=&quot;min + avx2&quot;&lt;/code&gt;. &lt;code&gt;--cpu-basline=&quot;min,avx2&quot;&lt;/code&gt; is equivalent to &lt;code&gt;--cpu-basline`=&quot;min,+avx2&quot;&lt;/code&gt;</source>
          <target state="translated">피연산자 &lt;code&gt;+&lt;/code&gt; 는 명목상의 이유로 만 추가됩니다. 예 : &lt;code&gt;--cpu-basline= &quot;min avx2&quot;&lt;/code&gt; 는 &lt;code&gt;--cpu-basline=&quot;min + avx2&quot;&lt;/code&gt; . &lt;code&gt;--cpu-basline=&quot;min,avx2&quot;&lt;/code&gt; 는 &lt;code&gt;--cpu-basline`=&quot;min,+avx2&quot;&lt;/code&gt; 와 같습니다.</target>
        </trans-unit>
        <trans-unit id="df0b92ea232e6d8dccfcd905588f89bc51445e3a" translate="yes" xml:space="preserve">
          <source>The operands of some operation whose result type is needed.</source>
          <target state="translated">결과 유형이 필요한 일부 연산의 피연산자</target>
        </trans-unit>
        <trans-unit id="10e5b80590b5efbd493758bd757a312d4d78c228" translate="yes" xml:space="preserve">
          <source>The operation in the inner loop is a straightforward multiplication. Everything to do with the outer product is handled by the iterator setup.</source>
          <target state="translated">내부 루프의 연산은 간단한 곱셈입니다. 외부 제품과 관련된 모든 것은 반복자 설정에 의해 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="471ee7828ebe7c0602cfc5e6e021f9c562ef10fd" translate="yes" xml:space="preserve">
          <source>The option &lt;code&gt;dtype=None&lt;/code&gt; is provided for convenience. However, it is significantly slower than setting the dtype explicitly.</source>
          <target state="translated">편의를 위해 &lt;code&gt;dtype=None&lt;/code&gt; 옵션 이 제공됩니다. 그러나 명시 적으로 dtype을 설정하는 것보다 훨씬 느립니다.</target>
        </trans-unit>
        <trans-unit id="5d9c6a82b754562bff3c30cfb164e81b6c34b6c3" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;aligned&amp;rsquo; value can be set to &lt;code&gt;True&lt;/code&gt; to make the automatic offset computation use aligned offsets (see &lt;a href=&quot;#offsets-and-alignment&quot;&gt;Automatic Byte Offsets and Alignment&lt;/a&gt;), as if the &amp;lsquo;align&amp;rsquo; keyword argument of &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; had been set to True.</source>
          <target state="translated">선택적 'aligned'값을 &lt;code&gt;True&lt;/code&gt; 로 설정하면 &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt; 의 'align'키워드 인수 가 True로 설정된 것처럼 자동 오프셋 계산에서 정렬 된 오프셋을 사용할 수 있습니다 ( &lt;a href=&quot;#offsets-and-alignment&quot;&gt;자동 바이트 오프셋 및 정렬 참조&lt;/a&gt; ) .</target>
        </trans-unit>
        <trans-unit id="03a3e8c483cee1d9d2b1425187728e8a245d58ca" translate="yes" xml:space="preserve">
          <source>The optional &amp;lsquo;titles&amp;rsquo; value should be a list of titles of the same length as &amp;lsquo;names&amp;rsquo;, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below.</source>
          <target state="translated">선택적 'titles'값은 'names'와 길이가 같은 제목 목록이어야 합니다. 아래의 &lt;a href=&quot;#titles&quot;&gt;필드 제목을&lt;/a&gt; 참조하세요.</target>
        </trans-unit>
        <trans-unit id="0af8d6f274a699b745815e9b76bdbe8e97f9313c" translate="yes" xml:space="preserve">
          <source>The optional argument &lt;code&gt;comments&lt;/code&gt; is used to define a character string that marks the beginning of a comment. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;comments='#'&lt;/code&gt;. The comment marker may occur anywhere on the line. Any character present after the comment marker(s) is simply ignored:</source>
          <target state="translated">선택적 인수 &lt;code&gt;comments&lt;/code&gt; 는 주석의 시작을 표시하는 문자열을 정의하는 데 사용됩니다. 기본적으로 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;comments='#'&lt;/code&gt; 라고 가정합니다 . 주석 마커는 줄의 어느 곳에서나 나타날 수 있습니다. 주석 표시 자 뒤에있는 모든 문자는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="94b62b6ba781a5ddd569b811fe572b78fe805c1d" translate="yes" xml:space="preserve">
          <source>The optional output arguments can be used to help you save memory for large calculations. If your arrays are large, complicated expressions can take longer than absolutely necessary due to the creation and (later) destruction of temporary calculation spaces. For example, the expression &lt;code&gt;G = a * b + c&lt;/code&gt; is equivalent to &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt;. It will be more quickly executed as &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; which is the same as &lt;code&gt;G = A * B; G += C&lt;/code&gt;.</source>
          <target state="translated">선택적 출력 인수를 사용하면 대규모 계산을 위해 메모리를 절약 할 수 있습니다. 배열이 크면 복잡한 계산은 임시 계산 공간의 생성 및 (나중에) 파괴로 인해 절대적으로 필요한 시간보다 오래 걸릴 수 있습니다. 예를 들어, 표현식 &lt;code&gt;G = a * b + c&lt;/code&gt; 는 &lt;code&gt;t1 = A * B; G = T1 + C; del t1&lt;/code&gt; 와 같습니다 . G = T1 + C; 델 t1 . &lt;code&gt;G = A * B; add(G, C, G)&lt;/code&gt; 로 더 빨리 실행됩니다 . &lt;code&gt;G = A * B; G += C&lt;/code&gt; 와 동일한 add (G, C, G) ; G는 = C + .</target>
        </trans-unit>
        <trans-unit id="7b2c78f4cc1b5de9c0c210654a3400e8183ebd83" translate="yes" xml:space="preserve">
          <source>The optional third element &lt;em&gt;field_shape&lt;/em&gt; contains the shape if this field represents an array of the data-type in the second element. Note that a 3-tuple with a third argument equal to 1 is equivalent to a 2-tuple.</source>
          <target state="translated">선택적인 세 번째 요소 인 &lt;em&gt;field_shape&lt;/em&gt; 는이 필드가 두 번째 요소의 데이터 유형 배열을 나타내는 경우 모양을 포함합니다. 세 번째 인수가 1 인 3 개의 튜플은 2 개의 튜플과 같습니다.</target>
        </trans-unit>
        <trans-unit id="14b215bf63d4b571de67dcde3ac908fb35772330" translate="yes" xml:space="preserve">
          <source>The options &amp;lsquo;reduced&amp;rsquo;, &amp;lsquo;complete, and &amp;lsquo;raw&amp;rsquo; are new in numpy 1.8, see the notes for more information. The default is &amp;lsquo;reduced&amp;rsquo;, and to maintain backward compatibility with earlier versions of numpy both it and the old default &amp;lsquo;full&amp;rsquo; can be omitted. Note that array h returned in &amp;lsquo;raw&amp;rsquo; mode is transposed for calling Fortran. The &amp;lsquo;economic&amp;rsquo; mode is deprecated. The modes &amp;lsquo;full&amp;rsquo; and &amp;lsquo;economic&amp;rsquo; may be passed using only the first letter for backwards compatibility, but all others must be spelled out. See the Notes for more explanation.</source>
          <target state="translated">'축소', '완료'및 '원시'옵션은 numpy 1.8의 새로운 기능입니다. 자세한 내용은 참고를 참조하십시오. 기본값은 '감소'이며 이전 버전의 numpy와의 호환성을 유지하기 위해 이전 기본값 인 'full'을 생략 할 수 있습니다. 'raw'모드에서 반환 된 배열 h는 Fortran을 호출하기 위해 바뀝니다. '경제적'모드는 더 이상 사용되지 않습니다. 'full'및 'economic'모드는 이전 버전과의 호환성을 위해 첫 번째 문자 만 사용하여 전달할 수 있지만 다른 모든 문자는 철자해야합니다. 자세한 설명은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6d9b2da0a0a7c1206d894d6f0fcce902e86c7458" translate="yes" xml:space="preserve">
          <source>The order in which the array data is stored in memory: &amp;lsquo;C&amp;rsquo; -&amp;gt; &amp;ldquo;row major&amp;rdquo; order (the default), &amp;lsquo;F&amp;rsquo; -&amp;gt; &amp;ldquo;column major&amp;rdquo; (Fortran) order.</source>
          <target state="translated">배열 데이터가 메모리에 저장되는 순서 : 'C'-&amp;gt; &quot;행 주&quot;순서 (기본값), 'F'-&amp;gt; &quot;열 주&quot;(Fortran) 순서.</target>
        </trans-unit>
        <trans-unit id="68929adbb771e5f9d5347a88dc7ca873ea9321af" translate="yes" xml:space="preserve">
          <source>The order in which they are preferred is determined by &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; and &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; environment variables. The default value is &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt;.</source>
          <target state="translated">선호되는 순서는 &lt;code&gt;NPY_BLAS_ILP64_ORDER&lt;/code&gt; 및 &lt;code&gt;NPY_LAPACK_ILP64_ORDER&lt;/code&gt; 환경 변수에 의해 결정됩니다 . 기본값은 &lt;code&gt;openblas64_,openblas_ilp64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e18fbd568fd064406da176fc5bb0b9a80dc8baa0" translate="yes" xml:space="preserve">
          <source>The order of &lt;code&gt;v1&lt;/code&gt; and &lt;code&gt;v2&lt;/code&gt; doesn&amp;rsquo;t matter.</source>
          <target state="translated">&lt;code&gt;v1&lt;/code&gt; 과 &lt;code&gt;v2&lt;/code&gt; 의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64c7894d7cfcaaec3478ec1e4aaf0c4a01f8cc6f" translate="yes" xml:space="preserve">
          <source>The order of sub-arrays is changed but their contents remains the same.</source>
          <target state="translated">하위 배열의 순서는 변경되지만 그 내용은 동일하게 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="1d4e69a308201075218d8a094df1f5f1f4d37aad" translate="yes" xml:space="preserve">
          <source>The order of the elements in the array resulting from ravel() is normally &amp;ldquo;C-style&amp;rdquo;, that is, the rightmost index &amp;ldquo;changes the fastest&amp;rdquo;, so the element after a[0,0] is a[0,1]. If the array is reshaped to some other shape, again the array is treated as &amp;ldquo;C-style&amp;rdquo;. NumPy normally creates arrays stored in this order, so ravel() will usually not need to copy its argument, but if the array was made by taking slices of another array or created with unusual options, it may need to be copied. The functions ravel() and reshape() can also be instructed, using an optional argument, to use FORTRAN-style arrays, in which the leftmost index changes the fastest.</source>
          <target state="translated">ravel ()으로 인한 배열 요소의 순서는 일반적으로 &quot;C 스타일&quot;입니다. 즉, 가장 오른쪽 인덱스가 &quot;가장 빠르게 변경됩니다&quot;이므로 a [0,0] 다음 요소는 a [0,1]입니다. . 배열의 모양이 다른 모양으로 변경되면 다시 배열이 &quot;C 스타일&quot;로 처리됩니다. NumPy는 일반적으로이 순서로 저장된 배열을 생성하므로 ravel ()은 일반적으로 인수를 복사 할 필요가 없지만 배열이 다른 배열의 슬라이스를 취하여 생성되었거나 특이한 옵션으로 생성 된 경우 복사해야 할 수 있습니다. 함수 ravel () 및 reshape ()는 선택적 인수를 사용하여 가장 왼쪽 인덱스가 가장 빠르게 변경되는 FORTRAN 스타일 배열을 사용하도록 지시 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a665b347299d28c9a4225cbaa35961f7257fdf3" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will
reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">입력 비트의 순서입니다. 'big'은 bin (val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011 =&amp;gt; ``, 'little' will reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; 을 모방합니다 . =&amp;gt; 3 = 0b00000011 =&amp;gt;``, 'little'는 순서를 반대로하여``[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3 입니다. 기본값은 'big'입니다.</target>
        </trans-unit>
        <trans-unit id="6a7badf2486ba3d65f6d452504aadca6f59aa17f" translate="yes" xml:space="preserve">
          <source>The order of the input bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order so &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">입력 비트의 순서. 'big'은 bin (val), &lt;code&gt;[0, 0, 0, 0, 0, 0, 1, 1] =&amp;gt; 3 = 0b00000011&lt;/code&gt; , 'little'은 순서를 반대로하므로 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0] =&amp;gt; 3&lt;/code&gt; . 기본값은 'big'입니다.</target>
        </trans-unit>
        <trans-unit id="284166d21f55654af6d0a1aecc95d3581a64b2f4" translate="yes" xml:space="preserve">
          <source>The order of the requsted optimizations doesn&amp;rsquo;t matter.</source>
          <target state="translated">필요한 최적화의 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c023a0582544690f15510a2492956e0e66cdc058" translate="yes" xml:space="preserve">
          <source>The order of the returned bits. &amp;lsquo;big&amp;rsquo; will mimic bin(val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt;, &amp;lsquo;little&amp;rsquo; will reverse the order to &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt;. Defaults to &amp;lsquo;big&amp;rsquo;.</source>
          <target state="translated">반환 된 비트의 순서입니다. 'big'은 bin (val), &lt;code&gt;3 = 0b00000011 =&amp;gt; [0, 0, 0, 0, 0, 0, 1, 1]&lt;/code&gt; 을 모방합니다 . 'little'는 순서를 &lt;code&gt;[1, 1, 0, 0, 0, 0, 0, 0]&lt;/code&gt; . 기본값은 'big'입니다.</target>
        </trans-unit>
        <trans-unit id="d31a5b9999b59b34b6ad9fdaccda217e19238ad4" translate="yes" xml:space="preserve">
          <source>The order or degree of the polynomial</source>
          <target state="translated">다항식의 차수 또는 차수</target>
        </trans-unit>
        <trans-unit id="eea06a8f88d6f17386cd112eab18c7ac9fc8e799" translate="yes" xml:space="preserve">
          <source>The orientation of &lt;code&gt;c&lt;/code&gt; can be changed using the &lt;code&gt;axisc&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;c&lt;/code&gt; 의 방향은 &lt;code&gt;axisc&lt;/code&gt; 키워드를 사용하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f6895b0ec7c91fa01ba724c0454c0ecbf9046ad1" translate="yes" xml:space="preserve">
          <source>The original contents of the &lt;code&gt;intent(in)&lt;/code&gt; argument may be altered by the Fortran/C function. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;intent(in)&lt;/code&gt; 인수 의 원래 내용은 Fortran / C 함수에 의해 변경 될 수 있습니다. F2PY 는 기본값 &lt;code&gt;1&lt;/code&gt; 을 사용하여 선택적 인수 &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="5b2e34a61895054c86583de1c9f28efb1bf046c4" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;coef&lt;/code&gt; attribute.</source>
          <target state="translated">다른 클래스에는 &lt;code&gt;coef&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="beffd1aec86565c0ed7e85fa9756b03e99dc1093" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;domain&lt;/code&gt; attribute.</source>
          <target state="translated">다른 클래스에는 &lt;code&gt;domain&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c7b5b660115b8d1bff6ffdc35071c1bc977b44f5" translate="yes" xml:space="preserve">
          <source>The other class must have the &lt;code&gt;window&lt;/code&gt; attribute.</source>
          <target state="translated">다른 클래스에는 &lt;code&gt;window&lt;/code&gt; 속성 이 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="208270eb05b02b535197d000879d544f3abebcde" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out 인수는 결과를 배치 할 위치를 지정합니다. out이 NULL이면 출력 배열이 작성되고, 그렇지 않으면 올바른 크기 및 유형이어야하는 출력이 출력됩니다. 출력 배열에 대한 새로운 참조는 out이 NULL이 아닌 경우에도 항상 반환됩니다. 루틴 호출자는 NULL이 아니거나 메모리 누수가 발생하는 경우 &lt;code&gt;DECREF&lt;/code&gt; 를 수행 할 책임 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1eb4436c2a0a0542bae9d8ee0693add2fca6bb8" translate="yes" xml:space="preserve">
          <source>The out argument specifies where to place the result. If out is NULL, then the output array is created, otherwise the output is placed in out which must be the correct size and type. A new reference to the output array is always returned even when out is not NULL. The caller of the routine has the responsibility to &lt;code&gt;Py_DECREF&lt;/code&gt; out if not NULL or a memory-leak will occur.</source>
          <target state="translated">out 인수는 결과를 배치 할 위치를 지정합니다. out이 NULL이면 출력 배열이 생성되고, 그렇지 않으면 출력이 올바른 크기와 유형이어야하는 out에 배치됩니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 출력 배열에 대한 새 참조는 out이 NULL이 아닌 경우에도 항상 반환됩니다. 루틴 호출자는 NULL이 아니거나 메모리 누수가 발생하는 경우 &lt;code&gt;Py_DECREF&lt;/code&gt; 출력에 대한 책임 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d41934f2889307f51eefc25e7532b745714248c8" translate="yes" xml:space="preserve">
          <source>The outer product</source>
          <target state="translated">외부 제품</target>
        </trans-unit>
        <trans-unit id="6a7d17b343c508aa5b0fa2c069711cc8be41d2b5" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">그런 다음 출력 인수 (있는 경우)가 처리되고 누락 된 반환 배열이 생성됩니다. 제공된 출력 배열이 올바른 유형이 아니거나 잘못 정렬되어 있고 버퍼 크기보다 작은 경우 특수 &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그 세트 를 사용하여 새 출력 배열이 생성됩니다 . 함수의 끝에서 &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 가 호출되어 그 내용이 출력 배열로 다시 복사됩니다. 그런 다음 출력 인수에 대한 반복기가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="eaacd893fa91168722bb422e1bd4cfd1660e87de" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">출력 인수 (있는 경우)가 처리되고 누락 된 리턴 배열이 구성됩니다. 제공된 출력 배열에 올바른 유형이 없거나 잘못 정렬 된 경우 버퍼 크기보다 작은 경우 특수 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그가 설정된 새 출력 배열이 구성됩니다 . 함수가 &lt;a href=&quot;c-api.array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 가 호출되어 그 내용이 출력 배열로 다시 복사됩니다. 그런 다음 출력 인수에 대한 반복자가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="02fbb66d65f083fd2d9e7a738b5f72feedd2f131" translate="yes" xml:space="preserve">
          <source>The output arguments (if any) are then processed and any missing return arrays are constructed. If any provided output array doesn&amp;rsquo;t have the correct type (or is mis-aligned) and is smaller than the buffer size, then a new output array is constructed with the special &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag set. At the end of the function, &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called so that its contents will be copied back into the output array. Iterators for the output arguments are then processed.</source>
          <target state="translated">그런 다음 출력 인수 (있는 경우)가 처리되고 누락 된 반환 배열이 생성됩니다. 제공된 출력 배열에 올바른 유형이 없거나 정렬이 잘못되어 버퍼 크기보다 작은 경우 특수 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그 세트 를 사용하여 새 출력 배열이 생성됩니다 . 함수의 끝에서 &lt;a href=&quot;c-api/array#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 가 호출되어 그 내용이 출력 배열로 다시 복사됩니다. 그런 다음 출력 인수에 대한 반복기가 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="f268497aae1cce8ff8c25da79f231196a245eaac" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 축을 따라 모든 값이 마스킹되는 경우 출력 배열이 마스킹됩니다. 출력이 스칼라 였고 모든 값이 마스킹 된 경우 출력이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="fb5ec377d841d6a8ac376aa017bca95b2c7ad6a2" translate="yes" xml:space="preserve">
          <source>The output array is masked where all the values along the given axis are masked: if the output would have been a scalar and that all the values are masked, then the output is &lt;code&gt;masked&lt;/code&gt;.</source>
          <target state="translated">출력 배열은 지정된 축의 모든 값이 마스킹되는 곳에서 마스킹됩니다. 출력이 스칼라이고 모든 값이 마스킹 된 경우 출력은 &lt;code&gt;masked&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7cdd30a82881324958754cfed2ed5012e49b5922" translate="yes" xml:space="preserve">
          <source>The output array of type Boolean with the same shape as a and b.</source>
          <target state="translated">a 및 b와 모양이 같은 부울 유형의 출력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f55976ddc6094b99d81ee9f07a8be602a3926550" translate="yes" xml:space="preserve">
          <source>The output array, containing the part of the content of &lt;code&gt;file&lt;/code&gt; that was matched by &lt;code&gt;regexp&lt;/code&gt;. &lt;code&gt;output&lt;/code&gt; is always a structured array.</source>
          <target state="translated">&lt;code&gt;regexp&lt;/code&gt; 와 일치하는 &lt;code&gt;file&lt;/code&gt; 내용의 일부를 포함하는 출력 배열 입니다. &lt;code&gt;output&lt;/code&gt; 은 항상 구조화 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5aa2c29b27cf9fdf4a29996c1b8c28730e8e0aea" translate="yes" xml:space="preserve">
          <source>The output array, element-wise Heaviside step function of &lt;code&gt;x1&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">출력 배열, &lt;code&gt;x1&lt;/code&gt; 의 요소 별 Heaviside 단계 함수 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="70719ba0effebe3bb3aa417f56a4a6c01822a6e7" translate="yes" xml:space="preserve">
          <source>The output array.</source>
          <target state="translated">출력 배열</target>
        </trans-unit>
        <trans-unit id="09c7e58e3fd89577e8de606a001975293d749592" translate="yes" xml:space="preserve">
          <source>The output array. The number of dimensions is the same as &lt;code&gt;a&lt;/code&gt;, but the shape can be different. This depends on whether &lt;code&gt;func&lt;/code&gt; changes the shape of its output with respect to its input.</source>
          <target state="translated">출력 배열 측정의 수는 동일하다 이지만 형상은 다를 수있다. 이는 &lt;code&gt;func&lt;/code&gt; 이 입력과 관련하여 출력 모양을 변경 하는지 여부에 따라 다릅니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d041e4d25d02f826463aa1a16a95e06fcf896235" translate="yes" xml:space="preserve">
          <source>The output array. The shape of &lt;code&gt;out&lt;/code&gt; is identical to the shape of &lt;code&gt;arr&lt;/code&gt;, except along the &lt;code&gt;axis&lt;/code&gt; dimension. This axis is removed, and replaced with new dimensions equal to the shape of the return value of &lt;code&gt;func1d&lt;/code&gt;. So if &lt;code&gt;func1d&lt;/code&gt; returns a scalar &lt;code&gt;out&lt;/code&gt; will have one fewer dimensions than &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">출력 배열 형상 &lt;code&gt;out&lt;/code&gt; 의 형상과 동일하다 &lt;code&gt;arr&lt;/code&gt; 따라 제외 &lt;code&gt;axis&lt;/code&gt; 치수. 이 축은 제거되고 &lt;code&gt;func1d&lt;/code&gt; 의 반환 값 모양과 동일한 새 치수로 대체됩니다 . 따라서 &lt;code&gt;func1d&lt;/code&gt; 가 반환하면 스칼라 &lt;code&gt;out&lt;/code&gt; 은 &lt;code&gt;arr&lt;/code&gt; 보다 하나의 치수가 작습니다 .</target>
        </trans-unit>
        <trans-unit id="8620240fb2ec2168fe1488fc7c50d1b1766a372e" translate="yes" xml:space="preserve">
          <source>The output at position m is the m-th element of the array in &lt;code&gt;choicelist&lt;/code&gt; where the m-th element of the corresponding array in &lt;code&gt;condlist&lt;/code&gt; is True.</source>
          <target state="translated">위치 m의 출력은 &lt;code&gt;choicelist&lt;/code&gt; 에있는 배열 의 m 번째 요소이며 &lt;code&gt;condlist&lt;/code&gt; 에있는 해당 배열의 m 번째 요소 는 True입니다.</target>
        </trans-unit>
        <trans-unit id="0043f09ea13cb649da8f2d6d2895f2519551c732" translate="yes" xml:space="preserve">
          <source>The output data type. It must be specified as either a string of typecode characters or a list of data type specifiers. There should be one data type specifier for each output.</source>
          <target state="translated">출력 데이터 유형 유형 코드 문자 문자열 또는 데이터 유형 지정자 목록으로 지정해야합니다. 각 출력마다 하나의 데이터 유형 지정자가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="abacf3469f99309139bddd0efe494fc74e079f06" translate="yes" xml:space="preserve">
          <source>The output has the same shape as the input and each 1-D loop operates over</source>
          <target state="translated">출력은 입력과 동일한 모양을 가지며 각 1D 루프는</target>
        </trans-unit>
        <trans-unit id="63770907dcff4eb26363f61fd3098799f014e4b4" translate="yes" xml:space="preserve">
          <source>The output is a &lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;tuple&lt;/a&gt; with three elements, which means that this is a three-dimensional array. In fact, since this is a color image, and we have used the &lt;code&gt;imread&lt;/code&gt; function to read it, the data is organized in three 2D arrays, representing color channels (in this case, red, green and blue - RGB). You can see this by looking at the shape above: it indicates that we have an array of 3 matrices, each having shape 768x1024.</source>
          <target state="translated">출력은 3 개의 요소 가있는 &lt;a href=&quot;https://docs.python.org/dev/tutorial/datastructures.html#tut-tuples&quot;&gt;튜플&lt;/a&gt; 이며 이는 3 차원 배열임을 의미합니다. 실제로 이것은 컬러 이미지이고 &lt;code&gt;imread&lt;/code&gt; 함수를 사용하여 읽었으므로 데이터는 컬러 채널을 나타내는 3 개의 2D 배열로 구성됩니다 (이 경우 빨강, 녹색 및 파랑-RGB). 위의 모양을 보면 알 수 있습니다. 이것은 각각 768x1024 모양을 가진 3 개의 행렬 배열이 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2e90afe5c10bc3b541c84caa9141acf978817abb" translate="yes" xml:space="preserve">
          <source>The output is left-padded by the length of the prefix string, and wrapping is forced at the column &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt;. It should be noted that the content of prefix and suffix strings are not included in the output.</source>
          <target state="translated">출력은 접두사 문자열의 길이만큼 왼쪽에 채워지고 &lt;code&gt;max_line_width - len(suffix)&lt;/code&gt; 열에 줄 바꿈이 적용 됩니다 . 접두사 및 접미사 문자열의 내용은 출력에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e11dba8a2e35e34ff280ff12d3cc6c9a772a17ab" translate="yes" xml:space="preserve">
          <source>The output is sorted along the key.</source>
          <target state="translated">출력은 키를 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="8da09507a5558a4c68826bbfbad5a55048ee486a" translate="yes" xml:space="preserve">
          <source>The output is the same shape and type as x and is found by calling the functions in &lt;code&gt;funclist&lt;/code&gt; on the appropriate portions of &lt;code&gt;x&lt;/code&gt;, as defined by the boolean arrays in &lt;code&gt;condlist&lt;/code&gt;. Portions not covered by any condition have a default value of 0.</source>
          <target state="translated">출력은 x와 동일한 모양과 유형이며 &lt;code&gt;funclist&lt;/code&gt; 의 부울 배열에 의해 정의 된대로 &lt;code&gt;x&lt;/code&gt; 의 적절한 부분 에서 funclist 의 함수를 호출하여 &lt;code&gt;condlist&lt;/code&gt; . 어떤 조건에서 다루지 않는 부분의 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="f50dbb1c407bc1480ac12746928854d5651c29cc" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;argwhere&lt;/code&gt; is not suitable for indexing arrays. For this purpose use &lt;code&gt;nonzero(a)&lt;/code&gt; instead.</source>
          <target state="translated">&lt;code&gt;argwhere&lt;/code&gt; 의 출력은 배열 인덱싱에 적합하지 않습니다. 이를 위해 &lt;code&gt;nonzero(a)&lt;/code&gt; 대신 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2f4440d892c3898fd91df0e56df25108b1e0bf3c" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;#ufuncs-overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">모든 입력 인수가 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 및 해당 메서드의 출력은 반드시 ndarray 일 필요 는 없습니다 . 실제로 입력이 &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메서드를 정의하면 제어가 해당 함수로 완전히 전달됩니다. 즉, ufunc가 &lt;a href=&quot;#ufuncs-overrides&quot;&gt;재정의&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9cad5509a2704fc8189ddac84d202e22c4e895ee" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">ufunc (및 그 방법)의 출력은 반드시 없다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 모든 입력 인자가 아닌 경우 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; 이&lt;/a&gt; . 실제로 어떤 입력이 &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메소드를 정의하면 제어가 해당 함수에 완전히 전달됩니다. 즉, ufunc가 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/ufuncs.overrides&quot;&gt;재정의&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="6599e81d2d214234687adf6fb69ac2c773f47b7b" translate="yes" xml:space="preserve">
          <source>The output of the ufunc (and its methods) is not necessarily an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if all input arguments are not &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. Indeed, if any input defines an &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, control will be passed completely to that function, i.e., the ufunc is &lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;overridden&lt;/a&gt;.</source>
          <target state="translated">모든 입력 인수가 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 및 해당 메서드의 출력은 반드시 ndarray 일 필요 는 없습니다 . 실제로 입력이 &lt;a href=&quot;arrays.classes#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메서드를 정의하면 제어가 해당 함수로 완전히 전달됩니다. 즉, ufunc가 &lt;a href=&quot;https://numpy.org/doc/1.19/reference/ufuncs.overrides&quot;&gt;재정의&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="dffd3ba3dd5dfca8ee836a2b9bb97cc8318013a0" translate="yes" xml:space="preserve">
          <source>The output shape in the dense case is obtained by prepending the number of dimensions in front of the tuple of dimensions, i.e. if &lt;code&gt;dimensions&lt;/code&gt; is a tuple &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the output shape is &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt;.</source>
          <target state="translated">치밀한 경우의 출력 형태는 치수의 튜플 앞에 치수의 수를 앞에 붙여서, 즉 &lt;code&gt;dimensions&lt;/code&gt; 가 길이 &lt;code&gt;N&lt;/code&gt; 의 튜플 &lt;code&gt;(r0, ..., rN-1)&lt;/code&gt; 인 경우 출력 형태는 &lt;code&gt;(N, r0, ..., rN-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58a2d32420f4e758be11c792f006660e86c89ee" translate="yes" xml:space="preserve">
          <source>The output type is determined by evaluating the first element of the input, unless it is specified:</source>
          <target state="translated">출력 유형은 지정되지 않은 한 입력의 첫 번째 요소를 평가하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="9fa5a7d08b947585ca82353fe9713958d5e25120" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 와 유사하게 출력 에는 모든 축의 하위 코너에있는 0 주파수에 대한 항, 모든 축의 전반부에있는 양의 주파수 항, 모든 축의 중간에있는 Nyquist 주파수에 대한 항 및 음수에 대한 항이 포함됩니다. 감소하는 음의 주파수 순서로 모든 축의 후반부에있는 주파수 항.</target>
        </trans-unit>
        <trans-unit id="810deb62d102585296e67e3c187bb792f35878ab" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">출력값은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 와 유사하게 변환 된 축의 하위 코너에있는 0 주파수에 대한 항, 이러한 축의 전반부에있는 양의 주파수 항, 축 중간에있는 나이 퀴 스트 주파수에 대한 항 및 감소하는 음의 주파수 순서로 축의 후반부에 음의 주파수 항을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="a8b2e53b333d791e589c426b13ebb877541abc09" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of all axes, the positive frequency terms in the first half of all axes, the term for the Nyquist frequency in the middle of all axes and the negative frequency terms in the second half of all axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 와 유사하게 출력 에는 모든 축의 하위 코너에있는 제로 주파수에 대한 항, 모든 축의 전반에있는 양의 주파수 항, 모든 축의 가운데에있는 나이키 스트 주파수에 대한 항 및 음수가 포함됩니다. 음의 주파수가 감소하는 순서로 모든 축의 후반부에있는 주파수 항.</target>
        </trans-unit>
        <trans-unit id="2e04271603cd70e84ef996c185fb1fb3c75eb84c" translate="yes" xml:space="preserve">
          <source>The output, analogously to &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt;, contains the term for zero frequency in the low-order corner of the transformed axes, the positive frequency terms in the first half of these axes, the term for the Nyquist frequency in the middle of the axes and the negative frequency terms in the second half of the axes, in order of decreasingly negative frequency.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 와 유사하게 출력 에는 변환 된 축의 하위 코너에있는 제로 주파수에 대한 항,이 축의 전반에있는 양의 주파수 항, 축의 중간에있는 나이키 스트 주파수에 대한 항 및 음의 주파수가 감소하는 순서로 축의 후반부에서 음의 주파수 항.</target>
        </trans-unit>
        <trans-unit id="ed35a4029927607a6ec8e44ffef5c4477bb8a981" translate="yes" xml:space="preserve">
          <source>The package ensures that masked entries are not used in computations.</source>
          <target state="translated">패키지는 마스크 된 항목이 계산에 사용되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="f6f78aee1988dc701d01aad263b1da5166d3a53f" translate="yes" xml:space="preserve">
          <source>The padding character to use (default is space).</source>
          <target state="translated">사용할 패딩 문자 (기본값은 공백)입니다.</target>
        </trans-unit>
        <trans-unit id="7e8fe55b063cd4163ba4aeac13d68612e9f5d53b" translate="yes" xml:space="preserve">
          <source>The padding function, if used, should modify a rank 1 array in-place. It has the following signature:</source>
          <target state="translated">패딩 기능을 사용하는 경우 순위 1 배열을 그 자리에서 수정해야합니다. 다음과 같은 서명이 있습니다.</target>
        </trans-unit>
        <trans-unit id="91842f7bb32c0502ac19c7e4e8ff23d234b3cdfd" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;oa_ndim&lt;/code&gt;, when not zero or -1, specifies the number of dimensions that will be iterated with customized broadcasting. If it is provided, &lt;code&gt;op_axes&lt;/code&gt; must and &lt;code&gt;itershape&lt;/code&gt; can also be provided. The &lt;code&gt;op_axes&lt;/code&gt; parameter let you control in detail how the axes of the operand arrays get matched together and iterated. In &lt;code&gt;op_axes&lt;/code&gt;, you must provide an array of &lt;code&gt;nop&lt;/code&gt; pointers to &lt;code&gt;oa_ndim&lt;/code&gt;-sized arrays of type &lt;code&gt;npy_intp&lt;/code&gt;. If an entry in &lt;code&gt;op_axes&lt;/code&gt; is NULL, normal broadcasting rules will apply. In &lt;code&gt;op_axes[j][i]&lt;/code&gt; is stored either a valid axis of &lt;code&gt;op[j]&lt;/code&gt;, or -1 which means &lt;code&gt;newaxis&lt;/code&gt;. Within each &lt;code&gt;op_axes[j]&lt;/code&gt; array, axes may not be repeated. The following example is how normal broadcasting applies to a 3-D array, a 2-D array, a 1-D array and a scalar.</source>
          <target state="translated">매개 변수 &lt;code&gt;oa_ndim&lt;/code&gt; 은 0이 아니거나 -1이 아닌 경우 사용자 지정 브로드 캐스트로 반복 될 차원 수를 지정합니다. 제공되는 경우 &lt;code&gt;op_axes&lt;/code&gt; 가 필요하고 &lt;code&gt;itershape&lt;/code&gt; 도 제공 할 수 있습니다. &lt;code&gt;op_axes&lt;/code&gt; 피연산자 배열의 축이 서로 일치하고 반복되는 방법을 보자 매개 변수는 구체적으로 제어 할 수 있습니다. 에서 &lt;code&gt;op_axes&lt;/code&gt; , 당신은의 배열을 제공해야 &lt;code&gt;nop&lt;/code&gt; 에 대한 포인터를 &lt;code&gt;oa_ndim&lt;/code&gt; 형의 2N 크기 배열 &lt;code&gt;npy_intp&lt;/code&gt; 을 . &lt;code&gt;op_axes&lt;/code&gt; 의 항목 이 NULL이면 일반 브로드 캐스트 규칙이 적용됩니다. 에서는 &lt;code&gt;op_axes[j][i]&lt;/code&gt; 하나의 유효 축 저장 &lt;code&gt;op[j]&lt;/code&gt; -1하는 수단 &lt;code&gt;newaxis&lt;/code&gt; . 각 &lt;code&gt;op_axes[j]&lt;/code&gt; 배열 내에서 축이 반복되지 않을 수 있습니다. 다음 예제는 일반 브로드 캐스트가 3D 배열, 2D 배열, 1D 배열 및 스칼라에 적용되는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="6f24110e4501ed427c7d67150722a36e47c9eb87" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자체 및 &lt;code&gt;c&lt;/code&gt; 요소와 함께 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="81b1fc95a0e75fbef51d185592084c9ff4aaba4c" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;x&lt;/code&gt; is converted to an array only if it is a tuple or a list, otherwise it is treated as a scalar. In either case, either &lt;code&gt;x&lt;/code&gt; or its elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;r&lt;/code&gt; 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="fed3e36a151b3d1051d8c0d0e63efcd30243f871" translate="yes" xml:space="preserve">
          <source>The parameter &lt;em&gt;dtype&lt;/em&gt; specifies the data type over which a reduction operation (like summing) should take place. The default reduce data type is the same as the data type of &lt;em&gt;self&lt;/em&gt;. To avoid overflow, it can be useful to perform the reduction using a larger data type.</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt; 매개 변수 는 합산과 같은 축소 연산이 수행되어야하는 데이터 유형을 지정합니다. 기본 축소 데이터 형식은 &lt;em&gt;self&lt;/em&gt; 데이터 형식과 동일합니다 . 오버플로를 피하려면 더 큰 데이터 유형을 사용하여 축소를 수행하는 것이 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5047704927c94b8b6586c636aa20a6789550df01" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리되며 변환 후 동일한 모양을 가져야합니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ab30d7deae7ce08d9cafc57f0a0d9da22b443d75" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 는 터플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dea737cd6cbb9eb4fabc09fa179fafbb398a4ba4" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars and they must have the same shape after conversion. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 는 튜플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리되며 변환 후 동일한 모양을 가져야합니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="942247face18dfe9d547bf9f163892321bfcd347" translate="yes" xml:space="preserve">
          <source>The parameters &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; are converted to arrays only if they are tuples or a lists, otherwise they are treated as a scalars. In either case, either &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt; or their elements must support multiplication and addition both with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">매개 변수 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 는 튜플 또는 목록 인 경우에만 배열로 변환되며, 그렇지 않으면 스칼라로 처리됩니다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소 모두와 곱셈과 덧셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2f059fed0e631d6e93c76ef517cee1b4493e82a4" translate="yes" xml:space="preserve">
          <source>The path of the template, relatively to the current package path.</source>
          <target state="translated">현재 패키지 경로에 상대적인 템플릿 경로입니다.</target>
        </trans-unit>
        <trans-unit id="a3bed8bc2ca97f198b6eb9b3e908d4ed3c7c443d" translate="yes" xml:space="preserve">
          <source>The path to the file for which the doctests are run.</source>
          <target state="translated">doctest가 실행되는 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="decb24fde62e2b923b5a976163e8c054497d68bf" translate="yes" xml:space="preserve">
          <source>The pattern for using nested iterators is as follows.</source>
          <target state="translated">중첩 된 반복자를 사용하는 패턴은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9db61e58e4763f03cd16195e5ed8a40825c96961" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패턴은 더 복잡한 다른 생성기와 유사합니다. 레거시 &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 생성기 의 정상적인 성능은 Ziggurat 생성기 대신 Box-Muller 변환을 사용하기 때문에 다른 생성기보다 훨씬 낮습니다. 지수의 성능 차이는 CDF를 반전하기 위해 로그 함수를 계산하는 비용으로 인해 큽니다. MT19973 레이블이 붙은 열은 RandomState와 동일한 32 비트 생성기를 &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 하지만 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 사용하여 임의 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="82eacc753e4241f8676568f6609cbd6d30cfc9ba" translate="yes" xml:space="preserve">
          <source>The pattern is similar for other, more complex generators. The normal performance of the legacy &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; generator is much lower than the other since it uses the Box-Muller transformation rather than the Ziggurat generator. The performance gap for Exponentials is also large due to the cost of computing the log function to invert the CDF. The column labeled MT19973 is used the same 32-bit generator as &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; but produces random values using &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 패턴은 더 복잡한 다른 발전기와 비슷합니다. 레거시 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 생성기 의 일반적인 성능은 Ziggurat 생성기보다는 Box-Muller 변환을 사용하므로 다른 것보다 훨씬 낮습니다. CDF를 반전시키기 위해 로그 함수를 계산하는 비용으로 인해 지수의 성능 격차도 큽니다. MT19973이라는 열은 RandomState와 동일한 32 비트 생성기에서 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 되지만 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 사용하여 임의의 값을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="5f948cd9daa190278b24b7616c4acaf6e82e63af" translate="yes" xml:space="preserve">
          <source>The payment is computed by solving the equation:</source>
          <target state="translated">지불은 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="7c38a52dfb1124cf95fad23836990fb2bf0bbca3" translate="yes" xml:space="preserve">
          <source>The percentage of waves larger than 3 meters is:</source>
          <target state="translated">3 미터보다 큰 파도의 비율은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf26c5d0de790b76d482846fdfc7d5a573504f09" translate="yes" xml:space="preserve">
          <source>The performance of 64-bit generators on 32-bit Windows is much lower than on 64-bit operating systems due to register width. MT19937, the generator that has been in NumPy since 2005, operates on 32-bit integers.</source>
          <target state="translated">32 비트 Windows에서 64 비트 생성기의 성능은 레지스터 너비로 인해 64 비트 운영 체제보다 훨씬 낮습니다. 2005 년 이래 NumPy에있는 발전기 인 MT19937은 32 비트 정수로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="02f4c7c728252209e49cade8944d95bdb15fb9ef" translate="yes" xml:space="preserve">
          <source>The place in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="translated">ufunc에 대한 실제 계산에 해당하는 코드의 위치는 / * BEGIN 기본 ufunc 계산 * / 및 / * END 기본 ufunc 계산 * /으로 표시됩니다. 이러한 줄 사이의 코드는 고유 한 ufunc를 만들기 위해 변경해야하는 주요 사항입니다.</target>
        </trans-unit>
        <trans-unit id="e0a72aed7747ec5b4e706a7296ecd1eb9faae060" translate="yes" xml:space="preserve">
          <source>The places in the code corresponding to the actual computations for the ufunc are marked with /*BEGIN main ufunc computation*/ and /*END main ufunc computation*/. The code in between those lines is the primary thing that must be changed to create your own ufunc.</source>
          <target state="translated">ufunc에 대한 실제 계산에 해당하는 코드의 위치는 / * BEGIN 기본 ufunc 계산 * / 및 / * END 기본 ufunc 계산 * /으로 표시됩니다. 이러한 줄 사이의 코드는 고유 한 ufunc를 만들기 위해 변경해야하는 주요 사항입니다.</target>
        </trans-unit>
        <trans-unit id="4a5ee23f497e38c29e0616fdcc0bb0ea7d4426f2" translate="yes" xml:space="preserve">
          <source>The points about sequence size and speed are particularly important in scientific computing. As a simple example, consider the case of multiplying each element in a 1-D sequence with the corresponding element in another sequence of the same length. If the data are stored in two Python lists, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, we could iterate over each element:</source>
          <target state="translated">시퀀스 크기와 속도에 대한 요점은 과학 컴퓨팅에서 특히 중요합니다. 간단한 예로서 1 차원 시퀀스의 각 요소를 길이가 같은 다른 시퀀스의 해당 요소와 곱하는 경우를 고려하십시오. 데이터가 두 개의 Python 목록 &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에 저장되면 각 요소를 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0779c65ec163a12759193f89f82723f01bb394dd" translate="yes" xml:space="preserve">
          <source>The polynomial coefficients</source>
          <target state="translated">다항식 계수</target>
        </trans-unit>
        <trans-unit id="daaa36d42f5e3da309c9eab093a92efe7a0076ca" translate="yes" xml:space="preserve">
          <source>The polynomial convenience classes cannot be passed to ufuncs</source>
          <target state="translated">다항식 편의 클래스는 ufuncs에 전달할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="b9ed1328025571c1195a04bff5fdf98ece032c1f" translate="yes" xml:space="preserve">
          <source>The polynomial resulting from the multiplication of the inputs. If either inputs is a poly1d object, then the output is also a poly1d object. Otherwise, it is a 1D array of polynomial coefficients from highest to lowest degree.</source>
          <target state="translated">입력 값의 곱셈으로 인한 다항식입니다. 입력 중 하나가 poly1d 객체이면 출력도 poly1d 객체입니다. 그렇지 않으면 다항식 계수의 1D 배열이 최고에서 최저까지입니다.</target>
        </trans-unit>
        <trans-unit id="515cfb6ef96288d03850b077c1e2ea4a5a576f0e" translate="yes" xml:space="preserve">
          <source>The polynomial series type class to which the current instance should be converted. If kind is None, then the class of the current instance is used.</source>
          <target state="translated">현재 인스턴스를 변환 할 다항식 계열 유형 클래스입니다. kind가 None이면 현재 인스턴스의 클래스가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="75f7f784e98730c24c6aac1a9a0a155ec4addf47" translate="yes" xml:space="preserve">
          <source>The polynomial&amp;rsquo;s coefficients, in decreasing powers, or if the value of the second parameter is True, the polynomial&amp;rsquo;s roots (values where the polynomial evaluates to 0). For example, &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; returns an object that represents</source>
          <target state="translated">다항식 계수 (감소 전력) 또는 두 번째 매개 변수의 값이 True 인 경우 다항식의 근 (다항식이 0으로 평가되는 값)입니다. 예를 들어 &lt;code&gt;poly1d([1, 2, 3])&lt;/code&gt; 는 다음을 나타내는 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="80160250c999cde418e5655d194ff040c11e355e" translate="yes" xml:space="preserve">
          <source>The position,</source>
          <target state="translated">위치,</target>
        </trans-unit>
        <trans-unit id="04babac298b058269a3dd833ef7829f7e3894479" translate="yes" xml:space="preserve">
          <source>The possibly nested list of array elements.</source>
          <target state="translated">배열 요소의 중첩 가능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5cb3bd54a03911e525c1ba1e36e3cfe8b319cbe5" translate="yes" xml:space="preserve">
          <source>The power function distribution is just the inverse of the Pareto distribution. It may also be seen as a special case of the Beta distribution.</source>
          <target state="translated">전력 함수 분포는 파레토 분포의 역수입니다. 베타 배포의 특별한 경우로 보일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c353d3430d1303bc49c56d7ffa562f5074d9b47" translate="yes" xml:space="preserve">
          <source>The power(s) to which &lt;code&gt;x&lt;/code&gt; is raised. If &lt;code&gt;x&lt;/code&gt; contains multiple values, &lt;code&gt;p&lt;/code&gt; has to either be a scalar, or contain the same number of values as &lt;code&gt;x&lt;/code&gt;. In the latter case, the result is &lt;code&gt;x[0]**p[0], x[1]**p[1], ...&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 를 올릴 수있는 거듭 제곱 입니다. &lt;code&gt;x&lt;/code&gt; 에 여러 값이 포함 된 경우 &lt;code&gt;p&lt;/code&gt; 는 스칼라이거나 &lt;code&gt;x&lt;/code&gt; 와 동일한 수의 값을 포함해야합니다 . 후자의 경우 결과는 &lt;code&gt;x[0]**p[0], x[1]**p[1], ...&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dc85a1fd23e1e3db0366910d77d438dbfca5d6af" translate="yes" xml:space="preserve">
          <source>The precision of &lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;numpy.number&lt;/code&gt;&lt;/a&gt; subclasses is treated as a covariant generic parameter (see &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt;), simplifying the annoting of proccesses involving precision-based casting.</source>
          <target state="translated">&lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt; &lt;code&gt;numpy.number&lt;/code&gt; &lt;/a&gt; 서브 클래스 의 정밀도는 공변 일반 매개 변수 ( &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt; &lt;code&gt;NBitBase&lt;/code&gt; &lt;/a&gt; 참조 ) 로 처리되어 정밀도 기반 캐스팅과 관련된 프로세스의 주석을 단순화합니다.</target>
        </trans-unit>
        <trans-unit id="e709f72b7679480004c48b6a53b93936d4d5cd1a" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on GitHub (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="translated">문서를 업데이트하는 선호되는 방법은 GitHub에서 pull 요청을 제출하는 것입니다 ( &lt;a href=&quot;docs/index&quot;&gt;문서 색인&lt;/a&gt; 참조 ). NumPy 문서를 더욱 개선 할 수 있도록 도와주세요!</target>
        </trans-unit>
        <trans-unit id="65b60415cb79d4266b3f17e50b1894cd53e37067" translate="yes" xml:space="preserve">
          <source>The preferred way to update the documentation is by submitting a pull request on Github (see the &lt;a href=&quot;docs/index&quot;&gt;Documentation Index&lt;/a&gt;). Please help us to further improve the NumPy documentation!</source>
          <target state="translated">문서를 업데이트하는 선호하는 방법은 Github에서 pull 요청을 제출하는 것입니다 ( &lt;a href=&quot;docs/index&quot;&gt;문서 색인&lt;/a&gt; 참조 ). NumPy 문서를 더욱 개선 할 수 있도록 도와주세요!</target>
        </trans-unit>
        <trans-unit id="2f79358f94b924f7a1e059d54f311b3bb21fdafb" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">병렬 응용 프로그램에서 BitGenerator를 사용하는 선호되는 방법은 &lt;a href=&quot;generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;SeedSequence.spawn&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 엔트로피 값을 얻고이를 사용하여 새 BitGenerator를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bce0b83b0022d3f62b001c90ef9147d9a4659969" translate="yes" xml:space="preserve">
          <source>The preferred way to use a BitGenerator in parallel applications is to use the &lt;code&gt;SeedSequence.spawn&lt;/code&gt; method to obtain entropy values, and to use these to generate new BitGenerators:</source>
          <target state="translated">병렬 응용 프로그램에서 &lt;code&gt;SeedSequence.spawn&lt;/code&gt; 를 사용하는 기본 방법 은 SeedSequence.spawn 메서드를 사용하여 엔트로피 값을 얻고이 값을 사용하여 새 BitGenerator를 생성하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="7ca668d501fbd18bd9dc320e9a4abf1ee3d102d7" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type specific C files generated (extension: .c) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce .h files).</source>
          <target state="translated">일반 유형 C 소스 파일의 전처리 (NumPy에서 또는 NumPy Distutils를 사용하는 타사 패키지에 상관없이)는 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py에&lt;/a&gt; 의해 수행됩니다 . 빌드 프로세스 중 이러한 모듈에서 생성 된 유형별 C 파일 (확장자 : .c)을 컴파일 할 준비가되었습니다. 이 형식의 일반 유형은 C 헤더 파일 (.h 파일을 생성하기 위해 사전 처리됨)에도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="56cdda624db28589a66dbc09b61a222075e2ac43" translate="yes" xml:space="preserve">
          <source>The preprocessing of generically-typed C source files (whether in NumPy proper or in any third party package using NumPy Distutils) is performed by &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;conv_template.py&lt;/a&gt;. The type-specific C files generated (extension: &lt;code&gt;.c&lt;/code&gt;) by these modules during the build process are ready to be compiled. This form of generic typing is also supported for C header files (preprocessed to produce &lt;code&gt;.h&lt;/code&gt; files).</source>
          <target state="translated">일반 형식의 C 소스 파일 (NumPy 적절한 또는 NumPy Distutils를 사용하는 타사 패키지)의 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/distutils/conv_template.py&quot;&gt;전처리&lt;/a&gt; 는 conv_template.py에 의해 수행됩니다 . 빌드 프로세스 중에 이러한 모듈에 의해 생성 된 유형별 C 파일 (확장자 : &lt;code&gt;.c&lt;/code&gt; )은 컴파일 할 준비가되었습니다. 이 형식의 일반 유형은 C 헤더 파일 ( &lt;code&gt;.h&lt;/code&gt; 파일 을 생성하기 위해 사전 처리됨 )에 대해서도 지원됩니다 .</target>
        </trans-unit>
        <trans-unit id="79ca2b18555d36b1c58583e3de2322375811401a" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 의 존재는 또한 &lt;code&gt;arr&lt;/code&gt; 이 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 사용자 정의 클래스의 인스턴스 일 때 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;arr + obj&lt;/code&gt; 및 &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 와 같은 이진 연산을 처리 하는 방법에 영향을줍니다 . 두 가지 가능성이 있습니다. 경우 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 나타나지 않고 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 다음 &lt;code&gt;ndarray.__add__&lt;/code&gt; 과 친구들은 그 의미하는 ufunc 기계에 위임합니다 &lt;code&gt;arr + obj&lt;/code&gt; 된다 &lt;code&gt;np.add(arr, obj)&lt;/code&gt; 한 다음 &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; 를 발동 할 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; . 배열처럼 작동하는 객체를 정의하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="40d6e2ba786e2b9884243f86e826abd1b1d0b0e2" translate="yes" xml:space="preserve">
          <source>The presence of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; also influences how &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; handles binary operations like &lt;code&gt;arr + obj&lt;/code&gt; and &lt;code&gt;arr
&amp;lt; obj&lt;/code&gt; when &lt;code&gt;arr&lt;/code&gt; is an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;obj&lt;/code&gt; is an instance of a custom class. There are two possibilities. If &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is present and not None, then &lt;code&gt;ndarray.__add__&lt;/code&gt; and friends will delegate to the ufunc machinery, meaning that &lt;code&gt;arr + obj&lt;/code&gt; becomes &lt;code&gt;np.add(arr, obj)&lt;/code&gt;, and then &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt; invokes &lt;code&gt;obj.__array_ufunc__&lt;/code&gt;. This is useful if you want to define an object that acts like an array.</source>
          <target state="translated">&lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 의 존재는 또한 &lt;code&gt;arr&lt;/code&gt; 이 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 사용자 정의 클래스의 인스턴스 일 때 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;arr + obj&lt;/code&gt; 및 &lt;code&gt;arr &amp;lt; obj&lt;/code&gt; 와 같은 이진 연산을 처리 하는 방법에 영향을줍니다 . 두 가지 가능성이 있습니다. 경우 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 존재하지 없음이며, 다음 &lt;code&gt;ndarray.__add__&lt;/code&gt; 과 친구들은 그 의미하는 ufunc 기계에 위임합니다 &lt;code&gt;arr + obj&lt;/code&gt; 된다 &lt;code&gt;np.add(arr, obj)&lt;/code&gt; 한 다음 &lt;a href=&quot;generated/numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; &lt;/a&gt; 를 발동 할 &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; . 이것은 배열처럼 작동하는 객체를 정의하려는 경우에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="6adb356cfd1303c61f397a436f3cf821b0707e98" translate="yes" xml:space="preserve">
          <source>The presence of a header in the file can hinder data processing. In that case, we need to use the &lt;code&gt;skip_header&lt;/code&gt; optional argument. The values of this argument must be an integer which corresponds to the number of lines to skip at the beginning of the file, before any other action is performed. Similarly, we can skip the last &lt;code&gt;n&lt;/code&gt; lines of the file by using the &lt;code&gt;skip_footer&lt;/code&gt; attribute and giving it a value of &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="translated">파일에 헤더가 있으면 데이터 처리를 방해 할 수 있습니다. 이 경우 &lt;code&gt;skip_header&lt;/code&gt; 선택적 인수 를 사용해야합니다 . 이 인수의 값은 다른 조치가 수행되기 전에 파일 시작 부분에서 건너 뛸 행 수에 해당하는 정수 여야합니다. 마찬가지로 &lt;code&gt;skip_footer&lt;/code&gt; 속성 을 사용하고 &lt;code&gt;n&lt;/code&gt; 값을 지정 하여 파일 의 마지막 &lt;code&gt;n&lt;/code&gt; 행을 건너 뛸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e5f36326e83630873ee2db09163f521fed09ccf8" translate="yes" xml:space="preserve">
          <source>The present value is computed by solving the equation:</source>
          <target state="translated">현재 값은 다음 방정식을 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="601986bff68f0c999502156a5c8a6f32ded002a4" translate="yes" xml:space="preserve">
          <source>The primary advantage of using array scalars is that they preserve the array type (Python may not have a matching scalar type available, e.g. &lt;code&gt;int16&lt;/code&gt;). Therefore, the use of array scalars ensures identical behaviour between arrays and scalars, irrespective of whether the value is inside an array or not. NumPy scalars also have many of the same methods arrays do.</source>
          <target state="translated">배열 스칼라 사용의 주요 이점은 배열 유형을 보존한다는 것입니다 (Python에는 사용 가능한 일치하는 스칼라 유형 (예 : &lt;code&gt;int16&lt;/code&gt; ) 가 없을 수 있음 ). 따라서 배열 스칼라를 사용하면 값이 배열 내부에 있는지 여부에 관계없이 배열과 스칼라간에 동일한 동작이 보장됩니다. NumPy 스칼라에는 배열과 동일한 메서드가 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c51c177d3ffae7eeb654a1cd5049b77b590c4db" translate="yes" xml:space="preserve">
          <source>The primitive types supported are tied closely to those in C:</source>
          <target state="translated">지원되는 기본 유형은 C의 유형과 밀접하게 연결되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="8faab5fdb76f1a3f47be9fc86bef262e2ab4b27a" translate="yes" xml:space="preserve">
          <source>The probabilities associated with each entry in a. If not given the sample assumes a uniform distribution over all entries in a.</source>
          <target state="translated">의 각 항목과 관련된 확률 제시되지 않은 경우, 표본은 a.</target>
        </trans-unit>
        <trans-unit id="8e475ecd8059b20acc5cee6528910a74a85f3b11" translate="yes" xml:space="preserve">
          <source>The probability density for the Gamma distribution is</source>
          <target state="translated">감마 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="de744fd74c21b122de22a0d8e948a2a51ccc2b96" translate="yes" xml:space="preserve">
          <source>The probability density for the Gaussian distribution is</source>
          <target state="translated">가우스 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="5905e8ef12f7d0d9eb54f382d72998ae48c8ef44" translate="yes" xml:space="preserve">
          <source>The probability density for the Gumbel distribution is</source>
          <target state="translated">Gumbel 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="bfb8724927e73ab8d936772b36c634818f86c5a4" translate="yes" xml:space="preserve">
          <source>The probability density for the Hypergeometric distribution is</source>
          <target state="translated">초기 하 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="f8985b96e26b0408a1f84b2787ee767e62c90303" translate="yes" xml:space="preserve">
          <source>The probability density for the Log Series distribution is</source>
          <target state="translated">로그 시리즈 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="99fc9473ccfc113313d9fd374b914f025b58f310" translate="yes" xml:space="preserve">
          <source>The probability density for the Logistic distribution is</source>
          <target state="translated">로지스틱 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="7985bdd977289b5652a3a0bba81a5da1bd3adf6d" translate="yes" xml:space="preserve">
          <source>The probability density for the Pareto distribution is</source>
          <target state="translated">파레토 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="238160654ada0174d17d83e1f0d7a26707c02c8d" translate="yes" xml:space="preserve">
          <source>The probability density for the Weibull distribution is</source>
          <target state="translated">와 이블 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="fc3b79ebd29285bfc80812044ba5bd995aaaa06a" translate="yes" xml:space="preserve">
          <source>The probability density for the Zipf distribution is</source>
          <target state="translated">Zipf 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="bb707b06597dece119e6e3ebea40c8f15c1cb44f" translate="yes" xml:space="preserve">
          <source>The probability density for the binomial distribution is</source>
          <target state="translated">이항 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="6264a2e3e986c29af2fd700f69cafdda6f6c9d98" translate="yes" xml:space="preserve">
          <source>The probability density for the von Mises distribution is</source>
          <target state="translated">폰 미제스 분포의 확률 밀도는</target>
        </trans-unit>
        <trans-unit id="2e977910510c195394a91f298d7c9556abc16027" translate="yes" xml:space="preserve">
          <source>The probability density function</source>
          <target state="translated">확률 밀도 함수</target>
        </trans-unit>
        <trans-unit id="a293dce90e3fe47dddc6a55e94ccb69a8fef9b0c" translate="yes" xml:space="preserve">
          <source>The probability density function for the Rayleigh distribution is</source>
          <target state="translated">레일리 분포의 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="d3e0872e16a6ab7b6c0ee2a22d52dd0d2e1ca84e" translate="yes" xml:space="preserve">
          <source>The probability density function for the Wald distribution is</source>
          <target state="translated">Wald 분포의 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="2f149a65fa2739e5de1eec985af9c1621ffacc73" translate="yes" xml:space="preserve">
          <source>The probability density function for the full Cauchy distribution is</source>
          <target state="translated">전체 Cauchy 분포에 대한 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b0dc98514227cdd44ff47b528c8a0bcaf89c265" translate="yes" xml:space="preserve">
          <source>The probability density function for the noncentral Chi-square distribution is</source>
          <target state="translated">비 중심 카이-제곱 분포의 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c30948020144257a9fb38966abff7c99e81c50e9" translate="yes" xml:space="preserve">
          <source>The probability density function for the t distribution is</source>
          <target state="translated">t 분포에 대한 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="dcdbad2794701215e8c40510ff713b7913263c5a" translate="yes" xml:space="preserve">
          <source>The probability density function for the triangular distribution is</source>
          <target state="translated">삼각 분포에 대한 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="6467351c7a0571530575123e2ae036078aaa2303" translate="yes" xml:space="preserve">
          <source>The probability density function is</source>
          <target state="translated">확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="ee41aab696af2a63a045005f9a20ab50a30087b5" translate="yes" xml:space="preserve">
          <source>The probability density function of the chi-squared distribution is</source>
          <target state="translated">카이 제곱 분포의 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c5e3eadc4ee0ddfc376707a7c47e36bdec30614e" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">정규 분포의 확률 밀도 함수는 De Moivre에 의해 처음으로 도출되고 200 년 후 Gauss와 Laplace에 의해 독립적으로 도출됩니다 &lt;a href=&quot;#r1536f9c044a3-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; , 특징적인 형태 때문에 종종 종 곡선이라고합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="2297eee1a9ef2ae469ffb4ffe7c7db8f4e4f83da" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">De Moivre에 의해 처음으로 도출되고 200 년 후 Gauss와 Laplace에 의해 독립적으로 도출 된 정규 분포의 확률 밀도 함수 &lt;a href=&quot;#ra2e838c5ea87-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; 는 특성 모양 때문에 종종 종 곡선이라고합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="d7e2875a44ce7ebdc83cb0f55dc114499ca0e8b1" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">정규 분포의 확률 밀도 함수는 De Moivre에 의해 처음으로 도출되고 200 년 후 Gauss와 Laplace에 의해 독립적으로 도출됩니다 &lt;a href=&quot;#rce7db652c312-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; , 특징적인 형태 때문에 종종 종 곡선이라고합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="31415e3883f5ad2cde00e0bf903f48cc5ab3d293" translate="yes" xml:space="preserve">
          <source>The probability density function of the normal distribution, first derived by De Moivre and 200 years later by both Gauss and Laplace independently &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt;, is often called the bell curve because of its characteristic shape (see the example below).</source>
          <target state="translated">De Moivre에 의해 처음으로 도출되고 200 년 후 Gauss와 Laplace에 의해 독립적으로 도출 된 정규 분포의 확률 밀도 함수 &lt;a href=&quot;#rf578abb8fba2-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; 는 특성 모양 때문에 종종 종 곡선이라고합니다 (아래 예 참조).</target>
        </trans-unit>
        <trans-unit id="2755556e2db9bd446cf581401e578c5337420320" translate="yes" xml:space="preserve">
          <source>The probability density function of the uniform distribution is</source>
          <target state="translated">균일 분포의 확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="415051b020f7949a62618fb53ef560dee4613543" translate="yes" xml:space="preserve">
          <source>The probability inputs should be normalized. As an implementation detail, the value of the last entry is ignored and assumed to take up any leftover probability mass, but this should not be relied on. A biased coin which has twice as much weight on one side as on the other should be sampled like so:</source>
          <target state="translated">확률 입력은 정규화되어야합니다. 구현 세부 사항으로, 마지막 항목의 값은 무시되고 남은 확률 질량을 취한다고 가정하지만, 이것에 의존해서는 안됩니다. 한쪽의 무게가 다른 쪽보다 두 배나 큰 편향 동전은 다음과 같이 샘플링해야합니다.</target>
        </trans-unit>
        <trans-unit id="8e4c202be333253a1251675439dcd7f21c1ef125" translate="yes" xml:space="preserve">
          <source>The probability mass function for the Log Series distribution is</source>
          <target state="translated">로그 시리즈 분포에 대한 확률 질량 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2d117aed0c4f59861c0b3330028791db8f91f6f5" translate="yes" xml:space="preserve">
          <source>The probability mass function of the geometric distribution is</source>
          <target state="translated">기하 분포의 확률 질량 함수는</target>
        </trans-unit>
        <trans-unit id="53c49feadffaed0acd89d507cebd4872b9032162" translate="yes" xml:space="preserve">
          <source>The probability mass function of the negative binomial distribution is</source>
          <target state="translated">음 이항 분포의 확률 질량 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f1f5e6e451a12ecc1dfa7cb3123b997ae141c402" translate="yes" xml:space="preserve">
          <source>The probability of success of an individual trial.</source>
          <target state="translated">개별 시험의 성공 확률.</target>
        </trans-unit>
        <trans-unit id="c0419d3f3c0dd14cc710a6332bd5b9e9f12f94e6" translate="yes" xml:space="preserve">
          <source>The problem here is that there is one dimension argument and two array arguments, and our typemaps are set up for dimensions that apply to a single array (in fact, &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; does not provide a mechanism for associating &lt;code&gt;len&lt;/code&gt; with &lt;code&gt;vec2&lt;/code&gt; that takes two Python input arguments). The recommended solution is the following:</source>
          <target state="translated">여기서 문제는 하나의 차원 인수와 두 개의 배열 인수가 있고 단일 배열에 적용되는 차원에 대한 유형 맵이 설정되어 있다는 것입니다. 실제로 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는 &lt;code&gt;len&lt;/code&gt; 을 &lt;code&gt;vec2&lt;/code&gt; 와 연관 시켜 두 개의 Python 입력 인수를 사용하는 메커니즘을 제공하지 않습니다. ). 권장되는 솔루션은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="258606759bb8ded772cb41c8f492be953461a647" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays.</source>
          <target state="translated">문제가 정확하게 해결되었습니다. 이 경우 함수는 배열간에 공유되는 요소가있는 경우에만 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4ad89e6d069e4dfa2e5a4dc8cd5ea0ef4b308ab4" translate="yes" xml:space="preserve">
          <source>The problem is solved exactly. In this case, the function returns True only if there is an element shared between the arrays. Finding the exact solution may take extremely long in some cases.</source>
          <target state="translated">문제가 정확히 해결되었습니다. 이 경우 함수는 배열간에 공유되는 요소가있는 경우에만 True를 반환합니다. 경우에 따라 정확한 솔루션을 찾는 데 매우 오래 걸릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12f7b79ffc79e216081a6d98b051a230198244d5" translate="yes" xml:space="preserve">
          <source>The product of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;, element-wise. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 곱을 요소 단위입니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3f6e1c408d5c694acb6e117eca1f17a66ff95359" translate="yes" xml:space="preserve">
          <source>The product of an empty array is the neutral element 1:</source>
          <target state="translated">빈 배열의 곱은 중립 요소 1입니다.</target>
        </trans-unit>
        <trans-unit id="75994948d8c7e15ea47031e7a198364fb67ad040" translate="yes" xml:space="preserve">
          <source>The project management structure can be found at our &lt;a href=&quot;dev/governance/index&quot;&gt;governance page&lt;/a&gt;</source>
          <target state="translated">프로젝트 관리 구조는 &lt;a href=&quot;dev/governance/index&quot;&gt;거버넌스 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0cb319efd0acc22671f035a1669648180fbd73bb" translate="yes" xml:space="preserve">
          <source>The promoted data type.</source>
          <target state="translated">승격 된 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6912cd62e766bc5197bb815c3a7a6d0beffe9f0f" translate="yes" xml:space="preserve">
          <source>The pseudo Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Chebyshev polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 Vandermonde 매트릭스. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 인덱스는 해당 Chebyshev 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="4ae75dbae228045f6a44f16a4959415e52a060af" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Hermite polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 인덱스는 해당 Hermite 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="88145706d808f4e5b4b300c092c6d0b48707e827" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding HermiteE polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 색인은 해당 HermiteE 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="461d6f363a2da4bb21861bdd9199b9a080f1058c" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Laguerre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 색인은 해당 Laguerre 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="a9fac4b82ab694bb7879684258269647508526ed" translate="yes" xml:space="preserve">
          <source>The pseudo-Vandermonde matrix. The shape of the returned matrix is &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt;, where The last index is the degree of the corresponding Legendre polynomial. The dtype will be the same as the converted &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">의사 밴더 몬드 행렬. 반환 된 행렬의 모양은 &lt;code&gt;x.shape + (deg + 1,)&lt;/code&gt; . 여기서 마지막 색인은 해당 Legendre 다항식의 차수입니다. dtype은 변환 된 &lt;code&gt;x&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1e87cfa1899783295ead645aa689484ac09d5ad0" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">의 역행렬 . 경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 예는 다음 그렇다 &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14e8343a4bfc8bf0e783456b4d87d1a38896cde9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; instance, then so is &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">의 역행렬 . 경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;matrix&lt;/code&gt; 예는 다음 그렇다 &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9935b0bcef3c9f2790af77d395c4f7367a5b4f9" translate="yes" xml:space="preserve">
          <source>The pseudo-inverse of a matrix A, denoted</source>
          <target state="translated">행렬 A의 의사 역수</target>
        </trans-unit>
        <trans-unit id="43268b21480b8908d11ac78845b26e8a85b3d3ad" translate="yes" xml:space="preserve">
          <source>The purpose of the &lt;code&gt;F2PY&lt;/code&gt; &amp;ndash;&lt;em&gt;Fortran to Python interface generator&lt;/em&gt;&amp;ndash; is to provide a connection between Python and Fortran languages. F2PY is a part of &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; (&lt;code&gt;numpy.f2py&lt;/code&gt;) and also available as a standalone command line tool &lt;code&gt;f2py&lt;/code&gt; when &lt;code&gt;numpy&lt;/code&gt; is installed that facilitates creating/building Python C/API extension modules that make it possible</source>
          <target state="translated">의 목적 &lt;code&gt;F2PY&lt;/code&gt; - &lt;em&gt;포트란 파이썬 인터페이스 생성기&lt;/em&gt; - 파이썬과 포트란 언어 사이의 연결을 제공하는 것입니다. F2PY는 &lt;a href=&quot;https://www.numpy.org/&quot;&gt;NumPy&lt;/a&gt; ( &lt;code&gt;numpy.f2py&lt;/code&gt; ) 의 일부이며 &lt;code&gt;numpy&lt;/code&gt; 가 설치된 경우 독립형 명령 줄 도구 &lt;code&gt;f2py&lt;/code&gt; 로도 사용할 수 있으며이를 가능 하게하는 Python C / API 확장 모듈을 쉽게 생성 / 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="273d622b1bbcac1e58ca2d1b74d9ecdc471af9f8" translate="yes" xml:space="preserve">
          <source>The purpose of the reference count check is to make sure you do not use this array as a buffer for another Python object and then reallocate the memory. However, reference counts can increase in other ways so if you are sure that you have not shared the memory for this array with another Python object, then you may safely set &lt;code&gt;refcheck&lt;/code&gt; to False.</source>
          <target state="translated">참조 횟수 확인의 목적은이 배열을 다른 Python 객체의 버퍼로 사용하지 않고 메모리를 재 할당하는 것입니다. 그러나 참조 횟수는 다른 방식으로 증가 할 수 &lt;code&gt;refcheck&lt;/code&gt; 배열의 메모리를 다른 Python 객체와 공유하지 않았다면 refcheck 를 False로 안전하게 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd4694d2cc663a00201267e4370ce5da08336131" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to formalize the governance process used by the NumPy project in both ordinary and extraordinary situations, and to clarify how decisions are made and how the various elements of our community interact, including the relationship between open source collaborative development and work that may be funded by for-profit or non-profit entities.</source>
          <target state="translated">이 문서의 목적은 일반적인 상황과 비정상적인 상황 모두에서 NumPy 프로젝트가 사용하는 거버넌스 프로세스를 공식화하고 오픈 소스 공동 개발과 작업 간의 관계를 포함하여 의사 결정 방법과 커뮤니티의 다양한 요소가 상호 작용하는 방법을 명확히하는 것입니다. 영리 단체 또는 비영리 단체에서 자금을 지원받을 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="fd1af1501c6ee7b4f0b0aa9bb7ca5e17785491ff" translate="yes" xml:space="preserve">
          <source>The quadrant (i.e., branch) is chosen so that &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; is the signed angle in radians between the ray ending at the origin and passing through the point (1,0), and the ray ending at the origin and passing through the point (&lt;code&gt;x2&lt;/code&gt;, &lt;code&gt;x1&lt;/code&gt;). (Note the role reversal: the &amp;ldquo;&lt;code&gt;y&lt;/code&gt;-coordinate&amp;rdquo; is the first function parameter, the &amp;ldquo;&lt;code&gt;x&lt;/code&gt;-coordinate&amp;rdquo; is the second.) By IEEE convention, this function is defined for &lt;code&gt;x2&lt;/code&gt; = +/-0 and for either or both of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; = +/-inf (see Notes for specific values).</source>
          <target state="translated">사분면 (즉, 분기)은 &lt;code&gt;arctan2(x1, x2)&lt;/code&gt; 가 원점에서 끝나고 점 (1,0)을 통과하는 광선과 원점에서 끝나고 통과하는 광선 사이의 라디안으로 표시된 각도로 라디안으로 선택됩니다. 점을 통해 ( &lt;code&gt;x2&lt;/code&gt; , &lt;code&gt;x1&lt;/code&gt; ). 역할 역전에 유의하십시오.&amp;ldquo; &lt;code&gt;y&lt;/code&gt; -coordinate&amp;rdquo;는 첫 번째 기능 매개 변수이고&amp;ldquo; &lt;code&gt;x&lt;/code&gt; -coordinate&amp;rdquo;는 두 번째 기능 매개 변수 입니다. IEEE 규약에 따라이 기능은 &lt;code&gt;x2&lt;/code&gt; = +/- 0 및 둘 중 하나 또는 둘 다에 대해 정의됩니다. &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; = +/- inf (특정 값에 대한 참고 사항 참조)</target>
        </trans-unit>
        <trans-unit id="a6498ac12126ab973a1934f179594a987afb7844" translate="yes" xml:space="preserve">
          <source>The quick and smart way</source>
          <target state="translated">빠르고 스마트 한 방법</target>
        </trans-unit>
        <trans-unit id="8b0770ff789fdc985036394e871929fde93eb9a9" translate="yes" xml:space="preserve">
          <source>The quick way</source>
          <target state="translated">빠른 방법</target>
        </trans-unit>
        <trans-unit id="d041efcac5d4fa984fd9e585c0e674ab20c24a98" translate="yes" xml:space="preserve">
          <source>The quickest way to wrap the Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; to Python is to run</source>
          <target state="translated">Fortran 서브 루틴 &lt;code&gt;FIB&lt;/code&gt; 를 Python 으로 래핑하는 가장 빠른 방법 은 다음을 실행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ef42c4d34d6fe180bfd554c782fbff1345844332" translate="yes" xml:space="preserve">
          <source>The random numbers generated are reproducible in the sense that the same seed will produce the same outputs, given that the number of threads does not change.</source>
          <target state="translated">생성 된 난수는 스레드 수가 변경되지 않는 한 동일한 시드가 동일한 출력을 생성한다는 의미에서 재현 가능합니다.</target>
        </trans-unit>
        <trans-unit id="d11423e3cc4bf0ed835c8b796b2965976e8e77d3" translate="yes" xml:space="preserve">
          <source>The random values are simulated using a rejection-based method and so, on average, more than one value from the underlying RNG is required to generate an single draw.</source>
          <target state="translated">랜덤 값은 거부 기반 방법을 사용하여 시뮬레이션되므로 평균적으로 단일 드로우를 생성하려면 기본 RNG의 둘 이상의 값이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="28da8ed4d2357ec2f5fb90d47c281e28c8eefc86" translate="yes" xml:space="preserve">
          <source>The random values produced by &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; orignate in a BitGenerator. The BitGenerators do not directly provide random numbers and only contains methods used for seeding, getting or setting the state, jumping or advancing the state, and for accessing low-level wrappers for consumption by code that can efficiently access the functions provided, e.g., &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 가&lt;/a&gt; 생성 한 임의의 값 은 BitGenerator에서 점화됩니다. BitGenerator는 임의의 숫자를 직접 제공하지 않으며, 시드, 상태 가져 오기 또는 설정, 상태 점프 또는 진행, 제공된 기능 (예 : &lt;a href=&quot;https://numba.pydata.org&quot;&gt;numba)에&lt;/a&gt; 효율적으로 액세스 할 수있는 코드를 사용하여 저수준 래퍼에 액세스하는 데 사용되는 방법 만 포함합니다. .</target>
        </trans-unit>
        <trans-unit id="5ad47a80d273e6280e7c076840353be5436abdd4" translate="yes" xml:space="preserve">
          <source>The random variate of the F distribution (also known as the Fisher distribution) is a continuous probability distribution that arises in ANOVA tests, and is the ratio of two chi-square variates.</source>
          <target state="translated">F 분포의 랜덤 변이 (피셔 분포라고도 함)는 분산 분석 검정에서 발생하는 연속 확률 분포이며 두 카이-제곱 변이의 비율입니다.</target>
        </trans-unit>
        <trans-unit id="5e26087033b3fc33a117f2ffd1f65fecc7d3f31d" translate="yes" xml:space="preserve">
          <source>The random.Generator class has a new &lt;code&gt;permuted&lt;/code&gt; function.</source>
          <target state="translated">random.Generator 클래스에는 새로운 &lt;code&gt;permuted&lt;/code&gt; 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="0add6113b9556467f5d4df18305b83fe87d90739" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False.</source>
          <target state="translated">최소 제곱 피팅에서 계수 행렬의 순위가 부족합니다. &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False 인 경우에만 경고가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="9713dea73f1e21f45e35ecea0c0c8c7ada18485a" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; = False. The warnings can be turned off by</source>
          <target state="translated">최소 제곱 적합도에서 계수 행렬의 순위가 부족합니다. 경고는 &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; = False 인 경우에만 발생합니다 . 경고는 다음 방법으로 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b6ce678d6ccc2a705d695d4a88057837caab615e" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False.</source>
          <target state="translated">최소 제곱 피팅에서 계수 행렬의 순위가 부족합니다. &lt;code&gt;full&lt;/code&gt; = False 인 경우에만 경고가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="bd75ec6be6b0946c94eb5124dc2c270b7f45fc83" translate="yes" xml:space="preserve">
          <source>The rank of the coefficient matrix in the least-squares fit is deficient. The warning is only raised if &lt;code&gt;full&lt;/code&gt; = False. The warnings can be turned off by</source>
          <target state="translated">최소 제곱 피팅에서 계수 행렬의 순위가 부족합니다. &lt;code&gt;full&lt;/code&gt; = False 인 경우에만 경고가 발생합니다 . 다음과 같은 방법으로 경고를 끌 수 있습니다</target>
        </trans-unit>
        <trans-unit id="2c0ff958aa13b6c22519b1f58af607e808b9fc81" translate="yes" xml:space="preserve">
          <source>The rate of interest is computed by iteratively solving the (non-linear) equation:</source>
          <target state="translated">이율은 (비선형) 방정식을 반복적으로 해결하여 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="b661d55a0a19500a077ffd4c961cfcdd8af11a0d" translate="yes" xml:space="preserve">
          <source>The real and imaginary parts of complex numbers are rounded separately. The result of rounding a float is a float.</source>
          <target state="translated">복소수의 실수 부와 허수 부는 따로 반올림됩니다. 플로트를 반올림 한 결과는 플로트입니다.</target>
        </trans-unit>
        <trans-unit id="207d8f1e0e497b598f007938a1132510a97a9210" translate="yes" xml:space="preserve">
          <source>The real component of the complex argument. If &lt;code&gt;val&lt;/code&gt; is real, the type of &lt;code&gt;val&lt;/code&gt; is used for the output. If &lt;code&gt;val&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">복잡한 인수의 실제 구성 요소. 경우 &lt;code&gt;val&lt;/code&gt; 진짜의 종류 &lt;code&gt;val&lt;/code&gt; 출력에 사용됩니다. &lt;code&gt;val&lt;/code&gt; 에 복잡한 요소가 있으면 반환 된 유형은 float입니다.</target>
        </trans-unit>
        <trans-unit id="bcba5206897319bd4dfef5984f33a61e7bfd3a3e" translate="yes" xml:space="preserve">
          <source>The real part of the array.</source>
          <target state="translated">배열의 실제 부분.</target>
        </trans-unit>
        <trans-unit id="f76c20342380d19b36138a77680129546c04ac6d" translate="yes" xml:space="preserve">
          <source>The real part of the masked array.</source>
          <target state="translated">마스크 배열의 실제 부분.</target>
        </trans-unit>
        <trans-unit id="3d31d01b7c11703d8075820106fa90d3e0159005" translate="yes" xml:space="preserve">
          <source>The real part of the scalar.</source>
          <target state="translated">스칼라의 실수 부분입니다.</target>
        </trans-unit>
        <trans-unit id="f8c34f7042b404b994731920ea347bbd1e355fae" translate="yes" xml:space="preserve">
          <source>The recommended approach to multithreaded iteration is to first create an iterator with the flags &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, and possibly &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt;. Create a copy of this iterator for each thread (minus one for the first iterator). Then, take the iteration index range &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; and split it up into tasks, for example using a TBB parallel_for loop. When a thread gets a task to execute, it then uses its copy of the iterator by calling &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; and iterating over the full range.</source>
          <target state="translated">멀티 스레드 반복에 권장되는 접근법은 먼저 플래그 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; 및 가능하면 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 반복자를 작성하는 것 입니다 . 각 스레드에 대해이 반복기의 사본을 작성하십시오 (첫 번째 반복기에서 1을 뺀 것). 그런 다음 반복 색인 범위 &lt;code&gt;[0, NpyIter_GetIterSize(iter))&lt;/code&gt; 를 가져 와서 예를 들어 TBB parallel_for 루프를 사용하여 작업으로 분할하십시오. 스레드가 실행할 작업을 &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt; 를 호출 하고 전체 범위에서 반복 하여 반복자의 사본을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="8ebf9173277c6dd7ef8e96321015ddb67f853d5b" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">일반적으로 권장되는 생성기는 &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 입니다. 대부분의 플랫폼에서 통계적으로 고품질이고 모든 기능을 갖추고 있으며 빠르지 만 32 비트 프로세스 용으로 컴파일 할 때는 다소 느립니다.</target>
        </trans-unit>
        <trans-unit id="5447919d67b87c18366730a8d862cd10ecf68752" translate="yes" xml:space="preserve">
          <source>The recommended generator for general use is &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt;. It is statistically high quality, full-featured, and fast on most platforms, but somewhat slow when compiled for 32-bit processes.</source>
          <target state="translated">일반적인 사용에 권장되는 발전기는 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 입니다. 통계적으로 고품질이며 모든 기능을 갖추고 있으며 대부분의 플랫폼에서 빠르지 만 32 비트 프로세스 용으로 컴파일 할 때는 다소 느립니다.</target>
        </trans-unit>
        <trans-unit id="1ecded761aa3b896fb25df737596c852ad7e09c5" translate="yes" xml:space="preserve">
          <source>The recommended practice for initializing &lt;code&gt;mask&lt;/code&gt; with a scalar boolean value is to use &lt;code&gt;True&lt;/code&gt;/&lt;code&gt;False&lt;/code&gt; rather than &lt;code&gt;np.True_&lt;/code&gt;/&lt;code&gt;np.False_&lt;/code&gt;. The reason is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="translated">스칼라 부울 값으로 &lt;code&gt;mask&lt;/code&gt; 를 초기화하는 데 권장되는 방법은 &lt;code&gt;np.True_&lt;/code&gt; / &lt;code&gt;np.False_&lt;/code&gt; 대신 &lt;code&gt;True&lt;/code&gt; / &lt;code&gt;False&lt;/code&gt; 를 사용 하는 것 입니다. 그 이유는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 내부적으로 &lt;code&gt;np.False_&lt;/code&gt; 로 표현되기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="f1f83ab16efb108e21fd8dc9140501bac936f974" translate="yes" xml:space="preserve">
          <source>The recommended way to mark one or several specific entries of a masked array as invalid is to assign the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; to them:</source>
          <target state="translated">무효로 마스크 배열의 하나 개 또는 여러 개의 특정 항목을 표시하는 권장 방법은 특수 값 할당하는 것입니다 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 그들에게를 :</target>
        </trans-unit>
        <trans-unit id="8e71a8b22e3d3f7dda123223a571d40b785e19ae" translate="yes" xml:space="preserve">
          <source>The recommended way to store and load data:</source>
          <target state="translated">권장되는 데이터 저장 및로드 방법 :</target>
        </trans-unit>
        <trans-unit id="8911e36d75ead22da4c98276ac7d48a14f617b1b" translate="yes" xml:space="preserve">
          <source>The reduceat function is a generalization of both the reduce and accumulate functions. It implements a reduce over ranges of the input array specified by indices. The extra indices argument is checked to be sure that every input is not too large for the input array along the selected dimension before the loop calculations take place. The loop implementation is handled using code that is very similar to the reduce code repeated as many times as there are elements in the indices input. In particular: the first input pointer passed to the underlying 1-D computational loop points to the input array at the correct location indicated by the index array. In addition, the output pointer and the second input pointer passed to the underlying 1-D loop point to the same position in memory. The size of the 1-D computational loop is fixed to be the difference between the current index and the next index (when the current index is the last index, then the next index is assumed to be the length of the array along the selected dimension). In this way, the 1-D loop will implement a reduce over the specified indices.</source>
          <target state="translated">감소 기능은 감소 및 누적 기능의 일반화입니다. 인덱스로 지정된 입력 배열 범위의 축소 범위를 구현합니다. 루프 계산을 수행하기 전에 선택한 차원을 따라 모든 입력이 입력 배열에 비해 너무 크지 않은지 확인하기 위해 여분의 인덱스 인수가 검사됩니다. 루프 구현은 인덱스 입력에 요소가있는 횟수만큼 반복되는 축소 코드와 매우 유사한 코드를 사용하여 처리됩니다. 특히 : 기본 1 차원 계산 루프로 전달 된 첫 번째 입력 포인터는 인덱스 배열로 표시된 올바른 위치에서 입력 배열을 가리 킵니다. 또한 출력 포인터와 두 번째 입력 포인터는 기본 1D 루프 포인트로 전달되어 메모리에서 동일한 위치를 가리 킵니다.1 차원 전산 루프의 크기는 현재 인덱스와 다음 인덱스의 차이로 고정됩니다 (현재 인덱스가 마지막 인덱스 인 경우 다음 인덱스는 선택한 차원을 따라 배열의 길이 인 것으로 가정 됨) ). 이런 식으로 1-D 루프는 지정된 인덱스에 대한 축소를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="7b43a1a08f82a3b68e452cbd124797f3f5925ce7" translate="yes" xml:space="preserve">
          <source>The reduced array. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to it.</source>
          <target state="translated">축소 된 배열입니다. 경우 &lt;code&gt;out&lt;/code&gt; 공급하고, &lt;code&gt;r&lt;/code&gt; 에 대한 참조이다.</target>
        </trans-unit>
        <trans-unit id="d46d2581ba496f8d142f6a4f33e8d4c920183656" translate="yes" xml:space="preserve">
          <source>The reduced values. If &lt;code&gt;out&lt;/code&gt; was supplied, &lt;code&gt;r&lt;/code&gt; is a reference to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">감소 된 값. 경우 &lt;code&gt;out&lt;/code&gt; 공급하고, &lt;code&gt;r&lt;/code&gt; 참조 인 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3281b17df16674bbe40c7e1efbe54eb9d464c9ee" translate="yes" xml:space="preserve">
          <source>The regular expression. Default value is None, in which case the nose default (&lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt;) is used. If &lt;code&gt;testmatch&lt;/code&gt; is a string, it is compiled to a regular expression first.</source>
          <target state="translated">정규식. 기본값은 None입니다.이 경우 코 기본값 ( &lt;code&gt;re.compile(r'(?:^|[\b_\.%s-])[Tt]est' % os.sep)&lt;/code&gt; )이 사용됩니다. 경우 &lt;code&gt;testmatch&lt;/code&gt; 은 문자열입니다, 그것은 첫번째 정규 표현식으로 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="bd0a0dfb20db6ba5c33bc9ca8a9fe1a01f1841cf" translate="yes" xml:space="preserve">
          <source>The relative performance on 64-bit Linux and 64-bit Windows is broadly similar.</source>
          <target state="translated">64 비트 Linux 및 64 비트 Windows의 상대적 성능은 대체로 비슷합니다.</target>
        </trans-unit>
        <trans-unit id="7989f6ae8fcd58319573d40c534aa46fe0a84b96" translate="yes" xml:space="preserve">
          <source>The relative tolerance parameter (see Notes).</source>
          <target state="translated">상대 공차 매개 변수 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="3e03b7da726f71e414e37015d45ecfcbfb010c83" translate="yes" xml:space="preserve">
          <source>The release should be announced on the mailing lists of NumPy and SciPy, to python-announce, and possibly also those of Matplotlib, IPython and/or Pygame.</source>
          <target state="translated">릴리스는 NumPy 및 SciPy의 메일 링리스트, python-announce 및 가능하면 Matplotlib, IPython 및 / 또는 Pygame의 메일 링리스트에 발표되어야합니다.</target>
        </trans-unit>
        <trans-unit id="96164d49d0f26476a5104ba2b3a4aa7deeeccb58" translate="yes" xml:space="preserve">
          <source>The release should be announced on the numpy-discussion, scipy-devel, scipy-user, and python-announce-list mailing lists. Look at previous announcements for the basic template. The contributor and PR lists are the same as generated for the release notes above. If you crosspost, make sure that python-announce-list is BCC so that replies will not be sent to that list.</source>
          <target state="translated">릴리스는 numpy-discussion, scipy-devel, scipy-user 및 python-announce-list 메일 링리스트에 발표되어야합니다. 기본 템플릿에 대한 이전 공지 사항을 참조하십시오. 기여자 및 PR 목록은 위의 릴리스 정보에 대해 생성 된 것과 동일합니다. 교차 게시하는 경우 python-announce-list가 BCC인지 확인하여 응답이 해당 목록으로 전송되지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="12f91fe84c2d74d72d982ce47fb9a64711667ccc" translate="yes" xml:space="preserve">
          <source>The release tag should have the release number in the annotation (tag message). Unfortunately, the name of a tag can be changed without breaking the signature, the contents of the message cannot.</source>
          <target state="translated">릴리스 태그에는 주석 (태그 메시지)에 릴리스 번호가 있어야합니다. 안타깝게도 태그 이름은 서명을 깨지 않고 변경할 수 있지만 메시지 내용은 변경할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="dafb58a5db48e1dfe53af56fea252537c1419b45" translate="yes" xml:space="preserve">
          <source>The remainder of the division of &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 을 &lt;code&gt;x2&lt;/code&gt; 로 나눈 나머지입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="addbfd0df60663d128185f6696a4113588a064dc" translate="yes" xml:space="preserve">
          <source>The repos shown by &lt;code&gt;git remote -v show&lt;/code&gt; will include your fork on GitHub and the main repo:</source>
          <target state="translated">&lt;code&gt;git remote -v show&lt;/code&gt; 에 표시된 저장소 에는 GitHub의 포크와 기본 저장소가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="45876a6251302c94b60ea59421b48e6f10e76b32" translate="yes" xml:space="preserve">
          <source>The required alignment (bytes) of this data-type according to the compiler.</source>
          <target state="translated">컴파일러에 따른이 데이터 유형의 필수 정렬 (바이트)입니다.</target>
        </trans-unit>
        <trans-unit id="13ef7d8fa51bbebbe1bd1d3ed4d25fe31e0c8b11" translate="yes" xml:space="preserve">
          <source>The required data type(s) of the operands. If copying or buffering is enabled, the data will be converted to/from their original types.</source>
          <target state="translated">피연산자의 필수 데이터 유형입니다. 복사 또는 버퍼링이 활성화 된 경우 데이터는 원래 유형과 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="0a7d78831f72627736ecbbe6affd07acc842cf9c" translate="yes" xml:space="preserve">
          <source>The required data-type. If None preserve the current dtype. If your application requires the data to be in native byteorder, include a byteorder specification as a part of the dtype specification.</source>
          <target state="translated">필요한 데이터 유형. None이면 현재 dtype을 유지합니다. 응용 프로그램에서 데이터가 기본 바이트 순서로되어 있어야하는 경우 dtype 사양의 일부로 바이트 순서 사양을 포함하십시오.</target>
        </trans-unit>
        <trans-unit id="65e5c657147f8f6206b51f162cff2b0b35eade26" translate="yes" xml:space="preserve">
          <source>The requirements flag allows specification of what kind of array is acceptable. If the object passed in does not satisfy this requirements then a copy is made so that thre returned object will satisfy the requirements. these ndarray can use a very generic pointer to memory. This flag allows specification of the desired properties of the returned array object. All of the flags are explained in the detailed API chapter. The flags most commonly needed are &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt;&lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt;&lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">요구 사항 플래그를 사용하면 어떤 종류의 배열이 허용되는지 지정할 수 있습니다. 전달 된 객체가이 요구 사항을 충족하지 않으면 반환 된 객체가 요구 사항을 충족하도록 복사본이 만들어집니다. 이러한 ndarray는 메모리에 대한 매우 일반적인 포인터를 사용할 수 있습니다. 이 플래그를 사용하면 반환 된 배열 개체의 원하는 속성을 지정할 수 있습니다. 모든 플래그는 자세한 API 장에 설명되어 있습니다. 가장 일반적으로 필요한 플래그는 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_IN_ARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_IN_ARRAY&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/c-api/array#c.NPY_OUT_ARRAY&quot;&gt; &lt;code&gt;NPY_OUT_ARRAY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_INOUT_ARRAY&quot;&gt; &lt;code&gt;NPY_ARRAY_INOUT_ARRAY&lt;/code&gt; 입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bb180b40fee6aef0d41f93f405142f00de46dd28" translate="yes" xml:space="preserve">
          <source>The requirements list can be any of the following</source>
          <target state="translated">요구 사항 목록은 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf0f3cb688cf9b5f44c6080748b72439b46fb978" translate="yes" xml:space="preserve">
          <source>The reshaping operation cannot guarantee that a copy will not be made, to modify the shape in place, use &lt;code&gt;a.shape = s&lt;/code&gt;</source>
          <target state="translated">모양 변경 작업으로 복사가되지 않는다고 보장 할 수 없으며, 모양을 수정하려면 &lt;code&gt;a.shape = s&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f3c22a2794d4be1171f3bb3051bbeb72ad7588dd" translate="yes" xml:space="preserve">
          <source>The rest of the story</source>
          <target state="translated">나머지 이야기</target>
        </trans-unit>
        <trans-unit id="2b262525b3075625bc8ca490c385d67e383e0b64" translate="yes" xml:space="preserve">
          <source>The rest of this document discusses working on the NumPy code base and documentation. We&amp;rsquo;re in the process of updating our descriptions of other activities and roles. If you are interested in these other activities, please contact us! You can do this via the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;, or on &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub&lt;/a&gt; (open an issue or comment on a relevant issue). These are our preferred communication channels (open source is open by nature!), however if you prefer to discuss in private first, please reach out to our community coordinators at &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; or &lt;code&gt;numpy-team.slack.com&lt;/code&gt; (send an email to &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; for an invite the first time).</source>
          <target state="translated">이 문서의 나머지 부분에서는 NumPy 코드베이스 및 문서 작업에 대해 설명합니다. 다른 활동 및 역할에 대한 설명을 업데이트하는 중입니다. 이러한 다른 활동에 관심이 있으시면 저희에게 연락하십시오! &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion 메일 링리스트&lt;/a&gt; 또는 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;GitHub&lt;/a&gt; (문제 열기 또는 관련 문제에 대한 의견)를 통해이 작업을 수행 할 수 있습니다 . 이들은 우리가 선호하는 커뮤니케이션 채널입니다 (오픈 소스는 본질적으로 개방되어 있습니다!). 먼저 비공개로 논의하고 &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; 또는 &lt;code&gt;numpy-team.slack.com&lt;/code&gt; ()으로 커뮤니티 코디네이터에게 문의하세요. 처음으로 초대하려면 &lt;code&gt;numpy-team@googlegroups.com&lt;/code&gt; 으로 이메일을 보내세요 ).</target>
        </trans-unit>
        <trans-unit id="efae226cd4ce4ec97472c40d085c0b19d6b0deb7" translate="yes" xml:space="preserve">
          <source>The rest of this page will give you a basic idea of how to add unit tests to modules in SciPy. It is extremely important for us to have extensive unit testing since this code is going to be used by scientists and researchers and is being developed by a large number of people spread across the world. So, if you are writing a package that you&amp;rsquo;d like to become part of SciPy, please write the tests as you develop the package. Also since much of SciPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it as you read through this introduction.</source>
          <target state="translated">이 페이지의 나머지 부분에서는 SciPy의 모듈에 단위 테스트를 추가하는 방법에 대한 기본 아이디어를 제공합니다. 이 코드는 과학자와 연구원이 사용하고 전 세계에 퍼져있는 많은 사람들이 개발하고 있기 때문에 광범위한 단위 테스트를 수행하는 것이 매우 중요합니다. 따라서 SciPy에 참여할 패키지를 작성하는 경우 패키지를 개발할 때 테스트를 작성하십시오. 또한 SciPy의 대부분은 원래 단위 테스트없이 작성된 레거시 코드이므로 아직 테스트하지 않은 여러 모듈이 있습니다. 이 소개를 읽으면서이 모듈 중 하나를 자유롭게 선택하고 테스트를 개발하십시오.</target>
        </trans-unit>
        <trans-unit id="90738a573063433b40a2bef8dfa08dda95ee95c6" translate="yes" xml:space="preserve">
          <source>The result can be used to construct a datetime that uses the same units as a timedelta</source>
          <target state="translated">결과는 timedelta와 동일한 단위를 사용하는 날짜 시간을 구성하는 데 사용될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="8baf21a4c319c73c6c3f91016a95ecc1ae5e1dca" translate="yes" xml:space="preserve">
          <source>The result depends on the bit-width:</source>
          <target state="translated">결과는 비트 너비에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="7a004033c9a8a28e785dfe7afb00d43720c2d90c" translate="yes" xml:space="preserve">
          <source>The result is &lt;strong&gt;not&lt;/strong&gt; a MaskedArray!</source>
          <target state="translated">결과는 MaskedArray 가 &lt;strong&gt;아닙니다&lt;/strong&gt; !</target>
        </trans-unit>
        <trans-unit id="88b2f160b598518e6df066363213cebfd6339e40" translate="yes" xml:space="preserve">
          <source>The result is an inverse for &lt;code&gt;a&lt;/code&gt; relative to the tensordot operation &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt;, i. e., up to floating-point accuracy, &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; is the &amp;ldquo;identity&amp;rdquo; tensor for the tensordot operation.</source>
          <target state="translated">결과는 tensordot 연산 &lt;code&gt;tensordot(a, b, ind)&lt;/code&gt; 에 &lt;code&gt;a&lt;/code&gt; 상대 값에 반비례합니다 . 즉, 부동 소수점 정확도까지 &lt;code&gt;tensordot(tensorinv(a), a, ind)&lt;/code&gt; 는 tensordot의 &quot;동일성&quot;텐서입니다. 조작.</target>
        </trans-unit>
        <trans-unit id="1513bc4b365343f54e37e3a0463aec42e49631e5" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being &lt;em&gt;stretched&lt;/em&gt; during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt; are simply copies of the original scalar. The stretching analogy is only conceptual. NumPy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible.</source>
          <target state="translated">결과는 &lt;code&gt;b&lt;/code&gt; 가 배열 인 이전 예제와 동일합니다 . 우리는 라 생각하면 &lt;code&gt;b&lt;/code&gt; 를 되는 &lt;em&gt;연신&lt;/em&gt; 과 동일한 형상으로 배열 연산 동안 . &lt;code&gt;b&lt;/code&gt; 의 새 요소 는 단순히 원래 스칼라의 복사본입니다. 스트레칭 비유는 단지 개념적입니다. NumPy는 실제로 복사하지 않고도 원래 스칼라 값을 사용할 수있을만큼 똑똑하므로 브로드 캐스팅 작업이 가능한 한 메모리와 계산적으로 효율적입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b234fdc2574c2d15c385cc66cebde459f6f8d571" translate="yes" xml:space="preserve">
          <source>The result is equivalent to the previous example where &lt;code&gt;b&lt;/code&gt; was an array. We can think of the scalar &lt;code&gt;b&lt;/code&gt; being stretched during the arithmetic operation into an array with the same shape as &lt;code&gt;a&lt;/code&gt;. The new elements in &lt;code&gt;b&lt;/code&gt;, as shown in &lt;a href=&quot;#figure-1&quot;&gt;Figure 1&lt;/a&gt;, are simply copies of the original scalar. The stretching analogy is only conceptual. numpy is smart enough to use the original scalar value without actually making copies so that broadcasting operations are as memory and computationally efficient as possible. Because &lt;a href=&quot;#example-2&quot;&gt;Example 2&lt;/a&gt; moves less memory, (&lt;code&gt;b&lt;/code&gt; is a scalar, not an array) around during the multiplication, it is about 10% faster than &lt;a href=&quot;#example-1&quot;&gt;Example 1&lt;/a&gt; using the standard numpy on Windows 2000 with one million element arrays.</source>
          <target state="translated">결과는 &lt;code&gt;b&lt;/code&gt; 가 배열 인 이전 예제와 동일합니다 . 우리는 라 생각할 수 &lt;code&gt;b&lt;/code&gt; 를 동일한 형상으로 배열에 연산 중에 연신 . &lt;code&gt;b&lt;/code&gt; 의 새 요소는 &lt;a href=&quot;#figure-1&quot;&gt;그림 1에&lt;/a&gt; 표시된 것처럼 원래 스칼라의 복사본 일뿐입니다. 스트레칭 비유는 단지 개념적입니다. numpy는 실제로 복사본을 만들지 않고도 원래 스칼라 값을 사용할 수있을만큼 똑똑하므로 브로드 캐스팅 작업이 가능한 한 메모리와 계산적으로 효율적입니다. 때문에 &lt;a href=&quot;#example-2&quot;&gt;예 2&lt;/a&gt; 이동 적은 메모리 ( &lt;code&gt;b&lt;/code&gt; 보다 빠르고보다 10 % 관한 승산 동안 주위 스칼라가 아니라 배열이다) &lt;a href=&quot;#example-1&quot;&gt;실시 예 1&lt;/a&gt; &lt;code&gt;a&lt;/code&gt; 100 만 개의 요소 배열이있는 Windows 2000에서 표준 numpy를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d98fd654993b2c5bc8c34d84506f2eeb585bf55f" translate="yes" xml:space="preserve">
          <source>The result is padded to full bytes by inserting zero bits at the end.</source>
          <target state="translated">끝에 0 비트를 삽입하여 결과를 전체 바이트로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a05d82855a760b96ff01a98014b6f39cd92699f0" translate="yes" xml:space="preserve">
          <source>The result is returned as a boolean array.</source>
          <target state="translated">결과는 부울 배열로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="f9d8170d98950c22e6026933d7548298a3e52f98" translate="yes" xml:space="preserve">
          <source>The result is:</source>
          <target state="translated">결과는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f485f36eec65ddcecdc4119f77e3da3d4540a73e" translate="yes" xml:space="preserve">
          <source>The result masks values that are masked in either &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt;.</source>
          <target state="translated">결과는 &lt;code&gt;m1&lt;/code&gt; 또는 &lt;code&gt;m2&lt;/code&gt; 로 마스크 된 값을 마스크합니다 .</target>
        </trans-unit>
        <trans-unit id="93fabead91587e60c1a08bfee6b05728d77a4b94" translate="yes" xml:space="preserve">
          <source>The result may be a view on &lt;code&gt;m1&lt;/code&gt; or &lt;code&gt;m2&lt;/code&gt; if the other is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (i.e. False).</source>
          <target state="translated">다른 하나가 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 (즉, 거짓) 결과는 &lt;code&gt;m1&lt;/code&gt; 또는 &lt;code&gt;m2&lt;/code&gt; 에서 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12ea562d907c93ffb2a2a48a2ff38a17f82a53ed" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;cPickle.loads(strg)&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;cPickle.loads(strg)&lt;/code&gt; 의 결과 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="b138f2dad8b26af563c2e4bf508dc59fdd1de271" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x**p&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are scalars, so is &lt;code&gt;out&lt;/code&gt;, otherwise an array is returned.</source>
          <target state="translated">&lt;code&gt;x**p&lt;/code&gt; 의 결과 . 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;p&lt;/code&gt; 는 스칼라이므로 인 &lt;code&gt;out&lt;/code&gt; 그렇지 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="437933320e33dbd911c7ecb653e24b023c9820e4" translate="yes" xml:space="preserve">
          <source>The result of &lt;code&gt;x1 * 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1 * 2**x2&lt;/code&gt; 의 결과입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d200549129cf50987e2e3db04a3ddae4d86fd86e" translate="yes" xml:space="preserve">
          <source>The result of binning the input array. The length of &lt;code&gt;out&lt;/code&gt; is equal to &lt;code&gt;np.amax(x)+1&lt;/code&gt;.</source>
          <target state="translated">입력 배열 비닝 결과입니다. &lt;code&gt;out&lt;/code&gt; 의 길이는 &lt;code&gt;np.amax(x)+1&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c6126cff082b1038f45f0cf4b879a12e8909f651" translate="yes" xml:space="preserve">
          <source>The result of indexing with a multi-field index is a view into the original array, as follows:</source>
          <target state="translated">다중 필드 인덱스를 사용한 인덱싱 결과는 다음과 같이 원래 배열에 대한 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="b74fd032efc344495e89da82ba5cefb838c783f0" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True.</source>
          <target state="translated">마스킹 결과 &lt;code&gt;a&lt;/code&gt; 여기서 &lt;code&gt;condition&lt;/code&gt; 참이다.</target>
        </trans-unit>
        <trans-unit id="2f9d4558b4365ff73c9c67d9671ab31c28b67b0f" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where approximately equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">마스킹 &lt;code&gt;x&lt;/code&gt; 의 결과는 대략 &lt;code&gt;value&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7c8d1e813923a2b2b410b1cadd9d90a6a3b27803" translate="yes" xml:space="preserve">
          <source>The result of masking &lt;code&gt;x&lt;/code&gt; where equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">마스킹 &lt;code&gt;x&lt;/code&gt; 의 결과는 &lt;code&gt;value&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="20b27291ef8731ea508bbd0cd5e12a0ad3afd15b" translate="yes" xml:space="preserve">
          <source>The result of repeating &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">를 반복 &lt;code&gt;a&lt;/code&gt; 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="080be4f2b719d17ca857f6ff65fc2c9ddc4f8015" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 호출의 결과는 직접 다시 전달됩니다. 따라서 &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; 의 모양 은 완전히 &lt;code&gt;function&lt;/code&gt; 에 의해 결정됩니다 . 경우 &lt;code&gt;function&lt;/code&gt; 스칼라 값을 반환의 모양 &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 는&lt;/a&gt; 일치하지 않을 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="5a3504d8e95aae2a9b20b749f6d2c5a3889c5102" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;code&gt;shape&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 호출의 결과는 직접 전달됩니다. 따라서 형상 &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 은&lt;/a&gt; 완전히 결정되어 &lt;code&gt;function&lt;/code&gt; . 경우 &lt;code&gt;function&lt;/code&gt; 스칼라 값을 반환의 모양 &lt;a href=&quot;#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 는&lt;/a&gt; 일치하지 않을 &lt;code&gt;shape&lt;/code&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="02a8e58b3d72e0b52f3592cd0fcb4ec46672a2f6" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 호출의 결과는 직접 전달됩니다. 따라서 형상 &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 은&lt;/a&gt; 완전히 결정되어 &lt;code&gt;function&lt;/code&gt; . 경우 &lt;code&gt;function&lt;/code&gt; 스칼라 값을 반환의 모양 &lt;a href=&quot;#numpy.ma.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 는&lt;/a&gt; 일치하지 않을 &lt;a href=&quot;numpy.ma.shape#numpy.ma.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="7ebaed6e2d6aea7781825cdc661171775d93ce2b" translate="yes" xml:space="preserve">
          <source>The result of the call to &lt;code&gt;function&lt;/code&gt; is passed back directly. Therefore the shape of &lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; is completely determined by &lt;code&gt;function&lt;/code&gt;. If &lt;code&gt;function&lt;/code&gt; returns a scalar value, the shape of &lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt;&lt;code&gt;fromfunction&lt;/code&gt;&lt;/a&gt; would not match the &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; parameter.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 호출의 결과는 직접 다시 전달됩니다. 따라서 &lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; &lt;/a&gt; 의 모양 은 완전히 &lt;code&gt;function&lt;/code&gt; 에 의해 결정됩니다 . 경우 &lt;code&gt;function&lt;/code&gt; 스칼라 값을 반환의 모양 &lt;a href=&quot;numpy.fromfunction#numpy.fromfunction&quot;&gt; &lt;code&gt;fromfunction&lt;/code&gt; 는&lt;/a&gt; 일치하지 않을 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 매개 변수를.</target>
        </trans-unit>
        <trans-unit id="be63aee25a235ea7ecaebcc7084bf9b89e5f1ba3" translate="yes" xml:space="preserve">
          <source>The result of the inverse real 2-D FFT.</source>
          <target state="translated">역 실수 2-D FFT의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0a8c1e8c657004ada13d1bd67fea4f58af8cdb70" translate="yes" xml:space="preserve">
          <source>The result of the modulo operation for negative dividend and divisors is bound by conventions. For &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt;, the sign of result is the sign of the dividend, while for &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt;&lt;code&gt;remainder&lt;/code&gt;&lt;/a&gt; the sign of the result is the sign of the divisor. The &lt;a href=&quot;#numpy.fmod&quot;&gt;&lt;code&gt;fmod&lt;/code&gt;&lt;/a&gt; function is equivalent to the Matlab(TM) &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">네거티브 배당 및 제수에 대한 모듈로 연산의 결과는 규칙에 따릅니다. 들어 &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; 에 대한하면서, 결과의 부호는 배당의 부호이며 &lt;a href=&quot;numpy.remainder#numpy.remainder&quot;&gt; &lt;code&gt;remainder&lt;/code&gt; &lt;/a&gt; 결과의 부호는 제수의 부호이다. &lt;a href=&quot;#numpy.fmod&quot;&gt; &lt;code&gt;fmod&lt;/code&gt; &lt;/a&gt; 함수는 Matlab의 (TM)에 해당 &lt;code&gt;rem&lt;/code&gt; 기능.</target>
        </trans-unit>
        <trans-unit id="432755e899e9d369003d6c1f79ef56f8c75f0660" translate="yes" xml:space="preserve">
          <source>The result of the real 2-D FFT.</source>
          <target state="translated">실제 2 차원 FFT의 결과.</target>
        </trans-unit>
        <trans-unit id="a62988dd4c556a700006b20bcac64bfa1f21b000" translate="yes" xml:space="preserve">
          <source>The result of this is always a 2d array, with a row for each non-zero element.</source>
          <target state="translated">이 결과는 항상 0이 아닌 각 요소에 대한 행이있는 2d 배열입니다.</target>
        </trans-unit>
        <trans-unit id="552e732df1a7e97a3ac3793f40b01156b930c9d2" translate="yes" xml:space="preserve">
          <source>The result of trimming the input. The input data type is preserved.</source>
          <target state="translated">입력을 다듬은 결과. 입력 데이터 형식이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="0ff6806d85e8fabd807a03dd151b7e1cdd284df8" translate="yes" xml:space="preserve">
          <source>The result type.</source>
          <target state="translated">결과 유형</target>
        </trans-unit>
        <trans-unit id="101ce3a3f58e25741f8924a6b8d0cfd25472eeff" translate="yes" xml:space="preserve">
          <source>The result will be multidimensional if y has more dimensions than b. For example:</source>
          <target state="translated">y의 차원이 b보다 많으면 결과는 다차원이됩니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e2a369eb25dfa6d23e15865ad12a81c98b2538db" translate="yes" xml:space="preserve">
          <source>The result.</source>
          <target state="translated">결과.</target>
        </trans-unit>
        <trans-unit id="d1fb43fabbedcad07c574b0e98cbace4463e697f" translate="yes" xml:space="preserve">
          <source>The resulting approximation of</source>
          <target state="translated">결과 근사치</target>
        </trans-unit>
        <trans-unit id="8f5a6724cd845387db9fbc4a8e08fe47ae3e4ec1" translate="yes" xml:space="preserve">
          <source>The resulting array is a view into the original array. It shares the same memory locations and writing to the view will modify the original array.</source>
          <target state="translated">결과 배열은 원래 배열에 대한보기입니다. 동일한 메모리 위치를 공유하고 뷰에 쓰면 원래 배열이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="a4450860735a4299b5638f4df95ccd877c9615a2" translate="yes" xml:space="preserve">
          <source>The resulting array therefore has a value &lt;code&gt;fn(x, y, z)&lt;/code&gt; at coordinate &lt;code&gt;(x, y, z)&lt;/code&gt;.</source>
          <target state="translated">결과 배열은 따라서 좌표 &lt;code&gt;(x, y, z)&lt;/code&gt; 에서 &lt;code&gt;fn(x, y, z)&lt;/code&gt; 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="8e45fa029de06ce207816940e254f28318e174ec" translate="yes" xml:space="preserve">
          <source>The resulting path indicates which terms of the input contraction should be contracted first, the result of this contraction is then appended to the end of the contraction list. This list can then be iterated over until all intermediate contractions are complete.</source>
          <target state="translated">결과 경로는 입력 수축의 어떤 용어가 먼저 수축되는지를 나타내며이 수축의 결과는 수축리스트의 끝에 추가됩니다. 그런 다음이 목록은 모든 중간 수축이 완료 될 때까지 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0397bb7d27e88275099d7a9e2663ecd158fec65" translate="yes" xml:space="preserve">
          <source>The resulting signature for the function add.zadd is exactly the same one that was created previously. If the original source code had contained &lt;code&gt;A(N)&lt;/code&gt; instead of &lt;code&gt;A(*)&lt;/code&gt; and so forth with &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;C&lt;/code&gt;, then I could obtain (nearly) the same interface simply by placing the &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; comment line in the source code. The only difference is that &lt;code&gt;N&lt;/code&gt; would be an optional input that would default to the length of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">add.zadd 함수에 대한 결과 서명은 이전에 생성 된 것과 정확히 동일합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 원본 소스 코드를 포함했다면 &lt;code&gt;A(N)&lt;/code&gt; 대신 &lt;code&gt;A(*)&lt;/code&gt; 와 등 및 &lt;code&gt;B&lt;/code&gt; 와 &lt;code&gt;C&lt;/code&gt; , 다음 I 단순히 배치하여 (거의) 동일 인터페이스를 얻을 수있다 &lt;code&gt;INTENT(OUT) :: C&lt;/code&gt; 에 주석 행 소스 코드. 유일한 차이점은 &lt;code&gt;N&lt;/code&gt; 이 &lt;code&gt;A&lt;/code&gt; 의 길이로 기본 설정되는 선택적 입력이라는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="4e44a556cdbd9e08c1c73c688efe96d93b4a9c2d" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100 higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">결과는 최대 100도까지만 테스트되었으며 문제가있을 수 있습니다. 가중치는 다음과 같은 사실을 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="ef4a7d2bf5791e871493bd9bc1998dc73f56d092" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. For Gauss-Chebyshev there are closed form solutions for the sample points and weights. If n = &lt;code&gt;deg&lt;/code&gt;, then</source>
          <target state="translated">결과는 100도까지만 테스트되었으며, 높은 수준은 문제가 될 수 있습니다. Gauss-Chebyshev의 경우 샘플 포인트 및 무게에 대한 폐쇄 형 솔루션이 있습니다. n = &lt;code&gt;deg&lt;/code&gt; 인 경우</target>
        </trans-unit>
        <trans-unit id="7a2a5f718e6f28fd9a2d71c1fb3ee2ee9fe5b2fb" translate="yes" xml:space="preserve">
          <source>The results have only been tested up to degree 100, higher degrees may be problematic. The weights are determined by using the fact that</source>
          <target state="translated">결과는 100도까지만 테스트되었으며, 높은 수준은 문제가 될 수 있습니다. 가중치는 다음과 같은 사실을 사용하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="af6fbd4d24683930cbf1a134289a3df4c1b144c3" translate="yes" xml:space="preserve">
          <source>The results will be placed in this array. It may be the input array for in-place clipping. &lt;code&gt;out&lt;/code&gt; must be of the right shape to hold the output. Its type is preserved.</source>
          <target state="translated">결과는이 배열에 배치됩니다. 적절한 클리핑을위한 입력 배열 일 수 있습니다. &lt;code&gt;out&lt;/code&gt; 출력을 보유 할 권리 모양이어야합니다. 유형이 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c6b62851dacdc54d8864ac2edf1604fc62b66dd6" translate="yes" xml:space="preserve">
          <source>The return statement should &lt;em&gt;not&lt;/em&gt; get redundant parentheses:</source>
          <target state="translated">return 문은 중복 된 괄호를 가져서는 &lt;em&gt;안됩니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9002868afc12284eedaa4f924eaaabb6a7944154" translate="yes" xml:space="preserve">
          <source>The return type will always be an inexact (i.e. floating point) scalar type, even if all the arrays are integer arrays. If one of the inputs is an integer array, the minimum precision type that is returned is a 64-bit floating point dtype.</source>
          <target state="translated">모든 배열이 정수 배열 인 경우에도 반환 형식은 항상 정확하지 않은 (예 : 부동 소수점) 스칼라 형식입니다. 입력 중 하나가 정수 배열 인 경우 반환되는 최소 정밀도 유형은 64 비트 부동 소수점 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="273dde020fc2e47183998cc14b3fb20e4a9436a7" translate="yes" xml:space="preserve">
          <source>The return value is 0 on success, -1 on failure.</source>
          <target state="translated">성공하면 리턴 값은 0이고 실패하면 -1입니다.</target>
        </trans-unit>
        <trans-unit id="95baf9f3feb186151992e17419a9d52bee50a218" translate="yes" xml:space="preserve">
          <source>The return value is the same shape and type as &lt;code&gt;M&lt;/code&gt;; if the exponent is positive or zero then the type of the elements is the same as those of &lt;code&gt;M&lt;/code&gt;. If the exponent is negative the elements are floating-point.</source>
          <target state="translated">반환 값은 &lt;code&gt;M&lt;/code&gt; 과 모양과 유형이 같습니다 . 지수가 양수 또는 0 인 경우 요소의 유형은 &lt;code&gt;M&lt;/code&gt; 의 유형과 동일 합니다. 지수가 음수이면 요소는 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="55801c938cbd16156c4c8c48d17f11e40e4107d9" translate="yes" xml:space="preserve">
          <source>The return value of failed converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 유사 함수 에서 &quot;O &amp;amp;&quot;구문을 사용하여 호출 된 실패한 변환기 함수의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="41e4fb8b6c4e49bb724d556b26ed34481cfcd6dd" translate="yes" xml:space="preserve">
          <source>The return value of successful converter functions which are called using the &amp;ldquo;O&amp;amp;&amp;rdquo; syntax in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;-like functions.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 유사 함수 에서 &quot;O &amp;amp;&quot;구문을 사용하여 호출 된 성공적인 변환기 함수의 리턴 값입니다 .</target>
        </trans-unit>
        <trans-unit id="c05aab266b5f8aae47c5e7319a883da33ec4e284" translate="yes" xml:space="preserve">
          <source>The return value, False if &lt;code&gt;x&lt;/code&gt; is of a complex type.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 복합 유형 인 경우 False를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c002d9b8869cd4388cf5943fa7426632d76c13b5" translate="yes" xml:space="preserve">
          <source>The return value, True if &lt;code&gt;x&lt;/code&gt; is of a complex type or has at least one complex element.</source>
          <target state="translated">반환 값, &lt;code&gt;x&lt;/code&gt; 가 복합 유형이거나 복합 요소가 하나 이상 이면 True 입니다.</target>
        </trans-unit>
        <trans-unit id="8cacfcdc238ffe8ba32e3f60b54d5d84f6258480" translate="yes" xml:space="preserve">
          <source>The returned array has the same type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">반환 된 배열의 유형은와 동일 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984b85b3f1b178d24103374b554ddde5426110f" translate="yes" xml:space="preserve">
          <source>The returned array is always 1D.</source>
          <target state="translated">반환 된 배열은 항상 1D입니다.</target>
        </trans-unit>
        <trans-unit id="59afb62c6311159c3a4c4a5a09d0fcb3d683db81" translate="yes" xml:space="preserve">
          <source>The returned array is always a structured array, and is constructed from all matches of the regular expression in the file. Groups in the regular expression are converted to fields of the structured array.</source>
          <target state="translated">반환 된 배열은 항상 구조화 된 배열이며 파일에서 정규식의 모든 일치 항목으로 구성됩니다. 정규식의 그룹은 구조화 된 배열의 필드로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="235ae9f13128943772ff554e126bc69621884d0e" translate="yes" xml:space="preserve">
          <source>The returned array will be guaranteed to have the listed requirements by making a copy if needed.</source>
          <target state="translated">반환 된 배열은 필요한 경우 복사본을 만들어 나열된 요구 사항을 갖도록 보장합니다.</target>
        </trans-unit>
        <trans-unit id="4d7c736b03b1eeb7cc2b9172d888763588690bd3" translate="yes" xml:space="preserve">
          <source>The returned array will have at least &lt;code&gt;ndmin&lt;/code&gt; dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</source>
          <target state="translated">반환 된 배열의 크기 는 최소한 &lt;code&gt;ndmin&lt;/code&gt; 입니다. 그렇지 않으면 1 차원 축이 압착됩니다. 유효한 값 : 0 (기본값), 1 또는 2.</target>
        </trans-unit>
        <trans-unit id="0991fc7713b9227f260fa7eb1775e9a559dcb08f" translate="yes" xml:space="preserve">
          <source>The returned class can be of different type than the current instance and/or have a different domain and/or different window.</source>
          <target state="translated">반환 된 클래스는 현재 인스턴스와 다른 유형이거나 도메인 및 / 또는 창이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="f40fdf0f51a86b8b90c8d1563cabe3126d1130f1" translate="yes" xml:space="preserve">
          <source>The returned float array &lt;code&gt;f&lt;/code&gt; contains the frequency bin centers in cycles per unit of the sample spacing (with zero at the start). For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second.</source>
          <target state="translated">반환 된 float 배열 &lt;code&gt;f&lt;/code&gt; 에는 샘플 간격 단위당 사이클 단위의 주파수 빈 중심이 포함됩니다 (시작시 0). 예를 들어, 샘플 간격이 초이면 주파수 단위는 사이클 / 초입니다.</target>
        </trans-unit>
        <trans-unit id="235d36eec348db0a4ce24e42c9d6a7df17b250d1" translate="yes" xml:space="preserve">
          <source>The returned indices will be valid to access arrays of shape (n, n).</source>
          <target state="translated">반환 된 인덱스는 모양 배열 (n, n)에 액세스하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="ae4549a46a428a48cedb9424b21a41ed06873386" translate="yes" xml:space="preserve">
          <source>The returned list contains array(s) of dtype double, complex double, or object. A 1-d argument of shape &lt;code&gt;(N,)&lt;/code&gt; is parsed into &lt;code&gt;N&lt;/code&gt; arrays of size one; a 2-d argument of shape &lt;code&gt;(M,N)&lt;/code&gt; is parsed into &lt;code&gt;M&lt;/code&gt; arrays of size &lt;code&gt;N&lt;/code&gt; (i.e., is &amp;ldquo;parsed by row&amp;rdquo;); and a higher dimensional array raises a Value Error if it is not first reshaped into either a 1-d or 2-d array.</source>
          <target state="translated">반환 된리스트는 dtype double, complex double 또는 object의 배열을 포함합니다. 1 차원 형상 인수 &lt;code&gt;(N,)&lt;/code&gt; 는 크기가 1 인 &lt;code&gt;N&lt;/code&gt; 개의 배열 로 구문 분석됩니다 . 2 차원 형상 인수 &lt;code&gt;(M,N)&lt;/code&gt; 는 크기가 &lt;code&gt;N&lt;/code&gt; 인 &lt;code&gt;M&lt;/code&gt; 개의 어레이 로 파싱되고 (즉, &quot;행에 의해 파싱된다&quot;); 더 높은 차원의 배열은 1 차원 배열 또는 2 차원 배열로 처음 재 형성되지 않으면 값 오류를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="14f1e30e33046331e7dfbbcb8096ad0d5112d69f" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">반환 된 객체는 Python-type &lt;em&gt;하위 유형&lt;/em&gt; 의 객체이며 , &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 하위 유형이어야합니다 . 배열 갖는 &lt;em&gt;ND&lt;/em&gt; 설명 치수 &lt;em&gt;희미&lt;/em&gt; . 새 배열의 데이터 유형 설명자는 &lt;em&gt;descr&lt;/em&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="32e057c6946960f31384643bb71f5913a86433e2" translate="yes" xml:space="preserve">
          <source>The returned object is an object of Python-type &lt;em&gt;subtype&lt;/em&gt;, which must be a subtype of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;. The array has &lt;em&gt;nd&lt;/em&gt; dimensions, described by &lt;em&gt;dims&lt;/em&gt;. The data-type descriptor of the new array is &lt;em&gt;descr&lt;/em&gt;.</source>
          <target state="translated">반환 된 객체는 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 하위 유형이어야하는 Python 유형 &lt;em&gt;하위&lt;/em&gt; 유형의 객체 입니다. 배열에는 &lt;em&gt;dims로&lt;/em&gt; 설명되는 &lt;em&gt;nd&lt;/em&gt; 차원이 있습니다. 새 배열의 데이터 유형 설명자는 &lt;em&gt;descr&lt;/em&gt; 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5d88cddc6712bcffcc47387ee400aa7949d299dc" translate="yes" xml:space="preserve">
          <source>The returned order &lt;code&gt;m&lt;/code&gt; antiderivative &lt;code&gt;P&lt;/code&gt; of polynomial &lt;code&gt;p&lt;/code&gt; satisfies</source>
          <target state="translated">다항식 &lt;code&gt;p&lt;/code&gt; 의 반환 순서 &lt;code&gt;m&lt;/code&gt; 반 유도 &lt;code&gt;P&lt;/code&gt; 는 다음을 충족합니다.</target>
        </trans-unit>
        <trans-unit id="0b8999800a1f602548a03b4247be14d85063c532" translate="yes" xml:space="preserve">
          <source>The returned pointer will keep a reference to the array.</source>
          <target state="translated">반환 된 포인터는 배열에 대한 참조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="ff4b18e64fa81ec18b5e45dfe00e0436536dea93" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt;&lt;code&gt;numpy.datetime64&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt;&lt;code&gt;numpy.timedelta64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반환 된 튜플은 &lt;a href=&quot;../arrays.scalars#numpy.datetime64&quot;&gt; &lt;code&gt;numpy.datetime64&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../arrays.scalars#numpy.timedelta64&quot;&gt; &lt;code&gt;numpy.timedelta64&lt;/code&gt; &lt;/a&gt; 의 두 번째 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="592b730c2fcc65333034a0c7238210b05d5a5c20" translate="yes" xml:space="preserve">
          <source>The returned tuple can be passed as the second argument of &lt;code&gt;numpy.datetime64&lt;/code&gt; and &lt;code&gt;numpy.timedelta64&lt;/code&gt;.</source>
          <target state="translated">리턴 된 튜플은 &lt;code&gt;numpy.datetime64&lt;/code&gt; 및 &lt;code&gt;numpy.timedelta64&lt;/code&gt; 의 두 번째 인수로 전달 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f91874be1de458c40a0f1f04bc921bf313bf20d4" translate="yes" xml:space="preserve">
          <source>The returned tuple has the following items:</source>
          <target state="translated">반환 된 튜플에는 다음 항목이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cef76c21baa4e56901ef823fceedd7a7068daf4e" translate="yes" xml:space="preserve">
          <source>The returned type character must represent the smallest size dtype such that an array of the returned type can handle the data from an array of all types in &lt;code&gt;typechars&lt;/code&gt; (or if &lt;code&gt;typechars&lt;/code&gt; is an array, then its dtype.char).</source>
          <target state="translated">리턴 된 유형 문자는 리턴 된 유형의 배열이 &lt;code&gt;typechars&lt;/code&gt; (또는 &lt;code&gt;typechars&lt;/code&gt; 가 배열 인 경우 dtype.char ) 의 모든 유형 배열의 데이터를 처리 할 수 ​​있도록 가장 작은 크기의 dtype을 나타내야합니다.</target>
        </trans-unit>
        <trans-unit id="4fcc4213866e3a2e0117cc077e63fcf825ea6d85" translate="yes" xml:space="preserve">
          <source>The returned ufunc always returns PyObject arrays.</source>
          <target state="translated">반환 된 ufunc는 항상 PyObject 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a3367f678ba189a0a7553569bd4ae4f1aabaa222" translate="yes" xml:space="preserve">
          <source>The returned ufunc object is a callable Python object. It should be placed in a (module) dictionary under the same name as was used in the name argument to the ufunc-creation routine. The following example is adapted from the umath module</source>
          <target state="translated">반환 된 ufunc 객체는 호출 가능한 Python 객체입니다. ufunc-creation 루틴의 이름 인수에 사용 된 것과 동일한 이름으로 (모듈) 사전에 배치되어야합니다. 다음 예제는 umath 모듈에서 수정되었습니다.</target>
        </trans-unit>
        <trans-unit id="15355fac5e58f997eedbca2c4b98e86da4be8c2c" translate="yes" xml:space="preserve">
          <source>The returned values define a linear map &lt;code&gt;off + scl*x&lt;/code&gt; that is applied to the input arguments before the series is evaluated. The map depends on the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt;; if the current &lt;code&gt;domain&lt;/code&gt; is equal to the &lt;code&gt;window&lt;/code&gt; the resulting map is the identity. If the coefficients of the series instance are to be used by themselves outside this class, then the linear function must be substituted for the &lt;code&gt;x&lt;/code&gt; in the standard representation of the base polynomials.</source>
          <target state="translated">반환 된 값 은 계열이 평가되기 전에 입력 인수에 적용되는 선형 맵 &lt;code&gt;off + scl*x&lt;/code&gt; 를 정의합니다 . 지도는 &lt;code&gt;domain&lt;/code&gt; 과 &lt;code&gt;window&lt;/code&gt; 에 따라 다릅니다 . 현재 &lt;code&gt;domain&lt;/code&gt; 이 &lt;code&gt;window&lt;/code&gt; 경우 결과 맵은 ID입니다. 계열 인스턴스의 계수를이 클래스 외부에서 사용하려면 선형 함수를 기본 다항식의 표준 표현에서 &lt;code&gt;x&lt;/code&gt; 로 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0b9b48003d17ce5e05cd985e616cb02707b4abeb" translate="yes" xml:space="preserve">
          <source>The role of &lt;code&gt;__array_finalize__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; 의 역할</target>
        </trans-unit>
        <trans-unit id="ee620d4452ada0e1d6c1803fadfa839462d12739" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the power series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">근본 추정값은 컴패니언 행렬의 고유 값으로 구합니다. 복소 평면의 원점에서 멀리 떨어진 근은 이러한 값에 대한 검정력 계열의 수치 적 불안정성으로 인해 큰 오류가있을 수 있습니다. 다중성이 1보다 큰 근은 그러한 점 근처의 계열 값이 근의 오차에 상대적으로 민감하지 않기 때문에 더 큰 오차를 나타냅니다. 원점 근처의 고립 된 뿌리는 뉴턴 방법의 몇 번의 반복으로 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f62c87e72745436aa10f6d1a92b0a21eb2cc7b33" translate="yes" xml:space="preserve">
          <source>The root estimates are obtained as the eigenvalues of the companion matrix, Roots far from the origin of the complex plane may have large errors due to the numerical instability of the series for such values. Roots with multiplicity greater than 1 will also show larger errors as the value of the series near such points is relatively insensitive to errors in the roots. Isolated roots near the origin can be improved by a few iterations of Newton&amp;rsquo;s method.</source>
          <target state="translated">근본 추정값은 컴패니언 행렬의 고유 값으로 구합니다. 복소 평면의 원점에서 멀리 떨어진 근은 그러한 값에 대한 계열의 수치 적 불안정성으로 인해 큰 오류를 가질 수 있습니다. 다중성이 1보다 큰 근은 그러한 점 근처의 계열 값이 근의 오차에 상대적으로 민감하지 않기 때문에 더 큰 오차를 나타냅니다. 원점 근처의 고립 된 뿌리는 뉴턴 방법의 몇 번의 반복으로 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8ae81d114b6feba67040d0b0dda1df226f1fa7e" translate="yes" xml:space="preserve">
          <source>The roots of the polynomial, where self(x) == 0</source>
          <target state="translated">self (x) == 0 인 다항식의 근</target>
        </trans-unit>
        <trans-unit id="b31543f4d0be4f9892b87954c40031df062dff89" translate="yes" xml:space="preserve">
          <source>The row dimension of the arrays for which the returned indices will be valid.</source>
          <target state="translated">반환 된 인덱스가 유효한 배열의 행 차원입니다.</target>
        </trans-unit>
        <trans-unit id="0cdec07351f87c4df86a480e3a89d1fead72ecd2" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype 인수는 축소가 수행되어야하는 데이터 유형을 지정합니다. 배열의 데이터 유형이 출력을 처리하기에 &quot;큰&quot;크기가 아닌 경우에 중요합니다. 기본적으로 모든 정수 데이터 유형 한 크게 적어도 만들어진다 &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt; &quot;추가&quot;및 (평균, 합계 cumsum, 자극 및 cumprod 기능에 대한 기초를 형성하는) &quot;다중&quot;ufuncs 대한.</target>
        </trans-unit>
        <trans-unit id="81acb42027d32e73c24e9573f794b96cf5d260da" translate="yes" xml:space="preserve">
          <source>The rtype argument specifies the data-type the reduction should take place over. This is important if the data-type of the array is not &amp;ldquo;large&amp;rdquo; enough to handle the output. By default, all integer data-types are made at least as large as &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt; for the &amp;ldquo;add&amp;rdquo; and &amp;ldquo;multiply&amp;rdquo; ufuncs (which form the basis for mean, sum, cumsum, prod, and cumprod functions).</source>
          <target state="translated">rtype 인수는 축소가 발생해야하는 데이터 유형을 지정합니다. 이것은 배열의 데이터 유형이 출력을 처리 할만큼 충분히 &quot;크지&quot;않은 경우에 중요합니다. 기본적으로 모든 정수 데이터 유형 한 크게 적어도 만들어진다 &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; &lt;/a&gt; &quot;추가&quot;및 (평균, 합계 cumsum, 자극 및 cumprod 기능에 대한 기초를 형성하는) &quot;다중&quot;ufuncs 대한.</target>
        </trans-unit>
        <trans-unit id="bec28ce661286e5b1ead8f4ea14b439b8431742d" translate="yes" xml:space="preserve">
          <source>The rule governing whether two arrays have compatible shapes for broadcasting can be expressed in a single sentence.</source>
          <target state="translated">두 배열이 방송에 적합한 형태를 가지고 있는지 여부를 결정하는 규칙은 한 문장으로 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3014977f10c304b722035fb1a265596f0e833693" translate="yes" xml:space="preserve">
          <source>The rules for ABI and API compatibilities can be summarized as follows:</source>
          <target state="translated">ABI 및 API 호환성에 대한 규칙은 다음과 같이 요약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="db5c92fbe4ce9110548aea4ebd5e7c863e8e7523" translate="yes" xml:space="preserve">
          <source>The same analysis could be done with several different interest rates and/or payments and/or total amounts to produce an entire table.</source>
          <target state="translated">전체 테이블을 생성하기 위해 여러 다른 이율 및 / 또는 지불 및 / 또는 총액으로 동일한 분석을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5194cb5cb7f5066d38ff362abcd5cc64d2bd2e08" translate="yes" xml:space="preserve">
          <source>The same axis can be used several times. In that case, every use reduces the corresponding original dimension:</source>
          <target state="translated">동일한 축을 여러 번 사용할 수 있습니다. 이 경우 사용할 때마다 해당 원래 크기가 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="48a74e2709e394bc98ff4e370f8920b6550d09a0" translate="yes" xml:space="preserve">
          <source>The same function can operate on a 4-D array:</source>
          <target state="translated">동일한 기능이 4D 배열에서 작동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54bfa0763e872f148814a7d73d89f2039603e607" translate="yes" xml:space="preserve">
          <source>The same gcc version is used as the one with which Python itself is built on each platform. At the moment this means:</source>
          <target state="translated">Python 자체가 각 플랫폼에서 빌드되는 것과 동일한 gcc 버전이 사용됩니다. 현재 이것은 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="db94598647ae75e98a229d31f17501768537975a" translate="yes" xml:space="preserve">
          <source>The same results can be obtained by using the name of the second column (&lt;code&gt;&quot;p&quot;&lt;/code&gt;) as key instead of its index (1):</source>
          <target state="translated">인덱스 (1) 대신 두 번째 열의 이름 ( &lt;code&gt;&quot;p&quot;&lt;/code&gt; )을 키로 사용하여 동일한 결과를 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0259137762b94ac22ad991901b42b9be660a1c59" translate="yes" xml:space="preserve">
          <source>The same works for max and min, if you expand the dimensions:</source>
          <target state="translated">치수를 확장하면 max와 min에 대해서도 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2941e8dc3350840406ccff2f87675580f31546c3" translate="yes" xml:space="preserve">
          <source>The sample points corresponding to the &lt;code&gt;y&lt;/code&gt; values. If &lt;code&gt;x&lt;/code&gt; is None, the sample points are assumed to be evenly spaced &lt;code&gt;dx&lt;/code&gt; apart. The default is None.</source>
          <target state="translated">&lt;code&gt;y&lt;/code&gt; 값에 해당하는 샘플 점 . 경우 &lt;code&gt;x&lt;/code&gt; 아무도없는 샘플 포인트 균등 것으로 가정 &lt;code&gt;dx&lt;/code&gt; 떨어져. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="52ca25ab3ba5f07f393e1c15a4222278fa9f69d6" translate="yes" xml:space="preserve">
          <source>The scale of the gamma distribution. Must be non-negative. Default is equal to 1.</source>
          <target state="translated">감마 분포의 스케일입니다. 음수가 아니어야합니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="db0a2a364021746365e2e2dca54712719a934f9d" translate="yes" xml:space="preserve">
          <source>The scale parameter of the distribution. Default is 1. Must be non- negative.</source>
          <target state="translated">분포의 척도 모수입니다. 기본값은 1입니다. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="da19b6d80b0b211e043d20a99e868d2264fb18da" translate="yes" xml:space="preserve">
          <source>The scale parameter,</source>
          <target state="translated">스케일 파라미터</target>
        </trans-unit>
        <trans-unit id="162cbdbbbf1e2c84bee29866f841c84cd6b13d80" translate="yes" xml:space="preserve">
          <source>The scaling of the covariance matrix in &lt;code&gt;np.polyfit&lt;/code&gt; is different</source>
          <target state="translated">&lt;code&gt;np.polyfit&lt;/code&gt; 에서 공분산 행렬의 스케일링 이 다릅니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
