<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="4ed14787943fa351395f0ee27e0b0514b81bf28b" translate="yes" xml:space="preserve">
          <source>Data type of the resulting array. If None, the dtypes will be determined by the contents of each column, individually.</source>
          <target state="translated">결과 배열의 데이터 유형입니다. 없음 인 경우 dtypes는 각 열의 내용에 따라 개별적으로 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="339d59d85f01f8cdcf6fd821645f37195e30ec02" translate="yes" xml:space="preserve">
          <source>Data type of the returned array. For binary files, it is used to determine the size and byte-order of the items in the file.</source>
          <target state="translated">반환 된 배열의 데이터 형식입니다. 이진 파일의 경우 파일에있는 항목의 크기와 바이트 순서를 결정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="3ba3363f75318cb54fd6298e9fc5286371dc0e38" translate="yes" xml:space="preserve">
          <source>Data type of the returned array. For binary files, it is used to determine the size and byte-order of the items in the file. Most builtin numeric types are supported and extension types may be supported.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다. 이진 파일의 경우 파일에있는 항목의 크기와 바이트 순서를 결정하는 데 사용됩니다. 대부분의 내장 숫자 유형이 지원되며 확장 유형이 지원 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f9f4851300f70d5dc3cf562fa3240960b4dbf05" translate="yes" xml:space="preserve">
          <source>Data type of the returned array. The default is float.</source>
          <target state="translated">반환 된 배열의 데이터 형식입니다. 기본값은 float입니다.</target>
        </trans-unit>
        <trans-unit id="ed2ace0ed658145111b32dfd15ea87700b2f229e" translate="yes" xml:space="preserve">
          <source>Data type routines</source>
          <target state="translated">데이터 타입 루틴</target>
        </trans-unit>
        <trans-unit id="594095b790071c2f98aec2dbd65de7709d74433d" translate="yes" xml:space="preserve">
          <source>Data type sizes</source>
          <target state="translated">데이터 타입 크기</target>
        </trans-unit>
        <trans-unit id="2adf3e418cb1c78b65b7a000ba430a45647a5ca7" translate="yes" xml:space="preserve">
          <source>Data type testing</source>
          <target state="translated">데이터 타입 테스트</target>
        </trans-unit>
        <trans-unit id="98a34d678f5229fc5eec78849854a56a627dd1d1" translate="yes" xml:space="preserve">
          <source>Data type to cast to.</source>
          <target state="translated">전송할 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="182df8c2af2c2944401a368243e72ff53aba919b" translate="yes" xml:space="preserve">
          <source>Data type with fields &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; (with the given titles), both being 8-bit unsigned integers, the first at byte position 0 from the start of the field and the second at position 2:</source>
          <target state="translated">필드 &lt;code&gt;r&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; (주어진 제목 포함)를 가진 데이터 유형 (둘 다 부호없는 정수), 필드의 시작에서 바이트 위치 0에서 첫 번째, 위치 2에서 두 번째 문자 :</target>
        </trans-unit>
        <trans-unit id="b44a74dfbd4c8cbced718e34ed1777e530392fab" translate="yes" xml:space="preserve">
          <source>Data type with fields &lt;code&gt;r&lt;/code&gt;, &lt;code&gt;g&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;a&lt;/code&gt;, each being an 8-bit unsigned integer:</source>
          <target state="translated">필드 &lt;code&gt;r&lt;/code&gt; , &lt;code&gt;g&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;a&lt;/code&gt; 가 각각 8 비트 부호없는 정수인 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="dce22c316f82e72fe3ef7972975de030981baa7a" translate="yes" xml:space="preserve">
          <source>Data type, scalar, or array to cast from.</source>
          <target state="translated">캐스팅 할 데이터 유형, 스칼라 또는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b6be514c02654c4ded06230fc9559da237b0aa77" translate="yes" xml:space="preserve">
          <source>Data types</source>
          <target state="translated">데이터 유형</target>
        </trans-unit>
        <trans-unit id="555f1cb511a7fc830b4f9270140d6d7d6b86fdc6" translate="yes" xml:space="preserve">
          <source>Data types have the following method for changing the byte order:</source>
          <target state="translated">데이터 형식에는 바이트 순서를 변경하는 다음과 같은 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddbd1fc6e1311002ff40414585d42fb972fc1c73" translate="yes" xml:space="preserve">
          <source>Data with a given value representing missing data</source>
          <target state="translated">결측 데이터를 나타내는 주어진 값을 가진 데이터</target>
        </trans-unit>
        <trans-unit id="f50b92dac70ad7de4503bf5c2f303133f756b532" translate="yes" xml:space="preserve">
          <source>Data, as a regular &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; of any shape or datatype;</source>
          <target state="translated">모든 모양 또는 데이터 유형 의 일반 &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 로서의 데이터</target>
        </trans-unit>
        <trans-unit id="fd4e634077f484849d79c425f4661ed26b88a935" translate="yes" xml:space="preserve">
          <source>Data-type checking</source>
          <target state="translated">데이터 유형 검사</target>
        </trans-unit>
        <trans-unit id="391d43bd010ab4fe13de7cc4c6ed3a95e700d762" translate="yes" xml:space="preserve">
          <source>Data-type consisting of more than one element:</source>
          <target state="translated">둘 이상의 요소로 구성된 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="0b016d89b64e9dc1c8dd396ed22b7193dd67c03e" translate="yes" xml:space="preserve">
          <source>Data-type descriptor of the returned view, e.g., float32 or int16. Omitting it results in the view having the same data-type as &lt;code&gt;a&lt;/code&gt;. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the &lt;code&gt;type&lt;/code&gt; parameter).</source>
          <target state="translated">반환 된 뷰의 데이터 유형 설명자 (예 : float32 또는 int16). 를 생략하면 동일한 데이터 형식을 갖는 뷰 결과 &lt;code&gt;a&lt;/code&gt; . 이 인수는 반환 된 객체의 유형을 지정하는 ndarray 하위 클래스로 지정할 수도 있습니다 (이는 &lt;code&gt;type&lt;/code&gt; 매개 변수 를 설정하는 것과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="b6f39aab51ccb8d0145c1277755ec804cf3ef171" translate="yes" xml:space="preserve">
          <source>Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as &lt;code&gt;a&lt;/code&gt;. As with &lt;code&gt;ndarray.view&lt;/code&gt;, dtype can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the &lt;code&gt;type&lt;/code&gt; parameter).</source>
          <target state="translated">반환 된 뷰의 데이터 유형 설명자 (예 : float32 또는 int16). 동일한 데이터 형식을 갖는 뷰에서 기본적 없음 결과 &lt;code&gt;a&lt;/code&gt; . &lt;code&gt;ndarray.view&lt;/code&gt; 와 마찬가지로 dtype 은 ndarray 하위 클래스로 지정 될 수도 있습니다. 그런 다음 반환 된 객체의 유형을 지정합니다 (이는 &lt;code&gt;type&lt;/code&gt; 매개 변수 를 설정하는 것과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="2bc09131fee35a52a645be0fa4f4e07fdb68a652" translate="yes" xml:space="preserve">
          <source>Data-type descriptor of the returned view, e.g., float32 or int16. The default, None, results in the view having the same data-type as &lt;code&gt;a&lt;/code&gt;. This argument can also be specified as an ndarray sub-class, which then specifies the type of the returned object (this is equivalent to setting the &lt;code&gt;type&lt;/code&gt; parameter).</source>
          <target state="translated">반환 된 뷰의 데이터 형식 설명자 (예 : float32 또는 int16) 기본값 None은 뷰와 데이터 유형이 동일 &lt;code&gt;a&lt;/code&gt; . 이 인수는 ndarray 서브 클래스로 지정 될 수 있으며,이 클래스는 리턴 된 오브젝트의 유형을 지정합니다 (이는 &lt;code&gt;type&lt;/code&gt; 매개 변수 설정과 동일 함 ).</target>
        </trans-unit>
        <trans-unit id="22f7dd2234bee3f3f18b97392a6490d3ba873dee" translate="yes" xml:space="preserve">
          <source>Data-type descriptors</source>
          <target state="translated">데이터 타입 설명자</target>
        </trans-unit>
        <trans-unit id="5047a1b21f308ef4a4edd9ded69fea90920bfe2e" translate="yes" xml:space="preserve">
          <source>Data-type encapsulation</source>
          <target state="translated">데이터 타입 캡슐화</target>
        </trans-unit>
        <trans-unit id="2507f1a7f55fba205d86cdd75b7ab0cf6f6fbdd9" translate="yes" xml:space="preserve">
          <source>Data-type objects must be reference counted so be aware of the action on the data-type reference of different C-API calls. The standard rule is that when a data-type object is returned it is a new reference. Functions that take &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; objects and return arrays steal references to the data-type their inputs unless otherwise noted. Therefore, you must own a reference to any data-type object used as input to such a function.</source>
          <target state="translated">데이터 유형 오브젝트는 참조 횟수를 계산해야하므로 다른 C-API 호출의 데이터 유형 참조에 대한 조치를 알고 있어야합니다. 표준 규칙은 데이터 유형 객체가 반환 될 때 새로운 참조라는 것입니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; 객체 를 가져 오고 배열을 반환 하는 함수는 달리 명시되지 않는 한 입력에 대한 데이터 형식에 대한 참조를 훔칩니다. 따라서 해당 함수의 입력으로 사용되는 모든 데이터 유형 오브젝트에 대한 참조를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e22d85cb52fcf6bb7492be5bede91731e2a7d9a" translate="yes" xml:space="preserve">
          <source>Data-type objects must be reference counted so be aware of the action on the data-type reference of different C-API calls. The standard rule is that when a data-type object is returned it is a new reference. Functions that take &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; objects and return arrays steal references to the data-type their inputs unless otherwise noted. Therefore, you must own a reference to any data-type object used as input to such a function.</source>
          <target state="translated">데이터 유형 개체는 참조 횟수가 계산되어야하므로 다른 C-API 호출의 데이터 유형 참조에 대한 작업을 알고 있어야합니다. 표준 규칙은 데이터 유형 객체가 반환 될 때 새로운 참조라는 것입니다. &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; 객체 를 취하고 배열을 반환 하는 함수는 별도로 언급하지 않는 한 입력 데이터 유형에 대한 참조를 훔칩니다. 따라서 이러한 함수에 대한 입력으로 사용되는 모든 데이터 유형 개체에 대한 참조를 소유해야합니다.</target>
        </trans-unit>
        <trans-unit id="b15d5f87e12104d07e12104f29fa0201983c667c" translate="yes" xml:space="preserve">
          <source>Data-type of returned array.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="175ad74f523c9673c9dc38454591d4eb74c4d08a" translate="yes" xml:space="preserve">
          <source>Data-type of the array&amp;rsquo;s elements.</source>
          <target state="translated">배열 요소의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="083ed855a488906eb5ff7c9039d435f48aa3b852" translate="yes" xml:space="preserve">
          <source>Data-type of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;. By default, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is float.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 에 전달 된 좌표 배열의 데이터 유형입니다 . 기본적으로 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 은 float입니다.</target>
        </trans-unit>
        <trans-unit id="dea8e2a1f7fb1db9b7e34231c5e0957886ee508e" translate="yes" xml:space="preserve">
          <source>Data-type of the coordinate arrays passed to &lt;code&gt;function&lt;/code&gt;. By default, &lt;code&gt;dtype&lt;/code&gt; is float.</source>
          <target state="translated">&lt;code&gt;function&lt;/code&gt; 에 전달 된 좌표 배열의 데이터 유형입니다 . 기본적으로 &lt;code&gt;dtype&lt;/code&gt; 은 float입니다.</target>
        </trans-unit>
        <trans-unit id="4e15c31196d8acf582467b65de7e2dab92710470" translate="yes" xml:space="preserve">
          <source>Data-type of the field in which to place &lt;code&gt;val&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;val&lt;/code&gt; 을 배치 할 필드의 데이터 유형입니다 .</target>
        </trans-unit>
        <trans-unit id="39073b2fd3057c7b3b9a07d35e36e49c334d3ebb" translate="yes" xml:space="preserve">
          <source>Data-type of the output mask. By default, the output mask has a dtype of MaskType (bool). If the dtype is flexible, each field has a boolean dtype. This is ignored when &lt;code&gt;m&lt;/code&gt; is &lt;code&gt;nomask&lt;/code&gt;, in which case &lt;code&gt;nomask&lt;/code&gt; is always returned.</source>
          <target state="translated">출력 마스크의 데이터 유형입니다. 기본적으로 출력 마스크의 dtype은 MaskType (bool)입니다. dtype이 유연한 경우 각 필드에는 부울 dtype이 있습니다. &lt;code&gt;m&lt;/code&gt; 이 &lt;code&gt;nomask&lt;/code&gt; 인 경우에는 무시 되며 ,이 경우 &lt;code&gt;nomask&lt;/code&gt; 가 항상 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="51e15f46df8957d190b0e9a32edbef5e443c1138" translate="yes" xml:space="preserve">
          <source>Data-type of the output matrix.</source>
          <target state="translated">출력 행렬의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="6c5a46bdf3d87da37dab2e1edc7254de947ac4c8" translate="yes" xml:space="preserve">
          <source>Data-type of the output. Defaults to &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">출력의 데이터 유형입니다. 기본값은 &lt;code&gt;float&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a79e89d079db4006248432086f0ba9b4fb3e1b79" translate="yes" xml:space="preserve">
          <source>Data-type of the result. By default, the return data-type will have at least &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;numpy.float64&lt;/code&gt;&lt;/a&gt; precision.</source>
          <target state="translated">결과의 데이터 유형입니다. 기본적으로 반환 데이터 유형은 최소한 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;numpy.float64&lt;/code&gt; &lt;/a&gt; 정밀도를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="dae41e8d6682b39b1719c5f729cf4403ad9808e2" translate="yes" xml:space="preserve">
          <source>Data-type of the resulting array; default: float. If this is a structured data-type, the resulting array will be 1-dimensional, and each row will be interpreted as an element of the array. In this case, the number of columns used must match the number of fields in the data-type.</source>
          <target state="translated">결과 배열의 데이터 유형. 디폴트 : float. 이것이 구조화 된 데이터 유형 인 경우 결과 배열은 1 차원이되고 각 행은 배열의 요소로 해석됩니다. 이 경우 사용 된 열 수는 데이터 유형의 필드 수와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b505071c887042075c861cc8fc2d25f1ea672dda" translate="yes" xml:space="preserve">
          <source>Data-type of the returned array.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="620d631e802c6625ade1eba3753c9c102dd738c0" translate="yes" xml:space="preserve">
          <source>Data-type of the returned array; default: float.</source>
          <target state="translated">반환 된 배열의 데이터 유형입니다. 디폴트 : float.</target>
        </trans-unit>
        <trans-unit id="b76cac3ce27a94ef1f707a3ae326b952d9ea72b6" translate="yes" xml:space="preserve">
          <source>Data-type of the returned matrix.</source>
          <target state="translated">반환 된 행렬의 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="83e3321d6d9c1b02b3af684537a3f17f48f92529" translate="yes" xml:space="preserve">
          <source>Data-type to convert &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; to if given. Default is None.</source>
          <target state="translated">주어진 경우 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 를 변환 할 데이터 유형 입니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="98198bc475e33e539f57bb5d611ce0c46719fda9" translate="yes" xml:space="preserve">
          <source>Data-type with fields &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;G&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, each being an unsigned 8-bit integer:</source>
          <target state="translated">필드가 &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;G&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 인 데이터 유형은 각각 부호없는 8 비트 정수입니다.</target>
        </trans-unit>
        <trans-unit id="97d945f72df62bf65abebd32ec6eeec836638f9c" translate="yes" xml:space="preserve">
          <source>Data-type with fields &lt;code&gt;big&lt;/code&gt; (big-endian 32-bit integer) and &lt;code&gt;little&lt;/code&gt; (little-endian 32-bit integer):</source>
          <target state="translated">&lt;code&gt;big&lt;/code&gt; (big-endian 32 비트 정수) 및 &lt;code&gt;little&lt;/code&gt; (little-endian 32 비트 정수) 필드가있는 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="7d8d0e4f66717afb9caca10ce7ca4b6fef1542ca" translate="yes" xml:space="preserve">
          <source>Data-types can be used as functions to convert python numbers to array scalars (see the array scalar section for an explanation), python sequences of numbers to arrays of that type, or as arguments to the dtype keyword that many numpy functions or methods accept. Some examples:</source>
          <target state="translated">데이터 유형은 파이썬 숫자를 배열 스칼라로 변환하는 함수 (설명은 배열 스칼라 섹션 참조), 숫자의 파이썬 시퀀스를 해당 유형의 배열로, 또는 많은 numpy 함수 나 메서드가 허용하는 dtype 키워드에 대한 인수로 사용할 수 있습니다. . 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="f9892dceaf4c393849b8298d0123d5d5f05ba0c0" translate="yes" xml:space="preserve">
          <source>Data-types.</source>
          <target state="translated">Data-types.</target>
        </trans-unit>
        <trans-unit id="236d451bd1043c68cb6b168fe59695d559f46b5c" translate="yes" xml:space="preserve">
          <source>DataSource (class in numpy)</source>
          <target state="translated">DataSource (numpy의 클래스)</target>
        </trans-unit>
        <trans-unit id="63d0f9bc2a331816b54d90289e0564cae9cab711" translate="yes" xml:space="preserve">
          <source>DataSource.abspath()</source>
          <target state="translated">DataSource.abspath()</target>
        </trans-unit>
        <trans-unit id="a75e29b5cace0f330a36c9eb65db62d75aa42186" translate="yes" xml:space="preserve">
          <source>DataSource.exists()</source>
          <target state="translated">DataSource.exists()</target>
        </trans-unit>
        <trans-unit id="bd4a229fdbfe009b3be26b6043f0184701a0533b" translate="yes" xml:space="preserve">
          <source>DataSource.open()</source>
          <target state="translated">DataSource.open()</target>
        </trans-unit>
        <trans-unit id="9406f9d63729835268647100d60fa6dda91bf0bf" translate="yes" xml:space="preserve">
          <source>DataSources can be local files or remote files/URLs. The files may also be compressed or uncompressed. DataSource hides some of the low-level details of downloading the file, allowing you to simply pass in a valid file path (or URL) and obtain a file object.</source>
          <target state="translated">데이터 소스는 로컬 파일 또는 원격 파일 / URL 일 수 있습니다. 파일이 압축되거나 압축되지 않을 수도 있습니다. DataSource는 파일 다운로드에 대한 일부 하위 레벨 세부 사항을 숨기므로 유효한 파일 경로 (또는 URL)를 전달하고 파일 오브젝트를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8aeeec1fd740b257ff42ec9b3acef6af6a7c28c" translate="yes" xml:space="preserve">
          <source>Datatype or sequence of datatypes. If None, the datatypes are estimated from the &lt;code&gt;data&lt;/code&gt;.</source>
          <target state="translated">데이터 유형 또는 데이터 유형 시퀀스. 없음 경우, 데이터 유형이 추정되는 &lt;code&gt;data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb9a4bc1c0c153e4e4b042a79113b815b7e3021d" translate="yes" xml:space="preserve">
          <source>Date</source>
          <target state="translated">Date</target>
        </trans-unit>
        <trans-unit id="81b7d2ea42df2f5da13026da9e2cb57a3aabc441" translate="yes" xml:space="preserve">
          <source>Date:</source>
          <target state="translated">Date:</target>
        </trans-unit>
        <trans-unit id="3a634fe6b2da8d8d4c344bc698f77cf69c809b5f" translate="yes" xml:space="preserve">
          <source>Datetime</source>
          <target state="translated">Datetime</target>
        </trans-unit>
        <trans-unit id="bb7bfb490786a995bfa9e2a5b6823f17a1a216ef" translate="yes" xml:space="preserve">
          <source>Datetime Arithmetic</source>
          <target state="translated">날짜 / 시간 산술</target>
        </trans-unit>
        <trans-unit id="26757f51523448884cb35f7c2e7a9d830a1f0706" translate="yes" xml:space="preserve">
          <source>Datetime Support Functions</source>
          <target state="translated">날짜 / 시간 지원 기능</target>
        </trans-unit>
        <trans-unit id="e00cad3edede5f768d55ef060cdd96323a7571ad" translate="yes" xml:space="preserve">
          <source>Datetime Units</source>
          <target state="translated">날짜 시간 단위</target>
        </trans-unit>
        <trans-unit id="38b428bb26c8af0c4b0fd0c5793ec1f2bdae7051" translate="yes" xml:space="preserve">
          <source>Datetime and Timedelta Arithmetic</source>
          <target state="translated">날짜 및 시간 델타 산술</target>
        </trans-unit>
        <trans-unit id="4c72e4c628fc8e294be703a7cacbedb31e07e1dc" translate="yes" xml:space="preserve">
          <source>Datetime support</source>
          <target state="translated">날짜 시간 지원</target>
        </trans-unit>
        <trans-unit id="48d6aa44d4ca3cc7a3a4b06f69e541ecb8ebd93c" translate="yes" xml:space="preserve">
          <source>Datetime support functions</source>
          <target state="translated">날짜 / 시간 지원 기능</target>
        </trans-unit>
        <trans-unit id="45540e9d36b6a636a7d3f2083fde0b3cb45e0a66" translate="yes" xml:space="preserve">
          <source>Datetimes and Timedeltas</source>
          <target state="translated">날짜 및 시간 델타</target>
        </trans-unit>
        <trans-unit id="d5889493937e34467174cb169e91b981059850e9" translate="yes" xml:space="preserve">
          <source>Datetimes and Timedeltas work together to provide ways for simple datetime calculations.</source>
          <target state="translated">Datetimes 및 Timedeltas는 간단한 날짜 / 시간 계산 방법을 제공하기 위해 함께 작동합니다.</target>
        </trans-unit>
        <trans-unit id="51531cc702406b6c9763cc42d8bdd8ad26a43c0f" translate="yes" xml:space="preserve">
          <source>Datetimes are always stored based on POSIX time (though having a TAI mode which allows for accounting of leap-seconds is proposed), with an epoch of 1970-01-01T00:00Z. This means the supported dates are always a symmetric interval around the epoch, called &amp;ldquo;time span&amp;rdquo; in the table below.</source>
          <target state="translated">날짜 시간은 항상 POSIX 시간을 기준으로 저장됩니다 (단, 윤초를 계산할 수있는 TAI 모드가 제 안됨). 이는 지원되는 날짜가 항상 에포크 주변의 대칭 간격이며 아래 표에서 &quot;시간 범위&quot;라고합니다.</target>
        </trans-unit>
        <trans-unit id="122763cb7427afdd4c15e276fdc1c80b3815094a" translate="yes" xml:space="preserve">
          <source>David McKay, &amp;ldquo;Information Theory, Inference and Learning Algorithms,&amp;rdquo; chapter 23, &lt;a href=&quot;http://www.inference.org.uk/mackay/itila/&quot;&gt;http://www.inference.org.uk/mackay/itila/&lt;/a&gt;</source>
          <target state="translated">David McKay,&amp;ldquo;정보 이론, 추론 및 학습 알고리즘,&amp;rdquo;23 장, &lt;a href=&quot;http://www.inference.org.uk/mackay/itila/&quot;&gt;http://www.inference.org.uk/mackay/itila/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3a5fdc0bfcbc22794c547cc3001bee75e7471095" translate="yes" xml:space="preserve">
          <source>Dealing with KIND specifiers</source>
          <target state="translated">KIND 지정자 다루기</target>
        </trans-unit>
        <trans-unit id="33d53a3ccf2fafd0ab1e36ce2784e68594b459b9" translate="yes" xml:space="preserve">
          <source>Dealing with array objects</source>
          <target state="translated">배열 객체 다루기</target>
        </trans-unit>
        <trans-unit id="323cd88ac9edb3118c18157c13cf0ea074760ad6" translate="yes" xml:space="preserve">
          <source>Dealing with encoding and dtype issues</source>
          <target state="translated">인코딩 및 dtype 문제 처리</target>
        </trans-unit>
        <trans-unit id="812d36d79a90e882bd2e8eae368ea14f78ae3b09" translate="yes" xml:space="preserve">
          <source>Dealing with types</source>
          <target state="translated">타입 다루기</target>
        </trans-unit>
        <trans-unit id="d2a20bd58858c9ae119cfad9819c0c3d1bae6ed3" translate="yes" xml:space="preserve">
          <source>Dealing with variable numbers of indices within programs</source>
          <target state="translated">프로그램 내에서 가변적 인 수의 인덱스 다루기</target>
        </trans-unit>
        <trans-unit id="a8f5a30a4cb8786cd322dd6dbfd8f1d482955120" translate="yes" xml:space="preserve">
          <source>Deallocates the iterator object and resolves any needed writebacks.</source>
          <target state="translated">반복자 객체를 할당 해제하고 필요한 모든 쓰기 저장을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="ad9c7cd74dc2bd34e8b8c600c07899c84dcc04dd" translate="yes" xml:space="preserve">
          <source>Debian (sid) Linux, Python 2.1.3+, 2.2.3+, 2.3.3 PyCrust 0.9.3, Idle 1.0.2</source>
          <target state="translated">데비안 (sid) 리눅스, Python 2.1.3+, 2.2.3+, 2.3.3 PyCrust 0.9.3, 유휴 1.0.2</target>
        </trans-unit>
        <trans-unit id="94860893584a6731f4089a31cf8088cfe91a8721" translate="yes" xml:space="preserve">
          <source>Debug build on Windows</source>
          <target state="translated">Windows에서 빌드 디버그</target>
        </trans-unit>
        <trans-unit id="895b27c88016513d278a0ce3dc0663fae3829d58" translate="yes" xml:space="preserve">
          <source>Debugging</source>
          <target state="translated">Debugging</target>
        </trans-unit>
        <trans-unit id="34b80087890916e2b26eb9e138628cfd6ccd9b6f" translate="yes" xml:space="preserve">
          <source>Debugging-Related Options</source>
          <target state="translated">디버깅 관련 옵션</target>
        </trans-unit>
        <trans-unit id="381cf1d4f9bf30b3f627a78d00fe15cdf2c7627c" translate="yes" xml:space="preserve">
          <source>Decide when the use of masked arrays is appropriate in some of your applications</source>
          <target state="translated">일부 애플리케이션에서 마스킹 된 배열의 사용이 적절한시기 결정</target>
        </trans-unit>
        <trans-unit id="1111acbc77e1b6bc2fd9153a83aaaa3e388ca65d" translate="yes" xml:space="preserve">
          <source>Deciding what case applies, checking broadcasting, and determining the kind of transposition needed are all done in &lt;code&gt;PyArray_MapIterNew&lt;/code&gt;. After setting up, there are two cases. If there is no subarray or it only has one element, no subarray iteration is necessary and an iterator is prepared which iterates all indexing arrays &lt;em&gt;as well as&lt;/em&gt; the result or value array. If there is a subarray, there are three iterators prepared. One for the indexing arrays, one for the result or value array (minus its subarray), and one for the subarrays of the original and the result/assignment array. The first two iterators give (or allow calculation) of the pointers into the start of the subarray, which then allows to restart the subarray iteration.</source>
          <target state="translated">적용 사례 결정, 방송 확인 및 필요한 전이 종류 결정은 모두 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 에서 수행됩니다 . 설정 후 두 가지 경우가 있습니다. 하위 배열이 없거나 하나의 요소 만있는 경우 하위 배열 반복이 필요하지 않으며 결과 또는 값 배열 &lt;em&gt;뿐만 아니라&lt;/em&gt; 모든 색인 배열을 반복하는 반복자가 준비 됩니다. 하위 배열이 있으면 세 개의 반복자가 준비됩니다. 하나는 인덱싱 배열, 하나는 결과 또는 값 배열 (하위 배열 빼기), 다른 하나는 원본 및 결과 / 할당 배열의 하위 배열입니다. 처음 두 반복자는 하위 배열의 시작 부분에 포인터를 제공 (또는 계산 가능) 한 다음 하위 배열 반복을 다시 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="992872abe2546d68e736db66506b69af3e9450e2" translate="yes" xml:space="preserve">
          <source>Decimal characters include digit characters, and all characters that can be used to form decimal-radix numbers, e.g. &lt;code&gt;U+0660, ARABIC-INDIC DIGIT ZERO&lt;/code&gt;.</source>
          <target state="translated">10 진수 문자에는 숫자 문자와 10 진수 기수를 형성하는 데 사용할 수있는 모든 문자가 포함됩니다 (예 : &lt;code&gt;U+0660, ARABIC-INDIC DIGIT ZERO&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9516fdc9c7eef205e499da4e7ec3cede5ceb388" translate="yes" xml:space="preserve">
          <source>Decimal characters include digit characters, and all characters that that can be used to form decimal-radix numbers, e.g. &lt;code&gt;U+0660, ARABIC-INDIC DIGIT ZERO&lt;/code&gt;.</source>
          <target state="translated">십진 문자에는 숫자 문자 및 십진 기수를 형성하는 데 사용할 수있는 모든 문자 (예 : &lt;code&gt;U+0660, ARABIC-INDIC DIGIT ZERO&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f5e804f5eda262d8f5e4948e51ed0cc0894ec6b2" translate="yes" xml:space="preserve">
          <source>Declare external functions and variables in a header file.</source>
          <target state="translated">헤더 파일에서 외부 함수 및 변수를 선언합니다.</target>
        </trans-unit>
        <trans-unit id="e660781fd8b95b64d64b6f05b5f17d8ea5d1d96c" translate="yes" xml:space="preserve">
          <source>Decompose the elements of x into mantissa and twos exponent.</source>
          <target state="translated">x의 요소를 가수와 2의 지수로 분해합니다.</target>
        </trans-unit>
        <trans-unit id="c0a2aa6456fc6630ef3dc6620f0cbae61a88fe6c" translate="yes" xml:space="preserve">
          <source>Decompositions</source>
          <target state="translated">Decompositions</target>
        </trans-unit>
        <trans-unit id="ffe4e593056575686068099d6790448db4206386" translate="yes" xml:space="preserve">
          <source>Decorator to apply to methods</source>
          <target state="translated">메소드에 적용하는 데코레이터</target>
        </trans-unit>
        <trans-unit id="e07b2c2e1e25e79a86c68698117e4cba4b32238d" translate="yes" xml:space="preserve">
          <source>Decorator which, when applied to a function, causes SkipTest to be raised when &lt;code&gt;skip_condition&lt;/code&gt; is True, and the function to be called normally otherwise.</source>
          <target state="translated">함수에 적용될 때 &lt;code&gt;skip_condition&lt;/code&gt; 이 True이면 SkipTest가 발생 하고 그렇지 않으면 함수가 정상적으로 호출 되는 데코레이터 .</target>
        </trans-unit>
        <trans-unit id="adc746be3b00936c8c3a3472b3e3078c3a4656a5" translate="yes" xml:space="preserve">
          <source>Decorator, which, when applied to a function, causes KnownFailureException to be raised when &lt;code&gt;fail_condition&lt;/code&gt; is True, and the function to be called normally otherwise.</source>
          <target state="translated">&lt;code&gt;fail_condition&lt;/code&gt; 이 True이면 함수에 적용될 때 KnownFailureException 이 발생 하고, 그렇지 않으면 함수가 정상적으로 호출 되는 Decorator .</target>
        </trans-unit>
        <trans-unit id="a2e23b650a15e5c693ca1445133d5ee60d9d20b4" translate="yes" xml:space="preserve">
          <source>Decorators</source>
          <target state="translated">Decorators</target>
        </trans-unit>
        <trans-unit id="951d318afe63ebb409ecca810f057a766c4ca7b0" translate="yes" xml:space="preserve">
          <source>Deep Copy</source>
          <target state="translated">딥 카피</target>
        </trans-unit>
        <trans-unit id="808d7dca8a74d84af27a2d6602c3d786de45fe1e" translate="yes" xml:space="preserve">
          <source>Default</source>
          <target state="translated">Default</target>
        </trans-unit>
        <trans-unit id="34692108afca567d865d43e42370d7e1925cff06" translate="yes" xml:space="preserve">
          <source>Default buffers</source>
          <target state="translated">기본 버퍼</target>
        </trans-unit>
        <trans-unit id="571112037f7618f6ce10d8c3dd958643f65f8421" translate="yes" xml:space="preserve">
          <source>Default casting rule change</source>
          <target state="translated">기본 캐스팅 규칙 변경</target>
        </trans-unit>
        <trans-unit id="2335a11535e98158d8ca1e7070652f1e66fd9c56" translate="yes" xml:space="preserve">
          <source>Default is &amp;lsquo;greedy&amp;rsquo;.</source>
          <target state="translated">기본값은 '욕심'입니다.</target>
        </trans-unit>
        <trans-unit id="c17e4da3ff3b0f9f748a4d6acc1f8640afd0a462" translate="yes" xml:space="preserve">
          <source>Default is &amp;lsquo;r+&amp;rsquo;.</source>
          <target state="translated">기본값은 'r +'입니다.</target>
        </trans-unit>
        <trans-unit id="d6fc6505a7468b1eb07e232276a1a144ed108cc4" translate="yes" xml:space="preserve">
          <source>Default is &amp;lsquo;safe&amp;rsquo;.</source>
          <target state="translated">기본값은 '안전'입니다.</target>
        </trans-unit>
        <trans-unit id="ffe4ea797d5b8a7f8cfde90ab339db72e2e542a2" translate="yes" xml:space="preserve">
          <source>Default is 0.</source>
          <target state="translated">기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="b9ce70b65cf5b4dc82412d7768f94d53c38cac38" translate="yes" xml:space="preserve">
          <source>Default is &lt;code&gt;False&lt;/code&gt;. If &lt;code&gt;True&lt;/code&gt;, the tuple (&lt;a href=&quot;#numpy.average&quot;&gt;&lt;code&gt;average&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;sum_of_weights&lt;/code&gt;) is returned, otherwise only the average is returned. If &lt;code&gt;weights=None&lt;/code&gt;, &lt;code&gt;sum_of_weights&lt;/code&gt; is equivalent to the number of elements over which the average is taken.</source>
          <target state="translated">기본값은 &lt;code&gt;False&lt;/code&gt; 입니다. 경우 &lt;code&gt;True&lt;/code&gt; , 튜플 ( &lt;a href=&quot;#numpy.average&quot;&gt; &lt;code&gt;average&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;sum_of_weights&lt;/code&gt; 가 ) 반환되고, 그렇지 않으면 단지 평균이 반환됩니다. 경우 &lt;code&gt;weights=None&lt;/code&gt; , &lt;code&gt;sum_of_weights&lt;/code&gt; 하면 평균 촬영되는 동안 소자의 수와 동일하다.</target>
        </trans-unit>
        <trans-unit id="6fafe55b73fa98b695385282c370b435d27e1633" translate="yes" xml:space="preserve">
          <source>Default is &lt;code&gt;None&lt;/code&gt;, to use the entire axis.</source>
          <target state="translated">전체 축을 사용하려면 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="28951177af990d02d67504338ec510505f905759" translate="yes" xml:space="preserve">
          <source>Default iteration</source>
          <target state="translated">기본 반복</target>
        </trans-unit>
        <trans-unit id="966299221cc27c9aaada9018f864b33036434b1d" translate="yes" xml:space="preserve">
          <source>Default normalization (False) is by &lt;code&gt;(N - 1)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations given (unbiased estimate). If &lt;code&gt;bias&lt;/code&gt; is True, then normalization is by &lt;code&gt;N&lt;/code&gt;. These values can be overridden by using the keyword &lt;code&gt;ddof&lt;/code&gt; in numpy versions &amp;gt;= 1.5.</source>
          <target state="translated">기본 정규화 (False)는 &lt;code&gt;(N - 1)&lt;/code&gt; . 여기서 &lt;code&gt;N&lt;/code&gt; 은 제공된 관측치 수입니다 (편견되지 않은 추정치). 경우 &lt;code&gt;bias&lt;/code&gt; True 인 후 정상화는 것입니다 &lt;code&gt;N&lt;/code&gt; . 이 값은 numpy 버전&amp;gt; = 1.5에서 키워드 &lt;code&gt;ddof&lt;/code&gt; 를 사용하여 무시할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="90d359fa1c07cc7df5b917d7e3f5d34c57ec0aae" translate="yes" xml:space="preserve">
          <source>Default normalization (False) is by &lt;code&gt;(N-1)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations given (unbiased estimate). If &lt;code&gt;bias&lt;/code&gt; is True, then normalization is by &lt;code&gt;N&lt;/code&gt;. This keyword can be overridden by the keyword &lt;code&gt;ddof&lt;/code&gt; in numpy versions &amp;gt;= 1.5.</source>
          <target state="translated">기본 정규화 (False)는 &lt;code&gt;(N-1)&lt;/code&gt; 입니다 . 여기서 &lt;code&gt;N&lt;/code&gt; 은 제공된 관측치 수입니다 (편견되지 않은 추정치). 경우 &lt;code&gt;bias&lt;/code&gt; True 인 후 정상화는 것입니다 &lt;code&gt;N&lt;/code&gt; . 이 키워드는 numpy 버전&amp;gt; = 1.5 의 키워드 &lt;code&gt;ddof&lt;/code&gt; 로 대체 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="719f3db22853f6f54f02e96c26a2311da39af743" translate="yes" xml:space="preserve">
          <source>Default priority for arrays.</source>
          <target state="translated">배열의 기본 우선 순위.</target>
        </trans-unit>
        <trans-unit id="6716ba557871317c5fd2c10ccc1e593c8f19cb74" translate="yes" xml:space="preserve">
          <source>Default scalar priority (very small)</source>
          <target state="translated">기본 스칼라 우선 순위 (매우 작음)</target>
        </trans-unit>
        <trans-unit id="e641966d275ad425b62fc62d9745e763b1f6dd59" translate="yes" xml:space="preserve">
          <source>Default size of the user-settable internal buffers.</source>
          <target state="translated">사용자 설정 가능한 내부 버퍼의 기본 크기.</target>
        </trans-unit>
        <trans-unit id="5d1efc3a1f02c0ec5b61bbb0c9ab7a02738e94d3" translate="yes" xml:space="preserve">
          <source>Default subtype priority.</source>
          <target state="translated">기본 하위 유형 우선 순위.</target>
        </trans-unit>
        <trans-unit id="16a99af14cd742b7888548aa51fb6ac7d09e8605" translate="yes" xml:space="preserve">
          <source>Defaults to true. If set to false, the output will always be a strict array, not a subtype.</source>
          <target state="translated">기본값은 true입니다. false로 설정하면 출력은 항상 하위 유형이 아닌 엄격한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2b3e0f5011c5a7820f042e8646d3807526feef63" translate="yes" xml:space="preserve">
          <source>Define a vectorized function which takes a nested sequence of objects or numpy arrays as inputs and returns a single numpy array or a tuple of numpy arrays. The vectorized function evaluates &lt;code&gt;pyfunc&lt;/code&gt; over successive tuples of the input arrays like the python map function, except it uses the broadcasting rules of numpy.</source>
          <target state="translated">중첩 된 객체 시퀀스 또는 numpy 배열을 입력으로 사용하고 단일 numpy 배열 또는 numpy 배열의 튜플을 반환하는 벡터화 된 함수를 정의하십시오. 벡터화 된 함수 는 numpy의 브로드 캐스트 규칙을 사용하는 것을 제외하고는 파이썬 맵 함수와 같은 입력 배열의 연속 튜플에 대해 &lt;code&gt;pyfunc&lt;/code&gt; 를 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="3524bed7c2347159eaf40501936c85412e29b564" translate="yes" xml:space="preserve">
          <source>Define auxiliary C variable in F2PY generated wrapper function. Useful to save parameter values so that they can be accessed in initialization expression of other variables. Note that &lt;code&gt;intent(aux)&lt;/code&gt; silently implies &lt;code&gt;intent(c)&lt;/code&gt;.</source>
          <target state="translated">F2PY 생성 래퍼 함수에서 보조 C 변수를 정의합니다. 다른 변수의 초기화 표현식에서 액세스 할 수 있도록 매개 변수 값을 저장하는 데 유용합니다. 참고 &lt;code&gt;intent(aux)&lt;/code&gt; 자동으로 의미 &lt;code&gt;intent(c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b67a2a6a2f10a0438338af977bc8d261b78376c0" translate="yes" xml:space="preserve">
          <source>Define macro &lt;code&gt;&amp;lt;macro&amp;gt;&lt;/code&gt;</source>
          <target state="translated">매크로 &lt;code&gt;&amp;lt;macro&amp;gt;&lt;/code&gt; 정의</target>
        </trans-unit>
        <trans-unit id="3d175b5790f5972e2666d5bdfe0e596a28cd9c1e" translate="yes" xml:space="preserve">
          <source>Define macro &lt;code&gt;&amp;lt;macro&amp;gt;&lt;/code&gt; as &lt;code&gt;&amp;lt;defn&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">매크로 &lt;code&gt;&amp;lt;macro&amp;gt;&lt;/code&gt; 를 &lt;code&gt;&amp;lt;defn&amp;gt;&lt;/code&gt; 로 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="61505cbdb5cf52ffbc6a8bf8b8f8af1217631a20" translate="yes" xml:space="preserve">
          <source>Define the absolute value, which is &lt;code&gt;-x&lt;/code&gt; for &lt;code&gt;x &amp;lt;0&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; for &lt;code&gt;x &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">인 절대 값 정의 &lt;code&gt;-x&lt;/code&gt; 대한 &lt;code&gt;x &amp;lt;0&lt;/code&gt; 및 &lt;code&gt;x&lt;/code&gt; 에 대한 &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60c3116e72bd6db8e3267fc1ab9d7cb6e083f5e7" translate="yes" xml:space="preserve">
          <source>Define the sigma function, which is -1 for &lt;code&gt;x &amp;lt; 0&lt;/code&gt; and +1 for &lt;code&gt;x &amp;gt;= 0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; 0&lt;/code&gt; -1 이고 &lt;code&gt;x &amp;gt;= 0&lt;/code&gt; +1 인 시그마 함수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="f5471ada09dfcde67297a0ac30990ba21a16931a" translate="yes" xml:space="preserve">
          <source>Defined as 0 for use with Bool.</source>
          <target state="translated">Bool과 함께 사용하기 위해 0으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="139ca190227fe964dc3838ddb050be0a20c65202" translate="yes" xml:space="preserve">
          <source>Defined as 1 for use with Bool.</source>
          <target state="translated">Bool과 함께 사용하기 위해 1로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="670d6eec1e9ea50b484d7c17bdc447c52fe95496" translate="yes" xml:space="preserve">
          <source>Defined in &lt;code&gt;numpy/npy_cpu.h&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy/npy_cpu.h&lt;/code&gt; 에 정의</target>
        </trans-unit>
        <trans-unit id="8b1b72675b98643cbdd56a0a279d2ae2f68589c9" translate="yes" xml:space="preserve">
          <source>Defined in &lt;code&gt;numpy/npy_endian.h&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy/npy_endian.h&lt;/code&gt; 에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae2f517ddf51729b13e97790dfae1d103c049332" translate="yes" xml:space="preserve">
          <source>Defined to be the number of scalar kinds (not including &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">스칼라 종류의 수로 정의됩니다 ( &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; 제외&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="26a40d9f0ef7f2215f8cc29e1f71feface330732" translate="yes" xml:space="preserve">
          <source>Defined to be the number of scalar kinds (not including &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;).</source>
          <target state="translated">스칼라 종류의 수로 정의됩니다 ( &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; 제외 ).</target>
        </trans-unit>
        <trans-unit id="419f0d57760d81471942dc1e9c4afabcbd428557" translate="yes" xml:space="preserve">
          <source>Defined to be the number of sorts. It is fixed at three by the need for backwards compatibility, and consequently &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_STABLESORT&quot;&gt;&lt;code&gt;NPY_STABLESORT&lt;/code&gt;&lt;/a&gt; are aliased to each other and may refer to one of several stable sorting algorithms depending on the data type.</source>
          <target state="translated">정렬 수로 정의됩니다. 이전 버전과의 호환성을 위해 3 개로 고정되어 &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;#c.NPY_STABLESORT&quot;&gt; &lt;code&gt;NPY_STABLESORT&lt;/code&gt; &lt;/a&gt; 는 서로 별칭이 지정되며 데이터 유형에 따라 몇 가지 안정적인 정렬 알고리즘 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba198b982dcf4bd0cea8ecc26bd1efeae5fde285" translate="yes" xml:space="preserve">
          <source>Defined to be the number of sorts. It is fixed at three by the need for backwards compatibility, and consequently &lt;code&gt;NPY_MERGESORT&lt;/code&gt; and &lt;code&gt;NPY_STABLESORT&lt;/code&gt; are aliased to each other and may refer to one of several stable sorting algorithms depending on the data type.</source>
          <target state="translated">정렬 수로 정의되었습니다. 이전 버전과의 호환성 필요성으로 인해 3으로 고정되어 결과적으로 &lt;code&gt;NPY_MERGESORT&lt;/code&gt; 와 &lt;code&gt;NPY_STABLESORT&lt;/code&gt; 는 서로 별명을 가지며 데이터 유형에 따라 몇 가지 안정적인 정렬 알고리즘 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c2126c80b6518c66a9593fe462e64cc5a15f601" translate="yes" xml:space="preserve">
          <source>Defines</source>
          <target state="translated">Defines</target>
        </trans-unit>
        <trans-unit id="6e49bf7d4a54a21945d1908234ab12cc2626625b" translate="yes" xml:space="preserve">
          <source>Defining a more complex dtype.</source>
          <target state="translated">보다 복잡한 dtype 정의</target>
        </trans-unit>
        <trans-unit id="31dc26e67e64acb30e7c20573a8ab908e2d70bbd" translate="yes" xml:space="preserve">
          <source>Defining an &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt; is similar to defining a class in C++, but the object semantics have to be tracked manually since the API is in C. Here&amp;rsquo;s an example for a function which doubles up an element using an element copier function as a primitive.</source>
          <target state="translated">정의 &lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; 은&lt;/a&gt; C ++에서 클래스를 정의하는 것과 유사하지만, API가 여기 C.에있는 프리미티브 소자 복사기 기능을 이용하여 요소를 두배로하는 기능에 대한 예시 이후 개체 의미 수동으로 추적해야한다.</target>
        </trans-unit>
        <trans-unit id="45bcbf15eef8b7f89c50a8bf22d703e07ba3a825" translate="yes" xml:space="preserve">
          <source>Defining an &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt; is similar to defining a class in C++, but the object semantics have to be tracked manually since the API is in C. Here&amp;rsquo;s an example for a function which doubles up an element using an element copier function as a primitive.:</source>
          <target state="translated">정의 &lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; 하면&lt;/a&gt; ++ C의 클래스를 정의하는 것과 유사하지만, 물체 의미는 API 여기 C.에있는 프리미티브 소자 복사기 기능을 이용하여 요소를 두배로하는 기능에 대한 예시 이후 수동으로 추적 할 수있다 :</target>
        </trans-unit>
        <trans-unit id="eaf85480139ce8b3345d7674369f7104c63e0e8b" translate="yes" xml:space="preserve">
          <source>Defining functions</source>
          <target state="translated">기능 정의</target>
        </trans-unit>
        <trans-unit id="8834c54a1246a67dbc0ecb790c071b10a7e3b66b" translate="yes" xml:space="preserve">
          <source>Defining new types</source>
          <target state="translated">새로운 유형 정의</target>
        </trans-unit>
        <trans-unit id="acaae33599c6928fc236b87036acdea8fbc03839" translate="yes" xml:space="preserve">
          <source>Defining the input</source>
          <target state="translated">입력 정의</target>
        </trans-unit>
        <trans-unit id="adaa548fb9106ef1144d20b8ae04cecae72c8510" translate="yes" xml:space="preserve">
          <source>Definite integral as approximated by trapezoidal rule.</source>
          <target state="translated">사다리꼴 규칙에 의해 근사 된 명확한 적분.</target>
        </trans-unit>
        <trans-unit id="e2949d64dd44cf7b6657e31baa94fc61cf1ad44c" translate="yes" xml:space="preserve">
          <source>Definitely, yes. But the &lt;a href=&quot;#dispatchable-sources&quot;&gt;dispatch-able sources&lt;/a&gt; are treated differently.</source>
          <target state="translated">분명하게 예입니다. 그러나 &lt;a href=&quot;#dispatchable-sources&quot;&gt;디스패치 가능한 소스&lt;/a&gt; 는 다르게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="3332194d546c6c7cc86b5b84d7cd68baf0e623cb" translate="yes" xml:space="preserve">
          <source>Definition of the core elements a generalized ufunc operates on.</source>
          <target state="translated">일반화 된 ufunc가 작동하는 핵심 요소의 정의.</target>
        </trans-unit>
        <trans-unit id="15225baac48fc3d689cb2b0f74b936eff4339ff7" translate="yes" xml:space="preserve">
          <source>Definitions</source>
          <target state="translated">Definitions</target>
        </trans-unit>
        <trans-unit id="9184d3e4687563972d72b163e489c6c843a31654" translate="yes" xml:space="preserve">
          <source>Degree of the basis polynomial for the series. Must be &amp;gt;= 0.</source>
          <target state="translated">시리즈의 다항식의 차수입니다. &amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="16c78a8e8f95308316ca05a4c6f57586f7f58e4d" translate="yes" xml:space="preserve">
          <source>Degree of the fitting polynomial</source>
          <target state="translated">피팅 다항식의 차수</target>
        </trans-unit>
        <trans-unit id="ecef1da3fe83c50441aa06c22147e1dea28f0c9b" translate="yes" xml:space="preserve">
          <source>Degree of the interpolating polynomial</source>
          <target state="translated">보간 다항식의 정도</target>
        </trans-unit>
        <trans-unit id="b8722a2887db9363ae0b8c5a5c30ec99ff352e3d" translate="yes" xml:space="preserve">
          <source>Degree of the interpolating polynomial.</source>
          <target state="translated">보간 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="214ea8bba1ed183b7e097241368f077a3cd144a1" translate="yes" xml:space="preserve">
          <source>Degree of the resulting matrix.</source>
          <target state="translated">결과 행렬의 정도입니다.</target>
        </trans-unit>
        <trans-unit id="80d0e0a542e906c0db420181650b3b792573e76e" translate="yes" xml:space="preserve">
          <source>Degree of the series, one less than the number of coefficients.</source>
          <target state="translated">계수의 수보다 1이 적은 계열의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="a6aec0c27c1647ddafe05683c8d4b8074b12d8ab" translate="yes" xml:space="preserve">
          <source>Degree(s) of the fitting polynomials. If &lt;code&gt;deg&lt;/code&gt; is a single integer all terms up to and including the &lt;code&gt;deg&lt;/code&gt;&amp;rsquo;th term are included in the fit. For NumPy versions &amp;gt;= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead.</source>
          <target state="translated">피팅 다항식의 차수입니다. 경우 &lt;code&gt;deg&lt;/code&gt; 하나의 정수입니다 및 포함한 모든 용어 &lt;code&gt;deg&lt;/code&gt; '제 용어는 적합에 포함되어 있습니다. NumPy 버전&amp;gt; = 1.11.0의 경우, 포함 할 항의 정도를 지정하는 정수 목록이 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4678dad6fdcb23005370fe1fca044a896edcd5e9" translate="yes" xml:space="preserve">
          <source>Degree(s) of the fitting polynomials. If &lt;code&gt;deg&lt;/code&gt; is a single integer, all terms up to and including the &lt;code&gt;deg&lt;/code&gt;&amp;rsquo;th term are included in the fit. For NumPy versions &amp;gt;= 1.11.0 a list of integers specifying the degrees of the terms to include may be used instead.</source>
          <target state="translated">피팅 다항식의 차수입니다. 경우 &lt;code&gt;deg&lt;/code&gt; 하나의 정수의 및 포함한 모든 용어 &lt;code&gt;deg&lt;/code&gt; '제 용어는 적합에 포함되어 있습니다. NumPy 버전&amp;gt; = 1.11.0의 경우, 포함 할 항의 정도를 지정하는 정수 목록이 대신 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2de0696584be15bbb43013a1abc8390fb59e0b4c" translate="yes" xml:space="preserve">
          <source>Degrees of freedom in denominator, must be &amp;gt; 0.</source>
          <target state="translated">분모의 자유도는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="d447133a9630e193dc9b4895034fdb7a2d5656cf" translate="yes" xml:space="preserve">
          <source>Degrees of freedom in numerator, must be &amp;gt; 0.</source>
          <target state="translated">분자의 자유도는&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2fc860f3319e43352dfab21d263879520eed366e" translate="yes" xml:space="preserve">
          <source>Degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">자유도는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="12ab214df85e4910f7e4400eea924b9565854a9f" translate="yes" xml:space="preserve">
          <source>Delegate</source>
          <target state="translated">Delegate</target>
        </trans-unit>
        <trans-unit id="efdf5c52531831e38290d369a2fc1a1d6c2f3ab4" translate="yes" xml:space="preserve">
          <source>Delete elements from an array.</source>
          <target state="translated">배열에서 요소를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="09e1a4ac558262087ade7474a27905ea0753215f" translate="yes" xml:space="preserve">
          <source>Delete self[key].</source>
          <target state="translated">자체 [키]를 삭제하십시오.</target>
        </trans-unit>
        <trans-unit id="826d5fa4cd77081924ffa3247bc7e1144ad995c4" translate="yes" xml:space="preserve">
          <source>Delete the memmap instance to close the memmap file.</source>
          <target state="translated">memmap 인스턴스를 삭제하여 memmap 파일을 닫으십시오.</target>
        </trans-unit>
        <trans-unit id="306dd5805fe4440e89d904988e954764b20a3834" translate="yes" xml:space="preserve">
          <source>Deleting a branch on &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 에서 브랜치 삭제</target>
        </trans-unit>
        <trans-unit id="ea0fd59ff17f24ffbadfe6e0d10ec0a51da31f4d" translate="yes" xml:space="preserve">
          <source>Deleting a branch on github</source>
          <target state="translated">github에서 브랜치 삭제</target>
        </trans-unit>
        <trans-unit id="1b1ea38145f80e657023804a5a2fb9968cec7261" translate="yes" xml:space="preserve">
          <source>Deletion flushes memory changes to disk before removing the object:</source>
          <target state="translated">삭제는 객체를 제거하기 전에 메모리 변경 사항을 디스크로 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="51de9c21719e1ebba2842f93455553ec20fd0114" translate="yes" xml:space="preserve">
          <source>Demonstrate how large values of non-centrality lead to a more symmetric distribution.</source>
          <target state="translated">비중 심의 큰 가치가 어떻게 더 대칭적인 분포로 이어지는 지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="c9afd5880fd0526ff9d73beb159ef27c30006c77" translate="yes" xml:space="preserve">
          <source>Demonstrate that taking the products of random samples from a uniform distribution can be fit well by a log-normal probability density function.</source>
          <target state="translated">균일 분포에서 랜덤 표본의 곱을 얻는 것이 로그 정규 확률 밀도 함수에 잘 맞는다는 것을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="7d7f05c3b413d3520059a47e99ca5537a68001e7" translate="yes" xml:space="preserve">
          <source>Denominator degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">분모의 자유도는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="ac772a011193bb984a652b0f5e9cfc8b6b3f2d87" translate="yes" xml:space="preserve">
          <source>Denominator. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">분모. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="a6d35ab78327ccc8143e058c2d052d12fd50168d" translate="yes" xml:space="preserve">
          <source>Depending on a particular situation, these steps can be carried out either by just in one command or step-by-step, some steps can be omitted or combined with others.</source>
          <target state="translated">특정 상황에 따라 이러한 단계는 하나의 명령으로 또는 단계별로 수행 할 수 있으며 일부 단계는 생략하거나 다른 단계와 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6afb75d92a8931b02a2738d385c5788774cce5b" translate="yes" xml:space="preserve">
          <source>Deprecate &lt;code&gt;PyArray_As1D&lt;/code&gt;, &lt;code&gt;PyArray_As2D&lt;/code&gt;</source>
          <target state="translated">비추천 &lt;code&gt;PyArray_As1D&lt;/code&gt; , &lt;code&gt;PyArray_As2D&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8177b7926d93631dfd44d657ba9e8e543611652c" translate="yes" xml:space="preserve">
          <source>Deprecate &lt;code&gt;np.alen&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.alen&lt;/code&gt; 사용 중단</target>
        </trans-unit>
        <trans-unit id="94bea58e36ea97a89f697055be06b02616bb6d29" translate="yes" xml:space="preserve">
          <source>Deprecate &lt;code&gt;numpy.distutils.exec_command&lt;/code&gt; and &lt;code&gt;temp_file_name&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils.exec_command&lt;/code&gt; 및 &lt;code&gt;temp_file_name&lt;/code&gt; 사용 중단</target>
        </trans-unit>
        <trans-unit id="e3d5c3226aeab842ac4342585e0eb153350d8fe9" translate="yes" xml:space="preserve">
          <source>Deprecate automatic &lt;code&gt;dtype=object&lt;/code&gt; for ragged input</source>
          <target state="translated">비정형 입력에 대해 자동 &lt;code&gt;dtype=object&lt;/code&gt; 사용 중지</target>
        </trans-unit>
        <trans-unit id="0e5f70a8079e6d84db2bee2ad6acdd2ae8fcdc60" translate="yes" xml:space="preserve">
          <source>Deprecate non-scalar arrays as fill values in &lt;code&gt;ma.fill_value&lt;/code&gt;</source>
          <target state="translated">비 스칼라 배열을 &lt;code&gt;ma.fill_value&lt;/code&gt; 의 채우기 값으로 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="70f8102d92a47e6f4e71c89d9fe6ee5a92104784" translate="yes" xml:space="preserve">
          <source>Deprecate the financial functions</source>
          <target state="translated">재무 기능을 더 이상 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb2c49fdd1b05e605a38f9115e56f66a3514e081" translate="yes" xml:space="preserve">
          <source>Deprecate views changing dimensions in fortran order</source>
          <target state="translated">포트란 순서로 차원을 변경하는 뷰 사용 중지</target>
        </trans-unit>
        <trans-unit id="35ee1fa50278c527aa6abc0d9e07608c509c3bdd" translate="yes" xml:space="preserve">
          <source>Deprecated features</source>
          <target state="translated">더 이상 사용되지 않는 기능</target>
        </trans-unit>
        <trans-unit id="b42515ab1d65352ed70392656cd1eb8f0df21091" translate="yes" xml:space="preserve">
          <source>Deprecated in 1.14, use &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; followed by &lt;code&gt;Py_XDECREF&lt;/code&gt;</source>
          <target state="translated">1.14에서 더 이상 사용되지 &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 와 Py_XDECREF를 차례로 사용 &lt;code&gt;Py_XDECREF&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75510f16f2c885973d68ca6976d07c5d06c5ddae" translate="yes" xml:space="preserve">
          <source>Deprecated in numpy 1.9.0, use the abstract ABCPolyBase class instead. Note that the latter requires a number of virtual functions to be implemented.</source>
          <target state="translated">numpy 1.9.0에서 사용되지 않으므로 대신 추상 ABCPolyBase 클래스를 사용하십시오. 후자는 여러 가지 가상 기능을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="90fbb082fd2714c0f36df6a60a4e4c93fb36448f" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.10.0.</source>
          <target state="translated">버전 1.10.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a505e56c3c318c866f582620a893576d41513eec" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.11.0.</source>
          <target state="translated">버전 1.11.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5bc11ab8238bab2b746c4aca2228903684569fa4" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.11.0: NumPy does not store timezone information. For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. This behaviour is deprecated and will raise an error in the future.</source>
          <target state="translated">버전 1.11.0부터 폐지 : NumPy는 시간대 정보를 저장하지 않습니다. 이전 버전과의 호환성을 위해 datetime64는 여전히 UTC로 변환하여 처리하는 시간대 오프셋을 구문 분석합니다. 이 동작은 더 이상 사용되지 않으며 향후 오류가 발생할 것입니다.</target>
        </trans-unit>
        <trans-unit id="94443fd2ced7d37ea3bb33b7fb41ae4c59135a80" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.12.0.</source>
          <target state="translated">버전 1.12.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1bb047c7fb6232a7717b280821f8be5014a745a8" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.13.0: Passing an axis where &lt;code&gt;axis &amp;gt; a.ndim&lt;/code&gt; will be treated as &lt;code&gt;axis == a.ndim&lt;/code&gt;, and passing &lt;code&gt;axis &amp;lt; -a.ndim - 1&lt;/code&gt; will be treated as &lt;code&gt;axis == 0&lt;/code&gt;. This behavior is deprecated.</source>
          <target state="translated">버전 1.13.0부터 사용되지 않음 : &lt;code&gt;axis &amp;gt; a.ndim&lt;/code&gt; 은 &lt;code&gt;axis == a.ndim&lt;/code&gt; 으로 처리되고 &lt;code&gt;axis &amp;lt; -a.ndim - 1&lt;/code&gt; 전달 하면 &lt;code&gt;axis == 0&lt;/code&gt; 으로 처리됩니다 . 이 동작은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3e9f850b19cb0642d327e07d7c89d5cd333bf85e" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.13.0: This function is identical to both:</source>
          <target state="translated">버전 1.13.0부터 폐지 :이 기능은 다음 두 가지 모두에 동일합니다.</target>
        </trans-unit>
        <trans-unit id="a9a59ff61f9445930ed15b411b507cb3a3190092" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.14.0.</source>
          <target state="translated">버전 1.14.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="229727d5d807915b35e3a79a88f55c01627e95f0" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.14: Passing &lt;code&gt;sep=''&lt;/code&gt;, the default, is deprecated since it will trigger the deprecated binary mode of this function. This mode interprets &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; as binary bytes, rather than ASCII text with decimal numbers, an operation which is better spelt &lt;code&gt;frombuffer(string, dtype, count)&lt;/code&gt;. If &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt;&lt;code&gt;string&lt;/code&gt;&lt;/a&gt; contains unicode text, the binary mode of &lt;a href=&quot;#numpy.fromstring&quot;&gt;&lt;code&gt;fromstring&lt;/code&gt;&lt;/a&gt; will first encode it into bytes using either utf-8 (python 3) or the default encoding (python 2), neither of which produce sane results.</source>
          <target state="translated">버전 1.14부터 사용되지 않음 : 기본값 인 &lt;code&gt;sep=''&lt;/code&gt; 를 전달하면 이 기능의 더 이상 사용되지 않는 이진 모드가 트리거되므로 더 이상 사용되지 않습니다. 이 모드 해석의 &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 이진 바이트로보다는 진수와 ASCII 텍스트, 더 나은 철자가 작동 &lt;code&gt;frombuffer(string, dtype, count)&lt;/code&gt; . &lt;a href=&quot;https://docs.python.org/dev/library/string.html#module-string&quot;&gt; &lt;code&gt;string&lt;/code&gt; &lt;/a&gt; 에 유니 코드 텍스트가 포함 된 경우 &lt;a href=&quot;#numpy.fromstring&quot;&gt; &lt;code&gt;fromstring&lt;/code&gt; &lt;/a&gt; 의 이진 모드 는 먼저 utf-8 (python 3) 또는 기본 인코딩 (python 2)을 사용하여 바이트로 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="254b720f5d2de6ea47b5e7eea6d4191eea0f3a39" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.15.0: In order to remain backward compatible with a common usage in Numeric, basic slicing is also initiated if the selection object is any non-ndarray and non-tuple sequence (such as a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;) containing &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; objects, the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; object, or the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object, but not for integer arrays or other embedded sequences.</source>
          <target state="translated">버전 1.15.0부터 사용되지 않음 : Numeric의 일반적인 사용과 역 호환성을 유지하기 위해 선택 객체가 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; 객체를 포함 하는 비 ndarray 및 비 튜플 시퀀스 (예 : &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; ) 인 경우 기본 슬라이스도 시작됩니다 . &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt; 객체 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체이지만 정수 배열이나 기타 포함 된 시퀀스에는 해당되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dca5b7419ce0c6a33ee759ad9e3594c329bce938" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.15.0: In order to remain backward compatible with a common usage in Numeric, basic slicing is also initiated if the selection object is any non-ndarray and non-tuple sequence (such as a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt;&lt;code&gt;list&lt;/code&gt;&lt;/a&gt;) containing &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; objects, the &lt;code&gt;Ellipsis&lt;/code&gt; object, or the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object, but not for integer arrays or other embedded sequences.</source>
          <target state="translated">버전 1.15.0부터 더 이상 사용되지 않음 : Numeric의 일반적인 사용법과 역 호환성을 유지하기 위해 선택 객체가 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; 객체를 포함 하는 비 ndarray 및 튜플이 아닌 시퀀스 (예 : &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#list&quot;&gt; &lt;code&gt;list&lt;/code&gt; &lt;/a&gt; ) 인 경우 기본 슬라이싱이 시작됩니다 . &lt;code&gt;Ellipsis&lt;/code&gt; 객체 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체이지만 정수 배열이나 다른 포함 된 시퀀스에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c18d46be05f158f4a9f48a23fcafd55bc8ee7952" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.16.</source>
          <target state="translated">버전 1.16부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6151f894a8e79cde423047d76e0abe9518b5d32" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.16: Deprecated, use &lt;code&gt;numpy.ndarray.item()&lt;/code&gt; instead.</source>
          <target state="translated">버전 1.16부터 사용되지 않음 : 사용되지 &lt;code&gt;numpy.ndarray.item()&lt;/code&gt; 대신 numpy.ndarray.item ()을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="53a12f447546998241b2c017df7ea038ab3665ab" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.17.0: Use &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">버전 1.17.0부터 폐지 : 의도적 인 동작 인 경우 &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; 를&lt;/a&gt; 명시 적으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b1b432849522b830c89f225ee338a9c7471a40a6" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.17.0: Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">버전 1.17.0부터 폐지 : 의도적 인 동작 인 경우 &lt;code&gt;atleast1d&lt;/code&gt; 를 명시 적으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f3fc485c4dc97b2ed8df47cb88214775178f80c1" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.17: The output is currently marked so that if written to, a deprecation warning will be emitted. A future version will set the &lt;code&gt;writable&lt;/code&gt; flag False so writing to it will raise an error.</source>
          <target state="translated">버전 1.17부터 더 이상 사용되지 않음 : 출력이 현재 표시되어 있으므로 쓰면 더 이상 사용되지 않음 경고가 표시됩니다. 이후 버전에서는 &lt;code&gt;writable&lt;/code&gt; 플래그를 False로 설정 하므로 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ebb895521198bf56dee5e321bf357df5fd4f6567" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.17: The use of this function will give a deprecation warning when &lt;code&gt;np.clip&lt;/code&gt;. Instead of this function, the datatype must instead use &lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt; to attach a custom loop to &lt;code&gt;np.core.umath.clip&lt;/code&gt;, &lt;code&gt;np.minimum&lt;/code&gt;, and &lt;code&gt;np.maximum&lt;/code&gt;.</source>
          <target state="translated">버전 1.17부터 폐지 :이 함수를 사용하면 &lt;code&gt;np.clip&lt;/code&gt; 일 때 폐지 경고가 표시됩니다 . 이 함수 대신 데이터 유형은 &lt;code&gt;PyUFunc_RegisterLoopForDescr&lt;/code&gt; 을 사용 하여 &lt;code&gt;np.core.umath.clip&lt;/code&gt; , &lt;code&gt;np.minimum&lt;/code&gt; 및 &lt;code&gt;np.maximum&lt;/code&gt; 에 사용자 정의 루프를 연결 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="de338e92c60a533166acb2812b8ac73bb6d4ce78" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#r56c3181b2753-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 폐지 : &lt;a href=&quot;#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; &lt;/a&gt; 는 폐지되었습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#r56c3181b2753-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b0facf806618dd79f85bcdfeb96b483a5d2c790b" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.ipmt&quot;&gt;&lt;code&gt;ipmt&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#r9c688a8cd90c-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 사용되지 않음 : &lt;a href=&quot;#numpy.ipmt&quot;&gt; &lt;code&gt;ipmt&lt;/code&gt; &lt;/a&gt; 는 사용되지 않습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#r9c688a8cd90c-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4af74ad1a42c5d78e705e877eeba1d13bc87a139" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.irr&quot;&gt;&lt;code&gt;irr&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#r709af50a60b2-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 사용되지 않음 : &lt;a href=&quot;#numpy.irr&quot;&gt; &lt;code&gt;irr&lt;/code&gt; &lt;/a&gt; 은 사용되지 않습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#r709af50a60b2-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="0e4a2e363c99818a9d13f0eaca950d1e5f129ea3" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.mirr&quot;&gt;&lt;code&gt;mirr&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#r456242a4ac51-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 사용되지 않음 : &lt;a href=&quot;#numpy.mirr&quot;&gt; &lt;code&gt;mirr&lt;/code&gt; &lt;/a&gt; 은 사용되지 않습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#r456242a4ac51-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9ae7d182c78d7880b97e071dd6c3f008c4703089" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.nper&quot;&gt;&lt;code&gt;nper&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#rc337c54a0685-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 폐지 : &lt;a href=&quot;#numpy.nper&quot;&gt; &lt;code&gt;nper&lt;/code&gt; &lt;/a&gt; 는 폐지되었습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#rc337c54a0685-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="722102ac0d93195875d5a48a6e6edb2b1334e60b" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.npv&quot;&gt;&lt;code&gt;npv&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#r3b2e08cf0480-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 폐지 : &lt;a href=&quot;#numpy.npv&quot;&gt; &lt;code&gt;npv&lt;/code&gt; &lt;/a&gt; 는 폐지되었습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#r3b2e08cf0480-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="9918e27cf21398356907f3c61a98f70daaa8ccca" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.pmt&quot;&gt;&lt;code&gt;pmt&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#rc2d922c8f780-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 사용되지 않음 : &lt;a href=&quot;#numpy.pmt&quot;&gt; &lt;code&gt;pmt&lt;/code&gt; &lt;/a&gt; 는 사용되지 않습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#rc2d922c8f780-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b61351ebc9c58fc245830a01ec935ce81776e389" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.ppmt&quot;&gt;&lt;code&gt;ppmt&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#rf57421fde8a5-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 사용되지 않음 : &lt;a href=&quot;#numpy.ppmt&quot;&gt; &lt;code&gt;ppmt&lt;/code&gt; &lt;/a&gt; 는 사용되지 않습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#rf57421fde8a5-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f58ebc3967f75da2ad4ad9a201aa5b95f732c23" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.pv&quot;&gt;&lt;code&gt;pv&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#r4dbb32670290-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 폐지 : &lt;a href=&quot;#numpy.pv&quot;&gt; &lt;code&gt;pv&lt;/code&gt; &lt;/a&gt; 는 폐지되었습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#r4dbb32670290-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="09696b345dc5d41ad6107a69e8f093f3ef6fbf60" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.18: &lt;a href=&quot;#numpy.rate&quot;&gt;&lt;code&gt;rate&lt;/code&gt;&lt;/a&gt; is deprecated; for details, see NEP 32 &lt;a href=&quot;#ra039f4b61da9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. Use the corresponding function in the numpy-financial library, &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial&lt;/a&gt;.</source>
          <target state="translated">버전 1.18부터 사용되지 않음 : &lt;a href=&quot;#numpy.rate&quot;&gt; &lt;code&gt;rate&lt;/code&gt; &lt;/a&gt; 는 사용되지 않습니다. 자세한 내용은 NEP 32 &lt;a href=&quot;#ra039f4b61da9-1&quot; id=&quot;id1&quot;&gt;[1]을&lt;/a&gt; 참조하십시오 . numpy-financial 라이브러리 ( &lt;a href=&quot;https://pypi.org/project/numpy-financial&quot;&gt;https://pypi.org/project/numpy-financial)&lt;/a&gt; 에서 해당 함수를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="977fd468425793cfbf8f772dae2496ad7d3fe053" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.19.0.</source>
          <target state="translated">버전 1.19.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ca6eb95578bdc7772094de6e91491645e79982f1" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.19: Setting this function is deprecated and should always be &lt;code&gt;NULL&lt;/code&gt;, if set, it will be ignored.</source>
          <target state="translated">버전 1.19부터 사용되지 않음 :이 함수 설정은 사용되지 않으며 항상 &lt;code&gt;NULL&lt;/code&gt; 이어야합니다. 설정하면 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="7a62a176c5b82fc14ce52a29253feecbcdf22787" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.19: This conversion of generic scalar types is deprecated. This is because it can be unexpected in a context such as &lt;code&gt;arr.astype(dtype=np.floating)&lt;/code&gt;, which casts an array of &lt;code&gt;float32&lt;/code&gt; to an array of &lt;code&gt;float64&lt;/code&gt;, even though &lt;code&gt;float32&lt;/code&gt; is a subdtype of &lt;code&gt;np.floating&lt;/code&gt;.</source>
          <target state="translated">버전 1.19부터 폐지 : 제네릭 스칼라 유형의이 변환은 폐지되었습니다. 이 같은 상황에서 예기치 할 수 있기 때문이다 &lt;code&gt;arr.astype(dtype=np.floating)&lt;/code&gt; 의 배열 캐스트 &lt;code&gt;float32&lt;/code&gt; 를 배열로 &lt;code&gt;float64&lt;/code&gt; 에도 &lt;code&gt;float32&lt;/code&gt; 가 의 subdtype이다 &lt;code&gt;np.floating&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="314d12c664f4004462d50664105a8e88d3219703" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.20.</source>
          <target state="translated">버전 1.20부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="06d71d3c841517925322769f09c81a0249035aee" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.20.0: This method has been advised against since numpy 1.8.0, but only started emitting DeprecationWarning as of this version.</source>
          <target state="translated">버전 1.20.0부터 사용되지 않음 :이 메서드는 numpy 1.8.0부터 권장되지 않았지만이 버전부터는 DeprecationWarning 만 생성하기 시작했습니다.</target>
        </trans-unit>
        <trans-unit id="871a87675de9c0d00da31af92c0c92451a1f9c73" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.20: The native libraries on macOS, provided by Accelerate, are not fit for use in NumPy since they have bugs that cause wrong output under easily reproducible conditions. If the vendor fixes those bugs, the library could be reinstated, but until then users compiling for themselves should use another linear algebra library or use the built-in (but slower) default, see the next section.</source>
          <target state="translated">버전 1.20부터 더 이상 사용되지 않음 : Accelerate에서 제공하는 macOS의 네이티브 라이브러리는 쉽게 재현 가능한 조건에서 잘못된 출력을 유발하는 버그가 있기 때문에 NumPy에서 사용하기에 적합하지 않습니다. 공급 업체가 이러한 버그를 수정하면 라이브러리를 복원 할 수 있지만, 그때까지 스스로 컴파일하는 사용자는 다른 선형 대수 라이브러리를 사용하거나 내장 (그러나 더 느린) 기본값을 사용해야합니다. 다음 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="26689b58bf759fcfedfe480ee292230f1eae7e85" translate="yes" xml:space="preserve">
          <source>Deprecated since version 1.6.0.</source>
          <target state="translated">버전 1.6.0부터 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="856a55e66a97bf5d240b17c1887aa296c5dc656c" translate="yes" xml:space="preserve">
          <source>Deprecated since version NumPy: 1.19</source>
          <target state="translated">버전 NumPy : 1.19부터 사용되지 않음</target>
        </trans-unit>
        <trans-unit id="b5ebd48a05d1197ffab8d82861190636acfcb48f" translate="yes" xml:space="preserve">
          <source>Deprecated. Use &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, which is similar. This flag &amp;ldquo;automatically&amp;rdquo; copies the data back when the returned array is deallocated, which is not supported in all python implementations.</source>
          <target state="translated">더 이상 사용되지 않습니다. &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 이 플래그는 &quot;자동으로&quot;반환 된 배열의 할당이 해제 될 때 데이터를 다시 복사합니다. 이는 모든 파이썬 구현에서 지원되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="141e039b9533a98c94309e5719dbf35ad8e170ab" translate="yes" xml:space="preserve">
          <source>Deprecated: use npy_clear_floatstatus from npy_math.h instead.</source>
          <target state="translated">더 이상 사용되지 않음 : 대신 npy_math.h에서 npy_clear_floatstatus를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5cf6f463ce56314bce23e2b79281c112c8d5ef7b" translate="yes" xml:space="preserve">
          <source>Deprecation Mechanism NPY_NO_DEPRECATED_API</source>
          <target state="translated">지원 중단 메커니즘 NPY_NO_DEPRECATED_API</target>
        </trans-unit>
        <trans-unit id="523433b4e3be28518ef09e47b52bf1385f6004e0" translate="yes" xml:space="preserve">
          <source>Deprecation of &lt;code&gt;numpy.dual&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.dual&lt;/code&gt; 의 지원 중단</target>
        </trans-unit>
        <trans-unit id="e805018e013c9abe7c09d3afc5c0fe507af41dc4" translate="yes" xml:space="preserve">
          <source>Deprecation of &lt;code&gt;round&lt;/code&gt; for &lt;code&gt;np.complexfloating&lt;/code&gt; scalars</source>
          <target state="translated">&lt;code&gt;np.complexfloating&lt;/code&gt; 스칼라에 대한 &lt;code&gt;round&lt;/code&gt; 사용 중단</target>
        </trans-unit>
        <trans-unit id="ec478f0c20f4040dee40fd9f3880a3597cbd5e18" translate="yes" xml:space="preserve">
          <source>Deprecation of probably unused C-API functions</source>
          <target state="translated">사용하지 않을 가능성이있는 C-API 기능의 지원 중단</target>
        </trans-unit>
        <trans-unit id="25762dd86ec1779e02b0d1ae6a317b370da8e560" translate="yes" xml:space="preserve">
          <source>DeprecationWarning to error</source>
          <target state="translated">DeprecationWarning to error</target>
        </trans-unit>
        <trans-unit id="34730e9bbd5c0ba7b7655973316eed44e39da85f" translate="yes" xml:space="preserve">
          <source>Deprecations</source>
          <target state="translated">Deprecations</target>
        </trans-unit>
        <trans-unit id="3df6d2fd6e8a67d3f249d430871341dc61199132" translate="yes" xml:space="preserve">
          <source>Describes a block of memory comprised of blocks, each block comprised of items and of the same size, and blocks are interpreted in exactly the same way. In the simplest case each block contains a single item, for instance int32 or float64.</source>
          <target state="translated">블록으로 구성된 메모리 블록을 설명합니다. 각 블록은 항목으로 구성되고 크기가 같으며 블록은 정확히 동일한 방식으로 해석됩니다. 가장 간단한 경우 각 블록에는 단일 항목 (예 : int32 또는 float64)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="6735a66773b194a7ae390d1ca4d06ddff66cb19d" translate="yes" xml:space="preserve">
          <source>Describes partition algorithms used.</source>
          <target state="translated">사용 된 파티션 알고리즘을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a4cf5c2fa78a781f3bab283524a5720dd26e5a08" translate="yes" xml:space="preserve">
          <source>Describes sorting algorithms used.</source>
          <target state="translated">사용되는 정렬 알고리즘을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="555c5d2cb07e18fc50ac305ad3849cdbe6160644" translate="yes" xml:space="preserve">
          <source>Describes whether or not &lt;code&gt;a&lt;/code&gt; can be written to.</source>
          <target state="translated">여부를 설명 &lt;code&gt;a&lt;/code&gt; 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="424441bbf87af33c47ad0cfb1f7fa3b9fa63955e" translate="yes" xml:space="preserve">
          <source>Describes whether or not &lt;code&gt;a&lt;/code&gt; is a copy of another &amp;ldquo;base&amp;rdquo; array.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 다른&amp;ldquo;기본&amp;rdquo;배열의 사본 인지 여부를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="65d8e7f90a58b5a5ee1060f1f22a86aed35beae6" translate="yes" xml:space="preserve">
          <source>Describes whether or not &lt;code&gt;a&lt;/code&gt; is aligned properly for its type.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 해당 유형에 맞게 정렬되었는지 여부를 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="370912d49663d282a37e14e8000dff571b91bc07" translate="yes" xml:space="preserve">
          <source>Describing the motivation for a change, the nature of a bug for bug fixes or some details on what an enhancement does are also good to include in a commit message. Messages should be understandable without looking at the code changes. A commit message like &lt;code&gt;MAINT: fixed another one&lt;/code&gt; is an example of what not to do; the reader has to go look for context elsewhere.</source>
          <target state="translated">변경 동기, 버그 수정을위한 버그의 특성 또는 향상 기능에 대한 세부 사항을 설명하는 것도 커밋 메시지에 포함하는 것이 좋습니다. 코드 변경 사항을 보지 않고도 메시지를 이해할 수 있어야합니다. &lt;code&gt;MAINT: fixed another one&lt;/code&gt; 와 같은 커밋 메시지 : fixed another one은하지 말아야 할 일의 예입니다. 독자는 다른 곳에서 문맥을 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="346e1a6ea2950aed7aedfa2b36e8e6dcfe2508d1" translate="yes" xml:space="preserve">
          <source>Description of the function arguments, keywords and their respective types.</source>
          <target state="translated">함수 인수, 키워드 및 해당 유형에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="3fcfa113d41636118b9fc7438de0f310d710e2cc" translate="yes" xml:space="preserve">
          <source>Description of the input data type code.</source>
          <target state="translated">입력 데이터 유형 코드에 대한 설명입니다.</target>
        </trans-unit>
        <trans-unit id="9829bed50f31ac25ea870651c23dc5ce8171f8e6" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result, either &amp;lsquo;d&amp;rsquo; (or &amp;lsquo;float64&amp;rsquo;) or &amp;lsquo;f&amp;rsquo; (or &amp;lsquo;float32&amp;rsquo;). All dtypes are determined by their name. The default value is &amp;lsquo;d&amp;rsquo;.</source>
          <target state="translated">결과의 원하는 dtype은 'd'(또는 'float64') 또는 'f'(또는 'float32')입니다. 모든 dtype은 이름으로 결정됩니다. 기본값은 'd'입니다.</target>
        </trans-unit>
        <trans-unit id="7da0ba9d34fd31c21d910aeeeed817873a288b07" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result, only &lt;a href=&quot;../../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; are supported. Byteorder must be native. The default value is np.float64.</source>
          <target state="translated">원하는 결과 dtype, &lt;a href=&quot;../../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../../arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; &lt;/a&gt; 만 지원됩니다. Byteorder는 기본이어야합니다. 기본값은 np.float64입니다.</target>
        </trans-unit>
        <trans-unit id="4dc0eca98857c96ea05d2834018645b78499602c" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result, only &lt;code&gt;float64&lt;/code&gt; and &lt;code&gt;float32&lt;/code&gt; are supported. Byteorder must be native. The default value is np.float64.</source>
          <target state="translated">원하는 결과 dtype, &lt;code&gt;float64&lt;/code&gt; 및 &lt;code&gt;float32&lt;/code&gt; 만 지원됩니다. Byteorder는 기본이어야합니다. 기본값은 np.float64입니다.</target>
        </trans-unit>
        <trans-unit id="f21ac6e26595def622d7f71a3b4db5b0d1d28b7c" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result. All dtypes are determined by their name, i.e., &amp;lsquo;int64&amp;rsquo;, &amp;lsquo;int&amp;rsquo;, etc, so byteorder is not available and a specific precision may have different C types depending on the platform. The default value is &amp;lsquo;np.int&amp;rsquo;.</source>
          <target state="translated">결과의 원하는 dtype입니다. 모든 dtype은 이름, 즉 'int64', 'int'등으로 결정되므로 바이트 순서를 사용할 수 없으며 플랫폼에 따라 특정 정밀도에 따라 C 유형이 다를 수 있습니다. 기본값은 'np.int'입니다.</target>
        </trans-unit>
        <trans-unit id="d558894b92f0819c442ffa7437422acfcded32d4" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result. Byteorder must be native. The default value is int.</source>
          <target state="translated">결과의 원하는 dtype입니다. Byteorder는 기본이어야합니다. 기본값은 int입니다.</target>
        </trans-unit>
        <trans-unit id="d86ba271286804fcc7fe2ef7c09a18afae0481f4" translate="yes" xml:space="preserve">
          <source>Desired dtype of the result. Byteorder must be native. The default value is np.int64.</source>
          <target state="translated">결과의 원하는 dtype입니다. Byteorder는 기본이어야합니다. 기본값은 np.int64입니다.</target>
        </trans-unit>
        <trans-unit id="74c71a3f63e1f8004c0601e8b1482c6cd79e69b7" translate="yes" xml:space="preserve">
          <source>Desired output data-type for the array, e.g, &lt;a href=&quot;../arrays.scalars#numpy.int8&quot;&gt;&lt;code&gt;numpy.int8&lt;/code&gt;&lt;/a&gt;. Default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;numpy.float64&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에 대해 원하는 출력 데이터 유형 (예 : &lt;a href=&quot;../arrays.scalars#numpy.int8&quot;&gt; &lt;code&gt;numpy.int8&lt;/code&gt; )&lt;/a&gt; . 기본값은 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;numpy.float64&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d121e78f3074bde690535b07325dfb836a0267ba" translate="yes" xml:space="preserve">
          <source>Desired output data-type for the array, e.g, &lt;code&gt;numpy.int8&lt;/code&gt;. Default is &lt;code&gt;numpy.float64&lt;/code&gt;.</source>
          <target state="translated">배열에 원하는 출력 데이터 유형입니다 (예 : &lt;code&gt;numpy.int8&lt;/code&gt; ) . 기본값은 &lt;code&gt;numpy.float64&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1b152ee224a01e68e60fe4dbd7092f5aa497fbc8" translate="yes" xml:space="preserve">
          <source>Desired output data-type.</source>
          <target state="translated">원하는 출력 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="d92d689242f2299b4475be6532f6b4c69b49753f" translate="yes" xml:space="preserve">
          <source>Desired precision, default is 6.</source>
          <target state="translated">원하는 정밀도, 기본값은 6입니다.</target>
        </trans-unit>
        <trans-unit id="57f388f8b04810bebe2800d826bdcb39eda4bd12" translate="yes" xml:space="preserve">
          <source>Desired precision, default is 7.</source>
          <target state="translated">원하는 정밀도, 기본값은 7입니다.</target>
        </trans-unit>
        <trans-unit id="a6a71856ceab1e7196aa2dbfeeb1fbad499209f5" translate="yes" xml:space="preserve">
          <source>Despite its name, it returns &lt;code&gt;bytes&lt;/code&gt; not &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;s.</source>
          <target state="translated">이름에도 불구하고 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; s가 아닌 &lt;code&gt;bytes&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="bca53b020cb8963bff96b2ef13263bbd6169b5e5" translate="yes" xml:space="preserve">
          <source>Despite its name, it returns &lt;code&gt;bytes&lt;/code&gt; not &lt;code&gt;str&lt;/code&gt;s.</source>
          <target state="translated">이름에도 불구하고 &lt;code&gt;str&lt;/code&gt; s가 아닌 &lt;code&gt;bytes&lt;/code&gt; 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="cde9d9b4e0b9af3dfaaddd342aedc25e93ab8375" translate="yes" xml:space="preserve">
          <source>Destination array.</source>
          <target state="translated">대상 배열.</target>
        </trans-unit>
        <trans-unit id="e7808a0714f80da97918a2e4274a40d30bcdd7a7" translate="yes" xml:space="preserve">
          <source>Destination positions for each of the original axes. These must also be unique.</source>
          <target state="translated">각 원래 축의 대상 위치입니다. 이것 또한 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="99fb38702fe48e541fee073291f16ca2b81c9e3c" translate="yes" xml:space="preserve">
          <source>Detailed docstrings for scalar numeric types</source>
          <target state="translated">스칼라 숫자 유형에 대한 자세한 독 스트링</target>
        </trans-unit>
        <trans-unit id="21ef51d75c614a51c95b2672f954fdc6c7fae2d1" translate="yes" xml:space="preserve">
          <source>Detailed notes</source>
          <target state="translated">자세한 메모</target>
        </trans-unit>
        <trans-unit id="7d40f5113e5a0be345c6e8da2b15397b86e772db" translate="yes" xml:space="preserve">
          <source>Details of Signature</source>
          <target state="translated">서명 내용</target>
        </trans-unit>
        <trans-unit id="600eeccd7db308f4a989eda843209f6bc5c9f6d7" translate="yes" xml:space="preserve">
          <source>Determinant of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 결정 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="706fbd5a75b61eb7b1941f3576619d3b0a2e0ad0" translate="yes" xml:space="preserve">
          <source>Determine an appropriate data-type object from the object &lt;em&gt;op&lt;/em&gt; (which should be a &amp;ldquo;nested&amp;rdquo; sequence object) and the minimum data-type descriptor mintype (which can be &lt;code&gt;NULL&lt;/code&gt; ). Similar in behavior to array(&lt;em&gt;op&lt;/em&gt;).dtype. Don&amp;rsquo;t confuse this function with &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt;. This function essentially looks at all the objects in the (nested) sequence and determines the data-type from the elements it finds.</source>
          <target state="translated">객체 &lt;em&gt;op&lt;/em&gt; ( &quot;중첩 된&quot;시퀀스 객체 여야 함)와 최소 데이터 유형 설명자 최소 유형 ​​( &lt;code&gt;NULL&lt;/code&gt; 일 수 있음 ) 에서 적절한 데이터 유형 객체를 결정합니다 . array ( &lt;em&gt;op&lt;/em&gt; ) .dtype과 유사합니다. 이 함수를 &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt; 와 혼동하지 마십시오 . 이 함수는 기본적으로 (중첩) 시퀀스의 모든 객체를보고 찾은 요소에서 데이터 유형을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="898483c19901b499900035a5195202d8244c4b8f" translate="yes" xml:space="preserve">
          <source>Determine common type following standard coercion rules.</source>
          <target state="translated">표준 강제 규칙에 따라 공통 유형을 결정하십시오.</target>
        </trans-unit>
        <trans-unit id="f493f90604c24e63ef3589f15cfb3213ad17edc7" translate="yes" xml:space="preserve">
          <source>Determine if &lt;em&gt;newstrides&lt;/em&gt; is a strides array consistent with the memory of an &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape &lt;code&gt;dims&lt;/code&gt; and element-size, &lt;em&gt;elsize&lt;/em&gt;. The &lt;em&gt;newstrides&lt;/em&gt; array is checked to see if jumping by the provided number of bytes in each direction will ever mean jumping more than &lt;em&gt;numbytes&lt;/em&gt; which is the assumed size of the available memory segment. If &lt;em&gt;numbytes&lt;/em&gt; is 0, then an equivalent &lt;em&gt;numbytes&lt;/em&gt; is computed assuming &lt;em&gt;nd&lt;/em&gt;, &lt;em&gt;dims&lt;/em&gt;, and &lt;em&gt;elsize&lt;/em&gt; refer to a single-segment array. Return &lt;a href=&quot;#c.NPY_TRUE&quot;&gt;&lt;code&gt;NPY_TRUE&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;newstrides&lt;/em&gt; is acceptable, otherwise return &lt;a href=&quot;#c.NPY_FALSE&quot;&gt;&lt;code&gt;NPY_FALSE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">만약 결정 &lt;em&gt;newstrides가&lt;/em&gt; 의 메모리 일관성 자선 배열이다 &lt;em&gt;ND&lt;/em&gt; 모양과 차원 배열 &lt;code&gt;dims&lt;/code&gt; 및 소자 크기 &lt;em&gt;elsize&lt;/em&gt; . &lt;em&gt;newstrides의&lt;/em&gt; 배열을 참조 할 것 선택하면 적 평균 점프보다 각 방향으로 제공되는 바이트 수만큼 점프 &lt;em&gt;하는 numBytes&lt;/em&gt; 가능한 메모리 세그먼트의 가정 된 크기이다. 한다면 &lt;em&gt;하는 numBytes이&lt;/em&gt; 0이고, 다음 상응 &lt;em&gt;하는 numBytes는&lt;/em&gt; 가정하에 계산 &lt;em&gt;ND&lt;/em&gt; , &lt;em&gt;희미&lt;/em&gt; 하고 &lt;em&gt;elsize은&lt;/em&gt; 단일 세그먼트 배열을 참조. &lt;a href=&quot;#c.NPY_TRUE&quot;&gt; &lt;code&gt;NPY_TRUE&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;NPY_TRUE를&lt;/em&gt; 반환 합니다 &lt;em&gt;.&lt;/em&gt;허용되는 경우, 그렇지 않으면 &lt;a href=&quot;#c.NPY_FALSE&quot;&gt; &lt;code&gt;NPY_FALSE&lt;/code&gt; 를&lt;/a&gt; 리턴 하십시오 .</target>
        </trans-unit>
        <trans-unit id="da40e84ab5bf1317a201c92d2f871ba0d2269134" translate="yes" xml:space="preserve">
          <source>Determine if a class is a subclass of a second class.</source>
          <target state="translated">클래스가 두 번째 클래스의 서브 클래스인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="497b024471b22505be0452cda6ffd1b787cf7f0a" translate="yes" xml:space="preserve">
          <source>Determine if the first argument is a subclass of the second argument.</source>
          <target state="translated">첫 번째 인수가 두 번째 인수의 서브 클래스인지 판별하십시오.</target>
        </trans-unit>
        <trans-unit id="e06c23b59abd9e583829ad68cbb8b3a58d4c4624" translate="yes" xml:space="preserve">
          <source>Determine if two arrays might share memory</source>
          <target state="translated">두 배열이 메모리를 공유 할 수 있는지 확인</target>
        </trans-unit>
        <trans-unit id="13f31601af111fc0a9613647f0e8d82f16d06a6c" translate="yes" xml:space="preserve">
          <source>Determine if two arrays share memory</source>
          <target state="translated">두 어레이가 메모리를 공유하는지 확인</target>
        </trans-unit>
        <trans-unit id="5d37eec65368e1615ae79a8f04af1a04a9dce477" translate="yes" xml:space="preserve">
          <source>Determine if two arrays share memory.</source>
          <target state="translated">두 어레이가 메모리를 공유하는지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="e963055554340fe23a99591f987fa19e05129866" translate="yes" xml:space="preserve">
          <source>Determine language value (c,f77,f90) from sources</source>
          <target state="translated">소스에서 언어 값 (c, f77, f90) 결정</target>
        </trans-unit>
        <trans-unit id="4fb1ffd013fbdd2899c42f65451c7410c495fa36" translate="yes" xml:space="preserve">
          <source>Determine whether input has masked values.</source>
          <target state="translated">입력 값에 마스크 값이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6da721475fcf2ac096aa56aec4327be0c131e55d" translate="yes" xml:space="preserve">
          <source>Determines the data-type of the returned array and of the accumulator where the elements are summed. If dtype has the value None and &lt;code&gt;a&lt;/code&gt; is of integer type of precision less than the default integer precision, then the default integer precision is used. Otherwise, the precision is the same as that of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">반환 된 배열 및 요소가 합산되는 누산기의 데이터 유형을 결정합니다. dtype에 None 값이 있고 &lt;code&gt;a&lt;/code&gt; 가 기본 정수 정밀도보다 작은 정수 유형의 정밀도 인 경우 기본 정수 정밀도가 사용됩니다. 그렇지 않으면 정밀도는의 정밀도와 동일 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0165b0ce28795b6a5c6c8a8e2bfad91d293d9b" translate="yes" xml:space="preserve">
          <source>Determines whether the array data should be viewed as in C (row-major) or FORTRAN (column-major) order.</source>
          <target state="translated">배열 데이터를 C (행 주요) 또는 FORTRAN (열 주요) 순서로 볼지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="62fef4817f86a662507fdd128bbc1b9cb8b3cd5a" translate="yes" xml:space="preserve">
          <source>Determines whether the given object represents a scalar data-type.</source>
          <target state="translated">주어진 객체가 스칼라 데이터 유형을 나타내는 지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="5f0e0492ec52021d3c5b8cdeeb35e0f95d3b1d72" translate="yes" xml:space="preserve">
          <source>Determines whether the indices should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.</source>
          <target state="translated">인덱스를 행 주요 (C 스타일) 또는 열 주요 (Fortran 스타일) 순서로 색인으로 볼지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="d8ccfefbbecb3816295b6b2447f684f6ceabb4bd" translate="yes" xml:space="preserve">
          <source>Determines whether the multi-index should be viewed as indexing in row-major (C-style) or column-major (Fortran-style) order.</source>
          <target state="translated">다중 인덱스를 행 주요 (C 스타일) 또는 열 주요 (Fortran 스타일) 순서로 인덱싱으로 볼지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7f3f11f5478a9e233c7c8cac100e2bfaec97f4b5" translate="yes" xml:space="preserve">
          <source>DevOps</source>
          <target state="translated">DevOps</target>
        </trans-unit>
        <trans-unit id="128d929e44ba67ff5c30b4087fdf313afa8ae540" translate="yes" xml:space="preserve">
          <source>Develop your contribution:</source>
          <target state="translated">기여도를 개발하십시오 :</target>
        </trans-unit>
        <trans-unit id="a48344532f1ee1fb98c3e511cc3d116bd18dc22b" translate="yes" xml:space="preserve">
          <source>Developing educational content &amp;amp; narrative documentation</source>
          <target state="translated">교육 콘텐츠 및 내러티브 문서 개발</target>
        </trans-unit>
        <trans-unit id="5b5a45feb873f8385f593977b660a4aeb8784691" translate="yes" xml:space="preserve">
          <source>Developing with git can be done entirely without github. Git is a distributed version control system. In order to use git on your machine you must &lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;install it&lt;/a&gt;.</source>
          <target state="translated">git로 개발하는 것은 github 없이도 완전히 수행 할 수 있습니다. Git은 분산 버전 제어 시스템입니다. 컴퓨터에서 git을 사용하려면이를 &lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;설치해야합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="87f796a86183612ba7edf694c5e9beb87d144d37" translate="yes" xml:space="preserve">
          <source>Development Setup</source>
          <target state="translated">개발 설정</target>
        </trans-unit>
        <trans-unit id="61783f8920477bd8cb8a05baf07e3ed366e8715d" translate="yes" xml:space="preserve">
          <source>Development process - details</source>
          <target state="translated">개발 프로세스-세부 사항</target>
        </trans-unit>
        <trans-unit id="502db4c9cee083b4aedd4680eb9c9eeb3fff329b" translate="yes" xml:space="preserve">
          <source>Development process - summary</source>
          <target state="translated">개발 프로세스-요약</target>
        </trans-unit>
        <trans-unit id="66e7dd4c526a5148a42bbca5f07010c8a652ad99" translate="yes" xml:space="preserve">
          <source>Development versions (no git hash available): &amp;lsquo;1.8.0.dev-Unknown&amp;rsquo;</source>
          <target state="translated">개발 버전 (사용 가능한 git 해시 없음) : '1.8.0.dev-Unknown'</target>
        </trans-unit>
        <trans-unit id="d0fdf3b26f9c530f928d171827b0d01a3adcb222" translate="yes" xml:space="preserve">
          <source>Development versions after a1: &amp;lsquo;1.8.0a1.dev-f1234afa&amp;rsquo;,</source>
          <target state="translated">a1 이후 개발 버전 : '1.8.0a1.dev-f1234afa',</target>
        </trans-unit>
        <trans-unit id="5fcf12e6d8e4b52c92d8112af85cd4e8de564860" translate="yes" xml:space="preserve">
          <source>Development versions: &amp;lsquo;1.8.0.dev-f1234afa&amp;rsquo; (git commit hash appended)</source>
          <target state="translated">개발 버전 : '1.8.0.dev-f1234afa'(git commit hash가 추가됨)</target>
        </trans-unit>
        <trans-unit id="4020adf902ce73aabcac806e3e7ff49d1c01db16" translate="yes" xml:space="preserve">
          <source>Development workflow</source>
          <target state="translated">개발 워크 플로우</target>
        </trans-unit>
        <trans-unit id="d19b6f0aed2ffef1a60727277d49ba4b00c0e3f0" translate="yes" xml:space="preserve">
          <source>Device to write message. If None, defaults to &lt;code&gt;sys.stdout&lt;/code&gt; which is very similar to &lt;code&gt;print&lt;/code&gt;. &lt;code&gt;device&lt;/code&gt; needs to have &lt;code&gt;write()&lt;/code&gt; and &lt;code&gt;flush()&lt;/code&gt; methods.</source>
          <target state="translated">메시지를 작성할 장치입니다. None이면 &lt;code&gt;print&lt;/code&gt; 와 매우 유사한 &lt;code&gt;sys.stdout&lt;/code&gt; 이 기본값 입니다. &lt;code&gt;device&lt;/code&gt; 에는 &lt;code&gt;write()&lt;/code&gt; 및 &lt;code&gt;flush()&lt;/code&gt; 메서드 가 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="2587e018673361fa809647d0df3794abbf90b626" translate="yes" xml:space="preserve">
          <source>Diagnosing machine parameters.</source>
          <target state="translated">기계 매개 변수 진단.</target>
        </trans-unit>
        <trans-unit id="571a1b4f25ce9e3bf2b1d858d49e854688780a04" translate="yes" xml:space="preserve">
          <source>Diagonal above which to zero elements. &lt;code&gt;k = 0&lt;/code&gt; (the default) is the main diagonal, &lt;code&gt;k &amp;lt; 0&lt;/code&gt; is below it and &lt;code&gt;k &amp;gt; 0&lt;/code&gt; is above.</source>
          <target state="translated">요소 위의 대각선. &lt;code&gt;k = 0&lt;/code&gt; (기본값)이 주 대각선이고, &lt;code&gt;k &amp;lt; 0&lt;/code&gt; 이 그 아래에 있고 &lt;code&gt;k &amp;gt; 0&lt;/code&gt; 이 위에 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0a04846111a5b5b030af15b7f8b50b6b2d862e0" translate="yes" xml:space="preserve">
          <source>Diagonal covariance (&lt;a href=&quot;../../generated/numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;cov&lt;/code&gt;&lt;/a&gt; has non-negative elements, and only on the diagonal)</source>
          <target state="translated">대각선 공분산 ( &lt;a href=&quot;../../generated/numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;cov&lt;/code&gt; &lt;/a&gt; 에는 음이 아닌 요소가 있으며 대각선에만 있음)</target>
        </trans-unit>
        <trans-unit id="55837b5795b6970f83dccf9cc6ed178e395491c1" translate="yes" xml:space="preserve">
          <source>Diagonal covariance (&lt;code&gt;cov&lt;/code&gt; has non-negative elements, and only on the diagonal)</source>
          <target state="translated">대각선 공분산 ( &lt;code&gt;cov&lt;/code&gt; 는 음이 아닌 요소를 가지며 대각선에만 있음)</target>
        </trans-unit>
        <trans-unit id="997674fd629a0b4695b89afdafe7066dd8688712" translate="yes" xml:space="preserve">
          <source>Diagonal covariance means that points are oriented along x or y-axis:</source>
          <target state="translated">대각선 공분산은 점이 x 또는 y 축을 따라 정렬됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8b13398d28ad559216c01627144dceb31c001c77" translate="yes" xml:space="preserve">
          <source>Diagonal in question. The default is 0. Use &lt;code&gt;k&amp;gt;0&lt;/code&gt; for diagonals above the main diagonal, and &lt;code&gt;k&amp;lt;0&lt;/code&gt; for diagonals below the main diagonal.</source>
          <target state="translated">문제의 대각선. 기본은 0입니다 . 주 대각선 위의 대각선 에는 &lt;code&gt;k&amp;gt;0&lt;/code&gt; 을 사용 하고 주 대각선 아래의 대각선에는 &lt;code&gt;k&amp;lt;0&lt;/code&gt; 을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="2272a7d3ef4499c2fba3286512459f06b9b8c4bb" translate="yes" xml:space="preserve">
          <source>Diagonal offset (see &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="translated">대각선 오프셋 (자세한 내용은 &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="bdb7019564c135f875fc4c3e6f917c80e9b077c0" translate="yes" xml:space="preserve">
          <source>Diagonal offset (see &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; for details).</source>
          <target state="translated">대각선 오프셋 (자세한 내용은 &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="03d8dd8b377b7d9a317ab567d850a967ff187884" translate="yes" xml:space="preserve">
          <source>Diagonal to set; 0, the default, corresponds to the &amp;ldquo;main&amp;rdquo; diagonal, a positive (negative) &lt;code&gt;k&lt;/code&gt; giving the number of the diagonal above (below) the main.</source>
          <target state="translated">설정할 대각선; 기본값 인 0은 &quot;메인&quot;대각선에 해당하며 양 (음수) &lt;code&gt;k&lt;/code&gt; 는 메인 위 (아래)의 대각선 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="01b9cc7bface7de40b225d1e08bfd9974c80817b" translate="yes" xml:space="preserve">
          <source>Dictionary containing the information required to describe the state of the PRNG</source>
          <target state="translated">PRNG의 상태를 설명하는 데 필요한 정보가 포함 된 사전</target>
        </trans-unit>
        <trans-unit id="465ece096e63883c4adc1473d9e883a01beef81f" translate="yes" xml:space="preserve">
          <source>Dictionary containing the old settings.</source>
          <target state="translated">이전 설정이 포함 된 사전입니다.</target>
        </trans-unit>
        <trans-unit id="238865dee85fc7a720df3db4fb92252c7e4d3acf" translate="yes" xml:space="preserve">
          <source>Dictionary mapping field names to the corresponding default values.</source>
          <target state="translated">필드 이름을 해당 기본값에 매핑하는 사전입니다.</target>
        </trans-unit>
        <trans-unit id="e39dc1ed92c57f800777e71abed1d83e5faca236" translate="yes" xml:space="preserve">
          <source>Dictionary mapping old field names to their new version.</source>
          <target state="translated">이전 필드 이름을 새 버전으로 매핑하는 사전.</target>
        </trans-unit>
        <trans-unit id="a302338cc77d36ca6ca6a444397d206bd6ba38d8" translate="yes" xml:space="preserve">
          <source>Dictionary of current print options with keys</source>
          <target state="translated">키가있는 현재 인쇄 옵션 사전</target>
        </trans-unit>
        <trans-unit id="9e2413069148ff06bfc90db576c632870eaad55e" translate="yes" xml:space="preserve">
          <source>Dictionary of named fields defined for this data type, or &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">이 데이터 유형 또는 정의라는 이름의 필드의 사전 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6015961218e2af6fe8520645bc2f02289c93438a" translate="yes" xml:space="preserve">
          <source>Dictionary of parent fields (used interbally during recursion).</source>
          <target state="translated">부모 필드의 사전 (재귀 동안 상호 사용됨).</target>
        </trans-unit>
        <trans-unit id="b18fcf6662ee91bcc267021a433a9c47b4716fe9" translate="yes" xml:space="preserve">
          <source>Difference (subtraction) of two polynomials.</source>
          <target state="translated">두 다항식의 차이 (빼기).</target>
        </trans-unit>
        <trans-unit id="825117b1f5072a690e7d5d35fccadef88b068aef" translate="yes" xml:space="preserve">
          <source>Difference between sequence and scalars:</source>
          <target state="translated">시퀀스와 스칼라의 차이점 :</target>
        </trans-unit>
        <trans-unit id="44ae6a3aab38641659dd21a2dd5a0126482da74d" translate="yes" xml:space="preserve">
          <source>Differences Between 1.6 and 1.7 Datetimes</source>
          <target state="translated">1.6과 1.7 날짜 / 시간의 차이</target>
        </trans-unit>
        <trans-unit id="837053a1ed40de495a5f88f03bf0ca2af5b9f49e" translate="yes" xml:space="preserve">
          <source>Differences from the runtime NumPy API</source>
          <target state="translated">런타임 NumPy API와의 차이점</target>
        </trans-unit>
        <trans-unit id="b75fd672a5cf256c07308370a04454e14a79f629" translate="yes" xml:space="preserve">
          <source>Differences with Array interface (Version 2)</source>
          <target state="translated">어레이 인터페이스 (버전 2)와의 차이점</target>
        </trans-unit>
        <trans-unit id="4300cd91f693489c6a5674ec8ec61a6dee25b189" translate="yes" xml:space="preserve">
          <source>Different &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; can share the same data, so that changes made in one &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; may be visible in another. That is, an ndarray can be a &lt;em&gt;&amp;ldquo;view&amp;rdquo;&lt;/em&gt; to another ndarray, and the data it is referring to is taken care of by the &lt;em&gt;&amp;ldquo;base&amp;rdquo;&lt;/em&gt; ndarray. ndarrays can also be views to memory owned by Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;strings&lt;/code&gt;&lt;/a&gt; or objects implementing the &lt;code&gt;buffer&lt;/code&gt; or &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;array&lt;/a&gt; interfaces.</source>
          <target state="translated">다른 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 는 동일한 데이터를 공유 할 수 있으므로 한 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 의&lt;/a&gt; 변경 사항이 다른 ndarray 에서 볼 수 있습니다. 즉, ndarray는 다른 ndarray에 대한 &lt;em&gt;&quot;보기&quot;&lt;/em&gt; 가 될 수 있으며 참조하는 데이터는 &lt;em&gt;&quot;기본&quot;&lt;/em&gt; ndarray 에 의해 처리됩니다. ndarray는 Python &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;strings&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;buffer&lt;/code&gt; 또는 &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;배열&lt;/a&gt; 인터페이스를 구현하는 객체가 소유 한 메모리에 대한 뷰일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d317c26cbc42ec5b9f720e139bd4e510372cd697" translate="yes" xml:space="preserve">
          <source>Different C numeric types of the same size have unique names</source>
          <target state="translated">같은 크기의 다른 C 숫자 유형은 고유 한 이름을가집니다.</target>
        </trans-unit>
        <trans-unit id="98865245deb6202007caff9ab4fef64fa9b26b3d" translate="yes" xml:space="preserve">
          <source>Different array objects can share the same data. The &lt;code&gt;view&lt;/code&gt; method creates a new array object that looks at the same data.</source>
          <target state="translated">다른 배열 객체는 동일한 데이터를 공유 할 수 있습니다. &lt;code&gt;view&lt;/code&gt; 방법은 새로운 어레이 오브젝트를 생성하는 것과 동일한 데이터를 보인다.</target>
        </trans-unit>
        <trans-unit id="2d1293c185e75af6d69f6c98a33e894acc7589c9" translate="yes" xml:space="preserve">
          <source>Differentiate a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="8d839ccd2dfc63fbf3d7f72d0c5a816686c1455a" translate="yes" xml:space="preserve">
          <source>Differentiate a Hermite series.</source>
          <target state="translated">은자 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="350467ef2f75b4100fac9eb332f8dbf9310f3098" translate="yes" xml:space="preserve">
          <source>Differentiate a Hermite_e series.</source>
          <target state="translated">Hermite_e 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="7ecd2cf570222711a1cc1ae4380637a814f82362" translate="yes" xml:space="preserve">
          <source>Differentiate a Laguerre series.</source>
          <target state="translated">Laguerre 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="320f56f9077471825e8d1549eab31dc00557c694" translate="yes" xml:space="preserve">
          <source>Differentiate a Legendre series.</source>
          <target state="translated">Legendre 시리즈를 차별화하십시오.</target>
        </trans-unit>
        <trans-unit id="7bfc33e1228b29a88933a8f29aae49636b3414cf" translate="yes" xml:space="preserve">
          <source>Differentiate a polynomial.</source>
          <target state="translated">다항식을 미분하십시오.</target>
        </trans-unit>
        <trans-unit id="844fa0e757902457e0da48c9d9d537e645b1a135" translate="yes" xml:space="preserve">
          <source>Differentiate.</source>
          <target state="translated">Differentiate.</target>
        </trans-unit>
        <trans-unit id="5fbe5e498b5af2c25aac251fb6bb0a2c7a4ee208" translate="yes" xml:space="preserve">
          <source>Dimension Index</source>
          <target state="translated">차원 색인</target>
        </trans-unit>
        <trans-unit id="604ffcf9d27fb4fb0162fdca0045216d08973bc5" translate="yes" xml:space="preserve">
          <source>Dimension Name</source>
          <target state="translated">차원 이름</target>
        </trans-unit>
        <trans-unit id="16b40f0ccd35ed9bc1f597c1b6ca359ab12da9c4" translate="yes" xml:space="preserve">
          <source>Dimension indices in a flattened form; indices of argument &lt;code&gt;k&lt;/code&gt; are stored in &lt;code&gt;core_dim_ixs[core_offsets[k] : core_offsets[k] +
core_numdims[k]]&lt;/code&gt;</source>
          <target state="translated">평평한 형태의 치수 지수; 인수 &lt;code&gt;k&lt;/code&gt; 의 인덱스는 &lt;code&gt;core_dim_ixs[core_offsets[k] : core_offsets[k] + core_numdims[k]]&lt;/code&gt; 저장됩니다 : core_offsets [k] + core_numdims [k]]</target>
        </trans-unit>
        <trans-unit id="4720f96f0dc9b13a80d3150f6ee99efe7a2bf618" translate="yes" xml:space="preserve">
          <source>Dimension lists for different arguments are separated by &lt;code&gt;&quot;,&quot;&lt;/code&gt;. Input/output arguments are separated by &lt;code&gt;&quot;-&amp;gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">다른 인수에 대한 차원 목록은 &lt;code&gt;&quot;,&quot;&lt;/code&gt; 로 구분됩니다 . 입력 / 출력 인수는 &lt;code&gt;&quot;-&amp;gt;&quot;&lt;/code&gt; 로 구분됩니다 .</target>
        </trans-unit>
        <trans-unit id="cbdc09a108a501fba34d1f040bdcbaddec6ddd61" translate="yes" xml:space="preserve">
          <source>Dimensions of length 1 may be prepended to either array.</source>
          <target state="translated">길이 1의 차원은 두 어레이 중 하나에 추가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93f05beec2d11025891d4dbf607e42fff20564b8" translate="yes" xml:space="preserve">
          <source>Disabling ATLAS and other accelerated libraries</source>
          <target state="translated">ATLAS 및 기타 가속 라이브러리 비활성화</target>
        </trans-unit>
        <trans-unit id="37cc6b0f7bb3682386878d1b4327551ac2b2f9c6" translate="yes" xml:space="preserve">
          <source>Discrete Fourier Transform (&lt;code&gt;numpy.fft&lt;/code&gt;)</source>
          <target state="translated">이산 푸리에 변환 ( &lt;code&gt;numpy.fft&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0599eda60b4e9fea359c989e15306fa6ba42641a" translate="yes" xml:space="preserve">
          <source>Discrete Fourier Transform (numpy.fft)</source>
          <target state="translated">이산 푸리에 변환 (numpy.fft)</target>
        </trans-unit>
        <trans-unit id="7e09c6be62e60a24d79a9a2519a544283d5d6191" translate="yes" xml:space="preserve">
          <source>Discrete cross-correlation of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 이산 상호 상관 .</target>
        </trans-unit>
        <trans-unit id="e53e1928d52ad6e33b46c1b8035d3e51b89bc405" translate="yes" xml:space="preserve">
          <source>Discrete fourier transform</source>
          <target state="translated">이산 푸리에 변환</target>
        </trans-unit>
        <trans-unit id="d506f48e956cd0fc595f2d760c2568b2ecab8f30" translate="yes" xml:space="preserve">
          <source>Discrete uniform distribution over the closed interval &lt;code&gt;[low, high]&lt;/code&gt;.</source>
          <target state="translated">닫힌 간격에 대한 불연속 균일 분포 &lt;code&gt;[low, high]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581725b9ae0b1aa5fab3c6862adf5b089aedf3b7" translate="yes" xml:space="preserve">
          <source>Discrete uniform distribution, yielding integers.</source>
          <target state="translated">불연속 균일 분포로 정수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="e9cbd8c39929bc0b483e8db9cb22ad66356f9dd1" translate="yes" xml:space="preserve">
          <source>Discrete, linear convolution of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;v&lt;/code&gt; 의 불연속 선형 컨벌루션 .</target>
        </trans-unit>
        <trans-unit id="2f1bd27e525549ac4c15b3721fa99d1b05468878" translate="yes" xml:space="preserve">
          <source>Discrete, linear convolution of two one-dimensional sequences.</source>
          <target state="translated">두 개의 1 차원 시퀀스의 불연속 선형 컨벌루션.</target>
        </trans-unit>
        <trans-unit id="e6320bdc4929e4f52b900ddb94c8b699ecbe6801" translate="yes" xml:space="preserve">
          <source>Discrimination can be subtle and it can be unconscious. It can show itself as unfairness and hostility in otherwise ordinary interactions. We know that this does occur, and we will take care to look out for it. We would very much like to hear from you if you feel you have been treated unfairly, and we will use these procedures to make sure that your complaint is heard and addressed.</source>
          <target state="translated">차별은 미묘 할 수 있으며 무의식적 일 수 있습니다. 다른 평범한 상호 작용에서 불공평 함과 적대감으로 나타날 수 있습니다. 우리는 이런 일이 발생한다는 것을 알고 있으며주의 깊게 살펴볼 것입니다. 부당한 대우를 받았다고 느끼는 경우 귀하의 의견을 듣고 싶습니다. 저희는 이러한 절차를 사용하여 귀하의 불만을 듣고 해결하도록 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="425d34f08981e7c8f15089f1a9c0b595e1a23a35" translate="yes" xml:space="preserve">
          <source>Dispatch-able sources are special &lt;strong&gt;C&lt;/strong&gt; files that can be compiled multiple times with different compiler flags and also with different &lt;strong&gt;C&lt;/strong&gt; definitions. These affect code paths to enable certain instruction-sets for each compiled object according to &amp;ldquo;&lt;strong&gt;the configuration statements&lt;/strong&gt;&amp;rdquo; that must be declared between a &lt;strong&gt;C&lt;/strong&gt; comment&lt;code&gt;(/**/)&lt;/code&gt; and start with a special mark &lt;strong&gt;@targets&lt;/strong&gt; at the top of each dispatch-able source. At the same time, dispatch-able sources will be treated as normal &lt;strong&gt;C&lt;/strong&gt; sources if the optimization was disabled by the command argument &lt;code&gt;--disable-optimization&lt;/code&gt; .</source>
          <target state="translated">디스패치 가능 소스는 다른 컴파일러 플래그와 다른 &lt;strong&gt;C&lt;/strong&gt; 정의를 사용 하여 여러 번 컴파일 할 수있는 특수 &lt;strong&gt;C&lt;/strong&gt; 파일입니다 . 이는 &lt;strong&gt;C&lt;/strong&gt; 주석 &lt;code&gt;(/**/)&lt;/code&gt; 사이에 선언되어야 하고 각 디스패치의 상단에 특수 마크 &lt;strong&gt;@targets&lt;/strong&gt; 로 시작 해야하는 &quot; &lt;strong&gt;구성 명령문&lt;/strong&gt; &quot; 에 따라 컴파일 된 각 객체에 대한 특정 명령어 세트를 활성화하는 코드 경로에 영향을줍니다 &lt;strong&gt;.&lt;/strong&gt; 가능한 소스. 동시에 명령 인수 &lt;code&gt;--disable-optimization&lt;/code&gt; 으로 최적화가 비활성화 된 경우 디스패치 가능 소스는 일반 &lt;strong&gt;C&lt;/strong&gt; 소스 로 처리됩니다 .&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="48f91366c839e056a4dcd440512f99e82188c46a" translate="yes" xml:space="preserve">
          <source>Dispatcher</source>
          <target state="translated">Dispatcher</target>
        </trans-unit>
        <trans-unit id="820f5171bb026c33497c51bf6408edd94f4c7574" translate="yes" xml:space="preserve">
          <source>Dispersion of the distribution, has to be &amp;gt;=0.</source>
          <target state="translated">분포의 분산은&amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4d84e2496f66666155184bfa4fad0c59a39f67e0" translate="yes" xml:space="preserve">
          <source>Display a message on a device.</source>
          <target state="translated">장치에 메시지를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="b40bb754403d167b3c047ebbae91fd8d8cb0914f" translate="yes" xml:space="preserve">
          <source>Display histogram of the sample:</source>
          <target state="translated">샘플의 히스토그램을 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="188801f0d5b3d1b7349810d9fd7ff8a72e496879" translate="yes" xml:space="preserve">
          <source>Display results as a histogram:</source>
          <target state="translated">히스토그램으로 결과 표시 :</target>
        </trans-unit>
        <trans-unit id="8a9edcfc295cbbba0c31cafd95aee17d95c83756" translate="yes" xml:space="preserve">
          <source>Display the histogram of the samples, along with the probability density function:</source>
          <target state="translated">확률 밀도 함수와 함께 샘플의 히스토그램을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="1e318b4b3e84c3dbcd35ba51c8d38616480afa39" translate="yes" xml:space="preserve">
          <source>Display the order (the leading zero-coefficients are removed):</source>
          <target state="translated">순서를 표시합니다 (선행 0 계수 제거).</target>
        </trans-unit>
        <trans-unit id="73a33865dd016879cd21dfa8fd105859512d6d5a" translate="yes" xml:space="preserve">
          <source>Distance between 1 and the nearest floating point number.</source>
          <target state="translated">1과 가장 가까운 부동 소수점 숫자 사이의 거리입니다.</target>
        </trans-unit>
        <trans-unit id="1d3c457cbe3e35739086346e0a4048653efa42e7" translate="yes" xml:space="preserve">
          <source>Distribution</source>
          <target state="translated">Distribution</target>
        </trans-unit>
        <trans-unit id="1908a0e50cf9cf44d92392e9f5f89a3166d12095" translate="yes" xml:space="preserve">
          <source>Distribution mean, must be &amp;gt; 0.</source>
          <target state="translated">분포 평균은&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="955961355de913bb9e7fa3e948b32a11d7c7c64d" translate="yes" xml:space="preserve">
          <source>Distribution parameter. Must be greater than 1.</source>
          <target state="translated">분포 모수. 1보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="71fff5ea85661c16e7519843bc17a41ff8e91eb9" translate="yes" xml:space="preserve">
          <source>Distributions</source>
          <target state="translated">Distributions</target>
        </trans-unit>
        <trans-unit id="72f2ae7feddc980201ec6ebbd694c4946a24da30" translate="yes" xml:space="preserve">
          <source>Dive into the CPU dispatcher</source>
          <target state="translated">CPU 디스패처 살펴보기</target>
        </trans-unit>
        <trans-unit id="e7bf168f4e2cefa6f42a3fb7b922464be193fe57" translate="yes" xml:space="preserve">
          <source>Divergence between &lt;code&gt;upstream/master&lt;/code&gt; and your feature branch</source>
          <target state="translated">&lt;code&gt;upstream/master&lt;/code&gt; 와 기능 브랜치 간의 차이</target>
        </trans-unit>
        <trans-unit id="3e0529b57b9e8a87d594e4db130981ead9c297bb" translate="yes" xml:space="preserve">
          <source>Diversity Statement</source>
          <target state="translated">다양성 선언문</target>
        </trans-unit>
        <trans-unit id="8b193321a119fbd0dcd684bd2d9426886ca75352" translate="yes" xml:space="preserve">
          <source>Divide one Chebyshev series by another.</source>
          <target state="translated">한 체비 쇼프 시리즈를 다른 것으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="143efc24501a0aca7c9b8146445d3052ccca2768" translate="yes" xml:space="preserve">
          <source>Divide one Hermite series by another.</source>
          <target state="translated">Hermite 시리즈를 다른 것으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="59969920d0ad8492606516de2799361ab80e51e4" translate="yes" xml:space="preserve">
          <source>Divide one Laguerre series by another.</source>
          <target state="translated">하나의 Laguerre 시리즈를 다른 시리즈로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="cb8fb14724e04e74acd5ed518b7956bde57f9f7f" translate="yes" xml:space="preserve">
          <source>Divide one Legendre series by another.</source>
          <target state="translated">하나의 Legendre 시리즈를 다른 시리즈로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="53b11bc9ec8586eecc94bbdfc2f103e8f1cdcb61" translate="yes" xml:space="preserve">
          <source>Divide one polynomial by another.</source>
          <target state="translated">하나의 다항식을 다른 다항식으로 나눕니다.</target>
        </trans-unit>
        <trans-unit id="c51ce5484f877f3b3126642a285f454856b1a199" translate="yes" xml:space="preserve">
          <source>Divide other into self, and return a new masked array.</source>
          <target state="translated">다른 것을 자기로 나누고 새로운 마스크 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="2ef1e5ad95321353adac46fbc8491e615e836d21" translate="yes" xml:space="preserve">
          <source>Divide self by other in-place.</source>
          <target state="translated">다른 곳으로 자기를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="1e3c651961978f36b837c449de83e63bcfcd74e0" translate="yes" xml:space="preserve">
          <source>Divide self into other, and return a new masked array.</source>
          <target state="translated">자기 자신을 다른 것으로 나누고 새로운 마스크 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="fdde9e15039c0cebf1238ec9b7a4737bb63abb02" translate="yes" xml:space="preserve">
          <source>Dividend array.</source>
          <target state="translated">배당 배열.</target>
        </trans-unit>
        <trans-unit id="94054a2bd282906d6045981a996c888ef4e4b84a" translate="yes" xml:space="preserve">
          <source>Dividend polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">배당 다항식의 계수.</target>
        </trans-unit>
        <trans-unit id="ae3d5366321b2cda8048303484a9efb3b8012809" translate="yes" xml:space="preserve">
          <source>Dividend.</source>
          <target state="translated">Dividend.</target>
        </trans-unit>
        <trans-unit id="3da76ff26283ccdfb95f22f35e70c08074f9c0d6" translate="yes" xml:space="preserve">
          <source>Division by zero: infinite result obtained from finite numbers.</source>
          <target state="translated">0으로 나누기 : 유한 숫자에서 얻은 무한 결과.</target>
        </trans-unit>
        <trans-unit id="5c970858ddd5ebfccc0979913547b40892ea84f0" translate="yes" xml:space="preserve">
          <source>Division:</source>
          <target state="translated">Division:</target>
        </trans-unit>
        <trans-unit id="e528cec9df846efb2d96080851febbb0ef5214b8" translate="yes" xml:space="preserve">
          <source>Divisor array. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">제수 배열. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="35ac85bf74de66241c9334431207aa5df69df721" translate="yes" xml:space="preserve">
          <source>Divisor polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">제수 다항식의 계수.</target>
        </trans-unit>
        <trans-unit id="a079e40a62a4209488cf119d0047ff12fb70cf71" translate="yes" xml:space="preserve">
          <source>Divisor. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">제수. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="1a536da5cd434d26e0ec447ec43ce448909aa6d1" translate="yes" xml:space="preserve">
          <source>Divmod:</source>
          <target state="translated">Divmod:</target>
        </trans-unit>
        <trans-unit id="45ce71204f92d6f8852c63ee93e7b51ac756d330" translate="yes" xml:space="preserve">
          <source>Do [not] lower the cases in &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt;. By default, &lt;code&gt;--lower&lt;/code&gt; is assumed with &lt;code&gt;-h&lt;/code&gt; switch, and &lt;code&gt;--no-lower&lt;/code&gt; without the &lt;code&gt;-h&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 에서 대소 문자를 줄이지 마십시오 . 기본적으로 &lt;code&gt;--lower&lt;/code&gt; 는 &lt;code&gt;-h&lt;/code&gt; 스위치 와 함께 사용 되며 &lt;code&gt;--no-lower&lt;/code&gt; 는 &lt;code&gt;-h&lt;/code&gt; 스위치 없이 가정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d78017db5e95583684a29d66eb903a8ce60aba4" translate="yes" xml:space="preserve">
          <source>Do a keyword search on docstrings.</source>
          <target state="translated">docstring에서 키워드 검색을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5093cfdeecbaad59b0032ada090cb03d7214ad89" translate="yes" xml:space="preserve">
          <source>Do any other changes. When you are ready to release, do the following changes:</source>
          <target state="translated">다른 변경을 수행하십시오. 릴리스 할 준비가되면 다음 변경을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="5ed0fbfa16e3c978333f6bb9479feb8cb786008c" translate="yes" xml:space="preserve">
          <source>Do any platform-specific customization of a compiler instance.</source>
          <target state="translated">컴파일러 인스턴스의 플랫폼 별 사용자 정의를 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="aa4f30d77ca9cffce5a730094491acaed21d0c15" translate="yes" xml:space="preserve">
          <source>Do not abbreviate &lt;code&gt;scipy&lt;/code&gt;. There is no motivating use case to abbreviate it in the real world, so we avoid it in the documentation to avoid confusion.</source>
          <target state="translated">&lt;code&gt;scipy&lt;/code&gt; 를 축약하지 마십시오 . 실제 세계에서는 축약 할 동기 부여 사용 사례가 없으므로 혼동을 피하기 위해 문서에서 사용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="69bea954d58a67db385bef3af18864d8842729f0" translate="yes" xml:space="preserve">
          <source>Do not let perfect be the enemy of the good, particularly for documentation. If you find yourself making many small suggestions, or being too nitpicky on style or grammar, consider merging the current PR when all important concerns are addressed. Then, either push a commit directly (if you are a maintainer) or open a follow-up PR yourself.</source>
          <target state="translated">완벽 함이 특히 문서화의 경우 선의 적이되도록 두지 마십시오. 작은 제안을 많이하거나 스타일이나 문법이 너무 간결하다고 생각되면 모든 중요한 문제가 해결 될 때 현재 PR을 병합하는 것을 고려하십시오. 그런 다음 커밋을 직접 푸시하거나 (관리자 인 경우) 직접 후속 PR을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="bbd5666b437c28187aec8798c5634c9e0657218d" translate="yes" xml:space="preserve">
          <source>Do not lookup &lt;code&gt;__buffer__&lt;/code&gt; attribute in &lt;code&gt;numpy.frombuffer&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__buffer__&lt;/code&gt; 에서 &lt;code&gt;numpy.frombuffer&lt;/code&gt; 속성을 조회하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ea9d279c47a9187c1db7b1f7b114b04d8f0172e5" translate="yes" xml:space="preserve">
          <source>Do not lose the type info if the sequence contains unknown objects.</source>
          <target state="translated">시퀀스에 알 수없는 객체가 포함 된 경우 유형 정보를 잃지 마십시오.</target>
        </trans-unit>
        <trans-unit id="753e558e0889bfe1b0b8ea64720e95bc5e2d003e" translate="yes" xml:space="preserve">
          <source>Do not make temporary copies for in-place accumulation</source>
          <target state="translated">내부 축적을 위해 임시 사본을 만들지 마십시오.</target>
        </trans-unit>
        <trans-unit id="37d435c090c5ec2cb12a71fd3a6a6e5087869ea8" translate="yes" xml:space="preserve">
          <source>Do not rely on the combination of &lt;code&gt;tofile&lt;/code&gt; and &lt;a href=&quot;#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt; for data storage, as the binary files generated are are not platform independent. In particular, no byte-order or data-type information is saved. Data can be stored in the platform independent &lt;code&gt;.npy&lt;/code&gt; format using &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">생성 된 이진 파일은 플랫폼 독립적이지 않기 때문에 데이터 저장을 위해 &lt;code&gt;tofile&lt;/code&gt; 과 &lt;a href=&quot;#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt; 의 조합에 의존하지 마십시오 . 특히 바이트 순서 또는 데이터 유형 정보는 저장되지 않습니다. &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;save&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 사용하여 플랫폼 독립적 인 &lt;code&gt;.npy&lt;/code&gt; 형식으로 데이터를 저장할 수 있습니다대신 를 .</target>
        </trans-unit>
        <trans-unit id="3c8f5a205e26b952d375f39fdb5421c127666dd7" translate="yes" xml:space="preserve">
          <source>Do not rely on the combination of &lt;code&gt;tofile&lt;/code&gt; and &lt;a href=&quot;#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt; for data storage, as the binary files generated are not platform independent. In particular, no byte-order or data-type information is saved. Data can be stored in the platform independent &lt;code&gt;.npy&lt;/code&gt; format using &lt;a href=&quot;numpy.save#numpy.save&quot;&gt;&lt;code&gt;save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">생성 된 바이너리 파일은 플랫폼에 독립적이지 않으므로 데이터 저장을 위해 &lt;code&gt;tofile&lt;/code&gt; 과 &lt;a href=&quot;#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt; 의 조합에 의존하지 마십시오 . 특히, 바이트 순서 또는 데이터 유형 정보는 저장되지 않습니다. 대신 &lt;a href=&quot;numpy.save#numpy.save&quot;&gt; &lt;code&gt;save&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 를 사용하여 데이터를 플랫폼 독립적 인 &lt;code&gt;.npy&lt;/code&gt; 형식으로 저장할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a3e1823cbbdfbb28b0abf8529520a9bf10c3f493" translate="yes" xml:space="preserve">
          <source>Do not use the Python keywords &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; to combine logical array expressions. These keywords will test the truth value of the entire array (not element-by-element as you might expect). Use the bitwise operators &amp;amp; and | instead.</source>
          <target state="translated">Python 키워드 &lt;code&gt;and&lt;/code&gt; / &lt;code&gt;or&lt;/code&gt; 논리 배열 표현식을 결합 하지 마십시오 . 이 키워드는 전체 배열의 실제 값을 테스트합니다 (예상대로 요소별로 아님). 비트 연산자 &amp;amp; 및 | 대신에.</target>
        </trans-unit>
        <trans-unit id="85f316156dde56fd422f702bfae89f5d01a4a0bd" translate="yes" xml:space="preserve">
          <source>Do this only for your own feature branches.</source>
          <target state="translated">고유 한 기능 브랜치에 대해서만이 작업을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2a35b8c3a828c6b50ebb9d495090ca5847cf7787" translate="yes" xml:space="preserve">
          <source>Do:</source>
          <target state="translated">Do:</target>
        </trans-unit>
        <trans-unit id="068e10d17a4f1e6b0314030af8daae7e135a1b46" translate="yes" xml:space="preserve">
          <source>Doc wiki</source>
          <target state="translated">문서 위키</target>
        </trans-unit>
        <trans-unit id="36c8ac7818e5614c3ac61ff4c43b3f1973d4e79a" translate="yes" xml:space="preserve">
          <source>Docstring Conventions</source>
          <target state="translated">독 스트링 규칙</target>
        </trans-unit>
        <trans-unit id="d28224752776e7c0254a76c36e65ec7c0fe81831" translate="yes" xml:space="preserve">
          <source>Docstring Processing Framework</source>
          <target state="translated">독 스트링 처리 프레임 워크</target>
        </trans-unit>
        <trans-unit id="70bb9e1dd74f67c945982b5b826ac5c41ebd16c8" translate="yes" xml:space="preserve">
          <source>Docstring Standard</source>
          <target state="translated">독 스트링 표준</target>
        </trans-unit>
        <trans-unit id="4f9095933912561f96f6400b90f6ef8100c5b8bc" translate="yes" xml:space="preserve">
          <source>Docstrings</source>
          <target state="translated">Docstrings</target>
        </trans-unit>
        <trans-unit id="166cd3bae5954cb6c42019231169856ee7b0313c" translate="yes" xml:space="preserve">
          <source>Docstrings for constants will not be visible in text terminals (constants are of immutable type, so docstrings can not be assigned to them like for for class instances), but will appear in the documentation built with Sphinx.</source>
          <target state="translated">상수에 대한 독 스트링은 텍스트 터미널에 표시되지 않지만 (상수는 변경 불가능한 유형이므로 클래스 인스턴스의 경우처럼 독 스트링을 할당 할 수 없습니다) Sphinx로 빌드 된 문서에 나타납니다.</target>
        </trans-unit>
        <trans-unit id="5e01c221d853296d84e769113c74b2df4ca129d1" translate="yes" xml:space="preserve">
          <source>Doctests</source>
          <target state="translated">Doctests</target>
        </trans-unit>
        <trans-unit id="974974af4b7655224f60ff495507eedae4f6994e" translate="yes" xml:space="preserve">
          <source>Doctests are a convenient way of documenting the behavior of a function and allowing that behavior to be tested at the same time. The output of an interactive Python session can be included in the docstring of a function, and the test framework can run the example and compare the actual output to the expected output.</source>
          <target state="translated">Doctest는 함수의 동작을 문서화하고 그 동작을 동시에 테스트 할 수있는 편리한 방법입니다. 대화 형 Python 세션의 출력은 함수의 docstring에 포함될 수 있으며 테스트 프레임 워크는 예제를 실행하고 실제 출력을 예상 출력과 비교할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f82082d9447e427b76298b58ef65d29e97146b17" translate="yes" xml:space="preserve">
          <source>Document changes</source>
          <target state="translated">문서 변경</target>
        </trans-unit>
        <trans-unit id="b04a22b66d493e28558760326ada34075924f9ee" translate="yes" xml:space="preserve">
          <source>Document conventions</source>
          <target state="translated">문서 규칙</target>
        </trans-unit>
        <trans-unit id="02a65528400a16184e36f721be3f5d8abfcc2982" translate="yes" xml:space="preserve">
          <source>Document history</source>
          <target state="translated">문서 기록</target>
        </trans-unit>
        <trans-unit id="20294552e8cd0d5904c98b6f704516d3b16d0084" translate="yes" xml:space="preserve">
          <source>Document these as you would any other function. Do not include &lt;code&gt;self&lt;/code&gt; in the list of parameters. If a method has an equivalent function (which is the case for many ndarray methods for example), the function docstring should contain the detailed documentation, and the method docstring should refer to it. Only put brief summary and &lt;strong&gt;See Also&lt;/strong&gt; sections in the method docstring. The method should use a &lt;strong&gt;Returns&lt;/strong&gt; or &lt;strong&gt;Yields&lt;/strong&gt; section, as appropriate.</source>
          <target state="translated">다른 기능과 마찬가지로 문서화하십시오. 매개 변수 목록에 &lt;code&gt;self&lt;/code&gt; 를 포함하지 마십시오 . 메서드에 동등한 기능이있는 경우 (예 : 많은 ndarray 메서드의 경우), 함수 docstring에는 자세한 문서가 포함되어야하며 메서드 docstring은이를 참조해야합니다. 메서드 독 스트링 에 간략한 요약과 &lt;strong&gt;See Also&lt;/strong&gt; 섹션 만 넣으십시오 . 방법은 적절하게 &lt;strong&gt;반품&lt;/strong&gt; 또는 &lt;strong&gt;수율&lt;/strong&gt; 섹션을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aace7c330abd46b13c19d17e41a2b983184fb5c8" translate="yes" xml:space="preserve">
          <source>Documentation changes</source>
          <target state="translated">문서 변경</target>
        </trans-unit>
        <trans-unit id="60fd3cca6a005f3a93b2ac968aefd3667051eb97" translate="yes" xml:space="preserve">
          <source>Documentation conventions</source>
          <target state="translated">문서화 규칙</target>
        </trans-unit>
        <trans-unit id="b23c2835b58ceee2da287f2913118028a305fb03" translate="yes" xml:space="preserve">
          <source>Documentation for &lt;code&gt;numpy.test&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.test&lt;/code&gt; 에 대한 문서</target>
        </trans-unit>
        <trans-unit id="bb46cfc837763500362046f3d178e5331ebd4963" translate="yes" xml:space="preserve">
          <source>Documentation for the f2py module (Fortran extensions for Python)</source>
          <target state="translated">f2py 모듈에 대한 문서 (Python 용 포트란 확장)</target>
        </trans-unit>
        <trans-unit id="d2706eec51222f32b825a53b6e68123a18fe8dfd" translate="yes" xml:space="preserve">
          <source>Documentation for the ufunc. Should not contain the function signature as this is generated dynamically when __doc__ is retrieved.</source>
          <target state="translated">ufunc에 대한 설명서. __doc__을 검색 할 때 동적으로 생성되므로 함수 서명을 포함하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="8286db5422ab7c51bd61ede1cb5e66ceeff9dcd5" translate="yes" xml:space="preserve">
          <source>Documentation needs to meet users where they are. &lt;code&gt;How-tos&lt;/code&gt; offer get-it-done information; the user wants steps to copy and doesn&amp;rsquo;t necessarily want to understand NumPy. &lt;code&gt;Tutorials&lt;/code&gt; are warm-fuzzy information; the user wants a feel for some aspect of NumPy (and again, may or may not care about deeper knowledge).</source>
          <target state="translated">문서는 사용자가있는 곳에서 사용자를 충족시켜야합니다. &lt;code&gt;How-tos&lt;/code&gt; 는 get-it-done 정보를 제공합니다. 사용자는 단계를 복사하기를 원하고 반드시 NumPy를 이해하기를 원하지는 않습니다. &lt;code&gt;Tutorials&lt;/code&gt; 은 웜 퍼지 정보입니다. 사용자는 NumPy의 일부 측면에 대한 느낌을 원합니다 (그리고 다시 한 번 더 깊은 지식에 관심이있을 수도 있고 아닐 수도 있습니다).</target>
        </trans-unit>
        <trans-unit id="d2d57ffb6e044984ba433980d77ebfe46f06b1d6" translate="yes" xml:space="preserve">
          <source>Documentation reading</source>
          <target state="translated">문서 읽기</target>
        </trans-unit>
        <trans-unit id="792adc86a2cb1a69c5ef4c2ed42e770b3385f9b9" translate="yes" xml:space="preserve">
          <source>Documentation team meetings</source>
          <target state="translated">문서화 팀 회의</target>
        </trans-unit>
        <trans-unit id="545b688d380f572b36365ef4db533e2981eb0dcd" translate="yes" xml:space="preserve">
          <source>Documenting class instances</source>
          <target state="translated">클래스 인스턴스 문서화</target>
        </trans-unit>
        <trans-unit id="de41a9c8105cd9d19325f3f162ff7a2bf42e6f9e" translate="yes" xml:space="preserve">
          <source>Documenting classes</source>
          <target state="translated">수업 문서화</target>
        </trans-unit>
        <trans-unit id="083e8a05c747196442536d6d3a79787f09f96786" translate="yes" xml:space="preserve">
          <source>Documenting constants</source>
          <target state="translated">상수 문서화</target>
        </trans-unit>
        <trans-unit id="e5a8458cad9711c106e216f2ddc8545dca74ac62" translate="yes" xml:space="preserve">
          <source>Documenting generators</source>
          <target state="translated">생성기 문서화</target>
        </trans-unit>
        <trans-unit id="e080b39745727d2a544712c7b574f27a35aa65d9" translate="yes" xml:space="preserve">
          <source>Documenting modules</source>
          <target state="translated">모듈 문서화</target>
        </trans-unit>
        <trans-unit id="2a54d61d3475020f8594e304efd77ba4b91e171c" translate="yes" xml:space="preserve">
          <source>Docutils Design Specification</source>
          <target state="translated">Docutils 디자인 사양</target>
        </trans-unit>
        <trans-unit id="0d7bd4643db21c4724f9db11e4bb21b57a80e3fc" translate="yes" xml:space="preserve">
          <source>Does &lt;em&gt;not&lt;/em&gt; conjugate! For the complex conjugate transpose, use &lt;code&gt;.H&lt;/code&gt;.</source>
          <target state="translated">않습니다 &lt;em&gt;하지&lt;/em&gt; 활용할! 복합 접합 전치의 경우 &lt;code&gt;.H&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb0e5a02446a93df5c6a9418c49d06da3e217cfb" translate="yes" xml:space="preserve">
          <source>Does not check that the x-coordinate sequence &lt;code&gt;xp&lt;/code&gt; is increasing. If &lt;code&gt;xp&lt;/code&gt; is not increasing, the results are nonsense. A simple check for increasing is:</source>
          <target state="translated">x 좌표 시퀀스 &lt;code&gt;xp&lt;/code&gt; 가 증가하고 있는지 확인하지 않습니다 . 경우 &lt;code&gt;xp&lt;/code&gt; 증가되지 않으며, 결과는 말도 있습니다. 증가에 대한 간단한 점검은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="37a9483068c43f31f29b0fa4bbb6e7ded8b89453" translate="yes" xml:space="preserve">
          <source>Does not include memory consumed by non-element attributes of the array object.</source>
          <target state="translated">배열 객체의 비 요소 속성이 사용하는 메모리는 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="012c8b761c8393729a4cb704d79590085ef18bb5" translate="yes" xml:space="preserve">
          <source>Does nothing here, but is called by the get_version method and can be overridden by subclasses.</source>
          <target state="translated">여기서는 아무 작업도하지 않지만 get_version 메서드에 의해 호출되며 하위 클래스에 의해 재정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="84887a1c94f098c6708719c1a6026e64aff20e8d" translate="yes" xml:space="preserve">
          <source>Does the code follow NumPy&amp;rsquo;s &lt;a href=&quot;index#stylistic-guidelines&quot;&gt;Stylistic Guidelines&lt;/a&gt;?</source>
          <target state="translated">코드가 NumPy의 &lt;a href=&quot;index#stylistic-guidelines&quot;&gt;스타일 가이드 라인을&lt;/a&gt; 따르 나요?</target>
        </trans-unit>
        <trans-unit id="67c613cffa27e436d1e39d528d4c0ea2d0e7f349" translate="yes" xml:space="preserve">
          <source>Does the documentation follow the &lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;NumPy guidelines&lt;/a&gt;? Are the docstrings properly formatted?</source>
          <target state="translated">문서가 &lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;NumPy 지침을 따르&lt;/a&gt; 나요? 독 스트링의 형식이 적절합니까?</target>
        </trans-unit>
        <trans-unit id="82197e5e2b65bee680b92d50de02f93e5275ccd4" translate="yes" xml:space="preserve">
          <source>Does their energy intake deviate systematically from the recommended value of 7725 kJ?</source>
          <target state="translated">그들의 에너지 섭취는 권장 값 7725 kJ에서 체계적으로 벗어 납니까?</target>
        </trans-unit>
        <trans-unit id="0c355f091494c5b95894a312c87fff6cb5463260" translate="yes" xml:space="preserve">
          <source>Does this mean NumPy&amp;rsquo;s infrastructure passes the compiler&amp;rsquo;s flags of baseline features to all sources?</source>
          <target state="translated">이것은 NumPy의 인프라가 컴파일러의 기준 기능 플래그를 모든 소스에 전달한다는 것을 의미합니까?</target>
        </trans-unit>
        <trans-unit id="d715a7a4180b81aa4dc0e99a729aab2873bf8d94" translate="yes" xml:space="preserve">
          <source>Doesn&amp;rsquo;t do much for numpy?</source>
          <target state="translated">numpy를 위해 많은 일을하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="fda52ba5b69a393e193dac1fab0651122da1f1df" translate="yes" xml:space="preserve">
          <source>Doing a little timing in IPython shows that the reduced overhead and memory allocation of the Cython inner loop is providing a very nice speedup over both the straightforward Python code and an expression using NumPy&amp;rsquo;s built-in sum function.:</source>
          <target state="translated">IPython에서 약간의 타이밍을 수행하면 Cython 내부 루프의 오버 헤드 및 메모리 할당이 줄어들어 간단한 Python 코드와 NumPy의 내장 합계 함수를 사용하는 표현식에 비해 매우 빠른 속도를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="5a2e054286be13032ccbf78259a0703d8d83b801" translate="yes" xml:space="preserve">
          <source>Domain for the resulting series. If None the domain is the interval from the smallest root to the largest. If [] the domain is the class domain. The default is [].</source>
          <target state="translated">결과 시리즈의 도메인. 없음 인 경우 도메인은 가장 작은 루트에서 가장 큰 루트까지의 간격입니다. [] 인 경우 도메인은 클래스 도메인입니다. 기본값은 []입니다.</target>
        </trans-unit>
        <trans-unit id="4eb122f9bcef4efacc38db644f8b8fbbbd3f1f52" translate="yes" xml:space="preserve">
          <source>Domain over which &lt;code&gt;func&lt;/code&gt; is interpolated. The default is None, in which case the domain is [-1, 1].</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 이 보간 되는 도메인 . 기본값은 없음입니다.이 경우 도메인은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="f2d15df66fa784a07d3132cdc84cc4e9d2a43f78" translate="yes" xml:space="preserve">
          <source>Domain to use for the returned series. If &lt;code&gt;None&lt;/code&gt;, then a minimal domain that covers the points &lt;code&gt;x&lt;/code&gt; is chosen. If &lt;code&gt;[]&lt;/code&gt; the class domain is used. The default value was the class domain in NumPy 1.4 and &lt;code&gt;None&lt;/code&gt; in later versions. The &lt;code&gt;[]&lt;/code&gt; option was added in numpy 1.5.0.</source>
          <target state="translated">반환 된 시리즈에 사용할 도메인입니다. 않으면 &lt;code&gt;None&lt;/code&gt; , 그 점 덮는 최소 도메인 &lt;code&gt;x&lt;/code&gt; 선택되지 않는다. 만약 &lt;code&gt;[]&lt;/code&gt; 클래스 도메인이 사용됩니다. 기본값은 NumPy 1.4의 클래스 도메인이고 이후 버전에서는 &lt;code&gt;None&lt;/code&gt; 입니다. &lt;code&gt;[]&lt;/code&gt; 옵션은 NumPy와 1.5.0에서 추가되었다.</target>
        </trans-unit>
        <trans-unit id="82edf41d9d3177c9bd118b575de636ba573d4e3f" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [-1, 1].</source>
          <target state="translated">사용할 도메인. 간격 &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; 은 이동 및 스케일링에 의해 간격 &lt;code&gt;[window[0], window[1]]&lt;/code&gt; 에 매핑됩니다 . 기본값은 [-1, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="07b2e5d2cce01727bf325f6bd8595469a9076b39" translate="yes" xml:space="preserve">
          <source>Domain to use. The interval &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; is mapped to the interval &lt;code&gt;[window[0], window[1]]&lt;/code&gt; by shifting and scaling. The default value is [0, 1].</source>
          <target state="translated">사용할 도메인. 간격 &lt;code&gt;[domain[0], domain[1]]&lt;/code&gt; 은 이동 및 스케일링에 의해 간격 &lt;code&gt;[window[0], window[1]]&lt;/code&gt; 에 매핑됩니다 . 기본값은 [0, 1]입니다.</target>
        </trans-unit>
        <trans-unit id="99ef7d89dc77a04fadda76f62633917fa42d732a" translate="yes" xml:space="preserve">
          <source>Domains. Each domain must (successfully) convert to a 1-d array containing precisely two values.</source>
          <target state="translated">도메인. 각 도메인은 (성공적으로) 정확히 두 개의 값을 포함하는 1 차원 배열로 변환해야합니다.</target>
        </trans-unit>
        <trans-unit id="1a0ae559f34e1c809e970b484a89ff4eaa2ace43" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t also give directions from Route 7.</source>
          <target state="translated">7 번 국도에서 오는 길도 알려주지 마세요.</target>
        </trans-unit>
        <trans-unit id="845a637b103bbcbbace502867de0ec52f11db37e" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be fooled by this attribute&amp;rsquo;s name: &lt;code&gt;reduceat(a)&lt;/code&gt; is not necessarily smaller than &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이 속성의 이름에 속지 마십시오. &lt;code&gt;reduceat(a)&lt;/code&gt; 가 반드시 &lt;code&gt;a&lt;/code&gt; 보다 작을 필요는 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c3bedf4c2fe85fbd36748106c43721c91baccb9b" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t be fooled by this attribute&amp;rsquo;s name: &lt;code&gt;reduceat(array)&lt;/code&gt; is not necessarily smaller than &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 속성의 이름에 속지 마십시오. &lt;code&gt;reduceat(array)&lt;/code&gt; 가 반드시 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 보다 작지는 않습니다 .</target>
        </trans-unit>
        <trans-unit id="13775066efbe40628c7dde4181e195cd2936bb6f" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t explain why the town has only one filling station.</source>
          <target state="translated">왜 마을에 주유소가 하나만 있는지 설명하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="ea5b3bcd94196dcf54402b9f64d0933d42d3c0f3" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t set the argtypes attribute of the function object and define an &lt;code&gt;_as_parameter_&lt;/code&gt; method for the object you want to pass in. The &lt;code&gt;_as_parameter_&lt;/code&gt; method must return a Python int which will be passed directly to the function.</source>
          <target state="translated">함수 객체의 argtypes 속성을 설정하지 말고 전달하려는 객체에 대해 &lt;code&gt;_as_parameter_&lt;/code&gt; 메소드를 정의하십시오 . &lt;code&gt;_as_parameter_&lt;/code&gt; 메소드는 함수에 직접 전달 될 Python int를 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="63f6c0cae180c1519a43cdaf129188e65581d9cb" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amax(a, axis=0)&lt;/code&gt;.</source>
          <target state="translated">2 개의 배열을 요소별로 비교하기 위해 &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; 를 사용하지 마십시오 . 경우 &lt;code&gt;a.shape[0]&lt;/code&gt; 2 인 &lt;code&gt;maximum(a[0], a[1])&lt;/code&gt; 보다 빠른 인 &lt;code&gt;amax(a, axis=0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ee45e18cb25f4ffa299fe638bc542425558ed71" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; for element-wise comparison of 2 arrays; when &lt;code&gt;a.shape[0]&lt;/code&gt; is 2, &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; is faster than &lt;code&gt;amin(a, axis=0)&lt;/code&gt;.</source>
          <target state="translated">2 개의 배열을 요소별로 비교하기 위해 &lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; 을 사용하지 마십시오 . 경우 &lt;code&gt;a.shape[0]&lt;/code&gt; 2 인 &lt;code&gt;minimum(a[0], a[1])&lt;/code&gt; 보다 빠른 인 &lt;code&gt;amin(a, axis=0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4daa4280ddb2880ee84e8ed5c7d8b50d974a1a2d" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t use GCC extensions (e.g. don&amp;rsquo;t write multi-line strings without trailing backslashes). Preferably break long strings up onto separate lines like so:</source>
          <target state="translated">GCC 확장을 사용하지 마십시오 (예 : 후행 백 슬래시없이 여러 줄 문자열을 작성하지 마십시오). 긴 문자열을 다음과 같이 별도의 줄로 나누는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="9f62bf0f863ac005820e3bcd72cad2769c334ac5" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry if English is not your first language, or if you can only come up with a rough draft. Open source is a community effort. Do your best &amp;ndash; we&amp;rsquo;ll help fix issues.</source>
          <target state="translated">영어가 모국어가 아니거나 대략적인 초안 만 나올 수 있더라도 걱정하지 마십시오. 오픈 소스는 커뮤니티의 노력입니다. 최선을 다해 문제 해결을 도와 드리겠습니다.</target>
        </trans-unit>
        <trans-unit id="925b7467380efc1c88b586cffa1954673d787eb8" translate="yes" xml:space="preserve">
          <source>Don&amp;rsquo;t worry if English is not your first language. Do your best - we&amp;rsquo;ll revise your content and make sure we fix any issues with the code or text.</source>
          <target state="translated">영어가 모국어가 아니어도 걱정하지 마십시오. 최선을 다해 콘텐츠를 수정하고 코드 또는 텍스트 관련 문제를 해결하도록하겠습니다.</target>
        </trans-unit>
        <trans-unit id="aa88c4200f9ff0af7b35d86c216e43d9a614dd06" translate="yes" xml:space="preserve">
          <source>Dot method for ndarrays</source>
          <target state="translated">ndarrays에 대한 점 방법</target>
        </trans-unit>
        <trans-unit id="e3ed26a26d95479b379119608058dbb2109efb38" translate="yes" xml:space="preserve">
          <source>Dot product of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. Can be an int, float, or complex depending on the types of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">내적 와 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 의 유형에 따라 int, float 또는 complex 일 수 있습니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1b5eb09c46c81da930e48b39cbd0988e1d15009" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays.</source>
          <target state="translated">두 배열의 내적.</target>
        </trans-unit>
        <trans-unit id="69fc04836f683a90b063205daff794ec842891ec" translate="yes" xml:space="preserve">
          <source>Dot product of two arrays. Specifically,</source>
          <target state="translated">두 배열의 내적. 구체적으로 특별히,</target>
        </trans-unit>
        <trans-unit id="483bddb46f1fe0cf62058030e5e7f966dfa5f159" translate="yes" xml:space="preserve">
          <source>Double-precision floating-point number type, compatible with Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt; and C &lt;code&gt;double&lt;/code&gt;.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 및 C &lt;code&gt;double&lt;/code&gt; 과 호환되는 배정 밀도 부동 소수점 숫자 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c1a9df5fa2f54e372302b1a84476eb9810716451" translate="yes" xml:space="preserve">
          <source>Download wheels</source>
          <target state="translated">바퀴 다운로드</target>
        </trans-unit>
        <trans-unit id="10eebd1ec669729dbb8a387ff1f1ee83e265b551" translate="yes" xml:space="preserve">
          <source>Draw &lt;code&gt;size&lt;/code&gt; samples of dimension k from a Dirichlet distribution. A Dirichlet-distributed random variable can be seen as a multivariate generalization of a Beta distribution. The Dirichlet distribution is a conjugate prior of a multinomial distribution in Bayesian inference.</source>
          <target state="translated">그리기 &lt;code&gt;size&lt;/code&gt; 디리클레 분포로부터 치수 (k)의 샘플. Dirichlet 분포 랜덤 변수는 베타 분포의 다변량 일반화로 볼 수 있습니다. Dirichlet 분포는 베이지안 추론에서 다항 분포 이전의 켤레입니다.</target>
        </trans-unit>
        <trans-unit id="8cef6690ff1fb5f0c2316445230ab79655322c59" translate="yes" xml:space="preserve">
          <source>Draw each 100 values for lambda 100 and 500:</source>
          <target state="translated">람다 100과 500에 대해 각각 100 개의 값을 그립니다 :</target>
        </trans-unit>
        <trans-unit id="81a1f06763debec752f9772c00b9c8c55a29d67f" translate="yes" xml:space="preserve">
          <source>Draw random samples from a multivariate normal distribution.</source>
          <target state="translated">다변량 정규 분포에서 랜덤 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="bc8a71087c0197828056ce59780ae3569bbf2e6d" translate="yes" xml:space="preserve">
          <source>Draw random samples from a normal (Gaussian) distribution.</source>
          <target state="translated">정규 (가우시안) 분포에서 랜덤 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c671d5af70be0d6ee7f133745fc1b0ba932a0dc3" translate="yes" xml:space="preserve">
          <source>Draw samples and plot the distribution:</source>
          <target state="translated">표본을 그리고 분포를 그리십시오 :</target>
        </trans-unit>
        <trans-unit id="d0efc43d29d4ab1659826dde574edba31ec35e3f" translate="yes" xml:space="preserve">
          <source>Draw samples from a 1-parameter Weibull distribution with the given shape parameter &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">주어진 모양 모수 &lt;code&gt;a&lt;/code&gt; 를 사용하여 1 모수 Weibull 분포에서 표본을 추출합니다 . .</target>
        </trans-unit>
        <trans-unit id="fc465d9bb43792a6a4d6d0b79fc58926df796844" translate="yes" xml:space="preserve">
          <source>Draw samples from a Beta distribution.</source>
          <target state="translated">베타 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="db385760aa8dd626fb9adb8853dfd6288a91a9df" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gamma distribution.</source>
          <target state="translated">감마 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="78ab6a861638484d02fed32908592521ecb292b9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution with specified location and scale. For more information on the Gumbel distribution, see Notes and References below.</source>
          <target state="translated">지정된 위치와 스케일로 Gumbel 분포에서 표본을 추출합니다. Gumbel 배포에 대한 자세한 내용은 아래 참고 및 참조를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="66a815e387ea9da74fa2238bda4162c421a8c8a9" translate="yes" xml:space="preserve">
          <source>Draw samples from a Gumbel distribution.</source>
          <target state="translated">Gumbel 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="cb301b24d49678b3e9fff80704432281d0df654a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Hypergeometric distribution.</source>
          <target state="translated">Hypergeometric 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="836d1593a600cfcfb833fff8c11191d4c4c5d27a" translate="yes" xml:space="preserve">
          <source>Draw samples from a Pareto II or Lomax distribution with specified shape.</source>
          <target state="translated">지정된 모양의 파레토 II 또는 Lomax 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="721b7e6dfb7ad60658e5e614aa751c343f6988fc" translate="yes" xml:space="preserve">
          <source>Draw samples from a Poisson distribution.</source>
          <target state="translated">푸 아송 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="62a0b4d313dadcf54cda2bc4c9745765dcc56eb6" translate="yes" xml:space="preserve">
          <source>Draw samples from a Rayleigh distribution.</source>
          <target state="translated">레일리 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0cdf4a2aee4c3b56a5568531ce7576534f61561f" translate="yes" xml:space="preserve">
          <source>Draw samples from a Wald, or inverse Gaussian, distribution.</source>
          <target state="translated">Wald 또는 역 가우스 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="16cd7ccf53dc2b531e1445308d5381898213743b" translate="yes" xml:space="preserve">
          <source>Draw samples from a Weibull distribution.</source>
          <target state="translated">Weibull 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0e097ecaf2ff3b51bfb55b676dfdfa6cbd8e50b1" translate="yes" xml:space="preserve">
          <source>Draw samples from a Zipf distribution.</source>
          <target state="translated">Zipf 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b159750cd52438190e80fd2b264928bcdbbeffee" translate="yes" xml:space="preserve">
          <source>Draw samples from a binomial distribution.</source>
          <target state="translated">이항 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3e18e00273a5fae8bbde1791f129e0cbe3bd2452" translate="yes" xml:space="preserve">
          <source>Draw samples from a chi-square distribution.</source>
          <target state="translated">카이 제곱 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="7461bda090453d4ff12b83f4027e9d3a1946262b" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution with specified mean, standard deviation, and array shape. Note that the mean and standard deviation are not the values for the distribution itself, but of the underlying normal distribution it is derived from.</source>
          <target state="translated">지정된 평균, 표준 편차 및 배열 모양을 가진 로그 정규 분포에서 표본을 추출합니다. 평균 및 표준 편차는 분포 자체의 값이 아니라 기본 정규 분포의 값입니다.</target>
        </trans-unit>
        <trans-unit id="418d59729801e30d611ad0edbc665078409b6f57" translate="yes" xml:space="preserve">
          <source>Draw samples from a log-normal distribution.</source>
          <target state="translated">로그 정규 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a1bc3727e4de5e7ab2b6eea3e4aaf62bfcf5bf0d" translate="yes" xml:space="preserve">
          <source>Draw samples from a logarithmic series distribution.</source>
          <target state="translated">로그 시리즈 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="259f9fd69d995b257a6d58ec3161de00c6ac8e73" translate="yes" xml:space="preserve">
          <source>Draw samples from a logistic distribution.</source>
          <target state="translated">로지스틱 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="caeefc0caf49fe896c077769862c6d8f2a2d4d55" translate="yes" xml:space="preserve">
          <source>Draw samples from a multinomial distribution.</source>
          <target state="translated">다항 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3f26805ca2b4fd1c182f06df074a9a855b5c8e20" translate="yes" xml:space="preserve">
          <source>Draw samples from a negative binomial distribution.</source>
          <target state="translated">음 이항 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="6fad248b8adad205bba771cea1b6af2c597903fb" translate="yes" xml:space="preserve">
          <source>Draw samples from a noncentral chi-square distribution.</source>
          <target state="translated">비 중심 카이-제곱 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="9282b1d217bfacf12c8b8d4a104f2cce46e68b92" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Cauchy distribution with mode = 0.</source>
          <target state="translated">mode = 0 인 표준 Cauchy 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="1bf09a114ab7401dced2153d963e20885d1b64c6" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Gamma distribution.</source>
          <target state="translated">표준 감마 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="14c3ce03d59dad5f0ba6dbc68a1db4e39a115c97" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Normal distribution (mean=0, stdev=1).</source>
          <target state="translated">표준 정규 분포에서 표본을 추출합니다 (평균 = 0, stdev = 1).</target>
        </trans-unit>
        <trans-unit id="0a5ed72650600061c64a7b3836210429f01c8df4" translate="yes" xml:space="preserve">
          <source>Draw samples from a standard Student&amp;rsquo;s t distribution with &lt;code&gt;df&lt;/code&gt; degrees of freedom.</source>
          <target state="translated">&lt;code&gt;df&lt;/code&gt; 자유도 를 사용하여 표준 Student 's t 분포에서 표본을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="a9791d093a2516b6b22df69cdc89a44c76c8547c" translate="yes" xml:space="preserve">
          <source>Draw samples from a uniform distribution.</source>
          <target state="translated">균일 한 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c8dcd074131ab16cf48b101b69dbb09a06467e24" translate="yes" xml:space="preserve">
          <source>Draw samples from a von Mises distribution.</source>
          <target state="translated">폰 미제스 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="3f67bb2441c84f4b1162da84f12a83a78820075f" translate="yes" xml:space="preserve">
          <source>Draw samples from an F distribution.</source>
          <target state="translated">F 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="b4cb12b4006c936a1a5eaa65c28e2a7372035b59" translate="yes" xml:space="preserve">
          <source>Draw samples from an exponential distribution.</source>
          <target state="translated">지수 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a30ab841488cf720b5a3a41538404e70c0fdfa78" translate="yes" xml:space="preserve">
          <source>Draw samples from the (univariate) hypergeometric distribution.</source>
          <target state="translated">(일 변량) 초기 하 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="9016ff24a09fb989d28a00e24a13cde2696b4777" translate="yes" xml:space="preserve">
          <source>Draw samples from the Dirichlet distribution.</source>
          <target state="translated">Dirichlet 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="a3fdcad14f303f834dc59b1f3dccb9f86e1705cd" translate="yes" xml:space="preserve">
          <source>Draw samples from the Laplace or double exponential distribution with specified location (or mean) and scale (decay).</source>
          <target state="translated">지정된 위치 (또는 평균) 및 스케일 (부패)을 사용하여 Laplace 또는 이중 지수 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="308c6270dd43fde905a32469d95cef01a142bca2" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution</source>
          <target state="translated">분포에서 표본 추출</target>
        </trans-unit>
        <trans-unit id="5b28ac74b7769bfdc417f7f61e050393575dc125" translate="yes" xml:space="preserve">
          <source>Draw samples from the distribution:</source>
          <target state="translated">분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="bf043e5601b2f68702eac5005c66d1ebbc6a2030" translate="yes" xml:space="preserve">
          <source>Draw samples from the geometric distribution.</source>
          <target state="translated">기하 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="50bffe344c068c3aa4f884953280cc5f75924007" translate="yes" xml:space="preserve">
          <source>Draw samples from the multivariate hypergeometric distribution.</source>
          <target state="translated">다변량 초기 하 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="570de821167a667775bfd8af3be681420e790f2f" translate="yes" xml:space="preserve">
          <source>Draw samples from the noncentral F distribution.</source>
          <target state="translated">비 중앙 F 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="c575768cb70c661f622a7746787703873a7fb9c5" translate="yes" xml:space="preserve">
          <source>Draw samples from the standard exponential distribution.</source>
          <target state="translated">표준 지수 분포에서 표본을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="dc17866b1f3b7819078bdef07b4d9d1716739b78" translate="yes" xml:space="preserve">
          <source>Draw samples from the triangular distribution over the interval &lt;code&gt;[left, right]&lt;/code&gt;.</source>
          <target state="translated">구간 &lt;code&gt;[left, right]&lt;/code&gt; 걸쳐 삼각 분포에서 표본을 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="1abf94062d6b0e1580c4eed26b19473395f5dd35" translate="yes" xml:space="preserve">
          <source>Draw ten thousand values from the geometric distribution, with the probability of an individual success equal to 0.35:</source>
          <target state="translated">개별 분포 확률이 0.35 인 기하 분포에서 만 값을 구합니다.</target>
        </trans-unit>
        <trans-unit id="226c6736b8b9dc551d8a75e9fd86f951df1752ee" translate="yes" xml:space="preserve">
          <source>Draw values from a noncentral chisquare with very small noncentrality, and compare to a chisquare.</source>
          <target state="translated">비중 심성이 매우 작은 비 중앙 카이 제곱에서 값을 그리고 카이 제곱과 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3329d33efc5189ab8786b87fd997f1cb2a5fa5e8" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram</source>
          <target state="translated">분포에서 값을 그리고 히스토그램을 플로팅</target>
        </trans-unit>
        <trans-unit id="2eb6c903d93ed4163d8a9ba3d7777ce26bf70cc2" translate="yes" xml:space="preserve">
          <source>Draw values from the distribution and plot the histogram:</source>
          <target state="translated">분포에서 값을 그리고 히스토그램을 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="345d5990ad5e8dc2505201d616bdccd87cd84e5e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Fisher distribution.</source>
          <target state="translated">매개 변수화 된 Fisher 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="19d957a8e68c68660a252e592ee001bf286ee4ee" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Gumbel distribution.</source>
          <target state="translated">매개 변수화 된 Gumbel 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="3874e3e9ab062a1d7bfdc5d30325b887fbc419d7" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Laplace distribution.</source>
          <target state="translated">매개 변수화 된 Laplace 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="1cf05e207a79201534bfd254b9ef20861558f17e" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Pareto distribution.</source>
          <target state="translated">매개 변수화 된 파레토 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="03c373308c04f8e25032a7f57925fc2cd89f5c43" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Poisson distribution.</source>
          <target state="translated">파라미터 화 된 포아송 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="800df344bc4e042b278de9e7bd37c782c2e5c6c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Rayleigh distribution.</source>
          <target state="translated">매개 변수화 된 Rayleigh 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="96c79cda5fd0d2766220ff50c40f50e59b603b40" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Wald distribution.</source>
          <target state="translated">매개 변수화 된 Wald 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="881edd9192611978afca45ae863cda6f17a1d7fb" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Weibull distribution.</source>
          <target state="translated">매개 변수화 된 Weibull 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="cec1a5674838f11821fe1b57bed9970f730915c8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized Zipf distribution.</source>
          <target state="translated">매개 변수화 된 Zipf 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="3e3af0fcef04d64e093680f90bd154da4da6f7e6" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized beta distribution.</source>
          <target state="translated">매개 변수화 된 베타 분포에서 추출한 샘플.</target>
        </trans-unit>
        <trans-unit id="66aa1280d92bc58e93f2dd0657680e02202ddedc" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized binomial distribution, where each sample is equal to the number of successes over the n trials.</source>
          <target state="translated">모수화 된 이항 분포에서 표본을 추출했습니다. 여기서 각 표본은 n 번의 시행에서 성공한 횟수와 같습니다.</target>
        </trans-unit>
        <trans-unit id="803cd0d20a6c49e0eab984068f59353e0ec6f797" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized chi-square distribution.</source>
          <target state="translated">매개 변수화 된 카이 제곱 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="0a07d0ff0927ba822ed7f54576b179ec4780bfd4" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized exponential distribution.</source>
          <target state="translated">모수화 된 지수 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="a2f28dab17c9ec69c1e4c0816e2b49d0d97cc8c9" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized gamma distribution.</source>
          <target state="translated">매개 변수화 된 감마 분포에서 추출한 샘플.</target>
        </trans-unit>
        <trans-unit id="645b194e18330c38a086d019ef409b1ad04a10ac" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized geometric distribution.</source>
          <target state="translated">매개 변수화 된 기하 분포에서 추출한 표본.</target>
        </trans-unit>
        <trans-unit id="675c1d8f69c01109a94a55f050b7feba6cfeb004" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized hypergeometric distribution. Each sample is the number of good items within a randomly selected subset of size &lt;code&gt;nsample&lt;/code&gt; taken from a set of &lt;code&gt;ngood&lt;/code&gt; good items and &lt;code&gt;nbad&lt;/code&gt; bad items.</source>
          <target state="translated">모수화 된 초기 하 분포에서 표본을 추출했습니다. 각 샘플은 &lt;code&gt;ngood&lt;/code&gt; good items 및 &lt;code&gt;nbad&lt;/code&gt; bad items 세트에서 가져온 &lt;code&gt;nsample&lt;/code&gt; 크기의 무작위로 선택된 하위 집합에 속하는 good items 수입니다.</target>
        </trans-unit>
        <trans-unit id="0ec5fd25c15e2f401571dd2213b5e63981af1884" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized log-normal distribution.</source>
          <target state="translated">모수화 된 로그 정규 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="92c1e4b50e7e0ed6389caf6bd275c9d96e903819" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logarithmic series distribution.</source>
          <target state="translated">매개 변수화 된 대수 시리즈 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="0418a31cc205f33ce6262d40794bf3e47add1b19" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized logistic distribution.</source>
          <target state="translated">매개 변수화 된 물류 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="16ad062ab33ce9488dba4d726621ff0742f56c11" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized negative binomial distribution, where each sample is equal to N, the number of failures that occurred before a total of n successes was reached.</source>
          <target state="translated">매개 변수화 된 음 이항 분포에서 추출 된 샘플 (각 샘플이 N과 같음), 총 n 개의 성공에 도달하기 전에 발생한 실패 수</target>
        </trans-unit>
        <trans-unit id="afe023dcddff604c4223693c51bcae1660f6eba8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral Fisher distribution.</source>
          <target state="translated">매개 변수화 된 비 중앙 Fisher 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="0dad06577da3cf941b7346f737f68fc3b67c036b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized noncentral chi-square distribution.</source>
          <target state="translated">매개 변수화 된 비 중앙 카이-제곱 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="1b7aa6be999ea249ca4e25e9eb3c5a161f178b65" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized normal distribution.</source>
          <target state="translated">모수화 된 정규 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="75a239b9fd8457ca43a81ea8883cb90f669b784d" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized power distribution.</source>
          <target state="translated">매개 변수화 된 배전에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="417f5f8f2a7e8f51ee4be6e5ef1c8c34cc318b2f" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard Student&amp;rsquo;s t distribution.</source>
          <target state="translated">매개 변수화 된 표준 스튜던트 t 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="9cfa7b49541ac131db1708e85662c20f82750d1b" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized standard gamma distribution.</source>
          <target state="translated">매개 변수화 된 표준 감마 분포에서 샘플을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="24c6b8b6588f6544b47569ada0a5521ca47031b8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized triangular distribution.</source>
          <target state="translated">모수화 된 삼각 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="59ea0a59c91c46f3d89e817e79cad726c3dc2dab" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized uniform distribution.</source>
          <target state="translated">모수화 된 균일 분포에서 표본을 추출했습니다.</target>
        </trans-unit>
        <trans-unit id="f20dd8e0ca9375ee4c56dd90351efacbd5b573d8" translate="yes" xml:space="preserve">
          <source>Drawn samples from the parameterized von Mises distribution.</source>
          <target state="translated">매개 변수화 된 폰 미제스 분포에서 추출한 샘플.</target>
        </trans-unit>
        <trans-unit id="cb8b86177c95587cf24b6f015131fe691b9fc3ba" translate="yes" xml:space="preserve">
          <source>Drawn samples.</source>
          <target state="translated">채취 한 샘플.</target>
        </trans-unit>
        <trans-unit id="1d18cceebff607d37e9bf2c1387fbd956866a568" translate="yes" xml:space="preserve">
          <source>Draws samples in [0, 1] from a power distribution with positive exponent a - 1.</source>
          <target state="translated">양의 지수 a-1을 갖는 전력 분포에서 [0, 1]의 샘플을 그립니다.</target>
        </trans-unit>
        <trans-unit id="3494c64843d7663d424ff8535f672114cde4d98a" translate="yes" xml:space="preserve">
          <source>Dropped Support</source>
          <target state="translated">지원 중단</target>
        </trans-unit>
        <trans-unit id="7d056b5f5f0adde2e16d37463c52db860d944e35" translate="yes" xml:space="preserve">
          <source>Dtype for the structured array.</source>
          <target state="translated">구조화 된 배열의 Dtype입니다.</target>
        </trans-unit>
        <trans-unit id="74a25c41a58aa29ed3adc5f8de64d6df2cab73e9" translate="yes" xml:space="preserve">
          <source>Dtype parameter added to &lt;code&gt;np.linspace&lt;/code&gt; and &lt;code&gt;np.logspace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.linspace&lt;/code&gt; 및 &lt;code&gt;np.logspace&lt;/code&gt; 에 Dtype 매개 변수가 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="90ed446a6c6e03872b9c3414013b747e673d0a8f" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;../../user/basics.rec#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조화 된 배열의 Dtype은 여러 형식으로 지정할 수 있지만 모든 형식은 최소한 데이터 형식과 필드 이름을 지정합니다. 자세한 내용은 &lt;a href=&quot;../../user/basics.rec#module-numpy.doc.structured_arrays&quot;&gt; &lt;code&gt;doc.structured_arrays&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c6259462846b5f9baee7053eaac196aa6133053" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt;&lt;code&gt;doc.structured_arrays&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조적 배열의 Dtype은 여러 형식으로 지정할 수 있지만 모든 형식은 최소한 데이터 형식과 필드 이름을 지정합니다. 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#module-numpy.doc.structured_arrays&quot;&gt; &lt;code&gt;doc.structured_arrays&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e3483b669fb4c30c323c5a51332eca41979d9ab8" translate="yes" xml:space="preserve">
          <source>Dtypes for structured arrays can be specified in several forms, but all forms specify at least the data type and field name. For details see &lt;code&gt;basics.rec&lt;/code&gt;.</source>
          <target state="translated">구조화 된 배열의 Dtype은 여러 형식으로 지정할 수 있지만 모든 형식은 최소한 데이터 형식과 필드 이름을 지정합니다. 자세한 내용은 &lt;code&gt;basics.rec&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ffaaa2445408170b57b919ca6485e258a7c95d8b" translate="yes" xml:space="preserve">
          <source>Duda, R. O., Hart, P. E., and Stork, D. G., &amp;ldquo;Pattern Classification,&amp;rdquo; 2nd ed., New York: Wiley, 2001.</source>
          <target state="translated">Duda, RO, Hart, PE 및 Stork, DG,&amp;ldquo;Pattern Classification&amp;rdquo;, 2nd ed., New York : Wiley, 2001.</target>
        </trans-unit>
        <trans-unit id="6baaefd65351906a350ba168fbf221f0d184adfa" translate="yes" xml:space="preserve">
          <source>Due to floating point rounding the resulting array may not be Hermitian, the diagonal elements may not be 1, and the elements may not satisfy the inequality abs(a) &amp;lt;= 1. The real and imaginary parts are clipped to the interval [-1, 1] in an attempt to improve on that situation but is not much help in the complex case.</source>
          <target state="translated">부동 소수점 반올림으로 인해 결과 배열은 에르 미트 (Hermitian)가 아니고 대각선 요소는 1이 아니고 요소는 부등식 abs (a) &amp;lt;= 1을 만족하지 않을 수 있습니다. 실수와 허수 부분은 간격 [-1로 클리핑됩니다. , 1] 그러한 상황을 개선하려는 시도에서 복잡한 경우에는 큰 도움이되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5668939217d0a50f3a990081bee30e034ec210d" translate="yes" xml:space="preserve">
          <source>Due to limitations in the interpretation of structured dtypes, dtypes with fields with empty names will have the names replaced by &amp;lsquo;f0&amp;rsquo;, &amp;lsquo;f1&amp;rsquo;, etc. Such arrays will not round-trip through the format entirely accurately. The data is intact; only the field names will differ. We are working on a fix for this. This fix will not require a change in the file format. The arrays with such structures can still be saved and restored, and the correct dtype may be restored by using the &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; method.</source>
          <target state="translated">구조화 된 dtype의 해석에 한계가 있으므로 이름이 비어있는 필드가있는 dtype은 이름이 'f0', 'f1'등으로 대체됩니다. 이러한 배열은 형식을 완전히 정확하게 왕복하지 않습니다. 데이터는 손상되지 않았습니다. 필드 이름 만 다릅니다. 이 문제를 해결하기 위해 노력하고 있습니다. 이 수정은 파일 형식을 변경할 필요가 없습니다. 이러한 구조의 어레이는 여전히 저장 및 복원 될 수 있으며 &lt;code&gt;loadedarray.view(correct_dtype)&lt;/code&gt; 메소드를 사용하여 올바른 dtype을 복원 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="be47cf08679632a886113408bbed677d155a3d74" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file.</source>
          <target state="translated">배열의 피클을 지정된 파일로 덤프합니다.</target>
        </trans-unit>
        <trans-unit id="c5317185019827371b1e31a396e0d441834d3252" translate="yes" xml:space="preserve">
          <source>Dump a pickle of the array to the specified file. The array can be read back with pickle.load or numpy.load.</source>
          <target state="translated">배열의 피클을 지정된 파일로 덤프합니다. pickle.load 또는 numpy.load를 사용하여 배열을 다시 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7a2c1b02316fce9ee22b42f7f9087251340c710e" translate="yes" xml:space="preserve">
          <source>During iteration, you may want to use the index of the current element in a computation. For example, you may want to visit the elements of an array in memory order, but use a C-order, Fortran-order, or multidimensional index to look up values in a different array.</source>
          <target state="translated">반복하는 동안 계산에 현재 요소의 색인을 사용할 수 있습니다. 예를 들어, 메모리의 순서로 배열의 요소를 방문하지만 C 순서, 포트란 순서 또는 다차원 인덱스를 사용하여 다른 배열의 값을 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3bf08c964c7c95130d665e4d98704726bfb41a50" translate="yes" xml:space="preserve">
          <source>During the beta/RC phase, an explicit request for testing the binaries with several other libraries (SciPy/Matplotlib/Pygame) should be posted on the mailing list.</source>
          <target state="translated">베타 / RC 단계에서 다른 여러 라이브러리 (SciPy / Matplotlib / Pygame)로 바이너리를 테스트하기위한 명시적인 요청이 메일 링리스트에 게시되어야합니다.</target>
        </trans-unit>
        <trans-unit id="b260078602d9938ed8897f4dbe8eacdc7db28c29" translate="yes" xml:space="preserve">
          <source>During the everyday project activities, council members participate in all discussions, code review and other project activities as peers with all other Contributors and the Community. In these everyday activities, Council Members do not have any special power or privilege through their membership on the Council. However, it is expected that because of the quality and quantity of their contributions and their expert knowledge of the Project Software and Services that Council Members will provide useful guidance, both technical and in terms of project direction, to potentially less experienced contributors.</source>
          <target state="translated">일상적인 프로젝트 활동 중에 협의회 구성원은 다른 모든 기여자 및 커뮤니티와 동료로서 모든 토론, 코드 검토 및 기타 프로젝트 활동에 참여합니다. 이러한 일상적인 활동에서 자문위원은위원회 회원 자격을 통해 특별한 권한이나 특권을 갖지 못합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 그러나 기여의 질과 양과 프로젝트 소프트웨어 및 서비스에 대한 전문 지식으로 인해 자문위원은 잠재적으로 경험이 부족한 기여자에게 기술 및 프로젝트 방향 측면에서 유용한 지침을 제공 할 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="50148ad962ec621811b6ecd1bdca81f3636b9d2b" translate="yes" xml:space="preserve">
          <source>During the loading of the NumPy module, there&amp;rsquo;s a validation step which detects this behavior. It will raise a Python runtime error to inform the user. This is to prevent the CPU reaching an illegal instruction error causing a segfault.</source>
          <target state="translated">NumPy 모듈을로드하는 동안이 동작을 감지하는 유효성 검사 단계가 있습니다. 사용자에게 알리기 위해 Python 런타임 오류가 발생합니다. 이것은 CPU가 segfault를 일으키는 잘못된 명령 오류에 도달하는 것을 방지하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3a97e818f2855e4e5e1bc73604c63d51f0dc4bf1" translate="yes" xml:space="preserve">
          <source>Durran D. R. (1999) Numerical Methods for Wave Equations in Geophysical Fluid Dynamics. New York: Springer.</source>
          <target state="translated">Durran DR (1999) 지구 물리학 적 유체 역학에서의 파동 방정식에 대한 수치 적 방법. 뉴욕 : 스프링거.</target>
        </trans-unit>
        <trans-unit id="e0184adedf913b076626646d3f52c3b49c39ad6d" translate="yes" xml:space="preserve">
          <source>E</source>
          <target state="translated">E</target>
        </trans-unit>
        <trans-unit id="26aa5b06114619ee705d4e196e09408f75d82651" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 106-108.</source>
          <target state="translated">ER Kanasewich, &quot;지구 물리학의 시간 순서 분석&quot;, 앨버타 프레스 대학, 1975, 106-108 페이지.</target>
        </trans-unit>
        <trans-unit id="7020945b62676f3792048d52264e61eaf1f2f06e" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 109-110.</source>
          <target state="translated">ER Kanasewich, &quot;지구 물리학의 시간 순서 분석&quot;, 앨버타 프레스 대학, 1975, 109-110 페이지.</target>
        </trans-unit>
        <trans-unit id="3bd1ccd7ec68cbb9d222ef47028613ad14f66cf8" translate="yes" xml:space="preserve">
          <source>E.R. Kanasewich, &amp;ldquo;Time Sequence Analysis in Geophysics&amp;rdquo;, The University of Alberta Press, 1975, pp. 177-178.</source>
          <target state="translated">ER Kanasewich, &quot;지구 물리학의 시간 순서 분석&quot;, 앨버타 프레스 대학, 1975, pp. 177-178.</target>
        </trans-unit>
        <trans-unit id="9282259a9bffd46a322a6acfc9997c91e019e7d4" translate="yes" xml:space="preserve">
          <source>Each &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple serves to expand the dimensions of the resulting selection by one unit-length dimension. The added dimension is the position of the &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; object in the selection tuple.</source>
          <target state="translated">선택 튜플의 각 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체는 결과 선택의 크기를 한 단위 길이 차원으로 확장하는 역할을합니다. 추가 된 치수는 선택 튜플에서 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체 의 위치입니다 .</target>
        </trans-unit>
        <trans-unit id="073efad576bf9e16c2944aef4f81bdac4eda711d" translate="yes" xml:space="preserve">
          <source>Each NumPy module exposes &lt;a href=&quot;#numpy.testing.Tester.bench&quot;&gt;&lt;code&gt;bench&lt;/code&gt;&lt;/a&gt; in its namespace to run all benchmarks for it.</source>
          <target state="translated">각 NumPy 모듈은 네임 스페이스에 &lt;a href=&quot;#numpy.testing.Tester.bench&quot;&gt; &lt;code&gt;bench&lt;/code&gt; &lt;/a&gt; 를 노출 하여 모든 벤치 마크를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f2eda913d3072244fb087de35642a2b1eb54ff25" translate="yes" xml:space="preserve">
          <source>Each NumPy module exposes &lt;a href=&quot;#numpy.testing.Tester.test&quot;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/a&gt; in its namespace to run all tests for it. For example, to run all tests for numpy.lib:</source>
          <target state="translated">각 NumPy 모듈은 네임 스페이스에 &lt;a href=&quot;#numpy.testing.Tester.test&quot;&gt; &lt;code&gt;test&lt;/code&gt; &lt;/a&gt; 를 노출 하여 모든 테스트를 실행합니다. 예를 들어 numpy.lib에 대한 모든 테스트를 실행하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="f76bc743577aee15d005972242975d93c3b7f843" translate="yes" xml:space="preserve">
          <source>Each array in the tuple has the same shape as the &lt;code&gt;indices&lt;/code&gt; array.</source>
          <target state="translated">튜플의 각 배열은 &lt;code&gt;indices&lt;/code&gt; 배열 과 모양이 같습니다 .</target>
        </trans-unit>
        <trans-unit id="386efca9f91ba00773f6c9bc7ed1232d730522e6" translate="yes" xml:space="preserve">
          <source>Each array must have the same shape.</source>
          <target state="translated">각 배열의 모양은 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="286a71006dd39afde343b3c45a4fd98ff7cec30e" translate="yes" xml:space="preserve">
          <source>Each boolean array corresponds to a function in &lt;code&gt;funclist&lt;/code&gt;. Wherever &lt;code&gt;condlist[i]&lt;/code&gt; is True, &lt;code&gt;funclist[i](x)&lt;/code&gt; is used as the output value.</source>
          <target state="translated">각 부울 배열은 &lt;code&gt;funclist&lt;/code&gt; 의 함수에 해당합니다 . 목적지 &lt;code&gt;condlist[i]&lt;/code&gt; 사실이다 &lt;code&gt;funclist[i](x)&lt;/code&gt; 의 출력값으로서 사용된다.</target>
        </trans-unit>
        <trans-unit id="eef78733a1d1f7432ec1ab2af99217db7ce78c93" translate="yes" xml:space="preserve">
          <source>Each boolean array in &lt;code&gt;condlist&lt;/code&gt; selects a piece of &lt;code&gt;x&lt;/code&gt;, and should therefore be of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condlist&lt;/code&gt; 의 각 부울 배열 은 &lt;code&gt;x&lt;/code&gt; 조각을 선택 하므로 &lt;code&gt;x&lt;/code&gt; 와 모양이 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="8fe6ffb6ecffd6c39387e8f0ab0c3a109b7064bf" translate="yes" xml:space="preserve">
          <source>Each built-in data-type has a character code (the updated Numeric typecodes), that uniquely identifies it.</source>
          <target state="translated">각 내장 데이터 유형에는 고유하게 식별하는 문자 코드 (업데이트 된 숫자 유형 코드)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a69a75e46ca3ac2d199e74b13f3b32f8dd1d6b80" translate="yes" xml:space="preserve">
          <source>Each differentiation is multiplied by &lt;code&gt;scl&lt;/code&gt;. The end result is multiplication by &lt;code&gt;scl**m&lt;/code&gt;. This is for use in a linear change of variable. (Default: 1)</source>
          <target state="translated">각 미분에 &lt;code&gt;scl&lt;/code&gt; 을 곱합니다 . 최종 결과는 &lt;code&gt;scl**m&lt;/code&gt; 곱하는 것 입니다. 변수의 선형 변경에 사용됩니다. (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="80d6286823e7a8996b335e27ee039bd71682bf33" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple.</source>
          <target state="translated">서명의 각 차원은 모양 튜플의 끝에서 시작하여 해당 전달 배열의 차원과 일치합니다.</target>
        </trans-unit>
        <trans-unit id="e3a7c87b9ea1dd98d592dea35e0511973a19c5ea" translate="yes" xml:space="preserve">
          <source>Each dimension in the signature is matched to a dimension of the corresponding passed-in array, starting from the end of the shape tuple. These are the core dimensions, and they must be present in the arrays, or an error will be raised.</source>
          <target state="translated">서명의 각 차원은 모양 튜플의 끝에서 시작하여 해당 전달 배열의 차원과 일치합니다. 이들은 핵심 치수이며 배열에 있어야합니다. 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f8fa7f34f98b652b735f9d41844bf81c524a5373" translate="yes" xml:space="preserve">
          <source>Each element of &lt;code&gt;a&lt;/code&gt; represents a bit-field that should be unpacked into a binary-valued output array. The shape of the output array is either 1-D (if &lt;code&gt;axis&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;) or the same shape as the input array with unpacking done along the axis specified.</source>
          <target state="translated">각각의 소자 &lt;code&gt;a&lt;/code&gt; 이진 - 값 출력으로 패킹 배열되어야 비트 필드를 나타낸다. 출력 배열의 모양은 1-D ( &lt;code&gt;axis&lt;/code&gt; 이 &lt;code&gt;None&lt;/code&gt; 인 경우 )이거나 지정된 축을 따라 압축을 푼 입력 배열과 같은 모양입니다.</target>
        </trans-unit>
        <trans-unit id="50237f597aa5c58319566769ed4e784a20d0c8c4" translate="yes" xml:space="preserve">
          <source>Each element of the sum of the &amp;lsquo;ipmt&amp;rsquo; and &amp;lsquo;ppmt&amp;rsquo; arrays should equal &amp;lsquo;pmt&amp;rsquo;.</source>
          <target state="translated">'ipmt'및 'ppmt'배열 합계의 각 요소는 'pmt'와 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="20a2380f652b4d55cd4c96370ca8c7d2de50620c" translate="yes" xml:space="preserve">
          <source>Each entry in the mymethods array is a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyMethodDef&quot;&gt;&lt;code&gt;PyMethodDef&lt;/code&gt;&lt;/a&gt; structure containing 1) the Python name, 2) the C-function that implements the function, 3) flags indicating whether or not keywords are accepted for this function, and 4) The docstring for the function. Any number of functions may be defined for a single module by adding more entries to this table. The last entry must be all NULL as shown to act as a sentinel. Python looks for this entry to know that all of the functions for the module have been defined.</source>
          <target state="translated">mymethods 배열의 각 항목은 1) Python 이름, 2) 함수를 구현하는 C 함수, 3)이 함수에 대해 키워드가 허용되는지 여부를 나타내는 플래그 및 4) 함수에 대한 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyMethodDef&quot;&gt; &lt;code&gt;PyMethodDef&lt;/code&gt; &lt;/a&gt; 포함 하는 PyMethodDef 구조입니다. . 이 테이블에 더 많은 항목을 추가하여 단일 모듈에 대해 원하는 수의 함수를 정의 할 수 있습니다. 마지막 항목은 센티널로 작동하도록 표시된대로 모두 NULL이어야합니다. Python은 모듈의 모든 함수가 정의되었는지 확인하기 위해이 항목을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="0f33bf09c046e31c2241219b2051cb5ec2d5021c" translate="yes" xml:space="preserve">
          <source>Each entry will be the default for the corresponding column</source>
          <target state="translated">각 항목은 해당 열의 기본값이됩니다.</target>
        </trans-unit>
        <trans-unit id="6596e910451a16280ea499b967185410396fa721" translate="yes" xml:space="preserve">
          <source>Each function is evaluated over &lt;code&gt;x&lt;/code&gt; wherever its corresponding condition is True. It should take a 1d array as input and give an 1d array or a scalar value as output. If, instead of a callable, a scalar is provided then a constant function (&lt;code&gt;lambda x: scalar&lt;/code&gt;) is assumed.</source>
          <target state="translated">각 함수는 해당 조건이 True 인 경우 &lt;code&gt;x&lt;/code&gt; 에 대해 평가 됩니다. 1d 배열을 입력으로 사용하고 1d 배열 또는 스칼라 값을 출력으로 제공해야합니다. 호출 가능 함수 대신 스칼라가 제공되면 상수 함수 ( &lt;code&gt;lambda x: scalar&lt;/code&gt; )가 가정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d8deda694e466984ce525e906c00ea4f5dea09d" translate="yes" xml:space="preserve">
          <source>Each generalized ufunc has information associated with it that states what the &amp;ldquo;core&amp;rdquo; dimensionality of the inputs is, as well as the corresponding dimensionality of the outputs (the element-wise ufuncs have zero core dimensions). The list of the core dimensions for all arguments is called the &amp;ldquo;signature&amp;rdquo; of a ufunc. For example, the ufunc numpy.add has signature &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; defining two scalar inputs and one scalar output.</source>
          <target state="translated">각 일반화 된 ufunc에는 입력의 &quot;핵심&quot;차원이 무엇인지, 출력의 해당 차원 (요소 별 ufunc가 0의 핵심 차원을 가짐)을 나타내는 정보가 있습니다. 모든 인수의 핵심 차원 목록을 ufunc의 &quot;서명&quot;이라고합니다. 예를 들어, ufunc numpy.add에는 두 개의 스칼라 입력과 하나의 스칼라 출력을 정의하는 서명 &lt;code&gt;(),()-&amp;gt;()&lt;/code&gt; 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="93ff2ff5db4665bc2536253e2cbc256cc6ee369b" translate="yes" xml:space="preserve">
          <source>Each item is used as an &amp;ldquo;op_axes&amp;rdquo; argument to an nditer</source>
          <target state="translated">각 항목은 nditer에 대한 &quot;op_axes&quot;인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6515db7940afb238e42bf63e06ca75d53b616e9e" translate="yes" xml:space="preserve">
          <source>Each key can be a column index or a column name, and the corresponding value should be a single object. We can use the special key &lt;code&gt;None&lt;/code&gt; to define a default for all columns.</source>
          <target state="translated">각 키는 열 인덱스 또는 열 이름 일 수 있으며 해당 값은 단일 개체 여야합니다. 특수 키 &lt;code&gt;None&lt;/code&gt; 을 사용하여 모든 열에 대한 기본값을 정의 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="83888ab60bad511e4b53bdc1db03bb5f1c808f79" translate="yes" xml:space="preserve">
          <source>Each line past the first &lt;code&gt;skip_header&lt;/code&gt; lines is split at the &lt;code&gt;delimiter&lt;/code&gt; character, and characters following the &lt;code&gt;comments&lt;/code&gt; character are discarded.</source>
          <target state="translated">첫 번째 &lt;code&gt;skip_header&lt;/code&gt; 행을 지나는 각 행 은 &lt;code&gt;delimiter&lt;/code&gt; 문자로 분할되며 &lt;code&gt;comments&lt;/code&gt; 문자 다음의 문자는 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="af447abfb761a63b2a173a6fe4db497d82a1d986" translate="yes" xml:space="preserve">
          <source>Each module should have a docstring with at least a summary line. Other sections are optional, and should be used in the same order as for documenting functions when they are appropriate:</source>
          <target state="translated">각 모듈에는 최소한 요약 줄이있는 독 스트링이 있어야합니다. 다른 섹션은 선택 사항이며 적절한 경우 기능을 문서화 할 때와 동일한 순서로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="13efd9029e94adb763eb953172be3877d35b0214" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="translated">각 산술 연산 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;divmod()&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 또는 &lt;code&gt;pow()&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; ) 및 비교 ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; ) 상응하는 범용 기능 (또는 동등 &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; NumPy와 짧은 경우). 자세한 내용은 다음 섹션을 참조하십시오.&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;범용 기능&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3956c5acda082528edb0dd788f86e08b90ce29c7" translate="yes" xml:space="preserve">
          <source>Each of the arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, &lt;code&gt;divmod()&lt;/code&gt;, &lt;code&gt;**&lt;/code&gt; or &lt;code&gt;pow()&lt;/code&gt;, &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;~&lt;/code&gt;) and the comparisons (&lt;code&gt;==&lt;/code&gt;, &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;) is equivalent to the corresponding universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) in NumPy. For more information, see the section on &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;Universal Functions&lt;/a&gt;.</source>
          <target state="translated">각 산술 연산 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;/&lt;/code&gt; , &lt;code&gt;//&lt;/code&gt; , &lt;code&gt;%&lt;/code&gt; , &lt;code&gt;divmod()&lt;/code&gt; , &lt;code&gt;**&lt;/code&gt; 또는 &lt;code&gt;pow()&lt;/code&gt; , &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;~&lt;/code&gt; ) 및 비교 ( &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; ) 상응하는 범용 기능 (또는 동등 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; NumPy와 짧은 경우). 자세한 내용은 섹션을 참조하십시오&lt;a href=&quot;ufuncs#ufuncs&quot;&gt;범용 함수&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce900752c03b63d004b95034fc7fe45e45781bb2" translate="yes" xml:space="preserve">
          <source>Each of these 12 classes is collected into a &lt;code&gt;unittest.TestSuite&lt;/code&gt;, which is then executed. Errors and failures are summed together and returned as the exit argument. Any non-zero result indicates that at least one test did not pass.</source>
          <target state="translated">이 12 개의 클래스 각각은 &lt;code&gt;unittest.TestSuite&lt;/code&gt; 에 수집되어 실행됩니다. 오류와 실패가 합산되어 종료 인수로 리턴됩니다. 0이 아닌 결과는 하나 이상의 테스트가 통과되지 않았 음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="534d5807de7d2badcef1e7e804770614e9153a49" translate="yes" xml:space="preserve">
          <source>Each of these sub-topics is covered in the following sub-sections.</source>
          <target state="translated">이러한 각 하위 주제는 다음 하위 섹션에서 다룹니다.</target>
        </trans-unit>
        <trans-unit id="f67c4cfb6e2d44f4338462a5c73308f6ff60ab98" translate="yes" xml:space="preserve">
          <source>Each row in the text file must have the same number of values.</source>
          <target state="translated">텍스트 파일의 각 행은 같은 수의 값을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="8b09b89b09738ea85b440f6b9b0782f598ebe968" translate="yes" xml:space="preserve">
          <source>Each sequence should be of integer or boolean type. Boolean sequences will be interpreted as boolean masks for the corresponding dimension (equivalent to passing in &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt;).</source>
          <target state="translated">각 시퀀스는 정수 또는 부울 유형이어야합니다. 부울 시퀀스는 해당 차원에 대한 부울 마스크로 해석됩니다 ( &lt;code&gt;np.nonzero(boolean_sequence)&lt;/code&gt; 전달과 동일 ).</target>
        </trans-unit>
        <trans-unit id="b117b16ba13396092e447a51f24074ff2e6bd854" translate="yes" xml:space="preserve">
          <source>Each test defined by the &lt;code&gt;VectorTestCase&lt;/code&gt; class extracts the python function it is trying to test by accessing the &lt;code&gt;Vector&lt;/code&gt; module&amp;rsquo;s dictionary:</source>
          <target state="translated">&lt;code&gt;VectorTestCase&lt;/code&gt; 클래스로 정의 된 각 테스트 는 &lt;code&gt;Vector&lt;/code&gt; 모듈의 사전 에 액세스하여 테스트하려는 Python 함수를 추출합니다 .</target>
        </trans-unit>
        <trans-unit id="6083c3d38cbd0a21c59fda4f10850fe83ec68a22" translate="yes" xml:space="preserve">
          <source>Each tuple has the form &lt;code&gt;(fieldname, datatype, shape)&lt;/code&gt; where shape is optional. &lt;code&gt;fieldname&lt;/code&gt; is a string (or tuple if titles are used, see &lt;a href=&quot;#titles&quot;&gt;Field Titles&lt;/a&gt; below), &lt;code&gt;datatype&lt;/code&gt; may be any object convertible to a datatype, and &lt;code&gt;shape&lt;/code&gt; is a tuple of integers specifying subarray shape.</source>
          <target state="translated">각 튜플은 형태 &lt;code&gt;(fieldname, datatype, shape)&lt;/code&gt; 를 가지며 형태는 선택 사항입니다. &lt;code&gt;fieldname&lt;/code&gt; 은 문자열 (또는 제목이 사용되는 경우 튜플, 아래 &lt;a href=&quot;#titles&quot;&gt;필드 제목&lt;/a&gt; 참조)이고, &lt;code&gt;datatype&lt;/code&gt; 은 데이터 유형으로 변환 할 수있는 모든 객체 일 수 있으며, &lt;code&gt;shape&lt;/code&gt; 는 하위 배열 모양을 지정하는 정수의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="a7730362892427e71964e48c12006a9cf86055b3" translate="yes" xml:space="preserve">
          <source>Each ufunc consists of an elementary function that performs the most basic operation on the smallest portion of array arguments (e.g. adding two numbers is the most basic operation in adding two arrays). The ufunc applies the elementary function multiple times on different parts of the arrays. The input/output of elementary functions can be vectors; e.g., the elementary function of inner1d takes two vectors as input.</source>
          <target state="translated">각 ufunc는 배열 인수의 가장 작은 부분에서 가장 기본적인 작업을 수행하는 기본 함수로 구성됩니다 (예 : 두 개의 숫자를 추가하는 것이 두 개의 배열을 추가하는 가장 기본적인 작업). ufunc는 기본 기능을 배열의 다른 부분에 여러 번 적용합니다. 기본 함수의 입력 / 출력은 벡터 일 수 있습니다. 예를 들어 inner1d의 기본 함수는 두 벡터를 입력으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="cb1cf57d2ff93f75da1bd8ea2b2acd61c3fea8cd" translate="yes" xml:space="preserve">
          <source>Each universal function takes array inputs and produces array outputs by performing the core function element-wise on the inputs (where an element is generally a scalar, but can be a vector or higher-order sub-array for generalized ufuncs). Standard broadcasting rules are applied so that inputs not sharing exactly the same shapes can still be usefully operated on. Broadcasting can be understood by four rules:</source>
          <target state="translated">각 범용 함수는 입력에 대해 요소 별 핵심 기능을 수행하여 배열 입력을 가져 와서 배열 출력을 생성합니다 (여기서 요소는 일반적으로 스칼라이지만 일반화 된 ufunc의 경우 벡터 또는 상위 차수 배열 일 수 있음). 정확히 동일한 모양을 공유하지 않는 입력을 여전히 유용하게 사용할 수 있도록 표준 브로드 캐스트 규칙이 적용됩니다. 방송은 다음 네 가지 규칙으로 이해할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="778a8f870adb20070c9bbd4345579e90072a320d" translate="yes" xml:space="preserve">
          <source>Easier setup and teardown functions / methods</source>
          <target state="translated">보다 쉬운 설정 및 분해 기능 / 방법</target>
        </trans-unit>
        <trans-unit id="2797646a63f7af5bb42f88a4088468f8dc30c1ee" translate="yes" xml:space="preserve">
          <source>Edit pavement.py and setup.py as detailed in HOWTO_RELEASE:</source>
          <target state="translated">HOWTO_RELEASE에 설명 된대로 pavement.py 및 setup.py를 편집합니다.</target>
        </trans-unit>
        <trans-unit id="2810e44da03a82e21b0a6385cc2c1eef5fd13ec6" translate="yes" xml:space="preserve">
          <source>Edit the &lt;code&gt;azure/posix.yml&lt;/code&gt; and &lt;code&gt;azure/windows.yml&lt;/code&gt; files to make sure they have the correct version, and put in the commit hash for the &lt;code&gt;REL&lt;/code&gt; commit created above for &lt;code&gt;BUILD_COMMIT&lt;/code&gt;, see an _example:</source>
          <target state="translated">&lt;code&gt;azure/posix.yml&lt;/code&gt; 및 &lt;code&gt;azure/windows.yml&lt;/code&gt; 파일을 편집하여 올바른 버전인지 확인하고 &lt;code&gt;BUILD_COMMIT&lt;/code&gt; 에 대해 위에서 만든 &lt;code&gt;REL&lt;/code&gt; 커밋 에 대한 커밋 해시를 입력합니다. _example 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="c7e9fb2ea6c3b8c3ce97645eb902c348d859f36d" translate="yes" xml:space="preserve">
          <source>Editor</source>
          <target state="translated">Editor</target>
        </trans-unit>
        <trans-unit id="b623d8fa968a5e7902b11f4b307e302e26ca5a2b" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">&lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 인수의 효과 .</target>
        </trans-unit>
        <trans-unit id="93d5c22f934ab8df1b20f8c3472b63bf839853fa" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">의 효과 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 인수의.</target>
        </trans-unit>
        <trans-unit id="b16a3ec6ab9f466c4d89051f80bac7ab3d7a2dde" translate="yes" xml:space="preserve">
          <source>Effect of the &lt;code&gt;shrink&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;shrink&lt;/code&gt; 매개 변수의 영향 .</target>
        </trans-unit>
        <trans-unit id="15b4ace616414347d2dd3d2801314c174bc7ba08" translate="yes" xml:space="preserve">
          <source>Effectively, this implements:</source>
          <target state="translated">효과적으로 다음을 구현합니다.</target>
        </trans-unit>
        <trans-unit id="76eeaec1ccfef9304ec0a31b036423f1378c5288" translate="yes" xml:space="preserve">
          <source>Efficient</source>
          <target state="translated">Efficient</target>
        </trans-unit>
        <trans-unit id="2b4d17c36c1ff28a27a4b2931f3e20dd1dbef5a2" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays.</source>
          <target state="translated">배열을 반복하는 효율적인 다차원 반복자 객체.</target>
        </trans-unit>
        <trans-unit id="7e03cfade90e6c295c76156a8e2c563a63efa318" translate="yes" xml:space="preserve">
          <source>Efficient multi-dimensional iterator object to iterate over arrays. To get started using this object, see the &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;introductory guide to array iteration&lt;/a&gt;.</source>
          <target state="translated">배열을 반복하는 효율적인 다차원 반복자 객체. 이 객체를 사용하려면 &lt;a href=&quot;../arrays.nditer#arrays-nditer&quot;&gt;배열 반복에&lt;/a&gt; 대한 소개 안내서를 참조하십시오. .</target>
        </trans-unit>
        <trans-unit id="036e376170c1d3906a5f0a04018619e235105dc6" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem (maximum number of candidate solutions to consider). The following special values are recognized:</source>
          <target state="translated">오버랩 문제를 해결하기 위해 노력합니다 (최대 후보 솔루션 수 고려). 다음과 같은 특수 값이 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="ab3820529f3b083c6a31ff8350ee28b11115b842" translate="yes" xml:space="preserve">
          <source>Effort to spend on solving the overlap problem. See &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;shares_memory&lt;/code&gt;&lt;/a&gt; for details. Default for &lt;code&gt;may_share_memory&lt;/code&gt; is to do a bounds check.</source>
          <target state="translated">오버랩 문제를 해결하기 위해 노력합니다. 자세한 내용은 &lt;a href=&quot;numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;shares_memory&lt;/code&gt; &lt;/a&gt; 를 참조하십시오. &lt;code&gt;may_share_memory&lt;/code&gt; 의 기본값 은 범위 검사를 수행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="444baf679021343f134e3ab4afdb77852c13f5b7" translate="yes" xml:space="preserve">
          <source>Einstein summation convention.</source>
          <target state="translated">아인슈타인 요약 협약.</target>
        </trans-unit>
        <trans-unit id="9e7269d88813a122dd6b4c8836b591f55f6ef940" translate="yes" xml:space="preserve">
          <source>Einsum</source>
          <target state="translated">Einsum</target>
        </trans-unit>
        <trans-unit id="b7f8aa394c8c17e22a13e4ec50ff49bf4fdd395d" translate="yes" xml:space="preserve">
          <source>Einsum optimization path updates and efficiency improvements</source>
          <target state="translated">Einsum 최적화 경로 업데이트 및 효율성 개선</target>
        </trans-unit>
        <trans-unit id="5f574da7dabc16cec8dc28f2e16dcdf93d39e214" translate="yes" xml:space="preserve">
          <source>Either &amp;lsquo;inv&amp;rsquo; or &amp;lsquo;zig&amp;rsquo;. &amp;lsquo;inv&amp;rsquo; uses the default inverse CDF method. &amp;lsquo;zig&amp;rsquo; uses the much faster Ziggurat method of Marsaglia and Tsang.</source>
          <target state="translated">'inv'또는 'zig'입니다. 'inv'는 기본 역 CDF 방법을 사용합니다. 'zig'는 Marsaglia와 Tsang의 훨씬 빠른 Ziggurat 방법을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e2ca0218b13b60d8d85cfba18d0bd0af6e320c32" translate="yes" xml:space="preserve">
          <source>Either &lt;a href=&quot;ufunc#c.PyUFunc_One&quot;&gt;&lt;code&gt;PyUFunc_One&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_Zero&quot;&gt;&lt;code&gt;PyUFunc_Zero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_MinusOne&quot;&gt;&lt;code&gt;PyUFunc_MinusOne&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_None&quot;&gt;&lt;code&gt;PyUFunc_None&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_ReorderableNone&quot;&gt;&lt;code&gt;PyUFunc_ReorderableNone&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt;&lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;&lt;/a&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">&lt;a href=&quot;ufunc#c.PyUFunc_One&quot;&gt; &lt;code&gt;PyUFunc_One&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ufunc#c.PyUFunc_Zero&quot;&gt; &lt;code&gt;PyUFunc_Zero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ufunc#c.PyUFunc_MinusOne&quot;&gt; &lt;code&gt;PyUFunc_MinusOne&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ufunc#c.PyUFunc_None&quot;&gt; &lt;code&gt;PyUFunc_None&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ufunc#c.PyUFunc_ReorderableNone&quot;&gt; &lt;code&gt;PyUFunc_ReorderableNone&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt; &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; &lt;/a&gt; 중 하나 는이 작업의 ID를 나타냅니다. 빈 배열에 대한 축소 형 호출에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="41ec8a6c5a0f22c1b241625049fb5165828e9c89" translate="yes" xml:space="preserve">
          <source>Either &lt;a href=&quot;ufunc#c.PyUFunc_One&quot;&gt;&lt;code&gt;PyUFunc_One&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_Zero&quot;&gt;&lt;code&gt;PyUFunc_Zero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;ufunc#c.PyUFunc_None&quot;&gt;&lt;code&gt;PyUFunc_None&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">어느 &lt;a href=&quot;ufunc#c.PyUFunc_One&quot;&gt; &lt;code&gt;PyUFunc_One&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ufunc#c.PyUFunc_Zero&quot;&gt; &lt;code&gt;PyUFunc_Zero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;ufunc#c.PyUFunc_None&quot;&gt; &lt;code&gt;PyUFunc_None&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; 는 이 작업에 대한 정체성을 나타냅니다. 빈 배열에 대한 축소 형 호출에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="492b328dfec8dad5745f3d5a1dcefdef27066686" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule *&lt;/code&gt;&lt;/a&gt; and keyed by the data-type number.</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 기능에 대한 사용자 - 캐스팅 사전 함유 저수준 데이터 타입을 정의. 각 함수는 &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule *&lt;/code&gt; &lt;/a&gt; 로 래핑되고 데이터 유형 번호로 키가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="f248b6168fbf2f57439344bf599f0d52d7a807c7" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or a dictionary containing low-level casting functions for user- defined data-types. Each function is wrapped in a &lt;code&gt;PyCObject *&lt;/code&gt; and keyed by the data-type number.</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 기능에 대한 사용자 - 캐스팅 사전 함유 저수준 데이터 타입을 정의. 각 함수는 &lt;code&gt;PyCObject *&lt;/code&gt; 에 싸여 있으며 데이터 유형 번호로 키가 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="cd680ae51259fbdc5100a31577a59d7a7923df2f" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 배열 &lt;a href=&quot;array#c.NPY_NSCALARKINDS&quot;&gt; &lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt; 의&lt;/a&gt; 포인터. 이러한 포인터는 각각 &lt;code&gt;NULL&lt;/code&gt; 이거나 지정된 종류의이 데이터 유형의 스칼라가 안전하게 캐스팅 될 수있는 데이터 유형을 나타내는 정수 배열 ( &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; 로&lt;/a&gt; 종료 됨 )에 대한 포인터 여야 합니다 (일반적으로 정밀도를 잃지 않음을 의미 함).</target>
        </trans-unit>
        <trans-unit id="ff36def358c4174701abf75ea4d4e0cdcf5bd477" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt;&lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt;&lt;/a&gt; pointers. These pointers should each be either &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt;) indicating data-types that a scalar of this data-type of the specified kind can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 배열 &lt;a href=&quot;c-api.array#c.NPY_NSCALARKINDS&quot;&gt; &lt;code&gt;NPY_NSCALARKINDS&lt;/code&gt; 의&lt;/a&gt; 포인터. 이러한 포인터는 각각 &lt;code&gt;NULL&lt;/code&gt; 이거나 지정된 종류의이 데이터 유형의 스칼라를 안전하게 캐스트 할 수 있음을 나타내는 데이터 유형을 나타내는 정수 배열 ( &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; 로&lt;/a&gt; 종료 됨 )에 대한 포인터 여야 합니다 (일반적으로 정밀도를 잃지 않고 의미 함).</target>
        </trans-unit>
        <trans-unit id="9b68604ef80074abda088f5c021808f55b2ed04d" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 (종료 정수 배열 &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; 는&lt;/a&gt; )이 데이터 유형 (정밀도의 손실없이 일반적으로 의미 함)로 안전하게 전송할 수 있다는 데이터 타입을 표시.</target>
        </trans-unit>
        <trans-unit id="8a8e73551f33a77ec9147f05121309347af67814" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;NULL&lt;/code&gt; or an array of integers (terminated by &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; ) indicated data-types that this data-type can be cast to safely (this usually means without losing precision).</source>
          <target state="translated">어느 &lt;code&gt;NULL&lt;/code&gt; 또는 (종료 정수 배열 &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; 는&lt;/a&gt; )이 데이터 유형 (정밀도의 손실없이 일반적으로 의미 함)로 안전하게 전송할 수 있다는 데이터 타입을 표시.</target>
        </trans-unit>
        <trans-unit id="fc708da248f7fca21989577f01a71025bc8ff72a" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; or a readonly dictionary of metadata (mappingproxy).</source>
          <target state="translated">어느 &lt;code&gt;None&lt;/code&gt; 또는 메타 데이터 (mappingproxy)의 판독 전용 사전.</target>
        </trans-unit>
        <trans-unit id="a72bcd252074f5791eeadc9caadcb597a823dbdd" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;). As with shape, the values may be larger than can be represented by a C &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;long long&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is &lt;code&gt;(10, 20, 30)&lt;/code&gt; would be &lt;code&gt;(4800, 240, 8)&lt;/code&gt;</source>
          <target state="translated">어느 &lt;code&gt;None&lt;/code&gt; C 스타일 연속 배열 또는 해당 치수 다음 배열 요소로 이동하는데 필요한 바이트의 수를 제공하는 진보 터플을 표시 없음. 각 항목은 정수 여야합니다 (Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; ). 모양과 마찬가지로 값은 C &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 으로 나타낼 수있는 것보다 클 수 있습니다 . 호출 코드는 오류를 발생 시키거나 C에서 &lt;code&gt;long long&lt;/code&gt; 을 사용하여이를 적절하게 처리해야합니다 . 기본값은 C 스타일의 연속 메모리 버퍼를 의미하는 &lt;code&gt;None&lt;/code&gt; 입니다. 이 모델에서는 배열의 마지막 차원이 가장 빠르게 변합니다. 예를 들어, 배열 항목의 길이가 8 바이트이고 모양이 &lt;code&gt;(10, 20, 30)&lt;/code&gt; 인 객체에 대한 기본 스트라이드 튜플입니다.될 것이다 &lt;code&gt;(4800, 240, 8)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="accffd1618e3de5c69c33d1510a23e42c114bdf3" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;None&lt;/code&gt; to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is &lt;code&gt;None&lt;/code&gt; which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="translated">어느 &lt;code&gt;None&lt;/code&gt; C 스타일 연속 배열 또는 해당 치수 다음 배열 요소로 이동하는데 필요한 바이트의 수를 제공하는 진보 터플을 표시 없음. 각 항목은 정수 여야합니다 (Python &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; ). 형상과 마찬가지로, 값은 C &quot;int&quot;또는 &quot;long&quot;으로 표현 될 수있는 것보다 클 수 있으며; 호출 코드는 오류를 발생 시키거나 C에서 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 을 사용하여이를 적절하게 처리해야합니다 . 기본값은 &lt;code&gt;None&lt;/code&gt; 이며 C 스타일의 연속 메모리 버퍼를 의미합니다. 이 모델에서는 배열의 마지막 차원이 가장 빠르게 변합니다. 예를 들어 배열 항목의 길이가 8 바이트이고 모양이 (10,20,30) 인 객체의 기본 보폭은 튜플입니다 (4800, 240, 8).</target>
        </trans-unit>
        <trans-unit id="2e35b148ce133a87759db1169ada9bc7afe8b136" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_None&lt;/code&gt; or &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; to indicate the identity for this operation. It is only used for a reduce-like call on an empty array.</source>
          <target state="translated">어느 &lt;code&gt;PyUFunc_One&lt;/code&gt; , &lt;code&gt;PyUFunc_Zero&lt;/code&gt; , &lt;code&gt;PyUFunc_None&lt;/code&gt; 또는 &lt;code&gt;PyUFunc_AllOnes&lt;/code&gt; 는 이 작업에 대한 정체성을 나타냅니다. 빈 배열에서 축소 형 호출에만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fb67ce0cbc08322db9293cceafb38eefe75acb01" translate="yes" xml:space="preserve">
          <source>Either None to indicate a C-style contiguous array or a Tuple of strides which provides the number of bytes needed to jump to the next array element in the corresponding dimension. Each entry must be an integer (a Python &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt;). As with shape, the values may be larger than can be represented by a C &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo;; the calling code should handle this appropriately, either by raising an error, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; in C. The default is None which implies a C-style contiguous memory buffer. In this model, the last dimension of the array varies the fastest. For example, the default strides tuple for an object whose array entries are 8 bytes long and whose shape is (10,20,30) would be (4800, 240, 8)</source>
          <target state="translated">None은 C 스타일 연속 배열을 나타내거나 해당 차원의 다음 배열 요소로 점프하는 데 필요한 바이트 수를 제공하는 튜플 스트라이드를 나타냅니다. 각 항목은 정수 여야합니다 (Python &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; ). 모양과 마찬가지로 값은 C &quot;int&quot;또는 &quot;long&quot;으로 나타낼 수있는 것보다 클 수 있습니다. 호출 코드는 오류를 발생 시키거나 C에서 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 을 사용하여이를 적절하게 처리해야합니다 . 기본값은 C 스타일의 연속 메모리 버퍼를 의미하는 None입니다. 이 모델에서는 배열의 마지막 차원이 가장 빠르게 변합니다. 예를 들어, 배열 항목의 길이가 8 바이트이고 모양이 (10,20,30) 인 객체에 대한 기본 strides 튜플은 (4800, 240, 8)입니다.</target>
        </trans-unit>
        <trans-unit id="987f54d54272ffd5f21f8146bd411a9086f8f96d" translate="yes" xml:space="preserve">
          <source>Either a basic-type description string as in &lt;em&gt;typestr&lt;/em&gt; or another list (for nested structured types)</source>
          <target state="translated">&lt;em&gt;typestr&lt;/em&gt; 또는 다른 목록 과 같은 기본 유형 설명 문자열 (중첩 구조화 된 유형의 경우)</target>
        </trans-unit>
        <trans-unit id="e36f94dd4a5bc304e7b8e5a337101261c2694c11" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="translated">데이터 유형, 데이터 유형의 튜플 또는 ufunc의 입력 및 출력 유형을 나타내는 특수 서명 문자열입니다. 이 인수를 사용하면 1-d 루프가 기본 계산에 사용할 특정 서명을 제공 할 수 있습니다. 지정된 루프가 ufunc에 대해 존재하지 않으면 TypeError가 발생합니다. 일반적으로 입력 유형을 사용 가능한 것과 비교하고 모든 입력을 안전하게 캐스트 할 수있는 데이터 유형이있는 루프를 검색하면 적합한 루프가 자동으로 발견됩니다. 이 키워드 인수를 사용하면 해당 검색을 무시하고 특정 루프를 선택할 수 있습니다. 사용 가능한 서명 목록은 ufunc 객체 의 &lt;strong&gt;types&lt;/strong&gt; 속성에 의해 제공됩니다 . 이전 버전과의 호환성을 위해이 인수를 &lt;em&gt;sig&lt;/em&gt; 로 제공 할 수도 있습니다.&lt;em&gt;&lt;/em&gt;긴 형태가 바람직하지만. 이것은 ufunc 객체 의 &lt;strong&gt;signature&lt;/strong&gt; 속성에 저장된 일반화 된 ufunc &lt;a href=&quot;c-api.generalized-ufuncs#details-of-signature&quot;&gt;서명&lt;/a&gt; 과 혼동되어서는 안됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7610b5a110dcd0d84cf907684a00201bedfda50b" translate="yes" xml:space="preserve">
          <source>Either a data-type, a tuple of data-types, or a special signature string indicating the input and output types of a ufunc. This argument allows you to provide a specific signature for the 1-d loop to use in the underlying calculation. If the loop specified does not exist for the ufunc, then a TypeError is raised. Normally, a suitable loop is found automatically by comparing the input types with what is available and searching for a loop with data-types to which all inputs can be cast safely. This keyword argument lets you bypass that search and choose a particular loop. A list of available signatures is provided by the &lt;strong&gt;types&lt;/strong&gt; attribute of the ufunc object. For backwards compatibility this argument can also be provided as &lt;em&gt;sig&lt;/em&gt;, although the long form is preferred. Note that this should not be confused with the generalized ufunc &lt;a href=&quot;c-api/generalized-ufuncs#details-of-signature&quot;&gt;signature&lt;/a&gt; that is stored in the &lt;strong&gt;signature&lt;/strong&gt; attribute of the of the ufunc object.</source>
          <target state="translated">데이터 유형, 데이터 유형의 튜플 또는 ufunc의 입력 및 출력 유형을 나타내는 특수 서명 문자열입니다. 이 인수를 사용하면 기본 계산에 사용할 1-d 루프에 대한 특정 서명을 제공 할 수 있습니다. 지정된 루프가 ufunc에 대해 존재하지 않으면 TypeError가 발생합니다. 일반적으로 입력 유형을 사용 가능한 것과 비교하고 모든 입력을 안전하게 캐스트 할 수있는 데이터 유형이있는 루프를 검색하여 적합한 루프를 자동으로 찾습니다. 이 키워드 인수를 사용하면 해당 검색을 우회하고 특정 루프를 선택할 수 있습니다. 사용 가능한 서명 목록은 ufunc 객체 의 &lt;strong&gt;types&lt;/strong&gt; 속성에 의해 제공됩니다 . 이전 버전과의 호환성을 위해이 인수는 &lt;em&gt;sig&lt;/em&gt; 로도 제공 될 수 있습니다.&lt;em&gt;&lt;/em&gt;, 긴 형식이 선호되지만. 이것은 ufunc 객체 의 &lt;strong&gt;서명&lt;/strong&gt; 속성에 저장된 일반화 된 ufunc &lt;a href=&quot;c-api/generalized-ufuncs#details-of-signature&quot;&gt;서명&lt;/a&gt; 과 혼동해서는 안됩니다 .&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1f29d08a7419982e08310d39c2c6ccec8145ca66" translate="yes" xml:space="preserve">
          <source>Either an opaque sequence of bytes, or a structure.</source>
          <target state="translated">불투명 한 바이트 시퀀스 또는 구조입니다.</target>
        </trans-unit>
        <trans-unit id="e5f7cfaaf00ef2a9d08f1fbf94a1102c83e776e0" translate="yes" xml:space="preserve">
          <source>Either commas or spaces can be used as a separator, e.g. &lt;code&gt;--cpu-dispatch&lt;/code&gt;= &amp;ldquo;avx2 avx512f&amp;rdquo; or &lt;code&gt;--cpu-dispatch&lt;/code&gt;= &amp;ldquo;avx2, avx512f&amp;rdquo; both work, but the arguments must be enclosed in quotes.</source>
          <target state="translated">쉼표 또는 공백을 구분 기호로 사용할 수 있습니다 (예 : &lt;code&gt;--cpu-dispatch&lt;/code&gt; = &quot;avx2 avx512f&quot;또는 &lt;code&gt;--cpu-dispatch&lt;/code&gt; = &quot;avx2, avx512f&quot;). 둘 다 작동하지만 인수는 따옴표로 묶어야합니다.</target>
        </trans-unit>
        <trans-unit id="1e1209e0f0503ff7dc267174ecb081f65f265397" translate="yes" xml:space="preserve">
          <source>Either passing n arguments as in njoin(&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;), or a sequence of n names as in njoin([&amp;lsquo;a&amp;rsquo;,&amp;rsquo;b&amp;rsquo;]) is handled, or a mixture of such arguments.</source>
          <target state="translated">njoin ( 'a', 'b')에서와 같이 n 개의 인수를 전달하거나 njoin ([ 'a', 'b'])에서와 같이 n 개의 이름 시퀀스가 ​​처리되거나 이러한 인수의 혼합이 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="c7015ddb90f8a42ecbacfed5d690fb153cc71ff7" translate="yes" xml:space="preserve">
          <source>Either the file name (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the file name if it is not already there.</source>
          <target state="translated">파일 이름 (문자열) 또는 데이터가 저장 될 열린 파일 (파일과 같은 객체)입니다. 파일이 문자열 또는 경로 인 경우 파일 이름이 &lt;code&gt;.npz&lt;/code&gt; 인 경우 파일 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0f9fa4310da3a7c0b9cf42ac99c7003bdc5b813b" translate="yes" xml:space="preserve">
          <source>Either the filename (string) or an open file (file-like object) where the data will be saved. If file is a string or a Path, the &lt;code&gt;.npz&lt;/code&gt; extension will be appended to the filename if it is not already there.</source>
          <target state="translated">데이터가 저장 될 파일 이름 (문자열) 또는 열린 파일 (파일 유사 객체)입니다. 파일이 문자열이거나 경로 인 경우 &lt;code&gt;.npz&lt;/code&gt; 확장자가 아직없는 경우 파일 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="2953df344283c54bedef1d8e252fb3c96e667a80" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th element will be in its final sorted position and all smaller elements will be moved before it and all larger elements behind it. The order all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all of them into their sorted position at once.</source>
          <target state="translated">파티셔닝 할 요소 인덱스. k 번째 요소는 최종 정렬 위치에 있으며 모든 작은 요소는 요소와 그보다 큰 요소보다 먼저 이동합니다. 파티션의 모든 요소 순서는 정의되어 있지 않습니다. k 번째 시퀀스가 ​​제공되면 모든 항목을 한 번에 정렬 된 위치로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="603f2f92b6e79eef48a044dac1baeab309560ae3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The k-th value of the element will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of k-th it will partition all elements indexed by k-th of them into their sorted position at once.</source>
          <target state="translated">파티셔닝 할 요소 인덱스. 요소의 k 번째 값은 최종 정렬 위치에 있으며 모든 작은 요소는 요소와 그 이전의 요소와 같거나 큰 요소보다 먼저 이동합니다. 파티션의 모든 요소 순서는 정의되어 있지 않습니다. k 번째 시퀀스가 ​​제공되면 k 번째로 인덱스 된 모든 요소를 ​​한 번에 정렬 된 위치로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="dd1e5c082697760ec705616bbb818b3e3054f2a3" translate="yes" xml:space="preserve">
          <source>Element index to partition by. The kth element value will be in its final sorted position and all smaller elements will be moved before it and all equal or greater elements behind it. The order of all elements in the partitions is undefined. If provided with a sequence of kth it will partition all elements indexed by kth of them into their sorted position at once.</source>
          <target state="translated">파티셔닝 할 요소 인덱스. k 번째 요소 값은 최종 정렬 된 위치에 있으며 모든 작은 요소는 그 이전의 요소와 그 이전의 모든 같거나 큰 요소보다 먼저 이동합니다. 파티션의 모든 요소 순서는 정의되어 있지 않습니다. kth 시퀀스가 ​​제공되면 kth로 인덱스 된 모든 요소를 ​​한 번에 정렬 된 위치로 분할합니다.</target>
        </trans-unit>
        <trans-unit id="67afd821e881e618d2d3c592047caa6ab2545d17" translate="yes" xml:space="preserve">
          <source>Element-wise 2 to the power &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">요소 별 2의 거듭 제곱 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="adaf9e130e6f948876c40cb7079ab5374d49e139" translate="yes" xml:space="preserve">
          <source>Element-wise &lt;code&gt;x*x&lt;/code&gt;, of the same shape and dtype as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">소자 현명한 &lt;code&gt;x*x&lt;/code&gt; 와 동일한 형상의 DTYPE &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="808b6a2cc974757f97aaa854c54baffd849df5f9" translate="yes" xml:space="preserve">
          <source>Element-wise arc tangent of &lt;code&gt;x1/x2&lt;/code&gt; choosing the quadrant correctly.</source>
          <target state="translated">사분면을 올바르게 선택하는 &lt;code&gt;x1/x2&lt;/code&gt; 의 요소 별 아크 탄젠트 .</target>
        </trans-unit>
        <trans-unit id="2ac96759d5e7cde7bc053be626eb0c73009447e8" translate="yes" xml:space="preserve">
          <source>Element-wise exponential minus one: &lt;code&gt;out = exp(x) - 1&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">요소 별 지수에서 1을 뺀 값 : &lt;code&gt;out = exp(x) - 1&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2e24669e28a8f1555e04e187ba59f7b56eef5d74" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of array elements.</source>
          <target state="translated">요소 별 최대 배열 요소</target>
        </trans-unit>
        <trans-unit id="de0f8227b430f00f150f25df31d4c6130cd8dee1" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignores NaNs.</source>
          <target state="translated">최대 2 개의 요소 배열로 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="f0000ade51e0b31f8609d90f1fdd9bbd95746777" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 요소 별 최대 2 개의 배열.</target>
        </trans-unit>
        <trans-unit id="a0de4ef4fdf4c984be543486b8ef23d43631cea6" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagates NaNs.</source>
          <target state="translated">원소 배열 최대 2 개의 배열은 NaN을 전파합니다.</target>
        </trans-unit>
        <trans-unit id="bdcc1733a93ea05c9ded4af3bbc823384a01061c" translate="yes" xml:space="preserve">
          <source>Element-wise maximum of two arrays, propagating any NaNs.</source>
          <target state="translated">NaN을 전파하는 요소 별 최대 2 개의 배열.</target>
        </trans-unit>
        <trans-unit id="117fbbb294a3d3f4ec6bf9953291f0979ba3eb6d" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of array elements.</source>
          <target state="translated">요소 별 최소 배열 요소</target>
        </trans-unit>
        <trans-unit id="f10c8e11f8111bdb87b272aa363c7d5a87d2958e" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignores NaNs.</source>
          <target state="translated">원소 배열의 최소 배열은 NaN을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="0c1d7d39298313f44ede26ddbe99082deaf8d999" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, ignoring any NaNs.</source>
          <target state="translated">NaN을 무시하고 요소별로 최소 2 개의 배열.</target>
        </trans-unit>
        <trans-unit id="129e7a520fce7febf9e89723a4b3e31c307bd988" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagates NaNs.</source>
          <target state="translated">두 배열의 요소 별 최소값으로 NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="31ccb3abbc1e393d00365ccd1319992c54e9ed13" translate="yes" xml:space="preserve">
          <source>Element-wise minimum of two arrays, propagating any NaNs.</source>
          <target state="translated">NaN을 전파하는 요소 별 최소 두 배열.</target>
        </trans-unit>
        <trans-unit id="a664254a8e3d768c1b8ca8504a3064612680ed55" translate="yes" xml:space="preserve">
          <source>Element-wise quotient resulting from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">바닥 분할로 인한 요소 별 지수. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="35a0aab7c92a2f3f84b40cb7246ed8c1bcebd9a8" translate="yes" xml:space="preserve">
          <source>Element-wise remainder from floor division. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">층 분할에서 요소 별 나머지. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="41a18c5c80ce790e4ab72162c437f0a9d09ae712" translate="yes" xml:space="preserve">
          <source>Elementary Function</source>
          <target state="translated">초등학교 기능</target>
        </trans-unit>
        <trans-unit id="04982a80ae05d1b0cdf8cb6f954f5d90370c1f1a" translate="yes" xml:space="preserve">
          <source>Elements shapes must match along the appropriate axes (without broadcasting), but leading 1s will be prepended to the shape as necessary to make the dimensions match.</source>
          <target state="translated">요소 셰이프는 브로드 캐스트없이 적절한 축을 따라 일치해야하지만 크기를 일치시키기 위해 필요에 따라 선행 1이 셰이프 앞에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ec73af38a64af612d36b6b1e08ea284a14bd8798" translate="yes" xml:space="preserve">
          <source>Elements that roll beyond the last position are re-introduced at the first.</source>
          <target state="translated">마지막 위치를 넘어서는 요소는 처음에 다시 도입됩니다.</target>
        </trans-unit>
        <trans-unit id="8ec956445b767a135cb8c6d627b5a2dfeb02537d" translate="yes" xml:space="preserve">
          <source>Elements to compare for the maximum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">최대 값과 비교할 요소 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4ba7c2272413ef1378137b3e69e8b4722f8659b1" translate="yes" xml:space="preserve">
          <source>Elements to compare for the minimum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">최소값과 비교할 요소. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9e8abab19f9f30d5191cc6a3b1bfb4655adaf1d6" translate="yes" xml:space="preserve">
          <source>Elements to include in checking for all &lt;code&gt;True&lt;/code&gt; values. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">모든 &lt;code&gt;True&lt;/code&gt; 값 을 확인하는 데 포함 할 요소 입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="baed6c1f073a2301af822ae78ce7d33048b71602" translate="yes" xml:space="preserve">
          <source>Elements to include in checking for any &lt;code&gt;True&lt;/code&gt; values. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 값 을 확인하는 데 포함 할 요소 입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5dee40e38322984cf6e5bb9e0b8d13a7afd8f692" translate="yes" xml:space="preserve">
          <source>Elements to include in the mean. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">평균에 포함 할 요소입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9c0973f46abdf4cfdea56a1e0e2597c002a92fb2" translate="yes" xml:space="preserve">
          <source>Elements to include in the product. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">제품에 포함 할 요소 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="db67037af61f287a3c7e10f4e794f1153504a0c2" translate="yes" xml:space="preserve">
          <source>Elements to include in the standard deviation. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">표준 편차에 포함 할 요소입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="836bba81daa7bbfa24fcec9d876cd0ca01db1438" translate="yes" xml:space="preserve">
          <source>Elements to include in the sum. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">합계에 포함 할 요소입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="00cbe31d2f86ac70034928c7ab30b66d4ef0842f" translate="yes" xml:space="preserve">
          <source>Elements to include in the variance. See &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;reduce&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">분산에 포함 할 요소입니다. 자세한 내용은 &lt;a href=&quot;numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;reduce&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a68b36609400536b206e5ed8f4915662a0a2020b" translate="yes" xml:space="preserve">
          <source>Elements to sum.</source>
          <target state="translated">합계 할 요소</target>
        </trans-unit>
        <trans-unit id="680319fcdd621a03121d173370e025227fa7d8d6" translate="yes" xml:space="preserve">
          <source>Elementwise bit operations</source>
          <target state="translated">요소 별 비트 연산</target>
        </trans-unit>
        <trans-unit id="59a9a9f6dbe39b1cf060328792d82b4916bb1fe4" translate="yes" xml:space="preserve">
          <source>Email the editor of LWN to let them know of the release. Directions at: &lt;a href=&quot;https://lwn.net/op/FAQ.lwn#contact&quot;&gt;https://lwn.net/op/FAQ.lwn#contact&lt;/a&gt;</source>
          <target state="translated">LWN 편집자에게 이메일을 보내 릴리스를 알립니다. 오시는 길 : &lt;a href=&quot;https://lwn.net/op/FAQ.lwn#contact&quot;&gt;https://lwn.net/op/FAQ.lwn#contact&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="599d2acd649f524c65c4bd78c5dfde8f2b7d2eea" translate="yes" xml:space="preserve">
          <source>Emeritus members</source>
          <target state="translated">명예 회원</target>
        </trans-unit>
        <trans-unit id="975003171b5d10383f8baffd2a3aedbe6bfb0ccf" translate="yes" xml:space="preserve">
          <source>Emit py3kwarnings for division of integer arrays</source>
          <target state="translated">정수 배열을 나누기 위해 py3kwarnings를 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5b188c1a7743df45af55da550ee4905951a67f8f" translate="yes" xml:space="preserve">
          <source>Emphasize empathy for individuals rather than judging behavior, avoiding binary labels of &amp;ldquo;good&amp;rdquo; and &amp;ldquo;bad/evil&amp;rdquo;. Overt, clear-cut aggression and harassment exists and we will be address that firmly. But many scenarios that can prove challenging to resolve are those where normal disagreements devolve into unhelpful or harmful behavior from multiple parties. Understanding the full context and finding a path that re-engages all is hard, but ultimately the most productive for our community.</source>
          <target state="translated">행동을 판단하는 것보다 개인에 대한 공감을 강조하고 &quot;좋은&quot;및 &quot;나쁜 / 악&quot;이라는 이진 레이블을 피하십시오. 명백하고 분명한 공격과 괴롭힘이 존재하며 우리는이를 확고히 다룰 것입니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 그러나 해결하기 어려울 수있는 많은 시나리오는 정상적인 불일치가 여러 당사자의 도움이되지 않거나 해로운 행동으로 이어지는 경우입니다. 전체 컨텍스트를 이해하고 모두를 다시 참여시키는 경로를 찾는 것은 어렵지만 궁극적으로 커뮤니티에 가장 생산적인 작업입니다.</target>
        </trans-unit>
        <trans-unit id="777a53a52816c5597e4f366c2ef31bc0f2a213da" translate="yes" xml:space="preserve">
          <source>Empty array of the given shape and type.</source>
          <target state="translated">주어진 모양과 유형의 빈 배열.</target>
        </trans-unit>
        <trans-unit id="30b8b3469c24b495eeedeb9693c9bf36670e4dcd" translate="yes" xml:space="preserve">
          <source>Empty masked array modelled on an existing array.</source>
          <target state="translated">기존 어레이에서 모델링 된 빈 마스크 어레이.</target>
        </trans-unit>
        <trans-unit id="6985c4b0d668125594b4f0ca6436e1c86a0154e8" translate="yes" xml:space="preserve">
          <source>Empty masked array with all elements masked.</source>
          <target state="translated">모든 요소가 마스크 된 빈 마스크 된 배열.</target>
        </trans-unit>
        <trans-unit id="680b8e573f5c82aced131f36a223b41bb3352d25" translate="yes" xml:space="preserve">
          <source>Empty masked array with the properties of an existing array.</source>
          <target state="translated">기존 배열의 속성을 가진 빈 마스크 배열.</target>
        </trans-unit>
        <trans-unit id="45886aabb4d2355c3b829d3be8c1cca38e105c36" translate="yes" xml:space="preserve">
          <source>Enable AVX2/AVX512 at compile time</source>
          <target state="translated">컴파일 타임에 AVX2 / AVX512 활성화</target>
        </trans-unit>
        <trans-unit id="65a22a27f610f307bbbf5c559b252565ede4fe31" translate="yes" xml:space="preserve">
          <source>Enable multi-platform SIMD compiler optimizations</source>
          <target state="translated">다중 플랫폼 SIMD 컴파일러 최적화 활성화</target>
        </trans-unit>
        <trans-unit id="a122b7a065f1b0b6e65770d5576676e667e835a7" translate="yes" xml:space="preserve">
          <source>Enables support for iteration of sub-ranges of the full &lt;code&gt;iterindex&lt;/code&gt; range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;. Use the function &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt;&lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt;&lt;/a&gt; to specify a range for iteration.</source>
          <target state="translated">전체 &lt;code&gt;iterindex&lt;/code&gt; 범위 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; 의 하위 범위 반복을 지원합니다 . &lt;a href=&quot;#c.NpyIter_ResetToIterIndexRange&quot;&gt; &lt;code&gt;NpyIter_ResetToIterIndexRange&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 반복 범위를 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="0bc79001ca7d4881c81aec2ea04317198e31e1bd" translate="yes" xml:space="preserve">
          <source>Enables the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">지정된 배열 플래그를 활성화합니다. 이 함수는 유효성 검사를 수행하지 않으며 수행중인 작업을 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="2919970bd082897345d32d119a4800b54dae0c81" translate="yes" xml:space="preserve">
          <source>Encapsulate the functionality of functions and methods that take the axis= keyword and work properly with None as the axis argument. The input array is &lt;code&gt;obj&lt;/code&gt;, while &lt;code&gt;*axis&lt;/code&gt; is a converted integer (so that &amp;gt;=MAXDIMS is the None value), and &lt;code&gt;requirements&lt;/code&gt; gives the needed properties of &lt;code&gt;obj&lt;/code&gt;. The output is a converted version of the input so that requirements are met and if needed a flattening has occurred. On output negative values of &lt;code&gt;*axis&lt;/code&gt; are converted and the new value is checked to ensure consistency with the shape of &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">axis = 키워드를 사용하고 None을 axis 인수로 사용하는 함수 및 메서드의 기능을 캡슐화합니다. 입력 배열은 &lt;code&gt;obj&lt;/code&gt; 이고 &lt;code&gt;*axis&lt;/code&gt; 는 변환 된 정수 (&amp;gt; = MAXDIMS는 None 값임)이며 &lt;code&gt;requirements&lt;/code&gt; 은 &lt;code&gt;obj&lt;/code&gt; 의 필요한 속성을 제공합니다 . 출력은 변환 된 버전의 입력이므로 요구 사항이 충족되고 필요한 경우 병합이 발생합니다. 출력에서 &lt;code&gt;*axis&lt;/code&gt; 음수 값 이 변환되고 &lt;code&gt;obj&lt;/code&gt; 모양과 일관성을 유지하기 위해 새 값이 검사됩니다 .</target>
        </trans-unit>
        <trans-unit id="27ce22c6173324f95f01ae2e015c760af4bd2880" translate="yes" xml:space="preserve">
          <source>Enclose variables in single backticks. The colon must be preceded by a space, or omitted if the type is absent.</source>
          <target state="translated">변수를 단일 백틱으로 묶습니다. 콜론 앞에는 공백이 있어야하며 유형이없는 경우 생략해야합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="349d554a10586cdec500258debd97663d605504e" translate="yes" xml:space="preserve">
          <source>Encoding argument for text IO functions</source>
          <target state="translated">텍스트 IO 함수에 대한 인코딩 인수</target>
        </trans-unit>
        <trans-unit id="3fcbf1219e531263b67edb6bcb90e0e603ad6031" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams.</source>
          <target state="translated">입력 파일을 디코딩하는 데 사용되는 인코딩 입력 스트림에는 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b27e46c5a085977e5cb88681f8a881b52c0fec71" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply to input streams. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes &amp;lsquo;latin1&amp;rsquo; encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">입력 파일을 디코딩하는 데 사용되는 인코딩 입력 스트림에는 적용되지 않습니다. 특수 값 'bytes'는 가능한 경우 결과로 바이트 배열을 수신하고 'latin1'인코딩 문자열을 변환기에 전달하는 이전 버전과의 호환성 해결 방법을 가능하게합니다. 유니 코드 배열을 수신하고 문자열을 변환기에 입력으로 전달하려면이 값을 대체하십시오. None으로 설정하면 시스템 기본값이 사용됩니다. 기본값은 '바이트'입니다.</target>
        </trans-unit>
        <trans-unit id="6776a87f17cb7165db7de968828852a089f8cd2b" translate="yes" xml:space="preserve">
          <source>Encoding used to decode the inputfile. Does not apply when &lt;code&gt;fname&lt;/code&gt; is a file object. The special value &amp;lsquo;bytes&amp;rsquo; enables backward compatibility workarounds that ensure that you receive byte arrays when possible and passes latin1 encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is &amp;lsquo;bytes&amp;rsquo;.</source>
          <target state="translated">입력 파일을 디코딩하는 데 사용되는 인코딩 &lt;code&gt;fname&lt;/code&gt; 이 파일 객체 인 경우에는 적용되지 않습니다 . 특수 값 'bytes'는 가능한 경우 바이트 배열을 수신하고 latin1로 인코딩 된 문자열을 변환기에 전달할 수 있도록 이전 버전과의 호환성 해결 방법을 가능하게합니다. 유니 코드 배열을 수신하고 문자열을 변환기에 입력으로 전달하려면이 값을 대체하십시오. None으로 설정하면 시스템 기본값이 사용됩니다. 기본값은 '바이트'입니다.</target>
        </trans-unit>
        <trans-unit id="8e2939a9752e2c7114a267e7bcdaebdf8d9a69e0" translate="yes" xml:space="preserve">
          <source>Encoding used to encode the outputfile. Does not apply to output streams. If the encoding is something other than &amp;lsquo;bytes&amp;rsquo; or &amp;lsquo;latin1&amp;rsquo; you will not be able to load the file in NumPy versions &amp;lt; 1.14. Default is &amp;lsquo;latin1&amp;rsquo;.</source>
          <target state="translated">출력 파일을 인코딩하는 데 사용되는 인코딩 출력 스트림에는 적용되지 않습니다. 인코딩이 'bytes'또는 'latin1'이외의 다른 경우 NumPy 버전 &amp;lt;1.14에서 파일을로드 할 수 없습니다. 기본값은 'latin1'입니다.</target>
        </trans-unit>
        <trans-unit id="672959489089d143587fef9e4d4ad09fb66e2197" translate="yes" xml:space="preserve">
          <source>End of interval. The interval does not include this value, except in some cases where &lt;code&gt;step&lt;/code&gt; is not an integer and floating point round-off affects the length of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">간격 끝 &lt;code&gt;step&lt;/code&gt; 가 정수가 아니고 부동 소수점 반올림이 &lt;code&gt;out&lt;/code&gt; 길이에 영향을 미치는 경우를 제외하고 간격에는이 값이 포함되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="d9b220f5e9cefe4e27d14fddf001bfa3a63353e7" translate="yes" xml:space="preserve">
          <source>Endianness of this data:</source>
          <target state="translated">이 데이터의 엔디안 :</target>
        </trans-unit>
        <trans-unit id="90010140c11fc0bb2865fc9b51fcfa59f205ccef" translate="yes" xml:space="preserve">
          <source>Endnotes</source>
          <target state="translated">Endnotes</target>
        </trans-unit>
        <trans-unit id="05406404937f1ded938df8b2535e2c18c93233ac" translate="yes" xml:space="preserve">
          <source>Enforcing the Code of Conduct impacts our community today and for the future. It&amp;rsquo;s an action that we do not take lightly. When reviewing enforcement measures, the Code of Conduct Committee will keep the following values and guidelines in mind:</source>
          <target state="translated">행동 강령을 시행하면 현재와 미래의 커뮤니티에 영향을 미칩니다. 우리가 가볍게하지 않는 행동입니다. 집행 조치를 검토 할 때 행동 강령위원회는 다음과 같은 가치와 지침을 염두에 둡니다.</target>
        </trans-unit>
        <trans-unit id="f3bf2be725863fdffb3b97618f54e280ae615ed8" translate="yes" xml:space="preserve">
          <source>Enhancements</source>
          <target state="translated">Enhancements</target>
        </trans-unit>
        <trans-unit id="bf62491e77a1f8eb70a16e4b3a6cb3c5e9f6e428" translate="yes" xml:space="preserve">
          <source>Enlarge and pad an array.</source>
          <target state="translated">배열을 확대하고 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="83a41a009718ba8b1b08f10745bce80452ba74f4" translate="yes" xml:space="preserve">
          <source>Enlarging an array: as above, but missing entries are filled with zeros:</source>
          <target state="translated">위와 같이 배열을 확대하지만 누락 된 항목은 0으로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="6c8cedd3caa9e42a775e9fa4b437c16d37b9b189" translate="yes" xml:space="preserve">
          <source>Ensure that the original contents of &lt;code&gt;intent(in)&lt;/code&gt; argument is preserved. Typically used in connection with &lt;code&gt;intent(in,out)&lt;/code&gt; attribute. F2PY creates an optional argument &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; with the default value &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;intent(in)&lt;/code&gt; 인수 의 원래 내용 이 유지 되는지 확인하십시오 . 일반적으로 &lt;code&gt;intent(in,out)&lt;/code&gt; 속성 과 관련하여 사용됩니다 . F2PY 는 기본값 &lt;code&gt;0&lt;/code&gt; 을 사용하여 선택적 인수 &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; 을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0b1cfaa83bf2eab645405941ddc61295f0ec9ed6" translate="yes" xml:space="preserve">
          <source>Ensure you are dealing with a well-behaved array (aligned, in machine byte-order and single-segment) of the correct type and number of dimensions.</source>
          <target state="translated">올바른 유형 및 차원 수의 올바르게 작동하는 배열 (시스템 바이트 순서 및 단일 세그먼트로 정렬 됨)을 처리하고 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="31a314f110f22f052f3fa828713d2b2afb82f2d3" translate="yes" xml:space="preserve">
          <source>Ensures that the input or output matches the iteration dimensions exactly.</source>
          <target state="translated">입력 또는 출력이 반복 차원과 정확히 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2dfe05db0717fbae4e4c8fa997a9589c52cb7615" translate="yes" xml:space="preserve">
          <source>Enter your GitHub username and password (repeat contributors or advanced users can remove this step by connecting to GitHub with &lt;a href=&quot;gitwash/development_setup#set-up-and-configure-a-github-account&quot;&gt;SSH&lt;/a&gt;).</source>
          <target state="translated">GitHub 사용자 이름 및 비밀번호를 입력합니다 (반복 기여자 또는 고급 사용자는 &lt;a href=&quot;gitwash/development_setup#set-up-and-configure-a-github-account&quot;&gt;SSH&lt;/a&gt; 로 GitHub에 연결하여이 단계를 제거 할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="b3a6fa7af7b1354d47707152a8ad806c277ca980" translate="yes" xml:space="preserve">
          <source>Entropy bits in 32-bit unsigned integers. A scalar is returned if size is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">부호없는 32 비트 정수의 엔트로피 비트. size가 &lt;code&gt;None&lt;/code&gt; 인 경우 스칼라가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="b0366a10ef9d6d3ef8c64dd51eeccb78bad1656a" translate="yes" xml:space="preserve">
          <source>Enumerated Types</source>
          <target state="translated">열거 형</target>
        </trans-unit>
        <trans-unit id="e4ac742e5d17c07aad844f80aaa89a24ed90f881" translate="yes" xml:space="preserve">
          <source>Equal to &lt;code&gt;np.prod(a.shape)&lt;/code&gt;, i.e., the product of the array&amp;rsquo;s dimensions.</source>
          <target state="translated">동일 &lt;code&gt;np.prod(a.shape)&lt;/code&gt; , 즉, 배열의 차원 제품.</target>
        </trans-unit>
        <trans-unit id="2baf15a74d602a8791ff350bd57dfdac0a7e5d0e" translate="yes" xml:space="preserve">
          <source>Equations : as discussed in the &lt;strong&gt;Notes&lt;/strong&gt; section above, LaTeX formatting should be kept to a minimum. Often it&amp;rsquo;s possible to show equations as Python code or pseudo-code instead, which is much more readable in a terminal. For inline display use double backticks (like &lt;code&gt;y = np.sin(x)&lt;/code&gt;). For display with blank lines above and below, use a double colon and indent the code, like:</source>
          <target state="translated">방정식 : 위 의 &lt;strong&gt;참고&lt;/strong&gt; 섹션에서 설명한 것처럼 LaTeX 형식은 최소한으로 유지해야합니다. 종종 방정식을 대신 Python 코드 또는 의사 코드로 표시 할 수 있습니다. 이는 터미널에서 훨씬 더 읽기 쉽습니다. 인라인 디스플레이의 경우 이중 백틱을 사용하십시오 (예 : &lt;code&gt;y = np.sin(x)&lt;/code&gt; ). 위와 아래에 빈 줄이있는 표시의 경우 이중 콜론을 사용하고 다음과 같이 코드를 들여 씁니다.</target>
        </trans-unit>
        <trans-unit id="cf762494180c61769e42e78eeea4e46c35cf2ea1" translate="yes" xml:space="preserve">
          <source>Equations can also be typeset underneath the math directive:</source>
          <target state="translated">수식은 math 지시문 아래에서 조판 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="b75f0322b44b0e91520f5021f79c37a01c9e121d" translate="yes" xml:space="preserve">
          <source>Equivalent array function.</source>
          <target state="translated">동등한 배열 기능.</target>
        </trans-unit>
        <trans-unit id="a87b0e23e278c7d5e4e266e84f6badc171df142a" translate="yes" xml:space="preserve">
          <source>Equivalent array method.</source>
          <target state="translated">동등한 배열 방법.</target>
        </trans-unit>
        <trans-unit id="1f85d863747d1d952d2380d6f9b0e6bc4a93c6e6" translate="yes" xml:space="preserve">
          <source>Equivalent function</source>
          <target state="translated">동등한 기능</target>
        </trans-unit>
        <trans-unit id="ec48c460ff53cdf24f427482ba077c38b868cbe6" translate="yes" xml:space="preserve">
          <source>Equivalent function for ndarrays.</source>
          <target state="translated">ndarray에 해당하는 기능.</target>
        </trans-unit>
        <trans-unit id="47b16a4308d5d95c02caa6becddf32961f2329b1" translate="yes" xml:space="preserve">
          <source>Equivalent function in the NumPy module.</source>
          <target state="translated">NumPy 모듈의 해당 기능.</target>
        </trans-unit>
        <trans-unit id="3fda7b941f8c3619f7cfea52fae50b8fafb8283f" translate="yes" xml:space="preserve">
          <source>Equivalent function in the masked array module.</source>
          <target state="translated">마스크 어레이 모듈의 해당 기능</target>
        </trans-unit>
        <trans-unit id="f3946f30225c2c4e0913895a299311328885ca06" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top level NumPy module.</source>
          <target state="translated">최상위 NumPy 모듈의 동등한 기능.</target>
        </trans-unit>
        <trans-unit id="e79348928e8ad109f51e4deea501091d1124a6a4" translate="yes" xml:space="preserve">
          <source>Equivalent function in the top-level NumPy module.</source>
          <target state="translated">최상위 NumPy 모듈의 해당 기능</target>
        </trans-unit>
        <trans-unit id="f012d5b24482ab2f7fe8b36bc8562d2e06cf863d" translate="yes" xml:space="preserve">
          <source>Equivalent function in top-level NumPy module.</source>
          <target state="translated">최상위 NumPy 모듈의 해당 기능.</target>
        </trans-unit>
        <trans-unit id="bb89f40e9f2471ebbc500654e8790a75f09e8680" translate="yes" xml:space="preserve">
          <source>Equivalent function with additional &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; arguments for setting the mean and standard deviation.</source>
          <target state="translated">추가적인 동등한 기능 &lt;code&gt;loc&lt;/code&gt; 및 &lt;code&gt;scale&lt;/code&gt; 평균 및 표준 편차를 설정 인수.</target>
        </trans-unit>
        <trans-unit id="3fec03561045f830610698c03c4e7cda301e9182" translate="yes" xml:space="preserve">
          <source>Equivalent functionality of &lt;a href=&quot;numpy.add#numpy.add&quot;&gt;&lt;code&gt;add&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.add#numpy.add&quot;&gt; &lt;code&gt;add&lt;/code&gt; 의&lt;/a&gt; 동등한 기능 .</target>
        </trans-unit>
        <trans-unit id="73110076e1002b6b052fe8f385604bf0bd306ff9" translate="yes" xml:space="preserve">
          <source>Equivalent method in ndarray</source>
          <target state="translated">ndarray의 동등한 방법</target>
        </trans-unit>
        <trans-unit id="8b818de9537a41af44762a6ff8c93846b78172ce" translate="yes" xml:space="preserve">
          <source>Equivalent method on ndarray object.</source>
          <target state="translated">ndarray 객체에 해당하는 방법입니다.</target>
        </trans-unit>
        <trans-unit id="323a53e2d1eaaaf783c2a6e70d300696fee31861" translate="yes" xml:space="preserve">
          <source>Equivalent method when working on 1-D arrays</source>
          <target state="translated">1 차원 배열에서 작업 할 때 동등한 방법</target>
        </trans-unit>
        <trans-unit id="198298ece560304dd9cecebb0a6c0ea2bb7a8bae" translate="yes" xml:space="preserve">
          <source>Equivalent method.</source>
          <target state="translated">동등한 방법.</target>
        </trans-unit>
        <trans-unit id="46b37d7b2f299efd2d123535be0f6369732ae724" translate="yes" xml:space="preserve">
          <source>Equivalent ndarray method.</source>
          <target state="translated">동등한 ndarray 방법.</target>
        </trans-unit>
        <trans-unit id="c920736bc05ff403de2ed423ca7f0b9c0f3adffb" translate="yes" xml:space="preserve">
          <source>Equivalent of Python &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">Python &lt;code&gt;//&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="505d790701850092dede13a1225a7d0508099ca4" translate="yes" xml:space="preserve">
          <source>Equivalent of the MATLAB &lt;code&gt;rem&lt;/code&gt; function.</source>
          <target state="translated">MATLAB &lt;code&gt;rem&lt;/code&gt; 함수 와 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="4cdc670d68d8d05adfb0ac70f3d0ea4670424187" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt;&lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;dtype&lt;/em&gt;, &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">&lt;a href=&quot;#c.PyDataType_FLAGCHK&quot;&gt; &lt;code&gt;PyDataType_FLAGCHK&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;dtype&lt;/em&gt; , &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fee6dbfeac3ceda19730d1e4e0704640fe75ab77" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="translated">등가 &lt;a href=&quot;../generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). 모든 요소가 True 인 &lt;code&gt;axis&lt;/code&gt; 으로 정의 된 &lt;code&gt;self&lt;/code&gt; 의 모든 1-d 하위 배열에 대해 True 요소가있는 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="186b0b563cbae838de8810c69312c1eaa62ec654" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;ndarray.any&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 동일합니다 . 요소가 True 인 &lt;em&gt;축&lt;/em&gt; 에 의해 정의 된 &lt;em&gt;self의&lt;/em&gt; 모든 1-d 하위 배열에 대해 True 요소가있는 배열을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f442103406eabff3384a2561e7e4f3b1cb166d5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 의 가장 큰 요소의 인덱스를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c75a0ddd8d31ee8d0abd1790434d076eb8e7770e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 의 가장 작은 요소의 인덱스를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a28fa5901ef493ca3cfeb35f1edc348f4ba70f84" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt; &lt;code&gt;ndarray.argpartition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). 주어진 &lt;code&gt;axis&lt;/code&gt; 따라 이러한 인덱스를 선택하면 &lt;em&gt;self&lt;/em&gt; 의 분할 된 버전이 반환 되도록 인덱스 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="e47633b0ba2c1ea2ce577109feb2860147110ce7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt; &lt;code&gt;ndarray.argsort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 주어진 &lt;code&gt;axis&lt;/code&gt; 따라 이러한 인덱스를 선택 하면 정렬 된 &lt;em&gt;self&lt;/em&gt; 버전이 반환 되도록 인덱스 배열을 반환합니다 . 경우 &lt;em&gt;자기&lt;/em&gt; -&amp;gt; DESCR 정의 필드 데이터 타입은 다음 자기&amp;gt; descr-&amp;gt; 이름이 정렬 순서를 결정하는 데 사용됩니다. 첫 번째 필드가 동일한 비교는 두 번째 필드를 사용하는 식입니다. 구조화 된 배열의 정렬 순서를 변경하려면 이름 순서가 다른 새 데이터 유형을 만들고 해당 새 데이터 유형으로 배열보기를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="ab44c6dfb76d44a22896198277fc1dfa63e19a39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt; &lt;code&gt;ndarray.byteswap&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;인플레 이스&lt;/em&gt; ). 데이터 영역이 바이트 스왑 된 배열을 반환합니다. &lt;em&gt;inplace&lt;/em&gt; 가 0이 아닌 경우 byteswap inplace를 수행하고 self에 대한 참조를 반환합니다. 그렇지 않으면 바이트 스왑 된 복사본을 만들고 자체를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="63580b7937fc29a8cc1a69e6dad1db1d8c003559" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="translated">등가 &lt;a href=&quot;../generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt; &lt;code&gt;ndarray.choose&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;OP&lt;/em&gt; , &lt;em&gt;RET&lt;/em&gt; , &lt;em&gt;clipmode을&lt;/em&gt; ). &lt;em&gt;self&lt;/em&gt; 의 정수 값을 기반으로 &lt;em&gt;op&lt;/em&gt; 의 배열 시퀀스에서 요소를 선택하여 새 배열을 만듭니다 . 배열은 모두 동일한 모양으로 브로드 캐스팅 가능 해야하며 &lt;em&gt;self&lt;/em&gt; 의 항목 은 0과 len ( &lt;em&gt;op&lt;/em&gt; ) 사이 여야합니다 . 새 출력이 생성되는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 출력은 &lt;em&gt;ret에&lt;/em&gt; 배치됩니다 . &lt;em&gt;clipmode의&lt;/em&gt; 인수 항목 때의 행동 결정 &lt;em&gt;자체가&lt;/em&gt; 없는 경우 0 렌 (아르 &lt;em&gt;영업 이익&lt;/em&gt; ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7c3b2ea44431c439616093a9d5ebd74980360b6c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="translated">등가 &lt;a href=&quot;../generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt; &lt;code&gt;ndarray.clip&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;최소&lt;/em&gt; , &lt;em&gt;최대&lt;/em&gt; ). 어레이, 클립 &lt;em&gt;자체를&lt;/em&gt; 보다 큰 값으로되도록, &lt;em&gt;최대가&lt;/em&gt; 고정되어 &lt;em&gt;최대&lt;/em&gt; 미만 값 &lt;em&gt;분&lt;/em&gt; 에 고정 &lt;em&gt;분&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="48d43c27921059f0a7a10c6b7d33e4ffbe0ee4d6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt; &lt;code&gt;ndarray.compress&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;상태&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). true 인 &lt;em&gt;조건&lt;/em&gt; 요소에 해당하는 &lt;em&gt;축을&lt;/em&gt; 따라 요소를 반환 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d9aa772deed9dfab23ce08d5aaf5096e5f550d9a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt; &lt;code&gt;ndarray.conjugate&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 동일합니다 . &lt;em&gt;self의&lt;/em&gt; 켤레 복소수를 반환합니다 . &lt;em&gt;self&lt;/em&gt; 가 복잡한 데이터 유형이 아닌 경우 참조와 함께 &lt;em&gt;self&lt;/em&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="9e0619959acd54807feb74d65e4fc49e0c39d7c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;fortran&lt;/em&gt; ) 와 동일합니다 . &lt;em&gt;이전&lt;/em&gt; 배열 의 복사본을 만듭니다 . 반환 된 배열은 항상 이전 배열과 동일하게 해석 된 데이터로 정렬되고 쓰기 가능합니다. 경우 &lt;em&gt;순서&lt;/em&gt; 입니다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 다음 C 스타일의 연속 배열이 반환됩니다. 경우 &lt;em&gt;순서&lt;/em&gt; 입니다 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , 다음 포트란 스타일의 연속 배열이 반환됩니다. 경우 &lt;em&gt;순서는 &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 후 반환 된 배열은 이전 인 경우에만 포트란 스타일의 연속이다; 그렇지 않으면 C 스타일 연속입니다.</target>
        </trans-unit>
        <trans-unit id="a0c3cd7eb6fa6d356c2901bb9f6d3ba8cab9d89e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt; &lt;code&gt;ndarray.cumprod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;code&gt;axis&lt;/code&gt; 를 따라 &lt;code&gt;self&lt;/code&gt; 에있는 요소의 1d 누적 곱을 반환 합니다. 데이터를 &lt;code&gt;rtype&lt;/code&gt; 데이터 유형으로 변환 한 후 제품을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="cb82bf0e510f4d18fb05a89ac99cab0f063a9efd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt; &lt;code&gt;ndarray.cumsum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 에있는 요소의 누적 1d 합을 반환 합니다. 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 합계를 수행합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="147baa3bca301ee2641ca21a0eba77e7a019e912" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt; &lt;code&gt;ndarray.diagonal&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; , &lt;em&gt;1 축&lt;/em&gt; , &lt;em&gt;축 2&lt;/em&gt; ). &lt;em&gt;axis1&lt;/em&gt; 및 &lt;em&gt;axis2로&lt;/em&gt; 정의 된 2 차원 배열 의 &lt;em&gt;오프셋&lt;/em&gt; 대각선을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8a8dee6eb2f62046701960813747a2ce4d3c4eb9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="translated">등가 &lt;a href=&quot;../generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;ndarray.flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;순서&lt;/em&gt; ). 배열의 1d 복사본을 반환합니다. 경우 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; 요소는 포트란 순서대로 스캐닝된다 (제 1 차원은 빠른 변화). 경우 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 요소 &lt;code&gt;self&lt;/code&gt; (최종 치수가 가장 빠른 변화) C-순서대로 스캐닝된다. 경우 &lt;em&gt;주문 &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 의 다음 결과 &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자아&lt;/em&gt; )를 결정하는 데 사용되는 순서 평탄화한다.</target>
        </trans-unit>
        <trans-unit id="55b8b003a6301beae59c2337672b7d873a7a30b4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt; &lt;code&gt;ndarray.getfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ) 와 동일합니다 . 이 함수 &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;는 &lt;/a&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; 에대한 참조 를 훔치고 지정된 &lt;code&gt;offset&lt;/code&gt; (바이트) 에서 현재 배열의 데이터를 사용하여 주어진 &lt;code&gt;dtype&lt;/code&gt; 의 새 배열을 반환 합니다. &lt;code&gt;offset&lt;/code&gt; 새로운 배열 유형의 플러스 itemsize 미만이어야합니다 &lt;code&gt;self -&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 또는 오류가 발생합니다. 원래 배열과 동일한 모양과 보폭이 사용됩니다. 따라서이 함수는 구조화 된 배열에서 필드를 반환하는 효과가 있습니다. 그러나 모든 배열 유형에서 특정 바이트 또는 바이트 그룹을 선택하는 데 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d22054d186b1f1ff23d804468173438990f202" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 의 가장 큰 요소를 반환합니다 . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9d38f65f39197f34563c038f540e3b44a0d2f6ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt; &lt;code&gt;ndarray.mean&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 합계 할 데이터 유형으로 열거 형 &lt;em&gt;rtype&lt;/em&gt; 을 사용하여 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 요소의 평균을 반환합니다 . 기본 합계 동작은 &lt;a href=&quot;dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; 대해 &lt;em&gt;NPY_NOTYPE을&lt;/em&gt; 사용하여 얻&lt;em&gt; 습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5cb706fff5203c363163a51434cc7adef7ffc29f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 의 가장 작은 요소를 반환합니다 . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d5d5265b484ee101637dbdbbeb657d0f5063ebd7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;ndarray.nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . 0이 아닌 &lt;em&gt;self&lt;/em&gt; 요소를 선택하는 인덱스 배열의 튜플을 반환합니다 . (nd = &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; )) == 1이면 단일 인덱스 배열이 반환됩니다. 인덱스 배열의 데이터 유형은 &lt;a href=&quot;dtype#c.NPY_INTP&quot;&gt; &lt;code&gt;NPY_INTP&lt;/code&gt; &lt;/a&gt; 입니다. 튜플이 반환되면 (nd</target>
        </trans-unit>
        <trans-unit id="404bdbd3b8a1b96a6c46adc73debf37dfd647756" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt; &lt;code&gt;ndarray.partition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). &lt;em&gt;ktharray&lt;/em&gt; 에 의해 인덱싱 된 요소의 값이 배열이 완전히 정렬되고 k 번째 요소 이전에 k 번째보다 작은 모든 요소와 k 번째 요소 뒤에 동일하거나 큰 모든 요소를 ​​배치하는 경우의 위치에 있도록 배열을 분할합니다 . 파티션 내 모든 요소의 순서는 정의되어 있지 않습니다. 만약 &lt;em&gt;자기&lt;/em&gt;-&amp;gt; descr은 필드가 정의 된 데이터 유형이며 self-&amp;gt; descr-&amp;gt; names는 정렬 순서를 결정하는 데 사용됩니다. 첫 번째 필드가 동일한 비교는 두 번째 필드를 사용하는 식입니다. 구조화 된 배열의 정렬 순서를 변경하려면 이름 순서가 다른 새 데이터 유형을 만들고 해당 새 데이터 유형으로 배열보기를 구성합니다. 성공하면 0을, 실패하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c549a447e1ab678178d605e0abed17f0cd61d094" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt; &lt;code&gt;ndarray.prod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;em&gt;축을&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 에있는 요소의 1-d 곱을 반환 합니다. 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 제품을 수행하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50e5592224385bd5a5a47c4e8db5171ddcc2ccb3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt; &lt;code&gt;ndarray.ptp&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 가장 큰 요소의 차이 돌아 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; 과의 가장 작은 소자 &lt;em&gt;자체&lt;/em&gt; 를 따라 &lt;em&gt;축&lt;/em&gt; . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="8518311e2b7b6ac094e9b94bd62860a33aa8bf47" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt; &lt;code&gt;ndarray.repeat&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 동일합니다 . 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; 시간 의 요소를 복사합니다 . 어느 &lt;em&gt;연산이&lt;/em&gt; 스칼라 정수 또는 길이의 서열이다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; 치수 [- &lt;em&gt;축&lt;/em&gt; 여러 번 축을 따라 각 항목을 반복하는 방법을 나타낸다].&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="0d8cf34534cc24beb73c77b84496c087a2293d28" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="translated">&lt;em&gt;shape&lt;/em&gt; 가 시퀀스 인 &lt;a href=&quot;../generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt; &lt;code&gt;ndarray.reshape&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;shape&lt;/em&gt; ) 와 동일합니다 . &lt;em&gt;모양&lt;/em&gt; 을 &lt;a href=&quot;types-and-structures#c.PyArray_Dims&quot;&gt; &lt;code&gt;PyArray_Dims&lt;/code&gt; &lt;/a&gt; 구조로 변환 하고 내부적으로 &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt; &lt;code&gt;PyArray_Newshape&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 이전 버전과의 호환성을 위해 &amp;ndash; 권장하지 않음&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="638611d108c9a9ce025011cf0fefaaa249e16115" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="translated">등가 &lt;a href=&quot;../generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;newshape&lt;/em&gt; , refcheck &lt;code&gt;=&lt;/code&gt; &lt;em&gt;refcheck&lt;/em&gt; 순서 = 포트란). 이 함수는 단일 세그먼트 배열에서만 작동합니다. 그것은 &lt;em&gt;self&lt;/em&gt; inplace 의 모양을 변경하고 &lt;em&gt;newshape&lt;/em&gt; 에 이전 모양과 다른 총 요소 수가 다른 경우 &lt;em&gt;self에&lt;/em&gt; 대한 메모리를 재 할당합니다 . 재 할당이 필요한 경우, &lt;em&gt;자기&lt;/em&gt; 자신의 데이터를 소유해야합니다,이 &lt;em&gt;자기&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt; 가지고 &lt;em&gt;자기&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt; 하고, (refcheck가 0이 아닌) 다른 배열로 참조 할 수 없습니다. fortran 인수는 &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; . 현재는 효과가 없습니다. 결국 다른 차원의 배열을 구성 할 때 크기 조정 작업에서 데이터를 보는 방법을 결정하는 데 사용할 수 있습니다. 성공하면 None을, 오류가 있으면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54966ab6c4e29db133f8104359b27e76b17c469a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="translated">당량 &lt;a href=&quot;../generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt; &lt;code&gt;ndarray.round&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;소수&lt;/em&gt; , &lt;em&gt;아웃&lt;/em&gt; ). 가장 가까운 소수점 자리로 반올림 된 요소가있는 배열을 반환합니다. 소수점 자리는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="ec01042d1895112ebd1035318c0017010dd4e832" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt; &lt;code&gt;ndarray.searchsorted&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;값&lt;/em&gt; , &lt;em&gt;측&lt;/em&gt; , &lt;em&gt;파마&lt;/em&gt; ). 가정 &lt;em&gt;자기하는&lt;/em&gt; 승순의 1 차원 배열이며, 출력은 동일한 형상 인덱스 배열을 인 &lt;em&gt;값&lt;/em&gt; 의 요소 경우 그에 따라, &lt;em&gt;값이&lt;/em&gt; 인덱스 앞에 삽입하고, 순서 &lt;em&gt;자체는&lt;/em&gt; 보존 될 수는. self가 오름차순인지 여부를 확인하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cef7e5af80a428c5254d2fef178ea505c8c19ead" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt; &lt;code&gt;ndarray.setfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;발&lt;/em&gt; , &lt;em&gt;DTYPE&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; ). &lt;em&gt;오프셋&lt;/em&gt; 에서 시작하는 필드 를 바이트 단위로 설정하고 지정된 &lt;em&gt;dtype의 필드&lt;/em&gt; 를 &lt;em&gt;val로 설정&lt;/em&gt; 합니다. &lt;em&gt;오프셋&lt;/em&gt; 플러스 &lt;em&gt;DTYPE은&lt;/em&gt; -&amp;gt; elsize 미만이어야합니다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; descr-&amp;gt; elsize 또는 오류가 발생합니다 -. 그렇지 않으면 &lt;em&gt;val&lt;/em&gt; 인수가 배열로 변환되고 가리키는 필드에 복사됩니다. 필요한 경우 대상 배열을 채우기 위해 &lt;em&gt;val&lt;/em&gt; 의 요소 가 반복되지만 대상의 요소 수는&lt;em&gt;val&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3c3255647be24898e308dd8ac21dadefba0c0a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt;, which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt; &lt;code&gt;ndarray.sort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;자체&lt;/em&gt; 정렬 된 항목이있는 배열을 반환합니다 . 배열은 사용 된 정렬 알고리즘 유형을 가리키는 정수 / 열거 인 &lt;em&gt;kind&lt;/em&gt; 로 표시된 알고리즘을 사용하여 정렬됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="27a6b11953d97b15697fad15568b370248cfeb20" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt; &lt;code&gt;ndarray.squeeze&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . 길이 1의 모든 차원이 모양에서 제거 된 상태 로 새로운 &lt;em&gt;self&lt;/em&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="862af43d2c6b0a55c85e6d3a6b411873c5226258" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">등가 &lt;a href=&quot;../generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE을&lt;/em&gt; ). &lt;em&gt;rtype&lt;/em&gt; 데이터 형으로 변환 된 &lt;em&gt;축을&lt;/em&gt; 따라 데이터를 사용하여 표준 편차를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e292f5ba0e99a5f16bcc2829ab5d9470ad0f4d13" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; 에있는 요소의 1d 벡터 합을 반환 합니다. 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 합계를 수행합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="246fe22eecb98bac6eed58c36c5c002cc77b5ad9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt; &lt;code&gt;ndarray.swapaxes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;A1&lt;/em&gt; , &lt;em&gt;A2&lt;/em&gt; ). 반환 된 배열은 지정된 축 &lt;em&gt;a1&lt;/em&gt; 및 &lt;em&gt;a2&lt;/em&gt; 가 교체 된 &lt;em&gt;자체&lt;/em&gt; 데이터의 새로운 뷰입니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="a390cc4ddaa841114316d31bea2078c5a16e1cf6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;ndarray.take&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;인덱스&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RET&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; 제외) &lt;em&gt;축&lt;/em&gt; = 파이썬 없음 설정함으로써 얻을 수 없다 &lt;em&gt;축&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; 를&lt;/a&gt; 자기 정수 값에 의해 표시로부터 항목을 추출 C.에서 &lt;em&gt;인덱스&lt;/em&gt; 주어진 따라 &lt;em&gt;축.&lt;/em&gt; clipmode 인수는 &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; &lt;/a&gt; 으로 아웃 바운드 인덱스로 수행 할 작업을 나타낼 수 있습니다 . &lt;em&gt;RET의&lt;/em&gt; 인수보다는 내부를 생성하는 것보다 출력 배열을 지정할 수있다.</target>
        </trans-unit>
        <trans-unit id="7206ce6e4a585b31fefc3d225467d40239cdb106" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ) 와 같습니다 . 이 배열의 바이트를 Python 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="171c56ed06f2b8f601e0836c87ae1d6a49d81221" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt; &lt;code&gt;ndarray.tolist&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;self&lt;/em&gt; 에서 중첩 된 Python 목록을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d77e40fb42cd93f8c483ffa7d7241b393d0e4ae3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="translated">상당 &lt;a href=&quot;../generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt; &lt;code&gt;ndarray.trace&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; , &lt;em&gt;1 축&lt;/em&gt; , &lt;em&gt;축 2&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). (사용 합 돌아 &lt;em&gt;RTYPE를&lt;/em&gt; 오버 합계의 데이터 형식으로) &lt;em&gt;오프셋&lt;/em&gt; 에 의해 정의되는 2 차원 어레이의 대각선 요소 &lt;em&gt;에서 축&lt;/em&gt; 과 &lt;em&gt;, 축&lt;/em&gt; 변수. 양의 오프셋은 주 대각선 위의 대각선을 선택합니다. 음수 오프셋은 주 대각선 아래의 대각선을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="9dd34a2c83d97a0f513db9230449465e813314c6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;ndarray.transpose&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;permute&lt;/em&gt; ) 와 같습니다 . 데이터 구조 &lt;em&gt;permute&lt;/em&gt; 에 따라 ndarray 객체 &lt;em&gt;self&lt;/em&gt; 의 축을 Permute하고 결과를 반환합니다. 경우 &lt;em&gt;변경하다가&lt;/em&gt; 있다 &lt;code&gt;NULL&lt;/code&gt; , 그 결과 어레이는 반전 축을 갖는다. 예를 들어 &lt;em&gt;self&lt;/em&gt; 가 모양을 가지고 있다면&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b13fb477c1c38e7bfcb6352e8ffc5f4bb87dd24f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;../generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;../generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;ndarray.view&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; ) 와 동일합니다 . 다른 데이터 유형, &lt;em&gt;dtype&lt;/em&gt; 및 다른 배열 하위 클래스 &lt;em&gt;ptype&lt;/em&gt; 으로 배열 &lt;em&gt;self&lt;/em&gt; 의 새 뷰를 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e3ecf3d3dd70eafb08906a1ad49ac399520f10f8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;ndarray.all&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;code&gt;self&lt;/code&gt; defined by &lt;code&gt;axis&lt;/code&gt; in which all the elements are True.</source>
          <target state="translated">등가 &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;ndarray.all&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). 모든 요소가 True 인 &lt;code&gt;axis&lt;/code&gt; 으로 정의 된 모든 1 차원 하위 ​​배열 &lt;code&gt;self&lt;/code&gt; 대해 True 요소가있는 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="efd8289812e23cf1b7df07369198edcd67ccd665" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;ndarray.any&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array with True elements for every 1-d sub-array of &lt;em&gt;self&lt;/em&gt; defined by &lt;em&gt;axis&lt;/em&gt; in which any of the elements are True.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;ndarray.any&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). 요소가 True 인 &lt;em&gt;축&lt;/em&gt; 으로 정의 된 모든 1 차원 하위 ​​배열 &lt;em&gt;자체에&lt;/em&gt; 대해 True 요소가있는 배열을 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ea109271e7fe639649aeaaf2a0b5dd56ecc23fcf" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt;&lt;code&gt;ndarray.argmax&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.argmax#numpy.ndarray.argmax&quot;&gt; &lt;code&gt;ndarray.argmax&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 가장 큰 &lt;em&gt;self&lt;/em&gt; 요소의 인덱스를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e5a451b453bc4aefcc71e37cd8b0e84168886e8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt;&lt;code&gt;ndarray.argmin&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the index of the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.argmin#numpy.ndarray.argmin&quot;&gt; &lt;code&gt;ndarray.argmin&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 가장 작은 &lt;em&gt;self&lt;/em&gt; 요소의 인덱스를 반환합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf7a1a44ff60373e9f731b7ce7e339177577c561" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt;&lt;code&gt;ndarray.argpartition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a partitioned version of &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.argpartition#numpy.ndarray.argpartition&quot;&gt; &lt;code&gt;ndarray.argpartition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). 주어진 &lt;code&gt;axis&lt;/code&gt; 따라 이러한 인덱스를 선택 하면 분할 된 버전의 &lt;em&gt;self&lt;/em&gt; 가 반환 되도록 인덱스 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="d75ff39235401fe4390dbb04fd226bfccafd46e5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt;&lt;code&gt;ndarray.argsort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return an array of indices such that selection of these indices along the given &lt;code&gt;axis&lt;/code&gt; would return a sorted version of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.argsort#numpy.ndarray.argsort&quot;&gt; &lt;code&gt;ndarray.argsort&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 주어진 &lt;code&gt;axis&lt;/code&gt; 따라 이러한 인덱스를 선택 하면 정렬 된 버전의 &lt;em&gt;self&lt;/em&gt; 가 반환 되도록 인덱스 배열을 반환합니다 . 경우 &lt;em&gt;자기&lt;/em&gt; -&amp;gt; DESCR 정의 필드 데이터 타입은 다음 자기&amp;gt; descr-&amp;gt; 이름이 정렬 순서를 결정하는 데 사용됩니다. 첫 번째 필드가 동일한 비교는 두 번째 필드 등을 사용합니다. 구조화 된 배열의 정렬 순서를 변경하려면 다른 이름 순서로 새 데이터 유형을 작성하고 해당 새 데이터 유형으로 배열보기를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="6daadea926a9bfb0a800c60a35b85b50c40374a1" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt;&lt;code&gt;ndarray.byteswap&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;inplace&lt;/em&gt;). Return an array whose data area is byteswapped. If &lt;em&gt;inplace&lt;/em&gt; is non-zero, then do the byteswap inplace and return a reference to self. Otherwise, create a byteswapped copy and leave self unchanged.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.byteswap#numpy.ndarray.byteswap&quot;&gt; &lt;code&gt;ndarray.byteswap&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;inplace&lt;/em&gt; ). 데이터 영역이 바이트 랩핑 된 배열을 반환합니다. &lt;em&gt;inplace&lt;/em&gt; 가 0이 아닌 경우 , byteswap inplace를 수행하고 self에 대한 참조를 리턴하십시오. 그렇지 않으면, 바이트 랩핑 된 사본을 작성하고 자체를 변경하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="2ab0b0009765a5d262f32c0eec580607299fc96a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt;&lt;code&gt;ndarray.choose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;). Create a new array by selecting elements from the sequence of arrays in &lt;em&gt;op&lt;/em&gt; based on the integer values in &lt;em&gt;self&lt;/em&gt;. The arrays must all be broadcastable to the same shape and the entries in &lt;em&gt;self&lt;/em&gt; should be between 0 and len(&lt;em&gt;op&lt;/em&gt;). The output is placed in &lt;em&gt;ret&lt;/em&gt; unless it is &lt;code&gt;NULL&lt;/code&gt; in which case a new output is created. The &lt;em&gt;clipmode&lt;/em&gt; argument determines behavior for when entries in &lt;em&gt;self&lt;/em&gt; are not between 0 and len(&lt;em&gt;op&lt;/em&gt;).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.choose#numpy.ndarray.choose&quot;&gt; &lt;code&gt;ndarray.choose&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; , &lt;em&gt;ret&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ). &lt;em&gt;self&lt;/em&gt; 의 정수 값을 기반으로 &lt;em&gt;op&lt;/em&gt; 의 시퀀스에서 요소를 선택하여 새 배열을 만듭니다 . 배열은 모두 같은 모양으로 브로드 캐스트 가능 해야하며 &lt;em&gt;자체&lt;/em&gt; 항목 은 0과 len ( &lt;em&gt;op&lt;/em&gt; ) 사이 여야합니다 . 출력이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 출력은 &lt;em&gt;ret에&lt;/em&gt; 배치 &lt;em&gt;되며이&lt;/em&gt; 경우 새 출력이 작성됩니다. &lt;em&gt;clipmode의&lt;/em&gt; 인수 항목 때의 행동 결정 &lt;em&gt;자체가&lt;/em&gt; 없는 경우 0 렌 (아르 &lt;em&gt;영업 이익&lt;/em&gt; ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07498cd87fe2ef12a2b26de127164c39b4bd9e44" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt;&lt;code&gt;ndarray.clip&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;min&lt;/em&gt;, &lt;em&gt;max&lt;/em&gt;). Clip an array, &lt;em&gt;self&lt;/em&gt;, so that values larger than &lt;em&gt;max&lt;/em&gt; are fixed to &lt;em&gt;max&lt;/em&gt; and values less than &lt;em&gt;min&lt;/em&gt; are fixed to &lt;em&gt;min&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.clip#numpy.ndarray.clip&quot;&gt; &lt;code&gt;ndarray.clip&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;min&lt;/em&gt; , &lt;em&gt;max&lt;/em&gt; ). 어레이, 클립 &lt;em&gt;자체를&lt;/em&gt; 보다 큰 값으로되도록, &lt;em&gt;최대가&lt;/em&gt; 고정되어 &lt;em&gt;최대&lt;/em&gt; 미만 값 &lt;em&gt;분&lt;/em&gt; 에 고정 &lt;em&gt;분&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c163c568fd35392b35f7cb27b6a29f0e9cbd90da" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt;&lt;code&gt;ndarray.compress&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;condition&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt; ). Return the elements along &lt;em&gt;axis&lt;/em&gt; corresponding to elements of &lt;em&gt;condition&lt;/em&gt; that are true.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.compress#numpy.ndarray.compress&quot;&gt; &lt;code&gt;ndarray.compress&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;condition&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). &lt;em&gt;조건&lt;/em&gt; 을 &lt;em&gt;충족&lt;/em&gt; 하는 요소에 해당하는 &lt;em&gt;축을&lt;/em&gt; 따라 요소를 반환 합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd9acb1c9e137920376909d2dadce0362beab80c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt;&lt;code&gt;ndarray.conjugate&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return the complex conjugate of &lt;em&gt;self&lt;/em&gt;. If &lt;em&gt;self&lt;/em&gt; is not of complex data type, then return &lt;em&gt;self&lt;/em&gt; with a reference.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.conjugate#numpy.ndarray.conjugate&quot;&gt; &lt;code&gt;ndarray.conjugate&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;self의&lt;/em&gt; 켤레 복소수를 반환합니다 . &lt;em&gt;self&lt;/em&gt; 가 복잡한 데이터 유형이 아닌 경우 참조를 사용하여 &lt;em&gt;self&lt;/em&gt; 를 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="cf40d04106c5d52e1884e99b3a37b71d8a81e331" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;fortran&lt;/em&gt;). Make a copy of the &lt;em&gt;old&lt;/em&gt; array. The returned array is always aligned and writeable with data interpreted the same as the old array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, then a C-style contiguous array is returned. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, then a Fortran-style contiguous array is returned. If &lt;em&gt;order is&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the array returned is Fortran-style contiguous only if the old one is; otherwise, it is C-style contiguous.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;fortran&lt;/em&gt; ). &lt;em&gt;이전&lt;/em&gt; 배열을 복사하십시오 . 반환 된 배열은 항상 이전 배열과 동일하게 해석되는 데이터로 정렬되고 쓰기 가능합니다. 경우 &lt;em&gt;순서&lt;/em&gt; 입니다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 다음 C 스타일의 연속 배열이 반환됩니다. 경우 &lt;em&gt;순서&lt;/em&gt; 입니다 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , 다음 포트란 스타일의 연속 배열이 반환됩니다. &lt;em&gt;order가 &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 인 경우 반환되는 배열 &lt;em&gt;은 &lt;/em&gt;이전 배열이 Fortran 스타일 인 경우에만 연속입니다. 그렇지 않으면 C 스타일이 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="98feecd02ab5026f0970a3c09806ab4167d96259" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt;&lt;code&gt;ndarray.cumprod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d cumulative products of elements in &lt;code&gt;self&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;. Perform the product after converting data to data type &lt;code&gt;rtype&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.cumprod#numpy.ndarray.cumprod&quot;&gt; &lt;code&gt;ndarray.cumprod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;code&gt;axis&lt;/code&gt; 따라 요소의 1 차원 누적 곱을 &lt;code&gt;self&lt;/code&gt; 반환 합니다. 데이터를 &lt;code&gt;rtype&lt;/code&gt; 데이터 유형으로 변환 한 후 제품을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="26f34a6ad4ecf38e07a2778b6f8366d8507a10ea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt;&lt;code&gt;ndarray.cumsum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return cumulative 1-d sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.cumsum#numpy.ndarray.cumsum&quot;&gt; &lt;code&gt;ndarray.cumsum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 소자에서의 1-D 누적 합을 반환 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; . 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 합계를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="44d031ba857ad4460b29f51ce74504941e945e52" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt;&lt;code&gt;ndarray.diagonal&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt; ). Return the &lt;em&gt;offset&lt;/em&gt; diagonals of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.diagonal#numpy.ndarray.diagonal&quot;&gt; &lt;code&gt;ndarray.diagonal&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; , &lt;em&gt;1 축&lt;/em&gt; , &lt;em&gt;축 2&lt;/em&gt; ). &lt;em&gt;axis1&lt;/em&gt; 과 &lt;em&gt;axis2로&lt;/em&gt; 정의 된 2 차원 배열 의 &lt;em&gt;오프셋&lt;/em&gt; 대각선을 반환합니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e6400ea427e27ba969159bbf1cd1e50c3dd25455" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;ndarray.flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return a 1-d copy of the array. If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; the elements are scanned out in Fortran order (first-dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, the elements of &lt;code&gt;self&lt;/code&gt; are scanned in C-order (last dimension varies the fastest). If &lt;em&gt;order&lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, then the result of &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;) is used to determine which order to flatten.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;ndarray.flatten&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). 배열의 1 차원 사본을 반환합니다. 경우 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; 요소는 포트란 순서대로 스캐닝된다 (제 1 차원은 빠른 변화). 경우 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 요소 &lt;code&gt;self&lt;/code&gt; (최종 치수가 가장 빠른 변화) C-순서대로 스캐닝된다. 경우 &lt;em&gt;주문 &lt;/em&gt;&lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 의 다음 결과 &lt;a href=&quot;#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자아&lt;/em&gt; )를 결정하는 데 사용되는 순서 평탄화한다.</target>
        </trans-unit>
        <trans-unit id="acb7bf8250a91a19555dbcdb02102524e6c94de7" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt;&lt;code&gt;ndarray.getfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;). This function &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;steals a reference&lt;/a&gt; to &lt;code&gt;PyArray_Descr&lt;/code&gt; and returns a new array of the given &lt;code&gt;dtype&lt;/code&gt; using the data in the current array at a specified &lt;code&gt;offset&lt;/code&gt; in bytes. The &lt;code&gt;offset&lt;/code&gt; plus the itemsize of the new array type must be less than &lt;code&gt;self
-&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; or an error is raised. The same shape and strides as the original array are used. Therefore, this function has the effect of returning a field from a structured array. But, it can also be used to select specific bytes or groups of bytes from any array type.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.getfield#numpy.ndarray.getfield&quot;&gt; &lt;code&gt;ndarray.getfield&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; , &lt;em&gt;offset&lt;/em&gt; ). 이 함수 &lt;a href=&quot;https://docs.python.org/3/c-api/intro.html?reference-count-details&quot;&gt;는 &lt;/a&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; 에대한 참조 를 훔치고 지정된 &lt;code&gt;offset&lt;/code&gt; (바이트)으로 현재 배열의 데이터를 사용하여 지정된 &lt;code&gt;dtype&lt;/code&gt; 의 새 배열을 반환 합니다. 새 배열 유형 의 &lt;code&gt;offset&lt;/code&gt; + 항목 크기는 &lt;code&gt;self -&amp;gt;descr-&amp;gt;elsize&lt;/code&gt; 보다 작아야합니다. 그렇지 않으면 오류가 발생합니다. 원래 배열과 동일한 모양과 보폭이 사용됩니다. 따라서이 함수는 구조화 된 배열에서 필드를 반환하는 효과가 있습니다. 그러나 모든 배열 유형에서 특정 바이트 또는 바이트 그룹을 선택하는 데에도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e1e5da9cdc7a9b4c6725235e40182f3951d083a" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt;&lt;code&gt;ndarray.max&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Returns the largest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.max#numpy.ndarray.max&quot;&gt; &lt;code&gt;ndarray.max&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 가장 큰 &lt;em&gt;자기&lt;/em&gt; 요소를 반환합니다 . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="bdd01120eccb02f99889760c9ef36e279a9f9ea8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt;&lt;code&gt;ndarray.mean&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Returns the mean of the elements along the given &lt;em&gt;axis&lt;/em&gt;, using the enumerated type &lt;em&gt;rtype&lt;/em&gt; as the data type to sum in. Default sum behavior is obtained using &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; for &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.mean#numpy.ndarray.mean&quot;&gt; &lt;code&gt;ndarray.mean&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 열거 된 유형 &lt;em&gt;rtype&lt;/em&gt; 을 합산 할 데이터 유형으로 사용하여 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 요소의 평균을 반환합니다 . 기본 &lt;a href=&quot;c-api.dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; 동작은 rtype에 대해 &lt;em&gt;NPY_NOTYPE을&lt;/em&gt; 사용하여 얻&lt;em&gt; 습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9e276f562081b61880c79febde9752c6b4583d12" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt;&lt;code&gt;ndarray.min&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the smallest element of &lt;em&gt;self&lt;/em&gt; along the given &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.min#numpy.ndarray.min&quot;&gt; &lt;code&gt;ndarray.min&lt;/code&gt; 과&lt;/a&gt; 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 가장 작은 &lt;em&gt;self&lt;/em&gt; 요소를 반환합니다 . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="e792db3a62a29831ce03976f5ea2350fba5a323b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;ndarray.nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Returns a tuple of index arrays that select elements of &lt;em&gt;self&lt;/em&gt; that are nonzero. If (nd= &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; ))==1, then a single index array is returned. The index arrays have data type &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt;&lt;code&gt;NPY_INTP&lt;/code&gt;&lt;/a&gt;. If a tuple is returned (nd</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;ndarray.nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . 0이 아닌 &lt;em&gt;self&lt;/em&gt; 요소를 선택하는 인덱스 배열의 튜플을 반환합니다 . (nd = &lt;a href=&quot;#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;self&lt;/code&gt; )) == 1이면 단일 인덱스 배열이 반환됩니다. 인덱스 배열의 데이터 유형은 &lt;a href=&quot;c-api.dtype#c.NPY_INTP&quot;&gt; &lt;code&gt;NPY_INTP&lt;/code&gt; &lt;/a&gt; 입니다. 튜플이 반환 된 경우 (nd</target>
        </trans-unit>
        <trans-unit id="a70d121c7d953594f404dacb0d342fd3ab8b30ba" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt;&lt;code&gt;ndarray.partition&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;ktharray&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Partitions the array so that the values of the element indexed by &lt;em&gt;ktharray&lt;/em&gt; are in the positions they would be if the array is fully sorted and places all elements smaller than the kth before and all elements equal or greater after the kth element. The ordering of all elements within the partitions is undefined. If &lt;em&gt;self&lt;/em&gt;-&amp;gt;descr is a data-type with fields defined, then self-&amp;gt;descr-&amp;gt;names is used to determine the sort order. A comparison where the first field is equal will use the second field and so on. To alter the sort order of a structured array, create a new data-type with a different order of names and construct a view of the array with that new data-type. Returns zero on success and -1 on failure.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.partition#numpy.ndarray.partition&quot;&gt; &lt;code&gt;ndarray.partition&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;ktharray&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;종류&lt;/em&gt; ). &lt;em&gt;ktharray&lt;/em&gt; 에 의해 색인화 된 요소의 값이 배열이 완전히 정렬되고 kth 이전의 kth보다 작은 모든 요소를 ​​배치하고 kth 요소 다음의 모든 요소를 ​​같거나 큰 경우 배열을 분할합니다. 파티션 내 모든 요소의 순서는 정의되어 있지 않습니다. 만약 &lt;em&gt;자기&lt;/em&gt;-&amp;gt; descr은 필드가 정의 된 데이터 유형이며, 정렬 순서를 결정하기 위해 self-&amp;gt; descr-&amp;gt; names가 사용됩니다. 첫 번째 필드가 동일한 비교는 두 번째 필드 등을 사용합니다. 구조화 된 배열의 정렬 순서를 변경하려면 다른 이름 순서로 새 데이터 유형을 작성하고 해당 새 데이터 유형으로 배열보기를 구성하십시오. 성공하면 0을, 실패하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1404ab20af4a0d50c24ff1ca93cc3a3448c7e38e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt;&lt;code&gt;ndarray.prod&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d products of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the product after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.prod#numpy.ndarray.prod&quot;&gt; &lt;code&gt;ndarray.prod&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). &lt;em&gt;축을&lt;/em&gt; 따라 요소의 1 차원 제품을 &lt;em&gt;자체로&lt;/em&gt; 반환 합니다. 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 제품을 수행하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1100d008c0276fd76e61e9204938c06e2c190cea" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt;&lt;code&gt;ndarray.ptp&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Return the difference between the largest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt; and the smallest element of &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. When the result is a single element, returns a numpy scalar instead of an ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.ptp#numpy.ndarray.ptp&quot;&gt; &lt;code&gt;ndarray.ptp&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) 와 같습니다 . 가장 큰 요소의 차이 돌아 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; 과의 가장 작은 소자 &lt;em&gt;자체&lt;/em&gt; 를 따라 &lt;em&gt;축&lt;/em&gt; . 결과가 단일 요소 인 경우 ndarray 대신 numpy 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2c16f538cf9a4222086ade1f8bc40148ea4157cd" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt;&lt;code&gt;ndarray.repeat&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;). Copy the elements of &lt;em&gt;self&lt;/em&gt;, &lt;em&gt;op&lt;/em&gt; times along the given &lt;em&gt;axis&lt;/em&gt;. Either &lt;em&gt;op&lt;/em&gt; is a scalar integer or a sequence of length &lt;em&gt;self&lt;/em&gt; -&amp;gt;dimensions[ &lt;em&gt;axis&lt;/em&gt; ] indicating how many times to repeat each item along the axis.</source>
          <target state="translated">등가 &lt;a href=&quot;generated/numpy.ndarray.repeat#numpy.ndarray.repeat&quot;&gt; &lt;code&gt;ndarray.repeat&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;OP&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; ). 주어진 &lt;em&gt;축을&lt;/em&gt; 따라 &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;op&lt;/em&gt; 시간 요소를 복사합니다 . 어느 &lt;em&gt;연산이&lt;/em&gt; 스칼라 정수 또는 길이의 서열이다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; 치수 [- &lt;em&gt;축&lt;/em&gt; 여러 번 축을 따라 각 항목을 반복하는 방법을 나타낸다].&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="89f8dce1a3fdb6440169e6117acb2747787948e3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt;&lt;code&gt;ndarray.reshape&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;shape&lt;/em&gt;) where &lt;em&gt;shape&lt;/em&gt; is a sequence. Converts &lt;em&gt;shape&lt;/em&gt; to a &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt;&lt;code&gt;PyArray_Dims&lt;/code&gt;&lt;/a&gt; structure and calls &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt;&lt;code&gt;PyArray_Newshape&lt;/code&gt;&lt;/a&gt; internally. For back-ward compatibility &amp;ndash; Not recommended</source>
          <target state="translated">&lt;em&gt;모양&lt;/em&gt; 이 시퀀스 인 &lt;a href=&quot;generated/numpy.ndarray.reshape#numpy.ndarray.reshape&quot;&gt; &lt;code&gt;ndarray.reshape&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;shape&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;shape&lt;/em&gt; 를 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Dims&quot;&gt; &lt;code&gt;PyArray_Dims&lt;/code&gt; &lt;/a&gt; 구조로 변환 하고 내부적으로 &lt;a href=&quot;#c.PyArray_Newshape&quot;&gt; &lt;code&gt;PyArray_Newshape&lt;/code&gt; 를&lt;/a&gt; 호출합니다 . 이전 버전과의 호환성을 위해 &amp;ndash; 권장하지 않음&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c66cfa86b4fd8c96342e13259600ca57c73356a4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt;&lt;code&gt;ndarray.resize&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;newshape&lt;/em&gt;, refcheck &lt;code&gt;=&lt;/code&gt;&lt;em&gt;refcheck&lt;/em&gt;, order= fortran ). This function only works on single-segment arrays. It changes the shape of &lt;em&gt;self&lt;/em&gt; inplace and will reallocate the memory for &lt;em&gt;self&lt;/em&gt; if &lt;em&gt;newshape&lt;/em&gt; has a different total number of elements then the old shape. If reallocation is necessary, then &lt;em&gt;self&lt;/em&gt; must own its data, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt;, have &lt;em&gt;self&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt;, and (unless refcheck is 0) not be referenced by any other array. The fortran argument can be &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;. It currently has no effect. Eventually it could be used to determine how the resize operation should view the data when constructing a differently-dimensioned array. Returns None on success and NULL on error.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.resize#numpy.ndarray.resize&quot;&gt; &lt;code&gt;ndarray.resize&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;newshape&lt;/em&gt; , refcheck &lt;code&gt;=&lt;/code&gt; &lt;em&gt;refcheck&lt;/em&gt; , order = fortran). 이 기능은 단일 세그먼트 배열에서만 작동합니다. 그것은의 모양 변경 &lt;em&gt;자체&lt;/em&gt; 인플레 이스와의 메모리를 재 할당 할 &lt;em&gt;자가&lt;/em&gt; 있는 경우 &lt;em&gt;newshape은&lt;/em&gt; 다음 요소의 다른 총 번호 이전 형태를 갖는다. 재 할당이 필요한 경우, &lt;em&gt;자기&lt;/em&gt; 자신의 데이터를 소유해야합니다,이 &lt;em&gt;자기&lt;/em&gt; - &lt;code&gt;&amp;gt;base==NULL&lt;/code&gt; 가지고 &lt;em&gt;자기&lt;/em&gt; - &lt;code&gt;&amp;gt;weakrefs==NULL&lt;/code&gt; 하고, (refcheck가 0이 아닌) 다른 배열로 참조 할 수 없습니다. 포트란 인수는 &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 일&lt;/a&gt; 수 있습니다 ., &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; . 현재 효과가 없습니다. 결국 다른 차원의 배열을 만들 때 크기 조정 작업에서 데이터를 보는 방법을 결정하는 데 사용할 수 있습니다. 성공하면 없음을, 오류이면 NULL을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c35d0fb0b3b672f40f8ed22b6a36b98bc32ccd79" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt;&lt;code&gt;ndarray.round&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;decimals&lt;/em&gt;, &lt;em&gt;out&lt;/em&gt;). Returns the array with elements rounded to the nearest decimal place. The decimal place is defined as the</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.round#numpy.ndarray.round&quot;&gt; &lt;code&gt;ndarray.round&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;decimals&lt;/em&gt; , &lt;em&gt;out&lt;/em&gt; ). 가장 가까운 소수점 자리로 반올림 된 요소가있는 배열을 반환합니다. 소수점 이하 자릿수는</target>
        </trans-unit>
        <trans-unit id="77c91912c2f0496c5da34bf18831db8c3ec272aa" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt;&lt;code&gt;ndarray.searchsorted&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;values&lt;/em&gt;, &lt;em&gt;side&lt;/em&gt;, &lt;em&gt;perm&lt;/em&gt;). Assuming &lt;em&gt;self&lt;/em&gt; is a 1-d array in ascending order, then the output is an array of indices the same shape as &lt;em&gt;values&lt;/em&gt; such that, if the elements in &lt;em&gt;values&lt;/em&gt; were inserted before the indices, the order of &lt;em&gt;self&lt;/em&gt; would be preserved. No checking is done on whether or not self is in ascending order.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.searchsorted#numpy.ndarray.searchsorted&quot;&gt; &lt;code&gt;ndarray.searchsorted&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;values&lt;/em&gt; , &lt;em&gt;side&lt;/em&gt; , &lt;em&gt;perm&lt;/em&gt; ). 가정 &lt;em&gt;자기하는&lt;/em&gt; 승순의 1 차원 배열이며, 출력은 동일한 형상 인덱스 배열을 인 &lt;em&gt;값&lt;/em&gt; 의 요소 경우 그에 따라, &lt;em&gt;값이&lt;/em&gt; 인덱스 앞에 삽입하고, 순서 &lt;em&gt;자체는&lt;/em&gt; 보존 될 수는. self가 오름차순인지 여부에 대한 점검은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="129c27494826551cd6d91c742839f2dd3b7a2b39" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt;&lt;code&gt;ndarray.setfield&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;val&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt; ). Set the field starting at &lt;em&gt;offset&lt;/em&gt; in bytes and of the given &lt;em&gt;dtype&lt;/em&gt; to &lt;em&gt;val&lt;/em&gt;. The &lt;em&gt;offset&lt;/em&gt; plus &lt;em&gt;dtype&lt;/em&gt; -&amp;gt;elsize must be less than &lt;em&gt;self&lt;/em&gt; -&amp;gt;descr-&amp;gt;elsize or an error is raised. Otherwise, the &lt;em&gt;val&lt;/em&gt; argument is converted to an array and copied into the field pointed to. If necessary, the elements of &lt;em&gt;val&lt;/em&gt; are repeated to fill the destination array, But, the number of elements in the destination must be an integer multiple of the number of elements in &lt;em&gt;val&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.setfield#numpy.ndarray.setfield&quot;&gt; &lt;code&gt;ndarray.setfield&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;발&lt;/em&gt; , &lt;em&gt;DTYPE&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; ). 바이트 단위의 &lt;em&gt;오프셋&lt;/em&gt; 에서 시작 하여 지정된 &lt;em&gt;dtype의 필드&lt;/em&gt; 를 &lt;em&gt;val로 설정하십시오&lt;/em&gt; . &lt;em&gt;오프셋&lt;/em&gt; 플러스 &lt;em&gt;DTYPE은&lt;/em&gt; -&amp;gt; elsize 미만이어야합니다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; descr-&amp;gt; elsize 또는 오류가 발생합니다 -. 그렇지 않으면, &lt;em&gt;val&lt;/em&gt; 인수는 배열로 변환되어 지정된 필드에 복사됩니다. 필요한 경우 &lt;em&gt;val&lt;/em&gt; 의 요소 는 대상 배열을 채우기 위해 반복되지만 대상의 요소 수는 요소의 수의 정수배 여야합니다.&lt;em&gt;val&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="329e170888d304760a845c23e2123d83a997ded2" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt;&lt;code&gt;ndarray.sort&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;kind&lt;/em&gt;). Return an array with the items of &lt;em&gt;self&lt;/em&gt; sorted along &lt;em&gt;axis&lt;/em&gt;. The array is sorted using the algorithm denoted by &lt;em&gt;kind&lt;/em&gt; , which is an integer/enum pointing to the type of sorting algorithms used.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.sort#numpy.ndarray.sort&quot;&gt; &lt;code&gt;ndarray.sort&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; , &lt;em&gt;kind&lt;/em&gt; ). &lt;em&gt;axis를&lt;/em&gt; 따라 &lt;em&gt;자체&lt;/em&gt; 정렬 된 항목이있는 배열을 반환합니다 . 배열은 &lt;em&gt;kind&lt;/em&gt; 로 표시된 알고리즘을 사용하여 정렬되며, 사용되는 정렬 알고리즘의 유형을 가리키는 정수 / 열입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="18f23f95a5677bb30c45f3519a8a38c4eb9ab14d" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt;&lt;code&gt;ndarray.squeeze&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a new view of &lt;em&gt;self&lt;/em&gt; with all of the dimensions of length 1 removed from the shape.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.squeeze#numpy.ndarray.squeeze&quot;&gt; &lt;code&gt;ndarray.squeeze&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . 길이 1의 모든 치수가 모양에서 제거 된 상태에서 새로운 &lt;em&gt;자기&lt;/em&gt; 뷰를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="f3ea257f6db1c3b5b426fb4027029e9f1b7413a5" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt;&lt;code&gt;ndarray.std&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the standard deviation using data along &lt;em&gt;axis&lt;/em&gt; converted to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">등가 &lt;a href=&quot;generated/numpy.ndarray.std#numpy.ndarray.std&quot;&gt; &lt;code&gt;ndarray.std&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE을&lt;/em&gt; ). &lt;em&gt;축을&lt;/em&gt; 따라 데이터 유형 &lt;em&gt;rtype으로&lt;/em&gt; 변환 된 데이터를 사용하여 표준 편차를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="4c7387b455871f5d5fed3305db644e74b9628876" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt;&lt;code&gt;ndarray.sum&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return 1-d vector sums of elements in &lt;em&gt;self&lt;/em&gt; along &lt;em&gt;axis&lt;/em&gt;. Perform the sum after converting data to data type &lt;em&gt;rtype&lt;/em&gt;.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.sum#numpy.ndarray.sum&quot;&gt; &lt;code&gt;ndarray.sum&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). 소자에서의 1 차원 벡터 합을 돌려 &lt;em&gt;자기&lt;/em&gt; 따라 &lt;em&gt;축&lt;/em&gt; . 데이터를 &lt;em&gt;rtype&lt;/em&gt; 데이터 유형으로 변환 한 후 합계를 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="9b9ac6ba7775647d994932881b5b117c78bc1d61" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt;&lt;code&gt;ndarray.swapaxes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;a1&lt;/em&gt;, &lt;em&gt;a2&lt;/em&gt;). The returned array is a new view of the data in &lt;em&gt;self&lt;/em&gt; with the given axes, &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt;, swapped.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.swapaxes#numpy.ndarray.swapaxes&quot;&gt; &lt;code&gt;ndarray.swapaxes&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;A1&lt;/em&gt; , &lt;em&gt;A2&lt;/em&gt; ). 반환 된 배열은 지정된 축 &lt;em&gt;a1&lt;/em&gt; 과 &lt;em&gt;a2&lt;/em&gt; 가 교체 된 &lt;em&gt;자체&lt;/em&gt; 데이터의 새로운 뷰입니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="526d5a8267bf48a76f6e4bef39106e81c90185a6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt;&lt;code&gt;ndarray.take&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;, &lt;em&gt;ret&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt;) except &lt;em&gt;axis&lt;/em&gt; =None in Python is obtained by setting &lt;em&gt;axis&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; in C. Extract the items from self indicated by the integer-valued &lt;em&gt;indices&lt;/em&gt; along the given &lt;em&gt;axis.&lt;/em&gt; The clipmode argument can be &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt; to indicate what to do with out-of-bound indices. The &lt;em&gt;ret&lt;/em&gt; argument can specify an output array rather than having one created internally.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.take#numpy.ndarray.take&quot;&gt; &lt;code&gt;ndarray.take&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;인덱스&lt;/em&gt; , &lt;em&gt;축&lt;/em&gt; , &lt;em&gt;RET&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; 제외) &lt;em&gt;축&lt;/em&gt; = 파이썬 없음 설정함으로써 얻을 수 없다 &lt;em&gt;축&lt;/em&gt; = &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; 를&lt;/a&gt; 자기 정수 값에 의해 표시로부터 항목을 추출 C.에서 &lt;em&gt;인덱스&lt;/em&gt; 주어진 따라 &lt;em&gt;축.&lt;/em&gt; clipmode 인수가 될 수 &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; 는&lt;/a&gt; 아웃 오브 바운드 인덱스 수행 할 작업을 나타냅니다. &lt;em&gt;RET의&lt;/em&gt; 인수보다는 내부를 생성하는 것보다 출력 배열을 지정할 수있다.</target>
        </trans-unit>
        <trans-unit id="3fbb6db45f5065f7d5f46448fca11ee7f459d488" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;). Return the bytes of this array in a Python string.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ). 이 배열의 바이트를 파이썬 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e1487cf1aae9421a58178865b5cc518907b872e6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt;&lt;code&gt;ndarray.tolist&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;). Return a nested Python list from &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.tolist#numpy.ndarray.tolist&quot;&gt; &lt;code&gt;ndarray.tolist&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;self&lt;/em&gt; 에서 중첩 된 Python 목록을 반환하십시오 .</target>
        </trans-unit>
        <trans-unit id="92f6eaf18a532cc83a7879c0fc5e0cdb9219ac58" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt;&lt;code&gt;ndarray.trace&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;offset&lt;/em&gt;, &lt;em&gt;axis1&lt;/em&gt;, &lt;em&gt;axis2&lt;/em&gt;, &lt;em&gt;rtype&lt;/em&gt;). Return the sum (using &lt;em&gt;rtype&lt;/em&gt; as the data type of summation) over the &lt;em&gt;offset&lt;/em&gt; diagonal elements of the 2-d arrays defined by &lt;em&gt;axis1&lt;/em&gt; and &lt;em&gt;axis2&lt;/em&gt; variables. A positive offset chooses diagonals above the main diagonal. A negative offset selects diagonals below the main diagonal.</source>
          <target state="translated">상당 &lt;a href=&quot;generated/numpy.ndarray.trace#numpy.ndarray.trace&quot;&gt; &lt;code&gt;ndarray.trace&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;자기&lt;/em&gt; , &lt;em&gt;오프셋&lt;/em&gt; , &lt;em&gt;1 축&lt;/em&gt; , &lt;em&gt;축 2&lt;/em&gt; , &lt;em&gt;RTYPE&lt;/em&gt; ). (사용 합 돌아 &lt;em&gt;RTYPE를&lt;/em&gt; 오버 합계의 데이터 형식으로) &lt;em&gt;오프셋&lt;/em&gt; 에 의해 정의되는 2 차원 어레이의 대각선 요소 &lt;em&gt;에서 축&lt;/em&gt; 과 &lt;em&gt;, 축&lt;/em&gt; 변수. 양의 오프셋은 주 대각선 위의 대각선을 선택합니다. 음수 오프셋은 주 대각선 아래의 대각선을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="903dc5f64afb6611725d0b8ef7bd16c3db35ef02" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;ndarray.transpose&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;permute&lt;/em&gt;). Permute the axes of the ndarray object &lt;em&gt;self&lt;/em&gt; according to the data structure &lt;em&gt;permute&lt;/em&gt; and return the result. If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the resulting array has its axes reversed. For example if &lt;em&gt;self&lt;/em&gt; has shape</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;ndarray.transpose&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;permute&lt;/em&gt; ). 데이터 구조 &lt;em&gt;치환&lt;/em&gt; 에 따라 ndarray 객체 &lt;em&gt;자체&lt;/em&gt; 의 축을 &lt;em&gt;치환&lt;/em&gt; 하고 결과를 반환합니다. 경우 &lt;em&gt;변경하다가&lt;/em&gt; 있다 &lt;code&gt;NULL&lt;/code&gt; , 그 결과 어레이는 반전 축을 갖는다. 예를 들어 &lt;em&gt;자기&lt;/em&gt; 모양이</target>
        </trans-unit>
        <trans-unit id="2e84dfaf00361747bc32ce6d08fe80d8b155279f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt;&lt;code&gt;ndarray.view&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;dtype&lt;/em&gt;). Return a new view of the array &lt;em&gt;self&lt;/em&gt; as possibly a different data-type, &lt;em&gt;dtype&lt;/em&gt;, and different array subclass &lt;em&gt;ptype&lt;/em&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.view#numpy.ndarray.view&quot;&gt; &lt;code&gt;ndarray.view&lt;/code&gt; &lt;/a&gt; 와 동일합니다 ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;dtype&lt;/em&gt; ). 배열 &lt;em&gt;자체&lt;/em&gt; 의 새로운 뷰를 다른 데이터 유형, &lt;em&gt;dtype&lt;/em&gt; 및 다른 배열 서브 클래스 &lt;em&gt;ptype으로 &lt;/em&gt;&lt;em&gt;리턴하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="502c90e7fe3ae2afa2f6265d26a3658ae879c43e" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 를 사용 하여 매크로가 공백으로 대체되는지 여부를 결정 &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 점을 제외하면 Py_BEGIN_ALLOW_THREADS 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="c80f2487a92354ad196d90ca737086d6a28cb501" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">동등 &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_BEGIN_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 이 사용 제외 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 를 매크로 공백 여부로 대체하는 경우를 결정하기 위해.</target>
        </trans-unit>
        <trans-unit id="473285d07f7845f243564b45b66377ccc7b9ae4c" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt;&lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ALLOW_THREADS&quot;&gt; &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 를 사용 하여 매크로가 공백으로 대체되는지 여부를 결정 &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 점을 제외하면 Py_END_ALLOW_THREADS 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="657a5eba5419e2937f0d7b0877025c3f2a8bf379" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt;&lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt;&lt;/a&gt; except it uses &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; to determine if the macro if replaced with white-space or not.</source>
          <target state="translated">동등 &lt;a href=&quot;https://docs.python.org/dev/c-api/init.html#c.Py_END_ALLOW_THREADS&quot;&gt; &lt;code&gt;Py_END_ALLOW_THREADS&lt;/code&gt; &lt;/a&gt; 이 사용 제외 &lt;code&gt;NPY_ALLOW_THREADS&lt;/code&gt; 를 매크로 공백 여부로 대체하는 경우를 결정하기 위해.</target>
        </trans-unit>
        <trans-unit id="821886e91092ad64682392ad985ffcb281eaf4b3" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; and &lt;code&gt;np.cos(1j*x)&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;1/2 * (np.exp(x) + np.exp(-x))&lt;/code&gt; 및 &lt;code&gt;np.cos(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cedbe2e2d0fc9bc98c2a4058eb21de10f0ba961" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; or &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;1/2 * (np.exp(x) - np.exp(-x))&lt;/code&gt; 또는 &lt;code&gt;-1j * np.sin(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65cabfa0a0b1ab314bf5ad313943ea0a61c9f913" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;a.copy(order='K')&lt;/code&gt;.</source>
          <target state="translated">상당 &lt;code&gt;a.copy(order='K')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8b0df6f8f30decfdb8712f593677bd0361c0ef" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;divmod(x, 1)&lt;/code&gt; for positive &lt;code&gt;x&lt;/code&gt; with the return values switched.</source>
          <target state="translated">리턴 값이 전환 된 양의 &lt;code&gt;x&lt;/code&gt; 에 대한 &lt;code&gt;divmod(x, 1)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="3f28125a3d825d23c8591cf7b44d136f5206aec6" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;m[::-1,...]&lt;/code&gt;. Does not require the array to be two-dimensional.</source>
          <target state="translated">동등 &lt;code&gt;m[::-1,...]&lt;/code&gt; . 배열이 2 차원 일 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="158b7bdd2f113f05d23975a3a9ae7c4cbbee72c4" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(self)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.asarray(self)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7b757950b99b3fb5a49cac119260ff6b59afd089" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</source>
          <target state="translated">등가 &lt;code&gt;np.asarray(x).ravel()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="01b942f822242874c950f31737a64908f9f10037" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; element-wise.</source>
          <target state="translated">요소 별 &lt;code&gt;np.sin(x)/np.cos(x)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="e03e98ed258ef214f7093f680237951ada6cdb9f" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; or &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt;.</source>
          <target state="translated">당량 &lt;code&gt;np.sinh(x)/np.cosh(x)&lt;/code&gt; 또는 &lt;code&gt;-1j * np.tan(1j*x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6b5ff4ad03763736f9b2a4f6770ab65b1c73219" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;np.transpose(self)&lt;/code&gt; if &lt;code&gt;self&lt;/code&gt; is real-valued.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 실수 인 경우 &lt;code&gt;np.transpose(self)&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="75b818defe3ad1876ebfb087b965f01d49fa2ec9" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt;, element-wise. If &lt;code&gt;x1&lt;/code&gt; or &lt;code&gt;x2&lt;/code&gt; is scalar_like (i.e., unambiguously cast-able to a scalar type), it is broadcast for use with each element of the other argument. (See Examples)</source>
          <target state="translated">상당 &lt;code&gt;sqrt(x1**2 + x2**2)&lt;/code&gt; , 소자 현명. 경우 &lt;code&gt;x1&lt;/code&gt; 또는 &lt;code&gt;x2&lt;/code&gt; scalar_like (즉, 명확하게 주조 할 수 스칼라 타입)입니다, 그것은 다른 인수의 각 요소와 함께 사용하기 위해 방송된다. (실시 예 참조)</target>
        </trans-unit>
        <trans-unit id="00df9c133fe8747499700e75effeb0cd5d136ccc" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x.copy()&lt;/code&gt;, but only defined for types that support arithmetic.</source>
          <target state="translated">&lt;code&gt;x.copy()&lt;/code&gt; 와 동일 하지만 산술을 지원하는 유형에 대해서만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="23adb20441299c90dbd1e383cfab76bf7d2274b8" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1 - x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">어레이 브로드 캐스팅 측면에서 &lt;code&gt;x1 - x2&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="2c304ff74936613f3d12e0fc5cde4c506dd3f3ab" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">어레이 브로드 캐스팅 측면에서 &lt;code&gt;x1&lt;/code&gt; * &lt;code&gt;x2&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="98520850afe8056507d9d642ea9323b3ed72e130" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; in terms of array broadcasting.</source>
          <target state="translated">어레이 브로드 캐스팅 측면에서 &lt;code&gt;x1&lt;/code&gt; + &lt;code&gt;x2&lt;/code&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="202bf1615636b8e0a84392691bc084a70b43390b" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.put(&lt;em&gt;values&lt;/em&gt;, &lt;em&gt;indices&lt;/em&gt;, &lt;em&gt;clipmode&lt;/em&gt; ). Put &lt;em&gt;values&lt;/em&gt; into &lt;em&gt;self&lt;/em&gt; at the corresponding (flattened) &lt;em&gt;indices&lt;/em&gt;. If &lt;em&gt;values&lt;/em&gt; is too small it will be repeated as necessary.</source>
          <target state="translated">상당 &lt;em&gt;자기&lt;/em&gt; .put ( &lt;em&gt;값&lt;/em&gt; , &lt;em&gt;인덱스&lt;/em&gt; , &lt;em&gt;clipmode&lt;/em&gt; ). 해당 (평평한) &lt;em&gt;지수&lt;/em&gt; 에서 &lt;em&gt;자체&lt;/em&gt; 에 &lt;em&gt;값&lt;/em&gt; 을 넣 습니다 . 경우 &lt;em&gt;값이&lt;/em&gt; 너무 작은 필요에 따라 반복됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="65d607762120cf690bb00c590b16fa127fb75062" translate="yes" xml:space="preserve">
          <source>Equivalent to &lt;em&gt;self&lt;/em&gt;.ravel(&lt;em&gt;order&lt;/em&gt;). Same basic functionality as &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt;&lt;code&gt;PyArray_Flatten&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;self&lt;/em&gt;, &lt;em&gt;order&lt;/em&gt;) except if &lt;em&gt;order&lt;/em&gt; is 0 and &lt;em&gt;self&lt;/em&gt; is C-style contiguous, the shape is altered but no copy is performed.</source>
          <target state="translated">&lt;em&gt;self&lt;/em&gt; .ravel ( &lt;em&gt;order&lt;/em&gt; ) 와 같습니다 . &lt;em&gt;order&lt;/em&gt; 가 0이고 &lt;em&gt;self&lt;/em&gt; 가 C 스타일 인 경우 모양이 변경되지만 복사는 수행되지 않는 것을 제외하고 &lt;a href=&quot;#c.PyArray_Flatten&quot;&gt; &lt;code&gt;PyArray_Flatten&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;self&lt;/em&gt; , &lt;em&gt;order&lt;/em&gt; ) 과 동일한 기본 기능 입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9032a6cc40438a50e150a4a41ff47d4fe89a4820" translate="yes" xml:space="preserve">
          <source>Equivalent to PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING).</source>
          <target state="translated">PyArray_CanCastTypeTo (fromtype, totype, NPY_SAFE_CASTING)와 같습니다.</target>
        </trans-unit>
        <trans-unit id="aa1dee2d3e2220598a3bbd05e1af8c95afb8286e" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Python의 &lt;code&gt;%&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="c543b869fe6bab79a3a934117c7c6a1eff863d6f" translate="yes" xml:space="preserve">
          <source>Equivalent to Python&amp;rsquo;s &lt;code&gt;//&lt;/code&gt; operator.</source>
          <target state="translated">파이썬의 &lt;code&gt;//&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="731025cc785b584c28e327dc6f1d60cad5cb1eb2" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt;. No check is performed to ensure &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.maximum(a_min, np.minimum(a, a_max))&lt;/code&gt; 와 같지만 빠릅니다 . &lt;code&gt;a_min &amp;lt; a_max&lt;/code&gt; 를 확인하기 위해 점검이 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="6b2f298705887fc3f13bb047301aaf8328f81dca" translate="yes" xml:space="preserve">
          <source>Equivalent to but faster than &lt;code&gt;np.minimum(a_max, np.maximum(a, a_min))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.minimum(a_max, np.maximum(a, a_min))&lt;/code&gt; 동일하지만 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="e127cc159cef630175cb2a2528435fea3e7fcdb3" translate="yes" xml:space="preserve">
          <source>Equivalent to calling &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; from the command line</source>
          <target state="translated">명령 행에서 &lt;code&gt;$ nosetests &amp;lt;argv&amp;gt; &amp;lt;file_to_run&amp;gt;&lt;/code&gt; 을 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ed8f3be106058d41aa3036c07045c7a5df9a7239" translate="yes" xml:space="preserve">
          <source>Equivalent to creating a copy of the array and applying the MaskedArray &lt;code&gt;sort()&lt;/code&gt; method.</source>
          <target state="translated">배열의 복사본을 만들고 MaskedArray &lt;code&gt;sort()&lt;/code&gt; 메서드를 적용하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5b847d0d31d2133c0201a061723b9aa92d8890f7" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_INT or NPY_LONGLONG, depending on the platform.</source>
          <target state="translated">플랫폼에 따라 NPY_INT 또는 NPY_LONGLONG과 같습니다.</target>
        </trans-unit>
        <trans-unit id="85f38ed4c0f6096936fc4b84fb6a21d19adcc1cb" translate="yes" xml:space="preserve">
          <source>Equivalent to either NPY_UINT or NPY_ULONGLONG, depending on the platform.</source>
          <target state="translated">플랫폼에 따라 NPY_UINT 또는 NPY_ULONGLONG과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d656dbe889cfc08e9f09fa23957b7de58cae8caa" translate="yes" xml:space="preserve">
          <source>Equivalent to m[:,::-1]. Requires the array to be at least 2-D.</source>
          <target state="translated">m [:, ::-1]과 같습니다. 배열이 2D 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1215aa39e41289b1c51c145e05d1743101aa9773" translate="yes" xml:space="preserve">
          <source>Equivalent to running:</source>
          <target state="translated">실행과 동일 :</target>
        </trans-unit>
        <trans-unit id="5a910d755d7e89acbf27b19fb05f069771ab0e7b" translate="yes" xml:space="preserve">
          <source>Equivalent to the Python &lt;code&gt;%&lt;/code&gt; operator.</source>
          <target state="translated">Python &lt;code&gt;%&lt;/code&gt; 연산자 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="d371f28bfea1e852f448381bb4f0bdfccaa7149e" translate="yes" xml:space="preserve">
          <source>Equivalent to:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f2c299359dd358c2f6f22a22ce8b45b901e994e8" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;&lt;code&gt;mask&lt;/code&gt; attribute.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; &lt;code&gt;mask&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6eed85d2c6463174f53200b994de55fedca2fe50" translate="yes" xml:space="preserve">
          <source>Equivalently use the &lt;code&gt;MaskedArray&lt;/code&gt;&lt;code&gt;data&lt;/code&gt; attribute.</source>
          <target state="translated">마찬가지로 &lt;code&gt;MaskedArray&lt;/code&gt; &lt;code&gt;data&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="e59ba61683ec6d73dab0ba426c13a6a7d9ed31cf" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, the last two lines would be:</source>
          <target state="translated">마찬가지로 내부 루프를 제거하면 마지막 두 줄은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6b59734e1b8f67d36df303549c4673ff4f6c8d66" translate="yes" xml:space="preserve">
          <source>Equivalently, eliminating the inner loop, this can be expressed as:</source>
          <target state="translated">마찬가지로 내부 루프를 제거하면 다음과 같이 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28b75128748a47d2bb367541f76250db5dd9b6a0" translate="yes" xml:space="preserve">
          <source>Equivalently:</source>
          <target state="translated">Equivalently:</target>
        </trans-unit>
        <trans-unit id="149658b77c9d6e6cef1bb293ac32b781ccfe7dbd" translate="yes" xml:space="preserve">
          <source>Eric Wieser</source>
          <target state="translated">에릭 위저</target>
        </trans-unit>
        <trans-unit id="73631d7f0356fdbdeaa36f8e5dbad89c6aa15dc4" translate="yes" xml:space="preserve">
          <source>Error handling</source>
          <target state="translated">오류 처리</target>
        </trans-unit>
        <trans-unit id="5f577c8bef8739558c43df8e8796bc8e5a825a61" translate="yes" xml:space="preserve">
          <source>Error objects</source>
          <target state="translated">오류 객체</target>
        </trans-unit>
        <trans-unit id="f13df400826d5582075c86f7280e918d94d2f9f5" translate="yes" xml:space="preserve">
          <source>Error type changes</source>
          <target state="translated">오류 유형 변경</target>
        </trans-unit>
        <trans-unit id="4884820cd63fe6870fd18f5bb40f96cacf7c1253" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values</source>
          <target state="translated">x가 스칼라 입력일 때 첫 번째 인수와 두 번째 인수의 모양이 다르거 나 첫 번째 인수의 복소수 값이있는 경우 두 번째 인수도 제공하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="68e944c31c80a964e18589df952c8e941c618fb2" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is also supplied when x is a scalar input, if first and second arguments have different shapes, or if the first argument has complex values.</source>
          <target state="translated">x가 스칼라 입력일 때 첫 번째 인수와 두 번째 인수의 모양이 다르거 나 첫 번째 인수의 복소수 값이있는 경우 두 번째 인수도 제공하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6896dc5d66baa055255d6a61e0f3010c1fcb944f" translate="yes" xml:space="preserve">
          <source>Errors result if the second argument is supplied when the first argument is a scalar, or if the first and second arguments have different shapes.</source>
          <target state="translated">첫 번째 인수가 스칼라 일 때 두 번째 인수가 제공되거나 첫 번째 인수와 두 번째 인수의 모양이 다른 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e6308f5d5324d30901fdba46e76a6baf1ab30827" translate="yes" xml:space="preserve">
          <source>Establish a timeline for mediation to complete, ideally within two weeks.</source>
          <target state="translated">중재를 완료하는 데 필요한 일정을 2 주 이내에 설정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="8e5c90765bd01e407f47b56e1714c9f9bd1ace4b" translate="yes" xml:space="preserve">
          <source>Estimate a covariance matrix, given data and weights.</source>
          <target state="translated">데이터와 가중치가 주어진 공분산 행렬을 추정합니다.</target>
        </trans-unit>
        <trans-unit id="3ff0c8c72ff670edbc5bdbae93aa2dbd2e54c4c0" translate="yes" xml:space="preserve">
          <source>Estimate the covariance matrix.</source>
          <target state="translated">공분산 행렬을 추정합니다.</target>
        </trans-unit>
        <trans-unit id="2e86acb34f53f4c550f3dcf28b42823f0f59d900" translate="yes" xml:space="preserve">
          <source>Estimator based on leave-one-out cross-validation estimate of the integrated squared error. Can be regarded as a generalization of Scott&amp;rsquo;s rule.</source>
          <target state="translated">적분 제곱 오차의 일대일 교차 검증 유효성에 기초한 추정값입니다. Scott 규칙의 일반화로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="35592e888d12a9934594d9f1f111830a7b9f7f37" translate="yes" xml:space="preserve">
          <source>Estimator does not take variability into account, only data size. Commonly overestimates number of bins required.</source>
          <target state="translated">Estimator는 가변성을 고려하지 않고 데이터 크기 만 고려합니다. 일반적으로 필요한 쓰레기통 수를 과대 평가합니다.</target>
        </trans-unit>
        <trans-unit id="da87f1093e8c246b1f6d85fea3650000b6da3790" translate="yes" xml:space="preserve">
          <source>Euler&amp;rsquo;s constant, base of natural logarithms, Napier&amp;rsquo;s constant.</source>
          <target state="translated">오일러 상수, 자연 로그의 기초, 네이피어 상수.</target>
        </trans-unit>
        <trans-unit id="f91dd3dbbfae685abb68bc410da02d957a011629" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="e05e0d192839700194b0291808ce8475fe0d0cc1" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Chebyshev series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="7249c2fe23f2e17738db2110e9c2474dc3a27187" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 Hermite 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="12ed956c99b6390def2dd7ee918ef9474cc02f06" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Hermite series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2-D Hermite 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="cedce799e74482d1942c64f4cd11a5b3fd98c128" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 HermiteE 계열을 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="48cc948294af1d7f259543794e3f125d854efce7" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D HermiteE series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 HermiteE 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="338d5b747397dce60dd29055f57344efa1d37666" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 Laguerre 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="4a829f126487a9ec9a923ab666b31db182581736" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Laguerre series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 Laguerre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="bb447e6da0b73bad544e19cbcbc6052261416eb9" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series at points (x, y).</source>
          <target state="translated">포인트 (x, y)에서 2D Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="7373a9e22eb3236ef35b254cc0cb7ed7d29c6948" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D Legendre series on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="a527503bfcf8c4cb30f6f6943d6775ba7732cdef" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial at points (x, y).</source>
          <target state="translated">점 (x, y)에서 2 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="03726da2d6f02abab8a254ba40a2a300ecaef683" translate="yes" xml:space="preserve">
          <source>Evaluate a 2-D polynomial on the Cartesian product of x and y.</source>
          <target state="translated">x와 y의 데카르트 곱에서 2 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="9029d2c825f46990756a36847b1a1b6ef93e7f31" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="6e0bda3c65d8c3458e685987ef115c2f03e1ce48" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Chebyshev series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ae23b9ad402238d53a7767ef4d1d0feecad8d46a" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 Hermite 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1fa86ea2fa2a78cb282ebd3e58571d4035e81572" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 Hermite 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="e0e36a6aa699aa19c71e1fd7089481c08a161992" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D HermiteE series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 HermiteE 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="645e8b8ce98d2275a7fb6f40acce5d53b7f2ad81" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Hermite_e series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 Hermite_e 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ea580f96650cb24e9fc6eb589c30aba361084e3d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 Laguerre 계열을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="345ed8afbed95aea3201f6d8df2e9d955fe4ee9d" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Laguerre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 Laguerre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="fc1af478b3c58299201cb5fd893a359ec10739ca" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3D Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="888774bb82f3f8de5edab168d25dbd0a2eb3d033" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D Legendre series on the Cartesian product of x, y, and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3D Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="e8846df08e194f124fe8cded1c782376715e8f39" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial at points (x, y, z).</source>
          <target state="translated">점 (x, y, z)에서 3 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="33f78fc3c5ae1454f9df0431d3f3fda38023ac26" translate="yes" xml:space="preserve">
          <source>Evaluate a 3-D polynomial on the Cartesian product of x, y and z.</source>
          <target state="translated">x, y 및 z의 데카르트 곱에서 3 차원 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8b4e7acfc43ebffbd9c6285f10ac1b60b175795c" translate="yes" xml:space="preserve">
          <source>Evaluate a Chebyshev series at points x.</source>
          <target state="translated">포인트 x에서 체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="1f4ce01843c1515b967b600cb8fa4018d3436eaa" translate="yes" xml:space="preserve">
          <source>Evaluate a Laguerre series at points x.</source>
          <target state="translated">포인트 x에서 Laguerre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="161f6a7aae0d5d7f196e5ee0e04ba73d7963b76b" translate="yes" xml:space="preserve">
          <source>Evaluate a Legendre series at points x.</source>
          <target state="translated">포인트 x에서 Legendre 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="1cc49d22e70eea61f6bdc96018100e105aba00e0" translate="yes" xml:space="preserve">
          <source>Evaluate a piecewise-defined function.</source>
          <target state="translated">구간 별 함수를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="79a283e785c7b9ab6cbfe6dbfe59b713502d0afb" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at points x.</source>
          <target state="translated">점 x에서 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ac86c84a106ffc30d8eceed0ff68761b61ebad9a" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial at specific values.</source>
          <target state="translated">특정 값에서 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="283714fe4f49f84ab071c16c98a04aac5c0eb13d" translate="yes" xml:space="preserve">
          <source>Evaluate a polynomial specified by its roots at points x.</source>
          <target state="translated">x 점에서 근에 의해 지정된 다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="5ae76cb25d3ddcb8fd7f5add4137cfe2c33287a6" translate="yes" xml:space="preserve">
          <source>Evaluate an Hermite series at points x.</source>
          <target state="translated">포인트 x에서 Hermite 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="ce1ba49b7053d6908dd1d4b7a38524a5c4ffc2df" translate="yes" xml:space="preserve">
          <source>Evaluate an HermiteE series at points x.</source>
          <target state="translated">포인트 x에서 HermiteE 시리즈를 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="a389fe7d0ca7745a323c209ce5b023a9e30716fa" translate="yes" xml:space="preserve">
          <source>Evaluate the polynomial at</source>
          <target state="translated">다항식 평가</target>
        </trans-unit>
        <trans-unit id="201867eba810e127d20356b4920cc833601a5f27" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the iterator has not looped through all of the elements, otherwise it evaluates FALSE.</source>
          <target state="translated">반복자가 모든 요소를 ​​반복하지 않는 한 TRUE를 평가하고, 그렇지 않으면 FALSE를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a61e7944eeb541b39ec48ef4572671aa9245dfe1" translate="yes" xml:space="preserve">
          <source>Evaluates TRUE as long as the multi-iterator has not looped through all of the elements (of the broadcasted result), otherwise it evaluates FALSE.</source>
          <target state="translated">다중 반복자가 브로드 캐스트 된 결과의 모든 요소를 ​​반복하지 않는 한 TRUE를 평가하고, 그렇지 않으면 FALSE를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="22e5fc7652637561dc1ca3671ce7888c08020803" translate="yes" xml:space="preserve">
          <source>Evaluates a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8f5b426162065bbed8197ac088255c41cba4b070" translate="yes" xml:space="preserve">
          <source>Evaluates a Hermite series.</source>
          <target state="translated">은자 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="df7f15c01da2df8b851fc9f6e1e067fbbad7da62" translate="yes" xml:space="preserve">
          <source>Evaluates a Laguerre series.</source>
          <target state="translated">Laguerre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="24200a16cfb4d36b211f0c64c8db3868f1aa7d7b" translate="yes" xml:space="preserve">
          <source>Evaluates a Legendre series.</source>
          <target state="translated">Legendre 시리즈를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="85ee46dc575694a88add8fcac6da5ac9ea0ec2c1" translate="yes" xml:space="preserve">
          <source>Evaluates a polynomial.</source>
          <target state="translated">다항식을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="c6780dad55d1f852632365f7570aa643328d5b06" translate="yes" xml:space="preserve">
          <source>Evaluates as True if arrays &lt;em&gt;a1&lt;/em&gt; and &lt;em&gt;a2&lt;/em&gt; have the same shape.</source>
          <target state="translated">배열 &lt;em&gt;a1&lt;/em&gt; 과 &lt;em&gt;a2&lt;/em&gt; 의 모양이 동일한 경우 True로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="14b73bad8268092556c3d59c6262a1db866e29f2" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is FORTRAN ordered.</source>
          <target state="translated">참으로 평가하여하는 경우 &lt;code&gt;a&lt;/code&gt; FORTRAN 주문이다.</target>
        </trans-unit>
        <trans-unit id="74face1b8e76f520379a33453af827275b42370d" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is a contiguous array. Equivalent to &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 연속 배열 인 경우 true로 평가됩니다 . &lt;code&gt;(PyArray_ISCONTIGUOUS(a))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="6a92de714017736a8a012563cdae53ed5c18d733" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;code&gt;a&lt;/code&gt; is non-&lt;code&gt;NULL&lt;/code&gt; and can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 캐스트 할 수있는 경우 true로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="30b857f72fdd592a4e93e214be9f6a2a22f1daa5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 가 데이터 유형 객체 인 경우 true로 평가됩니다 ( &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="1b0b459a4df746d063d9691e5dca8206407e50e5" translate="yes" xml:space="preserve">
          <source>Evaluates as true if &lt;em&gt;obj&lt;/em&gt; is a data-type object ( &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 가 데이터 유형 객체 ( &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; ) 이면 참으로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="01d60164442fc0f55a5557baa1dde2ec4ee3a192" translate="yes" xml:space="preserve">
          <source>Evaluates as true if the data buffer of &lt;code&gt;a&lt;/code&gt; uses native byte order. Equivalent to &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt;.</source>
          <target state="translated">의 데이터 버퍼 가 기본 바이트 순서를 사용 &lt;code&gt;a&lt;/code&gt; 경우 true로 평가됩니다 . &lt;code&gt;(PyArray_ISNOTSWAPPED(a))&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dcbfc3fc7cd5c92daad9c6700316991a65012cae" translate="yes" xml:space="preserve">
          <source>Evaluates pyfunc over input arrays using broadcasting rules of numpy.</source>
          <target state="translated">numpy의 브로드 캐스팅 규칙을 사용하여 입력 배열에 대해 pyfunc를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="88a80c85f7d09b073fbd515eb093798e576dcd94" translate="yes" xml:space="preserve">
          <source>Evaluates the Einstein summation convention on the operands.</source>
          <target state="translated">피연산자에 대한 아인슈타인 요약 규칙을 평가합니다.</target>
        </trans-unit>
        <trans-unit id="09f56994a692d463245ca900188d259358a1a1e3" translate="yes" xml:space="preserve">
          <source>Evaluates the lowest cost contraction order for an einsum expression by considering the creation of intermediate arrays.</source>
          <target state="translated">중간 배열 생성을 고려하여 이인 식에 대한 최저 비용 수축 순서를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a4fdb9cdb108616be69434eab1761cc78b88d33b" translate="yes" xml:space="preserve">
          <source>Evaluates to a pointer of type &lt;code&gt;void*&lt;/code&gt; that points to the data buffer of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">a가 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 캐스트 될 수 있다고 가정 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; 의 데이터 버퍼를 가리키는 &lt;code&gt;void*&lt;/code&gt; 유형의 포인터를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="5b165cdcba7dabc88d6d0700bab2cea35959b8e6" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the lengths of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">형의 배열로 평가 &lt;code&gt;npy_intp&lt;/code&gt; 및 길이 &lt;code&gt;array_numdims(a)&lt;/code&gt; 의 모든 차원의 길이주는 &lt;code&gt;a&lt;/code&gt; 가정하면, &lt;code&gt;a&lt;/code&gt; (A)에 캐스팅 될 수 &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d18aba4418a76811df39bd817fcca0ecc3daf26" translate="yes" xml:space="preserve">
          <source>Evaluates to an array of type &lt;code&gt;npy_intp&lt;/code&gt; and length &lt;code&gt;array_numdims(a)&lt;/code&gt;, giving the stridess of all of the dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;. A stride is the distance in bytes between an element and its immediate neighbor along the same axis.</source>
          <target state="translated">&lt;code&gt;npy_intp&lt;/code&gt; 유형 과 길이 &lt;code&gt;array_numdims(a)&lt;/code&gt; 의 배열로 평가하여를 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 캐스트 할 수 있다고 가정 &lt;code&gt;a&lt;/code&gt; 의 모든 차원에 &lt;code&gt;a&lt;/code&gt; 보폭을 제공합니다 . 보폭은 동일한 축을 따라 요소와 바로 인접한 요소 사이의 바이트 단위 거리입니다.</target>
        </trans-unit>
        <trans-unit id="ee0a95426dfe5b7eb47ffd5ae2f4fb51edb35193" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th dimension size of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">평가 &lt;code&gt;i&lt;/code&gt; 의 번째 차원 크기 가정하면, &lt;code&gt;a&lt;/code&gt; (A)에 전송할 수있다 &lt;code&gt;PyArrayObject*&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d4d289826f9e7f76dff23ce9b5a0d1ae92ad3cc" translate="yes" xml:space="preserve">
          <source>Evaluates to the &lt;code&gt;i&lt;/code&gt;-th stride of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">로 평가 &lt;code&gt;i&lt;/code&gt; 번째 보폭의 가정, &lt;code&gt;a&lt;/code&gt; 는 A를 캐스팅 할 수 &lt;code&gt;PyArrayObject*&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32b35e339f75424281676b07ad9e28b079acb58f" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer data type code of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">의 정수 데이터 유형 코드로 평가 가정하면, &lt;code&gt;a&lt;/code&gt; (A)에 전송할 수있다 &lt;code&gt;PyArrayObject*&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60ab5981a7770a6202629fec1405f5cf8e6b68cf" translate="yes" xml:space="preserve">
          <source>Evaluates to the integer number of dimensions of &lt;code&gt;a&lt;/code&gt;, assuming &lt;code&gt;a&lt;/code&gt; can be cast to a &lt;code&gt;PyArrayObject*&lt;/code&gt;.</source>
          <target state="translated">치수의 정수로 평가 &lt;code&gt;a&lt;/code&gt; , 가정 &lt;code&gt;a&lt;/code&gt; (A)에 캐스팅 될 수 &lt;code&gt;PyArrayObject*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0be0f4e7a59afdff5acbdbf74f20f94ceb3fdc16" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is C-style contiguous.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 이 C 스타일 연속 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="ccd3cb113f37e222d005c24c43bbeb4bb385e088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;em&gt;not&lt;/em&gt; C-style contiguous. &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is the correct way to test for Fortran-style contiguity.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 이 Fortran 스타일의 연속적이고 C 스타일의 연속이 &lt;em&gt;아닌&lt;/em&gt; 경우 true를 평가합니다 . &lt;a href=&quot;#c.PyArray_IS_F_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 는 포트란 스타일 연속성을 테스트하는 올바른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="299ed12a95038cc7c47da499ceb2b1bb9bee7088" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 이 포트란 스타일의 연속 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="0c6d7ddd3ec484ead393ec310ff7dd53898345cc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 type이 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 하위 유형 인 Python 객체 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="8d47b6abc57e8489e373d14442e0e135d79d490a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object whose type is a sub-type of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 유형이 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 하위 유형 인 Python 객체 이면 참으로 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="eda799e9981a95fbdf277bb7b4cac9dbe1897388" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 유형의 Python 객체 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="b99992949fa52eb31a616aa72ce3d2db9c377b8a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python object with type &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 유형의 Python 객체 이면 참으로 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="6eeb9c0e570ee6c3d7212996fe6c19be5c590a98" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">만약 참으로 &lt;em&gt;연산이&lt;/em&gt; 파이썬 스칼라 오브젝트 (볼이다 &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; 를&lt;/a&gt; ) 배열 스칼라 (의 서브 타입의 인스턴스 &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ) 또는 서브 타입의 인스턴스 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 차원 0이다.</target>
        </trans-unit>
        <trans-unit id="77128428ecc736c262cee4d932684f9895a30acc" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;), an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt;) or an instance of a sub-type of &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">만약 참으로 &lt;em&gt;연산이&lt;/em&gt; 파이썬 스칼라 오브젝트 (볼이다 &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; 를&lt;/a&gt; ) 배열 스칼라 (의 서브 타입의 인스턴스 &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ) 또는 서브 타입의 인스턴스 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 차원 0이다.</target>
        </trans-unit>
        <trans-unit id="67ae1d1c2d9114996b7543dee8f883c75689b0de" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, bytes, str, long, bool).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 내장 파이썬 스칼라 객체 (int, float, complex, bytes, str, long, bool) 이면 참을 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="782aad878c58725282c24466a66a6d37025e0309" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is a builtin Python scalar object (int, float, complex, str, unicode, long, bool).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 내장 Python 스칼라 객체 (int, float, complex, str, unicode, long, bool) 이면 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="f7b432815e26220931657feceb0900b1d3b25457" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an array iterator (or instance of a subclass of the array iterator type).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 배열 반복자 (또는 배열 반복자 유형의 하위 클래스 인스턴스) 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="72e9df6c71cba94b804e10a331ae768c03dc3136" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 (하위 클래스) 인스턴스 이고 크기가 0 인 경우 true를 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="a92e36e0c44fee9b890a2256c6136f6838cd352e" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of (a subclass of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; and has 0 dimensions.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 (하위 클래스) 인스턴스 이고 차원이 0 이면 참으로 평가 합니다.</target>
        </trans-unit>
        <trans-unit id="5906e8dd00d0a1adb4ea6aa8b5091429c7f25bb2" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt;.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 &lt;code&gt;Py{cls}ArrType_Type&lt;/code&gt; 의 인스턴스 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="4fb6fa662c78b1650cad28ec8017fe594278de63" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is an instance of a builtin numeric type (int, float, complex, long, bool)</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 내장 숫자 유형 (int, float, complex, long, bool)의 인스턴스 인 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="ab21393a2ba887799bdff9d28c50be01d0b70f5b" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either a Python scalar object (see &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt;&lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt;&lt;/a&gt;) or an array scalar (an instance of a sub- type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ).</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 Python 스칼라 객체 ( &lt;a href=&quot;#c.PyArray_IsPythonScalar&quot;&gt; &lt;code&gt;PyArray_IsPythonScalar&lt;/code&gt; &lt;/a&gt; 참조 )이거나 배열 스칼라 ( &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 의 하위 유형 인스턴스) 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="cf7b1413b57bbc99790ccf42c73ff86cedf1427a" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 가 배열 스칼라 ( &lt;code&gt;PyGenericArr_Type&lt;/code&gt; 의 하위 유형 인스턴스) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 차원이 0 인 PyArray_Type (의 서브 클래스) 인스턴스 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="5912b104b67fdb86cc53730cfe7f9447f1497a17" translate="yes" xml:space="preserve">
          <source>Evaluates true if &lt;em&gt;op&lt;/em&gt; is either an array scalar (an instance of a sub-type of &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ), or an instance of (a sub-class of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt; whose dimensionality is 0.</source>
          <target state="translated">만약 참으로 &lt;em&gt;연산이&lt;/em&gt; 어레이 스칼라 (의 서브 타입의 인스턴스 중 하나 인 &lt;code&gt;PyGenericArr_Type&lt;/code&gt; ) 또는 인스턴스 (의 소집단) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 그 차수는 0이다.</target>
        </trans-unit>
        <trans-unit id="82908b45216f6f64aa572e8d9614febf36cdc646" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; can be written to</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역에 쓸 수있는 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="a6798bac58d14b80f66da409bb3101b7acf52c78" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; consists of a single (C-style or Fortran-style) contiguous segment.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역이 단일 (C 스타일 또는 포트란 스타일) 연속 세그먼트로 구성된 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="52d051a4856042792e3562a8cf85f0b04c4a4af1" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, aligned, and in machine byte-order.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 C 스타일의 연속, 정렬 및 기계 바이트 순서 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="e202a99f33c9bfd2e1c5ac0fa0b8a81399b57105" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is C-style contiguous, and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 C 스타일의 연속이고 &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; )가 true 인 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="effc549b6cbff87555006675e1c79c18e43a5365" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous and &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt;&lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) is true.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 포트란 스타일의 연속이고 &lt;a href=&quot;#c.PyArray_ISBEHAVED&quot;&gt; &lt;code&gt;PyArray_ISBEHAVED&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; )가 true 인 경우 true를 평가합니다.</target>
        </trans-unit>
        <trans-unit id="8df904ca22ec2803d50d17cdbf121eedc6d72400" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is Fortran-style contiguous, aligned, and in machine byte-order &lt;strong&gt;.&lt;/strong&gt;</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 포트란 스타일의 연속, 정렬 및 기계 바이트 순서 인 경우 true를 평가합니다 &lt;strong&gt;.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7a1b64683aef87f7f1b4257764cf4227296d827e" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and in machine byte-order.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역이 기계 바이트 순서로 정렬 된 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="f7f20e7e1e5772639b1f7c4eb4bff4d2800f8c2a" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is aligned and writeable and in machine byte-order according to its descriptor.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역이 디스크립터에 따라 기계 바이트 순서로 정렬되고 쓰기 가능한 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="e474d3b13b1be737b699dd99e94b826acd4340ff" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of &lt;em&gt;arr&lt;/em&gt; is properly aligned on the machine.</source>
          <target state="translated">&lt;em&gt;arr&lt;/em&gt; 의 데이터 영역 이 기계에서 올바르게 정렬 된 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="2fa74bf1ebb6946b1363906270140aeda279cf9f" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">배열의 데이터 유형 설명자에 따라 ndarray &lt;em&gt;m&lt;/em&gt; 의 데이터 영역이 기계 바이트 순서 가 &lt;strong&gt;아닌&lt;/strong&gt; 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="3267c071decd2c90623cf8528c8e4938c54505e6" translate="yes" xml:space="preserve">
          <source>Evaluates true if the data area of the ndarray &lt;em&gt;m&lt;/em&gt; is in machine byte-order according to the array&amp;rsquo;s data-type descriptor.</source>
          <target state="translated">배열의 데이터 유형 설명자에 따라 ndarray &lt;em&gt;m&lt;/em&gt; 의 데이터 영역이 기계 바이트 순서 인 경우 true를 평가합니다 .</target>
        </trans-unit>
        <trans-unit id="74157d4f0e365e7c26ee7ae56617ac39f0fc6cb5" translate="yes" xml:space="preserve">
          <source>Evaluation:</source>
          <target state="translated">Evaluation:</target>
        </trans-unit>
        <trans-unit id="bfed403a77ac8bf381d674a3abfc57ba60883a8b" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">연속 배열 &lt;em&gt;의&lt;/em&gt; 경우 &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; 이거나 배열에 요소가없는 경우 지정된 차원 &lt;code&gt;arr.strides[dim]&lt;/code&gt; 대한 보폭은 &lt;em&gt;임의적&lt;/em&gt; 일 수 있습니다 . 일반적으로 C 스타일 연속 배열의 경우 &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 또는 Fortran 스타일 연속 배열의 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; 가 true 라는 것을 일반적으로 주장 하지는 &lt;em&gt;않습니다&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1298a53951ccd9aa53bf4ad3ab74e5154ee53b89" translate="yes" xml:space="preserve">
          <source>Even for contiguous arrays a stride for a given dimension &lt;code&gt;arr.strides[dim]&lt;/code&gt; may be &lt;em&gt;arbitrary&lt;/em&gt; if &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; or the array has no elements. It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true. The correct way to access the &lt;code&gt;itemsize&lt;/code&gt; of an array from the C API is &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt;.</source>
          <target state="translated">연속 배열 &lt;em&gt;의&lt;/em&gt; 경우 &lt;code&gt;arr.shape[dim] == 1&lt;/code&gt; 이거나 배열에 요소가없는 경우 지정된 차원 &lt;code&gt;arr.strides[dim]&lt;/code&gt; 대한 보폭은 &lt;em&gt;임의적&lt;/em&gt; 일 수 있습니다 . 일반적으로 C 스타일 연속 배열의 경우 &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 또는 Fortran 스타일 연속 배열의 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; 가 true 라는 것을 일반적으로 주장 하지는 &lt;em&gt;않습니다&lt;/em&gt; . C API에서 배열 의 항목 &lt;code&gt;itemsize&lt;/code&gt; 에 액세스하는 올바른 방법 은 &lt;code&gt;PyArray_ITEMSIZE(arr)&lt;/code&gt; 입니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="f9827d8888420fb8aa22f4344271feb523136ca5" translate="yes" xml:space="preserve">
          <source>Even though 0 occurs twice in the list of indices, the 0th element is only incremented once. This is because Python requires &amp;ldquo;a+=1&amp;rdquo; to be equivalent to &amp;ldquo;a = a + 1&amp;rdquo;.</source>
          <target state="translated">인덱스 목록에서 0이 두 번 발생하더라도 0 번째 요소는 한 번만 증가합니다. 이것은 파이썬이&amp;ldquo;a + = 1&amp;rdquo;이&amp;ldquo;a = a + 1&amp;rdquo;과 동등하도록 요구하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e92024a025e8d5da08f38acb277e2e10c54a8e1a" translate="yes" xml:space="preserve">
          <source>Even though the image is not as sharp, using a small number of &lt;code&gt;k&lt;/code&gt; singular values (compared to the original set of 768 values), we can recover many of the distinguishing features from this image.</source>
          <target state="translated">이미지가 그다지 선명하지 않더라도 (원래 768 개 값의 집합과 비교하여) &lt;code&gt;k&lt;/code&gt; 개의 특이 값을 적게 사용하면 이 이미지에서 많은 구별되는 특징을 복구 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c17cc6a8778f1a9a25e4a2f86caa32ef74f1e599" translate="yes" xml:space="preserve">
          <source>Even when the input array is two-dimensional:</source>
          <target state="translated">입력 배열이 2 차원 인 경우에도 :</target>
        </trans-unit>
        <trans-unit id="42a0931fb2d7f42f3ac87c5b18547abf5d77fe06" translate="yes" xml:space="preserve">
          <source>Evenly round to the given number of decimals.</source>
          <target state="translated">주어진 소수 자릿수로 고르게 반올림합니다.</target>
        </trans-unit>
        <trans-unit id="a19e0ffd5cc3d9a3df8ad933c77e6bea9dd169fb" translate="yes" xml:space="preserve">
          <source>Evenly spaced numbers with careful handling of endpoints.</source>
          <target state="translated">끝점을 신중하게 처리하여 균등 한 숫자.</target>
        </trans-unit>
        <trans-unit id="1b950907a8c83b7ddb21092298e5404983c4a665" translate="yes" xml:space="preserve">
          <source>Eventually, expect to &lt;code&gt;__array_function__&lt;/code&gt; to always be enabled.</source>
          <target state="translated">결국 &lt;code&gt;__array_function__&lt;/code&gt; 이 항상 활성화 되어 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="c49eff72347ffa8f4ae2d44fedce9c4dd2ec8159" translate="yes" xml:space="preserve">
          <source>Every PR, good or bad, is an act of generosity. Opening with a positive comment will help the author feel rewarded, and your subsequent remarks may be heard more clearly. You may feel good also.</source>
          <target state="translated">좋든 나쁘 든 모든 홍보는 관대함의 행위입니다. 긍정적 인 의견으로 여는 것은 저자가 보람을 느끼는 데 도움이되며 이후의 발언을 더 명확하게들을 수 있습니다. 기분이 좋을 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="581f2179fc03c06bcc3dcff4b3f8f2a107464b3a" translate="yes" xml:space="preserve">
          <source>Every Python module, extension module, or subpackage in the SciPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named test*) and test classes (named Test*).</source>
          <target state="translated">SciPy 패키지 디렉토리의 모든 Python 모듈, 확장 모듈 또는 하위 패키지에는 해당 &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; 파일이 있어야 합니다. Pytest는 이러한 파일에서 테스트 방법 (test *)과 테스트 클래스 (Test *)를 검사합니다.</target>
        </trans-unit>
        <trans-unit id="8b7039d02f9e55e5e4b1540b84794daa8aa48877" translate="yes" xml:space="preserve">
          <source>Every module should have a docstring at the very top of the file. The module&amp;rsquo;s docstring may extend over multiple lines. If your docstring does extend over multiple lines, the closing three quotation marks must be on a line by itself, preferably preceded by a blank line.</source>
          <target state="translated">모든 모듈은 파일 맨 위에 독 스트링이 있어야합니다. 모듈의 독 스트링은 여러 줄로 확장 될 수 있습니다. 독 스트링이 여러 줄로 확장되는 경우 닫는 세 개의 따옴표가 한 줄에 있어야하며, 가급적이면 빈 줄이 앞에 와야합니다.</target>
        </trans-unit>
        <trans-unit id="fae734cbfb45b3c7fcea4a1b93bd51caeedc12aa" translate="yes" xml:space="preserve">
          <source>Every ufunc calculation involves some overhead related to setting up the calculation. The practical significance of this overhead is that even though the actual calculation of the ufunc is very fast, you will be able to write array and type-specific code that will work faster for small arrays than the ufunc. In particular, using ufuncs to perform many calculations on 0-D arrays will be slower than other Python-based solutions (the silently-imported scalarmath module exists precisely to give array scalars the look-and-feel of ufunc based calculations with significantly reduced overhead).</source>
          <target state="translated">모든 ufunc 계산에는 계산 설정과 관련된 약간의 오버 헤드가 포함됩니다. 이 오버 헤드의 실질적인 의미는 ufunc의 실제 계산이 매우 빠르더라도 ufunc보다 작은 배열에서 더 빨리 작동하는 배열 및 유형별 코드를 작성할 수 있다는 것입니다. 특히, ufunc를 사용하여 0-D 배열에서 많은 계산을 수행하는 것은 다른 Python 기반 솔루션보다 느릴 것입니다 (자동으로 가져온 스칼라 수학 모듈은 정확하게 배열 스칼라에 오버 헤드를 크게 줄인 ufunc 기반 계산의 모양과 느낌을주기 위해 존재합니다) ).</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">예 1</target>
        </trans-unit>
        <trans-unit id="30643b2e1a03cdc521bd995bce3101935a638007" translate="yes" xml:space="preserve">
          <source>Example 1: Matrix creation from a string</source>
          <target state="translated">예제 1 : 문자열에서 행렬 생성</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">예 2</target>
        </trans-unit>
        <trans-unit id="ce3d11c2b2ea882cbd46aab60dee035848945f1a" translate="yes" xml:space="preserve">
          <source>Example 2: Matrix creation from nested sequence</source>
          <target state="translated">예제 2 : 중첩 시퀀스에서 매트릭스 생성</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">예제 3</target>
        </trans-unit>
        <trans-unit id="7a618a4143ae0244c26c66d93ae5ab076865eca3" translate="yes" xml:space="preserve">
          <source>Example 3: Matrix creation from an array</source>
          <target state="translated">예 3 : 배열에서 행렬 생성</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">예 4</target>
        </trans-unit>
        <trans-unit id="cbc410822099cff77c866f8b10c2e48ca12a1afc" translate="yes" xml:space="preserve">
          <source>Example Non-ufunc extension</source>
          <target state="translated">비 ufunc 확장 예제</target>
        </trans-unit>
        <trans-unit id="97f8c7c900cba2f392e5e38662fe498a8f56646a" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc for one dtype</source>
          <target state="translated">하나의 dtype에 대한 NumPy ufunc 예제</target>
        </trans-unit>
        <trans-unit id="b8809483f5fc6a5c010269d8adf002c5725f0e9b" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with multiple arguments/return values</source>
          <target state="translated">여러 인수 / 반환 값이있는 NumPy ufunc 예제</target>
        </trans-unit>
        <trans-unit id="66ef9bf28d21feb518a571e273d9e8fce03143d5" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with multiple dtypes</source>
          <target state="translated">여러 dtype이있는 NumPy ufunc 예제</target>
        </trans-unit>
        <trans-unit id="14395f9293b35a0e404c1a51a85116a67b48bdc5" translate="yes" xml:space="preserve">
          <source>Example NumPy ufunc with structured array dtype arguments</source>
          <target state="translated">구조화 된 배열 dtype 인수를 사용하는 NumPy ufunc 예제</target>
        </trans-unit>
        <trans-unit id="f8172515c31d6aac1029b5cb8f7b23a7b399484c" translate="yes" xml:space="preserve">
          <source>Example Rendered</source>
          <target state="translated">렌더링 된 예</target>
        </trans-unit>
        <trans-unit id="b501c037bbc988735c2c33076d9ac8bcdd035dcd" translate="yes" xml:space="preserve">
          <source>Example Source</source>
          <target state="translated">예제 소스</target>
        </trans-unit>
        <trans-unit id="4a0d4f43d7d9bdb2a4af703ab58a4be1e4d7fae7" translate="yes" xml:space="preserve">
          <source>Example illustrating a common use of &lt;a href=&quot;#numpy.linalg.qr&quot;&gt;&lt;code&gt;qr&lt;/code&gt;&lt;/a&gt;: solving of least squares problems</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.qr&quot;&gt; &lt;code&gt;qr&lt;/code&gt; &lt;/a&gt; 의 일반적인 사용법을 보여주는 예 : 최소 제곱 문제 해결</target>
        </trans-unit>
        <trans-unit id="63135172667b6a87b3380fb1464ecfa4e93bae96" translate="yes" xml:space="preserve">
          <source>Example npymath.ini modified for cross-compilation:</source>
          <target state="translated">교차 컴파일을 위해 수정 된 npymath.ini 예제 :</target>
        </trans-unit>
        <trans-unit id="8b9b4c475cb57be9cefc272ad9e58398f1d4a72d" translate="yes" xml:space="preserve">
          <source>Example of ellipsis use:</source>
          <target state="translated">줄임표 사용 예 :</target>
        </trans-unit>
        <trans-unit id="663d5de84d17f73904544fdaa7818c43c339aab6" translate="yes" xml:space="preserve">
          <source>Example of the &lt;em&gt;axis&lt;/em&gt; argument</source>
          <target state="translated">&lt;em&gt;축&lt;/em&gt; 인수의 예</target>
        </trans-unit>
        <trans-unit id="441193d28defb7b45677223f2e8385cc1771ef57" translate="yes" xml:space="preserve">
          <source>Example showing broadcast of scalar_like argument:</source>
          <target state="translated">scalar_like 인수의 브로드 캐스트를 보여주는 예 :</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="5ac5a296d96aa3e1af1d332eed81649776f6a783" translate="yes" xml:space="preserve">
          <source>Examples include ctypes, SWIG and Cython (which wraps C and C++) and f2py (which wraps Fortran).</source>
          <target state="translated">예를 들어 ctypes, SWIG 및 Cython (C 및 C ++ 래핑) 및 f2py (Fortran 래핑)가 있습니다.</target>
        </trans-unit>
        <trans-unit id="4fdbf34a4034d36b34a713099fb629e7144865e3" translate="yes" xml:space="preserve">
          <source>Examples of formats that cannot be read directly but for which it is not hard to convert are those formats supported by libraries like PIL (able to read and write many image formats such as jpg, png, etc).</source>
          <target state="translated">직접 읽을 수는 없지만 변환하기 어렵지 않은 형식의 예로는 PIL과 같은 라이브러리에서 지원하는 형식 (jpg, png 등 많은 이미지 형식을 읽고 쓸 수 있음)이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4f2c02f27681846f10b4ebe60fe1c291af3908e" translate="yes" xml:space="preserve">
          <source>Examples of using Numba, Cython, CFFI</source>
          <target state="translated">Numba, Cython, CFFI 사용 예</target>
        </trans-unit>
        <trans-unit id="bc6fa7b2668746155b7fd3ae40c9254ebb9987f4" translate="yes" xml:space="preserve">
          <source>Examples often include the Python prompt &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;. This is not part of the code and will cause an error if typed or pasted into the Python shell. It can be safely typed or pasted into the IPython shell; the &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; is ignored.</source>
          <target state="translated">예제에는 종종 Python 프롬프트 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가 포함 됩니다. 이것은 코드의 일부가 아니며 Python 셸에 입력하거나 붙여 넣으면 오류가 발생합니다. IPython 쉘에 안전하게 입력하거나 붙여 넣을 수 있습니다. &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="05c1453b20f0aa2713c512b8a046b6eeef5889f5" translate="yes" xml:space="preserve">
          <source>Examples often use &lt;code&gt;np&lt;/code&gt; as an alias for &lt;code&gt;numpy&lt;/code&gt;; that is, they assume you&amp;rsquo;ve run:</source>
          <target state="translated">예제에서는 종종 &lt;code&gt;np&lt;/code&gt; 를 &lt;code&gt;numpy&lt;/code&gt; 의 별칭으로 사용합니다 . 즉, 다음을 실행했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="f7651c4bad19b71b6cb07d324b05afde4b46e15c" translate="yes" xml:space="preserve">
          <source>Exceeded max_work.</source>
          <target state="translated">max_work를 초과했습니다.</target>
        </trans-unit>
        <trans-unit id="b4a918f3b3ebec530b94769e489c47c784e700d0" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오른쪽에서 분리하는 것을 제외하고 &lt;a href=&quot;#numpy.char.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;numpy.char.split#numpy.char.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 과 같이 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="5fa9076a048b190619bfcbf96eddfe860b6d5a91" translate="yes" xml:space="preserve">
          <source>Except for splitting from the right, &lt;a href=&quot;#numpy.char.rsplit&quot;&gt;&lt;code&gt;rsplit&lt;/code&gt;&lt;/a&gt; behaves like &lt;a href=&quot;numpy.split#numpy.split&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">오른쪽에서 분할하는 것을 제외하고 &lt;a href=&quot;#numpy.char.rsplit&quot;&gt; &lt;code&gt;rsplit&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;numpy.split#numpy.split&quot;&gt; &lt;code&gt;split&lt;/code&gt; &lt;/a&gt; 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="50cf8f9b1990e86989de06e0c8538067135c84c5" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt;&lt;code&gt;numpy.corrcoef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누락 된 데이터 처리를 제외하고이 함수는 &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 자세한 내용과 예는 &lt;a href=&quot;numpy.corrcoef#numpy.corrcoef&quot;&gt; &lt;code&gt;numpy.corrcoef&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fcfc562b386cd345086d419126e4274f3e7274f0" translate="yes" xml:space="preserve">
          <source>Except for the handling of missing data this function does the same as &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;. For more details and examples, see &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt;&lt;code&gt;numpy.cov&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">누락 된 데이터 처리를 제외하고이 함수는 &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 자세한 내용과 예는 &lt;a href=&quot;numpy.cov#numpy.cov&quot;&gt; &lt;code&gt;numpy.cov&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="596913a65e41737843ee5c2dbdb338f87062d44f" translate="yes" xml:space="preserve">
          <source>Exception: if &lt;code&gt;&amp;lt;modulename&amp;gt;&lt;/code&gt; contains a substring &lt;code&gt;__user__&lt;/code&gt;, then the corresponding &lt;code&gt;python module&lt;/code&gt; block describes the signatures of so-called call-back functions (see &lt;a href=&quot;python-usage#call-back-arguments&quot;&gt;Call-back arguments&lt;/a&gt;).</source>
          <target state="translated">예외 : &lt;code&gt;&amp;lt;modulename&amp;gt;&lt;/code&gt; 에 하위 문자열 &lt;code&gt;__user__&lt;/code&gt; 가 포함 된 경우 해당 &lt;code&gt;python module&lt;/code&gt; 블록은 소위 콜백 함수의 서명을 설명합니다 ( &lt;a href=&quot;python-usage#call-back-arguments&quot;&gt;콜백 인수&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="cd3dfbe79fda3a9d92de67b1bd4f1dc9f60ab723" translate="yes" xml:space="preserve">
          <source>Exceptions</source>
          <target state="translated">Exceptions</target>
        </trans-unit>
        <trans-unit id="356b80b4376a84cb81f1eaec6f12177c31c9684b" translate="yes" xml:space="preserve">
          <source>Excessive profanity. Please avoid swearwords; people differ greatly in their sensitivity to swearing.</source>
          <target state="translated">과도한 욕설. 욕설은 피하십시오. 사람들은 욕설에 대한 민감도가 크게 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d9b4ae599e40c23f9e1e3a0e96ba44f45767d0e8" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;f2py&lt;/code&gt; without any options to get an up-to-date list of available options.</source>
          <target state="translated">옵션없이 &lt;code&gt;f2py&lt;/code&gt; 를 실행 하여 사용 가능한 최신 옵션 목록을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="26e6ce501ea40e3a3a4030f941745cb2ec376d8c" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">실행 &lt;code&gt;func1d(a, *args)&lt;/code&gt; &lt;code&gt;func1d&lt;/code&gt; 이 1-D 어레이에 동작하고, &lt;code&gt;a&lt;/code&gt; 의 1-D 슬라이스 인 &lt;code&gt;arr&lt;/code&gt; 따라 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf7ed2655aaf6ca10ebe34c9fc51e6d32e46bc68" translate="yes" xml:space="preserve">
          <source>Execute &lt;code&gt;func1d(a, *args, **kwargs)&lt;/code&gt; where &lt;code&gt;func1d&lt;/code&gt; operates on 1-D arrays and &lt;code&gt;a&lt;/code&gt; is a 1-D slice of &lt;code&gt;arr&lt;/code&gt; along &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">실행 &lt;code&gt;func1d(a, *args, **kwargs)&lt;/code&gt; &lt;code&gt;func1d&lt;/code&gt; 이 1-D 어레이에 동작하고, &lt;code&gt;a&lt;/code&gt; 의 1-D 슬라이스 인 &lt;code&gt;arr&lt;/code&gt; 따라 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2cece8ace64c3475d26ff85f2c7434847f99f4d" translate="yes" xml:space="preserve">
          <source>Execute a command in a sub-process.</source>
          <target state="translated">하위 프로세스에서 명령을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="cbd62d234a86ea4d63bc3019c94a352e75700653" translate="yes" xml:space="preserve">
          <source>Existing array to use for output. If not given, returns a default copy of a.</source>
          <target state="translated">출력에 사용할 기존 배열. 지정하지 않으면 a의 기본 사본을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="49efde5e22ecb6838665120a39ab53a2bd9e68ce" translate="yes" xml:space="preserve">
          <source>Existing arrays are not copied:</source>
          <target state="translated">기존 어레이는 복사되지 않습니다 :</target>
        </trans-unit>
        <trans-unit id="49afcf31d80f21e8d0b1602a5dec36d208fe71f8" translate="yes" xml:space="preserve">
          <source>Expand the shape of an array.</source>
          <target state="translated">배열의 모양을 확장하십시오.</target>
        </trans-unit>
        <trans-unit id="ffcf950230f953a0aa6e82e09f28f2ca5a3b9124" translate="yes" xml:space="preserve">
          <source>Expectation of interval, must be &amp;gt;= 0. A sequence of expectation intervals must be broadcastable over the requested size.</source>
          <target state="translated">간격의 예상은&amp;gt; = 0이어야합니다. 예상 간격의 시퀀스는 요청 된 크기로 브로드 캐스트 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="b78dbac20462df52109f148c03ffe8d871381643" translate="yes" xml:space="preserve">
          <source>Expected type</source>
          <target state="translated">예상 유형</target>
        </trans-unit>
        <trans-unit id="cf1e24ddaed54869cdb52d8afc4913163a237789" translate="yes" xml:space="preserve">
          <source>Expects a 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, returns None if all values are masked.</source>
          <target state="translated">1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 를&lt;/a&gt; 예상하고 모든 값이 마스크 된 경우 None을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="436d6ba04e28ca54111c317cd8c5730750821416" translate="yes" xml:space="preserve">
          <source>Experimental Windows 64 bits support</source>
          <target state="translated">실험적인 Windows 64 비트 지원</target>
        </trans-unit>
        <trans-unit id="1bb6e6265dd9bdb6a18fab53ed1eab48ecc15430" translate="yes" xml:space="preserve">
          <source>Expired deprecations</source>
          <target state="translated">만료 된 지원 중단</target>
        </trans-unit>
        <trans-unit id="308f613122797fe7bbf7289f6c7ded6a9a215476" translate="yes" xml:space="preserve">
          <source>Explained without fancy indexing, this is equivalent to the following use of &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt;, which sets each of &lt;code&gt;ii&lt;/code&gt;, &lt;code&gt;jj&lt;/code&gt;, and &lt;code&gt;kk&lt;/code&gt; to a tuple of indices:</source>
          <target state="translated">멋진 인덱싱없이 설명하면 다음과 같은 &lt;a href=&quot;numpy.ndindex#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 사용과 동일하며, &lt;code&gt;ii&lt;/code&gt; , &lt;code&gt;jj&lt;/code&gt; 및 &lt;code&gt;kk&lt;/code&gt; 각각 을 인덱스 튜플로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="b32ef340ea4702fd5f41dbe4001671d76174ef71" translate="yes" xml:space="preserve">
          <source>Explanation</source>
          <target state="translated">Explanation</target>
        </trans-unit>
        <trans-unit id="70888d5de72e21e66f15d3b4da0b71ef035227ca" translate="yes" xml:space="preserve">
          <source>Explanation of &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 대한 설명 .</target>
        </trans-unit>
        <trans-unit id="6c1cbb49be518437de30818cb1c73f87724317b3" translate="yes" xml:space="preserve">
          <source>Explanation of anonymous return value of type &lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">type &lt;code&gt;type&lt;/code&gt; 의 익명 반환 값에 대한 설명입니다 .</target>
        </trans-unit>
        <trans-unit id="21e720a46ab84c7db649aa1af73527c035249fc0" translate="yes" xml:space="preserve">
          <source>Explanation of parameters passed to a generator&amp;rsquo;s &lt;code&gt;.send()&lt;/code&gt; method, formatted as for Parameters, above. Since, like for Yields and Returns, a single object is always passed to the method, this may describe either the single parameter, or positional arguments passed as a tuple. If a docstring includes Receives it must also include Yields.</source>
          <target state="translated">생성기의 &lt;code&gt;.send()&lt;/code&gt; 메서드에 전달 된 매개 변수에 대한 설명으로 위의 매개 변수 형식과 동일합니다. Yields 및 Return과 마찬가지로 단일 객체는 항상 메소드에 전달되므로 단일 매개 변수 또는 튜플로 전달 된 위치 인수를 설명 할 수 있습니다. 독 스트링에 Receives가 포함 된 경우 Yields도 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed24536543d63881e8b2573801bfcc470ea854c5" translate="yes" xml:space="preserve">
          <source>Explanation of return value named &lt;code&gt;describe&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;describe&lt;/code&gt; 라는 반환 값에 대한 설명 입니다.</target>
        </trans-unit>
        <trans-unit id="084a31a8f3e785c2c2a6e821453dbd829b121e68" translate="yes" xml:space="preserve">
          <source>Explanation of the returned values and their types. Similar to the &lt;strong&gt;Parameters&lt;/strong&gt; section, except the name of each return value is optional. The type of each return value is always required:</source>
          <target state="translated">반환 된 값 및 해당 유형에 대한 설명. 각 반환 값의 이름이 선택 사항이라는 점을 제외 하면 &lt;strong&gt;매개 변수&lt;/strong&gt; 섹션과 유사합니다 . 각 반환 값의 유형은 항상 필요합니다.</target>
        </trans-unit>
        <trans-unit id="7d6a974dcdac50109739458b5d455115ab1bc92d" translate="yes" xml:space="preserve">
          <source>Explanation of the yielded values and their types. This is relevant to generators only. Similar to the &lt;strong&gt;Returns&lt;/strong&gt; section in that the name of each value is optional, but the type of each value is always required:</source>
          <target state="translated">산출 된 값 및 유형에 대한 설명. 이것은 발전기에만 해당됩니다. 각 값의 이름은 선택 사항이지만 각 값의 유형은 항상 필수라는 점 에서 &lt;strong&gt;반품&lt;/strong&gt; 섹션과 유사 합니다.</target>
        </trans-unit>
        <trans-unit id="a9375f321c90af9af48e6e3fb9835073a5901dfe" translate="yes" xml:space="preserve">
          <source>Explanations</source>
          <target state="translated">Explanations</target>
        </trans-unit>
        <trans-unit id="83ab7f45afecc2791323d368cde7b157fa580ff5" translate="yes" xml:space="preserve">
          <source>Explicit constructor call - as in &lt;code&gt;MySubClass(params)&lt;/code&gt;. This is the usual route to Python instance creation.</source>
          <target state="translated">명시 적 생성자 호출 &lt;code&gt;MySubClass(params)&lt;/code&gt; . 이것은 Python 인스턴스 생성에 대한 일반적인 경로입니다.</target>
        </trans-unit>
        <trans-unit id="0c1d33b5bd4d5b9fa401f5843a2c2dbc40ef207e" translate="yes" xml:space="preserve">
          <source>Exploring the data</source>
          <target state="translated">데이터 탐색</target>
        </trans-unit>
        <trans-unit id="7239478231860a1fad923ee0b23fbd1cf944cc01" translate="yes" xml:space="preserve">
          <source>Exploring your repository</source>
          <target state="translated">저장소 탐색</target>
        </trans-unit>
        <trans-unit id="f2a8ab3710ac4db36fc8b2f6b13aa845d130b020" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest (most negative) power of &lt;code&gt;ibeta&lt;/code&gt; that, added to 1.0, gives something different from 1.0</source>
          <target state="translated">가장 작은 (가장 제외) 전력 지수 &lt;code&gt;ibeta&lt;/code&gt; 1.0 첨가 즉, 1.0에서 다른 무언가를 준다</target>
        </trans-unit>
        <trans-unit id="b6c379526da851c2c188007fc0f60f969489df7a" translate="yes" xml:space="preserve">
          <source>Exponent of the smallest power of &lt;code&gt;ibeta&lt;/code&gt; that, subtracted from 1.0, gives something different from 1.0.</source>
          <target state="translated">1.0에서 빼는 &lt;code&gt;ibeta&lt;/code&gt; 의 가장 작은 힘의 지수는 1.0과 다른 것을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4b6764a081f01f39974a118ba6996f7bb9dae570" translate="yes" xml:space="preserve">
          <source>Exponentials</source>
          <target state="translated">Exponentials</target>
        </trans-unit>
        <trans-unit id="3ce964226c06687afb0e1cd2608b915c6e2ae80f" translate="yes" xml:space="preserve">
          <source>Exponents and logarithms</source>
          <target state="translated">지수와 로그</target>
        </trans-unit>
        <trans-unit id="6816711cea53eaf2821d868455dd2b74af82fbfc" translate="yes" xml:space="preserve">
          <source>Extended Precision</source>
          <target state="translated">확장 된 정밀도</target>
        </trans-unit>
        <trans-unit id="c0c674d20d95b51b6a4e4dd52d4e269a50723636" translate="yes" xml:space="preserve">
          <source>Extended array wrapping mechanism for ufuncs</source>
          <target state="translated">ufuncs를위한 확장 된 배열 래핑 메커니즘</target>
        </trans-unit>
        <trans-unit id="04b03a3bd9df934ed9f605229c6779ed66aee4a4" translate="yes" xml:space="preserve">
          <source>Extended-precision floating-point number type, compatible with C &lt;code&gt;long double&lt;/code&gt; but not necessarily with IEEE 754 quadruple-precision.</source>
          <target state="translated">확장 정밀도 부동 소수점 숫자 유형으로 C &lt;code&gt;long double&lt;/code&gt; 과 호환 되지만 반드시 IEEE 754 4 중 정밀도와는 호환 되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4be9a4abd6d7c8083fc1a7bf9004e653250a9ba5" translate="yes" xml:space="preserve">
          <source>Extending</source>
          <target state="translated">Extending</target>
        </trans-unit>
        <trans-unit id="11f9e57877f87be0cc6660ad6431454b1ce0dd15" translate="yes" xml:space="preserve">
          <source>Extending numpy.random via Cython</source>
          <target state="translated">Cython을 통해 numpy.random 확장</target>
        </trans-unit>
        <trans-unit id="853464b537e82bc933ba7340602eb65117de87c5" translate="yes" xml:space="preserve">
          <source>Extending via CFFI</source>
          <target state="translated">CFFI를 통해 확장</target>
        </trans-unit>
        <trans-unit id="d370bc918c56f5c33646a1857c72f909913490c1" translate="yes" xml:space="preserve">
          <source>Extending via Numba</source>
          <target state="translated">Numba를 통해 확장</target>
        </trans-unit>
        <trans-unit id="800827a3cd2ee901ad8ec499c46ac0ff69445548" translate="yes" xml:space="preserve">
          <source>Extending via Numba and CFFI</source>
          <target state="translated">Numba 및 CFFI를 통해 확장</target>
        </trans-unit>
        <trans-unit id="b8df212e6d243492be0344c26fa93a5ac0e105d8" translate="yes" xml:space="preserve">
          <source>Extends &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt; with several advanced options providing more control over broadcasting and buffering.</source>
          <target state="translated">브로드 캐스트 및 버퍼링을보다 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; 제어 할 수있는 몇 가지 고급 옵션으로 NpyIter_MultiNew 를 확장 합니다.</target>
        </trans-unit>
        <trans-unit id="1071c16401775941686162869b5dcd9b3809f3d7" translate="yes" xml:space="preserve">
          <source>Extension (class in numpy.distutils.core)</source>
          <target state="translated">확장 (numpy.distutils.core의 클래스)</target>
        </trans-unit>
        <trans-unit id="85e3302475f159bce563240760503f1c4aa91903" translate="yes" xml:space="preserve">
          <source>Extension modules that need to compile against NumPy should use this function to locate the appropriate include directory.</source>
          <target state="translated">NumPy에 대해 컴파일해야하는 확장 모듈은이 함수를 사용하여 적절한 포함 디렉토리를 찾아야합니다.</target>
        </trans-unit>
        <trans-unit id="f48f1027b2aaccf449a26fbdeefabcf146890c52" translate="yes" xml:space="preserve">
          <source>Extension modules were discussed in &lt;a href=&quot;c-info.how-to-extend#writing-an-extension&quot;&gt;Writing an extension module&lt;/a&gt;. The most basic way to interface with compiled code is to write an extension module and construct a module method that calls the compiled code. For improved readability, your method should take advantage of the &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; call to convert between Python objects and C data-types. For standard C data-types there is probably already a built-in converter. For others you may need to write your own converter and use the &lt;code&gt;&quot;O&amp;amp;&quot;&lt;/code&gt; format string which allows you to specify a function that will be used to perform the conversion from the Python object to whatever C-structures are needed.</source>
          <target state="translated">확장 모듈은 &lt;a href=&quot;c-info.how-to-extend#writing-an-extension&quot;&gt;Writing an extension module&lt;/a&gt; 에서 논의되었습니다 . 컴파일 된 코드와 인터페이스하는 가장 기본적인 방법은 확장 모듈을 작성하고 컴파일 된 코드를 호출하는 모듈 메서드를 구성하는 것입니다. 가독성을 &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; 려면 메서드에서 PyArg_ParseTuple 호출을 활용하여 Python 객체와 C 데이터 유형간에 변환 해야 합니다. 표준 C 데이터 유형의 경우 이미 내장 변환기가있을 수 있습니다. 다른 사람들의 경우에는 자체 변환기를 작성하고 &lt;code&gt;&quot;O&amp;amp;&quot;&lt;/code&gt; 형식 문자열을 사용하여 Python 객체에서 필요한 C 구조로의 변환을 수행하는 데 사용할 함수를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c018e97c181cd9c183fd3a91a81ef0772a1542dd" translate="yes" xml:space="preserve">
          <source>Extension name.</source>
          <target state="translated">확장명.</target>
        </trans-unit>
        <trans-unit id="656bcfe284e2da39c77d4fdab55b16ad3c654719" translate="yes" xml:space="preserve">
          <source>Extensions</source>
          <target state="translated">Extensions</target>
        </trans-unit>
        <trans-unit id="27a37d04136a1c128f059ba2a96a979d4da85562" translate="yes" xml:space="preserve">
          <source>External &lt;code&gt;nose&lt;/code&gt; plugins are usable by &lt;code&gt;numpy.testing.Tester&lt;/code&gt;</source>
          <target state="translated">외부 &lt;code&gt;nose&lt;/code&gt; 플러그인은 &lt;code&gt;numpy.testing.Tester&lt;/code&gt; 에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="730550afb5b9c93a998c435ea0c0d79790c3f92e" translate="yes" xml:space="preserve">
          <source>External Links:</source>
          <target state="translated">외부 링크:</target>
        </trans-unit>
        <trans-unit id="ae23cb438f3e53ca3afef0a03ebcc1785000e0ee" translate="yes" xml:space="preserve">
          <source>External member: Thomas Caswell</source>
          <target state="translated">외부 회원 : Thomas Caswell</target>
        </trans-unit>
        <trans-unit id="f5695baec527125ed849fab25176346709bcdc26" translate="yes" xml:space="preserve">
          <source>Extra arguments to be used in the function call. Default is no extra arguments.</source>
          <target state="translated">함수 호출에 사용되는 추가 인수 기본값은 추가 인수가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7f681966048a97639927ca7899e8b79125b2db1c" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the compiler.</source>
          <target state="translated">컴파일러에 전달할 추가 명령 줄 인수입니다.</target>
        </trans-unit>
        <trans-unit id="ca14953b246ceea670453a567006ae580503bb4e" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the fortran77 compiler.</source>
          <target state="translated">fortran77 컴파일러에 전달할 추가 명령 줄 인수입니다.</target>
        </trans-unit>
        <trans-unit id="6295d4fda810b14243403cdc434ad1cb27dc0759" translate="yes" xml:space="preserve">
          <source>Extra command line arguments to pass to the fortran90 compiler.</source>
          <target state="translated">fortran90 컴파일러에 전달할 추가 명령 줄 인수입니다.</target>
        </trans-unit>
        <trans-unit id="7475cdd2c7bf2da401a59201928f6e438e74c2c4" translate="yes" xml:space="preserve">
          <source>Extra data to be passed to the 1-d vector loops or &lt;code&gt;NULL&lt;/code&gt; if no extra-data is needed. This C-array must be the same size ( &lt;em&gt;i.e.&lt;/em&gt; ntypes) as the functions array. &lt;code&gt;NULL&lt;/code&gt; is used if extra_data is not needed. Several C-API calls for UFuncs are just 1-d vector loops that make use of this extra data to receive a pointer to the actual function to call.</source>
          <target state="translated">1 차원 벡터 루프에 전달 될 추가 데이터 또는 추가 데이터가 필요하지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; . 이 C- 배열은 함수 배열 과 크기가 같아야합니다 ( &lt;em&gt;예 :&lt;/em&gt; ntype). extra_data가 필요하지 않은 경우 &lt;code&gt;NULL&lt;/code&gt; 이 사용됩니다. UFunc에 대한 여러 C-API 호출은이 추가 데이터를 사용하여 호출 할 실제 함수에 대한 포인터를받는 1 차원 벡터 루프입니다.</target>
        </trans-unit>
        <trans-unit id="76b524fa169ed9d7419720ac2e63f1800fb02fd6" translate="yes" xml:space="preserve">
          <source>Extra features in NumPy Distutils</source>
          <target state="translated">NumPy Distutils의 추가 기능</target>
        </trans-unit>
        <trans-unit id="0ba9e867255fe2b4e1a52a57cb3c07e37658da6a" translate="yes" xml:space="preserve">
          <source>Extra gotchas - custom &lt;code&gt;__del__&lt;/code&gt; methods and ndarray.base</source>
          <target state="translated">추가 문제-사용자 정의 &lt;code&gt;__del__&lt;/code&gt; 메서드 및 ndarray.base</target>
        </trans-unit>
        <trans-unit id="e4b908b04be2629c5ae91c968b91dbf4fa38bfee" translate="yes" xml:space="preserve">
          <source>Extract a diagonal or construct a diagonal array.</source>
          <target state="translated">대각선을 추출하거나 대각선 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="8f2f355e8dba1681289d909a9095fc402d801e4a" translate="yes" xml:space="preserve">
          <source>Extract the diagonal (requires explicit form):</source>
          <target state="translated">대각선을 추출하십시오 (명시 적 양식 필요).</target>
        </trans-unit>
        <trans-unit id="e69f20e9f683920d3fb4329abd951e878b1f9372" translate="yes" xml:space="preserve">
          <source>F</source>
          <target state="translated">F</target>
        </trans-unit>
        <trans-unit id="00b194f535090973445600575106dc4bd4b91c15" translate="yes" xml:space="preserve">
          <source>F &amp;amp; C order preserved, otherwise most similar order</source>
          <target state="translated">F &amp;amp; C 주문 유지, 그렇지 않으면 가장 유사한 주문</target>
        </trans-unit>
        <trans-unit id="3a82a1967b0685fff927bd0da5e7638582e5ea69" translate="yes" xml:space="preserve">
          <source>F order</source>
          <target state="translated">F 주문</target>
        </trans-unit>
        <trans-unit id="c79b9dbc4a93112f31ab2f13620d941f25753284" translate="yes" xml:space="preserve">
          <source>F order if input is F and not C, otherwise C order</source>
          <target state="translated">입력이 C가 아닌 F이면 F 순서, 그렇지 않으면 C 순서</target>
        </trans-unit>
        <trans-unit id="f2a180292b361263e635ced3b9691c0e12c80c50" translate="yes" xml:space="preserve">
          <source>F2PY Users Guide and Reference Manual</source>
          <target state="translated">F2PY 사용자 가이드 및 참조 설명서</target>
        </trans-unit>
        <trans-unit id="3b399d8776a2242967c58643767ca90dfddcac38" translate="yes" xml:space="preserve">
          <source>F2PY can be used either as a command line tool &lt;code&gt;f2py&lt;/code&gt; or as a Python module &lt;code&gt;numpy.f2py&lt;/code&gt;. While we try to install the command line tool as part of the numpy setup, some platforms like Windows make it difficult to reliably put the executable on the &lt;code&gt;PATH&lt;/code&gt;. We will refer to &lt;code&gt;f2py&lt;/code&gt; in this document but you may have to run it as a module:</source>
          <target state="translated">F2PY는 명령 줄 도구 &lt;code&gt;f2py&lt;/code&gt; 또는 Python 모듈 &lt;code&gt;numpy.f2py&lt;/code&gt; 로 사용할 수 있습니다 . numpy 설정의 일부로 명령 줄 도구를 설치하려고 시도하는 동안 Windows와 같은 일부 플랫폼에서는 &lt;code&gt;PATH&lt;/code&gt; 에 실행 파일을 안정적으로 배치하기가 어렵습니다 . 이 문서에서는 &lt;code&gt;f2py&lt;/code&gt; 를 참조 하지만 모듈로 실행해야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="792c6defec01dbafd2bb97ac5636c97cd76fd00b" translate="yes" xml:space="preserve">
          <source>F2PY compiles all sources and builds an extension module containing the wrappers. In building extension modules, F2PY uses &lt;code&gt;numpy_distutils&lt;/code&gt; that supports a number of Fortran 77/90/95 compilers, including Gnu, Intel, Sun Fortre, SGI MIPSpro, Absoft, NAG, Compaq etc. compilers.</source>
          <target state="translated">F2PY는 모든 소스를 컴파일하고 래퍼를 포함하는 확장 모듈을 빌드합니다. 확장 모듈을 구축, F2PY는 사용 &lt;code&gt;numpy_distutils&lt;/code&gt; 등 컴파일러은 GNU, 인텔, 썬 Fortre, SGI MIPSpro, Absoft, NAG, 컴팩 포함 포트란 77/90/95 컴파일러의 숫자를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="92e93ef7e35d0de4b606056f7c05a7e7f8e0fa7b" translate="yes" xml:space="preserve">
          <source>F2PY directive has the following form:</source>
          <target state="translated">F2PY 지시문의 형식은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c802734ec43042e46fc429c3bbb7f9b7a790ab48" translate="yes" xml:space="preserve">
          <source>F2PY directives</source>
          <target state="translated">F2PY 지시문</target>
        </trans-unit>
        <trans-unit id="b9c3fd91761103aa57848e2e22375fdb641f2ae9" translate="yes" xml:space="preserve">
          <source>F2PY generated interface is very flexible with respect to call-back arguments. For each call-back argument an additional optional argument &lt;code&gt;&amp;lt;name&amp;gt;_extra_args&lt;/code&gt; is introduced by F2PY. This argument can be used to pass extra arguments to user provided call-back arguments.</source>
          <target state="translated">F2PY 생성 인터페이스는 콜백 인수와 관련하여 매우 유연합니다. 각 콜백 인수에 대해 추가 선택적 인수 &lt;code&gt;&amp;lt;name&amp;gt;_extra_args&lt;/code&gt; 가 F2PY 에 의해 도입됩니다. 이 인수는 사용자가 제공 한 콜백 인수에 추가 인수를 전달하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99f6bbe236422250760ea03e1afee2f05419e0cf" translate="yes" xml:space="preserve">
          <source>F2PY generated wrapper functions accept (almost) any Python object as a string argument, &lt;code&gt;str&lt;/code&gt; is applied for non-string objects. Exceptions are NumPy arrays that must have type code &lt;code&gt;'c'&lt;/code&gt; or &lt;code&gt;'1'&lt;/code&gt; when used as string arguments.</source>
          <target state="translated">F2PY 생성 래퍼 함수는 (거의) 모든 Python 객체를 문자열 인수로 받아들이고 &lt;code&gt;str&lt;/code&gt; 은 문자열이 아닌 객체에 적용됩니다. 예외는 문자열 인수로 사용될 때 유형 코드 &lt;code&gt;'c'&lt;/code&gt; 또는 &lt;code&gt;'1'&lt;/code&gt; 을 가져야하는 NumPy 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="f8ac895bc25eb576f465fead8da56c16856e681e" translate="yes" xml:space="preserve">
          <source>F2PY generates wrappers to &lt;code&gt;common&lt;/code&gt; blocks defined in a routine signature block. Common blocks are visible by all Fortran codes linked with the current extension module, but not to other extension modules (this restriction is due to how Python imports shared libraries). In Python, the F2PY wrappers to &lt;code&gt;common&lt;/code&gt; blocks are &lt;code&gt;fortran&lt;/code&gt; type objects that have (dynamic) attributes related to data members of common blocks. When accessed, these attributes return as NumPy array objects (multidimensional arrays are Fortran-contiguous) that directly link to data members in common blocks. Data members can be changed by direct assignment or by in-place changes to the corresponding array objects.</source>
          <target state="translated">F2PY 는 루틴 서명 블록에 정의 된 &lt;code&gt;common&lt;/code&gt; 블록에 대한 래퍼를 생성 합니다. 공통 블록은 현재 확장 모듈과 연결된 모든 Fortran 코드에서 볼 수 있지만 다른 확장 모듈에는 표시되지 않습니다 (이 제한은 Python이 공유 라이브러리를 가져 오는 방식 때문입니다). Python에서 &lt;code&gt;common&lt;/code&gt; 블록에 대한 F2PY 래퍼는 공통 블록의 데이터 멤버와 관련된 (동적) 속성을 가진 &lt;code&gt;fortran&lt;/code&gt; 유형 객체입니다. 이러한 속성에 액세스하면 공통 블록의 데이터 멤버에 직접 연결되는 NumPy 배열 개체 (다차원 배열은 Fortran에 인접 함)로 반환됩니다. 데이터 멤버는 직접 할당하거나 해당 배열 개체에 대한 내부 변경을 통해 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="818e71d7199268e4ad0bb28a90c9ec7b67e6a73f" translate="yes" xml:space="preserve">
          <source>F2PY generates wrappers to all entry names using the signature of the routine block.</source>
          <target state="translated">F2PY는 루틴 블록의 서명을 사용하여 모든 항목 이름에 대한 랩퍼를 생성합니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
