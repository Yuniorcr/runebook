<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="19399207372e8d7c054365b0a529ccf2981f3b82" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.endswith.html#numpy.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="translated">벡터화 된 문자열 연산은 메소드 (예 : &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.endswith.html#numpy.chararray.endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; &lt;/a&gt; ) 및 삽입 연산자 (예 : &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt; )로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6b72c98ed88bb4df85be360c468c57b064be204e" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;numpy.char.chararray.endswith#numpy.char.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="translated">벡터화 된 문자열 연산은 메소드 (예 : &lt;a href=&quot;numpy.char.chararray.endswith#numpy.char.chararray.endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; &lt;/a&gt; ) 및 삽입 연산자 (예 : &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt; )로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="db454313195f316238acd17aeb5d938f4db3f3f4" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;a href=&quot;numpy.chararray.endswith#numpy.chararray.endswith&quot;&gt;&lt;code&gt;endswith&lt;/code&gt;&lt;/a&gt;) and infix operators (e.g. &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt;)</source>
          <target state="translated">벡터화 된 문자열 연산은 메소드 (예 : &lt;a href=&quot;numpy.chararray.endswith#numpy.chararray.endswith&quot;&gt; &lt;code&gt;endswith&lt;/code&gt; &lt;/a&gt; ) 및 중위 연산자 (예 : &lt;code&gt;&quot;+&quot;, &quot;*&quot;, &quot;%&quot;&lt;/code&gt; )로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b595ca1ad64c45adbaa59fe3b6b7fb1e998d72d6" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;code&gt;str.endswith&lt;/code&gt;) and infix operators (e.g. &lt;code&gt;+, *, %&lt;/code&gt;)</source>
          <target state="translated">벡터화 된 문자열 연산은 메소드 (예 : &lt;code&gt;str.endswith&lt;/code&gt; ) 및 삽입 연산자 (예 : &lt;code&gt;+, *, %&lt;/code&gt; )로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="e122cd45e8e9df8c348e263b4143f2a68e76e98d" translate="yes" xml:space="preserve">
          <source>vectorized string operations are provided as methods (e.g. &lt;code&gt;str.endswith&lt;/code&gt;) and infix operators (e.g. &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;,``%``)</source>
          <target state="translated">벡터화 된 문자열 연산은 메소드 (예 : &lt;code&gt;str.endswith&lt;/code&gt; ) 및 삽입 연산자 (예 : &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; ,``%``)로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="c692273deb2772da307ffe37041fef77bf4baa97" translate="yes" xml:space="preserve">
          <source>version</source>
          <target state="translated">version</target>
        </trans-unit>
        <trans-unit id="bfd190f5456486754027935ce9caa900beed7ccd" translate="yes" xml:space="preserve">
          <source>version:</source>
          <target state="translated">version:</target>
        </trans-unit>
        <trans-unit id="66e0e1037f3cc463bf7e6212024c466ab215fa03" translate="yes" xml:space="preserve">
          <source>very fast when it optimizes well</source>
          <target state="translated">잘 최적화되면 매우 빠릅니다.</target>
        </trans-unit>
        <trans-unit id="8f3a07543988e4673dcae5e59c35323c5791f370" translate="yes" xml:space="preserve">
          <source>view</source>
          <target state="translated">view</target>
        </trans-unit>
        <trans-unit id="aaafdd472f0b52f4b28e53842ae8095cfe8dc805" translate="yes" xml:space="preserve">
          <source>view() (numpy.char.chararray method)</source>
          <target state="translated">view () (numpy.char.chararray의 메서드)</target>
        </trans-unit>
        <trans-unit id="2ab098e314c8c4907b0cbf15c46523c5f4564351" translate="yes" xml:space="preserve">
          <source>views returned from np.einsum are writeable</source>
          <target state="translated">np.einsum에서 반환 된 뷰는 쓰기 가능합니다.</target>
        </trans-unit>
        <trans-unit id="4fc1ae3e178d0efaeaff5106a735070367cc2e3b" translate="yes" xml:space="preserve">
          <source>virtualenv (pip)</source>
          <target state="translated">virtualenv (pip)</target>
        </trans-unit>
        <trans-unit id="e9cede9b80ea3abd89c755f1117337d429162c86" translate="yes" xml:space="preserve">
          <source>void</source>
          <target state="translated">void</target>
        </trans-unit>
        <trans-unit id="48b1339239922b5e07d5ce4184fcf5e87effde2b" translate="yes" xml:space="preserve">
          <source>von Mises, R., &amp;ldquo;Mathematical Theory of Probability and Statistics&amp;rdquo;, New York: Academic Press, 1964.</source>
          <target state="translated">von Mises, R.,&amp;ldquo;확률과 통계의 수학 이론&amp;rdquo;, 뉴욕 : Academic Press, 1964</target>
        </trans-unit>
        <trans-unit id="9ae5fe8b31c05755c850ae4d90a3fcb76c2a182a" translate="yes" xml:space="preserve">
          <source>vonmises() (in module numpy.random)</source>
          <target state="translated">vonmises () (numpy.random 모듈)</target>
        </trans-unit>
        <trans-unit id="d7e5b9982ea5d22fcf5a1d1ad3376fc5a48e7c9d" translate="yes" xml:space="preserve">
          <source>vsplit() (in module numpy)</source>
          <target state="translated">vsplit () (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="99c757c8afc5629a307995e13f88bb23fe068b80" translate="yes" xml:space="preserve">
          <source>vstack (in module numpy.ma)</source>
          <target state="translated">vstack (numpy.ma 모듈)</target>
        </trans-unit>
        <trans-unit id="15311d1f0df12d81853bd7c190c65a543b943872" translate="yes" xml:space="preserve">
          <source>vstack() (in module numpy)</source>
          <target state="translated">vstack () (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="6cd1107921db5bd5aa7000a30d16d502418e2ec3" translate="yes" xml:space="preserve">
          <source>wald() (in module numpy.random)</source>
          <target state="translated">wald () (numpy.random 모듈)</target>
        </trans-unit>
        <trans-unit id="3ddc3bec9c70c5c7e765cd8cf5fa5aa389917ef0" translate="yes" xml:space="preserve">
          <source>warn: Print a &lt;code&gt;RuntimeWarning&lt;/code&gt; (via the Python &lt;a href=&quot;https://docs.python.org/dev/library/warnings.html#module-warnings&quot;&gt;&lt;code&gt;warnings&lt;/code&gt;&lt;/a&gt; module).</source>
          <target state="translated">경고 : Python &lt;a href=&quot;https://docs.python.org/dev/library/warnings.html#module-warnings&quot;&gt; &lt;code&gt;warnings&lt;/code&gt; &lt;/a&gt; 모듈을 통해 &lt;code&gt;RuntimeWarning&lt;/code&gt; 을 인쇄하십시오 .</target>
        </trans-unit>
        <trans-unit id="4884fd1a3cb1606444975d3740d56633fa35ad1b" translate="yes" xml:space="preserve">
          <source>we can build the approximation by doing</source>
          <target state="translated">우리는 다음을 수행하여 근사치를 구축 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0ee32d825d6ddb4025ab74af0609969ecc419c8" translate="yes" xml:space="preserve">
          <source>week</source>
          <target state="translated">week</target>
        </trans-unit>
        <trans-unit id="bc2615c16c37f07d240c50d07bfd867058aaeb3e" translate="yes" xml:space="preserve">
          <source>weekmask (numpy.busdaycalendar attribute)</source>
          <target state="translated">weekmask (numpy.busdaycalendar 속성)</target>
        </trans-unit>
        <trans-unit id="c6f09c0d1d993f2a543feb0ac90ea8458105cb1e" translate="yes" xml:space="preserve">
          <source>weibull() (in module numpy.random)</source>
          <target state="translated">weibull () (numpy.random 모듈)</target>
        </trans-unit>
        <trans-unit id="a2a0b13381d4d5d8e14bc62eb1948f61052d27ce" translate="yes" xml:space="preserve">
          <source>what are the names of the &amp;ldquo;&lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt;&amp;rdquo; of the structure, by which they can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;,</source>
          <target state="translated">은 &quot;의 이름이 무엇입니까 &lt;a href=&quot;../glossary#term-field&quot;&gt;필드&lt;/a&gt; 가 될 수있는 구조&quot;, &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;액세스는&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="916d4dfd40fa788d4f97c5cbd19732b935ee5e9e" translate="yes" xml:space="preserve">
          <source>what are the names of the &amp;ldquo;&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt;&amp;rdquo; of the structure, by which they can be &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;accessed&lt;/a&gt;,</source>
          <target state="translated">은 &quot;의 이름이 무엇입니까 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;필드&lt;/a&gt; 가 될 수있는 구조&quot;, &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;액세스는&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="4bdf2c9a9320c2bb30296f2a5be0fd38903dcd4d" translate="yes" xml:space="preserve">
          <source>what exactly &lt;code&gt;seq&lt;/code&gt; is. Is it a single value to be altered in-place? Is it an array, and if so what is its length? Is it input-only? Output-only? Input-output? &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; cannot determine these details, and does not attempt to do so.</source>
          <target state="translated">정확히 &lt;code&gt;seq&lt;/code&gt; 는 무엇입니까 . 제자리에서 변경되는 단일 값입니까? 배열입니까, 그렇다면 길이는 얼마입니까? 입력 전용입니까? 출력 전용? 입출력? &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 는 이러한 세부 정보를 확인할 수 없으며 그렇게 시도하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0380a220e77d143346e4de9f7efc19cb89f002b0" translate="yes" xml:space="preserve">
          <source>what is the data-type of each &lt;a href=&quot;../glossary#term-field&quot;&gt;field&lt;/a&gt;, and</source>
          <target state="translated">무엇 각각의 데이터 타입 &lt;a href=&quot;../glossary#term-field&quot;&gt;필드&lt;/a&gt; , 및</target>
        </trans-unit>
        <trans-unit id="52be18891fe12a3ccc69a948daf4a9df395f8160" translate="yes" xml:space="preserve">
          <source>what is the data-type of each &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;field&lt;/a&gt;, and</source>
          <target state="translated">무엇 각각의 데이터 타입 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;필드&lt;/a&gt; , 및</target>
        </trans-unit>
        <trans-unit id="d0192f6d7a8d53807254215b637508c53444c530" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (so for the last index), &lt;code&gt;indices[i+1] = a.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (그래서 마지막 인덱스) &lt;code&gt;indices[i+1] = a.shape[axis]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec1e659fd8ee011943e5f3a9c49fd36000cceebd" translate="yes" xml:space="preserve">
          <source>when &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (so for the last index), &lt;code&gt;indices[i+1] = array.shape[axis]&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;i = len(indices) - 1&lt;/code&gt; (그래서 마지막 인덱스) &lt;code&gt;indices[i+1] = array.shape[axis]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5297e650e9c08f060e1e619f5312964757572aef" translate="yes" xml:space="preserve">
          <source>when building Numpy. The following 64-bit BLAS/LAPACK libraries are supported:</source>
          <target state="translated">Numpy를 만들 때. 다음 64 비트 BLAS / LAPACK 라이브러리가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="5722cd99f39f9db8b61fbc3c1c82b426d3cd79fd" translate="yes" xml:space="preserve">
          <source>when investigating further and asking for support.</source>
          <target state="translated">더 조사하고 지원을 요청할 때.</target>
        </trans-unit>
        <trans-unit id="46148cc3b4d2b3ac8073f14b0cba7f25ffff54bd" translate="yes" xml:space="preserve">
          <source>where</source>
          <target state="translated">where</target>
        </trans-unit>
        <trans-unit id="cfaf285482cf6c4f89cd534ed09bc1fa065bdd59" translate="yes" xml:space="preserve">
          <source>where &amp;lt;package install directory&amp;gt; is the package (or sub-package) directory such as &amp;lsquo;/usr/lib/python2.4/site-packages/mypackage&amp;rsquo; (&amp;lsquo;C: Python2.4 Lib site-packages mypackage&amp;rsquo;) or &amp;lsquo;/usr/lib/python2.4/site- packages/mypackage/mysubpackage&amp;rsquo; (&amp;lsquo;C: Python2.4 Lib site-packages mypackage mysubpackage&amp;rsquo;).</source>
          <target state="translated">여기서 &amp;lt;package install directory&amp;gt;는 '/usr/lib/python2.4/site-packages/mypackage'('C : Python2.4 Lib site-packages mypackage') 또는 '와 같은 패키지 (또는 하위 패키지) 디렉토리입니다. /usr/lib/python2.4/site- packages / mypackage / mysubpackage '('C : Python2.4 Lib 사이트 패키지 mypackage mysubpackage ').</target>
        </trans-unit>
        <trans-unit id="15b93f3fc1f372444d0c3a34d4013852d05253ac" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;args&amp;gt;=string.join(&amp;lt;list&amp;gt;,' ')&lt;/code&gt;, but in Python. Unless &lt;code&gt;-h&lt;/code&gt; is used, this function returns a dictionary containing information on generated modules and their dependencies on source files. For example, the command &lt;code&gt;f2py -m scalar scalar.f&lt;/code&gt; can be executed from Python as follows</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;args&amp;gt;=string.join(&amp;lt;list&amp;gt;,' ')&lt;/code&gt; 이지만 Python에서. &lt;code&gt;-h&lt;/code&gt; 를 사용 하지 않으면 이 함수는 생성 된 모듈에 대한 정보와 소스 파일에 대한 종속성이 포함 된 사전을 반환합니다. 예를 들어 &lt;code&gt;f2py -m scalar scalar.f&lt;/code&gt; 명령 은 다음과 같이 Python에서 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="82814f25ca2293053d415c5e9086a2d82cae615d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;--bench&lt;/code&gt; activates the benchmark suite instead of the test suite. This builds NumPy and runs all available benchmarks defined in &lt;code&gt;benchmarks/&lt;/code&gt;. (Note: this could take a while. Each benchmark is run multiple times to measure the distribution in execution times.)</source>
          <target state="translated">여기서 &lt;code&gt;--bench&lt;/code&gt; 는 테스트 스위트 대신 벤치 마크 스위트를 활성화합니다. 이렇게하면 NumPy가 빌드되고 benchs &lt;code&gt;benchmarks/&lt;/code&gt; 정의 된 사용 가능한 모든 벤치 마크가 실행됩니다 . (참고 :이 작업은 시간이 걸릴 수 있습니다. 각 벤치 마크는 실행 시간의 분포를 측정하기 위해 여러 번 실행됩니다.)</target>
        </trans-unit>
        <trans-unit id="27722a8f94c49a1d17c79d2d98a28d7cd4fd50e2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Chebyshev polynomial.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 의 주요 지수는 &lt;code&gt;x&lt;/code&gt; 의 원소를 색인화하고 마지막 지수는 체비 쇼프 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="833860b51f45a74ee06a8481e7b59dec2776a9c5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Hermite polynomial.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 의 주요 지수는 &lt;code&gt;x&lt;/code&gt; 의 요소를 색인화하고 마지막 색인은 Hermite 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="c69795dbab93fd4905d0bc022d8ac56b6e1e0f54" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the HermiteE polynomial.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 의 주요 지수는 &lt;code&gt;x&lt;/code&gt; 의 요소를 색인화하고 마지막 색인은 HermiteE 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="bde30796ed968ed7657f0df45af477fbb40047da" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Laguerre polynomial.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 의 주요 지수는 &lt;code&gt;x&lt;/code&gt; 의 원소를 색인하고 마지막 지수는 Laguerre 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="c6b4ff5c9a6986803c5708a92c411c4b253dec9c" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the degree of the Legendre polynomial.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 의 주요 지수는 &lt;code&gt;x&lt;/code&gt; 의 요소를 색인화하고 마지막 색인은 Legendre 다항식의 차수입니다.</target>
        </trans-unit>
        <trans-unit id="538f7fb88a53c793cea30da00779237a649749e0" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the elements of &lt;code&gt;x&lt;/code&gt; and the last index is the power of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg&lt;/code&gt; . &lt;code&gt;V&lt;/code&gt; 의 주요 지수는 &lt;code&gt;x&lt;/code&gt; 의 요소를 색인화하고 마지막 색인은 &lt;code&gt;x&lt;/code&gt; 의 거듭 제곱입니다 .</target>
        </trans-unit>
        <trans-unit id="4de9c198e8ca08018e505031f38efeea306eb563" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Chebyshev polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 선행 지수 는 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 색인화하고 마지막 색인은 체비 쇼프 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="9c023f7138aa8d794b6a146fabd54c47a0508cbe" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Hermite polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 선행 지수 는 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 색인화하고 마지막 색인은 은자 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="d3cf2ba80598064afebb705d3f96da951d339ad7" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the HermiteE polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 선행 지수 는 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 색인화하고 마지막 색인은 HermiteE 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="931ddf7a677dd0bb054e68bb0682795a7ecb2d44" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Laguerre polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 주요 지수 는 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 색인화하고 마지막 색인은 Laguerre 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="5b4f668563e3498fcf093b6cc70e0bf28243dbb5" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the degrees of the Legendre polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 주요 인덱스는 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 색인화하고 마지막 색인은 Legendre 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="ae534bb750508bd12922fca33e07ed9e9147c7d1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; and &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y)&lt;/code&gt; and the last index encodes the powers of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= deg[0]&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= deg[1]&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 주요 지수 는 점 &lt;code&gt;(x, y)&lt;/code&gt; 을 색인화하고 마지막 색인은 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 거듭 제곱을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="968a8f99ae65dc781347987604737e4885f0347e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Chebyshev polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; , &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 선행 지수 는 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 을 색인화하고 마지막 색인은 체비 쇼프 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="290595042428a0adec26dcab062e9c72d203d119" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Hermite polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; , &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 선행 지수 는 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 을 색인화하고 마지막 색인은 은자 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="a3522d9ec4777ff57457a39fea3d27eb87e001f3" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the HermiteE polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; , &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 선행 지수 는 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 을 색인화하고 마지막 색인은 HermiteE 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="e21aabee789ef859247cb7d579e69b9306ad94e9" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Laguerre polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; , &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 주요 지수 는 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 을 색인화하고 마지막 색인은 Laguerre 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="0fec4bcf4d4a798ecc63d7a8b21b974ec59ac767" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the degrees of the Legendre polynomials.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; , &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 주요 인덱스는 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 을 색인화하고 마지막 색인은 Legendre 다항식의 차수를 인코딩합니다.</target>
        </trans-unit>
        <trans-unit id="ef93d8eb54977daa7c98c55d5dde9a9422edf21b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt;, &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt;, and &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt;. The leading indices of &lt;code&gt;V&lt;/code&gt; index the points &lt;code&gt;(x, y, z)&lt;/code&gt; and the last index encodes the powers of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt;= l&lt;/code&gt; , &lt;code&gt;0 &amp;lt;= j &amp;lt;= m&lt;/code&gt; 및 &lt;code&gt;0 &amp;lt;= j &amp;lt;= n&lt;/code&gt; 입니다. &lt;code&gt;V&lt;/code&gt; 의 주요 지수 는 점 &lt;code&gt;(x, y, z)&lt;/code&gt; 을 색인화하고 마지막 색인은 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;z&lt;/code&gt; 의 거듭 제곱을 인코딩합니다 .</target>
        </trans-unit>
        <trans-unit id="907ece41fc35a24200255d27b81c13eb4a497bd2" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;GITHUB&lt;/code&gt; contains your github access token. This text may also be appended to &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; for release updates, though not for new releases like &lt;code&gt;1.14.0&lt;/code&gt;, as the changelogs for &lt;code&gt;*.0&lt;/code&gt; releases tend to be excessively long. The &lt;code&gt;doc/source/release.rst&lt;/code&gt; file should also be updated with a link to the new release notes. These changes should be committed to the maintenance branch, and later will be forward ported to master.</source>
          <target state="translated">여기서 &lt;code&gt;GITHUB&lt;/code&gt; 에는 github 액세스 토큰이 포함되어 있습니다. 이 텍스트는 릴리스 업데이트 를 위해 &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; 에 추가 될 수 있습니다.하지만 &lt;code&gt;1.14.0&lt;/code&gt; 과 같은 새로운 릴리스에는 추가되지 않습니다. &lt;code&gt;*.0&lt;/code&gt; 릴리스에 대한 변경 로그 가 지나치게 긴 경향이 있기 때문입니다. &lt;code&gt;doc/source/release.rst&lt;/code&gt; 파일은 또한 새로운 릴리즈 노트에 대한 링크와 함께 업데이트해야합니다. 이러한 변경 사항은 유지 보수 분기에 커밋되어야하며 나중에 마스터로 포워딩됩니다.</target>
        </trans-unit>
        <trans-unit id="607e911964b92bbf30094d82119ac7da068f0db1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;GITHUB&lt;/code&gt; contains your github access token. This text may also be appended to &lt;code&gt;doc/release/1.19.0-notes.rst&lt;/code&gt; for patch release, though not for new releases like &lt;code&gt;1.19.0&lt;/code&gt;, as the changelogs for &lt;code&gt;*.0&lt;/code&gt; releases tend to be excessively long. The &lt;code&gt;doc/source/release.rst&lt;/code&gt; file should also be updated with a link to the new release notes. These changes should be committed to the maintenance branch, and later will be forward ported to master. The changelog should be reviewed for name duplicates or short names and the &lt;code&gt;.mailmap&lt;/code&gt; file updated if needed.</source>
          <target state="translated">여기서 &lt;code&gt;GITHUB&lt;/code&gt; 에는 github 액세스 토큰이 포함되어 있습니다. 이 텍스트는 패치 릴리스의 경우 &lt;code&gt;doc/release/1.19.0-notes.rst&lt;/code&gt; 에도 추가 될 수 있지만 &lt;code&gt;1.19.0&lt;/code&gt; 과 같은 새 릴리스의 경우는 아닙니다 . &lt;code&gt;*.0&lt;/code&gt; 릴리스 의 변경 로그 가 지나치게 긴 경향이 있기 때문입니다. &lt;code&gt;doc/source/release.rst&lt;/code&gt; 파일은 또한 새로운 릴리즈 노트에 대한 링크와 함께 업데이트해야합니다. 이러한 변경 사항은 유지 보수 분기에 커밋되어야하며 나중에 마스터로 포워딩됩니다. 변경 로그에서 이름 중복 또는 짧은 이름을 검토하고 필요한 경우 &lt;code&gt;.mailmap&lt;/code&gt; 파일을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="4b8c6ec18c2c43533633b2d6348c84d0e98e4282" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, the elements of &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, and the elements of &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;V&lt;/code&gt; 는 의사 가상의 Vandermonde 행렬 &lt;code&gt;x&lt;/code&gt; 이며, &lt;code&gt;c&lt;/code&gt; 의 요소는 풀어야 할 계수이며, &lt;code&gt;y&lt;/code&gt; 의 요소 는 관측 된 값입니다. 이 방정식은 &lt;code&gt;V&lt;/code&gt; 의 특이 값 분해를 사용하여 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="bed15d23c255396f5ff96e362455881dfb6045bf" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the weighted pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, &lt;code&gt;w&lt;/code&gt; are the weights, &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 가중 의사 Vandermonde 행렬이고 , &lt;code&gt;c&lt;/code&gt; 는 풀어야 할 계수이고, &lt;code&gt;w&lt;/code&gt; 는 가중치이며, &lt;code&gt;y&lt;/code&gt; 는 관측 값입니다. 이 방정식은 &lt;code&gt;V&lt;/code&gt; 의 특이 값 분해를 사용하여 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="d134ecc4ceb9149fc7a25fccd08e5a7a0a731874" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;V&lt;/code&gt; is the weighted pseudo Vandermonde matrix of &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt; are the coefficients to be solved for, &lt;code&gt;w&lt;/code&gt; are the weights, and &lt;code&gt;y&lt;/code&gt; are the observed values. This equation is then solved using the singular value decomposition of &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;V&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 가중 의사 Vandermonde 행렬이고 , &lt;code&gt;c&lt;/code&gt; 는 풀어야 할 계수이고, &lt;code&gt;w&lt;/code&gt; 는 가중이며, &lt;code&gt;y&lt;/code&gt; 는 관측 값입니다. 이 방정식은 &lt;code&gt;V&lt;/code&gt; 의 특이 값 분해를 사용하여 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="6cd5aea9272d9238144e1f9f8fbb6ec55a2f9e37" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;_i[&amp;lt;i&amp;gt;]&lt;/code&gt; refers to the &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;-th index value and that runs from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;shape(&amp;lt;array name&amp;gt;,&amp;lt;i&amp;gt;)-1&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;_i[&amp;lt;i&amp;gt;]&lt;/code&gt; 는 &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; 번째 인덱스 값을 나타내며 &lt;code&gt;0&lt;/code&gt; 부터 &lt;code&gt;shape(&amp;lt;array name&amp;gt;,&amp;lt;i&amp;gt;)-1&lt;/code&gt; 집니다.</target>
        </trans-unit>
        <trans-unit id="d6ef8bc2bec31043ebddcd21aa113fe148170b4b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n == len(roots) - 1&lt;/code&gt;; note that this implies that &lt;code&gt;1&lt;/code&gt; is always returned for</source>
          <target state="translated">여기서 &lt;code&gt;n == len(roots) - 1&lt;/code&gt; ; 이것은 &lt;code&gt;1&lt;/code&gt; 이 항상 반환 된다는 것을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4156f50382951be2ffb97afbef02067c099be6a8" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n&lt;/code&gt; is &lt;code&gt;deg&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;n&lt;/code&gt; 은 &lt;code&gt;deg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5da8ce8d8d1ee0181c57af0f31c56ab31f259987" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;n&lt;/code&gt; is the number of streams spawned. If a program uses an aggressive million streams, about</source>
          <target state="translated">여기서 &lt;code&gt;n&lt;/code&gt; 은 생성 된 스트림 수입니다. 프로그램이 공격적인 백만 개의 스트림을 사용하는 경우</target>
        </trans-unit>
        <trans-unit id="227e7320c448b66cb7c7d238597d7f3a2804dfcf" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;p&lt;/code&gt; is the probability of success of an individual trial.</source>
          <target state="translated">여기서 &lt;code&gt;p&lt;/code&gt; 는 개별 시행의 성공 확률입니다.</target>
        </trans-unit>
        <trans-unit id="97e11a7633599dcc0b171bd3aeedc2980516829b" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;seq&lt;/code&gt; would be a NumPy array of &lt;code&gt;double&lt;/code&gt; values, and its length &lt;code&gt;n&lt;/code&gt; would be extracted from &lt;code&gt;seq&lt;/code&gt; internally before being passed to the C routine. Even better, since NumPy supports construction of arrays from arbitrary Python sequences, &lt;code&gt;seq&lt;/code&gt; itself could be a nearly arbitrary sequence (so long as each element can be converted to a &lt;code&gt;double&lt;/code&gt;) and the wrapper code would internally convert it to a NumPy array before extracting its data and length.</source>
          <target state="translated">여기서 &lt;code&gt;seq&lt;/code&gt; 는 &lt;code&gt;double&lt;/code&gt; 값 의 NumPy 배열이며 길이 &lt;code&gt;n&lt;/code&gt; 은 C 루틴으로 전달되기 전에 &lt;code&gt;seq&lt;/code&gt; 에서 내부적 으로 추출됩니다 . 더 나은 점은 NumPy가 임의의 파이썬 시퀀스에서 배열 생성을 지원하기 때문에 &lt;code&gt;seq&lt;/code&gt; 자체는 거의 임의의 시퀀스 일 수 있습니다 (각 요소가 &lt;code&gt;double&lt;/code&gt; 로 변환 될 수있는 한 ) 래퍼 코드는 추출하기 전에 내부적으로 NumPy 배열로 변환합니다 데이터와 길이.</target>
        </trans-unit>
        <trans-unit id="f02a66bece2f0610117ed2e55b338b497ee6a2f1" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;subdtype&lt;/code&gt; is the subclass. Thus the returned view is of the same class as the subclass, rather than being of class &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;subdtype&lt;/code&gt; 은 하위 클래스입니다. 따라서 반환 된 뷰는 &lt;code&gt;ndarray&lt;/code&gt; 클래스가 아니라 하위 클래스와 동일한 클래스 입니다.</target>
        </trans-unit>
        <trans-unit id="75e868ab11f1f9e4c58bc8e76e5d240947af7c46" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;upstream&lt;/code&gt; points to the main &lt;a href=&quot;https://github.com/numpy/numpy.git&quot;&gt;https://github.com/numpy/numpy.git&lt;/a&gt; repository.</source>
          <target state="translated">여기서 &lt;code&gt;upstream&lt;/code&gt; 은 기본 &lt;a href=&quot;https://github.com/numpy/numpy.git&quot;&gt;https://github.com/numpy/numpy.git&lt;/a&gt; 저장소를 가리 킵니다 .</target>
        </trans-unit>
        <trans-unit id="3fa7dcc068f2c1b22079c4e51b9b1d150978fe4d" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;x2&lt;/code&gt; is often taken to be 0.5, but 0 and 1 are also sometimes used.</source>
          <target state="translated">여기서 &lt;code&gt;x2&lt;/code&gt; 는 종종 0.5로 간주되지만 0과 1도 종종 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6a9eda89bfd511983f4021317b7dd5833b1e827e" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;{bits}&lt;/code&gt; is the number of bits in the type and can be &lt;strong&gt;8&lt;/strong&gt;, &lt;strong&gt;16&lt;/strong&gt;, &lt;strong&gt;32&lt;/strong&gt;, &lt;strong&gt;64&lt;/strong&gt;, 128, and 256 for integer types; 16, &lt;strong&gt;32&lt;/strong&gt; , &lt;strong&gt;64&lt;/strong&gt;, 80, 96, 128, and 256 for floating-point types; and 32, &lt;strong&gt;64&lt;/strong&gt;, &lt;strong&gt;128&lt;/strong&gt;, 160, 192, and 512 for complex-valued types. Which bit-widths are available is platform dependent. The bolded bit-widths are usually available on all platforms.</source>
          <target state="translated">여기서 &lt;code&gt;{bits}&lt;/code&gt; 는 유형의 비트 수이며 정수 유형의 경우 &lt;strong&gt;8&lt;/strong&gt; , &lt;strong&gt;16&lt;/strong&gt; , &lt;strong&gt;32&lt;/strong&gt; , &lt;strong&gt;64&lt;/strong&gt; , 128 및 256 일 수 있습니다. 부동 소수점 유형의 경우 16, &lt;strong&gt;32&lt;/strong&gt; , &lt;strong&gt;64&lt;/strong&gt; , 80, 96, 128 및 256; 복소수 유형의 경우 32, &lt;strong&gt;64&lt;/strong&gt; , &lt;strong&gt;128&lt;/strong&gt; , 160, 192 및 512. 사용 가능한 비트 폭은 플랫폼에 따라 다릅니다. 굵은 비트 폭은 일반적으로 모든 플랫폼에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdc8cdc0932dfe2cf825eb22285d6dc4584efd79" translate="yes" xml:space="preserve">
          <source>where &lt;strong&gt;I&lt;/strong&gt; is the &lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt; identity matrix. &lt;a href=&quot;#r6c2ffae921d1-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</source>
          <target state="translated">여기서 &lt;strong&gt;I는&lt;/strong&gt; 은 IS &lt;code&gt;n&lt;/code&gt; -by- &lt;code&gt;n&lt;/code&gt; 항등 행렬이. &lt;a href=&quot;#r6c2ffae921d1-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c9d65fe7270866ad53495d99232a820922277569" translate="yes" xml:space="preserve">
          <source>where R is a non-nan real value. Complex values with the same nan placements are sorted according to the non-nan part if it exists. Non-nan values are sorted as before.</source>
          <target state="translated">여기서 R은 난이 아닌 실제 값입니다. Nan 배치가 동일한 복합 값은 Nan이 아닌 파트에 따라 정렬됩니다. 난이 아닌 값은 이전과 같이 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="c9686487c569c31836e68bc642e39a9e040607c0" translate="yes" xml:space="preserve">
          <source>where allowed comment characters for fixed and free format Fortran codes are &lt;code&gt;cC*!#&lt;/code&gt; and &lt;code&gt;!&lt;/code&gt;, respectively. Everything that follows &lt;code&gt;&amp;lt;comment char&amp;gt;f2py&lt;/code&gt; is ignored by a compiler but read by F2PY as a normal Fortran, non-comment line:</source>
          <target state="translated">고정 및 자유 형식 Fortran 코드에 허용되는 주석 문자는 &lt;code&gt;cC*!#&lt;/code&gt; 및 &lt;code&gt;!&lt;/code&gt; , 각각. &lt;code&gt;&amp;lt;comment char&amp;gt;f2py&lt;/code&gt; 뒤에 오는 모든 것은 컴파일러에 의해 무시되지만 F2PY는 일반 Fortran, 주석이 아닌 줄로 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9c3f870a9647b89f8d84edc93a3e3a7701994db4" translate="yes" xml:space="preserve">
          <source>where filename is a path relative to the reference guide source directory.</source>
          <target state="translated">여기서 filename은 참조 가이드 소스 디렉토리에 상대적인 경로입니다.</target>
        </trans-unit>
        <trans-unit id="5caa3907f70cffcfedf3fb4994a98de6a74be54f" translate="yes" xml:space="preserve">
          <source>where in this case the</source>
          <target state="translated">이 경우에</target>
        </trans-unit>
        <trans-unit id="a0047659d01e6a2429cd941ed10ecc15806ec5e4" translate="yes" xml:space="preserve">
          <source>where p = probability.</source>
          <target state="translated">여기서 p = 확률.</target>
        </trans-unit>
        <trans-unit id="ca92675847cdd29f796e592505c1d46281fcc976" translate="yes" xml:space="preserve">
          <source>where the</source>
          <target state="translated">어디</target>
        </trans-unit>
        <trans-unit id="53fc0cd37ec015722cb1c47e4ca053728ac6eba6" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;r_n&lt;/code&gt; are the roots specified in &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt;. If a zero has multiplicity n, then it must appear in &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; n times. For instance, if 2 is a root of multiplicity three and 3 is a root of multiplicity 2, then &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt;&lt;code&gt;roots&lt;/code&gt;&lt;/a&gt; looks something like [2, 2, 2, 3, 3]. The roots can appear in any order.</source>
          <target state="translated">여기서 &lt;code&gt;r_n&lt;/code&gt; 은 roots에 지정된 &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt; 입니다. 0이 다중도 n을 갖는 경우, &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt; n 번 나타나야합니다 . 예를 들어, 2가 다중도 3의 근이고 3이 다중도 2의 &lt;a href=&quot;numpy.roots#numpy.roots&quot;&gt; &lt;code&gt;roots&lt;/code&gt; &lt;/a&gt; 이면 근 은 [2, 2, 2, 3, 3]과 비슷합니다. 뿌리는 임의의 순서로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c1ce56b739d1a90c6c7a8decdd89da276904513" translate="yes" xml:space="preserve">
          <source>where the &lt;code&gt;r_n&lt;/code&gt; are the roots specified in &lt;code&gt;roots&lt;/code&gt;. If a zero has multiplicity n, then it must appear in &lt;code&gt;roots&lt;/code&gt; n times. For instance, if 2 is a root of multiplicity three and 3 is a root of multiplicity 2, then &lt;code&gt;roots&lt;/code&gt; looks something like [2, 2, 2, 3, 3]. The roots can appear in any order.</source>
          <target state="translated">여기서 &lt;code&gt;r_n&lt;/code&gt; 은 roots에 지정된 &lt;code&gt;roots&lt;/code&gt; 입니다. 0에 다중도 n이 있으면 &lt;code&gt;roots&lt;/code&gt; n에 n을 표시해야합니다 . 예를 들어,이 경우 다양성 세와 3의 루트 다양성이의 루트입니다, 다음 &lt;code&gt;roots&lt;/code&gt; 처럼 보이는 뭔가 [2, 2, 2, 3, 3]. 뿌리는 어떤 순서로도 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de25e1e31fb8e144046ff201f8ad1ae5facb6b87" translate="yes" xml:space="preserve">
          <source>where the normalization, B, is the beta function,</source>
          <target state="translated">정규화 B는 베타 함수입니다.</target>
        </trans-unit>
        <trans-unit id="1279820475c803c32a1be658737be93ee2a97148" translate="yes" xml:space="preserve">
          <source>where the points &lt;code&gt;(a, b)&lt;/code&gt; consist of all pairs formed by taking &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;y&lt;/code&gt;. The resulting points form a grid with &lt;code&gt;x&lt;/code&gt; in the first dimension and &lt;code&gt;y&lt;/code&gt; in the second.</source>
          <target state="translated">여기서, 점 &lt;code&gt;(a, b)&lt;/code&gt; 취함으로써 형성되는 모든 쌍으로 구성 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;y&lt;/code&gt; . 결과 점 은 첫 번째 차원에 &lt;code&gt;x&lt;/code&gt; 가 있고 두 번째 차원에 &lt;code&gt;y&lt;/code&gt; 가 있는 그리드를 형성합니다 .</target>
        </trans-unit>
        <trans-unit id="a6af8e5313e77ee7d6837ec79be794a7042e7075" translate="yes" xml:space="preserve">
          <source>where the points &lt;code&gt;(a, b, c)&lt;/code&gt; consist of all triples formed by taking &lt;code&gt;a&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; from &lt;code&gt;y&lt;/code&gt;, and &lt;code&gt;c&lt;/code&gt; from &lt;code&gt;z&lt;/code&gt;. The resulting points form a grid with &lt;code&gt;x&lt;/code&gt; in the first dimension, &lt;code&gt;y&lt;/code&gt; in the second, and &lt;code&gt;z&lt;/code&gt; in the third.</source>
          <target state="translated">여기서 점 &lt;code&gt;(a, b, c)&lt;/code&gt; 촬영에 의해 형성된 모든 트리플 구성 &lt;code&gt;a&lt;/code&gt; 으로부터 &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; 에서 &lt;code&gt;y&lt;/code&gt; 와 &lt;code&gt;c&lt;/code&gt; 에서 &lt;code&gt;z&lt;/code&gt; . 얻어진 점은 그리드 형성 &lt;code&gt;x&lt;/code&gt; 제 치수, &lt;code&gt;y&lt;/code&gt; 번째, 그리고 &lt;code&gt;z&lt;/code&gt; 세번째하여.</target>
        </trans-unit>
        <trans-unit id="83bfe9a2efafb46b83cd23b5c8266a3fd8781bb3" translate="yes" xml:space="preserve">
          <source>where() (in module numpy)</source>
          <target state="translated">where () (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="365862a50c0682caa8baa6f30edca76e3e5f81ed" translate="yes" xml:space="preserve">
          <source>where:</source>
          <target state="translated">where:</target>
        </trans-unit>
        <trans-unit id="bee8de4d18b018e76e45831ecaa774c3f734bfce" translate="yes" xml:space="preserve">
          <source>whether or not you have multiple versions of Python installed</source>
          <target state="translated">여러 버전의 Python이 설치되어 있는지 여부</target>
        </trans-unit>
        <trans-unit id="e37dbee4cae0df6201c1f4811e9b9537f69aabb6" translate="yes" xml:space="preserve">
          <source>which evaluates to:</source>
          <target state="translated">다음과 같이 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="a01e140cc92cbe722c0b95c684104ebb6b342985" translate="yes" xml:space="preserve">
          <source>which extends in the obvious way to higher dimensions, and the inverses in higher dimensions also extend in the same way.</source>
          <target state="translated">이것은 명백한 방식으로 더 높은 차원으로 확장되고 더 높은 차원의 역도 같은 방식으로 확장됩니다.</target>
        </trans-unit>
        <trans-unit id="ced4c5cabdd3ef65db772d8c6ef758745f7d3e32" translate="yes" xml:space="preserve">
          <source>which is different from a common alternative,</source>
          <target state="translated">일반적인 대안과는 다른</target>
        </trans-unit>
        <trans-unit id="84e2d073d86e6b4b5f8c8391549685b60c7e4b55" translate="yes" xml:space="preserve">
          <source>which is not the right shape for showing the image. Finally, reordering the axes back to our original shape of &lt;code&gt;(768, 1024, 3)&lt;/code&gt;, we can see our approximation:</source>
          <target state="translated">이미지를 표시하기에 적합한 모양이 아닙니다. 마지막으로 축을 원래 모양 인 &lt;code&gt;(768, 1024, 3)&lt;/code&gt; 다시 정렬하면 근사치를 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ee66060f3ffdf52489d6d257097e268641308e4" translate="yes" xml:space="preserve">
          <source>which is related to &lt;code&gt;c_{av}[k]&lt;/code&gt; by &lt;code&gt;c'_{av}[k] = c_{av}[-k]&lt;/code&gt;.</source>
          <target state="translated">이는이 관련된 &lt;code&gt;c_{av}[k]&lt;/code&gt; 가 &lt;code&gt;c'_{av}[k] = c_{av}[-k]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="778d43b6da6e59d12f7b859a3d029062778f7c7d" translate="yes" xml:space="preserve">
          <source>which part of the memory block each field takes.</source>
          <target state="translated">각 필드가 차지하는 메모리 블록의 부분.</target>
        </trans-unit>
        <trans-unit id="03234ac0a2f49221ceb858c5491d51de84061ef9" translate="yes" xml:space="preserve">
          <source>which provides 5 pointers. The first is an opaque pointer to the data structure used by the BitGenerators. The next three are function pointers which return the next 64- and 32-bit unsigned integers, the next random double and the next raw value. This final function is used for testing and so can be set to the next 64-bit unsigned integer function if not needed. Functions inside &lt;code&gt;Generator&lt;/code&gt; use this structure as in</source>
          <target state="translated">5 개의 포인터를 제공합니다. 첫 번째는 BitGenerator가 사용하는 데이터 구조에 대한 불투명 포인터입니다. 다음 세 개는 다음 64 및 32 비트 부호없는 정수, 다음 임의의 double 및 다음 원시 값을 반환하는 함수 포인터입니다. 이 최종 함수는 테스트에 사용되므로 필요하지 않은 경우 다음 64 비트 부호없는 정수 함수로 설정할 수 있습니다. &lt;code&gt;Generator&lt;/code&gt; 내부의 함수 는 다음과 같이이 구조를 사용합니다</target>
        </trans-unit>
        <trans-unit id="d47c4daeb44b47194663061e95cd8003350155df" translate="yes" xml:space="preserve">
          <source>which renders as &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 로 렌더링됩니다 .</target>
        </trans-unit>
        <trans-unit id="670381f53d7dde4b658afc72fb1f03743b30325f" translate="yes" xml:space="preserve">
          <source>which should be used for new code.</source>
          <target state="translated">새 코드에 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="9c7c5f596971b2cd6617c86437a81292c06ddf91" translate="yes" xml:space="preserve">
          <source>which should be used in new code</source>
          <target state="translated">새 코드에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="376b56642da39094e74a99573c74c162327692be" translate="yes" xml:space="preserve">
          <source>which will rebuild NumPy, install it to a temporary location, and build the documentation in all formats. This will most likely again only work on Unix platforms.</source>
          <target state="translated">NumPy를 다시 빌드하고 임시 위치에 설치하고 모든 형식으로 문서를 빌드합니다. 이것은 다시 Unix 플랫폼에서만 작동합니다.</target>
        </trans-unit>
        <trans-unit id="63577216ef75495c55551997ebb50867df34281b" translate="yes" xml:space="preserve">
          <source>which would have provided automatic type conversions for arrays of type &lt;code&gt;Py_complex&lt;/code&gt;, &lt;code&gt;npy_cfloat&lt;/code&gt; and &lt;code&gt;npy_cdouble&lt;/code&gt;. However, it seemed unlikely that there would be any independent (non-Python, non-NumPy) application code that people would be using &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; to generate a Python interface to, that also used these definitions for complex types. More likely, these application codes will define their own complex types, or in the case of C++, use &lt;code&gt;std::complex&lt;/code&gt;. Assuming these data structures are compatible with Python and NumPy complex types, &lt;code&gt;%numpy_typemap&lt;/code&gt; expansions as above (with the user&amp;rsquo;s complex type substituted for the first argument) should work.</source>
          <target state="translated">&lt;code&gt;Py_complex&lt;/code&gt; , &lt;code&gt;npy_cfloat&lt;/code&gt; 및 &lt;code&gt;npy_cdouble&lt;/code&gt; 유형의 배열에 대한 자동 유형 변환을 제공했을 것 입니다. 그러나 사람들이 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 를 사용하여 Python 인터페이스를 생성하고 복잡한 유형에 대해 이러한 정의를 사용 하는 독립적 인 (비 Python, NonNumPy) 응용 프로그램 코드가 없을 것 같습니다 . 이러한 응용 프로그램 코드는 고유 한 복잡한 유형을 정의하거나 C ++의 경우 &lt;code&gt;std::complex&lt;/code&gt; 합니다. 이러한 데이터 구조가 Python 및 NumPy 복합 유형과 호환 가능 &lt;code&gt;%numpy_typemap&lt;/code&gt; 가정하면 위의 % numpy_typemap 확장 (사용자의 복합 유형이 첫 번째 인수로 대체 됨)이 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="aad927bf697b386bb3e4f9b23016432e840fc725" translate="yes" xml:space="preserve">
          <source>who() (in module numpy)</source>
          <target state="translated">who () (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="2776b6c93cb7c4153849413953e56a2e5f33d80a" translate="yes" xml:space="preserve">
          <source>width:</source>
          <target state="translated">width:</target>
        </trans-unit>
        <trans-unit id="13bce647c8362fa91ee40694295febf34b1ec7fe" translate="yes" xml:space="preserve">
          <source>will allow using anything &lt;strong&gt;but&lt;/strong&gt; NetLIB BLAS and ATLAS libraries, the order of the above list is retained.</source>
          <target state="translated">아무것도 사용하실 수 &lt;strong&gt;있지만&lt;/strong&gt; NETLIB BLAS와 ATLAS 라이브러리를, 위의 목록의 순서가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="27fa578bb2dbcc1e48218589e15dc33381c7adf2" translate="yes" xml:space="preserve">
          <source>will allow using anything &lt;strong&gt;but&lt;/strong&gt; the NetLIB LAPACK library, the order of the above list is retained.</source>
          <target state="translated">아무것도 사용하실 수 &lt;strong&gt;있지만&lt;/strong&gt; NETLIB LAPACK 라이브러리를, 위의 목록의 순서가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="9fabe3e5adc197f1aefb22a24a130eff8c2333b8" translate="yes" xml:space="preserve">
          <source>will build two extension modules &lt;code&gt;scalar&lt;/code&gt; and &lt;code&gt;fib2&lt;/code&gt; to the build directory.</source>
          <target state="translated">두 개의 확장 모듈 &lt;code&gt;scalar&lt;/code&gt; 와 &lt;code&gt;fib2&lt;/code&gt; 를 빌드 디렉토리에 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="2344e686feb0404839466210c31bd50c5f4d1ab2" translate="yes" xml:space="preserve">
          <source>will cause a program crash on most systems. Under the covers, the lists are being converted to proper arrays but then the underlying add loop is told to cycle way beyond the borders of the allocated memory.</source>
          <target state="translated">대부분의 시스템에서 프로그램 충돌이 발생합니다. 내부적으로 목록은 적절한 배열로 변환되지만 기본 추가 루프는 할당 된 메모리의 경계를 넘어 순환하도록 지시됩니다.</target>
        </trans-unit>
        <trans-unit id="5c7e83ac1040b10c50be2504c71c5845f663b6fd" translate="yes" xml:space="preserve">
          <source>will compile the &lt;code&gt;library&lt;/code&gt; sources without optimization flags.</source>
          <target state="translated">최적화 플래그없이 &lt;code&gt;library&lt;/code&gt; 소스를 컴파일합니다 .</target>
        </trans-unit>
        <trans-unit id="51356c12b39d1c2e5b60995f4d65e090afd1cd6f" translate="yes" xml:space="preserve">
          <source>will create an &lt;code&gt;alias&lt;/code&gt; section in your &lt;code&gt;.gitconfig&lt;/code&gt; file with contents like this:</source>
          <target state="translated">&lt;code&gt;.gitconfig&lt;/code&gt; 파일에 다음과 같은 내용으로 &lt;code&gt;alias&lt;/code&gt; 섹션을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8d20a2ce8660814e46481f17cf57f185c268fa43" translate="yes" xml:space="preserve">
          <source>will install data files to the following locations</source>
          <target state="translated">다음 위치에 데이터 파일을 설치합니다</target>
        </trans-unit>
        <trans-unit id="9431832ed81f189de77da34df58a265d7a0dab02" translate="yes" xml:space="preserve">
          <source>will install these data files to:</source>
          <target state="translated">이 데이터 파일을 다음 위치에 설치합니다.</target>
        </trans-unit>
        <trans-unit id="65f2fae653365ee5c4440c9cc9c2d032f733a63a" translate="yes" xml:space="preserve">
          <source>will need to be changed. This code has raised a &lt;code&gt;FutureWarning&lt;/code&gt; since Numpy 1.12, and similar code has raised &lt;code&gt;FutureWarning&lt;/code&gt; since 1.7.</source>
          <target state="translated">변경해야합니다. 이 코드는 제기했다 &lt;code&gt;FutureWarning&lt;/code&gt; NumPy와 1.12 이후, 그리고 유사한 코드가 발생했다 &lt;code&gt;FutureWarning&lt;/code&gt; 을 1.7 있기 때문이다.</target>
        </trans-unit>
        <trans-unit id="c48dc5d80033d088b313d555b44339bd63ffba66" translate="yes" xml:space="preserve">
          <source>will output the difference from G to C (i.e. with effects of F and G), while:</source>
          <target state="translated">G에서 C 로의 차이를 출력합니다 (예 : F 및 G의 효과 포함).</target>
        </trans-unit>
        <trans-unit id="98b3c1b6f0363b4b36389d5d1b18d315d36840fd" translate="yes" xml:space="preserve">
          <source>will prefer to use ATLAS, then BLIS, then OpenBLAS and as a last resort MKL. If neither of these exists the build will fail (names are compared lower case).</source>
          <target state="translated">ATLAS, BLIS, OpenBLAS, 그리고 마지막 수단으로 MKL을 사용하는 것을 선호합니다. 둘 다 존재하지 않으면 빌드가 실패합니다 (이름은 소문자로 비교됨).</target>
        </trans-unit>
        <trans-unit id="6b43fee04276950efbf0354e10bfe96ae5f91c4b" translate="yes" xml:space="preserve">
          <source>will prefer to use ATLAS, then OpenBLAS and as a last resort MKL. If neither of these exists the build will fail (names are compared lower case).</source>
          <target state="translated">ATLAS를 선호하고 OpenBLAS를 사용하고 MKL을 최후의 수단으로 사용합니다. 둘 다 존재하지 않으면 빌드가 실패합니다 (이름은 소문자로 비교됨).</target>
        </trans-unit>
        <trans-unit id="fcf97db7680020e322957977ba54cdaae4e7c664" translate="yes" xml:space="preserve">
          <source>will result in typemaps that will produce code that reference improper data lengths. You can implement the following macro expansion:</source>
          <target state="translated">부적절한 데이터 길이를 참조하는 코드를 생성하는 유형 맵이 생성됩니다. 다음과 같은 매크로 확장을 구현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d09fffb5db2d7f631ba43ccc256617b444056d2e" translate="yes" xml:space="preserve">
          <source>win32</source>
          <target state="translated">win32</target>
        </trans-unit>
        <trans-unit id="273e334ec36853f9f9a05c2de34faba48191ff1f" translate="yes" xml:space="preserve">
          <source>window (numpy.polynomial.chebyshev.Chebyshev attribute)</source>
          <target state="translated">창 (numpy.polynomial.chebyshev.Chebyshev의 속성)</target>
        </trans-unit>
        <trans-unit id="8fcd25a39d2037183044a8897e9a5333d727fded" translate="yes" xml:space="preserve">
          <source>with</source>
          <target state="translated">with</target>
        </trans-unit>
        <trans-unit id="85906e975567ef059f93ee1ec6cded27b66be258" translate="yes" xml:space="preserve">
          <source>with a and v sequences being zero-padded where necessary and conj being the conjugate.</source>
          <target state="translated">a 및 v 서열은 필요한 경우 제로-패딩되고 컨쥬 게이트는 컨쥬 게이트이다.</target>
        </trans-unit>
        <trans-unit id="fb4da7b2e3434f85dca212e250f77b33115633d3" translate="yes" xml:space="preserve">
          <source>with assert_warns(SomeWarning):</source>
          <target state="translated">assert_warns (일부 경고) :</target>
        </trans-unit>
        <trans-unit id="198054914927940c04570defb3a1b48438d7e3f0" translate="yes" xml:space="preserve">
          <source>with similar code for &lt;code&gt;cadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, and &lt;code&gt;sadd&lt;/code&gt; that handles complex float, double, and float data-types, respectively:</source>
          <target state="translated">복잡한 float, double 및 float 데이터 유형을 각각 처리하는 &lt;code&gt;cadd&lt;/code&gt; , &lt;code&gt;dadd&lt;/code&gt; 및 &lt;code&gt;sadd&lt;/code&gt; 에 대한 유사한 코드를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="0080f1a2ae1b166b68400bbd8e3bf2ad9b849c08" translate="yes" xml:space="preserve">
          <source>with the elements of &lt;code&gt;s&lt;/code&gt; in its diagonal and with the appropriate dimensions for multiplying: in our case,</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 의 요소를 대각선으로 사용하고 곱하기위한 적절한 차원을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="475445d83d4b5fb4eb9cadb9634afa9926972eb2" translate="yes" xml:space="preserve">
          <source>with the weight function</source>
          <target state="translated">무게 기능으로</target>
        </trans-unit>
        <trans-unit id="e9106aaf08247a295732f94cac129b955c2a6cce" translate="yes" xml:space="preserve">
          <source>with their Taylor series expansion, this translates into solving the following the linear system:</source>
          <target state="translated">Taylor 시리즈 확장을 통해 다음 선형 시스템을 해결합니다.</target>
        </trans-unit>
        <trans-unit id="e2ac21e5524a785601b5d72a44f59a41ff0de1fa" translate="yes" xml:space="preserve">
          <source>with which we now extract only three elements:</source>
          <target state="translated">이제 세 가지 요소 만 추출합니다.</target>
        </trans-unit>
        <trans-unit id="73978edcd3b1eeaba9e3510afd89a742dbbd379c" translate="yes" xml:space="preserve">
          <source>work space</source>
          <target state="translated">작업 공간</target>
        </trans-unit>
        <trans-unit id="d664dcdca19ca8d9b446631ef2412473ee2226f1" translate="yes" xml:space="preserve">
          <source>worst case</source>
          <target state="translated">최악의 경우</target>
        </trans-unit>
        <trans-unit id="3632e151c760c3c0cb60d7646cc6fdee30ebbafe" translate="yes" xml:space="preserve">
          <source>would output just differences in the topic branch (i.e. only A, B, and C).</source>
          <target state="translated">토픽 브랜치 (즉, A, B, C 만)의 차이 만 출력합니다.</target>
        </trans-unit>
        <trans-unit id="6f1f2b93f598ca8c33b6833c0a41bac0f1e8474a" translate="yes" xml:space="preserve">
          <source>wrap values &amp;lt; 0 by adding len(&lt;em&gt;op&lt;/em&gt;) and values &amp;gt;=len(&lt;em&gt;op&lt;/em&gt;) by subtracting len(&lt;em&gt;op&lt;/em&gt;) until they are in range;</source>
          <target state="translated">랩 값 &amp;lt;렌 (0 첨가하여 &lt;em&gt;영업 이익&lt;/em&gt; ) 및 값&amp;gt; = LEN ( &lt;em&gt;OP&lt;/em&gt; 렌 (감산하여) &lt;em&gt;연산&lt;/em&gt; 들은 범위까지);</target>
        </trans-unit>
        <trans-unit id="c4ce690c09e8b66a80dc42798b931fd3f8dfe52d" translate="yes" xml:space="preserve">
          <source>wraps the C library function &lt;code&gt;system()&lt;/code&gt;:</source>
          <target state="translated">C 라이브러리 함수 &lt;code&gt;system()&lt;/code&gt; 래핑합니다 .</target>
        </trans-unit>
        <trans-unit id="11f6ad8ec52a2984abaafd7c3b516503785c2072" translate="yes" xml:space="preserve">
          <source>x</source>
          <target state="translated">x</target>
        </trans-unit>
        <trans-unit id="308f064ded46d05826bfd10e2ded24601eb24df9" translate="yes" xml:space="preserve">
          <source>x is equal to linspace(self.domain[0], self.domain[1], n) and y is the series evaluated at element of x.</source>
          <target state="translated">x는 linspace (self.domain [0], self.domain [1], n)과 같고 y는 x의 요소에서 평가 된 계열입니다.</target>
        </trans-unit>
        <trans-unit id="59dd422e447dd066581be0b92845e52e84b598c5" translate="yes" xml:space="preserve">
          <source>x-coordinates of the &lt;code&gt;M&lt;/code&gt; sample (data) points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;M&lt;/code&gt; 샘플 (데이터) 점 의 x 좌표 &lt;code&gt;(x[i], y[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba94ec9deda2ba79411318119236f9d9739ce86c" translate="yes" xml:space="preserve">
          <source>x-coordinates of the M sample points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">M 샘플 포인트의 x 좌표 &lt;code&gt;(x[i], y[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5cb437551401adf121138e8924c8f0383053f491" translate="yes" xml:space="preserve">
          <source>x.__getitem__(y) &amp;lt;==&amp;gt; x[y]</source>
          <target state="translated">x .__ getitem __ (y) &amp;lt;==&amp;gt; x [y]</target>
        </trans-unit>
        <trans-unit id="fdc9be9752ea52874fd39a2bdad0f5823c5b6118" translate="yes" xml:space="preserve">
          <source>x.__setitem__(i, y) &amp;lt;==&amp;gt; x[i]=y</source>
          <target state="translated">x .__ setitem __ (i, y) &amp;lt;==&amp;gt; x [i] = y</target>
        </trans-unit>
        <trans-unit id="344b1df0fe46a98fd4e221e42af496e380c32ddf" translate="yes" xml:space="preserve">
          <source>x86 - CPU feature names</source>
          <target state="translated">x86-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="43b450669c7286193c5254c90bdb392eaf23f5db" translate="yes" xml:space="preserve">
          <source>x86 - Group names</source>
          <target state="translated">x86-그룹 이름</target>
        </trans-unit>
        <trans-unit id="08295c7bc6ebf5316eef21f8acebd8d7cd029921" translate="yes" xml:space="preserve">
          <source>x86::Intel Compiler - CPU feature names</source>
          <target state="translated">x86 :: Intel 컴파일러-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="c5d394b1f44c3682fa63a0111665b3afbefe4aea" translate="yes" xml:space="preserve">
          <source>x86::Microsoft Visual C/C++ - CPU feature names</source>
          <target state="translated">x86 :: Microsoft Visual C / C ++-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="da421920ce1bd5a03d063f77e2157e2573edaac2" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (-(i + 1)*P_{i + 1}(x) + (2i + 1)P_{i}(x) - iP_{i - 1}(x))</source>
          <target state="translated">xP_i (x) = (-(i + 1) * P_ {i + 1} (x) + (2i + 1) P_ {i} (x)-iP_ {i-1} (x))</target>
        </trans-unit>
        <trans-unit id="1b073b5ec82f790856556cc378140ccaef2424ed" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (P_{i + 1}(x) + iP_{i - 1}(x)))</source>
          <target state="translated">xP_i (x) = (P_ {i + 1} (x) + iP_ {i-1} (x)))</target>
        </trans-unit>
        <trans-unit id="ef078637a19fed7e5c5fce6ae955f054edcce03b" translate="yes" xml:space="preserve">
          <source>xP_i(x) = (P_{i + 1}(x)/2 + i*P_{i - 1}(x))</source>
          <target state="translated">xP_i (x) = (P_ {i + 1} (x) / 2 + i * P_ {i-1} (x))</target>
        </trans-unit>
        <trans-unit id="7e771f58043b3b39cee02a1814b5e97f817e4084" translate="yes" xml:space="preserve">
          <source>y : A floating point representation of Not a Number.</source>
          <target state="translated">y : 숫자가 아닌 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="fe74eb20b81eed402c9b311b14c54faa75f17f0e" translate="yes" xml:space="preserve">
          <source>y = floor(&lt;code&gt;x1&lt;/code&gt;/&lt;code&gt;x2&lt;/code&gt;) This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">y = floor ( &lt;code&gt;x1&lt;/code&gt; / &lt;code&gt;x2&lt;/code&gt; ) &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="0153765279a24863ca46c77e0a9178c4b4e2152f" translate="yes" xml:space="preserve">
          <source>y is an array of the same subtype as &lt;code&gt;a&lt;/code&gt;, with shape &lt;code&gt;(a.size,)&lt;/code&gt;. Note that matrices are special cased for backward compatibility, if &lt;code&gt;a&lt;/code&gt; is a matrix, then y is a 1-D ndarray.</source>
          <target state="translated">y는 shape &lt;code&gt;(a.size,)&lt;/code&gt; 가 &lt;code&gt;a&lt;/code&gt; 와 동일한 하위 유형의 배열입니다 . 행렬은 역 호환성을 위해 특수한 경우입니다. &lt;code&gt;a&lt;/code&gt; 가 행렬 인 경우 y는 1 차원 ndarray입니다.</target>
        </trans-unit>
        <trans-unit id="5d4da4e2a79f33194ecd725a3df53905dab08a90" translate="yes" xml:space="preserve">
          <source>y-coordinates of the M sample points &lt;code&gt;(x[i], y[i])&lt;/code&gt;.</source>
          <target state="translated">M 개 샘플 포인트의 y 좌표 &lt;code&gt;(x[i], y[i])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71b29d0659535339d20f2f2d3906d3133889c3fc" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several data sets of sample points sharing the same x-coordinates can be fitted at once by passing in a 2D-array that contains one dataset per column.</source>
          <target state="translated">샘플 포인트의 y 좌표 열당 하나의 데이터 집합을 포함하는 2D 배열을 전달하여 동일한 x 좌표를 공유하는 여러 샘플 점 데이터 집합을 한 번에 맞출 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c5bcca9b96afa5b616e3604f848cc87a49f687f" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to &lt;a href=&quot;#numpy.polynomial.polynomial.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; by passing in for &lt;code&gt;y&lt;/code&gt; a 2-D array that contains one data set per column.</source>
          <target state="translated">샘플 포인트의 y 좌표 동일한 x 좌표를 공유하는 여러 샘플 포인트 세트는 &lt;a href=&quot;#numpy.polynomial.polynomial.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; 하나의 데이터 세트를 포함하는 2 차원 배열 을 &lt;code&gt;y&lt;/code&gt; 로 전달 하여 한 번의 polyfit 호출에 독립적으로 맞출 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c246519118cdd1a1151602d948da3fb079223f11" translate="yes" xml:space="preserve">
          <source>y-coordinates of the sample points. Several sets of sample points sharing the same x-coordinates can be (independently) fit with one call to &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; by passing in for &lt;code&gt;y&lt;/code&gt; a 2-D array that contains one data set per column.</source>
          <target state="translated">샘플 포인트의 y 좌표. 동일한 x 좌표를 공유하는 여러 샘플 포인트 세트는 &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; 하나의 데이터 세트를 포함하는 2D 배열 을 &lt;code&gt;y&lt;/code&gt; 에 전달 하여 polyfit 에 대한 한 번의 호출로 (독립적으로) 적합 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ff0b1538469338a0073e2cdaab6a517801b6ab4" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="translated">year</target>
        </trans-unit>
        <trans-unit id="df1118dd020814fd66ffa05fad743411846bb68c" translate="yes" xml:space="preserve">
          <source>yellow_text() (in module numpy.distutils.misc_util)</source>
          <target state="translated">yellow_text () (numpy.distutils.misc_util 모듈)</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="88e1e34fad9aac1803c28d999922c02344bde475" translate="yes" xml:space="preserve">
          <source>you can use &lt;code&gt;np.unique&lt;/code&gt; to print the unique values in your array:</source>
          <target state="translated">&lt;code&gt;np.unique&lt;/code&gt; 를 사용 하여 배열의 고유 값을 인쇄 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8ab429b829aab8de3c0b16635dc4fdd7df6b01db" translate="yes" xml:space="preserve">
          <source>your operating system</source>
          <target state="translated">운영 체제</target>
        </trans-unit>
        <trans-unit id="321f014e68afc5d27fa673e253b66c1d1a885e28" translate="yes" xml:space="preserve">
          <source>zero-dimensional numpy arrays</source>
          <target state="translated">0 차원 numpy 배열</target>
        </trans-unit>
        <trans-unit id="851d6a9d4f40adec7bdb22e6aa7d78c29e7bad48" translate="yes" xml:space="preserve">
          <source>zero-terminated bytes (not recommended)</source>
          <target state="translated">0으로 끝나는 바이트 (권장되지 않음)</target>
        </trans-unit>
        <trans-unit id="3f703704e5615124533004024ac41835014b9923" translate="yes" xml:space="preserve">
          <source>zeros (in module numpy.ma)</source>
          <target state="translated">0 (numpy.ma 모듈)</target>
        </trans-unit>
        <trans-unit id="03d38f0c14bca6590a27cad020688a8a53013cf8" translate="yes" xml:space="preserve">
          <source>zeros() (in module numpy)</source>
          <target state="translated">zeros () (numpy 모듈에서)</target>
        </trans-unit>
        <trans-unit id="f79617894be2a60271313f0d6918d0d57f8af46b" translate="yes" xml:space="preserve">
          <source>zeros(shape) will create an array filled with 0 values with the specified shape. The default dtype is float64.</source>
          <target state="translated">zeros (shape)는 지정된 모양으로 0 값으로 채워진 배열을 만듭니다. 기본 dtype은 float64입니다.</target>
        </trans-unit>
        <trans-unit id="bfb64fa17a2dd83829c97a1d19df887e579e00bf" translate="yes" xml:space="preserve">
          <source>zeros_like() (in module numpy)</source>
          <target state="translated">zeros_like () (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="1ecf8a17ab7800b6df8335d0e6bba16f16db3bac" translate="yes" xml:space="preserve">
          <source>zfill() (in module numpy.char)</source>
          <target state="translated">zfill () (numpy.char 모듈)</target>
        </trans-unit>
        <trans-unit id="3a4c1e0cb58cf02c936b120b0a676057daae3f59" translate="yes" xml:space="preserve">
          <source>zipf() (in module numpy.random)</source>
          <target state="translated">zipf () (numpy.random 모듈)</target>
        </trans-unit>
        <trans-unit id="7b16e4ea6cc467a3916252ca6ee5a838978ad9b6" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;B&amp;rsquo;} - big endian</source>
          <target state="translated">{ '&amp;gt;', 'B'}-빅 엔디안</target>
        </trans-unit>
        <trans-unit id="b1ed97369b58f912aec9b237bafe79be656e3b50" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;big&amp;rsquo;} - big endian</source>
          <target state="translated">{ '&amp;gt;', 'big'}-빅 엔디안</target>
        </trans-unit>
        <trans-unit id="69450a331083a0b68e4b8ea4f8d3ea5eed96797f" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;L&amp;rsquo;} - little endian</source>
          <target state="translated">{ '&amp;lt;', 'L'}-리틀 엔디안</target>
        </trans-unit>
        <trans-unit id="837338df0bd2d77a5c9b0a5480413547dfdf02d8" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;little&amp;rsquo;} - little endian</source>
          <target state="translated">{ '&amp;lt;', 'little'}-리틀 엔디안</target>
        </trans-unit>
        <trans-unit id="4a18b0c9674466129cdcccc0b853d0e7924dffb5" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;=&amp;rsquo;, &amp;lsquo;N&amp;rsquo;} - native order</source>
          <target state="translated">{ '=', 'N'}-기본 순서</target>
        </trans-unit>
        <trans-unit id="d8c7bacdfb9bb97d8000c8d86e26ecc69e84c128" translate="yes" xml:space="preserve">
          <source>{&amp;lsquo;|&amp;rsquo;, &amp;lsquo;I&amp;rsquo;} - ignore (no change to byte order)</source>
          <target state="translated">{ '|', 'I'}-무시 (바이트 순서 변경 없음)</target>
        </trans-unit>
        <trans-unit id="129c2a92772859dd050db619eaedbf46e847091c" translate="yes" xml:space="preserve">
          <source>~n/2</source>
          <target state="translated">~n/2</target>
        </trans-unit>
        <trans-unit id="ff8c31042699d05d07f6e439438f8c8528e3badb" translate="yes" xml:space="preserve">
          <source>~self</source>
          <target state="translated">~self</target>
        </trans-unit>
        <trans-unit id="8105745e3f0510d3e2e069ea766a5a441edea419" translate="yes" xml:space="preserve">
          <source>“descr” : dtype.descr</source>
          <target state="translated">&amp;ldquo;descr&amp;rdquo;: dtype.descr</target>
        </trans-unit>
        <trans-unit id="b7ed67990b9e24b4aacf785a5ce0eac13652bccc" translate="yes" xml:space="preserve">
          <source>⋮</source>
          <target state="translated">⋮</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
