<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="97ab86f3d69d58ce3be53a871603ed078f8824cf" translate="yes" xml:space="preserve">
          <source>To describe the type of scalar data, there are several &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;built-in scalar types&lt;/a&gt; in NumPy for various precision of integers, floating-point numbers, &lt;em&gt;etc&lt;/em&gt;. An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, will be a Python object whose type is the scalar type associated with the data type of the array.</source>
          <target state="translated">스칼라 데이터의 유형을 설명하기 위해 NumPy에는 다양한 정수, 부동 소수점 숫자 &lt;em&gt;등을&lt;/em&gt; 위한 &lt;a href=&quot;arrays.scalars#arrays-scalars-built-in&quot;&gt;내장 스칼라 유형&lt;/a&gt; 이 여러 개 있습니다. 배열에서 추출 된 항목 ( &lt;em&gt;예 :&lt;/em&gt; 인덱싱)은 유형이 배열의 데이터 유형과 연관된 스칼라 유형 인 Python 객체입니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="44e1fab9f28a4fa50d8975e0a1e46a2e64c1e9dc" translate="yes" xml:space="preserve">
          <source>To determine the type of an array, look at the dtype attribute:</source>
          <target state="translated">배열 유형을 확인하려면 dtype 속성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9f971fbdece5884152a2421faf1e4b6e44db96d0" translate="yes" xml:space="preserve">
          <source>To disable this behaviour and force NumPy to print the entire array, you can change the printing options using &lt;code&gt;set_printoptions&lt;/code&gt;.</source>
          <target state="translated">이 동작을 비활성화하고 NumPy가 전체 배열을 인쇄하도록 강제하려면 &lt;code&gt;set_printoptions&lt;/code&gt; 를 사용하여 인쇄 옵션을 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="42815d30b39c91ade5f76679c62182278601bee8" translate="yes" xml:space="preserve">
          <source>To do buffered reduction requires yet another adjustment during the setup. Normally the iterator construction involves copying the first buffer of data from the readable arrays into the buffer. Any reduction operand is readable, so it may be read into a buffer. Unfortunately, initialization of the operand after this buffering operation is complete will not be reflected in the buffer that the iteration starts with, and garbage results will be produced.</source>
          <target state="translated">버퍼링 감소를 수행하려면 설정 중에 또 다른 조정이 필요합니다. 일반적으로 반복자 구성은 읽을 수있는 배열의 첫 번째 데이터 버퍼를 버퍼로 복사하는 작업을 포함합니다. 모든 축소 피연산자를 읽을 수 있으므로 버퍼로 읽을 수 있습니다. 불행하게도,이 버퍼링 조작이 완료된 후 피연산자의 초기화는 반복이 시작되는 버퍼에 반영되지 않으며 가비지 결과가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="7bb73bf7d0560f6eb01b8f605dab2705b707dec2" translate="yes" xml:space="preserve">
          <source>To do this we need two files. The first is the C file which contains the actual code, and the second is the setup.py file used to create the module.</source>
          <target state="translated">이를 위해서는 두 개의 파일이 필요합니다. 첫 번째는 실제 코드가 포함 된 C 파일이고 두 번째는 모듈을 만드는 데 사용되는 setup.py 파일입니다.</target>
        </trans-unit>
        <trans-unit id="2a3fff7f3035206492b3a95d3cbf852432de0dee" translate="yes" xml:space="preserve">
          <source>To enable and control broadcasting, use an ellipsis. Default NumPy-style broadcasting is done by adding an ellipsis to the left of each term, like &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt;. To take the trace along the first and last axes, you can do &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt;, or to do a matrix-matrix product with the left-most indices instead of rightmost, one can do &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt;.</source>
          <target state="translated">방송을 활성화하고 제어하려면 줄임표를 사용하십시오. 기본 NumPy 스타일 방송은 &lt;code&gt;np.einsum('...ii-&amp;gt;...i', a)&lt;/code&gt; 와 같이 각 항의 왼쪽에 줄임표를 추가하여 수행됩니다 . 첫 번째 축과 마지막 축을 따라 추적하려면 &lt;code&gt;np.einsum('i...i', a)&lt;/code&gt; 을 수행하거나 가장 오른쪽 대신 가장 왼쪽에 인덱스가있는 행렬 행렬 곱을 수행하면됩니다. &lt;code&gt;np.einsum('ij...,jk...-&amp;gt;ik...', a, b)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73e17138c97818c1d4c0e646e333300b5a17a016" translate="yes" xml:space="preserve">
          <source>To enforce summaries when doing merges (&lt;code&gt;~/.gitconfig&lt;/code&gt; file again):</source>
          <target state="translated">병합을 수행 할 때 요약을 적용하려면 ( &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일 다시) :</target>
        </trans-unit>
        <trans-unit id="03b64a95ca31ed1440ed9609a8efdae966875477" translate="yes" xml:space="preserve">
          <source>To ensure all elements within an &lt;code&gt;object&lt;/code&gt; array are copied, use &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;object&lt;/code&gt; 배열 내의 모든 요소 가 복사 되도록하려면 &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7550453146cba531db73646e9c8ba39942085d8" translate="yes" xml:space="preserve">
          <source>To ensure that your code does not have to be compiled for a specific NumPy version, you may add a constant, leaving room for changes in NumPy. A solution guaranteed to be compatible with any future NumPy version requires the use of a runtime calculate offset and allocation size.</source>
          <target state="translated">특정 NumPy 버전에 대해 코드를 컴파일 할 필요가 없도록하기 위해 상수를 추가하여 NumPy에 변경 사항을 남길 수 있습니다. 향후 NumPy 버전과 호환이 보장되는 솔루션은 런타임 계산 오프셋 및 할당 크기를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="56d44cf88fb39b36da11cf8bbe02f976134b23c7" translate="yes" xml:space="preserve">
          <source>To facilitate easy matching of array shapes with expressions and in assignments, the np.newaxis object can be used within array indices to add new dimensions with a size of 1. For example:</source>
          <target state="translated">표현식 및 할당에서 배열 모양을 쉽게 일치시키기 위해 배열 인덱스 내에서 np.newaxis 객체를 사용하여 크기가 1 인 새 차원을 추가 할 수 있습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="09fc0ca575462761f878d637a2fecf46e1ccd71c" translate="yes" xml:space="preserve">
          <source>To facilitate this many similar unit tests, some high-level programming techniques are employed, including C and &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macros, as well as Python inheritance. The purpose of this document is to describe the testing infrastructure employed to verify that the &lt;code&gt;numpy.i&lt;/code&gt; typemaps are working as expected.</source>
          <target state="translated">이와 같이 많은 유사한 단위 테스트를 용이하게하기 위해 C 및 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 매크로와 Python 상속을 포함한 일부 고급 프로그래밍 기술이 사용 됩니다. 이 문서의 목적은 &lt;code&gt;numpy.i&lt;/code&gt; 타입 맵이 예상대로 작동 하는지 확인하는 데 사용되는 테스트 인프라를 설명하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="df1248d3a4c3c276bf78a49ecea34ca2333414db" translate="yes" xml:space="preserve">
          <source>To find how many valid days there are in a specified range of datetime64 dates, use &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt;&lt;code&gt;busday_count&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">지정된 datetime64 날짜 범위에 유효한 일 수를 찾으려면 &lt;a href=&quot;generated/numpy.busday_count#numpy.busday_count&quot;&gt; &lt;code&gt;busday_count&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="319db282e290412afdbf4c23744ae53a90ac551e" translate="yes" xml:space="preserve">
          <source>To find the number of dimensions of the array, run:</source>
          <target state="translated">배열의 차원 수를 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="f3533d0798888b92292cdc274cd5cbd4e7bdef89" translate="yes" xml:space="preserve">
          <source>To find the total number of elements in the array, run:</source>
          <target state="translated">배열의 총 요소 수를 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="381cf7b173efa6d304977d6f48b6eab1589b8ebf" translate="yes" xml:space="preserve">
          <source>To find the union of more than two arrays, use functools.reduce:</source>
          <target state="translated">두 개 이상의 배열의 합집합을 찾으려면 functools.reduce를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f20ef83823da30eba7178dbce314c99b1ef83b27" translate="yes" xml:space="preserve">
          <source>To get a feel for writing custom array containers, we&amp;rsquo;ll begin with a simple example that has rather narrow utility but illustrates the concepts involved.</source>
          <target state="translated">사용자 지정 배열 컨테이너를 작성하는 방법을 알아보기 위해 유틸리티가 다소 좁지 만 관련된 개념을 보여주는 간단한 예제로 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="e3a3751da83fe0d7f7a6c4230ed886f73729cca0" translate="yes" xml:space="preserve">
          <source>To get back to a plain ndarray both the dtype and type must be reset. The following view does so, taking into account the unusual case that the recordarr was not a structured type:</source>
          <target state="translated">일반 ndarray로 돌아가려면 dtype과 type을 모두 재설정해야합니다. 다음보기는 recordarr가 구조화 된 유형이 아닌 비정상적인 경우를 고려하여 그렇게합니다.</target>
        </trans-unit>
        <trans-unit id="4469a3b55f422122d26688e1424f485904a4794e" translate="yes" xml:space="preserve">
          <source>To get the indices of unique values in a NumPy array (an array of first index positions of unique values in the array), just pass the &lt;code&gt;return_index&lt;/code&gt; argument in &lt;code&gt;np.unique()&lt;/code&gt; as well as your array.</source>
          <target state="translated">NumPy 배열 (배열에서 고유 한 값의 첫 번째 인덱스 위치 배열)에서 고유 값의 인덱스 를 &lt;code&gt;np.unique()&lt;/code&gt; 려면 배열뿐 아니라 np.unique () 에 return_index 인수를 전달하기 &lt;code&gt;return_index&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="f05508b4b1612d928370bd8d22c78ce6740d7d75" translate="yes" xml:space="preserve">
          <source>To get the necessary information for the npymath library from NumPy:</source>
          <target state="translated">NumPy에서 npymath 라이브러리에 필요한 정보를 얻으려면 :</target>
        </trans-unit>
        <trans-unit id="6b92fc58e63db5aa668493a43f6017a9433c467a" translate="yes" xml:space="preserve">
          <source>To get the unique rows, index position, and occurrence count, you can use:</source>
          <target state="translated">고유 행, 인덱스 위치 및 발생 횟수를 가져 오려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8cb65420b2ca2983f196bbc9804b56531579abff" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt;&lt;code&gt;argwhere&lt;/code&gt;&lt;/a&gt;, which returns a row for each non-zero element.</source>
          <target state="translated">차원이 아닌 요소별로 색인을 그룹화하려면 0이 아닌 각 요소에 대한 행을 리턴하는 &lt;a href=&quot;numpy.argwhere#numpy.argwhere&quot;&gt; &lt;code&gt;argwhere&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd77da9e3cc0e1b206296360b148e66d7e5bf3e1" translate="yes" xml:space="preserve">
          <source>To group the indices by element, rather than dimension, use instead:</source>
          <target state="translated">차원이 아닌 요소별로 색인을 그룹화하려면 대신 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ee4cd0adbfaa4d4a1d76673c36c93886ead4c8dd" translate="yes" xml:space="preserve">
          <source>To have a particular script file executed when the interactive Python interpreter is started, define the &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; environment variable to contain the name of your startup script.</source>
          <target state="translated">대화 형 Python 인터프리터가 시작될 때 특정 스크립트 파일을 실행하려면 시작 스크립트의 이름을 포함하도록 &lt;code&gt;PYTHONSTARTUP&lt;/code&gt; 환경 변수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="01fa3621bdaf741ed6a071c7af18f6f77c074d16" translate="yes" xml:space="preserve">
          <source>To implement the second method, NumPy provides the class-factory function &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; in the &lt;a href=&quot;../reference/routines.ctypeslib#module-numpy.ctypeslib&quot;&gt;&lt;code&gt;numpy.ctypeslib&lt;/code&gt;&lt;/a&gt; module. This class-factory function produces an appropriate class that can be placed in an argtypes attribute entry of a ctypes function. The class will contain a from_param method which ctypes will use to convert any ndarray passed in to the function to a ctypes-recognized object. In the process, the conversion will perform checking on any properties of the ndarray that were specified by the user in the call to &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt;. Aspects of the ndarray that can be checked include the data-type, the number-of-dimensions, the shape, and/or the state of the flags on any array passed. The return value of the from_param method is the ctypes attribute of the array which (because it contains the &lt;code&gt;_as_parameter_&lt;/code&gt; attribute pointing to the array data area) can be used by ctypes directly.</source>
          <target state="translated">두 번째 방법을 구현하기 위해 NumPy는 &lt;a href=&quot;../reference/routines.ctypeslib#module-numpy.ctypeslib&quot;&gt; &lt;code&gt;numpy.ctypeslib&lt;/code&gt; &lt;/a&gt; 모듈 에서 클래스 팩토리 함수 &lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt; 를 제공합니다 . 이 클래스 팩토리 함수는 ctypes 함수의 argtypes 속성 항목에 배치 할 수있는 적절한 클래스를 생성합니다. 이 클래스에는 ctypes가 함수에 전달 된 ndarray를 ctypes 인식 객체로 변환하는 데 사용할 from_param 메서드가 포함됩니다. 이 과정에서, 전환은 호출의 사용자에 의해 특정 된 임의 ndarray 속성 검사를 수행 &lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt;. 확인할 수있는 ndarray의 측면에는 전달 된 배열의 데이터 유형, 차원 수, 모양 및 / 또는 플래그 상태가 포함됩니다. from_param 메소드의 반환 값은 ( 배열 데이터 영역을 가리키는 &lt;code&gt;_as_parameter_&lt;/code&gt; 속성을 포함하고 있기 때문에 ) ctypes에서 직접 사용할 수있는 배열 의 ctypes 속성입니다 .</target>
        </trans-unit>
        <trans-unit id="50d801e69012a04f7e0e0473d58cee9ab38e87fd" translate="yes" xml:space="preserve">
          <source>To install NumPy, run:</source>
          <target state="translated">NumPy를 설치하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="bd5ace9a611ff0639bf97923787f31ff3babad6c" translate="yes" xml:space="preserve">
          <source>To install NumPy, we strongly recommend using a scientific Python distribution. If you&amp;rsquo;re looking for the full instructions for installing NumPy on your operating system, you can &lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;find all of the details here&lt;/a&gt;.</source>
          <target state="translated">NumPy를 설치하려면 과학적 Python 배포판을 사용하는 것이 좋습니다. 운영 체제에 NumPy를 설치하기위한 전체 지침을 찾고 있다면 &lt;a href=&quot;https://www.scipy.org/install.html&quot;&gt;여기에서 모든 세부 정보를 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ceadcdbd2ecba0b0b71d04b040d27f4a8978392" translate="yes" xml:space="preserve">
          <source>To intersect more than two arrays, use functools.reduce:</source>
          <target state="translated">둘 이상의 배열을 교차 시키려면 functools.reduce를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="1eeff99dc3325ea11208d15f34bf3ae08056f134" translate="yes" xml:space="preserve">
          <source>To keep in sync with changes in NumPy, you want to set up your repository so it pulls from &lt;code&gt;upstream&lt;/code&gt; by default. This can be done with:</source>
          <target state="translated">NumPy의 변경 사항과 동기화를 유지하려면 기본적으로 &lt;code&gt;upstream&lt;/code&gt; 에서 가져 오도록 리포지토리를 설정하려고합니다 . 이것은 다음으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="422eea08f184929b902e9a6c5257e9028826306a" translate="yes" xml:space="preserve">
          <source>To learn more about finding the unique elements in an array, see &lt;a href=&quot;../reference/generated/numpy.unique#numpy.unique&quot;&gt;&lt;code&gt;unique&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열에서 고유 한 요소를 찾는 방법에 대한 자세한 내용은 &lt;a href=&quot;../reference/generated/numpy.unique#numpy.unique&quot;&gt; &lt;code&gt;unique&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f5278c1b18ea2b8e10ed17f38664074c6889df4" translate="yes" xml:space="preserve">
          <source>To learn more about transposing and reshaping arrays, see &lt;a href=&quot;../reference/generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열을 전치하고 재편에 대한 자세한 내용은 다음 페이지를 참조 &lt;a href=&quot;../reference/generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68755700558e4129caf4a1646cfbb8316cee0dd6" translate="yes" xml:space="preserve">
          <source>To make an iterator similar to the old iterator, this should work.</source>
          <target state="translated">반복자를 이전 반복기와 비슷하게 만들려면 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="36529c6f3589cad07eabf913ffb155048ea1dac5" translate="yes" xml:space="preserve">
          <source>To make it concrete, we can pick the operation to be the array-reversal function &lt;a href=&quot;reference/generated/numpy.flip#numpy.flip&quot;&gt;&lt;code&gt;numpy.flip&lt;/code&gt;&lt;/a&gt;, which accepts an &lt;code&gt;axis&lt;/code&gt; argument. We construct a 3 x 4 array &lt;code&gt;a&lt;/code&gt;:</source>
          <target state="translated">이 콘크리트를 만들기 위해, 우리는 배열 반전 기능으로 작업을 선택할 수 있습니다 &lt;a href=&quot;reference/generated/numpy.flip#numpy.flip&quot;&gt; &lt;code&gt;numpy.flip&lt;/code&gt; &lt;/a&gt; 받아, &lt;code&gt;axis&lt;/code&gt; 인수를. 3 x 4 배열 &lt;code&gt;a&lt;/code&gt; 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="6d696015c14a0cbcd57511007788b5810594a8d0" translate="yes" xml:space="preserve">
          <source>To make its properties more readily accessible during iteration, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; has an alternative syntax for iterating, which works explicitly with the iterator object itself. With this looping construct, the current value is accessible by indexing into the iterator. Other properties, such as tracked indices remain as before. The examples below produce identical results to the ones in the previous section.</source>
          <target state="translated">반복하는 동안 속성에 더 쉽게 액세스 할 수 있도록 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 에는 반복기 객체 자체와 함께 명시 적으로 작동하는 반복을위한 대체 구문이 있습니다. 이 루핑 구조를 사용하면 반복자로 인덱싱하여 현재 값에 액세스 할 수 있습니다. 추적 된 인덱스와 같은 다른 속성은 이전과 동일하게 유지됩니다. 아래 예제는 이전 섹션의 결과와 동일한 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="dcb62bb890eb45640b1d129077fff1a1982947c5" translate="yes" xml:space="preserve">
          <source>To make the necessary build options available to third parties, you could use the &lt;code&gt;npy-pkg-config&lt;/code&gt; mechanism implemented in &lt;a href=&quot;#module-numpy.distutils&quot;&gt;&lt;code&gt;numpy.distutils&lt;/code&gt;&lt;/a&gt;. This mechanism is based on a .ini file which contains all the options. A .ini file is very similar to .pc files as used by the pkg-config unix utility:</source>
          <target state="translated">필요한 빌드 옵션을 타사에서 사용할 수 있도록 &lt;code&gt;npy-pkg-config&lt;/code&gt; 구현 된 &lt;a href=&quot;#module-numpy.distutils&quot;&gt; &lt;code&gt;numpy.distutils&lt;/code&gt; &lt;/a&gt; -pkg-config 메커니즘을 사용할 수 있습니다 . 이 메커니즘은 모든 옵션이 포함 된 .ini 파일을 기반으로합니다. .ini 파일은 pkg-config unix 유틸리티에서 사용되는 .pc 파일과 매우 유사합니다.</target>
        </trans-unit>
        <trans-unit id="33556655b7ed4636c5875606d6d2c0f4cbb51bbb" translate="yes" xml:space="preserve">
          <source>To make your key more readily identifiable as you, consider sending your key to public keyservers, with a command such as:</source>
          <target state="translated">키를 더 쉽게 식별 할 수 있도록하려면 다음과 같은 명령을 사용하여 키를 공개 키 서버로 보내는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="18c1e38c6bb6394f66a0d335e612f3011262ff50" translate="yes" xml:space="preserve">
          <source>To measure the test coverage, install &lt;a href=&quot;https://pytest-cov.readthedocs.io/en/latest/&quot;&gt;pytest-cov&lt;/a&gt; and then run:</source>
          <target state="translated">테스트 범위를 측정하려면 &lt;a href=&quot;https://pytest-cov.readthedocs.io/en/latest/&quot;&gt;pytest-cov를&lt;/a&gt; 설치 한 후 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="6239277562da98f7f93ad4e57c8a93f41fe39464" translate="yes" xml:space="preserve">
          <source>To modify your Python search path to include the locations of your own modules, define the &lt;code&gt;PYTHONPATH&lt;/code&gt; environment variable.</source>
          <target state="translated">자체 모듈의 위치를 ​​포함하도록 Python 검색 경로를 수정하려면 &lt;code&gt;PYTHONPATH&lt;/code&gt; 환경 변수를 정의하십시오 .</target>
        </trans-unit>
        <trans-unit id="8d1963ae310b977b5fdaf7c01ceaf03485096cb4" translate="yes" xml:space="preserve">
          <source>To override the automatic detection of available memory, set the environment variable &lt;code&gt;NPY_AVAILABLE_MEM&lt;/code&gt;, for example &lt;code&gt;NPY_AVAILABLE_MEM=32GB&lt;/code&gt;, or using pytest &lt;code&gt;--available-memory=32GB&lt;/code&gt; target option.</source>
          <target state="translated">사용 가능한 메모리의 자동 감지를 재정의하려면 환경 변수 &lt;code&gt;NPY_AVAILABLE_MEM&lt;/code&gt; 을 설정합니다 ( 예 : &lt;code&gt;NPY_AVAILABLE_MEM=32GB&lt;/code&gt; ) 또는 pytest &lt;code&gt;--available-memory=32GB&lt;/code&gt; 대상 옵션을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="d1c61949e0ad3dc492f05ebb9e5438319174c320" translate="yes" xml:space="preserve">
          <source>To perform an in-place build that can be run from the source folder run:</source>
          <target state="translated">소스 폴더에서 실행할 수있는 인플레 이스 빌드를 수행하려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c334cf8d4bed58e0564b6be3f28b72afdf600e2c" translate="yes" xml:space="preserve">
          <source>To proceed, import the linear algebra submodule from NumPy:</source>
          <target state="translated">계속하려면 NumPy에서 선형 대수 하위 모듈을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="02d722ee9de32d295a3f1aa488c332a62e29240a" translate="yes" xml:space="preserve">
          <source>To put back the default options, you can use:</source>
          <target state="translated">기본 옵션을 되돌리려면 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4f4e1d38162c68bbafa8964bc64bfa72b23866db" translate="yes" xml:space="preserve">
          <source>To read more about Matplotlib and what it can do, take a look at &lt;a href=&quot;https://matplotlib.org/&quot;&gt;the official documentation&lt;/a&gt;. For directions regarding installing Matplotlib, see the official &lt;a href=&quot;https://matplotlib.org/users/installing.html&quot;&gt;installation section&lt;/a&gt;.</source>
          <target state="translated">Matplotlib 및 그 기능에 대해 자세히 알아 보려면 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;공식 문서를 참조하십시오&lt;/a&gt; . Matplotlib 설치에 대한 지침은 공식 &lt;a href=&quot;https://matplotlib.org/users/installing.html&quot;&gt;설치 섹션을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="98026c8318a10abcb126d49806744b4ae23d3123" translate="yes" xml:space="preserve">
          <source>To read more about concatenate, see: &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">CONCATENATE에 대해 자세히 알아 보려면 다음을 참조하십시오 &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="425cb75a01c3201b08612ec800f1a7971e0378d1" translate="yes" xml:space="preserve">
          <source>To read more about sorting an array, see: &lt;a href=&quot;../reference/generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열을 정렬에 대한 자세한 읽으려면, 참조 : &lt;a href=&quot;../reference/generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33f422775354a46e3c9c41ff160bfb3c38d25920" translate="yes" xml:space="preserve">
          <source>To reduce the chance of misinterpretation, even though the following &amp;ldquo;abuse&amp;rdquo; is nominally supported, &lt;code&gt;choices&lt;/code&gt; should neither be, nor be thought of as, a single array, i.e., the outermost sequence-like container should be either a list or a tuple.</source>
          <target state="translated">오해의 가능성을 줄이려면 다음과 같은 &quot;남용&quot;이 명목상 지원 되더라도 &lt;code&gt;choices&lt;/code&gt; 은 단일 배열, 즉 가장 바깥 쪽의 시퀀스 형 컨테이너가 목록 또는 튜플이어야한다고 생각해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="69f7fdf215ee6723757c121f1000e16153523a1d" translate="yes" xml:space="preserve">
          <source>To retrieve only the valid entries, we can use the inverse of the mask as an index. The inverse of the mask can be calculated with the &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt;&lt;code&gt;numpy.logical_not&lt;/code&gt;&lt;/a&gt; function or simply with the &lt;code&gt;~&lt;/code&gt; operator:</source>
          <target state="translated">유효한 항목 만 검색하기 위해 마스크의 역을 인덱스로 사용할 수 있습니다. 마스크의 역은 &lt;a href=&quot;generated/numpy.logical_not#numpy.logical_not&quot;&gt; &lt;code&gt;numpy.logical_not&lt;/code&gt; &lt;/a&gt; 함수 또는 &lt;code&gt;~&lt;/code&gt; 연산자 를 사용하여 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e546770d4089912cdd192abaecf0b1e29a9e2943" translate="yes" xml:space="preserve">
          <source>To return the indices of the values common to the input arrays along with the intersected values:</source>
          <target state="translated">교차 된 값과 함께 입력 배열에 공통적 인 값의 인덱스를 반환하려면</target>
        </trans-unit>
        <trans-unit id="67e6eaca69e6f48eb1845e3b15fc19b5fce3851f" translate="yes" xml:space="preserve">
          <source>To run SciPy&amp;rsquo;s full test suite, use the following:</source>
          <target state="translated">SciPy의 전체 테스트 스위트를 실행하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="402853161da9a462a3784d2121c2566aac78b1d2" translate="yes" xml:space="preserve">
          <source>To run a benchmark defined in a class, such as &lt;code&gt;Mandelbrot&lt;/code&gt; from &lt;code&gt;bench_avx.py&lt;/code&gt;:</source>
          <target state="translated">같은 클래스에 정의 된 벤치 마크를 실행하려면 &lt;code&gt;Mandelbrot&lt;/code&gt; 에서 &lt;code&gt;bench_avx.py&lt;/code&gt; 를 :</target>
        </trans-unit>
        <trans-unit id="3862a782eb6529a8c99b98cef4c13299f47f23c0" translate="yes" xml:space="preserve">
          <source>To run all benchmarks, navigate to the root NumPy directory at the command line and execute:</source>
          <target state="translated">모든 벤치 마크를 실행하려면 명령 줄에서 루트 NumPy 디렉터리로 이동하여 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="12365d76682fb967acae76310ae656f9290fed8d" translate="yes" xml:space="preserve">
          <source>To run benchmarks from a particular benchmark module, such as &lt;code&gt;bench_core.py&lt;/code&gt;, simply append the filename without the extension:</source>
          <target state="translated">특정 벤치 마크 모듈 (예 : &lt;code&gt;bench_core.py&lt;/code&gt; ) 에서 벤치 마크를 실행하려면 확장자없이 파일 이름을 추가하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9661928d3b7e0b0f53e4248625106d96b260f714" translate="yes" xml:space="preserve">
          <source>To sample from N evenly spaced floating-point numbers between a and b, use:</source>
          <target state="translated">a와 b 사이에 N 개의 균일 한 간격의 부동 소수점 숫자를 샘플링하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="cd520022e6b8a6d4a06e76bb94b1b7fee07bd6cf" translate="yes" xml:space="preserve">
          <source>To scan Fortran sources and generate a signature file, use</source>
          <target state="translated">Fortran 소스를 스캔하고 서명 파일을 생성하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="67f8780eccc675b04bcebf369f6ed02655b97ea2" translate="yes" xml:space="preserve">
          <source>To see a graphical representation of the repository branches and commits:</source>
          <target state="translated">저장소 브랜치 및 커밋의 그래픽 표현을 보려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="39780ed9cf55125c359d05489224449255a114a4" translate="yes" xml:space="preserve">
          <source>To see a linear list of commits for this branch:</source>
          <target state="translated">이 분기에 대한 커밋의 선형 목록을 보려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="8b637e484b0579f8dde3e86fc54af28832dba4d1" translate="yes" xml:space="preserve">
          <source>To see how striding underlies the power of NumPy views, see &lt;a href=&quot;https://arxiv.org/pdf/1102.1523.pdf&quot;&gt;The NumPy array: a structure for efficient numerical computation. &lt;/a&gt;</source>
          <target state="translated">striding이 NumPy보기의 힘의 기초가되는 방법을 보려면 &lt;a href=&quot;https://arxiv.org/pdf/1102.1523.pdf&quot;&gt;NumPy 배열 : 효율적인 수치 계산을위한 구조를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="79f07a6533e986fa44fe540266db879b8c346cb7" translate="yes" xml:space="preserve">
          <source>To see if an approximation is reasonable, we can check the values in &lt;code&gt;s&lt;/code&gt;:</source>
          <target state="translated">근사가 합리적인지 확인하기 위해 &lt;code&gt;s&lt;/code&gt; 의 값을 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc4aaad8d81152b0e7e6f7703b5cec989fcf2cef" translate="yes" xml:space="preserve">
          <source>To see if this makes sense in our image, we should use a colormap from &lt;code&gt;matplotlib&lt;/code&gt; corresponding to the color we wish to see in out image (otherwise, &lt;code&gt;matplotlib&lt;/code&gt; will default to a colormap that does not correspond to the real data).</source>
          <target state="translated">이것이 이미지에서 의미가 있는지 확인하려면 이미지에서보고자하는 색상에 해당하는 &lt;code&gt;matplotlib&lt;/code&gt; 의 컬러 맵을 사용해야합니다 (그렇지 않으면 &lt;code&gt;matplotlib&lt;/code&gt; 는 기본적으로 실제 데이터와 일치하지 않는 컬러 맵으로 설정됩니다).</target>
        </trans-unit>
        <trans-unit id="c11e108b211eeb3196e6c957c1a55cfbb8da63bc" translate="yes" xml:space="preserve">
          <source>To see the documentation for a specific ufunc, use &lt;a href=&quot;numpy.info#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt;. For example, &lt;code&gt;np.info(np.sin)&lt;/code&gt;. Because ufuncs are written in C (for speed) and linked into Python with NumPy&amp;rsquo;s ufunc facility, Python&amp;rsquo;s help() function finds this page whenever help() is called on a ufunc.</source>
          <target state="translated">특정 ufunc에 대한 문서를 보려면 &lt;a href=&quot;numpy.info#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 . 예 : &lt;code&gt;np.info(np.sin)&lt;/code&gt; . ufuncs는 C (속도를 위해)로 작성되고 NumPy의 ufunc 기능을 사용하여 Python에 연결되기 때문에 Python의 help () 함수는 ufunc에서 help ()가 호출 될 때마다이 페이지를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="74691658cd7769d44a45cda5e12dd3bc908a227e" translate="yes" xml:space="preserve">
          <source>To see whether F2PY generated interface performs copies of array arguments, use &lt;code&gt;-DF2PY_REPORT_ON_ARRAY_COPY=&amp;lt;int&amp;gt;&lt;/code&gt;. When the size of an array argument is larger than &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt;, a message about the coping is sent to &lt;code&gt;stderr&lt;/code&gt;.</source>
          <target state="translated">F2PY 생성 인터페이스가 배열 인수의 복사를 수행하는지 확인하려면 &lt;code&gt;-DF2PY_REPORT_ON_ARRAY_COPY=&amp;lt;int&amp;gt;&lt;/code&gt; 를 사용하십시오 . 배열 인수의 크기가 &lt;code&gt;&amp;lt;int&amp;gt;&lt;/code&gt; 보다 크면 대응에 대한 메시지가 &lt;code&gt;stderr&lt;/code&gt; 로 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="1ed1275cdacf759ff47d03a08e3787f0594bb1bb" translate="yes" xml:space="preserve">
          <source>To set up on another computer, you can copy your &lt;code&gt;~/.gitconfig&lt;/code&gt; file, or run the commands above.</source>
          <target state="translated">다른 컴퓨터에서 설정하려면 &lt;code&gt;~/.gitconfig&lt;/code&gt; 파일을 복사 하거나 위의 명령을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e4d00e748aea08f0006873ab29acb7a55ab4663b" translate="yes" xml:space="preserve">
          <source>To shuffle the rows of &lt;code&gt;x&lt;/code&gt; in-place, pass &lt;code&gt;x&lt;/code&gt; as the &lt;code&gt;out&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 행을 제자리에서 섞으려면 &lt;code&gt;x&lt;/code&gt; 를 &lt;code&gt;out&lt;/code&gt; 매개 변수 로 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4d884174d72a1ce55f9ee4b7d870c154a7a32b7" translate="yes" xml:space="preserve">
          <source>To skip a test, simply use &lt;code&gt;skipif&lt;/code&gt;:</source>
          <target state="translated">테스트를 건너 뛰려면 &lt;code&gt;skipif&lt;/code&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="3dc6e4230f5944b1098c8c2df7bd61f24c145894" translate="yes" xml:space="preserve">
          <source>To submit your contribution:</source>
          <target state="translated">기여를 제출하려면 :</target>
        </trans-unit>
        <trans-unit id="ceffd750378d21341a7019937d0c789148b4f90a" translate="yes" xml:space="preserve">
          <source>To support it, we need to define the Python interfaces &lt;code&gt;__add__&lt;/code&gt;, &lt;code&gt;__lt__&lt;/code&gt;, and so on to dispatch to the corresponding ufunc. We can achieve this conveniently by inheriting from the mixin &lt;a href=&quot;../reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이를 지원하려면 해당 ufunc에 디스패치하도록 Python 인터페이스 &lt;code&gt;__add__&lt;/code&gt; , &lt;code&gt;__lt__&lt;/code&gt; 등 을 정의해야합니다 . 믹스 인 &lt;a href=&quot;../reference/generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt; 을 상속하여 편리하게이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="673335eebf9011c1628160cca5d99d26576f081d" translate="yes" xml:space="preserve">
          <source>To take the running sum of four successive values:</source>
          <target state="translated">네 개의 연속 값의 누계를 계산하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="54587f602166cab38648eb3409cd921150aa4e7e" translate="yes" xml:space="preserve">
          <source>To test a datetime64 value to see if it is a valid day, use &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt;&lt;code&gt;is_busday&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">datetime64 값을 테스트하여 유효한 날짜인지 확인하려면 &lt;a href=&quot;generated/numpy.is_busday#numpy.is_busday&quot;&gt; &lt;code&gt;is_busday&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="054b90fbdf163bc568eceff518fb7e05620b88d4" translate="yes" xml:space="preserve">
          <source>To test the performance of F2PY generated interfaces, use &lt;code&gt;-DF2PY_REPORT_ATEXIT&lt;/code&gt;. Then a report of various timings is printed out at the exit of Python. This feature may not work on all platforms, currently only Linux platform is supported.</source>
          <target state="translated">F2PY 생성 인터페이스의 성능을 테스트하려면 -DF2PY_REPORT_ATEXIT를 사용 &lt;code&gt;-DF2PY_REPORT_ATEXIT&lt;/code&gt; . 그런 다음 Python이 종료 될 때 다양한 타이밍에 대한 보고서가 인쇄됩니다. 이 기능은 모든 플랫폼에서 작동하지 않을 수 있으며 현재 Linux 플랫폼 만 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="01b5e9d9370a428c2b83ae13e33fb71722d9bb4f" translate="yes" xml:space="preserve">
          <source>To test whether an array is C-contiguous, use the &lt;code&gt;.flags.c_contiguous&lt;/code&gt; attribute of NumPy arrays. To test for Fortran contiguity, use the &lt;code&gt;.flags.f_contiguous&lt;/code&gt; attribute.</source>
          <target state="translated">배열이 C 연속인지 테스트하려면 NumPy 배열 의 &lt;code&gt;.flags.c_contiguous&lt;/code&gt; 속성을 사용하십시오 . Fortran 연속성을 테스트하려면 &lt;code&gt;.flags.f_contiguous&lt;/code&gt; 속성을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="8ab2b1e95b971bb4c5c35b359a5634bf815d8fa6" translate="yes" xml:space="preserve">
          <source>To the extent possible under law, the authors have waived all copyright and related or neighboring rights to the NumPy project governance and decision-making document, as per the &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC-0 public domain dedication / license&lt;/a&gt;.</source>
          <target state="translated">법률에 따라 가능한 한, 저자는 &lt;a href=&quot;https://creativecommons.org/publicdomain/zero/1.0/&quot;&gt;CC-0 공개 도메인 전용 / 라이센스&lt;/a&gt; 에 따라 NumPy 프로젝트 거버넌스 및 의사 결정 문서에 대한 모든 저작권 및 관련 또는 이웃 권리를 포기했습니다 .</target>
        </trans-unit>
        <trans-unit id="4b06b82cac8a278e2d618ab82ddb18a2d508ecee" translate="yes" xml:space="preserve">
          <source>To the maximum extent possible, Council discussions and activities will be public and done in collaboration and discussion with the Project Contributors and Community. The Council will have a private mailing list that will be used sparingly and only when a specific matter requires privacy. When private communications and decisions are needed, the Council will do its best to summarize those to the Community after eliding personal/private/sensitive information that should not be posted to the public internet.</source>
          <target state="translated">가능한 한 최대한 협의회 토론 및 활동이 공개되고 프로젝트 기여자 및 커뮤니티와의 협력 및 토론을 통해 이루어집니다. 시의회는 특정 사안이 프라이버시를 필요로하는 경우에만 드물게 사용되는 개인 메일 링리스트를 보유 할 것입니다. 사적인 커뮤니케이션과 결정이 필요한 경우,위원회는 공개 인터넷에 게시해서는 안되는 개인 / 사적 / 민감한 정보를 제거한 후이를 커뮤니티에 요약하기 위해 최선을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="3cb8696297023077cd0b0457359ff13c01cdb0ce" translate="yes" xml:space="preserve">
          <source>To transform input arrays to column major storage order before passing them to Fortran routines, use the function &lt;code&gt;numpy.asfortranarray(&amp;lt;array&amp;gt;)&lt;/code&gt;.</source>
          <target state="translated">입력 배열을 Fortran 루틴에 전달하기 전에 열 주요 저장 순서로 변환하려면 &lt;code&gt;numpy.asfortranarray(&amp;lt;array&amp;gt;)&lt;/code&gt; 함수를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="ecbd73988a92874f75c5ca6f8256cc9806ceef6d" translate="yes" xml:space="preserve">
          <source>To unmask all masked entries of a masked array (provided the mask isn&amp;rsquo;t a hard mask), the simplest solution is to assign the constant &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; to the mask:</source>
          <target state="translated">마스크 된 배열의 마스크 된 항목을 모두 마스크 해제하려면 (마스크가 하드 마스크가 아닌 경우) 가장 간단한 해결 방법은 상수 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 를 마스크 에 지정하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="573c20b6a49882f7eb74a61c9d6cc94e9816cad4" translate="yes" xml:space="preserve">
          <source>To unmask one or several specific entries, we can just assign one or several new valid values to them:</source>
          <target state="translated">하나 또는 여러 개의 특정 항목을 마스크 해제하려면 하나 또는 여러 개의 새 유효한 값을 지정하면됩니다.</target>
        </trans-unit>
        <trans-unit id="9a8a0e07a3236c692c34f1277c4ab67311d7e811" translate="yes" xml:space="preserve">
          <source>To update your PR, make your changes on your local repository, commit, &lt;strong&gt;run tests, and only if they succeed&lt;/strong&gt; push to your fork. As soon as those changes are pushed up (to the same branch as before) the PR will update automatically. If you have no idea how to fix the test failures, you may push your changes anyway and ask for help in a PR comment.</source>
          <target state="translated">PR을 업데이트하려면 로컬 리포지토리에서 변경하고 커밋하고 &lt;strong&gt;테스트를 실행 한 다음 성공한 경우에만&lt;/strong&gt; 포크로 푸시합니다. 이러한 변경 사항이 이전과 동일한 분기로 푸시되는 즉시 PR이 자동으로 업데이트됩니다. 테스트 실패를 수정하는 방법을 모르는 경우 변경 사항을 푸시하고 PR 의견으로 도움을 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="334270275fd281b533f438d90c3f3ba9ca0332d2" translate="yes" xml:space="preserve">
          <source>To use ctypes you must</source>
          <target state="translated">ctypes를 사용하려면 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="678a8d94c4368f39ac59f5979ae212033bfc0aa2" translate="yes" xml:space="preserve">
          <source>To use the NPY_NO_DEPRECATED_API mechanism, you need to #define it to the target API version of NumPy before #including any NumPy headers. If you want to confirm that your code is clean against 1.7, use:</source>
          <target state="translated">NPY_NO_DEPRECATED_API 메커니즘을 사용하려면 #NumPy 헤더를 포함하기 전에 #NumPy의 대상 API 버전으로 # 정의해야합니다. 1.7에 대해 코드가 깨끗하다는 것을 확인하려면 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a6632c1bd45113f2d4d1587bfeed07e24b0355a1" translate="yes" xml:space="preserve">
          <source>To use the core math library in your own extension, you need to add the npymath compile and link options to your extension in your setup.py:</source>
          <target state="translated">자체 확장에서 핵심 수학 라이브러리를 사용하려면 setup.py에서 npymath 컴파일 및 링크 옵션을 확장에 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="b2026079012933359e4262f13af10283bf7286e8" translate="yes" xml:space="preserve">
          <source>To use the default &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; bit generator, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">기본 &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 비트 생성기 를 사용하려면 직접 인스턴스화하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 에&lt;/a&gt; 전달할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b22691af04491d10741332ecd435870cd225e63a" translate="yes" xml:space="preserve">
          <source>To use the deprecated &lt;code&gt;matrix&lt;/code&gt; and other &lt;code&gt;matlib&lt;/code&gt; functions:</source>
          <target state="translated">더 이상 사용되지 않는 &lt;code&gt;matrix&lt;/code&gt; 및 기타 &lt;code&gt;matlib&lt;/code&gt; 함수 를 사용하려면 :</target>
        </trans-unit>
        <trans-unit id="500206efd24c09b049a15922610b46ea489a6382" translate="yes" xml:space="preserve">
          <source>To use the setup.py file, place setup.py and spammodule.c in the same folder. Then python setup.py build will build the module to import, or setup.py install will install the module to your site-packages directory.</source>
          <target state="translated">setup.py 파일을 사용하려면 setup.py와 spammodule.c를 같은 폴더에 넣으십시오. 그런 다음 python setup.py 빌드가 가져올 모듈을 빌드하거나 setup.py 설치가 사이트 패키지 디렉토리에 모듈을 설치합니다.</target>
        </trans-unit>
        <trans-unit id="a62551f1b73595ab5f0441644c3e3f73182c8a6d" translate="yes" xml:space="preserve">
          <source>To work the examples, you&amp;rsquo;ll need &lt;code&gt;matplotlib&lt;/code&gt; installed in addition to NumPy.</source>
          <target state="translated">예제를 실행하려면 NumPy 외에도 &lt;code&gt;matplotlib&lt;/code&gt; 가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="9b09eedfc76bdeeb31bc979256f245ac870f03de" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place.</source>
          <target state="translated">선택적으로 제자리에 교체 된 바이트 단위 배열을 반환하여 저 엔디안 데이터와 빅 엔디안 데이터 표현간에 전환합니다.</target>
        </trans-unit>
        <trans-unit id="7ff4f3dd9acfe46112f7adc4d9246b8e34598f79" translate="yes" xml:space="preserve">
          <source>Toggle between low-endian and big-endian data representation by returning a byteswapped array, optionally swapped in-place. Arrays of byte-strings are not swapped. The real and imaginary parts of a complex number are swapped individually.</source>
          <target state="translated">선택적으로 제자리에서 스왑 된 바이트 스왑 배열을 반환하여 로우 엔디안과 빅 엔디안 데이터 표현 사이를 전환합니다. 바이트 문자열 배열은 교환되지 않습니다. 복소수의 실수 부와 허수 부는 개별적으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="7b37ca94c4e2eda42b84355ca6a25cdc55774133" translate="yes" xml:space="preserve">
          <source>Tolerance in machine epsilons for the complex part of the elements in the array.</source>
          <target state="translated">배열 요소의 복잡한 부분에 대한 머신 엡실론의 공차.</target>
        </trans-unit>
        <trans-unit id="7a686b14e99b6f371ad9d543037e8be2650e9924" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;a href=&quot;numpy.isclose#numpy.isclose&quot;&gt;&lt;code&gt;isclose&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.isclose#numpy.isclose&quot;&gt; &lt;code&gt;isclose&lt;/code&gt; 에&lt;/a&gt; 전달 된 공차 매개 변수</target>
        </trans-unit>
        <trans-unit id="eb34b2131d6523965cdff1a43f4d01b982373d17" translate="yes" xml:space="preserve">
          <source>Tolerance parameters passed on to &lt;code&gt;isclose&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isclose&lt;/code&gt; 에 전달 된 공차 매개 변수</target>
        </trans-unit>
        <trans-unit id="6670aa4fd96fc23b9c267762a58d3e2634e5e33d" translate="yes" xml:space="preserve">
          <source>Tolerance when checking the singular values in covariance matrix. cov is cast to double before the check.</source>
          <target state="translated">공분산 행렬에서 특이 값을 확인할 때의 공차. cov는 확인 전에 두 배로 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="849d7597da246bfdf3ea363c9c3966af6e67a060" translate="yes" xml:space="preserve">
          <source>Tool chain</source>
          <target state="translated">도구 체인</target>
        </trans-unit>
        <trans-unit id="6e7bd14cfcb5cad5c21ec7a7360b81cb111dc93e" translate="yes" xml:space="preserve">
          <source>Top priority goes to &lt;strong&gt;technical inaccuracies&lt;/strong&gt; &amp;ndash; a docstring missing a parameter, a faulty description of a function/parameter/method, and so on. Other &amp;ldquo;structural&amp;rdquo; defects like broken links also get priority. All these fixes are easy to confirm and put in place. You can submit a &lt;a href=&quot;https://numpy.org/devdocs/dev/index.html#devindex&quot;&gt;pull request (PR)&lt;/a&gt; with the fix, if you know how to do that; otherwise please &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;open an issue&lt;/a&gt;.</source>
          <target state="translated">최우선 순위는 &lt;strong&gt;기술적 부정확성입니다.&lt;/strong&gt; 즉, 매개 변수가 누락 된 독 스트링, 함수 / 매개 변수 / 메소드에 대한 잘못된 설명 등이 있습니다. 끊어진 링크와 같은 다른 &quot;구조적&quot;결함도 우선 순위를 갖습니다. 이러한 모든 수정 사항은 쉽게 확인하고 적용 할 수 있습니다. 방법을 알고있는 경우 수정 사항이 포함 된 &lt;a href=&quot;https://numpy.org/devdocs/dev/index.html#devindex&quot;&gt;풀 요청 (PR)&lt;/a&gt; 을 제출할 수 있습니다 . 그렇지 않으면 &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;문제를여십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bae3881b1524f2891087bd43b6435b29e2fd654" translate="yes" xml:space="preserve">
          <source>Topics not covered in this tutorial can be found in the documentation:</source>
          <target state="translated">이 자습서에서 다루지 않은 항목은 설명서에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62511550774b90e55fa9f4d081340a2b9a412907" translate="yes" xml:space="preserve">
          <source>Total bytes consumed by the elements of the array.</source>
          <target state="translated">배열의 요소가 소비 한 총 바이트입니다.</target>
        </trans-unit>
        <trans-unit id="f98da7ab34ca5eed412ebdc84c5c6ee4a001f890" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000).</source>
          <target state="translated">전체 repr이 아닌 요약을 트리거하는 총 배열 요소 수 (기본값 1000).</target>
        </trans-unit>
        <trans-unit id="af14b2afdcc9cc3c661815c98f45cde11a73254a" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr (default 1000). To always use the full repr without summarization, pass &lt;a href=&quot;https://docs.python.org/dev/library/sys.html#sys.maxsize&quot;&gt;&lt;code&gt;sys.maxsize&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">전체 반복 (기본값 1000)이 아닌 요약을 트리거하는 배열 요소의 총 수입니다. 요약없이 항상 전체 repr을 사용하려면 &lt;a href=&quot;https://docs.python.org/dev/library/sys.html#sys.maxsize&quot;&gt; &lt;code&gt;sys.maxsize&lt;/code&gt; 를&lt;/a&gt; 전달 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d7665d1d201c9ce2fd429127a2f276d913bba99d" translate="yes" xml:space="preserve">
          <source>Total number of array elements which trigger summarization rather than full repr. Defaults to &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt;.</source>
          <target state="translated">전체 repr이 아닌 요약을 트리거하는 총 배열 요소 수입니다. 기본값은 &lt;code&gt;numpy.get_printoptions()['threshold']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7b009fd84652963a9ad5cd24ef82072817ddee41" translate="yes" xml:space="preserve">
          <source>Total size of broadcasted result.</source>
          <target state="translated">방송 된 결과의 총 크기.</target>
        </trans-unit>
        <trans-unit id="77cca581150b844f956409245e7a5aa4e911b340" translate="yes" xml:space="preserve">
          <source>Trace of a matrix:</source>
          <target state="translated">행렬의 흔적 :</target>
        </trans-unit>
        <trans-unit id="b67024bc850bfd9a0093e89cd78bf7093386c17c" translate="yes" xml:space="preserve">
          <source>Trace of an array, &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;numpy.trace&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열의 추적 &lt;a href=&quot;numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;numpy.trace&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0e339a8e0484e2fd0a0d26f8fea815f7ce8155" translate="yes" xml:space="preserve">
          <source>Tracking an Index or Multi-Index</source>
          <target state="translated">색인 또는 다중 색인 추적</target>
        </trans-unit>
        <trans-unit id="4cf0fc0db43adb86a6609aeef379773c878c22d3" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception</source>
          <target state="translated">색인 또는 다중 색인 추적은 요소마다 다른 색인 값이 필요하기 때문에 외부 루프 사용과 호환되지 않습니다. 이 플래그를 결합하려고하면 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 객체에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d235c585e89d9d88a2fc997aec36a615cac97376" translate="yes" xml:space="preserve">
          <source>Tracking an index or multi-index is incompatible with using an external loop, because it requires a different index value per element. If you try to combine these flags, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object will raise an exception.</source>
          <target state="translated">인덱스 또는 다중 인덱스 추적은 요소마다 다른 인덱스 값이 필요하기 때문에 외부 루프 사용과 호환되지 않습니다. 이러한 플래그를 결합하려고하면 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 객체에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0de8c9ca9943956fbbe74f36e563016e4ecbb6f6" translate="yes" xml:space="preserve">
          <source>Trailing (i.e., highest order) elements with absolute value less than or equal to &lt;code&gt;tol&lt;/code&gt; (default value is zero) are removed.</source>
          <target state="translated">절대 값이 &lt;code&gt;tol&lt;/code&gt; 보다 작거나 같은 후행 (즉, 최상위) 요소 (기본값은 0)가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="60e5d748c9218c048de8740bcac1703e7a50da1a" translate="yes" xml:space="preserve">
          <source>Trailing comments should be used sparingly. Instead of</source>
          <target state="translated">후행 주석은 드물게 사용해야합니다. 대신에</target>
        </trans-unit>
        <trans-unit id="b4e92ff02a7f9ca1e9c93153fdca1e9712b3f065" translate="yes" xml:space="preserve">
          <source>Trailing slices can be omitted:</source>
          <target state="translated">후행 슬라이스는 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="556492d634d78a1f54a40b4fbbb6e6c53716147d" translate="yes" xml:space="preserve">
          <source>Trailing zeros in the coefficients will be used in the evaluation, so they should be avoided if efficiency is a concern.</source>
          <target state="translated">계수의 후행 0이 평가에 사용되므로 효율성이 문제가되는 경우 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="745b5ecf9a2d85dc724cf9ddd7a6df396eb1df69" translate="yes" xml:space="preserve">
          <source>Transforms a masked array into a flexible-type array.</source>
          <target state="translated">마스킹 된 배열을 유연한 유형 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5335ed0e86bcde3b96f32fd1545910f420f14d2e" translate="yes" xml:space="preserve">
          <source>Transition notice</source>
          <target state="translated">전환 통지</target>
        </trans-unit>
        <trans-unit id="d362208ff2e702ca3538568841ed00ca61c441f9" translate="yes" xml:space="preserve">
          <source>Translate slice objects to concatenation along the first axis.</source>
          <target state="translated">슬라이스 객체를 첫 번째 축을 따라 연결하도록 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c42fc49440b8d06a906b44be13eb608ca2ffc1dd" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the first axis.</source>
          <target state="translated">슬라이스 객체를 첫 번째 축을 따라 연결로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ff7c65a71ec845e39d241d138fd72490df88fa74" translate="yes" xml:space="preserve">
          <source>Translates slice objects to concatenation along the second axis.</source>
          <target state="translated">슬라이스 객체를 두 번째 축을 따라 연결로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="59ccc78dea6365b58077aeb5bd29c68b822c1ef5" translate="yes" xml:space="preserve">
          <source>Translating content</source>
          <target state="translated">콘텐츠 번역</target>
        </trans-unit>
        <trans-unit id="8def3943422e0dc87b7f47772bd3dc4ad8ea550b" translate="yes" xml:space="preserve">
          <source>Transpose-like operations</source>
          <target state="translated">전치 유사 조작</target>
        </trans-unit>
        <trans-unit id="1dfdbda20e491607190c97bd4edf114a4a693811" translate="yes" xml:space="preserve">
          <source>Transposing a 1-D array returns an unchanged view of the original array.</source>
          <target state="translated">1 차원 배열을 전치하면 원래 배열의 변경되지 않은보기가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cfbc312acbc39b5f0298bdc7c7b5f4e1b759968b" translate="yes" xml:space="preserve">
          <source>Transposing and reshaping a matrix</source>
          <target state="translated">행렬 전치 및 모양 변경</target>
        </trans-unit>
        <trans-unit id="66408bfa15c9ed2902e447a43b1f7abcdee55a60" translate="yes" xml:space="preserve">
          <source>Transpositions and permutations, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;numpy.transpose&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">트랜스 포지션 및 순열, &lt;a href=&quot;numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;numpy.transpose&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65154a91dcd03eb78f603f149abeb7b4b5c5b547" translate="yes" xml:space="preserve">
          <source>Travis Oliphant &amp;ndash; project founder / emeritus leader (2005-2012)</source>
          <target state="translated">Travis Oliphant &amp;ndash; 프로젝트 창립자 / 명예 리더 (2005-2012)</target>
        </trans-unit>
        <trans-unit id="a7b41f9df87a78abbe8128d5a249676911368def" translate="yes" xml:space="preserve">
          <source>Travis Oliphant - Project Founder / Emeritus Leader (served: 2005-2012)</source>
          <target state="translated">Travis Oliphant-프로젝트 창립자 / 명예 리더 (서비스 : 2005-2012)</target>
        </trans-unit>
        <trans-unit id="8cd1d8f1121212090792af3b195766028fb3300b" translate="yes" xml:space="preserve">
          <source>Treatment for division by zero.</source>
          <target state="translated">0으로 나누기위한 치료.</target>
        </trans-unit>
        <trans-unit id="c576a1cfdbaf816c1398a32382e59edc28900bee" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point overflow.</source>
          <target state="translated">부동 소수점 오버 플로우 처리</target>
        </trans-unit>
        <trans-unit id="17721dd3ac43e33f85ad621f2dc25c086c0470c0" translate="yes" xml:space="preserve">
          <source>Treatment for floating-point underflow.</source>
          <target state="translated">부동 소수점 언더 플로 처리.</target>
        </trans-unit>
        <trans-unit id="a13040b51033dafdb26f7572598a0d12e22e4ffe" translate="yes" xml:space="preserve">
          <source>Treatment for invalid floating-point operation.</source>
          <target state="translated">유효하지 않은 부동 소수점 연산 처리</target>
        </trans-unit>
        <trans-unit id="1150736fa84c0c4e53f25517e34313dcdeeed227" translate="yes" xml:space="preserve">
          <source>Tricks and Tips</source>
          <target state="translated">트릭과 팁</target>
        </trans-unit>
        <trans-unit id="daa2b8a97e48dc7878c0a5d70afe5d62a641a9fe" translate="yes" xml:space="preserve">
          <source>Trigger a build by pushing a commit of your edits to the repository. Note that you can do this on a branch, but it must be pushed upstream to the &lt;code&gt;MacPython/numpy-wheels&lt;/code&gt; repository to trigger uploads since only that repo has the appropriate tokens to allow uploads.</source>
          <target state="translated">수정 사항 커밋을 저장소에 푸시하여 빌드를 트리거합니다. 브랜치에서이 작업을 수행 할 수 있지만 해당 저장소에만 업로드를 허용하는 적절한 토큰이 있으므로 업로드를 트리거 하려면 &lt;code&gt;MacPython/numpy-wheels&lt;/code&gt; 저장소로 업스트림으로 푸시해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9ba6ba3648cadff3a99f26c6371ef76b8f5ec198" translate="yes" xml:space="preserve">
          <source>Trigger the wheel builds</source>
          <target state="translated">휠 빌드 트리거</target>
        </trans-unit>
        <trans-unit id="05468e0c8d821343ed9a233c1d01733b9266bd0b" translate="yes" xml:space="preserve">
          <source>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;. If this is the first release in a series, start with a pull as the repo may have been accessed and changed by someone else, then create a new branch for the series. If the branch already exists skip this:</source>
          <target state="translated">이 커밋에서 numpy-wheels 저장소를 지정하여 wheels 빌드를 트리거합니다. 최대 1 시간이 소요될 수 있습니다. numpy-wheels 저장소는 &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; 에서 복제됩니다 . 시리즈의 첫 번째 릴리스 인 경우 다른 사람이 저장소에 액세스하고 변경했을 수 있으므로 끌어 오기로 시작한 다음 시리즈에 대한 새 분기를 만듭니다. 분기가 이미있는 경우 다음을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="4be7bc22dfdfa583bec627625a7e1101bc895967" translate="yes" xml:space="preserve">
          <source>Trigger the wheels build by pointing the numpy-wheels repository at this commit. This can take up to an hour. The numpy-wheels repository is cloned from &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt;. Start with a pull as the repo may have been accessed and changed by someone else and a push will fail:</source>
          <target state="translated">이 커밋에서 numpy-wheels 저장소를 지정하여 wheels 빌드를 트리거합니다. 최대 1 시간이 소요될 수 있습니다. numpy-wheels 저장소는 &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; 에서 복제됩니다 . 다른 사람이 리포지토리에 액세스하고 변경했을 수 있으므로 풀로 시작하면 푸시가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="3a49a3516e9535a98c78b0ab59efaa267faaaeac" translate="yes" xml:space="preserve">
          <source>Triggers &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt;, and when an array operand is flagged for writing and is copied, causes the data in a copy to be copied back to &lt;code&gt;op[i]&lt;/code&gt; when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; 를&lt;/a&gt; 트리거 하고 배열 피연산자가 쓰기 플래그를 지정하고 복사 할 때 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 가 호출 될 때 사본의 데이터가 &lt;code&gt;op[i]&lt;/code&gt; 다시 복사됩니다 .</target>
        </trans-unit>
        <trans-unit id="b9e4c026492c440bf32166e0789393487d03b254" translate="yes" xml:space="preserve">
          <source>Trigonometric functions</source>
          <target state="translated">삼각 함수</target>
        </trans-unit>
        <trans-unit id="58cf0aee76fad599f97ff1db8c6a47d2270860db" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse cosine, element-wise.</source>
          <target state="translated">삼각법 역 코사인, 요소 별.</target>
        </trans-unit>
        <trans-unit id="b0b82a06c2ae28e8fcf146e965d0c41fd4531e3a" translate="yes" xml:space="preserve">
          <source>Trigonometric inverse tangent, element-wise.</source>
          <target state="translated">삼각법 역 탄젠트, 요소 별.</target>
        </trans-unit>
        <trans-unit id="ce4f3fa4852db4b9b207eedadc12e11135e46d85" translate="yes" xml:space="preserve">
          <source>Trigonometric sine, element-wise.</source>
          <target state="translated">요소 별 삼각 사인.</target>
        </trans-unit>
        <trans-unit id="10a283c17897bbd0b4cb4fd810a9eeb88aa8ef58" translate="yes" xml:space="preserve">
          <source>Trim the leading and/or trailing zeros from a 1-D array or sequence.</source>
          <target state="translated">1 차원 배열 또는 시퀀스에서 선행 및 / 또는 후행 0을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="e488bb5cb2e281f3b003ce95222b8e4917db65a6" translate="yes" xml:space="preserve">
          <source>Troubleshooting ImportError</source>
          <target state="translated">ImportError 문제 해결</target>
        </trans-unit>
        <trans-unit id="88b33e4e12f75ac8bf792aebde41f1a090f3a612" translate="yes" xml:space="preserve">
          <source>True</source>
          <target state="translated">True</target>
        </trans-unit>
        <trans-unit id="dec064efe14ed7a73f97fa4832f7dc39f8d37259" translate="yes" xml:space="preserve">
          <source>True divide self by other in-place.</source>
          <target state="translated">다른 곳에서 자기 자신을 나누십시오.</target>
        </trans-unit>
        <trans-unit id="7c6199295c88c515de03909ca69e74e54d8c40d0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;element&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 가 스칼라 유형 이면 True , 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="39cf2a1ac05eb7ec1f611fa8df3b32f9cff1d558" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;m.dtype.type&lt;/code&gt; is MaskType, False otherwise.</source>
          <target state="translated">&lt;code&gt;m.dtype.type&lt;/code&gt; 인 경우 참 이 MaskType 이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="c7e5263b6e49f0164ce122995ea161e565df58fa" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;num&lt;/code&gt; is a scalar type, False if it is not.</source>
          <target state="translated">&lt;code&gt;num&lt;/code&gt; 이 스칼라 유형 이면 True이고 , 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="2655b1728487edfb72db0ecd08ff9ea666177ee0" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;path&lt;/code&gt; exists.</source>
          <target state="translated">&lt;code&gt;path&lt;/code&gt; 가 존재 하면 true 입니다.</target>
        </trans-unit>
        <trans-unit id="0acadbce2849d20449e701a26739adbff1b98e78" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray with masked values, False otherwise.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 마스크 된 값을 갖는 MaskedArray 이면 True , 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="83f25ea97ce8639113893298b33aa2fdafa083b7" translate="yes" xml:space="preserve">
          <source>True if &lt;code&gt;x&lt;/code&gt; is a MaskedArray.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 MaskedArray 이면 참 .</target>
        </trans-unit>
        <trans-unit id="05ff71445923acdd0c38d736b463809c9ccd39de" translate="yes" xml:space="preserve">
          <source>True if a Fortran 77 compiler is available (because a simple Fortran 77 code was able to be compiled successfully).</source>
          <target state="translated">간단한 포트란 77 코드를 성공적으로 컴파일 할 수 있었기 때문에 포트란 77 컴파일러를 사용할 수 있으면 참입니다.</target>
        </trans-unit>
        <trans-unit id="00cd0fd9fd4e9fcf05a5961ba064f7c5fc57b8ef" translate="yes" xml:space="preserve">
          <source>True if a Fortran 90 compiler is available (because a simple Fortran 90 code was able to be compiled successfully)</source>
          <target state="translated">Fortran 90 컴파일러를 사용할 수있는 경우 True입니다 (단순한 Fortran 90 코드를 성공적으로 컴파일 할 수 있었기 때문에)</target>
        </trans-unit>
        <trans-unit id="3616df3a5e4787a2b7d174f6c5a2763bf50c6e85" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_BIG&quot;&gt;&lt;code&gt;NPY_BIG&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_IGNORE&quot;&gt;&lt;code&gt;NPY_IGNORE&lt;/code&gt;&lt;/a&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">바이트 순서 문자 ( &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_BIG&quot;&gt; &lt;code&gt;NPY_BIG&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_IGNORE&quot;&gt; &lt;code&gt;NPY_IGNORE&lt;/code&gt; &lt;/a&gt; )가 기본 바이트 순서 사양과 동일하거나 동등한 경우 참 입니다. 따라서 리틀 엔디안 머신에서 &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt; 는 빅 엔디안 머신에서 동일하지 않은 경우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="213506708b75038d86119f896c93fd459688fdaa" translate="yes" xml:space="preserve">
          <source>True if byteorder characters ( &lt;code&gt;NPY_LITTLE&lt;/code&gt;, &lt;code&gt;NPY_BIG&lt;/code&gt;, &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_IGNORE&lt;/code&gt; ) are either equal or equivalent as to their specification of a native byte order. Thus, on a little-endian machine &lt;code&gt;NPY_LITTLE&lt;/code&gt; and &lt;code&gt;NPY_NATIVE&lt;/code&gt; are equivalent where they are not equivalent on a big-endian machine.</source>
          <target state="translated">바이트 순서 문자 ( &lt;code&gt;NPY_LITTLE&lt;/code&gt; , &lt;code&gt;NPY_BIG&lt;/code&gt; , &lt;code&gt;NPY_NATIVE&lt;/code&gt; , &lt;code&gt;NPY_IGNORE&lt;/code&gt; )가 고유 바이트 순서의 스펙과 같거나 동등한 경우 참 입니다. 따라서 리틀 엔디안 머신 &lt;code&gt;NPY_LITTLE&lt;/code&gt; 및 &lt;code&gt;NPY_NATIVE&lt;/code&gt; 에서 는 동일하지 않은 경우에 동일합니다.</target>
        </trans-unit>
        <trans-unit id="ba3294550f0a20e5d9deb7f04a95fb8e4b4d1d46" translate="yes" xml:space="preserve">
          <source>True if cast can occur according to the casting rule.</source>
          <target state="translated">캐스팅 규칙에 따라 캐스팅이 발생할 수 있으면 true입니다.</target>
        </trans-unit>
        <trans-unit id="1f63565b32d103f3a4de31640d426343af47dd7d" translate="yes" xml:space="preserve">
          <source>True if equivalent, False otherwise.</source>
          <target state="translated">같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="1e741019d05ad4b1c0222d2d53486f99a6732190" translate="yes" xml:space="preserve">
          <source>True if other is same class as self</source>
          <target state="translated">다른 사람이 자기와 같은 계급이라면 참</target>
        </trans-unit>
        <trans-unit id="70fbd415e3863800b42dd70f2afc2d0435498df0" translate="yes" xml:space="preserve">
          <source>True if the coefficients are the same, False otherwise.</source>
          <target state="translated">계수가 같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="a6afbacb41b3137cec218f989dffb959ca4f44cd" translate="yes" xml:space="preserve">
          <source>True if the domains are the same, False otherwise.</source>
          <target state="translated">도메인이 같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="4bc2a6d6f70eb24c8def5df03724644edb474780" translate="yes" xml:space="preserve">
          <source>True if the windows are the same, False otherwise.</source>
          <target state="translated">창이 같으면 True, 그렇지 않으면 False</target>
        </trans-unit>
        <trans-unit id="24f9df4fb7133abd7e86f4b5f0391c10a93621e7" translate="yes" xml:space="preserve">
          <source>True if two arrays have the same shape and elements, False otherwise.</source>
          <target state="translated">두 배열의 모양과 요소가 동일한 경우 True이고, 그렇지 않으면 False입니다.</target>
        </trans-unit>
        <trans-unit id="755e15abf3303ababe3ade30f10af71c607d4530" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaN, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">사실 여기서 &lt;code&gt;x&lt;/code&gt; NaN를, 그렇지 않은 경우는 false입니다. &lt;code&gt;x&lt;/code&gt; 이면 스칼라입니다. 가 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="dc0b3f0e3c0fa8c731e1bcdadee661ee71b2ddb8" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is NaT, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">사실 여기서 &lt;code&gt;x&lt;/code&gt; NAT, 그렇지 않은 경우는 false입니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="cd270c6be47d5f9045a9640d5cc8ead8711407bc" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is not positive infinity, negative infinity, or NaN; false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 양의 무한대, 음의 무한대 또는 NaN이 아닌 경우 True ; 그렇지 않으면 거짓. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3170e8eb3762dd10d0e3ab109761eb5c944e9ac1" translate="yes" xml:space="preserve">
          <source>True where &lt;code&gt;x&lt;/code&gt; is positive or negative infinity, false otherwise. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">TRUE 여기서 &lt;code&gt;x&lt;/code&gt; 는 양 또는 음의 무한대, 그렇지 않은 경우는 false. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="425b939d0909e079d100ad47521c0febc0bd307a" translate="yes" xml:space="preserve">
          <source>Truncate s values at 50 so plot is interesting:</source>
          <target state="translated">s 값을 50으로 자르면 음모가 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="8726579bd5d3f34275a243eb604a9ceb6cbd38eb" translate="yes" xml:space="preserve">
          <source>Truncate series to length &lt;code&gt;size&lt;/code&gt;.</source>
          <target state="translated">시리즈를 길이 &lt;code&gt;size&lt;/code&gt; 자릅니다 .</target>
        </trans-unit>
        <trans-unit id="adcf68c15599690309b811decf083d5555853eeb" translate="yes" xml:space="preserve">
          <source>Truncate series to the given degree.</source>
          <target state="translated">주어진 정도로 시리즈를 자릅니다.</target>
        </trans-unit>
        <trans-unit id="d2338e206b938414aa6688a0afb4b20ac9ad0ec9" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt;&lt;code&gt;bool()&lt;/code&gt;&lt;/a&gt;):</source>
          <target state="translated">배열의 진실 값 ( &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#bool&quot;&gt; &lt;code&gt;bool()&lt;/code&gt; &lt;/a&gt; ) :</target>
        </trans-unit>
        <trans-unit id="d78b8c914ad90242aebfa1ad45be017c8a4ed426" translate="yes" xml:space="preserve">
          <source>Truth value of an array (&lt;code&gt;bool&lt;/code&gt;):</source>
          <target state="translated">배열의 진실 값 ( &lt;code&gt;bool&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="d14d79df6800bf8b855c978794baaad558b55ab7" translate="yes" xml:space="preserve">
          <source>Truth value testing</source>
          <target state="translated">진실 가치 테스트</target>
        </trans-unit>
        <trans-unit id="a34d6317df428f3a0882e4fcc17ec8a423d926fc" translate="yes" xml:space="preserve">
          <source>Truth-value testing of an array invokes &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt;&lt;code&gt;ndarray.__bool__&lt;/code&gt;&lt;/a&gt;, which raises an error if the number of elements in the array is larger than 1, because the truth value of such arrays is ambiguous. Use &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt;&lt;code&gt;.any()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt;&lt;code&gt;.all()&lt;/code&gt;&lt;/a&gt; instead to be clear about what is meant in such cases. (If the number of elements is 0, the array evaluates to &lt;code&gt;False&lt;/code&gt;.)</source>
          <target state="translated">배열의 진리 값 테스트는 &lt;a href=&quot;generated/numpy.ndarray.__bool__#numpy.ndarray.__bool__&quot;&gt; &lt;code&gt;ndarray.__bool__&lt;/code&gt; &lt;/a&gt; 호출 하며, 배열의 요소 수가 1보다 크면 배열의 실제 값이 모호하기 때문에 오류가 발생합니다. 사용 &lt;a href=&quot;generated/numpy.ndarray.any#numpy.ndarray.any&quot;&gt; &lt;code&gt;.any()&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.ndarray.all#numpy.ndarray.all&quot;&gt; &lt;code&gt;.all()&lt;/code&gt; &lt;/a&gt; 대신 이런 경우에 무엇을 의미하는지에 대해 명확하게합니다. 요소의 수가 0이면 배열은 &lt;code&gt;False&lt;/code&gt; 로 평가됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ecf59a43e289ad2b017cf95dec49da40904a53e" translate="yes" xml:space="preserve">
          <source>Try to get version string of a package.</source>
          <target state="translated">패키지의 버전 문자열을 가져 오십시오.</target>
        </trans-unit>
        <trans-unit id="d41c38be32c336059996707815d0e3ddc6359848" translate="yes" xml:space="preserve">
          <source>Try to keep the runtime of the benchmark reasonable.</source>
          <target state="translated">벤치 마크의 런타임을 합리적으로 유지하십시오.</target>
        </trans-unit>
        <trans-unit id="78b28b6348f61eb4f458af0454cbb48914113f96" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 하위 배열을 설명 하면 튜플 &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 이고 , 그렇지 않으면 None입니다.</target>
        </trans-unit>
        <trans-unit id="3e6ddb0c1b967dfa42de0aef208f74bd1f3fd6c6" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 하위 배열을 설명 하면 튜플 &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 이고 , 그렇지 않으면 None입니다.</target>
        </trans-unit>
        <trans-unit id="f3757a0166a586f2a2125cefab21784843d386d2" translate="yes" xml:space="preserve">
          <source>Tuple &lt;code&gt;(item_dtype, shape)&lt;/code&gt; if this &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; describes a sub-array, and None otherwise.</source>
          <target state="translated">이 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 하위 배열을 설명 하면 튜플 &lt;code&gt;(item_dtype, shape)&lt;/code&gt; 이고 , 그렇지 않으면 None입니다.</target>
        </trans-unit>
        <trans-unit id="84be13d7b7fcc75e7ec8441a86e66cf302003bb9" translate="yes" xml:space="preserve">
          <source>Tuple axis arguments to ufuncs are equivalent:</source>
          <target state="translated">ufunc에 대한 튜플 축 인수는 동일합니다.</target>
        </trans-unit>
        <trans-unit id="92e7c78c7d4063f090081adef280802cf975a20b" translate="yes" xml:space="preserve">
          <source>Tuple object dtypes</source>
          <target state="translated">튜플 객체 dtypes</target>
        </trans-unit>
        <trans-unit id="288ea08ff10a961743d4d8b925f5d1931f661310" translate="yes" xml:space="preserve">
          <source>Tuple of array dimensions.</source>
          <target state="translated">배열 차원의 튜플.</target>
        </trans-unit>
        <trans-unit id="f5d08265a0d5770b0b5299133319ac3ca12e44d4" translate="yes" xml:space="preserve">
          <source>Tuple of bytes steps in each dimension.</source>
          <target state="translated">각 차원의 튜플 바이트 단계.</target>
        </trans-unit>
        <trans-unit id="119e92503836c54689c5f8c6dff4e15a28816a46" translate="yes" xml:space="preserve">
          <source>Tuple of bytes to step in each dimension when traversing an array.</source>
          <target state="translated">배열을 탐색 할 때 각 차원에서 단계별로 이동할 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="08a4b4faf13c4a1ee940941cfebf009124c6372f" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;). Note that these integers could be larger than the platform &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;long&lt;/code&gt; could hold (a Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; is a C &lt;code&gt;long&lt;/code&gt;). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;long long&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">요소가 각 차원의 배열 크기 인 튜플입니다. 각 항목은 정수 (Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; )입니다. 이러한 정수는 플랫폼 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;long&lt;/code&gt; 이 보유 할 수있는 것보다 클 수 있습니다 (Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 는 C &lt;code&gt;long&lt;/code&gt; ). 이 속성을 적절하게 처리하는 것은이 속성을 사용하는 코드에 달려 있습니다. 오버플로가 가능할 때 오류를 발생 시키거나 도형에 대해 C 유형만큼 &lt;code&gt;long long&lt;/code&gt; 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a39e9bc9ce6796bfca6ebd0c63299d64e075f553" translate="yes" xml:space="preserve">
          <source>Tuple whose elements are the array size in each dimension. Each entry is an integer (a Python int or long). Note that these integers could be larger than the platform &amp;ldquo;int&amp;rdquo; or &amp;ldquo;long&amp;rdquo; could hold (a Python int is a C long). It is up to the code using this attribute to handle this appropriately; either by raising an error when overflow is possible, or by using &lt;code&gt;Py_LONG_LONG&lt;/code&gt; as the C type for the shapes.</source>
          <target state="translated">요소가 각 차원의 배열 크기 인 튜플. 각 항목은 정수입니다 (Python int 또는 long). 이 정수는 플랫폼 &quot;int&quot;또는 &quot;long&quot;이 보유 할 수있는 것보다 클 수 있습니다 (Python int는 C long 임). 이것을 적절히 처리하기 위해서는이 속성을 사용하는 것은 코드에 달려 있습니다. 오버플로가 가능한 경우 오류를 발생 시키거나 &lt;code&gt;Py_LONG_LONG&lt;/code&gt; 을 셰이프의 C 유형으로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="20d441ae2c7520e9597892d62d069dab012afe76" translate="yes" xml:space="preserve">
          <source>Turns pure python into efficient machine code through jit-like optimizations</source>
          <target state="translated">jit와 유사한 최적화를 통해 순수한 파이썬을 효율적인 기계 코드로 전환합니다.</target>
        </trans-unit>
        <trans-unit id="d9bd3e52f2caf4d6594b811b3960a4952fbdcd14" translate="yes" xml:space="preserve">
          <source>Tutorial: Linear algebra on n-dimensional arrays</source>
          <target state="translated">튜토리얼 : n 차원 배열에 대한 선형 대수</target>
        </trans-unit>
        <trans-unit id="6cedb23d3e7c47dc54b88999730d0194898d3934" translate="yes" xml:space="preserve">
          <source>Tutorial: Masked Arrays</source>
          <target state="translated">자습서 : 마스킹 된 배열</target>
        </trans-unit>
        <trans-unit id="654171647baa6be8557a5d627cf35c7075ebb257" translate="yes" xml:space="preserve">
          <source>Tutorials</source>
          <target state="translated">Tutorials</target>
        </trans-unit>
        <trans-unit id="a3aad8fcfc1fb793d988e46dd13b4c587f04cc94" translate="yes" xml:space="preserve">
          <source>Tutorials and summaries</source>
          <target state="translated">튜토리얼 및 요약</target>
        </trans-unit>
        <trans-unit id="0e8bc0a325097293ba3968264a6e780fc207371f" translate="yes" xml:space="preserve">
          <source>Tweaking the conversion</source>
          <target state="translated">변환 조정</target>
        </trans-unit>
        <trans-unit id="a84f46a1bd48b0888bd11bac416f31bd455192d4" translate="yes" xml:space="preserve">
          <source>Two and three dots in difference specs</source>
          <target state="translated">차이점 사양의 2 점 및 3 점</target>
        </trans-unit>
        <trans-unit id="eff015ed2b91595519ef0f82b5da310790ed8380" translate="yes" xml:space="preserve">
          <source>Two groups, children of diabetics (25 people) and children from people without diabetes (25 controls). Fasting blood glucose was measured, case group had a mean value of 86.1, controls had a mean value of 82.2. Standard deviations were 2.09 and 2.49 respectively. Are these data consistent with the null hypothesis that the parents diabetic status does not affect their children&amp;rsquo;s blood glucose levels? Calculating the F statistic from the data gives a value of 36.01.</source>
          <target state="translated">두 그룹, 당뇨병 아동 (25 명)과 당뇨병이없는 사람 (25 명). 공복 혈당을 측정하였고, 사례 군의 평균값은 86.1, 대조군의 평균값은 82.2였다. 표준 편차는 각각 2.09와 2.49입니다. 이러한 데이터는 부모 당뇨병 상태가 자녀의 혈당 수준에 영향을 미치지 않는다는 귀무 가설과 일치합니까? 데이터에서 F 통계량을 계산하면 값이 36.01입니다.</target>
        </trans-unit>
        <trans-unit id="9a29304c220b1dd3134936cc76050af186cb5278" translate="yes" xml:space="preserve">
          <source>Two times the reciprocal of pi (</source>
          <target state="translated">파이의 역수의 두 배 (</target>
        </trans-unit>
        <trans-unit id="c6b3128dd2f1c22ff8a2b286be1379fe8a8fe179" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from</source>
          <target state="translated">2 개에서 4 개의 샘플 배열</target>
        </trans-unit>
        <trans-unit id="b1f6d6c8746a437f90f0dee674c0b93df2f99381" translate="yes" xml:space="preserve">
          <source>Two-by-four array of samples from N(3, 6.25):</source>
          <target state="translated">N (3, 6.25)의 샘플 2 개씩 배열 :</target>
        </trans-unit>
        <trans-unit id="3db221513448342ff7f1391357dc023cdf6dc3dc" translate="yes" xml:space="preserve">
          <source>Two-by-four matrix of samples from</source>
          <target state="translated">샘플의 2x4 매트릭스</target>
        </trans-unit>
        <trans-unit id="862d5ad68d4b198349fd0cc9c98a5797e23f13c7" translate="yes" xml:space="preserve">
          <source>Two-dimensional array:</source>
          <target state="translated">2 차원 배열 :</target>
        </trans-unit>
        <trans-unit id="4ca814bb64ef6897ea819d313fffbc4815334f0e" translate="yes" xml:space="preserve">
          <source>Two-dimensional arrays are tested in exactly the same manner. The above description applies, but with &lt;code&gt;Matrix&lt;/code&gt; substituted for &lt;code&gt;Vector&lt;/code&gt;. For three-dimensional tests, substitute &lt;code&gt;Tensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For four-dimensional tests, substitute &lt;code&gt;SuperTensor&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For flat in-place array tests, substitute &lt;code&gt;Flat&lt;/code&gt; for &lt;code&gt;Vector&lt;/code&gt;. For the descriptions that follow, we will reference the &lt;code&gt;Vector&lt;/code&gt; tests, but the same information applies to &lt;code&gt;Matrix&lt;/code&gt;, &lt;code&gt;Tensor&lt;/code&gt; and &lt;code&gt;SuperTensor&lt;/code&gt; tests.</source>
          <target state="translated">2 차원 배열은 정확히 같은 방식으로 테스트됩니다. 위의 설명이 적용되지만 &lt;code&gt;Vector&lt;/code&gt; 가 &lt;code&gt;Matrix&lt;/code&gt; 로 대체되었습니다 . 3 차원 테스트의 경우 &lt;code&gt;Vector&lt;/code&gt; 대신 &lt;code&gt;Tensor&lt;/code&gt; 를 사용하십시오 . 4 차원 테스트의 경우 &lt;code&gt;SuperTensor&lt;/code&gt; 를 &lt;code&gt;Vector&lt;/code&gt; 로 대체 하십시오 . 전체 내부 배열 테스트의 경우 &lt;code&gt;Flat&lt;/code&gt; 을 &lt;code&gt;Vector&lt;/code&gt; 로 대체하십시오 . 다음 설명에 대해서는 &lt;code&gt;Vector&lt;/code&gt; 테스트 를 참조 하지만 &lt;code&gt;Matrix&lt;/code&gt; , &lt;code&gt;Tensor&lt;/code&gt; 및 &lt;code&gt;SuperTensor&lt;/code&gt; 테스트 에도 동일한 정보가 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="3deb7456519697ecf4eefc455516c969a3681bae" translate="yes" xml:space="preserve">
          <source>Type</source>
          <target state="translated">Type</target>
        </trans-unit>
        <trans-unit id="4f87d1dd8d472cbdfec76a8cf89933a4a1cf8dbd" translate="yes" xml:space="preserve">
          <source>Type Promotion</source>
          <target state="translated">유형 프로모션</target>
        </trans-unit>
        <trans-unit id="315f6367d2e7e25cde681d099ca28e1c2c774de1" translate="yes" xml:space="preserve">
          <source>Type declarations</source>
          <target state="translated">유형 선언</target>
        </trans-unit>
        <trans-unit id="546ef13b4643b6acadc0951eac37d6f468caac3d" translate="yes" xml:space="preserve">
          <source>Type description examples</source>
          <target state="translated">타입 설명 예제</target>
        </trans-unit>
        <trans-unit id="966782d7443e2170cf499e59f9a8368a7b7380cd" translate="yes" xml:space="preserve">
          <source>Type has fields associated with it.</source>
          <target state="translated">유형에는 관련 필드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad1651cc08eba91d6dce8f9e7cbe0420ed624c49" translate="yes" xml:space="preserve">
          <source>Type has no size information attached, and can be resized. Should only be called on flexible dtypes. Types that are attached to an array will always be sized, hence the array form of this macro not existing.</source>
          <target state="translated">유형에 첨부 된 크기 정보가 없으며 크기를 조정할 수 있습니다. 유연한 dtype에서만 호출해야합니다. 배열에 연결된 유형은 항상 크기가 조정되므로이 매크로의 배열 형식은 존재하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="00fea5456fe9ccd4a61fecaaa45953e334c1c594" translate="yes" xml:space="preserve">
          <source>Type is either flexible or user-defined.</source>
          <target state="translated">유형은 유동적이거나 사용자 정의입니다.</target>
        </trans-unit>
        <trans-unit id="fd89c694ef19c6e785630016c5d715bce35c6076" translate="yes" xml:space="preserve">
          <source>Type is preserved for boolean arrays, so the result will contain &lt;code&gt;False&lt;/code&gt; when consecutive elements are the same and &lt;code&gt;True&lt;/code&gt; when they differ.</source>
          <target state="translated">부울 배열의 경우 유형이 유지되므로 연속 요소가 동일 하면 결과에 &lt;code&gt;False&lt;/code&gt; 가 포함 되고 요소가 다르면 &lt;code&gt;True&lt;/code&gt; 가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="5f129dda4a5f86710986e28a3910cacd0ab66b0a" translate="yes" xml:space="preserve">
          <source>Type of comparison.</source>
          <target state="translated">비교 유형.</target>
        </trans-unit>
        <trans-unit id="c36d17e1133f5c5a545edd7db2e2ccd0a71a9cf5" translate="yes" xml:space="preserve">
          <source>Type of the data (integer, float, Python object, etc.)</source>
          <target state="translated">데이터 유형 (정수, 부동 소수점, Python 객체 등)</target>
        </trans-unit>
        <trans-unit id="dd429360d0a73315317719cd2b034bd7849c79e3" translate="yes" xml:space="preserve">
          <source>Type of the returned array and of the accumulator in which the elements are summed. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used.</source>
          <target state="translated">반환 된 배열 및 요소가 합산 된 누산기의 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 의 DTYPE가 기본값으로 지정되지 않은 &lt;code&gt;a&lt;/code&gt; 하지 않는 한, &lt;code&gt;a&lt;/code&gt; 덜 기본 플랫폼 정수보다 정밀도 정수 DTYPE 있습니다. 이 경우 기본 플랫폼 정수가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07bc03c5a2d510ae05b611f9e4728e3dfbb4d656" translate="yes" xml:space="preserve">
          <source>Type of the returned array, as well as of the accumulator in which the elements are multiplied. If &lt;em&gt;dtype&lt;/em&gt; is not specified, it defaults to the dtype of &lt;code&gt;a&lt;/code&gt;, unless &lt;code&gt;a&lt;/code&gt; has an integer dtype with a precision less than that of the default platform integer. In that case, the default platform integer is used instead.</source>
          <target state="translated">반환 된 배열의 유형과 요소가 곱해지는 누산기의 유형입니다. 경우 &lt;em&gt;DTYPE은&lt;/em&gt; 의 DTYPE가 기본값으로 지정되지 않은 &lt;code&gt;a&lt;/code&gt; 하지 않는 한, &lt;code&gt;a&lt;/code&gt; 덜 기본 플랫폼 정수보다 정밀도 정수 DTYPE 있습니다. 이 경우 기본 플랫폼 정수가 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2fbcc881be006ea806d10d1a75e79dec487e047f" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, omission of the parameter results in type preservation.</source>
          <target state="translated">반환 된 뷰의 유형입니다 (예 : ndarray 또는 행렬). 다시 말하지만, 매개 변수를 생략하면 유형이 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="36795fd8406bf11fda0ac3128a88df4463dd2892" translate="yes" xml:space="preserve">
          <source>Type of the returned view, e.g., ndarray or matrix. Again, the default None results in type preservation.</source>
          <target state="translated">반환 된보기의 유형 (예 : ndarray 또는 행렬) 다시, 기본값 없음은 유형 보존을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="e3dd48b9d6f09dc7416ab4d63d6ccc2dc14a5715" translate="yes" xml:space="preserve">
          <source>Type of the returned view, either ndarray or a subclass. The default None results in type preservation.</source>
          <target state="translated">리턴 된보기의 유형 (ndarray 또는 서브 클래스). 기본값 없음은 유형이 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="9d0b3189219da3d7ba109eef463be8e2071fbe7e" translate="yes" xml:space="preserve">
          <source>Type promotion in NumPy works similarly to the rules in languages like C++, with some slight differences. When both scalars and arrays are used, the array&amp;rsquo;s type takes precedence and the actual value of the scalar is taken into account.</source>
          <target state="translated">NumPy의 타입 프로모션은 C ++과 같은 언어의 규칙과 비슷하지만 약간의 차이가 있습니다. 스칼라와 배열을 모두 사용하는 경우 배열 유형이 우선하며 스칼라의 실제 값이 고려됩니다.</target>
        </trans-unit>
        <trans-unit id="66585ef6b68c044b299bc7220f22788121e21167" translate="yes" xml:space="preserve">
          <source>Type provided:</source>
          <target state="translated">제공되는 유형 :</target>
        </trans-unit>
        <trans-unit id="bc25fc1327a92506da2b55272b3113fcffa65d61" translate="yes" xml:space="preserve">
          <source>Type represents Boolean data type.</source>
          <target state="translated">유형은 부울 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="60db025c166ec63b9a181b61c24b20c5d24b0648" translate="yes" xml:space="preserve">
          <source>Type represents a signed integer.</source>
          <target state="translated">유형은 부호있는 정수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="acb6256437982d272438054c848d82884163b4d8" translate="yes" xml:space="preserve">
          <source>Type represents a string data type.</source>
          <target state="translated">유형은 문자열 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="08f325041fae51a65ee6e08f868548827f3e2b61" translate="yes" xml:space="preserve">
          <source>Type represents a user-defined type.</source>
          <target state="translated">유형은 사용자 정의 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f5f87b05bbeb10ab3c2ec34871c51fb7f3e190f2" translate="yes" xml:space="preserve">
          <source>Type represents an enumerated type corresponding to one of the standard Python scalar (bool, int, float, or complex).</source>
          <target state="translated">Type은 표준 Python 스칼라 (bool, int, float 또는 complex) 중 하나에 해당하는 열거 된 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6fc847c0dbefe834d836a7b9b36c518b8a349fc4" translate="yes" xml:space="preserve">
          <source>Type represents an unsigned integer.</source>
          <target state="translated">유형은 부호없는 정수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f8e7a296ef6aceb534615bd823bf7fad61a5043e" translate="yes" xml:space="preserve">
          <source>Type represents any complex floating point number.</source>
          <target state="translated">유형은 복잡한 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="28cd3b87be44c11187d7cc10075315e307082083" translate="yes" xml:space="preserve">
          <source>Type represents any floating point number.</source>
          <target state="translated">유형은 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="579601ba7e8ea9eb8623a33cadfe20f9eaea6f83" translate="yes" xml:space="preserve">
          <source>Type represents any integer, floating point, or complex floating point number.</source>
          <target state="translated">유형은 정수, 부동 소수점 또는 복합 부동 소수점 숫자를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="051ab06f1a62606ef03aadb95e9e56f705f31488" translate="yes" xml:space="preserve">
          <source>Type represents any integer.</source>
          <target state="translated">유형은 모든 정수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a2ba1da5781162c52e0abb1d3993de06d380b834" translate="yes" xml:space="preserve">
          <source>Type represents object data type.</source>
          <target state="translated">유형은 객체 데이터 유형을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="20eece7c06865b2554e5d1db1375400953d56528" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">유형은 유연한 배열 유형 중 하나를 나타냅니다 ( &lt;a href=&quot;c-api.dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;c-api.dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8e6c44e27b4edb7108b331e3527612380352acbf" translate="yes" xml:space="preserve">
          <source>Type represents one of the flexible array types ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt;&lt;code&gt;NPY_STRING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt;&lt;code&gt;NPY_UNICODE&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt;&lt;code&gt;NPY_VOID&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">유형은 유연한 배열 유형 ( &lt;a href=&quot;dtype#c.NPY_STRING&quot;&gt; &lt;code&gt;NPY_STRING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;dtype#c.NPY_UNICODE&quot;&gt; &lt;code&gt;NPY_UNICODE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;dtype#c.NPY_VOID&quot;&gt; &lt;code&gt;NPY_VOID&lt;/code&gt; &lt;/a&gt; ) 중 하나를 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="cab551b16a69b24d82e03c4a0d668cc3040d4465" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">하나의 입력 인수를 사용하고 하나의 출력을 리턴하여 함수를 호출하여 각 계산을 얻는 ufunc에 대한 유형별 핵심 1 차원 함수입니다. 이 함수는 &lt;code&gt;func&lt;/code&gt; 에 전달됩니다 . 문자는 지원되는 데이터 유형 ( &lt;code&gt;e&lt;/code&gt; - 반, &lt;code&gt;f&lt;/code&gt; -float, &lt;code&gt;d&lt;/code&gt; -double, &lt;code&gt;g&lt;/code&gt; -long double, &lt;code&gt;F&lt;/code&gt; -cfloat, &lt;code&gt;D&lt;/code&gt; -cdouble, &lt;code&gt;G&lt;/code&gt; -clongdouble)의 dtypechar에 해당합니다. &lt;em&gt;func&lt;/em&gt; 인수 는 동일한 서명을 지원해야합니다. _As_X_X 변형은 하나의 데이터 유형의 ndarray를 가정하지만 다른 데이터 유형을 취하는 기본 함수를 사용하도록 값을 캐스트합니다. 따라서 &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;데이터 유형 &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; 의 ndarray를 사용&lt;/a&gt; 하지만 double을 가져오고 double을 리턴하는 C 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="e494b69883a66d9ceddef7c995f1d4e3172789f0" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking one input argument and returning one output. This function is passed in &lt;code&gt;func&lt;/code&gt;. The letters correspond to dtypechar&amp;rsquo;s of the supported data types ( &lt;code&gt;e&lt;/code&gt; - half, &lt;code&gt;f&lt;/code&gt; - float, &lt;code&gt;d&lt;/code&gt; - double, &lt;code&gt;g&lt;/code&gt; - long double, &lt;code&gt;F&lt;/code&gt; - cfloat, &lt;code&gt;D&lt;/code&gt; - cdouble, &lt;code&gt;G&lt;/code&gt; - clongdouble). The argument &lt;em&gt;func&lt;/em&gt; must support the same signature. The _As_X_X variants assume ndarray&amp;rsquo;s of one data type but cast the values to use an underlying function that takes a different data type. Thus, &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt;&lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt;&lt;/a&gt; uses ndarrays of data type &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; but calls out to a C-function that takes double and returns double.</source>
          <target state="translated">하나의 입력 인수를 사용하고 하나의 출력을 반환하는 함수를 호출하여 각 계산을 얻는 ufuncs에 대한 유형별 핵심 1-d 함수입니다. 이 함수는 &lt;code&gt;func&lt;/code&gt; 로 전달됩니다 . 문자는 지원되는 데이터 유형의 dtypechar에 해당합니다 ( &lt;code&gt;e&lt;/code&gt; -half, &lt;code&gt;f&lt;/code&gt; -float, &lt;code&gt;d&lt;/code&gt; -double, &lt;code&gt;g&lt;/code&gt; -long double, &lt;code&gt;F&lt;/code&gt; -cfloat, &lt;code&gt;D&lt;/code&gt; -cdouble, &lt;code&gt;G&lt;/code&gt; -clongdouble). &lt;em&gt;func&lt;/em&gt; 인수 는 동일한 서명을 지원해야합니다. _As_X_X 변형은 ndarray가 하나의 데이터 유형이라고 가정하지만 다른 데이터 유형을 사용하는 기본 함수를 사용하도록 값을 캐스트합니다. 따라서 &lt;a href=&quot;#c.PyUFunc_f_f_As_d_d&quot;&gt; &lt;code&gt;PyUFunc_f_f_As_d_d&lt;/code&gt; &lt;/a&gt;NPY_FLOAT 데이터 유형의 &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 하지만 double을 취하고 double을 반환하는 C 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="2718d921f0c8c7bb73eed2147fee6ea79b6b6859" translate="yes" xml:space="preserve">
          <source>Type specific, core 1-d functions for ufuncs where each calculation is obtained by calling a function taking two input arguments and returning one output. The underlying function to call is passed in as &lt;em&gt;func&lt;/em&gt;. The letters correspond to dtypechar&amp;rsquo;s of the specific data type supported by the general-purpose function. The argument &lt;code&gt;func&lt;/code&gt; must support the corresponding signature. The &lt;code&gt;_As_XX_X&lt;/code&gt; variants assume ndarrays of one data type but cast the values at each iteration of the loop to use the underlying function that takes a different data type.</source>
          <target state="translated">두 개의 입력 인수를 사용하고 하나의 출력을 리턴하여 함수를 호출하여 각 계산을 얻는 ufunc에 대한 유형별 핵심 1 차원 함수입니다. 호출 할 기본 함수는 &lt;em&gt;func&lt;/em&gt; 로 전달됩니다 . 문자는 범용 함수가 지원하는 특정 데이터 유형의 dtypechar에 해당합니다. &lt;code&gt;func&lt;/code&gt; 인수 는 해당 서명을 지원해야합니다. &lt;code&gt;_As_XX_X&lt;/code&gt; 의 변종은 하나 개의 데이터 유형의 ndarrays을 가정하지만 다른 데이터 형식을 취하는 기본 기능을 사용하려면 루프의 각 반복에 값을 캐스팅.</target>
        </trans-unit>
        <trans-unit id="ef2ee12d948765f441a77e0dc116238b4eb26327" translate="yes" xml:space="preserve">
          <source>Type specifier strings are convertible to dtypes and can therefore be used instead of dtypes:</source>
          <target state="translated">유형 지정자 문자열은 dtypes로 변환 가능하므로 dtypes 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7df157385540da09117c232afd23b684eee205b" translate="yes" xml:space="preserve">
          <source>Type strings</source>
          <target state="translated">타입 문자열</target>
        </trans-unit>
        <trans-unit id="49d07ace07256156d179be0651876cfb45bce120" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">평균 계산에 사용할 유형입니다. 정수 입력의 경우 기본값은 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; 입니다&lt;/a&gt; . 부동 소수점 입력의 경우 입력 dtype과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3e254f683fcb738da4c686306a38d5b35595c5b4" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">평균 계산에 사용할 유형입니다. 정수 입력의 경우 기본값은 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; 입니다&lt;/a&gt; . 정확하지 않은 입력의 경우 입력 dtype과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b6e792a3d08a7bd144dac10e42edb461fd3dd2e3" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for floating point inputs, it is the same as the input dtype.</source>
          <target state="translated">평균 계산에 사용할 유형입니다. 정수 입력의 경우 기본값은 &lt;code&gt;float64&lt;/code&gt; 입니다 . 부동 소수점 입력의 경우 입력 dtype과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9f9df4fba8dcd1fb7d56164c04214c5a4ba9ba6b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the mean. For integer inputs, the default is &lt;code&gt;float64&lt;/code&gt;; for inexact inputs, it is the same as the input dtype.</source>
          <target state="translated">평균 계산에 사용할 유형입니다. 정수 입력의 경우 기본값은 &lt;code&gt;float64&lt;/code&gt; 입니다 . 부정확 한 입력의 경우 입력 dtype과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="3131a42adb40886f91b9db8d1e4f4fee7e5c8913" translate="yes" xml:space="preserve">
          <source>Type to use in computing the standard deviation. For arrays of integer type the default is float64, for arrays of float types it is the same as the array type.</source>
          <target state="translated">표준 편차 계산에 사용할 유형입니다. 정수 유형의 배열의 경우 기본값은 float64이고 부동 유형의 배열의 경우 배열 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="80e97dffa22c435830b854e8d6fb1c6cb57a1b46" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type</source>
          <target state="translated">분산 계산에 사용할 유형입니다. 정수형 배열의 경우</target>
        </trans-unit>
        <trans-unit id="af41caa041c2dd1ec692f185fc4f70fc76fd368b" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">분산 계산에 사용할 유형입니다. 정수형 배열의 경우 기본값은 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; 입니다&lt;/a&gt; . float 유형의 배열의 경우 배열 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="c52f694878c4817d9cf0e30a93a5ac5c826ca338" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float32&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">분산 계산에 사용할 유형입니다. 정수형 배열의 경우 기본값은 &lt;code&gt;float32&lt;/code&gt; 입니다 . 부동 유형의 배열의 경우 배열 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="251490cecef7141a0dccef6fed5a02c3f5f10907" translate="yes" xml:space="preserve">
          <source>Type to use in computing the variance. For arrays of integer type the default is &lt;code&gt;float64&lt;/code&gt;; for arrays of float types it is the same as the array type.</source>
          <target state="translated">분산 계산에 사용할 유형입니다. 정수형 배열의 경우 기본값은 &lt;code&gt;float64&lt;/code&gt; 입니다 . float 유형의 배열의 경우 배열 유형과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="9af8f14bd15271db0f113f7c146e7fa9294b1caa" translate="yes" xml:space="preserve">
          <source>TypeError</source>
          <target state="translated">TypeError</target>
        </trans-unit>
        <trans-unit id="d160c5845a8a77a5befb4851a7053d8bdf35eb94" translate="yes" xml:space="preserve">
          <source>Typecode or data-type to which the array is cast.</source>
          <target state="translated">배열이 캐스트되는 유형 코드 또는 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="41a5cdb8ef55e142306841748946bd3431f088b4" translate="yes" xml:space="preserve">
          <source>Typed versions of many of the &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; methods as well as the classes themselves can be accessed directly from Cython via</source>
          <target state="translated">여러 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 메서드 의 형식화 된 버전과 클래스 자체는 다음을 통해 Cython에서 직접 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="23cf72e69c01c79ece86b50f4bc0e1b659346558" translate="yes" xml:space="preserve">
          <source>Typemap conversions for complex floating-point types is also not supported automatically. This is because Python and NumPy are written in C, which does not have native complex types. Both Python and NumPy implement their own (essentially equivalent) &lt;code&gt;struct&lt;/code&gt; definitions for complex variables:</source>
          <target state="translated">복잡한 부동 소수점 유형에 대한 유형 맵 변환도 자동으로 지원되지 않습니다. 이는 Python과 NumPy가 C로 작성 되었기 때문에 기본 복합 유형이 없습니다. 파이썬과 NumPy는 모두 자신의 (본질적으로 동등한) &lt;code&gt;struct&lt;/code&gt; 구현합니다. 는 복잡한 변수에 대해 정의를 합니다.</target>
        </trans-unit>
        <trans-unit id="f2014cb40164abd5b9ac9cf3258c64ef343de062" translate="yes" xml:space="preserve">
          <source>Typemaps are keyed off a list of one or more function arguments, either by type or by type and name. We will refer to such lists as &lt;em&gt;signatures&lt;/em&gt;. One of the many typemaps defined by &lt;code&gt;numpy.i&lt;/code&gt; is used above and has the signature &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt;. The argument names are intended to suggest that the &lt;code&gt;double*&lt;/code&gt; argument is an input array of one dimension and that the &lt;code&gt;int&lt;/code&gt; represents the size of that dimension. This is precisely the pattern in the &lt;code&gt;rms&lt;/code&gt; prototype.</source>
          <target state="translated">유형 맵은 유형 또는 유형 및 이름별로 하나 이상의 함수 인수 목록에서 제외됩니다. 이러한 목록을 &lt;em&gt;서명&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; . &lt;code&gt;numpy.i&lt;/code&gt; 로 정의 된 많은 유형 맵 중 하나가 위에 사용되며 서명 &lt;code&gt;(double* IN_ARRAY1, int DIM1)&lt;/code&gt; 있습니다. 인수 이름은 &lt;code&gt;double*&lt;/code&gt; 인수가 한 차원의 입력 배열이고 &lt;code&gt;int&lt;/code&gt; 가 해당 차원의 크기를 나타냄을 의미합니다. 이것은 정확히 &lt;code&gt;rms&lt;/code&gt; 프로토 타입 의 패턴입니다 .</target>
        </trans-unit>
        <trans-unit id="93b9e289e2842469d001eccf7ad5d79f3c302dc9" translate="yes" xml:space="preserve">
          <source>Types</source>
          <target state="translated">Types</target>
        </trans-unit>
        <trans-unit id="908f34305dca26ca1d02c401b17bcc9125b1ab5c" translate="yes" xml:space="preserve">
          <source>Types with &lt;code&gt;.dtype&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;.dtype&lt;/code&gt; 이있는 유형</target>
        </trans-unit>
        <trans-unit id="9f433de3a09f2cf5cd13a827c57725457d725e39" translate="yes" xml:space="preserve">
          <source>Typical usage:</source>
          <target state="translated">일반적인 사용법 :</target>
        </trans-unit>
        <trans-unit id="e390f0c6d81411459ef6be418905b3473133c360" translate="yes" xml:space="preserve">
          <source>Typically a &amp;lsquo;greedy&amp;rsquo; algorithm is applied which empirical tests have shown returns the optimal path in the majority of cases. In some cases &amp;lsquo;optimal&amp;rsquo; will return the superlative path through a more expensive, exhaustive search. For iterative calculations it may be advisable to calculate the optimal path once and reuse that path by supplying it as an argument. An example is given below.</source>
          <target state="translated">일반적으로 경험적 테스트에서 대부분의 경우 최적의 경로를 반환하는 '욕심쟁이'알고리즘이 적용됩니다. 경우에 따라 '최적'은 더 비싸고 철저한 검색을 통해 최상의 경로를 반환합니다. 반복 계산의 경우 최적 경로를 한 번 계산하고 해당 경로를 인수로 제공하여 해당 경로를 재사용하는 것이 좋습니다. 아래에 예가 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="291bb923a1cf51e55db8c8127cc92200f5117732" translate="yes" xml:space="preserve">
          <source>Typically these new versions of the array metadata but the same data buffer are new &amp;lsquo;views&amp;rsquo; into the data buffer. There is a different ndarray object, but it uses the same data buffer. This is why it is necessary to force copies through use of the .copy() method if one really wants to make a new and independent copy of the data buffer.</source>
          <target state="translated">일반적으로 이러한 새로운 버전의 어레이 메타 데이터이지만 동일한 데이터 버퍼는 데이터 버퍼에 대한 새로운 '보기'입니다. 다른 ndarray 객체가 있지만 동일한 데이터 버퍼를 사용합니다. 그렇기 때문에 데이터 버퍼의 새롭고 독립적 인 복사본을 만들고자한다면 .copy () 메서드를 사용하여 복사본을 강제 실행해야합니다.</target>
        </trans-unit>
        <trans-unit id="54a23bec4dd6b17bf03f7139f1786ecb950b41b8" translate="yes" xml:space="preserve">
          <source>Typically this value will be one more than what you might expect because all ufuncs take the optional &amp;ldquo;out&amp;rdquo; argument.</source>
          <target state="translated">일반적으로이 값은 모든 ufunc가 선택적인&amp;ldquo;out&amp;rdquo;인수를 사용하기 때문에 예상했던 것보다 하나 더 높습니다.</target>
        </trans-unit>
        <trans-unit id="2db839a7e94204fc83aa9e6a4d27e6c5c452f385" translate="yes" xml:space="preserve">
          <source>Typically though, &lt;code&gt;self.min(axis=axis)&lt;/code&gt; is sufficient.</source>
          <target state="translated">일반적으로 &lt;code&gt;self.min(axis=axis)&lt;/code&gt; 이면 충분합니다.</target>
        </trans-unit>
        <trans-unit id="32606a7a80aee72f839ad47d7de51922ee1b0957" translate="yes" xml:space="preserve">
          <source>Typically you get a new reference to a variable when it is created or is the return value of some function (there are some prominent exceptions, however &amp;mdash; such as getting an item out of a tuple or a dictionary). When you own the reference, you are responsible to make sure that &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; (var) is called when the variable is no longer necessary (and no other function has &amp;ldquo;stolen&amp;rdquo; its reference). Also, if you are passing a Python object to a function that will &amp;ldquo;steal&amp;rdquo; the reference, then you need to make sure you own it (or use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; to get your own reference). You will also encounter the notion of borrowing a reference. A function that borrows a reference does not alter the reference count of the object and does not expect to &amp;ldquo;hold on &amp;ldquo;to the reference. It&amp;rsquo;s just going to use the object temporarily. When you use &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt;&lt;code&gt;PyArg_UnpackTuple&lt;/code&gt;&lt;/a&gt; you receive a borrowed reference to the objects in the tuple and should not alter their reference count inside your function. With practice, you can learn to get reference counting right, but it can be frustrating at first.</source>
          <target state="translated">일반적으로 변수가 생성 될 때 새로운 참조를 얻거나 일부 함수의 반환 값입니다 (그러나 튜플이나 사전에서 항목을 가져 오는 것과 같은 몇 가지 두드러진 예외가 있습니다). 참조를 소유 할 때 변수가 더 이상 필요하지 않을 때 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; (var)가 호출 되는지 확인해야합니다 (다른 함수가 참조를 &quot;도난&quot;하지 않음). 또한 참조를 &quot;훔치는&quot;함수에 Python 객체를 전달하는 경우 해당 객체를 소유하고 있는지 확인해야합니다 (또는 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오).자신의 참조를 얻으려면). 또한 참조를 빌리는 개념을 접하게 될 것입니다. 참조를 차용하는 함수는 객체의 참조 횟수를 변경하지 않으며 참조를 &quot;유지&quot;할 것으로 예상하지 않습니다. 객체를 일시적으로 사용할 것입니다. &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_UnpackTuple&quot;&gt; &lt;code&gt;PyArg_UnpackTuple&lt;/code&gt; &lt;/a&gt; 을 사용 하면 튜플의 객체에 대한 차용 참조를 받게되며 함수 내에서 참조 횟수를 변경해서는 안됩니다. 연습을 통해 참조 횟수를 올바르게 계산하는 방법을 배울 수 있지만 처음에는 실망 스러울 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3fadc3f723273062c4d9c5a6483a39eed14f9c66" translate="yes" xml:space="preserve">
          <source>Typically, the size of all core dimensions in an output will be determined by the size of a core dimension with the same label in an input array. This is not a requirement, and it is possible to define a signature where a label comes up for the first time in an output, although some precautions must be taken when calling such a function. An example would be the function &lt;code&gt;euclidean_pdist(a)&lt;/code&gt;, with signature &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt;, that given an array of &lt;code&gt;n&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;-dimensional vectors, computes all unique pairwise Euclidean distances among them. The output dimension &lt;code&gt;p&lt;/code&gt; must therefore be equal to &lt;code&gt;n * (n - 1) / 2&lt;/code&gt;, but it is the caller&amp;rsquo;s responsibility to pass in an output array of the right size. If the size of a core dimension of an output cannot be determined from a passed in input or output array, an error will be raised.</source>
          <target state="translated">일반적으로 출력의 모든 코어 치수의 크기는 입력 배열에서 동일한 레이블이있는 코어 치수의 크기에 의해 결정됩니다. 이것은 필수 사항이 아니며, 출력에서 ​​레이블이 처음으로 나타나는 시그니처를 정의 할 수 있지만 이러한 함수를 호출 할 때 일부 예방 조치를 취해야합니다. 예를 들어 , 서명 &lt;code&gt;(n,d)-&amp;gt;(p)&lt;/code&gt; 를 가진 함수 &lt;code&gt;euclidean_pdist(a)&lt;/code&gt; 는 &lt;code&gt;n&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; 차원 벡터 의 배열이 주어지면 그들 사이의 모든 고유 쌍별 유클리드 거리를 계산합니다. 따라서 출력 치수 &lt;code&gt;p&lt;/code&gt; 는 &lt;code&gt;n * (n - 1) / 2&lt;/code&gt; 그러나 올바른 크기의 출력 배열을 전달하는 것은 호출자의 책임입니다. 전달 된 입력 또는 출력 배열에서 출력의 코어 치수 크기를 결정할 수없는 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="81f4149c1a20e72abefc686a48b22d01b3176b3b" translate="yes" xml:space="preserve">
          <source>Typing (&lt;code&gt;numpy.typing&lt;/code&gt;)</source>
          <target state="translated">입력 ( &lt;code&gt;numpy.typing&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="59adc3948a7b50794673f56a730ed1dc08703d52" translate="yes" xml:space="preserve">
          <source>Typing (numpy.typing)</source>
          <target state="translated">타이핑 (numpy.typing)</target>
        </trans-unit>
        <trans-unit id="b2c7c0caa10a0cca5ea7d69e54018ae0c0389dd6" translate="yes" xml:space="preserve">
          <source>U</source>
          <target state="translated">U</target>
        </trans-unit>
        <trans-unit id="c093fd2ae7a1b6c1d5d85e7bc3cb2abb1cfc0cb0" translate="yes" xml:space="preserve">
          <source>UC Berkeley (St&amp;eacute;fan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</source>
          <target state="translated">UC 버클리 (St&amp;eacute;fan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</target>
        </trans-unit>
        <trans-unit id="f1bad5a5addf87c78243a0908ff2f26f2b5c976f" translate="yes" xml:space="preserve">
          <source>UC Berkeley (Stefan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</source>
          <target state="translated">UC 버클리 (Stefan van der Walt, Sebastian Berg, Warren Weckesser, Ross Barnowski)</target>
        </trans-unit>
        <trans-unit id="054ec2a1c571b996a33a40629d7bbd3a2c7c7a03" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_ERROR()</source>
          <target state="translated">UFUNC_CHECK_ERROR()</target>
        </trans-unit>
        <trans-unit id="d2291265ceb8694acf9ebd2a0083ea66791f6665" translate="yes" xml:space="preserve">
          <source>UFUNC_CHECK_STATUS()</source>
          <target state="translated">UFUNC_CHECK_STATUS()</target>
        </trans-unit>
        <trans-unit id="7c45c7778c0f3c31bbfb06962ea0f2b3d024a473" translate="yes" xml:space="preserve">
          <source>UFUNC_ERR_{HANDLER}</source>
          <target state="translated">UFUNC_ERR_{HANDLER}</target>
        </trans-unit>
        <trans-unit id="46518eb931ec8d24ef410f576a7160b8b457bb69" translate="yes" xml:space="preserve">
          <source>UFunc API</source>
          <target state="translated">UFunc API</target>
        </trans-unit>
        <trans-unit id="779cd7c4bcd3367298526e617162cab51fe8f735" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY (U) (deprecated), replaced by WRITEBACKIFCOPY;</source>
          <target state="translated">UPDATEIFCOPY (U) (더 이상 사용되지 않음)로 WRITEBACKIFCOPY로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="4eab2a5ea17917129ec8fa19b15a7cfda3fe1d46" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY / U</source>
          <target state="translated">업데이트 / U</target>
        </trans-unit>
        <trans-unit id="8c955f87125d1d07da79b0f8b10f03f3519e41af" translate="yes" xml:space="preserve">
          <source>UPDATEIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">UPDATEIFCOPY는 &lt;code&gt;False&lt;/code&gt; 로만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7033cb6e00b408f93174a1cb4dc874e5ec8f4436" translate="yes" xml:space="preserve">
          <source>URLs require a scheme string (&lt;code&gt;http://&lt;/code&gt;) to be used, without it they will fail:</source>
          <target state="translated">URL을 사용하려면 스키마 문자열 ( &lt;code&gt;http://&lt;/code&gt; )을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="76298f39f520148528f0c1a12443b1e9a612a67d" translate="yes" xml:space="preserve">
          <source>Ufunc API</source>
          <target state="translated">Ufunc API</target>
        </trans-unit>
        <trans-unit id="07fbda00eaafb6ceaaf8098d7abd7adf2f3fa665" translate="yes" xml:space="preserve">
          <source>Ufunc behavior for overlapping inputs</source>
          <target state="translated">중복 입력에 대한 Ufunc 동작</target>
        </trans-unit>
        <trans-unit id="01787e5708f1880517c980a345514f0ac0d4f3a1" translate="yes" xml:space="preserve">
          <source>Ufuncs allow other array-like classes to be passed seamlessly through the interface in that inputs of a particular class will induce the outputs to be of that same class. The mechanism by which this works is the following. If any of the inputs are not ndarrays and define the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, then the class with the largest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; attribute determines the type of all the outputs (with the exception of any output arrays passed in). The &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method of the input array will be called with the ndarray being returned from the ufunc as it&amp;rsquo;s input. There are two calling styles of the &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; function supported. The first takes the ndarray as the first argument and a tuple of &amp;ldquo;context&amp;rdquo; as the second argument. The context is (ufunc, arguments, output argument number). This is the first call tried. If a TypeError occurs, then the function is called with just the ndarray as the first argument.</source>
          <target state="translated">Ufuncs를 사용하면 특정 배열의 입력이 동일한 클래스의 출력을 유도한다는 점에서 다른 배열과 유사한 클래스를 인터페이스를 통해 원활하게 전달할 수 있습니다. 이것이 작동하는 메커니즘은 다음과 같습니다. 입력 중 ndarrays 아닌 상기 정의하면 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; 의&lt;/a&gt; 방법을, 다음으로 큰 클래스 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 특성 (전달 모든 출력 어레이를 제외한) 모든 출력의 유형을 결정한다. 입력 배열 의 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 메소드는 입력으로 ufunc에서 ndarray를 반환하여 호출됩니다. &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 에는 두 가지 호출 스타일이 있습니다.기능 지원. 첫 번째는 ndarray를 첫 번째 인수로 사용하고&amp;ldquo;context&amp;rdquo;의 튜플을 두 번째 인수로 사용합니다. 컨텍스트는 (ufunc, arguments, output argument number)입니다. 시도한 첫 번째 전화입니다. TypeError가 발생하면 첫 번째 인수로 ndarray 만 사용하여 함수가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="bb1e7beaee60184f94b2766ad490881fcda15d1a" translate="yes" xml:space="preserve">
          <source>Ufuncs also have a fifth method that allows in place operations to be performed using fancy indexing. No buffering is used on the dimensions where fancy indexing is used, so the fancy index can list an item more than once and the operation will be performed on the result of the previous operation for that item.</source>
          <target state="translated">Ufuncs에는 멋진 인덱스를 사용하여 적절한 작업을 수행 할 수있는 다섯 번째 방법도 있습니다. 팬시 색인 작성이 사용되는 차원에는 버퍼링이 사용되지 않으므로, 팬시 색인은 항목을 두 번 이상 나열 할 수 있으며 해당 항목에 대한 이전 조작의 결과에 대해 조작이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ebe1370731077d311895107006a4816f68d36e75" translate="yes" xml:space="preserve">
          <source>Ufuncs: If the &lt;code&gt;ALIGNED&lt;/code&gt; flag of an array is False, ufuncs will buffer/cast the array before evaluation. This is needed since ufunc inner loops access raw elements directly, which might fail on some archs if the elements are not true-aligned.</source>
          <target state="translated">Ufuncs : 배열 의 &lt;code&gt;ALIGNED&lt;/code&gt; 플래그가 False이면 ufuncs는 평가 전에 배열을 버퍼링 / 캐스트합니다. 이것은 ufunc 내부 루프가 원시 요소에 직접 액세스하기 때문에 필요합니다. 요소가 실제로 정렬되지 않으면 일부 아치에서 실패 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781ffa6fd9f0234942bb6847c5bb2f8924769498" translate="yes" xml:space="preserve">
          <source>Umath and multiarray c-extension modules merged into a single module</source>
          <target state="translated">단일 모듈로 병합 된 Umath 및 다중 어레이 c- 확장 모듈</target>
        </trans-unit>
        <trans-unit id="52313eed90dffcad6d336fc2df812a51c07afa3f" translate="yes" xml:space="preserve">
          <source>Un-sized flexible data-type objects do not have this attribute.</source>
          <target state="translated">크기가 조정되지 않은 유연한 데이터 형식 개체에는이 특성이 없습니다.</target>
        </trans-unit>
        <trans-unit id="b7fcaea31c03023df34e5b7b17cd0d3a054b94c0" translate="yes" xml:space="preserve">
          <source>Unary operations:</source>
          <target state="translated">단항 연산 :</target>
        </trans-unit>
        <trans-unit id="eb11f871299eef811cd072499c803b05b282a2bf" translate="yes" xml:space="preserve">
          <source>Under certain conditions, &lt;code&gt;nditer&lt;/code&gt; must be used in a context manager</source>
          <target state="translated">특정 조건에서 &lt;code&gt;nditer&lt;/code&gt; 는 컨텍스트 관리자에서 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="a813a893f115799fcd0b6f6dee8828d16c00cb4d" translate="yes" xml:space="preserve">
          <source>Under-the-hood Documentation for developers</source>
          <target state="translated">개발자를위한 내부 문서</target>
        </trans-unit>
        <trans-unit id="ee256bb7a636957391cc28f26fc314ab3aeba52b" translate="yes" xml:space="preserve">
          <source>Under-the-hood docs</source>
          <target state="translated">Under-the-hood 문서</target>
        </trans-unit>
        <trans-unit id="56332d95dfcc595c6bea8676636a72713f221f0a" translate="yes" xml:space="preserve">
          <source>Underflow: result so close to zero that some precision was lost.</source>
          <target state="translated">언더 플로 : 결과가 0에 가까워 일부 정밀도가 손실되었습니다.</target>
        </trans-unit>
        <trans-unit id="59c608e219e1ef1b3832d726571dbc3af32612af" translate="yes" xml:space="preserve">
          <source>Understand axis and shape properties for n-dimensional arrays.</source>
          <target state="translated">n 차원 배열의 축 및 모양 속성을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="cd6d50dccc320b7b45e093ddb7f7dd61e7e784a1" translate="yes" xml:space="preserve">
          <source>Understand how to access and modify data for masked arrays</source>
          <target state="translated">마스킹 된 배열에 대한 데이터 액세스 및 수정 방법 이해</target>
        </trans-unit>
        <trans-unit id="7a82cdb76fef36e8a84963b1363d0b9e06ddc672" translate="yes" xml:space="preserve">
          <source>Understand how to apply some linear algebra operations to n-dimensional arrays without using for-loops;</source>
          <target state="translated">for 루프를 사용하지 않고 몇 가지 선형 대수 연산을 n 차원 배열에 적용하는 방법을 이해합니다.</target>
        </trans-unit>
        <trans-unit id="c54944247198ee020e57c96492a8adaa8f1c26ce" translate="yes" xml:space="preserve">
          <source>Understand the difference between one-, two- and n-dimensional arrays in NumPy;</source>
          <target state="translated">NumPy에서 1 차원, 2 차원 및 n 차원 배열의 차이점을 이해하십시오.</target>
        </trans-unit>
        <trans-unit id="0ac405cd12d1e61ef3ec9ed67b16e321b2ef49d7" translate="yes" xml:space="preserve">
          <source>Understand what are masked arrays and how they can be created</source>
          <target state="translated">마스킹 된 배열의 정의와 생성 방법 이해</target>
        </trans-unit>
        <trans-unit id="64abb06a1b37c1ebb0933941a714064fe78f5ee7" translate="yes" xml:space="preserve">
          <source>Understanding CPU Dispatching, How the NumPy dispatcher works?</source>
          <target state="translated">CPU 디스패치 이해, NumPy 디스패처 작동 방식</target>
        </trans-unit>
        <trans-unit id="233fa68a512b31fd9c7e11c16b1a271f55f3bf8e" translate="yes" xml:space="preserve">
          <source>Understanding the code &amp;amp; getting started</source>
          <target state="translated">코드 이해 및 시작</target>
        </trans-unit>
        <trans-unit id="de8fa4e24f45bc650b9e48b7af77833b4a2c462a" translate="yes" xml:space="preserve">
          <source>Undoes &lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt;&lt;code&gt;fftshift&lt;/code&gt;&lt;/a&gt;, shifts zero-frequency terms to beginning of array.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fftshift#numpy.fft.fftshift&quot;&gt; &lt;code&gt;fftshift&lt;/code&gt; 를&lt;/a&gt; 취소하고 주파수가 0 인 용어를 배열의 시작으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="9ab0bd9a6126ee4b9d7538d5c6cba7aa587f31ed" translate="yes" xml:space="preserve">
          <source>Unicode</source>
          <target state="translated">Unicode</target>
        </trans-unit>
        <trans-unit id="4fee0b7959c07c12abdb6224e31004ed0e03fe8f" translate="yes" xml:space="preserve">
          <source>Unicode (fixed-length sequence of &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt;&lt;code&gt;Py_UNICODE&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">유니 코드 ( &lt;a href=&quot;https://docs.python.org/dev/c-api/unicode.html#c.Py_UNICODE&quot;&gt; &lt;code&gt;Py_UNICODE&lt;/code&gt; 의&lt;/a&gt; 고정 길이 시퀀스 )</target>
        </trans-unit>
        <trans-unit id="1b41da839119c4860ed2bab536f19149822ad0f7" translate="yes" xml:space="preserve">
          <source>Unicode string</source>
          <target state="translated">유니 코드 문자열</target>
        </trans-unit>
        <trans-unit id="b817c790c0e1eb2da135f6728ba7e7a734d36d2a" translate="yes" xml:space="preserve">
          <source>Uniforms</source>
          <target state="translated">Uniforms</target>
        </trans-unit>
        <trans-unit id="bd181d4ea0c5f747e6be59067008be3f6a568280" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt;&lt;code&gt;integers&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">유니폼 ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.random.generator.integers#numpy.random.Generator.integers&quot;&gt; &lt;code&gt;integers&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="e9cccdf4596cb9bd6da09d86e9aec754328ad900" translate="yes" xml:space="preserve">
          <source>Uniforms (&lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">유니폼 ( &lt;a href=&quot;generated/numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="2697f04d1c34bc0fd003a5d4f2f248be3c9842cb" translate="yes" xml:space="preserve">
          <source>Union types</source>
          <target state="translated">유니온 유형</target>
        </trans-unit>
        <trans-unit id="7d19a005048195442e1a0367112ec40ef36c8dd2" translate="yes" xml:space="preserve">
          <source>Unique, sorted union of the input arrays.</source>
          <target state="translated">입력 배열의 고유 한 정렬 조합.</target>
        </trans-unit>
        <trans-unit id="76a96316e226896e4f1438a10bfe2c7d74733b0a" translate="yes" xml:space="preserve">
          <source>Unit Conversion</source>
          <target state="translated">단위 변환</target>
        </trans-unit>
        <trans-unit id="2b379c9399e276f2dc8f9383decfb02923fa06dd" translate="yes" xml:space="preserve">
          <source>Unitary array(s). The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;. The size of the last two dimensions depends on the value of &lt;code&gt;full_matrices&lt;/code&gt;. Only returned when &lt;code&gt;compute_uv&lt;/code&gt; is True.</source>
          <target state="translated">단일 배열. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원은 입력 &lt;code&gt;a&lt;/code&gt; 와 크기가 같습니다 . 마지막 두 차원의 크기는 &lt;code&gt;full_matrices&lt;/code&gt; 값에 따라 다릅니다 . &lt;code&gt;compute_uv&lt;/code&gt; 가 True 인 경우에만 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="89952e170b7f249d54c02c56dc948ea92d581887" translate="yes" xml:space="preserve">
          <source>Universal Functions</source>
          <target state="translated">범용 함수</target>
        </trans-unit>
        <trans-unit id="7d5959424165b0a7771ddfd877626852ebcf0b02" translate="yes" xml:space="preserve">
          <source>Universal function. A fast element-wise, &lt;a href=&quot;#term-vectorization&quot;&gt;vectorized&lt;/a&gt; array operation. Examples include &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;sin&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt;.</source>
          <target state="translated">범용 기능. 빠른 요소 별 &lt;a href=&quot;#term-vectorization&quot;&gt;벡터화 된&lt;/a&gt; 배열 연산입니다. 예로는 &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;sin&lt;/code&gt; 및 &lt;code&gt;logical_or&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c4ed03ac8db5e6ac9dfa92939a06553bcbad44ab" translate="yes" xml:space="preserve">
          <source>Universal functions</source>
          <target state="translated">범용 기능</target>
        </trans-unit>
        <trans-unit id="e3950ded82824788c1d59c1dc67f67776133fd02" translate="yes" xml:space="preserve">
          <source>Universal functions (&lt;code&gt;ufunc&lt;/code&gt;)</source>
          <target state="translated">범용 함수 ( &lt;code&gt;ufunc&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="825ac503579fb05389d22b5b4afa49b44dc3e914" translate="yes" xml:space="preserve">
          <source>Universal functions (ufunc)</source>
          <target state="translated">범용 함수 (ufunc)</target>
        </trans-unit>
        <trans-unit id="1c8ff35a75bf6e5497766666bbe2a77eb53892e4" translate="yes" xml:space="preserve">
          <source>Universal functions are callable objects that take</source>
          <target state="translated">범용 함수는 호출 가능한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="14ef4c614fdbba7fe91a08e7e1d79eb5845cd489" translate="yes" xml:space="preserve">
          <source>Universal functions can trip special floating-point status registers in your hardware (such as divide-by-zero). If available on your platform, these registers will be regularly checked during calculation. Error handling is controlled on a per-thread basis, and can be configured using the functions</source>
          <target state="translated">범용 함수는 하드웨어의 특수 부동 소수점 상태 레지스터를 트립 할 수 있습니다 (예 : 0으로 나누기). 플랫폼에서 사용 가능한 경우 이러한 레지스터는 계산 중에 정기적으로 확인됩니다. 오류 처리는 스레드별로 제어되며 기능을 사용하여 구성 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="f2a6f922fe59febd69c7ec0550beca70f253abf6" translate="yes" xml:space="preserve">
          <source>Universal functions in NumPy are flexible enough to have mixed type signatures. Thus, for example, a universal function could be defined that works with floating-point and integer values. See &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt;&lt;code&gt;ldexp&lt;/code&gt;&lt;/a&gt; for an example.</source>
          <target state="translated">NumPy의 범용 함수는 혼합 유형 서명을 가질 수있을만큼 유연합니다. 따라서 예를 들어 부동 소수점 및 정수 값으로 작동하는 범용 함수를 정의 할 수 있습니다. 예제는 &lt;a href=&quot;generated/numpy.ldexp#numpy.ldexp&quot;&gt; &lt;code&gt;ldexp&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3933468b1ecf18729ecddd910fc6819434f5cf58" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;numpy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;numpy.test(label='full')&lt;/code&gt; run, you can label it with &lt;code&gt;pytest.mark.slow&lt;/code&gt;:</source>
          <target state="translated">위와 같이 라벨이없는 테스트는 기본 &lt;code&gt;numpy.test()&lt;/code&gt; 실행에서 실행됩니다. 테스트를 느리게 레이블을 지정하여 전체 &lt;code&gt;numpy.test(label='full')&lt;/code&gt; 실행을 위해 예약 하려면 &lt;code&gt;pytest.mark.slow&lt;/code&gt; 로 레이블을 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dc2928ef9066faa49b65eacee08cc9ff5b8df03a" translate="yes" xml:space="preserve">
          <source>Unlabeled tests like the ones above are run in the default &lt;code&gt;scipy.test()&lt;/code&gt; run. If you want to label your test as slow - and therefore reserved for a full &lt;code&gt;scipy.test(label='full')&lt;/code&gt; run, you can label it with a decorator:</source>
          <target state="translated">위와 같은 레이블이없는 테스트는 기본 &lt;code&gt;scipy.test()&lt;/code&gt; 실행에서 실행됩니다. 테스트에 느린 레이블을 지정하고 전체 &lt;code&gt;scipy.test(label='full')&lt;/code&gt; 실행을 위해 예약 하려면 데코레이터로 레이블을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f80a919f246626907387dd0726bbe89b8b51b4df" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.char.chararray.copy#numpy.char.chararray.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7dd27d4664eeedf99baaa7e0c49db6deaa478b" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5fb1f8307f01c7e357482bf17ec2115ae4f2033" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd72f00597798516e6971a2dbcb92a29bbbdaed9" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; is False and the other conditions for returning the input array are satisfied (see description for &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt; input parameter), &lt;code&gt;arr_t&lt;/code&gt; is a new array of the same shape as the input array, with dtype, order given by &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">않는 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; (설명 참조 거짓이고 입력 배열을 반환하기위한 다른 조건을 만족 &lt;a href=&quot;numpy.ma.copy#numpy.ma.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 입력 파라미터)를 &lt;code&gt;arr_t&lt;/code&gt; DTYPE 의해 주어진 순서로 입력 배열과 같은 형태의 새로운 배열이다 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e2517e50c2cd18f9fa374a65d4b11b6882475bf" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;refcheck&lt;/code&gt; is False:</source>
          <target state="translated">&lt;code&gt;refcheck&lt;/code&gt; 이 거짓이 아닌 한 :</target>
        </trans-unit>
        <trans-unit id="5c06c023a0677199fe16b8704d88475521f3247a" translate="yes" xml:space="preserve">
          <source>Unless NumPy is made aware of an issue with this, this function is scheduled for rapid removal without replacement.</source>
          <target state="translated">NumPy가이 문제를 인식하지 않는 한,이 기능은 교체없이 신속하게 제거 될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="b12a052540dd37bc0bf5e60cc41fc32cdcbd4cfa" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt;&lt;code&gt;numpy.equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.equal#numpy.equal&quot;&gt; &lt;code&gt;numpy.equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6b2b2c64bbd5177dd4a58ffb6ba3be3f39244e9c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt;&lt;code&gt;fftfreq&lt;/code&gt;&lt;/a&gt; (but like &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt;&lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt;&lt;/a&gt;) the Nyquist frequency component is considered to be positive.</source>
          <target state="translated">달리 &lt;a href=&quot;numpy.fft.fftfreq#numpy.fft.fftfreq&quot;&gt; &lt;code&gt;fftfreq&lt;/code&gt; &lt;/a&gt; (그러나 같은 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.fftpack.rfftfreq.html#scipy.fftpack.rfftfreq&quot;&gt; &lt;code&gt;scipy.fftpack.rfftfreq&lt;/code&gt; &lt;/a&gt; ) Nyquist 주파수 성분은 긍정적 인 것으로 간주된다.</target>
        </trans-unit>
        <trans-unit id="5f3a2cd1365b2531abc2f011c55c5607d024f719" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt;&lt;code&gt;numpy.greater&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.greater#numpy.greater&quot;&gt; &lt;code&gt;numpy.greater&lt;/code&gt; &lt;/a&gt; 와 달리 ,이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8db96ae1e185ea43483bbcf2e2a064fdf5d5ac53" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt;&lt;code&gt;numpy.greater_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.greater_equal#numpy.greater_equal&quot;&gt; &lt;code&gt;numpy.greater_equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cc98934fa39c9d5a378edf27cd9d3fdf09aca64f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt;&lt;code&gt;numpy.less_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.less_equal#numpy.less_equal&quot;&gt; &lt;code&gt;numpy.less_equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="13463cefef0c63fb378a22fb3869ee59d3559110" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; 는&lt;/a&gt; 입력이 이미 행렬 또는 ndarray 경우 복사를하지 않는다. 상당 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0d5bc239c5d20908848ae252443d0a4e4413dd3" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt;&lt;code&gt;asmatrix&lt;/code&gt;&lt;/a&gt; does not make a copy if the input is already a matrix or an ndarray. Equivalent to &lt;code&gt;matrix(data, copy=False)&lt;/code&gt;.</source>
          <target state="translated">달리 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.asmatrix#numpy.asmatrix&quot;&gt; &lt;code&gt;asmatrix&lt;/code&gt; 는&lt;/a&gt; 입력이 이미 행렬 또는 ndarray 경우 복사를하지 않는다. 상당 &lt;code&gt;matrix(data, copy=False)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5b1299452ddecaa69fc7626dc84ab62f7aec6df" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt;&lt;code&gt;numpy.not_equal&lt;/code&gt;&lt;/a&gt;, this comparison is performed by first stripping whitespace characters from the end of the string. This behavior is provided for backward-compatibility with numarray.</source>
          <target state="translated">&lt;a href=&quot;numpy.not_equal#numpy.not_equal&quot;&gt; &lt;code&gt;numpy.not_equal&lt;/code&gt; &lt;/a&gt; 과 달리이 비교는 먼저 문자열 끝에서 공백 문자를 제거하여 수행됩니다. 이 동작은 numarray와의 하위 호환성을 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="67d52aad6ea0dc9937241f5063f5755aaf1c098a" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt;, each slice along the given axis is shuffled independently of the others.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; 과 달리 주어진 축을 따라 각 슬라이스 는 다른 슬라이스와 독립적으로 셔플됩니다.</target>
        </trans-unit>
        <trans-unit id="1df4f0edb26736c54c37d1f3f53f3c4e05be97d2" translate="yes" xml:space="preserve">
          <source>Unlike MATLAB&amp;reg;, where anything on your path can be called immediately, with Python you need to first do an &amp;lsquo;import&amp;rsquo; statement to make functions in a particular file accessible.</source>
          <target state="translated">경로의 모든 항목을 즉시 호출 할 수있는 MATLAB&amp;reg;과 달리 Python에서는 먼저 'import'문을 수행하여 특정 파일의 함수에 액세스 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="5e87736758d47e2ea2a3e97a051391d1169b07f7" translate="yes" xml:space="preserve">
          <source>Unlike MATLAB, where anything on your path can be called immediately, with Python you need to first do an &amp;lsquo;import&amp;rsquo; statement to make functions in a particular file accessible.</source>
          <target state="translated">경로의 모든 항목을 즉시 호출 할 수있는 MATLAB과 달리 Python에서는 먼저 'import'문을 수행하여 특정 파일의 함수에 액세스 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="dd2a67552682e7936714b3e48fc7203a2e15901a" translate="yes" xml:space="preserve">
          <source>Unlike in many matrix languages, the product operator &lt;code&gt;*&lt;/code&gt; operates elementwise in NumPy arrays. The matrix product can be performed using the &lt;code&gt;@&lt;/code&gt; operator (in python &amp;gt;=3.5) or the &lt;code&gt;dot&lt;/code&gt; function or method:</source>
          <target state="translated">많은 행렬 언어와 달리 product 연산자 &lt;code&gt;*&lt;/code&gt; 는 NumPy 배열에서 요소별로 작동합니다. 행렬 곱은 &lt;code&gt;@&lt;/code&gt; 연산자 (python&amp;gt; = 3.5) 또는 &lt;code&gt;dot&lt;/code&gt; 함수 또는 방법을 사용하여 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="991d558a10f3fed386601ea572b9a25a236458aa" translate="yes" xml:space="preserve">
          <source>Unlike in the case of integer index arrays, in the boolean case, the result is a 1-D array containing all the elements in the indexed array corresponding to all the true elements in the boolean array. The elements in the indexed array are always iterated and returned in &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; (C-style) order. The result is also identical to &lt;code&gt;y[np.nonzero(b)]&lt;/code&gt;. As with index arrays, what is returned is a copy of the data, not a view as one gets with slices.</source>
          <target state="translated">정수 인덱스 배열의 경우와 달리 부울의 경우 결과는 부울 배열의 모든 실제 요소에 해당하는 인덱스 배열의 모든 요소를 ​​포함하는 1 차원 배열입니다. 인덱스 배열의 요소는 항상 반복되고 &lt;a href=&quot;../glossary#term-row-major&quot;&gt;행&lt;/a&gt; 우선 (C 스타일) 순서 로 반환됩니다 . 결과는 &lt;code&gt;y[np.nonzero(b)]&lt;/code&gt; 동일합니다 . 인덱스 배열과 마찬가지로 반환되는 것은 슬라이스로 가져 오는 뷰가 아니라 데이터의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="9b9e6d341e111d5abaa8c91d594d12353e24be13" translate="yes" xml:space="preserve">
          <source>Unlike lists and tuples, numpy arrays support multidimensional indexing for multidimensional arrays. That means that it is not necessary to separate each dimension&amp;rsquo;s index into its own set of square brackets.</source>
          <target state="translated">목록 및 튜플과 달리 numpy 배열은 다차원 배열에 대한 다차원 인덱싱을 지원합니다. 즉, 각 차원의 인덱스를 자체 대괄호 집합으로 분리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="70d4d959a48f1152d15702553262318c5fb98806" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Chebyshev 계열의 차이는 Chebyshev 계열 (결과를 기본 집합에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 빼기가 단순히 &quot;구성 요소 별&quot;입니다. &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="e46cc304c2f214fabbfe81dd6c99872edb6df227" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리, 두 Hermite 계열의 차이점은 Hermite 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 빼기는 단순히&amp;ldquo;구성 요소 별&amp;rdquo;입니다. &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="0beee9ca9d008b84130a4966827a4791db0f0fc1" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Laguerre 계열의 차이는 Laguerre 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 빼기는 단순히&amp;ldquo;구성 요소 별&amp;rdquo;입니다 &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="853913b39ae1eac706caf9dd0fbf8022480e5898" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the difference of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so subtraction, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Legendre 시리즈의 차이점은 Legendre 시리즈 (결과를 기본 세트에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 빼기가 단순히 &quot;구성 요소 별&quot;입니다. &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="817c653b37e40c515ff2966447fe5fceb6d50c2b" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Chebyshev series is a Chebyshev series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Chebyshev 계열의 합은 Chebyshev 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 단순히&amp;ldquo;구성 요소 별&amp;rdquo; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="96e94bebc99e72aa93e0ba2b3e9d976f9a242788" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Hermite series is a Hermite series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Hermite 계열의 합은 Hermite 계열 (결과를 기본 집합에 &quot;재 투영&quot;할 필요가 없음)이므로 &quot;표준&quot;다항식과 마찬가지로 간단히 &quot;구성 요소 별&quot; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a1bfae60ca127fe23c05d0fcb5e3af8c025e808e" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Laguerre series is a Laguerre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리, 두 개의 Laguerre 계열의 합은 Laguerre 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 간단히&amp;ldquo;구성 요소 별&amp;rdquo; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="479fccdc37cae736330d681081d02fd22d2b4c05" translate="yes" xml:space="preserve">
          <source>Unlike multiplication, division, etc., the sum of two Legendre series is a Legendre series (without having to &amp;ldquo;reproject&amp;rdquo; the result onto the basis set) so addition, just like that of &amp;ldquo;standard&amp;rdquo; polynomials, is simply &amp;ldquo;component-wise.&amp;rdquo;</source>
          <target state="translated">곱셈, 나눗셈 등과는 달리 두 Legendre 계열의 합은 Legendre 계열 (결과를 기본 집합에&amp;ldquo;재 투영&amp;rdquo;할 필요가 없음)이므로&amp;ldquo;표준&amp;rdquo;다항식과 마찬가지로 간단히&amp;ldquo;구성 요소 별&amp;rdquo; &amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="c37836d2f2fa6578d699e351ca0672a2d96cc650" translate="yes" xml:space="preserve">
          <source>Unlike other numpy scalars, structured scalars are mutable and act like views into the original array, such that modifying the scalar will modify the original array. Structured scalars also support access and assignment by field name:</source>
          <target state="translated">다른 numpy 스칼라와 달리 구조화 된 스칼라는 변경 가능하고 원래 배열에 대한 뷰처럼 ​​작동하므로 스칼라를 수정하면 원래 배열이 수정됩니다. 구조화 된 스칼라는 또한 필드 이름 별 액세스 및 할당을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="191384b28da289c339b69142c174b4bdb8ca4902" translate="yes" xml:space="preserve">
          <source>Unlike some of the references (such as array and mask indices) assignments are always made to the original data in the array (indeed, nothing else would make sense!). Note though, that some actions may not work as one may naively expect. This particular example is often surprising to people:</source>
          <target state="translated">일부 참조 (예 : 배열 및 마스크 인덱스)와 달리 항상 배열의 원래 데이터에 할당됩니다 (실제로 다른 것은 의미가 없습니다!). 그러나 일부 작업은 순진하게 예상 한대로 작동하지 않을 수 있습니다. 이 특별한 예는 종종 사람들에게 놀랍습니다.</target>
        </trans-unit>
        <trans-unit id="6138c52b3d14f1f06df9ad9cd32f8b7c13aad36f" translate="yes" xml:space="preserve">
          <source>Unlike the built-in &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt;&lt;code&gt;math.isclose&lt;/code&gt;&lt;/a&gt;, the above equation is not symmetric in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; &amp;ndash; it assumes &lt;code&gt;b&lt;/code&gt; is the reference value &amp;ndash; so that &lt;code&gt;isclose(a, b)&lt;/code&gt; might be different from &lt;code&gt;isclose(b, a)&lt;/code&gt;. Furthermore, the default value of atol is not zero, and is used to determine what small values should be considered close to zero. The default value is appropriate for expected values of order unity: if the expected values are significantly smaller than one, it can result in false positives. &lt;code&gt;atol&lt;/code&gt; should be carefully selected for the use case at hand. A zero value for &lt;code&gt;atol&lt;/code&gt; will result in &lt;code&gt;False&lt;/code&gt; if either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is zero.</source>
          <target state="translated">내장 된 &lt;a href=&quot;https://docs.python.org/dev/library/math.html#math.isclose&quot;&gt; &lt;code&gt;math.isclose&lt;/code&gt; &lt;/a&gt; 와 달리 위의 방정식은 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 에서 대칭이 아니며 &lt;code&gt;b&lt;/code&gt; 는 참조 값 이라고 가정 하므로 &lt;code&gt;isclose(a, b)&lt;/code&gt; 는 &lt;code&gt;isclose(b, a)&lt;/code&gt; 다를 수 있습니다 . 또한, atol의 기본값은 0이 아니며 0에 가까운 것으로 간주해야하는 작은 값을 결정하는 데 사용됩니다. 기본값은 주문 통일의 예상 값에 적합합니다. 예상 값이 1보다 상당히 작 으면 오 탐지가 발생할 수 있습니다. 사용 사례에 따라 &lt;code&gt;atol&lt;/code&gt; 을 신중하게 선택해야합니다. 에 대한 값이 0 &lt;code&gt;atol&lt;/code&gt; 발생합니다 &lt;code&gt;False&lt;/code&gt; 중 하나의 경우 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 는 0이다.</target>
        </trans-unit>
        <trans-unit id="f562bb48bffcb6e3afb75a4ff67fcee5424e89c9" translate="yes" xml:space="preserve">
          <source>Unlike the builtin &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt;, this supports the &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol&lt;/a&gt;, exposing its contents as UCS4:</source>
          <target state="translated">내장 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 과 달리 이것은 &lt;a href=&quot;https://docs.python.org/dev/c-api/buffer.html#bufferobjects&quot;&gt;Buffer Protocol을&lt;/a&gt; 지원하여 그 내용을 UCS4로 노출합니다.</target>
        </trans-unit>
        <trans-unit id="b9b43bc2298a20c8156a6023d94ab148e7869ea1" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">유리 함수 달리 &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; ,이 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 는&lt;/a&gt; 형상 매개 변수의 요소들이 별도의 인수로서 전달 될 수있다. 예를 들어, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 은 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c055ec1da31f5b3a36529d3d52329cd0cef8c5de" translate="yes" xml:space="preserve">
          <source>Unlike the free function &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;numpy.reshape&lt;/code&gt;&lt;/a&gt;, this method on &lt;code&gt;ndarray&lt;/code&gt; allows the elements of the shape parameter to be passed in as separate arguments. For example, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; is equivalent to &lt;code&gt;a.reshape((10, 11))&lt;/code&gt;.</source>
          <target state="translated">유리 함수 달리 &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;numpy.reshape&lt;/code&gt; &lt;/a&gt; ,이 메소드 &lt;code&gt;ndarray&lt;/code&gt; 는 형상 매개 변수의 요소들이 별도의 인수로서 전달 될 수있다. 예를 들어, &lt;code&gt;a.reshape(10, 11)&lt;/code&gt; 은 &lt;code&gt;a.reshape((10, 11))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6f1b0bab79178181c6f1258ede14dd475f1a6b3" translate="yes" xml:space="preserve">
          <source>Unlike the previous &lt;code&gt;nose&lt;/code&gt;-based implementation, this class is not publicly exposed as it performs some &lt;code&gt;numpy&lt;/code&gt;-specific warning suppression.</source>
          <target state="translated">이전 &lt;code&gt;nose&lt;/code&gt; 기반 구현 과 달리이 클래스는 일부 &lt;code&gt;numpy&lt;/code&gt; 관련 경고 억제를 수행하므로 공개적으로 노출되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="0206a9a6a08e980ce9de3768f0db78bc718405ea" translate="yes" xml:space="preserve">
          <source>Unlike the standard numpy comparison operators, the ones in the &lt;code&gt;char&lt;/code&gt; module strip trailing whitespace characters before performing the comparison.</source>
          <target state="translated">표준 numpy 비교 연산자와 달리 &lt;code&gt;char&lt;/code&gt; 모듈 의 연산자 는 비교를 수행하기 전에 후행 공백 문자를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="7fbacb4b6a81b741ccf818cdd058fa9d9f52d43b" translate="yes" xml:space="preserve">
          <source>Unmasking an entry</source>
          <target state="translated">항목 마스킹 해제</target>
        </trans-unit>
        <trans-unit id="de9f965938adc0324fd8157cc466e2436f4a68e4" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt;&lt;code&gt;hardmask&lt;/code&gt;&lt;/a&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">직접 할당에 의한 항목 마스크 해제는 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.hardmask&quot;&gt; &lt;code&gt;hardmask&lt;/code&gt; &lt;/a&gt; 속성에 표시된 것처럼 마스크 된 배열에 &lt;em&gt;하드&lt;/em&gt; 마스크 가있는 경우 자동으로 실패 합니다. 이 기능은 마스크 덮어 쓰기를 방지하기 위해 도입되었습니다. 배열에 하드 마스크가있는 항목의 마스크 해제를 강제하려면 할당 전에 먼저 &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 마스크를 부드럽게해야합니다 . &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; 를 사용&lt;/a&gt; 하여 다시 강화할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c37a5ee094534c733a693e498e6b83c12096d6e0" translate="yes" xml:space="preserve">
          <source>Unmasking an entry by direct assignment will silently fail if the masked array has a &lt;em&gt;hard&lt;/em&gt; mask, as shown by the &lt;code&gt;hardmask&lt;/code&gt; attribute. This feature was introduced to prevent overwriting the mask. To force the unmasking of an entry where the array has a hard mask, the mask must first to be softened using the &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt;&lt;code&gt;soften_mask&lt;/code&gt;&lt;/a&gt; method before the allocation. It can be re-hardened with &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt;&lt;code&gt;harden_mask&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;code&gt;hardmask&lt;/code&gt; 속성 으로 표시된 것처럼 마스크 된 배열에 &lt;em&gt;하드&lt;/em&gt; 마스크 가있는 경우 직접 할당으로 항목을 마스크 해제하면 자동으로 실패 합니다. 이 기능은 마스크 덮어 쓰기를 방지하기 위해 도입되었습니다. 배열에 하드 마스크가있는 항목을 강제로 마스크 해제하려면 할당 전에 &lt;a href=&quot;generated/numpy.ma.soften_mask#numpy.ma.soften_mask&quot;&gt; &lt;code&gt;soften_mask&lt;/code&gt; &lt;/a&gt; 메소드를 사용하여 마스크를 먼저 부드럽게해야합니다 . &lt;a href=&quot;generated/numpy.ma.harden_mask#numpy.ma.harden_mask&quot;&gt; &lt;code&gt;harden_mask&lt;/code&gt; &lt;/a&gt; 로 다시 강화할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5724dd60c593622fc16f28573a8be39237c1817b" translate="yes" xml:space="preserve">
          <source>Unmodified core dimensions that share the same name must have the same size. Each dimension name typically corresponds to one level of looping in the elementary function&amp;rsquo;s implementation.</source>
          <target state="translated">동일한 이름을 공유하는 수정되지 않은 코어 치수는 크기가 같아야합니다. 각 차원 이름은 일반적으로 기본 함수 구현에서 한 수준의 루핑에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="0c8c8df9f7c1cb71b2c99863e55f28b2342c49c8" translate="yes" xml:space="preserve">
          <source>Unpacks elements of a uint8 array into a binary-valued output array.</source>
          <target state="translated">uint8 배열의 요소를 이진 값 출력 배열로 압축 해제합니다.</target>
        </trans-unit>
        <trans-unit id="cfb0e26f84a72aa991cbd86d2a8e70f9268c36da" translate="yes" xml:space="preserve">
          <source>Unpickling while loading requires explicit opt-in</source>
          <target state="translated">로드하는 동안 언 피클 링에는 명시적인 옵트 인이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c2316b90ad07a17bab89992c697827520a7c1a76" translate="yes" xml:space="preserve">
          <source>Unsafe int casting of the num attribute in &lt;code&gt;linspace&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;linspace&lt;/code&gt; 에서 num 속성의 안전하지 않은 int 캐스팅</target>
        </trans-unit>
        <trans-unit id="9b27e09825b38c1619e31484868bfeb48e96d8d2" translate="yes" xml:space="preserve">
          <source>Unsigned integer</source>
          <target state="translated">부호없는 정수</target>
        </trans-unit>
        <trans-unit id="19201d9c175004fe2d2c285a14b33dc2f3c58964" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 18446744073709551615)</source>
          <target state="translated">부호없는 정수 (0 ~ 18446744073709551615)</target>
        </trans-unit>
        <trans-unit id="d614ab4b08ea51c529ca2afd42bd5cb8f14039b7" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 255)</source>
          <target state="translated">부호없는 정수 (0 ~ 255)</target>
        </trans-unit>
        <trans-unit id="ece1b13212dbdde6f6979b0eb6cfffcea163e303" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 4294967295)</source>
          <target state="translated">부호없는 정수 (0 ~ 4294967295)</target>
        </trans-unit>
        <trans-unit id="5280260c5f39b844aa889ca5265bd63ac321070f" translate="yes" xml:space="preserve">
          <source>Unsigned integer (0 to 65535)</source>
          <target state="translated">부호없는 정수 (0 ~ 65535)</target>
        </trans-unit>
        <trans-unit id="b2aab86479226bc8229a66fd8baa56a5fe8412a4" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned char&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;unsigned char&lt;/code&gt; 와 호환되는 부호없는 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="595c836cdf50bf3f4050476b93f63ab67a1da92f" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned int&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;unsigned int&lt;/code&gt; 와 호환되는 부호없는 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="2e05de9d1a63c40d810e731eb7ec8ec87ae658b9" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned long&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;unsigned long&lt;/code&gt; 과 호환되는 부호없는 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="c931b6dcc5518010a4218c052e902b5fef939e8d" translate="yes" xml:space="preserve">
          <source>Unsigned integer type, compatible with C &lt;code&gt;unsigned short&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;unsigned short&lt;/code&gt; 와 호환되는 부호없는 정수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fd0a7731fa8a0a0f488308cec0945059f2de6581" translate="yes" xml:space="preserve">
          <source>Unsigned integer types</source>
          <target state="translated">부호없는 정수 유형</target>
        </trans-unit>
        <trans-unit id="432373371510943ee2651ebf21148b86384d0a29" translate="yes" xml:space="preserve">
          <source>Unsigned integers:</source>
          <target state="translated">부호없는 정수 :</target>
        </trans-unit>
        <trans-unit id="c824dd22d12bde4feee6277b067eb0b05fa4fdf1" translate="yes" xml:space="preserve">
          <source>Unsigned versions of the integers can be defined by pre-pending a &amp;lsquo;u&amp;rsquo; to the front of the integer name.</source>
          <target state="translated">부호없는 버전의 정수는 정수 이름 앞에 'u'를 붙여서 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b4a1ed161e3d5d468bc7819a4a4469e69fb390c" translate="yes" xml:space="preserve">
          <source>Unstructured array or dtype to convert.</source>
          <target state="translated">변환 할 구조화되지 않은 배열 또는 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="8443c9cc12807ec6c811788bbce2592aaf619083" translate="yes" xml:space="preserve">
          <source>Unstructured array with one more dimension.</source>
          <target state="translated">차원이 하나 더있는 구조화되지 않은 어레이.</target>
        </trans-unit>
        <trans-unit id="239cbdafe6ac9fc4ef398b9a7b1e9b6cb6e3e71d" translate="yes" xml:space="preserve">
          <source>Until August 2020, this said:</source>
          <target state="translated">2020 년 8 월까지이 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="cd4f4dc80803ac1f52848ab12f25d8e2d5b8e16f" translate="yes" xml:space="preserve">
          <source>Until Python 3.5 the only disadvantage of using the array type was that you had to use &lt;code&gt;dot&lt;/code&gt; instead of &lt;code&gt;*&lt;/code&gt; to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). Since Python 3.5 you can use the matrix multiplication &lt;code&gt;@&lt;/code&gt; operator.</source>
          <target state="translated">Python 3.5까지 배열 유형을 사용하는 유일한 단점은 &lt;code&gt;*&lt;/code&gt; 대신 &lt;code&gt;dot&lt;/code&gt; 을 사용 하여 두 개의 텐서 (스칼라 곱, 행렬 벡터 곱셈 등)를 곱 (줄이기) 해야한다는 것 입니다. Python 3.5부터 행렬 곱셈 &lt;code&gt;@&lt;/code&gt; 연산자를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="91aa49f62879d325c6707e96a59652eaa942e8ca" translate="yes" xml:space="preserve">
          <source>Until the 1.15 release, NumPy used the &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;nose&lt;/a&gt; testing framework, it now uses the &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;pytest&lt;/a&gt; framework. The older framework is still maintained in order to support downstream projects that use the old numpy framework, but all tests for NumPy should use pytest.</source>
          <target state="translated">1.15 릴리스까지 NumPy는 &lt;a href=&quot;https://nose.readthedocs.io/en/latest/&quot;&gt;노즈&lt;/a&gt; 테스트 프레임 워크를 사용했으며 &lt;a href=&quot;https://pytest.readthedocs.io&quot;&gt;이제는 pytest&lt;/a&gt; 프레임 워크를 사용합니다 . 이전 numpy 프레임 워크를 사용하는 다운 스트림 프로젝트를 지원하기 위해 이전 프레임 워크는 계속 유지되지만 NumPy에 대한 모든 테스트는 pytest를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="f13be7738e1389f72c0f88aa84d17719f746bf4a" translate="yes" xml:space="preserve">
          <source>Unused.</source>
          <target state="translated">Unused.</target>
        </trans-unit>
        <trans-unit id="52bd5ee224646394816a409132afdc6f181c7d8b" translate="yes" xml:space="preserve">
          <source>Unwelcome sexual attention.</source>
          <target state="translated">원치 않는 성적 관심.</target>
        </trans-unit>
        <trans-unit id="91235b6cec5e2bdecb806fae5c6f1c673c46dd54" translate="yes" xml:space="preserve">
          <source>Unwrap by changing deltas between values to 2*pi complement.</source>
          <target state="translated">값 사이의 델타를 2 * pi 보완으로 변경하여 줄 바꿈을 해제하십시오.</target>
        </trans-unit>
        <trans-unit id="cba2ade8e0d37d0f36a249f716f7633b555a4616" translate="yes" xml:space="preserve">
          <source>Unwrap radian phase &lt;code&gt;p&lt;/code&gt; by changing absolute jumps greater than &lt;code&gt;discont&lt;/code&gt; to their 2*pi complement along the given axis.</source>
          <target state="translated">주어진 축을 따라 2 보다 큰 절대 점프 를 2 * pi 보수 로 변경하여 라디안 위상 &lt;code&gt;p&lt;/code&gt; 를 &lt;code&gt;discont&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="31f87bfbdb61e41f06f9d6ba5c2c33b85dec73cd" translate="yes" xml:space="preserve">
          <source>Upcasting:</source>
          <target state="translated">Upcasting:</target>
        </trans-unit>
        <trans-unit id="579edc70cbe349fcc3048fa42d7c965a563d10ae" translate="yes" xml:space="preserve">
          <source>Update PyPI</source>
          <target state="translated">PyPI 업데이트</target>
        </trans-unit>
        <trans-unit id="a305b240bddfefe147af5326421c8f0107898199" translate="yes" xml:space="preserve">
          <source>Update Release documentation</source>
          <target state="translated">업데이트 릴리스 문서</target>
        </trans-unit>
        <trans-unit id="a858dc159ecba3062c1406c8e0fb587c83eace91" translate="yes" xml:space="preserve">
          <source>Update policy documents such as this one.</source>
          <target state="translated">이와 같은 정책 문서를 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="676d87bea990c4c73ff4081f6b93aae5ebcc7dac" translate="yes" xml:space="preserve">
          <source>Update scipy.org</source>
          <target state="translated">scipy.org 업데이트</target>
        </trans-unit>
        <trans-unit id="64e81e08ab40d294f4651a8208d4e909d5156cbf" translate="yes" xml:space="preserve">
          <source>Update the Milestones in Trac.</source>
          <target state="translated">Trac에서 마일스톤을 업데이트합니다.</target>
        </trans-unit>
        <trans-unit id="8117487cd3d843fb21b5965b5f6cf86d9fd9d8a6" translate="yes" xml:space="preserve">
          <source>Update the release notes with a Highlights section. Mention some of the following:</source>
          <target state="translated">하이라이트 섹션으로 릴리스 노트를 업데이트하십시오. 다음 중 일부를 언급하십시오.</target>
        </trans-unit>
        <trans-unit id="cd25c09dc3e898187644d607cbbc12c4edc2554e" translate="yes" xml:space="preserve">
          <source>Update the release status and create a release &amp;ldquo;tag&amp;rdquo;</source>
          <target state="translated">출시 상태를 업데이트하고 출시 '태그'를 생성합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="1db22e1acc193e90fbde99ab0d68584a24cec01a" translate="yes" xml:space="preserve">
          <source>Update the version of the master branch</source>
          <target state="translated">마스터 브랜치의 버전 업데이트</target>
        </trans-unit>
        <trans-unit id="777088119e41bc0469a64ccb283496abe08bc95e" translate="yes" xml:space="preserve">
          <source>Updated version of PyArray_Correlate, which uses the usual definition of correlation for 1d arrays. The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">1d 배열에 대한 일반적인 상관 관계 정의를 사용하는 PyArray_Correlate 버전이 업데이트되었습니다. &lt;em&gt;op1&lt;/em&gt; 에 시프트 된 버전의 &lt;em&gt;op2&lt;/em&gt; 를 곱하고 결과를 합산하여 각 출력 지점에서 상관 관계가 계산됩니다 . 시프트 결과, 정의 된 &lt;em&gt;op1&lt;/em&gt; 및 &lt;em&gt;op2&lt;/em&gt; 범위를 벗어난 필요한 값 은 0으로 해석됩니다. 모드는 리턴 할 시프트 수를 결정합니다. 0-0 값을 가정 할 필요가없는 시프트 만 리턴합니다. 1- &lt;em&gt;op1&lt;/em&gt; 과 동일한 크기의 객체를 반환합니다 . 2-가능한 모든 시프트를 반환합니다 (모든 오버랩이 허용됨).</target>
        </trans-unit>
        <trans-unit id="a7409084cf2605b5cad89ac1878143241b496ed1" translate="yes" xml:space="preserve">
          <source>Updating the code</source>
          <target state="translated">코드 업데이트</target>
        </trans-unit>
        <trans-unit id="2ab89ee68187f5c809160685dea5430718e73ea0" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;doc/changelog/1.14.5-changelog.rst&lt;/code&gt; 를 바이너리 파일로 업로드 합니다.</target>
        </trans-unit>
        <trans-unit id="d1cf0b974aedc608d19f10cd46abf353ccf013a1" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;doc/changelog/1.19.0-changelog.rst&lt;/code&gt; 를 바이너리 파일로 업로드 합니다.</target>
        </trans-unit>
        <trans-unit id="e8242899ac44525eea3639fc9196319bcd5798e1" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/README.rst&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;release/README.rst&lt;/code&gt; 를 바이너리 파일로 업로드 합니다.</target>
        </trans-unit>
        <trans-unit id="4be4f20f37deddb1b1a33a72c43f77bfa0490a76" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.tar.gz&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;release/installers/numpy-1.14.5.tar.gz&lt;/code&gt; 를 바이너리 파일로 업로드 하십시오.</target>
        </trans-unit>
        <trans-unit id="c5f92deadaf10f46166261ad542bc8986cab5d64" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.14.5.zip&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;release/installers/numpy-1.14.5.zip&lt;/code&gt; 을 바이너리 파일로 업로드 합니다.</target>
        </trans-unit>
        <trans-unit id="33203022b8466a3576e1acf3d1dc460eb5c8960e" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.19.0.tar.gz&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;release/installers/numpy-1.19.0.tar.gz&lt;/code&gt; 를 바이너리 파일로 업로드하세요 .</target>
        </trans-unit>
        <trans-unit id="0420f995c997e7a2ced387d97a072ef37e7e87ef" translate="yes" xml:space="preserve">
          <source>Upload &lt;code&gt;release/installers/numpy-1.19.0.zip&lt;/code&gt; as a binary file.</source>
          <target state="translated">&lt;code&gt;release/installers/numpy-1.19.0.zip&lt;/code&gt; 을 바이너리 파일로 업로드 합니다.</target>
        </trans-unit>
        <trans-unit id="feca53bac4346b96bf1a7a8af5a58f9b95162f3b" translate="yes" xml:space="preserve">
          <source>Upload documents to numpy.org</source>
          <target state="translated">numpy.org에 문서 업로드</target>
        </trans-unit>
        <trans-unit id="8bc2fac0bfff4c1c9d6c6f5a22fc6d38d8b5119c" translate="yes" xml:space="preserve">
          <source>Upload files to github</source>
          <target state="translated">github에 파일 업로드</target>
        </trans-unit>
        <trans-unit id="37ea156fa200c4b1e62bfc88ad83c78600949638" translate="yes" xml:space="preserve">
          <source>Upload to PyPI</source>
          <target state="translated">PyPI에 업로드</target>
        </trans-unit>
        <trans-unit id="c16ab259dc55f6326fdf3044018a5aed36c63fd1" translate="yes" xml:space="preserve">
          <source>Upload to PyPI using &lt;code&gt;twine&lt;/code&gt;. A recent version of &lt;code&gt;twine&lt;/code&gt; of is needed after recent PyPI changes, version &lt;code&gt;1.11.0&lt;/code&gt; was used here.</source>
          <target state="translated">사용 PyPI에 업로드 &lt;code&gt;twine&lt;/code&gt; . 의 최신 버전 &lt;code&gt;twine&lt;/code&gt; 최근 PyPI 변경 후 필요의이 버전 &lt;code&gt;1.11.0&lt;/code&gt; 는 여기에 사용되었다.</target>
        </trans-unit>
        <trans-unit id="440f57ef8033b34c5e177db217a4c616fe0710cc" translate="yes" xml:space="preserve">
          <source>Upload to PyPI using &lt;code&gt;twine&lt;/code&gt;. A recent version of &lt;code&gt;twine&lt;/code&gt; of is needed after recent PyPI changes, version &lt;code&gt;3.1.1&lt;/code&gt; was used here:</source>
          <target state="translated">사용 PyPI에 업로드 &lt;code&gt;twine&lt;/code&gt; . 최근 PyPI 변경 후 최신 버전의 &lt;code&gt;twine&lt;/code&gt; 이 필요 합니다. 여기 에서는 버전 &lt;code&gt;3.1.1&lt;/code&gt; 이 사용되었습니다.</target>
        </trans-unit>
        <trans-unit id="6565e74e2ff5bcf02b09c60c49c14fcfab1feb84" translate="yes" xml:space="preserve">
          <source>Uploading to PyPI</source>
          <target state="translated">PyPI에 업로드</target>
        </trans-unit>
        <trans-unit id="9b72e324adb06ca1d01de4a8922403d911a439a0" translate="yes" xml:space="preserve">
          <source>Upper bound to relative error due to rounding in 64-bit floating point arithmetic.</source>
          <target state="translated">64 비트 부동 소수점 산술에서 반올림으로 인한 상대 오차의 상한.</target>
        </trans-unit>
        <trans-unit id="80d1841e63317d86d0b2bbae07f2e08dc59ff7f9" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than high. The default value is 1.0.</source>
          <target state="translated">출력 간격의 상한. 생성 된 모든 값은 높지 않습니다. 기본값은 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="94608c7ff5f4700d78cab2cf3285f4a9e6dc1615" translate="yes" xml:space="preserve">
          <source>Upper boundary of the output interval. All values generated will be less than or equal to high. The default value is 1.0.</source>
          <target state="translated">출력 간격의 상한. 생성 된 모든 값은 높거나 작습니다. 기본값은 1.0입니다.</target>
        </trans-unit>
        <trans-unit id="52be5864b9af229753de85f916fa14a1fa97d3a1" translate="yes" xml:space="preserve">
          <source>Upper limit, must be larger than &lt;code&gt;left&lt;/code&gt;.</source>
          <target state="translated">상한은 &lt;code&gt;left&lt;/code&gt; 보다 커야합니다 .</target>
        </trans-unit>
        <trans-unit id="528933f6438e2665073f1a6a0a370889bd9e0bae" translate="yes" xml:space="preserve">
          <source>Upper or lower-triangular Cholesky factor of &lt;code&gt;a&lt;/code&gt;. Returns a matrix object if &lt;code&gt;a&lt;/code&gt; is a matrix object.</source>
          <target state="translated">상위 또는 하위 삼각 콜레 요인 . 경우 매트릭스 오브젝트를 돌려줍니다 &lt;code&gt;a&lt;/code&gt; 매트릭스 개체입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="57bb98258946012ee6623d2627640ef4f5f0bbc8" translate="yes" xml:space="preserve">
          <source>Upper triangle of an array.</source>
          <target state="translated">배열의 위쪽 삼각형.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="0385484fbb876c4198e9c03bf37e041d3810df5e" translate="yes" xml:space="preserve">
          <source>Usage and Examples</source>
          <target state="translated">사용법 및 예</target>
        </trans-unit>
        <trans-unit id="a6ddf950ead3f5a277ec641c8bb4408b4523e874" translate="yes" xml:space="preserve">
          <source>Usage of ATLAS and other accelerated libraries in NumPy can be disabled via:</source>
          <target state="translated">NumPy에서 ATLAS 및 기타 가속 라이브러리의 사용은 다음을 통해 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="861a0e430ffac5e4ae6e11b7a947f2c32d388cf4" translate="yes" xml:space="preserve">
          <source>Usage:</source>
          <target state="translated">Usage:</target>
        </trans-unit>
        <trans-unit id="f8422a8af0050351fb69661fa171b15f26430c90" translate="yes" xml:space="preserve">
          <source>Use 4-space indents and no tabs at all.</source>
          <target state="translated">4 칸 들여 쓰기를 사용하고 탭은 전혀 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="a4f4f55257b83792366b61f4d5627bfeafb83aa3" translate="yes" xml:space="preserve">
          <source>Use 64-bit integer size on 64-bit platforms in fallback lapack_lite</source>
          <target state="translated">대체 lapack_lite의 64 비트 플랫폼에서 64 비트 정수 크기 사용</target>
        </trans-unit>
        <trans-unit id="a15df8cc43a52230464924d2366701940520ece7" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; because &lt;a href=&quot;#numpy.Inf&quot;&gt;&lt;code&gt;Inf&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.Infinity&quot;&gt;&lt;code&gt;Infinity&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.PINF&quot;&gt;&lt;code&gt;PINF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.infty&quot;&gt;&lt;code&gt;infty&lt;/code&gt;&lt;/a&gt; are aliases for &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;. For more details, see &lt;a href=&quot;#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.Inf&quot;&gt; &lt;code&gt;Inf&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.Infinity&quot;&gt; &lt;code&gt;Infinity&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.PINF&quot;&gt; &lt;code&gt;PINF&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.infty&quot;&gt; &lt;code&gt;infty&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 의&lt;/a&gt; 별칭 이므로 &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 자세한 내용은 &lt;a href=&quot;#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="351414f7c521f4b341a7a407035466c24988a100" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1081c5bfa15ce1f1d2793775db1564a0d257f094" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;. It can read files generated by any of &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;numpy.savez&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;numpy.savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;numpy.savez&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;numpy.savez_compressed&lt;/code&gt; 에&lt;/a&gt; 의해 생성 된 파일을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c2da46a0755bb961c8bf3e39960e920a669632f9" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;numpy.loadtxt&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;numpy.loadtxt&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f4f8ac8fa6bbe32be50850bd12eaa662fa8d4dcb" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;. Set &lt;code&gt;allow_pickle=False&lt;/code&gt;, unless the array dtype includes Python objects, in which case pickling is required.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; 를&lt;/a&gt; 사용하십시오 . 배열 dtype에 Python 객체가 포함되어 있지 않으면 &lt;code&gt;allow_pickle=False&lt;/code&gt; 를 설정 합니다.이 경우 피클 링이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="02b4c353908e359bf6eb7d8604286846ac3d1bd8" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt;, or to store multiple arrays &lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;numpy.savez&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;numpy.savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; 를&lt;/a&gt; 사용 하거나 여러 배열 &lt;a href=&quot;../reference/generated/numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;numpy.savez&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;numpy.savez_compressed&lt;/code&gt; &lt;/a&gt; 를 저장 하십시오 .</target>
        </trans-unit>
        <trans-unit id="6250a8c021e0b5f57d8def96501e9671eb570fb3" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;SeedSequence.spawn&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="315e845b90149a11b36b35f1bf0bf7c4eadadf53" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn&lt;/code&gt; &lt;/a&gt; 사용</target>
        </trans-unit>
        <trans-unit id="6cd23ceb7d31c81e1ae51bfa02cfeb8d16da6862" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;https://github.com/hawkowl/towncrier&quot;&gt;towncrier&lt;/a&gt; to build the release note and commit the changes. This will remove all the fragments from &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; and add &lt;code&gt;doc/release/&amp;lt;version&amp;gt;-note.rst&lt;/code&gt;. Note that currently towncrier must be installed from its master branch as the last release (19.2.0) is outdated.</source>
          <target state="translated">사용 &lt;a href=&quot;https://github.com/hawkowl/towncrier&quot;&gt;towncrier은&lt;/a&gt; 릴리스 노트를 작성하고 변경 내용을 커밋합니다. 이렇게하면 &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; 에서 모든 조각이 제거 되고 &lt;code&gt;doc/release/&amp;lt;version&amp;gt;-note.rst&lt;/code&gt; 가 추가 됩니다. 마지막 릴리스 (19.2.0)가 오래되었으므로 현재 towncrier는 마스터 브랜치에서 설치해야합니다.</target>
        </trans-unit>
        <trans-unit id="239d871fd4cf571322892166220cc9bdd722de95" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt;&lt;code&gt;printoptions&lt;/code&gt;&lt;/a&gt; as a context manager to set the values temporarily.</source>
          <target state="translated">일시적으로 값을 설정 하려면 &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt; &lt;code&gt;printoptions&lt;/code&gt; &lt;/a&gt; 를 컨텍스트 관리자로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="f81e110951d1c31f755b7eda89bda400f45185fe" translate="yes" xml:space="preserve">
          <source>Use &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt; or one of the nulp (number of floating point values) functions for these cases instead:</source>
          <target state="translated">이 경우 대신 &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; 또는 nulp (부동 소수점 값 수) 함수 중 하나를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2c3133adfff844d3d7390f3b12e049c01cfbf85" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;*italics*&lt;/code&gt;, &lt;code&gt;**bold**&lt;/code&gt; and &lt;code&gt;``monospace``&lt;/code&gt; if needed in any explanations (but not for variable names and doctest code or multi-line code). Variable, module, function, and class names should be written between single back-ticks (&lt;code&gt;`numpy`&lt;/code&gt;).</source>
          <target state="translated">사용 &lt;code&gt;*italics*&lt;/code&gt; , &lt;code&gt;**bold**&lt;/code&gt; 와 &lt;code&gt;``monospace``&lt;/code&gt; 어떤 설명이 필요한 경우 (그러나 변수 이름과에 대한 doctest가 코드 또는 여러 줄의 코드). 변수, 모듈, 함수 및 클래스 이름은 단일 &lt;code&gt;`numpy`&lt;/code&gt; ( `numpy` ) 사이에 작성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f96b961e5f74e075163f17783fa068cb28fd7dac" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS&lt;/code&gt; block around the call to Fortran/C function.</source>
          <target state="translated">Fortran / C 함수 호출 주위에 &lt;code&gt;Py_BEGIN_ALLOW_THREADS .. Py_END_ALLOW_THREADS&lt;/code&gt; 블록을 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="279c8e9cb261d8451ee87221b2c4c3c0acff77e2" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;atleast1d&lt;/code&gt; explicitly if this behavior is deliberate.</source>
          <target state="translated">이 동작이 의도적 인 경우 &lt;code&gt;atleast1d&lt;/code&gt; 를 명시 적으로 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f3c1a16eb9a2500b8452a8a5360fe793c9d0e80" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;integers(0, np.iinfo(np.int_).max,&lt;/code&gt;&lt;code&gt;endpoint=False)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;integers(0, np.iinfo(np.int_).max,&lt;/code&gt; 사용 (0, np.iinfo (np.int _). max, &lt;code&gt;endpoint=False)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9990e788a91877bc1314e512b42f5fa96b72afa8" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;intent(callback)&lt;/code&gt; in situations where a Fortran/C code assumes that a user implements a function with given prototype and links it to an executable. Don&amp;rsquo;t use &lt;code&gt;intent(callback)&lt;/code&gt; if function appears in the argument list of a Fortran routine.</source>
          <target state="translated">Fortran / C 코드가 사용자가 주어진 프로토 타입으로 함수를 구현하고 실행 파일에 링크한다고 가정하는 상황에서 인 &lt;code&gt;intent(callback)&lt;/code&gt; 를 사용 합니다. Fortran 루틴의 인수 목록에 함수가 표시되는 경우 인 &lt;code&gt;intent(callback)&lt;/code&gt; 사용하지 마십시오 . ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="c8f354d8129891e4371211f7e2b02c3e86182e68" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;np.rec.fromrecords&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.rec.fromrecords&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7b891c3328df6ed66c13f42757acead75f849207" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; to invert the transposition of tensors when using the &lt;code&gt;axes&lt;/code&gt; keyword argument.</source>
          <target state="translated">&lt;code&gt;axes&lt;/code&gt; 키워드 인수를 사용할 때 텐서의 전치를 반전 하려면 &lt;code&gt;transpose(a, argsort(axes))&lt;/code&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="464b9132a697ad83a17ca6141a5f052f243225bc" translate="yes" xml:space="preserve">
          <source>Use AVX512 intrinsic to implement &lt;code&gt;np.exp&lt;/code&gt; when input is &lt;code&gt;np.float64&lt;/code&gt;</source>
          <target state="translated">구현하는 데 사용할 AVX512 고유 &lt;code&gt;np.exp&lt;/code&gt; 입력되면 &lt;code&gt;np.float64&lt;/code&gt; 가</target>
        </trans-unit>
        <trans-unit id="54252b83acef1c2d4145831c1849100189007324" translate="yes" xml:space="preserve">
          <source>Use C99 (that is, the standard defined by ISO/IEC 9899:1999).</source>
          <target state="translated">C99 (즉, ISO / IEC 9899 : 1999에서 정의한 표준)를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="711cfaf9a47519e9f223142a373928a92e01f581" translate="yes" xml:space="preserve">
          <source>Use C99 complex functions when available</source>
          <target state="translated">가능한 경우 C99 복합 기능 사용</target>
        </trans-unit>
        <trans-unit id="86275be9977f886d82e016929a242789bd409942" translate="yes" xml:space="preserve">
          <source>Use a &lt;a href=&quot;basics.rec&quot;&gt;structured array&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;basics.rec&quot;&gt;구조화 된 배열을&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="98bf81203a370aca52162542f86441968d5a857b" translate="yes" xml:space="preserve">
          <source>Use a code checker:</source>
          <target state="translated">코드 검사기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e79cdecbdf930a5fc02d963ddb3cee0b341e1836" translate="yes" xml:space="preserve">
          <source>Use an index array to construct a new array from a set of choices.</source>
          <target state="translated">인덱스 배열을 사용하여 일련의 선택 항목에서 새 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="b449716c39e8e2ad1701598e0a781904fd930dad" translate="yes" xml:space="preserve">
          <source>Use boolean indexing to select all rows adding up to an even number. At the same time columns 0 and 2 should be selected with an advanced integer index. Using the &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; function this can be done with:</source>
          <target state="translated">부울 인덱싱을 사용하여 짝수까지 더하는 모든 행을 선택하십시오. 동시에 0과 2 열은 고급 정수 인덱스로 선택해야합니다. &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b644965af35188379a837d813ccb011d1f78f91" translate="yes" xml:space="preserve">
          <source>Use f90 compiler specified by the command line args</source>
          <target state="translated">명령 줄 인수로 지정된 f90 컴파일러 사용</target>
        </trans-unit>
        <trans-unit id="8f82174ebfd083d8637822ce00a0c4c91588113b" translate="yes" xml:space="preserve">
          <source>Use frompyfunc to add broadcasting to the Python function &lt;code&gt;oct&lt;/code&gt;:</source>
          <target state="translated">frompyfunc을 사용하여 파이썬 함수 &lt;code&gt;oct&lt;/code&gt; 에 브로드 캐스트를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="1985c7d495449d5cb406d70622b9f8f51933acf4" translate="yes" xml:space="preserve">
          <source>Use integers()</source>
          <target state="translated">정수 사용 ()</target>
        </trans-unit>
        <trans-unit id="dc8e632ae2c46f77a697535ec370bf0774d7d3a3" translate="yes" xml:space="preserve">
          <source>Use it inside source generating function to ensure that setup distribution instance has been initialized.</source>
          <target state="translated">소스 생성 기능 내부에서이를 사용하여 설정 분배 인스턴스가 초기화되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="19f951b7351050e3c262a94c6097609e26d32919" translate="yes" xml:space="preserve">
          <source>Use memory mapping. See &lt;a href=&quot;../reference/generated/numpy.lib.format.open_memmap#numpy.lib.format.open_memmap&quot;&gt;&lt;code&gt;numpy.lib.format.open_memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">메모리 매핑을 사용합니다. &lt;a href=&quot;../reference/generated/numpy.lib.format.open_memmap#numpy.lib.format.open_memmap&quot;&gt; &lt;code&gt;numpy.lib.format.open_memmap&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2ee4c011b47d55b7bfff5ce2a411098048a912df" translate="yes" xml:space="preserve">
          <source>Use numpy data types instead of strings (&lt;code&gt;np.uint8&lt;/code&gt; instead of &lt;code&gt;&quot;uint8&quot;&lt;/code&gt;).</source>
          <target state="translated">문자열 대신 numpy 데이터 유형을 사용하십시오 ( &lt;code&gt;&quot;uint8&quot;&lt;/code&gt; 대신 &lt;code&gt;np.uint8&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="2623e95742f95738b81e96ff23790e2857ea53b8" translate="yes" xml:space="preserve">
          <source>Use of Special Libraries</source>
          <target state="translated">특수 도서관 사용</target>
        </trans-unit>
        <trans-unit id="71894ec37f432f11f7de9a5b9b593a7cdf8ac0f3" translate="yes" xml:space="preserve">
          <source>Use of internal buffers</source>
          <target state="translated">내부 버퍼 사용</target>
        </trans-unit>
        <trans-unit id="19e9181ca40527ae40c5f3d764f8d2f436e1e1db" translate="yes" xml:space="preserve">
          <source>Use of special library functions (e.g., random)</source>
          <target state="translated">특수 라이브러리 기능 사용 (예 : 랜덤)</target>
        </trans-unit>
        <trans-unit id="375ee90511f8800725237c9c32010dd6bfc434d9" translate="yes" xml:space="preserve">
          <source>Use one of the two predefined instances &lt;code&gt;index_exp&lt;/code&gt; or &lt;a href=&quot;#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; rather than directly using &lt;code&gt;IndexExpression&lt;/code&gt;.</source>
          <target state="translated">두 개의 미리 정의 된 인스턴스를 사용하여 하나 &lt;code&gt;index_exp&lt;/code&gt; 또는 &lt;a href=&quot;#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 직접 사용하는 대신 &lt;code&gt;IndexExpression&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="4baff69e242f9bdf1683765ea1f2508b120d6009" translate="yes" xml:space="preserve">
          <source>Use statements:</source>
          <target state="translated">사용 문 :</target>
        </trans-unit>
        <trans-unit id="f399bcf7c74a9a9e383f645bfc3f3a24ebea505e" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;--f2cmap&lt;/code&gt; command-line option to pass the file name to F2PY. By default, F2PY assumes file name is &lt;code&gt;.f2py_f2cmap&lt;/code&gt; in the current working directory.</source>
          <target state="translated">사용 &lt;code&gt;--f2cmap&lt;/code&gt; F2PY에 파일 이름을 전달하는 명령 줄 옵션을. 기본적으로 F2PY 파일 이름은 가정 &lt;code&gt;.f2py_f2cmap&lt;/code&gt; 현재 작업 디렉토리에.</target>
        </trans-unit>
        <trans-unit id="563d6ccf41351782f370e56a915df0b3956e26f4" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;buf&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;buf&lt;/code&gt; 키워드를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6e0dab0efbd30d7f80d43f09e327292cfe0afdb8" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;endpoint&lt;/code&gt; kwarg to adjust the inclusion or exclution of the &lt;code&gt;high&lt;/code&gt; interval endpoint</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 크워 그를 사용하여 &lt;code&gt;high&lt;/code&gt; 간격의 엔드 포인트 포함 또는 제외를 조정하십시오.</target>
        </trans-unit>
        <trans-unit id="1a4a01452f45e746c6cb102d0e1fd6cdbe229239" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;order&lt;/code&gt; keyword to specify a field to use when sorting a structured array:</source>
          <target state="translated">사용 &lt;code&gt;order&lt;/code&gt; 구조화 된 배열을 정렬 할 때 사용하는 필드를 지정하는 키워드 :</target>
        </trans-unit>
        <trans-unit id="bd1412430a20e73aea7c2107ffe5351cd94a8833" translate="yes" xml:space="preserve">
          <source>Use the following import conventions:</source>
          <target state="translated">다음 가져 오기 규칙을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="25cbadfbabe4aec8c49a2fe4ad5d41f89ab2957d" translate="yes" xml:space="preserve">
          <source>Use the indices of the non-zero elements as an index array to extract these elements:</source>
          <target state="translated">0이 아닌 요소의 인덱스를 인덱스 배열로 사용하여 다음 요소를 추출하십시오.</target>
        </trans-unit>
        <trans-unit id="053906d6c11e234d0523bc070994cf48c59e8878" translate="yes" xml:space="preserve">
          <source>Use the library &lt;code&gt;&amp;lt;libname&amp;gt;&lt;/code&gt; when linking.</source>
          <target state="translated">링크 할 때 &lt;code&gt;&amp;lt;libname&amp;gt;&lt;/code&gt; 라이브러리를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="52a989636199f4d3c95f768797df44dd326f52d3" translate="yes" xml:space="preserve">
          <source>Use the same sections as outlined above (all except &lt;code&gt;Returns&lt;/code&gt; are applicable). The constructor (&lt;code&gt;__init__&lt;/code&gt;) should also be documented here, the &lt;strong&gt;Parameters&lt;/strong&gt; section of the docstring details the constructors parameters.</source>
          <target state="translated">위에 설명 된 것과 동일한 섹션을 사용합니다 ( &lt;code&gt;Returns&lt;/code&gt; 을 제외한 모든 항목 이 적용 가능). 생성자 ( &lt;code&gt;__init__&lt;/code&gt; )도 여기에 문서화해야합니다. 독 스트링 의 &lt;strong&gt;매개 변수&lt;/strong&gt; 섹션은 생성자 매개 변수에 대해 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bcbe93ff8f6462c82dd7a279518d76404badb4f2" translate="yes" xml:space="preserve">
          <source>Use the same sections as outlined for functions where applicable:</source>
          <target state="translated">해당하는 경우 기능에 대해 설명 된 것과 동일한 섹션을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="91b5ae96e69a49c5a6862c6b40c4da95f9ee09c6" translate="yes" xml:space="preserve">
          <source>Use these sparingly, as they do not look very good in text terminals and are not often necessary. One situation in which a warning can be useful is for marking a known bug that is not yet fixed.</source>
          <target state="translated">텍스트 터미널에서보기가 좋지 않고 자주 필요하지 않으므로 아껴서 사용하십시오. 경고가 유용 할 수있는 한 가지 상황은 아직 수정되지 않은 알려진 버그를 표시하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="fce2d931323b452a238b3e2d786e8a8211d7c7e3" translate="yes" xml:space="preserve">
          <source>Used as an alias of &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; and vica versa.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt; 의 별칭으로 사용되며 vica도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="fd6f1513bb6f3e4a98050539792c7f3cbaf760a6" translate="yes" xml:space="preserve">
          <source>Used as-is.</source>
          <target state="translated">있는 그대로 사용합니다.</target>
        </trans-unit>
        <trans-unit id="07b7a5c37f889b88311324311f27b8d80e97eae1" translate="yes" xml:space="preserve">
          <source>Used exclusively for the purpose static type checking, &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt; represents the base of a hierachieral set of subclasses. Each subsequent subclass is herein used for representing a lower level of precision, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;64Bit &amp;gt; 32Bit &amp;gt; 16Bit&lt;/code&gt;.</source>
          <target state="translated">정적 유형 검사 목적으로 만 사용되는 &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt; &lt;code&gt;NBitBase&lt;/code&gt; &lt;/a&gt; 는 계층 구조 하위 클래스 집합의 기본을 나타냅니다. 각 후속 서브 클래스는 여기서 더 낮은 수준의 정밀도 ( &lt;em&gt;예 : &lt;/em&gt; &lt;code&gt;64Bit &amp;gt; 32Bit &amp;gt; 16Bit&lt;/code&gt; 를 나타내는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="86d25879dd6e8e65f51cfd2c9e310da0aa3fb93c" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It decrements the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. Normal return value is 0. A -1 is returned if an error occurs.</source>
          <target state="translated">Python 객체가 포함 된 배열 &lt;em&gt;op에&lt;/em&gt; 사용됩니다 . &lt;em&gt;op&lt;/em&gt; 의 데이터 유형에 따라 배열의 모든 객체의 참조 카운트를 감소시킵니다 . 정상 반환 값은 0입니다. 오류가 발생하면 -1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12676328e0f8258da10db691bf737e9cd286a726" translate="yes" xml:space="preserve">
          <source>Used for an array, &lt;em&gt;op&lt;/em&gt;, that contains any Python objects. It increments the reference count of every object in the array according to the data-type of &lt;em&gt;op&lt;/em&gt;. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">Python 객체가 포함 된 배열 &lt;em&gt;op에&lt;/em&gt; 사용됩니다 . &lt;em&gt;op&lt;/em&gt; 의 데이터 유형에 따라 배열의 모든 객체의 참조 카운트를 증가시킵니다 . 오류가 발생하면 -1이 반환되고, 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2a13b41ea5661dcbc4d05b7183bc9d474dd67bb8" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="b1500692edf9e6d67bd590cb2e6428fecab9820c" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt;&lt;code&gt;copy.copy&lt;/code&gt;&lt;/a&gt; is called on an array. Returns a copy of the array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.copy&quot;&gt; &lt;code&gt;copy.copy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 . 배열의 복사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="054ce70cbf81d2356ba6ae20aa8fb864ef13bf9e" translate="yes" xml:space="preserve">
          <source>Used if &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt;&lt;code&gt;copy.deepcopy&lt;/code&gt;&lt;/a&gt; is called on an array.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/copy.html#copy.deepcopy&quot;&gt; &lt;code&gt;copy.deepcopy&lt;/code&gt; &lt;/a&gt; 가 배열에서 호출 된 경우에 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="df1278433c263cdbbd69170e679d3f52bb78e816" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;constant&amp;rsquo;. The values to set the padded values for each axis.</source>
          <target state="translated">'일정한'에서 사용됩니다. 각 축에 대해 채워진 값을 설정하는 값입니다.</target>
        </trans-unit>
        <trans-unit id="465b8fcd19cd5e2ed77adff74f2ff5a3fc18db79" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;linear_ramp&amp;rsquo;. The values used for the ending value of the linear_ramp and that will form the edge of the padded array.</source>
          <target state="translated">'linear_ramp'에서 사용됩니다. linear_ramp의 끝 값에 사용되는 값으로 채워진 배열의 가장자리를 형성합니다.</target>
        </trans-unit>
        <trans-unit id="d71d6f65b16e9b35cb9fcf9b7569838936b2caa2" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;maximum&amp;rsquo;, &amp;lsquo;mean&amp;rsquo;, &amp;lsquo;median&amp;rsquo;, and &amp;lsquo;minimum&amp;rsquo;. Number of values at edge of each axis used to calculate the statistic value.</source>
          <target state="translated">'최대 값', '평균값', '중간 값'및 '최소값'에 사용됩니다. 통계 값을 계산하는 데 사용되는 각 축의 가장자리에있는 값의 수입니다.</target>
        </trans-unit>
        <trans-unit id="4325f42e7e418215aac0a73c897c39904b4d0a1e" translate="yes" xml:space="preserve">
          <source>Used in &amp;lsquo;reflect&amp;rsquo;, and &amp;lsquo;symmetric&amp;rsquo;. The &amp;lsquo;even&amp;rsquo; style is the default with an unaltered reflection around the edge value. For the &amp;lsquo;odd&amp;rsquo; style, the extended part of the array is created by subtracting the reflected values from two times the edge value.</source>
          <target state="translated">'반사'및 '대칭'에 사용됩니다. '짝수'스타일은 가장자리 값을 기준으로 변경되지 않은 반사의 기본값입니다. 'odd'스타일의 경우 가장자리 값의 두 배에서 반사 된 값을 빼서 배열의 확장 부분을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="6a848d84f0829fb89fe0a4c3ff31da438ec74574" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">loop-&amp;gt; obj가 참이 아닌 경우에만 Python GIL을 해제하기 위해 범용 함수 코드에서 사용됩니다 ( &lt;em&gt;즉&lt;/em&gt; , OBJECT 배열 루프가 아닙니다). 변수 선언 영역에서 &lt;a href=&quot;array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="1b7f1793a4a4b44dd1933f922f757d629d3be5a3" translate="yes" xml:space="preserve">
          <source>Used in universal function code to only release the Python GIL if loop-&amp;gt;obj is not true (&lt;em&gt;i.e.&lt;/em&gt; this is not an OBJECT array loop). Requires use of &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt;&lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt;&lt;/a&gt; in variable declaration area.</source>
          <target state="translated">loop-&amp;gt; obj가 true가 아닌 경우 ( &lt;em&gt;즉,&lt;/em&gt; 이것은 OBJECT 배열 루프가 아님) Python GIL을 해제하기 위해 범용 함수 코드에서 사용됩니다 . 변수 선언 영역에서 &lt;a href=&quot;c-api.array#c.NPY_BEGIN_THREADS_DEF&quot;&gt; &lt;code&gt;NPY_BEGIN_THREADS_DEF&lt;/code&gt; &lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="10031fc1a49c2cbba6bbb424956b8667cda6fefa" translate="yes" xml:space="preserve">
          <source>Used in universal function code to re-acquire the Python GIL if it was released (because loop-&amp;gt;obj was not true).</source>
          <target state="translated">일반 함수 코드에서 사용되어 파이썬 GIL이 릴리스 된 경우 (loop-&amp;gt; obj가 true가 아니기 때문에) 다시 획득합니다.</target>
        </trans-unit>
        <trans-unit id="5e817653770e3b6919ac9612c69ec10ee688db47" translate="yes" xml:space="preserve">
          <source>Used synonymously in the NumPy docs with &lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#term-ndarray&quot;&gt;ndarray를&lt;/a&gt; 사용하는 NumPy 문서에서 동의어로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c23b41a6c14497a2fa2fb894918e5ebdff35b118" translate="yes" xml:space="preserve">
          <source>Used to construct the convolution operator.</source>
          <target state="translated">컨볼 루션 연산자를 구성하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c5c64c33615821368bc9743122d8a6c96ff848fe" translate="yes" xml:space="preserve">
          <source>Used to fill the array with data.</source>
          <target state="translated">배열을 데이터로 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9ead00318903d57eb423777b76455ee4a052f86f" translate="yes" xml:space="preserve">
          <source>Used to select only certain elements from a sequence:</source>
          <target state="translated">시퀀스에서 특정 요소 만 선택하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="4b06029f962bdaa60d205631cac84f36f3e29d6f" translate="yes" xml:space="preserve">
          <source>Useful functions in &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 에서 유용한 기능</target>
        </trans-unit>
        <trans-unit id="7dc863346a17f843606dc78b7fd5eaa70c18759a" translate="yes" xml:space="preserve">
          <source>Useful math constants</source>
          <target state="translated">유용한 수학 상수</target>
        </trans-unit>
        <trans-unit id="d7e7cae700d3c37685c439282d2378cb79df959c" translate="yes" xml:space="preserve">
          <source>Useful to regain the GIL in situations where it was released using the BEGIN form of this macro.</source>
          <target state="translated">이 매크로의 BEGIN 형식을 사용하여 릴리스 된 상황에서 GIL을 다시 얻는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8cef70f655bb7cdb9d1c581e3560341cb090e5c3" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop.</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt; 에 루프 실행 중에 Python 인터프리터가 필요할 수있는 임의의 Python 객체가 포함되지 않은 경우에만 GIL을 릴리스하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="d580b2c9b4825f08cb2691c40cd94404df444f3e" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;dtype&lt;/em&gt; does not contain arbitrary Python objects which may need the Python interpreter during execution of the loop. Equivalent to</source>
          <target state="translated">&lt;em&gt;dtype&lt;/em&gt; 에 루프 실행 중 Python 인터프리터가 필요할 수있는 임의의 Python 객체가없는 경우에만 GIL을 해제하는 데 유용합니다 . 에 해당</target>
        </trans-unit>
        <trans-unit id="2978535fda1f10395442e618746112da0bb87d3a" translate="yes" xml:space="preserve">
          <source>Useful to release the GIL only if &lt;em&gt;loop_size&lt;/em&gt; exceeds a minimum threshold, currently set to 500. Should be matched with a &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt;&lt;code&gt;NPY_END_THREADS&lt;/code&gt;&lt;/a&gt; to regain the GIL.</source>
          <target state="translated">&lt;em&gt;loop_size&lt;/em&gt; 가 현재 500으로 설정된 최소 임계 값을 초과하는 경우에만 GIL을 해제하는 데 유용합니다 . GIL을 다시 얻으려면 &lt;a href=&quot;#c.NPY_END_THREADS&quot;&gt; &lt;code&gt;NPY_END_THREADS&lt;/code&gt; &lt;/a&gt; 와 일치해야합니다 .</target>
        </trans-unit>
        <trans-unit id="67dcf8adc685ecdcc2081b1b467df13f891ef2cf" translate="yes" xml:space="preserve">
          <source>User documentation</source>
          <target state="translated">사용자 문서</target>
        </trans-unit>
        <trans-unit id="377ee38d9430016857a7ac84277e93d26f665af8" translate="yes" xml:space="preserve">
          <source>User-defined BLAS detection order</source>
          <target state="translated">사용자 정의 BLAS 감지 순서</target>
        </trans-unit>
        <trans-unit id="01d8c2fd752b3823aa5ae01359574a0ac7005a6d" translate="yes" xml:space="preserve">
          <source>User-defined LAPACK detection order</source>
          <target state="translated">사용자 정의 LAPACK 감지 순서</target>
        </trans-unit>
        <trans-unit id="feb130415c58c07804dd84fa00fab56690d584a4" translate="yes" xml:space="preserve">
          <source>User-defined data-types</source>
          <target state="translated">사용자 정의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="77352cf9f5e0b55e17c69c67b2dd7ed545a9424a" translate="yes" xml:space="preserve">
          <source>User-defined types now need to implement &lt;code&gt;__str__&lt;/code&gt; and &lt;code&gt;__repr__&lt;/code&gt;</source>
          <target state="translated">사용자 정의 유형은 이제 &lt;code&gt;__str__&lt;/code&gt; 및 &lt;code&gt;__repr__&lt;/code&gt; 을 구현해야합니다.</target>
        </trans-unit>
        <trans-unit id="2314f2b86670571851375cde1d05391e4ea574a3" translate="yes" xml:space="preserve">
          <source>Users can create arbitrarily complex &lt;a href=&quot;#term-dtype&quot;&gt;dtypes&lt;/a&gt; that can include other arrays and dtypes. These composite dtypes are called &lt;a href=&quot;user/basics.rec&quot;&gt;structured data types.&lt;/a&gt;</source>
          <target state="translated">사용자 는 다른 배열 및 dtype을 포함 할 수있는 임의의 복잡한 &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt; 을 만들 수 있습니다 . 이러한 복합 dtype을 &lt;a href=&quot;user/basics.rec&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="fd331bef50cb48757824818608d12be462d6034d" translate="yes" xml:space="preserve">
          <source>Users looking to manipulate tabular data, such as stored in csv files, may find other pydata projects more suitable, such as xarray, pandas, or DataArray. These provide a high-level interface for tabular data analysis and are better optimized for that use. For instance, the C-struct-like memory layout of structured arrays in numpy can lead to poor cache behavior in comparison.</source>
          <target state="translated">csv 파일에 저장된 것과 같은 테이블 형식 데이터를 조작하려는 사용자는 xarray, pandas 또는 DataArray와 같은 다른 pydata 프로젝트가 더 적합한 것을 찾을 수 있습니다. 이는 표 형식 데이터 분석을위한 고급 인터페이스를 제공하며 해당 용도에 더 잘 최적화됩니다. 예를 들어, numpy에서 구조화 된 배열의 C-struct와 유사한 메모리 레이아웃은 비교시 캐시 동작이 좋지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2637443926c71ce03a091c2e95bf9b5610348992" translate="yes" xml:space="preserve">
          <source>Using &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; as a first string argument creates a matrix.</source>
          <target state="translated">'r'또는 'c'를 첫 번째 문자열 인수로 사용하면 행렬이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="65fcf8542af4dfa98c8e336c7ebb663b2e96f530" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; one can quickly construct index arrays that will index the cross product. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; returns the array &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; one을 사용 하면 교차 곱을 인덱싱 할 인덱스 배열을 빠르게 구성 할 수 있습니다. &lt;code&gt;a[np.ix_([1,3],[2,5])]&lt;/code&gt; 는 배열 &lt;code&gt;[[a[1,2] a[1,5]], [a[3,2] a[3,5]]]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32ece8fbb6c1ed850bf1c3c8fb0f4d5a7300c2c0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with **kwds, the arrays are saved with the keyword names.</source>
          <target state="translated">** kwds와 함께 &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; 를 사용 하면 배열이 키워드 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="8c36d4099fe15bc91bbfe91acb74cd64e75d6b3f" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt; with *args, the arrays are saved with default names.</source>
          <target state="translated">* args와 함께 &lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt; 를 사용 하면 배열이 기본 이름으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="a65056bb65a5824d8a28541dbacefafbcbe064d0" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;../reference/generated/numpy.hsplit#numpy.hsplit&quot;&gt;&lt;code&gt;hsplit&lt;/code&gt;&lt;/a&gt;, you can split an array along its horizontal axis, either by specifying the number of equally shaped arrays to return, or by specifying the columns after which the division should occur:</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.hsplit#numpy.hsplit&quot;&gt; &lt;code&gt;hsplit&lt;/code&gt; 을&lt;/a&gt; 사용하면 반환 할 동일한 모양의 배열 수를 지정하거나 나눗셈이 발생해야하는 열을 지정하여 가로 축을 따라 배열을 분할 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="abcbf246bed1356ef5a4f7a84e0efa6276b04144" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;arr.reshape()&lt;/code&gt; will give a new shape to an array without changing the data. Just remember that when you use the reshape method, the array you want to produce needs to have the same number of elements as the original array. If you start with an array with 12 elements, you&amp;rsquo;ll need to make sure that your new array also has a total of 12 elements.</source>
          <target state="translated">&lt;code&gt;arr.reshape()&lt;/code&gt; 사용 하면 데이터를 변경하지 않고 배열에 새로운 모양을 제공합니다. reshape 메서드를 사용할 때 생성하려는 배열에는 원래 배열과 동일한 수의 요소가 있어야합니다. 12 개의 요소가있는 배열로 시작하는 경우 새 배열에도 총 12 개의 요소가 있는지 확인해야합니다.</target>
        </trans-unit>
        <trans-unit id="c05ea485672c370249efc13cf02206fa0079194e" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;intent(inout)&lt;/code&gt; is generally not recommended, use &lt;code&gt;intent(in,out)&lt;/code&gt; instead. See also &lt;code&gt;intent(inplace)&lt;/code&gt; attribute.</source>
          <target state="translated">인 &lt;code&gt;intent(inout)&lt;/code&gt; 은 일반적으로 권장되지 않으며 대신 인 &lt;code&gt;intent(in,out)&lt;/code&gt; 사용합니다. &lt;code&gt;intent(inplace)&lt;/code&gt; 속성 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d44e140015f4a842157d0c38e650d4d90f0d7d32" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;intent(inplace)&lt;/code&gt; is generally not recommended either. For example, when slices have been taken from an &lt;code&gt;intent(inplace)&lt;/code&gt; argument then after in-place changes, slices data pointers may point to unallocated memory area.</source>
          <target state="translated">&lt;code&gt;intent(inplace)&lt;/code&gt; 사용 하는 것도 일반적으로 권장되지 않습니다. 예를 들어, 인 &lt;code&gt;intent(inplace)&lt;/code&gt; 인수 에서 슬라이스를 가져온 경우 내부 변경 후 슬라이스 데이터 포인터가 할당되지 않은 메모리 영역을 가리킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b0a1a12d91b1a55351df033aec60b12c39daa72" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;np.newaxis&lt;/code&gt; will increase the dimensions of your array by one dimension when used once. This means that a &lt;strong&gt;1D&lt;/strong&gt; array will become a &lt;strong&gt;2D&lt;/strong&gt; array, a &lt;strong&gt;2D&lt;/strong&gt; array will become a &lt;strong&gt;3D&lt;/strong&gt; array, and so on.</source>
          <target state="translated">사용 &lt;code&gt;np.newaxis&lt;/code&gt; 은 한 번 사용할 때 하나 개의 차원으로 배열의 크기를 증가시킬 것이다. &amp;bull; 그래도이 수단 &lt;strong&gt;1 차원&lt;/strong&gt; 배열이 될 것입니다 &lt;strong&gt;2 차원&lt;/strong&gt; 배열은 &lt;strong&gt;2 차원&lt;/strong&gt; 배열이 될 것이다 &lt;strong&gt;차원&lt;/strong&gt; 등등 배열합니다.</target>
        </trans-unit>
        <trans-unit id="191982a04357e09366b8b88accf4a58472233372" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;runtests.py&lt;/code&gt; is the recommended approach to running tests. There are also a number of alternatives to it, for example in-place build or installing to a virtualenv. See the FAQ below for details.</source>
          <target state="translated">&lt;code&gt;runtests.py&lt;/code&gt; 사용 은 테스트 실행에 권장되는 접근 방식입니다. 예를 들어 인플레 이스 빌드 또는 virtualenv에 설치와 같은 여러 대안이 있습니다. 자세한 내용은 아래 FAQ를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f797cc0ae3c70b42806d8484c2173341138aa334" translate="yes" xml:space="preserve">
          <source>Using Eclipse/PyDev with Anaconda/conda Python (or environments)</source>
          <target state="translated">Anaconda / conda Python (또는 환경)과 함께 Eclipse / PyDev 사용</target>
        </trans-unit>
        <trans-unit id="0f4523c954e2a9e31bfb34aa3f197069ed09884a" translate="yes" xml:space="preserve">
          <source>Using F2PY</source>
          <target state="translated">F2PY 사용</target>
        </trans-unit>
        <trans-unit id="b5ca717d067542a1c5fc904dd82ea349b1543085" translate="yes" xml:space="preserve">
          <source>Using F2PY bindings in Python</source>
          <target state="translated">Python에서 F2PY 바인딩 사용</target>
        </trans-unit>
        <trans-unit id="805e17bb02b4c971b82b3da2b45fde14cdb9678e" translate="yes" xml:space="preserve">
          <source>Using NumPy C-API</source>
          <target state="translated">NumPy C-API 사용</target>
        </trans-unit>
        <trans-unit id="9c7bc452a9834b5876e355900cc35464401d0f74" translate="yes" xml:space="preserve">
          <source>Using PyCharm with Anaconda/conda Python</source>
          <target state="translated">Anaconda / conda Python과 함께 PyCharm 사용</target>
        </trans-unit>
        <trans-unit id="b9863374b5764d5e46c1682602eaea50268a1efa" translate="yes" xml:space="preserve">
          <source>Using Python as glue</source>
          <target state="translated">Python을 접착제로 사용</target>
        </trans-unit>
        <trans-unit id="6f2e5d63438a571f3123ef33ae03e1d5f2864e48" translate="yes" xml:space="preserve">
          <source>Using Python from &lt;code&gt;conda&lt;/code&gt; (Anaconda)</source>
          <target state="translated">&lt;code&gt;conda&lt;/code&gt; (Anaconda) 에서 Python 사용</target>
        </trans-unit>
        <trans-unit id="e43089c0ec4ca3358f03ef23a9043bc3004dbaed" translate="yes" xml:space="preserve">
          <source>Using VSCode with Anaconda/conda Python (or environments)</source>
          <target state="translated">Anaconda / conda Python (또는 환경)에서 VSCode 사용</target>
        </trans-unit>
        <trans-unit id="e7d91cc202089a17bf1dca7f6ffac1974935ce7f" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유연한 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; 사용&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4ecb91f09183edc4f23a5cc314556ac8c1af3c8" translate="yes" xml:space="preserve">
          <source>Using a flexible &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">유연한 &lt;code&gt;dtype&lt;/code&gt; 사용 .</target>
        </trans-unit>
        <trans-unit id="cfac66afdbdc20a411f9f9f200f87cdcbe870cdd" translate="yes" xml:space="preserve">
          <source>Using a view to convert an array to a recarray:</source>
          <target state="translated">뷰를 사용하여 배열을 recarray로 변환 :</target>
        </trans-unit>
        <trans-unit id="a4fb72e0c5f0602466b0b452237f4e23496663cc" translate="yes" xml:space="preserve">
          <source>Using an External Loop</source>
          <target state="translated">외부 루프 사용</target>
        </trans-unit>
        <trans-unit id="f210f428b873c49c7b2b57aa15cfa3164fde53af" translate="yes" xml:space="preserve">
          <source>Using an instance of &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; as a context manager allows statements in that context to execute with a known error handling behavior. Upon entering the context the error handling is set with &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;, and upon exiting it is reset to what it was before.</source>
          <target state="translated">컨텍스트 관리자로 &lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하면 해당 컨텍스트의 명령문이 알려진 오류 처리 동작으로 실행될 수 있습니다. 컨텍스트에 들어가면 오류 처리는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; 로&lt;/a&gt; 설정 되며 종료시 이전 상태로 재설정됩니다.</target>
        </trans-unit>
        <trans-unit id="d1fe8e1d4770589cbebb7564eb13c83317ecba70" translate="yes" xml:space="preserve">
          <source>Using an ndpointer class in the argtypes method can make it significantly safer to call a C function using ctypes and the data- area of an ndarray. You may still want to wrap the function in an additional Python wrapper to make it user-friendly (hiding some obvious arguments and making some arguments output arguments). In this process, the &lt;code&gt;requires&lt;/code&gt; function in NumPy may be useful to return the right kind of array from a given input.</source>
          <target state="translated">argtypes 메서드에서 ndpointer 클래스를 사용하면 ctypes와 ndarray의 데이터 영역을 사용하여 C 함수를 호출하는 것이 훨씬 더 안전해질 수 있습니다. 사용자 친화적으로 만들기 위해 추가 Python 래퍼로 함수를 래핑 할 수도 있습니다 (명백한 인수를 숨기고 일부 인수를 출력 인수로 만들기). 이 과정 에서 NumPy 의 &lt;code&gt;requires&lt;/code&gt; 함수는 주어진 입력에서 올바른 종류의 배열을 반환하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7af0c7a348040b3b4ff1744a0608d17163c9138e" translate="yes" xml:space="preserve">
          <source>Using array-protocol type strings:</source>
          <target state="translated">배열 프로토콜 유형 문자열 사용 :</target>
        </trans-unit>
        <trans-unit id="fd7054fa064ad2611d4b7d00df8240d7735e3c37" translate="yes" xml:space="preserve">
          <source>Using array-scalar type:</source>
          <target state="translated">배열 스칼라 타입 사용하기 :</target>
        </trans-unit>
        <trans-unit id="03a2b430abf28e746816ea1cff1b193db00a94c9" translate="yes" xml:space="preserve">
          <source>Using comma-separated field formats. The shape is (2,3):</source>
          <target state="translated">쉼표로 구분 된 필드 형식 사용 모양은 (2,3)입니다.</target>
        </trans-unit>
        <trans-unit id="e282c417933d97d3a53a56d481d1f405a74c7c0d" translate="yes" xml:space="preserve">
          <source>Using complex sequences:</source>
          <target state="translated">복잡한 시퀀스 사용하기 :</target>
        </trans-unit>
        <trans-unit id="eb191c9fcdc8ee9e52364b3acea1bba66afa1818" translate="yes" xml:space="preserve">
          <source>Using ctypes is a powerful way to connect Python with arbitrary C-code. Its advantages for extending Python include</source>
          <target state="translated">ctypes를 사용하는 것은 Python을 임의의 C 코드와 연결하는 강력한 방법입니다. Python 확장의 장점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="26e522c98bd807e94f2ab9fc3a1975ce203f287e" translate="yes" xml:space="preserve">
          <source>Using dictionaries. Two fields named &amp;lsquo;gender&amp;rsquo; and &amp;lsquo;age&amp;rsquo;:</source>
          <target state="translated">사전 사용. '성별'과 '나이'라는 두 필드 :</target>
        </trans-unit>
        <trans-unit id="af330b02f13d207e5fac3c22b8c9bdbaab36afee" translate="yes" xml:space="preserve">
          <source>Using dtype = None</source>
          <target state="translated">dtype = None 사용</target>
        </trans-unit>
        <trans-unit id="78961faefc955a768bc7940893e23db94f94772b" translate="yes" xml:space="preserve">
          <source>Using masked arrays to see COVID-19 data</source>
          <target state="translated">마스킹 된 배열을 사용하여 COVID-19 데이터보기</target>
        </trans-unit>
        <trans-unit id="00ac7fffb347ca02e4efcd6c4f0a66db988cde12" translate="yes" xml:space="preserve">
          <source>Using missing and filling values</source>
          <target state="translated">누락 및 채우기 값 사용</target>
        </trans-unit>
        <trans-unit id="8d2131672fafcfdf449f29b29350743e40c17d69" translate="yes" xml:space="preserve">
          <source>Using months for the unit:</source>
          <target state="translated">단위에 개월 사용 :</target>
        </trans-unit>
        <trans-unit id="68007c19f643deebacff69bbb71fb357fa3f341a" translate="yes" xml:space="preserve">
          <source>Using non-symbol-suffixed 64-bit BLAS/LAPACK in a program that also uses 32-bit BLAS/LAPACK can cause crashes under certain conditions (e.g. with embedded Python interpreters on Linux).</source>
          <target state="translated">32 비트 BLAS / LAPACK을 사용하는 프로그램에서 기호 접미사가없는 64 비트 BLAS / LAPACK을 사용하면 특정 조건 (예 : Linux에 내장 된 Python 인터프리터 사용)에서 충돌이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f696379652fe6905a66fc5fd2b9273fa2471296" translate="yes" xml:space="preserve">
          <source>Using numpy.i</source>
          <target state="translated">numpy.i 사용</target>
        </trans-unit>
        <trans-unit id="e8111da9fdc8286f7fa1decedd3c62fdfaa40d28" translate="yes" xml:space="preserve">
          <source>Using numpy.ma</source>
          <target state="translated">numpy.ma 사용</target>
        </trans-unit>
        <trans-unit id="fca1ba2673c50c8d4a43a28f5b4401d362ff3c79" translate="yes" xml:space="preserve">
          <source>Using numpy.random.binomial may change the RNG state vs. numpy &amp;lt; 1.9</source>
          <target state="translated">numpy.random.binomial을 사용하면 RNG 상태와 numpy &amp;lt;1.9가 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03252764a2ca129ee8f53a1ebcd3c94ffd3382b7" translate="yes" xml:space="preserve">
          <source>Using poly1d objects:</source>
          <target state="translated">poly1d 객체 사용 :</target>
        </trans-unit>
        <trans-unit id="79eb3bbcb08c7d6704be86d77b0727b917270b3d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute matrix norms:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 행렬 규범 계산 :</target>
        </trans-unit>
        <trans-unit id="9e684f49459c0d5aba4c5f2579aeb17add74610d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;axis&lt;/code&gt; argument to compute vector norms:</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 인수를 사용하여 벡터 규범 계산 :</target>
        </trans-unit>
        <trans-unit id="0049dd8bb80b8109d30cf294edeebc9226866484" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;copy&lt;/code&gt; method will make a complete copy of the array and its data (a &lt;em&gt;deep copy&lt;/em&gt;). To use this on your array, you could run:</source>
          <target state="translated">&lt;code&gt;copy&lt;/code&gt; 방법을 사용하면 배열과 데이터의 완전한 사본이 만들어집니다 ( &lt;em&gt;딥 사본&lt;/em&gt; ). 이를 어레이에서 사용하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9ba36c2f053a06ac3abc3a930f4a1d05aada052" translate="yes" xml:space="preserve">
          <source>Using the Convenience Classes</source>
          <target state="translated">편의 클래스 사용</target>
        </trans-unit>
        <trans-unit id="1bd2966f639ab87086919a9a710a3ff850eadf79" translate="yes" xml:space="preserve">
          <source>Using the Einstein summation convention, many common multi-dimensional, linear algebraic array operations can be represented in a simple fashion. In &lt;em&gt;implicit&lt;/em&gt; mode &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; computes these values.</source>
          <target state="translated">아인슈타인 합산 규칙을 ​​사용하면 많은 일반적인 다차원 선형 대수 배열 연산을 간단한 방식으로 표현할 수 있습니다. 에서 &lt;em&gt;암시 적&lt;/em&gt; 모드 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; 이 값을 계산한다.</target>
        </trans-unit>
        <trans-unit id="44ec7387e738c4a2877c9993514a14374905ca3a" translate="yes" xml:space="preserve">
          <source>Using the aliases of builtin types like &lt;code&gt;np.int&lt;/code&gt; is deprecated</source>
          <target state="translated">&lt;code&gt;np.int&lt;/code&gt; 와 같은 내장 유형의 별칭을 사용하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="75da2a462c666654f41a122b8cf7201ccca6f453" translate="yes" xml:space="preserve">
          <source>Using the casting rules</source>
          <target state="translated">캐스팅 규칙 사용</target>
        </trans-unit>
        <trans-unit id="eed50259686b11043b2277964d70797ed9e23c6d" translate="yes" xml:space="preserve">
          <source>Using the new casting implementation</source>
          <target state="translated">새로운 캐스팅 구현 사용</target>
        </trans-unit>
        <trans-unit id="a7a6cb5aa0103dc18935f9ad693972e0008b2a2f" translate="yes" xml:space="preserve">
          <source>Using the object looks like this:</source>
          <target state="translated">개체 사용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0e2a18ad6df592872579dd4bbee44818b7034db3" translate="yes" xml:space="preserve">
          <source>Using these #defines you can use the C-API in multiple files for a single extension module. In each file you must define &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; to some name that will hold the C-API (&lt;em&gt;e.g.&lt;/em&gt; myextension_ARRAY_API). This must be done &lt;strong&gt;before&lt;/strong&gt; including the numpy/arrayobject.h file. In the module initialization routine you call &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt;. In addition, in the files that do not have the module initialization sub_routine define &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; prior to including numpy/arrayobject.h.</source>
          <target state="translated">이러한 #defines를 사용하면 단일 확장 모듈에 대해 여러 파일에서 C-API를 사용할 수 있습니다. 각 파일에서 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; &lt;/a&gt; 을 C-API를 보유 할 이름으로 정의해야합니다 ( &lt;em&gt;예 :&lt;/em&gt; myextension_ARRAY_API). numpy / arrayobject.h 파일을 포함시키기 &lt;strong&gt;전에&lt;/strong&gt; 수행해야 합니다. 모듈 초기화 루틴에서 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 를 호출 합니다 . 또한 모듈 초기화 하위 _ 루틴이없는 파일에서 NO_IMPORT_ARRAY를 정의 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; &lt;/a&gt; NumPy와 / arrayobject.h 포함하기 전에.</target>
        </trans-unit>
        <trans-unit id="315900bdae1d95768693f5caf49a459c0e9247e8" translate="yes" xml:space="preserve">
          <source>Using this result to index &lt;code&gt;a&lt;/code&gt; is equivalent to using the mask directly:</source>
          <target state="translated">이 결과를 사용하여 &lt;code&gt;a&lt;/code&gt; 를 색인화 하는 것은 마스크를 직접 사용하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2b3c55a8f302db1fd2b8e30d4741e13199d60cd0" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt;), will be about</source>
          <target state="translated">이 체계를 사용하면 파생되는 스트림의 수를 알고있는 경우 충돌 확률의 상한을 추정 할 수 있습니다. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; 는 기본적으로&lt;/a&gt; 시드와 스폰 트리 경로 모두의 입력을 128 비트 풀로 해시합니다. 비관적으로 추정 된 ( &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; ) 풀에 충돌이있을 확률은 약</target>
        </trans-unit>
        <trans-unit id="f1e207983fdf75c13618b12af3dac2cc9b09a86a" translate="yes" xml:space="preserve">
          <source>Using this scheme, an upper bound on the probability of a collision can be estimated if one knows the number of streams that you derive. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; hashes its inputs, both the seed and the spawn-tree-path, down to a 128-bit pool by default. The probability that there is a collision in that pool, pessimistically-estimated (&lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;), will be about</source>
          <target state="translated">이 체계를 사용하면, 유도하는 스트림의 수를 알면 충돌 확률의 상한을 추정 할 수 있습니다. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; 는 기본적으로&lt;/a&gt; 시드와 스폰 트리 경로의 입력을 128 비트 풀로 해시합니다. 비수 적으로 추정 된 풀에 충돌이있을 확률은 대략 &lt;a href=&quot;#id3&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81f2b8dfbfc71c96c12b186f5770d7cbd6cb20f2" translate="yes" xml:space="preserve">
          <source>Using tuples. &lt;code&gt;int&lt;/code&gt; is a fixed type, 3 the field&amp;rsquo;s shape. &lt;code&gt;void&lt;/code&gt; is a flexible type, here of size 10:</source>
          <target state="translated">튜플 사용. &lt;code&gt;int&lt;/code&gt; 는 고정 된 유형이며, 3 필드의 모양입니다. &lt;code&gt;void&lt;/code&gt; 는 크기 10의 유연한 유형입니다.</target>
        </trans-unit>
        <trans-unit id="824f10f86cbfa339b11bf5f57f7a0ce042086b4a" translate="yes" xml:space="preserve">
          <source>Using via &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils&lt;/code&gt; 를 통해 사용</target>
        </trans-unit>
        <trans-unit id="6043061ff0da53be43d1b2e098be1b0520525dba" translate="yes" xml:space="preserve">
          <source>Using via numpy.distutils</source>
          <target state="translated">numpy.distutils를 통해 사용</target>
        </trans-unit>
        <trans-unit id="73888fb9a3aa49066395d1b7748b2f3a75b9907a" translate="yes" xml:space="preserve">
          <source>Using virtualenvs</source>
          <target state="translated">virtualenvs 사용</target>
        </trans-unit>
        <trans-unit id="ef8b4345a7cc12338d15d1fb67d9e4a4feb23426" translate="yes" xml:space="preserve">
          <source>Usually denoted</source>
          <target state="translated">일반적으로 표시</target>
        </trans-unit>
        <trans-unit id="9efea8253bd046afd804470a677e434b3a6392ca" translate="yes" xml:space="preserve">
          <source>Usually there is no need to worry about how the arrays are stored in memory and whether the wrapped functions, being either Fortran or C functions, assume one or another storage order. F2PY automatically ensures that wrapped functions get arguments with proper storage order; the corresponding algorithm is designed to make copies of arrays only when absolutely necessary. However, when dealing with very large multidimensional input arrays with sizes close to the size of the physical memory in your computer, then a care must be taken to use always proper-contiguous and proper type arguments.</source>
          <target state="translated">일반적으로 배열이 메모리에 저장되는 방법과 Fortran 또는 C 함수 인 래핑 된 함수가 하나 또는 다른 저장 순서를 가정하는지 여부에 대해 걱정할 필요가 없습니다. F2PY는 래핑 된 함수가 적절한 저장 순서로 인수를 받도록 자동으로 보장합니다. 해당 알고리즘은 절대적으로 필요한 경우에만 배열의 복사본을 만들도록 설계되었습니다. 그러나 컴퓨터의 실제 메모리 크기에 가까운 크기의 매우 큰 다차원 입력 배열을 처리 할 때는 항상 적절하고 연속적인 적절한 형식 인수를 사용하도록주의해야합니다.</target>
        </trans-unit>
        <trans-unit id="409d8adcbc7ff9f8ede9fa136b31fc43f33b4ab8" translate="yes" xml:space="preserve">
          <source>Usually, defining a dtype is sufficient to define how the sequence of strings must be converted. However, some additional control may sometimes be required. For example, we may want to make sure that a date in a format &lt;code&gt;YYYY/MM/DD&lt;/code&gt; is converted to a &lt;a href=&quot;https://docs.python.org/dev/library/datetime.html#datetime.datetime&quot;&gt;&lt;code&gt;datetime&lt;/code&gt;&lt;/a&gt; object, or that a string like &lt;code&gt;xx%&lt;/code&gt; is properly converted to a float between 0 and 1. In such cases, we should define conversion functions with the &lt;code&gt;converters&lt;/code&gt; arguments.</source>
          <target state="translated">일반적으로 dtype을 정의하면 문자열 시퀀스를 변환하는 방법을 정의하는 데 충분합니다. 그러나 일부 추가 제어가 필요할 수 있습니다. 예를 들어, &lt;code&gt;YYYY/MM/DD&lt;/code&gt; 형식 의 &lt;a href=&quot;https://docs.python.org/dev/library/datetime.html#datetime.datetime&quot;&gt; &lt;code&gt;datetime&lt;/code&gt; &lt;/a&gt; 가 datetime 객체 로 변환되었는지 확인 하거나 &lt;code&gt;xx%&lt;/code&gt; 와 같은 문자열 이 0과 1 사이의 부동 소수점으로 올바르게 변환되도록 할 수 있습니다. &lt;code&gt;converters&lt;/code&gt; 인수 로 변환 함수를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="04880c31a806536e09375a28b6393c4ae89b3000" translate="yes" xml:space="preserve">
          <source>Usually, defining a dtype is sufficient to define how the sequence of strings must be converted. However, some additional control may sometimes be required. For example, we may want to make sure that a date in a format &lt;code&gt;YYYY/MM/DD&lt;/code&gt; is converted to a &lt;code&gt;datetime&lt;/code&gt; object, or that a string like &lt;code&gt;xx%&lt;/code&gt; is properly converted to a float between 0 and 1. In such cases, we should define conversion functions with the &lt;code&gt;converters&lt;/code&gt; arguments.</source>
          <target state="translated">일반적으로 dtype을 정의하면 문자열 시퀀스를 변환하는 방법을 정의하는 데 충분합니다. 그러나 일부 추가 제어가 필요할 수 있습니다. 예를 들어, &lt;code&gt;YYYY/MM/DD&lt;/code&gt; 형식 의 &lt;code&gt;datetime&lt;/code&gt; 가 datetime 객체 로 변환되었는지 확인 하거나 &lt;code&gt;xx%&lt;/code&gt; 와 같은 문자열 이 0과 1 사이의 부동 소수점으로 올바르게 변환되도록 할 수 있습니다. &lt;code&gt;converters&lt;/code&gt; 인수 로 변환 함수를 정의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="a5abc30aa6f2b926c1472fe22071db5adb16a0bc" translate="yes" xml:space="preserve">
          <source>Usually, however, adding the &lt;code&gt;tests/&lt;/code&gt; directory to the python path isn&amp;rsquo;t desirable. Instead it would better to invoke the test straight from the module &lt;code&gt;xxx&lt;/code&gt;. To this end, simply place the following lines at the end of your package&amp;rsquo;s &lt;code&gt;__init__.py&lt;/code&gt; file:</source>
          <target state="translated">그러나 일반적으로 python 경로에 &lt;code&gt;tests/&lt;/code&gt; 디렉토리를 추가하는 것은 바람직하지 않습니다. 대신 &lt;code&gt;xxx&lt;/code&gt; 모듈에서 직접 테스트를 호출하는 것이 좋습니다 . 이를 위해 패키지의 &lt;code&gt;__init__.py&lt;/code&gt; 파일 끝에 다음 줄을 추가하면 됩니다.</target>
        </trans-unit>
        <trans-unit id="89189507b2a074e98b2e877227343a6e1f27b3ab" translate="yes" xml:space="preserve">
          <source>Utility</source>
          <target state="translated">Utility</target>
        </trans-unit>
        <trans-unit id="6be23322b56766a1db9b8621387497e594f16d2d" translate="yes" xml:space="preserve">
          <source>Utility classes and functions for the polynomial modules.</source>
          <target state="translated">다항식 모듈의 유틸리티 클래스 및 함수</target>
        </trans-unit>
        <trans-unit id="c9ee5681d3c59f7541c27a38b67edf46259e187b" translate="yes" xml:space="preserve">
          <source>V</source>
          <target state="translated">V</target>
        </trans-unit>
        <trans-unit id="d00ce61cfc8e3df435adebc36c2fa866be4f94a4" translate="yes" xml:space="preserve">
          <source>Valid dtype for all arrays</source>
          <target state="translated">모든 배열에 유효한 dtype</target>
        </trans-unit>
        <trans-unit id="1221b238d98a98303bde26ccb737f70710cfeaec" translate="yes" xml:space="preserve">
          <source>Valid dtype for array.</source>
          <target state="translated">배열에 유효한 dtype입니다.</target>
        </trans-unit>
        <trans-unit id="7c5b11cbfd943ab04293f9f062d297257b4ba0e8" translate="yes" xml:space="preserve">
          <source>Validating names</source>
          <target state="translated">이름 확인</target>
        </trans-unit>
        <trans-unit id="3522db33c6e586ed6f52f3af3bea08c2509cdaed" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed.</source>
          <target state="translated">마스크 된 배열에 유효하지 않은 항목이 없음을 나타내는 값입니다. 마스크가 필요하지 않은 경우 계산 속도를 높이기 위해 &lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 내부적으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a1c7830f6acd0062d2809fbc11f2bfb2e8aedd16" translate="yes" xml:space="preserve">
          <source>Value indicating that a masked array has no invalid entry. &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is used internally to speed up computations when the mask is not needed. It is represented internally as &lt;code&gt;np.False_&lt;/code&gt;.</source>
          <target state="translated">마스크 된 배열에 잘못된 항목이 없음을 나타내는 값입니다. 마스크가 필요하지 않을 때 계산 속도를 높이기 위해 내부적으로 &lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 가 사용됩니다. 내부적으로 &lt;code&gt;np.False_&lt;/code&gt; 로 표시 됩니다.</target>
        </trans-unit>
        <trans-unit id="0b9ec234c1eee91fedfeaba35509216217fe21cd" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;operands&lt;/code&gt; at current iteration. Normally, this is a tuple of array scalars, but if the flag &lt;code&gt;external_loop&lt;/code&gt; is used, it is a tuple of one dimensional arrays.</source>
          <target state="translated">현재 반복에서 &lt;code&gt;operands&lt;/code&gt; 값입니다 . 일반적으로 이것은 배열 스칼라의 튜플이지만 &lt;code&gt;external_loop&lt;/code&gt; 플래그 를 사용하면 1 차원 배열의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="d866e0938fcfdf12b88042317593d4295facb33c" translate="yes" xml:space="preserve">
          <source>Value to be placed in field.</source>
          <target state="translated">필드에 배치 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4ba37300f6a7d1d653bfd085d1c3e62828c53205" translate="yes" xml:space="preserve">
          <source>Value to be used to fill NaN values. If no value is passed then NaN values will be replaced with 0.0.</source>
          <target state="translated">NaN 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 NaN 값이 0.0으로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="73822c64a61d90da64aca29978cabf65524aa150" translate="yes" xml:space="preserve">
          <source>Value to be used to fill negative infinity values. If no value is passed then negative infinity values will be replaced with a very small (or negative) number.</source>
          <target state="translated">음의 무한대 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 음의 무한대 값이 매우 작은 (또는 음수) 숫자로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="f4796b06e4cb3d07bcdfe89591ec37b878b0609f" translate="yes" xml:space="preserve">
          <source>Value to be used to fill positive infinity values. If no value is passed then positive infinity values will be replaced with a very large number.</source>
          <target state="translated">양의 무한대 값을 채우는 데 사용되는 값입니다. 값이 전달되지 않으면 양의 무한대 값이 매우 큰 숫자로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="f7cccdf775f458dbd65351fa14dd9eb110134681" translate="yes" xml:space="preserve">
          <source>Value to be written on the diagonal, its type must be compatible with that of the array a.</source>
          <target state="translated">대각선에 쓰여질 값. 그 타입은 배열의 타입과 호환 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="715dcdd8f6ff522d4658e491027e9aae31a8b5e6" translate="yes" xml:space="preserve">
          <source>Value to format.</source>
          <target state="translated">형식화 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="3d3e32ccc4b0ab4e1f0dc806d286fb59b6c443d6" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt;, default is &lt;code&gt;fp[-1]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;gt; xp[-1]&lt;/code&gt; 대해 반환 할 값 입니다. 기본값은 &lt;code&gt;fp[-1]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="26d4865cbe90216e1386cb06fe27a2a8a2fdea6f" translate="yes" xml:space="preserve">
          <source>Value to return for &lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt;, default is &lt;code&gt;fp[0]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x &amp;lt; xp[0]&lt;/code&gt; 대해 반환 할 값 입니다. 기본값은 &lt;code&gt;fp[0]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="d7a5e0e3824dade99c632ba9171e408c2ecc5e00" translate="yes" xml:space="preserve">
          <source>Value used for fixing invalid data. Default is None, in which case the &lt;code&gt;a.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">유효하지 않은 데이터를 수정하는 데 사용되는 값입니다. 기본값은 없음이며,이 경우 &lt;code&gt;a.fill_value&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="69ddc9b73f581b3343b0affbf7e4377d672439b1" translate="yes" xml:space="preserve">
          <source>Value used internally for the masked values. If &lt;code&gt;fill_value&lt;/code&gt; is not None, it supersedes &lt;code&gt;endwith&lt;/code&gt;.</source>
          <target state="translated">마스크 된 값에 내부적으로 사용되는 값입니다. &lt;code&gt;fill_value&lt;/code&gt; 가 None이 아닌 경우 &lt;code&gt;endwith&lt;/code&gt; 로 대체 됩니다 .</target>
        </trans-unit>
        <trans-unit id="328663db0b3aba67f0d82903937cd9193c3e207c" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values when necessary. If None, a default based on the data-type is used.</source>
          <target state="translated">필요한 경우 마스크 된 값을 채우는 데 사용되는 값입니다. 없음 인 경우 데이터 유형을 기반으로하는 기본값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ac07a9705ce80720af8585478b1d81e8b7b8b456" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다.</target>
        </trans-unit>
        <trans-unit id="86e71cf73f1d7bc170999262699205370f1f93e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;MaskedArray.fill_value&lt;/code&gt;&lt;/a&gt; is used.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 기본값은 None이며,이 경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; &lt;/a&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8d8761f6b2df3e19fd6227b05e79d17f94c040e4" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. Default is None, in which case &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; is used.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 기본값은 None이며,이 경우 &lt;code&gt;MaskedArray.fill_value&lt;/code&gt; 가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="19866b65a013a0eb3c733fc479da8433fc02a5f3" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of maximum_fill_value(self._data) is used instead.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 maximum_fill_value (self._data)의 출력이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5c0a58c6eeb18776376a78bc0a9866ce44b1ad27" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, the output of minimum_fill_value(self._data) is used instead.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 minimum_fill_value (self._data)의 출력이 대신 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07a803442a8c55907703d44ba611d57fdb6545b5" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;a href=&quot;numpy.ma.minimum_fill_value#numpy.ma.minimum_fill_value&quot;&gt;&lt;code&gt;minimum_fill_value&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 &lt;a href=&quot;numpy.ma.minimum_fill_value#numpy.ma.minimum_fill_value&quot;&gt; &lt;code&gt;minimum_fill_value&lt;/code&gt; &lt;/a&gt; 의 출력을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="752e711d9ae184609f9efa220ffeb98e2623ff23" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of &lt;code&gt;minimum_fill_value&lt;/code&gt;.</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. 없음 인 경우 &lt;code&gt;minimum_fill_value&lt;/code&gt; 출력을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="94b3fde97e6b1196d461cd6d1087f12e6dea54b2" translate="yes" xml:space="preserve">
          <source>Value used to fill in the masked values. If None, use the output of maximum_fill_value().</source>
          <target state="translated">마스크 된 값을 채우는 데 사용되는 값입니다. None이면 maximum_fill_value ()의 출력을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="017e62bc34ab2d5b5f6988aa11de1c343e6dfb88" translate="yes" xml:space="preserve">
          <source>Value(s) to write on the diagonal. If &lt;code&gt;val&lt;/code&gt; is scalar, the value is written along the diagonal. If array-like, the flattened &lt;code&gt;val&lt;/code&gt; is written along the diagonal, repeating if necessary to fill all diagonal entries.</source>
          <target state="translated">대각선에 쓸 값입니다. 경우 &lt;code&gt;val&lt;/code&gt; 스칼라 값은 대각선을 따라 작성되었습니다. 배열과 같은 경우 평면화 된 &lt;code&gt;val&lt;/code&gt; 은 대각선을 따라 작성되며 필요한 경우 모든 대각선 항목을 채우기 위해 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="ca5e1888f7ff9f4679a3377b455596a48d014681" translate="yes" xml:space="preserve">
          <source>ValueError</source>
          <target state="translated">ValueError</target>
        </trans-unit>
        <trans-unit id="cff85a0729a85ef9e54dee30d0bb637ac055b748" translate="yes" xml:space="preserve">
          <source>ValueError: shape mismatch</source>
          <target state="translated">ValueError : 모양 불일치</target>
        </trans-unit>
        <trans-unit id="eddd55b4550fcb347a1d6bf73a696e1497719104" translate="yes" xml:space="preserve">
          <source>Values are appended to a copy of this array.</source>
          <target state="translated">이 배열의 사본에 값이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="24421420351a973d79bcca3d2ef0e453017e616f" translate="yes" xml:space="preserve">
          <source>Values are generated within the half-open interval &lt;code&gt;[start, stop)&lt;/code&gt; (in other words, the interval including &lt;code&gt;start&lt;/code&gt; but excluding &lt;code&gt;stop&lt;/code&gt;). For integer arguments the function is equivalent to the Python built-in &lt;code&gt;range&lt;/code&gt; function, but returns an ndarray rather than a list.</source>
          <target state="translated">반 개방 간격 &lt;code&gt;[start, stop)&lt;/code&gt; 내에서 값이 생성됩니다 (즉, &lt;code&gt;start&lt;/code&gt; 를 포함 하지만 &lt;code&gt;stop&lt;/code&gt; 을 제외한 간격 ). 정수 인수의 경우 함수는 Python 내장 &lt;code&gt;range&lt;/code&gt; 함수와 동일하지만 목록이 아닌 ndarray를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="38b38aff8e14ce007107a5b62d7837a43399e916" translate="yes" xml:space="preserve">
          <source>Values at which the weight function will be computed.</source>
          <target state="translated">가중치 함수가 계산 될 값입니다.</target>
        </trans-unit>
        <trans-unit id="8afc1edfb8d26a9a4bac7610a9a2ed43bc17c240" translate="yes" xml:space="preserve">
          <source>Values from which to choose. &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;condition&lt;/code&gt; need to be broadcastable to some shape.</source>
          <target state="translated">선택할 값입니다. &lt;code&gt;x&lt;/code&gt; , &lt;code&gt;y&lt;/code&gt; 및 &lt;code&gt;condition&lt;/code&gt; 은 어떤 형태로도 방송 가능해야합니다.</target>
        </trans-unit>
        <trans-unit id="55fd9fa348e62e91b8d05086f74314a1ab640581" translate="yes" xml:space="preserve">
          <source>Values in &lt;code&gt;i&lt;/code&gt; of less than 0 are treated as 0 (which yields an empty string).</source>
          <target state="translated">&lt;code&gt;i&lt;/code&gt; 보다 작은 i 의 값은 0으로 처리됩니다 (빈 문자열 생성).</target>
        </trans-unit>
        <trans-unit id="c01309d65a99b72623b37f6cd9a8f8ab7021db81" translate="yes" xml:space="preserve">
          <source>Values of the dictionary are strings or sequence of strings. The corresponding keys can be column indices (integers) or column names (strings). In addition, the special key &lt;code&gt;None&lt;/code&gt; can be used to define a default applicable to all columns.</source>
          <target state="translated">사전의 값은 문자열 또는 문자열 시퀀스입니다. 해당 키는 열 인덱스 (정수) 또는 열 이름 (문자열) 일 수 있습니다. 또한 특수 키 &lt;code&gt;None&lt;/code&gt; 을 사용하여 모든 열에 적용 할 수있는 기본값을 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c0da0f066601a2a9367e697b89519e6b0c50e33e" translate="yes" xml:space="preserve">
          <source>Values to change the sign of.</source>
          <target state="translated">부호를 변경할 값입니다.</target>
        </trans-unit>
        <trans-unit id="4158750ed1844d81234e02100fb4f6a0ce246137" translate="yes" xml:space="preserve">
          <source>Values to find the next representable value of.</source>
          <target state="translated">다음으로 표현 가능한 값을 찾는 값입니다.</target>
        </trans-unit>
        <trans-unit id="beb9a9be5bcba10dec2aa7359c7898f16a9d7ca8" translate="yes" xml:space="preserve">
          <source>Values to find the spacing of.</source>
          <target state="translated">간격을 찾을 값입니다.</target>
        </trans-unit>
        <trans-unit id="3b61fff151ba4cdc5d10abd1dbdd04d94f432686" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">값으로 삽입 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19b54e21994fdcbd2ab01d7104b74c970245cfe1" translate="yes" xml:space="preserve">
          <source>Values to insert into &lt;code&gt;arr&lt;/code&gt;. If the type of &lt;code&gt;values&lt;/code&gt; is different from that of &lt;code&gt;arr&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt; is converted to the type of &lt;code&gt;arr&lt;/code&gt;. &lt;code&gt;values&lt;/code&gt; should be shaped so that &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; is legal.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 에 삽입 할 값 입니다. &lt;code&gt;values&lt;/code&gt; 의 유형이 &lt;code&gt;arr&lt;/code&gt; 과 다른 경우 &lt;code&gt;values&lt;/code&gt; 은 &lt;code&gt;arr&lt;/code&gt; 유형으로 변환됩니다 . &lt;code&gt;arr[...,obj,...] = values&lt;/code&gt; 이 유효 하도록 &lt;code&gt;values&lt;/code&gt; 을 형성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="817bf23706b268004f4bf56ee98317c1ad7d150d" translate="yes" xml:space="preserve">
          <source>Values to place in &lt;code&gt;a&lt;/code&gt; at target indices. If &lt;code&gt;v&lt;/code&gt; is shorter than &lt;code&gt;ind&lt;/code&gt; it will be repeated as necessary.</source>
          <target state="translated">값에 배치 대상 인덱스에서. 경우 &lt;code&gt;v&lt;/code&gt; 보다 짧은 &lt;code&gt;ind&lt;/code&gt; 은 필요에 따라 반복됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a9be9f0fa346eb48800661efe4c9cdccf0a4d68a" translate="yes" xml:space="preserve">
          <source>Values to place in self._data copy at target indices.</source>
          <target state="translated">대상 인덱스에서 self._data 사본에 배치 할 값입니다.</target>
        </trans-unit>
        <trans-unit id="81f73f98efd45554f2765f8a372cd020b7023051" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &amp;ldquo;a&amp;rdquo; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &amp;ldquo;a&amp;rdquo; except along axis.</source>
          <target state="translated">차이를 수행하기 전에 축을 따라 &quot;a&quot;를 추가하거나 추가 할 값입니다. 스칼라 값은 축 방향으로 길이가 1이고 다른 모든 축을 따라 입력 배열의 모양으로 배열로 확장됩니다. 그렇지 않으면 치수와 모양이 축을 제외하고&amp;ldquo;a&amp;rdquo;와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e169e71a4b3659a2db1d8c19b6c033e97b1e36f" translate="yes" xml:space="preserve">
          <source>Values to prepend or append to &lt;code&gt;a&lt;/code&gt; along axis prior to performing the difference. Scalar values are expanded to arrays with length 1 in the direction of axis and the shape of the input array in along all other axes. Otherwise the dimension and shape must match &lt;code&gt;a&lt;/code&gt; except along axis.</source>
          <target state="translated">앞에 추가로 또는 추가하는 값 차이를 수행하기 전에 축을 따라. 스칼라 값은 축 방향으로 길이가 1이고 다른 모든 축을 따라 입력 배열의 모양이있는 배열로 확장됩니다. 그렇지 않으면 치수와 모양이 일치해야합니다 &lt;code&gt;a&lt;/code&gt; 축으로 따라 제외. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="462c5daaa1bebf27712ab1f9e6dff7991b7d4f2b" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt; where &lt;code&gt;mask&lt;/code&gt; is True. If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it will be repeated.</source>
          <target state="translated">값에 넣어 곳 &lt;code&gt;mask&lt;/code&gt; True입니다. 경우 &lt;code&gt;values&lt;/code&gt; 보다 작은 이 반복됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="25e7a819f368d39546137552cf420f108ade4ace" translate="yes" xml:space="preserve">
          <source>Values to put into &lt;code&gt;a&lt;/code&gt;. Only the first N elements are used, where N is the number of True values in &lt;code&gt;mask&lt;/code&gt;. If &lt;code&gt;vals&lt;/code&gt; is smaller than N, it will be repeated, and if elements of &lt;code&gt;a&lt;/code&gt; are to be masked, this sequence must be non-empty.</source>
          <target state="translated">값에 넣어 . 첫 번째 N 요소 만 사용되며 여기서 N은 &lt;code&gt;mask&lt;/code&gt; 의 True 값 수입니다 . 경우 &lt;code&gt;vals&lt;/code&gt; N보다 작은 경우는 반복 될 것이고, 요소 경우 &lt;code&gt;a&lt;/code&gt; 마스킹되어야하고,이 시퀀스는 비어 있어야한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60bd6b681e5d46e176fd602e7f740408a4b90a97" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix for powers.</source>
          <target state="translated">힘을위한 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="6401e380553d40526975bfbedfb18608ca5c00ad" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="ae6e82d94a52ea695163be06dc24993156d990a5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Hermite series.</source>
          <target state="translated">Hermite 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="a2d6130252c264087c83a0456898053f5cce8c9b" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of Legendre series.</source>
          <target state="translated">Legendre 시리즈의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="5d2bf93649140d94c435a78c84579d541c1303f5" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix of given degree.</source>
          <target state="translated">주어진 정도의 Vandermonde 매트릭스.</target>
        </trans-unit>
        <trans-unit id="315c420145ba2a2de3ef508e657b666b667d7db9" translate="yes" xml:space="preserve">
          <source>Vandermonde matrix. If &lt;code&gt;increasing&lt;/code&gt; is False, the first column is &lt;code&gt;x^(N-1)&lt;/code&gt;, the second &lt;code&gt;x^(N-2)&lt;/code&gt; and so forth. If &lt;code&gt;increasing&lt;/code&gt; is True, the columns are &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt;.</source>
          <target state="translated">방데 몬드 행렬. 만약 &lt;code&gt;increasing&lt;/code&gt; 거짓이고, 첫 번째 열은 &lt;code&gt;x^(N-1)&lt;/code&gt; , 제 &lt;code&gt;x^(N-2)&lt;/code&gt; 등. 경우 &lt;code&gt;increasing&lt;/code&gt; 참이고, 열은 &lt;code&gt;x^0, x^1, ..., x^(N-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fb0e847303b2656c561914c6c1fadfb2178ba16" translate="yes" xml:space="preserve">
          <source>Variable names are displayed in typewriter font, obtained by using &lt;code&gt;\mathtt{var}&lt;/code&gt;:</source>
          <target state="translated">변수 이름은 &lt;code&gt;\mathtt{var}&lt;/code&gt; 사용하여 얻은 타자기 글꼴로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ef7476851367ab64af3bc4c81c52e5e1e6857c25" translate="yes" xml:space="preserve">
          <source>Variables in Numpy which control and describe alignment</source>
          <target state="translated">정렬을 제어하고 설명하는 Numpy의 변수</target>
        </trans-unit>
        <trans-unit id="2a1f6fba473be39ef3c80a51eed0db143c77f764" translate="yes" xml:space="preserve">
          <source>Variance while not ignoring NaNs</source>
          <target state="translated">NaN을 무시하지 않는 동안의 차이</target>
        </trans-unit>
        <trans-unit id="8676fa65ac8cfd04cdda1d2741f1f3486c926b70" translate="yes" xml:space="preserve">
          <source>Various continuous integration (CI) services are triggered after each PR update to build the code, run unit tests, measure code coverage and check coding style of your branch. The CI tests must pass before your PR can be merged. If CI fails, you can find out why by clicking on the &amp;ldquo;failed&amp;rdquo; icon (red cross) and inspecting the build and test log. To avoid overuse and waste of this resource, &lt;a href=&quot;development_environment#recommended-development-setup&quot;&gt;test your work&lt;/a&gt; locally before committing.</source>
          <target state="translated">각 PR 업데이트 후에 다양한 CI (지속적 통합) 서비스가 트리거되어 코드를 빌드하고, 단위 테스트를 실행하고, 코드 적용 범위를 측정하고, 분기의 코딩 스타일을 확인합니다. PR을 병합하려면 먼저 CI 테스트를 통과해야합니다. CI가 실패하면 &quot;실패&quot;아이콘 (빨간색 십자가)을 클릭하고 빌드 및 테스트 로그를 검사하여 이유를 확인할 수 있습니다. 이 리소스의 남용 및 낭비를 방지하려면 커밋하기 전에 &lt;a href=&quot;development_environment#recommended-development-setup&quot;&gt;작업을&lt;/a&gt; 로컬 에서 테스트하십시오 .</target>
        </trans-unit>
        <trans-unit id="47604fcededf37e9515dbd4dd1f0e8ae5e2d23c4" translate="yes" xml:space="preserve">
          <source>Various fields have standard formats for array data. The following lists the ones with known python libraries to read them and return numpy arrays (there may be others for which it is possible to read and convert to numpy arrays so check the last section as well)</source>
          <target state="translated">다양한 필드에는 배열 데이터에 대한 표준 형식이 있습니다. 다음은 numpy 배열을 읽고 numpy 배열을 반환하는 알려진 python 라이브러리가있는 항목을 나열합니다 (읽고 numpy 배열로 변환 할 수있는 다른 항목도있을 수 있으므로 마지막 섹션도 확인하십시오)</target>
        </trans-unit>
        <trans-unit id="407b9055a29b3862ad6596884f933fb2e3b90801" translate="yes" xml:space="preserve">
          <source>Various windows</source>
          <target state="translated">다양한 창</target>
        </trans-unit>
        <trans-unit id="a77d3d622bb695acc100256fe700b0a21c995057" translate="yes" xml:space="preserve">
          <source>Vector Quantization J. Makhoul, S. Roucos, and H. Gish, &amp;ldquo;Vector Quantization in Speech Coding,&amp;rdquo; Proc. IEEE, vol. 73, pp. 1551-1587, Nov. 1985.</source>
          <target state="translated">벡터 양자화 J. Makhoul, S. Roucos 및 H. Gish, &quot;음성 코딩의 벡터 양자화&quot;, Proc. IEEE, vol. 73, pp. 1551-1587, 1985 년 11 월.</target>
        </trans-unit>
        <trans-unit id="f5d5df32cb3f2a3be9fd3df5321700c5dfe41670" translate="yes" xml:space="preserve">
          <source>Vector Stacking</source>
          <target state="translated">벡터 스태킹</target>
        </trans-unit>
        <trans-unit id="690a0d6330a132cb4527e3e44d7a2347c9a06b3a" translate="yes" xml:space="preserve">
          <source>Vector cross product(s).</source>
          <target state="translated">교차 제품 벡터.</target>
        </trans-unit>
        <trans-unit id="28cb052426ac62f08e613cbe9ac7789542c3593f" translate="yes" xml:space="preserve">
          <source>Vector cross-product.</source>
          <target state="translated">교차 제품 벡터.</target>
        </trans-unit>
        <trans-unit id="0fe94b620577959abe98d342c3396c44b95bc9ac" translate="yes" xml:space="preserve">
          <source>Vector inner and outer products, &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt;&lt;code&gt;numpy.inner&lt;/code&gt;&lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;numpy.outer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">벡터 내부 및 외부 제품 &lt;a href=&quot;numpy.inner#numpy.inner&quot;&gt; &lt;code&gt;numpy.inner&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;numpy.outer&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fc155524d5d2ad1522cc08f2291c52dc38dcecf1" translate="yes" xml:space="preserve">
          <source>Vector inner products:</source>
          <target state="translated">벡터 내부 제품 :</target>
        </trans-unit>
        <trans-unit id="7b8a7176d65340f9da0fa7937d046de8633e6685" translate="yes" xml:space="preserve">
          <source>Vector outer product:</source>
          <target state="translated">벡터 외부 제품 :</target>
        </trans-unit>
        <trans-unit id="acae4c791d04e4455a560ff6e41306cbb57dcf51" translate="yes" xml:space="preserve">
          <source>Vector(s) with the singular values, within each vector sorted in descending order. The first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions have the same size as those of the input &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">내림차순으로 정렬 된 각 벡터 내에서 특이 값을 가진 벡터입니다. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원은 입력 &lt;code&gt;a&lt;/code&gt; 와 크기가 같습니다 .</target>
        </trans-unit>
        <trans-unit id="2a5acfbe842fd0541792480526462188b04dde53" translate="yes" xml:space="preserve">
          <source>Vector, vector returns the scalar inner product, but neither argument is complex-conjugated:</source>
          <target state="translated">벡터, 벡터는 스칼라 내부 곱을 반환하지만 인수가 복잡하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d24d62baa6df1c0e53e6c0f85d62c2190886f5dd" translate="yes" xml:space="preserve">
          <source>Vectorization describes the absence of any explicit looping, indexing, etc., in the code - these things are taking place, of course, just &amp;ldquo;behind the scenes&amp;rdquo; in optimized, pre-compiled C code. Vectorized code has many advantages, among which are:</source>
          <target state="translated">벡터화는 코드에서 명시적인 루프, 인덱싱 등의 부재를 설명합니다. 물론 이러한 작업은 최적화되고 사전 컴파일 된 C 코드에서 &quot;뒤에서&quot;발생합니다. 벡터화 된 코드에는 다음과 같은 많은 장점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="c6ec9d2e3c00c48eca40b4ca66a3c4d474b90630" translate="yes" xml:space="preserve">
          <source>Vectorized function.</source>
          <target state="translated">벡터화 기능.</target>
        </trans-unit>
        <trans-unit id="72db9853411ecb8ab44d24a7ecaed3ef15eeb780" translate="yes" xml:space="preserve">
          <source>Verbosity value for benchmark outputs, in the range 1-10. Default is 1.</source>
          <target state="translated">벤치 마크 출력의 상세도 값, 범위는 1-10입니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="56a92946aff3755099c7d26b356bbca785b0c03f" translate="yes" xml:space="preserve">
          <source>Verbosity value for test outputs, in the range 1-10. Default is 1.</source>
          <target state="translated">1-10 범위의 테스트 출력에 대한 상세도 값입니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="7bfe5238ce1d36e9bfcb089f4f57728d117a113e" translate="yes" xml:space="preserve">
          <source>Verify the mean and the variance:</source>
          <target state="translated">평균과 분산을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="01e4cae31c98991a3d53edad9d5a04ca08ed4f3b" translate="yes" xml:space="preserve">
          <source>Version numbering</source>
          <target state="translated">버전 번호</target>
        </trans-unit>
        <trans-unit id="51eea7cbb443c92981917f3f8bfdb384f15a6153" translate="yes" xml:space="preserve">
          <source>Version of this function that preserves the shape of ar1.</source>
          <target state="translated">ar1의 모양을 유지하는이 함수의 버전.</target>
        </trans-unit>
        <trans-unit id="224aeb6086ba7022d83156756ac873c6ff737642" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 유형의 일반 NumPy 배열과 비교 클래스는 다음 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="a21f850c092874207e85425f1992b2d1d4a0daef" translate="yes" xml:space="preserve">
          <source>Versus a regular NumPy array of type &lt;code&gt;str&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt;, this class adds the following functionality:</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 유형의 일반 NumPy 배열과 비교 클래스는 다음 기능을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="8dff4805e231cae5fc82f2b66c5c75ea9b76e2a9" translate="yes" xml:space="preserve">
          <source>Very little support for C++ code and its different library-calling conventions. You will probably need a C wrapper around C++ code to use with ctypes (or just use Boost.Python instead).</source>
          <target state="translated">C ++ 코드 및 다른 라이브러리 호출 규칙에 대한 지원이 거의 없습니다. ctypes와 함께 사용하려면 C ++ 코드 주위에 C 래퍼가 필요할 것입니다 (또는 대신 Boost.Python 사용).</target>
        </trans-unit>
        <trans-unit id="c127fa63d626c5390ae1bdab993f5e47e3ded50c" translate="yes" xml:space="preserve">
          <source>Very often, it is desirable to iterate over several arrays at the same time. The universal functions are an example of this kind of behavior. If all you want to do is iterate over arrays with the same shape, then simply creating several iterator objects is the standard procedure. For example, the following code iterates over two arrays assumed to be the same shape and size (actually obj1 just has to have at least as many total elements as does obj2):</source>
          <target state="translated">매우 자주, 동시에 여러 배열을 반복하는 것이 바람직합니다. 범용 함수는 이러한 종류의 동작의 한 예입니다. 동일한 모양의 배열을 반복하는 것이 원하는 경우 여러 반복기 객체를 만드는 것이 표준 절차입니다. 예를 들어, 다음 코드는 모양과 크기가 같은 것으로 가정되는 두 배열을 반복합니다 (실제로 obj1은 obj2만큼의 총 요소를 가져야 함).</target>
        </trans-unit>
        <trans-unit id="ba00ebd75f3175e23b4f09615b45ef3560ac5818" translate="yes" xml:space="preserve">
          <source>View based and advanced indexing is mixed. In this case the view based indexing defines a collection of subarrays that are combined by the advanced indexing. For example, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; is created by vertically stacking the subarrays &lt;code&gt;arr[1, :]&lt;/code&gt;, &lt;code&gt;arr[2,:]&lt;/code&gt;, and &lt;code&gt;arr[3, :]&lt;/code&gt;.</source>
          <target state="translated">뷰 기반 및 고급 인덱싱이 혼합되어 있습니다. 이 경우 뷰 기반 인덱싱은 고급 인덱싱에 의해 결합 된 하위 배열의 컬렉션을 정의합니다. 예를 들어, &lt;code&gt;arr[[1, 2, 3], :]&lt;/code&gt; 는 하위 배열 &lt;code&gt;arr[1, :]&lt;/code&gt; , &lt;code&gt;arr[2,:]&lt;/code&gt; , &lt;code&gt;arr[3, :]&lt;/code&gt; 을 세로로 쌓아서 만듭니다 . 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a9c88862eb9a71fc0e8a80b619b8e3f7d2d2d42e" translate="yes" xml:space="preserve">
          <source>View casting</source>
          <target state="translated">캐스팅보기</target>
        </trans-unit>
        <trans-unit id="56880c7be840a348e75d7f5abcf907eb8bf9c7d5" translate="yes" xml:space="preserve">
          <source>View casting - casting an existing ndarray as a given subclass</source>
          <target state="translated">캐스팅보기-기존 ndarray를 주어진 하위 클래스로 캐스팅</target>
        </trans-unit>
        <trans-unit id="b2ca30abe686b95f053f55957fa5266ab07dca0a" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least three dimensions.</source>
          <target state="translated">입력을 3 차원 이상의 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="45fb889525ea027b940786067638d779d675de17" translate="yes" xml:space="preserve">
          <source>View inputs as arrays with at least two dimensions.</source>
          <target state="translated">입력 값을 2 차원 이상의 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="6e4fbf98b4a2f11308bf6ec449635485ea8cdb89" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased by one.</source>
          <target state="translated">보기 차원의 수는 하나씩 증가. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1435a6e88e9cfdd34dddec8e0ea3d664de355e82" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt; with the number of dimensions increased.</source>
          <target state="translated">보기 차원의 수는 증가했다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbf2e6fd5608dfcde8e1d428501030442d53386c" translate="yes" xml:space="preserve">
          <source>View of &lt;code&gt;a&lt;/code&gt;, with axes suitably permuted.</source>
          <target state="translated">의보기 축이 적절히 순열과 함께. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="64d2e5a4061b7a0c16fd366760c98d172091bc5e" translate="yes" xml:space="preserve">
          <source>View or Shallow Copy</source>
          <target state="translated">보기 또는 얕은 복사</target>
        </trans-unit>
        <trans-unit id="690413363bd8aafde5497bc7e1d13a4d8e5f2372" translate="yes" xml:space="preserve">
          <source>View the array as a record array:</source>
          <target state="translated">배열을 레코드 배열로 봅니다.</target>
        </trans-unit>
        <trans-unit id="aea7dff1c7bb5f575c10f755c8f2b7c22ca00476" translate="yes" xml:space="preserve">
          <source>Viewing Structured Arrays Containing Objects</source>
          <target state="translated">객체를 포함하는 구조화 된 배열보기</target>
        </trans-unit>
        <trans-unit id="81d42abd80c44b454ac926e28ee7856a84a169a3" translate="yes" xml:space="preserve">
          <source>Viewing array data using a different type and dtype:</source>
          <target state="translated">다른 유형과 dtype을 사용하여 배열 데이터보기 :</target>
        </trans-unit>
        <trans-unit id="e4585378f90f92f4cace47440b8fa755fd8680a6" translate="yes" xml:space="preserve">
          <source>Views are an important NumPy concept! NumPy functions, as well as operations like indexing and slicing, will return views whenever possible. This saves memory and is faster (no copy of the data has to be made). However it&amp;rsquo;s important to be aware of this - modifying data in a view also modifies the original array!</source>
          <target state="translated">뷰는 중요한 NumPy 개념입니다! NumPy 함수와 인덱싱 및 슬라이싱과 같은 작업은 가능할 때마다 뷰를 반환합니다. 이렇게하면 메모리가 절약되고 더 빠릅니다 (데이터를 복사 할 필요가 없음). 그러나 이것을 아는 것이 중요합니다. 뷰에서 데이터를 수정하면 원래 배열도 수정됩니다!</target>
        </trans-unit>
        <trans-unit id="30c8756fc6d8ab2295389484bbe9c6879a472d3c" translate="yes" xml:space="preserve">
          <source>Views of arrays in Fortran order</source>
          <target state="translated">Fortran 순서의 배열보기</target>
        </trans-unit>
        <trans-unit id="59879f373c87da4a2c95c0412230c3555cfc240e" translate="yes" xml:space="preserve">
          <source>Views returned from einsum are now writeable whenever the input array is writeable. For example, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; will now have the same effect as &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; will return a writeable view of the diagonal of a 2D array.</source>
          <target state="translated">입력 배열을 쓸 수있을 때마다 einsum에서 반환 된 뷰를 쓸 수 있습니다. 예를 들어, &lt;code&gt;np.einsum('ijk...-&amp;gt;kji...', a)&lt;/code&gt; 는 이제 &lt;a href=&quot;numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;np.swapaxes(a, 0, 2)&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 와 동일한 효과를 갖습니다. , ㅏ) 2D 배열의 대각선에 대한 쓰기 가능한보기를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="212733d972db48c77aaab9351402436eae4fd2ff" translate="yes" xml:space="preserve">
          <source>Views share data:</source>
          <target state="translated">조회수는 데이터를 공유합니다.</target>
        </trans-unit>
        <trans-unit id="c9d8f3fc365bae8c1e0312cb68b7341a485aec6e" translate="yes" xml:space="preserve">
          <source>Views that change the dtype size (bytes per entry) should normally be avoided on arrays defined by slices, transposes, fortran-ordering, etc.:</source>
          <target state="translated">dtype 크기 (항목 당 바이트 수)를 변경하는 뷰는 슬라이스, 조옮김, 포트 순서 지정 등으로 정의 된 배열에서는 일반적으로 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="56b0a8ac25b1950e1419116b1fa18ea25ea62bb3" translate="yes" xml:space="preserve">
          <source>Violent threats or language directed against another person.</source>
          <target state="translated">다른 사람을 대상으로 한 폭력적인 위협 또는 언어.</target>
        </trans-unit>
        <trans-unit id="43e46231e2e4425940323040c2be47d46f02e331" translate="yes" xml:space="preserve">
          <source>Virtualenv</source>
          <target state="translated">Virtualenv</target>
        </trans-unit>
        <trans-unit id="2e7e7becfbd2f76f4c7a1cf2e451eb461ef24b08" translate="yes" xml:space="preserve">
          <source>Virtualenv is a very useful tool to keep several versions of packages around. It is also used in the Paver script to build the docs.</source>
          <target state="translated">Virtualenv는 여러 버전의 패키지를 유지하는 데 매우 유용한 도구입니다. 문서를 빌드하기 위해 Paver 스크립트에서도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="319d8490779b3eba0e5e3b87402a7431309ef352" translate="yes" xml:space="preserve">
          <source>Void dtype discovery in &lt;code&gt;np.array&lt;/code&gt;</source>
          <target state="translated">의 공허 DTYPE 발견 &lt;code&gt;np.array&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="3cd2f9e2b1f25c2f5e7b93f7ce911077d7d964a4" translate="yes" xml:space="preserve">
          <source>W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery, &amp;ldquo;Numerical Recipes (3rd edition)&amp;rdquo;, Cambridge University Press, 2007, page 795.</source>
          <target state="translated">WH Press, SA Teukolsky, WT Vetterling 및 BP Flannery,&amp;ldquo;Numerical Recipes (3 판)&amp;rdquo;, Cambridge University Press, 2007, 795 페이지.</target>
        </trans-unit>
        <trans-unit id="e9c669c28770b602c0d3307e40af975f3d6ab286" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 425.</source>
          <target state="translated">WH Press, BP Flannery, SA Teukolsky 및 WT Vetterling,&amp;ldquo;수치 레시피&amp;rdquo;, Cambridge University Press, 1986 년, 425 페이지.</target>
        </trans-unit>
        <trans-unit id="dbd0b2fdf754a4d650097a931842e3ce01d68c23" translate="yes" xml:space="preserve">
          <source>W.H. Press, B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling, &amp;ldquo;Numerical Recipes&amp;rdquo;, Cambridge University Press, 1986, page 429.</source>
          <target state="translated">WH Press, BP Flannery, SA Teukolsky 및 WT Vetterling,&amp;ldquo;수치 레시피&amp;rdquo;, Cambridge University Press, 1986, 429 페이지.</target>
        </trans-unit>
        <trans-unit id="4d8b44b86ac9762795ccf1eb37bf4871143a380a" translate="yes" xml:space="preserve">
          <source>WRITEABLE (W) the data area can be written to;</source>
          <target state="translated">쓰기 가능 (W) 데이터 영역에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6dcab075be566e2b98d550a936f8cae5ce9422f" translate="yes" xml:space="preserve">
          <source>WRITEABLE / W</source>
          <target state="translated">쓰기 가능 / W</target>
        </trans-unit>
        <trans-unit id="73fb58e7589a9ff67f327a9e1cfb0abcae369bb5" translate="yes" xml:space="preserve">
          <source>WRITEABLE can only be set &lt;code&gt;True&lt;/code&gt; if the array owns its own memory or the ultimate owner of the memory exposes a writeable buffer interface or is a string.</source>
          <target state="translated">WRITEABLE은 어레이가 자체 메모리를 소유하거나 메모리의 최종 소유자가 쓰기 가능한 버퍼 인터페이스를 노출하거나 문자열 인 경우 에만 &lt;code&gt;True&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5ca2fe3e818dba5a5804a5bb3a831dd89c500d7a" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY (X) this array is a copy of some other array (referenced by .base). When the C-API function PyArray_ResolveWritebackIfCopy is called, the base array will be updated with the contents of this array.</source>
          <target state="translated">WRITEBACKIFCOPY (X)이 배열은 다른 배열 (.base로 참조)의 복사본입니다. C-API 함수 PyArray_ResolveWritebackIfCopy가 호출되면 기본 배열이이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="3b243b9b37eb143e3a1ec8091e9c80e424b7cb17" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY / X</source>
          <target state="translated">WRITEBACKIFCOPY / X</target>
        </trans-unit>
        <trans-unit id="09fcb82609179c1f7885c137f520c527fdcb1905" translate="yes" xml:space="preserve">
          <source>WRITEBACKIFCOPY can only be set &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">WRITEBACKIFCOPY는 &lt;code&gt;False&lt;/code&gt; 로만 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fd7081253d772e7a32e41421d2cdf6a9cabced2" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, &amp;ldquo;A Statistical Distribution Function of Wide Applicability&amp;rdquo;, Journal Of Applied Mechanics ASME Paper 1951.</source>
          <target state="translated">Waloddi Weibull,&amp;ldquo;광범위한 적용 성의 통계 분포 함수&amp;rdquo;, 응용 역학 저널 ASME 논문 1951.</target>
        </trans-unit>
        <trans-unit id="db8ff1d3b42b8d1fe40e88e8148de81cccee175c" translate="yes" xml:space="preserve">
          <source>Waloddi Weibull, Royal Technical University, Stockholm, 1939 &amp;ldquo;A Statistical Theory Of The Strength Of Materials&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</source>
          <target state="translated">1939 년 스톡홀름 왕립 기술 대학교 Waloddi Weibull,&amp;ldquo;재료의 강도에 관한 통계 이론&amp;rdquo;, Ingeniorsvetenskapsakademiens Handlingar Nr 151, 1939, Generalstabens Litografiska Anstalts Forlag, Stockholm.</target>
        </trans-unit>
        <trans-unit id="f1346bf7169c446f1eec32708e49a903284d1169" translate="yes" xml:space="preserve">
          <source>Warn when saving a dtype with metadata</source>
          <target state="translated">메타 데이터와 함께 dtype을 저장할 때 경고</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="4754f4fe525f9c37d19fda1322550a0b26e13158" translate="yes" xml:space="preserve">
          <source>Warning class to filter</source>
          <target state="translated">필터링 할 경고 클래스</target>
        </trans-unit>
        <trans-unit id="f88a191846138392ad4758d4ff77a36f017f6d00" translate="yes" xml:space="preserve">
          <source>Warning objects</source>
          <target state="translated">경고 객체</target>
        </trans-unit>
        <trans-unit id="bb630d84baa9f5fb3c8c438ee6064e7457d1688d" translate="yes" xml:space="preserve">
          <source>Warning on casting complex to real</source>
          <target state="translated">콤플렉스를 실제로 캐스팅 할 때 경고</target>
        </trans-unit>
        <trans-unit id="37361059464af82221d16eb1a2018e9694f9cd57" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and is not a datatype description compatible with &lt;code&gt;np.dtype&lt;/code&gt;.</source>
          <target state="translated">경고 :이 속성은 &lt;code&gt;__array_interface__&lt;/code&gt; 에 특별히 존재하며 np.dtype 과 호환되는 데이터 유형 설명이 &lt;code&gt;np.dtype&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53dd2d8a36d40ea4bb66f08310fbbcb2e7533b5f" translate="yes" xml:space="preserve">
          <source>Warning: This attribute exists specifically for &lt;code&gt;__array_interface__&lt;/code&gt;, and passing it directly to &lt;code&gt;np.dtype&lt;/code&gt; will not accurately reconstruct some dtypes (e.g., scalar and subarray dtypes).</source>
          <target state="translated">이 속성은 특별히 존재 : 경고 &lt;code&gt;__array_interface__&lt;/code&gt; ,과에 직접 전달 &lt;code&gt;np.dtype&lt;/code&gt; 정확하게 어떤 dtypes (예를 들어, 스칼라 및 부분 배열 dtypes)를 재구성하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="67f63aaa6eb093a2b8631aeb7aa1f1f56dd3fc86" translate="yes" xml:space="preserve">
          <source>Warning: This functionality does &lt;strong&gt;not&lt;/strong&gt; consider axes separately, i.e. it does not apply interpolation/extrapolation. It fills the return array with the required number of elements, taken from &lt;code&gt;a&lt;/code&gt; as they are laid out in memory, disregarding strides and axes. (This is in case the new shape is smaller. For larger, see above.) This functionality is therefore not suitable to resize images, or data where each axis represents a separate and distinct entity.</source>
          <target state="translated">경고 :이 기능은 축을 개별적으로 고려 하지 &lt;strong&gt;않습니다&lt;/strong&gt; . 즉 보간 / 외삽 법이 적용되지 않습니다. 그것은 보폭과 축을 무시하고 메모리에 배치 된 &lt;code&gt;a&lt;/code&gt; 에서 가져온 필요한 수의 요소로 반환 배열을 채 웁니다 . (이것은 새로운 모양이 더 작은 경우에 해당됩니다. 더 큰 것은 위를 참조하십시오.) 따라서이 기능은 이미지 나 각 축이 별개의 개별 엔티티를 나타내는 데이터의 크기를 조정하는 데 적합하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1430f976c596795274458abcfbc4f280cbfcebac" translate="yes" xml:space="preserve">
          <source>Warnings</source>
          <target state="translated">Warnings</target>
        </trans-unit>
        <trans-unit id="60f5d88ea293a20258ae77bd080550b12d5b3d82" translate="yes" xml:space="preserve">
          <source>Warns</source>
          <target state="translated">Warns</target>
        </trans-unit>
        <trans-unit id="6fcbb55cbf3a317fd9e559a46404d4ffc0901e5d" translate="yes" xml:space="preserve">
          <source>Warns:</source>
          <target state="translated">Warns:</target>
        </trans-unit>
        <trans-unit id="2877e71e929aa29b0e79a512d385261189d70371" translate="yes" xml:space="preserve">
          <source>Wave heights tend to follow a Rayleigh distribution. If the mean wave height is 1 meter, what fraction of waves are likely to be larger than 3 meters?</source>
          <target state="translated">파도 높이는 레일리 분포를 따르는 경향이 있습니다. 평균 파고가 1 미터 인 경우 파동의 3 분의 1보다 큰 파편의 비율은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="58cd26b5bf632fda361651c5bed4615a24ac5c34" translate="yes" xml:space="preserve">
          <source>We are thankful to the groups behind the following documents, from which we drew content and inspiration:</source>
          <target state="translated">우리는 내용과 영감을 얻은 다음 문서 뒤에있는 그룹들에게 감사합니다.</target>
        </trans-unit>
        <trans-unit id="87d1583437d12a714a66434e88f0db3dd9eec3f0" translate="yes" xml:space="preserve">
          <source>We build 32- and 64-bit wheels on Windows. Windows 7, 8 and 10 are supported. We build NumPy using the &lt;a href=&quot;https://mingwpy.github.io&quot;&gt;mingw-w64 toolchain&lt;/a&gt; on Appveyor.</source>
          <target state="translated">Windows에서 32 비트 및 64 비트 휠을 빌드합니다. Windows 7, 8 및 10이 지원됩니다. Appveyor 에서 &lt;a href=&quot;https://mingwpy.github.io&quot;&gt;mingw-&lt;/a&gt; w64 툴체인 을 사용하여 NumPy를 빌드 합니다.</target>
        </trans-unit>
        <trans-unit id="52a53769f72b3e9d74a22d9793d68e7e1c952be3" translate="yes" xml:space="preserve">
          <source>We build all our wheels on cloud infrastructure - so this list of compilers is for information and debugging builds locally. See the &lt;code&gt;.travis.yml&lt;/code&gt; and &lt;code&gt;appveyor.yml&lt;/code&gt; scripts in the &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;numpy wheels&lt;/a&gt; repo for the definitive source of the build recipes. Packages that are available using pip are noted.</source>
          <target state="translated">우리는 모든 바퀴를 클라우드 인프라에 구축합니다. 따라서이 컴파일러 목록은 정보를 제공하고 로컬에서 빌드를 디버깅하기위한 것입니다. 빌드 레시피의 최종 소스는 &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;numpy wheels&lt;/a&gt; repo 의 &lt;code&gt;.travis.yml&lt;/code&gt; 및 &lt;code&gt;appveyor.yml&lt;/code&gt; 스크립트를 참조하십시오 . pip를 사용하여 사용할 수있는 패키지가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="5ffd71ee5e18a21e4fac71c59e3fce6abfaf692e" translate="yes" xml:space="preserve">
          <source>We build and ship &lt;a href=&quot;https://www.python.org/dev/peps/pep-0513&quot;&gt;manylinux1&lt;/a&gt; wheels for NumPy. Many Linux distributions include their own binary builds of NumPy.</source>
          <target state="translated">우리는 NumPy를 위해 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0513&quot;&gt;많은 linux1&lt;/a&gt; 휠을 빌드하고 배송 합니다. 많은 Linux 배포판에는 NumPy의 자체 바이너리 빌드가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2a47a01a930577b3f6fd6bc57c66f9caa61248a" translate="yes" xml:space="preserve">
          <source>We build source releases in both .zip and .tar.gz formats.</source>
          <target state="translated">.zip 및 .tar.gz 형식으로 소스 릴리스를 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="90fdab75def7d856cf227160207c1857877a95de" translate="yes" xml:space="preserve">
          <source>We can access the elements in the array using square brackets. When you&amp;rsquo;re accessing elements, remember that indexing in NumPy starts at 0. That means that if you want to access the first element in your array, you&amp;rsquo;ll be accessing element &amp;ldquo;0&amp;rdquo;.</source>
          <target state="translated">대괄호를 사용하여 배열의 요소에 액세스 할 수 있습니다. 요소에 액세스 할 때 NumPy의 인덱싱이 0에서 시작한다는 점을 기억하십시오. 즉, 배열의 첫 번째 요소에 액세스하려는 경우 요소 &quot;0&quot;에 액세스하게됩니다.</target>
        </trans-unit>
        <trans-unit id="27c3166519c3983dd1bdd287de2f7543430ee161" translate="yes" xml:space="preserve">
          <source>We can also access the valid entries by using the logical negation for this mask:</source>
          <target state="translated">이 마스크에 대한 논리 부정을 사용하여 유효한 항목에 액세스 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="72895573c71234a77f8f78e60c8d2a3fa9071512" translate="yes" xml:space="preserve">
          <source>We can also give indexes for more than one dimension. The arrays of indices for each dimension must have the same shape.</source>
          <target state="translated">둘 이상의 차원에 대한 인덱스를 제공 할 수도 있습니다. 각 차원에 대한 인덱스 배열의 모양은 동일해야합니다.</target>
        </trans-unit>
        <trans-unit id="d199611fe572f9a604421aeb87fed868192644af" translate="yes" xml:space="preserve">
          <source>We can begin with a chain dot example. In this case, it is optimal to contract the &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; tensors first as represented by the first element of the path &lt;code&gt;(1, 2)&lt;/code&gt;. The resulting tensor is added to the end of the contraction and the remaining contraction &lt;code&gt;(0, 1)&lt;/code&gt; is then completed.</source>
          <target state="translated">우리는 체인 도트 예제로 시작할 수 있습니다. 이 경우 경로의 첫 번째 요소 &lt;code&gt;(1, 2)&lt;/code&gt; 로 표시되는대로 &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 텐서를 먼저 수축시키는 것이 가장 좋습니다. 결과 텐서가 수축의 끝에 추가되고 나머지 수축 &lt;code&gt;(0, 1)&lt;/code&gt; 이 완료됩니다.</target>
        </trans-unit>
        <trans-unit id="c24b2dc7e2cf1c2ee15a3b856c501da4eb664f2c" translate="yes" xml:space="preserve">
          <source>We can convert to a numpy array using &lt;a href=&quot;../reference/generated/numpy.array#numpy.array&quot;&gt;&lt;code&gt;numpy.array&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt;&lt;code&gt;numpy.asarray&lt;/code&gt;&lt;/a&gt;, which will call its &lt;code&gt;__array__&lt;/code&gt; method to obtain a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="translated">표준 &lt;code&gt;numpy.ndarray&lt;/code&gt; 를 얻기 위해 &lt;code&gt;__array__&lt;/code&gt; 메소드를 호출하는 &lt;a href=&quot;../reference/generated/numpy.array#numpy.array&quot;&gt; &lt;code&gt;numpy.array&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../reference/generated/numpy.asarray#numpy.asarray&quot;&gt; &lt;code&gt;numpy.asarray&lt;/code&gt; 를&lt;/a&gt; 사용하여 numpy 배열로 변환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="679a2f0f20fc2e3fa05b5f20a0ca536c32a5eeaa" translate="yes" xml:space="preserve">
          <source>We can get a finer control on the conversion of missing values with the &lt;code&gt;filling_values&lt;/code&gt; optional argument. Like &lt;code&gt;missing_values&lt;/code&gt;, this argument accepts different kind of values:</source>
          <target state="translated">&lt;code&gt;filling_values&lt;/code&gt; 선택적 인수를 사용하여 누락 된 값의 변환을 더 세밀하게 제어 할 수 있습니다 . &lt;code&gt;missing_values&lt;/code&gt; 와 마찬가지로이 인수는 다른 종류의 값을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="66a6a3c1aa8ab5615ae93578f83c6c2bc137c427" translate="yes" xml:space="preserve">
          <source>We can now compute the mean of the dataset, without taking the invalid data into account:</source>
          <target state="translated">이제 유효하지 않은 데이터를 고려하지 않고 데이터 세트의 평균을 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c82ab011abc5da0365af1d671286d5b3b09bbe" translate="yes" xml:space="preserve">
          <source>We can overwrite this default with the &lt;code&gt;defaultfmt&lt;/code&gt; argument, that takes any format string:</source>
          <target state="translated">이 기본값을 모든 형식 문자열을 취하는 &lt;code&gt;defaultfmt&lt;/code&gt; 인수로 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="55ec8b33a4acc5b04909546d200237b6de3e0139" translate="yes" xml:space="preserve">
          <source>We can replace the data with this information and plot a new graph, focusing on Mainland China:</source>
          <target state="translated">데이터를이 정보로 바꾸고 중국 본토에 초점을 맞춘 새 그래프를 그릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07dfd0de116a4118d2e8d7ab1e0ba4c4055ce110" translate="yes" xml:space="preserve">
          <source>We can replace the maximum values with:</source>
          <target state="translated">최대 값을 다음과 같이 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a512625d0cb7e17ddcfbaaf190c6f0c94959ed" translate="yes" xml:space="preserve">
          <source>We can reset the function to the default:</source>
          <target state="translated">기능을 기본값으로 재설정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b52b8758d686451191a4e1193e567d392d717d53" translate="yes" xml:space="preserve">
          <source>We can rewrite the line equation as &lt;code&gt;y = Ap&lt;/code&gt;, where &lt;code&gt;A = [[x 1]]&lt;/code&gt; and &lt;code&gt;p = [[m], [c]]&lt;/code&gt;. Now use &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt; to solve for &lt;code&gt;p&lt;/code&gt;:</source>
          <target state="translated">선 방정식을 &lt;code&gt;y = Ap&lt;/code&gt; 로 다시 작성할 수 있습니다 . 여기서 &lt;code&gt;A = [[x 1]]&lt;/code&gt; 및 &lt;code&gt;p = [[m], [c]]&lt;/code&gt; 입니다. 이제 &lt;a href=&quot;#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; &lt;/a&gt; 를 사용 하여 &lt;code&gt;p&lt;/code&gt; 를 해결하십시오 .</target>
        </trans-unit>
        <trans-unit id="dd1121cb835ca07af6856a6e1f4f9f9a02284739" translate="yes" xml:space="preserve">
          <source>We can see that this is a different kind of array. As mentioned in the introduction, it has three attributes (&lt;code&gt;data&lt;/code&gt;, &lt;code&gt;mask&lt;/code&gt; and &lt;code&gt;fill_value&lt;/code&gt;). Keep in mind that the &lt;code&gt;mask&lt;/code&gt; attribute has a &lt;code&gt;True&lt;/code&gt; value for elements corresponding to &lt;strong&gt;invalid&lt;/strong&gt; data (represented by two dashes in the &lt;code&gt;data&lt;/code&gt; attribute).</source>
          <target state="translated">이것이 다른 종류의 배열임을 알 수 있습니다. 소개에서 언급했듯이 세 가지 속성 ( &lt;code&gt;data&lt;/code&gt; , &lt;code&gt;mask&lt;/code&gt; 및 &lt;code&gt;fill_value&lt;/code&gt; )이 있습니다. 있다는 사실에 유의 &lt;code&gt;mask&lt;/code&gt; 속성은 보유 &lt;code&gt;True&lt;/code&gt; 에 대응하는 요소에 대한 값을 &lt;strong&gt;무효&lt;/strong&gt; 합니다 (두 개의 대시로 나타낸 데이터 &lt;code&gt;data&lt;/code&gt; 속성).</target>
        </trans-unit>
        <trans-unit id="9280da38538a3f969f230f09cea0b4dbc319a8ef" translate="yes" xml:space="preserve">
          <source>We can see the image using the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow&quot;&gt;&lt;code&gt;matplotlib.pyplot.imshow&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">&lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.imshow.html#matplotlib.pyplot.imshow&quot;&gt; &lt;code&gt;matplotlib.pyplot.imshow&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 이미지를 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bcf794d24d8964269b87153ebb1affba96ff631d" translate="yes" xml:space="preserve">
          <source>We can sort either by using sort directly, or argsort and this function</source>
          <target state="translated">sort를 직접 사용하거나 argsort와이 함수를 사용하여 정렬 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1a14ecae9fbda2061a0c2690a51d04695403160b" translate="yes" xml:space="preserve">
          <source>We can think of a &lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; as a combination of:</source>
          <target state="translated">&lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 는 다음의 조합으로 생각할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c8b935f50d33884f474e4109b428a56eb6fe6366" translate="yes" xml:space="preserve">
          <source>We can use a different method other than the default to factorize cov: &amp;gt;&amp;gt;&amp;gt; y = rng.multivariate_normal(mean, cov, (3, 3), method=&amp;rsquo;cholesky&amp;rsquo;) &amp;gt;&amp;gt;&amp;gt; y.shape (3, 3, 2)</source>
          <target state="translated">cov를 분해하기 위해 기본값이 아닌 다른 방법을 사용할 수 있습니다. &amp;gt;&amp;gt;&amp;gt; y = rng.multivariate_normal (mean, cov, (3, 3), method = 'cholesky') &amp;gt;&amp;gt;&amp;gt; y.shape (3, 3, 2)</target>
        </trans-unit>
        <trans-unit id="23502bd41157dbb482cc4d93fe154b6f35759b68" translate="yes" xml:space="preserve">
          <source>We can verify this, approximating the derivative with &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt;:</source>
          <target state="translated">우리는 이것을 &lt;code&gt;(f(x + h) - f(x))/h&lt;/code&gt; 근사값을 근사화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1edbc1babc558648a370766b66d6bf09ff4d2327" translate="yes" xml:space="preserve">
          <source>We chose our default threshold because it is in wide use. Other thresholds are possible. For example, elsewhere in the 2007 edition of &lt;em&gt;Numerical recipes&lt;/em&gt; there is an alternative threshold of &lt;code&gt;S.max() *
np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt;. The authors describe this threshold as being based on &amp;ldquo;expected roundoff error&amp;rdquo; (p 71).</source>
          <target state="translated">기본 임계 값은 널리 사용되므로 기본 임계 값을 선택했습니다. 다른 임계 값도 가능합니다. 예를 들어, 2007 년판 &lt;em&gt;수치 레시피&lt;/em&gt; 의 다른 곳에 는 &lt;code&gt;S.max() * np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)&lt;/code&gt; 의 대체 임계 값이 있습니다 . * np.sqrt (m + n + 1.) . 저자는이 임계 값을 &quot;예상 반올림 오류&quot;(p 71)에 기반한 것으로 설명합니다.</target>
        </trans-unit>
        <trans-unit id="81b92d4d0e0bfcb2ba46a1a8b9dd4a22e1691631" translate="yes" xml:space="preserve">
          <source>We could also have used the &lt;a href=&quot;../reference/generated/numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;numpy.allclose&lt;/code&gt;&lt;/a&gt; function to make sure the reconstructed product is, in fact, &lt;em&gt;close&lt;/em&gt; to our original matrix (the difference between the two arrays is small):</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;numpy.allclose&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 재구성 된 제품이 실제로 원래 행렬에 &lt;em&gt;가깝다&lt;/em&gt; 는 것을 확인할 수도 있습니다 (두 배열 간의 차이는 작음).</target>
        </trans-unit>
        <trans-unit id="d8ba993fff071da05f22748cefa6f6b8ad24e53b" translate="yes" xml:space="preserve">
          <source>We could have implemented:</source>
          <target state="translated">우리는 다음을 구현할 수있었습니다.</target>
        </trans-unit>
        <trans-unit id="37a18e023d482a1a5f3f0844c696551b9f7ca294" translate="yes" xml:space="preserve">
          <source>We currently support Python 3.6-3.8 on Windows, OSX, and Linux</source>
          <target state="translated">현재 Windows, OSX 및 Linux에서 Python 3.6-3.8을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="07a1c0a83c857f695d91b773fe8da038b7dff7fd" translate="yes" xml:space="preserve">
          <source>We currently use &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; for generating the API and reference documentation for NumPy. You will need Sphinx &amp;gt;= 2.2.0.</source>
          <target state="translated">현재 NumPy에 대한 API 및 참조 문서를 생성하기 위해 &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 를 사용하고 있습니다 . Sphinx&amp;gt; = 2.2.0이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="3e8150976e1be876e23fe9902955320291d1f04b" translate="yes" xml:space="preserve">
          <source>We currently use &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; for generating the API and reference documentation for NumPy. You will need Sphinx &amp;gt;= 2.2.0.</source>
          <target state="translated">현재 NumPy에 대한 API 및 참조 문서를 생성하기 위해 &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 를 사용하고 있습니다 . Sphinx&amp;gt; = 2.2.0이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="59bec2d1c76c534a2fc4afd9318e87ce91e937b9" translate="yes" xml:space="preserve">
          <source>We default to using a 128-bit integer using entropy gathered from the OS. This is a good amount of entropy to initialize all of the generators that we have in numpy. We do not recommend using small seeds below 32 bits for general use. Using just a small set of seeds to instantiate larger state spaces means that there are some initial states that are impossible to reach. This creates some biases if everyone uses such values.</source>
          <target state="translated">기본적으로 OS에서 수집 한 엔트로피를 사용하여 128 비트 정수를 사용합니다. 이것은 우리가 numpy에있는 모든 생성기를 초기화하기에 좋은 양의 엔트로피입니다. 일반적으로 32 비트 미만의 작은 시드를 사용하지 않는 것이 좋습니다. 더 큰 상태 공간을 인스턴스화하기 위해 작은 시드 세트 만 사용하면 도달 할 수없는 초기 상태가 있음을 의미합니다. 모든 사람이 그러한 가치를 사용한다면 이것은 약간의 편견을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="5796ea3e43e927c951158cf75a113735a9be5c88" translate="yes" xml:space="preserve">
          <source>We distinguish both tutorials and how-tos from &lt;code&gt;Explanations&lt;/code&gt;, which are deep dives intended to give understanding rather than immediate assistance, and &lt;code&gt;References&lt;/code&gt;, which give complete, autoritative data on some concrete part of NumPy (like its API) but aren&amp;rsquo;t obligated to paint a broader picture.</source>
          <target state="translated">우리는 튜토리얼과 하우투를 즉각적인 도움이 아닌 이해를 제공하기위한 심층 분석 인 &lt;code&gt;Explanations&lt;/code&gt; 및 API와 같은 NumPy의 일부 구체적인 부분에 대한 완전한 자동 데이터를 제공하지만 의무 사항은 아닌 &lt;code&gt;References&lt;/code&gt; 와 구별합니다. 더 넓은 그림을 그리십시오.</target>
        </trans-unit>
        <trans-unit id="dc787d0b25c896acc068b7c607665544c0350ae5" translate="yes" xml:space="preserve">
          <source>We do as follows:</source>
          <target state="translated">우리는 다음과 같이합니다 :</target>
        </trans-unit>
        <trans-unit id="6c39690106b67e736bf72e53ea7082db75a8ca14" translate="yes" xml:space="preserve">
          <source>We expect the arccos of 1 to be 0, and of -1 to be pi:</source>
          <target state="translated">우리는 1의 arccos가 0이고 -1의 pi가 pi 일 것으로 예상합니다 :</target>
        </trans-unit>
        <trans-unit id="44f2a9cfd92075d83d3f564752917c6115d7836b" translate="yes" xml:space="preserve">
          <source>We expect the arctan of 0 to be 0, and of 1 to be pi/4:</source>
          <target state="translated">우리는 arctan 0은 0, 1은 pi / 4가 될 것으로 예상합니다 :</target>
        </trans-unit>
        <trans-unit id="b30e48f7bd5611b7e5063995e5e3d8d0377a6a59" translate="yes" xml:space="preserve">
          <source>We finally give an example of a full ufunc, with inner loops for half-floats, floats, doubles, and long doubles. As in the previous sections we first give the .c file and then the corresponding setup.py file.</source>
          <target state="translated">마지막으로 half-floats, float, double 및 long double에 대한 내부 루프가있는 전체 ufunc의 예를 제공합니다. 이전 섹션에서와 같이 먼저 .c 파일을 제공 한 다음 해당 setup.py 파일을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="60136b35f0997a97a43dcb76040b0f18f3536c81" translate="yes" xml:space="preserve">
          <source>We have 10 degrees of freedom, so is the sample mean within 95% of the recommended value?</source>
          <target state="translated">우리는 10 자유도를 가지고 있으므로 표본 평균이 권장 값의 95 % 이내입니까?</target>
        </trans-unit>
        <trans-unit id="84db14adfcdaf5f72b2db96fd86ac625f5af0ee6" translate="yes" xml:space="preserve">
          <source>We have authoritative answers.</source>
          <target state="translated">권위있는 답변이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5235dd026426cf863204463534241d25f8524b9" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">numpy 함수를 (일반화 된) Ufunc로 다시 구현하려고합니다.이 경우 &lt;code&gt;__array_ufunc__&lt;/code&gt; 메서드에 의해 재정의 될 수 있습니다 . 대표적인 후보는 &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; 현재 Ufunc 아니라, 비교적 쉽게 Ufuncs 일반화 된 A (세트)로 다시 작성 될 수있는. &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 와 같은 함수도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="3e23f0ad561893af23edd41efd72f4bd368c5b95" translate="yes" xml:space="preserve">
          <source>We intend to re-implement numpy functions as (generalized) Ufunc, in which case it will become possible for them to be overridden by the &lt;code&gt;__array_ufunc__&lt;/code&gt; method. A prime candidate is &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt;, which currently is not a Ufunc, but could be relatively easily be rewritten as a (set of) generalized Ufuncs. The same may happen with functions such as &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;min&lt;/code&gt;, and &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리는 numpy 함수를 (일반화 된) Ufunc로 다시 구현하려고합니다.이 경우 &lt;code&gt;__array_ufunc__&lt;/code&gt; 메소드 로 대체 될 수 있습니다 . 주요 후보는 &lt;a href=&quot;generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; &lt;/a&gt; 이며, 현재 Ufunc는 아니지만 일반화 된 Ufuncs로 비교적 쉽게 다시 작성할 수 있습니다. &lt;a href=&quot;generated/numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;min&lt;/code&gt; 및 &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 와 같은 함수에서도 마찬가지 입니다.</target>
        </trans-unit>
        <trans-unit id="1293e5317149027712d90c363de09ae292d438a7" translate="yes" xml:space="preserve">
          <source>We know how to recognize missing data, but we still need to provide a value for these missing entries. By default, this value is determined from the expected dtype according to this table:</source>
          <target state="translated">누락 된 데이터를 인식하는 방법을 알고 있지만 이러한 누락 된 항목에 대한 값을 제공해야합니다. 기본적으로이 값은 다음 표에 따라 예상되는 dtype에서 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8e06849ef9bab23d7db3a10be02e06887dd75e" translate="yes" xml:space="preserve">
          <source>We know that it is painfully common for internet communication to start at or devolve into obvious and flagrant abuse. We also recognize that sometimes people may have a bad day, or be unaware of some of the guidelines in this Code of Conduct. Please keep this in mind when deciding on how to respond to a breach of this Code.</source>
          <target state="translated">우리는 인터넷 통신이 명백하고 명백한 악용으로 시작되거나 그로 이어지는 것이 고통스럽게 흔하다는 것을 알고 있습니다. 또한 때때로 사람들이 나쁜 하루를 보내거나이 행동 강령의 일부 지침을 알지 못할 수도 있음을 알고 있습니다. 이 강령 위반에 대응하는 방법을 결정할 때이를 염두에 두십시오.</target>
        </trans-unit>
        <trans-unit id="c3d95188759c6e8c19362be20ce93f51fbaea853" translate="yes" xml:space="preserve">
          <source>We know that it is painfully common for internet communication to start at or devolve into obvious and flagrant abuse. We will deal quickly with clear and severe breaches like personal threats, violent, sexist or racist language.</source>
          <target state="translated">우리는 인터넷 통신이 명백하고 명백한 악용으로 시작되거나 그로 이어지는 것이 고통스럽게 흔하다는 것을 알고 있습니다. 우리는 개인적 위협, 폭력적, 성 차별적 또는 인종 차별적 언어와 같은 명확하고 심각한 위반 사항을 신속하게 처리 할 것입니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="f7544e988af826e0fbccd6c4b63e19df859cd38a" translate="yes" xml:space="preserve">
          <source>We make something where they don&amp;rsquo;t match:</source>
          <target state="translated">일치하지 않는 부분을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="781a6efc97caaf1a36d25f937ebe769fa9a9b591" translate="yes" xml:space="preserve">
          <source>We may also want to keep track of the occurrence of missing data by constructing a boolean mask, with &lt;code&gt;True&lt;/code&gt; entries where data was missing and &lt;code&gt;False&lt;/code&gt; otherwise. To do that, we just have to set the optional argument &lt;code&gt;usemask&lt;/code&gt; to &lt;code&gt;True&lt;/code&gt; (the default is &lt;code&gt;False&lt;/code&gt;). The output array will then be a &lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또한 데이터가 누락 된 &lt;code&gt;True&lt;/code&gt; 항목과 &lt;code&gt;False&lt;/code&gt; 않으면 False 항목을 사용하여 부울 마스크를 구성하여 누락 된 데이터의 발생을 추적 할 수도 있습니다 . 이를 위해 선택적 인수 &lt;code&gt;usemask&lt;/code&gt; 를 &lt;code&gt;True&lt;/code&gt; 로 설정하면 됩니다 (기본값은 &lt;code&gt;False&lt;/code&gt; ). 그러면 출력 배열은 &lt;a href=&quot;../reference/maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 가&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d343b0827c2326d2e2dfa15e06ce5fa3d4c2f432" translate="yes" xml:space="preserve">
          <source>We may sometimes need to define the column names from the data itself. In that case, we must use the &lt;code&gt;names&lt;/code&gt; keyword with a value of &lt;code&gt;True&lt;/code&gt;. The names will then be read from the first line (after the &lt;code&gt;skip_header&lt;/code&gt; ones), even if the line is commented out:</source>
          <target state="translated">때때로 데이터 자체에서 열 이름을 정의해야 할 수도 있습니다. 이 경우 &lt;code&gt;True&lt;/code&gt; 값과 함께 &lt;code&gt;names&lt;/code&gt; 키워드를 사용해야합니다 . 그런 다음 줄이 주석 처리 된 경우에도 첫 번째 줄 ( &lt;code&gt;skip_header&lt;/code&gt; 다음)에서 이름을 읽 습니다.</target>
        </trans-unit>
        <trans-unit id="a4d639f7ac01ada7c421e46e5c0c6852fa788e6e" translate="yes" xml:space="preserve">
          <source>We might want to use an &lt;code&gt;ndarray&lt;/code&gt; to access these integers. In that case, we can create an array around this memory, and tell numpy that there are two integers, and that they are 16 bit and big-endian:</source>
          <target state="translated">&lt;code&gt;ndarray&lt;/code&gt; 를 사용하여 이러한 정수에 액세스 할 수 있습니다. 이 경우이 메모리 주위에 배열을 만들고 numpy에게 두 개의 정수가 있고 16 비트와 빅 엔디안임을 알릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="072334154bb34d89af6df6dd9ad4c673bc66d42c" translate="yes" xml:space="preserve">
          <source>We mostly follow the standard Python style conventions as described here:</source>
          <target state="translated">우리는 대부분 여기에 설명 된대로 표준 Python 스타일 규칙을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="b81decf25be5fe15c427b84c45168043bb0f3933" translate="yes" xml:space="preserve">
          <source>We need to keep in mind that &lt;code&gt;defaultfmt&lt;/code&gt; is used only if some names are expected but not defined.</source>
          <target state="translated">&lt;code&gt;defaultfmt&lt;/code&gt; 는 일부 이름이 예상되지만 정의되지 않은 경우에만 사용 된다는 점을 명심해야합니다 .</target>
        </trans-unit>
        <trans-unit id="380361f0524609518a908c9433a3d7c3dd0b0e84" translate="yes" xml:space="preserve">
          <source>We need to keep in mind that by default, &lt;code&gt;dtype=float&lt;/code&gt;. A float is therefore expected for the second column. However, the strings &lt;code&gt;' 2.3%'&lt;/code&gt; and &lt;code&gt;' 78.9%'&lt;/code&gt; cannot be converted to float and we end up having &lt;code&gt;np.nan&lt;/code&gt; instead. Let&amp;rsquo;s now use a converter:</source>
          <target state="translated">기본적으로 &lt;code&gt;dtype=float&lt;/code&gt; 입니다. 따라서 두 번째 열에는 부동 소수점이 필요합니다. 그러나 문자열 &lt;code&gt;' 2.3%'&lt;/code&gt; 및 &lt;code&gt;np.nan&lt;/code&gt; &lt;code&gt;' 78.9%'&lt;/code&gt; 는 float로 변환 할 수 없으며 대신 np.nan 을 갖게 됩니다. 이제 변환기를 사용하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b3cf3455d01dd7db3c5c070359dd30cf5e39de43" translate="yes" xml:space="preserve">
          <source>We need to stress that this behavior may not be systematic, that masked data may be affected by the operation in some cases and therefore users should not rely on this data remaining unchanged.</source>
          <target state="translated">우리는이 동작이 체계적이지 않을 수도 있고, 마스킹 된 데이터가 경우에 따라 작업의 영향을받을 수 있으므로 사용자는이 데이터가 변경되지 않은 상태로 남아 있으면 안된다고 강조해야합니다.</target>
        </trans-unit>
        <trans-unit id="70c4b47019e4c41b3daf6bed7ca28bdcaf2fd573" translate="yes" xml:space="preserve">
          <source>We only give the C code as the setup.py file is exactly the same as the setup.py file in &lt;a href=&quot;#example-numpy-ufunc-for-one-dtype&quot;&gt;Example NumPy ufunc for one dtype&lt;/a&gt;, except that the line</source>
          <target state="translated">setup.py 파일이 정확히에서 setup.py 파일과 동일로 우리는 단지 C 코드를 제공 &lt;a href=&quot;#example-numpy-ufunc-for-one-dtype&quot;&gt;한 DTYPE의 예 NumPy와 ufunc&lt;/a&gt; 줄 것을 제외하고,</target>
        </trans-unit>
        <trans-unit id="58ff07099c06b392c411860c04ae360c63b97582" translate="yes" xml:space="preserve">
          <source>We only show a few blocks for clarity:</source>
          <target state="translated">명확성을 위해 몇 가지 블록 만 표시합니다.</target>
        </trans-unit>
        <trans-unit id="3d2e197c5a535b7925bbc101233e0083e1245480" translate="yes" xml:space="preserve">
          <source>We pluralize &lt;em&gt;index&lt;/em&gt; as &lt;em&gt;indices&lt;/em&gt; rather than &lt;a href=&quot;https://developers.google.com/style/word-list#letter-i&quot;&gt;indexes&lt;/a&gt;, following the precedent of &lt;a href=&quot;../reference/generated/numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;numpy.indices&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">우리는 복수형 &lt;em&gt;인덱스&lt;/em&gt; 로 &lt;em&gt;인덱스&lt;/em&gt; 가 아닌 &lt;a href=&quot;https://developers.google.com/style/word-list#letter-i&quot;&gt;인덱스&lt;/a&gt; 의 선례에 따라 &lt;a href=&quot;../reference/generated/numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;numpy.indices&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="304f3c954bda4d21c5240e032a79df191a1f957e" translate="yes" xml:space="preserve">
          <source>We prefer not to use the Google style</source>
          <target state="translated">우리는 Google 스타일을 사용하지 않는 것을 선호합니다.</target>
        </trans-unit>
        <trans-unit id="673c3f49f8ee0b4069fb17ea81837a33f48d70f3" translate="yes" xml:space="preserve">
          <source>We recommend using &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt;&lt;code&gt;isin&lt;/code&gt;&lt;/a&gt; instead of &lt;a href=&quot;#numpy.in1d&quot;&gt;&lt;code&gt;in1d&lt;/code&gt;&lt;/a&gt; for new code.</source>
          <target state="translated">새 코드 에는 &lt;a href=&quot;#numpy.in1d&quot;&gt; &lt;code&gt;in1d&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;numpy.isin#numpy.isin&quot;&gt; &lt;code&gt;isin&lt;/code&gt; 을&lt;/a&gt; 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="cf93137d5dc17f96b6bf02cdfd69394699568873" translate="yes" xml:space="preserve">
          <source>We recommend using dtype objects instead.</source>
          <target state="translated">대신 dtype 개체를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="7ca33c6b93a76db017c3cdc61675ace9bc2b416c" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt; extensions for files saved in this format. This is by no means a requirement; applications may wish to use these file formats but use an extension specific to the application. In the absence of an obvious alternative, however, we suggest using &lt;code&gt;.npy&lt;/code&gt; and &lt;code&gt;.npz&lt;/code&gt;.</source>
          <target state="translated">이 형식으로 저장된 파일 에는 &lt;code&gt;.npy&lt;/code&gt; 및 &lt;code&gt;.npz&lt;/code&gt; 확장자를 사용하는 것이 좋습니다 . 이것은 결코 요구 사항이 아닙니다. 응용 프로그램은 이러한 파일 형식을 사용하지만 응용 프로그램에 맞는 확장명을 사용할 수 있습니다. 그러나 확실한 대안이 없으면 &lt;code&gt;.npy&lt;/code&gt; 및 &lt;code&gt;.npz&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e258b740225a3be0218640f279a2c21d7ffb3dc3" translate="yes" xml:space="preserve">
          <source>We review pull requests as soon as we can, typically within a week. If you get no review comments within two weeks, feel free to ask for feedback by adding a comment on your PR (this will notify maintainers).</source>
          <target state="translated">풀 리퀘스트는 가능한 한 빨리, 일반적으로 일주일 이내에 검토합니다. 2 주 이내에 리뷰 댓글이 없으면 PR에 댓글을 추가하여 자유롭게 피드백을 요청하십시오 (이는 관리자에게 알립니다).</target>
        </trans-unit>
        <trans-unit id="2d2b661adfc63aa8859c127667d479a970f43ef4" translate="yes" xml:space="preserve">
          <source>We run a ufunc on an instance of our new array:</source>
          <target state="translated">새 배열의 인스턴스에서 ufunc를 실행합니다.</target>
        </trans-unit>
        <trans-unit id="cba0887597362639bee54fad4d580fb5a05cde4d" translate="yes" xml:space="preserve">
          <source>We set the printing precision so the example can be auto-tested:</source>
          <target state="translated">예를 자동 테스트 할 수 있도록 인쇄 정밀도를 설정합니다.</target>
        </trans-unit>
        <trans-unit id="44aaad76397b012d2d13a57d62118fcba214a475" translate="yes" xml:space="preserve">
          <source>We strive to:</source>
          <target state="translated">우리는 다음을 위해 노력합니다.</target>
        </trans-unit>
        <trans-unit id="33c0514953dd33becf83ed3bc37cb8f06826d505" translate="yes" xml:space="preserve">
          <source>We then define a new test case class for each supported data type with a short definition such as:</source>
          <target state="translated">그런 다음 지원되는 각 데이터 유형에 대해 다음과 같은 간단한 정의를 사용하여 새 테스트 사례 클래스를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="0935f73910a1bfd402810a3c2528dcf47c85a9da" translate="yes" xml:space="preserve">
          <source>We understand that email is a difficult medium and can be isolating. Receiving criticism over email, without personal contact, can be particularly painful. This makes it especially important to keep an atmosphere of open-minded respect of the views of others. It also means that we must be transparent in our actions, and that we will do everything in our power to make sure that all our members are treated fairly and with sympathy.</source>
          <target state="translated">이메일은 어려운 매체이며 격리 될 수 있음을 알고 있습니다. 개인적인 연락없이 이메일을 통해 비판을받는 것은 특히 고통 스러울 수 있습니다. 이것은 다른 사람들의 견해를 열린 마음으로 존중하는 분위기를 유지하는 것이 특히 중요합니다. 또한 우리의 행동이 투명해야하며 모든 구성원이 공정하고 공감할 수 있도록 최선을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="ad180c1380373588b422b6f9367e1dfa995335a7" translate="yes" xml:space="preserve">
          <source>We use the algorithm published by Clenshaw &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and referenced by Abramowitz and Stegun &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;, for which the function domain is partitioned into the two intervals [0,8] and (8,inf), and Chebyshev polynomial expansions are employed in each interval. Relative error on the domain [0,30] using IEEE arithmetic is documented &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; as having a peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).</source>
          <target state="translated">우리 Clenshaw 발행 알고리즘을 사용하여 &lt;a href=&quot;#rfd38a370b188-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 아브라모 위츠와 Stegun 의해 참조 된 &lt;a href=&quot;#rfd38a370b188-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; 기능 영역에는 두 구간 [0,8] 및 (8, INF)로 분할되는이, 및 체비 셰프 다항식 전개는에 채용 각 간격. IEEE 산술을 사용하는 도메인 [0,30]의 상대 오류 는 1.4e-16의 rms (n = 30000)로 5.8e-16의 피크를 갖는 것으로 문서화되어 있습니다 &lt;a href=&quot;#rfd38a370b188-3&quot; id=&quot;id3&quot;&gt;[3]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d53c78c1f4b5630c6b07b51b68a31292300c983" translate="yes" xml:space="preserve">
          <source>We use the same Fortran 77 code as in previous example but now we&amp;rsquo;ll pretend that F2PY was not able to guess the signatures of call-back arguments correctly. First, we create an initial signature file &lt;code&gt;callback2.pyf&lt;/code&gt; using F2PY:</source>
          <target state="translated">이전 예제에서와 동일한 Fortran 77 코드를 사용하지만 이제 F2PY가 콜백 인수의 서명을 올바르게 추측 할 수 없다고 가정합니다. 먼저 F2PY를 사용하여 초기 서명 파일 &lt;code&gt;callback2.pyf&lt;/code&gt; 를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a0523fb6c3b4aea424494446d21b54e60300c1ae" translate="yes" xml:space="preserve">
          <source>We wait until this point to push the tag because it is public and should not be changed after it has been pushed.</source>
          <target state="translated">태그가 공개되어 푸시 된 후에는 변경되어서는 안되기 때문에이 시점까지 태그를 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="97648b7bd3927ac1d2723b1e8ddc4d732f8e55fd" translate="yes" xml:space="preserve">
          <source>We welcome being &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;alerted&lt;/a&gt; to cases we should add to the NumPy style rules.</source>
          <target state="translated">NumPy 스타일 규칙에 추가해야하는 사례 에 대한 &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;알림&lt;/a&gt; 을 받는 것을 환영 합니다.</target>
        </trans-unit>
        <trans-unit id="c9afbb264decb0b7e5bd769fa476b27d49621056" translate="yes" xml:space="preserve">
          <source>We will deal with the domain and window when we get to fitting, for the moment we ignore them and run through the basic algebraic and arithmetic operations.</source>
          <target state="translated">우리는 우리가 적합 할 때 도메인과 창을 다룰 것입니다. 우리는 그것들을 무시하고 기본 대수 및 산술 연산을 수행하는 순간입니다.</target>
        </trans-unit>
        <trans-unit id="4c1bac40e83eb84eced242b32b6de4090c9d63d5" translate="yes" xml:space="preserve">
          <source>We will investigate and respond to all complaints. The NumPy Code of Conduct Committee and the NumPy Steering Committee (if involved) will protect the identity of the reporter, and treat the content of complaints as confidential (unless the reporter agrees otherwise).</source>
          <target state="translated">우리는 모든 불만 사항을 조사하고 이에 대응할 것입니다. NumPy 행동 강령위원회 및 NumPy 운영위원회 (관련된 경우)는 신고자의 신원을 보호하고 신고 내용을 기밀로 취급합니다 (신고자가 달리 동의하지 않는 한).</target>
        </trans-unit>
        <trans-unit id="a83f39578a9a665e3a205bff08ec0d259c697975" translate="yes" xml:space="preserve">
          <source>We will use NumPy&amp;rsquo;s linear algebra module, &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt;, to perform the operations in this tutorial. Most of the linear algebra functions in this module can also be found in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt;, and users are encouraged to use the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy&quot;&gt;&lt;code&gt;scipy&lt;/code&gt;&lt;/a&gt; module for real-world applications. However, it is currently not possible to apply linear algebra operations to n-dimensional arrays using the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt;&lt;code&gt;scipy.linalg&lt;/code&gt;&lt;/a&gt; module. For more information on this, check the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html&quot;&gt;scipy.linalg Reference&lt;/a&gt;.</source>
          <target state="translated">NumPy의 선형 대수 모듈 인 &lt;a href=&quot;../reference/routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; 를 사용하여이 튜토리얼의 작업을 수행합니다. 이 모듈의 대부분의 선형 대수 함수는 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;scipy.linalg&lt;/code&gt; &lt;/a&gt; 에서도 찾을 수 있으며 사용자는 실제 응용 프로그램에 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/index.html#module-scipy&quot;&gt; &lt;code&gt;scipy&lt;/code&gt; &lt;/a&gt; 모듈 을 사용하는 것이 좋습니다 . 그러나 현재는 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/linalg.html#module-scipy.linalg&quot;&gt; &lt;code&gt;scipy.linalg&lt;/code&gt; &lt;/a&gt; 모듈을 사용하여 n 차원 배열에 선형 대수 연산을 적용 할 수 없습니다 . 이에 대한 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/tutorial/linalg.html&quot;&gt;scipy.linalg 참조를&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="82a72786c4fe5d6bfb5f753a25b0cbc3ef629d6d" translate="yes" xml:space="preserve">
          <source>We wish to mark the fourth entry as invalid. The easiest is to create a masked array:</source>
          <target state="translated">네 번째 항목을 유효하지 않은 것으로 표시하려고합니다. 가장 쉬운 방법은 마스크 배열을 만드는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2678a6cb2f01328bc5e5792424e05e77b5265e7c" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll do a simple outer product, placing the dimensions of the first operand before the dimensions of the second operand. The &lt;code&gt;op_axes&lt;/code&gt; parameter needs one list of axes for each operand, and provides a mapping from the iterator&amp;rsquo;s axes to the axes of the operand.</source>
          <target state="translated">첫 번째 피연산자의 치수를 두 번째 피연산자의 치수 앞에 배치하여 간단한 외부 곱을 수행합니다. &lt;code&gt;op_axes&lt;/code&gt; 의 매개 변수는 각 피연산자에 축 하나 개의 목록을 필요로하고, 피연산자의 축에 반복자의 축에서의 매핑을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ced2186a63444cfbd458cebaed4de6214b500394" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ll show how this works by creating a function &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt;&lt;code&gt;square&lt;/code&gt;&lt;/a&gt; which squares its input. Let&amp;rsquo;s start with a minimal function definition excluding &amp;lsquo;out&amp;rsquo; parameter support.</source>
          <target state="translated">입력을 제곱 하는 함수 &lt;a href=&quot;generated/numpy.square#numpy.square&quot;&gt; &lt;code&gt;square&lt;/code&gt; &lt;/a&gt; 을 만들어서 이것이 어떻게 작동하는지 보여 드리겠습니다 . 'out'매개 변수 지원을 제외한 최소 함수 정의부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="844ec2b5d0ad65b6ef4bf0acb9f400aab9e00804" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;re eager to hear about and fix doc defects. But to attack the biggest problems we end up having to defer or overlook some bug reports. Here are the best defects to go after.</source>
          <target state="translated">우리는 문서 결함에 대해 듣고 수정하기를 간절히 원합니다. 그러나 가장 큰 문제를 공격하기 위해 우리는 일부 버그 보고서를 연기하거나 간과해야합니다. 다음은 가장 좋은 결함입니다.</target>
        </trans-unit>
        <trans-unit id="0d014927573cadb3b0b374c9809c25adaa8d709f" translate="yes" xml:space="preserve">
          <source>We&amp;rsquo;ve seen that 13 is represented by &lt;code&gt;00001101&lt;/code&gt;. The invert or bit-wise NOT of 13 is then:</source>
          <target state="translated">13은 &lt;code&gt;00001101&lt;/code&gt; 로 표시되는 것을 보았습니다 . 13의 반전 또는 비트 NOT은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="08e02d58d5e7e09402e352c84d20a516011f20f4" translate="yes" xml:space="preserve">
          <source>Website design and development</source>
          <target state="translated">웹 사이트 디자인 및 개발</target>
        </trans-unit>
        <trans-unit id="9f5117721c82b02552e432ea3720cde40d7059ad" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite polynomials.</source>
          <target state="translated">은자 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="95800a204e1bbd4903f4870d8343853257206077" translate="yes" xml:space="preserve">
          <source>Weight function of the Hermite_e polynomials.</source>
          <target state="translated">Hermite_e 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="5f860b19432a865263496fdce430b1e33571bfe5" translate="yes" xml:space="preserve">
          <source>Weight function of the Laguerre polynomials.</source>
          <target state="translated">Laguerre 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="79be08f88c623301ce3bc873b7c9affda9625a90" translate="yes" xml:space="preserve">
          <source>Weight function of the Legendre polynomials.</source>
          <target state="translated">Legendre 다항식의 가중치 함수.</target>
        </trans-unit>
        <trans-unit id="c74e4e7c5caf95682fb65872b5814741f06c7fac" translate="yes" xml:space="preserve">
          <source>Weighted average</source>
          <target state="translated">가중 평균</target>
        </trans-unit>
        <trans-unit id="d8f6b85e664320ad22c47352d13059c9a94e57ff" translate="yes" xml:space="preserve">
          <source>Weighted average.</source>
          <target state="translated">가중 평균.</target>
        </trans-unit>
        <trans-unit id="50616113e0953b16858a840423f52798108ba636" translate="yes" xml:space="preserve">
          <source>Weights to apply to the y-coordinates of the sample points. For gaussian uncertainties, use 1/sigma (not 1/sigma**2).</source>
          <target state="translated">샘플 포인트의 y 좌표에 적용 할 가중치입니다. 가우스 불확실성의 경우 1 / 시그마 (1 / 시그마 ** 2 아님)를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5a7070233023bbad210855f921220f6a37969ec7" translate="yes" xml:space="preserve">
          <source>Weights, array of the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">가중치는 &lt;code&gt;x&lt;/code&gt; 와 동일한 모양의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="946476c654c11a5e92f8b55850bb98a1263ad96b" translate="yes" xml:space="preserve">
          <source>Weights. If not None the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">무게. 그렇지 않은 경우 적합치에 대한 각 점 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 의 기여도는 &lt;code&gt;w[i]&lt;/code&gt; 가중치가 적용됩니다 . 이상적으로 가중치는 제품 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 오차가 모두 동일한 분산을 갖도록 선택됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="1c25ee55e973a0ac3876804d2f28cc0929f53254" translate="yes" xml:space="preserve">
          <source>Weights. If not None, the contribution of each point &lt;code&gt;(x[i],y[i])&lt;/code&gt; to the fit is weighted by &lt;code&gt;w[i]&lt;/code&gt;. Ideally the weights are chosen so that the errors of the products &lt;code&gt;w[i]*y[i]&lt;/code&gt; all have the same variance. The default value is None.</source>
          <target state="translated">무게. None이 아닌 경우, 각 점 &lt;code&gt;(x[i],y[i])&lt;/code&gt; 의 적합치에 대한 가중치는 &lt;code&gt;w[i]&lt;/code&gt; 됩니다. 이상적으로 가중치는 제품 &lt;code&gt;w[i]*y[i]&lt;/code&gt; 오차가 모두 동일한 분산을 갖도록 선택됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="890907bf4b6e9a3c2721945116f4521c292ba997" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;이분 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/BinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/BinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="44532eacfd8a477fb8d811692e1a730faf373cda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Cauchy Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;Cauchy Distribution.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/CauchyDistribution.html&quot;&gt;http://mathworld.wolfram.com/CauchyDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ce6b4d0490f5c6c29f7bd660e93014a010601e88" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Gamma Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;감마 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/GammaDistribution.html&quot;&gt;http://mathworld.wolfram.com/GammaDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="250b4512032938435df06c099254026086b0b46d" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Hypergeometric Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;고도 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/HypergeometricDistribution.html&quot;&gt;http://mathworld.wolfram.com/HypergeometricDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="403ee22c6c9f5dfb6128b5015952af83dc7fe1f5" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Laplace Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;라플라스 배포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/LaplaceDistribution.html&quot;&gt;http://mathworld.wolfram.com/LaplaceDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c85ee5175b40c6661962e1c4dcdc7232b8e5568a" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Logistic Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;물류 유통&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/LogisticDistribution.html&quot;&gt;http://mathworld.wolfram.com/LogisticDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d1938577c4f79d7fadb65a22f0b9b9cba0e6904e" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Negative Binomial Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;음 이항 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&quot;&gt;http://mathworld.wolfram.com/NegativeBinomialDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed9cdcffdd5a34db501b8269560f163da34bcfda" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Noncentral F-Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;비 중앙 F- 배포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/NoncentralF-Distribution.html&quot;&gt;http://mathworld.wolfram.com/NoncentralF-Distribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6786c23a16b57cae22a2a2fe8c5eef583bfac0cc" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Poisson Distribution.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;포아송 분포&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/PoissonDistribution.html&quot;&gt;http://mathworld.wolfram.com/PoissonDistribution.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87ff1415ce102e6420c0e0f61ef322d348a5f507" translate="yes" xml:space="preserve">
          <source>Weisstein, Eric W. &amp;ldquo;Sinc Function.&amp;rdquo; From MathWorld&amp;ndash;A Wolfram Web Resource. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</source>
          <target state="translated">Weisstein, Eric W.&amp;ldquo;Sinc Function.&amp;rdquo; MathWorld &amp;ndash; Wolfram 웹 리소스. &lt;a href=&quot;http://mathworld.wolfram.com/SincFunction.html&quot;&gt;http://mathworld.wolfram.com/SincFunction.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d56f530182243e33b481a1e9052be8e6b37f719d" translate="yes" xml:space="preserve">
          <source>Welcome to NumPy!</source>
          <target state="translated">NumPy에 오신 것을 환영합니다!</target>
        </trans-unit>
        <trans-unit id="abaf546091bcd48cd855fade4a2162266fa33ab0" translate="yes" xml:space="preserve">
          <source>Welcome to the absolute beginner&amp;rsquo;s guide to NumPy! If you have comments or suggestions, please don&amp;rsquo;t hesitate to reach out!</source>
          <target state="translated">NumPy에 대한 완전 초보자 가이드에 오신 것을 환영합니다! 의견이나 제안이 있으시면 주저하지 마시고 연락주세요!</target>
        </trans-unit>
        <trans-unit id="97cc607ac7fcfde11c85a5379ce211093f48fda9" translate="yes" xml:space="preserve">
          <source>Welcome! This is the documentation for NumPy 1.19.0, last updated Jun 29, 2020.</source>
          <target state="translated">어서 오십시오! 이것은 NumPy 1.19.0에 대한 문서이며, 마지막으로 업데이트 된 2020 년 6 월 29 일입니다.</target>
        </trans-unit>
        <trans-unit id="e52f86b6168d7288c28967f3ee6d60f730fcffb9" translate="yes" xml:space="preserve">
          <source>Welcome! This is the documentation for NumPy 1.20.0 , last updated Jan 31, 2021.</source>
          <target state="translated">어서 오십시오! 이것은 NumPy 1.20.0에 대한 문서이며, 2021 년 1 월 31 일에 마지막으로 업데이트되었습니다.</target>
        </trans-unit>
        <trans-unit id="e4a9602b9f7c3767b63b80691e19a57b6adce08c" translate="yes" xml:space="preserve">
          <source>What are masked arrays?</source>
          <target state="translated">마스킹 된 배열이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="3fef717821661f9806ec19067704e1d37a6e1a47" translate="yes" xml:space="preserve">
          <source>What are the least-squares-best &lt;code&gt;m&lt;/code&gt; and &lt;code&gt;y0&lt;/code&gt; in &lt;code&gt;y = y0 + mx&lt;/code&gt; for the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points and you&amp;rsquo;ll see that it should be y0 = 0, m = 1.) The answer is provided by solving the over-determined matrix equation &lt;code&gt;Ax = b&lt;/code&gt;, where:</source>
          <target state="translated">{(0,1), (1,0), (1,2), (2,1)} 데이터에 대해 &lt;code&gt;y = y0 + mx&lt;/code&gt; 에서 최소 제곱이 가장 좋은 &lt;code&gt;m&lt;/code&gt; 및 &lt;code&gt;y0&lt;/code&gt; 은 무엇입니까? (점을 그래프로 표시하면 y0 = 0, m = 1이어야 함을 알 수 있습니다.) 답은 과도하게 결정된 행렬 방정식 &lt;code&gt;Ax = b&lt;/code&gt; 를 해결하여 제공됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e9b892da0c44e54a5a3d94ba212b74404ec1950" translate="yes" xml:space="preserve">
          <source>What can be converted to a data-type object is described below:</source>
          <target state="translated">데이터 형식 개체로 변환 할 수있는 내용은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7f1eadc1a60d1383bbd27a5874b7f7b346ec84b4" translate="yes" xml:space="preserve">
          <source>What encoding to use when reading Python 2 strings. Only useful when loading Python 2 generated pickled files in Python 3, which includes npy/npz files containing object arrays. Values other than &amp;lsquo;latin1&amp;rsquo;, &amp;lsquo;ASCII&amp;rsquo;, and &amp;lsquo;bytes&amp;rsquo; are not allowed, as they can corrupt numerical data. Default: &amp;lsquo;ASCII&amp;rsquo;</source>
          <target state="translated">Python 2 문자열을 읽을 때 사용할 인코딩 Python 3에서 객체 배열을 포함하는 npy / npz 파일을 포함하는 Python 2 생성 된 절인 파일을로드 할 때만 유용합니다. 'latin1', 'ASCII'및 'bytes'이외의 값은 숫자 데이터를 손상시킬 수 있으므로 허용되지 않습니다. 기본값 : 'ASCII'</target>
        </trans-unit>
        <trans-unit id="a414efd43aeae99e0f66cba2afec4195fe86ff0f" translate="yes" xml:space="preserve">
          <source>What happened.</source>
          <target state="translated">어떻게 된 거예요.</target>
        </trans-unit>
        <trans-unit id="cc1dbc2aba98097ae72989d44015108a57b61d35" translate="yes" xml:space="preserve">
          <source>What happens with unexpected inputs like empty arrays or nan/inf values?</source>
          <target state="translated">빈 배열이나 nan / inf 값과 같은 예상치 못한 입력은 어떻게됩니까?</target>
        </trans-unit>
        <trans-unit id="b53d35ef01217a62dff0ba25d166a1b1caaa9dc7" translate="yes" xml:space="preserve">
          <source>What if the user specifies certain &lt;strong&gt;baseline features&lt;/strong&gt; during the build but at runtime the machine doesn&amp;rsquo;t support even these features? Will the compiled code be called via one of these definitions, or maybe the compiler itself auto-generated/vectorized certain piece of code based on the provided command line compiler flags?</source>
          <target state="translated">사용자 가 빌드 중에 특정 &lt;strong&gt;기본 기능을&lt;/strong&gt; 지정 했지만 런타임시 머신이 이러한 기능도 지원하지 않으면 어떻게됩니까? 컴파일 된 코드는 이러한 정의 중 하나를 통해 호출됩니까, 아니면 컴파일러 자체가 제공된 명령 줄 컴파일러 플래그를 기반으로 특정 코드 조각을 자동 생성 / 벡터화합니까?</target>
        </trans-unit>
        <trans-unit id="d026aa92cb632a0008d65ec665e66cb82db19d44" translate="yes" xml:space="preserve">
          <source>What is NumPy?</source>
          <target state="translated">NumPy는 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="1e1fa581e9e916507b4446a529a092d8e86437db" translate="yes" xml:space="preserve">
          <source>What is a masked array?</source>
          <target state="translated">마스크 배열이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9751e6648cb276739f841dae292a17853fcae611" translate="yes" xml:space="preserve">
          <source>What is an array?</source>
          <target state="translated">어레이 란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="437c59796bebb67cae1bb453196d12e5dabd418f" translate="yes" xml:space="preserve">
          <source>What is compared are values, not types. So an int (1) and an array of length one can evaluate as True:</source>
          <target state="translated">비교되는 것은 유형이 아니라 값입니다. 따라서 int (1)과 길이가 1 인 배열은 True로 평가할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0ad7f91a8e7927b564b105b1d3081b63dcc31aef" translate="yes" xml:space="preserve">
          <source>What is described below is a recommended workflow with Git.</source>
          <target state="translated">아래에 설명 된 것은 Git에서 권장되는 워크 플로입니다.</target>
        </trans-unit>
        <trans-unit id="b5bea1d13da31e58211ad4c35c1a02b82b3ae53f" translate="yes" xml:space="preserve">
          <source>What is released</source>
          <target state="translated">출시되는 것</target>
        </trans-unit>
        <trans-unit id="ed5c56f4637ad63b06ae7f91c4fda9c76b610d6b" translate="yes" xml:space="preserve">
          <source>What is tested is whether the input has a non-zero imaginary part, not if the input type is complex.</source>
          <target state="translated">테스트 된 것은 입력 유형이 복잡한 경우가 아니라 입력에 0이 아닌 허수 부분이 있는지 여부입니다.</target>
        </trans-unit>
        <trans-unit id="010a5d0834f679e03164332d6d50425424fc97f8" translate="yes" xml:space="preserve">
          <source>What is the amortization schedule for a 1 year loan of $2500 at 8.24% interest per year compounded monthly?</source>
          <target state="translated">매월 복리로 지급되는 연간 8.24 %의 이자율로 $ 2500의 1 년 대출 상환 일정은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="59aacf2a72313a7cde0de3da40cb764e30627fa7" translate="yes" xml:space="preserve">
          <source>What is the future value after 10 years of saving $100 now, with an additional monthly savings of $100. Assume the interest rate is 5% (annually) compounded monthly?</source>
          <target state="translated">10 년 동안 $ 100를 절약 한 후의 미래 가치는 $ 100의 추가 월간 절약입니다. 이자율이 매월 5 % (연간) 복리라고 가정합니까?</target>
        </trans-unit>
        <trans-unit id="68f86a620521000717f405763a7c2c87aeacd919" translate="yes" xml:space="preserve">
          <source>What is the monthly payment needed to pay off a $200,000 loan in 15 years at an annual interest rate of 7.5%?</source>
          <target state="translated">15 년 동안 연간 7.5 %의 이자율로 20 만 달러의 대출을 상환하는 데 필요한 월별 지불금은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="bd55b3638089456ad2fcd33f8ddb002a9ff2afef" translate="yes" xml:space="preserve">
          <source>What is the present value (e.g., the initial investment) of an investment that needs to total $15692.93 after 10 years of saving $100 every month? Assume the interest rate is 5% (annually) compounded monthly.</source>
          <target state="translated">매월 $ 100를 절약 한 후 10 년 동안 총 $ 15692.93이 필요한 투자의 현재 가치 (예 : 초기 투자)는 얼마입니까? 이자율이 매월 5 % (연간) 복리라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="80bbcabaec75450b003887ef27bbf523c85b5a9f" translate="yes" xml:space="preserve">
          <source>What is the right way to index multi-dimensional arrays? Before you jump to conclusions about the one and true way to index multi-dimensional arrays, it pays to understand why this is a confusing issue. This section will try to explain in detail how numpy indexing works and why we adopt the convention we do for images, and when it may be appropriate to adopt other conventions.</source>
          <target state="translated">다차원 배열을 인덱싱하는 올바른 방법은 무엇입니까? 다차원 배열을 인덱스하는 하나의 진정한 방법에 대한 결론으로 ​​넘어 가기 전에 이것이 왜 혼란스러운 문제인지 이해해야합니다. 이 섹션에서는 numpy 인덱싱 작동 방식과 이미지에 대한 규칙을 채택하는 이유 및 다른 규칙을 채택하는 것이 적절한시기에 대해 자세히 설명하려고합니다.</target>
        </trans-unit>
        <trans-unit id="c8f9b6ad9828683b0bae9bbc812741ce15ef2e1e" translate="yes" xml:space="preserve">
          <source>What makes this work so well is that &lt;code&gt;predictions&lt;/code&gt; and &lt;code&gt;labels&lt;/code&gt; can contain one or a thousand values. They only need to be the same size.</source>
          <target state="translated">이것이 잘 작동하는 이유는 &lt;code&gt;predictions&lt;/code&gt; 과 &lt;code&gt;labels&lt;/code&gt; 이 하나 또는 천 개의 값을 포함 할 수 있다는 것입니다 . 크기 만 동일하면됩니다.</target>
        </trans-unit>
        <trans-unit id="e27b294bbb4cb3c1e3ee88822cc65d21f2416881" translate="yes" xml:space="preserve">
          <source>What results is the construction of a new array where each value of the index array selects one row from the array being indexed and the resultant array has the resulting shape (number of index elements, size of row).</source>
          <target state="translated">결과는 인덱스 배열의 각 값이 인덱싱되는 배열에서 한 행을 선택하고 결과 배열이 결과 모양 (인덱스 요소 수, 행 크기)을 갖는 새 배열의 구성입니다.</target>
        </trans-unit>
        <trans-unit id="5cc81ce77bcae494adbf2656415c9e36736b6793" translate="yes" xml:space="preserve">
          <source>What we lack are docs with broader scope &amp;ndash; tutorials, how-tos, and explanations. Reporting defects is another way to contribute. We discuss both.</source>
          <target state="translated">우리가 부족한 것은 자습서, 방법 및 설명과 같은 더 넓은 범위의 문서입니다. 결함보고는 기여하는 또 다른 방법입니다. 우리는 둘 다 논의합니다.</target>
        </trans-unit>
        <trans-unit id="0bd771107f7afe976fc592b463f0e0c3505ed432" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s New or Different</source>
          <target state="translated">새로운 점 또는 다른 점</target>
        </trans-unit>
        <trans-unit id="6137204c31653b349cf3c8ead844b7d64e89eb84" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s needed</source>
          <target state="translated">필요한 것</target>
        </trans-unit>
        <trans-unit id="2feeca88895960783f7c2e153b1e528ad57119f7" translate="yes" xml:space="preserve">
          <source>What&amp;rsquo;s the difference between a Python list and a NumPy array?</source>
          <target state="translated">Python 목록과 NumPy 배열의 차이점은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="9f2949fbd884fd2e87977bc6442d7541c249e9bc" translate="yes" xml:space="preserve">
          <source>What’s New or Different</source>
          <target state="translated">새로운 점 또는 다른 점</target>
        </trans-unit>
        <trans-unit id="7c1df74199c25c42832661082d6ca6ac9e56b175" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ?wg_abbrev=office-formulaOpenDocument-formula-20090508.odt</source>
          <target state="translated">휠러, DA, E. Rathke 및 R. Weir (Eds.) (2009, 5 월). Office 응용 프로그램 용 Open Document 형식 (OpenDocument) v1.2, Part 2 : 재 계산 된 수식 (OpenFormula) 형식-주석이 달린 버전, 초안 12. 구조화 된 정보 표준 (OASIS)의 발전을위한 조직. 미국 메사추세츠 빌리 카 [ODT 문서]. 이용 가능 : &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php&quot;&gt;http://www.oasis-open.org/committees/documents.php&lt;/a&gt; ? wg_abbrev = office-formulaOpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="030c83d2119f52206dbf3733046b420a1749a0e1" translate="yes" xml:space="preserve">
          <source>Wheeler, D. A., E. Rathke, and R. Weir (Eds.) (2009, May). Open Document Format for Office Applications (OpenDocument)v1.2, Part 2: Recalculated Formula (OpenFormula) Format - Annotated Version, Pre-Draft 12. Organization for the Advancement of Structured Information Standards (OASIS). Billerica, MA, USA. [ODT Document]. Available: &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</source>
          <target state="translated">휠러, DA, E. Rathke 및 R. Weir (Eds.) (2009, 5 월). Office 응용 프로그램 용 Open Document 형식 (OpenDocument) v1.2, Part 2 : 재 계산 된 수식 (OpenFormula) 형식-주석이 달린 버전, 초안 12. 구조화 된 정보 표준 (OASIS)의 발전을위한 조직. 미국 메사추세츠 빌리 카 [ODT 문서]. 이용 가능 : &lt;a href=&quot;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&quot;&gt;http://www.oasis-open.org/committees/documents.php?wg_abbrev=office-formula&lt;/a&gt; OpenDocument-formula-20090508.odt</target>
        </trans-unit>
        <trans-unit id="45e561a630c53e04980638c8d4e86ae0087886be" translate="yes" xml:space="preserve">
          <source>Wheels</source>
          <target state="translated">Wheels</target>
        </trans-unit>
        <trans-unit id="28b30ef805c7fb044e119b47e7ac08078b5b70cf" translate="yes" xml:space="preserve">
          <source>When &amp;lsquo;decimals&amp;rsquo; is negative, it specifies the number of positions to the left of the decimal point. The real and imaginary parts of complex numbers are rounded separately. Nothing is done if the array is not of float type and &amp;lsquo;decimals&amp;rsquo; is greater than or equal to 0.</source>
          <target state="translated">'소수'가 음수이면 소수점 왼쪽의 위치 수를 지정합니다. 복소수의 실수 부와 허수 부는 따로 반올림됩니다. 배열이 부동 유형이 아니고 '소수'가 0보다 크거나 같으면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f209cff1399437b00b7cd0ee8730d177efc65293" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is specified, the typical inner loop construct is as follows.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 가&lt;/a&gt; 지정되면, 전형적인 내부 루프 구조는 다음이다.</target>
        </trans-unit>
        <trans-unit id="e3bd2b595c2ff9c9cbf3b48defe560bc708bb864" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt; 이 호출 될 때</target>
        </trans-unit>
        <trans-unit id="62e74c933581584a63ff5ff51eb96f98ecf99dc0" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;#numpy.ma.masked_array.tofile&quot;&gt;&lt;code&gt;tofile&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.masked_array.tofile&quot;&gt; &lt;code&gt;tofile&lt;/code&gt; &lt;/a&gt; 이 호출 될 때 .</target>
        </trans-unit>
        <trans-unit id="0d17005044d622bf07127624dd5d1775dbe22cd5" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not a valid dtype for a structured array.</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 구조화 된 배열에 대한 유효 DTYPE 아니다.</target>
        </trans-unit>
        <trans-unit id="105e60976ea8fbfb90203db8ab4a0a320369170d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;A = rfft(a)&lt;/code&gt; and fs is the sampling frequency, &lt;code&gt;A[0]&lt;/code&gt; contains the zero-frequency term 0*fs, which is real due to Hermitian symmetry.</source>
          <target state="translated">경우 &lt;code&gt;A = rfft(a)&lt;/code&gt; 및 FS 샘플링 주파수이며, &lt;code&gt;A[0]&lt;/code&gt; 에르 미트 대칭으로 인한 진짜 제로 주파수 용어 0 * FS 함유한다.</target>
        </trans-unit>
        <trans-unit id="fb065328be54e2c3569cb5f58bbc8287bcb1fb7d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; is called, the array pointed to by base will be updated with the contents of this array.</source>
          <target state="translated">&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 가 호출 되면 base 가 가리키는 배열이이 배열의 내용으로 업데이트됩니다.</target>
        </trans-unit>
        <trans-unit id="6087c2287fac970fe48c994c66e9668908c28aae" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a = 1&lt;/code&gt;, the Weibull distribution reduces to the exponential distribution.</source>
          <target state="translated">경우 &lt;code&gt;a = 1&lt;/code&gt; ,와 이블 분포는 지수 분포를 감소시킨다.</target>
        </trans-unit>
        <trans-unit id="3234eec63d682a68b39f821bda537d5249018389" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a 2D array, it is factorized as &lt;code&gt;u @ np.diag(s) @ vh
= (u * s) @ vh&lt;/code&gt;, where &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; are 2D unitary arrays and &lt;code&gt;s&lt;/code&gt; is a 1D array of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s singular values. When &lt;code&gt;a&lt;/code&gt; is higher-dimensional, SVD is applied in stacked mode as explained below.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 2 차원 어레이가로 인수 분해된다 &lt;code&gt;u @ np.diag(s) @ vh = (u * s) @ vh&lt;/code&gt; 여기서 &lt;code&gt;u&lt;/code&gt; 와 &lt;code&gt;vh&lt;/code&gt; 2D 단일 배열하고 &lt;code&gt;s&lt;/code&gt; 의 1 차원 배열 의 특이 값 . &lt;code&gt;a&lt;/code&gt; 가 더 높은 차원 일 때 , SVD는 아래 설명 된 바와 같이 스택 모드로 적용됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40bcbe29998f385e3a1059191be0f61338a8c763" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is a structured array, this argument specifies which fields to compare first, second, and so on. This list does not need to include all of the fields.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 구조적 배열 필드 인수 지정이 먼저 제 등과 비교한다. 이 목록은 모든 필드를 포함 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="c171b92b4bddf9c8ebd2e75ee317f0b5fe3e94eb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드이 인수 지정 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수 있으며, 모든 필드가 지정 될 필요는 없지만, 불특정 필드 여전히에서 사용될 관계를 깨기 위해 dtype에 나타나는 순서.</target>
        </trans-unit>
        <trans-unit id="78f75090c501ced3a2b9ede8c30345a037a7c202" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string, and not all fields need to be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드이 인수 지정 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수 있으며, 모든 필드가 지정되어야하지만, 불특정 필드가 여전히 사용될 것이다 관계를 깨기 위해 dtype에 나타나는 순서.</target>
        </trans-unit>
        <trans-unit id="2cd3e98c67109375f859806b9beef061a4ef694a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. A single field can be specified as a string. Not all fields need be specified, but unspecified fields will still be used, in the order in which they come up in the dtype, to break ties.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드 인수 지정이 먼저 비교하는 제 등의 단일 필드가 문자열로 지정 될 수있다. 모든 필드를 지정할 필요는 없지만 지정되지 않은 필드는 dtype에 나타난 순서대로 계속 사용되어 관계를 끊습니다.</target>
        </trans-unit>
        <trans-unit id="b2ce72a40e12e2d7dda3e8c60930788493a39d27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;a&lt;/code&gt; is an array with fields defined, this argument specifies which fields to compare first, second, etc. Not all fields need be specified.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 정의 필드 배열 인 필드 인수 지정이 모든 필드가 지정 될 필요가없는 등의 초 먼저 비교한다.</target>
        </trans-unit>
        <trans-unit id="ffd5f3ded394e20ded56e4169ae0a349c97ccd8c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;arange&lt;/code&gt; is used with floating point arguments, it is generally not possible to predict the number of elements obtained, due to the finite floating point precision. For this reason, it is usually better to use the function &lt;code&gt;linspace&lt;/code&gt; that receives as an argument the number of elements that we want, instead of the step:</source>
          <target state="translated">경우 &lt;code&gt;arange&lt;/code&gt; 에가 소수점 인수 부동 사용되며, 그 때문에 상기 유한 부동 소수점 정밀도, 요소의 수는 얻어진 예측하는 것은 일반적으로 가능하지 않다. 이러한 이유로 일반적으로 단계 대신 원하는 요소 수를 인수로받는 &lt;code&gt;linspace&lt;/code&gt; 함수를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="d9212747ec3985b5dbc30be906a85b9cd4a58814" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axes&lt;/code&gt; is integer_like, the sequence for evaluation will be: first the -Nth axis in &lt;code&gt;a&lt;/code&gt; and 0th axis in &lt;code&gt;b&lt;/code&gt;, and the -1th axis in &lt;code&gt;a&lt;/code&gt; and Nth axis in &lt;code&gt;b&lt;/code&gt; last.</source>
          <target state="translated">경우 &lt;code&gt;axes&lt;/code&gt; 처음에 -Nth 축 : integer_like이며, 평가 용 시퀀스 것이다 및 0 차의 축 &lt;code&gt;b&lt;/code&gt; 과의 축 -1th 및 제 N은 축에 &lt;code&gt;b&lt;/code&gt; 마지막. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0e5c01c245527cc066079729775f892bf5a93e0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;axis&lt;/code&gt; is specified, &lt;code&gt;values&lt;/code&gt; must have the correct shape.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 지정되고, &lt;code&gt;values&lt;/code&gt; 올바른 모양을 가지고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="91b3e386bc1245c3b6fdcb369364554e159e0d4a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;callstatement&lt;/code&gt; statement is used then F2PY may not generate proper prototypes for Fortran/C functions (because &lt;code&gt;&amp;lt;C-expr&amp;gt;&lt;/code&gt; may contain any function calls and F2PY has no way to determine what should be the proper prototype). With this statement you can explicitly specify the arguments of the corresponding prototype:</source>
          <target state="translated">&lt;code&gt;callstatement&lt;/code&gt; 문이 사용 되면 F2PY 는 Fortran / C 함수에 대한 적절한 프로토 타입을 생성하지 못할 수 있습니다 ( &lt;code&gt;&amp;lt;C-expr&amp;gt;&lt;/code&gt; 에는 함수 호출이 포함될 수 있고 F2PY는 적절한 프로토 타입이 무엇인지 결정할 방법이 없기 때문입니다). 이 문을 사용하여 해당 프로토 타입의 인수를 명시 적으로 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a3f207a74aef7083c1eb02bef5c64216a30b6fc" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;condition&lt;/code&gt; or &lt;code&gt;a&lt;/code&gt; contain masked values.</source>
          <target state="translated">때 &lt;code&gt;condition&lt;/code&gt; 또는 &lt;code&gt;a&lt;/code&gt; 는 마스크 값이 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3581744e88f263225956bbed713e5c867c6bf74" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;copy=False&lt;/code&gt; and a copy is made for other reasons, the result is the same as if &lt;code&gt;copy=True&lt;/code&gt;, with some exceptions for &lt;code&gt;A&lt;/code&gt;, see the Notes section. The default order is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">때 &lt;code&gt;copy=False&lt;/code&gt; 및 사본이 다른 이유로 만들어진 것처럼, 결과는 동일 &lt;code&gt;copy=True&lt;/code&gt; , 일부의 예외를 제외하고 , 노트 섹션을 참조하십시오. 기본 순서는 'K'입니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2e1ae66e35c85b2fe34abaa8efd6e58beb3b3355" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 or when an inappropriate &lt;code&gt;size&lt;/code&gt; (e.g. &lt;code&gt;size=-1&lt;/code&gt;) is given.</source>
          <target state="translated">경우 &lt;code&gt;df&lt;/code&gt; &amp;lt;= 0 인 경우, 부적절한 &lt;code&gt;size&lt;/code&gt; (예 : &lt;code&gt;size=-1&lt;/code&gt; ) 주어진다.</target>
        </trans-unit>
        <trans-unit id="6647686e555ae4abe6c033723e872acfb1bd3153" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;df&lt;/code&gt; independent random variables, each with standard normal distributions (mean 0, variance 1), are squared and summed, the resulting distribution is chi-square (see Notes). This distribution is often used in hypothesis testing.</source>
          <target state="translated">경우 &lt;code&gt;df&lt;/code&gt; 표준 정규 분포와 독립된 확률 변수 각 (평균 0, 분산 1)를 제곱하여 합산되며, 결과적인 분포는 (주 참조) 치 정사각형이다. 이 분포는 종종 가설 검정에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ef591edbbf8bac21872c8b29394eee7a7391694c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;dtype=None&lt;/code&gt;, the type of each column is determined iteratively from its data. We start by checking whether a string can be converted to a boolean (that is, if the string matches &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; in lower cases); then whether it can be converted to an integer, then to a float, then to a complex and eventually to a string. This behavior may be changed by modifying the default mapper of the &lt;code&gt;StringConverter&lt;/code&gt; class.</source>
          <target state="translated">경우 &lt;code&gt;dtype=None&lt;/code&gt; , 각각의 컬럼의 유형은 데이터로부터 반복적으로 결정된다. 문자열이 부울로 변환 될 수 있는지 확인하는 것으로 시작합니다 (즉, 문자열 이 소문자에서 &lt;code&gt;true&lt;/code&gt; 또는 &lt;code&gt;false&lt;/code&gt; 와 일치하는지 여부 ). 그런 다음 정수로 변환 할 수 있는지, 부동 소수점으로 변환 할 수 있는지, 그런 다음 복합물로 변환하고 결국 문자열로 변환 할 수 있는지 여부. 이 동작은 &lt;code&gt;StringConverter&lt;/code&gt; 클래스 의 기본 매퍼를 수정하여 변경할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd7138161ba09f963f4c9ef09529d5db9dce6e9c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;equal_nan&lt;/code&gt; is True, complex values with nan components are considered equal if either the real &lt;em&gt;or&lt;/em&gt; the imaginary components are nan.</source>
          <target state="translated">때 &lt;code&gt;equal_nan&lt;/code&gt; 은 True입니다 실제 하나 경우, 유모 구성 요소와 복잡한 값은 동일한 것으로 간주됩니다 &lt;em&gt;또는&lt;/em&gt; 가상의 구성 요소가 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="ffb0cfba1c0d31cbfd6e3e6d57d32a4b67d07be0" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition.</source>
          <target state="translated">때 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; , 값 &lt;code&gt;low&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; , 결과가 공식적으로 정의되지 않은되고 결국 오류가 발생 할 수있다, 즉 불평등 조건을 만족 인수를 통과 할 때 작동하는이 기능에 의존하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3c038afaac1cec1ca1939f072442e623790bdaa5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt;, values of &lt;code&gt;low&lt;/code&gt; will be returned. If &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt;, the results are officially undefined and may eventually raise an error, i.e. do not rely on this function to behave when passed arguments satisfying that inequality condition. The &lt;code&gt;high&lt;/code&gt; limit may be included in the returned array of floats due to floating-point rounding in the equation &lt;code&gt;low + (high-low) * random_sample()&lt;/code&gt;. For example:</source>
          <target state="translated">때 &lt;code&gt;high&lt;/code&gt; == &lt;code&gt;low&lt;/code&gt; , 값 &lt;code&gt;low&lt;/code&gt; 반환됩니다. 경우 &lt;code&gt;high&lt;/code&gt; &amp;lt; &lt;code&gt;low&lt;/code&gt; , 결과가 공식적으로 정의되지 않은되고 결국 오류가 발생 할 수있다, 즉 불평등 조건을 만족 인수를 통과 할 때 작동하는이 기능에 의존하지 않습니다. &lt;code&gt;high&lt;/code&gt; 한계 방정식에 의한 라운딩 부동 소수점에 플로트의 돌려 어레이에 포함될 수있는 &lt;code&gt;low + (high-low) * random_sample()&lt;/code&gt; . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f9aa8b45107567c376fa7741eff97cb12f0255ea" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;normed&lt;/code&gt; is True, then the returned histogram is the sample density, defined such that the sum over bins of the product &lt;code&gt;bin_value * bin_area&lt;/code&gt; is 1.</source>
          <target state="translated">경우 &lt;code&gt;normed&lt;/code&gt; 참이된다 후 리턴 히스토그램은 제품의 빈들을 통해 합되도록 정의 샘플 밀도이다 &lt;code&gt;bin_value * bin_area&lt;/code&gt; 1이다.</target>
        </trans-unit>
        <trans-unit id="d3c1a253c347320a48abee4b8144700cbe11dedb" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;op[i]&lt;/code&gt; is NULL, the requested data type &lt;code&gt;op_dtypes[i]&lt;/code&gt; may be NULL as well, in which case it is automatically generated from the dtypes of the arrays which are flagged as readable. The rules for generating the dtype are the same is for UFuncs. Of special note is handling of byte order in the selected dtype. If there is exactly one input, the input&amp;rsquo;s dtype is used as is. Otherwise, if more than one input dtypes are combined together, the output will be in native byte order.</source>
          <target state="translated">경우 &lt;code&gt;op[i]&lt;/code&gt; NULL 인, 요청 된 데이터 타입 &lt;code&gt;op_dtypes[i]&lt;/code&gt; 그것이 자동적으로 판독하는 플래그 배열의 dtypes로부터 발생되는 경우뿐만 아니라 NULL 일 수있다. dtype 생성 규칙은 UFunc의 규칙과 동일합니다. 선택된 dtype에서 바이트 순서를 처리하는 것이 특히 중요합니다. 정확히 하나의 입력이 있으면 입력의 dtype이 그대로 사용됩니다. 그렇지 않으면, 둘 이상의 입력 dtype이 함께 결합되면 출력은 기본 바이트 순서가됩니다.</target>
        </trans-unit>
        <trans-unit id="8b2b29bdbe08a7c3e8ddf1683de5150728b2dbef" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;A&amp;rsquo;, it will preserve the array&amp;rsquo;s &amp;lsquo;C&amp;rsquo; or &amp;lsquo;F&amp;rsquo; ordering:</source>
          <target state="translated">때 &lt;code&gt;order&lt;/code&gt; 'A', 그것은 배열의 'C'또는 'F'순서를 유지한다 :</target>
        </trans-unit>
        <trans-unit id="6b8f346f1161f4e387f8b7fce9c3c4eab735e268" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;order&lt;/code&gt; is &amp;lsquo;K&amp;rsquo;, it will preserve orderings that are neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo;, but won&amp;rsquo;t reverse axes:</source>
          <target state="translated">때 &lt;code&gt;order&lt;/code&gt; 'K', 그것은 어느 쪽도 'C'나 'F'없는 순서 부를 유지하지만 것입니다하지 않습니다 반대 축 :</target>
        </trans-unit>
        <trans-unit id="08a648e9a0d7c320ff7a951bdd5b53abf89293b1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;p&lt;/code&gt; cannot be converted to a rank-1 array.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 랭크 1 배열로 변환 될 수 없다.</target>
        </trans-unit>
        <trans-unit id="e45ca1a69513367d482121e776e438a0bc2c1c76" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;path&lt;/code&gt; is an URL, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt;&lt;code&gt;exists&lt;/code&gt;&lt;/a&gt; will return True if it&amp;rsquo;s either stored locally in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory, or is a valid remote URL. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; does not discriminate between the two, the file is accessible if it exists in either location.</source>
          <target state="translated">때 &lt;code&gt;path&lt;/code&gt; URL이, &lt;a href=&quot;#numpy.DataSource.exists&quot;&gt; &lt;code&gt;exists&lt;/code&gt; &lt;/a&gt; 가 중 하나에 로컬로 저장되어있는 경우 True를 반환합니다 &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리, 또는 유효한 원격 URL입니다. &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 는이 둘을 구별하지 않으며, 파일이 어느 위치에 있는지 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="25d6d2d2a499c808880c721a0e1b19db64d43932" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;seed&lt;/code&gt; is omitted or &lt;code&gt;None&lt;/code&gt;, a new &lt;code&gt;BitGenerator&lt;/code&gt; and &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; will be instantiated each time. This function does not manage a default global instance.</source>
          <target state="translated">시 &lt;code&gt;seed&lt;/code&gt; 생략되거나되는 &lt;code&gt;None&lt;/code&gt; , 새로운 &lt;code&gt;BitGenerator&lt;/code&gt; 및 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 마다 인스턴스화됩니다. 이 기능은 기본 전역 인스턴스를 관리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="11aa8349ecf313cc611177c175cba7ab95aa1209" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;start &amp;lt;= axis&lt;/code&gt;, the axis is rolled back until it lies in this position. When &lt;code&gt;start &amp;gt; axis&lt;/code&gt;, the axis is rolled until it lies before this position. The default, 0, results in a &amp;ldquo;complete&amp;rdquo; roll. The following table describes how negative values of &lt;code&gt;start&lt;/code&gt; are interpreted:</source>
          <target state="translated">때 &lt;code&gt;start &amp;lt;= axis&lt;/code&gt; 이이 위치에 놓여까지 축 롤백. 때 &lt;code&gt;start &amp;gt; axis&lt;/code&gt; 이이 위치하기 전에해질 때까지, 축이 롤백됩니다. 기본값 인 0은 &quot;완전한&quot;롤이됩니다. 다음 표는 &lt;code&gt;start&lt;/code&gt; 의 음수 값 이 해석되는 방식을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="548ec80d9148e8694deef2af35ec844cd9f8fe80" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;writemasked&lt;/code&gt; flag is used, and this operand is buffered, this changes how data is copied from the buffer into the array. A masked copying routine is used, which only copies the elements in the buffer for which &lt;code&gt;writemasked&lt;/code&gt; returns true from the corresponding element in the ARRAYMASK operand.</source>
          <target state="translated">경우 &lt;code&gt;writemasked&lt;/code&gt; 플래그가 사용되며,이 피연산자는, 데이터가 어레이로 상기 버퍼로 복사하는 방법이 변화를 완충한다. ARRAYMASK 피연산자의 해당 요소에서 &lt;code&gt;writemasked&lt;/code&gt; 가 true를 리턴 하는 버퍼의 요소 만 복사하는 마스크 된 복사 루틴이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="e06542a52ac6a1f85d560afb9efd573db44bd48f" translate="yes" xml:space="preserve">
          <source>When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, the result order is &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;prototype&lt;/em&gt; is a fortran array, &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt; otherwise. When &lt;em&gt;order&lt;/em&gt; is &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, the result order matches that of &lt;em&gt;prototype&lt;/em&gt;, even when the axes of &lt;em&gt;prototype&lt;/em&gt; aren&amp;rsquo;t in C or Fortran order.</source>
          <target state="translated">되면 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; 이&lt;/a&gt; 결과 순서는 &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; 경우 &lt;em&gt;시제품&lt;/em&gt; 포트란 배열이다 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; 그렇지. 되면 &lt;em&gt;순서&lt;/em&gt; 이다 &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 결과 순서가 일치의 &lt;em&gt;원형&lt;/em&gt; 의 축 때에도 &lt;em&gt;프로토 타입&lt;/em&gt; C 또는 포트란 위해서는 아니다.</target>
        </trans-unit>
        <trans-unit id="e7033d51e081041b1a2d922760ea9482eb361bec" translate="yes" xml:space="preserve">
          <source>When F2PY finds a line with F2PY directive, the directive is first replaced by 5 spaces and then the line is reread.</source>
          <target state="translated">F2PY가 F2PY 지시문이있는 행을 찾으면 지시문은 먼저 5 개의 공백으로 대체 된 다음 해당 행을 다시 읽습니다.</target>
        </trans-unit>
        <trans-unit id="ad9397f3e6e3e4c72dcb47695405ed9d0b6444eb" translate="yes" xml:space="preserve">
          <source>When NumPy is built, information about system configuration is recorded, and is made available for extension modules using NumPy&amp;rsquo;s C API. These are mostly defined in &lt;code&gt;numpyconfig.h&lt;/code&gt; (included in &lt;code&gt;ndarrayobject.h&lt;/code&gt;). The public symbols are prefixed by &lt;code&gt;NPY_*&lt;/code&gt;. NumPy also offers some functions for querying information about the platform in use.</source>
          <target state="translated">NumPy가 빌드되면 시스템 구성에 대한 정보가 기록되고 NumPy의 C API를 사용하여 확장 모듈에 사용 가능합니다. 이들은 대부분에 정의되어 &lt;code&gt;numpyconfig.h&lt;/code&gt; (에 포함 &lt;code&gt;ndarrayobject.h&lt;/code&gt; ). 퍼블릭 심볼 앞에는 &lt;code&gt;NPY_*&lt;/code&gt; 가 붙습니다 . NumPy는 사용중인 플랫폼에 대한 정보를 쿼리하기위한 기능도 제공합니다.</target>
        </trans-unit>
        <trans-unit id="f9eebd0d248f1a6803fb5b3cabe894035e7a712b" translate="yes" xml:space="preserve">
          <source>When True, trailing zeros are removed from the inputs. When False, the inputs are passed through intact.</source>
          <target state="translated">True이면 입력에서 후행 0이 제거됩니다. False이면 입력이 그대로 통과됩니다.</target>
        </trans-unit>
        <trans-unit id="97a14729b31bf94d828802c225db2f870571e19a" translate="yes" xml:space="preserve">
          <source>When a &lt;em&gt;casting&lt;/em&gt; error occurs during assignment (for example updating a numerical array using a sequence of strings), the array being assigned to may end up in an unpredictable partially updated state. However, if any other error (such as an out of bounds index) occurs, the array will remain unchanged.</source>
          <target state="translated">할당 중 &lt;em&gt;캐스팅&lt;/em&gt; 오류가 발생 하면 (예 : 문자열 시퀀스를 사용하여 숫자 형 배열 업데이트) 할당 된 배열이 예기치 않은 부분적으로 업데이트 된 상태가 될 수 있습니다. 그러나 범위를 벗어난 인덱스와 같은 다른 오류가 발생하면 배열은 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e61114b95ee070856965d70e916fd6711963caa8" translate="yes" xml:space="preserve">
          <source>When a NumPy array, that is Fortran contiguous and has a dtype corresponding to presumed Fortran type, is used as an input array argument, then its C pointer is directly passed to Fortran.</source>
          <target state="translated">Fortran 연속적이고 추정 된 Fortran 유형에 해당하는 dtype을 갖는 NumPy 배열이 입력 배열 인수로 사용되면 해당 C 포인터가 Fortran에 직접 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="0d0060f5095733a108d2028d216426111947fd92" translate="yes" xml:space="preserve">
          <source>When a broadcasting error occurs, the iterator raises an exception which includes the input shapes to help diagnose the problem.</source>
          <target state="translated">브로드 캐스팅 오류가 발생하면 반복자가 문제를 진단하는 데 도움이되는 입력 모양이 포함 된 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="811ec8a0586d1ac674df53f06017026b62d3d8b5" translate="yes" xml:space="preserve">
          <source>When a member of the Code of Conduct committee becomes aware of a clear and severe breach, they will do the following:</source>
          <target state="translated">행동 강령위원회의 구성원이 명확하고 심각한 위반 사실을 알게되면 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="bb6f21e3a640b767ac7aa4f3739c198a4f93da24" translate="yes" xml:space="preserve">
          <source>When a memmap causes a file to be created or extended beyond its current size in the filesystem, the contents of the new part are unspecified. On systems with POSIX filesystem semantics, the extended part will be filled with zero bytes.</source>
          <target state="translated">memmap으로 인해 파일이 파일 시스템에서 현재 크기 이상으로 작성되거나 확장되면 새 부품의 내용이 지정되지 않습니다. POSIX 파일 시스템 시맨틱이있는 시스템에서 확장 부분은 0 바이트로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="7aea5877fc6d970c99b779ec7ae2a444e7ff36a4" translate="yes" xml:space="preserve">
          <source>When a parameter can only assume one of a fixed set of values, those values can be listed in braces, with the default appearing first:</source>
          <target state="translated">매개 변수가 고정 된 값 세트 중 하나만 가정 할 수있는 경우 해당 값은 중괄호 안에 나열 될 수 있으며 기본값이 먼저 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="9b87e186d194de6f9d4cd9e098a815eab1dbc5b7" translate="yes" xml:space="preserve">
          <source>When a recording filter is added, matching warnings are stored in the &lt;code&gt;log&lt;/code&gt; attribute as well as in the list returned by &lt;code&gt;record&lt;/code&gt;.</source>
          <target state="translated">기록 필터를 추가하면 일치하는 경고가 &lt;code&gt;log&lt;/code&gt; 속성과 &lt;code&gt;record&lt;/code&gt; 가 반환 한 목록에 저장됩니다 .</target>
        </trans-unit>
        <trans-unit id="d3862b7e9fa0724ebb3b8d0fa3f7b6e962081ab4" translate="yes" xml:space="preserve">
          <source>When a report is sent to the committee they will immediately reply to the reporter to confirm receipt. This reply must be sent within 72 hours, and the group should strive to respond much quicker than that.</source>
          <target state="translated">위원회에 신고가 접수되면 즉시 신고자에게 회신하여 접수를 확인합니다. 이 회신은 72 시간 이내에 보내야하며, 그룹은 그보다 훨씬 더 빨리 응답하도록 노력해야합니다.</target>
        </trans-unit>
        <trans-unit id="ba1de10f5ac1f9d67feabe34568ca76340334549" translate="yes" xml:space="preserve">
          <source>When a ufunc is called, many things must be done. The information collected from these setup operations is stored in a loop-object. This loop object is a C-structure (that could become a Python object but is not initialized as such because it is only used internally). This loop object has the layout needed to be used with PyArray_Broadcast so that the broadcasting can be handled in the same way as it is handled in other sections of code.</source>
          <target state="translated">ufunc가 호출되면 많은 작업을 수행해야합니다. 이러한 설정 작업에서 수집 된 정보는 루프 개체에 저장됩니다. 이 루프 객체는 C 구조입니다 (파이썬 객체가 될 수는 있지만 내부적으로 만 사용되므로 초기화되지는 않습니다). 이 루프 객체는 PyArray_Broadcast와 함께 사용하여 다른 코드 섹션에서 처리되는 것과 같은 방식으로 브로드 캐스트를 처리 할 수있는 레이아웃을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="bed1032321553c178be0f4aa76322e048587c74c" translate="yes" xml:space="preserve">
          <source>When a view is desired in as many cases as possible, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; may be preferable.</source>
          <target state="translated">가능한 많은 경우에 관점이 요구되는 경우, &lt;code&gt;arr.reshape(-1)&lt;/code&gt; 이 바람직 할 수있다.</target>
        </trans-unit>
        <trans-unit id="3d973a2064387ee8231885f5fb66b3c4832468fa" translate="yes" xml:space="preserve">
          <source>When accessing a single entry of a masked array with no named fields, the output is either a scalar (if the corresponding entry of the mask is &lt;code&gt;False&lt;/code&gt;) or the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; (if the corresponding entry of the mask is &lt;code&gt;True&lt;/code&gt;):</source>
          <target state="translated">명명 된 필드가없는 마스킹 된 배열의 단일 항목에 액세스 할 때 출력은 스칼라 (마스크의 해당 항목이 &lt;code&gt;False&lt;/code&gt; 인 경우 )이거나 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 특수 값 ( 마스크 의 해당 항목이 &lt;code&gt;True&lt;/code&gt; 인 경우 )입니다.</target>
        </trans-unit>
        <trans-unit id="06a15d5053f26aa57bf4b46b8d10d7192f9bc439" translate="yes" xml:space="preserve">
          <source>When accessing a slice, the output is a masked array whose &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; attribute is a view of the original data, and whose mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; (if there was no invalid entries in the original array) or a view of the corresponding slice of the original mask. The view is required to ensure propagation of any modification of the mask to the original.</source>
          <target state="translated">슬라이스에 액세스 할 때 출력은 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 속성이 원래 데이터의보기이고 마스크가 마스크가 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; (원래 배열에 유효하지 않은 항목이없는 경우) 마스크의 해당 배열의 마스크 된 배열입니다. 마스크. 마스크 수정 사항을 원본으로 전파하려면 뷰가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4d92b7829e88a948fb9eb65ffcf73c11643904a9" translate="yes" xml:space="preserve">
          <source>When added within a context, filters are only added inside the context and will be forgotten when the context is exited.</source>
          <target state="translated">컨텍스트 내에서 추가되면 필터는 컨텍스트 내에서만 추가되며 컨텍스트가 종료 될 때 잊혀집니다.</target>
        </trans-unit>
        <trans-unit id="9541e02340938d50efa6e54249172d0ce37841bb" translate="yes" xml:space="preserve">
          <source>When adding the &amp;lsquo;out&amp;rsquo; parameter, we have to explicitly provide those flags, because if someone passes in an array as &amp;lsquo;out&amp;rsquo;, the iterator will default to &amp;lsquo;readonly&amp;rsquo;, and our inner loop would fail. The reason &amp;lsquo;readonly&amp;rsquo; is the default for input arrays is to prevent confusion about unintentionally triggering a reduction operation. If the default were &amp;lsquo;readwrite&amp;rsquo;, any broadcasting operation would also trigger a reduction, a topic which is covered later in this document.</source>
          <target state="translated">'out'매개 변수를 추가 할 때 누군가가 'out'으로 배열을 전달하면 반복자는 기본적으로 'readonly'로 설정되고 내부 루프가 실패하므로 플래그를 명시 적으로 제공해야합니다. '읽기 전용'이 입력 배열의 기본값 인 이유는 의도하지 않게 축소 작업을 트리거하는 것에 대한 혼동을 방지하기위한 것입니다. 기본값이 '읽기'인 경우 모든 브로드 캐스트 작업은이 문서의 뒷부분에서 다루는 주제 인 축소를 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="4db060a24fc0c2ce0739cc8fe613a0f3bd607af5" translate="yes" xml:space="preserve">
          <source>When advanced indices are next to each other transposing may be necessary. All necessary transposing is handled by &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; and has to be handled by the caller unless &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; is asked to allocate the result.</source>
          <target state="translated">고급 지수가 나란히 배치되면 조옮김이 필요할 수 있습니다. 필요한 모든 이조에 의해 처리됩니다 &lt;code&gt;PyArray_MapIterSwapAxes&lt;/code&gt; 및 않는 호출자에 의해 처리되어야한다 &lt;code&gt;PyArray_MapIterNew&lt;/code&gt; 이 결과를 할당하도록 요청한다.</target>
        </trans-unit>
        <trans-unit id="d51d0efd85b1005294bf85e6a8973d000ac30965" translate="yes" xml:space="preserve">
          <source>When all weights along axis are zero. See &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt;&lt;code&gt;numpy.ma.average&lt;/code&gt;&lt;/a&gt; for a version robust to this type of error.</source>
          <target state="translated">축을 따라 모든 가중치가 0 일 때. 이 유형의 오류에 강력한 버전 은 &lt;a href=&quot;numpy.ma.average#numpy.ma.average&quot;&gt; &lt;code&gt;numpy.ma.average&lt;/code&gt; &lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b89455b8b1550525cbe82d65bea2d7c4ae5a2baa" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">배열 인 경우 각 행은 &lt;code&gt;histogramdd(np.array([p1, p2, p3]))&lt;/code&gt; 와 같은 D 차원 공간의 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="c8f93d8039436724f69d84838e7be89d226d23fc" translate="yes" xml:space="preserve">
          <source>When an array, each row is a coordinate in a D-dimensional space - such as &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt;.</source>
          <target state="translated">배열 인 경우 각 행은 &lt;code&gt;histogramgramdd(np.array([p1, p2, p3]))&lt;/code&gt; 와 같은 D 차원 공간의 좌표입니다 .</target>
        </trans-unit>
        <trans-unit id="74f6a2bdb1716e78ebe330a0020c810a9f33a7a2" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">array_like 인 경우 각 요소는 &lt;code&gt;histogramdd((X, Y, Z))&lt;/code&gt; 와 같은 단일 좌표에 대한 값 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="82d8732b0393645ea59279b9ddb8a309ed548c77" translate="yes" xml:space="preserve">
          <source>When an array_like, each element is the list of values for single coordinate - such as &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt;.</source>
          <target state="translated">array_like 인 경우 각 요소는 단일 좌표의 값 목록입니다 &lt;code&gt;histogramgramdd((X, Y, Z))&lt;/code&gt; 예 : histogramgramdd ((X, Y, Z))) .</target>
        </trans-unit>
        <trans-unit id="c37c33974afb82f0204264e74c8f9fe0fca4a425" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array (move the axis to the first dimension to keep the order of the other axes) and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">축이 지정되면 축으로 인덱싱 된 하위 배열이 정렬됩니다. 이것은 지정된 축을 배열의 첫 번째 차원으로 만든 다음 (다른 축의 순서를 유지하기 위해 축을 첫 번째 차원으로 이동) C 순서로 하위 배열을 평면화하여 수행됩니다. 평면화 된 하위 배열은 레이블이 지정된 각 요소가있는 구조화 된 유형으로 표시되며 다른 1D 배열과 동일한 방식으로 처리 할 수있는 구조화 된 유형의 1D 배열로 끝납니다. 결과적으로 평면화 된 하위 배열은 첫 번째 요소부터 사전 순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="355be91097240a30b4454a31696bf68a0b258227" translate="yes" xml:space="preserve">
          <source>When an axis is specified the subarrays indexed by the axis are sorted. This is done by making the specified axis the first dimension of the array and then flattening the subarrays in C order. The flattened subarrays are then viewed as a structured type with each element given a label, with the effect that we end up with a 1-D array of structured types that can be treated in the same way as any other 1-D array. The result is that the flattened subarrays are sorted in lexicographic order starting with the first element.</source>
          <target state="translated">축이 지정되면 축으로 인덱스 된 하위 배열이 정렬됩니다. 이것은 지정된 축을 배열의 첫 번째 차원으로 만든 다음 하위 순서를 C 순서로 병합하여 수행됩니다. 평면화 된 하위 배열은 레이블이 지정된 각 요소를 가진 구조화 된 유형으로 간주되며 다른 1 차원 배열과 동일한 방식으로 처리 할 수있는 구조화 된 유형의 1 차원 배열로 끝납니다. 결과적으로 평탄화 된 하위 배열이 첫 번째 요소로 시작하여 사전 순으로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="6b69f1e4103645c38ed661fd82fe69ef3f4b8546" translate="yes" xml:space="preserve">
          <source>When an ellipsis (&lt;code&gt;...&lt;/code&gt;) is present but has no size (i.e. replaces zero &lt;code&gt;:&lt;/code&gt;) the result will still always be an array. A view if no advanced index is present, otherwise a copy.</source>
          <target state="translated">생략 부호 ( &lt;code&gt;...&lt;/code&gt; )가 있지만 크기가없는 경우 (예 &lt;code&gt;:&lt;/code&gt; 0을 대체하는 경우 ) 결과는 항상 배열입니다. 고급 색인이없는 경우보기, 그렇지 않으면 사본.</target>
        </trans-unit>
        <trans-unit id="a6d6a3b6d360dde7b2d4e12e9485e974a0d7c19d" translate="yes" xml:space="preserve">
          <source>When an extension module is written, compiled, and installed to somewhere in the Python path (sys.path), the code can then be imported into Python as if it were a standard python file. It will contain objects and methods that have been defined and compiled in C code. The basic steps for doing this in Python are well-documented and you can find more information in the documentation for Python itself available online at &lt;a href=&quot;https://www.python.org&quot;&gt;www.python.org&lt;/a&gt; .</source>
          <target state="translated">확장 모듈이 작성, 컴파일 및 Python 경로 (sys.path)의 어딘가에 설치되면 코드를 표준 Python 파일 인 것처럼 Python으로 가져올 수 있습니다. 여기에는 C 코드로 정의되고 컴파일 된 개체와 메서드가 포함됩니다. Python에서이 작업을 수행하는 기본 단계는 잘 문서화되어 있으며 &lt;a href=&quot;https://www.python.org&quot;&gt;www.python.org&lt;/a&gt; 에서 온라인으로 제공되는 Python 문서에서 자세한 정보를 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d4c4fe16d2ce5d90f03758ae48eb086b0f73e4f" translate="yes" xml:space="preserve">
          <source>When an input date falls on the weekend or a holiday, &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt;&lt;code&gt;busday_offset&lt;/code&gt;&lt;/a&gt; first applies a rule to roll the date to a valid business day, then applies the offset. The default rule is &amp;lsquo;raise&amp;rsquo;, which simply raises an exception. The rules most typically used are &amp;lsquo;forward&amp;rsquo; and &amp;lsquo;backward&amp;rsquo;.</source>
          <target state="translated">입력 날짜가 주말 또는 공휴일 인 경우 &lt;a href=&quot;generated/numpy.busday_offset#numpy.busday_offset&quot;&gt; &lt;code&gt;busday_offset&lt;/code&gt; 은&lt;/a&gt; 먼저 규칙을 적용하여 날짜를 유효한 영업일로 롤링 한 다음 오프셋을 적용합니다. 기본 규칙은 '상승'이며, 이는 단순히 예외를 발생시킵니다. 가장 일반적으로 사용되는 규칙은 '전달'및 '뒤로'입니다.</target>
        </trans-unit>
        <trans-unit id="64e5ff0649d57b71884c5f5309f3367e78576ca8" translate="yes" xml:space="preserve">
          <source>When applied to masked arrays, this function drops the mask information if the &lt;code&gt;to_begin&lt;/code&gt; and/or &lt;code&gt;to_end&lt;/code&gt; parameters are used.</source>
          <target state="translated">마스크 배열에 적용될 때,이 함수는 &lt;code&gt;to_begin&lt;/code&gt; 및 / 또는 &lt;code&gt;to_end&lt;/code&gt; 매개 변수가 사용되는 경우 마스크 정보를 삭제합니다 .</target>
        </trans-unit>
        <trans-unit id="15d1d9494e1bc6589dcc00277cd9b509332d208c" translate="yes" xml:space="preserve">
          <source>When applying the rule would make the code less readable, even for someone who is used to reading code that follows the rules.</source>
          <target state="translated">규칙을 적용하면 규칙을 따르는 코드를 읽는 데 익숙한 사람에게도 코드의 가독성이 떨어집니다.</target>
        </trans-unit>
        <trans-unit id="e3d9940340bbe50ab427886c71fa9ffd19149804" translate="yes" xml:space="preserve">
          <source>When assigning to fields which are subarrays, the assigned value will first be broadcast to the shape of the subarray.</source>
          <target state="translated">하위 배열 인 필드에 할당 할 때 할당 된 값이 먼저 하위 배열의 모양으로 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="f9f55c2f275cd5eebce400c5d632f8721b4b827a" translate="yes" xml:space="preserve">
          <source>When axis is not None, this function does the same thing as &amp;ldquo;fancy&amp;rdquo; indexing (indexing arrays using arrays); however, it can be easier to use if you need elements along a given axis. A call such as &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; is equivalent to &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt;.</source>
          <target state="translated">axis가 None이 아닌 경우,이 함수는 &quot;fancy&quot;인덱싱 (배열을 사용한 어레이 인덱싱)과 동일한 기능을 수행합니다. 그러나 주어진 축을 따라 요소가 필요한 경우 사용하기가 더 쉬울 수 있습니다. &lt;code&gt;np.take(arr, indices, axis=3)&lt;/code&gt; 과 같은 호출 은 &lt;code&gt;arr[:,:,:,indices,...]&lt;/code&gt; :::: indices, ...]와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="98c8d4285d8be1f6c2247d830229aff2863b6c70" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, controls the size of the temporary buffers. Set to 0 for the default value.</source>
          <target state="translated">버퍼링이 활성화되면 임시 버퍼의 크기를 제어합니다. 기본값은 0으로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="16e4f331a390aab5d5358796f242e2ca6c555d93" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this allows the size of the inner loop to grow when buffering isn&amp;rsquo;t necessary. This option is best used if you&amp;rsquo;re doing a straight pass through all the data, rather than anything with small cache-friendly arrays of temporary values for each inner loop.</source>
          <target state="translated">버퍼링이 활성화되면 버퍼링이 필요하지 않을 때 내부 루프의 크기가 커질 수 있습니다. 이 옵션은 각 내부 루프에 대해 캐시 친화적 인 임시 값의 작은 배열이 아닌 모든 데이터를 직선 통과하는 경우에 가장 적합합니다.</target>
        </trans-unit>
        <trans-unit id="b51f6738b373830fc8b3cc055c675ac17c018d38" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this also switches to a special buffering mode which reduces the loop length as necessary to not trample on values being reduced.</source>
          <target state="translated">버퍼링이 활성화되면 감소되는 값을 짓밟 지 않도록 루프 길이를 줄이는 특수 버퍼링 모드로 전환됩니다.</target>
        </trans-unit>
        <trans-unit id="41819020a24f8ece45999c2f5c36e5cb1be0993f" translate="yes" xml:space="preserve">
          <source>When buffering is enabled, this delays allocation of the buffers until &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; or another reset function is called. This flag exists to avoid wasteful copying of buffer data when making multiple copies of a buffered iterator for multi-threaded iteration.</source>
          <target state="translated">버퍼링이 활성화되면 &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt; 또는 다른 재설정 기능이 호출 될 때까지 버퍼 할당이 지연 됩니다. 이 플래그는 다중 스레드 반복을 위해 버퍼 된 반복기의 여러 사본을 작성할 때 버퍼 데이터의 낭비적인 복사를 피하기 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="4659cc673583a700172b8a1a2788271c0236c929" translate="yes" xml:space="preserve">
          <source>When building Python packages containing Fortran sources, then one can choose different Fortran compilers by using &lt;code&gt;build_ext&lt;/code&gt; command option &lt;code&gt;--fcompiler=&amp;lt;Vendor&amp;gt;&lt;/code&gt;. Here &lt;code&gt;&amp;lt;Vendor&amp;gt;&lt;/code&gt; can be one of the following names:</source>
          <target state="translated">Fortran 소스를 포함하는 Python 패키지를 빌드 할 때 &lt;code&gt;build_ext&lt;/code&gt; 명령 옵션 &lt;code&gt;--fcompiler=&amp;lt;Vendor&amp;gt;&lt;/code&gt; 를 사용하여 다른 Fortran 컴파일러를 선택할 수 있습니다 . 여기서 &lt;code&gt;&amp;lt;Vendor&amp;gt;&lt;/code&gt; 는 다음 이름 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f21f4d61950661d3a1581fb7fc069996b1dddfdd" translate="yes" xml:space="preserve">
          <source>When building an extension module, a combination of the following macros may be required for non-gcc Fortran compilers:</source>
          <target state="translated">확장 모듈을 빌드 할 때 gcc가 아닌 Fortran 컴파일러에 대해 다음 매크로 조합이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="230c13e7258bcd1f717539097a4dd43ccf64c97d" translate="yes" xml:space="preserve">
          <source>When calculating the power of an experiment (power = probability of rejecting the null hypothesis when a specific alternative is true) the non-central F statistic becomes important. When the null hypothesis is true, the F statistic follows a central F distribution. When the null hypothesis is not true, then it follows a non-central F statistic.</source>
          <target state="translated">실험의 검정력을 계산할 때 (검정력 = 특정 대안이 참일 때 귀무 가설을 기각 할 확률) 비 중앙 F 통계량이 중요해집니다. 귀무 가설이 참이면 F 통계량은 중심 F 분포를 따릅니다. 귀무 가설이 참이 아닌 경우 중앙이 아닌 F 통계량을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="5a88371e6c71e0713242640efaf4aa0aa5e85f64" translate="yes" xml:space="preserve">
          <source>When called from the explicit constructor, &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;</source>
          <target state="translated">명시 적 생성자에서 호출 될 때 &lt;code&gt;obj&lt;/code&gt; 는 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4c4c9c09668cb4fc50a86156b0582de19cfc0aea" translate="yes" xml:space="preserve">
          <source>When called from view casting, &lt;code&gt;obj&lt;/code&gt; can be an instance of any subclass of ndarray, including our own.</source>
          <target state="translated">뷰 캐스팅에서 호출되면 &lt;code&gt;obj&lt;/code&gt; 는 우리 자신을 포함하여 ndarray의 모든 하위 클래스의 인스턴스가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bdfd9e1642e1e1ff8048cf3528d0f05bb78c463a" translate="yes" xml:space="preserve">
          <source>When called in new-from-template, &lt;code&gt;obj&lt;/code&gt; is another instance of our own subclass, that we might use to update the new &lt;code&gt;self&lt;/code&gt; instance.</source>
          <target state="translated">new-from-template에서 호출 될 때, &lt;code&gt;obj&lt;/code&gt; 는 새로운 &lt;code&gt;self&lt;/code&gt; 인스턴스 를 업데이트하는 데 사용할 수있는 자체 하위 클래스의 또 다른 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="67a93e8e91305afaf6fc0532016e5191c667e052" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt;.</source>
          <target state="translated">제로 d 배열 또는 스칼라에서 호출되면 &lt;code&gt;nonzero(a)&lt;/code&gt; 는 &lt;code&gt;nonzero(atleast1d(a))&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="983eb3e7c851b006b5ca4f0291c430972bc7e1fb" translate="yes" xml:space="preserve">
          <source>When called on a zero-d array or scalar, &lt;code&gt;nonzero(a)&lt;/code&gt; is treated as &lt;code&gt;nonzero(atleast_1d(a))&lt;/code&gt;.</source>
          <target state="translated">0 차원 배열 또는 스칼라에서 호출 될 때 &lt;code&gt;nonzero(a)&lt;/code&gt; 는 &lt;code&gt;nonzero(atleast_1d(a))&lt;/code&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="05271cb09f7d75c6bfb61cf24594f89c89131399" translate="yes" xml:space="preserve">
          <source>When called with only scalars, &lt;code&gt;np.block&lt;/code&gt; is equivalent to an ndarray call. So &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; is equivalent to &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt;.</source>
          <target state="translated">스칼라로 호출 할 때, &lt;code&gt;np.block&lt;/code&gt; 는 ndarray 호출하는 것과 동일합니다. 따라서 &lt;code&gt;np.block([[1, 2], [3, 4]])&lt;/code&gt; 은 &lt;code&gt;np.array([[1, 2], [3, 4]])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="067efac39e6f277a074b649718c28575841dd307" translate="yes" xml:space="preserve">
          <source>When can they be useful?</source>
          <target state="translated">언제 유용 할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="eb3fc5492e5904c93f3605a33709fbb0c2bb0c5b" translate="yes" xml:space="preserve">
          <source>When casting from complex to float or int. To avoid this, one should use &lt;code&gt;a.real.astype(t)&lt;/code&gt;.</source>
          <target state="translated">complex에서 float 또는 int로 캐스팅 할 때. 이를 피하려면 &lt;code&gt;a.real.astype(t)&lt;/code&gt; 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d77d44055e40bb5dab3ddffb7c979aaad7a40365" translate="yes" xml:space="preserve">
          <source>When coding custom algorithms, and sometimes when wrapping existing C libraries, some familiarity with C is required. In particular, when using C memory management (&lt;code&gt;malloc&lt;/code&gt; and friends), it&amp;rsquo;s easy to introduce memory leaks. However, just compiling a Python module renamed to &lt;code&gt;.pyx&lt;/code&gt; can already speed it up, and adding a few type declarations can give dramatic speedups in some code.</source>
          <target state="translated">사용자 지정 알고리즘을 코딩 할 때, 때로는 기존 C 라이브러리를 래핑 할 때 C에 어느 정도 익숙해야합니다. 특히 C 메모리 관리 ( &lt;code&gt;malloc&lt;/code&gt; 및 friends)를 사용하면 메모리 누수가 발생하기 쉽습니다. 그러나 &lt;code&gt;.pyx&lt;/code&gt; 로 이름이 변경된 Python 모듈을 컴파일하는 것만으로도 이미 속도 를 높일 수 있으며 몇 가지 유형 선언을 추가하면 일부 코드에서 극적인 속도를 높일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b0aeecc6c945df228976af6d76ace4f58298a37" translate="yes" xml:space="preserve">
          <source>When considering potential Members, the Council will look at candidates with a comprehensive view of their contributions. This will include but is not limited to code, code review, infrastructure work, mailing list and chat participation, community help/building, education and outreach, design work, etc. We are deliberately not setting arbitrary quantitative metrics (like &amp;ldquo;100 commits in this repo&amp;rdquo;) to avoid encouraging behavior that plays to the metrics rather than the project&amp;rsquo;s overall well-being. We want to encourage a diverse array of backgrounds, viewpoints and talents in our team, which is why we explicitly do not define code as the sole metric on which council membership will be evaluated.</source>
          <target state="translated">잠재적 인 회원을 고려할 때,위원회는 그들의 기여에 대한 포괄적 인 관점으로 후보자를 살펴볼 것입니다. 여기에는 코드, 코드 검토, 인프라 작업, 메일 링리스트 및 채팅 참여, 커뮤니티 도움말 / 구축, 교육 및 지원, 디자인 작업 등이 포함되지만 이에 국한되지 않습니다. 이 repo ')는 프로젝트의 전반적인 웰빙보다는 메트릭에 영향을 미치는 고무적인 행동을 방지합니다. 우리는 팀의 다양한 배경, 관점 및 재능을 장려하기를 원합니다. 그래서 우리는 코드를위원회 구성원이 평가되는 유일한 지표로 명시 적으로 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3afb0a37a10edd1baec0a1dc8d2095269323f16d" translate="yes" xml:space="preserve">
          <source>When creating a 0-d array from an array scalar use &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; instead of the standard copy from an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">배열 스칼라에서 0-d 배열을 만들 때는 배열 스칼라 의 표준 복사본 대신 &lt;code&gt;f-&amp;gt;setitem&lt;/code&gt; 을 사용하십시오. 데이터 유형과 함께 배열 스칼라를 정의하지 않은 경우 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8887c1561ce70af56f037b9ba953356547c232a4" translate="yes" xml:space="preserve">
          <source>When creating a new masked array with a simple, non-structured datatype, the mask is initially set to the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, that corresponds roughly to the boolean &lt;code&gt;False&lt;/code&gt;. Trying to set an element of &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; will fail with a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; exception, as a boolean does not support item assignment.</source>
          <target state="translated">구조화되지 않은 단순한 데이터 유형으로 새 마스크 배열을 작성할 때 마스크는 초기에 특수 값 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; 로&lt;/a&gt; 설정되며, 이는 부울 &lt;code&gt;False&lt;/code&gt; 와 대략 일치 합니다. 부울은 항목 할당을 지원하지 않으므로 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 요소를 설정하려고 하면 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 예외 가 발생하여 실패 합니다.</target>
        </trans-unit>
        <trans-unit id="4e6d2af630e30f862a489ba6df45674126eb3cd4" translate="yes" xml:space="preserve">
          <source>When creating an array of datetimes from a string, it is still possible to automatically select the unit from the inputs, by using the datetime type with generic units.</source>
          <target state="translated">문자열에서 날짜 시간 배열을 만들 때 일반 단위와 함께 날짜 시간 유형을 사용하여 입력에서 단위를 자동으로 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac49ba1355f1db42e6af84f03eb57484c54f1f5d" translate="yes" xml:space="preserve">
          <source>When cross-compiling with numpy distutils, it might be necessary to use modified npy-pkg-config files. Using the default/generated files will link with the host libraries (i.e. libnpymath.a). For cross-compilation you of-course need to link with target libraries, while using the host Python installation.</source>
          <target state="translated">numpy distutils로 크로스 컴파일 할 때 수정 된 npy-pkg-config 파일을 사용해야 할 수 있습니다. 기본 / 생성 된 파일을 사용하면 호스트 라이브러리 (예 : libnpymath.a)와 연결됩니다. 크로스 컴파일의 경우 호스트 Python 설치를 사용하는 동안 대상 라이브러리와 연결해야합니다.</target>
        </trans-unit>
        <trans-unit id="8f67c8b0b4f5cc7d1d888ed98b880f842ee42d75" translate="yes" xml:space="preserve">
          <source>When either of the dimensions compared is one, the other is used. In other words, dimensions with size 1 are stretched or &amp;ldquo;copied&amp;rdquo; to match the other.</source>
          <target state="translated">비교 된 차원 중 하나가 하나이면 다른 차원이 사용됩니다. 즉, 크기가 1 인 차원은 다른 차원과 일치하도록 확장되거나 &quot;복사&quot;됩니다.</target>
        </trans-unit>
        <trans-unit id="36a5c7d333e9c484967d9590699c121ae8287b5d" translate="yes" xml:space="preserve">
          <source>When either of the elements is masked, the result is masked as well, but the underlying boolean data are still set, with self and other considered equal if both are masked, and unequal otherwise.</source>
          <target state="translated">요소 중 하나가 마스킹되면 결과도 마스킹되지만 기본 부울 데이터는 여전히 설정되며, 둘 중 하나가 마스킹 된 경우 자체 및 기타가 동일하게 간주되고 그렇지 않으면 동일하지 않은 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="2c15c829ea1146c460c63d87fff55a43784eaa99" translate="yes" xml:space="preserve">
          <source>When estimating the standard error of a proportion in a population by using a random sample, the normal distribution works well unless the product p*n &amp;lt;=5, where p = population proportion estimate, and n = number of samples, in which case the binomial distribution is used instead. For example, a sample of 15 people shows 4 who are left handed, and 11 who are right handed. Then p = 4/15 = 27%. 0.27*15 = 4, so the binomial distribution should be used in this case.</source>
          <target state="translated">랜덤 표본을 사용하여 모집단에서 비율의 표준 오차를 추정 할 때, 정규 분포는 곱 p * n &amp;lt;= 5 (여기서 p = 모집단 비율 추정치, n = 표본 개수)가 아니면 잘 작동합니다. 이항 분포가 대신 사용됩니다. 예를 들어, 15 명 샘플은 왼손잡이 4 명, 오른 손잡이 11 명을 보여줍니다. 그런 다음 p = 4/15 = 27 %입니다. 0.27 * 15 = 4이므로이 경우 이항 분포를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="09930c9cc0372480cd647d7e9b5ec7bd58cefab8" translate="yes" xml:space="preserve">
          <source>When fewer indices are provided than the number of axes, the missing indices are considered complete slices&lt;code&gt;:&lt;/code&gt;</source>
          <target state="translated">축 수보다 적은 인덱스가 제공되면 누락 된 인덱스는 완전한 조각으로 간주됩니다 &lt;code&gt;:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b79bfc37b770b9a9d472063cecf571e647616c67" translate="yes" xml:space="preserve">
          <source>When fid is a file object, array contents are directly written to the file, bypassing the file object&amp;rsquo;s &lt;code&gt;write&lt;/code&gt; method. As a result, tofile cannot be used with files objects supporting compression (e.g., GzipFile) or file-like objects that do not support &lt;code&gt;fileno()&lt;/code&gt; (e.g., BytesIO).</source>
          <target state="translated">fid가 파일 객체 인 경우 파일 내용의 &lt;code&gt;write&lt;/code&gt; 메서드를 무시하고 배열 내용이 파일에 직접 기록됩니다 . 결과적으로 tofile은 압축을 지원하는 파일 객체 (예 : GzipFile) 또는 &lt;code&gt;fileno()&lt;/code&gt; 지원하지 않는 파일과 같은 객체 (예 : BytesIO) 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="aefa8c4cd90708b249d563eead9370ff301bdaf2" translate="yes" xml:space="preserve">
          <source>When finished:</source>
          <target state="translated">완료되면 :</target>
        </trans-unit>
        <trans-unit id="b8650f4614cacd7afc4a45f34e856756be0c8acc" translate="yes" xml:space="preserve">
          <source>When forcing an iteration order, we observed that the external loop option may provide the elements in smaller chunks because the elements can&amp;rsquo;t be visited in the appropriate order with a constant stride. When writing C code, this is generally fine, however in pure Python code this can cause a significant reduction in performance.</source>
          <target state="translated">반복 순서를 강제 할 때, 요소가 일정한 보폭으로 적절한 순서로 방문 될 수 없기 때문에 외부 루프 옵션이 요소를 더 작은 청크로 제공 할 수 있음을 관찰했습니다. C 코드를 작성할 때 일반적으로 문제는 없지만 순수 Python 코드에서는 성능이 크게 저하 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70fcc2c9e602ae36838f0ffe9f9889f2373533f4" translate="yes" xml:space="preserve">
          <source>When giving examples, we will use the following conventions:</source>
          <target state="translated">예제를 제공 할 때 다음 규칙을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f35ea57e8d85acee84ee1ddb5c53faafa07f0d16" translate="yes" xml:space="preserve">
          <source>When it comes to the data science ecosystem, Python and NumPy are built with the user in mind. One of the best examples of this is the built-in access to documentation. Every object contains the reference to a string, which is known as the &lt;strong&gt;docstring&lt;/strong&gt;. In most cases, this docstring contains a quick and concise summary of the object and how to use it. Python has a built-in &lt;code&gt;help()&lt;/code&gt; function that can help you access this information. This means that nearly any time you need more information, you can use &lt;code&gt;help()&lt;/code&gt; to quickly find the information that you need.</source>
          <target state="translated">데이터 과학 생태계와 관련하여 Python과 NumPy는 사용자를 염두에두고 구축되었습니다. 이에 대한 가장 좋은 예 중 하나는 문서에 대한 기본 제공 액세스입니다. 모든 객체는 &lt;strong&gt;docstring으로&lt;/strong&gt; 알려진 문자열에 대한 참조를 포함합니다 . 대부분의 경우이 독 스트링에는 객체 및 사용 방법에 대한 빠르고 간결한 요약이 포함되어 있습니다. Python에는 이 정보에 액세스하는 &lt;code&gt;help()&lt;/code&gt; 이되는 내장 help () 함수가 있습니다. 즉, 더 많은 정보가 필요할 때마다 &lt;code&gt;help()&lt;/code&gt; 를 사용 하여 필요한 정보를 빠르게 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b9b252a9e3ddb6a4daaa0819da4dce1d5c66c848" translate="yes" xml:space="preserve">
          <source>When matplotlib is imported in the example, the Example code will be wrapped in &lt;code&gt;matplotlib&amp;rsquo;s Sphinx `plot&lt;/code&gt; directive &amp;lt;&lt;a href=&quot;http://matplotlib.org/sampledoc/extensions.html&quot;&gt;http://matplotlib.org/sampledoc/extensions.html&lt;/a&gt;&amp;gt;`_. When matplotlib is not explicitly imported, &lt;code&gt; plot::&lt;/code&gt; can be used directly if &lt;a href=&quot;https://matplotlib.org/api/sphinxext_plot_directive_api.html#module-matplotlib.sphinxext.plot_directive&quot;&gt;&lt;code&gt;matplotlib.sphinxext.plot_directive&lt;/code&gt;&lt;/a&gt; is loaded as a Sphinx extension in &lt;code&gt;conf.py&lt;/code&gt;.</source>
          <target state="translated">예제에서 matplotlib를 가져 오면 예제 코드가 &lt;code&gt;matplotlib&amp;rsquo;s Sphinx `plot&lt;/code&gt; directive &amp;lt; &lt;a href=&quot;http://matplotlib.org/sampledoc/extensions.html&quot;&gt;http://matplotlib.org/sampledoc/extensions.html&lt;/a&gt; &amp;gt;`_에 래핑됩니다 . matplotlib를 명시 적으로 가져 오지 않은 경우 &lt;a href=&quot;https://matplotlib.org/api/sphinxext_plot_directive_api.html#module-matplotlib.sphinxext.plot_directive&quot;&gt; &lt;code&gt;matplotlib.sphinxext.plot_directive&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;conf.py&lt;/code&gt; 에 Sphinx 확장으로로드 되면 &lt;code&gt; plot::&lt;/code&gt; 을 직접 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c71cf348548e71c4885bb0a433c67bf4fdec31b8" translate="yes" xml:space="preserve">
          <source>When merging contributions, a committer is responsible for ensuring that those meet the requirements outlined in the &lt;a href=&quot;index#guidelines&quot;&gt;Development process guidelines&lt;/a&gt; for NumPy. Also, check that new features and backwards compatibility breaks were discussed on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;.</source>
          <target state="translated">기여를 병합 할 때 커미터는 NumPy 에 대한 &lt;a href=&quot;index#guidelines&quot;&gt;개발 프로세스 지침&lt;/a&gt; 에 설명 된 요구 사항을 충족하는지 확인할 책임이 있습니다 . 또한 &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion 메일 링리스트&lt;/a&gt; 에서 새로운 기능과 이전 버전과의 호환성 중단이 논의되었는지 확인 하세요 .</target>
        </trans-unit>
        <trans-unit id="d35b37d44b28508587e123d157336a91b6e8c01f" translate="yes" xml:space="preserve">
          <source>When multiple arrays are involved in an operation, you may want to use the same broadcasting rules that the math operations (&lt;em&gt;i.e.&lt;/em&gt; the ufuncs) use. This can be done easily using the &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;. This is the object returned from the Python command numpy.broadcast and it is almost as easy to use from C. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIterNew&quot;&gt;&lt;code&gt;PyArray_MultiIterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;...&lt;/code&gt; ) is used (with &lt;code&gt;n&lt;/code&gt; input objects in place of &lt;code&gt;...&lt;/code&gt; ). The input objects can be arrays or anything that can be converted into an array. A pointer to a PyArrayMultiIterObject is returned. Broadcasting has already been accomplished which adjusts the iterators so that all that needs to be done to advance to the next element in each array is for PyArray_ITER_NEXT to be called for each of the inputs. This incrementing is automatically performed by &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_NEXT&quot;&gt;&lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt; ) macro (which can handle a multiterator &lt;code&gt;obj&lt;/code&gt; as either a &lt;code&gt;PyArrayMultiObject *&lt;/code&gt; or a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt;). The data from input number &lt;code&gt;i&lt;/code&gt; is available using &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_DATA&quot;&gt;&lt;code&gt;PyArray_MultiIter_DATA&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; ) and the total (broadcasted) size as &lt;code&gt;PyArray_MultiIter_SIZE&lt;/code&gt; ( &lt;code&gt;obj&lt;/code&gt;). An example of using this feature follows.</source>
          <target state="translated">연산에 여러 배열이 포함 된 경우 수학 연산 ( &lt;em&gt;예 :&lt;/em&gt; ufuncs) 에서 사용하는 것과 동일한 브로드 캐스팅 규칙을 사용할 수 있습니다. 이것은 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; 를&lt;/a&gt; 사용하여 쉽게 할 수 있습니다 . 이것은 Python 명령 numpy.broadcast에서 반환 된 객체이며 C에서 사용하는 것만큼이나 쉽습니다. &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIterNew&quot;&gt; &lt;code&gt;PyArray_MultiIterNew&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;...&lt;/code&gt; ) 함수 가 사용됩니다 ( &lt;code&gt;...&lt;/code&gt; 대신 &lt;code&gt;n&lt;/code&gt; 개의 입력 객체 와 함께 사용됨) .). 입력 개체는 배열 또는 배열로 변환 할 수있는 모든 것이 될 수 있습니다. PyArrayMultiIterObject에 대한 포인터가 반환됩니다. 각 배열의 다음 요소로 진행하기 위해 수행해야하는 모든 작업은 각 입력에 대해 호출되는 PyArray_ITER_NEXT에 대한 것이므로 반복기를 조정하는 브로드 캐스팅이 이미 완료되었습니다. 이 증가는 &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_NEXT&quot;&gt; &lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt; ) 매크로에 의해 자동으로 수행됩니다 ( 멀티 &lt;code&gt;PyArrayMultiObject *&lt;/code&gt; &lt;code&gt;obj&lt;/code&gt; 를 PyArrayMultiObject * 또는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 로 처리 할 수 ​​있음 ). 입력 번호의 데이터 &lt;code&gt;i&lt;/code&gt; 사용 가능 &lt;a href=&quot;../reference/c-api/array#c.PyArray_MultiIter_DATA&quot;&gt; &lt;code&gt;PyArray_MultiIter_DATA&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;obj&lt;/code&gt; , &lt;code&gt;i&lt;/code&gt; ) 및 전체 (브로드 캐스트) 크기는 &lt;code&gt;PyArray_MultiIter_SIZE&lt;/code&gt; ( &lt;code&gt;obj&lt;/code&gt; )로 표시됩니다. 이 기능을 사용하는 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36f72cd33b97d536492271e1edd9154022c923bc" translate="yes" xml:space="preserve">
          <source>When multiple examples are provided, they should be separated by blank lines. Comments explaining the examples should have blank lines both above and below them:</source>
          <target state="translated">여러 예제가 제공되는 경우 빈 줄로 구분해야합니다. 예제를 설명하는 주석은 위와 아래에 빈 줄이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7c4c339ad493bfce465346e967265bb9c039f51a" translate="yes" xml:space="preserve">
          <source>When one of &lt;code&gt;actual&lt;/code&gt; and &lt;code&gt;desired&lt;/code&gt; is a scalar and the other is array_like, the function checks that each element of the array_like object is equal to the scalar.</source>
          <target state="translated">&lt;code&gt;actual&lt;/code&gt; 및 &lt;code&gt;desired&lt;/code&gt; 중 하나가 스칼라이고 다른 하나가 array_like이면 함수는 array_like 객체의 각 요소가 스칼라와 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="2eb53e9a562d149565801498a40e0d889c5c04ae" translate="yes" xml:space="preserve">
          <source>When one of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; is a scalar and the other is array_like, the function checks that each element of the array_like object is equal to the scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 중 하나가 스칼라이고 다른 하나가 array_like이면이 함수는 array_like 객체의 각 요소가 스칼라와 같은지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="63eda21eb7811aeacc325fcf56f657d21ccc05f4" translate="yes" xml:space="preserve">
          <source>When one or more of the arrays to be concatenated is a MaskedArray, this function will return a MaskedArray object instead of an ndarray, but the input masks are &lt;em&gt;not&lt;/em&gt; preserved. In cases where a MaskedArray is expected as input, use the ma.concatenate function from the masked array module instead.</source>
          <target state="translated">연결할 하나 이상의 배열이 MaskedArray 인 경우이 함수는 ndarray 대신 MaskedArray 객체를 반환하지만 입력 마스크는 유지 &lt;em&gt;되지 않습니다&lt;/em&gt; . MaskedArray가 입력으로 예상되는 경우 대신 마스크 배열 모듈에서 ma.concatenate 함수를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="eccfc4e1a7be21e04b2017257495e340f746e64f" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is a shorthand for &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt;. Using &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt; directly should be preferred, as it behaves correctly for subclasses. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되는 경우이 함수는 &lt;code&gt;np.asarray(condition).nonzero()&lt;/code&gt; 의 약어입니다 . 서브 클래스에서 올바르게 작동하므로 &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 직접 사용 하는 것이 좋습니다. 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="b8419db09cea322048fba5bff5f136770a8b6713" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되면이 함수는 &lt;a href=&quot;numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 것과 같습니다 . 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우 만 다룹니다.</target>
        </trans-unit>
        <trans-unit id="f0ab5d9437775df5178e579cfc66f050d2a606a1" translate="yes" xml:space="preserve">
          <source>When only &lt;code&gt;condition&lt;/code&gt; is provided, this function is identical to &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;. The rest of this documentation covers only the case where all three arguments are provided.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 만 제공되는 경우이 함수는 &lt;a href=&quot;numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; 것과 동일합니다 . 이 문서의 나머지 부분에서는 세 가지 인수가 모두 제공되는 경우에만 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a83dea336fc44b86e10fe7d04631005f6869d53b" translate="yes" xml:space="preserve">
          <source>When opening the saved &lt;code&gt;.npz&lt;/code&gt; file with &lt;a href=&quot;numpy.load#numpy.load&quot;&gt;&lt;code&gt;load&lt;/code&gt;&lt;/a&gt; a &lt;code&gt;NpzFile&lt;/code&gt; object is returned. This is a dictionary-like object which can be queried for its list of arrays (with the &lt;code&gt;.files&lt;/code&gt; attribute), and for the arrays themselves.</source>
          <target state="translated">저장된 &lt;code&gt;.npz&lt;/code&gt; 파일을 &lt;a href=&quot;numpy.load#numpy.load&quot;&gt; &lt;code&gt;load&lt;/code&gt; &lt;/a&gt; 하여 &lt;code&gt;NpzFile&lt;/code&gt; 객체가 반환됩니다. 이것은 배열 목록 ( &lt;code&gt;.files&lt;/code&gt; 속성 사용)과 배열 자체에 대해 쿼리 할 수있는 사전과 유사한 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="db678ddd8c249ca5b7124cc39a503e60a8883bd8" translate="yes" xml:space="preserve">
          <source>When operating and manipulating arrays, their data is sometimes copied into a new array and sometimes not. This is often a source of confusion for beginners. There are three cases:</source>
          <target state="translated">배열을 조작하고 조작 할 때 데이터가 새 배열로 복사되는 경우도 있고 그렇지 않은 경우도 있습니다. 이것은 종종 초보자에게 혼란의 원인이됩니다. 세 가지 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7826c9c3ec00652f97696ab5820b06d6f4736590" translate="yes" xml:space="preserve">
          <source>When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing (i.e. rightmost) dimensions and works its way left. Two dimensions are compatible when</source>
          <target state="translated">두 배열에서 작동 할 때 NumPy는 모양을 요소별로 비교합니다. 후행 (즉, 맨 오른쪽) 치수로 시작하여 왼쪽으로 작동합니다. 두 차원은 다음과 같은 경우 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="db500670e369fb09767346f1ee93c96337acfc4a" translate="yes" xml:space="preserve">
          <source>When operating on two arrays, NumPy compares their shapes element-wise. It starts with the trailing dimensions and works its way forward. Two dimensions are compatible when</source>
          <target state="translated">두 배열에서 작동 할 때 NumPy는 모양을 요소별로 비교합니다. 후행 치수에서 시작하여 앞으로 나아갑니다. 두 차원은 다음과 같은 경우 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="991db5cc5ea188509eab7bddbbcf6ec194a1d9e5" translate="yes" xml:space="preserve">
          <source>When operating with arrays of different types, the type of the resulting array corresponds to the more general or precise one (a behavior known as upcasting).</source>
          <target state="translated">다른 유형의 배열로 작동 할 때 결과 배열의 유형은보다 일반적이거나 정확한 배열 (업 캐스팅이라고하는 동작)에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="26e6b9fa52377f35e02d57b8c33d212f74b50ae3" translate="yes" xml:space="preserve">
          <source>When order is &amp;lsquo;A&amp;rsquo; and &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is an array in neither &amp;lsquo;C&amp;rsquo; nor &amp;lsquo;F&amp;rsquo; order, and a copy is forced by a change in dtype, then the order of the result is not necessarily &amp;lsquo;C&amp;rsquo; as expected. This is likely a bug.</source>
          <target state="translated">order가 'A'이고 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 가 'C'또는 'F'순서가 아닌 배열이고 dtype의 변경으로 인해 사본이 강제 실행되는 경우 결과 순서가 반드시 'C'인 것은 아닙니다. 이것은 버그 일 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="5be535caa0bb6516144fc1de604b8372d3c9991d" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0))</source>
          <target state="translated">지불 기한 ( '시작'(1) 또는 '종료'(0))</target>
        </trans-unit>
        <trans-unit id="9149bcf3649f5259f262c786b3a7a6478a7a8e0f" translate="yes" xml:space="preserve">
          <source>When payments are due (&amp;lsquo;begin&amp;rsquo; (1) or &amp;lsquo;end&amp;rsquo; (0)). Defaults to {&amp;lsquo;end&amp;rsquo;, 0}.</source>
          <target state="translated">지불 기한 ( '시작'(1) 또는 '종료'(0)). 기본값은 { 'end', 0}입니다.</target>
        </trans-unit>
        <trans-unit id="6642df63420a359718ac20ea567420cbe3b18377" translate="yes" xml:space="preserve">
          <source>When performance is important for manipulating many business dates with one particular choice of weekmask and holidays, there is an object &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; which stores the data necessary in an optimized form.</source>
          <target state="translated">특정 주 마스크 및 휴일 중 하나를 선택하여 많은 비즈니스 날짜를 조작하는 데 성능이 중요한 경우, 필요한 데이터를 최적화 된 형식으로 저장 하는 오브젝트 &lt;a href=&quot;generated/numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt; &lt;code&gt;busdaycalendar&lt;/code&gt; &lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd00b76d3636aeca15fb36d92b84ae47d7409ff3" translate="yes" xml:space="preserve">
          <source>When positive infinity and negative infinity are present:</source>
          <target state="translated">양의 무한대와 음의 무한대가 존재할 때 :</target>
        </trans-unit>
        <trans-unit id="bfd35400824f4bd78ecd5a9fec6a8610574752f0" translate="yes" xml:space="preserve">
          <source>When referring to an entirely different module:</source>
          <target state="translated">완전히 다른 모듈을 언급 할 때 :</target>
        </trans-unit>
        <trans-unit id="b81236c338b918002d5b76ae218758bcc0c4f094" translate="yes" xml:space="preserve">
          <source>When referring to functions in the same sub-module, no prefix is needed, and the tree is searched upwards for a match.</source>
          <target state="translated">동일한 하위 모듈의 기능을 참조 할 때 접두사가 필요하지 않으며 트리에서 일치하는 항목을 위쪽으로 검색합니다.</target>
        </trans-unit>
        <trans-unit id="6cda328920c935f49e7ba607f4bde2c82e352842" translate="yes" xml:space="preserve">
          <source>When reviewing pull requests, please use workflow tracking features on GitHub as appropriate:</source>
          <target state="translated">풀 요청을 검토 할 때 GitHub의 워크 플로 추적 기능을 적절하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="de7c6f732a621082b328f0e10ba6ebce8f1a6e6b" translate="yes" xml:space="preserve">
          <source>When saving dictionaries, the dictionary keys become filenames inside the ZIP archive. Therefore, keys should be valid filenames. E.g., avoid keys that begin with &lt;code&gt;/&lt;/code&gt; or contain &lt;code&gt;.&lt;/code&gt;.</source>
          <target state="translated">사전을 저장할 때 사전 키는 ZIP 아카이브 내의 파일 이름이됩니다. 따라서 키는 유효한 파일 이름이어야합니다. 예를 들어 &lt;code&gt;/&lt;/code&gt; 로 시작 하거나를 포함 하는 키는 피하십시오 &lt;code&gt;.&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a563656ae79c2922818f2a82bafe22a75de09b5e" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;madvise&lt;/code&gt; NumPy will typically use hugepages for a performance boost. This behaviour can be modified by setting the environment variable:</source>
          <target state="translated">&lt;code&gt;madvise&lt;/code&gt; 로 설정하면 NumPy는 일반적으로 성능 향상을 위해 hugepages를 사용합니다. 이 동작은 환경 변수를 설정하여 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="57212127eb9536990cda5db105b01bdf8367e735" translate="yes" xml:space="preserve">
          <source>When spaces are used as delimiters, or when no delimiter has been given as input, there should not be any missing data between two fields.</source>
          <target state="translated">공백이 분리 문자로 사용되거나 분리 문자가 입력으로 제공되지 않은 경우 두 필드 사이에 누락 된 데이터가 없어야합니다.</target>
        </trans-unit>
        <trans-unit id="4370d934ab543968b812927b0ca16a2cbda45f5d" translate="yes" xml:space="preserve">
          <source>When specifying a target using &lt;code&gt;-s&lt;/code&gt;, &lt;code&gt;-t&lt;/code&gt;, or &lt;code&gt;--python&lt;/code&gt;, additional arguments may be forwarded to the target embedded by &lt;code&gt;runtests.py&lt;/code&gt; by passing the extra arguments after a bare &lt;code&gt;--&lt;/code&gt;. For example, to run a test method with the &lt;code&gt;--pdb&lt;/code&gt; flag forwarded to the target, run the following:</source>
          <target state="translated">&lt;code&gt;-s&lt;/code&gt; , &lt;code&gt;-t&lt;/code&gt; 또는 &lt;code&gt;--python&lt;/code&gt; 을 사용하여 대상을 지정할 때 추가 인수는 베어 &lt;code&gt;--&lt;/code&gt; 뒤에 추가 인수를 전달하여 &lt;code&gt;runtests.py&lt;/code&gt; 에 의해 포함 된 대상으로 전달 될 수 있습니다 . 예를 들어 대상으로 전달 된 &lt;code&gt;--pdb&lt;/code&gt; 플래그를 사용하여 테스트 메서드를 실행하려면 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="de5db3a5e4bce528f298ed2c8c86e1143611c165" translate="yes" xml:space="preserve">
          <source>When storing a multi-byte value in memory as a sequence of bytes, the sequence addresses/sends/stores the least significant byte first (lowest address) and the most significant byte last (highest address). Common in x86 processors.</source>
          <target state="translated">다중 바이트 값을 바이트 시퀀스로 메모리에 저장할 때 시퀀스는 최하위 바이트 (최하위 주소)와 최상위 바이트 마지막 (가장 높은 주소)을 주소 지정 / 전송 / 저장합니다. x86 프로세서에서 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="ea57d2031842d794e355da55aa4d649b5ca424d5" translate="yes" xml:space="preserve">
          <source>When storing a multi-byte value in memory as a sequence of bytes, the sequence addresses/sends/stores the most significant byte first (lowest address) and the least significant byte last (highest address). Common in micro-processors and used for transmission of data over network protocols.</source>
          <target state="translated">다중 바이트 값을 바이트 시퀀스로 메모리에 저장할 때 시퀀스는 최상위 바이트를 먼저 (최하위 주소), 최하위 바이트를 마지막 (가장 높은 주소)에 주소 지정 / 전송 / 저장합니다. 마이크로 프로세서에서 일반적이며 네트워크 프로토콜을 통한 데이터 전송에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2c6d6090a315dc06167791d55632ca0e61a0eb7f" translate="yes" xml:space="preserve">
          <source>When studying hypothesis tests that assume normality, seeing how the tests perform on data from a Cauchy distribution is a good indicator of their sensitivity to a heavy-tailed distribution, since the Cauchy looks very much like a Gaussian distribution, but with heavier tails.</source>
          <target state="translated">정규성을 가정하는 가설 검정을 연구 할 때 Cauchy 분포가 가우시안 분포와 매우 유사하지만 꼬리가 무거 우기 때문에 Cauchy 분포의 데이터에서 검정이 어떻게 수행되는지는 꼬리 꼬리 분포에 대한 민감도를 나타내는 좋은 지표입니다.</target>
        </trans-unit>
        <trans-unit id="4d6b9c752dcf618e14ab373ad09afb2c5aaf1513" translate="yes" xml:space="preserve">
          <source>When sub-classing &lt;code&gt;ndarray&lt;/code&gt; or creating duck-types that mimic the &lt;code&gt;ndarray&lt;/code&gt; interface, it is your responsibility to decide how aligned your APIs will be with those of numpy. For convenience, many numpy functions that have a corresponding &lt;code&gt;ndarray&lt;/code&gt; method (e.g., &lt;code&gt;sum&lt;/code&gt;, &lt;code&gt;mean&lt;/code&gt;, &lt;code&gt;take&lt;/code&gt;, &lt;code&gt;reshape&lt;/code&gt;) work by checking if the first argument to a function has a method of the same name. If it exists, the method is called instead of coercing the arguments to a numpy array.</source>
          <target state="translated">&lt;code&gt;ndarray&lt;/code&gt; 를 하위 클래스로 분류 하거나 &lt;code&gt;ndarray&lt;/code&gt; 인터페이스 를 모방하는 duck 유형을 만들 때 API가 numpy의 API와 정렬되는 방식을 결정하는 것은 귀하의 책임입니다. 편의상 대응하는 &lt;code&gt;ndarray&lt;/code&gt; 메서드 (예 : &lt;code&gt;sum&lt;/code&gt; , &lt;code&gt;mean&lt;/code&gt; , &lt;code&gt;take&lt;/code&gt; , &lt;code&gt;reshape&lt;/code&gt; ) 가있는 많은 numpy 함수는 함수 의 첫 번째 인수에 동일한 이름의 메서드가 있는지 확인하여 작동합니다. 존재하는 경우 인수를 numpy 배열로 강제하는 대신 메서드가 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="83471109ed39b7eca8654b0b5b56f710df2f0ed6" translate="yes" xml:space="preserve">
          <source>When success (0 return value) is returned, either out_arr is filled with a non-NULL PyArrayObject and the rest of the parameters are untouched, or out_arr is filled with NULL, and the rest of the parameters are filled.</source>
          <target state="translated">성공 (0 반환 값)이 반환되면 out_arr은 NULL이 아닌 PyArrayObject로 채워지고 나머지 매개 변수는 변경되지 않거나 out_arr은 NULL로 채워지고 나머지 매개 변수는 채워집니다.</target>
        </trans-unit>
        <trans-unit id="c5848cbfcc751d6fb624a1cce409c076b5cc5302" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;external_loop&amp;rdquo; was not used during construction, but is desired, this modifies the iterator to behave as if the flag was specified.</source>
          <target state="translated">&quot;external_loop&quot;가 구성 중에 사용되지 않았지만 원하는 경우 플래그가 지정된 것처럼 반복자가 동작하도록 수정합니다.</target>
        </trans-unit>
        <trans-unit id="a1da80e9817b29febb418ac2727dd8feb1e9ca57" translate="yes" xml:space="preserve">
          <source>When the &amp;ldquo;multi_index&amp;rdquo; flag was specified, this removes it, allowing the internal iteration structure to be optimized further.</source>
          <target state="translated">&quot;multi_index&quot;플래그가 지정되면이를 제거하여 내부 반복 구조를 추가로 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea45d329df78eba717c22414db760106850fd424" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is specified an array of appropriate size is returned.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 키워드가 지정되어 적당한 크기의 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="3fdd0f5189c6dc8a23dfca9586f442b975510baf" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;axis&lt;/code&gt; keyword is used an array is returned.</source>
          <target state="translated">때 &lt;code&gt;axis&lt;/code&gt; 키워드가 사용되는 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="53c50ce51f38684cf2835cdea8b4002b8bbf92a8" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;c_index&lt;/code&gt; or &lt;code&gt;f_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed and &lt;code&gt;has_index&lt;/code&gt; is False.</source>
          <target state="translated">때 &lt;code&gt;c_index&lt;/code&gt; 또는 &lt;code&gt;f_index&lt;/code&gt; 플래그가 사용 된 경우이 속성은 인덱스에 대한 액세스를 제공합니다. 액세스하고 &lt;code&gt;has_index&lt;/code&gt; 가 False 이면 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="76706b5098ca6b382b941c090b506c3f0587d432" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;multi_index&lt;/code&gt; flag was used, this property provides access to the index. Raises a ValueError if accessed accessed and &lt;code&gt;has_multi_index&lt;/code&gt; is False.</source>
          <target state="translated">때 &lt;code&gt;multi_index&lt;/code&gt; 의 플래그가 사용 된 경우이 속성은 인덱스에 대한 액세스를 제공합니다. 액세스하고 &lt;code&gt;has_multi_index&lt;/code&gt; 가 False 이면 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ac5d59cc3a2303eaecb29429bf707b0c3c3bedde" translate="yes" xml:space="preserve">
          <source>When the DFT is computed for purely real input, the output is Hermitian-symmetric, i.e. the negative frequency terms are just the complex conjugates of the corresponding positive-frequency terms, and the negative-frequency terms are therefore redundant. This function does not compute the negative frequency terms, and the length of the transformed axis of the output is therefore &lt;code&gt;n//2 + 1&lt;/code&gt;.</source>
          <target state="translated">순수 실제 입력에 대해 DFT를 계산할 때 출력은 허미 시안 대칭입니다. 즉, 음의 주파수 항은 해당 양의 주파수 항의 복소수 복소수이므로 음의 주파수 항은 중복됩니다. 이 함수는 음의 주파수 항을 계산하지 않으므로 출력의 변환 된 축 길이는 &lt;code&gt;n//2 + 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b75d1885e8ca13361f9bec6a445a1ba51b9a5271" translate="yes" xml:space="preserve">
          <source>When the committee (or a committee member) receives a report, they will first determine whether the report is about a clear and severe breach (as defined below). If so, immediate action needs to be taken in addition to the regular report handling process.</source>
          <target state="translated">위원회 (또는위원회 위원)가 보고서를 받으면 먼저 보고서가 명확하고 심각한 위반 (아래 정의 참조)에 관한 것인지 여부를 결정합니다. 그렇다면 정기 보고서 처리 프로세스 외에 즉각적인 조치를 취해야합니다.</target>
        </trans-unit>
        <trans-unit id="d3d4a45bb9288ccb26e83539df4a7489dddcf142" translate="yes" xml:space="preserve">
          <source>When the data type of &lt;code&gt;a&lt;/code&gt; is longdouble or clongdouble, item() returns a scalar array object because there is no available Python scalar that would not lose information. Void arrays return a buffer object for item(), unless fields are defined, in which case a tuple is returned.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 데이터 유형 이 longdouble 또는 clongdouble 인 경우 item ()은 정보를 잃지 않는 사용 가능한 Python 스칼라가 없으므로 스칼라 배열 객체를 반환합니다. 무효 배열은 필드가 정의되어 있지 않으면 튜플이 반환되지 않는 한 item ()에 대한 버퍼 객체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="6d7c5ae7d2e5fed7aeaee002bc1ee17b1c24ba0a" translate="yes" xml:space="preserve">
          <source>When the dimension of the vector(s) in &lt;code&gt;a&lt;/code&gt; and/or &lt;code&gt;b&lt;/code&gt; does not equal 2 or 3.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 및 / 또는 &lt;code&gt;b&lt;/code&gt; 의 벡터 치수가 2 또는 3이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="dd1fba0c6bb426cf1f952081182426781d82c79b" translate="yes" xml:space="preserve">
          <source>When the error handling for a floating-point error (one of &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, or &amp;ldquo;invalid&amp;rdquo;) is set to &amp;lsquo;call&amp;rsquo; or &amp;lsquo;log&amp;rsquo;, the function that is called or the log instance that is written to is returned by &lt;a href=&quot;#numpy.geterrcall&quot;&gt;&lt;code&gt;geterrcall&lt;/code&gt;&lt;/a&gt;. This function or log instance has been set with &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt;&lt;code&gt;seterrcall&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 오류 ( &quot;divide&quot;, &quot;over&quot;, &quot;under&quot;또는 &quot;invalid&quot;중 하나)에 대한 오류 처리가 호출 된 함수 또는 로그 인스턴스 인 'call'또는 'log'로 설정된 경우 작성된 것은 &lt;a href=&quot;#numpy.geterrcall&quot;&gt; &lt;code&gt;geterrcall&lt;/code&gt; 에&lt;/a&gt; 의해 리턴됩니다 . 이 함수 또는 로그 인스턴스는 &lt;a href=&quot;numpy.seterrcall#numpy.seterrcall&quot;&gt; &lt;code&gt;seterrcall&lt;/code&gt; &lt;/a&gt; 로 설정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="3a105e739e37e79639871fe00f74a7608f41e18f" translate="yes" xml:space="preserve">
          <source>When the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt; is used, the code needs to know the parameters for doing the inner loop. These functions provide that information.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 플래그 가 사용될 때 코드는 내부 루프를 수행하기위한 매개 변수를 알아야합니다. 이러한 기능은 해당 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a3b33dbd60831369f7fef62a2b038dc2ad278fa8" translate="yes" xml:space="preserve">
          <source>When the flags attribute is retrieved from Python, a special builtin object of this type is constructed. This special type makes it easier to work with the different flags by accessing them as attributes or by accessing them as if the object were a dictionary with the flag names as entries.</source>
          <target state="translated">flags 속성이 Python에서 검색되면이 유형의 특수 내장 객체가 생성됩니다. 이 특수 유형을 사용하면 다른 플래그를 속성으로 액세스하거나 오브젝트가 플래그 이름을 항목으로 사용하는 사전 인 것처럼 액세스하여 다른 플래그로 작업하기가 더 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6997b127e257f2d9de0f0028a03e8903521c7172" translate="yes" xml:space="preserve">
          <source>When the index consists of as many integer arrays as the array being indexed has dimensions, the indexing is straight forward, but different from slicing.</source>
          <target state="translated">인덱스가 생성되는 배열의 크기만큼 인덱스가 정수 배열로 구성된 경우 인덱스는 간단하지만 슬라이싱과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="74a8e0eaba5b1fd886e8897754dffe2e69872867" translate="yes" xml:space="preserve">
          <source>When the indexed array &lt;code&gt;a&lt;/code&gt; is multidimensional, a single array of indices refers to the first dimension of &lt;code&gt;a&lt;/code&gt;. The following example shows this behavior by converting an image of labels into a color image using a palette.</source>
          <target state="translated">인덱스 배열 &lt;code&gt;a&lt;/code&gt; 가 다차원 인 경우 인덱스의 단일 배열은의 첫 번째 차원을 참조 &lt;code&gt;a&lt;/code&gt; . 다음 예제는 팔레트를 사용하여 레이블 이미지를 컬러 이미지로 변환하여이 동작을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e3539c51a85d030896869c59fab4a3546a18e92e" translate="yes" xml:space="preserve">
          <source>When the input &lt;code&gt;a&lt;/code&gt; is a time-domain signal and &lt;code&gt;A = fft(a)&lt;/code&gt;, &lt;code&gt;np.abs(A)&lt;/code&gt; is its amplitude spectrum and &lt;code&gt;np.abs(A)**2&lt;/code&gt; is its power spectrum. The phase spectrum is obtained by &lt;code&gt;np.angle(A)&lt;/code&gt;.</source>
          <target state="translated">입력 &lt;code&gt;a&lt;/code&gt; 가 시간 영역 신호이고 &lt;code&gt;A = fft(a)&lt;/code&gt; 경우 &lt;code&gt;np.abs(A)&lt;/code&gt; 는 진폭 스펙트럼이고 &lt;code&gt;np.abs(A)**2&lt;/code&gt; 는 전력 스펙트럼입니다. 위상 스펙트럼은 &lt;code&gt;np.angle(A)&lt;/code&gt; 의해 얻어진다 .</target>
        </trans-unit>
        <trans-unit id="1367f160bbb5fedd65e0cbb76f7f60e11a8156e2" translate="yes" xml:space="preserve">
          <source>When the input and output arrays are aligned and of the correct type, but the striding is not uniform (non-contiguous and 2-D or larger), then a second looping structure is employed for the calculation. This approach converts all of the iterators for the input and output arguments to iterate over all but the largest dimension. The inner loop is then handled by the underlying 1-D computational loop. The outer loop is a standard iterator loop on the converted iterators. The hardware error flags are checked after each 1-D loop is completed.</source>
          <target state="translated">입력 및 출력 배열이 정렬되고 올바른 유형이지만 스 트래 딩이 균일하지 않은 경우 (비 연속 및 2D 이상) 계산에 두 번째 루핑 구조가 사용됩니다. 이 방법은 입력 및 출력 인수에 대한 모든 반복자를 가장 큰 차원을 제외한 모든 반복에서 반복하도록 변환합니다. 그런 다음 내부 루프는 기본 1 차원 계산 루프에 의해 처리됩니다. 외부 루프는 변환 된 반복자의 표준 반복자 루프입니다. 하드웨어 오류 플래그는 각 1D 루프가 완료된 후에 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="34e3c1c18b6a533eb7d5554f7595a67b84951780" translate="yes" xml:space="preserve">
          <source>When the input is purely real, its transform is Hermitian, i.e., the component at frequency</source>
          <target state="translated">입력이 순수하게 실제 인 경우, 변환은 에르 미트 (Hermitian), 즉 주파수 성분</target>
        </trans-unit>
        <trans-unit id="52b34b95d5e176ad47f62260446b195804a6cada" translate="yes" xml:space="preserve">
          <source>When the length of 1D &lt;code&gt;weights&lt;/code&gt; is not the same as the shape of &lt;code&gt;a&lt;/code&gt; along axis.</source>
          <target state="translated">1 차원의 길이 때 &lt;code&gt;weights&lt;/code&gt; 의 형태와 동일하지 축을 따라. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1eaf8889fe184a62b6fd5a964889299281ae31" translate="yes" xml:space="preserve">
          <source>When the nested list is two levels deep, this allows block matrices to be constructed from their components.</source>
          <target state="translated">중첩 목록의 깊이가 두 수준 인 경우 구성 요소에서 블록 행렬을 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e5f5bbbcfb6705ce5d9a02195d69308545da2c5f" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">선택적인 키 &lt;em&gt;오프셋&lt;/em&gt; 및 &lt;em&gt;제목&lt;/em&gt; 이 제공되면 해당 값은 각각 &lt;em&gt;이름&lt;/em&gt; 및 &lt;em&gt;형식&lt;/em&gt; 목록 과 동일한 길이의 목록이어야 합니다. &lt;em&gt;옵셋&lt;/em&gt; 값 (한정 바이트 오프셋의 목록 &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; 그동안, 각 필드의) &lt;em&gt;타이틀의&lt;/em&gt; 값은 각 필드를위한 타이틀리스트 (인 &lt;code&gt;None&lt;/code&gt; 어떤 타이틀 해당 필드 소망하지 않으면 사용할 수 없다). &lt;em&gt;제목은&lt;/em&gt; 어떤 수 있습니다 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 개체 및 필드에 다른 항목 제목에 의해 키가 및 추가 튜플 구성원으로 제목을 포함 동일한 필드 튜플을 참조 사전 추가합니다.</target>
        </trans-unit>
        <trans-unit id="e15e18cad68d6d45da7080a3afbf8bf6942044ae" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (&lt;code&gt;None&lt;/code&gt; can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any object, but when a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; object will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">선택적 키 &lt;em&gt;오프셋&lt;/em&gt; 및 &lt;em&gt;제목&lt;/em&gt; 이 제공되는 경우 해당 값은 각각 &lt;em&gt;이름&lt;/em&gt; 및 &lt;em&gt;형식&lt;/em&gt; 목록 과 동일한 길이의 목록이어야 합니다. &lt;em&gt;옵셋&lt;/em&gt; 값 (한정 바이트 오프셋의 목록 &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; 그동안, 각 필드의) &lt;em&gt;타이틀의&lt;/em&gt; 값은 각 필드를위한 타이틀리스트 (인 &lt;code&gt;None&lt;/code&gt; 어떤 타이틀 해당 필드 소망하지 않으면 사용할 수 없다). &lt;em&gt;제목은&lt;/em&gt; 어떤 객체가 될 수 있지만, 때 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 개체를 추가 할 필드에 다른 항목은 제목 키가 및 추가 튜플 구성원으로 제목을 포함 동일한 필드 튜플을 참조 사전.</target>
        </trans-unit>
        <trans-unit id="fe8737aa96b92cabf0904a91af144d1939eed308" translate="yes" xml:space="preserve">
          <source>When the optional keys &lt;em&gt;offsets&lt;/em&gt; and &lt;em&gt;titles&lt;/em&gt; are provided, their values must each be lists of the same length as the &lt;em&gt;names&lt;/em&gt; and &lt;em&gt;formats&lt;/em&gt; lists. The &lt;em&gt;offsets&lt;/em&gt; value is a list of byte offsets (limited to &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt;&lt;code&gt;ctypes.c_int&lt;/code&gt;&lt;/a&gt;) for each field, while the &lt;em&gt;titles&lt;/em&gt; value is a list of titles for each field (None can be used if no title is desired for that field). The &lt;em&gt;titles&lt;/em&gt; can be any &lt;code&gt;string&lt;/code&gt; or &lt;code&gt;unicode&lt;/code&gt; object and will add another entry to the fields dictionary keyed by the title and referencing the same field tuple which will contain the title as an additional tuple member.</source>
          <target state="translated">선택적 키 &lt;em&gt;오프셋&lt;/em&gt; 및 &lt;em&gt;제목&lt;/em&gt; 이 제공되는 경우 해당 값은 각각 &lt;em&gt;이름&lt;/em&gt; 및 &lt;em&gt;형식&lt;/em&gt; 목록 과 동일한 길이의 목록이어야 합니다. &lt;em&gt;옵셋&lt;/em&gt; 값 (한정 바이트 오프셋의 목록 &lt;a href=&quot;https://docs.python.org/dev/library/ctypes.html#ctypes.c_int&quot;&gt; &lt;code&gt;ctypes.c_int&lt;/code&gt; &lt;/a&gt; 그동안, 각 필드의) &lt;em&gt;타이틀의&lt;/em&gt; 값은 각 필드를위한 타이틀리스트 (제목 없음 해당 분야에 요구되지 않는 경우 중에 사용되지 않을 수있다)이다. &lt;em&gt;제목은&lt;/em&gt; 어떤 수 있습니다 &lt;code&gt;string&lt;/code&gt; 또는 &lt;code&gt;unicode&lt;/code&gt; 개체 및 필드에 다른 항목 제목에 의해 키가 및 추가 튜플 구성원으로 제목을 포함 동일한 필드 튜플을 참조 사전 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0c89441828aa0daf46fb0989feeaa96e8f46c4c3" translate="yes" xml:space="preserve">
          <source>When the result of an advanced indexing operation has no elements but an individual index is out of bounds, whether or not an &lt;code&gt;IndexError&lt;/code&gt; is raised is undefined (e.g. &lt;code&gt;x[[], [123]]&lt;/code&gt; with &lt;code&gt;123&lt;/code&gt; being out of bounds).</source>
          <target state="translated">고급 인덱싱 동작의 결과에 요소가 없지만 개별 인덱스가 있는지의 여부, 범위를 벗어나면 &lt;code&gt;IndexError&lt;/code&gt; 상승이 정의된다 (예를 들면 &lt;code&gt;x[[], [123]]&lt;/code&gt; 와 &lt;code&gt;123&lt;/code&gt; 범위 외인 임).</target>
        </trans-unit>
        <trans-unit id="1684797a859b01eb303a68402fabf36c34b7e573" translate="yes" xml:space="preserve">
          <source>When the total size of the array does not change &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt; should be used. In most other cases either indexing (to reduce the size) or padding (to increase the size) may be a more appropriate solution.</source>
          <target state="translated">배열의 전체 크기가 변경되지 않는 경우 &lt;a href=&quot;numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt; 변경을 사용해야합니다. 대부분의 다른 경우에는 인덱싱 (크기 줄이기) 또는 패딩 (크기 늘리기)이 더 적절한 솔루션 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8285d0cb4c35abac624d1adebd2fa89972bd5bd" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;), there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">변수의 이름이 지정되면 (유연한 dtype 또는 &lt;code&gt;names&lt;/code&gt; ) 파일에 헤더가 없어야합니다 (그렇지 않으면 ValueError 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="cb9d5c54f477f497096e6733fd299984beb835c4" translate="yes" xml:space="preserve">
          <source>When the variables are named (either by a flexible dtype or with &lt;code&gt;names&lt;/code&gt;, there must not be any header in the file (else a ValueError exception is raised).</source>
          <target state="translated">변수에 이름이 지정되면 (유연한 dtype 또는 &lt;code&gt;names&lt;/code&gt; 포함 ) 파일에 헤더가 없어야합니다 (그렇지 않으면 ValueError 예외가 발생 함).</target>
        </trans-unit>
        <trans-unit id="6e373c4bcfc128e5c3fce3b4068067e3ffa9e6bc" translate="yes" xml:space="preserve">
          <source>When the wheels have all been successfully built and staged, download them from the Anaconda staging directory using the &lt;code&gt;tools/download-wheels.py&lt;/code&gt; script:</source>
          <target state="translated">바퀴가 모두 성공적으로 빌드되고 준비되면 &lt;code&gt;tools/download-wheels.py&lt;/code&gt; 스크립트를 사용하여 Anaconda 준비 디렉터리에서 다운로드합니다 .</target>
        </trans-unit>
        <trans-unit id="545b6ed903baa5a5144eaa7b81c5d5357b7f3721" translate="yes" xml:space="preserve">
          <source>When the wheels have all been successfully built, download them using the &lt;code&gt;wheel-uploader&lt;/code&gt; in the &lt;code&gt;terryfy&lt;/code&gt; repository. The terryfy repository may be cloned from &lt;a href=&quot;https://github.com/MacPython/terryfy&quot;&gt;https://github.com/MacPython/terryfy&lt;/a&gt; if you don&amp;rsquo;t already have it. The wheels can also be uploaded using the &lt;code&gt;wheel-uploader&lt;/code&gt;, but we prefer to download all the wheels to the &lt;code&gt;../numpy/release/installers&lt;/code&gt; directory and upload later using &lt;code&gt;twine&lt;/code&gt;:</source>
          <target state="translated">바퀴가 모두 성공적으로 빌드되면 &lt;code&gt;terryfy&lt;/code&gt; 저장소 의 &lt;code&gt;wheel-uploader&lt;/code&gt; 를 사용하여 다운로드 하십시오 . terryfy 저장소가 아직없는 경우 &lt;a href=&quot;https://github.com/MacPython/terryfy&quot;&gt;https://github.com/MacPython/terryfy&lt;/a&gt; 에서 복제 할 수 있습니다 . 바퀴는 또한 사용하여 업로드 할 수 있습니다 &lt;code&gt;wheel-uploader&lt;/code&gt; , 그러나 우리는 모든 바퀴를 다운로드하는 것을 선호 &lt;code&gt;../numpy/release/installers&lt;/code&gt; 의 디렉토리를 사용하여 나중에 업로드 &lt;code&gt;twine&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1ce6824829e37ca585156c8e8abdeb7e7047b4a6" translate="yes" xml:space="preserve">
          <source>When there is at least one slice (&lt;code&gt;:&lt;/code&gt;), ellipsis (&lt;code&gt;...&lt;/code&gt;) or &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; in the index (or the array has more dimensions than there are advanced indexes), then the behaviour can be more complicated. It is like concatenating the indexing result for each advanced index element</source>
          <target state="translated">(가 적어도 하나 개의 조각 인 경우 &lt;code&gt;:&lt;/code&gt; ), 줄임표 ( &lt;code&gt;...&lt;/code&gt; ) 또는 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 인덱스에 (또는 배열이 고급 인덱스가보다 더 많은 차원이), 다음 동작은 더 복잡 할 수 있습니다. 각 고급 색인 요소에 대한 색인 결과를 연결하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7fc05435c156ef19015ca040276948a66576f250" translate="yes" xml:space="preserve">
          <source>When there is more than one axis to sum over - and they are not the last (first) axes of &lt;code&gt;a&lt;/code&gt; (&lt;code&gt;b&lt;/code&gt;) - the argument &lt;code&gt;axes&lt;/code&gt; should consist of two sequences of the same length, with the first axis to sum over given first in both sequences, the second axis second, and so forth.</source>
          <target state="translated">합산 할 축이 두 개 이상이고 축이 &lt;code&gt;a&lt;/code&gt; ( &lt;code&gt;b&lt;/code&gt; ) 의 마지막 (첫 번째) 축이 아닌 경우 인수 &lt;code&gt;axes&lt;/code&gt; 동일한 길이의 두 시퀀스로 구성되어야합니다. 두 시퀀스, 두 번째 축 두 번째 등.</target>
        </trans-unit>
        <trans-unit id="aca72761c1059e14a576d5243f55b005214eb5e7" translate="yes" xml:space="preserve">
          <source>When there is only one operand, no axes are summed, and no output parameter is provided, a view into the operand is returned instead of a new array. Thus, taking the diagonal as &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; produces a view (changed in version 1.10.0).</source>
          <target state="translated">피연산자가 하나만 있고 축이 합산되지 않고 출력 매개 변수가 제공되지 않으면 새 배열 대신 피연산자에 대한 뷰가 반환됩니다. 따라서 대각선을 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 사용하면 뷰가 생성됩니다 (버전 1.10.0에서 변경됨).</target>
        </trans-unit>
        <trans-unit id="6c0c17ce5d478e05a8554320c78aec93528cb754" translate="yes" xml:space="preserve">
          <source>When true, allow writing to the returned view. The default is false, as this should be used with caution: the returned view contains the same memory location multiple times, so writing to one location will cause others to change.</source>
          <target state="translated">true이면 반환 된 뷰에 쓰기를 허용합니다. 기본값은 false이므로주의해서 사용해야합니다. 반환 된 뷰에는 동일한 메모리 위치가 여러 번 포함되어 있으므로 한 위치에 쓰면 다른 위치가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="d6560fa9a8a1164ba82db1ff6a46fb84089bde5d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true 인 경우 결과 문자 &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 에는 8 비트 문자 만 false 인 경우 유니 코드 문자가 포함될 수 있습니다. 유니 코드가 &lt;code&gt;None&lt;/code&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="65b8be94d25ee5071fb62b957f74c26a7a160de6" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true이면 결과 문자 &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 유니 코드 문자가 포함될 수 있고 false이면 8 비트 문자 만 포함될 수 있습니다. unicode가 None이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="eef56b2a721b3cb91ab7c41be9f28e5cebabf16b" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true이면 결과 문자 &lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; &lt;/a&gt; 유니 코드 문자가 포함될 수 있고 false이면 8 비트 문자 만 포함될 수 있습니다. unicode가 None이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="a283e044d3ebfd4430bd993011e5610365921585" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is &lt;code&gt;None&lt;/code&gt; and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true 인 경우 결과 문자 &lt;code&gt;chararray&lt;/code&gt; 에는 8 비트 문자 만 false 인 경우 유니 코드 문자가 포함될 수 있습니다. 유니 코드가 &lt;code&gt;None&lt;/code&gt; 이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="f2245dda0193d47132d217a15baacd8d95efb40d" translate="yes" xml:space="preserve">
          <source>When true, the resulting &lt;code&gt;chararray&lt;/code&gt; can contain Unicode characters, when false only 8-bit characters. If unicode is None and &lt;code&gt;obj&lt;/code&gt; is one of the following:</source>
          <target state="translated">true이면 결과 문자 &lt;code&gt;chararray&lt;/code&gt; 유니 코드 문자가 포함될 수 있고 false이면 8 비트 문자 만 포함될 수 있습니다. unicode가 None이고 &lt;code&gt;obj&lt;/code&gt; 가 다음 중 하나 인 경우 :</target>
        </trans-unit>
        <trans-unit id="d546b1cbadc8d553f3a2c608a6a9f37844d1cc07" translate="yes" xml:space="preserve">
          <source>When two or more input parameters have exactly the same type, shape and description, they can be combined:</source>
          <target state="translated">둘 이상의 입력 매개 변수가 정확히 동일한 유형, 모양 및 설명을 갖는 경우 다음과 같이 결합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec3e52986ad6366d7a0f302f7264cd3302d4a4d7" translate="yes" xml:space="preserve">
          <source>When used as a command line tool, &lt;code&gt;f2py&lt;/code&gt; has three major modes, distinguished by the usage of &lt;code&gt;-c&lt;/code&gt; and &lt;code&gt;-h&lt;/code&gt; switches:</source>
          <target state="translated">명령 줄 도구로 사용할 때 &lt;code&gt;f2py&lt;/code&gt; 에는 &lt;code&gt;-c&lt;/code&gt; 및 &lt;code&gt;-h&lt;/code&gt; 스위치 사용으로 구분되는 세 가지 주요 모드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78f0324161c5da45717d8c4c5bc86e44423bdd63" translate="yes" xml:space="preserve">
          <source>When used in arrays, this type strips trailing null bytes.</source>
          <target state="translated">배열에서 사용되는 경우이 유형은 후행 널 바이트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="40f0d662c07cdabfedd3b1f6952fe6f31dfba509" translate="yes" xml:space="preserve">
          <source>When used in arrays, this type strips trailing null codepoints.</source>
          <target state="translated">배열에서 사용되는 경우이 유형은 후행 널 코드 포인트를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="a2f6bc6ae79777087ef9f135d7de551097f22c0d" translate="yes" xml:space="preserve">
          <source>When used inside &lt;code&gt;&amp;lt;routine signature&amp;gt;&lt;/code&gt;, then given C code will be inserted to the corresponding wrapper function just after declaring variables but before any C statements. So, &lt;code&gt;usercode&lt;/code&gt; follow-up can contain both declarations and C statements.</source>
          <target state="translated">&lt;code&gt;&amp;lt;routine signature&amp;gt;&lt;/code&gt; 내부에서 사용하면 주어진 C 코드가 변수를 선언 한 직후 C 문 앞에 해당 래퍼 함수에 삽입됩니다. 따라서 사용자 &lt;code&gt;usercode&lt;/code&gt; 후속 작업은 선언과 C 문을 모두 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="596f3568b1167a9a713a0235333d3a0c34a92814" translate="yes" xml:space="preserve">
          <source>When used inside &lt;code&gt;python module&lt;/code&gt; block, then given C code will be inserted to generated C/API source just before wrapper function definitions. Here you can define arbitrary C functions to be used in initialization of optional arguments, for example. If &lt;code&gt;usercode&lt;/code&gt; is used twice inside &lt;code&gt;python
module&lt;/code&gt; block then the second multiline block is inserted after the definition of external routines.</source>
          <target state="translated">&lt;code&gt;python module&lt;/code&gt; 블록 내에서 사용될 때 , 주어진 C 코드는 래퍼 함수 정의 바로 전에 생성 된 C / API 소스에 삽입됩니다. 예를 들어, 여기에서 선택적 인수의 초기화에 사용할 임의의 C 함수를 정의 할 수 있습니다. 사용자 &lt;code&gt;usercode&lt;/code&gt; 가 &lt;code&gt;python module&lt;/code&gt; 블록 내에서 두 번 사용 되면 외부 루틴 정의 뒤에 두 번째 여러 줄 블록이 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="80e1b4b5cbc8b59436318942fdcb6ca6f33e723e" translate="yes" xml:space="preserve">
          <source>When used inside the first &lt;code&gt;interface&lt;/code&gt; block, then given C code will be inserted at the end of the initialization function of the extension module. Here you can modify extension modules dictionary. For example, for defining additional variables etc.</source>
          <target state="translated">첫 번째 &lt;code&gt;interface&lt;/code&gt; 블록 내에서 사용하면 주어진 C 코드가 확장 모듈의 초기화 기능 끝에 삽입됩니다. 여기에서 확장 모듈 사전을 수정할 수 있습니다. 예를 들어 추가 변수 등을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="436bc3d73aa6565d86aefabb54c9292e559b97a5" translate="yes" xml:space="preserve">
          <source>When used interactively with an object, &lt;code&gt;np.info(obj)&lt;/code&gt; is equivalent to &lt;code&gt;help(obj)&lt;/code&gt; on the Python prompt or &lt;code&gt;obj?&lt;/code&gt; on the IPython prompt.</source>
          <target state="translated">객체와 대화식으로 사용할 때 &lt;code&gt;np.info(obj)&lt;/code&gt; 는 Python 프롬프트 또는 &lt;code&gt;obj?&lt;/code&gt; 의 &lt;code&gt;help(obj)&lt;/code&gt; 와 동일 합니까? IPython 프롬프트에서.</target>
        </trans-unit>
        <trans-unit id="59366ede5c94f784128a0963e5498e4128255217" translate="yes" xml:space="preserve">
          <source>When used with arrays as arguments, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are similar to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; in their default behavior, but allow for an optional argument giving the number of the axis along which to concatenate.</source>
          <target state="translated">배열을 인수로 사용하는 경우 &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt; &lt;code&gt;r_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt; &lt;code&gt;c_&lt;/code&gt; &lt;/a&gt; 는 기본 동작에서 &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 과 유사 하지만 연결할 축 번호를 제공하는 선택적 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="29f0905c43c5dc57dbedbc6c77600c829150dde0" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; in combination with the numpy conventions, you should use the &lt;code&gt;numpydoc&lt;/code&gt; extension so that your docstrings will be handled correctly. For example, Sphinx will extract the &lt;code&gt;Parameters&lt;/code&gt; section from your docstring and convert it into a field list. Using &lt;code&gt;numpydoc&lt;/code&gt; will also avoid the reStructuredText errors produced by plain Sphinx when it encounters numpy docstring conventions like section headers (e.g. &lt;code&gt;-------------&lt;/code&gt;) that sphinx does not expect to find in docstrings.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;스핑크스를&lt;/a&gt; NumPy와 규칙과 함께, 당신은 사용해야 &lt;code&gt;numpydoc&lt;/code&gt; 의 당신의 문서화 문자열이 제대로 처리 될 수 있도록 확장. 예를 들어 Sphinx는 독 스트링에서 &lt;code&gt;Parameters&lt;/code&gt; 섹션을 추출하여 필드 목록으로 변환합니다. &lt;code&gt;numpydoc&lt;/code&gt; 을 사용하면 스핑크스 가 독 스트링 에서 찾을 것으로 예상하지 않는 섹션 헤더 (예 : &lt;code&gt;-------------&lt;/code&gt; ) 와 같은 numpy 독 스트링 규칙이 발생할 때 일반 Sphinx에서 생성하는 reStructuredText 오류를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4ead31700ab371101b93de0e7731e3c33827c622" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; in combination with the numpy conventions, you should use the &lt;code&gt;numpydoc&lt;/code&gt; extension so that your docstrings will be handled correctly. For example, Sphinx will extract the &lt;code&gt;Parameters&lt;/code&gt; section from your docstring and convert it into a field list. Using &lt;code&gt;numpydoc&lt;/code&gt; will also avoid the reStructuredText errors produced by plain Sphinx when it encounters numpy docstring conventions like section headers (e.g. &lt;code&gt;-------------&lt;/code&gt;) that sphinx does not expect to find in docstrings.</source>
          <target state="translated">사용하는 경우 &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;스핑크스를&lt;/a&gt; NumPy와 규칙과 함께, 당신은 사용해야 &lt;code&gt;numpydoc&lt;/code&gt; 의 당신의 문서화 문자열이 제대로 처리 될 수 있도록 확장. 예를 들어 Sphinx는 독 스트링에서 &lt;code&gt;Parameters&lt;/code&gt; 섹션을 추출하여 필드 목록으로 변환합니다. &lt;code&gt;numpydoc&lt;/code&gt; 을 사용하면 스핑크스 가 독 스트링 에서 찾을 것으로 예상하지 않는 섹션 헤더 (예 : &lt;code&gt;-------------&lt;/code&gt; ) 와 같은 numpy 독 스트링 규칙이 발생할 때 일반 Sphinx에서 생성하는 reStructuredText 오류를 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12d8af6e4436a72ae5774609dfe31b0219205b6b" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;distutils&lt;/code&gt;, for example in &lt;code&gt;setup.py&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;distutils&lt;/code&gt; 를 사용하는 경우 (예 : &lt;code&gt;setup.py&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="a8bcdc54785df618c23c01dc97dc1468fe9c49c4" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;jumped&lt;/code&gt;, one does have to take care not to jump to a stream that was already used. In the above example, one could not later use &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; as it would overlap with &lt;code&gt;blocked_rng[1]&lt;/code&gt;. Like with the independent streams, if the main process here wants to split off 10 more streams by jumping, then it needs to start with &lt;code&gt;range(10, 20)&lt;/code&gt;, otherwise it would recreate the same streams. On the other hand, if you carefully construct the streams, then you are guaranteed to have streams that do not overlap.</source>
          <target state="translated">&lt;code&gt;jumped&lt;/code&gt; 를 사용할 때 이미 사용 된 스트림으로 점프하지 않도록주의해야합니다. 위의 예에서 나중에 &lt;code&gt;blocked_rng[1]&lt;/code&gt; 과 겹치 &lt;code&gt;blocked_rng[0].jumped()&lt;/code&gt; 나중에 blocking_rng [0] .jumped () 를 사용할 수 없습니다 . 독립 스트림과 마찬가지로 여기서 주요 프로세스가 점프하여 10 개 이상의 스트림을 분리하려면 &lt;code&gt;range(10, 20)&lt;/code&gt; 로 시작해야합니다 . 그렇지 않으면 동일한 스트림을 다시 생성합니다. 반면에 스트림을 신중하게 구성하면 겹치지 않는 스트림이 보장됩니다.</target>
        </trans-unit>
        <trans-unit id="724bc629cdbfec6a4e5af9a220d38930424c297d" translate="yes" xml:space="preserve">
          <source>When using a non-integer step, such as 0.1, the results will often not be consistent. It is better to use &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt;&lt;code&gt;numpy.linspace&lt;/code&gt;&lt;/a&gt; for these cases.</source>
          <target state="translated">정수가 아닌 단계 (예 : 0.1)를 사용하는 경우 결과가 종종 일치하지 않습니다. 이 경우 &lt;a href=&quot;numpy.linspace#numpy.linspace&quot;&gt; &lt;code&gt;numpy.linspace&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="27718ed960a95a721b47ff1931021ed4073bbe48" translate="yes" xml:space="preserve">
          <source>When using a string for &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; it is possible to get multiple results.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 문자열을 사용 하면 여러 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4483d4c2e345ca8073aa1a9817270cc3cdb40e82" translate="yes" xml:space="preserve">
          <source>When using a subclass (especially one which manipulates its shape), the default &lt;code&gt;ndarray.__setitem__&lt;/code&gt; behaviour will call &lt;code&gt;__getitem__&lt;/code&gt; for &lt;em&gt;basic&lt;/em&gt; indexing but not for &lt;em&gt;advanced&lt;/em&gt; indexing. For such a subclass it may be preferable to call &lt;code&gt;ndarray.__setitem__&lt;/code&gt; with a &lt;em&gt;base class&lt;/em&gt; ndarray view on the data. This &lt;em&gt;must&lt;/em&gt; be done if the subclasses &lt;code&gt;__getitem__&lt;/code&gt; does not return views.</source>
          <target state="translated">서브 클래스 (특히 모양을 조작하는 서브 클래스)를 사용하는 경우 기본 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 비헤이비어는 &lt;em&gt;기본&lt;/em&gt; 인덱싱에 대해서는 &lt;code&gt;__getitem__&lt;/code&gt; 을 호출 하지만 &lt;em&gt;고급&lt;/em&gt; 인덱싱 에는 사용하지 않습니다 . 이러한 서브 클래스의 경우 &lt;code&gt;ndarray.__setitem__&lt;/code&gt; 을 호출하는 것이 좋습니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; , 데이터에&lt;em&gt; 기본 클래스&lt;/em&gt; ndarray보기로 . 이 &lt;em&gt;있어야&lt;/em&gt; 하위 클래스 경우 수행 할 수 &lt;code&gt;__getitem__&lt;/code&gt; 뷰를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bc311b69f41b3e0c41508f3b081d2280ad7970ec" translate="yes" xml:space="preserve">
          <source>When using broadcasting with uint64 dtypes, the maximum value (2**64) cannot be represented as a standard integer type. The high array (or low if high is None) must have object dtype, e.g., array([2**64]).</source>
          <target state="translated">uint64 dtype으로 브로드 캐스트를 사용하는 경우 최대 값 (2 ** 64)을 표준 정수 유형으로 나타낼 수 없습니다. 상위 배열 (또는 상위가 없음 인 경우 하위)에는 배열 ([2 ** 64])과 같은 개체 dtype이 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="23e3eec66bc7d3437b52c086371fd6ea153ed9c6" translate="yes" xml:space="preserve">
          <source>When using pytest as a target (the default), you can &lt;a href=&quot;https://docs.pytest.org/en/latest/usage.html#specifying-tests-selecting-tests&quot;&gt;match test names using python operators&lt;/a&gt; by passing the &lt;code&gt;-k&lt;/code&gt; argument to pytest:</source>
          <target state="translated">pytest를 대상으로 사용하는 경우 (기본값) pytest에 &lt;code&gt;-k&lt;/code&gt; 인수를 전달 &lt;a href=&quot;https://docs.pytest.org/en/latest/usage.html#specifying-tests-selecting-tests&quot;&gt;하여 python 연산자&lt;/a&gt; 를 사용하여 테스트 이름을 일치 시킬 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c04978427f46ec116ad24550bbf1c67bfbb16f61" translate="yes" xml:space="preserve">
          <source>When using signed integer types the result is the two&amp;rsquo;s complement of the result for the unsigned type:</source>
          <target state="translated">부호있는 정수 유형을 사용할 때 결과는 부호없는 유형에 대한 결과의 2의 보수입니다.</target>
        </trans-unit>
        <trans-unit id="453da0e9bd45f20742c660821d0bef0203dd876c" translate="yes" xml:space="preserve">
          <source>When using the first form of dictionary-based specification, the titles may be supplied as an extra &lt;code&gt;'titles'&lt;/code&gt; key as described above. When using the second (discouraged) dictionary-based specification, the title can be supplied by providing a 3-element tuple &lt;code&gt;(datatype, offset, title)&lt;/code&gt; instead of the usual 2-element tuple:</source>
          <target state="translated">사전 기반 사양의 첫 번째 형식을 사용하는 경우 제목은 위에서 설명한대로 추가 &lt;code&gt;'titles'&lt;/code&gt; 키로 제공 될 수 있습니다 . 두 번째 (권장되지 않은) 사전 기반 사양을 사용할 때 일반적인 2- 요소 튜플 대신 3- 요소 튜플 &lt;code&gt;(datatype, offset, title)&lt;/code&gt; 을 제공하여 제목을 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fefd781e401a9acf4994aa658770a54631a31aac" translate="yes" xml:space="preserve">
          <source>When using the iterator in multi-threaded code or in code not holding the Python GIL, care must be taken to only call functions which are safe in that context. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt;&lt;code&gt;NpyIter_Copy&lt;/code&gt;&lt;/a&gt; cannot be safely called without the Python GIL, because it increments Python references. The &lt;code&gt;Reset*&lt;/code&gt; and some other functions may be safely called by passing in the &lt;code&gt;errmsg&lt;/code&gt; parameter as non-NULL, so that the functions will pass back errors through it instead of setting a Python exception.</source>
          <target state="translated">다중 스레드 코드 또는 Python GIL을 포함하지 않는 코드에서 반복자를 사용할 때는 해당 컨텍스트에서 안전한 함수 만 호출하도록주의해야합니다. &lt;a href=&quot;#c.NpyIter_Copy&quot;&gt; &lt;code&gt;NpyIter_Copy&lt;/code&gt; &lt;/a&gt; 는 Python 참조를 증가시키기 때문에 Python GIL없이 안전하게 호출 할 수 없습니다. &lt;code&gt;Reset*&lt;/code&gt; 및 다른 기능은 안전하게 전달하여 호출 할 수 있습니다 &lt;code&gt;errmsg&lt;/code&gt; 기능이 파이썬 예외를 설정하는 대신 그것을 통해 오류를 다시 전달합니다 그래서, 비 NULL과 같은 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="88e2c9415b727957007e5109caacd82ffe84043d" translate="yes" xml:space="preserve">
          <source>When we call &lt;code&gt;C('hello')&lt;/code&gt;, the &lt;code&gt;__new__&lt;/code&gt; method gets its own class as first argument, and the passed argument, which is the string &lt;code&gt;'hello'&lt;/code&gt;. After python calls &lt;code&gt;__new__&lt;/code&gt;, it usually (see below) calls our &lt;code&gt;__init__&lt;/code&gt; method, with the output of &lt;code&gt;__new__&lt;/code&gt; as the first argument (now a class instance), and the passed arguments following.</source>
          <target state="translated">&lt;code&gt;C('hello')&lt;/code&gt; 를 호출 하면 &lt;code&gt;__new__&lt;/code&gt; 메서드는 자체 클래스를 첫 번째 인수로 가져오고 전달 된 인수 인 &lt;code&gt;'hello'&lt;/code&gt; 문자열을 가져옵니다 . 파이썬이 &lt;code&gt;__new__&lt;/code&gt; 를 호출 한 후 , 일반적으로 (아래 참조) &lt;code&gt;__new__&lt;/code&gt; 의 출력을 첫 번째 인수 (현재는 클래스 인스턴스)로 사용하여 &lt;code&gt;__init__&lt;/code&gt; 메서드를 호출하고 전달 된 인수가 뒤에옵니다.</target>
        </trans-unit>
        <trans-unit id="80e0c3e3144afbdbfb1503b2b31fd233cbb9bcb1" translate="yes" xml:space="preserve">
          <source>When we index arrays with arrays of (integer) indices we are providing the list of indices to pick. With boolean indices the approach is different; we explicitly choose which items in the array we want and which ones we don&amp;rsquo;t.</source>
          <target state="translated">(정수) 인덱스 배열로 배열을 인덱싱 할 때 선택할 인덱스 목록을 제공합니다. 부울 인덱스를 사용하면 접근 방식이 다릅니다. 배열에서 원하는 항목과 원하지 않는 항목을 명시 적으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e0e93c50be29a8db34812f3b063181378aab17d0" translate="yes" xml:space="preserve">
          <source>When working along a given axis, a slice along that axis is returned in &lt;code&gt;output&lt;/code&gt; for each index where &lt;code&gt;condition&lt;/code&gt; evaluates to True. When working on a 1-D array, &lt;a href=&quot;#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt;&lt;code&gt;extract&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">주어진 축을 따라 작업 할 때 해당 축을 따라 슬라이스 가 &lt;code&gt;condition&lt;/code&gt; 이 True로 평가 되는 각 인덱스에 대해 &lt;code&gt;output&lt;/code&gt; 으로 반환됩니다 . 1 차원 배열에서 작업 할 때 &lt;a href=&quot;#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; 은 &lt;a href=&quot;numpy.extract#numpy.extract&quot;&gt; &lt;code&gt;extract&lt;/code&gt; &lt;/a&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7d7c565731670a0f048fc0a67ffb9fb36e062b00" translate="yes" xml:space="preserve">
          <source>When working with more complex dtypes which are composed of other dtypes, such as the struct dtype, creating inner loops that manipulate the dtypes requires carrying along additional data. NumPy supports this idea through a struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt;&lt;code&gt;NpyAuxData&lt;/code&gt;&lt;/a&gt;, mandating a few conventions so that it is possible to do this.</source>
          <target state="translated">struct dtype과 같은 다른 dtype으로 구성된 더 복잡한 dtype으로 작업 할 때 dtype을 조작하는 내부 루프를 만들려면 추가 데이터가 필요합니다. NumPy는 struct &lt;a href=&quot;#c.NpyAuxData&quot;&gt; &lt;code&gt;NpyAuxData&lt;/code&gt; 를 통해이&lt;/a&gt; 아이디어를 지원하며 ,이를 수행 할 수 있도록 몇 가지 규칙을 요구합니다.</target>
        </trans-unit>
        <trans-unit id="dccc69e8b88626650c84c98fbaee8d5823372b3a" translate="yes" xml:space="preserve">
          <source>When working with very large arrays on modern Linux kernels, you can experience a significant speedup when &lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html&quot;&gt;transparent hugepage&lt;/a&gt; is used. The current system policy for transparent hugepages can be seen by:</source>
          <target state="translated">최신 Linux 커널에서 매우 큰 배열로 작업 할 때 &lt;a href=&quot;https://www.kernel.org/doc/html/latest/admin-guide/mm/transhuge.html&quot;&gt;투명한 hugepage&lt;/a&gt; 를 사용할 때 상당한 속도 향상을 경험할 수 있습니다 . 투명한 hugepage에 대한 현재 시스템 정책은 다음에서 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="37deec6852814cd475cf2ac8609e4771e7e23ff2" translate="yes" xml:space="preserve">
          <source>When you break a long expression at a binary operator, the operator goes at the end of the previous line, e.g.,</source>
          <target state="translated">이항 연산자에서 긴 표현식을 분리하면 연산자는 이전 줄의 끝으로 이동합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="e44c90082df7337355379f5ec7bbacbbcd47fdf0" translate="yes" xml:space="preserve">
          <source>When you edit dependence relations that were initially generated by F2PY, be careful not to break the dependence relations of other relevant variables. Another thing to watch out is cyclic dependencies. F2PY is able to detect cyclic dependencies when constructing wrappers and it complains if any are found.</source>
          <target state="translated">F2PY에 의해 처음 생성 된 의존 관계를 편집 할 때 다른 관련 변수의 의존 관계를 깨지 않도록주의하십시오. 주의해야 할 또 다른 사항은 순환 종속성입니다. F2PY는 래퍼를 구성 할 때 순환 종속성을 감지 할 수 있으며 발견되면 불평합니다.</target>
        </trans-unit>
        <trans-unit id="656c7a0b5e4bb86f29ff26d5f3ecacd14ae91bd4" translate="yes" xml:space="preserve">
          <source>When you feel your work is finished, you can create a pull request (PR). Github has a nice help page that outlines the process for &lt;a href=&quot;https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request&quot;&gt;filing pull requests&lt;/a&gt;.</source>
          <target state="translated">작업이 완료되었다고 생각되면 PR (풀 리퀘스트)을 생성 할 수 있습니다. Github에는 &lt;a href=&quot;https://help.github.com/articles/using-pull-requests/#initiating-the-pull-request&quot;&gt;pull 요청&lt;/a&gt; 을 제출 하는 프로세스를 설명하는 멋진 도움말 페이지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="57465a3d673d3ee14218ee57f56504a3d7049d2f" translate="yes" xml:space="preserve">
          <source>When you have a set of &amp;ldquo;ready&amp;rdquo; changes in a feature branch ready for NumPy&amp;rsquo;s &lt;code&gt;master&lt;/code&gt; or &lt;code&gt;maintenance&lt;/code&gt; branches, you can push them to &lt;code&gt;upstream&lt;/code&gt; as follows:</source>
          <target state="translated">NumPy의 &lt;code&gt;master&lt;/code&gt; 또는 &lt;code&gt;maintenance&lt;/code&gt; 분기를 위해 준비된 기능 분기에 일련의 &quot;준비된&quot;변경 사항이 있으면 다음과 같이 &lt;code&gt;upstream&lt;/code&gt; 으로 푸시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a89cc2a2b8c2002bf1ad2532a745d3004a2fb796" translate="yes" xml:space="preserve">
          <source>When you have different flags for missing or invalid values, and wish to preserve these flags without replacing them in the original dataset, but exclude them from computations;</source>
          <target state="translated">누락되거나 유효하지 않은 값에 대해 다른 플래그가 있고 원래 데이터 세트에서 대체하지 않고 이러한 플래그를 보존하고 싶지만 계산에서 제외하려는 경우;</target>
        </trans-unit>
        <trans-unit id="1aac8f9491bd528a6d7337e1a909f8444ac4779a" translate="yes" xml:space="preserve">
          <source>When you have to handle many arrays, each with their own mask. If the mask is part of the array, you avoid bugs and the code is possibly more compact;</source>
          <target state="translated">각각 고유 한 마스크가있는 여러 배열을 처리해야하는 경우. 마스크가 배열의 일부인 경우 버그를 방지하고 코드가 더 간결해질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df9284875f70d664e11ddef3155365522e76bf5c" translate="yes" xml:space="preserve">
          <source>When you print an array, NumPy displays it in a similar way to nested lists, but with the following layout:</source>
          <target state="translated">배열을 인쇄 할 때 NumPy는 중첩 된 목록과 비슷한 방식으로 배열을 표시하지만 다음 레이아웃을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ff118b2f38b6fa40b704c3319ca967dd7a981fb4" translate="yes" xml:space="preserve">
          <source>When you use &lt;code&gt;flatten&lt;/code&gt;, changes to your new array won&amp;rsquo;t change the parent array.</source>
          <target state="translated">&lt;code&gt;flatten&lt;/code&gt; 을 사용하면 새 배열을 변경해도 상위 배열이 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aaa9ed3a1aa18ac3b534d99cdc2037422344dc84" translate="yes" xml:space="preserve">
          <source>When you use the &lt;code&gt;%apply&lt;/code&gt; directive, as is usually necessary to use &lt;code&gt;numpy.i&lt;/code&gt;, it will remain in effect until you tell &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; that it shouldn&amp;rsquo;t be. If the arguments to the functions or methods that you are wrapping have common names, such as &lt;code&gt;length&lt;/code&gt; or &lt;code&gt;vector&lt;/code&gt;, these typemaps may get applied in situations you do not expect or want. Therefore, it is always a good idea to add a &lt;code&gt;%clear&lt;/code&gt; directive after you are done with a specific typemap:</source>
          <target state="translated">당신이 사용하는 경우 &lt;code&gt;%apply&lt;/code&gt; 등의 사용에 일반적으로 필요하다, 지시 &lt;code&gt;numpy.i&lt;/code&gt; 당신이 말할 때까지 효력이 유지됩니다 &lt;a href=&quot;http://www.swig.org&quot;&gt;꿀꺽 꿀꺽를&lt;/a&gt; 가되어서는 안된다는. 줄 바꿈하는 함수 또는 메소드에 대한 인수에 &lt;code&gt;length&lt;/code&gt; 또는 &lt;code&gt;vector&lt;/code&gt; 와 같은 공통 이름 이있는 경우 이러한 유형 맵은 예상하지 않거나 원하지 않는 상황에 적용될 수 있습니다. 따라서 특정 유형 맵을 사용한 후에 는 &lt;code&gt;%clear&lt;/code&gt; 지시문 을 추가하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="c9161d14b7fe0e0123346d805be6e656205c9a99" translate="yes" xml:space="preserve">
          <source>When you want to discard all changes and go back to the last commit in the repo, use one of:</source>
          <target state="translated">모든 변경 사항을 버리고 저장소의 마지막 커밋으로 돌아가려면 다음 중 하나를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="ab916b3f54cece1e88c682ef0d387765f5a2bcfb" translate="yes" xml:space="preserve">
          <source>When you want to preserve the values you masked for later processing, without copying the array;</source>
          <target state="translated">배열을 복사하지 않고 나중에 처리하기 위해 마스크 한 값을 보존하려는 경우;</target>
        </trans-unit>
        <trans-unit id="6d2417174abf12a643d6fa2e2e75101924104702" translate="yes" xml:space="preserve">
          <source>When you want to reject a PR: if it&amp;rsquo;s very obvious, you can just close it and explain why. If it&amp;rsquo;s not, then it&amp;rsquo;s a good idea to first explain why you think the PR is not suitable for inclusion in NumPy and then let a second committer comment or close.</source>
          <target state="translated">PR을 거부하고 싶을 때 : 매우 명백한 경우 PR을 닫고 이유를 설명 할 수 있습니다. 그렇지 않은 경우 먼저 PR이 NumPy에 포함하기에 적합하지 않다고 생각하는 이유를 설명하고 두 번째 커미터가 의견을 말하거나 닫도록하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="ccb838c9de18863cdb39cb5422eeea3c8d7e130e" translate="yes" xml:space="preserve">
          <source>Whenever &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; != &lt;code&gt;PyArray_GetNDArrayCVersion()&lt;/code&gt;, the extension has to be recompiled (ABI incompatibility).</source>
          <target state="translated">때마다 &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; ! = &lt;code&gt;PyArray_GetNDArrayCVersion()&lt;/code&gt; , 확장을 다시 컴파일 할 (ABI 호환성)를 갖는다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
