<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="40188341aa1ae4126e28065ab4ae4528efd4ab80" translate="yes" xml:space="preserve">
          <source>An array containing the size of the array in each dimension.</source>
          <target state="translated">각 차원의 배열 크기를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c5525cd97ca2fd0380b69e5fa824c4cb8926190c" translate="yes" xml:space="preserve">
          <source>An array containing the x coordinates of the points to be histogrammed.</source>
          <target state="translated">히스토그램 될 점의 x 좌표를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5e0350b6b12b116d1bc018ccc6e377cd22ea853f" translate="yes" xml:space="preserve">
          <source>An array containing the y coordinates of the points to be histogrammed.</source>
          <target state="translated">히스토그램 될 점의 y 좌표를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="23292ed5ea6c87129ac7edf129a6b29a5c739151" translate="yes" xml:space="preserve">
          <source>An array created this way is a &lt;code&gt;view&lt;/code&gt;, and NumPy often exploits the performance gain of using a view versus making a new array.</source>
          <target state="translated">이러한 방식으로 생성 된 어레이는 &lt;code&gt;view&lt;/code&gt; 이며 NumPy는 종종 뷰를 사용하는 대신 새 어레이를 만드는 성능 이점을 활용합니다.</target>
        </trans-unit>
        <trans-unit id="1cd97d56d812219b3b28e1a0c52b1ff6cc695c36" translate="yes" xml:space="preserve">
          <source>An array describing the shape and dtype of the required MaskedArray.</source>
          <target state="translated">필요한 MaskedArray의 모양과 dtype을 설명하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="04cda3e50b71bd943d98a23dec5faaaa9a7dbcdc" translate="yes" xml:space="preserve">
          <source>An array has a shape given by the number of elements along each axis:</source>
          <target state="translated">배열은 각 축을 따라있는 요소의 수로 주어진 모양을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="d793f2dc9aa6a2d7752deea585ed5cd173d35117" translate="yes" xml:space="preserve">
          <source>An array is a central data structure of the NumPy library. An array is a grid of values and it contains information about the raw data, how to locate an element, and how to interpret an element. It has a grid of elements that can be indexed in &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;various ways&lt;/a&gt;. The elements are all of the same type, referred to as the array &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">배열은 NumPy 라이브러리의 중앙 데이터 구조입니다. 배열은 값의 그리드이며 원시 데이터, 요소를 찾는 방법 및 요소를 해석하는 방법에 대한 정보를 포함합니다. &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;다양한 방법&lt;/a&gt; 으로 인덱싱 할 수있는 요소 그리드가 있습니다 . 요소는 모두 동일한 유형이며 배열 &lt;code&gt;dtype&lt;/code&gt; 이라고합니다 .</target>
        </trans-unit>
        <trans-unit id="cf313c17a2dcae5eace0c3bac8edc28ea3d4e63f" translate="yes" xml:space="preserve">
          <source>An array is considered aligned if the memory offsets for all elements and the base offset itself is a multiple of &lt;code&gt;self.itemsize&lt;/code&gt;. Understanding &lt;code&gt;memory-alignment&lt;/code&gt; leads to better performance on most hardware.</source>
          <target state="translated">모든 요소에 대한 메모리 오프셋과 기본 오프셋 자체가 &lt;code&gt;self.itemsize&lt;/code&gt; 의 배수 인 경우 배열은 정렬 된 것으로 간주됩니다 . &lt;code&gt;memory-alignment&lt;/code&gt; 이해 하면 대부분의 하드웨어에서 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="39caa1c045b8f25aa32aa854e91ee572acbabbf4" translate="yes" xml:space="preserve">
          <source>An array is contiguous if</source>
          <target state="translated">배열은 다음과 같은 경우 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="0d7bb147f3c8147036b25457f328e2835c359f8d" translate="yes" xml:space="preserve">
          <source>An array is usually a fixed-size container of items of the same type and size. The number of dimensions and items in an array is defined by its shape. The shape of an array is a tuple of non-negative integers that specify the sizes of each dimension.</source>
          <target state="translated">배열은 일반적으로 유형과 크기가 동일한 항목의 고정 크기 컨테이너입니다. 배열의 차원 및 항목 수는 모양에 의해 정의됩니다. 배열의 모양은 각 차원의 크기를 지정하는 음이 아닌 정수의 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="8d722ed07993e54ee58671613ec6bb989469ec46" translate="yes" xml:space="preserve">
          <source>An array iterator is a simple way to access the elements of an N-dimensional array quickly and efficiently. Section &lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt; provides more description and examples of this useful approach to looping over an array.</source>
          <target state="translated">배열 반복자는 N 차원 배열의 요소에 빠르고 효율적으로 액세스하는 간단한 방법입니다. &lt;a href=&quot;#sec-array-iterator&quot;&gt;2&lt;/a&gt; 장 에서는 배열을 반복하는이 유용한 방법에 대한 자세한 설명과 예를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="4332fb61829c6f89ffe9272f70c9a5a0a04142f9" translate="yes" xml:space="preserve">
          <source>An array nested in a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, as &lt;code&gt;b&lt;/code&gt; is here:</source>
          <target state="translated">&lt;a href=&quot;#term-structured-data-type&quot;&gt;구조화 된 데이터 유형에&lt;/a&gt; 중첩 된 배열 , &lt;code&gt;b&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8c8ecafe80193daba2a801115dc110f22a3a74c2" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items.</source>
          <target state="translated">배열 객체는 고정 크기 항목의 다차원, 동종 배열을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4cce5f6c6a06c1eb7b057cb09fd7ff7ffd616b00" translate="yes" xml:space="preserve">
          <source>An array object represents a multidimensional, homogeneous array of fixed-size items. An associated data-type object describes the format of each element in the array (its byte-order, how many bytes it occupies in memory, whether it is an integer, a floating point number, or something else, etc.)</source>
          <target state="translated">배열 객체는 고정 크기 항목의 다차원, 동종 배열을 나타냅니다. 연관된 데이터 유형 객체는 배열에서 각 요소의 형식 (바이트 순서, 메모리에서 차지하는 바이트 수, 정수, 부동 소수점 수 등)을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8d1e82b5439e905b1ddafb253ce61f57276c43a9" translate="yes" xml:space="preserve">
          <source>An array object satisfying the specified requirements.</source>
          <target state="translated">지정된 요구 사항을 만족하는 배열 객체입니다.</target>
        </trans-unit>
        <trans-unit id="b7bb351e2eb8c7a3b66881caf4f6450b8b6137b9" translate="yes" xml:space="preserve">
          <source>An array of</source>
          <target state="translated">의 배열</target>
        </trans-unit>
        <trans-unit id="5e4c885c1848f9a375fc02dab6bce7ae4010158c" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates, no matter which weekday they fall upon. Holiday dates may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="translated">어떤 요일에 관계없이 유효하지 않은 날짜로 간주 할 날짜 배열입니다. 휴일 날짜는 어떤 순서로도 지정할 수 있으며 NaT (비한시) 날짜는 무시됩니다. 이 목록은 유효한 요일의 빠른 계산에 적합한 표준화 된 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="43a99ea190c51364ce40fbff67e226039938f643" translate="yes" xml:space="preserve">
          <source>An array of dates to consider as invalid dates. They may be specified in any order, and NaT (not-a-time) dates are ignored. This list is saved in a normalized form that is suited for fast calculations of valid days.</source>
          <target state="translated">유효하지 않은 날짜로 간주 할 날짜 배열입니다. 그것들은 임의의 순서로 지정 될 수 있으며 NaT (비 한번) 날짜는 무시됩니다. 이 목록은 유효한 요일의 빠른 계산에 적합한 표준화 된 형식으로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e52ec49035d815a8b775d98b8000ec27cfc67177" translate="yes" xml:space="preserve">
          <source>An array of floats to be rounded</source>
          <target state="translated">둥글게 될 수레의 배열</target>
        </trans-unit>
        <trans-unit id="f3de1a372b66bb0f894c2b02cc87913d27ccf3e7" translate="yes" xml:space="preserve">
          <source>An array of function pointers &amp;mdash; one for each data type supported by the ufunc. This is the vector loop that is called to implement the underlying function &lt;em&gt;dims&lt;/em&gt; [0] times. The first argument, &lt;em&gt;args&lt;/em&gt;, is an array of &lt;em&gt;nargs&lt;/em&gt; pointers to behaved memory. Pointers to the data for the input arguments are first, followed by the pointers to the data for the output arguments. How many bytes must be skipped to get to the next element in the sequence is specified by the corresponding entry in the &lt;em&gt;steps&lt;/em&gt; array. The last argument allows the loop to receive extra information. This is commonly used so that a single, generic vector loop can be used for multiple functions. In this case, the actual scalar function to call is passed in as &lt;em&gt;extradata&lt;/em&gt;. The size of this function pointer array is ntypes.</source>
          <target state="translated">함수 포인터의 배열 &amp;mdash; ufunc에서 지원하는 각 데이터 유형마다 하나씩입니다. 이 기본 기능 구현 호출 벡터 루프 &lt;em&gt;어두워&lt;/em&gt; [0] 번. 첫 번째 인수 인 &lt;em&gt;args&lt;/em&gt; 는 동작 메모리에 대한 &lt;em&gt;nargs&lt;/em&gt; 포인터 의 배열입니다 . 입력 인수의 데이터에 대한 포인터가 먼저오고 출력 인수의 데이터에 대한 포인터가옵니다. 시퀀스의 다음 요소에 도달하기 위해 건너 뛰어야하는 바이트 수는 &lt;em&gt;단계&lt;/em&gt; 배열 의 해당 항목으로 지정됩니다 . 마지막 인수는 루프가 추가 정보를 수신 할 수있게합니다. 이것은 단일 함수 벡터 루프를 여러 함수에 사용할 수 있도록 일반적으로 사용됩니다. 이 경우 호출 할 실제 스칼라 함수는 다음과 같이 전달됩니다.&lt;em&gt;extradata&lt;/em&gt; . 이 함수 포인터 배열의 크기는 ntype입니다.</target>
        </trans-unit>
        <trans-unit id="e1457d1fa372ec75b9a3106caffe135f20a4e98d" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;a href=&quot;array#c.NPY_QUICKSORT&quot;&gt;&lt;code&gt;NPY_QUICKSORT&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_HEAPSORT&quot;&gt;&lt;code&gt;NPY_HEAPSORT&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="translated">특정 정렬 알고리즘에 대한 함수 포인터의 배열입니다. 키를 사용하여 특정 정렬 알고리즘을 얻습니다 (지금까지 &lt;a href=&quot;array#c.NPY_QUICKSORT&quot;&gt; &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#c.NPY_HEAPSORT&quot;&gt; &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;array#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt; 정의 됨). 이러한 정렬은 연속되고 정렬 된 데이터를 가정하여 제자리에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="89ccf0c919c71e47e2ddd7bf201588725f440dd1" translate="yes" xml:space="preserve">
          <source>An array of function pointers to a particular sorting algorithms. A particular sorting algorithm is obtained using a key (so far &lt;code&gt;NPY_QUICKSORT&lt;/code&gt;, &lt;code&gt;NPY_HEAPSORT&lt;/code&gt;, and &lt;code&gt;NPY_MERGESORT&lt;/code&gt; are defined). These sorts are done in-place assuming contiguous and aligned data.</source>
          <target state="translated">특정 정렬 알고리즘을 가리키는 함수 배열입니다. 특정 정렬 알고리즘은 키를 사용하여 얻습니다 (지금까지 &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; , &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; 및 &lt;code&gt;NPY_MERGESORT&lt;/code&gt; 가 정의 됨). 이러한 정렬은 연속적이고 정렬 된 데이터를 가정하여 제자리에서 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e16de626c174b91da42175d30f3d8341b71b66d8" translate="yes" xml:space="preserve">
          <source>An array of function pointers to cast from the current type to all of the other builtin types. Each function casts a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;from&lt;/em&gt; to a contiguous, aligned, and notswapped buffer pointed at by &lt;em&gt;to&lt;/em&gt; The number of items to cast is given by &lt;em&gt;n&lt;/em&gt;, and the arguments &lt;em&gt;fromarr&lt;/em&gt; and &lt;em&gt;toarr&lt;/em&gt; are interpreted as PyArrayObjects for flexible arrays to get itemsize information.</source>
          <target state="translated">현재 유형에서 다른 모든 내장 유형으로 캐스트 할 함수 포인터의 배열. 각 기능은 정렬 연속 캐스트 및가 가리키는 버퍼 notswapped &lt;em&gt;에서&lt;/em&gt; 정렬 연속으로하고,가 가리키는 된 버퍼 notswapped &lt;em&gt;에&lt;/em&gt; 의해 주어진다 캐스트 항목의 수 &lt;em&gt;N&lt;/em&gt; 과 인수 &lt;em&gt;fromarr&lt;/em&gt; 및 &lt;em&gt;toarr을&lt;/em&gt; 위한 PyArrayObjects로 해석 유연한 배열로 항목 별 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="e200feb9e53ed4ebf2adb54be5ba987c1cf7059b" translate="yes" xml:space="preserve">
          <source>An array of function pointers to sorting algorithms for this data type. The same sorting algorithms as for sort are available. The indices producing the sort are returned in &lt;code&gt;result&lt;/code&gt; (which must be initialized with indices 0 to &lt;code&gt;length-1&lt;/code&gt; inclusive).</source>
          <target state="translated">이 데이터 유형에 대한 정렬 알고리즘에 대한 함수 포인터의 배열입니다. 정렬과 동일한 정렬 알고리즘을 사용할 수 있습니다. 정렬을 생성하는 인덱스는 &lt;code&gt;result&lt;/code&gt; 로 리턴됩니다 (인덱스 0에서 &lt;code&gt;length-1&lt;/code&gt; 까지 초기화해야 함 ).</target>
        </trans-unit>
        <trans-unit id="4bf461a6da3a9c78b86edef9e37f8d374d2671a0" translate="yes" xml:space="preserve">
          <source>An array of indices into the flattened version of an array of dimensions &lt;code&gt;dims&lt;/code&gt;.</source>
          <target state="translated">차원 배열의 전개 된 버전에 대한 인덱스 배열이 &lt;code&gt;dims&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="43a2b96955709f32822d46286842703f4390b599" translate="yes" xml:space="preserve">
          <source>An array of indices or a single index value.</source>
          <target state="translated">인덱스 배열 또는 단일 인덱스 값</target>
        </trans-unit>
        <trans-unit id="c327e0cbb835c3f65406d2930b711dc0438fe097" translate="yes" xml:space="preserve">
          <source>An array of integers or booleans whose elements should be packed to bits.</source>
          <target state="translated">요소를 비트로 묶어야하는 정수 또는 부울 배열입니다.</target>
        </trans-unit>
        <trans-unit id="760cd2caf69b9cf29b19f984123cfb0704600d65" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension.</source>
          <target state="translated">각 차원에 대해 해당 차원의 다음 요소로 넘어 가기 위해 건너 뛰어야하는 바이트 수를 제공하는 정수 배열.</target>
        </trans-unit>
        <trans-unit id="71e7cb63a5da7e356218da95d576d7ce741d5a1c" translate="yes" xml:space="preserve">
          <source>An array of integers providing for each dimension the number of bytes that must be skipped to get to the next element in that dimension. Associated with macro &lt;a href=&quot;array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">각 차원에 대해 해당 차원의 다음 요소로 이동하기 위해 건너 뛰어야하는 바이트 수를 제공하는 정수 배열입니다. 매크로 &lt;a href=&quot;array#c.PyArray_STRIDES&quot;&gt; &lt;code&gt;PyArray_STRIDES&lt;/code&gt; &lt;/a&gt; 와 관련됩니다 .</target>
        </trans-unit>
        <trans-unit id="44196e580ff225be1ef1476b121c70c9f63af8cb" translate="yes" xml:space="preserve">
          <source>An array of integers providing the shape in each dimension as long as nd</source>
          <target state="translated">nd만큼 긴 각 차원의 모양을 제공하는 정수 배열</target>
        </trans-unit>
        <trans-unit id="62ed90156adc402e959f400c23d7929e6a74e615" translate="yes" xml:space="preserve">
          <source>An array of iterator objects that holds the iterators for the arrays to be broadcast together. On return, the iterators are adjusted for broadcasting.</source>
          <target state="translated">배열이 함께 브로드 캐스트되도록 반복자를 보유하는 반복자 오브젝트 배열입니다. 돌아 왔을 때, 반복자는 방송용으로 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="e3e82fd2fdc82899ac97dd9d7069f0c853f214d0" translate="yes" xml:space="preserve">
          <source>An array of numeric data can also be passed.</source>
          <target state="translated">숫자 데이터 배열도 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ece80d1b5df43cd5fed015f36204934c9ec31960" translate="yes" xml:space="preserve">
          <source>An array of pointers to the actual data for the input and output arrays. The input arguments are given first followed by the output arguments.</source>
          <target state="translated">입력 및 출력 배열의 실제 데이터에 대한 포인터 배열입니다. 입력 인수에는 먼저 출력 인수가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d47c875bafe38f3ae53b22be1ca5e1e026b9c87a" translate="yes" xml:space="preserve">
          <source>An array of start and end indexes if there are any masked data in the array. If there are no masked data in the array, &lt;code&gt;edges&lt;/code&gt; is a list of the first and last index.</source>
          <target state="translated">어레이에 마스킹 된 데이터가있는 경우 시작 및 종료 인덱스의 배열입니다. 배열에 마스킹 된 데이터가없는 경우 &lt;code&gt;edges&lt;/code&gt; 는 첫 번째 인덱스와 마지막 인덱스의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="c7dec96e92acd76ab0b9a5089a0591ab494441f3" translate="yes" xml:space="preserve">
          <source>An array of strings the same shape as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 와 동일한 모양의 문자열 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="4864cc2ae1f8d0267df4cabfa6aa6a6b4bbde15b" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the cube cube-root of each element in &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">동일한 형상의 배열 &lt;code&gt;x&lt;/code&gt; 의 각 요소의 큐브 형 큐브 루트 함유 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;out&lt;/code&gt; 제공하여, &lt;code&gt;y&lt;/code&gt; 이를 참조한다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2dca043d37393a6e2fc85fdd287fdcbcb4dfecc0" translate="yes" xml:space="preserve">
          <source>An array of the same shape as &lt;code&gt;x&lt;/code&gt;, containing the positive square-root of each element in &lt;code&gt;x&lt;/code&gt;. If any element in &lt;code&gt;x&lt;/code&gt; is complex, a complex array is returned (and the square-roots of negative reals are calculated). If all of the elements in &lt;code&gt;x&lt;/code&gt; are real, so is &lt;code&gt;y&lt;/code&gt;, with negative elements returning &lt;code&gt;nan&lt;/code&gt;. If &lt;code&gt;out&lt;/code&gt; was provided, &lt;code&gt;y&lt;/code&gt; is a reference to it. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">동일한 형상의 배열 &lt;code&gt;x&lt;/code&gt; 의 각 요소의 양의 제곱근 들어, &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 의 요소 가 복소수이면 복소수 배열이 반환되고 음의 실수의 제곱근이 계산됩니다. &lt;code&gt;x&lt;/code&gt; 의 모든 요소 가 실수이면 &lt;code&gt;y&lt;/code&gt; 도 그렇고 음수 요소는 &lt;code&gt;nan&lt;/code&gt; 을 반환 합니다. 경우 &lt;code&gt;out&lt;/code&gt; 제공하여, &lt;code&gt;y&lt;/code&gt; 이를 참조한다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="b73f11faf81ffda921b160f49100211ca44e9e3b" translate="yes" xml:space="preserve">
          <source>An array of the same type as &lt;code&gt;a&lt;/code&gt;, containing the rounded values. Unless &lt;code&gt;out&lt;/code&gt; was specified, a new array is created. A reference to the result is returned.</source>
          <target state="translated">동일한 유형의 배열 반올림 된 값을 포함. &lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 새 배열이 작성됩니다. 결과에 대한 참조가 리턴됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="979601eabdfd48b8ade710f0f03e8b5a86f0bf28" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i)&lt;/code&gt;. Weights are normalized to 1 if &lt;code&gt;normed&lt;/code&gt; is True. If &lt;code&gt;normed&lt;/code&gt; is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="translated">각 샘플을 계량 하는 값의 배열 &lt;code&gt;w_i&lt;/code&gt; &lt;code&gt;(x_i, y_i)&lt;/code&gt; . &lt;code&gt;normed&lt;/code&gt; 이 참 이면 가중치는 1로 정규화됩니다 . 경우 &lt;code&gt;normed&lt;/code&gt; 거짓이고, 반환 히스토그램의 값은 각 빈에 떨어지는 시료에 속하는 가중치의 합과 동일하다.</target>
        </trans-unit>
        <trans-unit id="e086307191e3a610d256fdc031206d0be076bb2f" translate="yes" xml:space="preserve">
          <source>An array of values &lt;code&gt;w_i&lt;/code&gt; weighing each sample &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt;. Weights are normalized to 1 if normed is True. If normed is False, the values of the returned histogram are equal to the sum of the weights belonging to the samples falling into each bin.</source>
          <target state="translated">각 샘플을 계량 하는 값의 배열 &lt;code&gt;w_i&lt;/code&gt; &lt;code&gt;(x_i, y_i, z_i, &amp;hellip;)&lt;/code&gt; . 표준이 참이면 가중치는 1로 정규화됩니다. normed가 False이면 반환 된 히스토그램의 값은 각 빈에 떨어지는 샘플에 속하는 가중치의 합과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c0ce1ac9c3e01f3e63767874318d5ec35c6c8162" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one.</source>
          <target state="translated">의 값과 연관된 가중치의 배열 . 각 값 연관된 가중치에 따른 평균에 기여한다. 가중치 배열은 1 차원 (이 경우 길이는 주어진 축의 크기 여야 함 )이거나 &lt;code&gt;a&lt;/code&gt; 와 같은 모양 일 &lt;code&gt;a&lt;/code&gt; 있습니다. &lt;code&gt;weights=None&lt;/code&gt; 인 경우 &lt;code&gt;a&lt;/code&gt; 의 모든 데이터 는 가중치가 1과 같다고 가정합니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc2b51a306ef6edd1f96be1bb988f9b49d26d1ac" translate="yes" xml:space="preserve">
          <source>An array of weights associated with the values in &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; contributes to the average according to its associated weight. The weights array can either be 1-D (in which case its length must be the size of &lt;code&gt;a&lt;/code&gt; along the given axis) or of the same shape as &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;weights=None&lt;/code&gt;, then all data in &lt;code&gt;a&lt;/code&gt; are assumed to have a weight equal to one. The 1-D calculation is:</source>
          <target state="translated">의 값과 연관된 가중치의 배열 . 각 값 연관된 가중치에 따른 평균에 기여한다. 가중치 어레이 중 1-D (이 경우 그 길이의 크기 여야 할 수 로서 소정 축을 따라) 또는 동일한 형상 &lt;code&gt;a&lt;/code&gt; . 경우 &lt;code&gt;weights=None&lt;/code&gt; 다음의 모든 데이터 &lt;code&gt;a&lt;/code&gt; 가중치를 갖는 것으로 가정되지 않은 한 동일. 1-D 계산은 다음과 같습니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="91d3b67fb93cc4bc7812921dd986159ce97b0f1e" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). If &lt;code&gt;density&lt;/code&gt; is True, the weights are normalized, so that the integral of the density over the range remains 1.</source>
          <target state="translated">동일한 형상의 가중치의 배열 . 각 값 &lt;code&gt;a&lt;/code&gt; 단지 (1 대신에) 빈 카운트으로 연관된 가중치에 기여한다. 경우 &lt;code&gt;density&lt;/code&gt; True 인, 가중치는 범위 밀도의 적분 1 남아 그래서, 정규화된다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e08534b68e928582028171965f68debd33645b68" translate="yes" xml:space="preserve">
          <source>An array of weights, of the same shape as &lt;code&gt;a&lt;/code&gt;. Each value in &lt;code&gt;a&lt;/code&gt; only contributes its associated weight towards the bin count (instead of 1). This is currently not used by any of the bin estimators, but may be in the future.</source>
          <target state="translated">동일한 형상의 가중치의 배열 . 각 값 &lt;code&gt;a&lt;/code&gt; 단지 (1 대신에) 빈 카운트으로 연관된 가중치에 기여한다. 이것은 현재 빈 추정기에서 사용되지 않지만 앞으로있을 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9f66c5b78a1ee6031ffac8fb1c853e09ee03b883" translate="yes" xml:space="preserve">
          <source>An array shaped as &lt;code&gt;a&lt;/code&gt; but with the specified axis removed. Returns a reference to &lt;code&gt;out&lt;/code&gt; if specified.</source>
          <target state="translated">배열 모양 삭제되지 지정된 축. 에 대한 참조를 반환 &lt;code&gt;out&lt;/code&gt; 지정한 경우입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd19a4a55dabbf2abd322a5d60254e3015e9603b" translate="yes" xml:space="preserve">
          <source>An array that does not own its data, but refers to another array&amp;rsquo;s data instead. For example, we may create a view that only shows every second element of another array:</source>
          <target state="translated">데이터를 소유하지 않지만 대신 다른 배열의 데이터를 참조하는 배열입니다. 예를 들어, 다른 배열의 모든 두 번째 요소 만 표시하는 뷰를 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28da6e5d441ca894170555ee158c5c43a7ecacb4" translate="yes" xml:space="preserve">
          <source>An array where all elements are equal to zero, except for the &lt;code&gt;k&lt;/code&gt;-th diagonal, whose values are equal to one.</source>
          <target state="translated">값이 1 인 &lt;code&gt;k&lt;/code&gt; 번째 대각선을 제외하고 모든 요소가 0 인 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="9b75a9f2449bf7b8b39aa7a14602f9d2a9c799dd" translate="yes" xml:space="preserve">
          <source>An array whose dtype is &lt;code&gt;object&lt;/code&gt;; that is, it contains references to Python objects. Indexing the array dereferences the Python objects, so unlike other ndarrays, an object array has the ability to hold heterogeneous objects.</source>
          <target state="translated">dtype이 &lt;code&gt;object&lt;/code&gt; 인 배열 . 즉, Python 객체에 대한 참조를 포함합니다. 배열을 인덱싱하면 Python 객체가 역 참조되므로 다른 ndarray와 달리 객체 배열은 이기종 객체를 보유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ea1e5537016317a890a5d4a449f9cc2d733ed07" translate="yes" xml:space="preserve">
          <source>An array whose nonzero or True entries indicate the elements of &lt;code&gt;arr&lt;/code&gt; to extract.</source>
          <target state="translated">0이 아닌 또는 True 항목 이 추출 할 &lt;code&gt;arr&lt;/code&gt; 의 요소를 나타내는 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="c9db9bfd04f4def5fd1afc2affd0945adf42512d" translate="yes" xml:space="preserve">
          <source>An array with (possibly) masked elements.</source>
          <target state="translated">마스크 된 요소가있는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="f661a37bc1f34ccd31f28fc314368c36fc3fd521" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;begindates&lt;/code&gt; and &lt;code&gt;enddates&lt;/code&gt; together, containing the number of valid days between the begin and end dates.</source>
          <target state="translated">방송의 형태로 배열 &lt;code&gt;begindates&lt;/code&gt; 및 &lt;code&gt;enddates&lt;/code&gt; 을 (가) 시작 및 종료일 사이 유효 일수를 함유 함께.</target>
        </trans-unit>
        <trans-unit id="da4b7ef06bb85fc991c331148db99f16620489ed" translate="yes" xml:space="preserve">
          <source>An array with a shape from broadcasting &lt;code&gt;dates&lt;/code&gt; and &lt;code&gt;offsets&lt;/code&gt; together, containing the dates with offsets applied.</source>
          <target state="translated">오프셋이 적용된 날짜를 포함하여 브로드 캐스트 &lt;code&gt;dates&lt;/code&gt; 및 &lt;code&gt;offsets&lt;/code&gt; 에서 모양이있는 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="cb96764e2b9c06bb0ff9fb7ca3e50e3f3bfa36d0" translate="yes" xml:space="preserve">
          <source>An array with elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="translated">행 요소 배열 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 에서 사실이며, 원소 &lt;code&gt;y&lt;/code&gt; 다른.</target>
        </trans-unit>
        <trans-unit id="1229c9f2e1287182eb9a66528204171c6010bc1b" translate="yes" xml:space="preserve">
          <source>An array with ones at and below the given diagonal and zeros elsewhere.</source>
          <target state="translated">지정된 대각선의 위와 아래에 1이 있고 다른 곳에 0이있는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="13f9e7222fb1b0027174f3c545f28e69a270792e" translate="yes" xml:space="preserve">
          <source>An array with the elements of &lt;code&gt;a&lt;/code&gt;, but where values &amp;lt; &lt;code&gt;a_min&lt;/code&gt; are replaced with &lt;code&gt;a_min&lt;/code&gt;, and those &amp;gt; &lt;code&gt;a_max&lt;/code&gt; with &lt;code&gt;a_max&lt;/code&gt;.</source>
          <target state="translated">의 요소 어레이 있지만 값 &amp;lt;여기서 &lt;code&gt;a_min&lt;/code&gt; 로 대체 &lt;code&gt;a_min&lt;/code&gt; , 그&amp;gt; &lt;code&gt;a_max&lt;/code&gt; 와 &lt;code&gt;a_max&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d0d81681b563f7cbf7ca14e4beb55c0e61ff30a7" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned. If an output array is specified, a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 축이 제거 된 &lt;code&gt;a&lt;/code&gt; 와 모양이 같은 배열입니다 . 경우 &lt;code&gt;a&lt;/code&gt; 는 0 차원 배열의 경우, 또는 &lt;code&gt;axis&lt;/code&gt; 것도없고, 스칼라가 반환된다. 출력 배열이 지정되면 &lt;code&gt;out&lt;/code&gt; 에 대한 참조 가 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="9baa9b65de91284b3761237390d81577243ec095" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;a&lt;/code&gt;, with the specified axis removed. If &lt;code&gt;a&lt;/code&gt; is a 0-d array, or if axis is None, an ndarray scalar is returned. The same dtype as &lt;code&gt;a&lt;/code&gt; is returned.</source>
          <target state="translated">지정된 축이 제거 된 &lt;code&gt;a&lt;/code&gt; 와 모양이 같은 배열입니다 . 경우 &lt;code&gt;a&lt;/code&gt; 는 0 차원 배열 또는 축 아무도없는 경우, ndarray 스칼라가 반환된다. &lt;code&gt;a&lt;/code&gt; 와 동일한 dtype 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e70abaa821cac7240773cdf6e7844c07f6b75f59" translate="yes" xml:space="preserve">
          <source>An array with the same shape as &lt;code&gt;dates&lt;/code&gt;, containing True for each valid day, and False for each invalid day.</source>
          <target state="translated">유효한 각 요일에 대해 True를, 유효하지 않은 각 요일에 대해 False를 포함하는 &lt;code&gt;dates&lt;/code&gt; 와 모양이 동일한 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="3dd1a7da3ce189a324136cbefbaa56e7594e5b61" translate="yes" xml:space="preserve">
          <source>An array with the same shape as the input array, with the specified axis removed. If the array is a 0-d array, or if &lt;code&gt;axis&lt;/code&gt; is None, a scalar is returned.</source>
          <target state="translated">지정된 축이 제거 된 입력 배열과 모양이 같은 배열입니다. 배열이 0-d 배열이거나 &lt;code&gt;axis&lt;/code&gt; 이 None이면 스칼라가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="02c2325cc9f9529260815a39ebd69bc396f69b18" translate="yes" xml:space="preserve">
          <source>An array, any object exposing the array interface, an object whose __array__ method returns an array, or any (nested) sequence.</source>
          <target state="translated">배열, 배열 인터페이스를 노출하는 객체, __array__ 메서드가 배열을 반환하는 객체 또는 (중첩 된) 시퀀스</target>
        </trans-unit>
        <trans-unit id="567f786634fc5daa235d994c1657787eea4b779a" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt;. Copies are made only if necessary.</source>
          <target state="translated">각각 &lt;code&gt;a.ndim &amp;gt;= 1&lt;/code&gt; 인 배열 또는 배열 목록 . 필요한 경우에만 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="cba647ea9fdf896d7caaed5b946ba91dc1f4274e" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;. Copies are avoided where possible, and views with two or more dimensions are returned.</source>
          <target state="translated">각각 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 인 배열 또는 배열 목록 . 가능한 경우 사본을 피하고 2 차원 이상의 뷰가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="20047f5be3a0546654cf45798129be0ced7cf529" translate="yes" xml:space="preserve">
          <source>An array, or list of arrays, each with &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt;. Copies are avoided where possible, and views with three or more dimensions are returned. For example, a 1-D array of shape &lt;code&gt;(N,)&lt;/code&gt; becomes a view of shape &lt;code&gt;(1, N, 1)&lt;/code&gt;, and a 2-D array of shape &lt;code&gt;(M, N)&lt;/code&gt; becomes a view of shape &lt;code&gt;(M, N, 1)&lt;/code&gt;.</source>
          <target state="translated">각각 &lt;code&gt;a.ndim &amp;gt;= 3&lt;/code&gt; 인 배열 또는 배열 목록 . 가능한 경우 사본을 피하고 3 차원 이상의 뷰가 반환됩니다. 예를 들어, 1 차원 형상 배열 &lt;code&gt;(N,)&lt;/code&gt; 은 형상 &lt;code&gt;(1, N, 1)&lt;/code&gt; 의 뷰가 되고, 2 차원 형상 배열 &lt;code&gt;(M, N)&lt;/code&gt; 은 형상 &lt;code&gt;(M, N, 1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2d598faf58dcce518852d1c23ec2af6d3886d1a" translate="yes" xml:space="preserve">
          <source>An assertion is raised if the following condition is not met:</source>
          <target state="translated">다음 조건이 충족되지 않으면 어설 션이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c3adef5312938abeed5e9919b7facafa03477317" translate="yes" xml:space="preserve">
          <source>An assignment example:</source>
          <target state="translated">과제 예 :</target>
        </trans-unit>
        <trans-unit id="5b8cae1664bf34207082790eecd4cff8bc80d113" translate="yes" xml:space="preserve">
          <source>An authority is a person who can tell you more about something than you really care to know. &amp;mdash; &lt;em&gt;Unknown&lt;/em&gt;</source>
          <target state="translated">권위는 당신이 정말로 알고 싶어하는 것보다 더 많은 것을 말해 줄 수있는 사람입니다. &amp;mdash; &lt;em&gt;알 수 없음&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d8abc81a5a743ea9f021fdfc70f53e317bae852f" translate="yes" xml:space="preserve">
          <source>An easier way of casting the data to a specific dtype and byte ordering can be achieved with the ndarray astype method:</source>
          <target state="translated">ndarray astype 메서드를 사용하면 데이터를 특정 dtype 및 바이트 순서로보다 쉽게 ​​캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a06ba8b5680e861b82812d380d7c8f04108d181f" translate="yes" xml:space="preserve">
          <source>An element of a structured datatype that behaves like an ndarray.</source>
          <target state="translated">ndarray처럼 작동하는 구조화 된 데이터 유형의 요소입니다.</target>
        </trans-unit>
        <trans-unit id="88aa14c58828551e162cc4a4661a6843968586b6" translate="yes" xml:space="preserve">
          <source>An empty (tuple) index is a full scalar index into a zero dimensional array. &lt;code&gt;x[()]&lt;/code&gt; returns a &lt;em&gt;scalar&lt;/em&gt; if &lt;code&gt;x&lt;/code&gt; is zero dimensional and a view otherwise. On the other hand &lt;code&gt;x[...]&lt;/code&gt; always returns a view.</source>
          <target state="translated">빈 (튜플) 인덱스는 0 차원 배열에 대한 전체 스칼라 인덱스입니다. &lt;code&gt;x[()]&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 가 0 차원 이면 &lt;em&gt;스칼라를&lt;/em&gt; 반환하고 그렇지 않으면 뷰를 반환합니다. 반면에 &lt;code&gt;x[...]&lt;/code&gt; 항상 뷰를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9f8fe74c5bf94bc803b1bb945a029de2c98e9baa" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating how permissive data conversions should be. This is used by the iterator added in NumPy 1.6, and is intended to be used more broadly in a future version.</source>
          <target state="translated">허용되는 데이터 변환 방법을 나타내는 열거 형입니다. 이것은 NumPy 1.6에 추가 된 반복자에 의해 사용되며 향후 버전에서 더 광범위하게 사용될 예정입니다.</target>
        </trans-unit>
        <trans-unit id="f076fadc0ee0a286669da0779a627fc24ddf6053" translate="yes" xml:space="preserve">
          <source>An enumeration type indicating the element order that an array should be interpreted in. When a brand new array is created, generally only &lt;strong&gt;NPY_CORDER&lt;/strong&gt; and &lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt; are used, whereas when one or more inputs are provided, the order can be based on them.</source>
          <target state="translated">배열을 해석해야하는 요소 순서를 나타내는 열거 형입니다. 새로운 배열을 만들 때는 일반적으로 &lt;strong&gt;NPY_CORDER&lt;/strong&gt; 및 &lt;strong&gt;NPY_FORTRANORDER&lt;/strong&gt; 만 사용되는 반면 하나 이상의 입력이 제공되면 순서는이를 기반으로 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ea26de5566952ec524cedbb60ee90bf6c1be0e2" translate="yes" xml:space="preserve">
          <source>An example</source>
          <target state="translated">예</target>
        </trans-unit>
        <trans-unit id="6e2daf8ca86e15a2e24ed018141a980cd426e388" translate="yes" xml:space="preserve">
          <source>An example Python session would be identical to the previous example except that argument names would differ.</source>
          <target state="translated">예제 Python 세션은 인수 이름이 다르다는 점을 제외하고 이전 예제와 동일합니다.</target>
        </trans-unit>
        <trans-unit id="edf41c0b27774c1df8aed12edb2351eadd7f38b3" translate="yes" xml:space="preserve">
          <source>An example castfunc is:</source>
          <target state="translated">castfunc의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64e8f4d7015b6070bf3f50c3e64f0fbef756b878" translate="yes" xml:space="preserve">
          <source>An example from Glantz[1], pp 47-40:</source>
          <target state="translated">Glantz [1]의 예, pp 47-40 :</target>
        </trans-unit>
        <trans-unit id="1ad321a0ede9c3a9da071e8e5fe72a77cf61d678" translate="yes" xml:space="preserve">
          <source>An example of a non-associative case:</source>
          <target state="translated">비연 관적 사례의 예 :</target>
        </trans-unit>
        <trans-unit id="21524e2813ff9dc11cf1667f630888b770b6f890" translate="yes" xml:space="preserve">
          <source>An example of broadcasting in practice:</source>
          <target state="translated">실제 방송의 예 :</target>
        </trans-unit>
        <trans-unit id="c9441160929c1f5a53f0eec18887501ddb4a68eb" translate="yes" xml:space="preserve">
          <source>An example of using the config header in light of the above:</source>
          <target state="translated">위의 관점에서 config 헤더를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="dd2a4a70d420aa2d3935775486296bc45b66a315" translate="yes" xml:space="preserve">
          <source>An example of where this may be useful is for a color lookup table where we want to map the values of an image into RGB triples for display. The lookup table could have a shape (nlookup, 3). Indexing such an array with an image with shape (ny, nx) with dtype=np.uint8 (or any integer type so long as values are with the bounds of the lookup table) will result in an array of shape (ny, nx, 3) where a triple of RGB values is associated with each pixel location.</source>
          <target state="translated">이것이 유용 할 수있는 예는 디스플레이를 위해 이미지 값을 RGB 트리플로 매핑하려는 색상 조회 테이블에 대한 것입니다. 조회 테이블은 모양 (nlookup, 3)을 가질 수 있습니다. dtype = np.uint8 (또는 값이 조회 테이블의 경계에있는 한 모든 정수 유형)의 모양 (ny, nx) 이미지로 이러한 배열을 인덱싱하면 모양 배열 (ny, nx, 3) RGB 값의 세 배가 각 픽셀 위치와 연관되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="92bcbe60f6b1cdb52a7d953fc81ff3369b0f2592" translate="yes" xml:space="preserve">
          <source>An example to show comments</source>
          <target state="translated">주석을 표시하는 예</target>
        </trans-unit>
        <trans-unit id="ab59fb864b641fc21102fa6867c9f294d4d4a6b9" translate="yes" xml:space="preserve">
          <source>An example using a &amp;ldquo;vector&amp;rdquo; of letters:</source>
          <target state="translated">문자의 &quot;벡터&quot;를 사용하는 예 :</target>
        </trans-unit>
        <trans-unit id="ae67380a5d930011edb475d7e700cc0a79c17af2" translate="yes" xml:space="preserve">
          <source>An example where &lt;code&gt;b&lt;/code&gt; is a scalar:</source>
          <target state="translated">예 &lt;code&gt;b&lt;/code&gt; 스칼라이다 :</target>
        </trans-unit>
        <trans-unit id="94faf0f11390e7c87a6db1e320054aa5b39eed5b" translate="yes" xml:space="preserve">
          <source>An example with fixed-width columns</source>
          <target state="translated">너비가 고정 된 예</target>
        </trans-unit>
        <trans-unit id="ee3a8754bce53d43d3e15790bf69e69f40787cb1" translate="yes" xml:space="preserve">
          <source>An extended example taking advantage of the overloading of + and *:</source>
          <target state="translated">+와 *의 과부하를 이용하는 확장 된 예 :</target>
        </trans-unit>
        <trans-unit id="153bca2420915680d942ae459053fce685c8d220" translate="yes" xml:space="preserve">
          <source>An extensive list of tools for scientific work with Python can be found in the &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;topical software page&lt;/a&gt;.</source>
          <target state="translated">Python을 사용한 과학 작업을위한 광범위한 도구 목록은 &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;주제별 소프트웨어 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3f1f5040c3fab0c8014dea349166afc8130d9681" translate="yes" xml:space="preserve">
          <source>An extensive list of tools for scientific work with python can be found in the &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;topical software page&lt;/a&gt;.</source>
          <target state="translated">파이썬을 사용한 과학적 작업을위한 광범위한 도구 목록은 &lt;a href=&quot;https://scipy.org/topical-software.html&quot;&gt;주제별 소프트웨어 페이지&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="41352b04320eefbd12c3e75a33715bda727551fe" translate="yes" xml:space="preserve">
          <source>An important distinction for these methods is how they handle the &lt;code&gt;axis&lt;/code&gt; parameter. Both &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;Generator.shuffle&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;Generator.permutation&lt;/code&gt;&lt;/a&gt; treat the input as a one-dimensional sequence, and the &lt;code&gt;axis&lt;/code&gt; parameter determines which dimension of the input array to use as the sequence. In the case of a two-dimensional array, &lt;code&gt;axis=0&lt;/code&gt; will, in effect, rearrange the rows of the array, and &lt;code&gt;axis=1&lt;/code&gt; will rearrange the columns. For example</source>
          <target state="translated">이러한 방법의 중요한 차이점은 &lt;code&gt;axis&lt;/code&gt; 매개 변수 를 처리하는 방법입니다 . &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;Generator.shuffle&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;Generator.permutation&lt;/code&gt; &lt;/a&gt; 은 모두 입력을 1 차원 시퀀스로 취급하고 &lt;code&gt;axis&lt;/code&gt; 매개 변수는 시퀀스로 사용할 입력 배열의 차원을 결정합니다. 2 차원 배열의 경우 , 실제로 &lt;code&gt;axis=0&lt;/code&gt; 은 배열의 행을 재 배열하고 &lt;code&gt;axis=1&lt;/code&gt; 은 열을 재 배열합니다. 예를 들면</target>
        </trans-unit>
        <trans-unit id="234994ab6fdb07f0421cdf6417fa8d08aaed3974" translate="yes" xml:space="preserve">
          <source>An important thing to be aware of for this iteration is that the order is chosen to match the memory layout of the array instead of using a standard C or Fortran ordering. This is done for access efficiency, reflecting the idea that by default one simply wants to visit each element without concern for a particular ordering. We can see this by iterating over the transpose of our previous array, compared to taking a copy of that transpose in C order.</source>
          <target state="translated">이 반복에 대해 알아야 할 중요한 사항은 표준 C 또는 포트란 순서를 사용하는 대신 배열의 메모리 레이아웃과 일치하도록 순서를 선택한다는 것입니다. 이는 기본적으로 특정 순서에 대한 염려없이 각 요소를 방문하려고한다는 아이디어를 반영하여 액세스 효율성을 위해 수행됩니다. 이 전치의 사본을 C 순서로 복사하는 것과 비교하여 이전 배열의 전치를 반복하여 이것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce8e2f3f33d5cad8aca5e828b4984abc49c8c85d" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; estimator that works better with non-normal datasets.</source>
          <target state="translated">비정규 데이터 세트에서 더 잘 작동하는 Sturges 추정기의 개선 된 버전입니다.</target>
        </trans-unit>
        <trans-unit id="f04b75dbec8a648ba0471c30efe8cb82bf3011bd" translate="yes" xml:space="preserve">
          <source>An improved version of Sturges&amp;rsquo; formula that produces better estimates for non-normal datasets. This estimator attempts to account for the skew of the data.</source>
          <target state="translated">비정규 데이터 집합에 대한 더 나은 추정치를 생성하는 Sturges 수식의 개선 된 버전. 이 추정기는 데이터의 왜곡을 설명하려고합니다.</target>
        </trans-unit>
        <trans-unit id="6c0daf8923a8ff879a417d16aa3697c8609e06f7" translate="yes" xml:space="preserve">
          <source>An index which matches the order of iteration.</source>
          <target state="translated">반복 순서와 일치하는 인덱스입니다.</target>
        </trans-unit>
        <trans-unit id="fd3ef13b14659602803a66f38a194c91b0d16c51" translate="yes" xml:space="preserve">
          <source>An input can be used in the calculation if its size in a particular dimension either matches the output size in that dimension, or has value exactly 1.</source>
          <target state="translated">특정 차원의 크기가 해당 차원의 출력 크기와 일치하거나 정확히 1의 값을 갖는 경우 입력을 계산에 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24428e2d87c0033a748d11a9f2ce4caa1e91c810" translate="yes" xml:space="preserve">
          <source>An input object.</source>
          <target state="translated">입력 객체.</target>
        </trans-unit>
        <trans-unit id="ccd98d417809c28451b9172282e9fd64d1c41e89" translate="yes" xml:space="preserve">
          <source>An instance of &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; can be thought as the combination of several elements:</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 의 인스턴스는 여러 요소의 조합으로 생각할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6e3d42720c490f4a7b292acd6a9d04e387f93f" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an dense (or fleshed out) mesh-grid when indexed, so that each returned argument has the same shape. The dimensions and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="translated">&lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; 의 인스턴스는 인덱싱 될 때 밀도가 높은 (또는 뭉친 ) 메쉬 그리드를 반환하므로 반환 된 각 인수의 모양이 동일합니다. 출력 배열의 차원과 수는 인덱싱 차원의 수와 같습니다. 단계 길이가 복소수가 아닌 경우 정지는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="634a502415ebc5263dc90361e50dd67e1f0e70b8" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; which returns an open (i.e. not fleshed out) mesh-grid when indexed, so that only one dimension of each returned array is greater than 1. The dimension and number of the output arrays are equal to the number of indexing dimensions. If the step length is not a complex number, then the stop is not inclusive.</source>
          <target state="translated">&lt;code&gt;numpy.lib.index_tricks.nd_grid&lt;/code&gt; 의 인스턴스는 색인을 생성 할 때 열린 (즉, 다듬지 않은) 메시 그리드를 반환하여 반환 된 각 배열의 한 차원 만 1보다 큽니다. 출력 배열의 차원과 수는 같습니다 인덱싱 차원 수 단계 길이가 복소수가 아닌 경우 정지는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3ea316e4ad89d0b127e75fd6f9a3da36dffed3ba" translate="yes" xml:space="preserve">
          <source>An instance of class &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; consists of a contiguous one-dimensional segment of computer memory (owned by the array, or by some other object), combined with an indexing scheme that maps &lt;em&gt;N&lt;/em&gt; integers into the location of an item in the block. The ranges in which the indices can vary is specified by the &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; of the array. How many bytes each item takes and how the bytes are interpreted is defined by the &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt; associated with the array.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스는 &lt;em&gt;N 개의&lt;/em&gt; 정수를 블록의 항목 위치에 매핑하는 인덱싱 체계와 결합 된 컴퓨터 메모리의 연속적인 1 차원 세그먼트 (배열 또는 다른 객체가 소유) 로 구성됩니다. 인덱스가 변할 수있는 범위 는 배열 의 &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 으로 지정됩니다 . 각 항목이 차지하는 바이트 수와 바이트를 해석하는 방법 은 배열과 연관된 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="6e1c5ac8d50b25041dc87f2c7519eb1a86058078" translate="yes" xml:space="preserve">
          <source>An integer array whose elements are indices into the flattened version of an array of dimensions &lt;code&gt;shape&lt;/code&gt;. Before version 1.6.0, this function accepted just one index value.</source>
          <target state="translated">요소가도 지수에 정수 배열 차원 배열의 버전 편평 &lt;code&gt;shape&lt;/code&gt; . 버전 1.6.0 이전에는이 ​​함수가 하나의 인덱스 값만 허용했습니다.</target>
        </trans-unit>
        <trans-unit id="4276a3e1422ad086a54d759953deada7066bbc35" translate="yes" xml:space="preserve">
          <source>An integer as a dimension name freezes that dimension to the value.</source>
          <target state="translated">차원 이름의 정수는 해당 차원을 값으로 고정합니다.</target>
        </trans-unit>
        <trans-unit id="1fa126ddddd0a6a8da1f0e66c4d42624e8184e08" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is &lt;code&gt;None&lt;/code&gt; or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="translated">배열 데이터 영역으로의 정수 오프셋입니다. 데이터가 &lt;code&gt;None&lt;/code&gt; 이거나 &lt;code&gt;buffer&lt;/code&gt; 객체를 반환 할 때만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="208ac298af4fe8503099d4537d939f78fa068387" translate="yes" xml:space="preserve">
          <source>An integer offset into the array data region. This can only be used when data is None or returns a &lt;code&gt;buffer&lt;/code&gt; object.</source>
          <target state="translated">배열 데이터 영역에 대한 정수 오프셋입니다. 데이터가 없음이거나 &lt;code&gt;buffer&lt;/code&gt; 객체를 반환하는 경우에만 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7827031c1e4779ee518d6bbc19386c165a21aa2f" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. &lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="translated">이 배열의 차원 수를 제공하는 정수입니다. nd가 0이면 배열을 종종 순위 -0 배열이라고합니다. 이러한 배열에는 정의되지 않은 차원과 보폭이 있으며 액세스 할 수 없습니다. &lt;a href=&quot;c-api.array#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 는 모든 배열에서 가장 큰 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="98a7f29877575db550ac35bbad96c05eb4cb8962" translate="yes" xml:space="preserve">
          <source>An integer providing the number of dimensions for this array. When nd is 0, the array is sometimes called a rank-0 array. Such arrays have undefined dimensions and strides and cannot be accessed. Macro &lt;a href=&quot;array#c.PyArray_NDIM&quot;&gt;&lt;code&gt;PyArray_NDIM&lt;/code&gt;&lt;/a&gt; defined in &lt;code&gt;ndarraytypes.h&lt;/code&gt; points to this data member. &lt;a href=&quot;array#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; is the largest number of dimensions for any array.</source>
          <target state="translated">이 배열의 차원 수를 제공하는 정수입니다. nd가 0 일 때 배열을 랭크 0 배열이라고도합니다. 이러한 배열에는 정의되지 않은 차원과 보폭이 있으며 액세스 할 수 없습니다. 매크로 &lt;a href=&quot;array#c.PyArray_NDIM&quot;&gt; &lt;code&gt;PyArray_NDIM&lt;/code&gt; 는&lt;/a&gt; 정의 &lt;code&gt;ndarraytypes.h&lt;/code&gt; 이 데이터 부재 포인트. &lt;a href=&quot;array#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 는 모든 어레이의 최대 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="740a8c0291954a1fc0b575bf55fa7f345ee70e49" translate="yes" xml:space="preserve">
          <source>An integer showing the version of the interface (i.e. 3 for this version). Be careful not to use this to invalidate objects exposing future versions of the interface.</source>
          <target state="translated">인터페이스의 버전을 나타내는 정수 (이 버전의 경우 3) 이 인터페이스를 사용하여 이후 버전의 인터페이스를 노출하는 객체를 무효화하지 않도록주의하십시오.</target>
        </trans-unit>
        <trans-unit id="d87fed7bbbc954e477fb70394a40418f3fdbf745" translate="yes" xml:space="preserve">
          <source>An integer, &lt;em&gt;i&lt;/em&gt;, returns the same values as &lt;code&gt;i:i+1&lt;/code&gt;&lt;strong&gt;except&lt;/strong&gt; the dimensionality of the returned object is reduced by 1. In particular, a selection tuple with the &lt;em&gt;p&lt;/em&gt;-th element an integer (and all other entries &lt;code&gt;:&lt;/code&gt;) returns the corresponding sub-array with dimension &lt;em&gt;N - 1&lt;/em&gt;. If &lt;em&gt;N = 1&lt;/em&gt; then the returned object is an array scalar. These objects are explained in &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;Scalars&lt;/a&gt;.</source>
          <target state="translated">정수는 &lt;em&gt;난&lt;/em&gt; 과 동일한 값을 반환 &lt;code&gt;i:i+1&lt;/code&gt; &lt;strong&gt;을 제외하고&lt;/strong&gt; , 특히 (1)에 의해 감소된다 리턴 된 객체의 차원은 함께 선택 튜플 &lt;em&gt;P&lt;/em&gt; 번째의 소자 정수 (모든 다른 항목 &lt;code&gt;:&lt;/code&gt; )를를 반환 &lt;em&gt;N-1&lt;/em&gt; 차원의 해당 하위 배열 . 경우 &lt;em&gt;N = 1로&lt;/em&gt; 한 후 리턴 된 객체는 배열 스칼라이다. 이 객체는 &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;스칼라&lt;/a&gt; 에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="73fd3d8e22c91d0b01a5e0d96a1a194d3f402dd7" translate="yes" xml:space="preserve">
          <source>An introduction to the concepts discussed here</source>
          <target state="translated">여기에서 설명하는 개념에 대한 소개</target>
        </trans-unit>
        <trans-unit id="9337d47802d85cb5aefc4c6ec7749f6fe4d0f859" translate="yes" xml:space="preserve">
          <source>An introduction, with definitions and general explanations.</source>
          <target state="translated">정의 및 일반적인 설명과 함께 소개합니다.</target>
        </trans-unit>
        <trans-unit id="0e55a620091e71a89cb39a3c09fd5cc874040b26" translate="yes" xml:space="preserve">
          <source>An item extracted from an array, &lt;em&gt;e.g.&lt;/em&gt;, by indexing, is represented by a Python object whose type is one of the &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar types&lt;/a&gt; built in NumPy. The array scalars allow easy manipulation of also more complicated arrangements of data.</source>
          <target state="translated">배열에서 추출 된 항목 ( &lt;em&gt;예 :&lt;/em&gt; 인덱싱)은 NumPy에 내장 된 &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;배열 스칼라 유형&lt;/a&gt; 중 하나 인 Python 객체로 표현됩니다 . 배열 스칼라를 사용하면 더 복잡한 데이터 배열도 쉽게 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de99db091c92a4334b9f2bbfb02c196f89f1e72f" translate="yes" xml:space="preserve">
          <source>An iterable object providing data for the array.</source>
          <target state="translated">배열에 대한 데이터를 제공하는 반복 가능한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="c2c683940adaf3e17b5b2d4dbfdc8fb1f9285bc0" translate="yes" xml:space="preserve">
          <source>An masked array with &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt;&lt;code&gt;masked&lt;/code&gt;&lt;/a&gt; elements where the condition is masked, elements from &lt;code&gt;x&lt;/code&gt; where &lt;code&gt;condition&lt;/code&gt; is True, and elements from &lt;code&gt;y&lt;/code&gt; elsewhere.</source>
          <target state="translated">함께 마스크 배열 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.masked&quot;&gt; &lt;code&gt;masked&lt;/code&gt; &lt;/a&gt; 조건이 마스크 요소의 요소 &lt;code&gt;x&lt;/code&gt; &lt;code&gt;condition&lt;/code&gt; 에서 사실이며, 원소 &lt;code&gt;y&lt;/code&gt; 다른.</target>
        </trans-unit>
        <trans-unit id="8ce742f07c8b93ebe9e87ec17c3c1ca6bc05421b" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortan-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="translated">ndarray에는 조작 할 수있는 잘 동작하는 메모리의 단순한 연속 덩어리가 아닌 데이터 세그먼트가있을 수 있습니다. 단어 경계와 정렬되지 않을 수 있습니다 (일부 플랫폼에서는 매우 중요 함). 머신이 인식하는 것과 다른 바이트 순서로 데이터를 가질 수 있습니다. 쓰기 불가능할 수 있습니다. 포텐 연속 순서로되어있을 수 있습니다. 배열 플래그는 배열과 관련된 데이터에 대해 말할 수있는 것을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bb779643bca7bbe52a88ddd4236e7e3d90ebda9e" translate="yes" xml:space="preserve">
          <source>An ndarray can have a data segment that is not a simple contiguous chunk of well-behaved memory you can manipulate. It may not be aligned with word boundaries (very important on some platforms). It might have its data in a different byte-order than the machine recognizes. It might not be writeable. It might be in Fortran-contiguous order. The array flags are used to indicate what can be said about data associated with an array.</source>
          <target state="translated">ndarray는 조작 할 수있는 잘 작동하는 메모리의 단순 연속 청크가 아닌 데이터 세그먼트를 가질 수 있습니다. 단어 경계와 일치하지 않을 수 있습니다 (일부 플랫폼에서는 매우 중요 함). 기계가 인식하는 것과 다른 바이트 순서로 데이터를 가질 수 있습니다. 쓰기가 불가능할 수 있습니다. 포트란 연속 순서 일 수 있습니다. 배열 플래그는 배열과 관련된 데이터에 대해 말할 수있는 내용을 나타내는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84038cf3f95c6f7f876de572eb50dcdd65ebb4e5" translate="yes" xml:space="preserve">
          <source>An ndarray containing the absolute value of each element in &lt;code&gt;x&lt;/code&gt;. For complex input, &lt;code&gt;a + ib&lt;/code&gt;, the absolute value is</source>
          <target state="translated">각 요소의 절대 값을 포함하는 ndarray &lt;code&gt;x&lt;/code&gt; . 복잡한 입력 &lt;code&gt;a + ib&lt;/code&gt; 의 경우 절대 값은</target>
        </trans-unit>
        <trans-unit id="937ff1e9853b1d8bb7896ced9c9a3c640f4a20fd" translate="yes" xml:space="preserve">
          <source>An ndarray of appropriate shape and dtype, filled with False.</source>
          <target state="translated">False로 채워진 적절한 모양과 dtype의 ndarray.</target>
        </trans-unit>
        <trans-unit id="a5ee74273207da7ae537266764fb0a696c970cac" translate="yes" xml:space="preserve">
          <source>An nditer for each item in &lt;code&gt;axes&lt;/code&gt;, outermost first</source>
          <target state="translated">&lt;code&gt;axes&lt;/code&gt; 각 항목에 대한 nditer ( 가장 바깥 쪽)</target>
        </trans-unit>
        <trans-unit id="d7605eba941666733600a4275983300b4a00400c" translate="yes" xml:space="preserve">
          <source>An ndpointer instance is used to describe an ndarray in restypes and argtypes specifications. This approach is more flexible than using, for example, &lt;code&gt;POINTER(c_double)&lt;/code&gt;, since several restrictions can be specified, which are verified upon calling the ctypes function. These include data type, number of dimensions, shape and flags. If a given array does not satisfy the specified restrictions, a &lt;code&gt;TypeError&lt;/code&gt; is raised.</source>
          <target state="translated">ndpointer 인스턴스는 restypes 및 argtypes 사양에서 ndarray를 설명하는 데 사용됩니다. 이 접근법은 예를 들어 &lt;code&gt;POINTER(c_double)&lt;/code&gt; 보다 유연 합니다. ctypes 함수를 호출 할 때 확인되는 몇 가지 제한 사항을 지정할 수 있기 때문입니다. 여기에는 데이터 유형, 차원 수, 모양 및 플래그가 포함됩니다. 지정된 배열이 지정된 제한을 만족하지 않으면 &lt;code&gt;TypeError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="7417872fe9adc5a45fba54aa51c9ae05347385d3" translate="yes" xml:space="preserve">
          <source>An object representing &lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;numpy.number&lt;/code&gt;&lt;/a&gt; precision during static type checking.</source>
          <target state="translated">정적 유형 검사 중 &lt;a href=&quot;arrays.scalars#numpy.number&quot;&gt; &lt;code&gt;numpy.number&lt;/code&gt; &lt;/a&gt; 정밀도를 나타내는 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="8249a78054c0cb82583f75cad623801b99c6e816" translate="yes" xml:space="preserve">
          <source>An object that can be passed as an argument to the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; constructor to create the array&amp;rsquo;s dtype.</source>
          <target state="translated">배열의 dtype을 만들기 위해 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt; 생성자에 인수로 전달할 수있는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="51b070f54d715dc3c886991b214975d29e065cb3" translate="yes" xml:space="preserve">
          <source>An object that can be queried for it&amp;rsquo;s numeric type.</source>
          <target state="translated">쿼리 할 수있는 개체는 숫자 형식입니다.</target>
        </trans-unit>
        <trans-unit id="cb7089d647c1b86db71967874a04b75f15c4139e" translate="yes" xml:space="preserve">
          <source>An object that cannot be modified after execution is called immutable. Two common examples are strings and tuples.</source>
          <target state="translated">실행 후 수정할 수없는 개체를 불변이라고합니다. 두 가지 일반적인 예는 문자열과 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="757fdfd1c89cb8f173de4247aa51861595590920" translate="yes" xml:space="preserve">
          <source>An object that exposes the buffer interface.</source>
          <target state="translated">버퍼 인터페이스를 노출하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="9aa10d88b8c5173358367cce862fb4a6d6fc0051" translate="yes" xml:space="preserve">
          <source>An object that specifies a custom set of valid days.</source>
          <target state="translated">유효한 일의 사용자 지정 집합을 지정하는 개체입니다.</target>
        </trans-unit>
        <trans-unit id="9697eabfa36a0c57b03730a9e63e9c0dd7cc2d09" translate="yes" xml:space="preserve">
          <source>An object to simplify the interaction of the array with the ctypes module.</source>
          <target state="translated">ctypes 모듈과 배열의 상호 작용을 단순화하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="77d04ad5d02d58a854d2c57fda919f98926805a2" translate="yes" xml:space="preserve">
          <source>An offset can be passed also to the masking function. This gets us the indices starting on the first diagonal right of the main one:</source>
          <target state="translated">마스킹 기능에도 오프셋을 전달할 수 있습니다. 이를 통해 주 인덱스의 첫 번째 대각선 오른쪽에서 시작하는 인덱스를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e7bb40a65a5fed271af7ea895f0c3a327894df3e" translate="yes" xml:space="preserve">
          <source>An open file object, or a string containing a filename.</source>
          <target state="translated">열린 파일 객체 또는 파일 이름이 포함 된 문자열</target>
        </trans-unit>
        <trans-unit id="d961e30e446f529b34e65541eef1f1abf1c657fc" translate="yes" xml:space="preserve">
          <source>An operation &lt;code&gt;along axis n&lt;/code&gt; of array &lt;code&gt;a&lt;/code&gt; behaves as if its argument were an array of slices of &lt;code&gt;a&lt;/code&gt; where each slice has a successive index of axis &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 의 &lt;code&gt;along axis n&lt;/code&gt; 을 따른 연산 은 인수가 &lt;code&gt;a&lt;/code&gt; 의 슬라이스 배열 인 것처럼 동작하며 , 여기서 각 슬라이스는 축 &lt;code&gt;n&lt;/code&gt; 의 연속 인덱스를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="fe21301c43ae5617db256d71e7099b9d072912c3" translate="yes" xml:space="preserve">
          <source>An operator that transforms a function. For example, a &lt;code&gt;log&lt;/code&gt; decorator may be defined to print debugging information upon function execution:</source>
          <target state="translated">함수를 변환하는 연산자입니다. 예를 들어, 함수 실행시 디버깅 정보를 인쇄 하도록 &lt;code&gt;log&lt;/code&gt; 데코레이터를 정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c61177b92fd6e93436d3f1589cdd0e84373a28c0" translate="yes" xml:space="preserve">
          <source>An optional argument which is passed through to &lt;code&gt;mask_func&lt;/code&gt;. Functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; take a second argument that is interpreted as an offset.</source>
          <target state="translated">&lt;code&gt;mask_func&lt;/code&gt; 로 전달되는 선택적 인수입니다 . 같은 기능 &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; 는&lt;/a&gt; , &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; 오프셋으로 해석됩니다 두 번째 인수를.</target>
        </trans-unit>
        <trans-unit id="6ed67195e81edd8b8281aeaf900064fe84cfec71" translate="yes" xml:space="preserve">
          <source>An optional section detailing which errors get raised and under what conditions:</source>
          <target state="translated">어떤 오류가 발생하고 어떤 조건에서 발생하는지 자세히 설명하는 선택적 섹션 :</target>
        </trans-unit>
        <trans-unit id="1ae26e0d878e399f66a265f5cebede9ebffc3136" translate="yes" xml:space="preserve">
          <source>An optional section detailing which warnings get raised and under what conditions, formatted similarly to Raises.</source>
          <target state="translated">Raises와 유사한 형식으로 어떤 경고가 발생하고 어떤 조건에서 발생하는지 자세히 설명하는 선택적 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="391f6511a38216160a18b8a442ab41f825e0e811" translate="yes" xml:space="preserve">
          <source>An optional section for examples, using the &lt;a href=&quot;http://docs.python.org/library/doctest.html&quot;&gt;doctest&lt;/a&gt; format. This section is meant to illustrate usage, not to provide a testing framework &amp;ndash; for that, use the &lt;code&gt;tests/&lt;/code&gt; directory. While optional, this section is very strongly encouraged.</source>
          <target state="translated">&lt;a href=&quot;http://docs.python.org/library/doctest.html&quot;&gt;doctest&lt;/a&gt; 형식을 사용하는 예제에 대한 선택적 섹션입니다 . 이 섹션은 테스트 프레임 워크를 제공하는 것이 아니라 사용법을 설명하기위한 것입니다.이를 위해서는 &lt;code&gt;tests/&lt;/code&gt; 디렉토리를 사용하십시오 . 선택 사항이지만이 섹션은 매우 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="366365808b8b78b0df47b3f2fa0f2ced248b85eb" translate="yes" xml:space="preserve">
          <source>An optional section that provides additional information about the code, possibly including a discussion of the algorithm. This section may include mathematical equations, written in &lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt; format:</source>
          <target state="translated">알고리즘에 대한 설명을 포함하여 코드에 대한 추가 정보를 제공하는 선택적 섹션입니다. 이 섹션에는 &lt;a href=&quot;http://www.latex-project.org/&quot;&gt;LaTeX&lt;/a&gt; 형식으로 작성된 수학 방정식이 포함될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9a2c98cd19c30e91e6748b44b5303643381a459b" translate="yes" xml:space="preserve">
          <source>An optional section used to describe infrequently used parameters. It should only be used if a function has a large number of keyword parameters, to prevent cluttering the &lt;strong&gt;Parameters&lt;/strong&gt; section.</source>
          <target state="translated">자주 사용하지 않는 매개 변수를 설명하는 데 사용되는 선택적 섹션입니다. &lt;strong&gt;매개 변수&lt;/strong&gt; 섹션이 복잡 해지는 것을 방지하기 위해 함수에 많은 수의 키워드 매개 변수가있는 경우에만 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="9abef9ce470f7fb03808979a319d66414811663e" translate="yes" xml:space="preserve">
          <source>An optional section used to refer to related code. This section can be very useful, but should be used judiciously. The goal is to direct users to other functions they may not be aware of, or have easy means of discovering (by looking at the module docstring, for example). Routines whose docstrings further explain parameters used by this function are good candidates.</source>
          <target state="translated">관련 코드를 참조하는 데 사용되는 선택적 섹션입니다. 이 섹션은 매우 유용 할 수 있지만 신중하게 사용해야합니다. 목표는 사용자가 알지 못하거나 쉽게 발견 할 수있는 다른 기능으로 사용자를 안내하는 것입니다 (예를 들어 모듈 독 스트링을 살펴봄으로써). 독 스트링이이 함수에서 사용하는 매개 변수를 자세히 설명하는 루틴이 좋은 후보입니다.</target>
        </trans-unit>
        <trans-unit id="163026d9f814b206fafab6b479ab36888cccfde6" translate="yes" xml:space="preserve">
          <source>An optional section with cautions to the user in free text/reST.</source>
          <target state="translated">자유 텍스트 / reST에서 사용자에게주의를 기울이는 선택적 섹션입니다.</target>
        </trans-unit>
        <trans-unit id="1965c219b7008fe9d099c530f609263a14ec3ab8" translate="yes" xml:space="preserve">
          <source>An optional shape tuple providing how many times this part of the structure should be repeated. No repeats are assumed if this is not given. Very complicated structures can be described using this generic interface. Notice, however, that each element of the array is still of the same data-type. Some examples of using this interface are given below.</source>
          <target state="translated">구조의이 부분을 몇 번 반복해야하는지 선택적인 형태 튜플. 이것이 주어지지 않으면 반복이 가정되지 않습니다. 이 일반 인터페이스를 사용하여 매우 복잡한 구조를 설명 할 수 있습니다. 그러나 배열의 각 요소는 여전히 동일한 데이터 유형입니다. 이 인터페이스를 사용하는 몇 가지 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="53899654d34ff89eb71076f6e6bc7701229a1b68" translate="yes" xml:space="preserve">
          <source>An order as close to the order of the inputs as possible, even if the input is in neither C nor Fortran order.</source>
          <target state="translated">입력이 C 또는 포트란 순서가 아닌 경우에도 입력 순서와 최대한 비슷한 순서입니다.</target>
        </trans-unit>
        <trans-unit id="62dbe9a66cb25d1e5f12073cb6b65d7c95221376" translate="yes" xml:space="preserve">
          <source>An ordered tuple of field names. It is NULL if no field is defined.</source>
          <target state="translated">정렬 된 필드 이름의 튜플. 필드가 정의되어 있지 않으면 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="b28a1d46b1f9296ef3b935989580ffec6bc90e2b" translate="yes" xml:space="preserve">
          <source>And even an array that contains a range of evenly spaced intervals. To do this, you will specify the &lt;strong&gt;first number&lt;/strong&gt;, &lt;strong&gt;last number&lt;/strong&gt;, and the &lt;strong&gt;step size&lt;/strong&gt;.</source>
          <target state="translated">그리고 균등 한 간격의 범위를 포함하는 배열도 있습니다. 이렇게하려면 &lt;strong&gt;첫 번째 숫자&lt;/strong&gt; , &lt;strong&gt;마지막 숫자&lt;/strong&gt; 및 &lt;strong&gt;단계 크기를 지정&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="3fba956825020587f9a5a64e281c04047de223ea" translate="yes" xml:space="preserve">
          <source>And even use a Greek symbol like</source>
          <target state="translated">그리고 같은 그리스 기호를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d209b0782b74a22172d98886be624cfb54a8889a" translate="yes" xml:space="preserve">
          <source>And finally, we build the extension module by running</source>
          <target state="translated">마지막으로 다음을 실행하여 확장 모듈을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="43728498911f9a35c7cfcd97027ee53c73e05582" translate="yes" xml:space="preserve">
          <source>And for assigning values:</source>
          <target state="translated">그리고 값을 할당하기 위해 :</target>
        </trans-unit>
        <trans-unit id="4fb83d7408641f0a8ebf4e9525e3b469b9150326" translate="yes" xml:space="preserve">
          <source>And here are the time units:</source>
          <target state="translated">시간 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1b699ec82ab8d002ac2193762454ef347af6a2da" translate="yes" xml:space="preserve">
          <source>And in more detail:</source>
          <target state="translated">그리고 더 자세하게 :</target>
        </trans-unit>
        <trans-unit id="de07ee02fee2070e061118495013c58fef8e83bb" translate="yes" xml:space="preserve">
          <source>And make sure the &lt;code&gt;VERSION&lt;/code&gt; variable is set properly.</source>
          <target state="translated">그리고 &lt;code&gt;VERSION&lt;/code&gt; 변수가 올바르게 설정되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4ee8deafdefbce6d1b2807fd39f58eb30f617552" translate="yes" xml:space="preserve">
          <source>And read your CSV with:</source>
          <target state="translated">다음을 사용하여 CSV를 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="750b2a038f3915c181ab3d5361e664ccd43727d0" translate="yes" xml:space="preserve">
          <source>And then in the debugger:</source>
          <target state="translated">그리고 디버거에서 :</target>
        </trans-unit>
        <trans-unit id="021c9202efccb926bf8e315a46e72fcbd7af5307" translate="yes" xml:space="preserve">
          <source>And to find the shape of your array, run:</source>
          <target state="translated">배열의 모양을 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="d96cb503f931b03fd273a49b170890809399fc62" translate="yes" xml:space="preserve">
          <source>And use it to set the diagonal of an array of zeros to 1:</source>
          <target state="translated">그리고 이것을 사용하여 0의 배열의 대각선을 1로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="240ae7e192fffb9c12f05d721f8aebdc4754f4de" translate="yes" xml:space="preserve">
          <source>Angle in radians.</source>
          <target state="translated">라디안 각도.</target>
        </trans-unit>
        <trans-unit id="0184757264cf635f3a2e2e908775a586af284275" translate="yes" xml:space="preserve">
          <source>Angle, in radians (</source>
          <target state="translated">라디안 단위 각도 (</target>
        </trans-unit>
        <trans-unit id="531138e549dac342fe270e2699b3c5521bbf5ec8" translate="yes" xml:space="preserve">
          <source>Angles in degrees.</source>
          <target state="translated">각도 (도)입니다.</target>
        </trans-unit>
        <trans-unit id="dfa37c7c185a546b145b8e12c452f16dbc48d7fc" translate="yes" xml:space="preserve">
          <source>Anirudh Subramanian</source>
          <target state="translated">아니 루드 수 브라마 니안</target>
        </trans-unit>
        <trans-unit id="1108804921f7fa74ee3f663d12f9acdb0f17609b" translate="yes" xml:space="preserve">
          <source>Announce the release on scipy.org</source>
          <target state="translated">scipy.org에서 릴리스 발표</target>
        </trans-unit>
        <trans-unit id="9e0f71af0703a17a0fe77843a34b501f25db1f87" translate="yes" xml:space="preserve">
          <source>Announce to Linux Weekly News</source>
          <target state="translated">Linux Weekly News에 발표</target>
        </trans-unit>
        <trans-unit id="542e50fbd0847e1465192e2a2bd9c3cc0e292cfc" translate="yes" xml:space="preserve">
          <source>Announce to mailing lists</source>
          <target state="translated">메일 링리스트에 알림</target>
        </trans-unit>
        <trans-unit id="ccc7a7a2cec9dbb01f44b9fb7e6acf4fd9b1506f" translate="yes" xml:space="preserve">
          <source>Announce to the lists</source>
          <target state="translated">목록에 발표</target>
        </trans-unit>
        <trans-unit id="3b4dde3e14d997b719c29d0bbd6c5103efadda68" translate="yes" xml:space="preserve">
          <source>Another common separator is &lt;code&gt;&quot;\t&quot;&lt;/code&gt;, the tabulation character. However, we are not limited to a single character, any string will do. By default, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; assumes &lt;code&gt;delimiter=None&lt;/code&gt;, meaning that the line is split along white spaces (including tabs) and that consecutive white spaces are considered as a single white space.</source>
          <target state="translated">또 다른 일반적인 구분 기호는 표 문자 인 &lt;code&gt;&quot;\t&quot;&lt;/code&gt; 입니다. 그러나 우리는 단일 문자로 제한되지 않으며 모든 문자열이 가능합니다. 기본적으로 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;delimiter=None&lt;/code&gt; 을 가정합니다. 즉, 행이 공백 (탭 포함)을 따라 분할되고 연속 공백은 단일 공백으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="dfdf42a70a6f5e3b9eb4a7a9d5fd5b3a5e3c028d" translate="yes" xml:space="preserve">
          <source>Another common use of indexing with arrays is the search of the maximum value of time-dependent series:</source>
          <target state="translated">배열을 사용한 인덱싱의 또 다른 일반적인 용도는 시간 종속 계열의 최대 값을 검색하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="4043a7e9def49f8cd15e6e1c3c67b85fcd702c3b" translate="yes" xml:space="preserve">
          <source>Another difference with the standard ndarray of str data-type is that the chararray inherits the feature introduced by Numarray that white-space at the end of any element in the array will be ignored on item retrieval and comparison operations.</source>
          <target state="translated">str 데이터 유형의 표준 ndarray와의 또 다른 차이점은 chararray가 Numarray에 의해 도입 된 기능을 상속한다는 점입니다. 배열의 모든 요소 끝에있는 공백은 항목 검색 및 비교 작업에서 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="5dcd2747e1a6d1d5aac68e7e1ee2b04c96abcc9c" translate="yes" xml:space="preserve">
          <source>Another example is the function &lt;code&gt;inner1d(a, b)&lt;/code&gt; with a signature of &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;. This applies the inner product along the last axis of each input, but keeps the remaining indices intact. For example, where &lt;code&gt;a&lt;/code&gt; is of shape &lt;code&gt;(3, 5, N)&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is of shape &lt;code&gt;(5, N)&lt;/code&gt;, this will return an output of shape &lt;code&gt;(3,5)&lt;/code&gt;. The underlying elementary function is called &lt;code&gt;3 * 5&lt;/code&gt; times. In the signature, we specify one core dimension &lt;code&gt;(i)&lt;/code&gt; for each input and zero core dimensions &lt;code&gt;()&lt;/code&gt; for the output, since it takes two 1-d arrays and returns a scalar. By using the same name &lt;code&gt;i&lt;/code&gt;, we specify that the two corresponding dimensions should be of the same size.</source>
          <target state="translated">또 다른 예는 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 서명 이있는 &lt;code&gt;inner1d(a, b)&lt;/code&gt; 함수 입니다. 이는 각 입력의 마지막 축을 따라 내부 제품을 적용하지만 나머지 인덱스는 그대로 유지합니다. 예를 들어, &lt;code&gt;a&lt;/code&gt; 의 모양이 &lt;code&gt;(3, 5, N)&lt;/code&gt; 이고 &lt;code&gt;b&lt;/code&gt; 의 모양이 &lt;code&gt;(5, N)&lt;/code&gt; 인 경우 모양 &lt;code&gt;(3,5)&lt;/code&gt; 의 출력을 반환합니다 . 기본 초등학교 기능은 &lt;code&gt;3 * 5&lt;/code&gt; 번 이라고 합니다. 시그니처에서는 각 입력에 대해 하나의 코어 차원 &lt;code&gt;(i)&lt;/code&gt; 을 지정 하고 출력에 대해 0 개의 코어 차원 &lt;code&gt;()&lt;/code&gt; 을 지정합니다. 두 개의 1 차원 배열을 취하고 스칼라를 반환하기 때문입니다. 같은 이름을 사용하여 &lt;code&gt;i&lt;/code&gt; 두 개의 해당 치수가 동일한 크기 여야한다고 지정합니다.</target>
        </trans-unit>
        <trans-unit id="90bf0b9c455b04ca91edfdb12178ac251d5b7ad5" translate="yes" xml:space="preserve">
          <source>Another frequently asked question is &amp;ldquo;How do I debug C code inside NumPy?&amp;rdquo;. First, ensure that you have gdb installed on your system with the Python extensions (often the default on Linux). You can see which version of Python is running inside gdb to verify your setup:</source>
          <target state="translated">또 다른 자주 묻는 질문은 &quot;NumPy 내부에서 C 코드를 어떻게 디버깅합니까?&quot;입니다. 먼저 Python 확장 (일반적으로 Linux에서 기본값)을 사용하여 시스템에 gdb가 설치되어 있는지 확인합니다. 설정을 확인하기 위해 gdb 내에서 실행중인 Python 버전을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0c72feff7651c1b9feda841c49b58c2d454b80e" translate="yes" xml:space="preserve">
          <source>Another important role played by deprecation markings in the C API is to move towards hiding internal details of the NumPy implementation. For those needing direct, easy, access to the data of ndarrays, this will not remove this ability. Rather, there are many potential performance optimizations which require changing the implementation details, and NumPy developers have been unable to try them because of the high value of preserving ABI compatibility. By deprecating this direct access, we will in the future be able to improve NumPy&amp;rsquo;s performance in ways we cannot presently.</source>
          <target state="translated">C API에서 더 이상 사용되지 않는 표시로 수행되는 또 다른 중요한 역할은 NumPy 구현의 내부 세부 사항을 숨기는 것입니다. ndarrays 데이터에 직접 쉽고 쉽게 액세스해야하는 사람들에게는이 기능이 제거되지 않습니다. 그보다는 구현 세부 사항을 변경해야하는 잠재적 인 성능 최적화가 많이 있으며 NumPy 개발자는 ABI 호환성을 보존하는 높은 가치로 인해이를 시도 할 수 없었습니다. 이 직접 액세스를 사용하지 않으면 앞으로 현재로서는 불가능한 방식으로 NumPy의 성능을 향상시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a86afb1ef0a04254ac219408ffb94437b02ea319" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="translated">또 다른 방법은 &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt; 를 사용 하여 상태를 그대로 진행하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="91143b613b806bdad96301f98bc353e17238828f" translate="yes" xml:space="preserve">
          <source>Another method is to use &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; which advances the state as-if</source>
          <target state="translated">또 다른 방법은 상태를 그대로 &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt; 하는 MT19937.jumped 를 사용 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="0fd6c16778a959995e7dc3e9960a7fccd4bf7af0" translate="yes" xml:space="preserve">
          <source>Another possibility is to use the &lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt;&lt;code&gt;getmask&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt;&lt;code&gt;getmaskarray&lt;/code&gt;&lt;/a&gt; functions. &lt;code&gt;getmask(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array, and the special value &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; otherwise. &lt;code&gt;getmaskarray(x)&lt;/code&gt; outputs the mask of &lt;code&gt;x&lt;/code&gt; if &lt;code&gt;x&lt;/code&gt; is a masked array. If &lt;code&gt;x&lt;/code&gt; has no invalid entry or is not a masked array, the function outputs a boolean array of &lt;code&gt;False&lt;/code&gt; with as many elements as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">또 다른 가능성은 &lt;a href=&quot;generated/numpy.ma.getmask#numpy.ma.getmask&quot;&gt; &lt;code&gt;getmask&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.ma.getmaskarray#numpy.ma.getmaskarray&quot;&gt; &lt;code&gt;getmaskarray&lt;/code&gt; &lt;/a&gt; 함수 를 사용하는 것 입니다. &lt;code&gt;getmask(x)&lt;/code&gt; 의 출력 마스크 &lt;code&gt;x&lt;/code&gt; 하는 경우 &lt;code&gt;x&lt;/code&gt; 마스킹 된 배열, 그리고 특별 값 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 그렇지. &lt;code&gt;x&lt;/code&gt; 가 마스크 된 배열 인 경우 &lt;code&gt;getmaskarray(x)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 마스크를 출력합니다 . 경우 &lt;code&gt;x&lt;/code&gt; 유효하지 않은 엔트리가 없거나 마스크 배열이 아닌 함수가 부울 어레이 출력 &lt;code&gt;False&lt;/code&gt; 많은 요소와 같은 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8f5707c41037b98d07b3655f44a00e7754af32b" translate="yes" xml:space="preserve">
          <source>Another simpler possibility is to use the &lt;code&gt;names&lt;/code&gt; keyword with a sequence of strings or a comma-separated string:</source>
          <target state="translated">또 다른 간단한 방법은 문자열 시퀀스 또는 쉼표로 구분 된 문자열과 함께 &lt;code&gt;names&lt;/code&gt; 키워드 를 사용하는 것입니다 .</target>
        </trans-unit>
        <trans-unit id="bb96c2d76983849aa396fb78c96e7b20143386c1" translate="yes" xml:space="preserve">
          <source>Another somewhat outdated MATLAB/NumPy cross-reference can be found at &lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;http://mathesaurus.sf.net/&lt;/a&gt;</source>
          <target state="translated">다소 오래된 또 다른 MATLAB / NumPy 상호 참조는 &lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;http://mathesaurus.sf.net/&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b047c7f58df9c5865a2b74a6710b7b1e5f19d15" translate="yes" xml:space="preserve">
          <source>Another term for &lt;a href=&quot;#term-advanced-indexing&quot;&gt;advanced indexing&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#term-advanced-indexing&quot;&gt;고급 인덱싱에&lt;/a&gt; 대한 또 다른 용어입니다 .</target>
        </trans-unit>
        <trans-unit id="28a695f570d8eedee37a6873f1169fc8ffe3e272" translate="yes" xml:space="preserve">
          <source>Another term for an array dimension. Axes are numbered left to right; axis 0 is the first element in the shape tuple.</source>
          <target state="translated">배열 차원에 대한 또 다른 용어입니다. 축은 왼쪽에서 오른쪽으로 번호가 매겨집니다. 축 0은 모양 튜플의 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="05af7d96a4421569602af070d1f51ae85302570e" translate="yes" xml:space="preserve">
          <source>Another use of this flag is for setting up reduction operations. After the iterator is created, and a reduction output is allocated automatically by the iterator (be sure to use READWRITE access), its value may be initialized to the reduction unit. Use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get the object. Then, call &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt;&lt;code&gt;NpyIter_Reset&lt;/code&gt;&lt;/a&gt; to allocate and fill the buffers with their initial values.</source>
          <target state="translated">이 플래그의 다른 용도는 축소 작업을 설정하는 것입니다. 이터레이터가 생성되고 이터레이터가 축소 출력을 자동으로 할당 한 후에는 (READWRITE 액세스를 사용해야 함) 해당 값이 축소 장치로 초기화 될 수 있습니다. &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; 를 사용 하여 개체를 가져옵니다. 그런 다음 &lt;a href=&quot;#c.NpyIter_Reset&quot;&gt; &lt;code&gt;NpyIter_Reset&lt;/code&gt; &lt;/a&gt; 을 호출 하여 버퍼를 초기 값으로 할당하고 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="1273c53271563cf36a39aab59fe3df9f43442e63" translate="yes" xml:space="preserve">
          <source>Another way to represent the determinant, more suitable for large matrices where underflow/overflow may occur.</source>
          <target state="translated">언더 플로 / 오버플로가 발생할 수있는 큰 행렬에 더 적합한 결정자를 나타내는 다른 방법입니다.</target>
        </trans-unit>
        <trans-unit id="4a9a549b7d1a971f20baf0bc7c2890ecc79e2921" translate="yes" xml:space="preserve">
          <source>Another way to retrieve the valid data is to use the &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; method, which returns a one-dimensional &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; (or one of its subclasses, depending on the value of the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt;&lt;code&gt;baseclass&lt;/code&gt;&lt;/a&gt; attribute):</source>
          <target state="translated">유효 데이터를 검색하기위한 다른 방법은 사용하는 &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt; 일차원 반환 방법 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 을&lt;/a&gt; (의 값에 따라, 또는 그 하위 클래스 중 하나 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.baseclass&quot;&gt; &lt;code&gt;baseclass&lt;/code&gt; &lt;/a&gt; 속성) :</target>
        </trans-unit>
        <trans-unit id="4c793b7f96dc3a05a24bc874af2795d6270941c5" translate="yes" xml:space="preserve">
          <source>Anti-derivative of a polynomial.</source>
          <target state="translated">다항식의 파생 방지.</target>
        </trans-unit>
        <trans-unit id="253f5b3f24b2fd1c0fc450339280f5eb6eb4f07c" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;reference/arrays.scalars&quot;&gt;scalar&lt;/a&gt; or &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-sequence&quot;&gt;sequence&lt;/a&gt; that can be interpreted as an ndarray. In addition to ndarrays and scalars this category includes lists (possibly nested and with different element types) and tuples. Any argument accepted by &lt;a href=&quot;reference/generated/numpy.array&quot;&gt;numpy.array&lt;/a&gt; is array_like.</source>
          <target state="translated">ndarray로 해석 될 수있는 모든 &lt;a href=&quot;reference/arrays.scalars&quot;&gt;스칼라&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-sequence&quot;&gt;시퀀스&lt;/a&gt; 입니다. ndarray 및 스칼라 외에도이 범주에는 목록 (중첩 및 다른 요소 유형 포함) 및 튜플이 포함됩니다. &lt;a href=&quot;reference/generated/numpy.array&quot;&gt;numpy.array에서&lt;/a&gt; 허용하는 모든 인수 는 array_like입니다.</target>
        </trans-unit>
        <trans-unit id="6711bfd3b820f62c39c4d88fd0c62299f5e94371" translate="yes" xml:space="preserve">
          <source>Any Python object.</source>
          <target state="translated">모든 Python 객체.</target>
        </trans-unit>
        <trans-unit id="a193823ba578f9f1e7b81264ee2c1d9779647da7" translate="yes" xml:space="preserve">
          <source>Any Python object:</source>
          <target state="translated">모든 파이썬 객체 :</target>
        </trans-unit>
        <trans-unit id="58e444efe77e462bb342fdd66c1b5f6f6487f4f4" translate="yes" xml:space="preserve">
          <source>Any binary operation can be extended to an array operation in an outer product fashion like in &lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt;&lt;code&gt;outer&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides a way to accomplish this by explicitly mapping the axes of the operands. It is also possible to do this with &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; indexing, but we will show you how to directly use the nditer &lt;code&gt;op_axes&lt;/code&gt; parameter to accomplish this with no intermediate views.</source>
          <target state="translated">이진 동작처럼 외적 형태로 배열 동작으로 확장 될 수있는 &lt;a href=&quot;generated/numpy.outer#numpy.outer&quot;&gt; &lt;code&gt;outer&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 개체를 명시 적 피연산자의 축 매핑함으로써이를 달성 할 수있는 방법을 제공한다. &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 인덱싱을 사용 하여이 작업 을 수행 할 수도 있지만 nditer &lt;code&gt;op_axes&lt;/code&gt; 매개 변수를 직접 사용하여 중간 뷰없이이를 수행 하는 방법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="df3387b9c652aaab79f08e9bac190d701d99f2f6" translate="yes" xml:space="preserve">
          <source>Any class or type can define this method which should take an ndarray argument and return an instance of the type. It can be seen as the opposite of the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method. This method is used by the ufuncs (and other NumPy functions) to allow other objects to pass through. For Python &amp;gt;2.4, it can also be used to write a decorator that converts a function that works only with ndarrays to one that works with any type with &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">모든 클래스 또는 유형은 ndarray 인수를 취하고 유형의 인스턴스를 리턴해야하는이 메소드를 정의 할 수 있습니다. &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 메서드 의 반대로 볼 수 있습니다 . 이 메서드는 ufuncs (및 기타 NumPy 함수)에서 다른 개체가 통과 할 수 있도록하는 데 사용됩니다. Python 2.4 이상인 경우 ndarray에서만 작동하는 함수를 &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 메서드를 사용하는 모든 유형에서 작동하는 함수로 변환하는 데코레이터를 작성하는 데 사용할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10078c28a66a73c575c275e6dbad2ad1c3448ead" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt; in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="translated">ndarray 서브 클래스 여부에 관계없이 모든 클래스 는 NumPy의 ufuncs 동작을 무시하기 위해이 메소드를 정의하거나 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 으로 설정할 수 있습니다. 이것은 파이썬의 &lt;code&gt;__mul__&lt;/code&gt; 및 기타 이진 연산 루틴과 매우 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="615fb1d9086b422643eac8df92cc3c45b3d4452a" translate="yes" xml:space="preserve">
          <source>Any class, ndarray subclass or not, can define this method or set it to None in order to override the behavior of NumPy&amp;rsquo;s ufuncs. This works quite similarly to Python&amp;rsquo;s &lt;code&gt;__mul__&lt;/code&gt; and other binary operation routines.</source>
          <target state="translated">ndarray 하위 클래스이든 아니든 모든 클래스는이 메서드를 정의하거나 NumPy의 ufunc 동작을 재정의하기 위해 None으로 설정할 수 있습니다. 이것은 Python의 &lt;code&gt;__mul__&lt;/code&gt; 및 기타 이진 연산 루틴과 매우 유사하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f4c392144526317c8f8ed6b5a13470ac5e7a3986" translate="yes" xml:space="preserve">
          <source>Any combination of N scalars/arrays with the meaning of 2. and 3.</source>
          <target state="translated">N 스칼라 / 배열의 의미가 2와 3의 조합</target>
        </trans-unit>
        <trans-unit id="7e81367c0096f8373d0b6f4554ea3cc6aafb3c68" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="translated">메모리를 해석하는 데 사용해야하는 모든 데이터 플래그 ( &lt;em&gt;예 : &lt;/em&gt;&lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="299b31e220e37372f3e91f15af6702628188b111" translate="yes" xml:space="preserve">
          <source>Any data flags (&lt;em&gt;e.g.&lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; ) that should be used to interpret the memory.</source>
          <target state="translated">메모리를 해석하는 데 사용해야하는 모든 데이터 플래그 ( &lt;em&gt;예 : &lt;/em&gt;&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d26a90b0973e9f5339ce6764ce63dbf7b59a3e02" translate="yes" xml:space="preserve">
          <source>Any data saved to the file is appended to the end of the file.</source>
          <target state="translated">파일에 저장된 모든 데이터는 파일 끝에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="5d0107d5bdb46b9143c29ff9e836efde601fe340" translate="yes" xml:space="preserve">
          <source>Any dynamically allocated memory. Currently, this is used for dynamic ufuncs created from a python function to store room for the types, data, and name members.</source>
          <target state="translated">동적으로 할당 된 메모리 현재, 이것은 파이썬 함수에서 생성 된 동적 ufunc에 사용되어 형식, 데이터 및 이름 멤버를위한 공간을 저장합니다.</target>
        </trans-unit>
        <trans-unit id="f1796623bc2027a8a0877fb0e869c4d3c3990d76" translate="yes" xml:space="preserve">
          <source>Any further arguments given to &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, 1, 'a')&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; 에&lt;/a&gt; 지정된 추가 인수 는 실행시 함수에 전달됩니다. 즉 &lt;code&gt;piecewise(..., ..., 1, 'a')&lt;/code&gt; 이면 각 함수는 &lt;code&gt;f(x, 1, 'a')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd7c425a186534062ca5afb654fb680173c25d5" translate="yes" xml:space="preserve">
          <source>Any keyword arguments the function requires.</source>
          <target state="translated">함수에 필요한 키워드 인수</target>
        </trans-unit>
        <trans-unit id="487737106c5cb105d4cc96a9c1768d045f864529" translate="yes" xml:space="preserve">
          <source>Any masked values in x is propagated in y, and vice-versa.</source>
          <target state="translated">x의 마스킹 된 값은 y로 전파되고 그 반대도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="5b3e589175f1027a44f22dd657bf35194fb4efe1" translate="yes" xml:space="preserve">
          <source>Any object that can be interpreted as a numpy data type.</source>
          <target state="translated">numpy 데이터 형식으로 해석 될 수있는 모든 개체</target>
        </trans-unit>
        <trans-unit id="5c7fd0d6a17d8a832706885c37ef7915bca46e30" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="translated">모든 &lt;a href=&quot;array#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; &lt;/a&gt; 열거 형 값은 &lt;code&gt;casting&lt;/code&gt; 전달 될 수 있습니다 . 값에는 &lt;a href=&quot;array#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;array#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; 이 포함&lt;/a&gt; 됩니다. 캐스트가 발생하도록하려면 복사 또는 버퍼링도 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="a5faa1a4aa7fab555a1cad670ecbaad358f811e8" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="translated">의 모든 &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; 의&lt;/a&gt; 열거 값이 전달 될 수 있습니다 &lt;code&gt;order&lt;/code&gt; . 효율적인 반복을 위해 &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 최상의 옵션이고 다른 순서는 특정 반복 패턴을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="61c0049b3dfe5e641bc6afd3eb13a7ff82f212c5" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 모든 &lt;a href=&quot;array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; 의&lt;/a&gt; 열거 값이 전달 될 수 있습니다 &lt;code&gt;order&lt;/code&gt; . 효율적인 반복을 위해 &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 최상의 옵션이고 다른 순서는 특정 반복 패턴을 적용합니다. &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 를&lt;/a&gt; 사용할 때 반복이 축을 따라 반전되지 않도록하려면 &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; &lt;/a&gt; 플래그를 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6945ac0af9b8b9ad29a3d13b28b137c3c2801d79" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;casting&lt;/code&gt;. The values include &lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;. To allow the casts to occur, copying or buffering must also be enabled.</source>
          <target state="translated">의 모든 &lt;a href=&quot;c-api.array#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; 의&lt;/a&gt; 열거 값이 전달 될 수 있습니다 &lt;code&gt;casting&lt;/code&gt; . 값은 &lt;a href=&quot;c-api.array#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;c-api.array#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; &lt;/a&gt; 입니다. 캐스트가 발생하도록하려면 복사 또는 버퍼링도 활성화해야합니다.</target>
        </trans-unit>
        <trans-unit id="99411ff6757ed2755306b2b1a16852e86b5af656" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern.</source>
          <target state="translated">의 모든 &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; 의&lt;/a&gt; 열거 값이 전달 될 수 있습니다 &lt;code&gt;order&lt;/code&gt; . 효율적인 반복을 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 최선의 선택이며 다른 순서는 특정 반복 패턴을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="edb631f6c3d9ec9fd114b3a0b6be2d92e321c394" translate="yes" xml:space="preserve">
          <source>Any of the &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enum values may be passed to &lt;code&gt;order&lt;/code&gt;. For efficient iteration, &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is the best option, and the other orders enforce the particular iteration pattern. When using &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;, if you also want to ensure that the iteration is not reversed along an axis, you should pass the flag &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt;&lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 모든 &lt;a href=&quot;c-api.array#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; 의&lt;/a&gt; 열거 값이 전달 될 수 있습니다 &lt;code&gt;order&lt;/code&gt; . 효율적인 반복을 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; &lt;/a&gt; 가 최선의 선택이며 다른 순서는 특정 반복 패턴을 적용합니다. &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 를&lt;/a&gt; 사용할 때 축을 따라 반복이 반전되지 않도록하려면 플래그 &lt;a href=&quot;#c.NPY_ITER_DONT_NEGATE_STRIDES&quot;&gt; &lt;code&gt;NPY_ITER_DONT_NEGATE_STRIDES&lt;/code&gt; 를&lt;/a&gt; 전달해야합니다 .</target>
        </trans-unit>
        <trans-unit id="b3abc478c3f222918197160be100f748fcb675c9" translate="yes" xml:space="preserve">
          <source>Any of the above can be repeated with an arbitrary array-like instead of just integers. For instance:</source>
          <target state="translated">위의 모든 것은 정수 대신 임의의 배열과 같이 반복 될 수 있습니다. 예를 들어 :</target>
        </trans-unit>
        <trans-unit id="baa143a57607b2a750593f79fe56d85a053bca99" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt;&lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt;&lt;/a&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">비트들의 상관 &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (1) &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (2) &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; (0x100에서) &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt; (을 0x200) 또는 &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; (0x400에)는 데이터에 대한 것을 나타냅니다. &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; 의&lt;/a&gt; 플래그는 실제로 다른 매개 변수에서 결정될 수있다. &lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt; &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; &lt;/a&gt; (0x800) 플래그를 설정하여 버전 3 배열 인터페이스를 사용하는 개체에 구조의 descr 멤버가 있음을 나타낼 수도 있습니다 (배열 인터페이스의 버전 2를 사용하는 개체에서는 무시 됨).</target>
        </trans-unit>
        <trans-unit id="50f8138ac25a7b846ede67771ef46a3519a7468a" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">비트들의 상관 &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (1) &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (2) &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; (0x100에서) &lt;a href=&quot;array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt; (을 0x200) 또는 &lt;a href=&quot;array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; (0x400에)는 데이터에 대한 것을 나타냅니다. &lt;a href=&quot;array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; 의&lt;/a&gt; 플래그는 실제로 다른 매개 변수에서 결정될 수있다. &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) 플래그를 설정하여 버전 3 배열 인터페이스를 사용하는 개체에 구조의 descr 멤버가 있음을 나타낼 수도 있습니다 (배열 인터페이스의 버전 2를 사용하는 개체에서는 무시 됨).</target>
        </trans-unit>
        <trans-unit id="be291c901c4e86c13d0921234777782594d69ca9" translate="yes" xml:space="preserve">
          <source>Any of the bits &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (1), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (2), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; (0x100), &lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt;&lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt;&lt;/a&gt; (0x200), or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; (0x400) to indicate something about the data. The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; flags can actually be determined from the other parameters. The flag &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; (0x800) can also be set to indicate to objects consuming the version 3 array interface that the descr member of the structure is present (it will be ignored by objects consuming version 2 of the array interface).</source>
          <target state="translated">비트들의 상관 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (1) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; (2) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; (0x100에서) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_NOTSWAPPED&quot;&gt; &lt;code&gt;NPY_ARRAY_NOTSWAPPED&lt;/code&gt; &lt;/a&gt; (을 0x200) 또는 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; (0x400에)는 데이터에 대한 것을 나타냅니다. &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; 의&lt;/a&gt; 플래그는 실제로 다른 매개 변수에서 결정될 수있다. &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; 플래그 (0x800)는 구조의 설명자 멤버 가 있음을 버전 3 배열 인터페이스를 소비하는 오브젝트를 나타내도록 설정할 수도 있습니다 (배열 인터페이스의 버전 2를 소비하는 오브젝트에서는 무시 됨).</target>
        </trans-unit>
        <trans-unit id="451522a82b98d1ecbb1f701acd57fae92d96248e" translate="yes" xml:space="preserve">
          <source>Any scalar or sequence that can be interpreted as an ndarray.</source>
          <target state="translated">ndarray로 해석 될 수있는 모든 스칼라 또는 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="ade55446d2b73db16731c562424aceaad0914376" translate="yes" xml:space="preserve">
          <source>Any sequence that can be interpreted as an ndarray. This includes nested lists, tuples, scalars and existing arrays.</source>
          <target state="translated">ndarray로 해석 될 수있는 모든 시퀀스입니다. 여기에는 중첩 된 목록, 튜플, 스칼라 및 기존 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="f40cd9ea72e6075ff56d97f5c96e1adeaca3800f" translate="yes" xml:space="preserve">
          <source>Any specified CPU feature to &lt;code&gt;--cpu-dispatch&lt;/code&gt; will be skipped if it&amp;rsquo;s part of CPU baseline features</source>
          <target state="translated">&lt;code&gt;--cpu-dispatch&lt;/code&gt; 에 지정된 모든 CPU 기능 이 CPU 기준 기능의 일부인 경우 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="c0fc04558da8dd3c7bccbbace9c70f03ebdb6a80" translate="yes" xml:space="preserve">
          <source>Any string in &lt;code&gt;numpy.sctypeDict&lt;/code&gt;.keys():</source>
          <target state="translated">&lt;code&gt;numpy.sctypeDict&lt;/code&gt; .keys ()의 모든 문자열 :</target>
        </trans-unit>
        <trans-unit id="d713c0e047edfbd49f0b3846ac98a9a40d4a3161" translate="yes" xml:space="preserve">
          <source>Any third argument to &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt;&lt;code&gt;pow&lt;/code&gt;&lt;/a&gt; is silently ignored, as the underlying &lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; takes only two arguments.</source>
          <target state="translated">기본 &lt;a href=&quot;generated/numpy.power#numpy.power&quot;&gt; &lt;code&gt;ufunc&lt;/code&gt; &lt;/a&gt; 는 두 개의 인수 만 취 하므로 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#pow&quot;&gt; &lt;code&gt;pow&lt;/code&gt; 에 대한&lt;/a&gt; 세 번째 인수 는 자동으로 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="946a38c0dae9772a5b694f0cc7db9666bf07194e" translate="yes" xml:space="preserve">
          <source>Any time you want to use a package or library in your code, you first need to make it accessible.</source>
          <target state="translated">코드에서 패키지 또는 라이브러리를 사용하려면 먼저 액세스 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="53be63b1330ee25c1f855c85df25ca52d3b0d9ac" translate="yes" xml:space="preserve">
          <source>Any type object with a &lt;code&gt;dtype&lt;/code&gt; attribute: The attribute will be accessed and used directly. The attribute must return something that is convertible into a dtype object.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 속성 이있는 모든 유형 객체 : 속성에 직접 액세스하여 사용됩니다. 속성은 dtype 객체로 변환 할 수있는 것을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="a26626a547f9526333d65f7f7ac98e634e8d404b" translate="yes" xml:space="preserve">
          <source>Append a new recording filter or apply it if the state is entered.</source>
          <target state="translated">새로운 녹음 필터를 추가하거나 상태가 입력되면 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="2911a13c39db194e9958de7d85a60b6ad7244721" translate="yes" xml:space="preserve">
          <source>Append directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; to the list of directories searched for include files.</source>
          <target state="translated">포함 파일을 검색 한 디렉토리 목록에 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 디렉토리를 추가 하십시오.</target>
        </trans-unit>
        <trans-unit id="01347379ae01a5a40d3d1ed49513be6a422e707d" translate="yes" xml:space="preserve">
          <source>Append elements at the end of an array.</source>
          <target state="translated">배열 끝에 요소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6e89159e1cc33f0d869902b46493c6f6e94db543" translate="yes" xml:space="preserve">
          <source>Append values to the end of an array.</source>
          <target state="translated">배열의 끝에 값을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="481aab454c2962551cc9f57d11f57a67e0fca9e4" translate="yes" xml:space="preserve">
          <source>Appending to build flags</source>
          <target state="translated">빌드 플래그에 추가</target>
        </trans-unit>
        <trans-unit id="5d9cf77e8ba225a7ce0a29de1d2139c5781725d4" translate="yes" xml:space="preserve">
          <source>Appends a data function to the data_files list that will generate __svn_version__.py file to the current package directory.</source>
          <target state="translated">__svn_version__.py 파일을 현재 패키지 디렉토리에 생성하는 data_files 목록에 데이터 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="33f5ee9b7c00e9ead408311c459141d052778da5" translate="yes" xml:space="preserve">
          <source>Applies an offset counted in valid days.</source>
          <target state="translated">유효한 일수로 계산 된 오프셋을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="2bf57444d43c734213e1d3c851fdf1b3fb150bdf" translate="yes" xml:space="preserve">
          <source>Applies glob.glob(&amp;hellip;) to each path in the sequence (if needed) and pre-pends the local_path if needed. Because this is called on all source lists, this allows wildcard characters to be specified in lists of sources for extension modules and libraries and scripts and allows path-names be relative to the source directory.</source>
          <target state="translated">시퀀스의 각 경로에 glob.glob (&amp;hellip;)를 적용하고 (필요한 경우) local_path를 미리 추가합니다. 이것은 모든 소스 목록에서 호출되므로 확장 모듈 및 라이브러리 및 스크립트의 소스 목록에서 와일드 카드 문자를 지정할 수 있으며 경로 이름이 소스 디렉토리와 관련 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78652f7b097973c5af68766b38955ba3ae45a013" translate="yes" xml:space="preserve">
          <source>Applies the Einstein summation convention to the array operands provided, returning a new array or placing the result in &lt;em&gt;out&lt;/em&gt;. The string in &lt;em&gt;subscripts&lt;/em&gt; is a comma separated list of index letters. The number of operands is in &lt;em&gt;nop&lt;/em&gt;, and &lt;em&gt;op_in&lt;/em&gt; is an array containing those operands. The data type of the output can be forced with &lt;em&gt;dtype&lt;/em&gt;, the output order can be forced with &lt;em&gt;order&lt;/em&gt; (&lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is recommended), and when &lt;em&gt;dtype&lt;/em&gt; is specified, &lt;em&gt;casting&lt;/em&gt; indicates how permissive the data conversion should be.</source>
          <target state="translated">Einstein 요약 규칙을 제공된 배열 피연산자에 적용하여 새 배열을 반환하거나 결과를 &lt;em&gt;출력&lt;/em&gt; 합니다. 아래 &lt;em&gt;첨자&lt;/em&gt; 의 문자열 은 쉼표로 구분 된 색인 문자 목록입니다. 피연산자의 수는 &lt;em&gt;nop&lt;/em&gt; 이며 &lt;em&gt;op_in&lt;/em&gt; 은 해당 피연산자가 포함 된 배열입니다. 출력의 데이터 유형으로 강제 할 수 &lt;em&gt;DTYPE&lt;/em&gt; , 출력 순서로 강제 할 수 &lt;em&gt;순서&lt;/em&gt; ( &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 가&lt;/a&gt; 권장), 때 &lt;em&gt;DTYPE이&lt;/em&gt; 지정, &lt;em&gt;캐스팅&lt;/em&gt; 데이터 변환해야한다 허용하는 방법을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="21feca4b141579d51c961cd00a897cb1717e4a03" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;index_array&lt;/code&gt; from argpartition to an array as if by calling partition.</source>
          <target state="translated">적용 &lt;code&gt;index_array&lt;/code&gt; 파티션을 호출하는 경우와 같이 배열에 argpartition에서.</target>
        </trans-unit>
        <trans-unit id="4ca4fe7fefd7c25f71a50eeea097cc697cb368a1" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;index_array&lt;/code&gt; from argsort to an array as if by calling sort.</source>
          <target state="translated">적용 &lt;code&gt;index_array&lt;/code&gt; 경우 같은 종류의 호출하여 배열에 argsort에서.</target>
        </trans-unit>
        <trans-unit id="c436985ffd81a143fc825046932ac1ad32bff874" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; from argmax to an array as if by calling max.</source>
          <target state="translated">적용 &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; 최대 호출하여 마치 어레이에 행을 argmax.</target>
        </trans-unit>
        <trans-unit id="7cc1b6ea691ac922af6be7bae41f63f959261f5d" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; from argmin to an array as if by calling min.</source>
          <target state="translated">적용 &lt;code&gt;np.expand_dims(index_array, axis)&lt;/code&gt; 분을 호출하는 경우와 같은 배열을 행 argmin.</target>
        </trans-unit>
        <trans-unit id="17c58f86e54424ee8c27debf26633ec82caf815e" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;op&lt;/code&gt; to the arguments &lt;code&gt;*x&lt;/code&gt; elementwise, broadcasting the arguments.</source>
          <target state="translated">인수 &lt;code&gt;*x&lt;/code&gt; 요소에 &lt;code&gt;op&lt;/code&gt; 를 적용 하여 인수를 브로드 캐스팅합니다.</target>
        </trans-unit>
        <trans-unit id="a15deb464b32712e5faad1a95646f2d13bba4428" translate="yes" xml:space="preserve">
          <source>Apply a decorator to all methods in a class matching a regular expression.</source>
          <target state="translated">정규식과 일치하는 클래스의 모든 메소드에 데코레이터를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="9aba00bb90c6eaaa703b9d293078221144653ecd" translate="yes" xml:space="preserve">
          <source>Apply a function repeatedly over multiple axes.</source>
          <target state="translated">여러 축에 반복적으로 함수를 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="930471cd723d35b6c2b966e96ceecc291d0fdf6a" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices along the given axis.</source>
          <target state="translated">주어진 축을 따라 1D 슬라이스에 함수를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="60e579e665f3197d6488027d302750921e380286" translate="yes" xml:space="preserve">
          <source>Apply a function to 1-D slices of an array along the given axis.</source>
          <target state="translated">주어진 축을 따라 배열의 1D 슬라이스에 함수를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="8a69d5c1511c3d8cf1aef04b61ce82902f9e77f8" translate="yes" xml:space="preserve">
          <source>Apply function &amp;lsquo;func&amp;rsquo; as a reduction across fields of a structured array.</source>
          <target state="translated">구조화 된 배열의 필드에 대한 축소로 함수 'func'를 적용합니다.</target>
        </trans-unit>
        <trans-unit id="92f37352400ea0595778e975d3829366956d6422" translate="yes" xml:space="preserve">
          <source>Apply glob to paths and prepend local_path if needed.</source>
          <target state="translated">경로에 glob을 적용하고 필요한 경우 local_path를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="6d57e8ee432c77c347bd91e42e1ec296a790a962" translate="yes" xml:space="preserve">
          <source>Apply linear map to input points.</source>
          <target state="translated">입력 포인트에 선형 맵을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="b451c47d03d2342612630d90e5961330763668d9" translate="yes" xml:space="preserve">
          <source>Apply the same function to a scalar value.</source>
          <target state="translated">동일한 함수를 스칼라 값에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="c19a38c87eebd888f6ee1a1c74150ed1ef57dd31" translate="yes" xml:space="preserve">
          <source>Apply the ufunc &lt;code&gt;op&lt;/code&gt; to all pairs (a, b) with a in &lt;code&gt;A&lt;/code&gt; and b in &lt;code&gt;B&lt;/code&gt;.</source>
          <target state="translated">ufunc 적용 &lt;code&gt;op&lt;/code&gt; 모두에서 함께 쌍 (a, b)에 및 B &lt;code&gt;B&lt;/code&gt; . &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b480bceb3391de1a231371b22b8f98d14965a74b" translate="yes" xml:space="preserve">
          <source>Applying to all colors</source>
          <target state="translated">모든 색상에 적용</target>
        </trans-unit>
        <trans-unit id="f11fedb225efa784388e87f9d68e4b132e27f024" translate="yes" xml:space="preserve">
          <source>Approximation</source>
          <target state="translated">Approximation</target>
        </trans-unit>
        <trans-unit id="0a7e07004db73b8ccd197df301f0c0c88108495f" translate="yes" xml:space="preserve">
          <source>Arbitrary data (extra arguments, function names, &lt;em&gt;etc.&lt;/em&gt; ) that can be stored with the ufunc and will be passed in when it is called.</source>
          <target state="translated">ufunc와 함께 저장 될 수 있고 호출 될 때 전달 될 임의의 데이터 (추가 인수, 함수 이름 &lt;em&gt;등&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="d6c0ec3c601093336049eacec64ee0a29b472718" translate="yes" xml:space="preserve">
          <source>Arbitrary subclasses of numpy.ndarray are not completely preserved. Subclasses will be accepted for writing, but only the array data will be written out. A regular numpy.ndarray object will be created upon reading the file.</source>
          <target state="translated">numpy.ndarray의 임의 서브 클래스는 완전히 보존되지 않습니다. 서브 클래스는 쓰기가 허용되지만 배열 데이터 만 기록됩니다. 파일을 읽을 때 일반 numpy.ndarray 객체가 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="55d5f33d484d4926bb72a9fc085161f70575b63d" translate="yes" xml:space="preserve">
          <source>Arch option for windows binary</source>
          <target state="translated">Windows 바이너리 용 아치 옵션</target>
        </trans-unit>
        <trans-unit id="d91c75193c3842b9d909ec7b8dd4d035b07a9f55" translate="yes" xml:space="preserve">
          <source>Are all arguments of a type that we know how to handle?</source>
          <target state="translated">처리 방법을 알고있는 유형의 모든 인수가 있습니까?</target>
        </trans-unit>
        <trans-unit id="9bdf5e0978150bd50fab817fc37629d830ac57f1" translate="yes" xml:space="preserve">
          <source>Are axis or shape arguments tested to be &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;tuples&lt;/code&gt;?</source>
          <target state="translated">축 또는 모양 인수가 &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;tuples&lt;/code&gt; 인지 테스트 됩니까?</target>
        </trans-unit>
        <trans-unit id="14bf0c3e3104c86791f4ce367eca2a5cc6cd438f" translate="yes" xml:space="preserve">
          <source>Are the array elements of type unicode (True) or string (False). Default is False.</source>
          <target state="translated">유니 코드 (True) 또는 문자열 (False) 유형의 배열 요소입니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="b5b7142c8499ab6cb5dbe41cc158e30ea956ddca" translate="yes" xml:space="preserve">
          <source>Are unusual &lt;code&gt;dtypes&lt;/code&gt; tested if a function supports those?</source>
          <target state="translated">함수가 지원하는 경우 비정상적인 &lt;code&gt;dtypes&lt;/code&gt; 테스트됩니까?</target>
        </trans-unit>
        <trans-unit id="54fec1cc4e99f8522843b011fb68aafe3fb92c1c" translate="yes" xml:space="preserve">
          <source>Aren&amp;rsquo;t how-tos and tutorials the same thing?</source>
          <target state="translated">방법과 튜토리얼이 똑같지 않나요?</target>
        </trans-unit>
        <trans-unit id="c651546e6d3a9b3b4ba1458219c7c80e713538c6" translate="yes" xml:space="preserve">
          <source>Argmin and argmax out argument</source>
          <target state="translated">Argmin 및 argmax 출력 인수</target>
        </trans-unit>
        <trans-unit id="04b5fdf11f1c668ee1bccda74e473d486cb80034" translate="yes" xml:space="preserve">
          <source>Argout Arrays</source>
          <target state="translated">인수 배열</target>
        </trans-unit>
        <trans-unit id="1f693ea5d95326ee12ba9edafca87f6f5ac163dc" translate="yes" xml:space="preserve">
          <source>Argout View Arrays</source>
          <target state="translated">Argout View Arrays</target>
        </trans-unit>
        <trans-unit id="9362235cd642830a37eb4b0e960e60e4a8a7f208" translate="yes" xml:space="preserve">
          <source>Argout arrays are arrays that appear in the input arguments in C, but are in fact output arrays. This pattern occurs often when there is more than one output variable and the single return argument is therefore not sufficient. In Python, the conventional way to return multiple arguments is to pack them into a sequence (tuple, list, etc.) and return the sequence. This is what the argout typemaps do. If a wrapped function that uses these argout typemaps has more than one return argument, they are packed into a tuple or list, depending on the version of Python. The Python user does not pass these arrays in, they simply get returned. For the case where a dimension is specified, the python user must provide that dimension as an argument. The argout signatures are</source>
          <target state="translated">Argout 배열은 C의 입력 인수에 나타나는 배열이지만 실제로는 출력 배열입니다. 이 패턴은 둘 이상의 출력 변수가 있고 단일 리턴 인수로 충분하지 않은 경우에 종종 발생합니다. Python에서 여러 인수를 반환하는 일반적인 방법은 인수를 시퀀스 (튜플, 목록 등)로 묶고 시퀀스를 반환하는 것입니다. 이것이 argout 타입 맵이하는 일입니다. 이러한 argout 타입 맵을 사용하는 랩핑 된 함수가 둘 이상의 리턴 인수를 갖는 경우, Python 버전에 따라 튜플 또는 목록으로 패킹됩니다. 파이썬 사용자는 이러한 배열을 전달하지 않고 단순히 반환됩니다. 차원이 지정된 경우 Python 사용자는 해당 차원을 인수로 제공해야합니다. argout 서명은</target>
        </trans-unit>
        <trans-unit id="f0d811a8c8b43b06e028e619f05e9d14eafcdca7" translate="yes" xml:space="preserve">
          <source>Argoutview arrays are for when your C code provides you with a view of its internal data and does not require any memory to be allocated by the user. This can be dangerous. There is almost no way to guarantee that the internal data from the C code will remain in existence for the entire lifetime of the NumPy array that encapsulates it. If the user destroys the object that provides the view of the data before destroying the NumPy array, then using that array may result in bad memory references or segmentation faults. Nevertheless, there are situations, working with large data sets, where you simply have no other choice.</source>
          <target state="translated">Argoutview 배열은 C 코드가 내부 데이터보기를 제공하고 사용자가 메모리를 할당 할 필요가없는 경우를위한 것입니다. 위험 할 수 있습니다. C 코드의 내부 데이터가 그것을 캡슐화하는 NumPy 배열의 전체 수명 동안 존재하도록 보장 할 방법이 거의 없습니다. 사용자가 NumPy 배열을 삭제하기 전에 데이터보기를 제공하는 개체를 삭제하면 해당 배열을 사용하면 메모리 참조 또는 세그먼트 오류가 발생할 수 있습니다. 그럼에도 불구하고 단순히 다른 선택의 여지가없는 큰 데이터 세트로 작업하는 상황이 있습니다.</target>
        </trans-unit>
        <trans-unit id="69013bc8794a33ce0d96e2362b8fd29875b1d20a" translate="yes" xml:space="preserve">
          <source>Argument can be either</source>
          <target state="translated">인수는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="80e8304a176934810abc17d2d26c3888e65cbaa7" translate="yes" xml:space="preserve">
          <source>Argument of complex values.</source>
          <target state="translated">복잡한 값의 인수.</target>
        </trans-unit>
        <trans-unit id="103cd4d5d40741b2189f1a4cd45b1145dc7d5cc2" translate="yes" xml:space="preserve">
          <source>Argument of the Bessel function.</source>
          <target state="translated">베셀 함수의 인수</target>
        </trans-unit>
        <trans-unit id="da03da7501b0f4c3d0e71a81aacac0740f6ea6ce" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either</source>
          <target state="translated">인수는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a267e3ae3a20fe67defefd5d3c99d6c87f6bed7" translate="yes" xml:space="preserve">
          <source>Argument(s) can be either:</source>
          <target state="translated">인수는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="5649abe78903b9f6461061e275735b25a7054ccd" translate="yes" xml:space="preserve">
          <source>Arguments for &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 에 대한 인수 .</target>
        </trans-unit>
        <trans-unit id="1fece9ebb467e36ae935eb7f9713ac9a4f47e841" translate="yes" xml:space="preserve">
          <source>Arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">인수가 &lt;code&gt;func&lt;/code&gt; 에 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="ed091b4d91808383da4576963f0c43e1c919be23" translate="yes" xml:space="preserve">
          <source>Arguments to be passed to the nose test runner. &lt;code&gt;argv[0]&lt;/code&gt; is ignored. All command line arguments accepted by &lt;code&gt;nosetests&lt;/code&gt; will work. If it is the default value None, sys.argv is used.</source>
          <target state="translated">코 테스트 러너에게 전달할 인수. &lt;code&gt;argv[0]&lt;/code&gt; 은 무시됩니다. &lt;code&gt;nosetests&lt;/code&gt; 가 승인 한 모든 명령 행 인수 가 작동합니다. 기본값이 None이면 sys.argv가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a47a631225ff0c3415173266008602c859777e94" translate="yes" xml:space="preserve">
          <source>Arguments to pass on to the ufunc. Typically &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">ufunc에 전달할 인수. 일반적으로 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="424915704fdafa9f1991a2f818f149305624ecb5" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations</source>
          <target state="translated">산술 및 비교 연산</target>
        </trans-unit>
        <trans-unit id="27c9afdfd25af93dd20b5c590862915ebec2aa5c" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="translated">마스킹 된 배열은 산술 및 비교 연산을 지원합니다. 가능한 한 마스크 된 배열의 유효하지 않은 항목은 처리되지 않습니다. 즉, 해당 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 항목 &lt;em&gt;은&lt;/em&gt; 작업 전후에 동일 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="c0e6f1226f47528d48f2f359b548a2a985744686" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations are supported by masked arrays. As much as possible, invalid entries of a masked array are not processed, meaning that the corresponding &lt;code&gt;data&lt;/code&gt; entries &lt;em&gt;should&lt;/em&gt; be the same before and after the operation.</source>
          <target state="translated">산술 및 비교 연산은 마스크 배열에서 지원됩니다. 마스크 배열의 유효하지 않은 항목은 처리되지 않으므로 가능한 한 해당 &lt;code&gt;data&lt;/code&gt; 항목 &lt;em&gt;이&lt;/em&gt; 작업 전후에 동일 &lt;em&gt;해야&lt;/em&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="574e424bf0f02d1b18e3ad5386f39a38953e230d" translate="yes" xml:space="preserve">
          <source>Arithmetic and comparison operations on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; are defined as element-wise operations, and generally yield &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects as results.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 산술 및 비교 연산 은 요소 별 연산으로 정의되며 일반적으로 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체를 결과로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="6179dfdf1f721c4f139e7add385d54ea9025725c" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow.</source>
          <target state="translated">정수 유형을 사용할 때는 산술이 모듈 식이며 오버플로시 오류가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="72188498e399312affe529bd4d440a03ee9c95e4" translate="yes" xml:space="preserve">
          <source>Arithmetic is modular when using integer types, and no error is raised on overflow. That means that, on a 32-bit platform:</source>
          <target state="translated">정수 유형을 사용할 때는 산술이 모듈 식이며 오버플로시 오류가 발생하지 않습니다. 이는 32 비트 플랫폼에서 다음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="339f6492877ce24a534c3f1e9110c317be457d3a" translate="yes" xml:space="preserve">
          <source>Arithmetic mean taken while not ignoring NaNs</source>
          <target state="translated">NaN을 무시하지 않은 채 산술 평균</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">산술 연산</target>
        </trans-unit>
        <trans-unit id="7ee1fda772751523c2669ec2f48ddc06e8ec6d54" translate="yes" xml:space="preserve">
          <source>Arithmetic operators on arrays apply &lt;em&gt;elementwise&lt;/em&gt;. A new array is created and filled with the result.</source>
          <target state="translated">배열의 산술 연산자는 &lt;em&gt;요소별로&lt;/em&gt; 적용됩니다 . 새 배열이 생성되고 결과로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="16ba88bd7d8f2b893c09bcff737706246adcbc3b" translate="yes" xml:space="preserve">
          <source>Arithmetic, in-place:</source>
          <target state="translated">적절한 산술 :</target>
        </trans-unit>
        <trans-unit id="ac2131c4955b2cce396141546558f75712964834" translate="yes" xml:space="preserve">
          <source>Arithmetic, matrix multiplication, and comparison operations</source>
          <target state="translated">산술, 행렬 곱셈 및 비교 연산</target>
        </trans-unit>
        <trans-unit id="d534ca6745f09f171b20632796505d5bd60949d7" translate="yes" xml:space="preserve">
          <source>Arithmetic:</source>
          <target state="translated">Arithmetic:</target>
        </trans-unit>
        <trans-unit id="0771a753fa9fe721bf5720d2f9bacca79fff9e8e" translate="yes" xml:space="preserve">
          <source>Arithmetics</source>
          <target state="translated">Arithmetics</target>
        </trans-unit>
        <trans-unit id="dfc7a32fa9a79ec3a22472c368d871d5e78afd31" translate="yes" xml:space="preserve">
          <source>Array (possibly multi-dimensional) of values for which to to calculate &lt;code&gt;sinc(x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sinc(x)&lt;/code&gt; 를 계산할 값의 배열 (다차원 일 수도 있음 ) .</target>
        </trans-unit>
        <trans-unit id="0523df413b1fea0ba7975ab7c9175833f364830f" translate="yes" xml:space="preserve">
          <source>Array &lt;strong&gt;attributes&lt;/strong&gt; reflect information intrinsic to the array itself. If you need to get, or even set, properties of an array without creating a new array, you can often access an array through its attributes.</source>
          <target state="translated">배열 &lt;strong&gt;속성&lt;/strong&gt; 은 배열 자체에 고유 한 정보를 반영합니다. 새 배열을 만들지 않고 배열의 속성을 가져 오거나 설정해야하는 경우 속성을 통해 배열에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6951f36c01ac0e1bf34c5ee5904784fafce57b89" translate="yes" xml:space="preserve">
          <source>Array API</source>
          <target state="translated">배열 API</target>
        </trans-unit>
        <trans-unit id="5555a6fcea0c1d138c4fd9c9348c13792e83ec8b" translate="yes" xml:space="preserve">
          <source>Array Attributes</source>
          <target state="translated">배열 속성</target>
        </trans-unit>
        <trans-unit id="3458034e7e106c04c09c4ec57632af02a473c676" translate="yes" xml:space="preserve">
          <source>Array Broadcasting in Numpy</source>
          <target state="translated">Numpy에서 어레이 브로드 캐스팅</target>
        </trans-unit>
        <trans-unit id="0c1a37c234fe9514069c7363784bf98af15b8355" translate="yes" xml:space="preserve">
          <source>Array Creation</source>
          <target state="translated">어레이 생성</target>
        </trans-unit>
        <trans-unit id="daa02d3f49bf321fb5979b03ac56b6cd9657dfad" translate="yes" xml:space="preserve">
          <source>Array Functions</source>
          <target state="translated">배열 함수</target>
        </trans-unit>
        <trans-unit id="12d693ff9b1c0d4047e2b7848ca27e4c2aad6719" translate="yes" xml:space="preserve">
          <source>Array Iterator</source>
          <target state="translated">배열 반복자</target>
        </trans-unit>
        <trans-unit id="043a8c676a7d5d7051367cd8181a4b07707df511" translate="yes" xml:space="preserve">
          <source>Array Iterator API</source>
          <target state="translated">배열 반복자 API</target>
        </trans-unit>
        <trans-unit id="23211b01eb261a332c7929b935052183b79935ba" translate="yes" xml:space="preserve">
          <source>Array Iterators</source>
          <target state="translated">배열 반복자</target>
        </trans-unit>
        <trans-unit id="17e44520a1762d19a9e642fb414c494c724cbf21" translate="yes" xml:space="preserve">
          <source>Array Scalars</source>
          <target state="translated">배열 스칼라</target>
        </trans-unit>
        <trans-unit id="d8dbcc76e586f64f22d24c3030096b5747dde0a4" translate="yes" xml:space="preserve">
          <source>Array arguments</source>
          <target state="translated">배열 인수</target>
        </trans-unit>
        <trans-unit id="2ec85771e631fd3b121a1ff64071bd20ad9c65bf" translate="yes" xml:space="preserve">
          <source>Array attributes</source>
          <target state="translated">배열 속성</target>
        </trans-unit>
        <trans-unit id="447450427b5d5b0e87b960a4d40e39c7fb5454bf" translate="yes" xml:space="preserve">
          <source>Array attributes reflect information that is intrinsic to the array itself. Generally, accessing an array through its attributes allows you to get and sometimes set intrinsic properties of the array without creating a new array. The exposed attributes are the core parts of an array and only some of them can be reset meaningfully without creating a new array. Information on each attribute is given below.</source>
          <target state="translated">배열 속성은 배열 자체에 고유 한 정보를 반영합니다. 일반적으로 해당 속성을 통해 배열에 액세스하면 새 배열을 만들지 않고도 배열의 고유 속성을 가져오고 설정할 수 있습니다. 노출 된 속성은 배열의 핵심 부분이며 일부만 새 배열을 만들지 않고 의미있게 재설정 할 수 있습니다. 각 속성에 대한 정보는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="43e339bdd3d217a5df3e10b8dade9046731deb5f" translate="yes" xml:space="preserve">
          <source>Array axis summations, &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;numpy.sum&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열 합산, 축 &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;numpy.sum&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c2c33d8dc2ce945222653dfcc314e267ebd95901" translate="yes" xml:space="preserve">
          <source>Array coercion changes when Strings and other types are mixed</source>
          <target state="translated">문자열 및 기타 유형이 혼합되면 배열 강제 변경</target>
        </trans-unit>
        <trans-unit id="c3499b80a79c532bb5bd65ecb4071851e51014ae" translate="yes" xml:space="preserve">
          <source>Array coercion restructure</source>
          <target state="translated">배열 강제 재구성</target>
        </trans-unit>
        <trans-unit id="57c60efa53930ae07f9d8ba23de0e194c69cf7fe" translate="yes" xml:space="preserve">
          <source>Array comparison assertions include maximum differences</source>
          <target state="translated">배열 비교 단언에는 최대 차이가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="347b135c7cac14f05d7b1660f5d4b4c54f55d66d" translate="yes" xml:space="preserve">
          <source>Array comparisons involving strings or structured dtypes</source>
          <target state="translated">문자열 또는 구조화 된 dtype을 포함하는 배열 비교</target>
        </trans-unit>
        <trans-unit id="d7a5d8de55dabc36dc25c0b90e8906cffcb6a61a" translate="yes" xml:space="preserve">
          <source>Array containing data to be averaged. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">평균화 할 데이터가 포함 된 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="54d016905c8d5e8ccde24c37f9843bcd318cb81c" translate="yes" xml:space="preserve">
          <source>Array containing elements to clip.</source>
          <target state="translated">클립 할 요소를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3961c6f8eadfe688bca31469d6a9f6d86adf81c6" translate="yes" xml:space="preserve">
          <source>Array containing number of representable floating point numbers between items in &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 항목 사이에 표현 가능한 부동 소수점 숫자의 수를 포함하는 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="3692161b3a773c7a966c7715be4b4e9968f11340" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose maximum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">최대 값을 원하는 숫자가 포함 된 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="e6449394cdaf60dea5ac71fdd09a0ed9e9fcf7ee" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose mean is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">평균을 원하는 숫자가 포함 된 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="535ad2f426544f7de05e5d9017d86d66f0dc26b1" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose minimum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">최소값을 원하는 숫자가 포함 된 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="64bc244f5b24dc5faeb077670f074a7e20727322" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose product is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">제품이 필요한 숫자를 포함하는 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="ee6ece6461a907cbfdfd61282756037912ce23f3" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose sum is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">합계를 원하는 숫자가 포함 된 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="2effaddf77c674bd9a13dc031c59b1eb4d28fa23" translate="yes" xml:space="preserve">
          <source>Array containing numbers whose variance is desired. If &lt;code&gt;a&lt;/code&gt; is not an array, a conversion is attempted.</source>
          <target state="translated">분산이 필요한 숫자를 포함하는 배열입니다. &lt;code&gt;a&lt;/code&gt; 가 배열이 아닌 경우 변환이 시도됩니다.</target>
        </trans-unit>
        <trans-unit id="f011f52156b6489c00057dbaf1f239251b746676" translate="yes" xml:space="preserve">
          <source>Array containing the roots of the series.</source>
          <target state="translated">계열의 근을 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="d1fb2d0b90ad27fe772216fd0efb4378564945a2" translate="yes" xml:space="preserve">
          <source>Array contents</source>
          <target state="translated">배열 내용</target>
        </trans-unit>
        <trans-unit id="2ea33ca743035321174ecf9d435d32b0b6324742" translate="yes" xml:space="preserve">
          <source>Array conversion</source>
          <target state="translated">배열 변환</target>
        </trans-unit>
        <trans-unit id="fc6b3a513ef2597bc0f03a1e823241af5164729d" translate="yes" xml:space="preserve">
          <source>Array convolution. Same output as polymul, but has parameter for overlap mode.</source>
          <target state="translated">배열 컨벌루션. polymul과 동일한 출력이지만 오버랩 모드에 대한 매개 변수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="57c72a1a53b95fbe1af3976c75af0287d5c9a140" translate="yes" xml:space="preserve">
          <source>Array creation</source>
          <target state="translated">배열 생성</target>
        </trans-unit>
        <trans-unit id="b5a18bd4e3702b73f0e8bbba0d5f2e2fddff6728" translate="yes" xml:space="preserve">
          <source>Array creation routines</source>
          <target state="translated">배열 생성 루틴</target>
        </trans-unit>
        <trans-unit id="a51f0e8ac2e03ac06587c6b47fb57edec0450c93" translate="yes" xml:space="preserve">
          <source>Array data to be saved.</source>
          <target state="translated">저장할 배열 데이터</target>
        </trans-unit>
        <trans-unit id="4e68baef4a7d203aefd9d4a59b835fc6af2a5db3" translate="yes" xml:space="preserve">
          <source>Array data-type.</source>
          <target state="translated">배열 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="52dbdba544f09b15fca774eb24a9caf2434bcfe6" translate="yes" xml:space="preserve">
          <source>Array desired.</source>
          <target state="translated">원하는 배열.</target>
        </trans-unit>
        <trans-unit id="785376e3605a2b132b04a5af283162b0f7133160" translate="yes" xml:space="preserve">
          <source>Array flags</source>
          <target state="translated">배열 플래그</target>
        </trans-unit>
        <trans-unit id="746aa39a47d26f55bf62b76f045191bc2131b857" translate="yes" xml:space="preserve">
          <source>Array flags provide information about how the memory area used for the array is to be interpreted. There are 7 Boolean flags in use, only four of which can be changed by the user: WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED.</source>
          <target state="translated">배열 플래그는 배열에 사용 된 메모리 영역을 해석하는 방법에 대한 정보를 제공합니다. 7 개의 부울 플래그가 사용 중이며 사용자가 WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE 및 ALIGNED 중 4 개만 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5f6e91f1df0558c7246187a2b89a1e305be167b2" translate="yes" xml:space="preserve">
          <source>Array flags; may be one or more of:</source>
          <target state="translated">배열 플래그; 다음 중 하나 이상일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="09f0fcdcc100e898aaa63b04e30eafb660bbc3ed" translate="yes" xml:space="preserve">
          <source>Array from which the diagonals are taken.</source>
          <target state="translated">대각선을 가져 오는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3966916957967be244949812c17944d586ffd56d" translate="yes" xml:space="preserve">
          <source>Array from which to extract a part.</source>
          <target state="translated">부품을 추출 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="e35c942121269158d9bce83e940f79fd38671bbd" translate="yes" xml:space="preserve">
          <source>Array indexing refers to any use of the square brackets ([]) to index array values. There are many options to indexing, which give numpy indexing great power, but with power comes some complexity and the potential for confusion. This section is just an overview of the various options and issues related to indexing. Aside from single element indexing, the details on most of these options are to be found in related sections.</source>
          <target state="translated">배열 인덱싱은 배열 값을 인덱싱하기 위해 대괄호 ([])를 사용하는 것을 말합니다. 인덱싱에는 많은 옵션이 있으며, 이는 numpy 인덱싱에 큰 힘을 제공하지만 힘이 있으면 약간의 복잡성과 혼란의 가능성이 있습니다. 이 섹션은 인덱싱과 관련된 다양한 옵션 및 문제에 대한 개요입니다. 단일 요소 인덱싱 외에도 이러한 옵션의 대부분에 대한 세부 정보는 관련 섹션에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a877fe238b2290421c4de0ccb250aa8e3797a13" translate="yes" xml:space="preserve">
          <source>Array interface</source>
          <target state="translated">배열 인터페이스</target>
        </trans-unit>
        <trans-unit id="533db24c36bf6bd74ce0240469f4033043848386" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 배열 해석 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1230519a64fd2e0f26f95201257e208e07092a99" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is an ndarray or a subclass of ndarray, it is returned as-is and no copy is performed.</source>
          <target state="translated">의 배열 해석 . 경우 &lt;code&gt;a&lt;/code&gt; ndarray 또는 ndarray의 서브 클래스는,있는 그대로 그것은 반환 및 카피가 수행되지 않습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2a004555e4ca47c97c392427144fe0dcc6f68634" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray with matching dtype and order. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">의 배열 해석 . 입력이 이미 dtype 및 순서와 일치하는 ndarray 인 경우 복사가 수행되지 않습니다. 경우 &lt;code&gt;a&lt;/code&gt; ndarray의 서브 클래스, 기본 클래스 ndarray이 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a82a73ea4a83ace24f5a89b08b00620d66cb5bf" translate="yes" xml:space="preserve">
          <source>Array interpretation of &lt;code&gt;a&lt;/code&gt;. No copy is performed if the input is already an ndarray. If &lt;code&gt;a&lt;/code&gt; is a subclass of ndarray, a base class ndarray is returned.</source>
          <target state="translated">의 배열 해석 . 입력이 이미 ndarray이면 복사가 수행되지 않습니다. 경우 &lt;code&gt;a&lt;/code&gt; ndarray의 서브 클래스, 기본 클래스 ndarray이 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1af36487281180923aa6bea35e0e5228dcc2e12d" translate="yes" xml:space="preserve">
          <source>Array into which the output is placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">출력이 배치되는 배열입니다. 그 유형은 유지되며 출력을 유지하기에 적합한 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="02f71c6bb3adeae64ae8bccd5d811288aeb1d5e1" translate="yes" xml:space="preserve">
          <source>Array into which the result can be placed. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">결과를 넣을 수있는 배열입니다. 그 유형은 유지되며 출력을 유지하기에 적합한 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1a57f1ce3b565cb3497401b660e08581c3aafec2" translate="yes" xml:space="preserve">
          <source>Array like index object or slice object for indexing into first operand. If first operand has multiple dimensions, indices can be a tuple of array like index objects or slice objects.</source>
          <target state="translated">첫 번째 피연산자로 인덱싱하기위한 인덱스 객체 또는 슬라이스 객체와 같은 배열입니다. 첫 번째 피연산자가 여러 차원을 갖는 경우 인덱스는 인덱스 개체 또는 슬라이스 개체와 같은 배열의 튜플 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d40d802fdd7ba3f82f5c9dc44f415145a1e22c74" translate="yes" xml:space="preserve">
          <source>Array manipulation routines</source>
          <target state="translated">배열 조작 루틴</target>
        </trans-unit>
        <trans-unit id="069ff2b332e403300b9cde701bf5368c5831882c" translate="yes" xml:space="preserve">
          <source>Array method alternative API</source>
          <target state="translated">배열 방법 대체 API</target>
        </trans-unit>
        <trans-unit id="5a716333b00a93ed3236b0b9385a0a127035480c" translate="yes" xml:space="preserve">
          <source>Array methods</source>
          <target state="translated">배열 방법</target>
        </trans-unit>
        <trans-unit id="4e4004372e15259457b2d1e38548f61c9bc5e00d" translate="yes" xml:space="preserve">
          <source>Array mixins</source>
          <target state="translated">어레이 믹스 인</target>
        </trans-unit>
        <trans-unit id="f161aeb75d90d23a000f60fbe55cf3eae07ee334" translate="yes" xml:space="preserve">
          <source>Array objects</source>
          <target state="translated">배열 객체</target>
        </trans-unit>
        <trans-unit id="cf093406a8132eb8bfd9cf1020e69e3fe6518645" translate="yes" xml:space="preserve">
          <source>Array obtained.</source>
          <target state="translated">배열을 얻었습니다.</target>
        </trans-unit>
        <trans-unit id="6b0a1f1e944aed373e67de14ba6a79b095a23306" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the given shape, dtype, and order.</source>
          <target state="translated">지정된 모양, dtype 및 순서를 가진 &lt;code&gt;fill_value&lt;/code&gt; 의 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="141b0992112c657405943baa4a593bdfd3d362b8" translate="yes" xml:space="preserve">
          <source>Array of &lt;code&gt;fill_value&lt;/code&gt; with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 모양 및 유형이 같은 &lt;code&gt;fill_value&lt;/code&gt; 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="d4591434d561c417ccddebc05c5c4eae4564de2b" translate="yes" xml:space="preserve">
          <source>Array of Chebyshev series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">체비 쇼프 계열 계수의 배열. c가 다차원 인 경우, 다른 축은 대응하는 인덱스에 의해 주어진 각 축의 차수를 갖는 다른 변수에 대응한다.</target>
        </trans-unit>
        <trans-unit id="4f8604db9d0154dd7eb0dded915686a2e44b5243" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">은자 (Hermite) 계열 계수의 배열. 경우 &lt;code&gt;c&lt;/code&gt; 해당 인덱스에 의해 지정된 각 축의 정도와 다른 변수 다차원 다른 축에 대응이다.</target>
        </trans-unit>
        <trans-unit id="817eb4e4585a916e35d1ff46432ac14702692600" translate="yes" xml:space="preserve">
          <source>Array of Hermite series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">은자 (Hermite) 계열 계수의 배열. c가 다차원 인 경우, 다른 축은 대응하는 인덱스에 의해 주어진 각 축의 차수를 갖는 다른 변수에 대응한다.</target>
        </trans-unit>
        <trans-unit id="6bb7459da4388ebdd50a78addd0898c1f80aabbe" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite_e 시리즈 계수의 배열. 경우 &lt;code&gt;c&lt;/code&gt; 해당 인덱스에 의해 지정된 각 축의 정도와 다른 변수 다차원 다른 축에 대응이다.</target>
        </trans-unit>
        <trans-unit id="63e65a5158a929fafcbc4f8f156592488b9429ea" translate="yes" xml:space="preserve">
          <source>Array of Hermite_e series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Hermite_e 시리즈 계수의 배열. c가 다차원 인 경우, 다른 축은 대응하는 인덱스에 의해 주어진 각 축의 차수를 갖는 다른 변수에 대응한다.</target>
        </trans-unit>
        <trans-unit id="1ea8d2a10d04a6eb03ee934ed9f9008e87ff51dc" translate="yes" xml:space="preserve">
          <source>Array of Laguerre series coefficients. If &lt;code&gt;c&lt;/code&gt; is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Laguerre 시리즈 계수의 배열. 경우 &lt;code&gt;c&lt;/code&gt; 해당 인덱스에 의해 지정된 각 축의 정도와 다른 변수 다차원 다른 축에 대응이다.</target>
        </trans-unit>
        <trans-unit id="35c007605e6d77452f8dad5eb06d7938bab0902f" translate="yes" xml:space="preserve">
          <source>Array of Legendre series coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">Legendre 시리즈 계수의 배열. c가 다차원 인 경우, 다른 축은 대응하는 인덱스에 의해 주어진 각 축의 차수를 갖는 다른 변수에 대응한다.</target>
        </trans-unit>
        <trans-unit id="4261b4b77833f5ffb9b4ec031af96d60404d62e0" translate="yes" xml:space="preserve">
          <source>Array of angles in radians, in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;[-pi, pi]&lt;/code&gt; 범위의 라디안 각도 배열입니다 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="d00b51bfc114fceca7b5e804468ddaae71dd1f04" translate="yes" xml:space="preserve">
          <source>Array of bins. It has to be 1-dimensional and monotonic.</source>
          <target state="translated">쓰레기통의 배열. 1 차원적이고 단조로운 것이어야합니다.</target>
        </trans-unit>
        <trans-unit id="2431f4c023950cb461e657c537178d58e27e27dd" translate="yes" xml:space="preserve">
          <source>Array of booleans</source>
          <target state="translated">부울 배열</target>
        </trans-unit>
        <trans-unit id="536a897428fe0f47a3d34f49d6446e12ae81a0e0" translate="yes" xml:space="preserve">
          <source>Array of booleans identical in shape to &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">동일한 형상의 배열 부울 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a77bc6459d956649f3ae15d32c4f2c19eb8edf06" translate="yes" xml:space="preserve">
          <source>Array of booleans of same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">동일 형상의 불리언 배열 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a658696b6a89082b912ff090b4b6b37dee9b715c" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 2 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">다도 i, j 항의 계수가 &lt;code&gt;c[i,j]&lt;/code&gt; 포함되도록 정렬 된 계수의 배열입니다 . 경우 &lt;code&gt;c&lt;/code&gt; 2보다 큰 차원을 갖는 나머지 지표 계수들의 다수의 세트를 열거.</target>
        </trans-unit>
        <trans-unit id="56c372955c6e7c782716979251e8af46e2f83f0a" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j is contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">다도 i, j 항의 계수가 &lt;code&gt;c[i,j]&lt;/code&gt; 포함되도록 정렬 된 계수의 배열입니다 . 경우 &lt;code&gt;c&lt;/code&gt; 두 개의보다 큰 사이즈를 갖고, 나머지 지수 계수들의 다수의 세트를 열거.</target>
        </trans-unit>
        <trans-unit id="fa76e8a2aedbceba248a9fc307fb834762ffa569" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficient of the term of multi-degree i,j,k is contained in &lt;code&gt;c[i,j,k]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than 3 the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">다도 i, j, k 항의 계수가 &lt;code&gt;c[i,j,k]&lt;/code&gt; 포함되도록 정렬 된 계수의 배열입니다 . 경우 &lt;code&gt;c&lt;/code&gt; 3보다 큰 사이즈를 갖고, 나머지 지수 계수들의 다수의 세트를 열거.</target>
        </trans-unit>
        <trans-unit id="2ca7ab8cb88305034f9c8ff4c4bec7fdbf7384a0" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree i,j are contained in &lt;code&gt;c[i,j]&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; has dimension greater than two the remaining indices enumerate multiple sets of coefficients.</source>
          <target state="translated">차분 i, j에 대한 계수가 &lt;code&gt;c[i,j]&lt;/code&gt; 포함되도록 정렬 된 계수의 배열 . 경우 &lt;code&gt;c&lt;/code&gt; 두 개의보다 큰 사이즈를 갖고, 나머지 지수 계수들의 다수의 세트를 열거.</target>
        </trans-unit>
        <trans-unit id="013054b355ed269971a257a22db8c61fecab58bc" translate="yes" xml:space="preserve">
          <source>Array of coefficients ordered so that the coefficients for terms of degree n are contained in c[n]. If &lt;code&gt;c&lt;/code&gt; is multidimensional the remaining indices enumerate multiple polynomials. In the two dimensional case the coefficients may be thought of as stored in the columns of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">차수 n 항에 대한 계수가 c [n]에 포함되도록 정렬 된 계수의 배열입니다. 경우 &lt;code&gt;c&lt;/code&gt; 다차원 나머지 인덱스 여러 다항식을 열거. 2 차원 경우에, 계수는 &lt;code&gt;c&lt;/code&gt; 의 열에 저장된 것으로 생각 될 수있다 .</target>
        </trans-unit>
        <trans-unit id="00bc78cb48de3651884eadaf718d38e560006d25" translate="yes" xml:space="preserve">
          <source>Array of evenly spaced values.</source>
          <target state="translated">균일 한 간격의 값으로 구성된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="2d1560c385ed8ca347f0a453a1d3ede23238d315" translate="yes" xml:space="preserve">
          <source>Array of indices into the array. It has the same shape as &lt;code&gt;a.shape&lt;/code&gt; with the dimension along &lt;code&gt;axis&lt;/code&gt; removed.</source>
          <target state="translated">배열에 대한 인덱스 배열. 그것은 동일한 형상 가진다 &lt;code&gt;a.shape&lt;/code&gt; 따라 치수가 &lt;code&gt;axis&lt;/code&gt; 제거한다.</target>
        </trans-unit>
        <trans-unit id="a8ca40e5ac25fd9b6c7a437f8b20abf87b6dd448" translate="yes" xml:space="preserve">
          <source>Array of indices that partition &lt;code&gt;a&lt;/code&gt; along the specified axis. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a partitioned &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; always yields the partitioned &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">지정된 축을 따라 &lt;code&gt;a&lt;/code&gt; 를 분할 하는 인덱스 배열입니다 . 경우 &lt;code&gt;a&lt;/code&gt; 일차원, &lt;code&gt;a[index_array]&lt;/code&gt; A가 분배 산출 &lt;code&gt;a&lt;/code&gt; . 보다 일반적으로, &lt;code&gt;np.take_along_axis(a, index_array, axis=a)&lt;/code&gt; 는 차원에 관계없이 항상 분할 된 &lt;code&gt;a&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="8b6035bba7c71c43b0b9bba16cae62cbd47fc547" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified &lt;code&gt;axis&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; is one-dimensional, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;. More generally, &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; always yields the sorted &lt;code&gt;a&lt;/code&gt;, irrespective of dimensionality.</source>
          <target state="translated">지정된 &lt;code&gt;axis&lt;/code&gt; 따라 정렬 &lt;code&gt;a&lt;/code&gt; 인덱스 배열입니다 . 경우 &lt;code&gt;a&lt;/code&gt; 일차원, &lt;code&gt;a[index_array]&lt;/code&gt; A가 정렬 산출 &lt;code&gt;a&lt;/code&gt; . 보다 일반적으로 &lt;code&gt;np.take_along_axis(a, index_array, axis=axis)&lt;/code&gt; 는 차원에 관계없이 항상 정렬 된 &lt;code&gt;a&lt;/code&gt; 를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="a0dc6273aecd116e71b925f830b8b852ca18868e" translate="yes" xml:space="preserve">
          <source>Array of indices that sort &lt;code&gt;a&lt;/code&gt; along the specified axis. In other words, &lt;code&gt;a[index_array]&lt;/code&gt; yields a sorted &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">지정된 축을 따라 정렬 &lt;code&gt;a&lt;/code&gt; 인덱스 배열입니다 . 즉, &lt;code&gt;a[index_array]&lt;/code&gt; 는 정렬 된 &lt;code&gt;a&lt;/code&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="87cf8b4326e4bf74829f6ee998b605e627a3e05c" translate="yes" xml:space="preserve">
          <source>Array of indices that sort the keys along the specified axis.</source>
          <target state="translated">지정된 축을 따라 키를 정렬하는 인덱스 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9ba877503fdc9b234f8b5bd4ff989ab5b66a993a" translate="yes" xml:space="preserve">
          <source>Array of insertion points with the same shape as &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;v&lt;/code&gt; 와 모양이 같은 삽입 점 배열 .</target>
        </trans-unit>
        <trans-unit id="eda2f2ab5893d6c8f805112f168403bde8914bdc" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n//2 + 1&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">샘플 주파수를 포함하는 길이 &lt;code&gt;n//2 + 1&lt;/code&gt; 배열 .</target>
        </trans-unit>
        <trans-unit id="16403e1679edece0422b414ba8df64826286ea95" translate="yes" xml:space="preserve">
          <source>Array of length &lt;code&gt;n&lt;/code&gt; containing the sample frequencies.</source>
          <target state="translated">샘플 주파수를 포함하는 길이 &lt;code&gt;n&lt;/code&gt; 의 배열 .</target>
        </trans-unit>
        <trans-unit id="3e56b710dd7f0b21c34a3b08ffd09a687bf4487b" translate="yes" xml:space="preserve">
          <source>Array of list objects</source>
          <target state="translated">리스트 객체의 배열</target>
        </trans-unit>
        <trans-unit id="8a37d72f2b1b4102a1be6ef75c473c25a6af0723" translate="yes" xml:space="preserve">
          <source>Array of multipliers.</source>
          <target state="translated">승수의 배열.</target>
        </trans-unit>
        <trans-unit id="206e9ffd7bd541d0301a39acc4ace879a4a8c4c0" translate="yes" xml:space="preserve">
          <source>Array of numbers to be decomposed.</source>
          <target state="translated">분해 할 숫자의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b8d93545bf76db1e421350de1ab5b27bda265c94" translate="yes" xml:space="preserve">
          <source>Array of ones with the given shape, dtype, and order.</source>
          <target state="translated">주어진 모양, dtype 및 순서를 가진 것의 배열.</target>
        </trans-unit>
        <trans-unit id="2a7562df8fd2349ba86c3e8c830bce9f44d2768c" translate="yes" xml:space="preserve">
          <source>Array of ones with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">모양과 유형이 &lt;code&gt;a&lt;/code&gt; 와 동일한 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="c57697e4962f7c2af124e859e719b69080933cff" translate="yes" xml:space="preserve">
          <source>Array of ones.</source>
          <target state="translated">하나의 배열.</target>
        </trans-unit>
        <trans-unit id="baa4adf58634fb06ef6ad2372bc5421740221f26" translate="yes" xml:space="preserve">
          <source>Array of points of the same shape as &lt;code&gt;x&lt;/code&gt;, after application of the linear map between the two domains.</source>
          <target state="translated">두 도메인간에 선형 맵을 적용한 후 &lt;code&gt;x&lt;/code&gt; 와 동일한 모양의 점으로 구성된 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="e10ad4b8d9ac04992efd38f05d15c560adaf42ef" translate="yes" xml:space="preserve">
          <source>Array of points. The dtype is converted to float64 or complex128 depending on whether any of the elements are complex. If &lt;code&gt;x&lt;/code&gt; is scalar it is converted to a 1-D array.</source>
          <target state="translated">점의 배열. 요소가 복잡한 지 여부에 따라 dtype이 float64 또는 complex128로 변환됩니다. 경우에 &lt;code&gt;x&lt;/code&gt; 는 스칼라이고 이는 1-D 어레이로 변환된다.</target>
        </trans-unit>
        <trans-unit id="2608e7cd905fe0c68e32ec9f1d08d5e186ac4133" translate="yes" xml:space="preserve">
          <source>Array of polynomial coefficients. If c is multidimensional the different axis correspond to different variables with the degree in each axis given by the corresponding index.</source>
          <target state="translated">다항식 계수의 배열. c가 다차원 인 경우, 다른 축은 대응하는 인덱스에 의해 주어진 각 축의 차수를 갖는 다른 변수에 대응한다.</target>
        </trans-unit>
        <trans-unit id="df9f1c9c3e6efbfb4f90ed818292071092d8d4f0" translate="yes" xml:space="preserve">
          <source>Array of random floats of shape &lt;code&gt;size&lt;/code&gt; (unless &lt;code&gt;size=None&lt;/code&gt;, in which case a single float is returned).</source>
          <target state="translated">모양 &lt;code&gt;size&lt;/code&gt; 의 임의의 부동 소수점 배열 ( &lt;code&gt;size=None&lt;/code&gt; 이 아닌 경우 단일 부동 소수점이 반환 됨).</target>
        </trans-unit>
        <trans-unit id="8c27164f605bc6a37751898bf3ccca7ad65d8b8c" translate="yes" xml:space="preserve">
          <source>Array of roots. If &lt;code&gt;r&lt;/code&gt; is multidimensional the first index is the root index, while the remaining indices enumerate multiple polynomials. For instance, in the two dimensional case the roots of each polynomial may be thought of as stored in the columns of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">뿌리의 배열. 경우 &lt;code&gt;r&lt;/code&gt; 다차원 나머지 인덱스 여러 다항식을 열거하는 동안 첫번째 인덱스는 원시 인덱스이다. 예를 들어, 2 차원 경우에, 각 다항식의 근은 &lt;code&gt;r&lt;/code&gt; 의 열에 저장된 것으로 생각 될 수있다 .</target>
        </trans-unit>
        <trans-unit id="f5e105f8faad33b4f50f2c4896fe5c70b476d2c2" translate="yes" xml:space="preserve">
          <source>Array of the roots of the polynomial. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">다항식의 근의 배열입니다. 모든 뿌리가 진짜라면 &lt;code&gt;out&lt;/code&gt; 도 진짜입니다. 그렇지 않으면 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="4d0d9a7ae0205565ce5ab6637ea0bc6fd758edf0" translate="yes" xml:space="preserve">
          <source>Array of the roots of the series. If all the roots are real, then &lt;code&gt;out&lt;/code&gt; is also real, otherwise it is complex.</source>
          <target state="translated">시리즈의 근의 배열입니다. 모든 뿌리가 진짜라면 &lt;code&gt;out&lt;/code&gt; 도 진짜입니다. 그렇지 않으면 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d523e60421af0d15597be465d458af223885d81e" translate="yes" xml:space="preserve">
          <source>Array of the same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 동일한 모양의 배열입니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="8fb65c76565be83184293a727b86b612f6baa966" translate="yes" xml:space="preserve">
          <source>Array of the same type and shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">동일한 유형의 배열 및 형상 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cde597bca9a6bd0298c0f76843af628711adacdc" translate="yes" xml:space="preserve">
          <source>Array of two or more dimensions.</source>
          <target state="translated">2 차원 이상의 배열.</target>
        </trans-unit>
        <trans-unit id="9c36b99254e0fa9d0972f22709ef88f81c5217da" translate="yes" xml:space="preserve">
          <source>Array of twos exponents. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">두 지수의 배열. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="ef176723af239a8b84441eb4e1012c9997a74190" translate="yes" xml:space="preserve">
          <source>Array of type uint8 whose elements represent bits corresponding to the logical (0 or nonzero) value of the input elements. The shape of &lt;code&gt;packed&lt;/code&gt; has the same number of dimensions as the input (unless &lt;code&gt;axis&lt;/code&gt; is None, in which case the output is 1-D).</source>
          <target state="translated">요소가 입력 요소의 논리적 (0 또는 0이 아닌) 값에 해당하는 비트를 나타내는 uint8 유형의 배열입니다. &lt;code&gt;packed&lt;/code&gt; 모양은 입력과 차원 수가 동일합니다 ( &lt;code&gt;axis&lt;/code&gt; 이 없음 인 경우 출력이 1D 임).</target>
        </trans-unit>
        <trans-unit id="d136dd4eb12fa67aaa6854e035f05c7d1d6e0269" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data of the given shape, dtype, and order. Object arrays will be initialized to None.</source>
          <target state="translated">지정된 모양, dtype 및 순서의 초기화되지 않은 (임의의) 데이터 배열입니다. 객체 배열은 None으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="84a6a10448bc129791439e6ef9301081b2eae3db" translate="yes" xml:space="preserve">
          <source>Array of uninitialized (arbitrary) data with the same shape and type as &lt;code&gt;prototype&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;prototype&lt;/code&gt; 과 동일한 모양과 유형을 가진 초기화되지 않은 (임의의) 데이터 배열 .</target>
        </trans-unit>
        <trans-unit id="1b00e6648235fca7be6befd806901affb44faa6e" translate="yes" xml:space="preserve">
          <source>Array of variates drawn from the multivariate hypergeometric distribution.</source>
          <target state="translated">다변량 초기 하 분포에서 추출 된 변량의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="e791423834bca116a632635c62e713e7f9a7037b" translate="yes" xml:space="preserve">
          <source>Array of zeros with the given shape, dtype, and order.</source>
          <target state="translated">지정된 모양, dtype 및 순서를 가진 0으로 구성된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="5118cee064bbe572e4b1416e1f0671b0db1bf70d" translate="yes" xml:space="preserve">
          <source>Array of zeros with the same shape and type as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 모양 및 유형이 같은 0으로 구성된 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="16e772e7005bc124d579516af58c7fbb273b27a8" translate="yes" xml:space="preserve">
          <source>Array or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; object of the difference polynomial&amp;rsquo;s coefficients.</source>
          <target state="translated">차 다항식 계수의 배열 또는 &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="dbb2927a7be8102e0b46249ee761be13ecebeed6" translate="yes" xml:space="preserve">
          <source>Array or sequence of arrays storing the fields to add to the base.</source>
          <target state="translated">베이스에 추가 할 필드를 저장하는 배열 또는 배열 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="95f2bfa93bf415207add71f7123707aa76abefda" translate="yes" xml:space="preserve">
          <source>Array output</source>
          <target state="translated">어레이 출력</target>
        </trans-unit>
        <trans-unit id="de7dfcc33834d14fc2a907169048d0358bdabe51" translate="yes" xml:space="preserve">
          <source>Array output, specified fill-in value</source>
          <target state="translated">배열 출력, 지정된 채우기 값</target>
        </trans-unit>
        <trans-unit id="367e141a4fff1b31230cbf6695c1abe0275a3a68" translate="yes" xml:space="preserve">
          <source>Array priority.</source>
          <target state="translated">배열 우선 순위.</target>
        </trans-unit>
        <trans-unit id="8afc8a14b9ea339f994a4b92b64eeee0fec93781" translate="yes" xml:space="preserve">
          <source>Array property returning the array transposed.</source>
          <target state="translated">전치 된 배열을 반환하는 배열 속성입니다.</target>
        </trans-unit>
        <trans-unit id="e80625fd7e8e2e9a68261ea8336b974ac71427ae" translate="yes" xml:space="preserve">
          <source>Array protocol: Python side</source>
          <target state="translated">배열 프로토콜 : 파이썬 측</target>
        </trans-unit>
        <trans-unit id="4090e62e110e0132c9a83e32a1060b0b2b11ae1b" translate="yes" xml:space="preserve">
          <source>Array protocol: struct</source>
          <target state="translated">배열 프로토콜 : struct</target>
        </trans-unit>
        <trans-unit id="8bf3a8f5e4206285d07a06e43310e4a207d5bd53" translate="yes" xml:space="preserve">
          <source>Array representing the Chebyshev series of their sum.</source>
          <target state="translated">Chebyshev 계열의 합을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="eb3f194c486d46ce1508a5889e8d0e228c628dfe" translate="yes" xml:space="preserve">
          <source>Array representing the Hermite series of their sum.</source>
          <target state="translated">Hermite 계열의 합을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="18e93cb56abb59b15e14ea61f7ed36817dbde4e6" translate="yes" xml:space="preserve">
          <source>Array representing the Laguerre series of their sum.</source>
          <target state="translated">Laguerre 계열의 합을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="ec5ec69f7e2ff45ce04c960bdf2303ea70114cd3" translate="yes" xml:space="preserve">
          <source>Array representing the Legendre series of their sum.</source>
          <target state="translated">합의 Legendre 계열을 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="edc338d6dbe8df5cb4ad885aef823a83fa3236d0" translate="yes" xml:space="preserve">
          <source>Array representing the result of the multiplication.</source>
          <target state="translated">곱셈 결과를 나타내는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="016974069d41d6a6d61d2549905026f66c136979" translate="yes" xml:space="preserve">
          <source>Array scalar checks the value, array does not</source>
          <target state="translated">배열 스칼라는 값을 확인하지만 배열은 그렇지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc176eaf5a192bedc6a645855de021bd9ca0e1d1" translate="yes" xml:space="preserve">
          <source>Array scalar type</source>
          <target state="translated">배열 스칼라 유형</target>
        </trans-unit>
        <trans-unit id="2ef4e544d40cf2979c0c92b90830370b3508c12a" translate="yes" xml:space="preserve">
          <source>Array scalars can be indexed like 0-dimensional arrays: if &lt;em&gt;x&lt;/em&gt; is an array scalar,</source>
          <target state="translated">배열 스칼라는 0 차원 배열과 같이 인덱싱 할 수 있습니다. &lt;em&gt;x&lt;/em&gt; 가 배열 스칼라 인 경우,</target>
        </trans-unit>
        <trans-unit id="e33eacc8d6c4dbb6e2b8986e0cc11de2dc224ecc" translate="yes" xml:space="preserve">
          <source>Array scalars have exactly the same methods as arrays. The default behavior of these methods is to internally convert the scalar to an equivalent 0-dimensional array and to call the corresponding array method. In addition, math operations on array scalars are defined so that the same hardware flags are set and used to interpret the results as for &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt;, so that the error state used for ufuncs also carries over to the math on array scalars.</source>
          <target state="translated">배열 스칼라는 배열과 정확히 같은 방법을 갖습니다. 이 메소드의 기본 동작은 스칼라를 내부적으로 동등한 0 차원 배열로 변환하고 해당 배열 메소드를 호출하는 것입니다. 또한 배열 스칼라에 대한 수학 연산이 정의되어 &lt;a href=&quot;ufuncs#ufuncs&quot;&gt;ufunc&lt;/a&gt; 와 동일한 하드웨어 플래그가 설정되고 결과를 해석하는 데 사용 되므로 ufuncs 에 사용되는 오류 상태도 배열 스칼라에 대한 수학으로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="037bfe1a4a99bed13c2116a48ffe9e15e096321a" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">배열 스칼라에는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 와 동일한 속성 및 메서드가 있습니다 . &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;1&lt;/a&gt; 이를 통해 배열과 동일한 기반에있는 배열의 항목을 부분적으로 처리하여 스칼라 및 배열 연산을 혼합 할 때 발생하는 거친 가장자리를 부드럽게 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3e59079f5e7b1524c0f3bc70e22cf06a0ad4de" translate="yes" xml:space="preserve">
          <source>Array scalars have the same attributes and methods as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; This allows one to treat items of an array partly on the same footing as arrays, smoothing out rough edges that result when mixing scalar and array operations.</source>
          <target state="translated">배열 스칼라는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 와 동일한 속성 및 메소드를 갖습니다 . &lt;a href=&quot;#id2&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 이것은 스칼라와 배열 연산을 혼합 할 때 발생하는 거친 가장자리를 부드럽게하여 배열의 항목을 배열과 동일한 기초에 부분적으로 처리 할 수있게합니다.</target>
        </trans-unit>
        <trans-unit id="646d54d2caceda76929950b800cb978c81f4566e" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;a href=&quot;#numpy.str_&quot;&gt;&lt;code&gt;str_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.bytes_&quot;&gt;&lt;code&gt;bytes_&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.void&quot;&gt;&lt;code&gt;void&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">배열 스칼라는 데이터 유형의 계층 구조 (아래 그림 참조)에 있습니다. 계층 구조를 사용하여 감지 할 수 있습니다. 예를 들어, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; 은 &lt;em&gt;val&lt;/em&gt; 이 배열 스칼라 객체 인 경우 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 를 반환 합니다. 또는 어떤 종류의 배열 스칼라가 존재하는지 데이터 유형 계층의 다른 멤버를 사용하여 판별 할 수 있습니다. 따라서 예를 들어 &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; 은 &lt;em&gt;val&lt;/em&gt; 이 복합 값 유형 이면 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 를 반환 하고, &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; 은 &lt;em&gt;val&lt;/em&gt; 이 유연한 항목 화 배열 유형 ( &lt;a href=&quot;#numpy.str_&quot;&gt; &lt;code&gt;str_&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.bytes_&quot;&gt; &lt;code&gt;bytes_&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.void&quot;&gt; &lt;code&gt;void&lt;/code&gt; &lt;/a&gt; ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9ed6ac908bf9aa1daed6dabda3ab37ae3cfe93cc" translate="yes" xml:space="preserve">
          <source>Array scalars live in a hierarchy (see the Figure below) of data types. They can be detected using the hierarchy: For example, &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is an array scalar object. Alternatively, what kind of array scalar is present can be determined using other members of the data type hierarchy. Thus, for example &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; will return &lt;code&gt;True&lt;/code&gt; if &lt;em&gt;val&lt;/em&gt; is a complex valued type, while &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; will return true if &lt;em&gt;val&lt;/em&gt; is one of the flexible itemsize array types (&lt;code&gt;string&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">배열 스칼라는 데이터 유형의 계층 구조 (아래 그림 참조)에 있습니다. 예를 들어, &lt;em&gt;val&lt;/em&gt; 이 배열 스칼라 객체 인 경우 &lt;code&gt;isinstance(val, np.generic)&lt;/code&gt; 는 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다. 대안 적으로, 어떤 종류의 배열 스칼라가 존재하는지는 데이터 유형 계층의 다른 멤버를 사용하여 결정될 수있다. 따라서, 예를 들어 대 &lt;code&gt;isinstance(val, np.complexfloating)&lt;/code&gt; 반환 &lt;code&gt;True&lt;/code&gt; 경우 &lt;em&gt;브로는&lt;/em&gt; 복소 값 형태 인 반면, &lt;code&gt;isinstance(val, np.flexible)&lt;/code&gt; 경우에 true를 반환 &lt;em&gt;브로는&lt;/em&gt; 가요 itemsize 어레이 타입 (하나 인 &lt;code&gt;string&lt;/code&gt; , &lt;code&gt;unicode&lt;/code&gt; , &lt;code&gt;void&lt;/code&gt; ).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="656531cc575d33e2858cc0fa46ccccf4a68a1757" translate="yes" xml:space="preserve">
          <source>Array shape.</source>
          <target state="translated">배열 모양.</target>
        </trans-unit>
        <trans-unit id="ef64ccc224961e26021d9bca9dc014037c55120d" translate="yes" xml:space="preserve">
          <source>Array structure and data access</source>
          <target state="translated">배열 구조 및 데이터 액세스</target>
        </trans-unit>
        <trans-unit id="342f29da2bf216f5bdf0ad7248aaa9e71a355727" translate="yes" xml:space="preserve">
          <source>Array that selects which entries to return. If len(condition) is less than the size of &lt;code&gt;a&lt;/code&gt; along the given axis, then output is truncated to the length of the condition array.</source>
          <target state="translated">반환 할 항목을 선택하는 배열입니다. len (condition)이 주어진 축을 따라 &lt;code&gt;a&lt;/code&gt; 의 크기보다 작 으면 출력이 조건 배열의 길이로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="592206156ca99ae21d8e7426eb607780c1bba521" translate="yes" xml:space="preserve">
          <source>Array that suppressed values indicated by a mask:</source>
          <target state="translated">마스크로 표시된 값을 억제 한 배열 :</target>
        </trans-unit>
        <trans-unit id="87d2918cacf26a2502b4f9340bca07e66e5e74fe" translate="yes" xml:space="preserve">
          <source>Array to be divided into sub-arrays.</source>
          <target state="translated">하위 배열로 나눌 배열입니다.</target>
        </trans-unit>
        <trans-unit id="e4b60ba832fd5d14a8b64e94627ba0a71256396f" translate="yes" xml:space="preserve">
          <source>Array to be reshaped.</source>
          <target state="translated">재구성 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="873958f5c5efd8efa35f71b483ecb2b2925a1b71" translate="yes" xml:space="preserve">
          <source>Array to be resized.</source>
          <target state="translated">크기를 조정할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a56492e54afe7d74e97671bd4eee3157258038ae" translate="yes" xml:space="preserve">
          <source>Array to be shuffled.</source>
          <target state="translated">셔플 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="b52f152b24d91c43ef9fb5209bce09865fb8369b" translate="yes" xml:space="preserve">
          <source>Array to be sorted.</source>
          <target state="translated">정렬 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="6b0f55aa6f40b643ba50d2b1a53516ef1346869f" translate="yes" xml:space="preserve">
          <source>Array to check for masked values.</source>
          <target state="translated">마스크 된 값을 확인하기위한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="20f86a6d67f17e927d1d04df5d4b886d82463103" translate="yes" xml:space="preserve">
          <source>Array to create a new.</source>
          <target state="translated">새로운 것을 만들기위한 배열.</target>
        </trans-unit>
        <trans-unit id="38e408cec29face92846919cb92911927e113755" translate="yes" xml:space="preserve">
          <source>Array to create the sliding window view from.</source>
          <target state="translated">슬라이딩 창보기를 만들 배열입니다.</target>
        </trans-unit>
        <trans-unit id="a70bc91712a140c808e5cb79192527e68b6c9390" translate="yes" xml:space="preserve">
          <source>Array to mask</source>
          <target state="translated">마스크 할 배열</target>
        </trans-unit>
        <trans-unit id="d43e409e24f30f0a6d90180b76c2efb4ab130452" translate="yes" xml:space="preserve">
          <source>Array to mask.</source>
          <target state="translated">마스크 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="83c52b56e1210abcac3501b49e1d67729c904dfd" translate="yes" xml:space="preserve">
          <source>Array to put data into.</source>
          <target state="translated">데이터를 넣을 배열.</target>
        </trans-unit>
        <trans-unit id="fd5b40620a3c780ffc94d7f339fd1c7607c14c60" translate="yes" xml:space="preserve">
          <source>Array to sort.</source>
          <target state="translated">정렬 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="63fbdd1db19d27a9a5c7eab3d132c8bb3f503729" translate="yes" xml:space="preserve">
          <source>Array to test.</source>
          <target state="translated">테스트 할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="55a565dc87ad0f5b9c2ac3f528dacc1158c373a0" translate="yes" xml:space="preserve">
          <source>Array type testing</source>
          <target state="translated">배열 유형 테스트</target>
        </trans-unit>
        <trans-unit id="585f95a404e839b1977230612e779c3487e0200e" translate="yes" xml:space="preserve">
          <source>Array types and conversions between types</source>
          <target state="translated">배열 유형 및 유형 간 변환</target>
        </trans-unit>
        <trans-unit id="023792f2b2e17a7b6e86f7c45b577b4c007acb28" translate="yes" xml:space="preserve">
          <source>Array types can also be referred to by character codes, mostly to retain backward compatibility with older packages such as Numeric. Some documentation may still refer to these, for example:</source>
          <target state="translated">배열 유형은 문자 코드로도 참조 할 수 있으며 주로 Numeric과 같은 이전 패키지와의 역 호환성을 유지합니다. 예를 들어, 일부 문서는 여전히 이들을 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="03d6303545819c17e2ef1222e68fb70dc26c55f8" translate="yes" xml:space="preserve">
          <source>Array whose &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt; is a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt; 이 &lt;a href=&quot;#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 인 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="e4bb8dd78a4c9a8f67c530c9ad1b7a619c52bea4" translate="yes" xml:space="preserve">
          <source>Array whose diagonal is to be filled, it gets modified in-place.</source>
          <target state="translated">대각선을 채울 배열은 제자리에서 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="82c627b6cd9b7d074082f31470ca27bba3557192" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">아래쪽 삼각형이 1로 채워지고 다른 곳에서는 0으로 배열됩니다. 다시 말하면 &lt;code&gt;i &amp;lt;= j + k&lt;/code&gt; 경우 &lt;code&gt;T[i,j] == 1&lt;/code&gt; 이고 , 그렇지 않으면 0입니다.</target>
        </trans-unit>
        <trans-unit id="b85c2934c5f2a59bc2e12dac7625860a488c925e" translate="yes" xml:space="preserve">
          <source>Array with its lower triangle filled with ones and zero elsewhere; in other words &lt;code&gt;T[i,j] == 1&lt;/code&gt; for &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt;, 0 otherwise.</source>
          <target state="translated">아래쪽 삼각형이 1과 0으로 채워진 배열. 환언 &lt;code&gt;T[i,j] == 1&lt;/code&gt; 대 &lt;code&gt;j &amp;lt;= i + k&lt;/code&gt; , 그렇지 않으면 0.</target>
        </trans-unit>
        <trans-unit id="41b54b4163faf0b1aa96452981f42d33d50824ef" translate="yes" xml:space="preserve">
          <source>Array with moved axes. This array is a view of the input array.</source>
          <target state="translated">축이 이동 한 배열. 이 배열은 입력 배열의보기입니다.</target>
        </trans-unit>
        <trans-unit id="84addce66651c27032bab9126d05042eeca1af0e" translate="yes" xml:space="preserve">
          <source>Array with specified requirements and type if given.</source>
          <target state="translated">지정된 요구 사항 및 유형이 지정된 배열.</target>
        </trans-unit>
        <trans-unit id="45f77fd17de7e78ac597a13bf5b178d24ee5d7aa" translate="yes" xml:space="preserve">
          <source>Array-checking restype/argtypes.</source>
          <target state="translated">배열 검사 restype / argtypes.</target>
        </trans-unit>
        <trans-unit id="54d7e23aa660ea078adfa79ac4b2e54c5ef44772" translate="yes" xml:space="preserve">
          <source>Array-protocol type strings (see &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;The Array Interface&lt;/a&gt;)</source>
          <target state="translated">배열 프로토콜 유형 문자열 ( &lt;a href=&quot;arrays.interface#arrays-interface&quot;&gt;어레이 인터페이스&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="7bf6ce513964e0342411a0531bf1b89c426a52c9" translate="yes" xml:space="preserve">
          <source>Array-scalar types</source>
          <target state="translated">배열 스칼라 유형</target>
        </trans-unit>
        <trans-unit id="8160528d25c4bf32940e604af5858cd6853079e6" translate="yes" xml:space="preserve">
          <source>ArrayLike</source>
          <target state="translated">ArrayLike</target>
        </trans-unit>
        <trans-unit id="91f0d52225d31ae76fcb11c767a8c5c08a4c298a" translate="yes" xml:space="preserve">
          <source>ArrayLike objects which do not define &lt;code&gt;__len__&lt;/code&gt; and &lt;code&gt;__getitem__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__len__&lt;/code&gt; 및 &lt;code&gt;__getitem__&lt;/code&gt; 을 정의하지 않는 ArrayLike 객체</target>
        </trans-unit>
        <trans-unit id="a50913b40e0e8d9dc26876d10bb49f2fa38c66fb" translate="yes" xml:space="preserve">
          <source>Array_like means all those objects &amp;ndash; lists, nested lists, etc. &amp;ndash; that can be converted to an array. We can also refer to variables like &lt;code&gt;var1&lt;/code&gt;.</source>
          <target state="translated">Array_like는 배열로 변환 할 수있는 모든 객체 (목록, 중첩 목록 등)를 의미합니다. &lt;code&gt;var1&lt;/code&gt; 과 같은 변수를 참조 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31b1e39950526e77b6041b42fc1b62056a817d46" translate="yes" xml:space="preserve">
          <source>Arrays &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; must have the same shape.</source>
          <target state="translated">배열 &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 는 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="f2499f813f17514e2097a1073a6cd307b768602d" translate="yes" xml:space="preserve">
          <source>Arrays based off readonly buffers cannot be set &lt;code&gt;writeable&lt;/code&gt;</source>
          <target state="translated">읽기 전용 버퍼를 기반으로하는 배열은 &lt;code&gt;writeable&lt;/code&gt; 으로 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f1c67ac3218c1c87b31cea1d27a13f34756f157a" translate="yes" xml:space="preserve">
          <source>Arrays can be both C-style and Fortran-style contiguous simultaneously. This is clear for 1-dimensional arrays, but can also be true for higher dimensional arrays.</source>
          <target state="translated">배열은 C 스타일과 포트란 스타일이 동시에 연속적 일 수 있습니다. 이것은 1 차원 배열에서는 분명하지만 더 높은 차원 배열에서도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="9cba266ac8d90f704b5607af4e06eea419c285f7" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">확장 된 Python 슬라이싱 구문 인 &lt;code&gt;array[selection]&lt;/code&gt; 사용하여 배열을 인덱싱 할 수 있습니다 . &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;구조화 된 데이터 유형의&lt;/a&gt; 필드에 액세스하는 데에도 유사한 구문이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="aac913dee168d782f611f9dc70790bf862c5b21d" translate="yes" xml:space="preserve">
          <source>Arrays can be indexed using an extended Python slicing syntax, &lt;code&gt;array[selection]&lt;/code&gt;. Similar syntax is also used for accessing fields in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;.</source>
          <target state="translated">확장 된 파이썬 슬라이싱 구문 인 &lt;code&gt;array[selection]&lt;/code&gt; 사용하여 배열을 인덱싱 할 수 있습니다 . &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;구조화 된 데이터 유형의&lt;/a&gt; 필드에 액세스 할 때도 비슷한 구문이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="7125fa97866bba33cfadfef25acde94b75f55b74" translate="yes" xml:space="preserve">
          <source>Arrays cannot be using subarray dtypes</source>
          <target state="translated">배열은 하위 배열 dtype을 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d674e5d59a78e41b46aaf270748b55f0fb8f59d0" translate="yes" xml:space="preserve">
          <source>Arrays do not need to have the same &lt;em&gt;number&lt;/em&gt; of dimensions. For example, if you have a &lt;code&gt;256x256x3&lt;/code&gt; array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rules, shows that they are compatible:</source>
          <target state="translated">배열 의 차원 &lt;em&gt;수가&lt;/em&gt; 같을 필요는 없습니다 . 예를 들어 RGB 값 의 &lt;code&gt;256x256x3&lt;/code&gt; 배열이 있고 이미지의 각 색상을 다른 값으로 배율 조정하려는 경우 이미지에 3 개의 값이있는 1 차원 배열을 곱할 수 있습니다. 브로드 캐스트 규칙에 따라 이러한 배열의 후행 축 크기를 정렬하면 호환된다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5cf5c66690e5daa90427ed3c7163aa6397d5aeea" translate="yes" xml:space="preserve">
          <source>Arrays may be repeated along dimensions of length 1.</source>
          <target state="translated">배열은 길이 1의 차원을 따라 반복 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00ec5e3a73cb29954290e60a6bc0ab13e3437ef3" translate="yes" xml:space="preserve">
          <source>Arrays may have a data-types containing fields, analogous to columns in a spread sheet. An example is &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt;, where each entry in the array is a pair of &lt;code&gt;(int, float)&lt;/code&gt;. Normally, these attributes are accessed using dictionary lookups such as &lt;code&gt;arr['x']&lt;/code&gt; and &lt;code&gt;arr['y']&lt;/code&gt;. Record arrays allow the fields to be accessed as members of the array, using &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.y&lt;/code&gt;.</source>
          <target state="translated">배열에는 스프레드 시트의 열과 유사한 필드를 포함하는 데이터 형식이있을 수 있습니다. 예를 들어 &lt;code&gt;[(x, int), (y, float)]&lt;/code&gt; . 여기서 배열의 각 항목은 &lt;code&gt;(int, float)&lt;/code&gt; 쌍입니다 . 일반적으로 이러한 속성은 &lt;code&gt;arr['x']&lt;/code&gt; 및 &lt;code&gt;arr['y']&lt;/code&gt; 와 같은 사전 검색을 사용하여 액세스합니다 . 레코드 배열을 사용하면 &lt;code&gt;arr.x&lt;/code&gt; 및 &lt;code&gt;arr.y&lt;/code&gt; 를 사용하여 필드를 배열의 구성원으로 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b36ecf0a7f7bd039ed5c1c0704a51fefda73d80e" translate="yes" xml:space="preserve">
          <source>Arrays may have more than one dimension, each which can be sliced individually:</source>
          <target state="translated">배열은 하나 이상의 차원을 가질 수 있으며 각 차원은 개별적으로 슬라이스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef7c0cea98d6d20ecb3d174c3213bef74e8bc018" translate="yes" xml:space="preserve">
          <source>Arrays of byte-strings are not swapped</source>
          <target state="translated">바이트 문자열 배열은 스왑되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d404bf1fb512f78d1d6fefbd98ddbbf1ae665dd2" translate="yes" xml:space="preserve">
          <source>Arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">N- 차원으로 균일 한 간격으로 배열 된 숫자.</target>
        </trans-unit>
        <trans-unit id="b8de1bbbfd3c637354288fac451e8a7c60ba28fc" translate="yes" xml:space="preserve">
          <source>Arrays of point coordinates, all of the same shape. The dtypes will be converted to either float64 or complex128 depending on whether any of the elements are complex. Scalars are converted to 1-D arrays.</source>
          <target state="translated">모두 동일한 모양의 점 좌표 배열. 요소가 복잡한 지 여부에 따라 dtypes가 float64 또는 complex128로 변환됩니다. 스칼라는 1 차원 배열로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="52434d147f7a6b19ab25a12561971251796b7c3c" translate="yes" xml:space="preserve">
          <source>Arrays of strings are not swapped</source>
          <target state="translated">문자열 배열은 교체되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fc13f22057f28c646ca1b198ca565af87af49f1b" translate="yes" xml:space="preserve">
          <source>Arrays of values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">값의 배열. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="e6f0032138e45d68f74e2c44f2f735c8b5313272" translate="yes" xml:space="preserve">
          <source>Arrays should be constructed using &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt;&lt;code&gt;zeros&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt;&lt;code&gt;empty&lt;/code&gt;&lt;/a&gt; (refer to the See Also section below). The parameters given here refer to a low-level method (&lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt;) for instantiating an array.</source>
          <target state="translated">배열은 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.zeros#numpy.zeros&quot;&gt; &lt;code&gt;zeros&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.empty#numpy.empty&quot;&gt; &lt;code&gt;empty&lt;/code&gt; 를&lt;/a&gt; 사용하여 구성해야합니다 (아래 참조 섹션 참조). 여기에 주어진 매개 변수 는 배열 인스턴스화를위한 저수준 메소드 ( &lt;code&gt;ndarray(&amp;hellip;)&lt;/code&gt; )를 참조합니다.</target>
        </trans-unit>
        <trans-unit id="28d3efbe465ae0abcb5a0dfba10ae7944a7f48a2" translate="yes" xml:space="preserve">
          <source>Arrays support the iterator protocol and can be iterated over like Python lists. See the &lt;a href=&quot;../user/quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;Indexing, Slicing and Iterating&lt;/a&gt; section in the Quickstart guide for basic usage and examples. The remainder of this document presents the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object and covers more advanced usage.</source>
          <target state="translated">배열은 반복기 프로토콜을 지원하며 Python 목록처럼 반복 될 수 있습니다. 기본 사용법 및 예제는 빠른 시작 가이드 의 &lt;a href=&quot;../user/quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;인덱싱, 분할 및 반복&lt;/a&gt; 섹션을 참조 하세요. 이 문서의 나머지 부분에서는 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 개체를 제공하고 고급 사용법을 다룹니다.</target>
        </trans-unit>
        <trans-unit id="bcfb0f71df3562232665c06d9cf63f39acceecc4" translate="yes" xml:space="preserve">
          <source>Arrays to be compared.</source>
          <target state="translated">비교할 배열입니다.</target>
        </trans-unit>
        <trans-unit id="c2fde1777833050ff202f7b922dc5d2847610f32" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Arrays will be saved in the file with the keyword names.</source>
          <target state="translated">파일에 저장할 배열입니다. 배열은 키워드 이름으로 파일에 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="4ba46cb118e6a4c1684691ff4c3a66ca5c9411f7" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">파일에 저장할 배열입니다. 파이썬이 외부 배열의 이름을 알 수 없기 때문에&lt;a href=&quot;#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;배열은&amp;ldquo;arr_0&amp;rdquo;,&amp;ldquo;arr_1&amp;rdquo;등의 이름으로 저장됩니다. 이러한 주장은 어떤 표현이든 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f51d18ef0f932163df8ae83aea003301ffa197e5" translate="yes" xml:space="preserve">
          <source>Arrays to save to the file. Since it is not possible for Python to know the names of the arrays outside &lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt;&lt;code&gt;savez&lt;/code&gt;&lt;/a&gt;, the arrays will be saved with names &amp;ldquo;arr_0&amp;rdquo;, &amp;ldquo;arr_1&amp;rdquo;, and so on. These arguments can be any expression.</source>
          <target state="translated">파일에 저장할 배열입니다. 파이썬이 외부 배열의 이름을 알 수 없기 때문에&lt;a href=&quot;numpy.savez#numpy.savez&quot;&gt; &lt;code&gt;savez&lt;/code&gt; &lt;/a&gt;배열은&amp;ldquo;arr_0&amp;rdquo;,&amp;ldquo;arr_1&amp;rdquo;등의 이름으로 저장됩니다. 이러한 주장은 어떤 표현이든 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44d87a6dc57d91b7292b09dc95f59e76af66bd2d" translate="yes" xml:space="preserve">
          <source>Arrays to stack. All of them must have the same first dimension.</source>
          <target state="translated">스택 할 배열입니다. 그들 모두는 첫 번째 차원이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="b99248188fbd19d8c22a40832b75d837dc4de460" translate="yes" xml:space="preserve">
          <source>Arrays with complex dtypes don&amp;rsquo;t return True.</source>
          <target state="translated">복잡한 dtype을 가진 배열은 True를 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a2bd40fc5b54aa90919de15beac751e23ad15489" translate="yes" xml:space="preserve">
          <source>Arrayterator (class in numpy.lib)</source>
          <target state="translated">Arrayterator (numpy.lib의 클래스)</target>
        </trans-unit>
        <trans-unit id="816e3f055425505d10d82fdb50f19dc782762aaa" translate="yes" xml:space="preserve">
          <source>Arrayterator.flat</source>
          <target state="translated">Arrayterator.flat</target>
        </trans-unit>
        <trans-unit id="e63ac43cdcb5a4238c7b9262748f81e7cf3457ea" translate="yes" xml:space="preserve">
          <source>Arrayterator.shape</source>
          <target state="translated">Arrayterator.shape</target>
        </trans-unit>
        <trans-unit id="62735fb443777d7de2d1c29ccbb762ccfb2be570" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, a masked array also inherits all the attributes and properties of a &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">으로 &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 이&lt;/a&gt; 의 서브 클래스입니다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 는&lt;/a&gt; , 마스크 배열은 속성과 속성 모든 상속 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="bdc5d12d9a06d1a300c059aee30b6e3298b8cd56" translate="yes" xml:space="preserve">
          <source>As Numeric has matured and developed into NumPy, people have been able to write more code directly in NumPy. Often this code is fast-enough for production use, but there are still times that there is a need to access compiled code. Either to get that last bit of efficiency out of the algorithm or to make it easier to access widely-available codes written in C/C++ or Fortran.</source>
          <target state="translated">Numeric이 성숙하고 NumPy로 발전함에 따라 사람들은 NumPy에서 직접 더 많은 코드를 작성할 수있게되었습니다. 종종이 코드는 프로덕션 용으로 충분히 빠르지 만 컴파일 된 코드에 액세스해야하는 경우가 있습니다. 알고리즘에서 효율성의 마지막 부분을 얻거나 C / C ++ 또는 Fortran으로 작성된 널리 사용 가능한 코드에 더 쉽게 액세스 할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="266410aaeb848f2f7510db1bcf8e20c2778f75df" translate="yes" xml:space="preserve">
          <source>As a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it inherits its mechanisms for indexing and slicing.</source>
          <target state="translated">A와 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 이&lt;/a&gt; 의 서브 클래스입니다 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; , 그것은 인덱싱과 슬라이싱에 대한 메커니즘을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="572a6b072b5d5bfb6b919bf3e8415158c50e5fd9" translate="yes" xml:space="preserve">
          <source>As a convenience for &lt;code&gt;__array_function__&lt;/code&gt; implementors, &lt;code&gt;types&lt;/code&gt; provides all argument types with an &lt;code&gt;'__array_function__'&lt;/code&gt; attribute. This allows implementors to quickly identify cases where they should defer to &lt;code&gt;__array_function__&lt;/code&gt; implementations on other arguments. Implementations should not rely on the iteration order of &lt;code&gt;types&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 구현 자의 편의를 위해 &lt;code&gt;types&lt;/code&gt; 는 모든 인수 유형에 &lt;code&gt;'__array_function__'&lt;/code&gt; 특성을 제공합니다. 이를 통해 구현 &lt;code&gt;__array_function__&lt;/code&gt; 다른 인수에 대한 __array_function__ 구현을 연기해야하는 경우를 신속하게 식별 할 수 있습니다 . 구현은 &lt;code&gt;types&lt;/code&gt; 의 반복 순서에 의존해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="943758d1e20ad4276263519968fa94f16b718bb2" translate="yes" xml:space="preserve">
          <source>As a corollary to this change, we no longer prohibit casting between datetimes with date units and datetimes with timeunits. With timezone naive datetimes, the rule for casting from dates to times is no longer ambiguous.</source>
          <target state="translated">이 변경의 결과로 더 이상 날짜 단위가있는 날짜 시간과 시간 단위가있는 날짜 시간 사이의 전송을 금지하지 않습니다. 시간대 순진 날짜 시간을 사용하면 날짜에서 시간으로의 캐스트 규칙이 더 이상 모호하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="013d98a5ec5b7f58afd0279b5cb85ae341df8643" translate="yes" xml:space="preserve">
          <source>As a final note: if the &lt;code&gt;super&lt;/code&gt; route is suited to a given class, an advantage of using it is that it helps in constructing class hierarchies. E.g., suppose that our other class &lt;code&gt;B&lt;/code&gt; also used the &lt;code&gt;super&lt;/code&gt; in its &lt;code&gt;__array_ufunc__&lt;/code&gt; implementation, and we created a class &lt;code&gt;C&lt;/code&gt; that depended on both, i.e., &lt;code&gt;class C(A, B)&lt;/code&gt; (with, for simplicity, not another &lt;code&gt;__array_ufunc__&lt;/code&gt; override). Then any ufunc on an instance of &lt;code&gt;C&lt;/code&gt; would pass on to &lt;code&gt;A.__array_ufunc__&lt;/code&gt;, the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;A&lt;/code&gt; would go to &lt;code&gt;B.__array_ufunc__&lt;/code&gt;, and the &lt;code&gt;super&lt;/code&gt; call in &lt;code&gt;B&lt;/code&gt; would go to &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt;, thus allowing &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; to collaborate.</source>
          <target state="translated">마지막으로, &lt;code&gt;super&lt;/code&gt; 라우트가 주어진 클래스에 적합한 경우 이를 사용하는 장점은 클래스 계층 구조를 구성하는 데 도움이된다는 것입니다. 예를 들면, 우리의 다른 클래스한다고 가정 &lt;code&gt;B&lt;/code&gt; 는 또한 사용 &lt;code&gt;super&lt;/code&gt; 의에서 &lt;code&gt;__array_ufunc__&lt;/code&gt; 구현을, 우리는 클래스 생성 &lt;code&gt;C&lt;/code&gt; 를 , 모두에 달려 있다는 즉, &lt;code&gt;class C(A, B)&lt;/code&gt; (단순성을 위해, 아니 다른과 &lt;code&gt;__array_ufunc__&lt;/code&gt; 의 대체). 다음의 인스턴스에 어떤 ufunc &lt;code&gt;C&lt;/code&gt; 가 에 전달할 것 &lt;code&gt;A.__array_ufunc__&lt;/code&gt; 의 &lt;code&gt;super&lt;/code&gt; 에서 호출 &lt;code&gt;A&lt;/code&gt; 는 에 갈 것 &lt;code&gt;B.__array_ufunc__&lt;/code&gt; 하고, &lt;code&gt;super&lt;/code&gt; 에서 전화 &lt;code&gt;B&lt;/code&gt; 가 에 갈 것 &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; 따라서 수 와 &lt;code&gt;B&lt;/code&gt; 를 공동으로. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="839c21dc6f9c35797b35f17417f1d765334d2a61" translate="yes" xml:space="preserve">
          <source>As a rough estimate, a sliding window approach with an input size of &lt;code&gt;N&lt;/code&gt; and a window size of &lt;code&gt;W&lt;/code&gt; will scale as &lt;code&gt;O(N*W)&lt;/code&gt; where frequently a special algorithm can achieve &lt;code&gt;O(N)&lt;/code&gt;. That means that the sliding window variant for a window size of 100 can be a 100 times slower than a more specialized version.</source>
          <target state="translated">대략적인 추정으로, 입력 크기가 &lt;code&gt;N&lt;/code&gt; 이고 창 크기가 &lt;code&gt;W&lt;/code&gt; 인 슬라이딩 창 접근 방식 은 &lt;code&gt;O(N*W)&lt;/code&gt; 로 확장되며 특수 알고리즘이 자주 &lt;code&gt;O(N)&lt;/code&gt; 얻을 수 있습니다 . 즉, 창 크기가 100 인 슬라이딩 창 변형은 더 전문화 된 버전보다 100 배 더 느릴 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="20a42179492180fa8aaa4dc644b08e20ca1aef18" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt;, there are a number of labels you can use.</source>
          <target state="translated">&lt;code&gt;pytest.mark.&amp;lt;label&amp;gt;&lt;/code&gt; 대신 사용할 수있는 레이블이 많이 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dab1c17c36782c312875481e08692d9b809435e" translate="yes" xml:space="preserve">
          <source>As an example, for &lt;code&gt;numpy.mean&lt;/code&gt; we would have:</source>
          <target state="translated">예를 들어, &lt;code&gt;numpy.mean&lt;/code&gt; 의 경우 다음과 같이됩니다.</target>
        </trans-unit>
        <trans-unit id="fecff8f943e371686abc1110d1711ebbbb86c5fa" translate="yes" xml:space="preserve">
          <source>As an example, see the 1.14.3 REL commit: &lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&lt;/a&gt;.</source>
          <target state="translated">예를 들어 1.14.3 REL 커밋 : &lt;a href=&quot;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93&quot;&gt;https://github.com/numpy/numpy/commit/73299826729be58cec179b52c656adfcaefada93을 참조하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7ec8e32822a5e0a0d90b5363a2541452778cbc3" translate="yes" xml:space="preserve">
          <source>As an example, we print out the result of broadcasting a one and a two dimensional array together.</source>
          <target state="translated">예를 들어, 1 차원 배열과 2 차원 배열을 함께 브로드 캐스트 한 결과를 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="8f262d8c602a1c1784a0611d8d573ccc9d004b7a" translate="yes" xml:space="preserve">
          <source>As an illustration, let&amp;rsquo;s consider the following dataset:</source>
          <target state="translated">예를 들어 다음 데이터 세트를 고려해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3c1410845edf2c868fb5a0fe8e6419a05b6e17f2" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt; that allows access to fields of structured arrays by attribute instead of only by index. Record arrays use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array. The &lt;code&gt;numpy.rec&lt;/code&gt; module provides functions for creating recarrays from various objects. Additional helper functions for creating and manipulating structured arrays can be found in &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">선택적 편의로 numpy는 인덱스가 아닌 속성으로 구조화 된 배열의 필드에 액세스 할 수 있는 ndarray 하위 클래스 인 &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;numpy.recarray&lt;/code&gt; &lt;/a&gt; 를 제공합니다 . 레코드 배열은 특수 데이터 유형 &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;numpy.record&lt;/code&gt; &lt;/a&gt; 를 사용하여 배열에서 얻은 구조화 된 스칼라의 속성에 의한 필드 액세스를 허용합니다. &lt;code&gt;numpy.rec&lt;/code&gt; 모듈을 다양한 개체로부터 recarrays를 만드는 기능을 제공한다. 구조화 된 배열을 만들고 조작하기위한 추가 도우미 함수는 &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt; &lt;code&gt;numpy.lib.recfunctions&lt;/code&gt; &lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06bd4fa6779fdd07b3d52175c70a52bf6deacdac" translate="yes" xml:space="preserve">
          <source>As an optional convenience numpy provides an ndarray subclass, &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt;, and associated helper functions in the &lt;code&gt;numpy.rec&lt;/code&gt; submodule, that allows access to fields of structured arrays by attribute instead of only by index. Record arrays also use a special datatype, &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt;, that allows field access by attribute on the structured scalars obtained from the array.</source>
          <target state="translated">선택적인 편의 NumPy와는 ndarray 서브 클래스 제공으로 &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;numpy.recarray&lt;/code&gt; &lt;/a&gt; , 그리고 관련 도우미 기능 &lt;code&gt;numpy.rec&lt;/code&gt; 속성에 의해 구조화 된 배열의 필드에 접근하는 대신 만의 인덱스를 허용 서브 모듈을,. 레코드 배열은 또한 배열에서 얻은 구조화 된 스칼라의 속성에 의한 필드 액세스를 허용 하는 특수 데이터 유형 &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;numpy.record&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ff6fd804dd39db5798ff08b4b25e0937a2c068e3" translate="yes" xml:space="preserve">
          <source>As an trivial example, consider this implementation of an &lt;code&gt;ArrayLike&lt;/code&gt; class that simply wraps a NumPy array and ensures that the result of any arithmetic operation is also an &lt;code&gt;ArrayLike&lt;/code&gt; object:</source>
          <target state="translated">사소한 예로서, 단순히 NumPy 배열을 감싸고 산술 연산의 결과가 &lt;code&gt;ArrayLike&lt;/code&gt; 객체 인지 확인 하는 &lt;code&gt;ArrayLike&lt;/code&gt; 클래스 의이 구현을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="cede8d515f0ee49ac10c9ddedbb9f437527bae9a" translate="yes" xml:space="preserve">
          <source>As can be seen, the &amp;ldquo;good&amp;rdquo; parts have shrunk to insignificance. In using Chebyshev polynomials for fitting we want to use the region where &lt;code&gt;x&lt;/code&gt; is between -1 and 1 and that is what the &lt;code&gt;window&lt;/code&gt; specifies. However, it is unlikely that the data to be fit has all its data points in that interval, so we use &lt;code&gt;domain&lt;/code&gt; to specify the interval where the data points lie. When the fit is done, the domain is first mapped to the window by a linear transformation and the usual least squares fit is done using the mapped data points. The window and domain of the fit are part of the returned series and are automatically used when computing values, derivatives, and such. If they aren&amp;rsquo;t specified in the call the fitting routine will use the default window and the smallest domain that holds all the data points. This is illustrated below for a fit to a noisy sine curve.</source>
          <target state="translated">보다시피, &quot;좋은&quot;부품은 무의미 해졌다. 피팅에 Chebyshev 다항식을 사용할 때 &lt;code&gt;x&lt;/code&gt; 가 -1과 1 사이 의 영역을 사용 하고 데이터 점이 놓이는 간격을 지정하는 &lt;code&gt;window&lt;/code&gt; 지정 합니다. 그러나 적합 할 데이터가 해당 간격의 모든 데이터 포인트를 가질 가능성은 낮으므로 &lt;code&gt;domain&lt;/code&gt; 을 사용 합니다. 됩니다. 맞춤이 완료되면 선형 변환에 의해 도메인이 먼저 창에 매핑되고 매핑 된 데이터 포인트를 사용하여 일반적으로 최소 제곱 맞춤이 수행됩니다. 적합의 창과 영역은 반환 된 계열의 일부이며 값, 미분 등을 계산할 때 자동으로 사용됩니다. 호출에 지정되지 않은 경우 피팅 루틴은 기본 창과 모든 데이터 포인트를 보유하는 가장 작은 도메인을 사용합니다. 시끄러운 사인 곡선에 맞추기 위해 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e0bc58a150fd519b1ef1b28d23e1c4528291bcac" translate="yes" xml:space="preserve">
          <source>As expected, this is a 768x1024 matrix:</source>
          <target state="translated">예상대로 이것은 768x1024 매트릭스입니다.</target>
        </trans-unit>
        <trans-unit id="c53fc1e45dbe406be17b6e30a5cfb9d43c0f2859" translate="yes" xml:space="preserve">
          <source>As explained previously, C-style contiguous arrays and Fortran-style contiguous arrays have particular striding patterns. Two array flags (&lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;) indicate whether or not the striding pattern of a particular array matches the C-style contiguous or Fortran-style contiguous or neither. Whether or not the striding pattern matches a standard C or Fortran one can be tested Using &lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt;&lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; (obj) and &lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt;&lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt;&lt;/a&gt; (obj) respectively. Most third-party libraries expect contiguous arrays. But, often it is not difficult to support general-purpose striding. I encourage you to use the striding information in your own code whenever possible, and reserve single-segment requirements for wrapping third-party code. Using the striding information provided with the ndarray rather than requiring a contiguous striding reduces copying that otherwise must be made.</source>
          <target state="translated">이전에 설명했듯이 C 스타일 연속 배열과 Fortran 스타일 연속 배열에는 특별한 striding 패턴이 있습니다. 두 개의 배열 플래그 ( &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/c-api/array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; )는 특정 배열의 striding 패턴이 C 스타일 연속 또는 포트란 스타일 연속과 일치하는지 여부를 나타냅니다. &lt;a href=&quot;../reference/c-api/array#c.PyArray_IS_C_CONTIGUOUS&quot;&gt; &lt;code&gt;PyArray_IS_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 패턴이 표준 C 또는 Fortran 패턴과 일치하는지 여부는 PyArray_IS_C_CONTIGUOUS (obj) 및 &lt;a href=&quot;../reference/c-api/array#c.PyArray_ISFORTRAN&quot;&gt; &lt;code&gt;PyArray_ISFORTRAN&lt;/code&gt; 을&lt;/a&gt; 사용하여 테스트 할 수 있습니다.(obj). 대부분의 타사 라이브러리는 연속 배열을 기대합니다. 그러나 종종 범용 보폭을 지원하는 것이 어렵지 않습니다. 가능한 한 자신의 코드에서 striding 정보를 사용하고 타사 코드를 래핑하기위한 단일 세그먼트 요구 사항을 예약하는 것이 좋습니다. 연속적인 striding을 요구하지 않고 ndarray와 함께 제공되는 striding 정보를 사용하면 다른 방법으로 만들어야하는 복사를 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fdede3e80508e2816102dcd54a9d5c797c31ec48" translate="yes" xml:space="preserve">
          <source>As for &lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;ndarray.tobytes&lt;/code&gt;&lt;/a&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">에 관해서는 &lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;ndarray.tobytes&lt;/code&gt; &lt;/a&gt; 등 모양, DTYPE에 대한 정보뿐만 아니라 약 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; , 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="6eb7f695a43a210c4ab19e5bc957617a28b1a107" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">에 관해서는 &lt;code&gt;ndarray.tobytes&lt;/code&gt; 등 모양, DTYPE에 대한 정보뿐만 아니라 약 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; , 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="442dd71dc758bc00985af7b82e3b46e788353af0" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;ndarray.tobytes&lt;/code&gt;, information about the shape, dtype, etc., but also about &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, will be lost.</source>
          <target state="translated">에 관해서는 &lt;code&gt;ndarray.tobytes&lt;/code&gt; 등 모양, DTYPE에 대한 정보뿐만 아니라 약 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; , 손실됩니다.</target>
        </trans-unit>
        <trans-unit id="b59d207ef2133a3867224936518ca5838dca25c9" translate="yes" xml:space="preserve">
          <source>As it turns out, numpy is smart enough when dealing with ufuncs to determine which index is the most rapidly varying one in memory and uses that for the innermost loop. Thus for ufuncs there is no large intrinsic advantage to either approach in most cases. On the other hand, use of .flat with an FORTRAN ordered array will lead to non-optimal memory access as adjacent elements in the flattened array (iterator, actually) are not contiguous in memory.</source>
          <target state="translated">numpy는 ufunc를 처리 할 때 메모리에서 가장 빠르게 변화하는 인덱스를 결정하고 가장 안쪽 루프에 사용하는 인덱스를 결정할 때 충분히 영리합니다. 따라서 ufuncs의 경우 대부분의 경우 두 가지 접근 방식에 비해 본질적인 이점이 없습니다. 반면, FORTRAN 정렬 배열과 함께 .flat을 사용하면 평면 배열 (실제로 반복자)의 인접 요소가 메모리에서 연속적이지 않으므로 최적의 메모리 액세스가 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bae171d630e66c8dccf252742ea919c5676002d9" translate="yes" xml:space="preserve">
          <source>As mentioned in the Notes section, &lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt;&lt;code&gt;assert_array_equal&lt;/code&gt;&lt;/a&gt; has special handling for scalars. Here the test checks that each value in &lt;code&gt;x&lt;/code&gt; is 3:</source>
          <target state="translated">Notes 섹션에서 언급했듯이 &lt;a href=&quot;#numpy.testing.assert_array_equal&quot;&gt; &lt;code&gt;assert_array_equal&lt;/code&gt; &lt;/a&gt; 에는 스칼라에 대한 특수 처리가 있습니다. 여기서 테스트는 &lt;code&gt;x&lt;/code&gt; 의 각 값 이 3인지 확인합니다.</target>
        </trans-unit>
        <trans-unit id="13dc2b7c8c10ac2fc73aefee2fde7f627c9b6aa2" translate="yes" xml:space="preserve">
          <source>As mentioned previously, the flat attribute of ndarray objects returns an iterator that will cycle over the entire array in C-style contiguous order.</source>
          <target state="translated">앞에서 언급했듯이 ndarray 객체의 flat 특성은 전체 배열을 C 스타일 연속 순서로 순환하는 반복자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1eeb436878ddf7f47ab4d8c1fb337ec14f285994" translate="yes" xml:space="preserve">
          <source>As mentioned, one can select a subset of an array to assign to using a single index, slices, and index and mask arrays. The value being assigned to the indexed array must be shape consistent (the same shape or broadcastable to the shape the index produces). For example, it is permitted to assign a constant to a slice:</source>
          <target state="translated">언급했듯이 단일 인덱스, 슬라이스, 인덱스 및 마스크 배열을 사용하여 할당 할 배열의 하위 집합을 선택할 수 있습니다. 인덱스 배열에 할당되는 값은 모양이 일치해야합니다 (인덱스가 생성하는 모양과 동일한 모양 또는 브로드 캐스트 가능). 예를 들어 슬라이스에 상수를 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6bb256df55b0c84359db8c790668112e195bd64a" translate="yes" xml:space="preserve">
          <source>As noted above the inverse Gaussian distribution first arise from attempts to model Brownian motion. It is also a competitor to the Weibull for use in reliability modeling and modeling stock returns and interest rate processes.</source>
          <target state="translated">위에서 언급 한 바와 같이 역 가우시안 분포는 먼저 브라운 운동을 모델링하려는 시도에서 발생합니다. 또한 주식 수익률 및 금리 프로세스의 신뢰성 모델링 및 모델링에 사용하기 위해 Weibull의 경쟁 업체입니다.</target>
        </trans-unit>
        <trans-unit id="ec730138fa95973e97f6613bc68aa1a1f0c5aafb" translate="yes" xml:space="preserve">
          <source>As of 1.6, this function simply calls &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt;&lt;code&gt;PyArray_CopyInto&lt;/code&gt;&lt;/a&gt;, which handles the casting.</source>
          <target state="translated">1.6 &lt;a href=&quot;#c.PyArray_CopyInto&quot;&gt; &lt;code&gt;PyArray_CopyInto&lt;/code&gt; &lt;/a&gt; 함수는 단순히 캐스팅을 처리하는 PyArray_CopyInto 를 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3f3530b3b21291b3dd3b74336008cc7a706ed945" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.10, the returned array will have the same type as the input array. (for example, a masked array will be returned for a masked array input)</source>
          <target state="translated">NumPy 1.10부터 반환 된 배열은 입력 배열과 동일한 유형을 갖습니다. (예를 들어, 마스크 배열은 마스크 배열 입력에 대해 반환됩니다)</target>
        </trans-unit>
        <trans-unit id="12042a22f9b6865da757e69e8d2ce21273a85e0c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing nan values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.4.0 &lt;a href=&quot;#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 는 nan 값을 포함하는 실수 / 복잡한 배열에서 작동합니다. 향상된 정렬 순서에 설명되어 있습니다 &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bba53cf9adf4ac58af71ddd4d6acfa9ee160b6ec" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.4.0 &lt;a href=&quot;#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; works with real/complex arrays containing &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; values. The enhanced sort order is documented in &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.4.0 현재 &lt;a href=&quot;#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; 는 &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; 값을 포함하는 실수 / 복잡한 배열로 작동 합니다. 향상된 정렬 순서에 설명되어 있습니다 &lt;a href=&quot;numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="17597aa038b28f9f5c8df2774b1f9eab6ad3af4c" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superceded by the new array iterator, &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.6.0 &lt;a href=&quot;c-api.iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; 배열 반복자는 새로운 배열 반복자 인 NpyIter 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="8364d1abaebc5d8b1444ea31949f7accfaa13ead" translate="yes" xml:space="preserve">
          <source>As of NumPy 1.6.0, these array iterators are superseded by the new array iterator, &lt;a href=&quot;iterator#c.NpyIter&quot;&gt;&lt;code&gt;NpyIter&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.6.0부터 이러한 배열 반복기는 새로운 배열 반복기 &lt;a href=&quot;iterator#c.NpyIter&quot;&gt; &lt;code&gt;NpyIter&lt;/code&gt; &lt;/a&gt; 로 대체됩니다 .</target>
        </trans-unit>
        <trans-unit id="7f60464691ec1296f5eb92b23ac7c66b95bdc223" translate="yes" xml:space="preserve">
          <source>As previously discussed, you can also set the argtypes attribute of the function in order to have ctypes check the types of the input arguments when the function is called. Use the &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; factory function to generate a ready-made class for data-type, shape, and flags checking on your new function. The &lt;a href=&quot;#ndpointer&quot;&gt;&lt;code&gt;ndpointer&lt;/code&gt;&lt;/a&gt; function has the signature</source>
          <target state="translated">앞에서 설명한 것처럼 함수가 호출 될 때 ctypes가 입력 인수의 유형을 확인하도록 함수의 argtypes 속성을 설정할 수도 있습니다. &lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; &lt;/a&gt; 팩토리 함수를 사용하여 새 함수에 대한 데이터 유형, 모양 및 플래그 검사를위한 기성 클래스를 생성합니다. &lt;a href=&quot;#ndpointer&quot;&gt; &lt;code&gt;ndpointer&lt;/code&gt; 의&lt;/a&gt; 기능은 서명이</target>
        </trans-unit>
        <trans-unit id="7e6c9caa222f474d8200d79ae5b20b408a1c8172" translate="yes" xml:space="preserve">
          <source>As shown in &lt;a href=&quot;#figure-2&quot;&gt;Figure 2&lt;/a&gt;, &lt;code&gt;b&lt;/code&gt; is added to each row of &lt;code&gt;a&lt;/code&gt;. When &lt;code&gt;b&lt;/code&gt; is longer than the rows of &lt;code&gt;a&lt;/code&gt;, as in &lt;a href=&quot;#figure-3&quot;&gt;Figure 3&lt;/a&gt;, an exception is raised because of the incompatible shapes.</source>
          <target state="translated">도시 된 바와 같이 &lt;a href=&quot;#figure-2&quot;&gt;,도 2&lt;/a&gt; , &lt;code&gt;b&lt;/code&gt; 각 행에 첨가 . 경우 &lt;code&gt;b&lt;/code&gt; 는 의 행보다 긴 마찬가지로, &lt;a href=&quot;#figure-3&quot;&gt;도 3&lt;/a&gt; , 예외가 있기 때문에 호환 도형 상승된다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0eb75b8579bfe992aa268341a4c85c6d503920b9" translate="yes" xml:space="preserve">
          <source>As the scale approaches infinity, the distribution becomes more like a Gaussian. Some references claim that the Wald is an inverse Gaussian with mean equal to 1, but this is by no means universal.</source>
          <target state="translated">스케일이 무한대에 가까울수록 분포는 가우시안처럼됩니다. 일부 참고 문헌은 Wald가 평균 1과 같은 역 가우시안이라고 주장하지만 이것이 보편적 인 것은 아닙니다.</target>
        </trans-unit>
        <trans-unit id="2f0e40b24d4f520710fd1ed228a57a1690ea8227" translate="yes" xml:space="preserve">
          <source>As well as the scalar array special case signaling that an integer array was interpreted as an integer index, which is important because an integer array index forces a copy but is ignored if a scalar is returned (full integer index). The prepared index is guaranteed to be valid with the exception of out of bound values and broadcasting errors for advanced indexing. This includes that an ellipsis is added for incomplete indices for example when a two dimensional array is indexed with a single integer.</source>
          <target state="translated">정수 배열이 정수 인덱스로 해석되었다는 신호를 표시하는 스칼라 배열 특수 사례뿐만 아니라 정수 배열 인덱스가 사본을 강제 실행하지만 스칼라가 리턴되는 경우 (전 정수 인덱스) 무시되므로 중요합니다. 준비된 인덱스는 범위를 벗어난 값과 고급 인덱싱에 대한 브로드 캐스트 오류를 ​​제외하고 유효합니다. 여기에는 2 차원 배열이 단일 정수로 색인화 될 때 불완전한 색인에 줄임표가 추가되는 것도 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="925814af80369e67056380832c2cbc226e28baa6" translate="yes" xml:space="preserve">
          <source>As with other container objects in Python, the contents of an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; can be accessed and modified by &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexing or slicing&lt;/a&gt; the array (using, for example, &lt;em&gt;N&lt;/em&gt; integers), and via the methods and attributes of the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python의 다른 컨테이너 객체와 마찬가지로 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 의 내용은 배열 을 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;인덱싱하거나 슬라이싱&lt;/a&gt; (예 : &lt;em&gt;N&lt;/em&gt; 정수 사용)하고 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 의 메소드 및 속성을 통해 액세스하고 수정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="52fd93066bad29b67273e079568eccef85b00fa0" translate="yes" xml:space="preserve">
          <source>As you can imagine from the introduction, there are two ways you can affect the relationship between the byte ordering of the array and the underlying memory it is looking at:</source>
          <target state="translated">소개에서 상상할 수 있듯이 배열의 바이트 순서와보고있는 기본 메모리 간의 관계에 영향을 미칠 수있는 두 가지 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2891acf8ae5fe1d5007874779732cde26b391a3" translate="yes" xml:space="preserve">
          <source>As you can see, the object can be initialized in the &lt;code&gt;__new__&lt;/code&gt; method or the &lt;code&gt;__init__&lt;/code&gt; method, or both, and in fact ndarray does not have an &lt;code&gt;__init__&lt;/code&gt; method, because all the initialization is done in the &lt;code&gt;__new__&lt;/code&gt; method.</source>
          <target state="translated">보시다시피 객체는 &lt;code&gt;__new__&lt;/code&gt; 메서드 나 &lt;code&gt;__init__&lt;/code&gt; 메서드 또는 둘 다 에서 초기화 될 수 있으며 , 모든 초기화가 &lt;code&gt;__new__&lt;/code&gt; 메서드 에서 수행되기 때문에 실제로 ndarray에는 &lt;code&gt;__init__&lt;/code&gt; 메서드 가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="3b4f7dc7b3c4a70ce9ff533c44a9b7a4a1713152" translate="yes" xml:space="preserve">
          <source>Asking for your changes to be merged with the main repo</source>
          <target state="translated">변경 사항이 기본 저장소와 병합되도록 요청</target>
        </trans-unit>
        <trans-unit id="b3cf9d2ab1eb546a2eba1efeb64eb1e97091b955" translate="yes" xml:space="preserve">
          <source>Assemble an nd-array from nested lists of blocks.</source>
          <target state="translated">중첩 된 블록 목록에서 배열을 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="74cbd6c218f89d00f752e7ba4b2b17d97a1a1ff7" translate="yes" xml:space="preserve">
          <source>Assemble arrays from blocks.</source>
          <target state="translated">블록에서 배열을 조립하십시오.</target>
        </trans-unit>
        <trans-unit id="de78d0a7b76ee6bba1ecaedfc383918b06ba62a9" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical imprecision with floats:</source>
          <target state="translated">부동 소수점을 사용한 수치 부정확성으로 Assert 실패 :</target>
        </trans-unit>
        <trans-unit id="79536b913447cc8edd9ecd5192bb8530d9a9202a" translate="yes" xml:space="preserve">
          <source>Assert fails with numerical inprecision with floats:</source>
          <target state="translated">부동 소수점이있는 숫자의 정밀도가 틀리면 Assert가 실패합니다.</target>
        </trans-unit>
        <trans-unit id="e3292c12a856a02722a46d87471ff4e6faefa104" translate="yes" xml:space="preserve">
          <source>AssertionError</source>
          <target state="translated">AssertionError</target>
        </trans-unit>
        <trans-unit id="561c16749736b8dbda1124817a2b4447de5e4505" translate="yes" xml:space="preserve">
          <source>Asserts</source>
          <target state="translated">Asserts</target>
        </trans-unit>
        <trans-unit id="289e36002d46d5808069779b9fe9f985a8b15407" translate="yes" xml:space="preserve">
          <source>Assigning data to a Structured Array</source>
          <target state="translated">구조적 배열에 데이터 할당</target>
        </trans-unit>
        <trans-unit id="8a799af040a420920800093adb9e84b1752618c3" translate="yes" xml:space="preserve">
          <source>Assigning to slices/views of &lt;code&gt;MaskedArray&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MaskedArray&lt;/code&gt; 의 슬라이스 / 뷰에 할당</target>
        </trans-unit>
        <trans-unit id="a63aa663ce3fd806853c6e1d56f0f1c1896855bd" translate="yes" xml:space="preserve">
          <source>Assigning values to indexed arrays</source>
          <target state="translated">인덱스 배열에 값 할당</target>
        </trans-unit>
        <trans-unit id="4d5174a57fec035b53144526667e457e11d00dd3" translate="yes" xml:space="preserve">
          <source>Assignment between two structured arrays occurs as if the source elements had been converted to tuples and then assigned to the destination elements. That is, the first field of the source array is assigned to the first field of the destination array, and the second field likewise, and so on, regardless of field names. Structured arrays with a different number of fields cannot be assigned to each other. Bytes of the destination structure which are not included in any of the fields are unaffected.</source>
          <target state="translated">두 구조화 된 배열 사이의 할당은 소스 요소가 튜플으로 변환 된 다음 대상 요소에 할당 된 것처럼 발생합니다. 즉, 소스 배열의 첫 번째 필드는 대상 배열의 첫 번째 필드에 할당되고 두 번째 필드도 마찬가지로 필드 이름에 관계없이 할당됩니다. 필드 수가 다른 구조화 된 배열은 서로 할당 할 수 없습니다. 필드에 포함되지 않은 대상 구조의 바이트는 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="acccf5c6ee3457ada97687fe5c7f1318e0893486" translate="yes" xml:space="preserve">
          <source>Assignment from Python Native Types (Tuples)</source>
          <target state="translated">Python 기본 유형 (튜플)에서 할당</target>
        </trans-unit>
        <trans-unit id="9cc21533901f2115eb4a3c32d19650f93349565e" translate="yes" xml:space="preserve">
          <source>Assignment from Scalars</source>
          <target state="translated">스칼라에서 할당</target>
        </trans-unit>
        <trans-unit id="4c57993301d1b6548c0e4939d7c7c8d9a2d56b2c" translate="yes" xml:space="preserve">
          <source>Assignment from other Structured Arrays</source>
          <target state="translated">다른 구조적 배열에서 할당</target>
        </trans-unit>
        <trans-unit id="fc5e2a82565507aaae14030e1c010088c6562688" translate="yes" xml:space="preserve">
          <source>Assignment involving subarrays</source>
          <target state="translated">하위 배열과 관련된 할당</target>
        </trans-unit>
        <trans-unit id="dc3ede0861439daaed8c3de08958646d9211be1a" translate="yes" xml:space="preserve">
          <source>Assignment of ndarray object&amp;rsquo;s &lt;code&gt;data&lt;/code&gt; attribute</source>
          <target state="translated">ndarray 객체의 &lt;code&gt;data&lt;/code&gt; 속성 할당</target>
        </trans-unit>
        <trans-unit id="2edeef440cbb6c2ba230df4bbf3e9bef68f36e23" translate="yes" xml:space="preserve">
          <source>Assignment to an array with a multi-field index modifies the original array:</source>
          <target state="translated">다중 필드 인덱스가있는 배열에 할당하면 원래 배열이 수정됩니다.</target>
        </trans-unit>
        <trans-unit id="af53b1c5013c72eb7aa598ce977b69cfb859c315" translate="yes" xml:space="preserve">
          <source>Assignment to the view modifies the original array. The view&amp;rsquo;s fields will be in the order they were indexed. Note that unlike for single-field indexing, the dtype of the view has the same itemsize as the original array, and has fields at the same offsets as in the original array, and unindexed fields are merely missing.</source>
          <target state="translated">보기에 할당하면 원래 배열이 수정됩니다. 뷰의 필드는 인덱싱 된 순서대로 표시됩니다. 단일 필드 인덱싱과 달리 뷰의 dtype은 원래 배열과 동일한 항목 크기를 가지며 원래 배열과 동일한 오프셋에 필드가 있으며 인덱싱되지 않은 필드는 단순히 누락됩니다.</target>
        </trans-unit>
        <trans-unit id="ed91fb02ba267588e9268d85784e62da51f799fd" translate="yes" xml:space="preserve">
          <source>Assignment vs referencing</source>
          <target state="translated">할당 vs 참조</target>
        </trans-unit>
        <trans-unit id="d8a1879dbe4b9ce9021e415e931186b4b4a19157" translate="yes" xml:space="preserve">
          <source>Assigns values from one structured array to another by field name.</source>
          <target state="translated">한 구조화 된 배열의 값을 필드 이름으로 다른 배열에 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ae9a24254ec6cd55a31a48c28461f44e73e53f66" translate="yes" xml:space="preserve">
          <source>Assume &lt;code&gt;mask_func&lt;/code&gt; is a function that, for a square array a of size &lt;code&gt;(n, n)&lt;/code&gt; with a possible offset argument &lt;code&gt;k&lt;/code&gt;, when called as &lt;code&gt;mask_func(a, k)&lt;/code&gt; returns a new array with zeros in certain locations (functions like &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt; do precisely this). Then this function returns the indices where the non-zero values would be located.</source>
          <target state="translated">가정 &lt;code&gt;mask_func&lt;/code&gt; 하는 크기의 정사각형 어레이 A의 것을 함수 &lt;code&gt;(n, n)&lt;/code&gt; 의 가능한 오프셋 인자와 &lt;code&gt;k&lt;/code&gt; 로 불리는 &lt;code&gt;mask_func(a, k)&lt;/code&gt; 특정 위치에서 제로로 새로운 배열을 반환 (같은 기능 &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; 정확히 이것을하십시오). 그런 다음이 함수는 0이 아닌 값이있는 인덱스를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="87a473db70c6a624c40e23afb12c39561d92a618" translate="yes" xml:space="preserve">
          <source>Assume &lt;em&gt;n&lt;/em&gt; is the number of elements in the dimension being sliced. Then, if &lt;em&gt;i&lt;/em&gt; is not given it defaults to 0 for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;n - 1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;j&lt;/em&gt; is not given it defaults to &lt;em&gt;n&lt;/em&gt; for &lt;em&gt;k &amp;gt; 0&lt;/em&gt; and &lt;em&gt;-n-1&lt;/em&gt; for &lt;em&gt;k &amp;lt; 0&lt;/em&gt; . If &lt;em&gt;k&lt;/em&gt; is not given it defaults to 1. Note that &lt;code&gt;::&lt;/code&gt; is the same as &lt;code&gt;:&lt;/code&gt; and means select all indices along this axis.</source>
          <target state="translated">&lt;em&gt;n&lt;/em&gt; 은 슬라이스되는 차원의 요소 수라고 가정합니다 . 그런 다음 &lt;em&gt;i&lt;/em&gt; 를 지정하지 않으면 &lt;em&gt;k&amp;gt; 0의&lt;/em&gt; 경우 기본값은 &lt;em&gt;0&lt;/em&gt; 이고 &lt;em&gt;k &amp;lt;0의 경우 &lt;/em&gt;&lt;em&gt;n-1&lt;/em&gt; 입니다 . 경우 &lt;em&gt;J는&lt;/em&gt; 에 그것을 디폴트 주어지지 &lt;em&gt;N&lt;/em&gt; 에 대한 &lt;em&gt;K&amp;gt; 0&lt;/em&gt; 과 &lt;em&gt;&amp;alpha;-1&lt;/em&gt; 위한 &lt;em&gt;K &amp;lt;0&lt;/em&gt; . 경우 &lt;em&gt;k는&lt;/em&gt; 1 주에에게 기본적으로 부여되지 않는다는는 &lt;code&gt;::&lt;/code&gt; 과 동일 &lt;code&gt;:&lt;/code&gt; 수단이 축을 따라 모든 인덱스를 선택합니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b9dccb798e5c5e1b5508e3a8630765c07522b225" translate="yes" xml:space="preserve">
          <source>Assume that the observations are in the columns of the observation array &lt;code&gt;m&lt;/code&gt; and let &lt;code&gt;f = fweights&lt;/code&gt; and &lt;code&gt;a = aweights&lt;/code&gt; for brevity. The steps to compute the weighted covariance are as follows:</source>
          <target state="translated">관찰은 관찰 어레이의 컬럼에 있다고 가정 &lt;code&gt;m&lt;/code&gt; 및하자 &lt;code&gt;f = fweights&lt;/code&gt; 와 &lt;code&gt;a = aweights&lt;/code&gt; 간결. 가중 공분산을 계산하는 단계는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="97728787c4c0fd66ac4cc28f08c4ba4e206f76e5" translate="yes" xml:space="preserve">
          <source>Assume we have three matrices</source>
          <target state="translated">세 개의 행렬이 있다고 가정</target>
        </trans-unit>
        <trans-unit id="68035e390827bfef5b6a722908902bf830e33068" translate="yes" xml:space="preserve">
          <source>Assuming that</source>
          <target state="translated">그것을 가정</target>
        </trans-unit>
        <trans-unit id="361dbf446d2fcbde7f8e5127964dd121d2c08adc" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;a&lt;/code&gt; is sorted:</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 정렬 되었다고 가정하면 :</target>
        </trans-unit>
        <trans-unit id="a66d954bab07db2d2ebde3811f3d1797fded0efb" translate="yes" xml:space="preserve">
          <source>Assuming the foo.ini.in file has the following content:</source>
          <target state="translated">foo.ini.in 파일에 다음 내용이 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="3d748459a93c925f679363da9105b14fbf94ff7f" translate="yes" xml:space="preserve">
          <source>Assuming you have followed the instructions in these pages, git will create a default link to your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo called &lt;code&gt;origin&lt;/code&gt;. In git &amp;gt;= 1.7 you can ensure that the link to origin is permanently set by using the &lt;code&gt;--set-upstream&lt;/code&gt; option:</source>
          <target state="translated">이 페이지의 지침을 따랐다 고 가정하면 git은 &lt;code&gt;origin&lt;/code&gt; 이라는 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 저장소에 대한 기본 링크를 생성합니다 . git&amp;gt; = 1.7에서는 &lt;code&gt;--set-upstream&lt;/code&gt; 옵션 을 사용하여 원본에 대한 링크가 영구적으로 설정되었는지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="deb0f65a2eba6ba7c9892f097c02bd25a54d7da6" translate="yes" xml:space="preserve">
          <source>Assuming you have your &lt;a href=&quot;development_environment#development-environment&quot;&gt;development environment&lt;/a&gt; set up, you can now build the code and test it.</source>
          <target state="translated">&lt;a href=&quot;development_environment#development-environment&quot;&gt;개발 환경이&lt;/a&gt; 설정 되었다고 가정하면 이제 코드를 빌드하고 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c95f65947e1bc255843aa11283635e0c0b35d4e" translate="yes" xml:space="preserve">
          <source>At &lt;em&gt;compile&lt;/em&gt; time, a distutils command is used to define the minimum and maximum features to support, based on user choice and compiler support. The appropriate macros are overlayed with the platform / architecture intrinsics, and the three loops are compiled.</source>
          <target state="translated">에서 &lt;em&gt;컴파일&lt;/em&gt; 시간하는의 distutils 명령은 사용자의 선택과 컴파일러 지원에 따라 지원 최소 및 최대 기능을 정의하는 데 사용됩니다. 적절한 매크로가 플랫폼 / 아키텍처 내장 함수로 오버레이되고 세 개의 루프가 컴파일됩니다.</target>
        </trans-unit>
        <trans-unit id="3efe13899297822b3fa2661ba300f5fe4b4634e5" translate="yes" xml:space="preserve">
          <source>At &lt;em&gt;runtime import&lt;/em&gt;, the CPU is probed for the set of supported intrinsic features. A mechanism is used to grab the pointer to the most appropriate function, and this will be the one called for the function.</source>
          <target state="translated">에서 &lt;em&gt;런타임 수입&lt;/em&gt; 의 CPU를 지원하는 고유 기능 세트에 대한 탐침된다. 가장 적절한 함수에 대한 포인터를 잡기 위해 메커니즘이 사용되며, 이것이 함수에 대해 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="0527fe789f4627f3a63d0bb5ba48121982fec81a" translate="yes" xml:space="preserve">
          <source>At each iteration of the loop, the &lt;em&gt;nin&lt;/em&gt; input objects are extracted from their object arrays and placed into an argument tuple, the Python &lt;em&gt;callable&lt;/em&gt; is called with the input arguments, and the nout outputs are placed into their object arrays.</source>
          <target state="translated">루프의 각 반복에서, &lt;em&gt;닌&lt;/em&gt; 입력 개체들은 객체 어레이로부터 추출 및 인수 튜플에 넣고, 파이썬 &lt;em&gt;호출은&lt;/em&gt; 상기 입력 인자로 호출되고, NOUT 출력들은 객체 배열로 배치된다.</target>
        </trans-unit>
        <trans-unit id="ca83daf60668ea69e76df727d7b2b16f815d0807" translate="yes" xml:space="preserve">
          <source>At the beginning of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The output array is passed in and whatever is returned is passed to the ufunc. Subclasses inherit a default implementation of this method which simply returns the output array unmodified. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the ufunc for computation.</source>
          <target state="translated">모든 &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; 의 시작 부분 에서이 메소드는 배열 우선 순위가 가장 높은 입력 오브젝트 또는 지정된 경우 출력 오브젝트에서 호출됩니다. 출력 배열이 전달되고 리턴 된 것은 ufunc에 전달됩니다. 서브 클래스는이 메소드의 기본 구현을 상속하여 단순히 수정되지 않은 출력 배열을 리턴합니다. 서브 클래스는이 메소드를 사용하여 출력 배열을 서브 클래스의 인스턴스로 변환하고 배열을 계산을 위해 ufunc로 리턴하기 전에 메타 데이터를 업데이트하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="12bc262a1577057e701d7713e64c78fa019c087b" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a collection of type-specific functions that defines the basic functionality for each of the supported types. These functions must evaluate the underlying function</source>
          <target state="translated">모든 ufunc의 핵심에는 지원되는 각 유형의 기본 기능을 정의하는 유형별 함수 모음이 있습니다. 이 함수는 기본 함수를 평가해야합니다</target>
        </trans-unit>
        <trans-unit id="99499535512b6c181a0f3b43a50d805096cef5c2" translate="yes" xml:space="preserve">
          <source>At the core of every ufunc is a one-dimensional strided loop that implements the actual function for a specific type combination. When a ufunc is created, it is given a static list of inner loops and a corresponding list of type signatures over which the ufunc operates. The ufunc machinery uses this list to determine which inner loop to use for a particular case. You can inspect the &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt;&lt;code&gt;.types&lt;/code&gt;&lt;/a&gt; attribute for a particular ufunc to see which type combinations have a defined inner loop and which output type they produce (&lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;character codes&lt;/a&gt; are used in said output for brevity).</source>
          <target state="translated">모든 ufunc의 핵심에는 특정 유형 조합에 대한 실제 기능을 구현하는 1 차원 스트라이드 루프가 있습니다. ufunc가 생성되면 내부 루프의 정적 목록과 ufunc가 작동하는 해당 유형의 서명 목록이 제공됩니다. ufunc 기계 장치는이 목록을 사용하여 특정 사례에 사용할 내부 루프를 결정합니다. 특정 ufunc에 대해 &lt;a href=&quot;generated/numpy.ufunc.types#numpy.ufunc.types&quot;&gt; &lt;code&gt;.types&lt;/code&gt; &lt;/a&gt; 속성을 검사하여 내부 루프가 정의 된 유형 조합과 이들이 생성하는 출력 유형을 확인할 수 있습니다 ( 간단하게 출력에 &lt;a href=&quot;arrays.scalars#arrays-scalars-character-codes&quot;&gt;문자 코드&lt;/a&gt; 가 사용됨).</target>
        </trans-unit>
        <trans-unit id="a696ebe70ac5ecb64adf92ab51868a20788e2014" translate="yes" xml:space="preserve">
          <source>At the core of the NumPy package, is the &lt;code&gt;ndarray&lt;/code&gt; object. This encapsulates &lt;em&gt;n&lt;/em&gt;-dimensional arrays of homogeneous data types, with many operations being performed in compiled code for performance. There are several important differences between NumPy arrays and the standard Python sequences:</source>
          <target state="translated">NumPy 패키지의 핵심은 &lt;code&gt;ndarray&lt;/code&gt; 객체입니다. 이는 성능을 위해 컴파일 된 코드에서 많은 작업이 수행되는 동종 데이터 유형의 &lt;em&gt;n&lt;/em&gt; 차원 배열을 캡슐화 합니다. NumPy 배열과 표준 Python 시퀀스 사이에는 몇 가지 중요한 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d886c7715daa7e13f2899ef3973389ec60967548" translate="yes" xml:space="preserve">
          <source>At the end of every &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, this method is called on the input object with the highest array priority, or the output object if one was specified. The ufunc-computed array is passed in and whatever is returned is passed to the user. Subclasses inherit a default implementation of this method, which transforms the array into a new instance of the object&amp;rsquo;s class. Subclasses may opt to use this method to transform the output array into an instance of the subclass and update metadata before returning the array to the user.</source>
          <target state="translated">모든 &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; 의 끝에서 ,이 메소드는 배열 우선 순위가 가장 높은 입력 오브젝트 또는 지정된 경우 출력 오브젝트에서 호출됩니다. ufunc-computed 배열이 전달되고 리턴 된 것은 사용자에게 전달됩니다. 서브 클래스는이 메소드의 기본 구현을 상속하여 배열을 객체 클래스의 새 인스턴스로 변환합니다. 서브 클래스는이 메소드를 사용하여 출력 배열을 서브 클래스의 인스턴스로 변환하고 배열을 사용자에게 리턴하기 전에 메타 데이터를 업데이트하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5c2669a04a5d46f02634839c3dfc6c41bdd3f88" translate="yes" xml:space="preserve">
          <source>At the upper right of the page, click &lt;code&gt;Fork&lt;/code&gt;:</source>
          <target state="translated">페이지 오른쪽 상단에서 &lt;code&gt;Fork&lt;/code&gt; 를 클릭합니다 .</target>
        </trans-unit>
        <trans-unit id="54f27a6635e66c8275db039314e451b39ca65192" translate="yes" xml:space="preserve">
          <source>At this point &lt;code&gt;arr + 3&lt;/code&gt; does not work.</source>
          <target state="translated">이 시점에서 &lt;code&gt;arr + 3&lt;/code&gt; 은 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7cf21779cc632f37ca6f9f1b905fd816410c5c5" translate="yes" xml:space="preserve">
          <source>Attribute statements:</source>
          <target state="translated">속성 설명 :</target>
        </trans-unit>
        <trans-unit id="e30390c6b25519953f15954ce4132cba67fdd587" translate="yes" xml:space="preserve">
          <source>AttributeError</source>
          <target state="translated">AttributeError</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="cfe76174da05e50b979cc6188b003f45d1df8482" translate="yes" xml:space="preserve">
          <source>Attributes and properties of masked arrays</source>
          <target state="translated">마스크 배열의 속성 및 속성</target>
        </trans-unit>
        <trans-unit id="75d3cd51a61f739cdedf79817eefc8974a835455" translate="yes" xml:space="preserve">
          <source>Attributes providing additional information:</source>
          <target state="translated">추가 정보를 제공하는 속성 :</target>
        </trans-unit>
        <trans-unit id="1003414a3eb685608efbc345c0f83084c22559bd" translate="yes" xml:space="preserve">
          <source>Attributes that are properties and have their own docstrings can be simply listed by name:</source>
          <target state="translated">속성이고 고유 한 독 스트링이있는 속성은 이름으로 간단하게 나열 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8087185e5ee37cef4c337de5697d35d75d909fd" translate="yes" xml:space="preserve">
          <source>Attributes:</source>
          <target state="translated">Attributes:</target>
        </trans-unit>
        <trans-unit id="6854c23ffe094a9dcc2c7d18b7054597700c09d7" translate="yes" xml:space="preserve">
          <source>Author: Pearu Peterson &amp;lt;&lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt;&amp;gt; Created: 11 January 2003</source>
          <target state="translated">저자 : Pearu Peterson &amp;lt; &lt;a href=&quot;mailto:pearu%40cens.ioc.ee&quot;&gt;pearu@cens.ioc.ee&lt;/a&gt; &amp;gt; 만든 날짜 : 2003 년 1 월 11 일</target>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="9a8e09e3b7e8024727baccc0a1e74a9673de3c0e" translate="yes" xml:space="preserve">
          <source>Automated Bin Selection Methods example, using 2 peak random data with 2000 points:</source>
          <target state="translated">자동 빈 선택 방법 예제, 2000 포인트로 2 개의 피크 랜덤 데이터 사용 :</target>
        </trans-unit>
        <trans-unit id="bfb122c45c152fbdf176456bb1bd4e6bc24c337e" translate="yes" xml:space="preserve">
          <source>Automatic Byte Offsets and Alignment</source>
          <target state="translated">자동 바이트 오프셋 및 정렬</target>
        </trans-unit>
        <trans-unit id="522d7710743316a9bb70282225a360f203660682" translate="yes" xml:space="preserve">
          <source>Automatic detection of forward incompatibilities</source>
          <target state="translated">순방향 비 호환성 자동 감지</target>
        </trans-unit>
        <trans-unit id="687034389bdc7cc4294c91418210f69e71c2ea75" translate="yes" xml:space="preserve">
          <source>Automatic extension module generation</source>
          <target state="translated">자동 확장 모듈 생성</target>
        </trans-unit>
        <trans-unit id="b2ebac8c965ff2e52dca0ea08eceaccc8803b780" translate="yes" xml:space="preserve">
          <source>Automatically generated reference documentation</source>
          <target state="translated">자동 생성 된 참조 문서</target>
        </trans-unit>
        <trans-unit id="65efb82d6e37e5b9994108df57fecde86e561550" translate="yes" xml:space="preserve">
          <source>Auxiliary Data With Object Semantics</source>
          <target state="translated">객체 시맨틱을 이용한 보조 데이터</target>
        </trans-unit>
        <trans-unit id="b5d54069c98dcc2bb7ef53455746da49544d4c61" translate="yes" xml:space="preserve">
          <source>Available Typemaps</source>
          <target state="translated">사용 가능한 타입 맵</target>
        </trans-unit>
        <trans-unit id="0eba0fa1e7377ce939b86cc49e664126d93a94fb" translate="yes" xml:space="preserve">
          <source>Available labels are:</source>
          <target state="translated">사용 가능한 라벨은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9ef456325fee29b959d2b71abeec2f41a07fee2" translate="yes" xml:space="preserve">
          <source>Available ufuncs</source>
          <target state="translated">사용 가능한 ufunc</target>
        </trans-unit>
        <trans-unit id="15f86c051ecf0b64e5f8cdc8c689552f42595942" translate="yes" xml:space="preserve">
          <source>Average</source>
          <target state="translated">Average</target>
        </trans-unit>
        <trans-unit id="00230b1d5c35405f7ca65ccbf60097d1ff75f793" translate="yes" xml:space="preserve">
          <source>Averages and variances</source>
          <target state="translated">평균과 분산</target>
        </trans-unit>
        <trans-unit id="c283b762c8c40e64645901b30f41d8175d39891d" translate="yes" xml:space="preserve">
          <source>Avoid when possible; &lt;a href=&quot;https://docs.python.org/dev/library/pickle.html&quot;&gt;pickles&lt;/a&gt; are not secure against erroneous or maliciously constructed data.</source>
          <target state="translated">가능하면 피하십시오. &lt;a href=&quot;https://docs.python.org/dev/library/pickle.html&quot;&gt;피클&lt;/a&gt; 은 오류가 있거나 악의적으로 구성된 데이터에 대해 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7a6dacf63a1600c6901329b8727cfba6197e8fd" translate="yes" xml:space="preserve">
          <source>Axes are defined for arrays with more than one dimension. A 2-dimensional array has two corresponding axes: the first running vertically downwards across rows (axis 0), and the second running horizontally across columns (axis 1).</source>
          <target state="translated">축은 차원이 두 개 이상인 배열에 대해 정의됩니다. 2 차원 배열에는 두 개의 해당 축이 있습니다. 첫 번째 축은 행을 가로 질러 수직으로 아래쪽으로 이동하고 (축 0) 두 번째 축은 열을 가로 질러 가로로 이동합니다 (축 1).</target>
        </trans-unit>
        <trans-unit id="260a17f609be1b620f1eb6b59b7945c255c81429" translate="yes" xml:space="preserve">
          <source>Axes in &lt;code&gt;a&lt;/code&gt; to reorder to the right, before inversion. If None (default), no reordering is done.</source>
          <target state="translated">반전하기 전에 오른쪽으로 다시 정렬하기 위해의 축을 축으로 &lt;code&gt;a&lt;/code&gt; . None (기본값)이면 재정렬이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="db233fcb37135c7f09c5ffb89b7ba1fec760ef66" translate="yes" xml:space="preserve">
          <source>Axes over which &lt;code&gt;func&lt;/code&gt; is applied; the elements must be integers.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 이 적용 되는 축 ; 요소는 정수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="3c7544c1215157a53157a59a39707d4b0bcf94df" translate="yes" xml:space="preserve">
          <source>Axes over which to calculate. Defaults to None, which shifts all axes.</source>
          <target state="translated">계산할 축입니다. 기본적으로 없음으로 설정되어 모든 축이 이동합니다.</target>
        </trans-unit>
        <trans-unit id="01251d80564e6fc5615a7911ad0e73434e304c26" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT.</source>
          <target state="translated">FFT를 계산할 축입니다.</target>
        </trans-unit>
        <trans-unit id="eae74832fcf1fa3443d947416920310bd08270f6" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified.</source>
          <target state="translated">FFT를 계산할 축입니다. 지정하지 않으면 마지막 &lt;code&gt;len(s)&lt;/code&gt; 축이 사용되거나 &lt;code&gt;s&lt;/code&gt; 도 지정되지 않은 경우 모든 축이 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="087a54cd73e6a93e216a09c22b970ec84185e189" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the transform over that axis is performed multiple times.</source>
          <target state="translated">FFT를 계산할 축입니다. 지정하지 않으면 마지막 &lt;code&gt;len(s)&lt;/code&gt; 축이 사용되거나 &lt;code&gt;s&lt;/code&gt; 도 지정되지 않은 경우 모든 축이 사용 됩니다. &lt;code&gt;axes&lt;/code&gt; 에서 반복되는 인덱스는 해당 축 에 대한 변환이 여러 번 수행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c012449cfef6487dddab190f30ddad2f2e0316c1" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the FFT. If not given, the last two axes are used. A repeated index in &lt;code&gt;axes&lt;/code&gt; means the transform over that axis is performed multiple times. A one-element sequence means that a one-dimensional FFT is performed.</source>
          <target state="translated">FFT를 계산할 축입니다. 지정하지 않으면 마지막 두 축이 사용됩니다. &lt;code&gt;axes&lt;/code&gt; 에서 반복되는 인덱스는 해당 축에 대한 변환이 여러 번 수행됨을 의미합니다. 1 요소 시퀀스는 1 차원 FFT가 수행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c1bbe9559f43f27cc8c677ee579702aea02533b0" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the IFFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">IFFT를 계산할 축입니다. 지정하지 않으면 마지막 &lt;code&gt;len(s)&lt;/code&gt; 축이 사용되거나 &lt;code&gt;s&lt;/code&gt; 도 지정되지 않은 경우 모든 축이 사용 됩니다. &lt;code&gt;axes&lt;/code&gt; 에서 반복되는 인덱스는 해당 축 에 대한 역변환이 여러 번 수행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b354616c4fe4a354f85531d5428c20c0b32f3c2f" translate="yes" xml:space="preserve">
          <source>Axes over which to compute the inverse FFT. If not given, the last &lt;code&gt;len(s)&lt;/code&gt; axes are used, or all axes if &lt;code&gt;s&lt;/code&gt; is also not specified. Repeated indices in &lt;code&gt;axes&lt;/code&gt; means that the inverse transform over that axis is performed multiple times.</source>
          <target state="translated">역 FFT를 계산할 축입니다. 지정하지 않으면 마지막 &lt;code&gt;len(s)&lt;/code&gt; 축이 사용되거나 &lt;code&gt;s&lt;/code&gt; 도 지정되지 않은 경우 모든 축이 사용 됩니다. &lt;code&gt;axes&lt;/code&gt; 에서 반복되는 인덱스는 해당 축 에 대한 역변환이 여러 번 수행됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="8a99b64a4a7a7c7ead7b23b02c696f0da53ae319" translate="yes" xml:space="preserve">
          <source>Axes over which to shift. Default is None, which shifts all axes.</source>
          <target state="translated">변속 할 도끼. 기본값은 없음이며 모든 축을 이동시킵니다.</target>
        </trans-unit>
        <trans-unit id="0a52967d9e9b8df8a4f8c170f8ca693ae8a86fe3" translate="yes" xml:space="preserve">
          <source>Axes to be used as the first and second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults are the first two axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">대각선을 가져와야하는 2 차원 하위 ​​배열의 첫 번째 축과 두 번째 축으로 사용될 축입니다. 기본값의 처음 두 축이다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f303f8b434501d0a0e88a06f71ae6bf60e07440a" translate="yes" xml:space="preserve">
          <source>Axis along which &lt;code&gt;arr&lt;/code&gt; is sliced.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 이 슬라이스 되는 축 입니다.</target>
        </trans-unit>
        <trans-unit id="eb47b635b568e5dba0343ed2ed07af3eb1c5f691" translate="yes" xml:space="preserve">
          <source>Axis along which logical OR is performed</source>
          <target state="translated">논리 OR이 수행되는 축</target>
        </trans-unit>
        <trans-unit id="09cfc91cd9019ea0548a0bc697b5fe1ac4febf1f" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative product is computed. By default the input is flattened.</source>
          <target state="translated">누적 곱이 계산되는 축입니다. 기본적으로 입력은 평평합니다.</target>
        </trans-unit>
        <trans-unit id="57187cefb1f2a69dac281d57460affb45a365e61" translate="yes" xml:space="preserve">
          <source>Axis along which the cumulative sum is computed. The default (None) is to compute the cumsum over the flattened array.</source>
          <target state="translated">누적 합계가 계산되는 축입니다. 기본 (없음)은 평평한 배열에서 누적을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="f37486b57129451282a7b678277fa8169fe0110e" translate="yes" xml:space="preserve">
          <source>Axis along which the elements are counted. By default, give the total number of elements.</source>
          <target state="translated">요소가 계산되는 축입니다. 기본적으로 총 요소 수를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="b08197a0ff41e61316a0f60a6919ee14fb5fe98b" translate="yes" xml:space="preserve">
          <source>Axis along which the medians are computed. The default (None) is to compute the median along a flattened version of the array.</source>
          <target state="translated">중앙값이 계산되는 축입니다. 기본 (없음)은 전개 된 버전의 배열을 따라 중앙값을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bc92a5f411fa4b8657deb697c80aca8e1f76fb85" translate="yes" xml:space="preserve">
          <source>Axis along which the operation must be performed.</source>
          <target state="translated">작업을 수행해야하는 축입니다.</target>
        </trans-unit>
        <trans-unit id="f2cd71dae3fa50b163de963d5f5e4581028e17b5" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;None&lt;/code&gt;, averaging is done over the flattened array.</source>
          <target state="translated">평균을 &lt;code&gt;a&lt;/code&gt; 축 입니다. 경우 &lt;code&gt;None&lt;/code&gt; , 평균은 평평 배열을 통해 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="17667e8c77ab258d88774c70f62a92c1b9869875" translate="yes" xml:space="preserve">
          <source>Axis along which to average &lt;code&gt;a&lt;/code&gt;. If None, averaging is done over the flattened array.</source>
          <target state="translated">축 평균하는 함께 . None이면 평탄화 된 배열에 대해 평균화가 수행됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6740a47c78c530ff5565f890ca7a6510d66b94b6" translate="yes" xml:space="preserve">
          <source>Axis along which to count. If None (default), a flattened version of the array is used.</source>
          <target state="translated">계산할 축입니다. None (기본값)이면 평탄화 된 버전의 어레이가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="87e6cb227cab73030094d0bab3690d5e44d50da1" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. By default, flatten the array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">피크를 찾는 축입니다. 기본적으로 배열을 평평하게합니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="d012a76459484bfd8767b22b0537d0b22d4d11bb" translate="yes" xml:space="preserve">
          <source>Axis along which to find the peaks. If None (default) the flattened array is used.</source>
          <target state="translated">피크를 찾는 축입니다. None (기본값)이면 병합 된 배열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c855b308fb59a9f63969a5e9a73073df7701d3a8" translate="yes" xml:space="preserve">
          <source>Axis along which to insert &lt;code&gt;values&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is None then &lt;code&gt;arr&lt;/code&gt; is flattened first.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; 을 삽입 할 축 입니다. 경우 &lt;code&gt;axis&lt;/code&gt; 없음 다음입니다 &lt;code&gt;arr&lt;/code&gt; 첫번째 평평하게됩니다.</target>
        </trans-unit>
        <trans-unit id="caa670fb62ad34335b9428afd9953d664aefbfc6" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default flattened input is used.</source>
          <target state="translated">작동 할 축. 기본적으로 납작한 입력이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1612a72f0d3b6ca5a9a80a269a8a766d4f4346ff" translate="yes" xml:space="preserve">
          <source>Axis along which to operate. By default, &lt;code&gt;axis&lt;/code&gt; is None and the flattened input is used.</source>
          <target state="translated">작동 할 축. 기본적으로 &lt;code&gt;axis&lt;/code&gt; 없음이며 평탄화 된 입력이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="dfc23123538404f83aba951929e9f61fafacf779" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. Default is None.</source>
          <target state="translated">작업을 수행 할 축입니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="f599b7c76d66ef3380a35805a50ac6efed5828ce" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array, and this is the same as &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt;&lt;code&gt;flatnotmasked_contiguous&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">작업을 수행 할 축입니다. None (기본값) 인 경우 병합 된 버전의 배열에 적용되며 &lt;a href=&quot;numpy.ma.flatnotmasked_contiguous#numpy.ma.flatnotmasked_contiguous&quot;&gt; &lt;code&gt;flatnotmasked_contiguous&lt;/code&gt; &lt;/a&gt; 와 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="04c94dfe1278eba9030646d853545708152162d2" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None (default), applies to a flattened version of the array.</source>
          <target state="translated">작업을 수행 할 축입니다. None (기본값) 인 경우 평탄화 된 버전의 어레이에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="504f2a8eb88761fe60f8368b4521f8ae3d7cee4e" translate="yes" xml:space="preserve">
          <source>Axis along which to perform the operation. If None, applies to a flattened version of the array.</source>
          <target state="translated">작업을 수행 할 축입니다. None 인 경우, 평탄화 된 버전의 어레이에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="152709e5051b3ce45dda1f386ffce54b5252f137" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. Default is -1, which means sort along the last axis.</source>
          <target state="translated">정렬 할 축입니다. 기본값은 -1이며 마지막 축을 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="2188a35fbb2aa8c603498f4b78d1698cebdd5a7d" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the array is flattened before sorting. The default is -1, which sorts along the last axis.</source>
          <target state="translated">정렬 할 축입니다. None이면 정렬하기 전에 배열이 평평 해집니다. 기본값은 -1이며 마지막 축을 따라 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="740a6ece80316cdabae954a87f619b8a229d3521" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. If None, the default, the flattened array is used.</source>
          <target state="translated">정렬 할 축입니다. None 인 경우 기본값으로 평탄화 된 배열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4ba2932956beb23c342eb9374fa565cb3b55723" translate="yes" xml:space="preserve">
          <source>Axis along which to sort. The default is -1 (the last axis). If None, the flattened array is used.</source>
          <target state="translated">정렬 할 축입니다. 기본값은 -1 (마지막 축)입니다. None이면 평탄화 된 배열이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="bf13afc2432793901330c8c7a32dd664b93fb6da" translate="yes" xml:space="preserve">
          <source>Axis along which to take slices. If None (default), work on the flattened array.</source>
          <target state="translated">슬라이스를 취할 축. None (기본값)이면 평평한 배열에서 작업합니다.</target>
        </trans-unit>
        <trans-unit id="862dd8c4bcf2d6630f10d14b83366d28de07835e" translate="yes" xml:space="preserve">
          <source>Axis along which unwrap will operate, default is the last axis.</source>
          <target state="translated">랩 해제가 작동 할 축으로, 기본값은 마지막 축입니다.</target>
        </trans-unit>
        <trans-unit id="2642370e7acd3a38fa3e5ae2e4852e710ae2493f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;a&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">의 축 벡터 (들)을 정의합니다. 기본적으로 마지막 축입니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac79a24e9b27340a01d757c607f815c179d09b07" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;b&lt;/code&gt; that defines the vector(s). By default, the last axis.</source>
          <target state="translated">벡터를 정의하는 &lt;code&gt;b&lt;/code&gt; 의 축입니다 . 기본적으로 마지막 축입니다.</target>
        </trans-unit>
        <trans-unit id="f367b3271f5fcf8c75672a1e31a99c742130492f" translate="yes" xml:space="preserve">
          <source>Axis of &lt;code&gt;c&lt;/code&gt; containing the cross product vector(s). Ignored if both input vectors have dimension 2, as the return is scalar. By default, the last axis.</source>
          <target state="translated">교차 곱 벡터를 포함하는 &lt;code&gt;c&lt;/code&gt; 축 . 반환 값이 스칼라이므로 두 입력 벡터 모두 차원이 2 인 경우 무시됩니다. 기본적으로 마지막 축입니다.</target>
        </trans-unit>
        <trans-unit id="73455e870dee7c0562b8878e31766028fce2291e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">논리 AND 축소가 수행되는 축. 기본값 ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; )은 입력 배열의 모든 차원에 대해 논리 AND를 수행하는 것입니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="10ee68577b50399a741722b3f075be540558e59c" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical AND reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical AND over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">논리적 AND 감소가 수행되는 축입니다. 기본값 ( &lt;code&gt;axis=None&lt;/code&gt; )은 입력 배열의 모든 차원에 대해 논리 AND를 수행하는 것입니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="f611b0275c8907be5ddfd942eef1d1cb490e3bfa" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">논리 OR 축소가 수행되는 축. 기본값 ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; )은 입력 배열의 모든 차원에 대해 논리 OR을 수행하는 것입니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="4b3cd50c25bcf6114d5dbf62c339109576c970bf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a logical OR reduction is performed. The default (&lt;code&gt;axis=None&lt;/code&gt;) is to perform a logical OR over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">논리적 OR 감소가 수행되는 축입니다. 기본값 ( &lt;code&gt;axis=None&lt;/code&gt; )은 입력 배열의 모든 차원에 대해 논리 OR을 수행하는 것입니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd47f9900eba5a8ae95abac9ad38d16026ca50d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a product is performed. The default, axis=None, will calculate the product of all the elements in the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">제품이 수행되는 축. 기본값 인 axis = None은 입력 배열에있는 모든 요소의 곱을 계산합니다. 축이 음수이면 마지막 축부터 첫 번째 축까지 계산합니다.</target>
        </trans-unit>
        <trans-unit id="be576580b5bc0f979cac29a5b9d9045456b366f7" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a reduction is performed. The default (&lt;code&gt;axis&lt;/code&gt; = 0) is perform a reduction over the first dimension of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">축소가 수행되는 축. 기본값 ( &lt;code&gt;axis&lt;/code&gt; = 0)은 입력 배열의 첫 번째 차원에 대해 축소를 수행하는 것입니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="a9d8568517293b16cabcf73bd06fbc68a72003cd" translate="yes" xml:space="preserve">
          <source>Axis or axes along which a sum is performed. The default, axis=None, will sum all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">합이 수행되는 축. 기본값 인 axis = None은 입력 배열의 모든 요소를 ​​합산합니다. 축이 음수이면 마지막 축부터 첫 번째 축까지 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7cc8bc628160032ea1ebe6f16101b997f0306e3e" translate="yes" xml:space="preserve">
          <source>Axis or axes along which elements are shifted. By default, the array is flattened before shifting, after which the original shape is restored.</source>
          <target state="translated">요소가 이동하는 축. 기본적으로 배열은 이동하기 전에 평평한 후에 원래 모양이 복원됩니다.</target>
        </trans-unit>
        <trans-unit id="0e425003e67ef9bdd8af0004538626cffe9c1582" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default (&lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt;) performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">카운트가 수행되는 축. 기본값 ( &lt;code&gt;axis&lt;/code&gt; = &lt;code&gt;None&lt;/code&gt; )은 입력 배열의 모든 차원에 대해 카운트를 수행합니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="dbd8b445b81cd5436ce710f441b84e722e566a56" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the count is performed. The default, None, performs the count over all the dimensions of the input array. &lt;code&gt;axis&lt;/code&gt; may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">카운트가 수행되는 축입니다. 기본값 인 None은 입력 배열의 모든 차원에 대해 카운트를 수행합니다. &lt;code&gt;axis&lt;/code&gt; 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="337ec9c050b4ae190316c405d645be292f57618f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the maximum is computed. The default is to compute the maximum of the flattened array.</source>
          <target state="translated">최대 값이 계산되는 축입니다. 기본값은 평평한 배열의 최대 값을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5bcbcdbcc90358e775edd4243e64cbf53abf5bcb" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the means are computed. The default is to compute the mean of the flattened array.</source>
          <target state="translated">평균이 계산되는 축입니다. 기본값은 평평한 배열의 평균을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="81e7f835d919d359ddd019861026589dd953700f" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the medians are computed. The default is to compute the median along a flattened version of the array. A sequence of axes is supported since version 1.9.0.</source>
          <target state="translated">중앙값이 계산되는 축입니다. 기본값은 전개 된 버전의 배열을 따라 중앙값을 계산하는 것입니다. 버전 1.9.0부터 일련의 축이 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="86845400b54274fa2252847f24187b5fc174bc52" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the minimum is computed. The default is to compute the minimum of the flattened array.</source>
          <target state="translated">최소값이 계산되는 축입니다. 기본값은 평탄화 된 배열의 최소값을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="afcadb3cc3e2b57bd1839f95d5290aac2075b609" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</source>
          <target state="translated">백분위 수가 계산되는 축입니다. 기본값은 배열의 평면화 된 버전을 따라 백분위 수를 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="1383f75934b288777f915d7bd0d8e7d4bc49532a" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the product is computed. The default is to compute the product of the flattened array.</source>
          <target state="translated">제품이 계산되는 축입니다. 기본값은 평평한 배열의 곱을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="dc86583a236f0e917d6fd47accfd6b2805fa40e8" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the quantiles are computed. The default is to compute the quantile(s) along a flattened version of the array.</source>
          <target state="translated">Quantile이 계산되는 축입니다. 기본값은 배열의 평면화 된 버전을 따라 Quantile을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="c32c668e0dd59a8b292f11f9182ecb083fc9a19d" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sliding window is applied. By default, the sliding window is applied to all axes and &lt;code&gt;window_shape[i]&lt;/code&gt; will refer to axis &lt;code&gt;i&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;axis&lt;/code&gt; is given as a &lt;code&gt;tuple of int&lt;/code&gt;, &lt;code&gt;window_shape[i]&lt;/code&gt; will refer to the axis &lt;code&gt;axis[i]&lt;/code&gt; of &lt;code&gt;x&lt;/code&gt;. Single integers &lt;code&gt;i&lt;/code&gt; are treated as if they were the tuple &lt;code&gt;(i,)&lt;/code&gt;.</source>
          <target state="translated">슬라이딩 윈도우가 적용되는 축입니다. 기본적으로 슬라이딩 윈도우는 모든 축에 적용되며 &lt;code&gt;window_shape[i]&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 의 축 &lt;code&gt;i&lt;/code&gt; 를 참조합니다 . 경우 &lt;code&gt;axis&lt;/code&gt; A와 주어진다 &lt;code&gt;tuple of int&lt;/code&gt; , &lt;code&gt;window_shape[i]&lt;/code&gt; 축 참조 것이다 &lt;code&gt;axis[i]&lt;/code&gt; 중 &lt;code&gt;x&lt;/code&gt; . 단일 정수 &lt;code&gt;i&lt;/code&gt; 는 마치 튜플 &lt;code&gt;(i,)&lt;/code&gt; 인 것처럼 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="ff0198667d8f16fd97a42b385598004387813742" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the standard deviation is computed. The default is to compute the standard deviation of the flattened array.</source>
          <target state="translated">표준 편차가 계산되는 축입니다. 기본값은 평평한 배열의 표준 편차를 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="561888a8d151a5f97b2ece2d51ce899a36bbfbdf" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the sum is computed. The default is to compute the sum of the flattened array.</source>
          <target state="translated">합이 계산되는 축입니다. 기본값은 평평한 배열의 합을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="949a7d6d27806e44a3241bd974384af685d26396" translate="yes" xml:space="preserve">
          <source>Axis or axes along which the variance is computed. The default is to compute the variance of the flattened array.</source>
          <target state="translated">분산이 계산되는 축입니다. 기본값은 평평한 배열의 분산을 계산하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="daa1ea5e7ee9d15405e9d59d22ce1b86e2982a0b" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to average &lt;code&gt;a&lt;/code&gt;. The default, axis=None, will average over all of the elements of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">축 또는 축 평균하는 함께 &lt;code&gt;a&lt;/code&gt; . 기본값 인 axis = None은 입력 배열의 모든 요소에 대한 평균입니다. 축이 음수이면 마지막 축부터 첫 번째 축까지 계산합니다.</target>
        </trans-unit>
        <trans-unit id="64370fd7391d23015a65d6e00207ab3ff57c0028" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to flip over. The default, axis=None, will flip over all of the axes of the input array. If axis is negative it counts from the last to the first axis.</source>
          <target state="translated">뒤집을 축입니다. 기본값 인 axis = None은 입력 배열의 모든 축을 뒤집습니다. 축이 음수이면 마지막 축부터 첫 번째 축까지 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f2bf5799ae5ef9d1cdddea7d865553db9614fd21" translate="yes" xml:space="preserve">
          <source>Axis or axes along which to operate. By default, flattened input is used.</source>
          <target state="translated">작동 할 축. 기본적으로 납작한 입력이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f257ca43f52b8d212133752a1e0cef3f157fcc12" translate="yes" xml:space="preserve">
          <source>Axis or tuple of axes along which to count non-zeros. Default is None, meaning that non-zeros will be counted along a flattened version of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">0이 아닌 숫자를 세는 축 또는 축의 튜플. 기본값은 없음이며, 0이 아닌 값은 플랫 버전의 &lt;code&gt;a&lt;/code&gt; 에 따라 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="1dfdd6be5ea8d2b943040ace17a9b289e52760e7" translate="yes" xml:space="preserve">
          <source>Axis over which the anomalies are taken. The default is to use the mean of the flattened array as reference.</source>
          <target state="translated">이상이 발생한 축. 기본값은 평평한 배열의 평균을 참조로 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="5a28ddd98da60a547b5ae35ef6abe54e89e91508" translate="yes" xml:space="preserve">
          <source>Axis over which the derivative is taken. (Default: 0).</source>
          <target state="translated">도함수가 취해지는 축. (기본값 : 0).</target>
        </trans-unit>
        <trans-unit id="ca8db3e3878b22dd385e21680a7f2404ba4af59f" translate="yes" xml:space="preserve">
          <source>Axis over which the integral is taken. (Default: 0).</source>
          <target state="translated">적분을 취하는 축. (기본값 : 0).</target>
        </trans-unit>
        <trans-unit id="7238aa3702fcf05542c14de94bdcecf60c8463af" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the FFT. If not given, the last axis is used.</source>
          <target state="translated">FFT를 계산할 축입니다. 지정하지 않으면 마지막 축이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="78aed7a81e841b649e307d86af83f2a27f772253" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse DFT. If not given, the last axis is used.</source>
          <target state="translated">역 DFT를 계산할 축입니다. 지정하지 않으면 마지막 축이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1994028401ccc8c25a36ddcd64e63635d1053d3a" translate="yes" xml:space="preserve">
          <source>Axis over which to compute the inverse FFT. If not given, the last axis is used.</source>
          <target state="translated">역 FFT를 계산할 축입니다. 지정하지 않으면 마지막 축이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7fc8d289aafc37f1ce906424ecc35f2c72d9a34f" translate="yes" xml:space="preserve">
          <source>Axis to be indirectly sorted. By default, sort over the last axis.</source>
          <target state="translated">간접적으로 정렬 될 축. 기본적으로 마지막 축을 기준으로 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="3e1ca61bed45345ef5098f13d05c389833be3df8" translate="yes" xml:space="preserve">
          <source>Axis to be used as the first axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to first axis (0).</source>
          <target state="translated">대각선을 가져와야하는 2 차원 하위 ​​배열의 첫 번째 축으로 사용될 축입니다. 기본값은 첫 번째 축 (0)입니다.</target>
        </trans-unit>
        <trans-unit id="45f7ee7208a9fb7d4e4732ffbd5f973fe0a479d3" translate="yes" xml:space="preserve">
          <source>Axis to be used as the second axis of the 2-D sub-arrays from which the diagonals should be taken. Defaults to second axis (1).</source>
          <target state="translated">대각선을 가져와야하는 2 차원 하위 ​​배열의 두 번째 축으로 사용될 축입니다. 기본적으로 두 번째 축 (1)입니다.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="c7781e5925cc1162bf57ca801ea173a8789aefd5" translate="yes" xml:space="preserve">
          <source>BEHAVED and C_CONTIGUOUS.</source>
          <target state="translated">이상과 C_CONTIGUOUS.</target>
        </trans-unit>
        <trans-unit id="eca3180a6c33b0a38f6f76fa644f63211aa1f14e" translate="yes" xml:space="preserve">
          <source>BEHAVED and F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">C_CONTIGUOUS가 아닌 BEHAVED 및 F_CONTIGUOUS</target>
        </trans-unit>
        <trans-unit id="c7243d04c977df0309eee7b50ccaddc2665154ee" translate="yes" xml:space="preserve">
          <source>BLAS</source>
          <target state="translated">BLAS</target>
        </trans-unit>
        <trans-unit id="bcd158bb5feaae9038808e3b55d2a031b8ba7709" translate="yes" xml:space="preserve">
          <source>BLAS (NetLIB)</source>
          <target state="translated">BLAS (NetLIB)</target>
        </trans-unit>
        <trans-unit id="dcf8c920edb3ad9eb9b92f8b67ba19eaaa1b8c86" translate="yes" xml:space="preserve">
          <source>BLIS</source>
          <target state="translated">BLIS</target>
        </trans-unit>
        <trans-unit id="cf867b1a06ac32f25a3a53b5cac69625adf84e3c" translate="yes" xml:space="preserve">
          <source>BLIS support in &lt;code&gt;numpy.distutils&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.distutils&lt;/code&gt; 의 BLIS 지원</target>
        </trans-unit>
        <trans-unit id="214e501b88ef4fd6dfd2e0ceb3d07f872f3aa657" translate="yes" xml:space="preserve">
          <source>BSD / Solaris</source>
          <target state="translated">BSD / Solaris</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="bd452a7ea759269a521e984eabecb645ce4b2ea6" translate="yes" xml:space="preserve">
          <source>Background information</source>
          <target state="translated">배경 정보</target>
        </trans-unit>
        <trans-unit id="090a12d667902964e48f38714b38e1c7c7410ac2" translate="yes" xml:space="preserve">
          <source>Backport Pull Requests</source>
          <target state="translated">백 포트 풀 요청</target>
        </trans-unit>
        <trans-unit id="304c9bb8acb18cf698a66eac9714c36a88110784" translate="yes" xml:space="preserve">
          <source>Backporting</source>
          <target state="translated">Backporting</target>
        </trans-unit>
        <trans-unit id="850de91aa7213a4adf4d94aeab2caaf4d100f909" translate="yes" xml:space="preserve">
          <source>Backporting is the process of copying new feature/fixes committed in &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy/master&lt;/a&gt; back to stable release branches. To do this you make a branch off the branch you are backporting to, cherry pick the commits you want from &lt;code&gt;numpy/master&lt;/code&gt;, and then submit a pull request for the branch containing the backport.</source>
          <target state="translated">백 포팅은 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;numpy / master&lt;/a&gt; 에서 커밋 된 새로운 기능 / 수정 사항 을 안정적인 릴리스 브랜치로 다시 복사하는 프로세스입니다 . 이를 위해 백 포팅중인 브랜치에서 브랜치를 만들고 &lt;code&gt;numpy/master&lt;/code&gt; 에서 원하는 커밋을 선택한 다음 백 포트를 포함하는 브랜치에 대한 풀 요청을 제출합니다.</target>
        </trans-unit>
        <trans-unit id="7e9bfe183c1510e40aa465bc59796172c1a8f60e" translate="yes" xml:space="preserve">
          <source>Bad or missing data can be cleanly ignored by putting it in a masked array, which has an internal boolean array indicating invalid entries. Operations with masked arrays ignore these entries.</source>
          <target state="translated">잘못되거나 누락 된 데이터는 잘못된 항목을 나타내는 내부 부울 배열이있는 마스킹 된 배열에 넣어 완전히 무시할 수 있습니다. 마스킹 된 배열을 사용한 작업은 이러한 항목을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="172132c5b69b62eb861ca29a9ea486edc3f7219f" translate="yes" xml:space="preserve">
          <source>Bare metal, wrap your own C-code manually.</source>
          <target state="translated">베어 메탈, 자신의 C 코드를 수동으로 래핑하십시오.</target>
        </trans-unit>
        <trans-unit id="53740dccbfb785b89a2a2e2837295960b3f62362" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms.</source>
          <target state="translated">서로 다른 알고리즘을 기반으로 임의의 비트 스트림을 제공하는 일반 BitGenerators의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="2f03f2251cbc22f3d11027c3e6199900a02163b7" translate="yes" xml:space="preserve">
          <source>Base Class for generic BitGenerators, which provide a stream of random bits based on different algorithms. Must be overridden.</source>
          <target state="translated">서로 다른 알고리즘을 기반으로 임의의 비트 스트림을 제공하는 일반 BitGenerators의 기본 클래스입니다. 재정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="18c896688f02b72b07f8b6644f275710e91f33b7" translate="yes" xml:space="preserve">
          <source>Base class</source>
          <target state="translated">기본 수업</target>
        </trans-unit>
        <trans-unit id="c559e4e184dd4d014a0b5060ba07110daeea6a9f" translate="yes" xml:space="preserve">
          <source>Base class for all polynomial types.</source>
          <target state="translated">모든 다항식 유형의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6149d0f0d497f5c19a312e242e3099f49c4e1828" translate="yes" xml:space="preserve">
          <source>Base class for errors in this module.</source>
          <target state="translated">이 모듈의 오류에 대한 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6c3e6ca54a7a88ced88fed404dda8485677d4e2e" translate="yes" xml:space="preserve">
          <source>Base class for numpy scalar types.</source>
          <target state="translated">numpy 스칼라 유형의 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="860a1492914588f337f184bd4823757e7c5382ef" translate="yes" xml:space="preserve">
          <source>Base object if memory is from some other object.</source>
          <target state="translated">메모리가 다른 개체의 경우 기본 개체입니다.</target>
        </trans-unit>
        <trans-unit id="e272affdfa292522d2f5ac68c3e4ab276db10b62" translate="yes" xml:space="preserve">
          <source>Base of natural logarithm (</source>
          <target state="translated">자연 로그의 밑 (</target>
        </trans-unit>
        <trans-unit id="65a08d51a2e698f7325209df48e279e52d580030" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;2**x1 + 2**x2&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;2**x1 + 2**x2&lt;/code&gt; 밑이 2 인 로그 . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="dc8e13711f25f1ed77c835a90063cf7df6b684db" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑이 2 인 로그 .</target>
        </trans-unit>
        <trans-unit id="99798b5608dba0e80521a63a27ddafba29b89b07" translate="yes" xml:space="preserve">
          <source>Base-2 logarithm of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑이 2 인 로그 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="38987414db4d1bf81908059ba9b136da28c33714" translate="yes" xml:space="preserve">
          <source>Base-n representations</source>
          <target state="translated">Base-n 표현</target>
        </trans-unit>
        <trans-unit id="0bff1548231bd093df6d8bc4bf7a28a9733d2f0e" translate="yes" xml:space="preserve">
          <source>Based on the above characterization, &amp;ldquo;high-priority&amp;rdquo; changes (i.e. fixing technical inaccuracies, broken links, etc.) can be proposed via pull requests directly as they are straightforward to review. Other changes should be raised as issues first so that the discussion can happen before you make major modifications, which in principle saves you from wasting your time on undesired changes.</source>
          <target state="translated">위의 특성을 기반으로 &quot;높은 우선 순위&quot;변경 (즉, 기술적 부정확성 수정, 끊어진 링크 등)은 검토가 간단하므로 풀 요청을 통해 직접 제안 할 수 있습니다. 다른 변경 사항을 먼저 문제로 제기하여 큰 수정을하기 전에 토론이 이루어질 수 있도록해야합니다. 그러면 원칙적으로 원하지 않는 변경에 시간을 낭비하지 않아도됩니다.</target>
        </trans-unit>
        <trans-unit id="da94602e9563f3ceebc2fc5b569a77851b4c7e35" translate="yes" xml:space="preserve">
          <source>Basic &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;: ~1520ms (benchmarked on 3.1GHz Intel i5.)</source>
          <target state="translated">기본 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; : ~ 1520ms (3.1GHz Intel i5에서 벤치 마크 됨)</target>
        </trans-unit>
        <trans-unit id="e6e180bdb3abc214441692c8749fa0f6558a1809" translate="yes" xml:space="preserve">
          <source>Basic Array Flags</source>
          <target state="translated">기본 배열 플래그</target>
        </trans-unit>
        <trans-unit id="e4e049299abaf782878f7f84544dfdb97d319e23" translate="yes" xml:space="preserve">
          <source>Basic Datetimes</source>
          <target state="translated">기본 날짜 시간</target>
        </trans-unit>
        <trans-unit id="6081b68b227981c90bce83d2c2beb9f59d79503d" translate="yes" xml:space="preserve">
          <source>Basic Git setup</source>
          <target state="translated">기본 Git 설정</target>
        </trans-unit>
        <trans-unit id="7a031fb4b54459f27072c9ee40c4b13ebd94a781" translate="yes" xml:space="preserve">
          <source>Basic Installation</source>
          <target state="translated">기본 설치</target>
        </trans-unit>
        <trans-unit id="e5074656d77a5a1b87923975067a88a41f1ac1c1" translate="yes" xml:space="preserve">
          <source>Basic Iteration</source>
          <target state="translated">기본 반복</target>
        </trans-unit>
        <trans-unit id="57a6dc8bc52fe0e5017a1d4e4df961ab713b5b3a" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra</source>
          <target state="translated">기본 선형 대수</target>
        </trans-unit>
        <trans-unit id="c7231dfbf12224ef4a3543250815ccb954fcb938" translate="yes" xml:space="preserve">
          <source>Basic Linear Algebra Subprograms</source>
          <target state="translated">기본 선형 대수 하위 프로그램</target>
        </trans-unit>
        <trans-unit id="9a85f6e8c6ded273cdb7e38718d85979a45dd77e" translate="yes" xml:space="preserve">
          <source>Basic Operations</source>
          <target state="translated">기본 작동</target>
        </trans-unit>
        <trans-unit id="7169d2b21ccd399c4bc0e79bbfdd0bd5c61ee835" translate="yes" xml:space="preserve">
          <source>Basic Slicing and Indexing</source>
          <target state="translated">기본 슬라이싱 및 인덱싱</target>
        </trans-unit>
        <trans-unit id="60094894bbbb579bd2f4b96162f9928ec2ce169d" translate="yes" xml:space="preserve">
          <source>Basic Statistics</source>
          <target state="translated">기본 통계</target>
        </trans-unit>
        <trans-unit id="b9b6d01ce3d08fc15e9971b8d7ad62d621a90733" translate="yes" xml:space="preserve">
          <source>Basic array operations</source>
          <target state="translated">기본 어레이 작업</target>
        </trans-unit>
        <trans-unit id="bf23a24f7e23fb617c002847d87b0e8162ee99d1" translate="yes" xml:space="preserve">
          <source>Basic customization:</source>
          <target state="translated">기본 맞춤 설정 :</target>
        </trans-unit>
        <trans-unit id="4c8d5fdc5db9950cf7bea592d196bad4f803b3fb" translate="yes" xml:space="preserve">
          <source>Basic examples</source>
          <target state="translated">기본 예</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">기본 조작</target>
        </trans-unit>
        <trans-unit id="d6e8bb93c76a2ef8f7afd4a4fc3b007cbfd7ef2c" translate="yes" xml:space="preserve">
          <source>Basic operations are simple with NumPy. If you want to find the sum of the elements in an array, you&amp;rsquo;d use &lt;code&gt;sum()&lt;/code&gt;. This works for 1D arrays, 2D arrays, and arrays in higher dimensions.</source>
          <target state="translated">NumPy를 사용하면 기본 작업이 간단합니다. 배열에서 요소의 합을 찾으려면 &lt;code&gt;sum()&lt;/code&gt; 합니다. 이것은 1D 배열, 2D 배열 및 더 높은 차원의 배열에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2f8920f677fe61e2e2076f058e28c7701ee809c1" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">기본 슬라이싱은 Python의 기본 슬라이싱 개념을 N 차원으로 확장합니다. 기본 슬라이싱은 &lt;em&gt;obj&lt;/em&gt; 가 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; 객체 ( 괄호 안에 &lt;code&gt;start:stop:step&lt;/code&gt; 표기법으로 구성됨), 정수 또는 슬라이스 객체와 정수의 튜플 일 때 발생합니다. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체도 이것들과 함께 산재 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b900db10ad3fb5583b98ef507ab36ddd8153f435" translate="yes" xml:space="preserve">
          <source>Basic slicing extends Python&amp;rsquo;s basic concept of slicing to N dimensions. Basic slicing occurs when &lt;em&gt;obj&lt;/em&gt; is a &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt;&lt;code&gt;slice&lt;/code&gt;&lt;/a&gt; object (constructed by &lt;code&gt;start:stop:step&lt;/code&gt; notation inside of brackets), an integer, or a tuple of slice objects and integers. &lt;code&gt;Ellipsis&lt;/code&gt; and &lt;a href=&quot;constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt; objects can be interspersed with these as well.</source>
          <target state="translated">기본 슬라이싱은 Python의 기본 슬라이싱 개념을 N 차원으로 확장합니다. 기본 슬라이싱은 &lt;em&gt;obj&lt;/em&gt; 가 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#slice&quot;&gt; &lt;code&gt;slice&lt;/code&gt; &lt;/a&gt; 객체 ( 괄호 안의 &lt;code&gt;start:stop:step&lt;/code&gt; 표기법으로 구성됨), 정수 또는 슬라이스 객체와 정수의 튜플 일 때 발생합니다. &lt;code&gt;Ellipsis&lt;/code&gt; 와 &lt;a href=&quot;constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 객체가 이것들과 함께 산재 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b34ccf1a566015b10946e74591046f4136452341" translate="yes" xml:space="preserve">
          <source>Basic slicing with more than one non-&lt;code&gt;:&lt;/code&gt; entry in the slicing tuple, acts like repeated application of slicing using a single non-&lt;code&gt;:&lt;/code&gt; entry, where the non-&lt;code&gt;:&lt;/code&gt; entries are successively taken (with all other non-&lt;code&gt;:&lt;/code&gt; entries replaced by &lt;code&gt;:&lt;/code&gt;). Thus, &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; acts like &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; under basic slicing.</source>
          <target state="translated">슬라이싱 튜플에 둘 이상의 비 &lt;code&gt;:&lt;/code&gt; 항목이있는 기본 슬라이싱 은 단일 비 &lt;code&gt;:&lt;/code&gt; 항목을 사용하여 슬라이싱을 반복 적용하는 것처럼 작동 합니다. 비 &lt;code&gt;:&lt;/code&gt; 항목을 연속적으로 가져옵니다 (다른 모든 비 &lt;code&gt;:&lt;/code&gt; 항목은 &lt;code&gt;:&lt;/code&gt; 로 대체 됨 ) . 따라서 &lt;code&gt;x[ind1,...,ind2,:]&lt;/code&gt; &lt;code&gt;x[ind1][...,ind2,:]&lt;/code&gt; 는 기본 슬라이싱에서 x [ind1] [..., ind2 ,:] 처럼 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="de17dd65e3190938ee92ddb98549d2245920a8ee" translate="yes" xml:space="preserve">
          <source>Basic usage is to call &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt;&lt;code&gt;PyArray_IterNew&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt; ) where array is an ndarray object (or one of its sub-classes). The returned object is an array-iterator object (the same object returned by the .flat attribute of the ndarray). This object is usually cast to PyArrayIterObject* so that its members can be accessed. The only members that are needed are &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; which contains the total size of the array, &lt;code&gt;iter-&amp;gt;index&lt;/code&gt;, which contains the current 1-d index into the array, and &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; which is a pointer to the data for the current element of the array. Sometimes it is also useful to access &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; which is a pointer to the underlying ndarray object.</source>
          <target state="translated">기본 사용법은 &lt;a href=&quot;../reference/c-api/array#c.PyArray_IterNew&quot;&gt; &lt;code&gt;PyArray_IterNew&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;array&lt;/code&gt; ) 를 호출하는 것입니다. 여기서 array는 ndarray 객체 (또는 하위 클래스 중 하나)입니다. 반환 된 객체는 배열 반복자 객체 (ndarray의 .flat 속성에서 반환 된 동일한 객체)입니다. 이 개체는 일반적으로 해당 멤버에 액세스 할 수 있도록 PyArrayIterObject *로 캐스팅됩니다. 필요한 유일한 구성원이다 &lt;code&gt;iter-&amp;gt;size&lt;/code&gt; 어레이의 전체 크기를 포함 &lt;code&gt;iter-&amp;gt;index&lt;/code&gt; 현재 1 차원 배열에 대한 인덱스 및 포함 &lt;code&gt;iter-&amp;gt;dataptr&lt;/code&gt; 위한 데이터를 가리키는 포인터가 배열의 현재 요소 때로는 기본 ndarray 객체에 대한 포인터 인 iter- &lt;code&gt;iter-&amp;gt;ao&lt;/code&gt; 에 액세스하는 것도 유용 합니다.</target>
        </trans-unit>
        <trans-unit id="af837eca09697118dc16afab4a2dc5bfeccd2a15" translate="yes" xml:space="preserve">
          <source>Basic usage. Note how y is the &amp;ldquo;flattened&amp;rdquo; version of [a[:, 0, :], a[:, 1, 0], a[:, 2, :]] since we specified the first iter&amp;rsquo;s axes as [1]</source>
          <target state="translated">기본 사용법. 첫 번째 iter 's axis를 [1]로 지정했기 때문에 y는 [a [:, 0, :], a [:, 1, 0], a [:, 2, :]]의 &quot;평평한&quot;버전입니다.</target>
        </trans-unit>
        <trans-unit id="189ceeabec801d69e58e27b3296832fd339cfd5c" translate="yes" xml:space="preserve">
          <source>Basic workflow</source>
          <target state="translated">기본 워크 플로우</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4ce3c1a6b26e31f8d07ec92f4cb05d49b3eec33d" translate="yes" xml:space="preserve">
          <source>Be aware that when NumPy prints N-dimensional arrays, the last axis is looped over the fastest while the first axis is the slowest. For instance:</source>
          <target state="translated">NumPy가 N 차원 배열을 인쇄 할 때 마지막 축은 가장 빠르게 반복되는 반면 첫 번째 축은 가장 느립니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="11716f1e3c0926fa9c04fbb3c924f0811bf4b112" translate="yes" xml:space="preserve">
          <source>Be careful about round-off error!</source>
          <target state="translated">반올림 오류에주의하십시오!</target>
        </trans-unit>
        <trans-unit id="3008b1888d55827508c13f2c0985bc725a03a91e" translate="yes" xml:space="preserve">
          <source>Be careful in the words that we choose. We are careful and respectful in our communication and we take responsibility for our own speech. Be kind to others. Do not insult or put down other participants. We will not accept harassment or other exclusionary behaviour, such as:</source>
          <target state="translated">우리가 선택하는 말에주의하십시오. 우리는 의사 소통에 신중하고 존중하며 자신의 연설에 대한 책임을집니다. 다른 사람들에게 친절하십시오. 다른 참가자를 모욕하거나 실망시키지 마십시오. 우리는 괴롭힘이나 다음과 같은 기타 배제적인 행동을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a95dfdc69ac7b8c496606d6afad271cdcc3a6cdb" translate="yes" xml:space="preserve">
          <source>Be collaborative. Our work will be used by other people, and in turn we will depend on the work of others. When we make something for the benefit of the project, we are willing to explain to others how it works, so that they can build on the work to make it even better. Any decision we make will affect users and colleagues, and we take those consequences seriously when making decisions.</source>
          <target state="translated">협력하십시오. 우리의 일은 다른 사람들이 사용할 것이고, 차례로 우리는 다른 사람들의 일에 의존하게 될 것입니다. 우리가 프로젝트의 이익을 위해 무언가를 만들 때, 우리는 그것이 어떻게 작동하는지 다른 사람들에게 기꺼이 설명하여 그들이 더 나은 것을 만들기 위해 작업을 구축 할 수 있도록합니다. 우리가 내리는 모든 결정은 사용자와 동료에게 영향을 미치며 결정을 내릴 때 이러한 결과를 진지하게 받아들입니다.</target>
        </trans-unit>
        <trans-unit id="ff801bed133a99446534aede438fa2583bcd9e5a" translate="yes" xml:space="preserve">
          <source>Be empathetic, welcoming, friendly, and patient. We work together to resolve conflict, and assume good intentions. We may all experience some frustration from time to time, but we do not allow frustration to turn into a personal attack. A community where people feel uncomfortable or threatened is not a productive one.</source>
          <target state="translated">공감하고, 환영하고, 친절하고, 인내하십시오. 우리는 갈등을 해결하기 위해 협력하고 좋은 의도를 가지고 있습니다. 우리 모두는 때때로 약간의 좌절감을 경험할 수 있지만 좌절감이 개인적인 공격으로 변하는 것을 허용하지 않습니다. 사람들이 불편하거나 위협을 느끼는 커뮤니티는 생산적인 커뮤니티가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="3eaab4694464d982dfc3e0a1afc07f0c4449c8cc" translate="yes" xml:space="preserve">
          <source>Be inquisitive. Nobody knows everything! Asking questions early avoids many problems later, so we encourage questions, although we may direct them to the appropriate forum. We will try hard to be responsive and helpful.</source>
          <target state="translated">호기심을 가지십시오. 아무도 모든 것을 알지 못합니다! 질문을 일찍하면 나중에 많은 문제를 피할 수 있으므로 적절한 포럼으로 안내 할 수 있지만 질문을 권장합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 우리는 반응하고 도움이되도록 열심히 노력할 것입니다.</target>
        </trans-unit>
        <trans-unit id="6a20b0ffbe846eba275eb3ea56da6251c7cd9752" translate="yes" xml:space="preserve">
          <source>Be mindful of the needs of new members: provide them with explicit support and consideration, with the aim of increasing participation from underrepresented groups in particular.</source>
          <target state="translated">신규 회원의 요구 사항을 염두에 두십시오. 특히 소외된 그룹의 참여를 늘리기 위해 명시적인 지원과 고려를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="1f37a97353eabf9fd15a91dbc5d9f5eb04cea0bf" translate="yes" xml:space="preserve">
          <source>Be mindful that large arrays created with &lt;code&gt;np.empty&lt;/code&gt; or &lt;code&gt;np.zeros&lt;/code&gt; might not be allocated in physical memory until the memory is accessed. If this is desired behaviour, make sure to comment it in your setup function. If you are benchmarking an algorithm, it is unlikely that a user will be executing said algorithm on a newly created empty/zero array. One can force pagefaults to occur in the setup phase either by calling &lt;code&gt;np.ones&lt;/code&gt; or &lt;code&gt;arr.fill(value)&lt;/code&gt; after creating the array,</source>
          <target state="translated">&lt;code&gt;np.empty&lt;/code&gt; 또는 &lt;code&gt;np.zeros&lt;/code&gt; 로 생성 된 대형 배열 은 메모리에 액세스 할 때까지 물리적 메모리에 할당되지 않을 수 있습니다. 이것이 원하는 동작이면 설정 기능에 주석을 달아야합니다. 알고리즘을 벤치마킹하는 경우 사용자가 새로 생성 된 빈 / 제로 배열에서 해당 알고리즘을 실행할 가능성은 거의 없습니다. 배열을 만든 후 &lt;code&gt;np.ones&lt;/code&gt; 또는 &lt;code&gt;arr.fill(value)&lt;/code&gt; 를 호출하여 설정 단계에서 페이지 오류가 발생하도록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3730bbeeef610bbf04c76abf5ec330327e101406" translate="yes" xml:space="preserve">
          <source>Be open. We invite anyone to participate in our community. We prefer to use public methods of communication for project-related messages, unless discussing something sensitive. This applies to messages for help or project-related support, too; not only is a public support request much more likely to result in an answer to a question, it also ensures that any inadvertent mistakes in answering are more easily detected and corrected.</source>
          <target state="translated">개방하십시오. 우리는 누구나 우리 커뮤니티에 참여하도록 초대합니다. 민감한 내용을 논의하지 않는 한 프로젝트 관련 메시지에 공개 커뮤니케이션 방법을 사용하는 것을 선호합니다. 이는 도움말 또는 프로젝트 관련 지원을위한 메시지에도 적용됩니다. 공개 지원 요청은 질문에 대한 답변으로 이어질 가능성이 훨씬 높을뿐만 아니라 부주의 한 답변 실수를보다 쉽게 ​​감지하고 수정할 수 있도록합니다.</target>
        </trans-unit>
        <trans-unit id="ac10e1f58e2260e13e0683472d08e8f00358973a" translate="yes" xml:space="preserve">
          <source>Be sure to understand what steps you should take to manage the memory when using these conversion functions. These functions can require freeing memory, and/or altering the reference counts of specific objects based on your use.</source>
          <target state="translated">이러한 변환 기능을 사용할 때 메모리를 관리하기 위해 수행해야하는 단계를 이해해야합니다. 이 기능을 사용하려면 메모리를 비우거나 사용에 따라 특정 객체의 참조 카운트를 변경해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e72bb7e156cb39574b057b9674c2412ed422481" translate="yes" xml:space="preserve">
          <source>Be warned that even if &lt;code&gt;np.longdouble&lt;/code&gt; offers more precision than python &lt;code&gt;float&lt;/code&gt;, it is easy to lose that extra precision, since python often forces values to pass through &lt;code&gt;float&lt;/code&gt;. For example, the &lt;code&gt;%&lt;/code&gt; formatting operator requires its arguments to be converted to standard python types, and it is therefore impossible to preserve extended precision even if many decimal places are requested. It can be useful to test your code with the value &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;np.longdouble&lt;/code&gt; 이 python &lt;code&gt;float&lt;/code&gt; 보다 더 많은 정밀도를 제공 하더라도 파이썬은 종종 값이 &lt;code&gt;float&lt;/code&gt; 를 통과하도록 강제하기 때문에 추가 정밀도를 잃기 쉽습니다 . 예를 들어, &lt;code&gt;%&lt;/code&gt; 형식화 연산자는 인수를 표준 파이썬 유형으로 변환해야하므로 소수 자릿수가 많이 요청 된 경우에도 확장 된 정밀도를 유지할 수 없습니다. &lt;code&gt;1 + np.finfo(np.longdouble).eps&lt;/code&gt; 값으로 코드를 테스트하는 것이 유용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="782223c5915f4980a539ed4710dad922b52bef1d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a built-in type (written in C), the &lt;code&gt;__r{op}__&lt;/code&gt; special methods are not directly defined.</source>
          <target state="translated">때문에 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 는&lt;/a&gt; 내장 타입 (C로 작성)에있다 &lt;code&gt;__r{op}__&lt;/code&gt; 특별한 방법을 직접 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d79cf7f45add11b370a63146a7703acf9ea33ca1" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;__array_finalize__&lt;/code&gt; is the only method that always sees new instances being created, it is the sensible place to fill in instance defaults for new object attributes, among other tasks.</source>
          <target state="translated">&lt;code&gt;__array_finalize__&lt;/code&gt; 는 항상 새 인스턴스가 생성되는 것을 보는 유일한 메서드 이기 때문에 다른 작업 중에서 새 객체 속성에 대한 인스턴스 기본값을 채우는 것이 현명한 위치입니다.</target>
        </trans-unit>
        <trans-unit id="cc46c55e2dfa187c2ac071bbb4bae1702d622519" translate="yes" xml:space="preserve">
          <source>Because Python strings are immutable, an &lt;code&gt;intent(inout)&lt;/code&gt; argument expects an array version of a string in order to have &lt;em&gt;in situ&lt;/em&gt; changes be effective.</source>
          <target state="translated">파이썬 문자열은 불변이기 때문에 인 &lt;code&gt;intent(inout)&lt;/code&gt; 인수는 &lt;em&gt;현장&lt;/em&gt; 변경이 효과적 이기 위해 문자열의 배열 버전을 기대합니다 .</target>
        </trans-unit>
        <trans-unit id="b4ea4687fdb37cf012f30310b86e8fc32c6c91ad" translate="yes" xml:space="preserve">
          <source>Because access to additional information is so useful, IPython uses the &lt;code&gt;?&lt;/code&gt; character as a shorthand for accessing this documentation along with other relevant information. IPython is a command shell for interactive computing in multiple languages. &lt;a href=&quot;https://ipython.org/&quot;&gt;You can find more information about IPython here&lt;/a&gt;.</source>
          <target state="translated">추가 정보에 대한 액세스가 매우 유용하기 때문에 IPython은 &lt;code&gt;?&lt;/code&gt; 다른 관련 정보와 함께이 문서에 액세스하기위한 축약 형 문자입니다. IPython은 여러 언어로 된 대화 형 컴퓨팅을위한 명령 셸입니다. &lt;a href=&quot;https://ipython.org/&quot;&gt;여기에서 IPython에 대한 자세한 정보를 찾을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="67d90e5f1ae663c377ee558cca369308548469d2" translate="yes" xml:space="preserve">
          <source>Because exact overlap detection has exponential runtime in the number of dimensions, the decision is made based on heuristics, which has false positives (needless copies in unusual cases) but has no false negatives.</source>
          <target state="translated">정확한 오버랩 탐지는 차원 수에서 지수 런타임을 가지기 때문에, 휴리스틱을 기반으로 결정됩니다. 휴리스틱은 오 탐지 (비정상적인 경우 불필요한 사본)는 있지만 오음은 없습니다.</target>
        </trans-unit>
        <trans-unit id="b6f4af8bef1f35015b148a058f523cde0f4ccc9d" translate="yes" xml:space="preserve">
          <source>Because of how &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; handles sets, the following does not work as expected:</source>
          <target state="translated">&lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 이 집합을 처리 하는 방식으로 인해 다음과 같이 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a390a00169642b8c370c2fa0fa4fb8d3ba973c7" translate="yes" xml:space="preserve">
          <source>Because of the difficulty in distributing an extension module made using ctypes, f2py and Cython are still the easiest ways to extend Python for package creation. However, ctypes is in some cases a useful alternative. This should bring more features to ctypes that should eliminate the difficulty in extending Python and distributing the extension using ctypes.</source>
          <target state="translated">ctypes를 사용하여 만든 확장 모듈을 배포하는 데 어려움이 있기 때문에 f2py와 Cython은 여전히 ​​패키지 생성을 위해 Python을 확장하는 가장 쉬운 방법입니다. 그러나 ctypes는 경우에 따라 유용한 대안입니다. 이것은 파이썬을 확장하고 ctypes를 사용하여 확장을 배포하는 어려움을 제거해야하는 ctypes에 더 많은 기능을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="74a5855103a7e35a06feda100f69f0d3c37a35c5" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions &lt;a href=&quot;#c.PyArray_GetNDArrayCVersion&quot;&gt;&lt;code&gt;PyArray_GetNDArrayCVersion&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_GetNDArrayCFeatureVersion&quot;&gt;&lt;code&gt;PyArray_GetNDArrayCFeatureVersion&lt;/code&gt;&lt;/a&gt; corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">Python 확장은 대부분의 플랫폼에서 일반적인 라이브러리와 같은 방식으로 사용되지 않기 때문에 일부 오류는 빌드시 또는 런타임에 자동으로 감지되지 않습니다. 예를 들어 numpy&amp;gt; = 1.3.0에서만 사용할 수있는 함수를 사용하여 확장을 빌드하고 나중에 numpy 1.2로 확장을 가져 오면 가져 오기 오류가 발생하지 않습니다 (하지만 함수를 호출 할 때 거의 확실히 세분화 오류가 발생 함). . 그렇기 때문에 numpy 버전을 확인하기 위해 여러 기능이 제공됩니다. 매크로 &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt; 은 확장을 빌드하는 데 사용 된 numpy 버전에 해당하는 반면 &lt;a href=&quot;#c.PyArray_GetNDArrayCVersion&quot;&gt; &lt;code&gt;PyArray_GetNDArrayCVersion&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.PyArray_GetNDArrayCFeatureVersion&quot;&gt; &lt;code&gt;PyArray_GetNDArrayCFeatureVersion&lt;/code&gt; &lt;/a&gt; 함수에서 반환 된 버전은 런타임 numpy의 버전에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="c5a38fa639091b6298538af300d0ae57dcac2792" translate="yes" xml:space="preserve">
          <source>Because python extensions are not used in the same way as usual libraries on most platforms, some errors cannot be automatically detected at build time or even runtime. For example, if you build an extension using a function available only for numpy &amp;gt;= 1.3.0, and you import the extension later with numpy 1.2, you will not get an import error (but almost certainly a segmentation fault when calling the function). That&amp;rsquo;s why several functions are provided to check for numpy versions. The macros &lt;a href=&quot;#c.NPY_VERSION&quot;&gt;&lt;code&gt;NPY_VERSION&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; corresponds to the numpy version used to build the extension, whereas the versions returned by the functions PyArray_GetNDArrayCVersion and PyArray_GetNDArrayCFeatureVersion corresponds to the runtime numpy&amp;rsquo;s version.</source>
          <target state="translated">파이썬 확장은 대부분의 플랫폼에서 일반적인 라이브러리와 같은 방식으로 사용되지 않기 때문에 일부 오류는 빌드 타임 또는 런타임에 자동으로 감지 될 수 없습니다. 예를 들어, numpy&amp;gt; = 1.3.0에만 사용할 수있는 함수를 사용하여 확장을 빌드하고 나중에 numpy 1.2를 사용하여 확장을 가져 오는 경우 가져 오기 오류가 발생하지 않습니다 (그러나 함수를 호출 할 때 거의 확실하게 분할 오류가 발생 함) . numpy 버전을 확인하기 위해 여러 기능이 제공되는 이유입니다. 매크로 &lt;a href=&quot;#c.NPY_VERSION&quot;&gt; &lt;code&gt;NPY_VERSION&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; 은 확장을 빌드하는 데 사용 된 numpy 버전에 해당하는 반면 PyArray_GetNDArrayCVersion 및 PyArray_GetNDArrayCFeatureVersion 함수에 의해 리턴되는 버전은 런타임 numpy의 버전에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="00d51d08a981e99f75ad16b5ac99f6d7fcbcfe04" translate="yes" xml:space="preserve">
          <source>Because the ctypes approach exposes a raw interface to the compiled code it is not always tolerant of user mistakes. Robust use of the ctypes module typically involves an additional layer of Python code in order to check the data types and array bounds of objects passed to the underlying subroutine. This additional layer of checking (not to mention the conversion from ctypes objects to C-data-types that ctypes itself performs), will make the interface slower than a hand-written extension-module interface. However, this overhead should be negligible if the C-routine being called is doing any significant amount of work. If you are a great Python programmer with weak C skills, ctypes is an easy way to write a useful interface to a (shared) library of compiled code.</source>
          <target state="translated">ctypes 접근 방식은 원시 인터페이스를 컴파일 된 코드에 노출하기 때문에 항상 사용자 실수를 용인하지는 않습니다. ctypes 모듈의 강력한 사용에는 일반적으로 기본 서브 루틴에 전달 된 객체의 데이터 유형 및 배열 경계를 확인하기 위해 Python 코드의 추가 계층이 포함됩니다. 이 추가 검사 계층 (ctypes 객체에서 ctypes 자체가 수행하는 C 데이터 유형으로의 변환은 말할 것도 없음)은 인터페이스를 수동으로 작성한 확장 모듈 인터페이스보다 느리게 만듭니다. 그러나 호출되는 C 루틴이 상당한 양의 작업을 수행하는 경우이 오버 헤드는 무시해도됩니다. C 기술이 약한 훌륭한 Python 프로그래머라면 ctypes는 컴파일 된 코드의 (공유) 라이브러리에 유용한 인터페이스를 작성하는 쉬운 방법입니다.</target>
        </trans-unit>
        <trans-unit id="29dd075a4977fb05332410d8621bf30c67da289c" translate="yes" xml:space="preserve">
          <source>Because the discrete Fourier transform separates its input into components that contribute at discrete frequencies, it has a great number of applications in digital signal processing, e.g., for filtering, and in this context the discretized input to the transform is customarily referred to as a &lt;em&gt;signal&lt;/em&gt;, which exists in the &lt;em&gt;time domain&lt;/em&gt;. The output is called a &lt;em&gt;spectrum&lt;/em&gt; or &lt;em&gt;transform&lt;/em&gt; and exists in the &lt;em&gt;frequency domain&lt;/em&gt;.</source>
          <target state="translated">이산 푸리에 변환은 입력을 이산 주파수에 기여하는 컴포넌트로 분리하기 때문에, 디지털 신호 처리에있어서, 예를 들어 필터링과 같은 많은 응용이 있으며, 이러한 맥락에서 변환에 대한 이산 입력은 관례 적으로 &lt;em&gt;신호&lt;/em&gt; 라고 불린다 &lt;em&gt;시간 도메인에&lt;/em&gt; 존재 &lt;em&gt;합니다&lt;/em&gt; . 출력을 &lt;em&gt;스펙트럼&lt;/em&gt; 또는 &lt;em&gt;변환&lt;/em&gt; 이라고하며 &lt;em&gt;주파수 영역에&lt;/em&gt; 존재 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="9e9097d0b4adb9f9ce14f47bf1a8961a11b5917f" translate="yes" xml:space="preserve">
          <source>Because the output is limited to the range of the C int64 type, a ValueError is raised when &lt;code&gt;lam&lt;/code&gt; is within 10 sigma of the maximum representable value.</source>
          <target state="translated">출력이 C int64 유형의 범위로 제한되므로 &lt;code&gt;lam&lt;/code&gt; 이 최대 표현 가능 값의 10 시그마 내에 있으면 ValueError가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="fac8d49cb6d5e3c4d76e0475c48ac86177c281c5" translate="yes" xml:space="preserve">
          <source>Because the special treatment of tuples, they are not automatically converted to an array as a list would be. As an example:</source>
          <target state="translated">튜플의 특수 처리로 인해 목록처럼 자동으로 배열로 변환되지 않습니다. 예로서:</target>
        </trans-unit>
        <trans-unit id="b9411fa9bcced44864e82d01d766c1a2786cafda" translate="yes" xml:space="preserve">
          <source>Because you shouldn&amp;rsquo;t have done that.</source>
          <target state="translated">그렇게하지 말았어야했기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="e66686e9fe82b8c4d1e36e68b32d366de35a5f9f" translate="yes" xml:space="preserve">
          <source>Before beginning, ensure that &lt;em&gt;airspeed velocity&lt;/em&gt; is installed. By default, &lt;code&gt;asv&lt;/code&gt; ships with support for anaconda and virtualenv:</source>
          <target state="translated">시작하기 전에 &lt;em&gt;대기 속도&lt;/em&gt; 가 설치되어 있는지 확인하십시오 . 기본적으로 &lt;code&gt;asv&lt;/code&gt; 는 anaconda 및 virtualenv를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a4352ccd0a83ad23754cd59af6872e1e5131c575" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼을 읽기 전에 Python에 대해 알아야합니다. 기억을 되 살리고 싶다면 &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python 가이드를 참조하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab8362b68d70c7caa9ac18442122ac15a5a21eab" translate="yes" xml:space="preserve">
          <source>Before reading this tutorial, you should know a bit of Python. If you would like to refresh your memory, take a look at the &lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">이 튜토리얼을 읽기 전에 Python에 대해 알아야합니다. 기억을 되 살리고 싶다면 &lt;a href=&quot;https://docs.python.org/dev/tutorial/index.html&quot;&gt;Python 가이드를 참조하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6701eda483d7c3d519624fb81a0315cb15ec0008" translate="yes" xml:space="preserve">
          <source>Before reading this, it may help to familiarize yourself with the basics of C extensions for Python by reading/skimming the tutorials in Section 1 of &lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;Extending and Embedding the Python Interpreter&lt;/a&gt; and in &lt;a href=&quot;c-info.how-to-extend&quot;&gt;How to extend NumPy&lt;/a&gt;</source>
          <target state="translated">이 글을 읽는하기 전에 제 1의 튜토리얼 감추고 / 읽어 파이썬 C 확장의 기본 사항을 숙지하는 데 도움이 될 수 &lt;a href=&quot;https://docs.python.org/extending/index.html&quot;&gt;확장 및 포함 파이썬 인터프리터&lt;/a&gt; 와의 &lt;a href=&quot;c-info.how-to-extend&quot;&gt;NumPy와 확장하는 방법&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="32836ad1d5d4d4bb58df8da3afbc677909c61049" translate="yes" xml:space="preserve">
          <source>Before the release branch is made, it should be checked that all deprecated code that should be removed is actually removed, and all new deprecations say in the docstring or deprecation warning at what version the code will be removed.</source>
          <target state="translated">릴리스 브랜치를 만들기 전에 제거해야하는 모든 사용되지 않는 코드가 실제로 제거되었는지 확인해야하며 모든 새로운 사용 중단은 코드가 제거 될 버전의 docstring 또는 사용 중단 경고에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="6843f140ae464de1cf1062218ac15fdc241e46ba" translate="yes" xml:space="preserve">
          <source>Before you can register a 1-d loop for a ufunc, the ufunc must be previously created. Then you call &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt;&lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the information needed for the loop. The return value of this function is &lt;code&gt;0&lt;/code&gt; if the process was successful and &lt;code&gt;-1&lt;/code&gt; with an error condition set if it was not successful.</source>
          <target state="translated">ufunc에 대한 1-d 루프를 등록하려면 먼저 ufunc를 미리 생성해야합니다. 그런 다음 루프에 필요한 정보를 사용하여 &lt;a href=&quot;../reference/c-api/ufunc#c.PyUFunc_RegisterLoopForType&quot;&gt; &lt;code&gt;PyUFunc_RegisterLoopForType&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 을 호출 합니다. 이 함수의 반환 값은 프로세스가 성공한 경우 &lt;code&gt;0&lt;/code&gt; 이고 성공 하지 못한 경우 오류 조건이 설정된 경우 &lt;code&gt;-1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="be89e8229b2d83a60fa787b8ef67a25d3d7f1699" translate="yes" xml:space="preserve">
          <source>Begin if possible with the large issues, so the author knows they&amp;rsquo;ve been understood. Resist the temptation to immediately go line by line, or to open with small pervasive issues.</source>
          <target state="translated">가능한 한 큰 문제부터 시작하여 저자가 이해했음을 알 수 있습니다. 즉시 한 줄씩 진행하거나 작은 만연한 문제로 시작하려는 유혹에 저항하십시오.</target>
        </trans-unit>
        <trans-unit id="29cee176b513b19c85d7dfdf113b326997fd0f33" translate="yes" xml:space="preserve">
          <source>Behavior when the covariance matrix is not positive semidefinite.</source>
          <target state="translated">공분산 행렬이 양의 반 정밀도가 아닌 경우의 동작입니다.</target>
        </trans-unit>
        <trans-unit id="16b46349029a1f8fc5f5c2e429e2632fc7c9ed5c" translate="yes" xml:space="preserve">
          <source>Behaviors and Errors</source>
          <target state="translated">행동 및 오류</target>
        </trans-unit>
        <trans-unit id="20b4ea80568cb9ce63d7c954c6894e4b50f0041f" translate="yes" xml:space="preserve">
          <source>Below I&amp;rsquo;ll describe three typical approaches of using F2PY. The following example Fortran 77 code will be used for illustration, save it as fib1.f:</source>
          <target state="translated">아래에서는 F2PY를 사용하는 세 가지 일반적인 접근 방식을 설명합니다. 다음 예제 Fortran 77 코드는 설명에 사용되며 fib1.f로 저장합니다.</target>
        </trans-unit>
        <trans-unit id="252e06d389a00c02f7e08aa374784958db4dd768" translate="yes" xml:space="preserve">
          <source>Below are the public attributes of this object which were documented in &amp;ldquo;Guide to NumPy&amp;rdquo; (we have omitted undocumented public attributes, as well as documented private attributes):</source>
          <target state="translated">아래는 &quot;NumPy로 안내&quot;에 설명 된이 개체의 공개 속성입니다 (문서화되지 않은 공개 속성과 문서화 된 비공개 속성은 생략했습니다).</target>
        </trans-unit>
        <trans-unit id="4b6fe750132d00281d0a5b32dae239702c2e48c2" translate="yes" xml:space="preserve">
          <source>Below is a typical usage example: &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt;&lt;code&gt;NBitBase&lt;/code&gt;&lt;/a&gt; is herein used for annotating a function that takes a float and integer of arbitrary precision as arguments and returns a new float of whichever precision is largest (&lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;np.float16 + np.int64 -&amp;gt; np.float64&lt;/code&gt;).</source>
          <target state="translated">다음은 일반적인 사용 예입니다. 여기서 &lt;a href=&quot;#numpy.typing.NBitBase&quot;&gt; &lt;code&gt;NBitBase&lt;/code&gt; &lt;/a&gt; 는 임의 정밀도의 부동 소수점과 정수를 인수로 취하고 정밀도가 가장 큰 새 부동 소수점을 반환하는 함수에 주석을다는 데 사용됩니다 ( &lt;em&gt;예 : &lt;/em&gt; &lt;code&gt;np.float16 + np.int64 -&amp;gt; np.float64&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="94890db1b347a181e379f1b5ca0fad5bcd6b3fc7" translate="yes" xml:space="preserve">
          <source>Below is an example of a minimal &lt;code&gt;setup.py&lt;/code&gt; file for a pure SciPy package:</source>
          <target state="translated">아래는 순수 SciPy 패키지에 대한 최소 &lt;code&gt;setup.py&lt;/code&gt; 파일 의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="525759fddd68e1f874367bb6bfc9a8ba5f573531" translate="yes" xml:space="preserve">
          <source>Below, are several code examples and graphical representations that help make the broadcast rule visually obvious. &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt; adds a one-dimensional array to a two-dimensional array:</source>
          <target state="translated">다음은 브로드 캐스트 규칙을 시각적으로 명확하게 만드는 데 도움이되는 몇 가지 코드 예제와 그래픽 표현입니다. &lt;a href=&quot;#example-3&quot;&gt;예제 3&lt;/a&gt; 은 2 차원 배열에 1 차원 배열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="6f3b2ca2746598a5c0c336c60d7f1e5542f3b64a" translate="yes" xml:space="preserve">
          <source>Benchmarking</source>
          <target state="translated">Benchmarking</target>
        </trans-unit>
        <trans-unit id="817dcc8fca981b9f81e80ededa53ee4f0c2fe004" translate="yes" xml:space="preserve">
          <source>Benchmarking NumPy with Airspeed Velocity.</source>
          <target state="translated">Airspeed Velocity로 NumPy 벤치마킹.</target>
        </trans-unit>
        <trans-unit id="a532923696aa5c8f039ac98c01ebbdc352eb0162" translate="yes" xml:space="preserve">
          <source>Benchmarks are like tests, but have names starting with &amp;ldquo;bench&amp;rdquo; instead of &amp;ldquo;test&amp;rdquo;, and can be found under the &amp;ldquo;benchmarks&amp;rdquo; sub-directory of the module.</source>
          <target state="translated">벤치 마크는 테스트와 비슷하지만 &quot;test&quot;대신 &quot;bench&quot;로 시작하는 이름이 있으며 모듈의 &quot;benchmarks&quot;하위 디렉토리에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e0aad69f001fa26b773185a06a8bef93c3f6567" translate="yes" xml:space="preserve">
          <source>Bernoulli trials are experiments with one of two outcomes: success or failure (an example of such an experiment is flipping a coin). The geometric distribution models the number of trials that must be run in order to achieve success. It is therefore supported on the positive integers, &lt;code&gt;k = 1, 2, ...&lt;/code&gt;.</source>
          <target state="translated">베르누이 (Beroulli) 시험은 성공 또는 실패 두 가지 결과 중 하나를 사용한 실험입니다 (이러한 실험의 예는 동전 던지기입니다). 기하 분포는 성공을 달성하기 위해 실행해야하는 시행 횟수를 모델링합니다. 따라서 양의 정수 &lt;code&gt;k = 1, 2, ...&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="9fb2a7b505b1b75b34095ee2ffe16a241dd5bdfa" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;sys.stdout&lt;/code&gt;, a file-like object can also be used as it has both required methods:</source>
          <target state="translated">&lt;code&gt;sys.stdout&lt;/code&gt; 외에도 파일 류 객체는 두 가지 필수 메소드가 모두 있으므로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4e5ba1e315701c442ad54ed60833fcd6227c3ccc" translate="yes" xml:space="preserve">
          <source>Besides creating an array from a sequence of elements, you can easily create an array filled with &lt;code&gt;0&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="translated">일련의 요소에서 배열을 만드는 것 외에도 &lt;code&gt;0&lt;/code&gt; 으로 채워진 배열을 쉽게 만들 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="feb46c86681950d0f6eb887f4a6fb11b462f9f2e" translate="yes" xml:space="preserve">
          <source>Besides its obvious scientific uses, &lt;em&gt;NumPy&lt;/em&gt; can also be used as an efficient multi-dimensional container of generic data. Arbitrary data types can be defined. This allows &lt;em&gt;NumPy&lt;/em&gt; to seamlessly and speedily integrate with a wide variety of databases.</source>
          <target state="translated">명백한 과학적 용도 외에도 &lt;em&gt;NumPy&lt;/em&gt; 는 일반 데이터의 효율적인 다차원 컨테이너로도 사용할 수 있습니다. 임의의 데이터 유형을 정의 할 수 있습니다. 이를 통해 &lt;em&gt;NumPy&lt;/em&gt; 는 다양한 데이터베이스와 원활하고 신속하게 통합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab274f607cf51efd384bd87e6b3a93295c182bec" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">&lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 의 strides 및 dimension 멤버에 포함 된 구조 정보 외에도 플래그에는 데이터 액세스 방법에 대한 중요한 정보가 포함됩니다. 특히 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; 플래그는 메모리가 데이터 유형 배열에 따라 적절한 경계에있을 때 설정됩니다. 연속 된 메모리 청크가 있더라도 요소에 대한 데이터 유형별 포인터를 역 참조하는 것이 안전하다고 가정 할 수는 없습니다. &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; 플래그가 설정된 경우에만 안전한 작업입니다 (일부 플랫폼에서는 작동하지만 Solaris와 같은 다른 플랫폼에서는 버스 오류가 발생 함). 그만큼&lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;어레이의 메모리 영역에 쓰려는 경우에도 확인해야합니다. 쓰기 불가능한 메모리 영역에 대한 포인터를 얻을 수도 있습니다. 때로는 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그가 설정되지 않은 경우 메모리 영역에 쓰는 것이 무례한 경우가 있습니다. 다른 경우에는 프로그램 충돌을 일으킬 수 있습니다 ( &lt;em&gt;예 :&lt;/em&gt; 읽기 전용 메모리 매핑 파일 인 데이터 영역).</target>
        </trans-unit>
        <trans-unit id="7552a827553f203cc1e2b5ca99b7201f49328d40" translate="yes" xml:space="preserve">
          <source>Besides the structural information contained in the strides and dimensions members of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;, the flags contain important information about how the data may be accessed. In particular, the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set when the memory is on a suitable boundary according to the data-type array. Even if you have a contiguous chunk of memory, you cannot just assume it is safe to dereference a data- type-specific pointer to an element. Only if the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; flag is set is this a safe operation (on some platforms it will work but on others, like Solaris, it will cause a bus error). The &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; should also be ensured if you plan on writing to the memory area of the array. It is also possible to obtain a pointer to an unwritable memory area. Sometimes, writing to the memory area when the &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag is not set will just be rude. Other times it can cause program crashes ( &lt;em&gt;e.g.&lt;/em&gt; a data-area that is a read-only memory-mapped file).</source>
          <target state="translated">&lt;a href=&quot;c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 의 보폭 및 차원 멤버에 포함 된 구조 정보 외에도 플래그에는 데이터에 액세스 할 수있는 방법에 대한 중요한 정보가 포함되어 있습니다. 특히 &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; 플래그는 메모리가 데이터 형 배열에 따라 적절한 경계에있을 때 설정됩니다. 연속적인 메모리 청크가 있더라도 요소에 대한 데이터 유형별 포인터를 역 참조하는 것이 안전하다고 가정 할 수는 없습니다. &lt;a href=&quot;c-api/array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; 플래그가 설정된 경우에만 이것이 안전한 작업입니다 (일부 플랫폼에서는 작동하지만 Solaris와 같은 다른 플랫폼에서는 버스 오류가 발생합니다). &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt;어레이의 메모리 영역에 쓸 계획 인 경우에도 확인해야합니다. 쓰기 불가능한 메모리 영역에 대한 포인터를 얻을 수도 있습니다. 때로는 &lt;a href=&quot;c-api/array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그가 설정되지 않은 경우 메모리 영역에 쓰는 것이 무례합니다. 다른 경우에는 프로그램 충돌을 일으킬 수 있습니다 ( &lt;em&gt;예 :&lt;/em&gt; 읽기 전용 메모리 매핑 파일 인 데이터 영역).</target>
        </trans-unit>
        <trans-unit id="e1ba37be85f86a4053d7f866745343aa6628b3b0" translate="yes" xml:space="preserve">
          <source>Besides using &lt;code&gt;runtests.py&lt;/code&gt;, there are various ways to run the tests. Inside the interpreter, tests can be run like this:</source>
          <target state="translated">&lt;code&gt;runtests.py&lt;/code&gt; 를 사용하는 것 외에도 테스트를 실행하는 다양한 방법이 있습니다. 인터프리터 내에서 테스트는 다음과 같이 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bf0953ee914f2edfe24d253c99b5774c0b042b9" translate="yes" xml:space="preserve">
          <source>Best choice for unitary and other non-Hermitian normal matrices.</source>
          <target state="translated">단일 및 기타 비 Hermitian 정규 행렬에 가장 적합한 선택입니다.</target>
        </trans-unit>
        <trans-unit id="22e034c69c8701c0ed22fdd3834451a1ee6eff5e" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">재현 가능한 비트 스트림을 달성하는 가장 좋은 방법 은 초기 엔트로피에 기본 &lt;code&gt;None&lt;/code&gt; 을 사용한 다음 &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt; 를 사용하여 재현성 을 위해 &lt;a href=&quot;../../entropy#module-numpy.random.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt; 를 기록 / 피클하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7670ec2417d2f252a955be33c6c1b4f20bd90718" translate="yes" xml:space="preserve">
          <source>Best practice for achieving reproducible bit streams is to use the default &lt;code&gt;None&lt;/code&gt; for the initial entropy, and then use &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;SeedSequence.entropy&lt;/code&gt;&lt;/a&gt; to log/pickle the &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt;&lt;code&gt;entropy&lt;/code&gt;&lt;/a&gt; for reproducibility:</source>
          <target state="translated">재현 가능한 비트 스트림을 얻기위한 모범 사례 는 초기 엔트로피에 기본값 &lt;code&gt;None&lt;/code&gt; 을 사용한 다음 &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;SeedSequence.entropy&lt;/code&gt; &lt;/a&gt; 를 사용하여 재현성 을 위해 &lt;a href=&quot;numpy.random.seedsequence.entropy#numpy.random.SeedSequence.entropy&quot;&gt; &lt;code&gt;entropy&lt;/code&gt; &lt;/a&gt; 를 기록 / 피클하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="ff113b93867eb5d4708dd06e48a11f6662278fd5" translate="yes" xml:space="preserve">
          <source>Beta, positive (&amp;gt;0).</source>
          <target state="translated">베타, 양성 (&amp;gt; 0).</target>
        </trans-unit>
        <trans-unit id="df6d93c232f8ef730e08cac2f842b70dab985fb0" translate="yes" xml:space="preserve">
          <source>Beta: &amp;lsquo;1.8.0b1&amp;rsquo;, &amp;lsquo;1.8.0b2&amp;rsquo;, etc.</source>
          <target state="translated">베타 : '1.8.0b1', '1.8.0b2'등</target>
        </trans-unit>
        <trans-unit id="e5c69acc70fda034169d23116e19f5548d61c870" translate="yes" xml:space="preserve">
          <source>Better &lt;code&gt;repr&lt;/code&gt; of object arrays</source>
          <target state="translated">객체 배열의 더 나은 &lt;code&gt;repr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71ff91962e9990f86b3c3c6f7d7e56caab72ace4" translate="yes" xml:space="preserve">
          <source>Better behaviour of ufunc identities during reductions</source>
          <target state="translated">축소 중 ufunc ID의 더 나은 동작</target>
        </trans-unit>
        <trans-unit id="2e8b6f98e6b21c5c6afa9104a0769b9205288f70" translate="yes" xml:space="preserve">
          <source>Better default repr for &lt;code&gt;ndarray&lt;/code&gt; subclasses</source>
          <target state="translated">&lt;code&gt;ndarray&lt;/code&gt; 하위 클래스에 대한 더 나은 기본 repr</target>
        </trans-unit>
        <trans-unit id="9c34cb1b69a33b2d347cbab7a352fe546099b5b5" translate="yes" xml:space="preserve">
          <source>Better numerical stability for sum in some cases</source>
          <target state="translated">경우에 따라 합계에 대한 더 나은 수치 안정성</target>
        </trans-unit>
        <trans-unit id="c1c0df1717608a8779754648098f8f6a8b834b75" translate="yes" xml:space="preserve">
          <source>Better support for &lt;code&gt;const&lt;/code&gt; dimensions in API functions</source>
          <target state="translated">API 함수에서 &lt;code&gt;const&lt;/code&gt; 차원에 대한 더 나은 지원</target>
        </trans-unit>
        <trans-unit id="9bf8b70bc38b460cf450f48cba644f58d2901785" translate="yes" xml:space="preserve">
          <source>Better support for empty structured and string types</source>
          <target state="translated">빈 구조화 및 문자열 유형에 대한 더 나은 지원</target>
        </trans-unit>
        <trans-unit id="741240e1ef7d29df48749ede4195530d21b5583c" translate="yes" xml:space="preserve">
          <source>Beyond changes to a functions docstring and possible description in the general documentation, if your change introduces any user-facing modifications they may need to be mentioned in the release notes. To add your change to the release notes, you need to create a short file with a summary and place it in &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt;. The file &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; details the format and filename conventions.</source>
          <target state="translated">일반 문서의 함수 독 스트링 및 가능한 설명에 대한 변경 사항 외에도 사용자가 직접 수정 한 사항이 있으면 릴리스 노트에서 언급해야 할 수 있습니다. 릴리스 노트에 변경 사항을 추가하려면 요약이 포함 된 짧은 파일을 만들어 &lt;code&gt;doc/release/upcoming_changes&lt;/code&gt; 에 배치해야합니다 . 파일 &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; 형식과 파일 이름 규칙을 자세히 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1d7c1c795d86187e8f7208b51b9e4bbd86fa144c" translate="yes" xml:space="preserve">
          <source>Beyond the Basics</source>
          <target state="translated">기본을 넘어서</target>
        </trans-unit>
        <trans-unit id="26ffbba2ad335a399beb79e57cd9f0fee4d0bfe1" translate="yes" xml:space="preserve">
          <source>Beyond the Provided Typemaps</source>
          <target state="translated">제공된 타입 맵을 넘어</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="2381a720988421ed44a915283532f745ec598844" translate="yes" xml:space="preserve">
          <source>Binary Format Description</source>
          <target state="translated">이진 형식 설명</target>
        </trans-unit>
        <trans-unit id="b26f6c63a335a90adeeab8f4d5013e4f2efe2bec" translate="yes" xml:space="preserve">
          <source>Binary operations</source>
          <target state="translated">이진 연산</target>
        </trans-unit>
        <trans-unit id="e2606828726dd092395e99ae84af2fb16d4bba99" translate="yes" xml:space="preserve">
          <source>Binary operations with non-arrays as second argument</source>
          <target state="translated">두 번째 인수로 배열이 아닌 이진 연산</target>
        </trans-unit>
        <trans-unit id="1cc036b4a48151bfca642ff2ead78a54a934983c" translate="yes" xml:space="preserve">
          <source>Binary representation of &lt;code&gt;num&lt;/code&gt; or two&amp;rsquo;s complement of &lt;code&gt;num&lt;/code&gt;.</source>
          <target state="translated">바이너리 표현 &lt;code&gt;num&lt;/code&gt; 또는 2의 보수 &lt;code&gt;num&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cc1259e21c7e613999e790394c5c675e22538ae" translate="yes" xml:space="preserve">
          <source>Binary search is used to find the required insertion points.</source>
          <target state="translated">이진 검색은 필요한 삽입 점을 찾는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d16d7bbb9c6ef7dc7a209b9f7f44b9f5da556503" translate="yes" xml:space="preserve">
          <source>Binary serialization</source>
          <target state="translated">이진 직렬화</target>
        </trans-unit>
        <trans-unit id="c2fcfedbbaa7680e63fd8ec6b6d6fea722eb952d" translate="yes" xml:space="preserve">
          <source>Binomials</source>
          <target state="translated">Binomials</target>
        </trans-unit>
        <trans-unit id="d12186b0252e4232a8110ba893b738140b658fd0" translate="yes" xml:space="preserve">
          <source>Bit Generators</source>
          <target state="translated">비트 생성기</target>
        </trans-unit>
        <trans-unit id="d9ea127fdd4796c75fc01357c967509bff02d70a" translate="yes" xml:space="preserve">
          <source>Bit field (following integer gives the number of bits in the bit field).</source>
          <target state="translated">비트 필드 (정수 뒤에 오는 비트 필드의 비트 수)</target>
        </trans-unit>
        <trans-unit id="4239f8b7894d76bb52c94538f111a8da8d4fb0a0" translate="yes" xml:space="preserve">
          <source>Bit packing</source>
          <target state="translated">비트 패킹</target>
        </trans-unit>
        <trans-unit id="b80dbb4a253c53f5aa98843beeecc669ef1da4eb" translate="yes" xml:space="preserve">
          <source>Bit-flags describing how this data type is to be interpreted.</source>
          <target state="translated">이 데이터 유형을 해석하는 방법을 설명하는 비트 플래그.</target>
        </trans-unit>
        <trans-unit id="59a321c44dd261b336bb24b8f3a93b2ffcf9ad14" translate="yes" xml:space="preserve">
          <source>Bit-masks are in &lt;code&gt;numpy.core.multiarray&lt;/code&gt; as the constants &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt;, &lt;code&gt;LIST_PICKLE&lt;/code&gt;, &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt;, &lt;code&gt;NEEDS_INIT&lt;/code&gt;, &lt;code&gt;NEEDS_PYAPI&lt;/code&gt;, &lt;code&gt;USE_GETITEM&lt;/code&gt;, &lt;code&gt;USE_SETITEM&lt;/code&gt;. A full explanation of these flags is in C-API documentation; they are largely useful for user-defined data-types.</source>
          <target state="translated">비트 마스크에 &lt;code&gt;numpy.core.multiarray&lt;/code&gt; 상수로 &lt;code&gt;ITEM_HASOBJECT&lt;/code&gt; , &lt;code&gt;LIST_PICKLE&lt;/code&gt; , &lt;code&gt;ITEM_IS_POINTER&lt;/code&gt; , &lt;code&gt;NEEDS_INIT&lt;/code&gt; , &lt;code&gt;NEEDS_PYAPI&lt;/code&gt; , &lt;code&gt;USE_GETITEM&lt;/code&gt; , &lt;code&gt;USE_SETITEM&lt;/code&gt; . 이러한 플래그에 대한 자세한 설명은 C-API 설명서에 있습니다. 이들은 사용자 정의 데이터 유형에 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="c6c2f273c5d1a8dcbceea602bbb87c029bbc0d32" translate="yes" xml:space="preserve">
          <source>Bit-twiddling functions</source>
          <target state="translated">비트 트위들 링 기능</target>
        </trans-unit>
        <trans-unit id="460d665e77f8686560c843f72478486336f12a1b" translate="yes" xml:space="preserve">
          <source>Bit-width names</source>
          <target state="translated">비트 폭 이름</target>
        </trans-unit>
        <trans-unit id="7176dd338904b0fc1d2cdf1063572e4e5cbd193a" translate="yes" xml:space="preserve">
          <source>Bit-width references to enumerated typenums</source>
          <target state="translated">열거 된 typenum에 대한 비트 너비 참조</target>
        </trans-unit>
        <trans-unit id="143911730a6c4fbdf6bd766470cddffa24dd0b5c" translate="yes" xml:space="preserve">
          <source>BitGenerator</source>
          <target state="translated">BitGenerator</target>
        </trans-unit>
        <trans-unit id="e1d49785c1daa86c89ab6e63f74767502d9e2cd5" translate="yes" xml:space="preserve">
          <source>BitGenerator (class in numpy.random)</source>
          <target state="translated">BitGenerator (numpy.random의 클래스)</target>
        </trans-unit>
        <trans-unit id="cc03ca2870189a580c7299116633756162b41a61" translate="yes" xml:space="preserve">
          <source>BitGenerator for Chris Doty-Humphrey&amp;rsquo;s Small Fast Chaotic PRNG.</source>
          <target state="translated">Chris Doty-Humphrey의 소형 고속 혼돈 PRNG 용 BitGenerator.</target>
        </trans-unit>
        <trans-unit id="218df33e7359786597fc4c2a6c1726e5e91ef2e6" translate="yes" xml:space="preserve">
          <source>BitGenerator for the PCG-64 pseudo-random number generator.</source>
          <target state="translated">PCG-64 의사 난수 생성기를위한 BitGenerator.</target>
        </trans-unit>
        <trans-unit id="9b6bde107d0c3c8164f2b3ab1e4164dad1766298" translate="yes" xml:space="preserve">
          <source>BitGenerator to use as the core generator.</source>
          <target state="translated">핵심 생성기로 사용할 BitGenerator</target>
        </trans-unit>
        <trans-unit id="dbbe08f6d74daba648b1cd173a6a41449071b1bf" translate="yes" xml:space="preserve">
          <source>BitGenerator.random_raw()</source>
          <target state="translated">BitGenerator.random_raw()</target>
        </trans-unit>
        <trans-unit id="ade67fe752c31c985cb01482e4ad03f16cfe18bb" translate="yes" xml:space="preserve">
          <source>BitGenerators: Objects that generate random numbers. These are typically unsigned integer words filled with sequences of either 32 or 64 random bits.</source>
          <target state="translated">BitGenerators : 난수를 생성하는 객체. 이들은 일반적으로 32 또는 64 개의 임의 비트 시퀀스로 채워진 부호없는 정수 워드입니다.</target>
        </trans-unit>
        <trans-unit id="a36a25a1cccb68c7c87fcd879bbb216973e2de75" translate="yes" xml:space="preserve">
          <source>Bits</source>
          <target state="translated">Bits</target>
        </trans-unit>
        <trans-unit id="02f4859e8970806328996752f2ca5818252436db" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the left by appending &lt;code&gt;x2&lt;/code&gt; 0s at the right of &lt;code&gt;x1&lt;/code&gt;. Since the internal representation of numbers is in binary format, this operation is equivalent to multiplying &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 오른쪽에 &lt;code&gt;x2&lt;/code&gt; 0을 추가하여 비트를 왼쪽으로 이동합니다 . 숫자의 내부 표현은 이진 형식 &lt;code&gt;x1&lt;/code&gt; 연산은 x1 에 &lt;code&gt;2**x2&lt;/code&gt; 를 곱하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9f79b7b35bc256a0d1b6d4ab01f312eace24eb" translate="yes" xml:space="preserve">
          <source>Bits are shifted to the right &lt;code&gt;x2&lt;/code&gt;. Because the internal representation of numbers is in binary format, this operation is equivalent to dividing &lt;code&gt;x1&lt;/code&gt; by &lt;code&gt;2**x2&lt;/code&gt;.</source>
          <target state="translated">비트는 오른쪽 &lt;code&gt;x2&lt;/code&gt; 로 이동합니다 . 숫자의 내부 표현은 이진 형식 &lt;code&gt;x1&lt;/code&gt; 연산은 x1 을 &lt;code&gt;2**x2&lt;/code&gt; 로 나누는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="eb86c6c99db380b9a785bd4e060a6f5dc41e87fd" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt;&lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">개체 데이터 유형에 대해 설정된 비트 : ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_REFCOUNT&quot;&gt; &lt;code&gt;NPY_ITEM_REFCOUNT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="117a063b0a577c59c490f864292bca239247279f" translate="yes" xml:space="preserve">
          <source>Bits set for the object data-type: ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt;&lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt;&lt;code&gt;NPY_USE_GETITEM&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt;&lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt;&lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt;&lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt;&lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt;&lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">객체 데이터 유형에 설정된 비트 : ( &lt;a href=&quot;#c.NPY_LIST_PICKLE&quot;&gt; &lt;code&gt;NPY_LIST_PICKLE&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_USE_GETITEM&quot;&gt; &lt;code&gt;NPY_USE_GETITEM&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_ITEM_IS_POINTER&quot;&gt; &lt;code&gt;NPY_ITEM_IS_POINTER&lt;/code&gt; &lt;/a&gt; | &lt;code&gt;NPY_REFCOUNT&lt;/code&gt; | &lt;a href=&quot;#c.NPY_NEEDS_INIT&quot;&gt; &lt;code&gt;NPY_NEEDS_INIT&lt;/code&gt; &lt;/a&gt; | &lt;a href=&quot;#c.NPY_NEEDS_PYAPI&quot;&gt; &lt;code&gt;NPY_NEEDS_PYAPI&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="13031923c83ade827195c6241750d4615a698b51" translate="yes" xml:space="preserve">
          <source>Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra, Dover Publications, New York.</source>
          <target state="translated">Blackman, RB and Tukey, JW, (1958) 전력 스펙트럼의 측정, Dover Publications, New York.</target>
        </trans-unit>
        <trans-unit id="348cdf7ff3c8eec7d1cd1aa8880558948fba2435" translate="yes" xml:space="preserve">
          <source>Blocks can be of any dimension, but will not be broadcasted using the normal rules. Instead, leading axes of size 1 are inserted, to make &lt;code&gt;block.ndim&lt;/code&gt; the same for all blocks. This is primarily useful for working with scalars, and means that code like &lt;code&gt;np.block([v, 1])&lt;/code&gt; is valid, where &lt;code&gt;v.ndim == 1&lt;/code&gt;.</source>
          <target state="translated">블록은 어떤 차원이든 될 수 있지만 일반적인 규칙을 사용하여 브로드 캐스트되지는 않습니다. 대신 크기가 1 인 리딩 축이 삽입 되어 모든 블록에 대해 &lt;code&gt;block.ndim&lt;/code&gt; 을 동일 하게 만듭니다 . 이것은 주로 스칼라 작업에 유용하며 &lt;code&gt;np.block([v, 1])&lt;/code&gt; 과 같은 코드 가 유효 하다는 것을 의미합니다 . 여기서 &lt;code&gt;v.ndim == 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8994034796d9ec39a7933eb34371fad5f6ce9920" translate="yes" xml:space="preserve">
          <source>Blocks in the innermost lists are concatenated (see &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt;) along the last dimension (-1), then these are concatenated along the second-last dimension (-2), and so on until the outermost list is reached.</source>
          <target state="translated">최 목록의 블록 (참조 연결된다 &lt;a href=&quot;numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; 최종 치수를 따라) (-1), 그 다음 이러한 두 번째 최종 치수를 따라 연결된다 (-2), 그래서 최 목록에 도달 할 때까지.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="317be1616a174c84304de299b4ead5ef76ce4a76" translate="yes" xml:space="preserve">
          <source>Boolean (True or False) stored as a byte</source>
          <target state="translated">바이트로 저장된 부울 (True 또는 False)</target>
        </trans-unit>
        <trans-unit id="71383121b53c1c9facdaaabc47b0de18549c5c80" translate="yes" xml:space="preserve">
          <source>Boolean (integer type where all values are only True or False)</source>
          <target state="translated">부울 (모든 값이 True 또는 False 인 정수 유형)</target>
        </trans-unit>
        <trans-unit id="c7a0fd639a6581c56ba10f492adee6f212cd45b8" translate="yes" xml:space="preserve">
          <source>Boolean 1-d array selecting which entries to return. If len(condition) is less than the size of a along the axis, then output is truncated to length of condition array.</source>
          <target state="translated">반환 할 항목을 선택하는 부울 1-d 배열입니다. len (condition)이 축을 따라 a의 크기보다 작 으면 출력이 조건 배열의 길이로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="87962449a461c8ec49f5151d2bbb30e7a462a28e" translate="yes" xml:space="preserve">
          <source>Boolean array indexing</source>
          <target state="translated">부울 배열 인덱싱</target>
        </trans-unit>
        <trans-unit id="60d82fac26a05eb411b70101c41bd3047454cb5f" translate="yes" xml:space="preserve">
          <source>Boolean array indices with mismatching shapes now properly give &lt;code&gt;IndexError&lt;/code&gt;</source>
          <target state="translated">모양이 일치하지 않는 부울 배열 인덱스가 이제 올바르게 &lt;code&gt;IndexError&lt;/code&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="c1aefe73a2b6727a0e572007771ddec686a6bb1f" translate="yes" xml:space="preserve">
          <source>Boolean array of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 같은 모양의 부울 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="233d1fbe1852dc657d35dfe3cd279e3947a9a911" translate="yes" xml:space="preserve">
          <source>Boolean arrays used as indices are treated in a different manner entirely than index arrays. Boolean arrays must be of the same shape as the initial dimensions of the array being indexed. In the most straightforward case, the boolean array has the same shape:</source>
          <target state="translated">인덱스로 사용되는 부울 배열은 인덱스 배열과 완전히 다른 방식으로 처리됩니다. 부울 배열은 인덱싱되는 배열의 초기 차원과 모양이 같아야합니다. 가장 간단한 경우 부울 배열의 모양은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="98073379b648edd4cbe725ce47f959a6d23058d4" translate="yes" xml:space="preserve">
          <source>Boolean indexing changes</source>
          <target state="translated">부울 인덱싱 변경</target>
        </trans-unit>
        <trans-unit id="639386fbce5315b91a1c655018a3b9643e9bcfef" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the byte order of this dtype is native to the platform.</source>
          <target state="translated">이 dtype의 바이트 순서가 플랫폼 고유인지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="0c76417c3c3c65ffeed61396388e3db4b8c19de6" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment.</source>
          <target state="translated">dtype이 필드 정렬을 유지하는 구조 체인지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="dad1680b2705f6d7f6eeec97cbb513a4e1699f09" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether the dtype is a struct which maintains field alignment. This flag is sticky, so when combining multiple structs together, it is preserved and produces new dtypes which are also aligned.</source>
          <target state="translated">dtype이 필드 정렬을 유지하는 구조 체인지 여부를 나타내는 부울입니다. 이 플래그는 고정적이므로 여러 구조체를 함께 결합하면 유지되고 새로운 dtype도 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="36f2224ace3c78a988e50bdc966ac649a4d3fc0b" translate="yes" xml:space="preserve">
          <source>Boolean indicating whether this dtype contains any reference-counted objects in any fields or sub-dtypes.</source>
          <target state="translated">이 dtype에 필드 또는 하위 dtype에 참조 횟수 개체가 포함되어 있는지 여부를 나타내는 부울입니다.</target>
        </trans-unit>
        <trans-unit id="398d7e2271209225ea68a985a7b2fa72caeee3a6" translate="yes" xml:space="preserve">
          <source>Boolean mask array. It has to be the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">부울 마스크 배열. 의 모양과 같아야 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59815579c0e1a982c330b63fe4d4075e4fd81815" translate="yes" xml:space="preserve">
          <source>Boolean mask array. Must have the same size as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">부울 마스크 배열. 의 크기와 같아야 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="30d9ef559552bdd87313d89c8796d8136275e739" translate="yes" xml:space="preserve">
          <source>Boolean operations</source>
          <target state="translated">부울 연산</target>
        </trans-unit>
        <trans-unit id="0d747f327c87280779ba3eb08a42ad6dc25e090e" translate="yes" xml:space="preserve">
          <source>Boolean or &amp;ldquo;mask&amp;rdquo; index arrays</source>
          <target state="translated">부울 또는 &quot;마스크&quot;인덱스 배열</target>
        </trans-unit>
        <trans-unit id="dd5ec2e25bdf5818c59dcd317ab96e5a1ea9111e" translate="yes" xml:space="preserve">
          <source>Boolean result of check whether &lt;code&gt;rep&lt;/code&gt; is a scalar dtype.</source>
          <target state="translated">&lt;code&gt;rep&lt;/code&gt; 가 스칼라 dtype 인지 확인한 부울 결과입니다 .</target>
        </trans-unit>
        <trans-unit id="e4ae3e1eb416ce7ddaa17364adbe02e871496027" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical AND operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용된 논리 AND 연산의 부울 결과입니다 . 모양은 방송에 의해 결정됩니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="80129c87ec19d7266b12fa62c898f1de8e697318" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical OR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용된 논리 OR 연산의 부울 결과 . 형태는 방송에 의해 결정됩니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="efce76e1529f243bc75f6c85e1cb168b94a21ce6" translate="yes" xml:space="preserve">
          <source>Boolean result of the logical XOR operation applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;; the shape is determined by broadcasting. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용된 논리 XOR 연산의 부울 결과 . 형태는 방송에 의해 결정됩니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="e598e8b30eff8ac988c047694ee54841654f4531" translate="yes" xml:space="preserve">
          <source>Boolean result with the same shape as &lt;code&gt;x&lt;/code&gt; of the NOT operation on elements of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">같은 모양 부울 결과 &lt;code&gt;x&lt;/code&gt; 의 요소에 NOT 연산 &lt;code&gt;x&lt;/code&gt; . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="b93268f3c2db16861f90ecc22ed53005b764061c" translate="yes" xml:space="preserve">
          <source>Boolean type (True or False), stored as a byte.</source>
          <target state="translated">바이트로 저장되는 부울 유형 (True 또는 False).</target>
        </trans-unit>
        <trans-unit id="4cfb7a503c91815ccbf2f35210fcd3eadc71e7eb" translate="yes" xml:space="preserve">
          <source>Booleans are accepted as well:</source>
          <target state="translated">부울도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fff8683eb97daf0f7f34cfbaabaadf811d8b8133" translate="yes" xml:space="preserve">
          <source>Booleans:</source>
          <target state="translated">Booleans:</target>
        </trans-unit>
        <trans-unit id="37cb1b945ecb9b619ea4147615565076f43e7b81" translate="yes" xml:space="preserve">
          <source>Boost Python</source>
          <target state="translated">Python 부스트</target>
        </trans-unit>
        <trans-unit id="80eb86696c9c70e3e908a024dfe4075dae3951c7" translate="yes" xml:space="preserve">
          <source>Boost is a repository of C++ libraries and Boost.Python is one of those libraries which provides a concise interface for binding C++ classes and functions to Python. The amazing part of the Boost.Python approach is that it works entirely in pure C++ without introducing a new syntax. Many users of C++ report that Boost.Python makes it possible to combine the best of both worlds in a seamless fashion. I have not used Boost.Python because I am not a big user of C++ and using Boost to wrap simple C-subroutines is usually over-kill. It&amp;rsquo;s primary purpose is to make C++ classes available in Python. So, if you have a set of C++ classes that need to be integrated cleanly into Python, consider learning about and using Boost.Python.</source>
          <target state="translated">Boost는 C ++ 라이브러리의 저장소이고 Boost.Python은 C ++ 클래스와 함수를 Python에 바인딩하기위한 간결한 인터페이스를 제공하는 라이브러리 중 하나입니다. Boost.Python 접근 방식의 놀라운 부분은 새로운 구문을 도입하지 않고 순수 C ++에서 완전히 작동한다는 것입니다. 많은 C ++ 사용자가 Boost.Python을 사용하면 두 세계의 장점을 완벽하게 결합 할 수 있다고보고합니다. 나는 C ++의 큰 사용자가 아니기 때문에 Boost.Python을 사용하지 않았으며 Boost를 사용하여 간단한 C- 서브 루틴을 래핑하는 것은 일반적으로 과잉입니다. 주요 목적은 Python에서 C ++ 클래스를 사용할 수 있도록하는 것입니다. 따라서 Python에 깔끔하게 통합되어야하는 C ++ 클래스 집합이있는 경우 Boost.Python에 대해 배우고 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3d9f5c6c1605197a54538b1a42018d968a659108" translate="yes" xml:space="preserve">
          <source>Boost.Python</source>
          <target state="translated">Boost.Python</target>
        </trans-unit>
        <trans-unit id="35f319efb34e1e345510a06307dd059dbed15ac2" translate="yes" xml:space="preserve">
          <source>Boost.python</source>
          <target state="translated">Boost.python</target>
        </trans-unit>
        <trans-unit id="6a6c7de0b010d58cd0f9cb5716158db428b24bc0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;v&lt;/code&gt; must be 0-d or 1-d (ndim = 0 or 1), but &lt;code&gt;u.ndim&lt;/code&gt; need not equal &lt;code&gt;v.ndim&lt;/code&gt;. In other words, all four possible combinations - &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt;, &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt;, &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt;, and &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; - work.</source>
          <target state="translated">두 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;v&lt;/code&gt; 0 또는 1-D-D (ndim = 0 또는 1)해야하지만 &lt;code&gt;u.ndim&lt;/code&gt; 필요 같지 &lt;code&gt;v.ndim&lt;/code&gt; . 즉, &lt;code&gt;u.ndim = v.ndim = 0&lt;/code&gt; , &lt;code&gt;u.ndim = v.ndim = 1&lt;/code&gt; , &lt;code&gt;u.ndim = 1, v.ndim = 0&lt;/code&gt; , &lt;code&gt;u.ndim = 0, v.ndim = 1&lt;/code&gt; 네 가지 가능한 조합이 있습니다. ndim = 1- 작동합니다.</target>
        </trans-unit>
        <trans-unit id="88f65d9e2d112f1a7a284a45eccfdccc621dc60d" translate="yes" xml:space="preserve">
          <source>Both C-ordering (&amp;ldquo;last dimension fastest&amp;rdquo;) or Fortran-ordering (&amp;ldquo;first dimension fastest&amp;rdquo;) support for 2D, 3D and 4D arrays.</source>
          <target state="translated">2 차원, 3 차원 및 4 차원 배열에 대해 C 순서 ( &quot;최종 차원&quot;) 또는 포트란 순서 ( &quot;1 차원&quot;)를 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="3720a76c9cc3b6258ee484172d090cd5b19b7e16" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a &lt;code&gt;DLL&lt;/code&gt; or &lt;code&gt;so&lt;/code&gt;. An example showing the use of a more complicated distribution is in the &lt;code&gt;examples&lt;/code&gt; section below.</source>
          <target state="translated">하는 ctypes와 CFFI 모두 더 복잡하게 분포는로 파일 distributions.c을 컴파일 한 후 Numba에서 직접 사용할 수 있도록 &lt;code&gt;DLL&lt;/code&gt; 또는 &lt;code&gt;so&lt;/code&gt; . 더 복잡한 배포판의 사용을 보여주는 예는 아래 &lt;code&gt;examples&lt;/code&gt; 섹션에 있습니다.</target>
        </trans-unit>
        <trans-unit id="6876b038e6598420047feff6385d214f7a9456e4" translate="yes" xml:space="preserve">
          <source>Both CTypes and CFFI allow the more complicated distributions to be used directly in Numba after compiling the file distributions.c into a DLL or so. An example showing the use of a more complicated distribution is in the examples folder.</source>
          <target state="translated">CTypes와 CFFI는 distributions.c를 DLL 등으로 컴파일 한 후 Numba에서보다 복잡한 배포판을 직접 사용할 수있게합니다. 보다 복잡한 배포판을 사용하는 예는 예제 폴더에 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b2e6b498660f219d33da75fb672071ec22d0de1" translate="yes" xml:space="preserve">
          <source>Both arguments must be convertible to data-type objects with the same total size.</source>
          <target state="translated">두 인수 모두 총 크기가 동일한 데이터 유형 객체로 변환 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="25024cfe43b48611add0d26f273e9fb8f30c82d0" translate="yes" xml:space="preserve">
          <source>Both for indexing:</source>
          <target state="translated">인덱싱 모두 :</target>
        </trans-unit>
        <trans-unit id="9c58adbe49cf294225a6b4d010fdfff04815b05a" translate="yes" xml:space="preserve">
          <source>Both of these routines multiply an &lt;em&gt;n&lt;/em&gt; -length array, &lt;em&gt;seq&lt;/em&gt;, of integers and return the result. No overflow checking is performed.</source>
          <target state="translated">이 루틴들 모두 정수 의 &lt;em&gt;n-&lt;/em&gt; 길이 배열 &lt;em&gt;seq를&lt;/em&gt; 곱하고 결과를 반환합니다. 오버 플로우 검사가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e7d4dd33376799dad2f66b13833f7382c04f91d5" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;names&lt;/code&gt; and &lt;code&gt;fields&lt;/code&gt; attributes will equal &lt;code&gt;None&lt;/code&gt; for unstructured arrays. The recommended way to test if a dtype is structured is with &lt;code&gt;if dt.names is not None&lt;/code&gt; rather than &lt;code&gt;if dt.names&lt;/code&gt;, to account for dtypes with 0 fields.</source>
          <target state="translated">구조화되지 않은 배열의 경우 &lt;code&gt;names&lt;/code&gt; 및 &lt;code&gt;fields&lt;/code&gt; 속성 모두 &lt;code&gt;None&lt;/code&gt; 이됩니다. dtype이 구조화되었는지 테스트하는 권장 방법은 &lt;code&gt;if dt.names is not None&lt;/code&gt; 이 아닌 &lt;code&gt;if dt.names&lt;/code&gt; dt.names가 0 필드가있는 dtypes를 고려하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="a5df7074d510c649a42e62d1e6b7c4d94875f1b9" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;../glossary#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">C 및 Fortran 순서는 모두 &lt;a href=&quot;../glossary#term-contiguous&quot;&gt;연속적입니다&lt;/a&gt; . &lt;em&gt;즉,&lt;/em&gt; 단일 세그먼트, 메모리 레이아웃으로, 일부 인덱스 조합으로 메모리 블록의 모든 부분에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a9d7b7663daf24925c25758270cb4610491dfdf" translate="yes" xml:space="preserve">
          <source>Both the C and Fortran orders are &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;contiguous&lt;/a&gt;, &lt;em&gt;i.e.,&lt;/em&gt; single-segment, memory layouts, in which every part of the memory block can be accessed by some combination of the indices.</source>
          <target state="translated">C 및 Fortran 차수는 &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-contiguous&quot;&gt;연속적&lt;/a&gt; 이며, &lt;em&gt;즉&lt;/em&gt; 단일 세그먼트 메모리 레이아웃으로, 일부 인덱스 조합으로 메모리 블록의 모든 부분에 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d093ba37f9ce9c9f30f8fca73c109507dfcb0225" translate="yes" xml:space="preserve">
          <source>Both the Frobenius and nuclear norm orders are only defined for matrices and raise a ValueError when &lt;code&gt;x.ndim != 2&lt;/code&gt;.</source>
          <target state="translated">Frobenius 및 핵 노름 순서는 모두 행렬에 대해서만 정의되며 &lt;code&gt;x.ndim != 2&lt;/code&gt; 때 ValueError를 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="ffea5bc12b4c544392f03bcbcae76a932ec7e9d3" translate="yes" xml:space="preserve">
          <source>Both vectors with dimension 2.</source>
          <target state="translated">차원이 2 인 두 벡터</target>
        </trans-unit>
        <trans-unit id="ee63b82109d9ff030ecbe37ab04ceac7db2412e8" translate="yes" xml:space="preserve">
          <source>Breaking long lines: if you can, break after commas in the outermost argument list. Always indent continuation lines appropriately, e.g.,</source>
          <target state="translated">긴 줄 끊기 : 가능하면 가장 바깥 쪽 인수 목록에서 쉼표 뒤에서 줄 바꿈합니다. 항상 연속 줄을 적절하게 들여 쓰십시오. 예 :</target>
        </trans-unit>
        <trans-unit id="bd6b304289af9581af2ffeee2445279337f31f30" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., &amp;ldquo;Rayleigh Distribution,&amp;rdquo; &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., &quot;Rayleigh Distribution&quot;, &lt;a href=&quot;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&quot;&gt;https://web.archive.org/web/20090514091424/http://brighton-webs.co.uk:80/distributions/rayleigh.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f95280aadb50a5d76ebefb36fbe813c4a9ec99eb" translate="yes" xml:space="preserve">
          <source>Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</source>
          <target state="translated">Brighton Webs Ltd., Wald Distribution, &lt;a href=&quot;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&quot;&gt;https://web.archive.org/web/20090423014010/http://www.brighton-webs.co.uk:80/distributions/wald.asp&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8d469ff5df319fd73b1f4431adc89a3cb7f9bc26" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape</source>
          <target state="translated">배열을 새로운 모양으로 브로드 캐스트</target>
        </trans-unit>
        <trans-unit id="73facd5bb35116bed91fa4d11828ee34122a7818" translate="yes" xml:space="preserve">
          <source>Broadcast an array to a new shape.</source>
          <target state="translated">배열을 새로운 모양으로 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="335cb5d296e07dc61fd4677d50111abd1712ceae" translate="yes" xml:space="preserve">
          <source>Broadcast any number of arrays against each other.</source>
          <target state="translated">서로 다른 배열을 브로드 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="98d4c99349e07c3606d8247f67b6a69bf991b037" translate="yes" xml:space="preserve">
          <source>Broadcast the input parameters against one another, and return an object that encapsulates the result. Amongst others, it has &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;nd&lt;/code&gt; properties, and may be used as an iterator.</source>
          <target state="translated">입력 매개 변수를 서로 브로드 캐스트하고 결과를 캡슐화하는 오브젝트를 리턴하십시오. 여러 가지 중에서도, 그것을 갖는 &lt;code&gt;shape&lt;/code&gt; 및 &lt;code&gt;nd&lt;/code&gt; 특성 및 반복자로서 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="a82937f02ff3220ad370539cf8e7b1333cdbe7e9" translate="yes" xml:space="preserve">
          <source>Broadcast the input shapes into a single shape.</source>
          <target state="translated">입력 셰이프를 단일 셰이프로 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="6bb1c7bbc547d77034be314540af70ac8dab269b" translate="yes" xml:space="preserve">
          <source>Broadcasted shape.</source>
          <target state="translated">방송 된 모양.</target>
        </trans-unit>
        <trans-unit id="ba459229366746c447e3cdf752eb917433152cfe" translate="yes" xml:space="preserve">
          <source>Broadcasting</source>
          <target state="translated">Broadcasting</target>
        </trans-unit>
        <trans-unit id="2d4bd5e0675f1aedc285134fe7e6bea24d68a36e" translate="yes" xml:space="preserve">
          <source>Broadcasting (multi-iterators)</source>
          <target state="translated">방송 (다중 반복자)</target>
        </trans-unit>
        <trans-unit id="5e308728b0383411510cb3c77af8cc43a178e5fc" translate="yes" xml:space="preserve">
          <source>Broadcasting Array Iteration</source>
          <target state="translated">방송 배열 반복</target>
        </trans-unit>
        <trans-unit id="ffca602e6975476928a035e0bd899a364b765bab" translate="yes" xml:space="preserve">
          <source>Broadcasting allows universal functions to deal in a meaningful way with inputs that do not have exactly the same shape.</source>
          <target state="translated">브로드 캐스팅을 사용하면 범용 함수가 정확히 동일한 모양을 갖지 않는 입력을 의미있는 방식으로 처리 할 수 ​​있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="3f1a8f806c9ec4c20408d10522361491e36b1938" translate="yes" xml:space="preserve">
          <source>Broadcasting and scalar multiplication:</source>
          <target state="translated">방송 및 스칼라 곱셈 :</target>
        </trans-unit>
        <trans-unit id="9c4c6b372f00f9bbc9735f2491e20986adab213c" translate="yes" xml:space="preserve">
          <source>Broadcasting comes up quite often in real world problems. A typical example occurs in the vector quantization (VQ) algorithm used in information theory, classification, and other related areas. The basic operation in VQ [#f0] finds the closest point in a set of points, called codes in VQ jargon, to a given point, called the observation. In the very simple, two-dimensional case shown in &lt;a href=&quot;#figure-5&quot;&gt;Figure 5&lt;/a&gt;, the values in observation describe the weight and height of an athlete to be classified. The codes represent different classes of athletes. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; Finding the closest point requires calculating the distance between observation and each of the codes. The shortest distance provides the best match. In this example, &lt;code&gt;codes[0]&lt;/code&gt; is the closest class indicating that the athlete is likely a basketball player.</source>
          <target state="translated">방송은 현실 세계의 문제에서 자주 등장합니다. 일반적인 예는 정보 이론, 분류 및 기타 관련 영역에서 사용되는 벡터 양자화 (VQ) 알고리즘에서 발생합니다. VQ [# f0]의 기본 연산은 VQ 전문 용어로 코드라고하는 점 집합에서 관찰이라고하는 주어진 점에 가장 가까운 점을 찾습니다. &lt;a href=&quot;#figure-5&quot;&gt;그림 5에&lt;/a&gt; 표시된 매우 간단한 2 차원 사례 에서 관찰 값은 분류 할 선수의 체중과 키를 설명합니다. 코드는 다양한 종류의 운동 선수를 나타냅니다. &lt;a href=&quot;#f1&quot; id=&quot;id2&quot;&gt;2&lt;/a&gt; 가장 가까운 지점을 찾으려면 관찰과 각 코드 사이의 거리를 계산해야합니다. 최단 거리가 최상의 일치를 제공합니다. 이 예에서 &lt;code&gt;codes[0]&lt;/code&gt; 선수가 농구 선수 일 가능성이 있음을 나타내는 가장 가까운 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3086582d38372be76fcd6867986780678b3bdbd6" translate="yes" xml:space="preserve">
          <source>Broadcasting is conventional for stacks of arrays</source>
          <target state="translated">방송은 어레이 스택에 일반적입니다</target>
        </trans-unit>
        <trans-unit id="60a524b775e11155b5c4df4747f272a28d6e6176" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt;&lt;code&gt;numpy.doc.broadcasting&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스팅은 작업의 암시 적 요소 별 동작을 설명하는 데 사용되는 용어입니다. 일반적으로 NumPy에서는 산술 연산뿐 아니라 논리, 비트 단위, 기능 등의 모든 연산이 이러한 암시 적 요소 별 방식으로 동작합니다. 즉, 브로드 캐스트합니다. 또한 위의 예에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 동일한 모양의 다차원 배열이거나 스칼라와 배열이거나 다른 모양의 두 배열 일 수 있습니다. 단, 작은 배열이 큰 배열로 &quot;확장 가능&quot;하다면 결과 방송이 모호하지 않은 방식으로. 방송의 자세한 &quot;규칙&quot;은 &lt;a href=&quot;basics.broadcasting#module-numpy.doc.broadcasting&quot;&gt; &lt;code&gt;numpy.doc.broadcasting&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4f8bfce10b38e0298dd7b485ac126daa93a79456" translate="yes" xml:space="preserve">
          <source>Broadcasting is the term used to describe the implicit element-by-element behavior of operations; generally speaking, in NumPy all operations, not just arithmetic operations, but logical, bit-wise, functional, etc., behave in this implicit element-by-element fashion, i.e., they broadcast. Moreover, in the example above, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; could be multidimensional arrays of the same shape, or a scalar and an array, or even two arrays of with different shapes, provided that the smaller array is &amp;ldquo;expandable&amp;rdquo; to the shape of the larger in such a way that the resulting broadcast is unambiguous. For detailed &amp;ldquo;rules&amp;rdquo; of broadcasting see &lt;code&gt;basics.broadcasting&lt;/code&gt;.</source>
          <target state="translated">브로드 캐스팅은 작업의 암시 적 요소 별 동작을 설명하는 데 사용되는 용어입니다. 일반적으로 NumPy에서는 산술 연산뿐 아니라 논리, 비트 단위, 기능 등의 모든 연산이 이러한 암시 적 요소 별 방식으로 동작합니다. 즉, 브로드 캐스트합니다. 또한 위의 예에서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 동일한 모양의 다차원 배열이거나 스칼라와 배열이거나 다른 모양의 두 배열 일 수 있습니다. 단, 작은 배열이 큰 배열로 &quot;확장 가능&quot;하다면 결과 방송이 모호하지 않은 방식으로. 방송의 자세한 &quot;규칙&quot;은 &lt;code&gt;basics.broadcasting&lt;/code&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8a22fa6f76158c02a615ce1e41377e5e327d96b" translate="yes" xml:space="preserve">
          <source>Broadcasting is used throughout NumPy to decide how to handle disparately shaped arrays; for example, all arithmetic operations (&lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &amp;hellip;) between &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; broadcast the arrays before operation.</source>
          <target state="translated">방송은 NumPy 전체에서 사용되어 서로 다른 모양의 어레이를 처리하는 방법을 결정합니다. 예를 들어, &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 사이의 모든 산술 연산 ( &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; ,&amp;hellip;)은 연산 전에 배열을 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="c2ccb1ef65055f853bfad815cb4304fa00148706" translate="yes" xml:space="preserve">
          <source>Broadcasting over multiple arrays</source>
          <target state="translated">여러 어레이를 통해 브로드 캐스팅</target>
        </trans-unit>
        <trans-unit id="8643e22fd07e0fa1b2c6f3538e1689c01bced1a3" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays that produces the same result as &lt;a href=&quot;#example-3&quot;&gt;Example 3&lt;/a&gt;</source>
          <target state="translated">브로드 캐스팅은 두 어레이의 외부 제품 (또는 기타 외부 작업)을 가져 오는 편리한 방법을 제공합니다. 다음 예제는 &lt;a href=&quot;#example-3&quot;&gt;예제 3&lt;/a&gt; 과 동일한 결과를 생성하는 두 개의 1-d 배열의 외부 더하기 연산을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f086db6f9cde283cd15667e2a34db081fa8323d1" translate="yes" xml:space="preserve">
          <source>Broadcasting provides a convenient way of taking the outer product (or any other outer operation) of two arrays. The following example shows an outer addition operation of two 1-d arrays:</source>
          <target state="translated">브로드 캐스팅은 두 어레이의 외부 제품 (또는 기타 외부 작업)을 가져 오는 편리한 방법을 제공합니다. 다음 예제는 2 개의 1-d 배열의 외부 더하기 연산을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="916a860416eab96b40dda7fe2424a559b1d3ae5f" translate="yes" xml:space="preserve">
          <source>Broadcasting rules</source>
          <target state="translated">방송 규칙</target>
        </trans-unit>
        <trans-unit id="d8a2b5b45365993f46ca0dedffba4cb7be1f878c" translate="yes" xml:space="preserve">
          <source>Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">브로드 캐스트 규칙이 적용됩니다. 자세한 내용은 &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d885a1b2d5577844b42f9c37b9817de5d134c079" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">브로드 캐스트는 항상 확장 차원에 대해 0 값의 보폭을 사용하여 숫자로 구현되었습니다. NumPy에서와 동일한 방식으로 수행됩니다. 가장 큰 차이점은 이제 보폭 배열이 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 되고 브로드 캐스트 결과와 관련된 반복자가 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 된다는 것입니다 . &lt;code&gt;PyArray_BroadCast&lt;/code&gt; 호출은 브로드 캐스트 규칙을 구현한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="34f655aae3670aa20a7e4bb7846e02a31bb3ce80" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; call implements the broad-casting rules.</source>
          <target state="translated">브로드 캐스팅은 항상 확장 차원에 대해 0 값 보폭을 사용하여 숫자로 구현되었습니다. NumPy에서도 똑같은 방식으로 수행됩니다. 큰 차이점은 이제 스트라이드 배열이 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 되고 브로드 캐스트 결과에 포함 된 반복자는 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 되며 &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; 호출이 브로드 캐스팅 규칙을 구현한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2a0a6879b6872d1f7b106e1d3c8e15aa2bd9c9f9" translate="yes" xml:space="preserve">
          <source>Broadcasting was always implemented in Numeric using 0-valued strides for the extended dimensions. It is done in exactly the same way in NumPy. The big difference is that now the array of strides is kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject&lt;/code&gt;&lt;/a&gt;, the iterators involved in a broadcast result are kept track of in a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt;, and the &lt;code&gt;PyArray_BroadCast&lt;/code&gt; call implements the broad-casting rules.</source>
          <target state="translated">브로드 캐스팅은 항상 확장 차원에 대해 0 값 보폭을 사용하여 숫자로 구현되었습니다. NumPy에서도 똑같은 방식으로 수행됩니다. 큰 차이점은 이제 보폭 배열이 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 되고 브로드 캐스트 결과에 포함 된 반복자는 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 에서 추적 되며 &lt;code&gt;PyArray_BroadCast&lt;/code&gt; 호출이 브로드 캐스팅 규칙을 구현한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="6cc8d02b192349a4f1b4b7f860e5e3a1c421ecb8" translate="yes" xml:space="preserve">
          <source>Broadcasting, element-wise and scalar multiplication, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">방송, 요소 별 및 스칼라 곱셈, &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="90812c9e094ac5522eea3d57aa754d6964a1cdf2" translate="yes" xml:space="preserve">
          <source>Buffer (&lt;code&gt;buf&lt;/code&gt;) is interpreted according to these strides (strides define how many bytes each array element, row, column, etc. occupy in memory).</source>
          <target state="translated">버퍼 ( &lt;code&gt;buf&lt;/code&gt; )는 이러한 보폭에 따라 해석됩니다 (스트라이드는 각 배열 요소, 행, 열 등이 메모리에서 차지하는 바이트 수를 정의합니다).</target>
        </trans-unit>
        <trans-unit id="3a3c6f456f2df72c3dcf8bdef2f2f225bc537cc1" translate="yes" xml:space="preserve">
          <source>Buffer of binary data</source>
          <target state="translated">이진 데이터의 버퍼</target>
        </trans-unit>
        <trans-unit id="27cb2ff0185bcfdbaec6ac70d0f611c9c03b02a8" translate="yes" xml:space="preserve">
          <source>Buffered Loop</source>
          <target state="translated">버퍼링 된 루프</target>
        </trans-unit>
        <trans-unit id="3aa9875f6199e297bab60e3e7102191f0ce73af1" translate="yes" xml:space="preserve">
          <source>Buffered iterator for big arrays.</source>
          <target state="translated">큰 배열을위한 버퍼링 된 반복자.</target>
        </trans-unit>
        <trans-unit id="6d37057306b02ade5a2d41571a0c0e632337fc5c" translate="yes" xml:space="preserve">
          <source>Buffering mode mitigates the memory usage issue and is more cache-friendly than making temporary copies. Except for special cases, where the whole array is needed at once outside the iterator, buffering is recommended over temporary copying. Within NumPy, buffering is used by the ufuncs and other functions to support flexible inputs with minimal memory overhead.</source>
          <target state="translated">버퍼링 모드는 메모리 사용 문제를 완화하고 임시 사본을 만드는 것보다 캐시 친화적입니다. 반복자 외부에서 한 번에 전체 배열이 필요한 특별한 경우를 제외하고 임시 복사보다 버퍼링이 권장됩니다. NumPy 내에서 버퍼링은 ufunc 및 기타 기능에서 메모리 오버 헤드를 최소화하면서 유연한 입력을 지원하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="aff21481cc1c0abc2cbd1fe3d4ce255d0403752e" translate="yes" xml:space="preserve">
          <source>Buffering the Array Elements</source>
          <target state="translated">배열 요소 버퍼링</target>
        </trans-unit>
        <trans-unit id="e0ea19fac7306381f9369bebfc56bf181ad2f644" translate="yes" xml:space="preserve">
          <source>Bugs Fixed</source>
          <target state="translated">수정 된 버그</target>
        </trans-unit>
        <trans-unit id="ac95995878b77d2a8ce4a1c4b232969f85fc5862" translate="yes" xml:space="preserve">
          <source>Build System Changes</source>
          <target state="translated">시스템 변경 사항 구축</target>
        </trans-unit>
        <trans-unit id="041e1aac6c7d1e7294bc5d8fa3967aabcde7a325" translate="yes" xml:space="preserve">
          <source>Build a matrix object from a string, nested sequence, or array.</source>
          <target state="translated">문자열, 중첩 시퀀스 또는 배열에서 행렬 객체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="62d0591005ae8571425b97ff29068016515cd29b" translate="yes" xml:space="preserve">
          <source>Build and archive documentation</source>
          <target state="translated">문서 작성 및 보관</target>
        </trans-unit>
        <trans-unit id="7fcd3a3a0bc7c1a4ce328d262f632a0650b70528" translate="yes" xml:space="preserve">
          <source>Build extension module from a Fortran 77 source string with f2py.</source>
          <target state="translated">f2py를 사용하여 Fortran 77 소스 문자열에서 확장 모듈을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="1d349060ba731253879161224c46e4521b75c084" translate="yes" xml:space="preserve">
          <source>Build options can be discovered by running any of:</source>
          <target state="translated">빌드 옵션은 다음 중 하나를 실행하여 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="368f9cf215b81c7db781f6218da65973b2216ee7" translate="yes" xml:space="preserve">
          <source>Build options for compilation</source>
          <target state="translated">컴파일을위한 빌드 옵션</target>
        </trans-unit>
        <trans-unit id="7b1b626e82829b0dfeb4bfac3a16b7d5bcd6a8fc" translate="yes" xml:space="preserve">
          <source>Build source releases</source>
          <target state="translated">소스 릴리스 빌드</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">시스템 구축</target>
        </trans-unit>
        <trans-unit id="ea4c8827fa3eb397f1363449f23094e9e120bb77" translate="yes" xml:space="preserve">
          <source>Build the changelog and notes for upload with:</source>
          <target state="translated">다음을 사용하여 업로드 할 변경 로그 및 메모를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="133bc31192cbeea22da4122bb90ba0a93a894d67" translate="yes" xml:space="preserve">
          <source>Build wheels</source>
          <target state="translated">바퀴 만들기</target>
        </trans-unit>
        <trans-unit id="d0fa723cff6db05fe0f943d3ba65530fea4a58d8" translate="yes" xml:space="preserve">
          <source>Building Installable C libraries</source>
          <target state="translated">설치 가능한 C 라이브러리 빌드</target>
        </trans-unit>
        <trans-unit id="fc68ddc861d1de39d367519f523580fe22e0de8b" translate="yes" xml:space="preserve">
          <source>Building NumPy requires the following software installed:</source>
          <target state="translated">NumPy를 빌드하려면 다음 소프트웨어가 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f7247d0ef96399c8a6f6f94bdfcbbd262feaf108" translate="yes" xml:space="preserve">
          <source>Building NumPy with a Python built with debug support (on Linux distributions typically packaged as &lt;code&gt;python-dbg&lt;/code&gt;) is highly recommended.</source>
          <target state="translated">디버그 지원으로 빌드 된 Python으로 NumPy를 빌드 하는 것이 좋습니다 ( 일반적으로 &lt;code&gt;python-dbg&lt;/code&gt; 로 패키지 된 Linux 배포판에서 ).</target>
        </trans-unit>
        <trans-unit id="e3ab4efd8b4a10d38ed8959a1cb29fc9881db378" translate="yes" xml:space="preserve">
          <source>Building against OpenBLAS</source>
          <target state="translated">OpenBLAS에 대한 빌드</target>
        </trans-unit>
        <trans-unit id="f1cd4f14fd9faeca78fccf35fd005e67e4d55852" translate="yes" xml:space="preserve">
          <source>Building and Extending the Documentation</source>
          <target state="translated">문서 작성 및 확장</target>
        </trans-unit>
        <trans-unit id="e724a6fd06203378a19b755ba05b8cd55da0f623" translate="yes" xml:space="preserve">
          <source>Building and extending the documentation</source>
          <target state="translated">문서 작성 및 확장</target>
        </trans-unit>
        <trans-unit id="ea6e2e9b251f8b11fe3d952437e66c0d7503db76" translate="yes" xml:space="preserve">
          <source>Building docs</source>
          <target state="translated">문서 작성</target>
        </trans-unit>
        <trans-unit id="8cd56ee99256f6026c82a35e18d75551094d8936" translate="yes" xml:space="preserve">
          <source>Building from source</source>
          <target state="translated">소스에서 빌드</target>
        </trans-unit>
        <trans-unit id="797c000e127fd646fe95625f81ea1c57543896ff" translate="yes" xml:space="preserve">
          <source>Building in-place</source>
          <target state="translated">내부 구축</target>
        </trans-unit>
        <trans-unit id="e1f8c7d7fa78c6eb31ad5ca785a393676894e731" translate="yes" xml:space="preserve">
          <source>Building matrices</source>
          <target state="translated">행렬 만들기</target>
        </trans-unit>
        <trans-unit id="d1d8b51984115777766e2f069b697c4bb754479c" translate="yes" xml:space="preserve">
          <source>Building source archives and wheels</source>
          <target state="translated">소스 아카이브 및 휠 빌드</target>
        </trans-unit>
        <trans-unit id="1cc054390cfe90161261914ab7d65d3cfee4150a" translate="yes" xml:space="preserve">
          <source>Building the NumPy API and reference docs</source>
          <target state="translated">NumPy API 및 참조 문서 빌드</target>
        </trans-unit>
        <trans-unit id="2b0584a2ddbe43766e4479e6f854126bbc0cb8a1" translate="yes" xml:space="preserve">
          <source>Building the documents requires a number of latex &lt;code&gt;.sty&lt;/code&gt; files. Install them all to avoid aggravation.</source>
          <target state="translated">문서를 작성하려면 많은 라텍스 &lt;code&gt;.sty&lt;/code&gt; 파일이 필요 합니다. 악화를 피하기 위해 모두 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="2afe730004d87377bea3908e9c6c7255bf4ce79e" translate="yes" xml:space="preserve">
          <source>Building the extension module can be now carried out in one command:</source>
          <target state="translated">확장 모듈 빌드는 이제 하나의 명령으로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fe2db8e7c7c6c32ba1fc4b4a6634f60ac081da44" translate="yes" xml:space="preserve">
          <source>Builds a set of strides which are the same as the strides of an output array created using the &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt; flag, where NULL was passed for op_axes. This is for data packed contiguously, but not necessarily in C or Fortran order. This should be used together with &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt;&lt;code&gt;NpyIter_GetShape&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt;&lt;code&gt;NpyIter_GetNDim&lt;/code&gt;&lt;/a&gt; with the flag &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt; passed into the constructor.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 작성된 출력 배열의 보폭과 동일한 보폭 세트를 빌드합니다. 여기서 op_axes 에 NULL이 전달되었습니다. 이것은 연속적으로 압축 된 데이터를위한 것이지만 반드시 C 또는 Fortran 순서로되어있는 것은 아닙니다. 생성자에 전달 된 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 플래그를 사용하여 &lt;a href=&quot;#c.NpyIter_GetShape&quot;&gt; &lt;code&gt;NpyIter_GetShape&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NpyIter_GetNDim&quot;&gt; &lt;code&gt;NpyIter_GetNDim&lt;/code&gt; &lt;/a&gt; 과 함께 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8b40e55c8fd12c110479c1a8e453add933b9c6e8" translate="yes" xml:space="preserve">
          <source>Built-in Python types</source>
          <target state="translated">내장 파이썬 타입</target>
        </trans-unit>
        <trans-unit id="b858e075ef402953578da270159a51f6ad1575b6" translate="yes" xml:space="preserve">
          <source>Built-in scalar types</source>
          <target state="translated">내장 스칼라 유형</target>
        </trans-unit>
        <trans-unit id="4a2892e18069d1f5869c7225c38ebadc7aa96d21" translate="yes" xml:space="preserve">
          <source>Bundled version of LAPACK is now 3.2.2</source>
          <target state="translated">LAPACK의 번들 버전은 이제 3.2.2입니다.</target>
        </trans-unit>
        <trans-unit id="f0300972b4a8f0b0074aec4f6903cf3e57d597c8" translate="yes" xml:space="preserve">
          <source>Business Day Functionality</source>
          <target state="translated">영업일 기능</target>
        </trans-unit>
        <trans-unit id="3cbeeffaaa46e0b3d6b0ea56538a20f899791f42" translate="yes" xml:space="preserve">
          <source>Business Day Functions</source>
          <target state="translated">영업일 기능</target>
        </trans-unit>
        <trans-unit id="a4da80602eb90228591a52fa43450b5af3478d27" translate="yes" xml:space="preserve">
          <source>But different types can be used for substitution. In fact, this is how conversion of Polynomial classes among themselves is done for type, domain, and window casting:</source>
          <target state="translated">그러나 다른 유형을 대체에 사용할 수 있습니다. 실제로 이것은 유형, 도메인 및 창 캐스팅에 대해 다항식 클래스의 변환이 수행되는 방식입니다.</target>
        </trans-unit>
        <trans-unit id="bd8c2ef60d42745d2cdc473c152c1f9687c4dcc2" translate="yes" xml:space="preserve">
          <source>But if &lt;code&gt;rowsum&lt;/code&gt; would have two dimensions as well:</source>
          <target state="translated">그러나 &lt;code&gt;rowsum&lt;/code&gt; 이 두 차원을 가지면 :</target>
        </trans-unit>
        <trans-unit id="a50860d81b9d10875263242c5534750b4457432a" translate="yes" xml:space="preserve">
          <source>But if the arrays have different dtype metadata, the metadata may be dropped:</source>
          <target state="translated">그러나 배열에 다른 dtype 메타 데이터가있는 경우 메타 데이터가 삭제 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2cce3613bf130a21ef8719b403ca292f0f091a49" translate="yes" xml:space="preserve">
          <source>But in certain useful cases, NumPy can duplicate data along &amp;ldquo;missing&amp;rdquo; axes or &amp;ldquo;too-short&amp;rdquo; dimensions so shapes will match. The duplication costs no memory or time. For details, see &lt;a href=&quot;user/basics.broadcasting&quot;&gt;Broadcasting.&lt;/a&gt;</source>
          <target state="translated">그러나 특정 유용한 경우에 NumPy는 &quot;누락 된&quot;축 또는 &quot;너무 짧은&quot;차원을 따라 데이터를 복제하여 모양이 일치 할 수 있습니다. 복제에는 메모리 나 시간이 들지 않습니다. 자세한 내용은 &lt;a href=&quot;user/basics.broadcasting&quot;&gt;방송을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b4df18df25d280603f202e60c13a7a8f66254798" translate="yes" xml:space="preserve">
          <source>But is also allowed to produce, for some &lt;code&gt;a, b, c, d&lt;/code&gt;:</source>
          <target state="translated">그러나 &lt;code&gt;a, b, c, d&lt;/code&gt; 를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95f2ff26f5da95b9bea4d70486f2a022cde496b8" translate="yes" xml:space="preserve">
          <source>But it automatically handles negative inputs:</source>
          <target state="translated">그러나 음수 입력을 자동으로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="6646b6ecbc06bc26898d3bc8dfd20372b9b785ad" translate="yes" xml:space="preserve">
          <source>But that&amp;rsquo;s not the only way to look at it. Suppose one has large two-dimensional arrays (images or matrices) stored in data files. Suppose the data are stored by rows rather than by columns. If we are to preserve our index convention (whether matrix or image) that means that depending on the language we use, we may be forced to reorder the data if it is read into memory to preserve our indexing convention. For example if we read row-ordered data into memory without reordering, it will match the matrix indexing convention for C, but not for Fortran. Conversely, it will match the image indexing convention for Fortran, but not for C. For C, if one is using data stored in row order, and one wants to preserve the image index convention, the data must be reordered when reading into memory.</source>
          <target state="translated">그러나 그것이 그것을 보는 유일한 방법은 아닙니다. 데이터 파일에 큰 2 차원 배열 (이미지 또는 행렬)이 저장되어 있다고 가정합니다. 데이터가 열이 아닌 행으로 저장되었다고 가정하십시오. 우리가 사용하는 언어에 따라 인덱스 규칙 (매트릭스 또는 이미지)을 유지해야하는 경우, 인덱스 규칙을 유지하기 위해 데이터를 메모리로 읽는 경우 데이터를 다시 정렬해야 할 수도 있습니다. 예를 들어, 재정렬하지 않고 행 순서 데이터를 메모리로 읽는 경우, C의 행렬 색인 규칙과 일치하지만 Fortran의 경우는 아닙니다. 반대로, Fortran의 이미지 인덱싱 규칙과 일치하지만 C의 경우에는 일치하지 않습니다. C의 경우 행 순서로 저장된 데이터를 사용하고 있고 이미지 인덱스 규칙을 유지하려면 메모리를 읽을 때 데이터를 다시 정렬해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e0bd4df436692919faeb191ed09cf810cb22035" translate="yes" xml:space="preserve">
          <source>But there are cross-platform considerations, such as library file extensions, plus the fact Windows will just load the first library it finds with that name. NumPy supplies the load_library function as a convenience.</source>
          <target state="translated">그러나 라이브러리 파일 확장자와 같은 크로스 플랫폼 고려 사항이 있으며 Windows가 해당 이름으로 찾은 첫 번째 라이브러리를로드한다는 사실도 있습니다. NumPy는 편의상 load_library 함수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ec781290ccbee49bdd7da500afd06d4ca2f948bf" translate="yes" xml:space="preserve">
          <source>But this omits some subtleties. Here is a fully general summary:</source>
          <target state="translated">그러나 이것은 약간의 미묘함을 생략합니다. 다음은 일반적인 요약입니다.</target>
        </trans-unit>
        <trans-unit id="9d33835f4b0ffd7a417785ade1f5f4a66909b7f6" translate="yes" xml:space="preserve">
          <source>But we can also specify the axis over which to multiply:</source>
          <target state="translated">그러나 곱할 축을 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f79d5f66a9deb8e0798847bf7ab428de8db1e5a" translate="yes" xml:space="preserve">
          <source>But when you use &lt;code&gt;ravel&lt;/code&gt;, the changes you make to the new array will affect the parent array.</source>
          <target state="translated">그러나 &lt;code&gt;ravel&lt;/code&gt; 을 사용 하면 새 배열에 대한 변경 사항이 부모 배열에 영향을 미칩니다.</target>
        </trans-unit>
        <trans-unit id="7460c60c1fec76b65a3c31a575c95674fb86e283" translate="yes" xml:space="preserve">
          <source>But, we could do anything we wanted:</source>
          <target state="translated">하지만 우리가 원하는 것은 무엇이든 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e13f0fd9c0e50a5064cf51cb50663812feb86a8e" translate="yes" xml:space="preserve">
          <source>Buzas, Martin A.; Culver, Stephen J., Understanding regional species diversity through the log series distribution of occurrences: BIODIVERSITY RESEARCH Diversity &amp;amp; Distributions, Volume 5, Number 5, September 1999 , pp. 187-195(9).</source>
          <target state="translated">Buzas, Martin A .; Culver, Stephen J., 로그 시리즈 발생 분포를 통한 지역 종 다양성 이해 : 생물 다양성 연구 다양성 및 분포, 5 권, 5 호, 1999 년 9 월, 187-195 (9).</target>
        </trans-unit>
        <trans-unit id="66360bf7fbf8657df2c1591ab899dd54476a182c" translate="yes" xml:space="preserve">
          <source>By choosing an offset of 8 bytes we can select the complex part of the array for our view:</source>
          <target state="translated">8 바이트의 오프셋을 선택하면 뷰에서 배열의 복잡한 부분을 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c96bbfd74d3086f0a931f577a61fdefbdd812bbe" translate="yes" xml:space="preserve">
          <source>By constructing a new ndarray of your desired shape and type using &lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or a simpler macro or function based on it.</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/array#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; 또는이를 기반으로하는 더 간단한 매크로 또는 함수를 사용하여 원하는 모양과 유형의 새 ndarray를 구성 합니다.</target>
        </trans-unit>
        <trans-unit id="6503cfb311994e99b18c321cb4370162b665063d" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e. money not available today). Thus, saving $100 a month at 5% annual interest leads to $15,692.93 available to spend in 10 years.</source>
          <target state="translated">일반적으로 마이너스 부호는 현금 유출을 나타냅니다 (즉, 현재 사용할 수없는 금액). 따라서 5 %의 연간 이자율로 한 달에 100 달러를 절약하면 10 년 동안 15,692.93 달러를 사용할 수있게됩니다.</target>
        </trans-unit>
        <trans-unit id="7f5fbe94c54051531f7d898251f9826df16e5720" translate="yes" xml:space="preserve">
          <source>By convention, the negative sign represents cash flow out (i.e., money not available today). Thus, to end up with $15,692.93 in 10 years saving $100 a month at 5% annual interest, one&amp;rsquo;s initial deposit should also be $100.</source>
          <target state="translated">일반적으로 마이너스 부호는 현금 유출을 나타냅니다 (즉, 현재 사용할 수없는 금액). 따라서 10 년 만에 15,692.93 달러로 매월 5 %의 연간 이자율로 100 달러를 절약하려면 초기 예금도 100 달러가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="e8f9209679e0d480aec7fb981fefcc0f2b86d6ab" translate="yes" xml:space="preserve">
          <source>By converting it from some Python object using &lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; or a macro built on it.</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/array#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 또는 그 위에 빌드 된 매크로를 사용하여 일부 Python 객체에서 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="2387467eae05dde35d2654a3dbfc0d30bc85b00f" translate="yes" xml:space="preserve">
          <source>By default (&lt;code&gt;align=False&lt;/code&gt;), numpy will pack the fields together such that each field starts at the byte offset the previous field ended, and the fields are contiguous in memory.</source>
          <target state="translated">기본적으로 ( &lt;code&gt;align=False&lt;/code&gt; ), numpy는 각 필드가 이전 필드가 끝난 바이트 오프셋에서 시작하고 필드가 메모리에서 연속되도록 필드를 함께 압축합니다.</target>
        </trans-unit>
        <trans-unit id="52bf606add02bda44e68afd9558117218dd1b2cb" translate="yes" xml:space="preserve">
          <source>By default &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt;&lt;code&gt;rundocs&lt;/code&gt;&lt;/a&gt; raises an AssertionError on failure.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;#numpy.testing.rundocs&quot;&gt; &lt;code&gt;rundocs&lt;/code&gt; &lt;/a&gt; 는 실패시 AssertionError를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="57786a266025c7ab2defbf0e660b34ff7cd9c745" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;../arrays.scalars#numpy.float16&quot;&gt;&lt;code&gt;float16&lt;/code&gt;&lt;/a&gt; results are computed using &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; intermediates for extra precision.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;../arrays.scalars#numpy.float16&quot;&gt; &lt;code&gt;float16&lt;/code&gt; &lt;/a&gt; 결과는 추가 정밀도를 위해 &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; &lt;/a&gt; 중간을 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="bd3d90ca79bba610cc2cceb26a3b68c32b444a0a" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt; returns a copy. To operate in-place with &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt;&lt;code&gt;Generator.permuted&lt;/code&gt;&lt;/a&gt;, pass the same array as the first argument &lt;em&gt;and&lt;/em&gt; as the value of the &lt;code&gt;out&lt;/code&gt; parameter. For example,</source>
          <target state="translated">기본적으로 &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; &lt;/a&gt; 는 복사본을 반환합니다. &lt;a href=&quot;generated/numpy.random.generator.permuted#numpy.random.Generator.permuted&quot;&gt; &lt;code&gt;Generator.permuted&lt;/code&gt; 를 사용&lt;/a&gt; 하여 제자리에서 작동하려면 동일한 배열을 첫 번째 인수 &lt;em&gt;와 &lt;/em&gt; &lt;code&gt;out&lt;/code&gt; 매개 변수 의 값으로 전달하십시오 . 예를 들면</target>
        </trans-unit>
        <trans-unit id="0791e549c9e1c0c68c18f4046427ddfd65fee6cf" translate="yes" xml:space="preserve">
          <source>By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy mt19937 random number generator in &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">기본적으로, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 에 의해 제공되는 비트 사용 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 에서 레거시 mt19937 난수 발생기보다 통계적 특성 갖는다 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2eb2435c3e98faf455297cd059d456431f056aed" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;float16&lt;/code&gt; results are computed using &lt;code&gt;float32&lt;/code&gt; intermediates for extra precision.</source>
          <target state="translated">기본적으로 &lt;code&gt;float16&lt;/code&gt; 결과는 정밀도 를 높이기 위해 &lt;code&gt;float32&lt;/code&gt; 중간체를 사용하여 계산됩니다 .</target>
        </trans-unit>
        <trans-unit id="f255d5e8f1a7ce5480c00642bd965d8cbd147605" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;skip_header=0&lt;/code&gt; and &lt;code&gt;skip_footer=0&lt;/code&gt;, meaning that no lines are skipped.</source>
          <target state="translated">기본적으로 &lt;code&gt;skip_header=0&lt;/code&gt; 및 &lt;code&gt;skip_footer=0&lt;/code&gt; 은 건너 뛰는 줄이 없음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="509cc82d7b395ceb5fa528a542a3fa0619544044" translate="yes" xml:space="preserve">
          <source>By default, a new array is created of the given shape and data-type. If &lt;code&gt;buf&lt;/code&gt; is specified and is an object exposing the buffer interface, the array will use the memory from the existing buffer. In this case, the &lt;code&gt;offset&lt;/code&gt; and &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt;&lt;code&gt;strides&lt;/code&gt;&lt;/a&gt; keywords are available.</source>
          <target state="translated">기본적으로 지정된 모양과 데이터 유형으로 새 배열이 작성됩니다. 경우 &lt;code&gt;buf&lt;/code&gt; 지정한 버퍼 인터페이스를 노출시키는 목적으로하고, 상기 어레이는 기존의 버퍼 메모리를 사용한다. 이 경우 &lt;code&gt;offset&lt;/code&gt; 및 &lt;a href=&quot;numpy.recarray.strides#numpy.recarray.strides&quot;&gt; &lt;code&gt;strides&lt;/code&gt; &lt;/a&gt; 키워드를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="823f8fa3f73a578c65a2065fa5f02e69dcee70ef" translate="yes" xml:space="preserve">
          <source>By default, all user-defined data-types are not presumed to be safely castable to any builtin data-types. In addition builtin data-types are not presumed to be safely castable to user-defined data-types. This situation limits the ability of user-defined data-types to participate in the coercion system used by ufuncs and other times when automatic coercion takes place in NumPy. This can be changed by registering data-types as safely castable from a particular data-type object. The function &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt;&lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt;&lt;/a&gt; (from_descr, totype_number, scalarkind) should be used to specify that the data-type object from_descr can be cast to the data-type with type number totype_number. If you are not trying to alter scalar coercion rules, then use &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt; for the scalarkind argument.</source>
          <target state="translated">기본적으로 모든 사용자 정의 데이터 유형은 내장 데이터 유형으로 안전하게 캐스트 가능한 것으로 간주되지 않습니다. 또한 내장 데이터 유형은 사용자 정의 데이터 유형으로 안전하게 캐스트 가능한 것으로 간주되지 않습니다. 이 상황은 ufuncs 및 NumPy에서 자동 강제가 발생하는 다른 시간에 사용되는 강제 시스템에 참여하는 사용자 정의 데이터 유형의 기능을 제한합니다. 특정 데이터 유형 객체에서 안전하게 캐스팅 할 수 있도록 데이터 유형을 등록하여 변경할 수 있습니다. &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterCanCast&quot;&gt; &lt;code&gt;PyArray_RegisterCanCast&lt;/code&gt; &lt;/a&gt; (from_descr, totype_number, scalarkind) 함수 를 사용하여 데이터 유형 객체 from_descr이 유형 번호 totype_number를 가진 데이터 유형으로 캐스트 될 수 있음을 지정해야합니다. 스칼라 강제 규칙을 변경하지 않으 려면 scalarkind 인수에 &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c3c9f5af6f6f20b9748f044265ea41cc53afdaad" translate="yes" xml:space="preserve">
          <source>By default, any empty string is marked as missing. We can also consider more complex strings, such as &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; or &lt;code&gt;&quot;???&quot;&lt;/code&gt; to represent missing or invalid data. The &lt;code&gt;missing_values&lt;/code&gt; argument accepts three kind of values:</source>
          <target state="translated">기본적으로 빈 문자열은 누락 된 것으로 표시됩니다. &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;???&quot;&lt;/code&gt; 와 같은 더 복잡한 문자열도 고려할 수 있습니다. 누락되거나 잘못된 데이터를 나타냅니다. &lt;code&gt;missing_values&lt;/code&gt; 의 인수는 값의 세 가지 종류를 받아 들인다 :</target>
        </trans-unit>
        <trans-unit id="5c0614e39713a118bc2e830f1f54b096ac814bb1" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이 값이 false로 설정되고 &lt;a href=&quot;numpy.char.chararray.dtype#numpy.char.chararray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 복사본 대신 입력 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="65020739d65de234914c6eca7148d91943920302" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이 값이 false로 설정되고 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 복사본 대신 입력 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="67bd53a8510577a68e06f12cd6753f65341b7ba7" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이것이 false로 설정되고 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 복사본 대신 입력 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="33a91516197cac2d79884383700e7cb303d84acc" translate="yes" xml:space="preserve">
          <source>By default, astype always returns a newly allocated array. If this is set to false, and the &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, and &lt;code&gt;subok&lt;/code&gt; requirements are satisfied, the input array is returned instead of a copy.</source>
          <target state="translated">기본적으로 astype은 항상 새로 할당 된 배열을 반환합니다. 이 값이 false로 설정되고 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 및 &lt;code&gt;subok&lt;/code&gt; 요구 사항이 충족되면 복사본 대신 입력 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="18abc4afb5a03b89f3bcee3c191658826915b7e7" translate="yes" xml:space="preserve">
          <source>By default, calculate the product of all elements:</source>
          <target state="translated">기본적으로 모든 요소의 곱을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="29592fecd779ff823d8494d78a32e4c6bef17a8b" translate="yes" xml:space="preserve">
          <source>By default, masked values are recognized as such. If &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; have the same shape, a common mask is allocated: if &lt;code&gt;x[i,j]&lt;/code&gt; is masked, then &lt;code&gt;y[i,j]&lt;/code&gt; will also be masked. Setting &lt;code&gt;allow_masked&lt;/code&gt; to False will raise an exception if values are missing in either of the input arrays.</source>
          <target state="translated">기본적으로 마스크 된 값은 그대로 인식됩니다. 경우 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 동일 형상을 가지고, 공통 마스크가 할당되어있는 경우 &lt;code&gt;x[i,j]&lt;/code&gt; 마스킹 한 후 &lt;code&gt;y[i,j]&lt;/code&gt; 또한 마스킹 될 것이다. &lt;code&gt;allow_masked&lt;/code&gt; 를 False로 설정 하면 입력 배열 중 하나에서 값이 누락 된 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="72d47f0b8465ed8e3b2a5736c0d1dfec28a91237" translate="yes" xml:space="preserve">
          <source>By default, mode is &amp;lsquo;full&amp;rsquo;. This returns the convolution at each point of overlap, with an output shape of (N+M-1,). At the end-points of the convolution, the signals do not overlap completely, and boundary effects may be seen.</source>
          <target state="translated">기본적으로 mode는 'full'입니다. 그러면 출력 모양이 (N + M-1) 인 각 오버랩 지점에서 컨벌루션이 반환됩니다. 컨벌루션의 끝점에서 신호가 완전히 겹치지 않고 경계 효과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="781e5458e78b28bbdf619e8539b2f911598af3c5" translate="yes" xml:space="preserve">
          <source>By default, returned multidimensional arrays are Fortran-contiguous. If &lt;code&gt;intent(c)&lt;/code&gt; is used, then returned multidimensional arrays are C-contiguous.</source>
          <target state="translated">기본적으로 반환 된 다차원 배열은 포트란에 인접 해 있습니다. 경우 &lt;code&gt;intent(c)&lt;/code&gt; 사용하고 다차원 배열은 C-인접 돌아왔다.</target>
        </trans-unit>
        <trans-unit id="6971450c7aa549483b5389a69fedb16eaf066171" translate="yes" xml:space="preserve">
          <source>By default, reverse the dimensions, otherwise permute the axes according to the values given.</source>
          <target state="translated">기본적으로 치수를 반대로하고, 그렇지 않으면 주어진 값에 따라 축을 치환합니다.</target>
        </trans-unit>
        <trans-unit id="f55a7b395485c3988f5bccbb6f9eaebb26dfc947" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; treats the input operand as a read-only object. To be able to modify the array elements, you must specify either read-write or write-only mode using the &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; or &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; per-operand flags.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 는 입력 피연산자를 읽기 전용 개체로 취급합니다. 배열 요소를 수정할 수 있으려면 &lt;code&gt;&amp;lsquo;readwrite&amp;rsquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;lsquo;writeonly&amp;rsquo;&lt;/code&gt; -operand 플래그를 사용하여 읽기 / 쓰기 또는 쓰기 전용 모드를 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="174daf14dced474235661dc4a8a7f2c4b87b4b7c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; uses the flags &amp;lsquo;allocate&amp;rsquo; and &amp;lsquo;writeonly&amp;rsquo; for operands that are passed in as None. This means we were able to provide just the two operands to the iterator, and it handled the rest.</source>
          <target state="translated">기본적으로 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 는 None으로 전달되는 피연산자에 'allocate'및 'writeonly'플래그를 사용합니다. 이것은 두 개의 피연산자를 반복자에게 제공 할 수 있었고 나머지는 처리했습니다.</target>
        </trans-unit>
        <trans-unit id="17e308c1f2a6481942287f2519e364f482dd5128" translate="yes" xml:space="preserve">
          <source>By default, the data-type is inferred from the input data.</source>
          <target state="translated">기본적으로 데이터 유형은 입력 데이터에서 유추됩니다.</target>
        </trans-unit>
        <trans-unit id="d105f45ad87599a046dab97b11d0171a9dd2c47e" translate="yes" xml:space="preserve">
          <source>By default, the index is into the flattened array, otherwise along the specified axis.</source>
          <target state="translated">기본적으로 인덱스는 평평한 배열에 있고 그렇지 않으면 지정된 축을 따라 배열됩니다.</target>
        </trans-unit>
        <trans-unit id="e68b2ebbdaa7d8bde52807398926b542381f9c7b" translate="yes" xml:space="preserve">
          <source>By default, the iterator produces pointers into the arrays provided, which may be aligned or unaligned, and with any byte order. If copying or buffering is not enabled and the operand data doesn&amp;rsquo;t satisfy the constraints, an error will be raised.</source>
          <target state="translated">기본적으로 반복자는 제공된 배열에 대한 포인터를 생성하며, 배열은 정렬되거나 정렬되지 않고 바이트 순서로 정렬 될 수 있습니다. 복사 또는 버퍼링이 사용 가능하지 않고 피연산자 데이터가 제한 조건을 만족하지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="ab25c157edc4354c1f57c1df2646a0b82ab1dad1" translate="yes" xml:space="preserve">
          <source>By default, these operations apply to the array as though it were a list of numbers, regardless of its shape. However, by specifying the &lt;code&gt;axis&lt;/code&gt; parameter you can apply an operation along the specified axis of an array:</source>
          <target state="translated">기본적으로 이러한 작업은 모양에 관계없이 숫자 목록 인 것처럼 배열에 적용됩니다. 그러나 &lt;code&gt;axis&lt;/code&gt; 매개 변수를 지정하면 배열의 지정된 축을 따라 작업을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8619d136820b4ea98c355d5e9bb29020512d7ef1" translate="yes" xml:space="preserve">
          <source>By default, when a line is decomposed into a series of strings, the individual entries are not stripped of leading nor trailing white spaces. This behavior can be overwritten by setting the optional argument &lt;code&gt;autostrip&lt;/code&gt; to a value of &lt;code&gt;True&lt;/code&gt;:</source>
          <target state="translated">기본적으로 행이 일련의 문자열로 분해 될 때 개별 항목은 선행 또는 후행 공백이 제거되지 않습니다. 이 동작은 선택적 인수 &lt;code&gt;autostrip&lt;/code&gt; 을 &lt;code&gt;True&lt;/code&gt; 값으로 설정하여 덮어 쓸 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a90e6d5076b3318d5438106f6aec8b51a30f2edc" translate="yes" xml:space="preserve">
          <source>By eliminating the inner loop in the description above, and using &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt;&lt;code&gt;s_&lt;/code&gt;&lt;/a&gt; to build simple slice objects, &lt;a href=&quot;#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt; can be expressed in terms of applying fancy indexing to each 1-d slice:</source>
          <target state="translated">상기 설명에서 내부 루프를 제거하고 사용함으로써 &lt;a href=&quot;numpy.s_#numpy.s_&quot;&gt; &lt;code&gt;s_&lt;/code&gt; &lt;/a&gt; 간단한 슬라이스 객체를 구축 &lt;a href=&quot;#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; 각 1 차원 슬라이스에 멋진 인덱싱을 적용하는 관점에서 를 표현할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f5e127dadff417279256627201011a26eddd8177" translate="yes" xml:space="preserve">
          <source>By enabling buffering mode, the chunks provided by the iterator to the inner loop can be made larger, significantly reducing the overhead of the Python interpreter. In the example forcing Fortran iteration order, the inner loop gets to see all the elements in one go when buffering is enabled.</source>
          <target state="translated">버퍼링 모드를 활성화하면 반복자가 내부 루프에 제공하는 청크를 크게 만들 수 있으므로 Python 인터프리터의 오버 헤드가 크게 줄어 듭니다. Fortran 반복 순서를 강제하는 예제에서 버퍼링이 활성화되면 내부 루프가 모든 요소를 ​​한 번에 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="842fa81b602f5ee9d6e48f92f8610cb23e1b4b1b" translate="yes" xml:space="preserve">
          <source>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</source>
          <target state="translated">계수를 살펴보면 선의 경사도가 대략 1이고 y 축을 -1로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="4b0026b5caaf6e12c9b18e1ac7ccb5e7684a2b52" translate="yes" xml:space="preserve">
          <source>By far the most complex case is advanced indexing, which may or may not be combined with typical view based indexing. Here integer indices are interpreted as view based. Before trying to understand this, you may want to make yourself familiar with its subtleties. The advanced indexing code has three different branches and one special case:</source>
          <target state="translated">지금까지 가장 복잡한 경우는 고급 인덱싱으로 일반적인 뷰 기반 인덱싱과 결합되거나 결합되지 않을 수 있습니다. 여기서 정수 인덱스는 뷰 기반으로 해석됩니다. 이것을 이해하기 전에 그 미묘함에 익숙해지기를 원할 수 있습니다. 고급 인덱싱 코드에는 세 가지 분기와 하나의 특별한 경우가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e675b296a66e810552905002296a09520d23ea5d" translate="yes" xml:space="preserve">
          <source>By organizing how-tos this way, you not only display the options for people who need to narrow their question, you also have provided answers for users who start with narrower questions (&amp;ldquo;I want to see historic buildings,&amp;rdquo; &amp;ldquo;Which way to city hall?&amp;rdquo;).</source>
          <target state="translated">이러한 방식으로 방법을 구성하면 질문의 범위를 좁혀 야하는 사람들을위한 옵션을 표시 할뿐만 아니라 더 좁은 질문으로 시작하는 사용자에게도 답변을 제공 할 수 있습니다 ( &quot;역사적인 건물을보고 싶습니다&quot;, &quot;도시로가는 방법&quot;). 홀?&quot;).</target>
        </trans-unit>
        <trans-unit id="46784614463c18819405731702cb3c998ad15a83" translate="yes" xml:space="preserve">
          <source>By placing intent directives and checking code, the interface can be cleaned up quite a bit until the Python module method is both easier to use and more robust.</source>
          <target state="translated">의도 지시문을 배치하고 코드를 확인하면 Python 모듈 메서드가 사용하기 쉽고 더 강력해질 때까지 인터페이스를 꽤 많이 정리할 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="eb83a5c83addee3a887cb831a30aba85bb504443" translate="yes" xml:space="preserve">
          <source>By substituting</source>
          <target state="translated">대체하여</target>
        </trans-unit>
        <trans-unit id="a10b2dfc802325db14226bfb0f644772b0ee8dc9" translate="yes" xml:space="preserve">
          <source>By testing them against the compiler, and seeing what the compiler can support according to the requested optimizations.</source>
          <target state="translated">컴파일러에 대해 테스트하고 요청 된 최적화에 따라 컴파일러가 지원할 수있는 사항을 확인합니다.</target>
        </trans-unit>
        <trans-unit id="5cf0a6a61d5c04a9d920300ad8c8de64a060c650" translate="yes" xml:space="preserve">
          <source>By the above description, the casting rules are essentially implemented by the question of when a data type can be cast &amp;ldquo;safely&amp;rdquo; to another data type. The answer to this question can be determined in Python with a function call: &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt;&lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt;&lt;/a&gt;. The Figure below shows the results of this call for the 24 internally supported types on the author&amp;rsquo;s 64-bit system. You can generate this table for your system with the code given in the Figure.</source>
          <target state="translated">상기 설명에 의해, 캐스팅 규칙은 본질적으로 데이터 타입이 다른 데이터 타입으로 &quot;안전하게&quot;캐스팅 될 수있는 시점에 의해 구현된다. 이 질문에 대한 답변은 파이썬에서 함수 호출을 사용하여 결정할 수 있습니다. &lt;a href=&quot;generated/numpy.can_cast#numpy.can_cast&quot;&gt; &lt;code&gt;can_cast(fromtype, totype)&lt;/code&gt; &lt;/a&gt; . 아래 그림은 작성자의 64 비트 시스템에서 24 개의 내부 지원 유형에 대한이 호출의 결과를 보여줍니다. 그림에 제공된 코드를 사용하여 시스템에 대해이 테이블을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cffcf4de4e9b85ff13913ac390d2131986b166e" translate="yes" xml:space="preserve">
          <source>Byte (-128 to 127)</source>
          <target state="translated">바이트 (-128 ~ 127)</target>
        </trans-unit>
        <trans-unit id="c3b1bb21176956a777afbce91b2dc46b27bfdbd1" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">데이터의 바이트 순서 ( &lt;a href=&quot;../glossary#term-little-endian&quot;&gt;little-endian&lt;/a&gt; 또는 &lt;a href=&quot;../glossary#term-big-endian&quot;&gt;big-endian&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="c3ee543ea3c911ca70be24ca50be4966bfc9d11e" translate="yes" xml:space="preserve">
          <source>Byte order of the data (&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt;)</source>
          <target state="translated">데이터의 바이트 순서 ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-little-endian&quot;&gt;little-endian&lt;/a&gt; 또는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-big-endian&quot;&gt;big-endian&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="33aea8e37e75e01b5515b25f2b9a264a2526b968" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order.</source>
          <target state="translated">강제 할 바이트 순서. 위의 바이트 순서 사양의 값. 기본값 ( 'S')은 현재 바이트 순서를 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="4fa7dfbdbb33fd63c061542164ead10c6ea66cdb" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications above. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. The code does a case-insensitive check on the first letter of &lt;code&gt;new_order&lt;/code&gt; for the alternatives above. For example, any of &amp;lsquo;B&amp;rsquo; or &amp;lsquo;b&amp;rsquo; or &amp;lsquo;biggish&amp;rsquo; are valid to specify big-endian.</source>
          <target state="translated">바이트 순서 강제; 위의 바이트 순서 스펙의 값 기본값 ( 'S')은 현재 바이트 순서를 교체합니다. 이 코드는 위의 대안에 대해 &lt;code&gt;new_order&lt;/code&gt; 의 첫 글자를 대소 문자를 구분하지 않고 검사합니다 . 예를 들어, 'B'또는 'b'또는 'biggish'는 big-endian을 지정하는 데 유효합니다.</target>
        </trans-unit>
        <trans-unit id="d891a9572e92fd87112849b433aa9d82773e6323" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">바이트 순서 강제; 아래의 바이트 순서 스펙의 값 &lt;code&gt;new_order&lt;/code&gt; 코드는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="925da9e3660113afb959c492e32c0df4c8fba9ab" translate="yes" xml:space="preserve">
          <source>Byte order to force; a value from the byte order specifications below. The default value (&amp;lsquo;S&amp;rsquo;) results in swapping the current byte order. &lt;code&gt;new_order&lt;/code&gt; codes can be any of:</source>
          <target state="translated">바이트 순서 강제; 아래의 바이트 순서 스펙의 값 기본값 ( 'S')은 현재 바이트 순서를 교체합니다. &lt;code&gt;new_order&lt;/code&gt; 코드는 다음 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="208a9d70c2ceb4cad845268b3793f06f24736861" translate="yes" xml:space="preserve">
          <source>Byte-order for all fields.</source>
          <target state="translated">모든 필드의 바이트 순서.</target>
        </trans-unit>
        <trans-unit id="3d30b75f6bbab6dd2f33ea184465104adfe034dc" translate="yes" xml:space="preserve">
          <source>Byte-swapping</source>
          <target state="translated">Byte-swapping</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="c380132bd13732c2a4492b58e8089f6c672f3148" translate="yes" xml:space="preserve">
          <source>C API</source>
          <target state="translated">C API</target>
        </trans-unit>
        <trans-unit id="90c2059501661b20579455b452bcdf7917e96a74" translate="yes" xml:space="preserve">
          <source>C API Deprecations</source>
          <target state="translated">C API 지원 중단</target>
        </trans-unit>
        <trans-unit id="5eefd673571a664f98901cbfc9269cc56d66bdd2" translate="yes" xml:space="preserve">
          <source>C API changes</source>
          <target state="translated">C API 변경</target>
        </trans-unit>
        <trans-unit id="991eaf0718be5436cf82b4e88422dbaeb580655b" translate="yes" xml:space="preserve">
          <source>C API for random</source>
          <target state="translated">임의의 C API</target>
        </trans-unit>
        <trans-unit id="a09f5c39498227c23bac03c4d85a857f0c660b68" translate="yes" xml:space="preserve">
          <source>C dialect</source>
          <target state="translated">C 방언</target>
        </trans-unit>
        <trans-unit id="baf0b9cf537d3452f0bedecd7885e6a6f5c95212" translate="yes" xml:space="preserve">
          <source>C expressions</source>
          <target state="translated">C 식</target>
        </trans-unit>
        <trans-unit id="5053549bf41c7c644de43b7357e8b95981f3b14c" translate="yes" xml:space="preserve">
          <source>C expressions are used in the following parts of signature files:</source>
          <target state="translated">C 표현식은 서명 파일의 다음 부분에서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="62988a5cc34cb2d480ad455963d13a5b50fea224" translate="yes" xml:space="preserve">
          <source>C order</source>
          <target state="translated">C 주문</target>
        </trans-unit>
        <trans-unit id="4d3779622c7ddb81083220abbfe17022ee213c7f" translate="yes" xml:space="preserve">
          <source>C order.</source>
          <target state="translated">C 주문.</target>
        </trans-unit>
        <trans-unit id="502ca6c945d9f8aee115c49e01f9edd12a50b0c8" translate="yes" xml:space="preserve">
          <source>C type</source>
          <target state="translated">C 유형</target>
        </trans-unit>
        <trans-unit id="1ef859ea3c4b4e94c8561ce88af6e45cd8c349e4" translate="yes" xml:space="preserve">
          <source>C++ support</source>
          <target state="translated">C ++ 지원</target>
        </trans-unit>
        <trans-unit id="e04e63e5d64190b9021eeae0aa43f4dd8f802b80" translate="yes" xml:space="preserve">
          <source>C-API</source>
          <target state="translated">C-API</target>
        </trans-unit>
        <trans-unit id="b42fb0a4e21a6c7c2ad779467660c5d634cd1f27" translate="yes" xml:space="preserve">
          <source>C-API Array Additions</source>
          <target state="translated">C-API 어레이 추가</target>
        </trans-unit>
        <trans-unit id="20e7136fe60c57d32b3ba713a50d60dd983c3865" translate="yes" xml:space="preserve">
          <source>C-API Developer Improvements</source>
          <target state="translated">C-API 개발자 개선</target>
        </trans-unit>
        <trans-unit id="847c15716f4f18fd587862ab143e5d2f9581c235" translate="yes" xml:space="preserve">
          <source>C-API Ufunc Additions</source>
          <target state="translated">C-API Ufunc 추가</target>
        </trans-unit>
        <trans-unit id="c77824df8f5b9b7ad0f95af7e88364d494112e7e" translate="yes" xml:space="preserve">
          <source>C-API for implementing Elementary Functions</source>
          <target state="translated">기본 기능 구현을위한 C-API</target>
        </trans-unit>
        <trans-unit id="6bc42241dfe0e66ad03fd900ab60e09366468123" translate="yes" xml:space="preserve">
          <source>C-Level string to datetime casts changed</source>
          <target state="translated">C 레벨 문자열에서 datetime 형 변환으로 변경됨</target>
        </trans-unit>
        <trans-unit id="39aa49db7f4958819165d85870c4e3056a314158" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (&lt;code&gt;numpy.ctypeslib&lt;/code&gt;)</source>
          <target state="translated">C 유형 외부 함수 인터페이스 ( &lt;code&gt;numpy.ctypeslib&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1ee13877e6105fd56e4080481ca6046e3bea7c13" translate="yes" xml:space="preserve">
          <source>C-Types Foreign Function Interface (numpy.ctypeslib)</source>
          <target state="translated">C 유형 외부 함수 인터페이스 (numpy.ctypeslib)</target>
        </trans-unit>
        <trans-unit id="72c1b618d901fa2527c184612af8e5f097445876" translate="yes" xml:space="preserve">
          <source>C-contiguous or simply contiguous arrays when data is stored row-wise, i.e. indexing of data as stored in memory starts from the highest dimension.</source>
          <target state="translated">데이터가 행 단위로 저장 될 때 C- 연속 또는 단순히 연속 배열, 즉 메모리에 저장된 데이터의 인덱싱은 가장 높은 차원에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="bdb65d7a9aa6da6471ba4a02f9d435dd19d2ae5a" translate="yes" xml:space="preserve">
          <source>C-order</source>
          <target state="translated">C-order</target>
        </trans-unit>
        <trans-unit id="8bbf8c25cb421fee0bffcb1218c14c15435923a5" translate="yes" xml:space="preserve">
          <source>C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.</source>
          <target state="translated">C 순서 배열은 FORTRAN 순서 인 경우에도 False로 평가됩니다.</target>
        </trans-unit>
        <trans-unit id="18f7fb2659bfefae5fe403809093ff794847eddb" translate="yes" xml:space="preserve">
          <source>C-series coefficients of the integral.</source>
          <target state="translated">적분의 C- 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="aa3b96b2dd6cb469f06816ec7d846596063a8314" translate="yes" xml:space="preserve">
          <source>C-side of the array interface</source>
          <target state="translated">어레이 인터페이스의 C면</target>
        </trans-unit>
        <trans-unit id="6e0b67185c9289cda6113607f367a9d9edf7fee3" translate="yes" xml:space="preserve">
          <source>C-struct access</source>
          <target state="translated">C-struct 액세스</target>
        </trans-unit>
        <trans-unit id="bd0b363c8100c3e0002d75837308df33fee89719" translate="yes" xml:space="preserve">
          <source>C-type names</source>
          <target state="translated">C 타입 이름</target>
        </trans-unit>
        <trans-unit id="af48e472b36161e129dd7edb2b2bd61998b64144" translate="yes" xml:space="preserve">
          <source>C. W. Clenshaw, &amp;ldquo;Chebyshev series for mathematical functions&amp;rdquo;, in &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt;, vol. 5, London: Her Majesty&amp;rsquo;s Stationery Office, 1962.</source>
          <target state="translated">CW Clenshaw, &quot;수학적 기능을위한 체비 쇼프 시리즈&quot;, &lt;em&gt;National Physical Laboratory Mathematical Tables&lt;/em&gt; , vol. 5, 런던 : 폐하의 문구 사무소, 1962</target>
        </trans-unit>
        <trans-unit id="43beb2dca45ea5b86cf6e2c78e1df08bb1062e1a" translate="yes" xml:space="preserve">
          <source>C99-like complex functions have been added. Those can be used if you wish to implement portable C extensions. Since we still support platforms without C99 complex type, you need to restrict to C90-compatible syntax, e.g.:</source>
          <target state="translated">C99와 같은 복잡한 기능이 추가되었습니다. 이식 가능한 C 확장을 구현하려는 경우 사용할 수 있습니다. C99 복합 유형이없는 플랫폼을 계속 지원하므로 다음과 같이 C90 호환 구문으로 제한해야합니다.</target>
        </trans-unit>
        <trans-unit id="cf46ba2402ead2c46d226454dffcd7ce5ff43524" translate="yes" xml:space="preserve">
          <source>CFFI</source>
          <target state="translated">CFFI</target>
        </trans-unit>
        <trans-unit id="51aa24adb10c8f416d462fb3a5357dabf3e3fd38" translate="yes" xml:space="preserve">
          <source>CFFI + Numba</source>
          <target state="translated">CFFI + Numba</target>
        </trans-unit>
        <trans-unit id="b9f44f432adf98c7d09c95f8b09f92c94663702d" translate="yes" xml:space="preserve">
          <source>CFFI can be used to directly access the functions in &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt;. Some &amp;ldquo;massaging&amp;rdquo; of the header file is required:</source>
          <target state="translated">CFFI를 사용하여 &lt;code&gt;include/numpy/random/distributions.h&lt;/code&gt; 의 함수에 직접 액세스 할 수 있습니다 . 헤더 파일의 일부 &quot;마 사이징&quot;이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="ebba6dc140f09bcbb9638f5bf4b3df884108c2f7" translate="yes" xml:space="preserve">
          <source>CFFI interface</source>
          <target state="translated">CFFI 인터페이스</target>
        </trans-unit>
        <trans-unit id="a36da1e151b2b0823e662d5b8eaaa38259edebce" translate="yes" xml:space="preserve">
          <source>CI extended with additional services</source>
          <target state="translated">추가 서비스로 확장 된 CI</target>
        </trans-unit>
        <trans-unit id="6821c968895aca188636e67b589fcc004a8bbd12" translate="yes" xml:space="preserve">
          <source>CPU arch detection</source>
          <target state="translated">CPU 아치 감지</target>
        </trans-unit>
        <trans-unit id="1ade62840c85639fb7384a1d18b950f273e9fb48" translate="yes" xml:space="preserve">
          <source>CPU architecture of the platform; only one of the above is defined.</source>
          <target state="translated">플랫폼의 CPU 아키텍처; 위 중 하나만 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="70b1c54ffd0a791d6e36e2ee0d98c9acf4b031e8" translate="yes" xml:space="preserve">
          <source>CPU features and other options are case-insensitive.</source>
          <target state="translated">CPU 기능 및 기타 옵션은 대소 문자를 구분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="19b3426c923b3e7b1cdee4b651f488f72bf3c78b" translate="yes" xml:space="preserve">
          <source>CXX</source>
          <target state="translated">CXX</target>
        </trans-unit>
        <trans-unit id="c9cddb0fc26555bd7e44c82c30b8dd03f9efdf7e" translate="yes" xml:space="preserve">
          <source>C_CONTIGUOUS / C / CONTIGUOUS</source>
          <target state="translated">C_CONTIGUOUS / C / 연속</target>
        </trans-unit>
        <trans-unit id="0ce3a73aca867f2538f5c735d732291c3a6e377f" translate="yes" xml:space="preserve">
          <source>Caches in &lt;code&gt;np.fft&lt;/code&gt; are now bounded in total size and item count</source>
          <target state="translated">&lt;code&gt;np.fft&lt;/code&gt; 의 캐시 는 이제 총 크기와 항목 수에 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="f3d5846dd99b124383ff0d457d07594b45e6712e" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**p&lt;/code&gt; for all &lt;code&gt;p&lt;/code&gt; in the input array.</source>
          <target state="translated">입력 배열의 모든 &lt;code&gt;p&lt;/code&gt; 에 대해 &lt;code&gt;2**p&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="250bbdf8f96508ded0e2419aede1c85ce8e60f69" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;2**x&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">배열의 모든 요소에 대해 &lt;code&gt;2**x&lt;/code&gt; 를 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="80c054468bb32b1733a38bd9e500e3c7e2410c60" translate="yes" xml:space="preserve">
          <source>Calculate &lt;code&gt;exp(x) - 1&lt;/code&gt; for all elements in the array.</source>
          <target state="translated">배열의 모든 요소에 대해 &lt;code&gt;exp(x) - 1&lt;/code&gt; 을 계산 하십시오.</target>
        </trans-unit>
        <trans-unit id="897a0bcc51e675340eb8de452d794c61bbe86ad4" translate="yes" xml:space="preserve">
          <source>Calculate the absolute value element-wise.</source>
          <target state="translated">요소 별 절대 값을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="52d855325ad8b8ba2e5f03ed06faa393dd2b3c5d" translate="yes" xml:space="preserve">
          <source>Calculate the exponential of all elements in the input array.</source>
          <target state="translated">입력 배열에있는 모든 원소의 지수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a3dc7bdd6edd5fbaf2d2ff0fab2c5a4b13186ce0" translate="yes" xml:space="preserve">
          <source>Calculate the generalized inverse of a matrix using its singular-value decomposition (SVD) and including all &lt;em&gt;large&lt;/em&gt; singular values.</source>
          <target state="translated">단일 값 분해 (SVD)를 사용하고 모든 &lt;em&gt;큰&lt;/em&gt; 특이 값을 포함하여 행렬의 일반화 된 역을 계산 합니다.</target>
        </trans-unit>
        <trans-unit id="4b25208e5ebec1248ee411c25859b5c2fd7bb09b" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along given axis.</source>
          <target state="translated">주어진 축을 따라 n 번째 이산 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="42cb44e98b4304fa793f5c2a54298181fdecfa02" translate="yes" xml:space="preserve">
          <source>Calculate the n-th discrete difference along the given axis.</source>
          <target state="translated">주어진 축을 따라 n 번째 이산 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="1c03f8fb0f5af1d1f5a42484860a4bc9ada64002" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of the non-NaN values.</source>
          <target state="translated">비 NaN 값의 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="f8c757cfbde7655c0c48030d0cc0f2a47e05c8b1" translate="yes" xml:space="preserve">
          <source>Calculate the standard deviation of these values.</source>
          <target state="translated">이 값의 표준 편차를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="7c1b58f3d94fc67cd514e1570aa6b12719e32b56" translate="yes" xml:space="preserve">
          <source>Calculate the t statistic, setting the ddof parameter to the unbiased value so the divisor in the standard deviation will be degrees of freedom, N-1.</source>
          <target state="translated">표준 편차의 제수가 자유도 N-1이되도록 ddof 매개 변수를 바이어스되지 않은 값으로 설정하여 t 통계량을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a8acd54a675004438176e793d314e80390eec770" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;1/x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1/x&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e5f90663e28e9982e7de271dda336040dea8f7aa" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only.</source>
          <target state="translated">을 계산의 &lt;code&gt;element in test_elements&lt;/code&gt; 를 통해 방송, &lt;code&gt;element&lt;/code&gt; 만.</target>
        </trans-unit>
        <trans-unit id="c2efd3cd9b667cce814af0fcbaac60b64cdcdb35" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;element in test_elements&lt;/code&gt;, broadcasting over &lt;code&gt;element&lt;/code&gt; only. Returns a boolean array of the same shape as &lt;code&gt;element&lt;/code&gt; that is True where an element of &lt;code&gt;element&lt;/code&gt; is in &lt;code&gt;test_elements&lt;/code&gt; and False otherwise.</source>
          <target state="translated">을 계산의 &lt;code&gt;element in test_elements&lt;/code&gt; 를 통해 방송, &lt;code&gt;element&lt;/code&gt; 만. element의 &lt;code&gt;element&lt;/code&gt; 가 &lt;code&gt;test_elements&lt;/code&gt; 에 있는 경우 True 인 &lt;code&gt;element&lt;/code&gt; 와 동일한 모양의 부울 배열을 리턴하고 그렇지 않으면 False 를 리턴 합니다.</target>
        </trans-unit>
        <trans-unit id="74b05ed646884364ea61a52a0d97dd5553fc5db3" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(1 + x)&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;log(1 + x)&lt;/code&gt; 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="793634569b16ddadf09c84f21826d340c4bb186b" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt;. This function is useful in statistics where the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the logarithm of the calculated probability is stored. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">계산은 &lt;code&gt;log(exp(x1) + exp(x2))&lt;/code&gt; . 이 함수는 계산 된 이벤트 확률이 정규 부동 소수점 수의 범위를 초과 할 정도로 작은 통계에 유용합니다. 이러한 경우 계산 된 확률의 로그가 저장됩니다. 이 기능을 사용하면 이러한 방식으로 저장된 확률을 추가 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="55306f441c10b288ef594152ca5bc10ba426774f" translate="yes" xml:space="preserve">
          <source>Calculates &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt;. This function is useful in machine learning when the calculated probabilities of events may be so small as to exceed the range of normal floating point numbers. In such cases the base-2 logarithm of the calculated probability can be used instead. This function allows adding probabilities stored in such a fashion.</source>
          <target state="translated">계산의 &lt;code&gt;log2(2**x1 + 2**x2)&lt;/code&gt; . 이 함수는 계산 된 이벤트 확률이 정상 부동 소수점 수의 범위를 초과 할 정도로 작을 때 기계 학습에 유용합니다. 이러한 경우 계산 된 확률의 밑이 2 인 로그가 대신 사용될 수 있습니다. 이 기능을 사용하면 이러한 방식으로 저장된 확률을 추가 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
