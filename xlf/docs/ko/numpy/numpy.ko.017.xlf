<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="653a93daba5d03116d06838a5a76a1330934f611" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;str&lt;/code&gt; refers to either null terminated bytes or unicode strings depending on the Python version. In code targeting both Python 2 and 3 &lt;code&gt;np.unicode_&lt;/code&gt; should be used as a dtype for strings. See &lt;a href=&quot;#string-dtype-note&quot;&gt;Note on string types&lt;/a&gt;.</source>
          <target state="translated">참고 것을 &lt;code&gt;str&lt;/code&gt; 파이썬 버전에 따라 널 종료 바이트 유니 코드 문자열 중 하나를 의미합니다. 모두 파이썬 (2, 3) 코드에 타겟팅 &lt;code&gt;np.unicode_&lt;/code&gt; 를 문자열 DTYPE 용으로 사용되어야한다. &lt;a href=&quot;#string-dtype-note&quot;&gt;문자열 유형에 대한 참고 사항을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="577f40a867da04018fffaab4749ee48c7ab85bee" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;test_&lt;/code&gt; functions or methods should not have a docstring, because that makes it hard to identify the test from the output of running the test suite with &lt;code&gt;verbose=2&lt;/code&gt; (or similar verbosity setting). Use plain comments (&lt;code&gt;#&lt;/code&gt;) if necessary.</source>
          <target state="translated">참고 것을 &lt;code&gt;test_&lt;/code&gt; 그게 하드로 테스트 스위트를 실행의 출력에서 테스트를 식별 할 수 있기 때문에 함수 또는 메소드는 문서화 문자열을하지 말았어야 &lt;code&gt;verbose=2&lt;/code&gt; (또는 이와 유사한 상세 설정). 필요한 경우 일반 주석 ( &lt;code&gt;#&lt;/code&gt; )을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="84da082e7c60f89cf395b2c2caf3ee075a4fd999" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;tiny&lt;/code&gt; is not actually the smallest positive representable value in a NumPy floating point type. As in the IEEE-754 standard &lt;a href=&quot;#r2ee89c7f792a-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, NumPy floating point types make use of subnormal numbers to fill the gap between 0 and &lt;code&gt;tiny&lt;/code&gt;. However, subnormal numbers may have significantly reduced precision &lt;a href=&quot;#r2ee89c7f792a-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;.</source>
          <target state="translated">주의 &lt;code&gt;tiny&lt;/code&gt; 실제로 NumPy와 부동 소수점 형에서 가장 작은 양의 표현 가능한 값이 아닙니다. IEEE-754 표준 &lt;a href=&quot;#r2ee89c7f792a-1&quot; id=&quot;id1&quot;&gt;[1]에서&lt;/a&gt; 와 같이 NumPy 부동 소수점 유형은 비정규 숫자를 사용하여 0과 &lt;code&gt;tiny&lt;/code&gt; 사이의 간격을 채 웁니다 . 그러나 비정규 숫자는 정밀도를 크게 떨어 뜨릴 수 있습니다 &lt;a href=&quot;#r2ee89c7f792a-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="02e2af0a66e4601c973f5ec5d0ddca41b2da6bef" translate="yes" xml:space="preserve">
          <source>Note that C++ type &lt;code&gt;bool&lt;/code&gt; is not supported in the list in the &lt;a href=&quot;#available-typemaps&quot;&gt;Available Typemaps&lt;/a&gt; section. NumPy bools are a single byte, while the C++ &lt;code&gt;bool&lt;/code&gt; is four bytes (at least on my system). Therefore:</source>
          <target state="translated">C ++ 유형 &lt;code&gt;bool&lt;/code&gt; 은 &lt;a href=&quot;#available-typemaps&quot;&gt;사용 가능한 유형 맵&lt;/a&gt; 섹션 의 목록에서 지원되지 않습니다 . NumPy bool은 단일 바이트이며 C ++ &lt;code&gt;bool&lt;/code&gt; 은 4 바이트입니다 (적어도 내 시스템에서는). 따라서:</target>
        </trans-unit>
        <trans-unit id="b7fb7bda276a077f32e3518dd51fb7c92f1227b3" translate="yes" xml:space="preserve">
          <source>Note that F2PY found that the second argument &lt;code&gt;n&lt;/code&gt; is the dimension of the first array argument &lt;code&gt;a&lt;/code&gt;. Since by default all arguments are input-only arguments, F2PY concludes that &lt;code&gt;n&lt;/code&gt; can be optional with the default value &lt;code&gt;len(a)&lt;/code&gt;.</source>
          <target state="translated">F2PY는 두 번째 인수 &lt;code&gt;n&lt;/code&gt; 이 첫 번째 배열 인수 &lt;code&gt;a&lt;/code&gt; 의 차원 임을 발견 했습니다 . 기본적으로 모든 인수는 입력 전용 인수이므로 F2PY는 &lt;code&gt;n&lt;/code&gt; 이 기본값 &lt;code&gt;len(a)&lt;/code&gt; 으로 선택 사항 일 수 있다는 결론을 내립니다 .</target>
        </trans-unit>
        <trans-unit id="2aa71944aea37a075fc5603b1c286b6996796fc2" translate="yes" xml:space="preserve">
          <source>Note that LaTeX is not particularly easy to read, so use equations sparingly.</source>
          <target state="translated">LaTeX는 특히 읽기 쉽지 않으므로 방정식을 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="9cc512ad322760dff623f859eafd23590a132e18" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended.</source>
          <target state="translated">NumPy는 주로 GNU 컴파일러를 사용하여 개발되었으며 MSVC 및 Clang 컴파일러에서 테스트되었습니다. Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM과 같은 다른 공급 업체의 컴파일러는 커뮤니티 피드백의 형태로만 지원되며 즉시 작동하지 않을 수 있습니다. GCC 4.x (이상) 컴파일러가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="fe4dc94a38ed3b66216a78c32ac7673436712897" translate="yes" xml:space="preserve">
          <source>Note that NumPy is developed mainly using GNU compilers and tested on MSVC and Clang compilers. Compilers from other vendors such as Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM are only supported in the form of community feedback, and may not work out of the box. GCC 4.x (and later) compilers are recommended. On ARM64 (aarch64) GCC 8.x (and later) are recommended.</source>
          <target state="translated">NumPy는 주로 GNU 컴파일러를 사용하여 개발되었으며 MSVC 및 Clang 컴파일러에서 테스트되었습니다. Intel, Absoft, Sun, NAG, Compaq, Vast, Portland, Lahey, HP, IBM과 같은 다른 공급 업체의 컴파일러는 커뮤니티 피드백의 형태로만 지원되며 즉시 작동하지 않을 수 있습니다. GCC 4.x (이상) 컴파일러가 권장됩니다. ARM64 (aarch64)에서는 GCC 8.x (이상)가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="d6fea2f832bdac55a57e8bcf7203f52e450af3e1" translate="yes" xml:space="preserve">
          <source>Note that NumPy submodules still use a file named &lt;code&gt;info.py&lt;/code&gt; in which the module docstring and &lt;code&gt;__all__&lt;/code&gt; dict are defined. These files will be removed at some point.</source>
          <target state="translated">NumPy 서브 모듈은 여전히 docstring 및 &lt;code&gt;__all__&lt;/code&gt; dict 모듈 이 정의 된 &lt;code&gt;info.py&lt;/code&gt; 라는 파일을 사용합니다 . 이 파일들은 언젠가 제거 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="cd1c6148abd4d8a68d9037726f201b07b6224a50" translate="yes" xml:space="preserve">
          <source>Note that a Fortran source file can contain many routines, and not necessarily all routines are needed to be used from Python. So, you can either specify which routines should be wrapped (in &lt;code&gt;only: .. :&lt;/code&gt; part) or which routines F2PY should ignored (in &lt;code&gt;skip: .. :&lt;/code&gt; part).</source>
          <target state="translated">Fortran 소스 파일에는 많은 루틴이 포함될 수 있으며 Python에서 모든 루틴을 사용해야하는 것은 아닙니다. 따라서 랩핑해야하는 루틴 ( &lt;code&gt;only: .. :&lt;/code&gt; 파트) 또는 무시해야하는 루틴 F2PY ( &lt;code&gt;skip: .. :&lt;/code&gt; 파트) 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="59ecaa164d1fdc3d2b5cb9ca7ff5cce49bcc5610" translate="yes" xml:space="preserve">
          <source>Note that a sliding window approach is often &lt;strong&gt;not&lt;/strong&gt; optimal (see Notes).</source>
          <target state="translated">슬라이딩 윈도우 접근 방식은 종종 최적 이 &lt;strong&gt;아닙니다&lt;/strong&gt; (참고 참조).</target>
        </trans-unit>
        <trans-unit id="243df166efa690ac8a711211a7fdea37ebc1d718" translate="yes" xml:space="preserve">
          <source>Note that although almost all modern C compilers pad in this way by default, padding in C structs is C-implementation-dependent so this memory layout is not guaranteed to exactly match that of a corresponding struct in a C program. Some work may be needed, either on the numpy side or the C side, to obtain exact correspondence.</source>
          <target state="translated">거의 모든 최신 C 컴파일러는 기본적으로 이러한 방식으로 패딩하지만 C 구조체의 패딩은 C 구현에 따라 다르므로이 메모리 레이아웃이 C 프로그램의 해당 구조체와 정확히 일치한다고 보장 할 수는 없습니다. 정확한 대응을 얻으려면 numpy 쪽이나 C 쪽에서 약간의 작업이 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3a0319be442be6ef174d641d2057417bdd72b054" translate="yes" xml:space="preserve">
          <source>Note that another approach would be to to use &lt;code&gt;getattr(ufunc,
methods)(*inputs, **kwargs)&lt;/code&gt; instead of the &lt;code&gt;super&lt;/code&gt; call. For this example, the result would be identical, but there is a difference if another operand also defines &lt;code&gt;__array_ufunc__&lt;/code&gt;. E.g., lets assume that we evalulate &lt;code&gt;np.add(a, b)&lt;/code&gt;, where &lt;code&gt;b&lt;/code&gt; is an instance of another class &lt;code&gt;B&lt;/code&gt; that has an override. If you use &lt;code&gt;super&lt;/code&gt; as in the example, &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; will notice that &lt;code&gt;b&lt;/code&gt; has an override, which means it cannot evaluate the result itself. Thus, it will return &lt;code&gt;NotImplemented&lt;/code&gt; and so will our class &lt;code&gt;A&lt;/code&gt;. Then, control will be passed over to &lt;code&gt;b&lt;/code&gt;, which either knows how to deal with us and produces a result, or does not and returns &lt;code&gt;NotImplemented&lt;/code&gt;, raising a &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">또 다른 접근 방식은 &lt;code&gt;super&lt;/code&gt; 호출 대신 &lt;code&gt;getattr(ufunc, methods)(*inputs, **kwargs)&lt;/code&gt; 사용하는 것입니다 . 이 예제의 경우 결과는 동일하지만 다른 피연산자도 &lt;code&gt;__array_ufunc__&lt;/code&gt; 를 정의하면 차이가 있습니다 . 예를 들어 &lt;code&gt;np.add(a, b)&lt;/code&gt; 한다고 가정 해 보겠습니다 . 여기서 &lt;code&gt;b&lt;/code&gt; 는 재정의가있는 다른 클래스 &lt;code&gt;B&lt;/code&gt; 의 인스턴스입니다 . 예제에서와 같이 &lt;code&gt;super&lt;/code&gt; 를 사용하는 경우 &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; 는 &lt;code&gt;b&lt;/code&gt; 에 재정의가 있음을 알 수 있으며 이는 결과 자체를 평가할 수 없음을 의미합니다. 따라서 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환 하고 클래스 &lt;code&gt;A&lt;/code&gt; 도 반환합니다 .. 그런 다음 제어가 &lt;code&gt;b&lt;/code&gt; 로 전달됩니다. b 는 우리를 처리하는 방법을 알고 결과를 생성하거나 &lt;code&gt;NotImplemented&lt;/code&gt; 를 반환하지 않고 반환 하여 &lt;code&gt;TypeError&lt;/code&gt; 를 발생 시킵니다.</target>
        </trans-unit>
        <trans-unit id="2f3a7170281d96c749df00a8822f6364f1c668d7" translate="yes" xml:space="preserve">
          <source>Note that another way to do an inplace build visible outside the repo base dir is with &lt;code&gt;python setup.py develop&lt;/code&gt;. Instead of adjusting &lt;code&gt;PYTHONPATH&lt;/code&gt;, this installs a &lt;code&gt;.egg-link&lt;/code&gt; file into your site-packages as well as adjusts the &lt;code&gt;easy-install.pth&lt;/code&gt; there, so its a more permanent (and magical) operation.</source>
          <target state="translated">repo base dir 외부에서 볼 수있는 inplace 빌드를 수행하는 또 다른 방법은 &lt;code&gt;python setup.py develop&lt;/code&gt; 입니다. &lt;code&gt;PYTHONPATH&lt;/code&gt; 를 조정하는 대신 &lt;code&gt;.egg-link&lt;/code&gt; 파일을 사이트 패키지에 설치 하고 &lt;code&gt;easy-install.pth&lt;/code&gt; 를 조정하여 보다 영구적이고 마법적인 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="8d0bc3c9921682280a85d9ad74708f6af3774f00" translate="yes" xml:space="preserve">
          <source>Note that arrays with hard-coded dimensions are not supported. These cannot follow the double pointer signatures of these typemaps.</source>
          <target state="translated">하드 코딩 된 차원을 가진 배열은 지원되지 않습니다. 이들은 이러한 유형 맵의 이중 포인터 서명을 따를 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="48706be1cfd595ac0f989289e2a8fb9947cff916" translate="yes" xml:space="preserve">
          <source>Note that as the order of the arguments are reversed, the side must be too. The &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt; call is marginally faster, as it does not do any monotonicity checks. Perhaps more importantly, it supports all dtypes.</source>
          <target state="translated">인수의 순서가 반대이므로 측면도 마찬가지입니다. &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; 은 어떤 단순성 검사를하지 않는 한 호출, 빠른 변두리에있다. 더 중요한 것은 모든 dtype을 지원한다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="b5450d42b830584acc5db98da979017850552b6b" translate="yes" xml:space="preserve">
          <source>Note that assignments may result in changes if assigning higher types to lower types (like floats to ints) or even exceptions (assigning complex to floats or ints):</source>
          <target state="translated">더 높은 유형을 더 낮은 유형에 할당하거나 (예 : floats to int) 예외 (복합을 float 또는 int에 할당)에 할당하면 할당이 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1107611495a4cef20786212c1426d524434253be" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="translated">Windows에서 문서를 빌드하는 것은 가능해야하지만 현재 적극적으로 지원되지 않습니다. (자세한 내용은 &lt;a href=&quot;http://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 문서를 참조하세요.)</target>
        </trans-unit>
        <trans-unit id="16a4ad0db92a475933d552d809189c9d735b06a9" translate="yes" xml:space="preserve">
          <source>Note that building the documentation on Windows is currently not actively supported, though it should be possible. (See &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; documentation for more information.)</source>
          <target state="translated">Windows에서 문서를 빌드하는 것은 가능해야하지만 현재 적극적으로 지원되지 않습니다. (자세한 내용은 &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 문서를 참조하세요.)</target>
        </trans-unit>
        <trans-unit id="6b7ba7f496bb7ba121307112b93618161ad3c991" translate="yes" xml:space="preserve">
          <source>Note that by default using single &lt;code&gt;intent(out)&lt;/code&gt; also implies &lt;code&gt;intent(hide)&lt;/code&gt;. Arguments that have the &lt;code&gt;intent(hide)&lt;/code&gt; attribute specified will not be listed in the argument list of a wrapper function.</source>
          <target state="translated">기본적으로 single &lt;code&gt;intent(out)&lt;/code&gt; 사용하면 &lt;code&gt;intent(hide)&lt;/code&gt; 도 의미 합니다. 이 인수 &lt;code&gt;intent(hide)&lt;/code&gt; 지정된 속성은 래퍼 함수의 인수 목록에 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e4dd030963aaaf3be4bd9f6afb2a54167cbe9671" translate="yes" xml:space="preserve">
          <source>Note that computing a monthly mortgage payment is only one use for this function. For example, pmt returns the periodic deposit one must make to achieve a specified future balance given an initial deposit, a fixed, periodically compounded interest rate, and the total number of periods.</source>
          <target state="translated">월간 모기지 상환을 계산하는 것은이 기능에 대한 한 가지 용도 일뿐입니다. 예를 들어, pmt는 초기 예금, 고정적이고 정기적으로 복합 이자율 및 총 기간 수를 고려하여 지정된 미래 잔액을 달성하기 위해 만들어야하는 정기적 예금을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d45705fbd740d84091e3bf2b229712fdd0365205" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt;&lt;code&gt;str&lt;/code&gt;&lt;/a&gt; instances.</source>
          <target state="translated">이 함수의 이름에도 불구하고 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str&quot;&gt; &lt;code&gt;str&lt;/code&gt; &lt;/a&gt; 인스턴스를 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="a3299a2dbf1b83250c6148ada8e7d466fe67fe1d" translate="yes" xml:space="preserve">
          <source>Note that despite the name of this function it does not accept &lt;code&gt;str&lt;/code&gt; instances.</source>
          <target state="translated">이 함수의 이름에도 불구하고 &lt;code&gt;str&lt;/code&gt; 인스턴스를 허용하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="46d023cb473537055d9b3a4020206aea9635b5fe" translate="yes" xml:space="preserve">
          <source>Note that dictionaries are not stored in any specific order. Also, most mutable (see &lt;em&gt;immutable&lt;/em&gt; below) objects, such as lists, may not be used as keys.</source>
          <target state="translated">사전은 특정 순서로 저장되지 않습니다. 또한 목록과 같은 대부분의 변경 가능한 (아래의 &lt;em&gt;변경 불가능&lt;/em&gt; 참조) 객체는 키로 사용되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6b262586803e1839adc1dd7ba61528562de1c4dc" translate="yes" xml:space="preserve">
          <source>Note that element</source>
          <target state="translated">그 요소에 유의하십시오</target>
        </trans-unit>
        <trans-unit id="3361278c66a9a950ab868f2606daa6d980ba0742" translate="yes" xml:space="preserve">
          <source>Note that fitting polynomial coefficients is inherently badly conditioned when the degree of the polynomial is large or the interval of sample points is badly centered. The quality of the fit should always be checked in these cases. When polynomial fits are not satisfactory, splines may be a good alternative.</source>
          <target state="translated">다항식의 차수가 크거나 샘플 포인트의 간격이 잘못 중심이되면 다항식 계수 피팅이 본질적으로 잘못 조정됩니다. 이 경우 적합도는 항상 확인해야합니다. 다항식 피팅이 만족스럽지 않으면 스플라인이 좋은 대안이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0754d929f5032a758a77b70b619d10e1a6b0a14a" translate="yes" xml:space="preserve">
          <source>Note that for complex numbers, the absolute value is taken before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">복소수의 경우, 제곱하기 전에 절대 값이 사용되므로 결과는 항상 실수이고 음이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="17ba305768334a737a4dfbed178a872a09842e7e" translate="yes" xml:space="preserve">
          <source>Note that for documentation within numpy, it is not necessary to do &lt;code&gt;import numpy as np&lt;/code&gt; at the beginning of an example. However, some sub-modules, such as &lt;code&gt;fft&lt;/code&gt;, are not imported by default, and you have to include them explicitly:</source>
          <target state="translated">numpy 내의 문서 의 경우 예제 시작 부분에서 &lt;code&gt;import numpy as np&lt;/code&gt; 로 가져올 필요가 없습니다 . 그러나 &lt;code&gt;fft&lt;/code&gt; 와 같은 일부 하위 모듈 은 기본적으로 가져 오지 않으므로 명시 적으로 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="fc16e5fa0b99ff8394b543959e3c5038077d609b" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 평균은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; 의&lt;/a&gt; 경우 결과가 부정확해질 수 있습니다 (아래 예 참조). &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 고정밀 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81ef16afabd45555cde2cd7088469cd77b4f8e66" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 평균은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; 의&lt;/a&gt; 경우 결과가 부정확해질 수 있습니다 . &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 고정밀 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c532f8402b234b1805dc32ad508ed06d2d992bc4" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 평균은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 &lt;code&gt;float32&lt;/code&gt; 의 경우 결과가 정확하지 않을 수 있습니다 (아래 예 참조). &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 고정밀 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="28ec6b24f09abee0bf153ce2a68e94e6fc60a244" translate="yes" xml:space="preserve">
          <source>Note that for floating-point input, the mean is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt;. Specifying a higher-precision accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 평균은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라, 특히 &lt;code&gt;float32&lt;/code&gt; 의 경우 결과가 정확하지 않을 수 있습니다 . &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 고정밀 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9429c3e4d702a779857d710d5ba3d4bb8d91e3db" translate="yes" xml:space="preserve">
          <source>Note that for higher dimensional inserts &lt;code&gt;obj=0&lt;/code&gt; behaves very different from &lt;code&gt;obj=[0]&lt;/code&gt; just like &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; is different from &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt;.</source>
          <target state="translated">더 높은 치수의 인서트의 경우 &lt;code&gt;obj=0&lt;/code&gt; 은 &lt;code&gt;arr[:,0,:] = values&lt;/code&gt; 가 &lt;code&gt;arr[:,[0],:] = values&lt;/code&gt; :] = values 와 다른 것처럼 &lt;code&gt;obj=[0]&lt;/code&gt; 과 매우 다르게 동작 합니다 .</target>
        </trans-unit>
        <trans-unit id="64098939d0cc3bd11f1e190ea4842decacbcc08d" translate="yes" xml:space="preserve">
          <source>Note that higher-dimensional arrays are flattened!</source>
          <target state="translated">더 높은 차원의 배열은 평평합니다!</target>
        </trans-unit>
        <trans-unit id="08dbdae6232197f6e8ea8b77dc3750bf740014ac" translate="yes" xml:space="preserve">
          <source>Note that if &lt;code&gt;threads&lt;/code&gt; is not set by the user, it will be determined by &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;threads&lt;/code&gt; 가 사용자에 의해 설정되지 않은 경우 &lt;code&gt;multiprocessing.cpu_count()&lt;/code&gt; 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="3e03a6fba50452828f3483eb33a462b6c52de935" translate="yes" xml:space="preserve">
          <source>Note that if a field has the same name as an ndarray attribute, the ndarray attribute takes precedence. Such fields will be inaccessible by attribute but will still be accessible by index.</source>
          <target state="translated">필드의 이름이 ndarray 속성과 동일한 경우 ndarray 속성이 우선합니다. 이러한 필드는 속성으로 액세스 할 수 없지만 인덱스로 계속 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="18c7921c177ba1f557c86613521ffad6b35f74d0" translate="yes" xml:space="preserve">
          <source>Note that if an operand is given the flag &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, a copy will be made in preference to buffering. Buffering will still occur when the array was broadcast so elements need to be duplicated to get a constant stride.</source>
          <target state="translated">피연산자에 &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 제공되면 버퍼링보다 복사가 우선합니다. 배열이 브로드 캐스트 될 때 버퍼링이 계속 발생하므로 일정한 보폭을 얻으려면 요소를 복제해야합니다.</target>
        </trans-unit>
        <trans-unit id="b29d0e1167132199e264175b7a1e173cb2ad60e1" translate="yes" xml:space="preserve">
          <source>Note that if an uninitialized return array is created, values of False will leave those values &lt;strong&gt;uninitialized&lt;/strong&gt;.</source>
          <target state="translated">초기화되지 않은 리턴 배열이 작성되면 False 값은 해당 값을 &lt;strong&gt;초기화되지 않은 상태로 유지&lt;/strong&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8aa598501b8ebf0323315a582a961e1c62a8f937" translate="yes" xml:space="preserve">
          <source>Note that if one indexes a multidimensional array with fewer indices than dimensions, one gets a subdimensional array. For example:</source>
          <target state="translated">차원보다 적은 수의 인덱스를 사용하여 다차원 배열을 인덱싱하면 하위 차원 배열을 얻습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e7d909696047578f38bea71bdf411f55070df9d2" translate="yes" xml:space="preserve">
          <source>Note that if the C function signature was in a different order:</source>
          <target state="translated">C 함수 서명의 순서가 다른 경우</target>
        </trans-unit>
        <trans-unit id="01a168adfe5fe1f5dd6875481bec15e4f9aa1985" translate="yes" xml:space="preserve">
          <source>Note that if you want to do a reduction on an automatically allocated output, you must use &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; to get its reference, then set every value to the reduction unit before doing the iteration loop. In the case of a buffered reduction, this means you must also specify the flag &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt;, then reset the iterator after initializing the allocated operand to prepare the buffers.</source>
          <target state="translated">자동으로 할당 된 출력에서 ​​축소를 수행하려면 &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; 를 사용 하여 참조를 얻은 다음 반복 루프를 수행하기 전에 모든 값을 축소 단위로 설정해야합니다. 버퍼링 된 감소의 경우 이는 &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; 플래그를 지정한 다음 할당 된 피연산자를 초기화 한 후 반복기를 재설정하여 버퍼를 준비 해야 함을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="2b010bbfdb300bcd389c385bed7ea27b3386f09b" translate="yes" xml:space="preserve">
          <source>Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000, and 32 = 0010 0000.</source>
          <target state="translated">이진수 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000, 32 = 0010 0000입니다.</target>
        </trans-unit>
        <trans-unit id="a6ebb270150b81af72246532a75002f3434d09b6" translate="yes" xml:space="preserve">
          <source>Note that in the code snippets below, &lt;code&gt;upstream&lt;/code&gt; refers to the root repository on github and &lt;code&gt;origin&lt;/code&gt; to a fork in your personal account. You may need to make adjustments if you have not forked the repository but simply cloned it locally. You can also edit &lt;code&gt;.git/config&lt;/code&gt; and add &lt;code&gt;upstream&lt;/code&gt; if it isn&amp;rsquo;t already present.</source>
          <target state="translated">아래 코드 스 니펫에서 &lt;code&gt;upstream&lt;/code&gt; 은 github의 루트 저장소를 나타내고 &lt;code&gt;origin&lt;/code&gt; 은 개인 계정의 포크를 나타냅니다. 저장소를 분기하지 않고 로컬로 복제 한 경우 조정이 필요할 수 있습니다. &lt;code&gt;.git/config&lt;/code&gt; 를 편집 하고 아직없는 경우 &lt;code&gt;upstream&lt;/code&gt; 추가 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0deb1edca6a6f101961c6c8ff2fdf5eb19dff4d3" translate="yes" xml:space="preserve">
          <source>Note that integer divide-by-zero is handled by the same machinery. These behaviors are set on a per-thread basis.</source>
          <target state="translated">정수 0으로 나누기는 동일한 기계에 의해 처리됩니다. 이러한 동작은 스레드별로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="6720060be8821678605a9cb8b96c71daf2200a5d" translate="yes" xml:space="preserve">
          <source>Note that it is not required for &lt;code&gt;__array_function__&lt;/code&gt; implementations to include &lt;em&gt;all&lt;/em&gt; of the corresponding NumPy function&amp;rsquo;s optional arguments (e.g., &lt;code&gt;broadcast_to&lt;/code&gt; above omits the irrelevant &lt;code&gt;subok&lt;/code&gt; argument). Optional arguments are only passed in to &lt;code&gt;__array_function__&lt;/code&gt; if they were explicitly used in the NumPy function call.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 구현에 해당하는 NumPy 함수의 선택적 인수를 &lt;em&gt;모두&lt;/em&gt; 포함 &lt;em&gt;할&lt;/em&gt; 필요는 없습니다 (예를 들어, &lt;code&gt;broadcast_to&lt;/code&gt; 는 관련없는 &lt;code&gt;subok&lt;/code&gt; 인수를 생략 함 ). 선택적 인수는 NumPy 함수 호출에 명시 적으로 사용 된 경우 에만 &lt;code&gt;__array_function__&lt;/code&gt; 에 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="401f22bf499be24336e06ca8c727f49552e9ba96" translate="yes" xml:space="preserve">
          <source>Note that it would be more straightforward in the above example to extract the required elements directly with &lt;code&gt;x[:2, :3]&lt;/code&gt;.</source>
          <target state="translated">위의 예에서 &lt;code&gt;x[:2, :3]&lt;/code&gt; 필요한 요소를 직접 추출하는 것이 더 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="640acbca975ba8209807d8f3d4cb4b40d4247c4c" translate="yes" xml:space="preserve">
          <source>Note that license and author info, while often included in source files, do not belong in docstrings.</source>
          <target state="translated">라이센스 및 작성자 정보는 종종 소스 파일에 포함되지만 독 스트링에 속하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03915cb39403716ec5a60a8297475cd1fe487299" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;a href=&quot;arrays.scalars#numpy.flexible&quot;&gt;&lt;code&gt;flexible&lt;/code&gt;&lt;/a&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="translated">모든 데이터 유형 정보가 유형 객체와 함께 제공 될 수있는 것은 아닙니다. 예를 들어 &lt;a href=&quot;arrays.scalars#numpy.flexible&quot;&gt; &lt;code&gt;flexible&lt;/code&gt; &lt;/a&gt; 데이터 유형은 기본 항목 &lt;em&gt;크기&lt;/em&gt; 가 0이고 유용하려면 명시 적으로 지정된 크기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="aaaef84f5e6e416f2f83a03c812a03e6bee63048" translate="yes" xml:space="preserve">
          <source>Note that not all data-type information can be supplied with a type-object: for example, &lt;code&gt;flexible&lt;/code&gt; data-types have a default &lt;em&gt;itemsize&lt;/em&gt; of 0, and require an explicitly given size to be useful.</source>
          <target state="translated">모든 데이터 유형 정보에 유형 객체를 제공 할 수있는 것은 아닙니다. 예를 들어, &lt;code&gt;flexible&lt;/code&gt; 데이터 유형은 기본 항목 &lt;em&gt;크기&lt;/em&gt; 가 0이며 명시 적으로 지정된 크기가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="780756f1773042c233a75d985a3181931209c4b9" translate="yes" xml:space="preserve">
          <source>Note that np.copy is a shallow copy and will not copy object elements within arrays. This is mainly important for arrays containing Python objects. The new array will contain the same object which may lead to surprises if that object can be modified (is mutable):</source>
          <target state="translated">np.copy는 얕은 복사본이며 배열 내에서 개체 요소를 복사하지 않습니다. 이것은 주로 Python 객체를 포함하는 배열에 중요합니다. 새 배열에는 동일한 객체가 포함되어 해당 객체를 수정할 수있는 경우 놀라움을 유발할 수 있습니다 (변경 가능).</target>
        </trans-unit>
        <trans-unit id="2e81c263eba620a31c6f05237f30bb45194a05fe" translate="yes" xml:space="preserve">
          <source>Note that once the iterator is closed we can not access &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt;&lt;code&gt;operands&lt;/code&gt;&lt;/a&gt; and must use a reference created inside the context manager.</source>
          <target state="translated">반복자가 닫히면 &lt;a href=&quot;generated/numpy.nditer.operands#numpy.nditer.operands&quot;&gt; &lt;code&gt;operands&lt;/code&gt; &lt;/a&gt; 액세스 할 수 없으며 컨텍스트 관리자 내에 작성된 참조를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="60c2866e24780637913bab15a3c10ed5a1e5ba08" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;a href=&quot;../arrays.scalars#numpy.int16&quot;&gt;&lt;code&gt;int16&lt;/code&gt;&lt;/a&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="translated">정수 스칼라 유형 (예 : &lt;a href=&quot;../arrays.scalars#numpy.int16&quot;&gt; &lt;code&gt;int16&lt;/code&gt; &lt;/a&gt; )에 대한 연산은 부동 소수점처럼 처리되며 이러한 설정의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="a0072c6c9282c50699dd3bb094606976a4136251" translate="yes" xml:space="preserve">
          <source>Note that operations on integer scalar types (such as &lt;code&gt;int16&lt;/code&gt;) are handled like floating point, and are affected by these settings.</source>
          <target state="translated">정수 스칼라 유형 (예 : &lt;code&gt;int16&lt;/code&gt; )에 대한 연산은 부동 소수점처럼 처리되며 이러한 설정의 영향을받습니다.</target>
        </trans-unit>
        <trans-unit id="b5c0500d98fa9cc106c3d86fe8d639514bc7b011" translate="yes" xml:space="preserve">
          <source>Note that slices of arrays do not copy the internal array data but only produce new views of the original data. This is different from list or tuple slicing and an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended if the original data is not required anymore.</source>
          <target state="translated">배열 조각은 내부 배열 데이터를 복사하지 않고 원본 데이터의 새보기 만 생성합니다. 이것은 목록 또는 튜플 슬라이싱과 다르며 원본 데이터가 더 이상 필요하지 않은 경우 명시 적 &lt;code&gt;copy()&lt;/code&gt; 를 권장합니다.</target>
        </trans-unit>
        <trans-unit id="09f50c6ff377ac0a2ca64d0c66fbaa9d2065ec9a" translate="yes" xml:space="preserve">
          <source>Note that some examples may use &lt;code&gt;None&lt;/code&gt; instead of &lt;code&gt;np.newaxis&lt;/code&gt;. These are the same objects:</source>
          <target state="translated">일부 예제는 &lt;code&gt;np.newaxis&lt;/code&gt; 대신 &lt;code&gt;None&lt;/code&gt; 을 사용할 수 있습니다 . 이들은 동일한 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1c4abf3101df64ae31f9f09aef9564b202ca3573" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to rerun them. You will need to be logged in under &amp;lsquo;numpy&amp;rsquo; to do this on azure.</source>
          <target state="translated">테스트와 같은 빌드가 관련없는 이유로 실패하는 경우가 있으며이를 다시 실행해야합니다. azure에서이 작업을 수행하려면 'numpy'에서 로그인해야합니다.</target>
        </trans-unit>
        <trans-unit id="4f987286ad6faa40518b3a8186b7c20cb6434a93" translate="yes" xml:space="preserve">
          <source>Note that sometimes builds, like tests, fail for unrelated reasons and you will need to restart them.</source>
          <target state="translated">테스트와 같은 빌드가 관련없는 이유로 실패하는 경우가 있으며이를 다시 시작해야한다는 점에 유의하세요. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="ffa9fecdeba09a0f43a75d04eeb01c1da54d7720" translate="yes" xml:space="preserve">
          <source>Note that sorting is first according to the elements of &lt;code&gt;a&lt;/code&gt;. Secondary sorting is according to the elements of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">먼저 정렬 요소에 따른되어 있습니다 . 2 차 정렬은 &lt;code&gt;b&lt;/code&gt; 의 요소에 따릅니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2ab2cbf3d7d05721e26131cbe4f74f5e6c689750" translate="yes" xml:space="preserve">
          <source>Note that the above may not produce exact integers:</source>
          <target state="translated">위의 정확한 정수를 생성하지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eca364d78cae8f55568bb70af05b48416bbfc64c" translate="yes" xml:space="preserve">
          <source>Note that the columns have been rearranged &amp;ldquo;in bulk&amp;rdquo;: the values within each column have not changed.</source>
          <target state="translated">열이 &quot;대량&quot;으로 재정렬되었습니다. 각 열의 값은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="816b54542ce937e025129bb5a02d396360440696" translate="yes" xml:space="preserve">
          <source>Note that the covariance matrix must be positive semidefinite (a.k.a. nonnegative-definite). Otherwise, the behavior of this method is undefined and backwards compatibility is not guaranteed.</source>
          <target state="translated">공분산 행렬은 양의 반정의 (일명 음이 아닌-정의) 여야합니다. 그렇지 않으면이 메소드의 동작이 정의되지 않으며 이전 버전과의 호환성이 보장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ce6b6a669d0954769df5e326b05520fbeb05f879" translate="yes" xml:space="preserve">
          <source>Note that the dtype of the second argument may change the dtype of the result and can lead to unexpected results in some cases (see &lt;a href=&quot;../ufuncs#ufuncs-casting&quot;&gt;Casting Rules&lt;/a&gt;):</source>
          <target state="translated">두 번째 인수의 dtype은 결과의 dtype을 변경할 수 있으며 경우에 따라 예기치 않은 결과가 발생할 수 있습니다 ( &lt;a href=&quot;../ufuncs#ufuncs-casting&quot;&gt;캐스팅 규칙&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="891f0fa3122015805e6600a7a4bd2235d2515ff8" translate="yes" xml:space="preserve">
          <source>Note that the length of the 1D boolean array must coincide with the length of the dimension (or axis) you want to slice. In the previous example, &lt;code&gt;b1&lt;/code&gt; has length 3 (the number of &lt;em&gt;rows&lt;/em&gt; in &lt;code&gt;a&lt;/code&gt;), and &lt;code&gt;b2&lt;/code&gt; (of length 4) is suitable to index the 2nd axis (columns) of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1D 부울 배열의 길이는 분할하려는 차원 (또는 축)의 길이와 일치해야합니다. 이전 예에서, &lt;code&gt;b1&lt;/code&gt; 길이 3 (수 갖는다 &lt;em&gt;행&lt;/em&gt; 에 ) 및 &lt;code&gt;b2&lt;/code&gt; (길이를 4)의 제 2 축 (열) 인덱스에 적합 . &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51fdfec7c0c161ff5cf20da12ebf59920f92cef4" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is filled varies depending on the flip function.</source>
          <target state="translated">대각선이 채워지는 순서는 플립 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="724f6e013fa8829f11659c1f81abf24921dbd546" translate="yes" xml:space="preserve">
          <source>Note that the order in which the diagonal is retrieved varies depending on the flip function.</source>
          <target state="translated">대각선이 검색되는 순서는 플립 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a99c18cf39a32483fd943f4224186f409906587f" translate="yes" xml:space="preserve">
          <source>Note that the output of &lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt;&lt;code&gt;compressed&lt;/code&gt;&lt;/a&gt; is always 1D.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ma.compressed#numpy.ma.compressed&quot;&gt; &lt;code&gt;compressed&lt;/code&gt; &lt;/a&gt; 출력 은 항상 1D입니다.</target>
        </trans-unit>
        <trans-unit id="fe6f42e3829661cf63ecd7296a8f95be4fb61504" translate="yes" xml:space="preserve">
          <source>Note that the result of each integration is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt;. Why is this important to note? Say one is making a linear change of variable</source>
          <target state="translated">각 통합의 결과 에 &lt;code&gt;scl&lt;/code&gt; 을&lt;em&gt;곱&lt;/em&gt; 합니다 . 이것이 중요한 이유는 무엇입니까? 변수를 선형 적으로 변경한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="87d64ab0ec81404f96e3a3fd6a0cf4af1b48cd4a" translate="yes" xml:space="preserve">
          <source>Note that the result shape is identical to the (broadcast) indexing array shapes &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt;.</source>
          <target state="translated">결과 모양은 (브로드 캐스트) 인덱싱 배열 모양 &lt;code&gt;ind_1, ..., ind_N&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="970776667a9fe553514eecc1dd1a72278348d24e" translate="yes" xml:space="preserve">
          <source>Note that the scalar types are not &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; objects, even though they can be used in place of one whenever a data type specification is needed in NumPy.</source>
          <target state="translated">NumPy에서 데이터 유형 스펙이 필요할 때마다 스칼라 유형이 대신 사용될 수 있지만 스칼라 유형은 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 오브젝트 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="c59a59639135c22037a5377f994f5afdc88bff2a" translate="yes" xml:space="preserve">
          <source>Note that the strided-copy and strided-cast code are deeply intertwined and so any arrays being processed by them must be both uint and true aligned, even though the copy-code only needs uint alignment and the cast code only true alignment. If there is ever a big rewrite of this code it would be good to allow them to use different alignments.</source>
          <target state="translated">strided-copy 코드와 strided-cast 코드는 깊이 얽혀 있으므로 복사 코드에 uint 정렬 만 필요하고 cast 코드에만 진정한 정렬이 필요하더라도 처리되는 배열은 uint와 true로 정렬되어야합니다. 이 코드를 크게 다시 작성하는 경우 다른 정렬을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="773d567bd01efce78b3ce4a4307782bcff7af947" translate="yes" xml:space="preserve">
          <source>Note that the string representation of polynomials uses Unicode characters by default (except on Windows) to express powers and subscripts. An ASCII-based representation is also available (default on Windows). The polynomial string format can be toggled at the package-level with the &lt;a href=&quot;generated/numpy.polynomial.set_default_printstyle#numpy.polynomial.set_default_printstyle&quot;&gt;&lt;code&gt;set_default_printstyle&lt;/code&gt;&lt;/a&gt; function:</source>
          <target state="translated">다항식의 문자열 표현은 기본적으로 유니 코드 문자 (Windows 제외)를 사용하여 거듭 제곱과 첨자를 표현합니다. ASCII 기반 표현도 사용할 수 있습니다 (Windows의 기본값). 다항식 문자열 형식은 &lt;a href=&quot;generated/numpy.polynomial.set_default_printstyle#numpy.polynomial.set_default_printstyle&quot;&gt; &lt;code&gt;set_default_printstyle&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 패키지 수준에서 전환 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="66c05a00c87427b26e39bf9edf93e478c145e10d" translate="yes" xml:space="preserve">
          <source>Note that the terms in the multi-line Boolean expression are indented so as to make the beginning of the code block clearly visible.</source>
          <target state="translated">여러 줄로 된 부울 식의 용어는 코드 블록의 시작 부분이 명확하게 보이도록 들여 쓰기됩니다.</target>
        </trans-unit>
        <trans-unit id="fecfca7c041f47ec9751b796cf84238ada1da72a" translate="yes" xml:space="preserve">
          <source>Note that the ufunc (&lt;code&gt;np.add&lt;/code&gt;) has called the &lt;code&gt;__array_wrap__&lt;/code&gt; method with arguments &lt;code&gt;self&lt;/code&gt; as &lt;code&gt;obj&lt;/code&gt;, and &lt;code&gt;out_arr&lt;/code&gt; as the (ndarray) result of the addition. In turn, the default &lt;code&gt;__array_wrap__&lt;/code&gt; (&lt;code&gt;ndarray.__array_wrap__&lt;/code&gt;) has cast the result to class &lt;code&gt;MySubClass&lt;/code&gt;, and called &lt;code&gt;__array_finalize__&lt;/code&gt; - hence the copying of the &lt;code&gt;info&lt;/code&gt; attribute. This has all happened at the C level.</source>
          <target state="translated">ufunc ( &lt;code&gt;np.add&lt;/code&gt; )는 인수 &lt;code&gt;self&lt;/code&gt; 를 &lt;code&gt;obj&lt;/code&gt; , &lt;code&gt;out_arr&lt;/code&gt; 을 추가 결과로 사용하여 &lt;code&gt;__array_wrap__&lt;/code&gt; 메서드를 호출했습니다 . 차례로, 기본 &lt;code&gt;__array_wrap__&lt;/code&gt; 은 ( &lt;code&gt;ndarray.__array_wrap__&lt;/code&gt; ) 클래스에 결과를 던졌다 &lt;code&gt;MySubClass&lt;/code&gt; 및 전화 &lt;code&gt;__array_finalize__&lt;/code&gt; - 따라서의 복사 &lt;code&gt;info&lt;/code&gt; 속성. 이것은 모두 C 수준에서 발생했습니다.</target>
        </trans-unit>
        <trans-unit id="6d91192b6712228963707a6381dc069bd269f72d" translate="yes" xml:space="preserve">
          <source>Note that there are no new elements in the array, just that the dimensionality is increased. This can be handy to combine two arrays in a way that otherwise would require explicitly reshaping operations. For example:</source>
          <target state="translated">배열에 새로운 요소가 없으며 차원이 증가한다는 점에 유의하십시오. 그렇지 않으면 명시 적으로 재구성 작업이 필요한 방식으로 두 배열을 결합하는 것이 편리 할 수 ​​있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="2c86d4295cc278f91db8c615a2b6f47dcfb069bb" translate="yes" xml:space="preserve">
          <source>Note that there are some subtleties regarding the last usage that the user should be aware of that are described in the arange docstring.</source>
          <target state="translated">Arange docstring에 설명되어있는 사용자가 알고 있어야하는 마지막 사용법과 관련하여 약간의 미묘함이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f3272a5f558b3fab42d4539ad3dc738bcb4ce852" translate="yes" xml:space="preserve">
          <source>Note that there are three parts to the long version of the printout. The first is the coefficients, the second is the domain, and the third is the window:</source>
          <target state="translated">인쇄물의 긴 버전에는 세 부분이 있습니다. 첫 번째는 계수이고, 두 번째는 도메인이며, 세 번째는 윈도우입니다.</target>
        </trans-unit>
        <trans-unit id="3a9c78ac3abf35e5e3337780f5e62c12c7df494d" translate="yes" xml:space="preserve">
          <source>Note that this distribution is very similar to the binomial distribution, except that in this case, samples are drawn without replacement, whereas in the Binomial case samples are drawn with replacement (or the sample space is infinite). As the sample space becomes large, this distribution approaches the binomial.</source>
          <target state="translated">이 분포는 이항 분포와 매우 유사하지만이 경우 표본은 교체없이 추출되는 반면, 이항 경우에서는 표본이 교체로 그려집니다 (또는 표본 공간이 무한대 임). 표본 공간이 커짐에 따라이 분포는 이항에 접근합니다.</target>
        </trans-unit>
        <trans-unit id="71bb480ec02fbb938cca2004bc6943842a328aaa" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;complex&lt;/code&gt;.</source>
          <target state="translated">이것은 내장 파이썬 &lt;code&gt;complex&lt;/code&gt; 의 정밀도와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="1c75e7f017341538d8b3f779cf45143d903afb1a" translate="yes" xml:space="preserve">
          <source>Note that this matches the precision of the builtin python &lt;code&gt;float&lt;/code&gt;.</source>
          <target state="translated">이것은 내장 파이썬 &lt;code&gt;float&lt;/code&gt; 의 정밀도와 일치합니다 .</target>
        </trans-unit>
        <trans-unit id="207f864735403916ab64725fc35836347eea06c9" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;data_as&lt;/code&gt;, a reference will not be kept to the array: code like &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; will result in a pointer to a deallocated array, and should be spelt &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;data_as&lt;/code&gt; 와 달리 참조는 배열에 유지되지 않습니다. &lt;code&gt;ctypes.c_void_p((a + b).ctypes.data)&lt;/code&gt; 와 같은 코드 는 할당이 해제 된 배열에 대한 포인터를 생성하며 철자가 &lt;code&gt;(a + b).ctypes.data_as(ctypes.c_void_p)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fa5eae61b870cb56e093988870d6dd9877647aa6" translate="yes" xml:space="preserve">
          <source>Note that unlike &lt;code&gt;numpy.ndarray&lt;/code&gt;, &lt;code&gt;ArrayLike&lt;/code&gt; does not allow operations with arbitrary, unrecognized types. This ensures that interactions with ArrayLike preserve a well-defined casting hierarchy.</source>
          <target state="translated">달리합니다 &lt;code&gt;numpy.ndarray&lt;/code&gt; 가 , &lt;code&gt;ArrayLike&lt;/code&gt; 가 임의의, 인식 할 수없는 유형의 작업을 허용하지 않습니다. 이를 통해 ArrayLike와의 상호 작용은 잘 정의 된 캐스팅 계층 구조를 유지합니다.</target>
        </trans-unit>
        <trans-unit id="43c59c07e98c965f271cd8992d38ce79563e80fe" translate="yes" xml:space="preserve">
          <source>Note that we can assign each color channel to a separate matrix using the slice syntax:</source>
          <target state="translated">슬라이스 구문을 사용하여 각 색상 채널을 별도의 행렬에 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="448e8d337bf988d0c2429a16c43ede94f241e3d0" translate="yes" xml:space="preserve">
          <source>Note that we had to use only the first &lt;code&gt;k&lt;/code&gt; rows of &lt;code&gt;Vt&lt;/code&gt;, since all other rows would be multiplied by the zeros corresponding to the singular values we eliminated from this approximation.</source>
          <target state="translated">다른 모든 행에는이 근사값에서 제거한 특이 값에 해당하는 0이 곱해지기 때문에 &lt;code&gt;Vt&lt;/code&gt; 의 처음 &lt;code&gt;k&lt;/code&gt; 개 행만 사용해야했습니다 .</target>
        </trans-unit>
        <trans-unit id="6653eb59198778eef2da729298a76ec147105c9f" translate="yes" xml:space="preserve">
          <source>Note that we picked datetimes that cross a DST boundary. Passing in a &lt;code&gt;pytz&lt;/code&gt; timezone object will print the appropriate offset</source>
          <target state="translated">우리는 DST 경계를 넘는 날짜 시간을 선택했습니다. &lt;code&gt;pytz&lt;/code&gt; 시간대 객체를 전달 하면 적절한 오프셋이 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="ff6a8871cdaa44abafcf71b9b33d5e54dbc5be42" translate="yes" xml:space="preserve">
          <source>Note that we support &lt;code&gt;DATA_TYPE*&lt;/code&gt; argout typemaps in 1D, but not 2D or 3D. This is because of a quirk with the &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; typemap syntax and cannot be avoided. Note that for these types of 1D typemaps, the Python function will take a single argument representing &lt;code&gt;DIM1&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;DATA_TYPE*&lt;/code&gt; argout 유형 맵은 1D로 지원 하지만 2D 또는 3D 는 지원 하지 않습니다. 이것은 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 타입 맵 구문에 문제가 있기 때문에 피할 수 없습니다. 이러한 유형의 1D 유형 맵의 경우 Python 함수는 &lt;code&gt;DIM1&lt;/code&gt; 을 나타내는 단일 인수를 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="11034ab53fb8599a1310cf4207146288e154fc02" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;a == 1&lt;/code&gt;, the normalization factor &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; goes over to &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; as it should.</source>
          <target state="translated">참고 때 &lt;code&gt;a == 1&lt;/code&gt; 정규화 인자 &lt;code&gt;v1 / (v1**2 - ddof * v2)&lt;/code&gt; 를 넘어 &lt;code&gt;1 / (np.sum(f) - ddof)&lt;/code&gt; 예상대로.</target>
        </trans-unit>
        <trans-unit id="9bc6e51338747705400e85f794a015c6a2357856" translate="yes" xml:space="preserve">
          <source>Note that when &lt;code&gt;out&lt;/code&gt; is given, the return value is &lt;code&gt;out&lt;/code&gt;:</source>
          <target state="translated">참고 &lt;code&gt;out&lt;/code&gt; 주어진다는, 반환 값은 &lt;code&gt;out&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="f3037f71e1ac80b9e7b6e511f234ab46281a3503" translate="yes" xml:space="preserve">
          <source>Note that when the &lt;code&gt;out&lt;/code&gt; parameter is given, the return value is &lt;code&gt;out&lt;/code&gt;:</source>
          <target state="translated">있습니다 &lt;code&gt;out&lt;/code&gt; 매개 변수가 제공되고, 반환 값은 &lt;code&gt;out&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="98530ea6c0be02d22c92fb9a99dc0d9aff053c64" translate="yes" xml:space="preserve">
          <source>Note that when type-casting is required and there is possible loss of information (e.g. when type-casting float to integer or complex to float), F2PY does not raise any exception. In complex to real type-casting only the real part of a complex number is used.</source>
          <target state="translated">유형 캐스팅이 필요하고 정보 손실 가능성이있을 때 (예 : float를 정수로 또는 복소수를 부동으로 유형 캐스팅하는 경우) F2PY는 예외를 발생시키지 않습니다. 복소수에서 실수로의 형변환에서는 복소수의 실수 부분 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="23123ffca4ff0e0a4a42f0653d7d9ea09cd17620" translate="yes" xml:space="preserve">
          <source>Note that whenever &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is used, &lt;code&gt;optional&lt;/code&gt; attribute is set automatically by F2PY.</source>
          <target state="translated">&lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; 이 사용될 때마다 &lt;code&gt;optional&lt;/code&gt; 속성은 F2PY에 의해 자동으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="ee0fb9212f997bf3174d26345ac37f18f11183de" translate="yes" xml:space="preserve">
          <source>Note that without the &lt;code&gt;np.ix_&lt;/code&gt; call, only the diagonal elements would be selected, as was used in the previous example. This difference is the most important thing to remember about indexing with multiple advanced indexes.</source>
          <target state="translated">&lt;code&gt;np.ix_&lt;/code&gt; 호출 이 없으면 이전 예제에서 사용 된 것처럼 대각선 요소 만 선택됩니다. 이 차이점은 여러 고급 인덱스를 사용하여 인덱싱 할 때 기억해야 할 가장 중요한 사항입니다.</target>
        </trans-unit>
        <trans-unit id="b5412b8a5c5e8aa3576931f3f122d134b272fe13" translate="yes" xml:space="preserve">
          <source>Note that you can eg. install NumPy to a temporary location and set the PYTHONPATH environment variable appropriately. Alternatively, if using Python virtual environments (via e.g. &lt;code&gt;conda&lt;/code&gt;, &lt;code&gt;virtualenv&lt;/code&gt; or the &lt;code&gt;venv&lt;/code&gt; module), installing numpy into a new virtual environment is recommended. All of the necessary dependencies for building the NumPy docs can be installed with:</source>
          <target state="translated">예를 들어 할 수 있습니다. NumPy를 임시 위치에 설치하고 PYTHONPATH 환경 변수를 적절하게 설정하십시오. 또는 Python 가상 환경을 사용하는 경우 (예 : &lt;code&gt;conda&lt;/code&gt; , &lt;code&gt;virtualenv&lt;/code&gt; 또는 &lt;code&gt;venv&lt;/code&gt; 모듈을 통해) 새 가상 환경에 numpy를 설치하는 것이 좋습니다. NumPy 문서를 빌드하는 데 필요한 모든 종속성은 다음을 사용하여 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b3edd40f42578284bf324094d774023e21eda09" translate="yes" xml:space="preserve">
          <source>Note that you get the time reversed, complex conjugated result when the two input sequences change places, i.e., &lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;c_{va}[k] = c^{*}_{av}[-k]&lt;/code&gt; : 두 입력 시퀀스가 ​​장소를 변경할 때 시간이 바뀐 복잡한 공액 결과를 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="dc4f36c08ee65f253c387ba6c97a8e2ba7041327" translate="yes" xml:space="preserve">
          <source>Note that, above, we use the &lt;em&gt;Python&lt;/em&gt; float object as a dtype. NumPy knows that &lt;code&gt;int&lt;/code&gt; refers to &lt;code&gt;np.int_&lt;/code&gt;, &lt;code&gt;bool&lt;/code&gt; means &lt;code&gt;np.bool_&lt;/code&gt;, that &lt;code&gt;float&lt;/code&gt; is &lt;code&gt;np.float_&lt;/code&gt; and &lt;code&gt;complex&lt;/code&gt; is &lt;code&gt;np.complex_&lt;/code&gt;. The other data-types do not have Python equivalents.</source>
          <target state="translated">위에서 &lt;em&gt;Python&lt;/em&gt; float 객체를 dtype으로 사용합니다 . NumPy는 &lt;code&gt;int&lt;/code&gt; 가 &lt;code&gt;np.int_&lt;/code&gt; , &lt;code&gt;bool&lt;/code&gt; 은 &lt;code&gt;np.bool_&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; 는 &lt;code&gt;np.float_&lt;/code&gt; , &lt;code&gt;complex&lt;/code&gt; 는 &lt;code&gt;np.complex_&lt;/code&gt; 를 의미한다는 것을 알고 있습니다. 다른 데이터 유형에는 Python에 해당하는 항목이 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba5c8fb85c6ca6f109e49af951ef9e99c064bb30" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">복소수의 경우 &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 는 제곱하기 전에 절대 값을 취하므로 결과는 항상 실수이고 음이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="67ff0ed45eb77e75fcc2a8d19c65a90ea73589bb" translate="yes" xml:space="preserve">
          <source>Note that, for complex numbers, &lt;a href=&quot;numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; takes the absolute value before squaring, so that the result is always real and nonnegative.</source>
          <target state="translated">복소수의 경우 &lt;a href=&quot;numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 는 제곱하기 전에 절대 값을 취하므로 결과는 항상 실수이고 음이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="70d9a8c143ac6b7cff84e338754a98ad2f6ecebc" translate="yes" xml:space="preserve">
          <source>Note that, in linear algebra, the dimension of a vector refers to the number of entries in an array. In NumPy, it instead defines the number of axes. For example, a 1D array is a vector such as &lt;code&gt;[1, 2, 3]&lt;/code&gt;, a 2D array is a matrix, and so forth.</source>
          <target state="translated">선형 대수에서 벡터의 차원은 배열의 항목 수를 나타냅니다. NumPy에서는 대신 축의 수를 정의합니다. 예를 들어 1D 배열은 &lt;code&gt;[1, 2, 3]&lt;/code&gt; 와 같은 벡터 이고 2D 배열은 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="65e93cf7b4b44a5b77a394d19e4276d3eaadfbbd" translate="yes" xml:space="preserve">
          <source>Note that, in the old API that was deprecated in version 1.7, this function had the return type &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">버전 1.7에서 폐기 된 이전 API에서이 함수의 반환 유형은 &lt;code&gt;int&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="7589de457b1bf436d7dda2480bd2ade65f60a09f" translate="yes" xml:space="preserve">
          <source>Note that, since NaN is unsortable, &lt;code&gt;xp&lt;/code&gt; also cannot contain NaNs.</source>
          <target state="translated">NaN은 정렬 불가능하므로 &lt;code&gt;xp&lt;/code&gt; 는 NaN도 포함 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c60913e9a1e7e3a8383e344378c5f7011cb280cd" translate="yes" xml:space="preserve">
          <source>Note that, when we modify x, y changes, but not z:</source>
          <target state="translated">x를 수정하면 y는 변경되지만 z는 변경되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a663ed58f0a095b16634564fa9a49f9e01516158" translate="yes" xml:space="preserve">
          <source>Note the array &lt;code&gt;dtype&lt;/code&gt; above of &lt;code&gt;&amp;gt;i2&lt;/code&gt;. The &lt;code&gt;&amp;gt;&lt;/code&gt; means &amp;lsquo;big-endian&amp;rsquo; (&lt;code&gt;&amp;lt;&lt;/code&gt; is little-endian) and &lt;code&gt;i2&lt;/code&gt; means &amp;lsquo;signed 2-byte integer&amp;rsquo;. For example, if our data represented a single unsigned 4-byte little-endian integer, the dtype string would be &lt;code&gt;&amp;lt;u4&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&amp;gt;i2&lt;/code&gt; 위의 &lt;code&gt;dtype&lt;/code&gt; 배열에 유의하십시오 . &lt;code&gt;&amp;gt;&lt;/code&gt; 수단 빅 엔디안 '( &lt;code&gt;&amp;lt;&lt;/code&gt; 리틀 엔디안)과 &lt;code&gt;i2&lt;/code&gt; 수단 &quot;서명 된 2 바이트 정수'. 예를 들어 데이터가 단일 부호없는 4 바이트 리틀 엔디안 정수를 나타내는 경우 dtype 문자열은 &lt;code&gt;&amp;lt;u4&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="cf42915649d8c90d2411a01638407672b7fa26fe" translate="yes" xml:space="preserve">
          <source>Note the array has not changed in memory:</source>
          <target state="translated">배열은 메모리에서 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="b45db9188e4e378f18f56f3c51bcc9db7db73d40" translate="yes" xml:space="preserve">
          <source>Note the normalization factor of &lt;code&gt;pi&lt;/code&gt; used in the definition. This is the most commonly used definition in signal processing. Use &lt;code&gt;sinc(x / np.pi)&lt;/code&gt; to obtain the unnormalized sinc function</source>
          <target state="translated">정의에 사용 된 &lt;code&gt;pi&lt;/code&gt; 의 정규화 계수를 확인 하십시오. 이것은 신호 처리에서 가장 일반적으로 사용되는 정의입니다. 사용 &lt;code&gt;sinc(x / np.pi)&lt;/code&gt; 얻었다 표준화 싱크 함수</target>
        </trans-unit>
        <trans-unit id="7868473a32c7a3c40bb3a312d03eac57c7a37527" translate="yes" xml:space="preserve">
          <source>Note the order of the parameters. &lt;a href=&quot;#numpy.arctan2&quot;&gt;&lt;code&gt;arctan2&lt;/code&gt;&lt;/a&gt; is defined also when &lt;code&gt;x2&lt;/code&gt; = 0 and at several other special points, obtaining values in the range &lt;code&gt;[-pi, pi]&lt;/code&gt;:</source>
          <target state="translated">매개 변수의 순서를 참고하십시오. &lt;a href=&quot;#numpy.arctan2&quot;&gt; &lt;code&gt;arctan2&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;x2&lt;/code&gt; = 0 일 때 와 다른 여러 특수 지점 에서도 정의 되어 &lt;code&gt;[-pi, pi]&lt;/code&gt; 범위의 값을 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="3999859e7edf0b6850997e2b685c81e41f6bf30b" translate="yes" xml:space="preserve">
          <source>Note the unusual interpretation of sample when an array_like:</source>
          <target state="translated">array_like 인 경우 샘플의 비정상적인 해석에 유의하십시오.</target>
        </trans-unit>
        <trans-unit id="4959b44a65b76595dc01fa81f812b74fb283e1a6" translate="yes" xml:space="preserve">
          <source>Note to those used to IDL or Fortran memory order as it relates to indexing. NumPy uses C-order indexing. That means that the last index usually represents the most rapidly changing memory location, unlike Fortran or IDL, where the first index represents the most rapidly changing location in memory. This difference represents a great potential for confusion.</source>
          <target state="translated">인덱싱과 관련하여 IDL 또는 Fortran 메모리 순서에 사용되는 항목에 유의하십시오. NumPy는 C 순서 인덱싱을 사용합니다. 즉, 첫 번째 인덱스가 메모리에서 가장 빠르게 변화하는 위치를 나타내는 Fortran 또는 IDL과 달리 마지막 인덱스는 일반적으로 가장 빠르게 변화하는 메모리 위치를 나타냅니다. 이 차이는 혼란을 일으킬 가능성이 크다는 것을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="111feaa1cd8151a1eb25cfbf746ea648c6673cdc" translate="yes" xml:space="preserve">
          <source>Note: Prior to NumPy 1.10.0, less strict checks were in place: missing core dimensions were created by prepending 1&amp;rsquo;s to the shape as necessary, core dimensions with the same label were broadcast together, and undetermined dimensions were created with size 1.</source>
          <target state="translated">참고 : NumPy 1.10.0 이전에는 덜 엄격한 검사가 수행되었습니다. 필요에 따라 1을 셰이프 앞에 추가하여 누락 된 코어 치수를 작성하고 동일한 레이블을 가진 코어 치수를 함께 브로드 캐스트하고 크기가 1 인 결정되지 않은 치수를 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="d21079fa664fe20f0bcb604959e5d77d12a5f0cb" translate="yes" xml:space="preserve">
          <source>Note: This function returns an array with at least one-dimension (1-d) so it will not preserve 0-d arrays.</source>
          <target state="translated">참고 :이 함수는 1 차원 이상의 배열을 반환하므로 0 차원 배열을 유지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a1a649c093516be216b047d4a6e07a8bfed16fc" translate="yes" xml:space="preserve">
          <source>Note: cannot use equality to test NaNs. E.g.:</source>
          <target state="translated">참고 : 같음을 사용하여 NaN을 테스트 할 수 없습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="046d816b2cced12f2b8341cea27cc367cd961583" translate="yes" xml:space="preserve">
          <source>Notes about the implementation algorithm (if needed).</source>
          <target state="translated">구현 알고리즘에 대한 참고 사항 (필요한 경우).</target>
        </trans-unit>
        <trans-unit id="1a08e04c0814f8e83ad56517e19ff3c0721fcd94" translate="yes" xml:space="preserve">
          <source>Notes and Warnings : If there are points in the docstring that deserve special emphasis, the reST directives for a note or warning can be used in the vicinity of the context of the warning (inside a section). Syntax:</source>
          <target state="translated">참고 및 경고 : 독 스트링에 특별히 강조 할만한 점이있는 경우 경고 컨텍스트 근처 (섹션 내부)에서 참고 또는 경고에 대한 reST 지시문을 사용할 수 있습니다. 통사론:</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="f57a8f12c91535f8b3bf8808e86d3137e06887d9" translate="yes" xml:space="preserve">
          <source>Nothing happens if &lt;code&gt;a&lt;/code&gt; is not a masked array.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 마스크 배열이 아닌 경우 아무 일도 일어나지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a10912bd64eec5f116a9c3fe1369faded07c9f4b" translate="yes" xml:space="preserve">
          <source>Nothing returned by this function.</source>
          <target state="translated">이 함수는 아무것도 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="15640e8dfd2dd046a0fb763219826f0e011ee43c" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="translated">&lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 출력 의 최종 요소가 실제 입력에 대해 두 번째 요소의 켤레 복소수임을 확인하십시오. 들면 &lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 이 대칭은 비 - 음의 주파수 조건을 계산하는데 이용된다.</target>
        </trans-unit>
        <trans-unit id="184b0a59161cac7480934a6869880704e9ffc1c5" translate="yes" xml:space="preserve">
          <source>Notice how the final element of the &lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt;&lt;code&gt;fft&lt;/code&gt;&lt;/a&gt; output is the complex conjugate of the second element, for real input. For &lt;a href=&quot;#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;, this symmetry is exploited to compute only the non-negative frequency terms.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.fft#numpy.fft.fft&quot;&gt; &lt;code&gt;fft&lt;/code&gt; &lt;/a&gt; 출력 의 최종 요소가 실제 입력을 위해 두 번째 요소의 복합 켤레 인 방법에 주목하십시오 . 들면 &lt;a href=&quot;#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 이 대칭은 비 - 음의 주파수 조건을 계산하는데 이용된다.</target>
        </trans-unit>
        <trans-unit id="9d24afb4770f955e79718f663c68d81c2708b5a7" translate="yes" xml:space="preserve">
          <source>Notice how the last term in the input to the ordinary &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt; is the complex conjugate of the second term, and the output has zero imaginary part everywhere. When calling &lt;a href=&quot;#numpy.fft.irfft&quot;&gt;&lt;code&gt;irfft&lt;/code&gt;&lt;/a&gt;, the negative frequencies are not specified, and the output array is purely real.</source>
          <target state="translated">일반 &lt;a href=&quot;numpy.fft.ifft#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 에 대한 입력의 마지막 항이 두 번째 항의 복소수 복소수이며 출력이 어디에서나 가상의 부분이 없는지 확인하십시오. &lt;a href=&quot;#numpy.fft.irfft&quot;&gt; &lt;code&gt;irfft&lt;/code&gt; 를&lt;/a&gt; 호출 하면 음의 주파수가 지정되지 않고 출력 배열은 순수하게 실제입니다.</target>
        </trans-unit>
        <trans-unit id="ed100c4959db20fe84fd87eecf37518e6739a62d" translate="yes" xml:space="preserve">
          <source>Notice that Cython is an extension-module generator only. Unlike f2py, it includes no automatic facility for compiling and linking the extension module (which must be done in the usual fashion). It does provide a modified distutils class called &lt;code&gt;build_ext&lt;/code&gt; which lets you build an extension module from a &lt;code&gt;.pyx&lt;/code&gt; source. Thus, you could write in a &lt;code&gt;setup.py&lt;/code&gt; file:</source>
          <target state="translated">Cython은 확장 모듈 생성기 일뿐입니다. f2py와 달리 확장 모듈을 컴파일하고 연결하는 자동 기능이 없습니다 (일반적인 방식으로 수행되어야 함). &lt;code&gt;.pyx&lt;/code&gt; 소스 에서 확장 모듈을 빌드 할 수있는 &lt;code&gt;build_ext&lt;/code&gt; 라는 수정 된 distutils 클래스를 제공합니다 . 따라서 &lt;code&gt;setup.py&lt;/code&gt; 파일에 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0cb564d7e3f343c55b0fae22523656706209711d" translate="yes" xml:space="preserve">
          <source>Notice that the above 3 flags are defined so that a new, well- behaved array has these flags defined as true.</source>
          <target state="translated">위의 3 개 플래그는 올바르게 작동하는 새로운 배열에 이러한 플래그가 true로 정의되도록 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="933e026efdbeaa2316ba75443c7fec80dcb22b12" translate="yes" xml:space="preserve">
          <source>Notice that the full PyArrayObject is used as the first entry in order to ensure that the binary layout of instances of the new type is identical to the PyArrayObject.</source>
          <target state="translated">새 유형의 인스턴스의 이진 레이아웃이 PyArrayObject와 동일한 지 확인하기 위해 전체 PyArrayObject가 첫 번째 항목으로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="847535dd495885c3e2ed82b62e1abcb626ece607" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the maximum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">초기 값은 빈 iterables에만 사용되는 기본 인수 Python의 max 함수와 달리 최대 값이 결정되는 요소 중 하나로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="98ab17cc2cf9317019aeddb2bbabfef19cd3a629" translate="yes" xml:space="preserve">
          <source>Notice that the initial value is used as one of the elements for which the minimum is determined, unlike for the default argument Python&amp;rsquo;s max function, which is only used for empty iterables.</source>
          <target state="translated">초기 값은 빈 iterables에만 사용되는 기본 인수 Python의 max 함수와 달리 최소값이 결정되는 요소 중 하나로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7a3bf5045be1e646ff0b1cf93fe99f156e23026b" translate="yes" xml:space="preserve">
          <source>Notice that the resulting wrapper to &lt;code&gt;FIB&lt;/code&gt; is as &amp;ldquo;smart&amp;rdquo; as in previous case:</source>
          <target state="translated">&lt;code&gt;FIB&lt;/code&gt; 에 대한 결과 래퍼 는 이전 사례와 같이 &quot;스마트&quot;합니다.</target>
        </trans-unit>
        <trans-unit id="492b4a295e5558fecc78ff637653ffa8b09ca97f" translate="yes" xml:space="preserve">
          <source>Notice that the return type is a standard &lt;code&gt;numpy.ndarray&lt;/code&gt;.</source>
          <target state="translated">반환 유형은 표준 &lt;code&gt;numpy.ndarray&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="95fad7b0d0de8433821f8ae84856c18eccd090df" translate="yes" xml:space="preserve">
          <source>Notice that the second &lt;code&gt;usercode&lt;/code&gt; statement must be defined inside an &lt;code&gt;interface&lt;/code&gt; block and where the module dictionary is available through the variable &lt;code&gt;d&lt;/code&gt; (see &lt;code&gt;f2py var.pyf&lt;/code&gt;-generated &lt;code&gt;varmodule.c&lt;/code&gt; for additional details).</source>
          <target state="translated">제 알 &lt;code&gt;usercode&lt;/code&gt; 의 문 내측 정의되어야 &lt;code&gt;interface&lt;/code&gt; 모듈 딕셔너리는 변수를 통해 사용 가능 블록 &lt;code&gt;d&lt;/code&gt; (참조 &lt;code&gt;f2py var.pyf&lt;/code&gt; -generated &lt;code&gt;varmodule.c&lt;/code&gt; 추가 세부 사항).</target>
        </trans-unit>
        <trans-unit id="8b99552cfe5ebf21e89509d47400467670883a7d" translate="yes" xml:space="preserve">
          <source>Notice that this isn&amp;rsquo;t the same as Python&amp;rsquo;s &lt;code&gt;default&lt;/code&gt; argument.</source>
          <target state="translated">이것은 파이썬의 &lt;code&gt;default&lt;/code&gt; 인수 와 동일하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="86ca463fe236705953b4cb323c8e44dbe110c67f" translate="yes" xml:space="preserve">
          <source>Notice the automatic conversion to the correct format that occurred.</source>
          <target state="translated">발생한 올바른 형식으로 자동 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="75917695664ab58d7b5d23aff9664353427c773e" translate="yes" xml:space="preserve">
          <source>Now all those people can do:</source>
          <target state="translated">이제 모든 사람들이 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c558c7187dbb9215bbd627b6f1b25246d5a8c6fd" translate="yes" xml:space="preserve">
          <source>Now assume you attached &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; to the source tree, then the infrastructure should generate a temporary config header called &lt;strong&gt;hello.dispatch.h&lt;/strong&gt; that can be reached by any source in the source tree, and it should contain the following code :</source>
          <target state="translated">이제 &lt;strong&gt;hello.dispatch.c&lt;/strong&gt; 를 소스 트리에 첨부 &lt;strong&gt;했다고&lt;/strong&gt; 가정하면 인프라는 소스 트리의 모든 소스에서 도달 할 수있는 &lt;strong&gt;hello.dispatch.h&lt;/strong&gt; 라는 임시 구성 헤더를 생성 해야하며 다음 코드를 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="70bfcb10a3d92ea0cb076fb11e889a3f7696c2f5" translate="yes" xml:space="preserve">
          <source>Now editing a Python source file in NumPy allows you to immediately test and use your changes (in &lt;code&gt;.py&lt;/code&gt; files), by simply restarting the interpreter.</source>
          <target state="translated">이제 NumPy에서 Python 소스 파일을 편집 하면 인터프리터를 다시 시작 하여 변경 사항 ( &lt;code&gt;.py&lt;/code&gt; 파일) 을 즉시 테스트하고 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="02f1d525547aac9ec4fc5c41b72c69bb1f2c8bfa" translate="yes" xml:space="preserve">
          <source>Now go to your fork and make a pull request for the branch.</source>
          <target state="translated">이제 포크로 이동하여 브랜치에 대한 풀 요청을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="59497d295295e7471278d2cef4e18af42ce6655b" translate="yes" xml:space="preserve">
          <source>Now it must be a tuple whose first element is a string with &amp;ldquo;PyArrayInterface Version #&amp;rdquo; and whose second element is the object exposing the array.</source>
          <target state="translated">이제 첫 번째 요소가 &quot;PyArrayInterface Version #&quot;이있는 문자열이고 두 번째 요소가 배열을 노출하는 객체 인 튜플이어야합니다.</target>
        </trans-unit>
        <trans-unit id="1562b378f268443ad7a3ad7b80f355a383c82822" translate="yes" xml:space="preserve">
          <source>Now let&amp;rsquo;s tackle &lt;code&gt;__array_function__&lt;/code&gt;. We&amp;rsquo;ll create dict that maps numpy functions to our custom variants.</source>
          <target state="translated">이제 &lt;code&gt;__array_function__&lt;/code&gt; 을 다루 겠습니다 . numpy 함수를 사용자 지정 변형에 매핑하는 dict를 만들 것입니다.</target>
        </trans-unit>
        <trans-unit id="a4854dca388c79f7bb12e14a8a161b7a492c001a" translate="yes" xml:space="preserve">
          <source>Now multiply a diagonal matrix by &lt;code&gt;Q&lt;/code&gt; on one side and by &lt;code&gt;Q.T&lt;/code&gt; on the other:</source>
          <target state="translated">이제 대각선 행렬 에 한쪽 에 &lt;code&gt;Q&lt;/code&gt; 를 곱하고 다른쪽에 &lt;code&gt;Q.T&lt;/code&gt; 를 곱하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9aee1cf03a85f2c9234d34f54fa504a0ad159f3" translate="yes" xml:space="preserve">
          <source>Now our custom array type passes through numpy functions.</source>
          <target state="translated">이제 사용자 지정 배열 유형이 numpy 함수를 통과합니다.</target>
        </trans-unit>
        <trans-unit id="653b19d1d4883b62177051122cc7aeebf0172920" translate="yes" xml:space="preserve">
          <source>Now returns an empty list instead of None for a fully masked array</source>
          <target state="translated">이제 완전히 마스크 된 배열에 대해 None 대신 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ba8aa04151c2a1b06d4ae8fedf1218b84591b899" translate="yes" xml:space="preserve">
          <source>Now that our data has been masked, let&amp;rsquo;s try summing up all the cases in China:</source>
          <target state="translated">이제 데이터가 마스킹되었으므로 중국의 모든 사례를 요약 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ec58b2146d74f6a1fb2a7b312c2b04a59b639bdc" translate="yes" xml:space="preserve">
          <source>Now the array &lt;em&gt;has&lt;/em&gt; changed in memory:</source>
          <target state="translated">이제 배열 &lt;em&gt;이&lt;/em&gt; 메모리에서 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="d5721d6e90bb96b54d081e10fa69a0fa60aa41ba" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded before proceeding. There should currently be 21 of them at &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy/files&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy/files&lt;/a&gt;, 3 for Mac, 6 for Windows, and 12 for Linux.</source>
          <target state="translated">이제 기다려. 소요 된 시간에 긴장이된다면 (빌드하는 데 시간이 걸릴 수 있음) &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; 에 제공된 링크 를 따라 빌드 상태를 확인하여 빌드 진행 상황을 확인할 수 있습니다. 진행하기 전에 필요한 모든 휠이 제작 및 업로드되었는지 확인하십시오. 현재 &lt;a href=&quot;https://anaconda.org/multibuild-wheels-staging/numpy/files&quot;&gt;https://anaconda.org/multibuild-wheels-staging/numpy/files에&lt;/a&gt; 21 개, Mac 용 3 개, Windows 용 6 개, Linux 용 12 개가 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="699a899259937ad1e936681606eb842fe76f5cf4" translate="yes" xml:space="preserve">
          <source>Now wait. If you get nervous at the amount of time taken &amp;ndash; the builds can take a while &amp;ndash; you can check the build progress by following the links provided at &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; to check the build status. Check if all the needed wheels have been built and uploaded to the staging repository before proceeding.</source>
          <target state="translated">이제 기다려. 소요 된 시간에 긴장이된다면 (빌드하는 데 시간이 걸릴 수 있음) &lt;a href=&quot;https://github.com/MacPython/numpy-wheels&quot;&gt;https://github.com/MacPython/numpy-wheels&lt;/a&gt; 에 제공된 링크 를 따라 빌드 상태를 확인하여 빌드 진행 상황을 확인할 수 있습니다. 계속하기 전에 필요한 모든 휠이 빌드되고 스테이징 저장소에 업로드되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3a3bd4e9414b13e38275e5df8769440d431b61f" translate="yes" xml:space="preserve">
          <source>Now we are ready to apply the SVD:</source>
          <target state="translated">이제 SVD를 적용 할 준비가되었습니다.</target>
        </trans-unit>
        <trans-unit id="747aa74212ee1540da17718b2993f3a2e84b8796" translate="yes" xml:space="preserve">
          <source>Now we can correctly sum entries for mainland China:</source>
          <target state="translated">이제 중국 본토에 대한 항목을 올바르게 합산 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1f39ae5d13c5ad14506d67df0c86ac586848a064" translate="yes" xml:space="preserve">
          <source>Now we can iterate over &lt;code&gt;a_itor&lt;/code&gt;, and it will return arrays of size two. Since &lt;code&gt;buf_size&lt;/code&gt; was smaller than any dimension, the first dimension will be iterated over first:</source>
          <target state="translated">이제 &lt;code&gt;a_itor&lt;/code&gt; 반복하고 크기가 2 인 배열을 반환합니다. 이후 &lt;code&gt;buf_size&lt;/code&gt; 모든 사이즈보다 작습니다, 첫 번째 차원은 첫 번째 반복 한을 넘는 것입니다 :</target>
        </trans-unit>
        <trans-unit id="bf7432fe9f7d1de2712d47dd480396ec30fe9d54" translate="yes" xml:space="preserve">
          <source>Now we create an array &lt;code&gt;b1&lt;/code&gt; by slicing &lt;code&gt;a&lt;/code&gt; and modify the first element of &lt;code&gt;b1&lt;/code&gt;. This will modify the corresponding element in &lt;code&gt;a&lt;/code&gt; as well!</source>
          <target state="translated">이제 배열 생성 &lt;code&gt;b1&lt;/code&gt; 슬라이싱하여 &lt;code&gt;a&lt;/code&gt; 그리고 제 수정 요소 &lt;code&gt;b1&lt;/code&gt; . 이것은에서 해당 요소를 수정합니다 아니라! &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e76ea020d2e734b4cfb0d824a7cb637d663128ae" translate="yes" xml:space="preserve">
          <source>Now we want to do the same kind of operation, but to all three colors. Our first instinct might be to repeat the same operation we did above to each color matrix individually. However, NumPy&amp;rsquo;s &lt;code&gt;broadcasting&lt;/code&gt; takes care of this for us.</source>
          <target state="translated">이제 우리는 세 가지 색상 모두에 대해 동일한 종류의 작업을 수행하려고합니다. 우리의 첫 번째 본능은 각 색상 매트릭스에 대해 위에서 한 것과 동일한 작업을 개별적으로 반복하는 것입니다. 그러나 NumPy의 &lt;code&gt;broadcasting&lt;/code&gt; 이 우리를 위해 처리합니다.</target>
        </trans-unit>
        <trans-unit id="be6dd4a7bf7c5c8f068a6e558d5c8ec36b5c692a" translate="yes" xml:space="preserve">
          <source>Now we write implementations of numpy functions for &lt;code&gt;DiagonalArray&lt;/code&gt;. For completeness, to support the usage &lt;code&gt;arr.sum()&lt;/code&gt; add a method &lt;code&gt;sum&lt;/code&gt; that calls &lt;code&gt;numpy.sum(self)&lt;/code&gt;, and the same for &lt;code&gt;mean&lt;/code&gt;.</source>
          <target state="translated">이제 &lt;code&gt;DiagonalArray&lt;/code&gt; 에 대한 numpy 함수의 구현을 작성합니다 . 완전성을 위해 &lt;code&gt;arr.sum()&lt;/code&gt; 사용법을 지원하려면 &lt;code&gt;numpy.sum(self)&lt;/code&gt; 를 호출 하는 메서드 &lt;code&gt;sum&lt;/code&gt; 를 추가하고 &lt;code&gt;mean&lt;/code&gt; 에 대해서도 동일합니다 .</target>
        </trans-unit>
        <trans-unit id="8dc172f812b48628145c33844eeb0c5e41365a9a" translate="yes" xml:space="preserve">
          <source>Now you are ready to generate the docs, so write:</source>
          <target state="translated">이제 문서를 생성 할 준비가되었으므로 다음과 같이 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="2ae5aab236f57788a41324d9fac04d9f996796fb" translate="yes" xml:space="preserve">
          <source>Now you can do the following to test your module:</source>
          <target state="translated">이제 다음을 수행하여 모듈을 테스트 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="93e01758207ef7eac9898579c0a0ad53ac2cbd99" translate="yes" xml:space="preserve">
          <source>Now you can make the release commit and tag. We recommend you don&amp;rsquo;t push the commit or tag immediately, just in case you need to do more cleanup. We prefer to defer the push of the tag until we&amp;rsquo;re confident this is the exact form of the released code (see: &lt;a href=&quot;#push-tag-and-commit&quot;&gt;Push the release tag and commit&lt;/a&gt;):</source>
          <target state="translated">이제 릴리스 커밋 및 태그를 만들 수 있습니다. 더 많은 정리가 필요한 경우를 대비하여 커밋이나 태그를 즉시 푸시하지 않는 것이 좋습니다. 이것이 릴리스 된 코드의 정확한 형식이라고 확신 할 때까지 태그 푸시를 연기하는 것을 선호합니다 (참조 : &lt;a href=&quot;#push-tag-and-commit&quot;&gt;릴리스 태그 푸시 및 커밋 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d14145f90c1ed14c03e17b7327ce3f007834c2f" translate="yes" xml:space="preserve">
          <source>Now you need to apply the changes from master to this branch using &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html&quot;&gt;git cherry-pick&lt;/a&gt;:</source>
          <target state="translated">이제 &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-cherry-pick.html&quot;&gt;git cherry-pick을&lt;/a&gt; 사용하여 master에서이 브랜치로 변경 사항을 적용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="da29f0210a502c721dd0dd5c83f6b4fa9f50c915" translate="yes" xml:space="preserve">
          <source>Now you want to connect to the upstream &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; repository, so you can merge in changes from trunk.</source>
          <target state="translated">이제 업스트림 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt; 리포지토리 에 연결하여 트렁크의 변경 사항을 병합 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="99261818f6547b5ed54374d3a2426ea44c25412d" translate="yes" xml:space="preserve">
          <source>Now,</source>
          <target state="translated">Now,</target>
        </trans-unit>
        <trans-unit id="54e3f4943855839d7ff1038b70ea21091b66f2f7" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;china_mask&lt;/code&gt; is an array of boolean values (&lt;code&gt;True&lt;/code&gt; or &lt;code&gt;False&lt;/code&gt;); we can check that the indices are what we wanted with the &lt;a href=&quot;../reference/generated/numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt;&lt;code&gt;ma.nonzero&lt;/code&gt;&lt;/a&gt; method for masked arrays:</source>
          <target state="translated">이제 &lt;code&gt;china_mask&lt;/code&gt; 는 부울 값 ( &lt;code&gt;True&lt;/code&gt; 또는 &lt;code&gt;False&lt;/code&gt; ) 의 배열입니다 . 마스크 배열에 대해 &lt;a href=&quot;../reference/generated/numpy.ma.nonzero#numpy.ma.nonzero&quot;&gt; &lt;code&gt;ma.nonzero&lt;/code&gt; &lt;/a&gt; 메서드를 사용하여 인덱스가 원하는 것인지 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1a849066ed1f230f65474fee40b0e94a7d98faa2" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;git remote -v&lt;/code&gt; will show two remote repositories named:</source>
          <target state="translated">이제 &lt;code&gt;git remote -v&lt;/code&gt; 는 다음과 같은 두 개의 원격 저장소를 표시합니다.</target>
        </trans-unit>
        <trans-unit id="eb1e590b12ac969204974436ab86b73a66b484b9" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;h&lt;/code&gt; is called a &lt;code&gt;House&lt;/code&gt; instance. An instance is therefore a specific realisation of a class.</source>
          <target state="translated">이제 &lt;code&gt;h&lt;/code&gt; 는 &lt;code&gt;House&lt;/code&gt; 인스턴스 라고 합니다. 따라서 인스턴스는 클래스의 특정 실현입니다.</target>
        </trans-unit>
        <trans-unit id="c9d9c91fe6808bc153fedc3a3be54f274b18ccbd" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img&lt;/code&gt; is a NumPy array, as we can see when using the &lt;code&gt;type&lt;/code&gt; function:</source>
          <target state="translated">이제 &lt;code&gt;img&lt;/code&gt; 는 &lt;code&gt;type&lt;/code&gt; 함수를 사용할 때 볼 수 있듯이 NumPy 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="52ef6adb474c75b77cfec6493b6e37127e46dd0c" translate="yes" xml:space="preserve">
          <source>Now, &lt;code&gt;img_gray&lt;/code&gt; has shape</source>
          <target state="translated">이제 &lt;code&gt;img_gray&lt;/code&gt; 모양이</target>
        </trans-unit>
        <trans-unit id="9b5e3ab134c32e63476e019b6cc1db7108c6756a" translate="yes" xml:space="preserve">
          <source>Now, applying the &lt;a href=&quot;../reference/generated/numpy.linalg.svd#numpy.linalg.svd&quot;&gt;&lt;code&gt;linalg.svd&lt;/code&gt;&lt;/a&gt; function to this matrix, we obtain the following decomposition:</source>
          <target state="translated">이제이 행렬에 &lt;a href=&quot;../reference/generated/numpy.linalg.svd#numpy.linalg.svd&quot;&gt; &lt;code&gt;linalg.svd&lt;/code&gt; &lt;/a&gt; 함수를 적용 하여 다음과 같은 분해를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="4103944902505e88c56a448e8658e10eed8eb1b4" translate="yes" xml:space="preserve">
          <source>Now, do one experiment throwing the dice 10 time, and 10 times again, and another throwing the dice 20 times, and 20 times again:</source>
          <target state="translated">이제 주사위 하나를 10 번, 다시 10 번 던지고 다른 하나는 주사위를 20 번, 20 번 던지는 실험을합니다 :</target>
        </trans-unit>
        <trans-unit id="c02651c46a41ca9f07ac3b1090a827bd1aa0997e" translate="yes" xml:space="preserve">
          <source>Now, if we want to create a very simple approximation for this data, we should take into account the valid entries around the invalid ones. So first let&amp;rsquo;s select the dates for which the data is valid. Note that we can use the mask from the &lt;code&gt;china_total&lt;/code&gt; masked array to index the dates array:</source>
          <target state="translated">이제이 데이터에 대한 매우 간단한 근사치를 생성하려면 유효하지 않은 항목 주변의 유효한 항목을 고려해야합니다. 따라서 먼저 데이터가 유효한 날짜를 선택해 보겠습니다. &lt;code&gt;china_total&lt;/code&gt; 마스크 배열 의 마스크를 사용 하여 날짜 배열을 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d2ea454c7baf7564ea6fcb77c917ce2269209f53" translate="yes" xml:space="preserve">
          <source>Now, if we wish to rebuild the full SVD (with no approximation), we can do</source>
          <target state="translated">이제 전체 SVD (근사치 없음)를 다시 빌드하려면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79503e4a7bcf0bb6045b13fb5038f72cea2083ab" translate="yes" xml:space="preserve">
          <source>Now, the function can be called in a much more robust way:</source>
          <target state="translated">이제 함수를 훨씬 더 강력한 방식으로 호출 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a0435f8dfb75dd633a8592e953b3a61869c66ed" translate="yes" xml:space="preserve">
          <source>Now, throw the dice 20 times, and 20 times again:</source>
          <target state="translated">이제 주사위를 20 번, 다시 20 번 던지십시오 :</target>
        </trans-unit>
        <trans-unit id="e886cde483c798665f26429d663d928161ab6acf" translate="yes" xml:space="preserve">
          <source>Now, to build our approximation, we first need to make sure that our singular values are ready for multiplication, so we build our &lt;code&gt;Sigma&lt;/code&gt; matrix similarly to what we did before. The &lt;code&gt;Sigma&lt;/code&gt; array must have dimensions &lt;code&gt;(3, 768, 1024)&lt;/code&gt;. In order to add the singular values to the diagonal of &lt;code&gt;Sigma&lt;/code&gt;, we will use the &lt;code&gt;fill_diagonal&lt;/code&gt; function from NumPy, using each of the 3 rows in &lt;code&gt;s&lt;/code&gt; as the diagonal for each of the 3 matrices in &lt;code&gt;Sigma&lt;/code&gt;:</source>
          <target state="translated">이제 근사치를 작성하려면 먼저 특이 값이 곱셈을위한 준비가되었는지 확인해야합니다. 따라서 이전에했던 것과 유사하게 &lt;code&gt;Sigma&lt;/code&gt; 행렬을 작성합니다. &lt;code&gt;Sigma&lt;/code&gt; 배열 치수 있어야 &lt;code&gt;(3, 768, 1024)&lt;/code&gt; . 의 대각선에 특이 값을 추가하기 위해 &lt;code&gt;Sigma&lt;/code&gt; , 우리는 사용 &lt;code&gt;fill_diagonal&lt;/code&gt; 에서 3 행의 각각을 사용하여, NumPy와의 기능 &lt;code&gt;s&lt;/code&gt; 에서 3 행렬들 각각에 대한 대각 등 &lt;code&gt;Sigma&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="565f463048564fa2ff4bfcbc1dc8859dde3aeacc" translate="yes" xml:space="preserve">
          <source>Now, to do the approximation, we must choose only the first &lt;code&gt;k&lt;/code&gt; singular values for each color channel. This can be done using the following syntax:</source>
          <target state="translated">이제 근사를 수행하려면 각 색상 채널에 대해 처음 &lt;code&gt;k&lt;/code&gt; 개의 특이 값 만 선택해야합니다 . 다음 구문을 사용하여 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="53a0393525e01988d9f9cb1a6b35b57bda883e2e" translate="yes" xml:space="preserve">
          <source>Now, we create indices to manipulate a 3-D array:</source>
          <target state="translated">이제 3 차원 배열을 조작하기위한 인덱스를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c7902891716f837cf46001e7e450e13862b8420f" translate="yes" xml:space="preserve">
          <source>Now, we want to check if the reconstructed &lt;code&gt;U @ Sigma @ Vt&lt;/code&gt; is close to the original &lt;code&gt;img_gray&lt;/code&gt; matrix.</source>
          <target state="translated">이제 재구성 된 &lt;code&gt;U @ Sigma @ Vt&lt;/code&gt; 가 원래 &lt;code&gt;img_gray&lt;/code&gt; 행렬에 가까운 지 확인하고 싶습니다 .</target>
        </trans-unit>
        <trans-unit id="5f06f8937e93eb4f141bfb2a705595fcdf67626f" translate="yes" xml:space="preserve">
          <source>Now, when we define a function, we can &amp;ldquo;decorate&amp;rdquo; it using &lt;code&gt;log&lt;/code&gt;:</source>
          <target state="translated">이제 함수를 정의 할 때 &lt;code&gt;log&lt;/code&gt; 를 사용하여 &quot;장식&quot;할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="4cc7b2e6b23e5632ad7c5158bf566b73a38ffebf" translate="yes" xml:space="preserve">
          <source>Now, whenever you want to switch to the virtual environment, you can use the command &lt;code&gt;source numpy-dev/bin/activate&lt;/code&gt;, and &lt;code&gt;deactivate&lt;/code&gt; to exit from the virtual environment and back to your previous shell.</source>
          <target state="translated">이제 가상 환경으로 전환 할 때마다 &lt;code&gt;source numpy-dev/bin/activate&lt;/code&gt; 명령을 사용 하고 &lt;code&gt;deactivate&lt;/code&gt; 하여 가상 환경을 종료하고 이전 셸로 돌아갈 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="198b66dda9dfc0b0d1d736fde28782e16d5483f5" translate="yes" xml:space="preserve">
          <source>Now, you can go ahead and repeat this experiment with other values of &lt;code&gt;k&lt;/code&gt;, and each of your experiments should give you a slightly better (or worse) image depending on the value you choose.</source>
          <target state="translated">이제 &lt;code&gt;k&lt;/code&gt; 의 다른 값으로이 실험을 반복 할 수 있으며, 각 실험은 선택한 값에 따라 약간 더 나은 (또는 더 나쁜) 이미지를 제공 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="1bd61014c9008087889fd725668b3c8d4970463d" translate="yes" xml:space="preserve">
          <source>Now, you can run:</source>
          <target state="translated">이제 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a61d4e29999f717e20a2ffa02fda03db9cc09177" translate="yes" xml:space="preserve">
          <source>Now:</source>
          <target state="translated">Now:</target>
        </trans-unit>
        <trans-unit id="8b7fcaae0aa22776c49d066644c2b1975dfe6da1" translate="yes" xml:space="preserve">
          <source>NpyAuxData (C type)</source>
          <target state="translated">NpyAuxData (C 유형)</target>
        </trans-unit>
        <trans-unit id="34a30eac154cabdf7a90e0db5f0c2478a5065e89" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc</source>
          <target state="translated">NpyAuxData_CloneFunc</target>
        </trans-unit>
        <trans-unit id="34e8b7730172c8e3d3adc73c058819a6f92f117f" translate="yes" xml:space="preserve">
          <source>NpyAuxData_CloneFunc (C type)</source>
          <target state="translated">NpyAuxData_CloneFunc (C 유형)</target>
        </trans-unit>
        <trans-unit id="4c4fef0ec03464a7b11bd65b370680102da32d76" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc</source>
          <target state="translated">NpyAuxData_FreeFunc</target>
        </trans-unit>
        <trans-unit id="97e892e902cfe2bd9ee7b43a2c987c5ba8273d80" translate="yes" xml:space="preserve">
          <source>NpyAuxData_FreeFunc (C type)</source>
          <target state="translated">NpyAuxData_FreeFunc (C 유형)</target>
        </trans-unit>
        <trans-unit id="4e3a83bac5637b7f866d954fa04d5054091c36cc" translate="yes" xml:space="preserve">
          <source>NpyIter</source>
          <target state="translated">NpyIter</target>
        </trans-unit>
        <trans-unit id="82a0508669bbb7771cac0c8d3e2c866a68070845" translate="yes" xml:space="preserve">
          <source>NpyIter (C type)</source>
          <target state="translated">NpyIter (C 유형)</target>
        </trans-unit>
        <trans-unit id="38c5db212050a32c003c23a2e475d5c5ce78e2df" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew (C function)</source>
          <target state="translated">NpyIter_AdvancedNew (C 함수)</target>
        </trans-unit>
        <trans-unit id="8af20c5dee7afb2fdfe083ea49a8e985dcebda12" translate="yes" xml:space="preserve">
          <source>NpyIter_AdvancedNew()</source>
          <target state="translated">NpyIter_AdvancedNew()</target>
        </trans-unit>
        <trans-unit id="4b68aef05b915f8c4d85c85d6e5e698604e22d5b" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy (C function)</source>
          <target state="translated">NpyIter_Copy (C 함수)</target>
        </trans-unit>
        <trans-unit id="b997b8b2b511720cd1069c024299823f83302c9e" translate="yes" xml:space="preserve">
          <source>NpyIter_Copy()</source>
          <target state="translated">NpyIter_Copy()</target>
        </trans-unit>
        <trans-unit id="dead001979a949af7bc216d40e317c11b1627b50" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides (C function)</source>
          <target state="translated">NpyIter_CreateCompatibleStrides (C 함수)</target>
        </trans-unit>
        <trans-unit id="3fb78c3f62b576c1af874d751640db8eff8c9979" translate="yes" xml:space="preserve">
          <source>NpyIter_CreateCompatibleStrides()</source>
          <target state="translated">NpyIter_CreateCompatibleStrides()</target>
        </trans-unit>
        <trans-unit id="bd5f39811c4a438e4611fe7324c733dae8e18e94" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate (C function)</source>
          <target state="translated">NpyIter_Deallocate (C 함수)</target>
        </trans-unit>
        <trans-unit id="6ad45ab8ae95fe7da10aaac502dcfd57dbf572fa" translate="yes" xml:space="preserve">
          <source>NpyIter_Deallocate()</source>
          <target state="translated">NpyIter_Deallocate()</target>
        </trans-unit>
        <trans-unit id="9e58f50382b305a7c644ed30e9dbf73ab673b658" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop (C function)</source>
          <target state="translated">NpyIter_EnableExternalLoop (C 함수)</target>
        </trans-unit>
        <trans-unit id="e39e8d7265758ca02d07e1e363c5debc0123f813" translate="yes" xml:space="preserve">
          <source>NpyIter_EnableExternalLoop()</source>
          <target state="translated">NpyIter_EnableExternalLoop()</target>
        </trans-unit>
        <trans-unit id="329ae7e5f8f4f861595a2f3783d09679b3a68e75" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray (C function)</source>
          <target state="translated">NpyIter_GetAxisStrideArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="bb2c139e38956ebdf5ce855ccf3149ea641f8b05" translate="yes" xml:space="preserve">
          <source>NpyIter_GetAxisStrideArray()</source>
          <target state="translated">NpyIter_GetAxisStrideArray()</target>
        </trans-unit>
        <trans-unit id="11e9224b826aa03f20a5575963d1a61c21bde7ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize (C function)</source>
          <target state="translated">NpyIter_GetBufferSize (C 함수)</target>
        </trans-unit>
        <trans-unit id="1c71d1d0e6fd6d70024c7dd931246be434c73502" translate="yes" xml:space="preserve">
          <source>NpyIter_GetBufferSize()</source>
          <target state="translated">NpyIter_GetBufferSize()</target>
        </trans-unit>
        <trans-unit id="efd6b812e98d492f8edfd24e4ba12b4a6b2f06ff" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray (C function)</source>
          <target state="translated">NpyIter_GetDataPtrArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="87a85869fc34454e6204a9b83263efd25b3b19a8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDataPtrArray()</source>
          <target state="translated">NpyIter_GetDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="4818f80260586e06d259cc413bb89e872d11d852" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray (C function)</source>
          <target state="translated">NpyIter_GetDescrArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="62cedbb3cbc591b2ae980b3bc6c8c39f71d0c16b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetDescrArray()</source>
          <target state="translated">NpyIter_GetDescrArray()</target>
        </trans-unit>
        <trans-unit id="b2e4a49c346fdbeb713aed872c544759f393dc2a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex (C function)</source>
          <target state="translated">NpyIter_GetGetMultiIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="4d029059dda4dad1438f1bd80a75d454f99834d6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetGetMultiIndex()</source>
          <target state="translated">NpyIter_GetGetMultiIndex()</target>
        </trans-unit>
        <trans-unit id="0b61a40f2f042effaff1a816288916e29182e78d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr (C function)</source>
          <target state="translated">NpyIter_GetIndexPtr (C 함수)</target>
        </trans-unit>
        <trans-unit id="66611101d6de9d68cce0bd7a8cf2f113e7678aaf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIndexPtr()</source>
          <target state="translated">NpyIter_GetIndexPtr()</target>
        </trans-unit>
        <trans-unit id="709bac1bb4a069b2df14e08fa3d634e04e1b48d8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray (C function)</source>
          <target state="translated">NpyIter_GetInitialDataPtrArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="cca4420e7f21331a3412d9afdd62effd1a37e0d5" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInitialDataPtrArray()</source>
          <target state="translated">NpyIter_GetInitialDataPtrArray()</target>
        </trans-unit>
        <trans-unit id="ce42d7c0034eff3c7307f8b08adc8d1d3d5232be" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray (C function)</source>
          <target state="translated">NpyIter_GetInnerFixedStrideArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="3e2852a223ce3a2b4862d0d75cd1f8c82ebb096d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerFixedStrideArray()</source>
          <target state="translated">NpyIter_GetInnerFixedStrideArray()</target>
        </trans-unit>
        <trans-unit id="320bab14d48a2be5366699d949e501506d8b52ef" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr (C function)</source>
          <target state="translated">NpyIter_GetInnerLoopSizePtr (C 함수)</target>
        </trans-unit>
        <trans-unit id="a28fb690d09a18949fd479bfd69414cd7025ffd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerLoopSizePtr()</source>
          <target state="translated">NpyIter_GetInnerLoopSizePtr()</target>
        </trans-unit>
        <trans-unit id="2741ed5c537a092cf9f55caeb0d6909844811cae" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray (C function)</source>
          <target state="translated">NpyIter_GetInnerStrideArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="459e9e1f94992501dfb6860694a283afdd8b7cd8" translate="yes" xml:space="preserve">
          <source>NpyIter_GetInnerStrideArray()</source>
          <target state="translated">NpyIter_GetInnerStrideArray()</target>
        </trans-unit>
        <trans-unit id="916bfb4b9ccc85a495812e9b0ef709804cf83e7b" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex (C function)</source>
          <target state="translated">NpyIter_GetIterIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="2b51d4d2bf86336410a4e52bb5d565c6529f946c" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndex()</source>
          <target state="translated">NpyIter_GetIterIndex()</target>
        </trans-unit>
        <trans-unit id="4f98f4187c0881fc46fb9149b68116d68e20d9ea" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange (C function)</source>
          <target state="translated">NpyIter_GetIterIndexRange (C 함수)</target>
        </trans-unit>
        <trans-unit id="46f9917bbb45a59125169b7d51e52942d1ae839d" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterIndexRange()</source>
          <target state="translated">NpyIter_GetIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="6ac9c145de13db3cda86b9108539ac806761dc14" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterNext (C function)</source>
          <target state="translated">NpyIter_GetIterNext (C 함수)</target>
        </trans-unit>
        <trans-unit id="eb93380537687af5addf300e0da2d51122534b79" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize (C function)</source>
          <target state="translated">NpyIter_GetIterSize (C 함수)</target>
        </trans-unit>
        <trans-unit id="e7b47088c34a7caf54317e4c555ce5eeee306bf9" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterSize()</source>
          <target state="translated">NpyIter_GetIterSize()</target>
        </trans-unit>
        <trans-unit id="971f351012eac4ac6bf123d19280ff6e83e62e85" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView (C function)</source>
          <target state="translated">NpyIter_GetIterView (C 함수)</target>
        </trans-unit>
        <trans-unit id="b37332e2ac83c27d275077f93c1a5465ad79ccdf" translate="yes" xml:space="preserve">
          <source>NpyIter_GetIterView()</source>
          <target state="translated">NpyIter_GetIterView()</target>
        </trans-unit>
        <trans-unit id="260ac3818c138694453f685279c2631308cb9db4" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc</source>
          <target state="translated">NpyIter_GetMultiIndexFunc</target>
        </trans-unit>
        <trans-unit id="268c5739b883afa9c178c9d12b961525ac033a81" translate="yes" xml:space="preserve">
          <source>NpyIter_GetMultiIndexFunc (C type)</source>
          <target state="translated">NpyIter_GetMultiIndexFunc (C 유형)</target>
        </trans-unit>
        <trans-unit id="12fef6dc6e8adca628a81ab1f9f58214b8989570" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim (C function)</source>
          <target state="translated">NpyIter_GetNDim (C 함수)</target>
        </trans-unit>
        <trans-unit id="8e9bba8a229eb928a91402e6ca604c155e3edd64" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNDim()</source>
          <target state="translated">NpyIter_GetNDim()</target>
        </trans-unit>
        <trans-unit id="68db817bd7a88e9a2db3bf2cfbe83efefe3a7b98" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp (C function)</source>
          <target state="translated">NpyIter_GetNOp (C 함수)</target>
        </trans-unit>
        <trans-unit id="50db8bb821c577506b545754506219ead592b053" translate="yes" xml:space="preserve">
          <source>NpyIter_GetNOp()</source>
          <target state="translated">NpyIter_GetNOp()</target>
        </trans-unit>
        <trans-unit id="4be079e1aeeda5c22d683667022b51cf015a2c21" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray (C function)</source>
          <target state="translated">NpyIter_GetOperandArray (C 함수)</target>
        </trans-unit>
        <trans-unit id="3af90f6f35483cf45c99c7df56d9615992da54dd" translate="yes" xml:space="preserve">
          <source>NpyIter_GetOperandArray()</source>
          <target state="translated">NpyIter_GetOperandArray()</target>
        </trans-unit>
        <trans-unit id="4b047889d28074e88029d8a1e07fab68c9e1b2a6" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags (C function)</source>
          <target state="translated">NpyIter_GetReadFlags (C 함수)</target>
        </trans-unit>
        <trans-unit id="a30bb289b8e86739e36ea60928a2ed64312d2fec" translate="yes" xml:space="preserve">
          <source>NpyIter_GetReadFlags()</source>
          <target state="translated">NpyIter_GetReadFlags()</target>
        </trans-unit>
        <trans-unit id="72287467289d08139728b9bd588cb1fba0d298e1" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape (C function)</source>
          <target state="translated">NpyIter_GetShape (C 함수)</target>
        </trans-unit>
        <trans-unit id="9c3fe550cadce766e0ebaa92151a7d483873ef4a" translate="yes" xml:space="preserve">
          <source>NpyIter_GetShape()</source>
          <target state="translated">NpyIter_GetShape()</target>
        </trans-unit>
        <trans-unit id="16f7d0a2122c563a659425f4ce571bbbba298beb" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags (C function)</source>
          <target state="translated">NpyIter_GetWriteFlags (C 함수)</target>
        </trans-unit>
        <trans-unit id="acd9a2ff8ce509672e11ffa76fdbabff9b0c7181" translate="yes" xml:space="preserve">
          <source>NpyIter_GetWriteFlags()</source>
          <target state="translated">NpyIter_GetWriteFlags()</target>
        </trans-unit>
        <trans-unit id="6668661c9c3f5c1e327bd4f2c42ad82f1605c898" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex (C function)</source>
          <target state="translated">NpyIter_GotoIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="d3120c654191cddf0b70bae47a341b3c86669393" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIndex()</source>
          <target state="translated">NpyIter_GotoIndex()</target>
        </trans-unit>
        <trans-unit id="32885a42e6fb8b031f26299bec0d11656e3b1eaa" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex (C function)</source>
          <target state="translated">NpyIter_GotoIterIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="4f1654c5ff8fe66cc2194f6b61e83a8e796fe628" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoIterIndex()</source>
          <target state="translated">NpyIter_GotoIterIndex()</target>
        </trans-unit>
        <trans-unit id="e135f8536fc5fd83a52cd6bbd2bce201e704280c" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex (C function)</source>
          <target state="translated">NpyIter_GotoMultiIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="d041142525a40cf564e2e7e029c65f6509b0a323" translate="yes" xml:space="preserve">
          <source>NpyIter_GotoMultiIndex()</source>
          <target state="translated">NpyIter_GotoMultiIndex()</target>
        </trans-unit>
        <trans-unit id="1d5b6a575bb6f461dea653952d455489a8ea3d4a" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc (C function)</source>
          <target state="translated">NpyIter_HasDelayedBufAlloc (C 함수)</target>
        </trans-unit>
        <trans-unit id="ed0864809f09d890d29d15054f92994f033a3f43" translate="yes" xml:space="preserve">
          <source>NpyIter_HasDelayedBufAlloc()</source>
          <target state="translated">NpyIter_HasDelayedBufAlloc()</target>
        </trans-unit>
        <trans-unit id="8d6631cc570fdeba0443b204635f61ead9da9cc0" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop (C function)</source>
          <target state="translated">NpyIter_HasExternalLoop (C 함수)</target>
        </trans-unit>
        <trans-unit id="02c750ba9fcfc1c225387cebcaf21e29ccbc7ab1" translate="yes" xml:space="preserve">
          <source>NpyIter_HasExternalLoop()</source>
          <target state="translated">NpyIter_HasExternalLoop()</target>
        </trans-unit>
        <trans-unit id="01ff965a16adc18e1fe09a249c239ef993e1e4cd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex (C function)</source>
          <target state="translated">NpyIter_HasIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="1495f8b014a812b7d5168151357e69d6e80056fa" translate="yes" xml:space="preserve">
          <source>NpyIter_HasIndex()</source>
          <target state="translated">NpyIter_HasIndex()</target>
        </trans-unit>
        <trans-unit id="524724e0000bf6ba5bb9fefb1e4de88d3ce724e6" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex (C function)</source>
          <target state="translated">NpyIter_HasMultiIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="ca93af25bd286e2ffe55a87884c419afcd79bfcd" translate="yes" xml:space="preserve">
          <source>NpyIter_HasMultiIndex()</source>
          <target state="translated">NpyIter_HasMultiIndex()</target>
        </trans-unit>
        <trans-unit id="b4e6deeafbbcf71e1a3f6bc2ac6366e5bd6c1b90" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered (C function)</source>
          <target state="translated">NpyIter_IsBuffered (C 함수)</target>
        </trans-unit>
        <trans-unit id="476b949116e329f3c582aec5e76ce2e141633429" translate="yes" xml:space="preserve">
          <source>NpyIter_IsBuffered()</source>
          <target state="translated">NpyIter_IsBuffered()</target>
        </trans-unit>
        <trans-unit id="7304a6b23051f3e1aaa8d76004af420f8c287e9d" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit (C function)</source>
          <target state="translated">NpyIter_IsFirstVisit (C 함수)</target>
        </trans-unit>
        <trans-unit id="0e9bbd57db7393e50498619291fc91b81f37f813" translate="yes" xml:space="preserve">
          <source>NpyIter_IsFirstVisit()</source>
          <target state="translated">NpyIter_IsFirstVisit()</target>
        </trans-unit>
        <trans-unit id="c71ca1fe83aa6474b8db38df750b5605a0ad4041" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner (C function)</source>
          <target state="translated">NpyIter_IsGrowInner (C 함수)</target>
        </trans-unit>
        <trans-unit id="1f0a2dba542604a7f3103127f1353c17a14acca2" translate="yes" xml:space="preserve">
          <source>NpyIter_IsGrowInner()</source>
          <target state="translated">NpyIter_IsGrowInner()</target>
        </trans-unit>
        <trans-unit id="89d075475c669dbbf16b180a78f6a538e870d992" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc</source>
          <target state="translated">NpyIter_IterNextFunc</target>
        </trans-unit>
        <trans-unit id="ed5e1d448ea8ab46ae13594b26e85229c0f707c9" translate="yes" xml:space="preserve">
          <source>NpyIter_IterNextFunc (C type)</source>
          <target state="translated">NpyIter_IterNextFunc (C 유형)</target>
        </trans-unit>
        <trans-unit id="7035ada01b636882b1ed7a431b18b92987e61d41" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew (C function)</source>
          <target state="translated">NpyIter_MultiNew (C 함수)</target>
        </trans-unit>
        <trans-unit id="959108f7b8a46be14788dcc6f2c656a40adf98c1" translate="yes" xml:space="preserve">
          <source>NpyIter_MultiNew()</source>
          <target state="translated">NpyIter_MultiNew()</target>
        </trans-unit>
        <trans-unit id="ed094cc005976d6753311589b5d73c8f2c8e5e4f" translate="yes" xml:space="preserve">
          <source>NpyIter_New (C function)</source>
          <target state="translated">NpyIter_New (C 함수)</target>
        </trans-unit>
        <trans-unit id="75df925e997f8a9b01f4fc38c2a52f970f929a3f" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex (C function)</source>
          <target state="translated">NpyIter_RemoveMultiIndex (C 함수)</target>
        </trans-unit>
        <trans-unit id="1d0fc99dccddcd13dec9ec17ac48fd49dd80c577" translate="yes" xml:space="preserve">
          <source>NpyIter_RemoveMultiIndex()</source>
          <target state="translated">NpyIter_RemoveMultiIndex()</target>
        </trans-unit>
        <trans-unit id="71dc9b48fe46c56aa709225d6c3eb5faead7860b" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering (C function)</source>
          <target state="translated">NpyIter_RequiresBuffering (C 함수)</target>
        </trans-unit>
        <trans-unit id="a202ae5802958f468dad8c3e99a4bb5293a4dde8" translate="yes" xml:space="preserve">
          <source>NpyIter_RequiresBuffering()</source>
          <target state="translated">NpyIter_RequiresBuffering()</target>
        </trans-unit>
        <trans-unit id="082f6c0216a14a9d8e91d9d0eb80091b4c8e7c17" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset (C function)</source>
          <target state="translated">NpyIter_Reset (C 함수)</target>
        </trans-unit>
        <trans-unit id="c109fda112a4bfc0725b7a5833fd46c5602a3173" translate="yes" xml:space="preserve">
          <source>NpyIter_Reset()</source>
          <target state="translated">NpyIter_Reset()</target>
        </trans-unit>
        <trans-unit id="70f5ee8ee0cc17ab92992d6cf6ee393f1e4520e7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers (C function)</source>
          <target state="translated">NpyIter_ResetBasePointers (C 함수)</target>
        </trans-unit>
        <trans-unit id="f1294ce3152cab7ceda644b504d717770b89e5c7" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetBasePointers()</source>
          <target state="translated">NpyIter_ResetBasePointers()</target>
        </trans-unit>
        <trans-unit id="14a37f97f8b6e5b56b6e83ff5eb67b7c25067c0c" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange (C function)</source>
          <target state="translated">NpyIter_ResetToIterIndexRange (C 함수)</target>
        </trans-unit>
        <trans-unit id="7a0acf29df8ba8a7bb014f05220b41b68cf91300" translate="yes" xml:space="preserve">
          <source>NpyIter_ResetToIterIndexRange()</source>
          <target state="translated">NpyIter_ResetToIterIndexRange()</target>
        </trans-unit>
        <trans-unit id="73626c9be0436b0d908d20d700956f6f6ce365b0" translate="yes" xml:space="preserve">
          <source>NpyIter_Type</source>
          <target state="translated">NpyIter_Type</target>
        </trans-unit>
        <trans-unit id="61c3b0ba34d7f397bd9f7eff4691cefedb4d278d" translate="yes" xml:space="preserve">
          <source>NpyIter_Type (C type)</source>
          <target state="translated">NpyIter_Type (C 유형)</target>
        </trans-unit>
        <trans-unit id="114cc06627557f63febd03e44f39195669b3db75" translate="yes" xml:space="preserve">
          <source>NumFOCUS Subcommittee</source>
          <target state="translated">NumFOCUS 소위원회</target>
        </trans-unit>
        <trans-unit id="148fb3e1f0f3a0a5a25d7af63d9dc5d6da0841ea" translate="yes" xml:space="preserve">
          <source>NumPy</source>
          <target state="translated">NumPy</target>
        </trans-unit>
        <trans-unit id="a9d2a1b57f4f20938978d4d1c165136857a81954" translate="yes" xml:space="preserve">
          <source>NumPy &amp;mdash; it provides packages like:</source>
          <target state="translated">NumPy &amp;mdash; 다음과 같은 패키지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="766bc7e1c62d6bf447df2796935c0002e01046b4" translate="yes" xml:space="preserve">
          <source>NumPy (&lt;strong&gt;Numerical Python&lt;/strong&gt;) is an open source Python library that&amp;rsquo;s used in almost every field of science and engineering. It&amp;rsquo;s the universal standard for working with numerical data in Python, and it&amp;rsquo;s at the core of the scientific Python and PyData ecosystems. NumPy users include everyone from beginning coders to experienced researchers doing state-of-the-art scientific and industrial research and development. The NumPy API is used extensively in Pandas, SciPy, Matplotlib, scikit-learn, scikit-image and most other data science and scientific Python packages.</source>
          <target state="translated">NumPy ( &lt;strong&gt;Numerical Python&lt;/strong&gt; )는 거의 모든 과학 및 공학 분야에서 사용되는 오픈 소스 Python 라이브러리입니다. Python에서 숫자 데이터 작업을위한 보편적 인 표준이며 과학적 Python 및 PyData 생태계의 핵심입니다. NumPy 사용자에는 초보 코더부터 최첨단 과학 및 산업 연구 및 개발을 수행하는 숙련 된 연구원까지 모든 사람이 포함됩니다. NumPy API는 Pandas, SciPy, Matplotlib, scikit-learn, scikit-image 및 대부분의 기타 데이터 과학 및 과학 Python 패키지에서 광범위하게 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c505ea92418c9a5d535f7526fb8ff95e78ef0962" translate="yes" xml:space="preserve">
          <source>NumPy &lt;a href=&quot;#term-object-array&quot;&gt;object arrays&lt;/a&gt;, which contain references to Python objects, fill the role of heterogeneous arrays.</source>
          <target state="translated">Python 객체에 대한 참조를 포함하는 NumPy &lt;a href=&quot;#term-object-array&quot;&gt;객체 배열&lt;/a&gt; 은 이기종 배열의 역할을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="dd7856c2dbbcca63221ed726f4aced6db4c3c7ff" translate="yes" xml:space="preserve">
          <source>NumPy API Reference</source>
          <target state="translated">NumPy API 참조</target>
        </trans-unit>
        <trans-unit id="de84e2593a0db73fdbbba3a6d668459795665a8b" translate="yes" xml:space="preserve">
          <source>NumPy API reference</source>
          <target state="translated">NumPy API 참조</target>
        </trans-unit>
        <trans-unit id="f41afbb931d30bf51df3c5d024df1c8569665b6f" translate="yes" xml:space="preserve">
          <source>NumPy Array Scalars and SWIG</source>
          <target state="translated">NumPy 어레이 스칼라 및 SWIG</target>
        </trans-unit>
        <trans-unit id="51ad55a9768d51db51dfc0fe1a4177bdd94eb2e8" translate="yes" xml:space="preserve">
          <source>NumPy C API</source>
          <target state="translated">NumPy C API</target>
        </trans-unit>
        <trans-unit id="3ee0e4047919b43a08c3c67ba0e3fc5e60d9cdaa" translate="yes" xml:space="preserve">
          <source>NumPy C Code Explanations</source>
          <target state="translated">NumPy C 코드 설명</target>
        </trans-unit>
        <trans-unit id="e338b3196336652494be7c1852eae3cde59bd702" translate="yes" xml:space="preserve">
          <source>NumPy C Style Guide</source>
          <target state="translated">NumPy C 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="808f9bc55e71edfa349e88dbc3b76c5d2e90cc3f" translate="yes" xml:space="preserve">
          <source>NumPy C style guide</source>
          <target state="translated">NumPy C 스타일 가이드</target>
        </trans-unit>
        <trans-unit id="b6796af8c026b629052c1b19daa9ac3e40093d9f" translate="yes" xml:space="preserve">
          <source>NumPy C-API</source>
          <target state="translated">NumPy C-API</target>
        </trans-unit>
        <trans-unit id="a1586bc86c3a6e96b55470571a3b7966155b62c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct</source>
          <target state="translated">NumPy 행동 강령</target>
        </trans-unit>
        <trans-unit id="1435e02825452fed2fb68e6c73bfa4d34ac784c1" translate="yes" xml:space="preserve">
          <source>NumPy Code of Conduct - How to follow up on a report</source>
          <target state="translated">NumPy 행동 강령-보고서에 대한 후속 조치 방법</target>
        </trans-unit>
        <trans-unit id="d68b43adfe65e0ada7943e8e901732e697fd8106" translate="yes" xml:space="preserve">
          <source>NumPy Contributor Guide</source>
          <target state="translated">NumPy 컨트 리뷰 터 가이드</target>
        </trans-unit>
        <trans-unit id="dd9b8569488631e17e9c539e945f4151de6b16a5" translate="yes" xml:space="preserve">
          <source>NumPy Distutils - Users Guide</source>
          <target state="translated">NumPy Distutils-사용자 안내서</target>
        </trans-unit>
        <trans-unit id="c956147a86ea5dbf2bd113161d5a9a92844fee2c" translate="yes" xml:space="preserve">
          <source>NumPy Distutils preprocesses C source files (extension: &lt;code&gt;.c.src&lt;/code&gt;) written in a custom templating language to generate C code. The &lt;code&gt;@&lt;/code&gt; symbol is used to wrap macro-style variables to empower a string substitution mechanism that might describe (for instance) a set of data types.</source>
          <target state="translated">NumPy Distutils 는 사용자 정의 템플릿 언어로 작성된 C 소스 파일 (확장자 : &lt;code&gt;.c.src&lt;/code&gt; )을 사전 처리 하여 C 코드를 생성합니다. &lt;code&gt;@&lt;/code&gt; 의 기호 (예를 들어)을 설명 할 수 문자열 대체 메커니즘 데이터 유형의 집합 권한을 부여하는 매크로 스타일의 변수를 포장하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="6d3daec11f336cbe9aa58a4987acc6154b7a71ca" translate="yes" xml:space="preserve">
          <source>NumPy Docs</source>
          <target state="translated">NumPy 문서</target>
        </trans-unit>
        <trans-unit id="a87b70e72189be1c91039076031182a00ca8a4a2" translate="yes" xml:space="preserve">
          <source>NumPy Documentation</source>
          <target state="translated">NumPy 문서</target>
        </trans-unit>
        <trans-unit id="d11f236a358860bc1630b35d02b897f965a3abe6" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposal (NEP) 32, &lt;a href=&quot;https://numpy.org/neps/nep-0032-remove-financial-functions.html&quot;&gt;https://numpy.org/neps/nep-0032-remove-financial-functions.html&lt;/a&gt;</source>
          <target state="translated">NumPy 향상 제안 (NEP) 32, &lt;a href=&quot;https://numpy.org/neps/nep-0032-remove-financial-functions.html&quot;&gt;https://numpy.org/neps/nep-0032-remove-financial-functions.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a3f4b91200bead38a769f70a1e46a5128f09c922" translate="yes" xml:space="preserve">
          <source>NumPy Enhancement Proposals</source>
          <target state="translated">NumPy 개선 제안</target>
        </trans-unit>
        <trans-unit id="9b610e33661eed30d2fd4d5c8298056db2d15c3b" translate="yes" xml:space="preserve">
          <source>NumPy How Tos</source>
          <target state="translated">NumPy 방법</target>
        </trans-unit>
        <trans-unit id="00b77a99ad474e5c770e0ddd949ded46acfaf38e" translate="yes" xml:space="preserve">
          <source>NumPy Issues: &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;https://github.com/numpy/numpy/issues&lt;/a&gt;</source>
          <target state="translated">NumPy 문제 : &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;https://github.com/numpy/numpy/issues&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b07568fa1b23354307b498eba5947dd449b1ae50" translate="yes" xml:space="preserve">
          <source>NumPy License</source>
          <target state="translated">NumPy 라이선스</target>
        </trans-unit>
        <trans-unit id="df1797f9e232d63f819933885e2ac94ec0352d11" translate="yes" xml:space="preserve">
          <source>NumPy Reference</source>
          <target state="translated">NumPy 참조</target>
        </trans-unit>
        <trans-unit id="23bd4c05c1a40776eacbfc3e62d23e6f2151bb0f" translate="yes" xml:space="preserve">
          <source>NumPy Reference, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;Generalized Universal Function API&lt;/a&gt;.</source>
          <target state="translated">NumPy Reference, &lt;a href=&quot;https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html&quot;&gt;Generalized Universal Function API&lt;/a&gt; 섹션 .</target>
        </trans-unit>
        <trans-unit id="ba14bf798691d10d0084ffd0e5302c3bb4aff789" translate="yes" xml:space="preserve">
          <source>NumPy Scalars are cast when assigned to arrays</source>
          <target state="translated">NumPy 스칼라는 배열에 할당 될 때 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="bcf67cf31bc3a7972c91a07dd966f1740a8d146e" translate="yes" xml:space="preserve">
          <source>NumPy Tutorials</source>
          <target state="translated">NumPy 튜토리얼</target>
        </trans-unit>
        <trans-unit id="da31cee45cf66b17220997ed18c1c784b896e561" translate="yes" xml:space="preserve">
          <source>NumPy User Guide, section &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;I/O with NumPy&lt;/a&gt;.</source>
          <target state="translated">NumPy 사용 설명서, &lt;a href=&quot;https://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&quot;&gt;NumPy를 사용한 I / O&lt;/a&gt; 섹션 .</target>
        </trans-unit>
        <trans-unit id="dfb797f6ad28f48ccb741b2ddb48976e23e00a3f" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64.</source>
          <target state="translated">NumPy를 사용하면 두 개의 Datetime 값을 뺄 수 있으며 시간 단위를 사용하여 숫자를 생성하는 연산입니다. NumPy의 코어에는 물리적 수량 시스템이 없기 때문에 datedelta64를 보완하기 위해 timedelta64 데이터 유형이 작성되었습니다.</target>
        </trans-unit>
        <trans-unit id="f9dacbde768b51aaba6413e3c788f0b194b5b375" translate="yes" xml:space="preserve">
          <source>NumPy allows the subtraction of two Datetime values, an operation which produces a number with a time unit. Because NumPy doesn&amp;rsquo;t have a physical quantities system in its core, the timedelta64 data type was created to complement datetime64. The arguments for timedelta64 are a number, to represent the number of units, and a date/time unit, such as (D)ay, (M)onth, (Y)ear, (h)ours, (m)inutes, or (s)econds. The timedelta64 data type also accepts the string &amp;ldquo;NAT&amp;rdquo; in place of the number for a &amp;ldquo;Not A Time&amp;rdquo; value.</source>
          <target state="translated">NumPy를 사용하면 두 개의 Datetime 값을 뺄 수 있습니다.이 연산은 시간 단위가있는 숫자를 생성합니다. NumPy는 코어에 물리량 시스템이 없기 때문에 datetime64를 보완하기 위해 timedelta64 데이터 유형이 생성되었습니다. timedelta64에 대한 인수는 단위 수를 나타내는 숫자와 (D) ay, (M) onth, (Y) ear, (h) ours, (m) inutes 또는 (s) econds. timedelta64 데이터 유형은 또한 &quot;Not A Time&quot;값에 대한 숫자 대신 &quot;NAT&quot;문자열을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="750ef31835ba51a139fefe6ca7653831fa1d642d" translate="yes" xml:space="preserve">
          <source>NumPy also performs aggregation functions. In addition to &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;max&lt;/code&gt;, and &lt;code&gt;sum&lt;/code&gt;, you can easily run &lt;code&gt;mean&lt;/code&gt; to get the average, &lt;code&gt;prod&lt;/code&gt; to get the result of multiplying the elements together, &lt;code&gt;std&lt;/code&gt; to get the standard deviation, and more.</source>
          <target state="translated">NumPy는 집계 기능도 수행합니다. &lt;code&gt;min&lt;/code&gt; , &lt;code&gt;max&lt;/code&gt; 및 &lt;code&gt;sum&lt;/code&gt; 외에도 &lt;code&gt;mean&lt;/code&gt; 을 실행하여 평균 을 구하고, &lt;code&gt;prod&lt;/code&gt; 를 실행 하여 요소를 곱한 결과 를 얻고, 표준 편차를 &lt;code&gt;std&lt;/code&gt; 을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3681d5d48b000e09eb74bcf9d80a233df272bb0f" translate="yes" xml:space="preserve">
          <source>NumPy and SWIG</source>
          <target state="translated">NUMPY와 SWIG</target>
        </trans-unit>
        <trans-unit id="c826d8c52c25e4bbad4a786ac8dfdcf96c8f11ac" translate="yes" xml:space="preserve">
          <source>NumPy and Swig</source>
          <target state="translated">NumPy와 Swig</target>
        </trans-unit>
        <trans-unit id="378b259740f670c18f15c2234a2938b6e65c8a3f" translate="yes" xml:space="preserve">
          <source>NumPy array slicing uses pass-by-reference, that does not copy the arguments. Slicing operations are views into an array.</source>
          <target state="translated">NumPy 배열 슬라이싱은 인수를 복사하지 않는 참조에 의한 전달을 사용합니다. 슬라이싱 작업은 배열에 대한 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="a3f3f40987eacf79da1da15ffc970ce1ce8e5996" translate="yes" xml:space="preserve">
          <source>NumPy arrays are &lt;strong&gt;not&lt;/strong&gt; directly &lt;a href=&quot;https://github.com/numpy/numpy/issues/12481&quot;&gt;JSON serializable&lt;/a&gt;.</source>
          <target state="translated">NumPy 배열은 직접 &lt;a href=&quot;https://github.com/numpy/numpy/issues/12481&quot;&gt;JSON 직렬화&lt;/a&gt; 할 수 &lt;strong&gt;없습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="bd9f76864b0123b6e81c3abbfaba07bd1a398902" translate="yes" xml:space="preserve">
          <source>NumPy arrays are faster and more compact than Python lists. An array consumes less memory and is convenient to use. NumPy uses much less memory to store data and it provides a mechanism of specifying the data types. This allows the code to be optimized even further.</source>
          <target state="translated">NumPy 배열은 Python 목록보다 빠르고 간결합니다. 어레이는 메모리를 덜 사용하고 사용하기 편리합니다. NumPy는 데이터를 저장하는 데 훨씬 적은 메모리를 사용하며 데이터 유형을 지정하는 메커니즘을 제공합니다. 이를 통해 코드를 더욱 최적화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="45e9cb3043e5f97824505a55cbdfc5294d3ba613" translate="yes" xml:space="preserve">
          <source>NumPy arrays consist of two major components, the raw array data (from now on, referred to as the data buffer), and the information about the raw array data. The data buffer is typically what people think of as arrays in C or Fortran, a contiguous (and fixed) block of memory containing fixed sized data items. NumPy also contains a significant set of data that describes how to interpret the data in the data buffer. This extra information contains (among other things):</source>
          <target state="translated">NumPy 배열은 두 가지 주요 구성 요소, 즉 원시 배열 데이터 (지금부터 데이터 버퍼라고 함)와 원시 배열 데이터에 대한 정보로 구성됩니다. 데이터 버퍼는 일반적으로 사람들이 고정 된 크기의 데이터 항목을 포함하는 연속 된 (고정 된) 메모리 블록 인 C 또는 Fortran의 배열이라고 생각합니다. NumPy에는 데이터 버퍼의 데이터를 해석하는 방법을 설명하는 중요한 데이터 세트도 포함되어 있습니다. 이 추가 정보에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="064ff558785222ad92d746322b42cf271317a323" translate="yes" xml:space="preserve">
          <source>NumPy arrays facilitate advanced mathematical and other types of operations on large numbers of data. Typically, such operations are executed more efficiently and with less code than is possible using Python&amp;rsquo;s built-in sequences.</source>
          <target state="translated">NumPy 배열은 많은 수의 데이터에 대한 고급 수학 및 기타 유형의 연산을 용이하게합니다. 일반적으로 이러한 작업은 Python의 내장 시퀀스를 사용하여 가능한 것보다 적은 코드로 더 효율적으로 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f9df6ed13e1a0bf8dd7a4da9cdb0f04829d71462" translate="yes" xml:space="preserve">
          <source>NumPy arrays have a fixed size at creation, unlike Python lists (which can grow dynamically). Changing the size of an &lt;code&gt;ndarray&lt;/code&gt; will create a new array and delete the original.</source>
          <target state="translated">NumPy 배열은 동적으로 커질 수있는 Python 목록과 달리 생성시 고정 된 크기를 갖습니다. &lt;code&gt;ndarray&lt;/code&gt; 의 크기를 변경하면 새 어레이가 생성되고 원본이 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="b9a2b1964b63758771b415bd46c81a550e3302e2" translate="yes" xml:space="preserve">
          <source>NumPy arrays may be indexed with other arrays (or any other sequence- like object that can be converted to an array, such as lists, with the exception of tuples; see the end of this document for why this is). The use of index arrays ranges from simple, straightforward cases to complex, hard-to-understand cases. For all cases of index arrays, what is returned is a copy of the original data, not a view as one gets for slices.</source>
          <target state="translated">NumPy 배열은 다른 배열 (또는 튜플을 제외하고 목록과 같은 배열로 변환 될 수있는 다른 시퀀스 유사 객체)으로 인덱싱 될 수 있습니다. 그 이유는이 문서의 끝 부분을 참조하십시오. 인덱스 배열의 사용 범위는 간단하고 간단한 경우부터 복잡하고 이해하기 어려운 경우에 이르기까지 다양합니다. 인덱스 배열의 모든 경우에 대해 반환되는 것은 슬라이스에 대해 가져 오는 뷰가 아니라 원본 데이터의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="f594d6227d1e21e95a87fa36149ce8ba56ba3bd8" translate="yes" xml:space="preserve">
          <source>NumPy arrays with a structured dtype can also be viewed as &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, where a field can be accessed as if it were an attribute. For that reason, we may need to make sure that the field name doesn&amp;rsquo;t contain any space or invalid character, or that it does not correspond to the name of a standard attribute (like &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;shape&lt;/code&gt;), which would confuse the interpreter. &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; accepts three optional arguments that provide a finer control on the names:</source>
          <target state="translated">구조적으로 DTYPE NumPy와 배열은 또한 볼 수 &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt; 이 속성 것처럼 필드를 액세스 할 수있다. 따라서 필드 이름에 공백이나 유효하지 않은 문자가 포함되어 있지 않거나 인터프리터를 혼동 할 수 있는 표준 속성 (예 : &lt;code&gt;size&lt;/code&gt; 또는 &lt;code&gt;shape&lt;/code&gt; ) 의 이름과 일치하지 않는지 확인해야 할 수 있습니다 . &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 는 이름을보다 세밀하게 제어 할 수있는 세 가지 선택적 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="9ddb7bcd5abd45f2c144892bcef25d7ca724d758" translate="yes" xml:space="preserve">
          <source>NumPy assigns by reference</source>
          <target state="translated">NumPy는 참조로 할당합니다.</target>
        </trans-unit>
        <trans-unit id="ac46c4db4be1d2bf47d471c892c8666f70fae9c0" translate="yes" xml:space="preserve">
          <source>NumPy basics</source>
          <target state="translated">NumPy 기본</target>
        </trans-unit>
        <trans-unit id="3a5ee6decc812823bbb32d4c52868169ed0e2dc6" translate="yes" xml:space="preserve">
          <source>NumPy benchmarks</source>
          <target state="translated">NumPy 벤치 마크</target>
        </trans-unit>
        <trans-unit id="acba6e54dd52e6409526789be99f698cf4b66810" translate="yes" xml:space="preserve">
          <source>NumPy binary files (NPY, NPZ)</source>
          <target state="translated">NumPy 이진 파일 (NPY, NPZ)</target>
        </trans-unit>
        <trans-unit id="24422cd746cd54c121886f257099a4c4b493866b" translate="yes" xml:space="preserve">
          <source>NumPy can be tested in a number of ways, choose any way you feel comfortable.</source>
          <target state="translated">NumPy는 여러 가지 방법으로 테스트 할 수 있으며 편안하게 느끼는 방식을 선택합니다.</target>
        </trans-unit>
        <trans-unit id="e2731ffa90b7c735aae8e17474bd85f4ca800f4d" translate="yes" xml:space="preserve">
          <source>NumPy can do operations on arrays whose shapes are mismatched:</source>
          <target state="translated">NumPy는 모양이 일치하지 않는 배열에서 작업을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d16a651e79e36287ab38bac721290bfd05bc2a01" translate="yes" xml:space="preserve">
          <source>NumPy comes with 24 builtin data-types. While this covers a large majority of possible use cases, it is conceivable that a user may have a need for an additional data-type. There is some support for adding an additional data-type into the NumPy system. This additional data- type will behave much like a regular data-type except ufuncs must have 1-d loops registered to handle it separately. Also checking for whether or not other data-types can be cast &amp;ldquo;safely&amp;rdquo; to and from this new type or not will always return &amp;ldquo;can cast&amp;rdquo; unless you also register which types your new data-type can be cast to and from.</source>
          <target state="translated">NumPy에는 24 개의 내장 데이터 유형이 있습니다. 여기에는 가능한 대부분의 사용 사례가 포함되지만 사용자에게 추가 데이터 유형이 필요할 수 있습니다. NumPy 시스템에 추가 데이터 유형을 추가하기위한 일부 지원이 있습니다. 이 추가 데이터 유형은 ufuncs가 별도로 처리하기 위해 등록 된 1-d 루프를 가져야한다는 점을 제외하면 일반 데이터 유형과 매우 유사하게 작동합니다. 또한 다른 데이터 유형을이 새 유형으로 &quot;안전하게&quot;캐스트 할 수 있는지 여부를 확인하면 새 데이터 유형을 캐스트 할 수있는 유형을 등록하지 않는 한 항상 &quot;캐스트 가능&quot;을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e0f2beec853b334d966939a6cfbd8740cabbc29f" translate="yes" xml:space="preserve">
          <source>NumPy community</source>
          <target state="translated">NumPy 커뮤니티</target>
        </trans-unit>
        <trans-unit id="587dfdb00740f1bca4ab2388a780e1daaf9e9438" translate="yes" xml:space="preserve">
          <source>NumPy contains both an &lt;code&gt;array&lt;/code&gt; class and a &lt;code&gt;matrix&lt;/code&gt; class. The &lt;code&gt;array&lt;/code&gt; class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while &lt;code&gt;matrix&lt;/code&gt; is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two.</source>
          <target state="translated">NumPy는 &lt;code&gt;array&lt;/code&gt; 클래스와 &lt;code&gt;matrix&lt;/code&gt; 클래스를 모두 포함합니다 . &lt;code&gt;array&lt;/code&gt; 하면서 클래스는, 수치 계산의 많은 종류의 범용 N 차원 배열되도록 의도 &lt;code&gt;matrix&lt;/code&gt; 특히 선형 대수 계산을 용이하게하기위한 것이다. 실제로 둘 사이에는 몇 가지 주요 차이점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="648b2c826e9dca058d52cb253a3629a695c1c05a" translate="yes" xml:space="preserve">
          <source>NumPy contributor guide</source>
          <target state="translated">NumPy 컨트 리뷰 터 가이드</target>
        </trans-unit>
        <trans-unit id="e9e0392d352bfceb00b69b8aae489d3cfcd35b94" translate="yes" xml:space="preserve">
          <source>NumPy core libraries</source>
          <target state="translated">NumPy 핵심 라이브러리</target>
        </trans-unit>
        <trans-unit id="ccf16bd0788fff6636ddfa05a6cb0f611b1a5988" translate="yes" xml:space="preserve">
          <source>NumPy core math library</source>
          <target state="translated">NumPy 핵심 수학 라이브러리</target>
        </trans-unit>
        <trans-unit id="973c555328d9b9a87fd43d16a1a900328d00f946" translate="yes" xml:space="preserve">
          <source>NumPy data type descriptions are instances of the &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">NumPy 데이터 형식 설명은 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="978f537fd61d02bcc51970587f176772f017251f" translate="yes" xml:space="preserve">
          <source>NumPy dispatcher is based on multi-source compiling, which means taking a certain source and compiling it multiple times with different compiler flags and also with different &lt;strong&gt;C&lt;/strong&gt; definitions that affect the code paths to enable certain instruction-sets for each compiled object depending on the required optimizations, then combining the returned objects together.</source>
          <target state="translated">NumPy 디스패처는 다중 소스 컴파일을 기반으로합니다. 즉, 특정 소스를 가져 와서 다른 컴파일러 플래그를 사용하여 여러 번 컴파일 하고 코드 경로에 영향을주는 다른 &lt;strong&gt;C&lt;/strong&gt; 정의를 사용하여 필요에 따라 각 컴파일 된 객체에 대한 특정 명령어 세트를 활성화합니다. 최적화 한 다음 반환 된 객체를 함께 결합합니다.</target>
        </trans-unit>
        <trans-unit id="be9b40e5263a5085939745fd3402fa19fc002ecb" translate="yes" xml:space="preserve">
          <source>NumPy distutils - users guide</source>
          <target state="translated">NumPy distutils-사용자 안내서</target>
        </trans-unit>
        <trans-unit id="7682241df5064b6dcd3fa7f5b4aadf68c8c520d1" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases.</source>
          <target state="translated">NumPy distutils는 &amp;lt;somefile&amp;gt; .src라는 소스 파일의 자동 변환을 지원합니다. 이 기능을 사용하면 블록간에 간단한 변경 만 필요한 매우 유사한 코드 블록을 유지할 수 있습니다. 설정의 빌드 단계에서 &amp;lt;somefile&amp;gt; .src라는 템플리트 파일이 발견되면 &amp;lt;somefile&amp;gt;이라는 새 파일이 템플리트에서 구성되고 대신 빌드 디렉토리에 배치됩니다. 두 가지 형식의 템플릿 변환이 지원됩니다. 첫 번째 형식은 &amp;lt;file&amp;gt; .ext.src라는 파일에서 발생합니다. 여기서 ext는 인식되는 Fortran 확장명입니다 (f, f90, f95, f77, for, ftn, pyf). 두 번째 양식은 다른 모든 경우에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="52e91b4c51a9db40b4247ecf6771ad0f610935f6" translate="yes" xml:space="preserve">
          <source>NumPy distutils supports automatic conversion of source files named &amp;lt;somefile&amp;gt;.src. This facility can be used to maintain very similar code blocks requiring only simple changes between blocks. During the build phase of setup, if a template file named &amp;lt;somefile&amp;gt;.src is encountered, a new file named &amp;lt;somefile&amp;gt; is constructed from the template and placed in the build directory to be used instead. Two forms of template conversion are supported. The first form occurs for files named &amp;lt;file&amp;gt;.ext.src where ext is a recognized Fortran extension (f, f90, f95, f77, for, ftn, pyf). The second form is used for all other cases. See &lt;a href=&quot;distutils_guide#templating&quot;&gt;Conversion of .src files using Templates&lt;/a&gt;.</source>
          <target state="translated">NumPy distutils는 &amp;lt;somefile&amp;gt; .src라는 소스 파일의 자동 변환을 지원합니다. 이 기능을 사용하면 블록간에 간단한 변경 만 필요한 매우 유사한 코드 블록을 유지할 수 있습니다. 설정의 빌드 단계에서 &amp;lt;somefile&amp;gt; .src라는 템플리트 파일이 발견되면 &amp;lt;somefile&amp;gt;이라는 새 파일이 템플리트에서 구성되고 대신 빌드 디렉토리에 배치됩니다. 두 가지 형식의 템플릿 변환이 지원됩니다. 첫 번째 형식은 &amp;lt;file&amp;gt; .ext.src라는 파일에서 발생합니다. 여기서 ext는 인식되는 Fortran 확장명입니다 (f, f90, f95, f77, for, ftn, pyf). 두 번째 양식은 다른 모든 경우에 사용됩니다. 보다&lt;a href=&quot;distutils_guide#templating&quot;&gt; 템플릿을 사용하여 .src 파일 변환을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62cb8c054f8f025824b221606b89da66fb01bcbf" translate="yes" xml:space="preserve">
          <source>NumPy docs have the details covered. API reference documentation is generated directly from &lt;a href=&quot;https://www.python.org/dev/peps/pep-0257/&quot;&gt;docstrings&lt;/a&gt; in the code when the documentation is &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;built&lt;/a&gt;.</source>
          <target state="translated">NumPy 문서에는 자세한 내용이 있습니다. API 참조 문서는 문서가 &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;빌드&lt;/a&gt; 될 때 코드의 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0257/&quot;&gt;독 스트링&lt;/a&gt; 에서 직접 생성됩니다 .</target>
        </trans-unit>
        <trans-unit id="1fd1726df240b387443461a0936d41d6367c1cbf" translate="yes" xml:space="preserve">
          <source>NumPy documentation is kept in the source code tree. To get your document into the docbase you must download the tree, &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;build it&lt;/a&gt;, and submit a pull request. If GitHub and pull requests are new to you, check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="translated">NumPy 문서는 소스 코드 트리에 보관됩니다. 문서를 Docbase로 가져 오려면 트리를 다운로드하고 &lt;a href=&quot;../docs/howto_build_docs#howto-build-docs&quot;&gt;빌드&lt;/a&gt; 한 다음 풀 요청을 제출해야합니다. GitHub 및 pull 요청이 처음이라면 &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide를&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="7ec067cc97926d6f20fb73fa3184c126e233e754" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;) is not available.</source>
          <target state="translated">NumPy는 C의 &lt;code&gt;long double&lt;/code&gt; 보다 더 정밀한 dtype을 제공하지 않습니다 . 특히 128 비트 IEEE 쿼드 정밀도 데이터 유형 (FORTRAN의 &lt;code&gt;REAL*16&lt;/code&gt; )은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="71b5f2ddae9a416483671c90287f2072fd0042bc" translate="yes" xml:space="preserve">
          <source>NumPy does not provide a dtype with more precision than C&amp;rsquo;s &lt;code&gt;long double&lt;/code&gt;\; in particular, the 128-bit IEEE quad precision data type (FORTRAN&amp;rsquo;s &lt;code&gt;REAL*16&lt;/code&gt;\) is not available.</source>
          <target state="translated">NumPy는 C의 &lt;code&gt;long double&lt;/code&gt; \ 보다 더 정확한 dtype을 제공하지 않습니다 . 특히 128 비트 IEEE 쿼드 정밀도 데이터 유형 (FORTRAN의 &lt;code&gt;REAL*16&lt;/code&gt; \)은 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="ba5d51a5b62b750c1604f2d01dcf736580720f16" translate="yes" xml:space="preserve">
          <source>NumPy does not require any external linear algebra libraries to be installed. However, if these are available, NumPy&amp;rsquo;s setup script can detect them and use them for building. A number of different LAPACK library setups can be used, including optimized LAPACK libraries such as OpenBLAS or MKL. The choice and location of these libraries as well as include paths and other such build options can be specified in a &lt;code&gt;site.cfg&lt;/code&gt; file located in the NumPy root repository or a &lt;code&gt;.numpy-site.cfg&lt;/code&gt; file in your home directory. See the &lt;code&gt;site.cfg.example&lt;/code&gt; example file included in the NumPy repository or sdist for documentation, and below for specifying search priority from environmental variables.</source>
          <target state="translated">NumPy는 외부 선형 대수 라이브러리를 설치할 필요가 없습니다. 그러나 이것이 가능한 경우 NumPy의 설정 스크립트는이를 감지하여 빌드에 사용할 수 있습니다. OpenBLAS 또는 MKL과 같은 최적화 된 LAPACK 라이브러리를 포함하여 다양한 LAPACK 라이브러리 설정을 사용할 수 있습니다. 이러한 라이브러리의 선택과 위치, 포함 경로 및 기타 이러한 빌드 옵션은 NumPy 루트 저장소 에있는 &lt;code&gt;site.cfg&lt;/code&gt; 파일 또는 홈 디렉토리 의 &lt;code&gt;.numpy-site.cfg&lt;/code&gt; 파일에서 지정할 수 있습니다. 설명서는 NumPy 저장소 또는 sdist에 포함 된 &lt;code&gt;site.cfg.example&lt;/code&gt; 예제 파일을 참조하고 환경 변수에서 검색 우선 순위를 지정하려면 아래를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c7a95170c1892d84e44be0593492dbf2a5886a93" translate="yes" xml:space="preserve">
          <source>NumPy doesn&amp;rsquo;t have a C function documentation standard at this time, but needs one. Most numpy functions are not documented in the code and that should change. One possibility is Doxygen with a plugin so that the same NumPy style used for Python functions can also be used for documenting C functions, see the files in doc/cdoc/.</source>
          <target state="translated">NumPy에는 현재 C 함수 문서 표준이 없지만 필요합니다. 대부분의 numpy 함수는 코드에 문서화되어 있지 않으며 변경되어야합니다. 한 가지 가능성은 플러그인이있는 Doxygen으로 Python 함수에 사용되는 동일한 NumPy 스타일을 C 함수 문서화에도 사용할 수 있습니다. doc / cdoc /의 파일을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="8f68fa749d0083be9916fd2a5a507830517a2a85" translate="yes" xml:space="preserve">
          <source>NumPy for MATLAB users</source>
          <target state="translated">MATLAB 사용자를위한 NumPy</target>
        </trans-unit>
        <trans-unit id="e2d7988a962e51ca82f6767321b92e79ba1d8ec3" translate="yes" xml:space="preserve">
          <source>NumPy for Matlab users</source>
          <target state="translated">Matlab 사용자를위한 NumPy</target>
        </trans-unit>
        <trans-unit id="c4cda8cf1f381ff8936b6e543e5a88f49fb98417" translate="yes" xml:space="preserve">
          <source>NumPy fully supports an object-oriented approach, starting, once again, with &lt;code&gt;ndarray&lt;/code&gt;. For example, &lt;code&gt;ndarray&lt;/code&gt; is a class, possessing numerous methods and attributes. Many of its methods are mirrored by functions in the outer-most NumPy namespace, allowing the programmer to code in whichever paradigm they prefer. This flexibility has allowed the NumPy array dialect and NumPy &lt;code&gt;ndarray&lt;/code&gt; class to become the &lt;em&gt;de-facto&lt;/em&gt; language of multi-dimensional data interchange used in Python.</source>
          <target state="translated">NumPy는 다시 한 번 &lt;code&gt;ndarray&lt;/code&gt; 로 시작하는 객체 지향 접근 방식을 완벽하게 지원합니다 . 예를 들어, &lt;code&gt;ndarray&lt;/code&gt; 는 수많은 메서드와 속성을 가진 클래스입니다. 대부분의 메서드는 가장 바깥 쪽 NumPy 네임 스페이스의 함수에 의해 미러링되므로 프로그래머가 선호하는 패러다임으로 코딩 할 수 있습니다. 이러한 유연성 덕분에 NumPy 배열 방언과 NumPy &lt;code&gt;ndarray&lt;/code&gt; 클래스가 Python에서 사용되는 다차원 데이터 교환의 &lt;em&gt;사실상&lt;/em&gt; 언어 가 될 수 있었습니다.</target>
        </trans-unit>
        <trans-unit id="4900e8d811971de762aa8ebe80dcd63c7e850d2e" translate="yes" xml:space="preserve">
          <source>NumPy functions now always support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="translated">NumPy 함수는 이제 항상 &lt;code&gt;__array_function__&lt;/code&gt; 을 사용한 재정의를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="9e2f30850bdb0a0d23d96244e831d9063c220901" translate="yes" xml:space="preserve">
          <source>NumPy functions now support overrides with &lt;code&gt;__array_function__&lt;/code&gt;</source>
          <target state="translated">NumPy 함수는 이제 &lt;code&gt;__array_function__&lt;/code&gt; 을 사용한 재정의를 지원합니다.</target>
        </trans-unit>
        <trans-unit id="832b7ee6576dfafa6af4c3707e511d8557196774" translate="yes" xml:space="preserve">
          <source>NumPy generally returns elements of arrays as array scalars (a scalar with an associated dtype). Array scalars differ from Python scalars, but for the most part they can be used interchangeably (the primary exception is for versions of Python older than v2.x, where integer array scalars cannot act as indices for lists and tuples). There are some exceptions, such as when code requires very specific attributes of a scalar or when it checks specifically whether a value is a Python scalar. Generally, problems are easily fixed by explicitly converting array scalars to Python scalars, using the corresponding Python type function (e.g., &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;complex&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt;, &lt;code&gt;unicode&lt;/code&gt;).</source>
          <target state="translated">NumPy는 일반적으로 배열 요소를 배열 스칼라 (연관된 dtype이있는 스칼라)로 반환합니다. 배열 스칼라는 Python 스칼라와 다르지만 대부분 서로 바꿔서 사용할 수 있습니다 (주된 예외는 v2.x 이전 버전의 Python에서 정수 배열 스칼라가 목록 및 튜플에 대한 인덱스로 작동 할 수 없음). 코드에 스칼라의 매우 구체적인 속성이 필요한 경우 또는 값이 Python 스칼라인지 여부를 구체적으로 확인할 때와 같은 몇 가지 예외가 있습니다. 일반적으로 해당 Python 유형 함수 (예 : &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;complex&lt;/code&gt; , &lt;code&gt;str&lt;/code&gt; , &lt;code&gt;unicode&lt;/code&gt; )를 사용하여 배열 스칼라를 Python 스칼라로 명시 적으로 변환하면 문제가 쉽게 해결됩니다 .</target>
        </trans-unit>
        <trans-unit id="890be7939c4a57f24699a49e8b1d3523457ca863" translate="yes" xml:space="preserve">
          <source>NumPy gives us the best of both worlds: element-by-element operations are the &amp;ldquo;default mode&amp;rdquo; when an &lt;code&gt;ndarray&lt;/code&gt; is involved, but the element-by-element operation is speedily executed by pre-compiled C code. In NumPy</source>
          <target state="translated">NumPy는 두 가지 장점을 모두 제공합니다. 요소 별 작업은 &lt;code&gt;ndarray&lt;/code&gt; 가 관련 될 때 &quot;기본 모드&quot; 이지만 요소 별 작업은 미리 컴파일 된 C 코드에 의해 신속하게 실행됩니다. NumPy에서</target>
        </trans-unit>
        <trans-unit id="2c84a4092d43fdae4261d3327c4c544413793832" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogeneous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogeneous.</source>
          <target state="translated">NumPy는 배열을 생성하고 배열 내부의 숫자 데이터를 조작하는 빠르고 효율적인 방법을 제공합니다. Python 목록은 단일 목록 내에 다른 데이터 유형을 포함 할 수 있지만 NumPy 배열의 모든 요소는 동종이어야합니다. 배열이 동일하지 않은 경우 배열에서 수행되는 수학적 연산은 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="d4e59636db0bed7b9eb085bfb86e99aa0957bc34" translate="yes" xml:space="preserve">
          <source>NumPy gives you an enormous range of fast and efficient ways of creating arrays and manipulating numerical data inside them. While a Python list can contain different data types within a single list, all of the elements in a NumPy array should be homogenous. The mathematical operations that are meant to be performed on arrays would be extremely inefficient if the arrays weren&amp;rsquo;t homogenous.</source>
          <target state="translated">NumPy는 배열을 생성하고 배열 내부의 숫자 데이터를 조작하는 빠르고 효율적인 방법을 제공합니다. Python 목록은 단일 목록 내에 다른 데이터 유형을 포함 할 수 있지만 NumPy 배열의 모든 요소는 동종이어야합니다. 배열이 동 질적이지 않은 경우 배열에서 수행되는 수학적 연산은 매우 비효율적입니다.</target>
        </trans-unit>
        <trans-unit id="ce24f4bb69b1ac53e640f756f04696d112954c58" translate="yes" xml:space="preserve">
          <source>NumPy governance</source>
          <target state="translated">NumPy 거버넌스</target>
        </trans-unit>
        <trans-unit id="fadfd147c1bce43e0bd90025c0c918f23b1fb090" translate="yes" xml:space="preserve">
          <source>NumPy hands off array processing to C, where looping and computation are much faster than in Python. To exploit this, programmers using NumPy eliminate Python loops in favor of array-to-array operations. &lt;a href=&quot;#term-vectorization&quot;&gt;vectorization&lt;/a&gt; can refer both to the C offloading and to structuring NumPy code to leverage it.</source>
          <target state="translated">NumPy는 배열 처리를 C로 넘겨줍니다. 여기서 루프와 계산은 Python보다 훨씬 빠릅니다. 이를 악용하기 위해 NumPy를 사용하는 프로그래머는 배열 간 작업을 위해 Python 루프를 제거합니다. &lt;a href=&quot;#term-vectorization&quot;&gt;벡터화&lt;/a&gt; 는 C 오프 로딩과이를 활용하기위한 NumPy 코드 구조화를 모두 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="33fab98fb581f98170a2f8d5e454b21a4a9ae970" translate="yes" xml:space="preserve">
          <source>NumPy has a Documentation Team. We have open meetings on Zoom every three weeks and invite everyone to join. Don&amp;rsquo;t hesitate to reach out if you have questions or just need someone to guide you through your first steps - we&amp;rsquo;re always happy to help. Meetings are usually announced on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion mailing list&lt;/a&gt;. Meeting minutes are taken &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;on hackmd.io&lt;/a&gt; and stored in the &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive repository&lt;/a&gt;.</source>
          <target state="translated">NumPy에는 문서화 팀이 있습니다. Zoom에서 3 주마다 공개 회의를 열고 모든 사람이 참여하도록 초대합니다. 궁금한 점이 있거나 첫 번째 단계를 안내해 줄 사람이 필요한 경우 주저하지 마시고 문의 해주세요. 언제든지 기꺼이 도와 드리겠습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 회의는 일반적으로 &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;numpy-discussion 메일 링리스트&lt;/a&gt; 에 발표됩니다 . 회의록은 &lt;a href=&quot;https://hackmd.io/oB_boakvRqKR-_2jRV-Qjg&quot;&gt;hackmd.io&lt;/a&gt; 에서 작성되어 &lt;a href=&quot;https://github.com/numpy/archive&quot;&gt;NumPy Archive 저장소에 저장&lt;/a&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="1252a4902fb7242313c7e4fd534a4effe97cd036" translate="yes" xml:space="preserve">
          <source>NumPy has a few import-time, compile-time, or runtime options which change the global behaviour. Most of these are related to performance or for debugging purposes and will not be interesting to the vast majority of users.</source>
          <target state="translated">NumPy에는 전역 동작을 변경하는 몇 가지 가져 오기 시간, 컴파일 시간 또는 런타임 옵션이 있습니다. 이들 중 대부분은 성능 또는 디버깅 목적과 관련이 있으며 대다수의 사용자에게는 흥미롭지 않습니다.</target>
        </trans-unit>
        <trans-unit id="99117692035516c5cb720484aff4e4e585660600" translate="yes" xml:space="preserve">
          <source>NumPy has a set of rules for dealing with arrays that have differing shapes which are applied whenever functions take multiple operands which combine element-wise. This is called &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;broadcasting&lt;/a&gt;. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object can apply these rules for you when you need to write such a function.</source>
          <target state="translated">NumPy에는 함수가 요소별로 결합하는 여러 피연산자를 사용할 때마다 적용되는 다른 모양을 가진 배열을 처리하기위한 규칙 세트가 있습니다. 이것을 &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;방송&lt;/a&gt; 이라고 합니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 이 같은 함수를 작성해야하는 경우 객체는 이러한 규칙을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="333e27cc5487f69edc109f8bd0d8086fc2dbda03" translate="yes" xml:space="preserve">
          <source>NumPy has built-in functions for creating arrays from scratch:</source>
          <target state="translated">NumPy에는 처음부터 배열을 생성하는 내장 함수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="60168f40b56e28aca9cf44fb018703394a1b278b" translate="yes" xml:space="preserve">
          <source>NumPy has the following versioning scheme (numbers given are examples; they can be &amp;gt; 9) in principle):</source>
          <target state="translated">NumPy에는 다음과 같은 버전 관리 체계가 있습니다 (주어진 숫자는 예제이며 9보다 클 수 있음).</target>
        </trans-unit>
        <trans-unit id="79eee1716a93d0c26d644ba6dc16d49583d1dea3" translate="yes" xml:space="preserve">
          <source>NumPy includes several constants:</source>
          <target state="translated">NumPy는 여러 상수를 포함합니다 :</target>
        </trans-unit>
        <trans-unit id="7f95e3acee5a2de64945dfe9e2cae9083154d9ea" translate="yes" xml:space="preserve">
          <source>NumPy internals</source>
          <target state="translated">NumPy 내부</target>
        </trans-unit>
        <trans-unit id="6dae93447071b4ec5703dcc87628e48329941095" translate="yes" xml:space="preserve">
          <source>NumPy is a community-owned and community-run project. To the maximum extent possible, decisions about project direction are made by community consensus (but note that &amp;ldquo;consensus&amp;rdquo; here has a somewhat technical meaning that might not match everyone&amp;rsquo;s expectations &amp;ndash; see below). Some members of the community additionally contribute by serving on the NumPy steering council, where they are responsible for facilitating the establishment of community consensus, for stewarding project resources, and &amp;ndash; in extreme cases &amp;ndash; for making project decisions if the normal community-based process breaks down.</source>
          <target state="translated">NumPy는 커뮤니티 소유 및 커뮤니티 운영 프로젝트입니다. 가능한 한 최대한 프로젝트 방향에 대한 결정은 커뮤니티 합의에 의해 내려집니다 (그러나 여기에서 &quot;합의&quot;는 모든 사람의 기대와 일치하지 않을 수있는 다소 기술적 의미가 있음에 유의하십시오 &amp;ndash; 아래 참조). 커뮤니티의 일부 구성원은 추가로 NumPy 운영 협의회에 참여하여 커뮤니티 합의 수립을 촉진하고 프로젝트 자원을 관리하며 극단적 인 경우에는 정상적인 커뮤니티 기반 프로세스가 중단 될 경우 프로젝트 결정을 내릴 책임이 있습니다. 하위.</target>
        </trans-unit>
        <trans-unit id="99f4695ea1e6796c3681301e16dfcf7c8b735296" translate="yes" xml:space="preserve">
          <source>NumPy is a distributed, volunteer, open-source project. &lt;em&gt;You&lt;/em&gt; can help us make it better; if you believe something should be improved either in functionality or in documentation, don&amp;rsquo;t hesitate to contact us &amp;mdash; or even better, contact us and participate in fixing the problem.</source>
          <target state="translated">NumPy는 분산 된 자원 봉사자 오픈 소스 프로젝트입니다. &lt;em&gt;당신은&lt;/em&gt; 우리가 더 잘 할 수 있습니다; 기능이나 문서에서 개선해야 할 사항이 있다고 생각되면 주저하지 말고 저희에게 연락하십시오. 또는 더 나은 방법으로 저희에게 연락하여 문제 해결에 참여하십시오.</target>
        </trans-unit>
        <trans-unit id="991ba5f7e8a9558d2bf270584d8056914d9ad664" translate="yes" xml:space="preserve">
          <source>NumPy is a successor for two earlier scientific Python libraries: Numeric and Numarray.</source>
          <target state="translated">NumPy는 두 개의 이전 과학 Python 라이브러리 인 Numeric 및 Numarray의 후속 제품입니다.</target>
        </trans-unit>
        <trans-unit id="4e2a33b46873f26a8ea57c12754716a4bc2bae10" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, a general-purpose language. The advantage to NumPy is access to Python libraries including: &lt;a href=&quot;https://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt;, &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;, &lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt;, &lt;a href=&quot;https://opencv.org/&quot;&gt;OpenCV&lt;/a&gt;, and more. In addition, Python is often &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language&quot;&gt;embedded as a scripting language&lt;/a&gt; in other software, allowing NumPy to be used there too.</source>
          <target state="translated">NumPy는 범용 언어 인 Python을 기반으로합니다. NumPy의 장점은 &lt;a href=&quot;https://www.scipy.org/&quot;&gt;SciPy&lt;/a&gt; , &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt; , &lt;a href=&quot;https://pandas.pydata.org/&quot;&gt;Pandas&lt;/a&gt; , &lt;a href=&quot;https://opencv.org/&quot;&gt;OpenCV&lt;/a&gt; 등을 포함한 Python 라이브러리에 대한 액세스 입니다. 또한 Python은 종종 다른 소프트웨어에 &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_Python_software#Embedded_as_a_scripting_language&quot;&gt;스크립팅 언어로 포함&lt;/a&gt; 되어 NumPy도 여기에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0402fb92221bd3cd2c68208cc2865ddc5a180086" translate="yes" xml:space="preserve">
          <source>NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab&amp;rsquo;s syntax for some array manipulations is more compact than NumPy&amp;rsquo;s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance dealing properly with stacks of matrices.</source>
          <target state="translated">NumPy는 처음부터 우수한 범용 프로그래밍 언어로 설계된 Python을 기반으로합니다. 일부 배열 조작에 대한 Matlab의 구문은 NumPy보다 더 간결하지만 NumPy (Python에 대한 추가 기능으로 인해)는 Matlab이 할 수없는 많은 일을 수행 할 수 있습니다 (예 : 행렬 스택을 적절하게 처리).</target>
        </trans-unit>
        <trans-unit id="0a1930f65134cee5b200e1969765b9f9a7fa7a24" translate="yes" xml:space="preserve">
          <source>NumPy is now typed</source>
          <target state="translated">이제 NumPy가 입력되었습니다.</target>
        </trans-unit>
        <trans-unit id="6eab1c6f817d74852716edac9ada3c155fd78dc5" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package for scientific computing in Python. It is a Python library that provides a multidimensional array object, various derived objects (such as masked arrays and matrices), and an assortment of routines for fast operations on arrays, including mathematical, logical, shape manipulation, sorting, selecting, I/O, discrete Fourier transforms, basic linear algebra, basic statistical operations, random simulation and much more.</source>
          <target state="translated">NumPy는 Python의 과학 컴퓨팅을위한 기본 패키지입니다. 다차원 배열 객체, 다양한 파생 객체 (예 : 마스킹 된 배열 및 행렬) 및 수학적, 논리적, 모양 조작, 정렬, 선택, I / O를 포함하여 배열에 대한 빠른 작업을위한 루틴 모음을 제공하는 Python 라이브러리입니다. , 이산 푸리에 변환, 기본 선형 대수, 기본 통계 연산, 랜덤 시뮬레이션 등.</target>
        </trans-unit>
        <trans-unit id="0da01ca615e98a9d3de5876bf011bc4feb765cc1" translate="yes" xml:space="preserve">
          <source>NumPy is the fundamental package needed for scientific computing with Python. This package contains:</source>
          <target state="translated">NumPy는 Python을 사용한 과학 컴퓨팅에 필요한 기본 패키지입니다. 이 패키지에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2707988141b2528631eeb146c6abc6ae889534d6" translate="yes" xml:space="preserve">
          <source>NumPy is very flexible. Trying to describe the full range of possibilities statically would result in types that are not very helpful. For that reason, the typed NumPy API is often stricter than the runtime NumPy API. This section describes some notable differences.</source>
          <target state="translated">NumPy는 매우 유연합니다. 가능성의 전체 범위를 정적으로 설명하려고 시도하면 그다지 도움이되지 않는 유형이 생성 될 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 이러한 이유로 형식화 된 NumPy API는 종종 런타임 NumPy API보다 더 엄격합니다. 이 섹션에서는 몇 가지 주목할만한 차이점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a0842da7a3c9a631b811fb55a0710af0d36229b7" translate="yes" xml:space="preserve">
          <source>NumPy itself is normally intentionally limited to a single thread during function calls, however it does support multiple Python threads running at the same time. Note that for performant linear algebra NumPy uses a BLAS backend such as OpenBLAS or MKL, which may use multiple threads that may be controlled by environment variables such as &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; depending on what is used. One way to control the number of threads is the package &lt;a href=&quot;https://pypi.org/project/threadpoolctl/&quot;&gt;threadpoolctl&lt;/a&gt;</source>
          <target state="translated">NumPy 자체는 일반적으로 함수 호출 중에 의도적으로 단일 스레드로 제한되지만 동시에 실행되는 여러 Python 스레드를 지원합니다. 성능이 뛰어난 선형 대수학의 경우 NumPy는 OpenBLAS 또는 MKL과 같은 BLAS 백엔드를 사용하며, 사용되는 항목에 따라 &lt;code&gt;OMP_NUM_THREADS&lt;/code&gt; 와 같은 환경 변수에 의해 제어 될 수있는 여러 스레드를 사용할 수 있습니다 . 스레드 수를 제어하는 ​​한 가지 방법은 &lt;a href=&quot;https://pypi.org/project/threadpoolctl/&quot;&gt;threadpoolctl&lt;/a&gt; 패키지입니다.</target>
        </trans-unit>
        <trans-unit id="fa3d14564899f1e1d8b53467e884e70e752511fc" translate="yes" xml:space="preserve">
          <source>NumPy license</source>
          <target state="translated">NumPy 라이선스</target>
        </trans-unit>
        <trans-unit id="c6c5b9ca35b73a4c5ad8cc11ecf764298cf0bacc" translate="yes" xml:space="preserve">
          <source>NumPy may be built with relaxed stride checking debugging</source>
          <target state="translated">NumPy는 편안한 보폭 검사 디버깅으로 구축 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e53e90e7b656a00b8ffca88bb6b89ffe64b4a95" translate="yes" xml:space="preserve">
          <source>NumPy numerical types are instances of &lt;code&gt;dtype&lt;/code&gt; (data-type) objects, each having unique characteristics. Once you have imported NumPy using</source>
          <target state="translated">NumPy 숫자 유형은 각각 고유 한 특성을 가진 &lt;code&gt;dtype&lt;/code&gt; (데이터 유형) 개체의 인스턴스입니다 . 다음을 사용하여 NumPy를 가져 오면</target>
        </trans-unit>
        <trans-unit id="385beaafbdefdbe97d289ec18bd9e262a0ed8458" translate="yes" xml:space="preserve">
          <source>NumPy offers more indexing facilities than regular Python sequences. In addition to indexing by integers and slices, as we saw before, arrays can be indexed by arrays of integers and arrays of booleans.</source>
          <target state="translated">NumPy는 일반 Python 시퀀스보다 더 많은 인덱싱 기능을 제공합니다. 정수와 슬라이스로 인덱싱하는 것 외에도, 앞에서 본 것처럼 배열은 정수 배열과 부울 배열로 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ac2c9d8a2fd7d4b8f16afdbb4951561e207021" translate="yes" xml:space="preserve">
          <source>NumPy operations are usually done on pairs of arrays on an element-by-element basis. In the simplest case, the two arrays must have exactly the same shape, as in the following example:</source>
          <target state="translated">NumPy 작업은 일반적으로 요소별로 배열 쌍에서 수행됩니다. 가장 간단한 경우, 두 배열은 다음 예제와 같이 정확히 동일한 모양을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="0aab5ecc0999cd974eb3c7668641606fa9f4eb6b" translate="yes" xml:space="preserve">
          <source>NumPy project governance and decision-making</source>
          <target state="translated">NumPy 프로젝트 거버넌스 및 의사 결정</target>
        </trans-unit>
        <trans-unit id="344b2ccffdbc846784cb6ec3e6e0955c7148fb58" translate="yes" xml:space="preserve">
          <source>NumPy provides &lt;a href=&quot;../reference/generated/numpy.iinfo#numpy.iinfo&quot;&gt;&lt;code&gt;numpy.iinfo&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.finfo#numpy.finfo&quot;&gt;&lt;code&gt;numpy.finfo&lt;/code&gt;&lt;/a&gt; to verify the minimum or maximum values of NumPy integer and floating point values respectively</source>
          <target state="translated">NumPy는 NumPy 정수 및 부동 소수점 값의 최소값 또는 최대 값을 각각 확인하기 위해 &lt;a href=&quot;../reference/generated/numpy.iinfo#numpy.iinfo&quot;&gt; &lt;code&gt;numpy.iinfo&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.finfo#numpy.finfo&quot;&gt; &lt;code&gt;numpy.finfo&lt;/code&gt; &lt;/a&gt; 를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="e0b798355ee6b0ba0edb9030dee01599200313df" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code than create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="translated">NumPy는 사용자가 시스템을 확장하고 다른 루틴에서 사용하기 위해 배열 개체에 액세스 할 수 있도록 C-API를 제공합니다. C-API를 진정으로 이해하는 가장 좋은 방법은 소스 코드를 읽는 것입니다. 그러나 (C) 소스 코드에 익숙하지 않은 경우 처음에는 벅찬 경험이 될 수 있습니다. 연습을하면 작업이 더 쉬워지고 C 코드를 이해하는 것이 얼마나 간단한 지 놀랄 수 있습니다. 당신은 당신이 처음부터 C-코드를 작성할 수 있다고 생각하지 않습니다하더라도, 이해하고 만드는 것보다 이미 작성된 소스 코드를 수정하는 것이 훨씬 쉽다 &lt;em&gt;드 노보를&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="c8046368fea8bda3d4541728b814c2be74d1348d" translate="yes" xml:space="preserve">
          <source>NumPy provides a C-API to enable users to extend the system and get access to the array object for use in other routines. The best way to truly understand the C-API is to read the source code. If you are unfamiliar with (C) source code, however, this can be a daunting experience at first. Be assured that the task becomes easier with practice, and you may be surprised at how simple the C-code can be to understand. Even if you don&amp;rsquo;t think you can write C-code from scratch, it is much easier to understand and modify already-written source code then create it &lt;em&gt;de novo&lt;/em&gt;.</source>
          <target state="translated">NumPy는 C-API를 제공하여 사용자가 시스템을 확장하고 다른 루틴에서 사용하기 위해 배열 객체에 액세스 할 수 있도록합니다. C-API를 진정으로 이해하는 가장 좋은 방법은 소스 코드를 읽는 것입니다. 그러나 (C) 소스 코드에 익숙하지 않다면 처음에는 어려운 경험이 될 수 있습니다. 실습을 통해 작업이 쉬워 지므로 C 코드를 이해하기가 얼마나 간단한 지 놀랄 수 있습니다. C 코드를 처음부터 작성할 수 없다고 생각하더라도 이미 작성된 소스 코드를 이해하고 수정 한 다음 &lt;em&gt;새로운&lt;/em&gt; 코드를 작성하는 것이 훨씬 쉽습니다.&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="93fc0aec43944a02522a3921ad457b6e9255c9c4" translate="yes" xml:space="preserve">
          <source>NumPy provides a convenience function called &lt;code&gt;ctypeslib.load_library&lt;/code&gt; (name, path). This function takes the name of the shared library (including any prefix like &amp;lsquo;lib&amp;rsquo; but excluding the extension) and a path where the shared library can be located. It returns a ctypes library object or raises an &lt;code&gt;OSError&lt;/code&gt; if the library cannot be found or raises an &lt;code&gt;ImportError&lt;/code&gt; if the ctypes module is not available. (Windows users: the ctypes library object loaded using &lt;code&gt;load_library&lt;/code&gt; is always loaded assuming cdecl calling convention. See the ctypes documentation under &lt;code&gt;ctypes.windll&lt;/code&gt; and/or &lt;code&gt;ctypes.oledll&lt;/code&gt; for ways to load libraries under other calling conventions).</source>
          <target state="translated">NumPy는 &lt;code&gt;ctypeslib.load_library&lt;/code&gt; (이름, 경로) 라는 편리한 기능을 제공합니다 . 이 함수는 공유 라이브러리의 이름 ( 'lib'와 같은 접두어 포함, 확장자 제외)과 공유 라이브러리가 위치 할 수있는 경로를 사용합니다. ctypes 라이브러리 객체를 반환하거나 라이브러리를 찾을 수없는 경우 &lt;code&gt;OSError&lt;/code&gt; 를 발생시키고 ctypes 모듈을 사용할 수없는 경우 &lt;code&gt;ImportError&lt;/code&gt; 를 발생시킵니다. (Windows 사용자 : &lt;code&gt;load_library&lt;/code&gt; 를 사용하여로드 된 ctypes 라이브러리 객체 는 항상 cdecl 호출 규칙을 가정 하여로드됩니다. 다른 호출 규칙에 따라 라이브러리를로드하는 방법 은 &lt;code&gt;ctypes.windll&lt;/code&gt; 및 / 또는 &lt;code&gt;ctypes.oledll&lt;/code&gt; 의 ctypes 설명서를 참조하십시오 ).</target>
        </trans-unit>
        <trans-unit id="1cfa01d82f003cb630031c6b813526f750ab53b1" translate="yes" xml:space="preserve">
          <source>NumPy provides a set of macros that define &lt;a href=&quot;https://numpy.org/neps/nep-0038-SIMD-optimizations.html&quot;&gt;Universal Intrinsics&lt;/a&gt; to abstract out typical platform-specific intrinsics so SIMD code needs to be written only once. There are three layers:</source>
          <target state="translated">NumPy는 일반적인 플랫폼 별 내장 함수를 추상화하기 위해 &lt;a href=&quot;https://numpy.org/neps/nep-0038-SIMD-optimizations.html&quot;&gt;범용 내장&lt;/a&gt; 함수 를 정의하는 일련의 매크로를 제공 하므로 SIMD 코드는 한 번만 작성하면됩니다. 세 가지 레이어가 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7a7d5fdc3538cf929aee4c511ed8f06972767b8" translate="yes" xml:space="preserve">
          <source>NumPy provides an N-dimensional array type, the &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt;, which describes a collection of &amp;ldquo;items&amp;rdquo; of the same type. The items can be &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;indexed&lt;/a&gt; using for example N integers.</source>
          <target state="translated">NumPy는 &lt;a href=&quot;arrays.ndarray#arrays-ndarray&quot;&gt;ndarray&lt;/a&gt; 라는 N 차원 배열 유형을 제공하며 , 이는 동일한 유형의 &quot;항목&quot;모음을 설명합니다. 항목을 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;색인&lt;/a&gt; 할 수 있습니다예를 들어 N 정수를 사용하여 .</target>
        </trans-unit>
        <trans-unit id="1a75765bb40779d587b945d346fd4f25656a32a8" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="translated">NumPy는 향상된 distutils 기능을 제공하여 포트란 컴파일 된 라이브러리를 사용하는 하위 패키지, 자동 생성 코드 및 확장 모듈을보다 쉽게 ​​빌드하고 설치할 수 있습니다. NumPy distutils의 기능을 사용하려면 &lt;code&gt;numpy.distutils.core&lt;/code&gt; 의 &lt;code&gt;setup&lt;/code&gt; 명령을 사용하십시오 . &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 에&lt;/a&gt; 유용한 &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 클래스가 제공되어 키워드의 인수를 구성 함수로 전달하기 쉽게 만들 수 있습니다 (클래스의 todict () 메서드에서 얻은 사전을 전달하여). 자세한 내용은 &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils-사용 설명서를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dc45b2b061a3c987c044eb3531af83d969814354" translate="yes" xml:space="preserve">
          <source>NumPy provides enhanced distutils functionality to make it easier to build and install sub-packages, auto-generate code, and extension modules that use Fortran-compiled libraries. To use features of NumPy distutils, use the &lt;code&gt;setup&lt;/code&gt; command from &lt;code&gt;numpy.distutils.core&lt;/code&gt;. A useful &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; class is also provided in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt; that can make it easier to construct keyword arguments to pass to the setup function (by passing the dictionary obtained from the todict() method of the class). More information is available in the &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils - Users Guide&lt;/a&gt;.</source>
          <target state="translated">NumPy는 Fortran에서 컴파일 된 라이브러리를 사용하는 하위 패키지, 자동 생성 코드 및 확장 모듈을 쉽게 빌드 및 설치할 수 있도록 향상된 distutils 기능을 제공합니다. NumPy distutils의 기능을 사용하려면 &lt;code&gt;numpy.distutils.core&lt;/code&gt; 에서 &lt;code&gt;setup&lt;/code&gt; 명령을 사용하십시오 . &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; 에도 유용한 &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 클래스가 제공되어 설정 함수에 전달할 키워드 인수를 쉽게 구성 할 수 있습니다 (클래스의 todict () 메서드에서 얻은 사전을 전달하여). 자세한 내용은 &lt;a href=&quot;distutils_guide#distutils-user-guide&quot;&gt;NumPy Distutils-사용자 가이드&lt;/a&gt; 에서 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6a083cfd3cae0f2b0c71ffa2d89ecb4205930693" translate="yes" xml:space="preserve">
          <source>NumPy provides familiar mathematical functions such as sin, cos, and exp. In NumPy, these are called &amp;ldquo;universal functions&amp;rdquo;(&lt;code&gt;ufunc&lt;/code&gt;). Within NumPy, these functions operate elementwise on an array, producing an array as output.</source>
          <target state="translated">NumPy는 sin, cos 및 exp와 같은 친숙한 수학 함수를 제공합니다. NumPy에서는이를 &quot;범용 함수&quot;( &lt;code&gt;ufunc&lt;/code&gt; )라고합니다. NumPy 내에서 이러한 함수는 배열에서 요소별로 작동하여 배열을 출력으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="5a62542984876095dd49786ce30743b4af981559" translate="yes" xml:space="preserve">
          <source>NumPy provides several functions to create arrays from tabular data. We focus here on the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">NumPy는 테이블 형식 데이터에서 배열을 생성하는 여러 기능을 제공합니다. 여기서는 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 함수 에 중점을 둡니다 .</target>
        </trans-unit>
        <trans-unit id="23cd70d7e4f84112d992fc760c41c139b7d9150b" translate="yes" xml:space="preserve">
          <source>NumPy provides several hooks that classes can customize:</source>
          <target state="translated">NumPy는 클래스가 사용자 정의 할 수있는 몇 가지 후크를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="db997f8d5529d90e4e824067ebfe5d83669d3578" translate="yes" xml:space="preserve">
          <source>NumPy provides the &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; class which allows accessing the fields of a structured array as attributes, and a corresponding scalar data type object &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;record&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">NumPy는 구조화 된 배열의 필드에 속성으로 액세스 할 수 있는 &lt;a href=&quot;generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt; 클래스 및 해당 스칼라 데이터 유형 오브젝트 &lt;a href=&quot;generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;record&lt;/code&gt; &lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="46067414ac2be3ec3b21adf1f81bfbaed905b370" translate="yes" xml:space="preserve">
          <source>NumPy quickstart</source>
          <target state="translated">NumPy 빠른 시작</target>
        </trans-unit>
        <trans-unit id="2334ad60fc95510fca18811e881286378efc5596" translate="yes" xml:space="preserve">
          <source>NumPy refers to each dimension as an &lt;code&gt;axis&lt;/code&gt;. Because of how &lt;code&gt;imread&lt;/code&gt; works, the &lt;em&gt;first index in the 3rd axis&lt;/em&gt; is the red pixel data for our image. We can access this by using the syntax</source>
          <target state="translated">NumPy는 각 차원을 &lt;code&gt;axis&lt;/code&gt; 합니다. &lt;code&gt;imread&lt;/code&gt; 의 작동 방식 때문에 &lt;em&gt;세 번째 축의 첫 번째 인덱스는&lt;/em&gt; 이미지의 빨간색 픽셀 데이터입니다. 구문을 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aaeae0e0ef5087fb1cba7dbba1eef7ee4ab1c725" translate="yes" xml:space="preserve">
          <source>NumPy searches for optimized linear algebra libraries such as BLAS and LAPACK. There are specific orders for searching these libraries, as described below and in the &lt;code&gt;site.cfg.example&lt;/code&gt; file.</source>
          <target state="translated">NumPy는 BLAS 및 LAPACK과 같은 최적화 된 선형 대수 라이브러리를 검색합니다. 아래 및 &lt;code&gt;site.cfg.example&lt;/code&gt; 파일 에 설명 된대로 이러한 라이브러리를 검색하는 특정 순서가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6871239fcd860bb968e0e454a350e13641da17d" translate="yes" xml:space="preserve">
          <source>NumPy slices are by reference</source>
          <target state="translated">NumPy 슬라이스는 참조 용입니다.</target>
        </trans-unit>
        <trans-unit id="e0ea34766b2df6ce15b555bccc153c9453e468d7" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="translated">NumPy 슬라이싱은 문자열, 튜플 및 목록과 같은 내장 Python 시퀀스의 경우와 같이 복사본 대신 &lt;a href=&quot;../glossary#term-view&quot;&gt;뷰&lt;/a&gt; 를 생성 합니다. 추출 후 쓸모 없게되는 큰 배열에서 작은 부분을 추출 할 때주의해야합니다. 추출 된 작은 부분에는 그로부터 파생 된 모든 배열이 가비지 수집 될 때까지 메모리가 해제되지 않는 큰 원본 배열에 대한 참조가 포함되어 있기 때문입니다. 이러한 경우 명시 적 &lt;code&gt;copy()&lt;/code&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b50bd9e44504ee882f7d36e3a1a29183cd10ae09" translate="yes" xml:space="preserve">
          <source>NumPy slicing creates a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; instead of a copy as in the case of builtin Python sequences such as string, tuple and list. Care must be taken when extracting a small portion from a large array which becomes useless after the extraction, because the small portion extracted contains a reference to the large original array whose memory will not be released until all arrays derived from it are garbage-collected. In such cases an explicit &lt;code&gt;copy()&lt;/code&gt; is recommended.</source>
          <target state="translated">NumPy 슬라이싱은 문자열, 튜플 및 목록과 같은 내장 Python 시퀀스의 경우와 같이 복사본 대신 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;보기&lt;/a&gt; 를 만듭니다 . 추출 된 작은 부분은 메모리에서 파생 된 모든 배열이 가비지 수집 될 때까지 메모리가 해제되지 않는 큰 원래 배열에 대한 참조를 포함하므로 추출 후 쓸모없는 큰 배열에서 작은 부분을 추출 할 때는주의해야합니다. 이러한 경우 명시 적 &lt;code&gt;copy()&lt;/code&gt; 가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="9315eaa766c603c7ff5592ed435945f3c4e579c8" translate="yes" xml:space="preserve">
          <source>NumPy stores an internal table of Python callable objects that are used to implement arithmetic operations for arrays as well as certain array calculation methods. This function allows the user to replace any or all of these Python objects with their own versions. The keys of the dictionary, &lt;em&gt;dict&lt;/em&gt;, are the named functions to replace and the paired value is the Python callable object to use. Care should be taken that the function used to replace an internal array operation does not itself call back to that internal array operation (unless you have designed the function to handle that), or an unchecked infinite recursion can result (possibly causing program crash). The key names that represent operations that can be replaced are:</source>
          <target state="translated">NumPy는 특정 배열 계산 방법뿐만 아니라 배열에 대한 산술 연산을 구현하는 데 사용되는 Python 호출 가능 객체의 내부 테이블을 저장합니다. 이 함수를 사용하면 사용자는 이러한 Python 객체 중 일부 또는 전부를 자체 버전으로 바꿀 수 있습니다. 사전의 키 &lt;em&gt;DICT&lt;/em&gt; 대체 할 명명 된 함수이며 쌍으로 된 값은 사용할 Python 호출 가능 객체입니다. 내부 배열 연산을 대체하는 데 사용 된 함수가 해당 내부 배열 연산을 다시 호출하지 않거나 (해당 함수를 처리하도록 함수를 설계하지 않은 경우) 확인되지 않은 무한 재귀가 발생할 수 있습니다 (프로그램 충돌의 원인이 될 수 있음). 대체 할 수있는 조작을 나타내는 키 이름은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="387d18f40b5cc90de6d4cee0fbe4a352c5b8dee6" translate="yes" xml:space="preserve">
          <source>NumPy style governs cases where:</source>
          <target state="translated">NumPy 스타일은 다음과 같은 경우에 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="e0ffae4d5e74817321bd554d6e22d7ad10db9e4c" translate="yes" xml:space="preserve">
          <source>NumPy supports PEP 3141 numbers:</source>
          <target state="translated">NumPy는 PEP 3141 번호를 지원합니다 :</target>
        </trans-unit>
        <trans-unit id="a30e09b28bd3a22ee136145ff9e9655f237427ce" translate="yes" xml:space="preserve">
          <source>NumPy supports a much greater variety of numerical types than Python does. This section shows which are available, and how to modify an array&amp;rsquo;s data-type.</source>
          <target state="translated">NumPy는 Python보다 훨씬 더 다양한 숫자 유형을 지원합니다. 이 섹션에서는 사용 가능한 항목과 배열의 데이터 유형을 수정하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="233a312424d8a0ad1356c1a0f6d65ae323b75b8a" translate="yes" xml:space="preserve">
          <source>NumPy understands that the multiplication should happen with each cell. That concept is called &lt;strong&gt;broadcasting&lt;/strong&gt;. Broadcasting is a mechanism that allows NumPy to perform operations on arrays of different shapes. The dimensions of your array must be compatible, for example, when the dimensions of both arrays are equal or when one of them is 1. If the dimensions are not compatible, you will get a &lt;code&gt;ValueError&lt;/code&gt;.</source>
          <target state="translated">NumPy는 곱셈이 각 셀에서 발생해야한다는 것을 이해합니다. 그 개념을 &lt;strong&gt;방송&lt;/strong&gt; 이라고 합니다. 브로드 캐스팅은 NumPy가 다양한 모양의 배열에서 작업을 수행 할 수 있도록하는 메커니즘입니다. 예를 들어 두 배열의 차원이 같거나 둘 중 하나가 1 인 경우 배열의 차원은 호환되어야합니다. 차원이 호환되지 않으면 &lt;code&gt;ValueError&lt;/code&gt; 가 발생 합니다.</target>
        </trans-unit>
        <trans-unit id="ce9b240ab41f1a17ca7549bbe67eafcc942f1048" translate="yes" xml:space="preserve">
          <source>NumPy user guide</source>
          <target state="translated">NumPy 사용자 가이드</target>
        </trans-unit>
        <trans-unit id="f9253086c7c4965c63bda0ce6993cc9b981baa4c" translate="yes" xml:space="preserve">
          <source>NumPy uses a series of tests to probe the compiler and libc libraries for funtions. The results are stored in &lt;code&gt;_numpyconfig.h&lt;/code&gt; and &lt;code&gt;config.h&lt;/code&gt; files using &lt;code&gt;HAVE_XXX&lt;/code&gt; definitions. These tests are run during the &lt;code&gt;build_src&lt;/code&gt; phase of the &lt;code&gt;_multiarray_umath&lt;/code&gt; module in the &lt;code&gt;generate_config_h&lt;/code&gt; and &lt;code&gt;generate_numpyconfig_h&lt;/code&gt; functions. Since the output of these calls includes many compiler warnings and errors, by default it is run quietly. If you wish to see this output, you can run the &lt;code&gt;build_src&lt;/code&gt; stage verbosely:</source>
          <target state="translated">NumPy는 일련의 테스트를 사용하여 기능을 위해 컴파일러 및 libc 라이브러리를 조사합니다. 결과에 저장됩니다 &lt;code&gt;_numpyconfig.h&lt;/code&gt; 과 &lt;code&gt;config.h&lt;/code&gt; 를 사용하여 파일 &lt;code&gt;HAVE_XXX&lt;/code&gt; 의 정의를. 이러한 테스트는 &lt;code&gt;generate_config_h&lt;/code&gt; 및 &lt;code&gt;generate_numpyconfig_h&lt;/code&gt; 함수 에서 &lt;code&gt;_multiarray_umath&lt;/code&gt; 모듈 의 &lt;code&gt;build_src&lt;/code&gt; 단계에서 실행됩니다 . 이러한 호출의 출력에는 많은 컴파일러 경고 및 오류가 포함되어 있으므로 기본적으로 조용히 실행됩니다. 이 출력을 보려면 &lt;code&gt;build_src&lt;/code&gt; 단계를 자세히 실행할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a7fbc5d580827f690776ae9fde2ddf99b3716968" translate="yes" xml:space="preserve">
          <source>NumPy uses both methods with a preference for the second method because it can be safer. The ctypes attribute of the ndarray returns an object that has an &lt;code&gt;_as_parameter_&lt;/code&gt; attribute which returns an integer representing the address of the ndarray to which it is associated. As a result, one can pass this ctypes attribute object directly to a function expecting a pointer to the data in your ndarray. The caller must be sure that the ndarray object is of the correct type, shape, and has the correct flags set or risk nasty crashes if the data-pointer to inappropriate arrays are passed in.</source>
          <target state="translated">NumPy는 더 안전 할 수 있기 때문에 두 번째 방법을 선호하는 두 방법을 모두 사용합니다. ndarray의 ctypes 속성 은 연관된 ndarray의 주소를 나타내는 정수를 리턴하는 &lt;code&gt;_as_parameter_&lt;/code&gt; 속성 이있는 오브젝트 를 리턴합니다. 결과적으로이 ctypes 속성 객체를 ndarray의 데이터에 대한 포인터를 예상하는 함수에 직접 전달할 수 있습니다. 호출자는 ndarray 객체가 올바른 유형, 모양이며 올바른 플래그가 설정되어 있는지 확인해야합니다. 그렇지 않으면 부적절한 배열에 대한 데이터 포인터가 전달되면 심각한 충돌이 발생할 위험이 있습니다.</target>
        </trans-unit>
        <trans-unit id="fddaf9c91d8d4012f023752f68ed0149bce87d6e" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754).</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="8667558f0f51c03b2587a599efedda1f9f4468ac" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Negative zero is considered to be a finite number.</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다. 음수 0은 유한 숫자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="d23202e89199272fb59380a61ef4cc7654a36b65" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). Positive zero is considered to be a finite number.</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다. 양의 0은 유한 숫자로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="f42533d92c39de593371e6aa3dde32696064d2b8" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity.</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다. 이는 숫자가 아님이 무한대에 해당하지 않음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="af1c83a08aa63e00fff2b45b2f860192ca21bcf1" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity.</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다. 이는 숫자가 아님이 무한대에 해당하지 않음을 의미합니다. 또한 양의 무한대는 음의 무한대와 동일하지 않습니다. 그러나 무한대는 양의 무한대와 같습니다.</target>
        </trans-unit>
        <trans-unit id="389fed054ec853b5b8bb20d440426bf9262e8e46" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Also that positive infinity is not equivalent to negative infinity. But infinity is equivalent to positive infinity. Errors result if the second argument is also supplied when &lt;code&gt;x&lt;/code&gt; is a scalar input, or if first and second arguments have different shapes.</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다. 이것은 숫자가 아님이 무한대에 해당하지 않음을 의미합니다. 또한 양의 무한대는 음의 무한대와 동일하지 않습니다. 그러나 무한대는 양의 무한대와 같습니다. &lt;code&gt;x&lt;/code&gt; 가 스칼라 입력이거나 첫 번째 인수와 두 번째 인수의 모양이 다른 경우 두 번째 인수도 제공하면 오류가 발생합니다 .</target>
        </trans-unit>
        <trans-unit id="35a6249b4224925e0bdcfa0f8624c08fcc4790ef" translate="yes" xml:space="preserve">
          <source>NumPy uses the IEEE Standard for Binary Floating-Point for Arithmetic (IEEE 754). This means that Not a Number is not equivalent to infinity. Positive infinity is treated as a very large number and negative infinity is treated as a very small (i.e. negative) number.</source>
          <target state="translated">NumPy는 산술을위한 이진 부동 소수점에 대한 IEEE 표준 (IEEE 754)을 사용합니다. 이는 숫자가 아님이 무한대에 해당하지 않음을 의미합니다. 양의 무한대는 매우 큰 숫자로 취급되고 음의 무한대는 매우 작은 (즉, 음수) 숫자로 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="4026f26ee4d1cd9de2a496e4e3dd03a3e5a7f962" translate="yes" xml:space="preserve">
          <source>NumPy v1.19 Manual</source>
          <target state="translated">NumPy v1.19 매뉴얼</target>
        </trans-unit>
        <trans-unit id="a799f9f2b696a8693dd829a76caa31a7afbdcb94" translate="yes" xml:space="preserve">
          <source>NumPy v1.20 Manual</source>
          <target state="translated">NumPy v1.20 매뉴얼</target>
        </trans-unit>
        <trans-unit id="3ea0a36ef00ca34de0c91ee7b58a561c1bb0550a" translate="yes" xml:space="preserve">
          <source>NumPy version comparison</source>
          <target state="translated">NumPy 버전 비교</target>
        </trans-unit>
        <trans-unit id="8ba9f463515e23b0f299b2ffc9d54837e3d43200" translate="yes" xml:space="preserve">
          <source>NumPy version string (&lt;code&gt;np.__version__&lt;/code&gt;).</source>
          <target state="translated">NumPy 버전 문자열 ( &lt;code&gt;np.__version__&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="9b3a90b67fc6e7751631f73fbd200fedcaf6517b" translate="yes" xml:space="preserve">
          <source>NumPy will gather implementations of &lt;code&gt;__array_function__&lt;/code&gt; from all specified inputs and call them in order: subclasses before superclasses, and otherwise left to right. Note that in some edge cases involving subclasses, this differs slightly from the &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;current behavior&lt;/a&gt; of Python.</source>
          <target state="translated">NumPy는 지정된 모든 입력에서 &lt;code&gt;__array_function__&lt;/code&gt; 의 구현을 수집하여 수퍼 클래스 이전의 서브 클래스, 그렇지 않으면 왼쪽에서 오른쪽으로 순서대로 호출합니다. 서브 클래스와 관련된 일부 경우에는 &lt;a href=&quot;https://bugs.python.org/issue30140&quot;&gt;현재&lt;/a&gt; 파이썬의 동작 과 약간 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="eaf96b4a25ad851a2b4abd4e522b636c4d667ac3" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip()&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="translated">NumPy의 &lt;code&gt;np.flip()&lt;/code&gt; 함수를 사용하면 축을 따라 배열의 내용을 뒤집거나 뒤집을 수 있습니다. &lt;code&gt;np.flip()&lt;/code&gt; 사용할 때 반전하려는 배열과 축을 지정하십시오. 축을 지정하지 않으면 NumPy는 입력 배열의 모든 축을 따라 내용을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="2fb311f19fa41c253fcda50763e8cfca7eec45cb" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s &lt;code&gt;np.flip()&lt;/code&gt; function allows you to flip, or reverse, the contents of an array along an axis. When using &lt;code&gt;np.flip&lt;/code&gt;, specify the array you would like to reverse and the axis. If you don&amp;rsquo;t specify the axis, NumPy will reverse the contents along all of the axes of your input array.</source>
          <target state="translated">NumPy의 &lt;code&gt;np.flip()&lt;/code&gt; 함수를 사용하면 축을 따라 배열의 내용을 뒤집거나 뒤집을 수 있습니다. &lt;code&gt;np.flip&lt;/code&gt; 을 사용할 때 반전하려는 배열과 축을 지정하십시오. 축을 지정하지 않으면 NumPy는 입력 배열의 모든 축을 따라 내용을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="1b39796df6889956cc3b3ff1db77e20497876b0e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s Documentation</source>
          <target state="translated">NumPy의 문서</target>
        </trans-unit>
        <trans-unit id="86c194038698da06d4deba03ca0f701303ee7a9e" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s array class is called &lt;code&gt;ndarray&lt;/code&gt;. It is also known by the alias &lt;code&gt;array&lt;/code&gt;. Note that &lt;code&gt;numpy.array&lt;/code&gt; is not the same as the Standard Python Library class &lt;code&gt;array.array&lt;/code&gt;, which only handles one-dimensional arrays and offers less functionality. The more important attributes of an &lt;code&gt;ndarray&lt;/code&gt; object are:</source>
          <target state="translated">NumPy의 배열 클래스는 &lt;code&gt;ndarray&lt;/code&gt; 라고 합니다 . 별칭 &lt;code&gt;array&lt;/code&gt; 도 알려져 있습니다. 참고 &lt;code&gt;numpy.array&lt;/code&gt; 는 표준 파이썬 라이브러리 클래스와 동일하지 않습니다 &lt;code&gt;array.array&lt;/code&gt; 하나의 차원 배열 및 이벤트 적은 기능을 처리합니다. &lt;code&gt;ndarray&lt;/code&gt; 객체 의 더 중요한 속성 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0132beeeb0b4ce70a8210a70bdb9c78c481e563b" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s broadcasting rule relaxes this constraint when the arrays&amp;rsquo; shapes meet certain constraints. The simplest broadcasting example occurs when an array and a scalar value are combined in an operation:</source>
          <target state="translated">NumPy의 브로드 캐스팅 규칙은 배열의 모양이 특정 제약 조건을 충족 할 때이 제약 조건을 완화합니다. 가장 간단한 브로드 캐스팅 예제는 작업에서 배열과 스칼라 값이 결합 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="da6e87a1254c0e2518a18db62672d9b8b4222aec" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s documentation uses several custom extensions to Sphinx. These are shipped in the &lt;code&gt;sphinxext/&lt;/code&gt; directory (as git submodules, as discussed above), and are automatically enabled when building NumPy&amp;rsquo;s documentation.</source>
          <target state="translated">NumPy의 문서는 Sphinx에 대한 몇 가지 사용자 지정 확장을 사용합니다. 이들은 &lt;code&gt;sphinxext/&lt;/code&gt; 디렉토리 (위에서 논의한 git 하위 모듈로)에 제공되며 NumPy 문서를 빌드 할 때 자동으로 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="c9b4ca4dd070cbb18cd729b7d82f19fbc8f9eb17" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s fast element-by-element computation (&lt;a href=&quot;#term-vectorization&quot;&gt;vectorization&lt;/a&gt;) gives a choice which function gets applied. The general term for the function is &lt;code&gt;ufunc&lt;/code&gt;, short for &lt;code&gt;universal function&lt;/code&gt;. NumPy routines have built-in ufuncs, but users can also &lt;a href=&quot;reference/ufuncs&quot;&gt;write their own.&lt;/a&gt;</source>
          <target state="translated">NumPy의 빠른 요소 별 계산 ( &lt;a href=&quot;#term-vectorization&quot;&gt;벡터화&lt;/a&gt; )은 적용 할 함수를 선택할 수 있습니다. 함수의 일반적인 용어는 &lt;code&gt;universal function&lt;/code&gt; 약자 인 &lt;code&gt;ufunc&lt;/code&gt; 입니다. NumPy 루틴에는 내장 ufunc가 있지만 사용자는 &lt;a href=&quot;reference/ufuncs&quot;&gt;직접 작성할 수도 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a23df3dc68bb04fcd72ce4a7accb7a59c107ed5" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s main object is the homogeneous multidimensional array. It is a table of elements (usually numbers), all of the same type, indexed by a tuple of non-negative integers. In NumPy dimensions are called &lt;em&gt;axes&lt;/em&gt;.</source>
          <target state="translated">NumPy의 주요 객체는 동종 다차원 배열입니다. 음이 아닌 정수의 튜플에 의해 인덱싱 된 동일한 유형의 요소 (일반적으로 숫자) 테이블입니다. NumPy에서 차원은 &lt;em&gt;축&lt;/em&gt; 이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="b6bdc0eebf8a97bb8d97d7e158fade619726770f" translate="yes" xml:space="preserve">
          <source>NumPy&amp;rsquo;s two-dimensional &lt;a href=&quot;reference/generated/numpy.matrix&quot;&gt;matrix class&lt;/a&gt; should no longer be used; use regular ndarrays.</source>
          <target state="translated">NumPy의 2 차원 &lt;a href=&quot;reference/generated/numpy.matrix&quot;&gt;행렬 클래스&lt;/a&gt; 는 더 이상 사용되지 않아야합니다. 일반 ndarrays를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="4e72e3b2d20e9ce05fa10cf5b67fd4a5d867f2b5" translate="yes" xml:space="preserve">
          <source>NumPy, &lt;a href=&quot;http://www.scipy.org&quot;&gt;SciPy&lt;/a&gt;, and the scikits follow a common convention for docstrings that provides for consistency, while also allowing our toolchain to produce well-formatted reference guides. This document describes the current community consensus for such a standard. If you have suggestions for improvements, post them on the &lt;a href=&quot;http://scipy.org/scipylib/mailing-lists.html&quot;&gt;numpy-discussion list&lt;/a&gt;.</source>
          <target state="translated">NumPy, &lt;a href=&quot;http://www.scipy.org&quot;&gt;SciPy&lt;/a&gt; 및 scikits는 일관성을 제공하는 독 스트링에 대한 일반적인 규칙을 따르며, 툴체인이 올바른 형식의 참조 가이드를 생성 할 수 있도록합니다. 이 문서는 이러한 표준에 대한 현재 커뮤니티 합의를 설명합니다. 개선에 대한 제안이 있으면 &lt;a href=&quot;http://scipy.org/scipylib/mailing-lists.html&quot;&gt;numpy-discussion 목록&lt;/a&gt; 에 게시 하십시오 .</target>
        </trans-unit>
        <trans-unit id="29e598a2efe067bb7689f0ffff5764af8bbe8461" translate="yes" xml:space="preserve">
          <source>NumPy, like Python, numbers indices from 0; &lt;code&gt;a[0]&lt;/code&gt; is the first element.</source>
          <target state="translated">NumPy는 Python과 마찬가지로 0부터 숫자 인덱스를 사용합니다. &lt;code&gt;a[0]&lt;/code&gt; 은 첫 번째 요소입니다.</target>
        </trans-unit>
        <trans-unit id="65980c8f8cdaffbdb9dc6b41c004c578cf994ed4" translate="yes" xml:space="preserve">
          <source>NumPy, or rather Python, has similar facilities.</source>
          <target state="translated">NumPy 또는 Python에는 유사한 기능이 있습니다.</target>
        </trans-unit>
        <trans-unit id="8b99044d84c351a4ed63efec49bbe1ae3bf320ae" translate="yes" xml:space="preserve">
          <source>NumPy-specific help functions</source>
          <target state="translated">NumPy 관련 도움말 기능</target>
        </trans-unit>
        <trans-unit id="8e5883940f8591fc18bd2d38714b4441d0bc3808" translate="yes" xml:space="preserve">
          <source>NumPy-specific workflow is in &lt;a href=&quot;development_workflow#development-workflow&quot;&gt;numpy-development-workflow&lt;/a&gt;.</source>
          <target state="translated">NumPy 관련 워크 플로는 &lt;a href=&quot;development_workflow#development-workflow&quot;&gt;numpy-development-workflow에&lt;/a&gt; 있습니다.</target>
        </trans-unit>
        <trans-unit id="b61e66899eea7ee7ff7294019b3070d639ae0728" translate="yes" xml:space="preserve">
          <source>NumPy: the absolute basics for beginners</source>
          <target state="translated">NumPy : 초보자를위한 절대적인 기초</target>
        </trans-unit>
        <trans-unit id="16f40cf39f0e25d8cf6f052959da2085155ae248" translate="yes" xml:space="preserve">
          <source>Numba</source>
          <target state="translated">Numba</target>
        </trans-unit>
        <trans-unit id="2ad094bf2eb6f204e2abae88bcc155073c5a7b5d" translate="yes" xml:space="preserve">
          <source>Numba can be used with either CTypes or CFFI. The current iteration of the BitGenerators all export a small set of functions through both interfaces.</source>
          <target state="translated">Numba는 CType 또는 CFFI와 함께 사용할 수 있습니다. BitGenerator의 현재 반복은 모두 두 인터페이스를 통해 작은 함수 집합을 내 보냅니다.</target>
        </trans-unit>
        <trans-unit id="25996b6bfaea719dfb36b6f8bc64656e147e8c2f" translate="yes" xml:space="preserve">
          <source>Number Precision</source>
          <target state="translated">숫자 정밀도</target>
        </trans-unit>
        <trans-unit id="858e21b5a976ec86aff538495ea9c4f65e263a29" translate="yes" xml:space="preserve">
          <source>Number of &amp;lsquo;guard digits&amp;rsquo; used when truncating the product of two mantissas to fit the representation.</source>
          <target state="translated">표현에 맞게 두 가수의 곱을자를 때 사용되는 '보호 숫자'의 수입니다.</target>
        </trans-unit>
        <trans-unit id="bbf91dba201dcc9eece0dc41a5e6c527d91e56cf" translate="yes" xml:space="preserve">
          <source>Number of Threads used for Linear Algebra</source>
          <target state="translated">선형 대수에 사용되는 스레드 수</target>
        </trans-unit>
        <trans-unit id="4be768826cc42fcf995f3aef93d52ff0cd53e9ae" translate="yes" xml:space="preserve">
          <source>Number of array dimensions.</source>
          <target state="translated">배열 차원의 수</target>
        </trans-unit>
        <trans-unit id="a97fad0d0844aff9a71f23c56eb56e01fb752db2" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension (default 3).</source>
          <target state="translated">각 차원의 시작과 끝에서 요약 된 배열 항목 수 (기본값 3).</target>
        </trans-unit>
        <trans-unit id="9201c088075dba2ae62f215d4d2fdd9a8a777253" translate="yes" xml:space="preserve">
          <source>Number of array items in summary at beginning and end of each dimension. Defaults to &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt;.</source>
          <target state="translated">각 차원의 시작과 끝에서 요약 된 배열 항목 수입니다. 기본값은 &lt;code&gt;numpy.get_printoptions()['edgeitems']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="4574e45463a4337cd6208d1b13e93be562f45874" translate="yes" xml:space="preserve">
          <source>Number of base-&lt;code&gt;ibeta&lt;/code&gt; digits in the floating point mantissa M.</source>
          <target state="translated">부동 소수점 가수 M 의 기본 &lt;code&gt;ibeta&lt;/code&gt; 자릿수</target>
        </trans-unit>
        <trans-unit id="3ada3f66dbd1b40b353be9a0f81e475922b90cd9" translate="yes" xml:space="preserve">
          <source>Number of bits in data types</source>
          <target state="translated">데이터 타입의 비트 수</target>
        </trans-unit>
        <trans-unit id="f0e91946bba240191d8f8b60627edef4c8d6081d" translate="yes" xml:space="preserve">
          <source>Number of bits in the exponent (including its sign and bias).</source>
          <target state="translated">지수의 비트 수 (기호 및 바이어스 포함)</target>
        </trans-unit>
        <trans-unit id="3a305056bc0be0ed46faf9a5c4020bd05011c494" translate="yes" xml:space="preserve">
          <source>Number of bits to remove at the right of &lt;code&gt;x1&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 오른쪽에서 제거 할 비트 수입니다 . 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="bcd1696318c5332018bcf91295a29c11afe64192" translate="yes" xml:space="preserve">
          <source>Number of bytes to skip before beginning the element view.</source>
          <target state="translated">요소보기를 시작하기 전에 건너 뛸 바이트 수입니다.</target>
        </trans-unit>
        <trans-unit id="2bd38d497915bde99690ede2a81fd5739730552b" translate="yes" xml:space="preserve">
          <source>Number of columns in the array. By default, &lt;code&gt;M&lt;/code&gt; is taken equal to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">배열의 열 수 기본적으로 &lt;code&gt;M&lt;/code&gt; 은 &lt;code&gt;N&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="27e78e98de656ac1f174b228b3b3cfaba70b125d" translate="yes" xml:space="preserve">
          <source>Number of columns in the output, defaults to &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">출력의 열 수이며 기본값은 &lt;code&gt;n&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="00044a0ba0541a7997dd2599a4f9b91182edde55" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If &lt;code&gt;N&lt;/code&gt; is not specified, a square array is returned (&lt;code&gt;N = len(x)&lt;/code&gt;).</source>
          <target state="translated">출력의 열 수 경우 &lt;code&gt;N&lt;/code&gt; 이 지정되지 않은 정사각형 어레이가 반환된다 ( &lt;code&gt;N = len(x)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a06d5e776ba9dffd0e77cd97b2c7b86bb26acb1a" translate="yes" xml:space="preserve">
          <source>Number of columns in the output. If None, defaults to &lt;code&gt;N&lt;/code&gt;.</source>
          <target state="translated">출력의 열 수 None이면 기본값은 &lt;code&gt;N&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0217140ca3d5b8f088751040a1594d26b45a1b44" translate="yes" xml:space="preserve">
          <source>Number of compounding periods</source>
          <target state="translated">복리 기간 수</target>
        </trans-unit>
        <trans-unit id="97af9143d62e7223493889f6bc88440f1ed78209" translate="yes" xml:space="preserve">
          <source>Number of core dimensions of each argument</source>
          <target state="translated">각 인수의 핵심 차원 수</target>
        </trans-unit>
        <trans-unit id="33246fa87d0b3d8cf0cd33d590270d0d5b8977dd" translate="yes" xml:space="preserve">
          <source>Number of decimal places to round to (default: 0). If decimals is negative, it specifies the number of positions to the left of the decimal point.</source>
          <target state="translated">반올림 할 소수점 이하 자릿수 (기본값 : 0) 소수점이 음수이면 소수점 왼쪽의 위치 수를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="6d7f7a5c3f27de2bb3c70596c0f42aef8c17be9e" translate="yes" xml:space="preserve">
          <source>Number of decimals to round to. May be negative.</source>
          <target state="translated">반올림 할 소수 자릿수입니다. 부정적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d0f39eca925aa79a0a6c1e41a38d8c60caef28f9" translate="yes" xml:space="preserve">
          <source>Number of degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">자유도는 0보다 커야합니다.</target>
        </trans-unit>
        <trans-unit id="947cb948510d628b02b33a2e4f5d937c49f48f16" translate="yes" xml:space="preserve">
          <source>Number of derivatives taken, must be non-negative. (Default: 1)</source>
          <target state="translated">취한 파생 상품의 수는 음수가 아니어야합니다. (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="97245ef113e26038c737c690b9b01b48fa8ebd7e" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be &lt;code&gt;None&lt;/code&gt; if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="translated">부동 소수점 출력의 정밀도 자릿수 (기본값 8). &lt;code&gt;floatmode&lt;/code&gt; 가 &lt;code&gt;fixed&lt;/code&gt; 있지 않은 경우 &lt;code&gt;None&lt;/code&gt; 일 수 있습니다 . 값을 고유하게 지정하는 데 필요한만큼의 숫자를 인쇄하십시오.</target>
        </trans-unit>
        <trans-unit id="f527b9aa37b022d773444c86018ada827757d9b4" translate="yes" xml:space="preserve">
          <source>Number of digits of precision for floating point output (default 8). May be None if &lt;code&gt;floatmode&lt;/code&gt; is not &lt;code&gt;fixed&lt;/code&gt;, to print as many digits as necessary to uniquely specify the value.</source>
          <target state="translated">부동 소수점 출력의 정밀도 자릿수 (기본값 8). 값을 고유하게 지정하는 데 필요한만큼 자릿수를 인쇄 하려면 &lt;code&gt;floatmode&lt;/code&gt; 가 &lt;code&gt;fixed&lt;/code&gt; 되지 않은 경우 None 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3d97ec2f2e677c40d4431d2275107bedf5755ab8" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result.</source>
          <target state="translated">방송 결과의 차원 수입니다.</target>
        </trans-unit>
        <trans-unit id="e3508cd09f84a8328fcc45ebfc715b277ccf9575" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. Alias for &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt;&lt;code&gt;nd&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">방송 결과의 차원 수입니다. &lt;a href=&quot;numpy.broadcast.nd#numpy.broadcast.nd&quot;&gt; &lt;code&gt;nd&lt;/code&gt; 의&lt;/a&gt; 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="f2d295ce1b14b658fe281bd20aab41d9aab0b616" translate="yes" xml:space="preserve">
          <source>Number of dimensions of broadcasted result. For code intended for NumPy 1.12.0 and later the more consistent &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt; is preferred.</source>
          <target state="translated">방송 결과의 차원 수입니다. NumPy 1.12.0 &lt;a href=&quot;numpy.broadcast.ndim#numpy.broadcast.ndim&quot;&gt; &lt;code&gt;ndim&lt;/code&gt; &lt;/a&gt; 코드의 경우보다 일관된 ndim 이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="b135521e22bf0efd0692b304dc2944b4be1550dd" translate="yes" xml:space="preserve">
          <source>Number of dimensions of the sub-array if this data type describes a sub-array, and &lt;code&gt;0&lt;/code&gt; otherwise.</source>
          <target state="translated">이 데이터 유형이 하위 배열을 설명하는 경우 하위 배열의 차원 수이고, 그렇지 않으면 &lt;code&gt;0&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="19ea598f5fd4c1ee639980fee9928d5377e30cf8" translate="yes" xml:space="preserve">
          <source>Number of distinct core dimension names in the signature</source>
          <target state="translated">서명의 고유 한 핵심 차원 이름 수</target>
        </trans-unit>
        <trans-unit id="30b78d11ec827a9cb1ca1519eabc00a62b47ac43" translate="yes" xml:space="preserve">
          <source>Number of draws to advance the RNG. Must be less than the size state variable in the underlying RNG.</source>
          <target state="translated">RNG를 진행시키기위한 추첨 횟수. 기본 RNG에서 크기 상태 변수보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="70e37b72989cb2f41b3fc9d963c59f76fe6543ba" translate="yes" xml:space="preserve">
          <source>Number of elements along the specified axis.</source>
          <target state="translated">지정된 축을 따르는 요소의 수</target>
        </trans-unit>
        <trans-unit id="807011d441713287a8ad8dac9e44680a221be633" translate="yes" xml:space="preserve">
          <source>Number of elements in the array.</source>
          <target state="translated">배열의 요소 수</target>
        </trans-unit>
        <trans-unit id="9dd78b22d2ed99e0d773b0892f1882002390793b" translate="yes" xml:space="preserve">
          <source>Number of experiments.</source>
          <target state="translated">실험 횟수.</target>
        </trans-unit>
        <trans-unit id="f483027559825fca9bfa4da6e5eb78910571331a" translate="yes" xml:space="preserve">
          <source>Number of first indices that are involved in the inverse sum. Must be a positive integer, default is 2.</source>
          <target state="translated">역 합계에 관련된 첫 번째 인덱스 수입니다. 양의 정수 여야하며 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="b1779d0462b8633175ab393ef9880942bb660fa7" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be at least 1 and at most &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">샘플링 된 항목 수 1 이상, &lt;code&gt;ngood + nbad&lt;/code&gt; 이상이어야합니다 .</target>
        </trans-unit>
        <trans-unit id="eafdf0d454dc2aa43f8a71aaefeb0feceae0766e" translate="yes" xml:space="preserve">
          <source>Number of items sampled. Must be nonnegative and less than &lt;code&gt;ngood + nbad&lt;/code&gt;.</source>
          <target state="translated">샘플링 된 항목 수 음수가 &lt;code&gt;ngood + nbad&lt;/code&gt; 보다 작아야 합니다.</target>
        </trans-unit>
        <trans-unit id="897014b016e872c41c97ea0a9d1726a5e3c782d9" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all data in the buffer.</source>
          <target state="translated">읽을 항목 수 &lt;code&gt;-1&lt;/code&gt; 은 버퍼의 모든 데이터를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="b39ddea78956da2963bde4fd3e57272e8d0acb35" translate="yes" xml:space="preserve">
          <source>Number of items to read. &lt;code&gt;-1&lt;/code&gt; means all items (i.e., the complete file).</source>
          <target state="translated">읽을 항목 수 &lt;code&gt;-1&lt;/code&gt; 은 모든 항목 (즉, 전체 파일)을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="166e4814f7850463b72419995efff990410c931d" translate="yes" xml:space="preserve">
          <source>Number of iterators possessed by the broadcasted result.</source>
          <target state="translated">브로드 캐스트 된 결과가 소유 한 반복자의 수입니다.</target>
        </trans-unit>
        <trans-unit id="4211a9fc555cfccd24b355f573ae3f8ff77483ef" translate="yes" xml:space="preserve">
          <source>Number of non-zero values in the array along a given axis. Otherwise, the total number of non-zero values in the array is returned.</source>
          <target state="translated">주어진 축을 따라 배열에서 0이 아닌 값의 수입니다. 그렇지 않으면 배열에서 0이 아닌 값의 총 수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10474dca8982c65317e69ff33c6161fee40334b7" translate="yes" xml:space="preserve">
          <source>Number of point pairs to return. The default value is 100.</source>
          <target state="translated">반환 할 포인트 쌍 수입니다. 기본값은 100입니다.</target>
        </trans-unit>
        <trans-unit id="551051df538e93f92abd0e4d70bab9ebd0a9979c" translate="yes" xml:space="preserve">
          <source>Number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">사용할 입력에서 변형 축을 따르는 점의 수입니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 입력의 길이보다 작은 경우, 입력이 잘려있다. 더 큰 경우 입력이 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지에 의해 지정된 축 방향 입력의 길이 &lt;code&gt;axis&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="1f1a0e92249dd7ea05411a06963194533d7918c7" translate="yes" xml:space="preserve">
          <source>Number of points in the output window. If zero or less, an empty array is returned.</source>
          <target state="translated">출력 창의 포인트 수입니다. 0 이하이면 빈 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="79e81bd3a9cf8f13e4e087ed6b9ef489d7061b0e" translate="yes" xml:space="preserve">
          <source>Number of random bytes.</source>
          <target state="translated">임의의 바이트 수</target>
        </trans-unit>
        <trans-unit id="53975b0c071abdcd5131d1862834f5b08e87e264" translate="yes" xml:space="preserve">
          <source>Number of rows (and columns) in &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; output.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; x &lt;code&gt;n&lt;/code&gt; 출력 의 행 및 열 수입니다 .</target>
        </trans-unit>
        <trans-unit id="ba04adb79f4c3bf3f6caa8c01f8f929a74cbf8dc" translate="yes" xml:space="preserve">
          <source>Number of rows in the array.</source>
          <target state="translated">배열의 행 수</target>
        </trans-unit>
        <trans-unit id="9371726ac94e49726635264017eacaef06541bb1" translate="yes" xml:space="preserve">
          <source>Number of rows in the output.</source>
          <target state="translated">출력의 행 수</target>
        </trans-unit>
        <trans-unit id="89c00ebdcc34147d25718afd7dbd46f5e2d21937" translate="yes" xml:space="preserve">
          <source>Number of sample points and weights. It must be &amp;gt;= 1.</source>
          <target state="translated">샘플 포인트 및 무게의 수. &amp;gt; = 1이어야합니다.</target>
        </trans-unit>
        <trans-unit id="394bbce360690b00428b0808fa6c2c7bc474b75c" translate="yes" xml:space="preserve">
          <source>Number of sample points desired.</source>
          <target state="translated">원하는 샘플 포인트 수.</target>
        </trans-unit>
        <trans-unit id="8f13e51c56d80088f553a736484516fc0a17451a" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50.</source>
          <target state="translated">생성 할 샘플 수입니다. 기본값은 50입니다.</target>
        </trans-unit>
        <trans-unit id="b944ba1a6a786da2de285aee44ef64df7a0334c1" translate="yes" xml:space="preserve">
          <source>Number of samples to generate. Default is 50. Must be non-negative.</source>
          <target state="translated">생성 할 샘플 수입니다. 기본값은 50입니다. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="b8477012cd08123303aba533415512dffd6caae6" translate="yes" xml:space="preserve">
          <source>Number of times the array is rotated by 90 degrees.</source>
          <target state="translated">배열이 90도 회전 한 횟수입니다.</target>
        </trans-unit>
        <trans-unit id="43c5f5739f871a7eba2351b02c5057ed709b7574" translate="yes" xml:space="preserve">
          <source>Number of times to jump the state of the bit generator returned</source>
          <target state="translated">반환 된 비트 생성기 상태를 건너 뛰는 횟수</target>
        </trans-unit>
        <trans-unit id="612ea9a9fedd365d5dfed6db5fa33a0bb992e5bc" translate="yes" xml:space="preserve">
          <source>Number of values padded to the edges of each axis. ((before_1, after_1), &amp;hellip; (before_N, after_N)) unique pad widths for each axis. ((before, after),) yields same before and after pad for each axis. (pad,) or int is a shortcut for before = after = pad width for all axes.</source>
          <target state="translated">각 축의 가장자리에 채워지는 값 수입니다. 각 축에 대해 ((before_1, after_1),&amp;hellip; (before_N, after_N)) 고유 패드 너비. ((전, 후),)는 각 축의 패드 전후에 동일하게 산출됩니다. (pad,) 또는 int는 모든 축의 before = after = pad width에 대한 바로 가기입니다.</target>
        </trans-unit>
        <trans-unit id="21f1fbd39c40968c76006276fee34189d50015b9" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">잘못된 선택을하는 방법의 수 음이 아니어야하고 10 ** 9보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="4fbe2e90660c2e70b194a26e014711298205f94b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a bad selection. Must be nonnegative.</source>
          <target state="translated">잘못된 선택을하는 방법의 수 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="3f0216b57e4ddf8587c6f571d9e2b9562f1ca140" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative and less than 10**9.</source>
          <target state="translated">좋은 선택을하는 방법의 수. 음이 아니어야하고 10 ** 9보다 작아야합니다.</target>
        </trans-unit>
        <trans-unit id="e7a90f9a528b46c6111a9dd205b3c9485855546b" translate="yes" xml:space="preserve">
          <source>Number of ways to make a good selection. Must be nonnegative.</source>
          <target state="translated">좋은 선택을하는 방법의 수. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="f8ef4addb29288d67ee3b4225212bd0c25d2c82e" translate="yes" xml:space="preserve">
          <source>Number of zeros padded on the left. Default is 0 (no padding).</source>
          <target state="translated">왼쪽에 채워진 0의 수입니다. 기본값은 0 (패딩 없음)입니다.</target>
        </trans-unit>
        <trans-unit id="c42ce792573d252e0e5bfedf479c34b63dd69907" translate="yes" xml:space="preserve">
          <source>Number of zeros to append to &lt;code&gt;x1&lt;/code&gt;. Has to be non-negative. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 에 추가 할 0의 개수입니다 . 음수가 아니어야합니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="48744031d20b47daf05a16a7cf85445cecfa69bb" translate="yes" xml:space="preserve">
          <source>Number(s) to append at the end of the returned differences.</source>
          <target state="translated">반환 된 차이 끝에 추가 할 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="b058e82a0ebd1af4fdfdc76f108d0c56ee2817ee" translate="yes" xml:space="preserve">
          <source>Number(s) to prepend at the beginning of the returned differences.</source>
          <target state="translated">반환 된 차이의 시작 부분에 붙일 숫자입니다.</target>
        </trans-unit>
        <trans-unit id="415e3bf4df03605336c3914770641333dc739919" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom in &lt;code&gt;random.noncentral_f&lt;/code&gt; need only be positive.</source>
          <target state="translated">&lt;code&gt;random.noncentral_f&lt;/code&gt; 의 분자 자유도는 양수이면됩니다.</target>
        </trans-unit>
        <trans-unit id="aef085dad0112ed12e20c9ac768d68c02abb5c39" translate="yes" xml:space="preserve">
          <source>Numerator degrees of freedom, must be &amp;gt; 0.</source>
          <target state="translated">분자 자유도는&amp;gt; 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="915427ef41bad72baf07ece61495d7f8349cc6ce" translate="yes" xml:space="preserve">
          <source>Numerator.</source>
          <target state="translated">Numerator.</target>
        </trans-unit>
        <trans-unit id="725a001aa87d95c548766f8d2dce89bbb2b6023f" translate="yes" xml:space="preserve">
          <source>Numeric Compatibility: If you used old typecode characters in your Numeric code (which was never recommended), you will need to change some of them to the new characters. In particular, the needed changes are &lt;code&gt;c -&amp;gt; S1&lt;/code&gt;, &lt;code&gt;b -&amp;gt; B&lt;/code&gt;, &lt;code&gt;1 -&amp;gt; b&lt;/code&gt;, &lt;code&gt;s -&amp;gt; h&lt;/code&gt;, &lt;code&gt;w -&amp;gt;
H&lt;/code&gt;, and &lt;code&gt;u -&amp;gt; I&lt;/code&gt;. These changes make the type character convention more consistent with other Python modules such as the &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/a&gt; module.</source>
          <target state="translated">숫자 호환성 : 숫자 코드에서 이전 유형 코드 문자를 사용한 경우 (권장하지 않음) 일부 문자를 새 문자로 변경해야합니다. 특히, 필요한 변경 사항은 &lt;code&gt;c -&amp;gt; S1&lt;/code&gt; , &lt;code&gt;b -&amp;gt; B&lt;/code&gt; , &lt;code&gt;1 -&amp;gt; b&lt;/code&gt; , &lt;code&gt;s -&amp;gt; h&lt;/code&gt; , &lt;code&gt;w -&amp;gt; H&lt;/code&gt; 및 &lt;code&gt;u -&amp;gt; I&lt;/code&gt; 입니다. 이러한 변경으로 인해 &lt;a href=&quot;https://docs.python.org/dev/library/struct.html#module-struct&quot;&gt; &lt;code&gt;struct&lt;/code&gt; &lt;/a&gt; 모듈 과 같은 다른 Python 모듈과 유형 문자 규칙이 더 일관성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb439f202c0c83a4476c0493068474885a0d04ea" translate="yes" xml:space="preserve">
          <source>Numeric characters include digit characters, and all characters that have the Unicode numeric value property, e.g. &lt;code&gt;U+2155,
VULGAR FRACTION ONE FIFTH&lt;/code&gt;.</source>
          <target state="translated">숫자 문자에는 숫자 문자 및 유니 코드 숫자 값 특성이있는 모든 문자 (예 : &lt;code&gt;U+2155, VULGAR FRACTION ONE FIFTH&lt;/code&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="d110fd1044993992c435dc5c01496d108d91112c" translate="yes" xml:space="preserve">
          <source>Numeric-style type names have been removed from type dictionaries</source>
          <target state="translated">숫자 스타일 유형 이름이 유형 사전에서 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="ef5636617d28e515f0b65e76f0f4004b94b623c0" translate="yes" xml:space="preserve">
          <source>Numerical negative, element-wise.</source>
          <target state="translated">요소 별 숫자 부정</target>
        </trans-unit>
        <trans-unit id="4370eb3bfbe7ac1a30c0f9e9ca59a934adb66660" translate="yes" xml:space="preserve">
          <source>Numerical operations</source>
          <target state="translated">수치 연산</target>
        </trans-unit>
        <trans-unit id="42eddc11b63fd08bdfea69adf3f079710df9af97" translate="yes" xml:space="preserve">
          <source>Numerical operations can be easily performed without worrying about missing values, dividing by zero, square roots of negative numbers, etc.:</source>
          <target state="translated">결 측값에 대한 걱정없이 0으로 나누거나 음수의 제곱근 등을 걱정하지 않고 수치 연산을 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4259f28206bfbca56d0e23c019e2fc661e9b9dc6" translate="yes" xml:space="preserve">
          <source>Numerical positive, element-wise.</source>
          <target state="translated">요소별로 숫자로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="52d7754f5a98c840b507e69ac61f5c2741e65c9f" translate="yes" xml:space="preserve">
          <source>Numerical ranges</source>
          <target state="translated">수치 범위</target>
        </trans-unit>
        <trans-unit id="6466751f790e1e415eaeb56dd6736b61b1be5ff5" translate="yes" xml:space="preserve">
          <source>Numpy Alignment Goals</source>
          <target state="translated">못생긴 정렬 목표</target>
        </trans-unit>
        <trans-unit id="5e9d87ae4602a83bd12085c965654deb5c3d6e16" translate="yes" xml:space="preserve">
          <source>Numpy has switched to using pytest instead of nose for testing</source>
          <target state="translated">Numpy는 테스트를 위해 nose 대신 pytest를 사용하도록 전환했습니다.</target>
        </trans-unit>
        <trans-unit id="5ecbc9f20872e5d771f0c6a8fd21f4eb8338d6ff" translate="yes" xml:space="preserve">
          <source>Numpy no longer monkey-patches &lt;code&gt;ctypes&lt;/code&gt; with &lt;code&gt;__array_interface__&lt;/code&gt;</source>
          <target state="translated">Numpy는 더 이상 &lt;code&gt;__array_interface__&lt;/code&gt; 로 &lt;code&gt;ctypes&lt;/code&gt; 를 원숭이 패치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="924ed3491b77ccfa9befdd61777a79adde9bfe4c" translate="yes" xml:space="preserve">
          <source>Numpy type</source>
          <target state="translated">Numpy 유형</target>
        </trans-unit>
        <trans-unit id="dfa7af780a848cf7ff977252465dc8e7c6177248" translate="yes" xml:space="preserve">
          <source>Numpy uses one of two methods to automatically determine the field byte offsets and the overall itemsize of a structured datatype, depending on whether &lt;code&gt;align=True&lt;/code&gt; was specified as a keyword argument to &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Numpy는 두 가지 방법 중 하나를 사용하여 &lt;code&gt;align=True&lt;/code&gt; 가 &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; 에&lt;/a&gt; 대한 키워드 인수로 지정 되었는지 여부에 따라 구조화 된 데이터 유형의 필드 바이트 오프셋 및 전체 항목 화를 자동으로 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="4bfbe596058b381b5d62de809d86afe7e25ae53f" translate="yes" xml:space="preserve">
          <source>Numpy uses two different forms of alignment to achieve these goals: &amp;ldquo;True alignment&amp;rdquo; and &amp;ldquo;Uint alignment&amp;rdquo;.</source>
          <target state="translated">Numpy는 이러한 목표를 달성하기 위해 두 가지 다른 형태의 정렬을 사용합니다 : &quot;진정 정렬&quot;및 &quot;유니트 정렬&quot;.</target>
        </trans-unit>
        <trans-unit id="0bb9027c1066c8ed830e4c8560442711a99e34e6" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;http://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="translated">numpy 버전 v1.16에 도입 된 Numpy의 디스패치 메커니즘은 numpy API와 호환되고 numpy 기능의 사용자 지정 구현을 제공하는 사용자 지정 N 차원 배열 컨테이너를 작성하는 데 권장되는 접근 방식입니다. 애플리케이션에는 여러 노드에 분산 된 N 차원 배열 인 &lt;a href=&quot;http://dask.pydata.org&quot;&gt;dask&lt;/a&gt; 배열과 GPU의 N 차원 배열 인 &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="a93c9bf237607868ba74040bad035c52633b9e7e" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s dispatch mechanism, introduced in numpy version v1.16 is the recommended approach for writing custom N-dimensional array containers that are compatible with the numpy API and provide custom implementations of numpy functionality. Applications include &lt;a href=&quot;https://dask.pydata.org&quot;&gt;dask&lt;/a&gt; arrays, an N-dimensional array distributed across multiple nodes, and &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; arrays, an N-dimensional array on a GPU.</source>
          <target state="translated">numpy 버전 v1.16에 도입 된 Numpy의 디스패치 메커니즘은 numpy API와 호환되고 numpy 기능의 사용자 지정 구현을 제공하는 사용자 지정 N 차원 배열 컨테이너를 작성하는 데 권장되는 접근 방식입니다. 애플리케이션에는 여러 노드에 분산 된 N 차원 배열 인 &lt;a href=&quot;https://dask.pydata.org&quot;&gt;dask&lt;/a&gt; 배열과 GPU의 N 차원 배열 인 &lt;a href=&quot;https://docs-cupy.chainer.org/en/stable/&quot;&gt;cupy&lt;/a&gt; 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="893f750b4312b0bd2ff35bac0b6f12ab34ffa8d1" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="translated">Numpy의 난수 루틴은 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 의&lt;/a&gt; 조합을 사용하여 의사 난수 를 생성하여 시퀀스를 생성하고 해당 시퀀스를 사용하여 다른 통계 분포에서 샘플링 하는 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="964f31d6716dc00a266686a77065b8428590080d" translate="yes" xml:space="preserve">
          <source>Numpy&amp;rsquo;s random number routines produce pseudo random numbers using combinations of a &lt;code&gt;BitGenerator&lt;/code&gt; to create sequences and a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to use those sequences to sample from different statistical distributions:</source>
          <target state="translated">Numpy의 난수 루틴은 시퀀스를 생성하기 위해 &lt;code&gt;BitGenerator&lt;/code&gt; 와 시퀀스 를 사용하여 다른 통계적 분포에서 샘플링하기 위해 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 를 사용 하여 의사 난수 를 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="dbcd930c38d963d5846a86153db381c82c24485e" translate="yes" xml:space="preserve">
          <source>NumpyVersion (class in numpy.lib)</source>
          <target state="translated">NumpyVersion (numpy.lib의 클래스)</target>
        </trans-unit>
        <trans-unit id="1987fcddaae88d3445636d103d2f655d68cf7145" translate="yes" xml:space="preserve">
          <source>NumpyVersion class added</source>
          <target state="translated">NumpyVersion 클래스 추가</target>
        </trans-unit>
        <trans-unit id="08a914cde05039694ef0194d9ee79ff9a79dde33" translate="yes" xml:space="preserve">
          <source>O</source>
          <target state="translated">O</target>
        </trans-unit>
        <trans-unit id="76403535a8ec16748017a87f4c76e50c07884d6f" translate="yes" xml:space="preserve">
          <source>O&amp;rsquo;Neill, Melissa E. &lt;a href=&quot;https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf&quot;&gt;&amp;ldquo;PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation&amp;rdquo;&lt;/a&gt;</source>
          <target state="translated">O'Neill, Melissa E. &lt;a href=&quot;https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf&quot;&gt;&quot;PCG : 난수 생성을위한 단순하고 빠른 공간 효율적인 통계적으로 우수한 알고리즘 제품군&quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ebc75cd71fe8ecc45d16e8fbe4ca608d05d1efe0" translate="yes" xml:space="preserve">
          <source>O(n)</source>
          <target state="translated">O(n)</target>
        </trans-unit>
        <trans-unit id="cd32e6ddbd41be3c5a4eb16b6f1ed3f8efca53a5" translate="yes" xml:space="preserve">
          <source>O(n*log(n))</source>
          <target state="translated">O(n*log(n))</target>
        </trans-unit>
        <trans-unit id="65ac5f452cfa676b59863240cc6b58ed94146182" translate="yes" xml:space="preserve">
          <source>O(n^2)</source>
          <target state="translated">O(n^2)</target>
        </trans-unit>
        <trans-unit id="16e21f4d3aaf4aa65a40bf94fc12335c25429454" translate="yes" xml:space="preserve">
          <source>O. McNoleg, &amp;ldquo;The integration of GIS, remote sensing, expert systems and adaptive co-kriging for environmental habitat modelling of the Highland Haggis using object-oriented, fuzzy-logic and neural-network techniques,&amp;rdquo; Computers &amp;amp; Geosciences, vol. 22, pp. 585-588, 1996.</source>
          <target state="translated">O. McNoleg, &quot;객체 지향, 퍼지 논리 및 신경망 기술을 사용하여 Highland Haggis의 환경 서식지 모델링을위한 GIS, 원격 감지, 전문가 시스템 및 적응 형 co-kriging의 통합&quot;, Computers &amp;amp; Geosciences, vol. 22, pp. 585-588, 1996.</target>
        </trans-unit>
        <trans-unit id="9ce3bd4224c8c1780db56b4125ecf3f24bf748b7" translate="yes" xml:space="preserve">
          <source>OK</source>
          <target state="translated">OK</target>
        </trans-unit>
        <trans-unit id="9954b5cb646af3e1d62f8936ee802e399e164efe" translate="yes" xml:space="preserve">
          <source>OS X</source>
          <target state="translated">OS X</target>
        </trans-unit>
        <trans-unit id="4363d346523c5b2cd1bf247b95c174fae0de6fec" translate="yes" xml:space="preserve">
          <source>OS X builds on travis currently use &lt;code&gt;clang&lt;/code&gt;. It appears that binary wheels for OSX &amp;gt;= 10.6 can be safely built from the travis-ci OSX 10.9 VMs when building against the Python from the Python.org installers;</source>
          <target state="translated">OS X는 travis를 기반으로 현재 &lt;code&gt;clang&lt;/code&gt; 을 사용 합니다. OSX&amp;gt; = 10.6 용 바이너리 휠은 Python.org 설치 프로그램에서 Python에 대해 빌드 할 때 travis-ci OSX 10.9 VM에서 안전하게 빌드 할 수있는 것으로 보입니다.</target>
        </trans-unit>
        <trans-unit id="3edf589ebc096e6f9b1588e4ff5155e67b354878" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="translated">OS X 버전&amp;gt; = 10.9가 지원되며 Python 버전 지원은 &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html&quot;&gt;NEP 29를&lt;/a&gt; 참조하십시오 . Python.org Python, 시스템 Python, homebrew 및 macports와 호환되는 OSX 용 바이너리 휠을 빌드 합니다. 자세한 내용 은이 &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX 휠 빌드 요약&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="e4888b19146be35293d0e37e7d29c9c307248078" translate="yes" xml:space="preserve">
          <source>OS X versions &amp;gt;= 10.9 are supported, for Python version support see &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29&quot;&gt;NEP 29&lt;/a&gt;. We build binary wheels for OSX that are compatible with Python.org Python, system Python, homebrew and macports - see this &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX wheel building summary&lt;/a&gt; for details.</source>
          <target state="translated">OS X 버전&amp;gt; = 10.9가 지원되며 Python 버전 지원은 &lt;a href=&quot;https://numpy.org/neps/nep-0029-deprecation_policy.html#nep29&quot;&gt;NEP 29를&lt;/a&gt; 참조하십시오 . Python.org Python, 시스템 Python, homebrew 및 macports와 호환되는 OSX 용 바이너리 휠을 빌드 합니다. 자세한 내용 은이 &lt;a href=&quot;https://github.com/MacPython/wiki/wiki/Spinning-wheels&quot;&gt;OSX 휠 빌드 요약&lt;/a&gt; 을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="495dc72791fecbe14725db696ffa42ad8b5edf3d" translate="yes" xml:space="preserve">
          <source>OSError</source>
          <target state="translated">OSError</target>
        </trans-unit>
        <trans-unit id="8803bb33e936d33e0faf20b780197077a08628ad" translate="yes" xml:space="preserve">
          <source>OSX: x64_86 OSX wheels built using travis-ci;</source>
          <target state="translated">OSX : travis-ci를 사용하여 제작 된 x64_86 OSX 휠;</target>
        </trans-unit>
        <trans-unit id="5fce725b9aa55e80045f38a3d07a2d5daf8ad25e" translate="yes" xml:space="preserve">
          <source>OWNDATA / O</source>
          <target state="translated">OWNDATA / O</target>
        </trans-unit>
        <trans-unit id="77cbefcb956b9d9d63f0f7b3f93654f940febe59" translate="yes" xml:space="preserve">
          <source>Object (i.e. the memory contains a pointer to &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject&lt;/code&gt;&lt;/a&gt;)</source>
          <target state="translated">객체 (즉, 메모리는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject&lt;/code&gt; 에&lt;/a&gt; 대한 포인터를 포함합니다 )</target>
        </trans-unit>
        <trans-unit id="afdc54032033cacfee557f2ce2a005fa3b70eafb" translate="yes" xml:space="preserve">
          <source>Object array equality comparisons</source>
          <target state="translated">객체 배열 동등성 비교</target>
        </trans-unit>
        <trans-unit id="b3cc0c5c1acda14fa673f72ba7a000a4aeb4b75a" translate="yes" xml:space="preserve">
          <source>Object arrays containing multi-line objects have a more readable &lt;code&gt;repr&lt;/code&gt;</source>
          <target state="translated">다중 라인 객체를 포함하는 객체 배열은 더 읽기 쉬운 &lt;code&gt;repr&lt;/code&gt; 을가집니다.</target>
        </trans-unit>
        <trans-unit id="3760fc40824fa6cae9e794ba9f7b99a3316407ab" translate="yes" xml:space="preserve">
          <source>Object that defines the index or indices before which &lt;code&gt;values&lt;/code&gt; is inserted.</source>
          <target state="translated">&lt;code&gt;values&lt;/code&gt; 을 삽입 하기 전에 인덱스를 정의하는 객체입니다 .</target>
        </trans-unit>
        <trans-unit id="d05ef3a802418a7aebbd13573f51be0ead5f4193" translate="yes" xml:space="preserve">
          <source>Object to be converted to a data type object.</source>
          <target state="translated">데이터 형식 개체로 변환 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="1fd19fd89522d105167e839769054978a325524d" translate="yes" xml:space="preserve">
          <source>Object to test.</source>
          <target state="translated">테스트 할 개체입니다.</target>
        </trans-unit>
        <trans-unit id="1c4aa609fdcdcac826105f68748fd29ccfe3e04a" translate="yes" xml:space="preserve">
          <source>Objects implementing the &lt;code&gt;__array__&lt;/code&gt; protocol.</source>
          <target state="translated">&lt;code&gt;__array__&lt;/code&gt; 프로토콜을 구현하는 객체 .</target>
        </trans-unit>
        <trans-unit id="3ce13dfb5c9252ebd908c62fdf9e3deef898f9e3" translate="yes" xml:space="preserve">
          <source>Objects with the &lt;code&gt;.dtype&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;code&gt;.dtype&lt;/code&gt; 특성을 가진 개체 .</target>
        </trans-unit>
        <trans-unit id="a8900e78cbf680bcf40ca195f2953f79bcfe04f2" translate="yes" xml:space="preserve">
          <source>Observe that we are using the dataptr array inside the iterator, not copying the values to a local temporary. This is possible because when &lt;code&gt;iternext()&lt;/code&gt; is called, these pointers will be overwritten with fresh values, not incrementally updated.</source>
          <target state="translated">값을 로컬 임시로 복사하지 않고 반복자 내에서 dataptr 배열을 사용하고 있는지 확인하십시오. &lt;code&gt;iternext()&lt;/code&gt; 가 호출 될 때 이러한 포인터는 점진적으로 업데이트되지 않고 새로운 값으로 덮어 쓰기 때문에 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="f7b6a1c7c2ab92717708ab52dfb304953f89b662" translate="yes" xml:space="preserve">
          <source>Observe that with the default of keeping native memory order, the iterator is able to provide a single one-dimensional chunk, whereas when forcing Fortran order, it has to provide three chunks of two elements each.</source>
          <target state="translated">기본 메모리 순서를 유지하는 기본값을 사용하면 반복자가 단일 1 차원 청크를 제공 할 수 있지만, 포트란 순서를 강제 할 때는 각각 두 요소의 세 청크를 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="d9a0a259d7da286202ed894d68d15acb64fcfe1b" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reported person(s).</source>
          <target state="translated">신고자의 동의를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="03b79a5cda4ce7e7ddd9f792b9921027f93e2741" translate="yes" xml:space="preserve">
          <source>Obtain the agreement of the reporter(s). The reporter(s) have complete freedom to decline the mediation idea, or to propose an alternate mediator.</source>
          <target state="translated">기자의 동의를 얻습니다. 기자는 중재 아이디어를 거부하거나 대체 중재자를 제안 할 수있는 완전한 자유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="be4aa4abf7a6245dfaef0c8852a595c8fb657a3c" translate="yes" xml:space="preserve">
          <source>Obvious &lt;strong&gt;wording&lt;/strong&gt; mistakes (like leaving out a &amp;ldquo;not&amp;rdquo;) fall into the typo category, but other rewordings &amp;ndash; even for grammar &amp;ndash; require a judgment call, which raises the bar. Test the waters by first presenting the fix as an issue.</source>
          <target state="translated">명백한 &lt;strong&gt;표현&lt;/strong&gt; 실수 (예 : &quot;not&quot;제외)는 오타 범주에 속하지만 다른 &lt;strong&gt;단어 변경&lt;/strong&gt; (문법의 경우에도)은 판단을 요구하여 기준을 높입니다. 먼저 수정 사항을 문제로 제시하여 물을 테스트하십시오.</target>
        </trans-unit>
        <trans-unit id="0b8499c2c896d61295bd16e3c134140b4e72b522" translate="yes" xml:space="preserve">
          <source>Occasionally there may be simple issues with old or bad installations of NumPy. In this case you may just try to uninstall and reinstall NumPy. Make sure that NumPy is not found after uninstalling.</source>
          <target state="translated">때때로 NumPy의 오래되거나 잘못된 설치에 간단한 문제가있을 수 있습니다. 이 경우 NumPy를 제거하고 다시 설치할 수 있습니다. 제거 후 NumPy가 없는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fa8a40208cbec6893957fea3d09da8c32d4bb67b" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing the quotient and remainder.</source>
          <target state="translated">체비 쇼프 시리즈의 몫과 나머지를 나타내는 계수.</target>
        </trans-unit>
        <trans-unit id="95a193973a1a38f794d62d2292b358ed61a158d4" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their difference.</source>
          <target state="translated">체비 쇼프 계열 계수의 차이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="f6f11800879153b66dc0982f5c4e19a52fd99bfd" translate="yes" xml:space="preserve">
          <source>Of Chebyshev series coefficients representing their product.</source>
          <target state="translated">체비 쇼프의 계열 계수는 해당 제품을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="1e744292f68f81ff06c4af2891c2284d51276990" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing the quotient and remainder.</source>
          <target state="translated">Hermite 계열 계수 중 몫과 나머지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="68e73a174e70afa8021e3a5b69b172f5340b60a0" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their difference.</source>
          <target state="translated">Hermite 계열 계수의 차이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="584dca0bbf2ee8dea79e52251025d455fc466309" translate="yes" xml:space="preserve">
          <source>Of Hermite series coefficients representing their product.</source>
          <target state="translated">제품을 나타내는 Hermite 시리즈 계수 중.</target>
        </trans-unit>
        <trans-unit id="f835afbe8ca3fee3a7aaf7264b53bfe89607c7f1" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing the quotient and remainder.</source>
          <target state="translated">Laguerre 계열 계수 중 몫과 나머지를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="90b47b338ded7c0b1d451aae2b6b202ac054bd26" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their difference.</source>
          <target state="translated">Laguerre 계열 계수의 차이를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="9b96161c3659cfd1e35cc2549dc17860026b7cdc" translate="yes" xml:space="preserve">
          <source>Of Laguerre series coefficients representing their product.</source>
          <target state="translated">Laguerre 계열 계수 중 제품을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="bd7f06a962c25e759bd9ef64c710ec6053768d88" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing the quotient and remainder.</source>
          <target state="translated">몫과 나머지를 나타내는 Legendre 시리즈 계수 중.</target>
        </trans-unit>
        <trans-unit id="3059e37623b23a53a523c2b1352662c0102ac1da" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their difference.</source>
          <target state="translated">그들의 차이를 나타내는 Legendre 시리즈 계수 중.</target>
        </trans-unit>
        <trans-unit id="50248795d9f87718e76bae1fc0c734509f84b250" translate="yes" xml:space="preserve">
          <source>Of Legendre series coefficients representing their product.</source>
          <target state="translated">그들의 제품을 나타내는 Legendre 시리즈 계수 중.</target>
        </trans-unit>
        <trans-unit id="d8427b6e14c2b373d5a6dab581028bfc5f363679" translate="yes" xml:space="preserve">
          <source>Of coefficient series representing the quotient and remainder.</source>
          <target state="translated">몫과 나머지를 나타내는 계수 계열.</target>
        </trans-unit>
        <trans-unit id="d290318bfec96b6b8a0b5657cb6aa25c8656f248" translate="yes" xml:space="preserve">
          <source>Of coefficients representing their difference.</source>
          <target state="translated">그들의 차이를 나타내는 계수.</target>
        </trans-unit>
        <trans-unit id="6a85fe85cc5899aa41f4c1b4360a890de25aa1af" translate="yes" xml:space="preserve">
          <source>Of course you&amp;rsquo;ll need to replace &lt;code&gt;Your Name&lt;/code&gt; and &lt;code&gt;you@yourdomain.example.com&lt;/code&gt; with your actual name and email address.</source>
          <target state="translated">물론 &lt;code&gt;Your Name&lt;/code&gt; 과 &lt;code&gt;you@yourdomain.example.com&lt;/code&gt; 을 실제 이름과 이메일 주소 로 바꿔야 합니다.</target>
        </trans-unit>
        <trans-unit id="3c3f315ee6b4ab53b8b92ba8326227f97899e80b" translate="yes" xml:space="preserve">
          <source>Of course, a test can be unconditionally skipped or marked as a known failure by using &lt;code&gt;skip&lt;/code&gt; or &lt;code&gt;xfail&lt;/code&gt; without argument, respectively.</source>
          <target state="translated">물론 인수없이 &lt;code&gt;skip&lt;/code&gt; 또는 &lt;code&gt;xfail&lt;/code&gt; 을 사용하여 테스트를 무조건 건너 뛰거나 알려진 실패로 표시 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fbcd4dc2b30c5efc09e8b8e0ac34e1195e3be111" translate="yes" xml:space="preserve">
          <source>Of course, this is not the best method to &lt;em&gt;approximate&lt;/em&gt; an image. However, there is, in fact, a result in linear algebra that says that the approximation we built above is the best we can get to the original matrix in terms of the norm of the difference. For more information, see &lt;em&gt;G. H. Golub and C. F. Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985&lt;/em&gt;.</source>
          <target state="translated">물론 이것은 이미지 를 &lt;em&gt;근사화&lt;/em&gt; 하는 가장 좋은 방법은 아닙니다 . 그러나 실제로 위에서 구축 한 근사값이 차이의 규범 측면에서 원래 행렬에 도달 할 수있는 최고라고 말하는 선형 대수 결과가 있습니다. 자세한 내용은 &lt;em&gt;GH Golub 및 CF Van Loan, Matrix Computations, Baltimore, MD, Johns Hopkins University Press, 1985를 참조하십시오&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="6e8a45899d21a287f8cee5fcbf7d53b28d2a2524" translate="yes" xml:space="preserve">
          <source>Of the coefficients of their product.</source>
          <target state="translated">그들의 제품 계수.</target>
        </trans-unit>
        <trans-unit id="609c29eaa3c81a7bde19a799569654e9420a8d39" translate="yes" xml:space="preserve">
          <source>Offset into a memmap:</source>
          <target state="translated">memmap으로 오프셋 :</target>
        </trans-unit>
        <trans-unit id="0bc2c6922816779fd173b29551f1ab7c3175a4b8" translate="yes" xml:space="preserve">
          <source>Offset is limited to C int, which is signed and usually 32 bits. If present, the optional title can be any object (if it is a string or unicode then it will also be a key in the fields dictionary, otherwise it&amp;rsquo;s meta-data). Notice also that the first two elements of the tuple can be passed directly as arguments to the &lt;code&gt;ndarray.getfield&lt;/code&gt; and &lt;code&gt;ndarray.setfield&lt;/code&gt; methods.</source>
          <target state="translated">오프셋은 부호있는 C int로 제한되며 보통 32 비트입니다. 존재하는 경우, 선택적인 제목은 임의의 객체 일 수 있습니다 (문자열 또는 유니 코드 인 경우 필드 사전의 키가되고 그렇지 않으면 메타 데이터 임). 튜플의 처음 두 요소는 &lt;code&gt;ndarray.getfield&lt;/code&gt; 및 &lt;code&gt;ndarray.setfield&lt;/code&gt; 에 인수로 직접 전달할 수 있습니다. 메소드에 .</target>
        </trans-unit>
        <trans-unit id="86ce02382c3cd06f8561677ae11ec555fdb1fe4e" translate="yes" xml:space="preserve">
          <source>Offset of array data in buffer.</source>
          <target state="translated">버퍼에서 배열 데이터의 오프셋입니다.</target>
        </trans-unit>
        <trans-unit id="680177996996fd2c23e4d0d5181bef8478a843b3" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be both positive and negative. Defaults to 0.</source>
          <target state="translated">주 대각선에서 대각선의 오프셋. 긍정적이거나 부정적 일 수 있습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="6b6b5a41310e8f5b4f7075c43a048e4d2e50484a" translate="yes" xml:space="preserve">
          <source>Offset of the diagonal from the main diagonal. Can be positive or negative. Defaults to main diagonal (0).</source>
          <target state="translated">주 대각선에서 대각선의 오프셋. 긍정적이거나 부정적 일 수 있습니다. 기본 대각선 (0)으로 기본 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="efcd2ae12c66734a66a7aa79ae569a447152e17b" translate="yes" xml:space="preserve">
          <source>Offset position in the file.</source>
          <target state="translated">파일에서 오프셋 위치.</target>
        </trans-unit>
        <trans-unit id="e5143224a659eeda117fd7431883f438f099ac14" translate="yes" xml:space="preserve">
          <source>Offsets in bytes, here 0 and 25:</source>
          <target state="translated">바이트 단위의 오프셋 (0과 25) :</target>
        </trans-unit>
        <trans-unit id="c9a4dc99b78136ab2e2bc1eee5d9d7344239f777" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;a href=&quot;../reference/arrays.scalars#numpy.object_&quot;&gt;&lt;code&gt;numpy.object_&lt;/code&gt;&lt;/a&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="translated">필드가 겹치도록 오프셋을 선택할 수 있지만 이는 하나의 필드에 할당하면 겹치는 필드의 데이터를 방해 할 수 있음을 의미합니다. 예외적으로 &lt;a href=&quot;../reference/arrays.scalars#numpy.object_&quot;&gt; &lt;code&gt;numpy.object_&lt;/code&gt; &lt;/a&gt; 유형의 필드는 내부 개체 포인터 를 막고 다시 참조 할 위험이 있으므로 다른 필드와 겹칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7329966e05964c08e33b7a47b16c9992cb5a4adf" translate="yes" xml:space="preserve">
          <source>Offsets may be chosen such that the fields overlap, though this will mean that assigning to one field may clobber any overlapping field&amp;rsquo;s data. As an exception, fields of &lt;code&gt;numpy.object&lt;/code&gt; type cannot overlap with other fields, because of the risk of clobbering the internal object pointer and then dereferencing it.</source>
          <target state="translated">필드가 겹치도록 오프셋을 선택할 수 있지만 이는 하나의 필드에 할당하면 겹치는 필드의 데이터를 방해 할 수 있음을 의미합니다. 예외적으로 &lt;code&gt;numpy.object&lt;/code&gt; 유형의 필드는 내부 개체 포인터 를 막고 다시 참조 할 위험이 있으므로 다른 필드와 겹칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="967a38eb8129ad7778f2c9f5678f5fdf3c82cadb" translate="yes" xml:space="preserve">
          <source>Often it is preferable to use a boolean mask. For example:</source>
          <target state="translated">종종 부울 마스크를 사용하는 것이 좋습니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="6904502646c7743d277053efc8b47079c56c46bb" translate="yes" xml:space="preserve">
          <source>Often seen in method signatures, &lt;code&gt;self&lt;/code&gt; refers to the instance of the associated class. For example:</source>
          <target state="translated">메서드 시그니처에서 자주 볼 수있는 &lt;code&gt;self&lt;/code&gt; 는 연결된 클래스의 인스턴스를 나타냅니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="e3b563fa4cc80accab04bf13505ac3eb5aa2b458" translate="yes" xml:space="preserve">
          <source>Often, the elements of an array are originally unknown, but its size is known. Hence, NumPy offers several functions to create arrays with initial placeholder content. These minimize the necessity of growing arrays, an expensive operation.</source>
          <target state="translated">종종 배열의 요소는 원래 알려지지 않았지만 크기는 알려져 있습니다. 따라서 NumPy는 초기 자리 표시 자 콘텐츠로 배열을 만드는 여러 기능을 제공합니다. 이는 비용이 많이 드는 작업 인 어레이 증가의 필요성을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="57f9c3f125b2ae3755f9cc2e88d97945e0b2e6b1" translate="yes" xml:space="preserve">
          <source>Old, no conjugate, version of correlate.</source>
          <target state="translated">오래되고 접합체가 없으며 상관 관계가 있습니다.</target>
        </trans-unit>
        <trans-unit id="22b35a56584d02836f725dd51b4643aaa3081190" translate="yes" xml:space="preserve">
          <source>Older Equivalent</source>
          <target state="translated">더 오래된</target>
        </trans-unit>
        <trans-unit id="a2240253307fec1cb9e7de6b2b992423b8538bf0" translate="yes" xml:space="preserve">
          <source>On AArch64 &lt;code&gt;NEON&lt;/code&gt;&lt;code&gt;FP16&lt;/code&gt;&lt;code&gt;VFPV4&lt;/code&gt;&lt;code&gt;ASIMD&lt;/code&gt; implies each other since they are part of the hardware baseline.</source>
          <target state="translated">AArch64에서 &lt;code&gt;NEON&lt;/code&gt; &lt;code&gt;FP16&lt;/code&gt; &lt;code&gt;VFPV4&lt;/code&gt; &lt;code&gt;ASIMD&lt;/code&gt; 는 하드웨어 기준의 일부이기 때문에 서로를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="950780760d17e16ea15a84017774640eae55ce02" translate="yes" xml:space="preserve">
          <source>On Unix-like machines, reads from &lt;code&gt;/dev/urandom&lt;/code&gt;. On Windows machines reads from the RSA algorithm provided by the cryptographic service provider.</source>
          <target state="translated">유닉스 계열 머신에서는 &lt;code&gt;/dev/urandom&lt;/code&gt; 에서 읽습니다 . Windows 시스템에서는 암호화 서비스 제공자가 제공 한 RSA 알고리즘을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="2d3188b9edd47b7b8e155f7d62759b49e4bbd63c" translate="yes" xml:space="preserve">
          <source>On array access use the &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; function pointer instead of the standard conversion to an array scalar. Must use if you don&amp;rsquo;t define an array scalar to go along with the data-type.</source>
          <target state="translated">배열 액세스에서는 배열 스칼라로의 표준 변환 대신 &lt;code&gt;f-&amp;gt;getitem&lt;/code&gt; 함수 포인터를 사용하십시오. 데이터 유형과 함께 배열 스칼라를 정의하지 않은 경우 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4dcefd1cec20f7966d92a38bf6e10deb907560ec" translate="yes" xml:space="preserve">
          <source>On compilers which support a #warning mechanism, NumPy issues a compiler warning if you do not define the symbol NPY_NO_DEPRECATED_API. This way, the fact that there are deprecations will be flagged for third-party developers who may not have read the release notes closely.</source>
          <target state="translated">#warning 메커니즘을 지원하는 컴파일러에서 NPY_NO_DEPRECATED_API 기호를 정의하지 않으면 NumPy가 컴파일러 경고를 발행합니다. 이러한 방식으로 릴리스 노트를 자세히 읽지 않은 타사 개발자에게는 더 이상 사용되지 않음이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="3a15f70253da2dd06321b41b01d9ced818944641" translate="yes" xml:space="preserve">
          <source>On ppc64le &lt;code&gt;VSX(ISA 2.06)&lt;/code&gt; and &lt;code&gt;VSX2(ISA 2.07)&lt;/code&gt; both imply one another since the first generation that supports little-endian mode is Power-8`(ISA 2.07)`</source>
          <target state="translated">ppc64le에서 &lt;code&gt;VSX(ISA 2.06)&lt;/code&gt; 와 &lt;code&gt;VSX2(ISA 2.07)&lt;/code&gt; 모두 리틀 엔디안 모드를 지원하는 1 세대가 Power-8` (ISA 2.07)이므로 서로를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="c713072ca3a05590ed7b22ab2b7c84fab6d46af9" translate="yes" xml:space="preserve">
          <source>On some platforms (&lt;em&gt;e.g.&lt;/em&gt; Windows), a shared library requires a .def file that specifies the functions to be exported. For example a mylib.def file might contain:</source>
          <target state="translated">일부 플랫폼 ( &lt;em&gt;예 :&lt;/em&gt; Windows)에서 공유 라이브러리에는 내보낼 함수를 지정하는 .def 파일이 필요합니다. 예를 들어 mylib.def 파일에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30b6987bb053c195d4d4a88861df5cc0bec8c735" translate="yes" xml:space="preserve">
          <source>On the other hand, coolhelper.c would contain at the top:</source>
          <target state="translated">반면에 coolhelper.c는 맨 위에 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="8e10b67ab476fcac9d1e17bd9eaadbb9eeb769ca" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt;&lt;code&gt;row_stack&lt;/code&gt;&lt;/a&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt;&lt;code&gt;row_stack&lt;/code&gt;&lt;/a&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">반면에 &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt; &lt;code&gt;row_stack&lt;/code&gt; &lt;/a&gt; 함수 는 모든 입력 배열에 대한 &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt; 과 동일 합니다. 사실, &lt;a href=&quot;../reference/generated/numpy.row_stack#numpy.row_stack&quot;&gt; &lt;code&gt;row_stack&lt;/code&gt; 는&lt;/a&gt; 별칭입니다 &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; 는&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="e97323f6987cba1f587e924c7a9998279536c754" translate="yes" xml:space="preserve">
          <source>On the other hand, the function &lt;code&gt;row_stack&lt;/code&gt; is equivalent to &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; for any input arrays. In fact, &lt;code&gt;row_stack&lt;/code&gt; is an alias for &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">반면에 &lt;code&gt;row_stack&lt;/code&gt; 함수 는 모든 입력 배열에 대한 &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt; 과 동일 합니다. 사실, &lt;code&gt;row_stack&lt;/code&gt; 는 별칭입니다 &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; 는&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="5a8085f065b43ca0612f8f5a0dd702c78428f8a7" translate="yes" xml:space="preserve">
          <source>On this machine, building the .pyx file into a module looked like the following, but you may have to find some Cython tutorials to tell you the specifics for your system configuration.:</source>
          <target state="translated">이 머신에서 .pyx 파일을 모듈로 빌드하는 방법은 다음과 같지만 시스템 구성에 대한 구체적인 내용을 알려주는 Cython 자습서를 찾아야 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a506ebe097fd976b21e552ba29fd40b62947df8" translate="yes" xml:space="preserve">
          <source>Once a busdaycalendar object is created, the weekmask and holidays cannot be modified.</source>
          <target state="translated">busdaycalendar 오브젝트가 작성된 후에는 주 마스크 및 휴일을 수정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="eba82deb0932802c527a81a17b1d4d366fc0af03" translate="yes" xml:space="preserve">
          <source>Once a new &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure is created and filled with the needed information and useful functions you call &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterDataType&quot;&gt;&lt;code&gt;PyArray_RegisterDataType&lt;/code&gt;&lt;/a&gt; (new_descr). The return value from this call is an integer providing you with a unique type_number that specifies your data-type. This type number should be stored and made available by your module so that other modules can use it to recognize your data-type (the other mechanism for finding a user-defined data-type number is to search based on the name of the type-object associated with the data-type using &lt;code&gt;PyArray_TypeNumFromName&lt;/code&gt; ).</source>
          <target state="translated">새로운 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조가 생성되고 필요한 정보와 유용한 함수로 &lt;a href=&quot;../reference/c-api/array#c.PyArray_RegisterDataType&quot;&gt; &lt;code&gt;PyArray_RegisterDataType&lt;/code&gt; &lt;/a&gt; (new_descr) 을 호출 합니다. 이 호출의 반환 값은 데이터 유형을 지정하는 고유 한 type_number를 제공하는 정수입니다. 이 유형 번호는 다른 모듈이 데이터 유형을 인식하는 데 사용할 수 있도록 저장하고 모듈에서 사용할 수 있어야합니다 (사용자 정의 데이터 유형 번호를 찾는 다른 메커니즘은 유형의 이름을 기반으로 검색하는 것입니다). &lt;code&gt;PyArray_TypeNumFromName&lt;/code&gt; 을 사용하여 데이터 유형과 관련된 객체 ).</target>
        </trans-unit>
        <trans-unit id="5183e36c12674d881f64d8eaa0dea9c0fa03d80d" translate="yes" xml:space="preserve">
          <source>Once a resolution is agreed upon, but before it is enacted, the committee will contact the original reporter and any other affected parties and explain the proposed resolution. The committee will ask if this resolution is acceptable, and must note feedback for the record.</source>
          <target state="translated">결의안이 합의되고 제정되기 전에위원회는 원래의보고자 및 기타 영향을받는 당사자에게 연락하여 제안 된 결의안을 설명합니다. 위원회는이 결의안이 수용 가능한지 묻고 기록에 대한 피드백을 기록해야합니다.</target>
        </trans-unit>
        <trans-unit id="d441f19f98ee4b31cf802d2cbf0a4fb74d4c8d91" translate="yes" xml:space="preserve">
          <source>Once everything seems satisfactory, commit and upload the changes:</source>
          <target state="translated">모든 것이 만족 스러우면 변경 사항을 커밋하고 업로드합니다.</target>
        </trans-unit>
        <trans-unit id="abc2ddc32e9564a57768ba3eb61dec0741c722ab" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;numpy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="translated">일단 &lt;code&gt;numpy/xxx/tests/test_yyy.py&lt;/code&gt; 받는 이동하여 테스트를 실행하기 위해, 그것의 가능한 기록 &lt;code&gt;tests/&lt;/code&gt; 디렉토리를 입력 :</target>
        </trans-unit>
        <trans-unit id="f7d8ca7f94183ec448b711283a3a7fa64f6c8872" translate="yes" xml:space="preserve">
          <source>Once the &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; is written, its possible to run the tests by going to the &lt;code&gt;tests/&lt;/code&gt; directory and typing:</source>
          <target state="translated">한 번 &lt;code&gt;scipy/xxx/tests/test_yyy.py&lt;/code&gt; 받는 이동하여 테스트를 실행하기 위해, 그것의 가능한 기록 &lt;code&gt;tests/&lt;/code&gt; 디렉토리를 입력 :</target>
        </trans-unit>
        <trans-unit id="ac70209362afce77775660280fe98f52f86f930f" translate="yes" xml:space="preserve">
          <source>Once the SeedSequence is instantiated, you can call the &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt;&lt;code&gt;generate_state&lt;/code&gt;&lt;/a&gt; method to get an appropriately sized seed. Calling &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;spawn(n)&lt;/code&gt;&lt;/a&gt; will create &lt;code&gt;n&lt;/code&gt; SeedSequences that can be used to seed independent BitGenerators, i.e. for different threads.</source>
          <target state="translated">SeedSequence가 인스턴스화되면 &lt;a href=&quot;numpy.random.seedsequence.generate_state#numpy.random.SeedSequence.generate_state&quot;&gt; &lt;code&gt;generate_state&lt;/code&gt; &lt;/a&gt; 메소드를 호출하여 적절한 크기의 시드를 얻을 수 있습니다. &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;spawn(n)&lt;/code&gt; &lt;/a&gt; 호출 하면 독립적 인 BitGenerator를 시드하는 데 사용할 수있는 &lt;code&gt;n&lt;/code&gt; 개의 SeedSequence 가 생성됩니다 ( 예 : 다른 스레드).</target>
        </trans-unit>
        <trans-unit id="9b8c845df2375661d6c8904939512353e20ecd41" translate="yes" xml:space="preserve">
          <source>Once the conversions to the appropriate C-structures and C data-types have been performed, the next step in the wrapper is to call the underlying function. This is straightforward if the underlying function is in C or C++. However, in order to call Fortran code you must be familiar with how Fortran subroutines are called from C/C++ using your compiler and platform. This can vary somewhat platforms and compilers (which is another reason f2py makes life much simpler for interfacing Fortran code) but generally involves underscore mangling of the name and the fact that all variables are passed by reference (i.e. all arguments are pointers).</source>
          <target state="translated">적절한 C 구조 및 C 데이터 유형으로의 변환이 수행되면 래퍼의 다음 단계는 기본 함수를 호출하는 것입니다. 기본 함수가 C 또는 C ++ 인 경우 이는 간단합니다. 그러나 Fortran 코드를 호출하려면 컴파일러 및 플랫폼을 사용하여 C / C ++에서 Fortran 서브 루틴을 호출하는 방법에 대해 잘 알고 있어야합니다. 이것은 플랫폼과 컴파일러에 따라 약간 씩 다를 수 있지만 (f2py가 Fortran 코드를 인터페이스하는 데있어 삶을 훨씬 더 간단하게 만드는 또 다른 이유입니다) 일반적으로 이름의 밑줄 조작과 모든 변수가 참조로 전달된다는 사실 (즉, 모든 인수가 포인터입니다)이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="9fd5de6f03a0c2c385081a0d6f534ba7e379838a" translate="yes" xml:space="preserve">
          <source>Once the file is defined and open for reading, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; splits each non-empty line into a sequence of strings. Empty or commented lines are just skipped. The &lt;code&gt;delimiter&lt;/code&gt; keyword is used to define how the splitting should take place.</source>
          <target state="translated">파일이 정의되고 읽기 위해 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 비어 있지 않은 각 줄을 일련의 문자열로 분할합니다. 비어 있거나 주석 처리 된 줄은 건너 뜁니다. &lt;code&gt;delimiter&lt;/code&gt; 키워드는 분할이 수행하는 방법을 정의하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="97b7cac8dde7cbe137262c702e77fb0ca9ad5356" translate="yes" xml:space="preserve">
          <source>Once the header is parsed by &lt;code&gt;ffi.cdef&lt;/code&gt;, the functions can be accessed directly from the &lt;code&gt;_generator&lt;/code&gt; shared object, using the &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator.cffi#numpy.random.BitGenerator.cffi&quot;&gt;&lt;code&gt;BitGenerator.cffi&lt;/code&gt;&lt;/a&gt; interface.</source>
          <target state="translated">헤더가 &lt;code&gt;ffi.cdef&lt;/code&gt; 에 의해 구문 분석되면 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator.cffi#numpy.random.BitGenerator.cffi&quot;&gt; &lt;code&gt;BitGenerator.cffi&lt;/code&gt; &lt;/a&gt; 인터페이스를 사용하여 &lt;code&gt;_generator&lt;/code&gt; 공유 객체 에서 직접 함수에 액세스 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="31e905cb6480a6fdb98cbdeb00114c7de3f9ecca" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt;&lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt;&lt;/a&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="translated">반복기가 반복을 위해 준비되면 ( &lt;a href=&quot;#c.NPY_ITER_DELAY_BUFALLOC&quot;&gt; &lt;code&gt;NPY_ITER_DELAY_BUFALLOC&lt;/code&gt; &lt;/a&gt; 가 사용 된 경우 재설정 후 ) 빠른 내부 루프 함수를 선택하는 데 사용할 수있는 스트라이드를 가져 오기 위해 이것을 호출합니다. 예를 들어, stride가 0이면 내부 루프가 항상 해당 값을 변수에 한 번로드 한 다음 루프 전체에서 변수를 사용하거나 stride가 항목 크기와 같으면 해당 피연산자에 대한 연속 버전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="231d4308334f05ae25082dce13bc3cf1e18cdbf8" translate="yes" xml:space="preserve">
          <source>Once the iterator is prepared for iteration (after a reset if &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; was used), call this to get the strides which may be used to select a fast inner loop function. For example, if the stride is 0, that means the inner loop can always load its value into a variable once, then use the variable throughout the loop, or if the stride equals the itemsize, a contiguous version for that operand may be used.</source>
          <target state="translated">반복자가 반복 준비를 마치면 ( &lt;code&gt;NPY_DELAY_BUFALLOC&lt;/code&gt; 를 사용한 경우 재설정 후 ) 빠른 내부 루프 기능을 선택하는 데 사용할 수있는 보폭을 얻습니다. 예를 들어 보폭이 0이면 내부 루프가 항상 값을 변수에 한 번로드 한 다음 루프 전체에서 변수를 사용하거나 보폭이 항목 크기와 같으면 해당 피연산자의 연속 버전을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c04dbd1660afe1562d16b591f18b1bb40507aaa1" translate="yes" xml:space="preserve">
          <source>Once the spam module is imported into python, you can call logit via spam.logit. Note that the function used above cannot be applied as-is to numpy arrays. To do so we must call numpy.vectorize on it. For example, if a python interpreter is opened in the file containing the spam library or spam has been installed, one can perform the following commands:</source>
          <target state="translated">스팸 모듈을 Python으로 가져 오면 spam.logit를 통해 logit을 호출 할 수 있습니다. 위에서 사용 된 함수는 numpy 배열에있는 그대로 적용 할 수 없습니다. 그렇게하려면 numpy.vectorize를 호출해야합니다. 예를 들어, 스팸 라이브러리가 포함 된 파일에서 파이썬 인터프리터가 열리거나 스팸이 설치된 경우 다음 명령을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e78ec319a64fd7535ba4d9ce2b45a93a3eddd1ea" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="translated">바퀴가 빌드되고 오류없이 다운로드되면 &lt;code&gt;REL&lt;/code&gt; 커밋에 태그를 지정하고 gpg 키로 서명합니다.</target>
        </trans-unit>
        <trans-unit id="993e871933c3573c232eaa172843213039b4efd1" translate="yes" xml:space="preserve">
          <source>Once the wheels have been built and downloaded without errors, go back to your numpy repository in the maintenance branch and tag the &lt;code&gt;REL&lt;/code&gt; commit, signing it with your gpg key:</source>
          <target state="translated">휠이 빌드되고 오류없이 다운로드되면 유지 보수 브랜치의 numpy 저장소로 돌아가 &lt;code&gt;REL&lt;/code&gt; 커밋에 태그를 지정하고 gpg 키로 서명합니다.</target>
        </trans-unit>
        <trans-unit id="44934f86865426c152af6fe43faca7909cb74599" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your arrays, you can start to work with them. Let&amp;rsquo;s say, for example, that you&amp;rsquo;ve created two arrays, one called &amp;ldquo;data&amp;rdquo; and one called &amp;ldquo;ones&amp;rdquo;</source>
          <target state="translated">어레이를 만든 후에는 작업을 시작할 수 있습니다. 예를 들어 &quot;데이터&quot;라는 배열과 &quot;1&quot;이라는 두 개의 배열을 만들었다 고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="71c392b0b03965e8b7e58ba06da44426e1525511" translate="yes" xml:space="preserve">
          <source>Once you&amp;rsquo;ve created your matrices, you can add and multiply them using arithmetic operators if you have two matrices that are the same size.</source>
          <target state="translated">행렬을 만든 후에는 크기가 같은 두 개의 행렬이있는 경우 산술 연산자를 사용하여 행렬을 더하고 곱할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77517b16ad949bec662df3d2780dff01b3a28d3c" translate="yes" xml:space="preserve">
          <source>One Loop</source>
          <target state="translated">하나의 루프</target>
        </trans-unit>
        <trans-unit id="fb74c341b98c307818ac342dee77af9f705b8e7e" translate="yes" xml:space="preserve">
          <source>One big advantage of Cython-generated extension modules is that they are easy to distribute. In summary, Cython is a very capable tool for either gluing C code or generating an extension module quickly and should not be over-looked. It is especially useful for people that can&amp;rsquo;t or won&amp;rsquo;t write C or Fortran code.</source>
          <target state="translated">Cython에서 생성 한 확장 모듈의 큰 장점 중 하나는 배포가 쉽다는 것입니다. 요약하면 Cython은 C 코드를 붙이거나 확장 모듈을 빠르게 생성 할 수있는 매우 유용한 도구이므로 간과해서는 안됩니다. C 또는 Fortran 코드를 작성할 수 없거나 작성할 수없는 사람들에게 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="91705b60cf41602239345b05e981d551e6358c23" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 직접 인스턴스화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="444c9c354929cf1b3a58f15b3f0b2168f58f68f7" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 인스턴스를 사용하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 직접 인스턴스화 할 수도 있습니다 . 이전 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 알고리즘 을 사용하려면 직접 인스턴스화하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 에&lt;/a&gt; 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8524b74ddf89508f43aa1069be40f8c206f86f89" translate="yes" xml:space="preserve">
          <source>One can also instantiate &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; directly with a &lt;code&gt;BitGenerator&lt;/code&gt; instance. To use the older &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; algorithm, one can instantiate it directly and pass it to &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; 인스턴스를 사용하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 직접 인스턴스화 할 수도 있습니다 . 구형 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 알고리즘 을 사용하기 위해 직접 인스턴스화하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 에&lt;/a&gt; 전달할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="070709f2e07ce3e32b6abdd9998a1049f1bd5e84" translate="yes" xml:space="preserve">
          <source>One can index and assign to a structured array with a multi-field index, where the index is a list of field names.</source>
          <target state="translated">다중 필드 색인이있는 구조화 된 배열에 색인화하고 할당 할 수 있습니다. 여기서 색인은 필드 이름 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4e3340151bf466504ea342e74247a72d1486385a" translate="yes" xml:space="preserve">
          <source>One can use &lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; to declare a more general ufunc. The argument list is the same as &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt;, with an additional argument specifying the signature as C string.</source>
          <target state="translated">&lt;code&gt;PyUFunc_FromFuncAndDataAndSignature&lt;/code&gt; 를 사용 하여보다 일반적인 ufunc를 선언 할 수 있습니다 . 인수 목록은 &lt;code&gt;PyUFunc_FromFuncAndData&lt;/code&gt; 와 동일 하며 서명을 C 문자열로 지정하는 추가 인수가 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6a96a24425a79d2472bdd027a95e9628f8491bc" translate="yes" xml:space="preserve">
          <source>One can use different values for optional &lt;code&gt;n&lt;/code&gt;:</source>
          <target state="translated">선택적 &lt;code&gt;n&lt;/code&gt; 에 대해 다른 값을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93c665d4f58d5aed156c11bf302a241bec2c3bfe" translate="yes" xml:space="preserve">
          <source>One cannot mix negation and positives, nor have multiple negations, such cases will raise an error.</source>
          <target state="translated">부정과 긍정을 혼합하거나 여러 부정을 할 수 없으므로 이러한 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="56899b43e5156c96d1005f04cd69878206c68abd" translate="yes" xml:space="preserve">
          <source>One common algorithmic requirement is to be able to walk over all elements in a multidimensional array. The array iterator object makes this easy to do in a generic way that works for arrays of any dimension. Naturally, if you know the number of dimensions you will be using, then you can always write nested for loops to accomplish the iteration. If, however, you want to write code that works with any number of dimensions, then you can make use of the array iterator. An array iterator object is returned when accessing the .flat attribute of an array.</source>
          <target state="translated">일반적인 알고리즘 요구 사항 중 하나는 다차원 배열의 모든 요소를 ​​살펴볼 수 있어야한다는 것입니다. 배열 반복기 객체를 사용하면 모든 차원의 배열에서 작동하는 일반적인 방식으로이 작업을 쉽게 수행 할 수 있습니다. 당연히 사용할 차원의 수를 알고 있다면 항상 중첩 된 for 루프를 작성하여 반복을 수행 할 수 있습니다. 그러나 여러 차원에서 작동하는 코드를 작성하려면 배열 반복기를 사용할 수 있습니다. 배열의 .flat 속성에 액세스 할 때 배열 반복기 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="81089507935f358c69911644b087b72a2a0a612b" translate="yes" xml:space="preserve">
          <source>One common source of reference-count errors is the &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt; function. Pay careful attention to the difference between the &amp;lsquo;N&amp;rsquo; format character and the &amp;lsquo;O&amp;rsquo; format character. If you create a new object in your subroutine (such as an output array), and you are passing it back in a tuple of return values, then you should most- likely use the &amp;lsquo;N&amp;rsquo; format character in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt;. The &amp;lsquo;O&amp;rsquo; character will increase the reference count by one. This will leave the caller with two reference counts for a brand-new array. When the variable is deleted and the reference count decremented by one, there will still be that extra reference count, and the array will never be deallocated. You will have a reference-counting induced memory leak. Using the &amp;lsquo;N&amp;rsquo; character will avoid this situation as it will return to the caller an object (inside the tuple) with a single reference count.</source>
          <target state="translated">참조 횟수 오류의 일반적인 원인 중 하나는 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt; &lt;code&gt;Py_BuildValue&lt;/code&gt; &lt;/a&gt; 함수입니다. 'N'형식 문자와 'O'형식 문자의 차이에주의하십시오. 서브 루틴 (예 : 출력 배열)에 새 객체를 생성하고 반환 값의 튜플에 다시 전달하는 경우 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt; &lt;code&gt;Py_BuildValue&lt;/code&gt; &lt;/a&gt; 에서 'N'형식 문자를 사용해야합니다.. 'O'문자는 참조 횟수를 1 씩 증가시킵니다. 이렇게하면 새로운 어레이에 대해 두 개의 참조 카운트가 발신자에게 남게됩니다. 변수가 삭제되고 참조 횟수가 1만큼 감소해도 추가 참조 횟수가 남아 있으며 배열은 할당 해제되지 않습니다. 참조 계산으로 인해 메모리 누수가 발생합니다. 'N'문자를 사용하면 단일 참조 카운트를 가진 객체 (튜플 내부)를 호출자에게 반환하므로 이러한 상황을 피할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="46d4e9404ec123b91b7f0181eb9f23e04fe59bd2" translate="yes" xml:space="preserve">
          <source>One deviation from the current behavior of &lt;code&gt;__array_ufunc__&lt;/code&gt; is that NumPy will only call &lt;code&gt;__array_function__&lt;/code&gt; on the &lt;em&gt;first&lt;/em&gt; argument of each unique type. This matches Python&amp;rsquo;s &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;rule for calling reflected methods&lt;/a&gt;, and this ensures that checking overloads has acceptable performance even when there are a large number of overloaded arguments.</source>
          <target state="translated">현재 &lt;code&gt;__array_ufunc__&lt;/code&gt; 동작과 다른 점 은 NumPy가 각 고유 한 유형 의 &lt;em&gt;첫 번째&lt;/em&gt; 인수 에서만 &lt;code&gt;__array_function__&lt;/code&gt; 을 호출 한다는 것 입니다. 이것은 &lt;a href=&quot;https://docs.python.org/3/reference/datamodel.html#object.__ror__&quot;&gt;반영된 메소드를 호출하는&lt;/a&gt; Python의 규칙 과 일치 하며 과부하가 많은 인수가있는 경우에도 과부하 검사가 허용 가능한 성능을 보장합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="b47e08224aaf497fafd8b89783b8a17e95a05214" translate="yes" xml:space="preserve">
          <source>One dimensional array:</source>
          <target state="translated">1 차원 배열 :</target>
        </trans-unit>
        <trans-unit id="bbfcf4855e8547b3c2c018358506a526943e1c9a" translate="yes" xml:space="preserve">
          <source>One fundamental aspect of the ndarray is that an array is seen as a &amp;ldquo;chunk&amp;rdquo; of memory starting at some location. The interpretation of this memory depends on the stride information. For each dimension in an</source>
          <target state="translated">ndarray의 기본 요소 중 하나는 어레이가 특정 위치에서 시작하는 메모리의 &quot;청크&quot;로 간주된다는 것입니다. 이 기억의 해석은 보폭 정보에 달려 있습니다. 의 각 차원마다</target>
        </trans-unit>
        <trans-unit id="16275c9ae04e235f8070983e66409df72503b036" translate="yes" xml:space="preserve">
          <source>One is returned for slices that are all-NaN or empty.</source>
          <target state="translated">all-NaN이거나 비어있는 슬라이스에 대해서는 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e2800fbab71db8fc98d5d383e0fd87d0d933e41f" translate="yes" xml:space="preserve">
          <source>One of &amp;ldquo;always&amp;rdquo;, &amp;ldquo;once&amp;rdquo;, &amp;ldquo;module&amp;rdquo;, or &amp;ldquo;location&amp;rdquo;. Analogous to the usual warnings module filter mode, it is useful to reduce noise mostly on the outmost level. Unsuppressed and unrecorded warnings will be forwarded based on this rule. Defaults to &amp;ldquo;always&amp;rdquo;. &amp;ldquo;location&amp;rdquo; is equivalent to the warnings &amp;ldquo;default&amp;rdquo;, match by exact location the warning warning originated from.</source>
          <target state="translated">&quot;항상&quot;, &quot;한 번&quot;, &quot;모듈&quot;또는 &quot;위치&quot;중 하나입니다. 일반적인 경고 모듈 필터 모드와 유사하게 대부분 가장 바깥의 소음을 줄이는 것이 유용합니다. 이 규칙에 따라 억제되지 않고 기록되지 않은 경고가 전달됩니다. 기본값은 &quot;항상&quot;입니다. &amp;ldquo;location&amp;rdquo;은&amp;ldquo;default&amp;rdquo;경고와 동일하며 경고 경고가 발생한 정확한 위치와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="a089b8e63dd4e8eb30432f942f75f4b932e1fd5a" translate="yes" xml:space="preserve">
          <source>One of None, &amp;lsquo;auto&amp;rsquo;, or a &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime unit&lt;/a&gt;.</source>
          <target state="translated">None, 'auto'또는 &lt;a href=&quot;../arrays.datetime#arrays-dtypes-dateunits&quot;&gt;datetime 단위&lt;/a&gt; 중 하나입니다 .</target>
        </trans-unit>
        <trans-unit id="f39ed1de2c370ff6c78c1184ddb58d4c6a6a7345" translate="yes" xml:space="preserve">
          <source>One of the built-in data-types, the void data-type allows for arbitrary structured types containing 1 or more fields as elements of the array. A field is simply another data-type object along with an offset into the current structured type. In order to support arbitrarily nested fields, several recursive implementations of data-type access are implemented for the void type. A common idiom is to cycle through the elements of the dictionary and perform a specific operation based on the data-type object stored at the given offset. These offsets can be arbitrary numbers. Therefore, the possibility of encountering mis- aligned data must be recognized and taken into account if necessary.</source>
          <target state="translated">내장 데이터 유형 중 하나 인 void 데이터 유형은 배열의 요소로 하나 이상의 필드를 포함하는 임의의 구조화 된 유형을 허용합니다. 필드는 단순히 현재 구조화 된 유형에 대한 오프셋과 함께 다른 데이터 유형 개체입니다. 임의로 중첩 된 필드를 지원하기 위해 void 유형에 대해 여러 재귀적인 데이터 유형 액세스 구현이 구현됩니다. 일반적인 관용구는 사전의 요소를 순환하고 주어진 오프셋에 저장된 데이터 유형 객체를 기반으로 특정 작업을 수행하는 것입니다. 이 오프셋은 임의의 숫자 일 수 있습니다. 따라서 잘못 정렬 된 데이터가 발생할 가능성을 인식하고 필요한 경우 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="7fb71e305de0bd82275b57dccd8d18215eb5533d" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="translated">&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt; 의 요소 중 하나는 유형 객체 구조에 대한 포인터입니다. 새로운 유형 객체 구조를 생성하고 원하는 유형의 동작을 설명하는 함수와 포인터로 채우면 새로운 Python 유형이 생성됩니다. 일반적으로 유형의 각 객체에 필요한 인스턴스 별 정보를 포함하기 위해 새로운 C 구조도 생성됩니다. 예를 들어, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; 은 ndarray 에 대한 유형-객체 테이블에 대한 포인터이고 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; 변수는 ndarray 의 특정 인스턴스에 대한 포인터입니다 (ndarray 구조의 구성원 중 하나는 차례로 유형에 대한 포인터입니다. -개체 테이블 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; ). 마지막으로 &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt;(&amp;lt;pointer_to_type_object&amp;gt;)는 모든 새로운 Python 유형에 대해 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="7f15581ffc61dc8d280c89c7bfaccc5af8a60a18" translate="yes" xml:space="preserve">
          <source>One of the elements in &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; is a pointer to a type-object structure. A new Python type is created by creating a new type-object structure and populating it with functions and pointers to describe the desired behavior of the type. Typically, a new C-structure is also created to contain the instance-specific information needed for each object of the type as well. For example, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt; is a pointer to the type-object table for the ndarray while a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt; variable is a pointer to a particular instance of an ndarray (one of the members of the ndarray structure is, in turn, a pointer to the type- object table &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;). Finally &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_type_object&amp;gt;) must be called for every new Python type.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt; 의 요소 중 하나는 유형 객체 구조에 대한 포인터입니다. 새로운 유형 객체 구조를 생성하고 원하는 유형의 동작을 설명하는 함수와 포인터로 채우면 새로운 Python 유형이 생성됩니다. 일반적으로 유형의 각 객체에 필요한 인스턴스 별 정보를 포함하기 위해 새로운 C 구조도 생성됩니다. 예를 들어, &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; 은 ndarray 에 대한 유형-객체 테이블에 대한 포인터이고 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; 변수는 ndarray 의 특정 인스턴스에 대한 포인터입니다 (ndarray 구조의 구성원 중 하나는 차례로 유형에 대한 포인터입니다. -개체 테이블 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; ). 마지막으로 &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt;(&amp;lt;pointer_to_type_object&amp;gt;)는 모든 새로운 Python 유형에 대해 호출되어야합니다.</target>
        </trans-unit>
        <trans-unit id="800f0527f171cc2cc2f96013ed1d0d73822e318b" translate="yes" xml:space="preserve">
          <source>One of the enumerated types or &lt;a href=&quot;../reference/c-api/dtype#c.NPY_NOTYPE&quot;&gt;&lt;code&gt;NPY_NOTYPE&lt;/code&gt;&lt;/a&gt; if the data-type should be determined from the object itself. The C-based names can be used:</source>
          <target state="translated">열거 된 유형 중 하나 또는 데이터 유형이 객체 자체에서 결정되어야하는 경우 &lt;a href=&quot;../reference/c-api/dtype#c.NPY_NOTYPE&quot;&gt; &lt;code&gt;NPY_NOTYPE&lt;/code&gt; &lt;/a&gt; 입니다. C 기반 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b8bb917d30f8e918beefbd1feb7c9a171676de0" translate="yes" xml:space="preserve">
          <source>One of the following string values or a user supplied function.</source>
          <target state="translated">다음 문자열 값 중 하나 또는 사용자 제공 함수.</target>
        </trans-unit>
        <trans-unit id="c247d033f683cfebb6311017bf9488ea1b3de438" translate="yes" xml:space="preserve">
          <source>One of the lesser-used features that has been lurking in Python since 2.2 is the ability to sub-class types in C. This facility is one of the important reasons for basing NumPy off of the Numeric code-base which was already in C. A sub-type in C allows much more flexibility with regards to memory management. Sub-typing in C is not difficult even if you have only a rudimentary understanding of how to create new types for Python. While it is easiest to sub-type from a single parent type, sub-typing from multiple parent types is also possible. Multiple inheritance in C is generally less useful than it is in Python because a restriction on Python sub-types is that they have a binary compatible memory layout. Perhaps for this reason, it is somewhat easier to sub-type from a single parent type.</source>
          <target state="translated">2.2 이후 파이썬에 숨어있는 덜 사용되는 기능 중 하나는 C에서 유형을 하위 클래스 화하는 기능입니다.이 기능은 이미 C에 있던 숫자 코드 기반에서 NumPy를 기반으로하는 중요한 이유 중 하나입니다. C의 하위 유형은 메모리 관리와 관련하여 훨씬 더 많은 유연성을 허용합니다. C의 하위 타이핑은 파이썬을위한 새로운 유형을 만드는 방법에 대한 기초적인 이해 만 가지고 있어도 어렵지 않습니다. 단일 상위 유형에서 하위 유형을 지정하는 것이 가장 쉽지만 여러 상위 유형에서 하위 유형을 지정할 수도 있습니다. C의 다중 상속은 일반적으로 Python에서보다 덜 유용합니다. 왜냐하면 Python 하위 유형에 대한 제한은 바이너리 호환 메모리 레이아웃이 있다는 것입니다. 이러한 이유로 단일 상위 유형에서 하위 유형을 지정하는 것이 다소 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="27403d9ce40c15186aafb846c5de4d2a9de532c0" translate="yes" xml:space="preserve">
          <source>One of the problems that ndarray solves is keeping track of memory ownership of ndarrays and their views. Consider the case where we have created an ndarray, &lt;code&gt;arr&lt;/code&gt; and have taken a slice with &lt;code&gt;v = arr[1:]&lt;/code&gt;. The two objects are looking at the same memory. NumPy keeps track of where the data came from for a particular array or view, with the &lt;code&gt;base&lt;/code&gt; attribute:</source>
          <target state="translated">ndarray가 해결하는 문제 중 하나는 ndarray 및 해당 뷰의 메모리 소유권을 추적하는 것입니다. ndarray, &lt;code&gt;arr&lt;/code&gt; 을 생성하고 &lt;code&gt;v = arr[1:]&lt;/code&gt; 으로 슬라이스를 취한 경우를 고려하십시오 . 두 개체는 동일한 메모리를보고 있습니다. NumPy는 &lt;code&gt;base&lt;/code&gt; 속성 을 사용하여 특정 배열 또는 뷰에 대한 데이터의 출처를 추적 합니다.</target>
        </trans-unit>
        <trans-unit id="e3967d3ba22f4ac7f4c1ab09bac9634bd847ca9c" translate="yes" xml:space="preserve">
          <source>One of:</source>
          <target state="translated">다음 중 하나 :</target>
        </trans-unit>
        <trans-unit id="eb28eadbd381d78c0578e9d33fcdb60f914be747" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have three or more dimensions are preserved.</source>
          <target state="translated">하나 이상의 배열 형 시퀀스 비 배열 입력은 배열로 변환됩니다. 이미 3 개 이상의 차원이있는 배열은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="30e8ba24447e6b42366fd8b8bb4f9518361510cc" translate="yes" xml:space="preserve">
          <source>One or more array-like sequences. Non-array inputs are converted to arrays. Arrays that already have two or more dimensions are preserved.</source>
          <target state="translated">하나 이상의 배열 형 시퀀스 비 배열 입력은 배열로 변환됩니다. 이미 두 개 이상의 차원이있는 배열은 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="b5ac146eea9a6c289d467e482f8a257b9519c8d8" translate="yes" xml:space="preserve">
          <source>One or more input arrays.</source>
          <target state="translated">하나 이상의 입력 배열.</target>
        </trans-unit>
        <trans-unit id="c995dd2d01832787cd57c037ae2c18a3ecd49592" translate="yes" xml:space="preserve">
          <source>One padding, Outside bounds values will be 1.</source>
          <target state="translated">하나의 패딩, 외부 경계 값은 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="d567aa2c7888a9ebb9443758e2ad3f65f13a88e0" translate="yes" xml:space="preserve">
          <source>One possibility we can think of is to interpolate the missing data to estimate the number of cases in late January. Observe that we can select the masked elements using the &lt;code&gt;.mask&lt;/code&gt; attribute:</source>
          <target state="translated">우리가 생각할 수있는 한 가지 가능성은 누락 된 데이터를 보간하여 1 월 말의 사례 수를 추정하는 것입니다. &lt;code&gt;.mask&lt;/code&gt; 속성을 사용하여 마스크 된 요소를 선택할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce4e66d66f3f25393b9b9092b14d986216b8ea91" translate="yes" xml:space="preserve">
          <source>One relatively simple and reliable way to check for the compiler used to build a library is to use ldd on the library. If libg2c.so is a dependency, this means that g77 has been used (note: g77 is no longer supported for building NumPy). If libgfortran.so is a dependency, gfortran has been used. If both are dependencies, this means both have been used, which is almost always a very bad idea.</source>
          <target state="translated">라이브러리를 빌드하는 데 사용되는 컴파일러를 확인하는 비교적 간단하고 안정적인 방법 중 하나는 라이브러리에서 ldd를 사용하는 것입니다. libg2c.so가 종속성이면 g77이 사용되었음을 의미합니다 (참고 : g77은 NumPy 빌드에 더 이상 지원되지 않음). libgfortran.so가 종속성이면 gfortran이 사용되었습니다. 둘 다 종속성이면 둘 다 사용되었음을 의미하며 이는 거의 항상 매우 나쁜 생각입니다.</target>
        </trans-unit>
        <trans-unit id="e6362eba61fec5cf9abb4f9817d64b7cd0aed92b" translate="yes" xml:space="preserve">
          <source>One sees that the &lt;code&gt;super&lt;/code&gt; call, which goes to &lt;code&gt;ndarray.__new__&lt;/code&gt;, passes &lt;code&gt;__array_finalize__&lt;/code&gt; the new object, of our own class (&lt;code&gt;self&lt;/code&gt;) as well as the object from which the view has been taken (&lt;code&gt;obj&lt;/code&gt;). As you can see from the output above, the &lt;code&gt;self&lt;/code&gt; is always a newly created instance of our subclass, and the type of &lt;code&gt;obj&lt;/code&gt; differs for the three instance creation methods:</source>
          <target state="translated">&lt;code&gt;ndarray.__new__&lt;/code&gt; 로 이동 하는 &lt;code&gt;super&lt;/code&gt; 호출 은 &lt;code&gt;__array_finalize__&lt;/code&gt; 자신의 클래스 ( &lt;code&gt;self&lt;/code&gt; )와 뷰를 가져온 객체 ( &lt;code&gt;obj&lt;/code&gt; ) 의 새 객체를 전달 합니다 . 위의 출력에서 ​​볼 수 있듯이 &lt;code&gt;self&lt;/code&gt; 는 항상 우리 서브 클래스의 새로 생성 된 인스턴스이며 &lt;code&gt;obj&lt;/code&gt; 유형은 세 가지 인스턴스 생성 방법에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="33ec8922f9be1aeeb6fe45b52431c5e822f5d065" translate="yes" xml:space="preserve">
          <source>One simple way to achieve this is to install the released version in site-packages, by using a binary installer or pip for example, and set up the development version in a virtualenv. First install &lt;a href=&quot;http://www.virtualenv.org/&quot;&gt;virtualenv&lt;/a&gt; (optionally use &lt;a href=&quot;http://www.doughellmann.com/projects/virtualenvwrapper/&quot;&gt;virtualenvwrapper&lt;/a&gt;), then create your virtualenv (named numpy-dev here) with:</source>
          <target state="translated">이를 달성하는 한 가지 간단한 방법은 바이너리 설치 프로그램 또는 pip를 사용하여 사이트 패키지에 릴리스 된 버전을 설치하고 virtualenv에서 개발 버전을 설정하는 것입니다. 먼저 &lt;a href=&quot;http://www.virtualenv.org/&quot;&gt;virtualenv를&lt;/a&gt; 설치하고 (선택적으로 &lt;a href=&quot;http://www.doughellmann.com/projects/virtualenvwrapper/&quot;&gt;virtualenvwrapper&lt;/a&gt; 사용 ) 다음을 사용하여 virtualenv (여기서는 numpy-dev로 명명 됨)를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="01bd59e7480ae8ee0b30eea6aab25ec69688345a" translate="yes" xml:space="preserve">
          <source>One thing to watch out for is conversions back to the original data type when using a read-write or write-only operand. A common case is to implement the inner loop in terms of 64-bit floats, and use &amp;lsquo;same_kind&amp;rsquo; casting to allow the other floating-point types to be processed as well. While in read-only mode, an integer array could be provided, read-write mode will raise an exception because conversion back to the array would violate the casting rule.</source>
          <target state="translated">주의해야 할 사항은 읽기 쓰기 또는 쓰기 전용 피연산자를 사용할 때 원래 데이터 형식으로 다시 변환하는 것입니다. 일반적인 경우는 64 비트 부동 소수점으로 내부 루프를 구현하고 'same_kind'캐스팅을 사용하여 다른 부동 소수점 유형도 처리 할 수 ​​있습니다. 읽기 전용 모드에서는 정수 배열이 제공 될 수 있지만, 읽기 / 쓰기 모드는 배열로 다시 변환 할 때 캐스팅 규칙을 위반하므로 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2cc36f9c20276e56c093db5e52fdeb366528fc58" translate="yes" xml:space="preserve">
          <source>One vector with dimension 2.</source>
          <target state="translated">차원이 2 인 하나의 벡터</target>
        </trans-unit>
        <trans-unit id="99918e2f05caf6cd6ec60dc844a473737b719247" translate="yes" xml:space="preserve">
          <source>One very nice feature of testing is allowing easy testing across a range of parameters - a nasty problem for standard unit tests. Use the &lt;code&gt;dec.paramaterize&lt;/code&gt; decorator.</source>
          <target state="translated">테스트의 매우 유용한 기능 중 하나는 표준 단위 테스트에서 어려운 문제인 다양한 매개 변수에서 쉽게 테스트 할 수 있다는 것입니다. &lt;code&gt;dec.paramaterize&lt;/code&gt; 데코레이터를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bd9c1c4f351a78f93a1ea46f7fb6388f8d6e8ce8" translate="yes" xml:space="preserve">
          <source>One way we can initialize NumPy arrays is from Python lists, using nested lists for two- or higher-dimensional data.</source>
          <target state="translated">NumPy 배열을 초기화 할 수있는 한 가지 방법은 2 차원 이상의 데이터에 중첩 된 목록을 사용하는 Python 목록에서 가져 오는 것입니다.</target>
        </trans-unit>
        <trans-unit id="bd980620fd6bb0d38c87e52f67df303553acf634" translate="yes" xml:space="preserve">
          <source>One-character strings</source>
          <target state="translated">1 문자열</target>
        </trans-unit>
        <trans-unit id="7dd48564d3a850a05467a68a151727d64b2ad461" translate="yes" xml:space="preserve">
          <source>One-dimensional arrays are then printed as rows, bidimensionals as matrices and tridimensionals as lists of matrices.</source>
          <target state="translated">그런 다음 1 차원 배열은 행으로, 2 차원은 행렬로, 3 차원은 행렬 목록으로 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="5131dc464a794c785bc59aee87c51ca82227aaed" translate="yes" xml:space="preserve">
          <source>One-dimensional linear interpolation.</source>
          <target state="translated">1 차원 선형 보간.</target>
        </trans-unit>
        <trans-unit id="cd572fc9dc51ce4fd31312f0bb79afc0c6e4432a" translate="yes" xml:space="preserve">
          <source>One-dimensional, two-dimensional, three-dimensional and four-dimensional arrays.</source>
          <target state="translated">1 차원, 2 차원, 3 차원 및 4 차원 배열.</target>
        </trans-unit>
        <trans-unit id="3b7777f0a5babbc2cd6ca70c30ebaa80abc0442d" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 데이터 유형에 대한 1 입력, 1 출력 및 2 입력, 1 출력 코어 1d 기능 . 이 함수는 참조 횟수 문제를 처리하고 오류 발생시 조기에 반환됩니다. 호출에 실제 기능입니다 &lt;em&gt;FUNC&lt;/em&gt; 과는 서명 호출을 수용해야합니다 &lt;code&gt;(PyObject*) (PyObject*)&lt;/code&gt; 에 대한 &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt; &lt;code&gt;PyUFunc_O_O&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;(PyObject*)(PyObject *, PyObject *)&lt;/code&gt; 에 대한 &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt; &lt;code&gt;PyUFunc_OO_O&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8c1f106f50e29c9c2b8a1ac2b65d27f3773387b3" translate="yes" xml:space="preserve">
          <source>One-input, one-output, and two-input, one-output core 1-d functions for the &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; data type. These functions handle reference count issues and return early on error. The actual function to call is &lt;em&gt;func&lt;/em&gt; and it must accept calls with the signature &lt;code&gt;(PyObject*)
(PyObject*)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt;&lt;code&gt;PyUFunc_O_O&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;(PyObject*)(PyObject *,
PyObject *)&lt;/code&gt; for &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt;&lt;code&gt;PyUFunc_OO_O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 데이터 유형에 대한 1 개 입력, 1 개 출력 및 2 개 입력, 1 개 출력 코어 1-d 함수입니다 . 이러한 함수는 참조 횟수 문제를 처리하고 오류가 발생하면 조기에 반환합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 호출에 실제 기능입니다 &lt;em&gt;FUNC&lt;/em&gt; 과는 서명 호출을 수용해야합니다 &lt;code&gt;(PyObject*) (PyObject*)&lt;/code&gt; 에 대한 &lt;a href=&quot;#c.PyUFunc_O_O&quot;&gt; &lt;code&gt;PyUFunc_O_O&lt;/code&gt; &lt;/a&gt; 또는 &lt;code&gt;(PyObject*)(PyObject *, PyObject *)&lt;/code&gt; 에 대한 &lt;a href=&quot;#c.PyUFunc_OO_O&quot;&gt; &lt;code&gt;PyUFunc_OO_O&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ddd47ce11e1fa9754d28954cfcd5881bbc1273cc" translate="yes" xml:space="preserve">
          <source>Ones and zeros</source>
          <target state="translated">1과 0</target>
        </trans-unit>
        <trans-unit id="cb940bbbd02e7c31b4ae50aac2139276e3822e9f" translate="yes" xml:space="preserve">
          <source>Ones are returned for slices that are all-NaN or empty.</source>
          <target state="translated">all-NaN이거나 비어있는 슬라이스에 대해서는 1이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="09f22eb6b2adcce43b85d8b07506fb5c95ab640d" translate="yes" xml:space="preserve">
          <source>Only a few, unrelated commits then prefer rebasing:</source>
          <target state="translated">관련되지 않은 소수의 커밋 만이 리베이스를 선호합니다.</target>
        </trans-unit>
        <trans-unit id="32b697531330130760eafc916bd6f1be5353ebde" translate="yes" xml:space="preserve">
          <source>Only a survey of the choices. Little detail on how each works.</source>
          <target state="translated">선택 사항에 대한 설문 조사 일뿐입니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 각각의 작동 방식에 대한 세부 사항.</target>
        </trans-unit>
        <trans-unit id="1addd7b3649a3c34fc344240c254d5a275033117" translate="yes" xml:space="preserve">
          <source>Only accepts 1-D arrays.</source>
          <target state="translated">1 차원 배열 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="bde044c10adb7133cf0f3ad6c4862788f16172f1" translate="yes" xml:space="preserve">
          <source>Only accepts 2-D arrays at most.</source>
          <target state="translated">최대 2D 배열 만 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7afe5b0a4d7cbceb0c653cfc81e1d454858d38ee" translate="yes" xml:space="preserve">
          <source>Only allow casts which will not cause values to be rounded, truncated, or otherwise changed.</source>
          <target state="translated">값이 반올림되거나 잘 리거나 다르게 변경되지 않는 캐스트 만 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="c3582e0ecb066430ad3be065ab374165ffa609f3" translate="yes" xml:space="preserve">
          <source>Only allow identical types.</source>
          <target state="translated">동일한 유형 만 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="603519900a2e75cc37ace5a2f71e7c45cdb8b832" translate="yes" xml:space="preserve">
          <source>Only an integer decimal number can be used.</source>
          <target state="translated">정수 10 진수 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cae35f53e6308f43d551d7ad3a2026ad04e15e23" translate="yes" xml:space="preserve">
          <source>Only contiguous arrays (data elements consecutive in memory) can be resized.</source>
          <target state="translated">연속 배열 (메모리에서 연속적인 데이터 요소) 만 크기를 조정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e992238c6b6cf34041def067b036cda1362cc0ed" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled.</source>
          <target state="translated">정수 및 부울 유형 만 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="ce974e565e6e54262541b566a10f88e312bc9462" translate="yes" xml:space="preserve">
          <source>Only integer and boolean types are handled. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">정수 및 부울 유형 만 처리됩니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="7329167d275db4d33debe4e1e78cc7c194228992" translate="yes" xml:space="preserve">
          <source>Only on intel (windows?)</source>
          <target state="translated">인텔에서만 (Windows?)</target>
        </trans-unit>
        <trans-unit id="c1e46a9dd5cfa9d4541737997e2a69c528376429" translate="yes" xml:space="preserve">
          <source>Only return the middle values of the convolution. Contains boundary effects, where zeros are taken into account:</source>
          <target state="translated">컨벌루션의 중간 값만 반환하십시오. 0을 고려한 경계 효과를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="c646c2238b413bc43301092aedff89ef1f867724" translate="yes" xml:space="preserve">
          <source>Only returned if &lt;code&gt;retstep&lt;/code&gt; is True</source>
          <target state="translated">&lt;code&gt;retstep&lt;/code&gt; 이 True 인 경우에만 반환</target>
        </trans-unit>
        <trans-unit id="e429b326ee86d54ede5217418c8826c4e767d391" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt;&lt;code&gt;ndarray.setflags&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE 및 ALIGNED 플래그 만 사용자가 속성 또는 사전 항목에 직접 지정하거나 &lt;a href=&quot;numpy.ndarray.setflags#numpy.ndarray.setflags&quot;&gt; &lt;code&gt;ndarray.setflags&lt;/code&gt; &lt;/a&gt; 를 호출하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba8823766a1477c99c5d6107c4aad19cb79aa3fe" translate="yes" xml:space="preserve">
          <source>Only the WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE, and ALIGNED flags can be changed by the user, via direct assignment to the attribute or dictionary entry, or by calling &lt;code&gt;ndarray.setflags&lt;/code&gt;.</source>
          <target state="translated">WRITEBACKIFCOPY, UPDATEIFCOPY, WRITEABLE 및 ALIGNED 플래그 만 사용자가 속성 또는 사전 항목에 직접 지정하거나 &lt;code&gt;ndarray.setflags&lt;/code&gt; 를 호출하여 변경할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="14128c80bfe87033c27d2c8a406f61e4d63d6d90" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked by default.</source>
          <target state="translated">기본적으로 a 및 b의 메모리 범위 만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="a133ec60f230a1d745372bd29522c9608116df62" translate="yes" xml:space="preserve">
          <source>Only the memory bounds of a and b are checked.</source>
          <target state="translated">a와 b의 메모리 경계 만 검사됩니다.</target>
        </trans-unit>
        <trans-unit id="2828ce3af0ec6cf22589ee67ae2d61139d97726f" translate="yes" xml:space="preserve">
          <source>Only used in &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt;&lt;code&gt;PyArray_CheckFromAny&lt;/code&gt;&lt;/a&gt; to over-ride the byteorder of the data-type object passed in.</source>
          <target state="translated">전달 된 데이터 형식 개체의 바이트 순서를 &lt;a href=&quot;#c.PyArray_CheckFromAny&quot;&gt; &lt;code&gt;PyArray_CheckFromAny&lt;/code&gt; &lt;/a&gt; 하기 위해 PyArray_CheckFromAny 에서만 사용 됩니다.</target>
        </trans-unit>
        <trans-unit id="c499db64f45476fb60b7a934c6b0e9eae67b09aa" translate="yes" xml:space="preserve">
          <source>Only useful in forcing objects in object arrays on Python 3 to be pickled in a Python 2 compatible way. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the new Python 3 names to the old module names used in Python 2, so that the pickle data stream is readable with Python 2.</source>
          <target state="translated">Python 3에서 객체 배열의 객체를 Python 2 호환 방식으로 강제로 선택하는 경우에만 유용합니다. 경우 &lt;code&gt;fix_imports&lt;/code&gt; 은 True입니다 피클은 피클 데이터 스트림 파이썬 2 읽을 그래서, 파이썬 2에서 사용 된 모듈 이름에 새로운 파이썬 3 명을 매핑 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="9be2bb2a7cf937c49df50863791a7e2b8e618032" translate="yes" xml:space="preserve">
          <source>Only useful when loading Python 2 generated pickled files on Python 3, which includes npy/npz files containing object arrays. If &lt;code&gt;fix_imports&lt;/code&gt; is True, pickle will try to map the old Python 2 names to the new names used in Python 3.</source>
          <target state="translated">Python 3에서 객체 배열을 포함하는 npy / npz 파일을 포함하는 Python 2 생성 된 절인 파일을로드 할 때만 유용합니다. 경우 &lt;code&gt;fix_imports&lt;/code&gt; 은 True입니다 피클은 파이썬 3에서 사용 된 새로운 이름으로 기존의 파이썬이 이름을 매핑하려고합니다.</target>
        </trans-unit>
        <trans-unit id="284f33151b0cb79968c40e4b088e6fb638c9882a" translate="yes" xml:space="preserve">
          <source>Open a .npy file as a memory-mapped array.</source>
          <target state="translated">.npy 파일을 메모리 매핑 배열로 엽니 다.</target>
        </trans-unit>
        <trans-unit id="17ffc3b0833d539654e5ad58b641d1cef1d2a7bc" translate="yes" xml:space="preserve">
          <source>Open and return file-like object.</source>
          <target state="translated">파일과 같은 객체를 열고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="bb7abb02e2506f465eda9d56007ed5a7e2b0bd98" translate="yes" xml:space="preserve">
          <source>Open existing file for reading and writing.</source>
          <target state="translated">읽고 쓸 기존 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="bd185b75f1b59e945b739489c944a7512ff51fd8" translate="yes" xml:space="preserve">
          <source>Open existing file for reading only.</source>
          <target state="translated">읽기 전용으로 기존 파일을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="96179d121ec9cf7124c6c2755cce0f345158530b" translate="yes" xml:space="preserve">
          <source>Open file object or filename.</source>
          <target state="translated">파일 객체 또는 파일 이름을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="a6f0b5cd06c0857fa1094ec1c01c44ffc62a3722" translate="yes" xml:space="preserve">
          <source>Open text file with given encoding. The default encoding will be what &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt;&lt;code&gt;io.open&lt;/code&gt;&lt;/a&gt; uses.</source>
          <target state="translated">주어진 인코딩으로 텍스트 파일을 엽니 다. 기본 인코딩은 &lt;a href=&quot;https://docs.python.org/dev/library/io.html#io.open&quot;&gt; &lt;code&gt;io.open&lt;/code&gt; 이&lt;/a&gt; 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="988a0621a69f95c126d429edd6ad72b8b9753d30" translate="yes" xml:space="preserve">
          <source>OpenBLAS</source>
          <target state="translated">OpenBLAS</target>
        </trans-unit>
        <trans-unit id="9e6729afd8b62e6a17fee3a65c668dbe74656c3a" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 with &lt;code&gt;64_&lt;/code&gt; symbol suffix (&lt;code&gt;openblas64_&lt;/code&gt;)</source>
          <target state="translated">와 OpenBLAS ILP64 &lt;code&gt;64_&lt;/code&gt; 기호 접미사 ( &lt;code&gt;openblas64_&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6db258279bc027edbc14a901c4f72c25179352f5" translate="yes" xml:space="preserve">
          <source>OpenBLAS ILP64 without symbol suffix (&lt;code&gt;openblas_ilp64&lt;/code&gt;)</source>
          <target state="translated">기호 접미사가없는 OpenBLAS ILP64 ( &lt;code&gt;openblas_ilp64&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d9413e771602d364356d827e1ba5484c54b2980c" translate="yes" xml:space="preserve">
          <source>OpenGL Half Float Pixel Support</source>
          <target state="translated">OpenGL Half Float Pixel 지원</target>
        </trans-unit>
        <trans-unit id="92b199ce7b8a6cd2b986683aff11b8b6f7fca3cd" translate="yes" xml:space="preserve">
          <source>Openness &amp;amp; Transparency</source>
          <target state="translated">개방성 및 투명성</target>
        </trans-unit>
        <trans-unit id="a1fdaa6b2a846c8fcf18d414bf8c61db610eda6a" translate="yes" xml:space="preserve">
          <source>Operations</source>
          <target state="translated">Operations</target>
        </trans-unit>
        <trans-unit id="802737eaf4ae404056a43d4b36a403eb607a4663" translate="yes" xml:space="preserve">
          <source>Operations on an axis</source>
          <target state="translated">축에 대한 작업</target>
        </trans-unit>
        <trans-unit id="ba63388b76fb2354877e0a00827567f3e7dd9beb" translate="yes" xml:space="preserve">
          <source>Operations on masked arrays</source>
          <target state="translated">마스크 배열 작업</target>
        </trans-unit>
        <trans-unit id="52f32163af2ed7163e716ed54ad45e1abac6d362" translate="yes" xml:space="preserve">
          <source>Operations on masks</source>
          <target state="translated">마스크 작업</target>
        </trans-unit>
        <trans-unit id="ee87ced5cf49f6083697398814cf1d512f44d6ad" translate="yes" xml:space="preserve">
          <source>Operations on np.memmap objects return numpy arrays in most cases</source>
          <target state="translated">np.memmap 객체에 대한 작업은 대부분의 경우 numpy 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e36cb408f625975bc7da03d4112be652fbd5e3b3" translate="yes" xml:space="preserve">
          <source>Operations where ufunc input and output operands have memory overlap are defined to be the same as for equivalent operations where there is no memory overlap. Operations affected make temporary copies as needed to eliminate data dependency. As detecting these cases is computationally expensive, a heuristic is used, which may in rare cases result in needless temporary copies. For operations where the data dependency is simple enough for the heuristic to analyze, temporary copies will not be made even if the arrays overlap, if it can be deduced copies are not necessary. As an example, &lt;code&gt;np.add(a, b, out=a)&lt;/code&gt; will not involve copies.</source>
          <target state="translated">ufunc 입력 및 출력 피연산자가 메모리 겹침을 갖는 연산은 메모리 겹침이없는 동등한 연산과 동일하게 정의됩니다. 영향을받는 작업은 데이터 종속성을 제거하기 위해 필요에 따라 임시 복사본을 만듭니다. 이러한 경우를 감지하는 것은 계산 비용이 많이 들기 때문에 휴리스틱이 사용되며 드물게 불필요한 임시 복사본이 생성 될 수 있습니다. 휴리스틱이 분석 할 수있을만큼 데이터 종속성이 간단한 작업의 경우, 추론 할 수있는 경우 복제가 필요하지 않은 경우 어레이가 겹치더라도 임시 복사본이 만들어지지 않습니다. 예를 들어, &lt;code&gt;np.add(a, b, out=a)&lt;/code&gt; 는 복사본을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9ca78838064bd04174cc1a2b7101984f13a328d5" translate="yes" xml:space="preserve">
          <source>Operators &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;@&lt;/code&gt;, functions &lt;code&gt;dot()&lt;/code&gt;, and &lt;code&gt;multiply()&lt;/code&gt;:</source>
          <target state="translated">연산자 &lt;code&gt;*&lt;/code&gt; 및 &lt;code&gt;@&lt;/code&gt; , 함수 &lt;code&gt;dot()&lt;/code&gt; 및 &lt;code&gt;multiply()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5c0563fccbe64a1dfd8037f51262c4fd0530cd94" translate="yes" xml:space="preserve">
          <source>Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing. Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.</source>
          <target state="translated">Oppenheim, AV 및 RW Schafer. 불연속 신호 처리. 뉴저지 북부 새들 리버 : Prentice-Hall, 1999, 468-471 쪽.</target>
        </trans-unit>
        <trans-unit id="dc6761ca91dcee4424a2851cbb50045197345e3f" translate="yes" xml:space="preserve">
          <source>Optimal &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (best usage pattern in some use cases): ~110ms</source>
          <target state="translated">최적의 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (일부 사용 사례에서 최상의 사용 패턴) : ~ 110ms</target>
        </trans-unit>
        <trans-unit id="14a620b1a39a0c10e2201e1aff4cc0715f2dfce6" translate="yes" xml:space="preserve">
          <source>Optimization names can be CPU features or groups of features that gather several features or &lt;a href=&quot;#special-options&quot;&gt;special options&lt;/a&gt; to perform a series of procedures.</source>
          <target state="translated">최적화 이름은 일련의 절차를 수행하기 위해 여러 기능 또는 &lt;a href=&quot;#special-options&quot;&gt;특수 옵션&lt;/a&gt; 을 수집하는 CPU 기능 또는 기능 그룹 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6005faa183a89f9948e43f5a980447b421fb158" translate="yes" xml:space="preserve">
          <source>Optimizations for operations of the form &lt;code&gt;A.T @ A&lt;/code&gt; and &lt;code&gt;A @ A.T&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;A.T @ A&lt;/code&gt; 및 &lt;code&gt;A @ A.T&lt;/code&gt; 형식의 작업에 대한 최적화</target>
        </trans-unit>
        <trans-unit id="99a9abbcaa67a245b7df3c4aa99c089ac4fab21b" translate="yes" xml:space="preserve">
          <source>Optimizing a looping block by specialized code. In a traditional sense, vectorization performs the same operation on multiple elements with fixed strides between them via specialized hardware. Compilers know how to take advantage of well-constructed loops to implement such optimizations. NumPy uses &lt;a href=&quot;user/whatisnumpy#whatis-vectorization&quot;&gt;vectorization&lt;/a&gt; to mean any optimization via specialized code performing the same operations on multiple elements, typically achieving speedups by avoiding some of the overhead in looking up and converting the elements.</source>
          <target state="translated">특수 코드로 루핑 블록 최적화. 전통적인 의미에서 벡터화는 특수 하드웨어를 통해 여러 요소간에 고정 된 보폭으로 여러 요소에서 동일한 작업을 수행합니다. 컴파일러는 잘 구성된 루프를 활용하여 이러한 최적화를 구현하는 방법을 알고 있습니다. NumPy는 &lt;a href=&quot;user/whatisnumpy#whatis-vectorization&quot;&gt;벡터화&lt;/a&gt; 를 사용 하여 여러 요소에 대해 동일한 작업을 수행하는 특수 코드를 통한 최적화를 의미 하며 , 일반적으로 요소를 찾고 변환 할 때 약간의 오버 헤드를 피하여 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="92272bcec6c59382899a85edc8fe1911432803d7" translate="yes" xml:space="preserve">
          <source>Option whether to print a line feed or not. Defaults to True.</source>
          <target state="translated">줄 바꿈을 인쇄할지 여부를 선택합니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="f1be0f36b97d1f66b6be8a1b7591fde1a83a0d94" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;axis&lt;/code&gt; argument for methods like &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt;&lt;code&gt;choice&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt;&lt;code&gt;permutation&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt;&lt;code&gt;shuffle&lt;/code&gt;&lt;/a&gt; that controls which axis an operation is performed over for multi-dimensional arrays.</source>
          <target state="translated">다차원 배열에 대해 작업이 수행되는 축을 제어하는 &lt;a href=&quot;generated/numpy.random.generator.choice#numpy.random.Generator.choice&quot;&gt; &lt;code&gt;choice&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.random.generator.permutation#numpy.random.Generator.permutation&quot;&gt; &lt;code&gt;permutation&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.random.generator.shuffle#numpy.random.Generator.shuffle&quot;&gt; &lt;code&gt;shuffle&lt;/code&gt; &lt;/a&gt; 과 같은 메서드에 대한 선택적 &lt;code&gt;axis&lt;/code&gt; 인수입니다 .</target>
        </trans-unit>
        <trans-unit id="fb8be51f4f30d13faa44a6de0502a01108e24089" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;dtype&lt;/code&gt; argument that accepts &lt;code&gt;np.float32&lt;/code&gt; or &lt;code&gt;np.float64&lt;/code&gt; to produce either single or double prevision uniform random variables for select distributions</source>
          <target state="translated">&lt;code&gt;np.float32&lt;/code&gt; 또는 &lt;code&gt;np.float64&lt;/code&gt; 를 허용 하여 선택 분포에 대한 단일 또는 이중 사전 균일 한 무작위 변수를 생성 하는 선택적 &lt;code&gt;dtype&lt;/code&gt; 인수</target>
        </trans-unit>
        <trans-unit id="12126826f76c7f0467a4ffb91534c1d1ec680e4d" translate="yes" xml:space="preserve">
          <source>Optional &lt;code&gt;out&lt;/code&gt; argument that allows existing arrays to be filled for select distributions</source>
          <target state="translated">선택 분포를 위해 기존 배열을 채울 수있는 선택적 &lt;code&gt;out&lt;/code&gt; 인수</target>
        </trans-unit>
        <trans-unit id="01273e336bfe0a367b1748fe162d52aafeac5e31" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as in slice notation.</source>
          <target state="translated">선택적 인수 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 슬라이스 표기법으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="ad0126e97a8970efb03fe063de9451fa05d68f3f" translate="yes" xml:space="preserve">
          <source>Optional arguments &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are interpreted as slice notation to specify the range in which to count.</source>
          <target state="translated">선택적 인수 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 계산할 범위를 지정하기 위해 슬라이스 표기법으로 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="4dd32917dfd5f66fb159ebdd50889a1b4bed7749" translate="yes" xml:space="preserve">
          <source>Optional array of integer indices that sort array a into ascending order. They are typically the result of argsort.</source>
          <target state="translated">배열 a를 오름차순으로 정렬하는 정수 인덱스의 선택적 배열. 그것들은 일반적으로 argsort의 결과입니다.</target>
        </trans-unit>
        <trans-unit id="6024e1a91279063fb7e7889daf1b6251045d44cb" translate="yes" xml:space="preserve">
          <source>Optional character strings placed as the first element of the index expression can be used to change the output. The strings &amp;lsquo;r&amp;rsquo; or &amp;lsquo;c&amp;rsquo; result in matrix output. If the result is 1-D and &amp;lsquo;r&amp;rsquo; is specified a 1 x N (row) matrix is produced. If the result is 1-D and &amp;lsquo;c&amp;rsquo; is specified, then a N x 1 (column) matrix is produced. If the result is 2-D then both provide the same matrix result.</source>
          <target state="translated">인덱스 표현식의 첫 번째 요소로 배치 된 선택적 문자열은 출력을 변경하는 데 사용될 수 있습니다. 문자열 'r'또는 'c'는 행렬 출력을 생성합니다. 결과가 1-D이고 'r'이 지정되면 1 x N (행) 행렬이 생성됩니다. 결과가 1-D이고 'c'가 지정되면 N x 1 (열) 행렬이 생성됩니다. 결과가 2 차원이면 둘 다 동일한 행렬 결과를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fa7999c926f6055eca464cd4cd0189771a96574e" translate="yes" xml:space="preserve">
          <source>Optional keyword arguments</source>
          <target state="translated">선택적 키워드 인수</target>
        </trans-unit>
        <trans-unit id="957ed642dc25daf64f22e9ce4f2d86f58626bccf" translate="yes" xml:space="preserve">
          <source>Optional keyword parameters have default values, which are displayed as part of the function signature. They can also be detailed in the description:</source>
          <target state="translated">선택적 키워드 매개 변수에는 함수 시그니처의 일부로 표시되는 기본값이 있습니다. 또한 설명에서 자세히 설명 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a5739d18910534a4fc38a98f7f49af50c8efbd3" translate="yes" xml:space="preserve">
          <source>Optional reduced verbosity for np.distutils</source>
          <target state="translated">np.distutils에 대한 선택적 축소 된 자세한 정보</target>
        </trans-unit>
        <trans-unit id="5e7d5ecd852396fa81676288ee6a2c196a7a5edc" translate="yes" xml:space="preserve">
          <source>Optional: Check which files have changed with &lt;code&gt;git status&lt;/code&gt; (see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-status.html&quot;&gt;git status&lt;/a&gt;). You&amp;rsquo;ll see a listing like this one:</source>
          <target state="translated">선택 사항 : &lt;code&gt;git status&lt;/code&gt; 변경된 파일을 확인 합니다 ( &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-status.html&quot;&gt;git status&lt;/a&gt; 참조 ). 다음과 같은 목록이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="cc6f5f42f191b45dd21642dce26f8c271e45fd28" translate="yes" xml:space="preserve">
          <source>Optional: Compare the changes with the previous version using with &lt;code&gt;git
diff&lt;/code&gt; (&lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-diff.html&quot;&gt;git diff&lt;/a&gt;). This brings up a simple text browser interface that highlights the difference between your files and the previous version.</source>
          <target state="translated">선택 사항 : &lt;code&gt;git diff&lt;/code&gt; ( &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-diff.html&quot;&gt;git diff&lt;/a&gt; ) 와 함께 사용하여 이전 버전과 변경 사항을 비교하십시오 . 그러면 파일과 이전 버전의 차이점을 강조하는 간단한 텍스트 브라우저 인터페이스가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="b391073386a52a6e7c7d2a204ec775ecfe3f5d3a" translate="yes" xml:space="preserve">
          <source>Optional: set up SSH keys to avoid passwords</source>
          <target state="translated">선택 사항 : 비밀번호를 피하기 위해 SSH 키 설정</target>
        </trans-unit>
        <trans-unit id="4a1956660192de93e6ae71981428d48e53a65ccc" translate="yes" xml:space="preserve">
          <source>Optionally SciPy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="translated">선택적으로 SciPy 가속 루틴 ( &lt;code&gt;numpy.dual&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="32c0f096a4d20dec7aa72b3d7d08a3d6f13db350" translate="yes" xml:space="preserve">
          <source>Optionally SciPy-accelerated routines (numpy.dual)</source>
          <target state="translated">선택적으로 SciPy 가속 루틴 (numpy.dual)</target>
        </trans-unit>
        <trans-unit id="8eb0ace95d7206d55e77238265b3a66f3d4c761a" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (&lt;code&gt;numpy.dual&lt;/code&gt;)</source>
          <target state="translated">선택적으로 Scipy 가속 루틴 ( &lt;code&gt;numpy.dual&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a841da812f87c91971335f8748cac5433932b134" translate="yes" xml:space="preserve">
          <source>Optionally Scipy-accelerated routines (numpy.dual)</source>
          <target state="translated">선택적으로 Scipy 가속 루틴 (numpy.dual)</target>
        </trans-unit>
        <trans-unit id="8836fa518e3fcc554024b475844ea5ac0ecd26c6" translate="yes" xml:space="preserve">
          <source>Optionally, F2PY created signature files can be edited to optimize wrappers functions, make them &amp;ldquo;smarter&amp;rdquo; and more &amp;ldquo;Pythonic&amp;rdquo;.</source>
          <target state="translated">선택적으로 F2PY가 생성 한 서명 파일을 편집하여 래퍼 기능을 최적화하고 &quot;스마트&quot;하고 &quot;파이 토닉&quot;으로 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a19671beddc2d78364aeb52dc43b5315cb3a7f11" translate="yes" xml:space="preserve">
          <source>Or a non uniform one:</source>
          <target state="translated">또는 균일하지 않은 것 :</target>
        </trans-unit>
        <trans-unit id="8fe65c617425af9e2c3d6f2775ea339d5f9f089e" translate="yes" xml:space="preserve">
          <source>Or a similar way from the command line:</source>
          <target state="translated">또는 명령 줄에서 비슷한 방법으로 :</target>
        </trans-unit>
        <trans-unit id="953f087657473d16d4beb73a89ced5320c3f6acc" translate="yes" xml:space="preserve">
          <source>Or an array filled with &lt;code&gt;1&lt;/code&gt;&amp;rsquo;s:</source>
          <target state="translated">또는 &lt;code&gt;1&lt;/code&gt; 로 채워진 어레이 :</target>
        </trans-unit>
        <trans-unit id="cf7ef857cc1fde38181b075860bab6fb0bd52da8" translate="yes" xml:space="preserve">
          <source>Or as a decorator:</source>
          <target state="translated">또는 데코레이터로 :</target>
        </trans-unit>
        <trans-unit id="c7e6a42ed35b95f820330f765f1edafa77be23aa" translate="yes" xml:space="preserve">
          <source>Or even an empty array! The function &lt;code&gt;empty&lt;/code&gt; creates an array whose initial content is random and depends on the state of the memory. The reason to use &lt;code&gt;empty&lt;/code&gt; over &lt;code&gt;zeros&lt;/code&gt; (or something similar) is speed - just make sure to fill every element afterwards!</source>
          <target state="translated">또는 심지어 빈 배열! &lt;code&gt;empty&lt;/code&gt; 함수 는 초기 내용이 무작위이고 메모리 상태에 따라 달라지는 배열을 만듭니다. &lt;code&gt;zeros&lt;/code&gt; (또는 이와 유사한 것) 위에 &lt;code&gt;empty&lt;/code&gt; 것을 사용하는 이유 는 속도입니다. 나중에 모든 요소를 ​​채워야합니다!</target>
        </trans-unit>
        <trans-unit id="de9b2d57a173de94af257f54a0e80ee07c9cf0f4" translate="yes" xml:space="preserve">
          <source>Or for a vectorized convolution:</source>
          <target state="translated">또는 벡터화 된 회선의 경우 :</target>
        </trans-unit>
        <trans-unit id="b0d8b33e98de773e2f38b3003cb0a7e130e442fc" translate="yes" xml:space="preserve">
          <source>Or from the command line:</source>
          <target state="translated">또는 명령 줄에서 :</target>
        </trans-unit>
        <trans-unit id="87d726b49f504d34574328c172ded1bdd16da0e2" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;numpy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="translated">또는 &lt;code&gt;numpy/xxx/tests/&lt;/code&gt; 를 Python 경로에 추가하면 다음과 같이 인터프리터에서 대화식으로 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60d67dbe290ba345acdc7d9f67357d1c9ca90c84" translate="yes" xml:space="preserve">
          <source>Or if you add &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; to the Python path, you could run the tests interactively in the interpreter like this:</source>
          <target state="translated">또는 &lt;code&gt;scipy/xxx/tests/&lt;/code&gt; 를 Python 경로에 추가하면 다음과 같이 인터프리터에서 대화식으로 테스트를 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="86168e460ad3421414419c2552c4c8f1c87145ff" translate="yes" xml:space="preserve">
          <source>Or more generally, the f2cmap file must contain a dictionary with items:</source>
          <target state="translated">또는보다 일반적으로 f2cmap 파일에는 항목이있는 사전이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="a034f1d60dd7621f858f2d8cd0dbc13046363fae" translate="yes" xml:space="preserve">
          <source>Or reverse only the &lt;em&gt;columns&lt;/em&gt; with:</source>
          <target state="translated">또는 다음을 사용하여 &lt;em&gt;열만&lt;/em&gt; 반전하십시오 .</target>
        </trans-unit>
        <trans-unit id="002d2f07f89a6dd55f4dbdba5b6f9608201e1d77" translate="yes" xml:space="preserve">
          <source>Or select specific elements to include:</source>
          <target state="translated">또는 포함 할 특정 요소를 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="91f70ad6cdb41e4acfd7bf765e82bbdee8fa8d5e" translate="yes" xml:space="preserve">
          <source>Or stack them horizontally with &lt;code&gt;hstack&lt;/code&gt;:</source>
          <target state="translated">또는 &lt;code&gt;hstack&lt;/code&gt; 을 사용 하여 수평으로 쌓으십시오 .</target>
        </trans-unit>
        <trans-unit id="56c3ddf3aab6700d937d53be3d5b45771f361386" translate="yes" xml:space="preserve">
          <source>Or wish to add a constant to all negative elements:</source>
          <target state="translated">또는 모든 부정적인 요소에 상수를 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="9ed306dae12d1d39fff858942862ae59bbc4399d" translate="yes" xml:space="preserve">
          <source>Or without &lt;code&gt;np.ix_&lt;/code&gt; (compare the integer array examples):</source>
          <target state="translated">또는 &lt;code&gt;np.ix_&lt;/code&gt; 없이 (정수 배열 예제 비교) :</target>
        </trans-unit>
        <trans-unit id="05b188193e465d376dab17b5c2f6bf78bee37c0c" translate="yes" xml:space="preserve">
          <source>Or you can open the file any time with a text editor!</source>
          <target state="translated">또는 텍스트 편집기로 언제든지 파일을 열 수 있습니다!</target>
        </trans-unit>
        <trans-unit id="b97c15fab9ba4d55adcaf397914137e45e790605" translate="yes" xml:space="preserve">
          <source>Or you can select elements that satisfy two conditions using the &lt;code&gt;&amp;amp;&lt;/code&gt; and &lt;code&gt;|&lt;/code&gt; operators:</source>
          <target state="translated">또는 &lt;code&gt;&amp;amp;&lt;/code&gt; 및 &lt;code&gt;|&lt;/code&gt; 를 사용하여 두 가지 조건을 충족하는 요소를 선택할 수 있습니다. 연산자 :</target>
        </trans-unit>
        <trans-unit id="522e527e2f2a0e03657e01d30970c004e213dc85" translate="yes" xml:space="preserve">
          <source>Or, for a column vector, you can insert an axis along the second dimension:</source>
          <target state="translated">또는 열 벡터의 경우 두 번째 차원을 따라 축을 삽입 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb0c3124f81c1d85f2179239c9449534ba1cd1e5" translate="yes" xml:space="preserve">
          <source>Or, if you start with these arrays:</source>
          <target state="translated">또는 다음 배열로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="00fcdda14949d42c1610edfba9ca80d41d59564f" translate="yes" xml:space="preserve">
          <source>Or:</source>
          <target state="translated">Or:</target>
        </trans-unit>
        <trans-unit id="57f93044bc0a408687e6b01e33395f89ff4d70a4" translate="yes" xml:space="preserve">
          <source>Order of differentiation (default: 1)</source>
          <target state="translated">차별화 순서 (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="788c2fe754b6f79f4fc9b0b665993b8ce7234c19" translate="yes" xml:space="preserve">
          <source>Order of integration, must be positive. (Default: 1)</source>
          <target state="translated">통합 순서는 양수 여야합니다. (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="a5353df5e917b478408b634f2bf535553074c600" translate="yes" xml:space="preserve">
          <source>Order of operations optimization in &lt;code&gt;np.einsum&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.einsum&lt;/code&gt; 의 작업 최적화 순서</target>
        </trans-unit>
        <trans-unit id="41ad4bbf3f62befe7c196979bd8380406f97a913" translate="yes" xml:space="preserve">
          <source>Order of the antiderivative. (Default: 1)</source>
          <target state="translated">해독제 순서. (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="c2ecce42b9cac400a1b6d5085507c247c9b755ae" translate="yes" xml:space="preserve">
          <source>Order of the data for multidimensional arrays: C, Fortran, or the same as for the original array.</source>
          <target state="translated">다차원 배열의 데이터 순서 : C, Fortran 또는 원래 배열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1c001b919a2f52d0fbb20d49a83e3f37a24b3cfa" translate="yes" xml:space="preserve">
          <source>Order of the data item in the copy. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">사본에서 데이터 항목의 순서입니다. 기본값은 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="f847d5dac01910a77c77edf954ad824a1e14efe8" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;a href=&quot;../constants#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt; object. The default is None.</source>
          <target state="translated">규범의 순서 ( &lt;code&gt;Notes&lt;/code&gt; 아래 표 참조 ). inf는 numpy의 &lt;a href=&quot;../constants#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt; 객체를 의미 합니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="46f142fafd57c235130d4ec687878d429370c853" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object.</source>
          <target state="translated">규범의 순서 ( &lt;code&gt;Notes&lt;/code&gt; 표 참조 ). inf는 numpy의 &lt;code&gt;inf&lt;/code&gt; 객체를 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="b66f9f860fc227b1d5431e30c1b51053269954ff" translate="yes" xml:space="preserve">
          <source>Order of the norm (see table under &lt;code&gt;Notes&lt;/code&gt;). inf means numpy&amp;rsquo;s &lt;code&gt;inf&lt;/code&gt; object. The default is None.</source>
          <target state="translated">규범의 순서 ( &lt;code&gt;Notes&lt;/code&gt; 아래 표 참조 ). inf는 numpy의 &lt;code&gt;inf&lt;/code&gt; 객체를 의미 합니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="accc210a4b093569ae3685cc2f2612720dea8f1e" translate="yes" xml:space="preserve">
          <source>Order of the norm:</source>
          <target state="translated">규범의 순서 :</target>
        </trans-unit>
        <trans-unit id="b8a7abb1120bc925fdb57310f93f2fa464fdc7ae" translate="yes" xml:space="preserve">
          <source>Order of the powers of the columns. If True, the powers increase from left to right, if False (the default) they are reversed.</source>
          <target state="translated">열의 힘의 순서. True이면 거듭 제곱이 왼쪽에서 오른쪽으로 증가하고 False (기본값)이면 거꾸로됩니다.</target>
        </trans-unit>
        <trans-unit id="9ad696b93bae4cfca8937f28f2148899d7322e0a" translate="yes" xml:space="preserve">
          <source>Order statistics</source>
          <target state="translated">주문 통계</target>
        </trans-unit>
        <trans-unit id="422e3f686c9f8818631b86e59adef2a48327ba9b" translate="yes" xml:space="preserve">
          <source>Ordered list of field names, or &lt;code&gt;None&lt;/code&gt; if there are no fields.</source>
          <target state="translated">정렬 된 필드 이름 목록 또는 필드가없는 경우 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3ed86c1334d74f0ae883f47feef902d83b9d8c6" translate="yes" xml:space="preserve">
          <source>Ordering</source>
          <target state="translated">Ordering</target>
        </trans-unit>
        <trans-unit id="d1225815854e81b81f3a0215f90f105cc1022337" translate="yes" xml:space="preserve">
          <source>Ordinarly, vector operands must all be the same size, because NumPy works element by element &amp;ndash; for instance, &lt;code&gt;c = a * b&lt;/code&gt; is</source>
          <target state="translated">일반적으로 벡터 피연산자는 모두 동일한 크기 여야합니다. NumPy는 요소별로 작동하기 때문입니다. 예를 들어 &lt;code&gt;c = a * b&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="8d44d98096c18e71b1176f355d8b6f0c7c16e1d1" translate="yes" xml:space="preserve">
          <source>Ordinary inner product for vectors:</source>
          <target state="translated">벡터의 일반적인 내부 제품 :</target>
        </trans-unit>
        <trans-unit id="191b600520d98586a88c24fcdd4e2889be08fced" translate="yes" xml:space="preserve">
          <source>Ordinary inner product of vectors for 1-D arrays (without complex conjugation), in higher dimensions a sum product over the last axes.</source>
          <target state="translated">1 차원 배열에 대한 벡터의 일반적인 내부 곱 (복잡한 컨쥬 게이션없이), 더 높은 차원에서 마지막 축에 대한 합계 곱.</target>
        </trans-unit>
        <trans-unit id="eb7dc7265e25691a9373e1ca80276306cb88c7ca" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values.</source>
          <target state="translated">정규 또는&amp;ldquo;종속 변수&amp;rdquo;값.</target>
        </trans-unit>
        <trans-unit id="8c7ff7749bfea5af2d2c09b7c86b2dbdfee56f2a" translate="yes" xml:space="preserve">
          <source>Ordinate or &amp;ldquo;dependent variable&amp;rdquo; values. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the least-squares solution is calculated for each of the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">정규 또는&amp;ldquo;종속 변수&amp;rdquo;값. 경우 &lt;code&gt;b&lt;/code&gt; 2 차원, 최소 제곱 솔루션은 각각 산출 &lt;code&gt;K&lt;/code&gt; 에서 의 열 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bedfebf0ecf8e3c63711ee41881ab8ce7f77971c" translate="yes" xml:space="preserve">
          <source>Original Source</source>
          <target state="translated">원본 출처</target>
        </trans-unit>
        <trans-unit id="92bff9048309d096b7578598a0790ad0978b76db" translate="yes" xml:space="preserve">
          <source>Original Source of the Generator and BitGenerators</source>
          <target state="translated">Generator 및 BitGenerator의 원본 소스</target>
        </trans-unit>
        <trans-unit id="2f05a12c3fefa36c0646baab0998b9e0baf27dee" translate="yes" xml:space="preserve">
          <source>Original author: Robert Cimrman</source>
          <target state="translated">원저자 : Robert Cimrman</target>
        </trans-unit>
        <trans-unit id="01d77937700b7f6304cd9cc6f6f114b310986845" translate="yes" xml:space="preserve">
          <source>Original positions of the axes to move. These must be unique.</source>
          <target state="translated">이동할 축의 원래 위치. 이들은 고유해야합니다.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="34d7150cfcec917eee04da671286a02a27c1a6b8" translate="yes" xml:space="preserve">
          <source>Other (void * &amp;ndash; each item is a fixed-size chunk of memory)</source>
          <target state="translated">기타 (void * &amp;ndash; 각 항목은 고정 크기의 메모리 청크)</target>
        </trans-unit>
        <trans-unit id="16863278e548d66fae935c08b81b275cea6f9914" translate="yes" xml:space="preserve">
          <source>Other C-Structures</source>
          <target state="translated">다른 C- 구조</target>
        </trans-unit>
        <trans-unit id="c5164a0d79a937ac6a201b20d3ffe5ea4af04bc1" translate="yes" xml:space="preserve">
          <source>Other Common Types: bool</source>
          <target state="translated">다른 일반적인 유형 : bool</target>
        </trans-unit>
        <trans-unit id="9a529214aef07d296fc3d4d086152694a3e98921" translate="yes" xml:space="preserve">
          <source>Other Common Types: complex</source>
          <target state="translated">다른 일반적인 유형 : complex</target>
        </trans-unit>
        <trans-unit id="708bf6f62e354ff314651598e7eebc62fd8d2bb2" translate="yes" xml:space="preserve">
          <source>Other Parameters</source>
          <target state="translated">기타 매개 변수</target>
        </trans-unit>
        <trans-unit id="0faa321ae463cf423d057b0fb19c09b0142f3c2a" translate="yes" xml:space="preserve">
          <source>Other Parameters:</source>
          <target state="translated">다른 매개 변수 :</target>
        </trans-unit>
        <trans-unit id="3a704886f69c3b776903fa1eae3b74661fb05227" translate="yes" xml:space="preserve">
          <source>Other Polynomial Constructors</source>
          <target state="translated">다른 다항식 생성자</target>
        </trans-unit>
        <trans-unit id="407cab4f45e3f1e45a4d3d8364006412c6cfc5cd" translate="yes" xml:space="preserve">
          <source>Other Situations</source>
          <target state="translated">다른 상황</target>
        </trans-unit>
        <trans-unit id="ae276ac9fe79a4b2444ced92d93c1c04bd2cde2e" translate="yes" xml:space="preserve">
          <source>Other aliases</source>
          <target state="translated">기타 별칭</target>
        </trans-unit>
        <trans-unit id="d042bb243a9d93f7d217c6e5a0c1a49c971c43e7" translate="yes" xml:space="preserve">
          <source>Other attributes</source>
          <target state="translated">다른 속성들</target>
        </trans-unit>
        <trans-unit id="e84477e1de2ec14b541d8664b31b8881de493393" translate="yes" xml:space="preserve">
          <source>Other axes remain in their original order.</source>
          <target state="translated">다른 축은 원래 순서대로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="94a56f444dca5dd30ab9a1fe9100b3b01d86f467" translate="yes" xml:space="preserve">
          <source>Other build options</source>
          <target state="translated">기타 빌드 옵션</target>
        </trans-unit>
        <trans-unit id="767a6c3afafd0ae34a74385fb566d6175cb96b17" translate="yes" xml:space="preserve">
          <source>Other constants</source>
          <target state="translated">다른 상수</target>
        </trans-unit>
        <trans-unit id="ed4b1121b10e2ed9c2b0a79e79f85e8ad19d33ae" translate="yes" xml:space="preserve">
          <source>Other conversions</source>
          <target state="translated">다른 전환</target>
        </trans-unit>
        <trans-unit id="b0c0a3787c5b36b4fe5b178d91a655c6a5cbdf6b" translate="yes" xml:space="preserve">
          <source>Other files</source>
          <target state="translated">다른 파일들</target>
        </trans-unit>
        <trans-unit id="e12e322f5b694198963cd183428de579cc666876" translate="yes" xml:space="preserve">
          <source>Other functions</source>
          <target state="translated">다른 기능들</target>
        </trans-unit>
        <trans-unit id="1cddb5c0e17d84098d16d9325f9cc36b4d8d05b6" translate="yes" xml:space="preserve">
          <source>Other indexing options</source>
          <target state="translated">기타 인덱싱 옵션</target>
        </trans-unit>
        <trans-unit id="e0b002f2786124a662470fe9d1d4b2061560ed34" translate="yes" xml:space="preserve">
          <source>Other keys that can be used to set a group of types at once are:</source>
          <target state="translated">한 번에 유형 그룹을 설정하는 데 사용할 수있는 다른 키는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="04009c322c38e522287cb7657248010dcf883c3a" translate="yes" xml:space="preserve">
          <source>Other methods of running tests</source>
          <target state="translated">테스트를 실행하는 다른 방법</target>
        </trans-unit>
        <trans-unit id="ee6b0460067623519cc565a472bd480c100039cf" translate="yes" xml:space="preserve">
          <source>Other modules</source>
          <target state="translated">다른 모듈</target>
        </trans-unit>
        <trans-unit id="486d94e1070b48b0053b9b70f1f9be9f4d9d5bf1" translate="yes" xml:space="preserve">
          <source>Other new functions</source>
          <target state="translated">기타 새로운 기능</target>
        </trans-unit>
        <trans-unit id="599ffbd6e95e9102a19874cfc765e0666e6a5f25" translate="yes" xml:space="preserve">
          <source>Other options:</source>
          <target state="translated">다른 옵션:</target>
        </trans-unit>
        <trans-unit id="a99a2c4e58511e531864aed996a281648e9837a1" translate="yes" xml:space="preserve">
          <source>Other points to keep in mind</source>
          <target state="translated">명심해야 할 기타 사항</target>
        </trans-unit>
        <trans-unit id="312a81da2e8af18ed2deb2ba9e65ed60e75f7dbe" translate="yes" xml:space="preserve">
          <source>Other related special value functions:</source>
          <target state="translated">기타 관련 특수 값 기능 :</target>
        </trans-unit>
        <trans-unit id="b56243f47f05b7964d5f4fc1a7a1d5dc330f1664" translate="yes" xml:space="preserve">
          <source>Other special functions</source>
          <target state="translated">다른 특수 기능</target>
        </trans-unit>
        <trans-unit id="9cc692beb493cdd7b095a31706521fdb297cd3ab" translate="yes" xml:space="preserve">
          <source>Other statements:</source>
          <target state="translated">기타 진술 :</target>
        </trans-unit>
        <trans-unit id="0b28f6f004c86b1b4979a17c950470ea4d696d78" translate="yes" xml:space="preserve">
          <source>Other than the view syntax, the function is immediately readable to a Python programmer. Static typing of the variable &lt;code&gt;i&lt;/code&gt; is implicit. Instead of the view syntax, we could also have used Cython&amp;rsquo;s special NumPy array syntax, but the view syntax is preferred.</source>
          <target state="translated">보기 구문을 제외하고이 함수는 Python 프로그래머가 즉시 읽을 수 있습니다. 변수 &lt;code&gt;i&lt;/code&gt; 의 정적 유형 은 암시 적입니다. 뷰 구문 대신 Cython의 특수 NumPy 배열 구문을 사용할 수도 있지만 뷰 구문이 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="8c5befcc2e0951ae7c577c186d5015110ab50c93" translate="yes" xml:space="preserve">
          <source>Other types</source>
          <target state="translated">다른 유형</target>
        </trans-unit>
        <trans-unit id="db156a16585b32767d434efac29632f353ee893f" translate="yes" xml:space="preserve">
          <source>Other useful flags that can be OR&amp;rsquo;d as additional requirements are:</source>
          <target state="translated">추가 요구 사항으로 OR 될 수있는 기타 유용한 플래그는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d80ae13d27005970d36a64205ad27c701906310c" translate="yes" xml:space="preserve">
          <source>Other useful related constants are</source>
          <target state="translated">다른 유용한 관련 상수는</target>
        </trans-unit>
        <trans-unit id="da626da9b3eb80a71166ddec09244cef236be1ee" translate="yes" xml:space="preserve">
          <source>Other ways to contribute</source>
          <target state="translated">기여하는 다른 방법</target>
        </trans-unit>
        <trans-unit id="b60a0a7b60b2c507b8c7be2f403c23dd728c5542" translate="yes" xml:space="preserve">
          <source>Otherwise F2PY makes a contiguous copy (with a proper dtype) of the input array and passes C pointer of the copy to Fortran subroutine. As a result, any possible changes to the (copy of) input array have no effect to the original argument, as demonstrated below:</source>
          <target state="translated">그렇지 않으면 F2PY는 입력 배열의 연속 복사본 (적절한 dtype 사용)을 만들고 복사본의 C 포인터를 Fortran 서브 루틴에 전달합니다. 결과적으로 (복사본) 입력 배열의 가능한 변경 사항은 아래에 설명 된대로 원래 인수에 영향을주지 않습니다.</target>
        </trans-unit>
        <trans-unit id="01dc3acd71c35a47919d5dc18e67e38bbe2ca711" translate="yes" xml:space="preserve">
          <source>Otherwise we recommend simply learning to reverse the usual order of indices when accessing elements of an array. Granted, it goes against the grain, but it is more in line with Python semantics and the natural order of the data.</source>
          <target state="translated">그렇지 않으면 배열의 요소에 액세스 할 때 일반적인 색인 순서를 바꾸는 방법을 배우는 것이 좋습니다. 물론, 그것은 그레인에 위배되지만 파이썬 의미 및 데이터의 자연스러운 순서에 더 가깝습니다.</target>
        </trans-unit>
        <trans-unit id="29b9f8169fedb0ad1c9be824eca55314fa16d94e" translate="yes" xml:space="preserve">
          <source>Otherwise, &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; is called on each array, and the resulting data types are all combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">그렇지 않으면 각 배열 에서 &lt;a href=&quot;numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; &lt;/a&gt; 이 호출되고 결과 데이터 형식이 모두 &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; 와 결합되어 반환 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="fae9e7a3585b77fe783d86ad593d20c5ecc3f354" translate="yes" xml:space="preserve">
          <source>Otherwise, PyArray_MinScalarType is called on each array, and the resulting data types are all combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">그렇지 않으면 각 배열에서 PyArray_MinScalarType이 호출되고 결과 데이터 형식이 모두 &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; 와 결합되어 반환 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a5347d369bb3cc80acdc3e9eec52dbe20542bf3e" translate="yes" xml:space="preserve">
          <source>Otherwise, only the &lt;code&gt;zip&lt;/code&gt; and &lt;code&gt;pdf&lt;/code&gt; links should be updated with the new tag name:</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;zip&lt;/code&gt; 및 &lt;code&gt;pdf&lt;/code&gt; 링크 만 새 태그 이름으로 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="fcd38ba9fb1f1dbc35dcac58860b6157e6882b67" translate="yes" xml:space="preserve">
          <source>Our &lt;code&gt;MySubClass.__new__&lt;/code&gt; method only gets called in the case of the explicit constructor call, so we can&amp;rsquo;t rely on &lt;code&gt;MySubClass.__new__&lt;/code&gt; or &lt;code&gt;MySubClass.__init__&lt;/code&gt; to deal with the view casting and new-from-template. It turns out that &lt;code&gt;MySubClass.__array_finalize__&lt;/code&gt;&lt;em&gt;does&lt;/em&gt; get called for all three methods of object creation, so this is where our object creation housekeeping usually goes.</source>
          <target state="translated">우리 &lt;code&gt;MySubClass.__new__&lt;/code&gt; 우리가 의지 할 수 있도록 메소드는, 명시 적 생성자 호출의 경우 호출되는 &lt;code&gt;MySubClass.__new__&lt;/code&gt; 또는 &lt;code&gt;MySubClass.__init__&lt;/code&gt; 보기 주조 및 새로운에서 템플릿을 처리 할 수 있습니다. 그것은 밝혀 &lt;code&gt;MySubClass.__array_finalize__&lt;/code&gt; &lt;em&gt;않는&lt;/em&gt; 우리의 객체 생성의 가사는 일반적으로가는 곳이 있으므로, 객체 생성의 세 가지 방법에 대해 전화를받을.</target>
        </trans-unit>
        <trans-unit id="16c471225c8348ecdf3cb9056eeb4166b9df8525" translate="yes" xml:space="preserve">
          <source>Our current rules:</source>
          <target state="translated">우리의 현재 규칙 :</target>
        </trans-unit>
        <trans-unit id="5388893497a63e10962c70e1e04399dd9d5a42e3" translate="yes" xml:space="preserve">
          <source>Our custom array can be instantiated like:</source>
          <target state="translated">사용자 지정 배열은 다음과 같이 인스턴스화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf78b3f6f52a00f298a7bfb0726e5baf2bd452dd" translate="yes" xml:space="preserve">
          <source>Our docstring standard uses &lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;re-structured text (reST)&lt;/a&gt; syntax and is rendered using &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; (a pre-processor that understands the particular documentation style we are using). While a rich set of markup is available, we limit ourselves to a very basic subset, in order to provide docstrings that are easy to read on text-only terminals.</source>
          <target state="translated">&lt;a href=&quot;http://docutils.sourceforge.net/rst.html&quot;&gt;독 스트링&lt;/a&gt; 표준은 reST (re-structured text) 구문을 사용하며 &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; (우리가 사용하는 특정 문서 스타일을 이해하는 전 처리기)를 사용하여 렌더링됩니다 . 다양한 마크 업 세트를 사용할 수 있지만 텍스트 전용 터미널에서 읽기 쉬운 독 스트링을 제공하기 위해 매우 기본적인 하위 집합으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="699b767a44afe4a72b5254c097705dfd2fc0c0eb" translate="yes" xml:space="preserve">
          <source>Our final example is a ufunc with multiple arguments. It is a modification of the code for a logit ufunc for data with a single dtype. We compute (A*B, logit(A*B)).</source>
          <target state="translated">마지막 예는 여러 인수가있는 ufunc입니다. 단일 dtype을 가진 데이터에 대한 logit ufunc의 코드를 수정 한 것입니다. (A * B, logit (A * B))를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cd99f75ef9c59f37909a92800122629525cfc030" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="translated">우리의 목표는 NumPy의 모든 모듈과 패키지가 철저한 단위 테스트 세트를 가져야한다는 것입니다. 이러한 테스트는 주어진 루틴의 전체 기능과 오류가 있거나 예상치 못한 입력 인수에 대한 견고성을 발휘해야합니다. 오랜 경험에 따르면 테스트를 작성하는 가장 좋은시기는 코드를 작성하거나 변경하기 전 입니다. 이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;테스트 중심 개발&lt;/a&gt; 입니다. 이에 대한 주장은 다소 추상적으로 들릴 수 있지만 먼저 테스트를 작성하면 더 강력하고 더 나은 디자인의 코드로 이어진다는 것을 확신 할 수 있습니다. 커버리지가 좋은 잘 설계된 테스트는 리팩토링의 용이성에 큰 차이를 만듭니다. 루틴에서 새 버그가 발견 될 때마다 해당 특정 사례에 대한 새 테스트를 작성하고 테스트 스위트에 추가하여 해당 버그가 눈에 띄지 않게 돌아 오는 것을 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="e4eb13334b28d2a094a12f8ab9ba2e910911e99a" translate="yes" xml:space="preserve">
          <source>Our goal is that every module and package in SciPy and NumPy should have a thorough set of unit tests. These tests should exercise the full functionality of a given routine as well as its robustness to erroneous or unexpected input arguments. Long experience has shown that by far the best time to write the tests is before you write or change the code - this is &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;test-driven development&lt;/a&gt;. The arguments for this can sound rather abstract, but we can assure you that you will find that writing the tests first leads to more robust and better designed code. Well-designed tests with good coverage make an enormous difference to the ease of refactoring. Whenever a new bug is found in a routine, you should write a new test for that specific case and add it to the test suite to prevent that bug from creeping back in unnoticed.</source>
          <target state="translated">우리의 목표는 SciPy와 NumPy의 모든 모듈과 패키지는 철저한 단위 테스트를 가져야한다는 것입니다. 이러한 테스트는 주어진 루틴의 모든 기능뿐만 아니라 잘못되었거나 예상치 못한 입력 인수에 대한 견고성을 발휘해야합니다. 오랜 경험에 따르면 테스트를 작성하기에 가장 좋은 시간은 코드를 작성하거나 변경하기 전입니다. 이것은 &lt;a href=&quot;https://en.wikipedia.org/wiki/Test-driven_development&quot;&gt;테스트 중심 개발입니다.&lt;/a&gt;. 이것에 대한 주장은 다소 추상적 인 것처럼 들릴 수 있지만 테스트를 먼저 작성하면 더 강력하고 더 나은 코드를 디자인 할 수 있습니다. 커버리지가 좋은 잘 설계된 테스트는 리팩토링의 용이성에 엄청난 차이를 만듭니다. 루틴에서 새 버그가 발견 될 때마다 해당 사례에 대한 새 테스트를 작성하고 테스트 스위트에 추가하여 해당 버그가 눈에 띄지 않게 다시 크롤되지 않도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="d68e5db67be9b03d20fd91c37de52993f3c9d547" translate="yes" xml:space="preserve">
          <source>Our main means of communication are:</source>
          <target state="translated">당사의 주요 의사 소통 수단은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2469d2ebc8c77151c167772e7a4f4b5ae56c779b" translate="yes" xml:space="preserve">
          <source>Our markup language is reStructuredText (rST), which is more elaborate than Markdown. Sphinx, the tool many Python projects use to build and link project documentation, converts the rST into HTML and other formats. For more on rST, see the &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;Quick reStructuredText Guide&lt;/a&gt; or the &lt;a href=&quot;https://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText Primer&lt;/a&gt;</source>
          <target state="translated">마크 업 언어는 reStructuredText (rST)로 Markdown보다 더 정교합니다. 많은 Python 프로젝트에서 프로젝트 문서를 빌드하고 연결하는 데 사용하는 도구 인 Sphinx는 rST를 HTML 및 기타 형식으로 변환합니다. rST에 대한 자세한 내용은 &lt;a href=&quot;https://docutils.sourceforge.io/docs/user/rst/quickref.html&quot;&gt;빠른 reStructuredText 가이드&lt;/a&gt; 또는 &lt;a href=&quot;https://www.sphinx-doc.org/en/stable/usage/restructuredtext/basics.html&quot;&gt;reStructuredText 입문서를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="092ac50b2f1d2b5a2fd5de4d521d3e71263ef97d" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="translated">우리 자신의 &lt;a href=&quot;http://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git 기반&lt;/a&gt; 은 &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git 비유를&lt;/a&gt; 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="09929ef69018d98fc6ab68200819ee812816f740" translate="yes" xml:space="preserve">
          <source>Our own &lt;a href=&quot;https://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git foundation&lt;/a&gt; expands on the &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git parable&lt;/a&gt;.</source>
          <target state="translated">우리 자신의 &lt;a href=&quot;https://matthew-brett.github.com/pydagogue/foundation.html&quot;&gt;git 기반&lt;/a&gt; 은 &lt;a href=&quot;http://tom.preston-werner.com/2009/05/19/the-git-parable.html&quot;&gt;git 비유를&lt;/a&gt; 확장합니다 .</target>
        </trans-unit>
        <trans-unit id="154d74419b6aca893341269b8ba48a9e26a16006" translate="yes" xml:space="preserve">
          <source>Out has the same shape as &lt;code&gt;x&lt;/code&gt;. Its real part is in &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; (&lt;code&gt;arctan(+/-inf)&lt;/code&gt; returns &lt;code&gt;+/-pi/2&lt;/code&gt;). This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">Out은 &lt;code&gt;x&lt;/code&gt; 와 모양이 같습니다 . 실제 부분은 &lt;code&gt;[-pi/2, pi/2]&lt;/code&gt; ( &lt;code&gt;arctan(+/-inf)&lt;/code&gt; 는 &lt;code&gt;+/-pi/2&lt;/code&gt; 를 반환합니다 ). &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="851f8da769fc08fe920a7a332149d07bd3e21638" translate="yes" xml:space="preserve">
          <source>Out of the box, &lt;code&gt;numpy.i&lt;/code&gt; provides typemaps that support conversion between NumPy arrays and C arrays:</source>
          <target state="translated">상자 중, &lt;code&gt;numpy.i&lt;/code&gt; 는 적인 typemap을 제공하는 NumPy와 배열 및 C 배열 사이 지원 변환 :</target>
        </trans-unit>
        <trans-unit id="b99f04d1fc495fb457ec6ab4bb045f1b70e94783" translate="yes" xml:space="preserve">
          <source>Outer Product Iteration</source>
          <target state="translated">외부 제품 반복</target>
        </trans-unit>
        <trans-unit id="c6ee0caa49ecd5d48b8b76e247cdb1d691fc307b" translate="yes" xml:space="preserve">
          <source>Outer product, same as &lt;code&gt;outer(x, y)&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;outer(x, y)&lt;/code&gt; 와 같은 외부 제품 :</target>
        </trans-unit>
        <trans-unit id="f31dd41cdb77529134dabee0a5149b6913233527" translate="yes" xml:space="preserve">
          <source>Outer product.</source>
          <target state="translated">외부 제품.</target>
        </trans-unit>
        <trans-unit id="a8eb7f250550fb11f31a150896a2c233c22e5afb" translate="yes" xml:space="preserve">
          <source>Output Arrays</source>
          <target state="translated">출력 배열</target>
        </trans-unit>
        <trans-unit id="69721e85622681a00d5e83b618b8602f51f2805c" translate="yes" xml:space="preserve">
          <source>Output a 3x8000 array:</source>
          <target state="translated">3x8000 배열을 출력합니다 :</target>
        </trans-unit>
        <trans-unit id="7156471f771c478a3049744cdf9adc5be3b74b53" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a, b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="translated">출력 인수. 사용하지 않은 경우 반환되는 정확한 종류가 있어야합니다. 특히, 올바른 유형을 가져야하고 C- 연속적이어야하며 dtype은 &lt;code&gt;dot(a, b)&lt;/code&gt; 대해 반환되는 dtype이어야합니다 . 이것은 성능 기능입니다. 따라서 이러한 조건이 충족되지 않으면 유연성을 시도하는 대신 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="92e70b270c18c83f26e6230a7a984b1fb40cee94" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="translated">출력 인수. 사용되지 않은 경우 반환 될 정확한 종류를 가져야합니다. 특히, 올바른 유형이어야하고 C 연속적이어야하며 dtype은 &lt;code&gt;dot(a,b)&lt;/code&gt; 대해 리턴 될 dtype이어야합니다 . 이것은 성능 기능입니다. 따라서 이러한 조건이 충족되지 않으면 유연성을 유지하는 대신 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6e978531d306139571810dad3cc0f8a44d943b22" translate="yes" xml:space="preserve">
          <source>Output argument. This must have the exact kind that would be returned if it was not used. In particular, it must have the right type, must be C-contiguous, and its dtype must be the dtype that would be returned for &lt;code&gt;ma.dot(a,b)&lt;/code&gt;. This is a performance feature. Therefore, if these conditions are not met, an exception is raised, instead of attempting to be flexible.</source>
          <target state="translated">출력 인수. 사용하지 않은 경우 반환되는 정확한 종류가 있어야합니다. 특히, 올바른 유형을 가져야하고 C- 연속적이어야하며 dtype은 &lt;code&gt;ma.dot(a,b)&lt;/code&gt; 대해 리턴되는 dtype이어야합니다 . 이것은 성능 기능입니다. 따라서 이러한 조건이 충족되지 않으면 유연성을 시도하는 대신 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="a83f71ed49812b1c51736e820cd87f0f9865fcb1" translate="yes" xml:space="preserve">
          <source>Output arguments to ufuncs can be tuples also for ufunc methods</source>
          <target state="translated">ufunc에 대한 출력 인수는 ufunc 메서드의 경우에도 튜플이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85f12acadc64d21e2feac22d1a1b4692fb105ee3" translate="yes" xml:space="preserve">
          <source>Output array</source>
          <target state="translated">출력 배열</target>
        </trans-unit>
        <trans-unit id="f89327ce1837e2c79277b79c5f26d1462b21d4b0" translate="yes" xml:space="preserve">
          <source>Output array for the exponent. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">지수에 대한 출력 배열입니다. &lt;code&gt;x&lt;/code&gt; 와 모양이 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="ce4222d68677642db5d8cd581c2069a152c5cd0e" translate="yes" xml:space="preserve">
          <source>Output array for the mantissa. Must have the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">가수의 출력 배열입니다. &lt;code&gt;x&lt;/code&gt; 와 모양이 같아야 합니다.</target>
        </trans-unit>
        <trans-unit id="d1138d70b1d22742de8a7eec1ca180e5192ab003" translate="yes" xml:space="preserve">
          <source>Output array is same shape and type as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">출력 배열은 &lt;code&gt;x&lt;/code&gt; 와 모양과 유형이 같습니다 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2e976c3ac1b3c4a193e0ef93cc1e51ab4229d440" translate="yes" xml:space="preserve">
          <source>Output array of &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;string_&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;unicode_&lt;/code&gt;&lt;/a&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 와 같은 형태의 입력 유형에 따라 &lt;a href=&quot;../arrays.scalars#numpy.string_&quot;&gt; &lt;code&gt;string_&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;unicode_&lt;/code&gt; &lt;/a&gt; 의 출력 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="9ef051a2e330bee8268ab4c049205eb02d245cc1" translate="yes" xml:space="preserve">
          <source>Output array of &lt;code&gt;string_&lt;/code&gt; or &lt;code&gt;unicode_&lt;/code&gt;, depending on input types of the same shape as &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 와 동일한 모양의 입력 유형에 따라 &lt;code&gt;string_&lt;/code&gt; 또는 &lt;code&gt;unicode_&lt;/code&gt; 의 출력 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="5cd088a12712ab8d4c2c426261156c01f4ed1606" translate="yes" xml:space="preserve">
          <source>Output array of bools</source>
          <target state="translated">부울의 출력 배열</target>
        </trans-unit>
        <trans-unit id="32b7b13439f3e6221fd4780b32449d5d4d7f2b86" translate="yes" xml:space="preserve">
          <source>Output array of bools, or a single bool if x1 and x2 are scalars.</source>
          <target state="translated">부울의 출력 배열 또는 x1과 x2가 스칼라 인 경우 단일 부울입니다.</target>
        </trans-unit>
        <trans-unit id="242b7670831be50eb14727f2ee1d42762f40625b" translate="yes" xml:space="preserve">
          <source>Output array of bools.</source>
          <target state="translated">bool의 출력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="59628506899dd565c36cb8637802ca8d03d5a7e8" translate="yes" xml:space="preserve">
          <source>Output array of indices, of same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 같은 모양의 인덱스 출력 배열 .</target>
        </trans-unit>
        <trans-unit id="5ee5c2cea50e4665a7ae56f4b3614a03fe2437d2" translate="yes" xml:space="preserve">
          <source>Output array of integers</source>
          <target state="translated">정수의 출력 배열</target>
        </trans-unit>
        <trans-unit id="7e2593695a5d88e14bbbac4809c3409ae05309b7" translate="yes" xml:space="preserve">
          <source>Output array of ints.</source>
          <target state="translated">정수의 출력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="52a772b58c524d2ad00244b1064922aec6a445c6" translate="yes" xml:space="preserve">
          <source>Output array of ints. Return -1 on failure.</source>
          <target state="translated">정수의 출력 배열입니다. 실패하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a30063ccd5b6202d238ce61d0b6db2952ded8310" translate="yes" xml:space="preserve">
          <source>Output array of ints. Returns -1 if &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">정수의 출력 배열입니다. &lt;code&gt;sub&lt;/code&gt; 를 찾을 수 없으면 -1을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9735bcc93d569bce2b6e7befd7418f0ba4b716c9" translate="yes" xml:space="preserve">
          <source>Output array of same shape as &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 같은 모양의 출력 배열 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a38bebcd0d7b96b1c608bbee88ef6bc304e314b0" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type</source>
          <target state="translated">입력 유형에 따라 str 또는 유니 코드의 출력 배열</target>
        </trans-unit>
        <trans-unit id="58c2378e8c8946ae97f1ea7dac73a13c10abcd50" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">입력 유형에 따라 str 또는 유니 코드의 출력 배열입니다. 출력 배열에는 입력 요소 당 3 개의 요소가있는 추가 차원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="64d5dcb1c0c304c381fa58f443d7ded824e0bc47" translate="yes" xml:space="preserve">
          <source>Output array of str or unicode, depending on input types</source>
          <target state="translated">입력 유형에 따라 str 또는 유니 코드의 출력 배열</target>
        </trans-unit>
        <trans-unit id="fd13d84379a70df2e078233919d2189882423201" translate="yes" xml:space="preserve">
          <source>Output array of string or unicode, depending on input type. The output array will have an extra dimension with 3 elements per input element.</source>
          <target state="translated">입력 유형에 따라 문자열 또는 유니 코드의 출력 배열입니다. 출력 배열에는 입력 요소 당 3 개의 요소가있는 추가 차원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="f7c9fa3972ed6e6a39e0733beb489d1ce3ad7791" translate="yes" xml:space="preserve">
          <source>Output array which has the same shape as &lt;code&gt;a&lt;/code&gt;, except along the given axis.</source>
          <target state="translated">지정된 축을 따른 것을 제외하고 &lt;code&gt;a&lt;/code&gt; 와 모양이 같은 출력 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="b3c1a1cbd46397d96a8e1319b9f70d2c4e83a943" translate="yes" xml:space="preserve">
          <source>Output array, containing the indices of the elements of &lt;code&gt;a.ravel()&lt;/code&gt; that are non-zero.</source>
          <target state="translated">0이 아닌 &lt;code&gt;a.ravel()&lt;/code&gt; 요소의 인덱스를 포함하는 출력 배열 입니다.</target>
        </trans-unit>
        <trans-unit id="307c943561bf0b8b5ee1a6f51fb083d57904faed" translate="yes" xml:space="preserve">
          <source>Output array, element-wise comparison of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. Typically of type bool, unless &lt;code&gt;dtype=object&lt;/code&gt; is passed. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">출력 배열의 요소 와이즈 비교 &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; . &lt;code&gt;dtype=object&lt;/code&gt; 가 전달 되지 않는 한 일반적으로 bool 유형 입니다. &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="2e21fc9917d319d6359f007add3068ca89130f62" translate="yes" xml:space="preserve">
          <source>Output array, element-wise exponential of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 요소 별 지수 출력 배열 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="16e86016f9dd58438b33f8fa3832e0a84ce8bad6" translate="yes" xml:space="preserve">
          <source>Output array, or reference to &lt;code&gt;out&lt;/code&gt; if that was supplied. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">출력 어레이 또는 기준 &lt;code&gt;out&lt;/code&gt; 그 공급 된 경우. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="1c4ffa82eda162fa8929d170e0a0f647fbc47d46" translate="yes" xml:space="preserve">
          <source>Output array, with the same shape as &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">동일한 형상과 출력 어레이 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6c7fe807ab5dc7a002fea6ec306d2d20dd6cd310" translate="yes" xml:space="preserve">
          <source>Output array.</source>
          <target state="translated">출력 배열.</target>
        </trans-unit>
        <trans-unit id="bfcf0a026c1c1c3df16d07e5c463c5d22ef8d769" translate="yes" xml:space="preserve">
          <source>Output array. Its type is preserved and it must be of the right shape to hold the output.</source>
          <target state="translated">출력 배열. 그 유형은 유지되며 출력을 유지하기에 적합한 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="21470ea6838153d93bb789847f1e781e9233d56c" translate="yes" xml:space="preserve">
          <source>Output formatting</source>
          <target state="translated">출력 형식</target>
        </trans-unit>
        <trans-unit id="ebe7bf947438344dfee2f421c7f0822ca9d92fa3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a vector of length &lt;code&gt;k&lt;/code&gt; is returned.</source>
          <target state="translated">출력 모양. 주어진 모양이 예를 들어 &lt;code&gt;(m, n)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. 기본값은 None이며,이 경우 길이 &lt;code&gt;k&lt;/code&gt; 의 벡터 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a267ec8ecd4cabb56c1672c1c1515df13c271b4b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn from the 1-d &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than one dimension, the &lt;code&gt;size&lt;/code&gt; shape will be inserted into the &lt;code&gt;axis&lt;/code&gt; dimension, so the output &lt;code&gt;ndim&lt;/code&gt; will be &lt;code&gt;a.ndim - 1 +
len(size)&lt;/code&gt;. Default is None, in which case a single value is returned.</source>
          <target state="translated">출력 형태. 주어진 형상이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면, &lt;code&gt;m * n * k&lt;/code&gt; 샘플은 1-d &lt;code&gt;a&lt;/code&gt; 에서 추출됩니다 . 경우 &lt;code&gt;a&lt;/code&gt; 는 1 차원 이상의 상기 &lt;code&gt;size&lt;/code&gt; 형상이 삽입 될 &lt;code&gt;axis&lt;/code&gt; 출력되도록 치수 &lt;code&gt;ndim&lt;/code&gt; 는 것이다 &lt;code&gt;a.ndim - 1 + len(size)&lt;/code&gt; . 기본값은 없음이며,이 경우 단일 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2424a491af135ae36f950b7ab0516bd18ace8df" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. Default is None, in which case a single value is returned.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. 기본값은 없음이며,이 경우 단일 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="89e56aa13faf2ac19ffb0b3e5e716f7bfddc1ab9" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(a, b).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="55b478ddcb62162e8ce07219dee1d9d6ca7a8be6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;a&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(a).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;a&lt;/code&gt; 가 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.array(a).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="bad13c9c05fba2155bd76b001de567b59798e200" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; and &lt;code&gt;nonc&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;df&lt;/code&gt; 와 &lt;code&gt;nonc&lt;/code&gt; 가 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(df, nonc).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="738b6886d61591bdc17ae069de249790d6b71087" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;df&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(df).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;df&lt;/code&gt; 가 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.array(df).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="ae475a1d95fefab6fd2f2bedb6223f991fcc41b6" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt; and &lt;code&gt;dfden&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;dfnum&lt;/code&gt; 과 &lt;code&gt;dfden&lt;/code&gt; 이 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(dfnum, dfden).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="46a9903f305b04fd0f7d5079b4658c01625926e1" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;dfnum&lt;/code&gt;, &lt;code&gt;dfden&lt;/code&gt;, and &lt;code&gt;nonc&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 &lt;code&gt;dfnum&lt;/code&gt; , &lt;code&gt;dfden&lt;/code&gt; 및 &lt;code&gt;nonc&lt;/code&gt; 가 모두 스칼라 이면 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(dfnum, dfden, nonc).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="cf9a357ee338f25bf2bcb1c6a39d7e36ff751b6d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;lam&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(lam).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;lam&lt;/code&gt; 이 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.array(lam).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="6bfc36fdff77cbd952a127d76db752bf9585b331" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;left&lt;/code&gt;, &lt;code&gt;mode&lt;/code&gt;, and &lt;code&gt;right&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 &lt;code&gt;left&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; 및 &lt;code&gt;right&lt;/code&gt; 가 모두 스칼라 이면 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(left, mode, right).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="221f43b3f6b78ea4ffc570a2b4686a11e53b9689" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;loc&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;loc&lt;/code&gt; 과 &lt;code&gt;scale&lt;/code&gt; 이 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(loc, scale).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="4282c4067b87ca3f0f86b5fc7e0e58c780e280c3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;low&lt;/code&gt; 와 &lt;code&gt;high&lt;/code&gt; 가 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(low, high).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="d0683da40c0442ae9f7198c7d720ea85a5de1b4d" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;mean&lt;/code&gt; 과 &lt;code&gt;scale&lt;/code&gt; 이 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(mean, scale).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="0de49618d9158d1b17813c0b098c763f862b1d88" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mean&lt;/code&gt; and &lt;code&gt;sigma&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;mean&lt;/code&gt; 과 &lt;code&gt;sigma&lt;/code&gt; 가 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(mean, sigma).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="4e92a7af3b2b74719c734b754039059712af838b" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;mu&lt;/code&gt; and &lt;code&gt;kappa&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;mu&lt;/code&gt; 와 &lt;code&gt;kappa&lt;/code&gt; 가 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(mu, kappa).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="508329c1fbd22ad6be84a6836708268204490867" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;p&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;n&lt;/code&gt; 과 &lt;code&gt;p&lt;/code&gt; 가 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(n, p).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="b122820c89df713b07cfbc58626294123f0af0a3" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;ngood&lt;/code&gt;, &lt;code&gt;nbad&lt;/code&gt;, and &lt;code&gt;nsample&lt;/code&gt; are all scalars. Otherwise, &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;ngood&lt;/code&gt; , &lt;code&gt;nbad&lt;/code&gt; 및 &lt;code&gt;nsample&lt;/code&gt; 이 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(ngood, nbad, nsample).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="27d2ec43f10ca379398aac021ba6a41147bbbdc4" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;p&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(p).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;p&lt;/code&gt; 가 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.array(p).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="df56295e78bed4d72315ff68acac7d0f9dadfb30" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;scale&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값) 인 경우 &lt;code&gt;scale&lt;/code&gt; 이 스칼라 이면 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.array(scale).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="948b72efe91fbed7c1a9b81472148fc726a10ddb" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; and &lt;code&gt;scale&lt;/code&gt; are both scalars. Otherwise, &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;shape&lt;/code&gt; 와 &lt;code&gt;scale&lt;/code&gt; 이 모두 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.broadcast(shape, scale).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="eb5df5a3ebce059571acee730f004ee96866a67f" translate="yes" xml:space="preserve">
          <source>Output shape. If the given shape is, e.g., &lt;code&gt;(m, n, k)&lt;/code&gt;, then &lt;code&gt;m * n * k&lt;/code&gt; samples are drawn. If size is &lt;code&gt;None&lt;/code&gt; (default), a single value is returned if &lt;code&gt;shape&lt;/code&gt; is a scalar. Otherwise, &lt;code&gt;np.array(shape).size&lt;/code&gt; samples are drawn.</source>
          <target state="translated">출력 형태. 주어진 모양이 예를 들어 &lt;code&gt;(m, n, k)&lt;/code&gt; 이면 &lt;code&gt;m * n * k&lt;/code&gt; 샘플이 그려집니다. size가 &lt;code&gt;None&lt;/code&gt; (기본값)이면 &lt;code&gt;shape&lt;/code&gt; 가 스칼라 인 경우 단일 값이 반환됩니다 . 그렇지 않으면 &lt;code&gt;np.array(shape).size&lt;/code&gt; 샘플이 그려집니다.</target>
        </trans-unit>
        <trans-unit id="93434be0fa874141cd4c8b5151bed934649c82c6" translate="yes" xml:space="preserve">
          <source>Output to existing array instead of creating new one, must have same shape as expected output</source>
          <target state="translated">새로운 배열을 생성하는 대신 기존 배열로 출력 할 때 예상되는 출력과 모양이 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="84eedc132f8f3afc97e2735311f70af181b638d1" translate="yes" xml:space="preserve">
          <source>Output type determination</source>
          <target state="translated">출력 유형 결정</target>
        </trans-unit>
        <trans-unit id="25c6817215cc63aae8850c0698a2094523318f20" translate="yes" xml:space="preserve">
          <source>Output values. Used for performance testing since the generated values are not returned.</source>
          <target state="translated">출력값. 생성 된 값이 리턴되지 않으므로 성능 테스트에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="645e7318aeb0e81470723bb7fa3e333eeb197cd2" translate="yes" xml:space="preserve">
          <source>Output view is of shape &lt;code&gt;(self.size,)&lt;/code&gt; (or &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt;).</source>
          <target state="translated">출력보기의 모양은 &lt;code&gt;(self.size,)&lt;/code&gt; (또는 &lt;code&gt;(np.ma.product(self.shape),)&lt;/code&gt; )입니다.</target>
        </trans-unit>
        <trans-unit id="75eaf4cf3feb6b5ab1173e2bce737a946dc189fe" translate="yes" xml:space="preserve">
          <source>Outputs an array of bools.</source>
          <target state="translated">부울 배열을 출력합니다.</target>
        </trans-unit>
        <trans-unit id="0ba159acbd720278d8203620bd6051e07665bfbd" translate="yes" xml:space="preserve">
          <source>Outside the context the error handling behavior has not changed:</source>
          <target state="translated">컨텍스트 외부에서 오류 처리 동작이 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="8a528519bdaba69c0bdc57fdcdf7b370f2e098f2" translate="yes" xml:space="preserve">
          <source>Overall</source>
          <target state="translated">Overall</target>
        </trans-unit>
        <trans-unit id="3b4b69a29c016e758ecb737d47f6f3d84f5ea925" translate="yes" xml:space="preserve">
          <source>Overall view of discrete Fourier transforms, with definitions and conventions used.</source>
          <target state="translated">정의와 규칙이 사용 된 불연속 푸리에 변환의 전체보기.</target>
        </trans-unit>
        <trans-unit id="bd6510575c0d6b439267f2e4a3758c5ec63354f0" translate="yes" xml:space="preserve">
          <source>Overflow Errors</source>
          <target state="translated">오버플로 오류</target>
        </trans-unit>
        <trans-unit id="0e247da042a068cd8a71502e0fd76c6b94f4ca5d" translate="yes" xml:space="preserve">
          <source>Overflow: result too large to be expressed.</source>
          <target state="translated">오버플로 : 결과가 너무 커서 표현할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2efc34a90711b7a3d99847c32b113347fb82c866" translate="yes" xml:space="preserve">
          <source>Override the default nditer flags for the ufunc.</source>
          <target state="translated">ufunc의 기본 nditer 플래그를 재정의하십시오.</target>
        </trans-unit>
        <trans-unit id="75e6a3ee5dadc59620ad485d88ddab650173edc7" translate="yes" xml:space="preserve">
          <source>Override the default operand flags for each ufunc operand.</source>
          <target state="translated">각 ufunc 피연산자에 대한 기본 피연산자 플래그를 대체하십시오.</target>
        </trans-unit>
        <trans-unit id="c7112a2f014dc699135617be0b1abde474ac316b" translate="yes" xml:space="preserve">
          <source>Overrideable operand flags in ufunc C-API</source>
          <target state="translated">ufunc C-API의 재정의 가능한 피연산자 플래그</target>
        </trans-unit>
        <trans-unit id="d2e2dc0135e076adb3e9a12f5a92b84ec65a0542" translate="yes" xml:space="preserve">
          <source>Overrides the &lt;code&gt;normed&lt;/code&gt; keyword if given.</source>
          <target state="translated">지정된 경우 &lt;code&gt;normed&lt;/code&gt; 키워드를 대체합니다 .</target>
        </trans-unit>
        <trans-unit id="3a7540b1b3a0dda7242487679ca9b11862d3a4ba" translate="yes" xml:space="preserve">
          <source>Overrides the data type of the result.</source>
          <target state="translated">결과의 데이터 유형을 대체합니다.</target>
        </trans-unit>
        <trans-unit id="cb013ea80decaa67cad8a4fef77945440ec27842" translate="yes" xml:space="preserve">
          <source>Overrides the dtype of the calculation and output arrays. Similar to &lt;em&gt;signature&lt;/em&gt;.</source>
          <target state="translated">계산 및 출력 배열의 dtype을 재정의합니다. &lt;em&gt;signature&lt;/em&gt; 와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="7006d2b6fc1325bb6529d58eb36199d98e2b6962" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible.</source>
          <target state="translated">결과의 메모리 레이아웃을 재정의합니다. 'C'는 C 순서를, 'F'는 F 순서를, 'A'는 &lt;code&gt;a&lt;/code&gt; 가 포트란 연속 이면 'F' , 그렇지 않으면 'C'를 의미합니다. 'K'수단의 레이아웃과 일치 &lt;code&gt;a&lt;/code&gt; 가능한 가깝게한다.</target>
        </trans-unit>
        <trans-unit id="ddaf5efe8542a3a691f6af72e37e55e4e33af102" translate="yes" xml:space="preserve">
          <source>Overrides the memory layout of the result. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;prototype&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;prototype&lt;/code&gt; as closely as possible.</source>
          <target state="translated">결과의 메모리 레이아웃을 재정의합니다. 'C'는 C 순서를, 'F'는 F 순서를, 'A'는 &lt;code&gt;prototype&lt;/code&gt; 이 포트란 연속 이면 'F' , 그렇지 않으면 'C'를 의미합니다. 'K'는 &lt;code&gt;prototype&lt;/code&gt; 의 레이아웃을 최대한 가깝게 일치시키는 것을 의미 합니다.</target>
        </trans-unit>
        <trans-unit id="4bd31b5015136a3790d4ea1e4b56f5e23f60c98d" translate="yes" xml:space="preserve">
          <source>Overrides the shape of the result. If order=&amp;rsquo;K&amp;rsquo; and the number of dimensions is unchanged, will try to keep order, otherwise, order=&amp;rsquo;C&amp;rsquo; is implied.</source>
          <target state="translated">결과의 모양을 재정의합니다. order = 'K'이고 치수 수를 변경하지 않으면 order를 유지하려고 시도하고, 그렇지 않으면 order = 'C'가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="3ab7f8eaa264cb0094ba3f9ca231b49fca803e1c" translate="yes" xml:space="preserve">
          <source>Overriding Ufunc behavior</source>
          <target state="translated">Ufunc 동작 재정의</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="4b0a4170e8329f03d8b135ba293e3ad03fce2389" translate="yes" xml:space="preserve">
          <source>Overview of numpy type hierarchy.</source>
          <target state="translated">numpy 유형 계층 구조 개요</target>
        </trans-unit>
        <trans-unit id="043d190b03e4fa8608d62de06341dd2afb4fd385" translate="yes" xml:space="preserve">
          <source>Overview of the numpy type hierarchy.</source>
          <target state="translated">numpy 유형 계층의 개요.</target>
        </trans-unit>
        <trans-unit id="34ec4594b7176e776330d622e2702954b1c3e9ee" translate="yes" xml:space="preserve">
          <source>Overwrite existing signature file.</source>
          <target state="translated">기존 서명 파일을 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="aa00a8efe8f9b81ac75da5a75a43b320bd64395d" translate="yes" xml:space="preserve">
          <source>P. R. Peebles Jr., &amp;ldquo;Central Limit Theorem&amp;rdquo; in &amp;ldquo;Probability, Random Variables and Random Signal Principles&amp;rdquo;, 4th ed., 2001, pp. 51, 51, 125.</source>
          <target state="translated">PR Peebles Jr., &quot;확률, 무작위 변수 및 무작위 신호 원리&quot;의 &quot;중심 한계 정리&quot;, 4 판, 2001, pp. 51, 51, 125.</target>
        </trans-unit>
        <trans-unit id="bb033dba7abb6161a0c83b9f27fd0eb075c43755" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="translated">PCG-64-기본값입니다. 많은 병렬 스트림을 지원하고 임의의 양만큼 전진 할 수있는 빠른 생성기입니다. &lt;a href=&quot;generated/numpy.random.pcg64.advance#numpy.random.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; 대한 문서를 참조하십시오 . PCG-64는</target>
        </trans-unit>
        <trans-unit id="852c68657fb7b98de4c0c80a1fc558db4eb1cb65" translate="yes" xml:space="preserve">
          <source>PCG-64 - The default. A fast generator that supports many parallel streams and can be advanced by an arbitrary amount. See the documentation for &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt;&lt;code&gt;advance&lt;/code&gt;&lt;/a&gt;. PCG-64 has a period of</source>
          <target state="translated">PCG-64-기본값입니다. 많은 병렬 스트림을 지원하고 임의의 양만큼 진행할 수있는 빠른 생성기입니다. &lt;a href=&quot;generated/numpy.random.pcg64.pcg64.advance#numpy.random.pcg64.PCG64.advance&quot;&gt; &lt;code&gt;advance&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오 . PCG-64의 기간은</target>
        </trans-unit>
        <trans-unit id="ec3f94c212b0721b903c3ee685e360e3ef15a646" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r4523891264fe-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r4523891264fe-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="translated">PCG-64는 O'Neill의 순열 합동 생성기 ( &lt;a href=&quot;#r4523891264fe-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;#r4523891264fe-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; ) 의 128 비트 구현입니다 . PCG-64는</target>
        </trans-unit>
        <trans-unit id="7c1cc812d4eb7fa422b89cbdb7060063b9828124" translate="yes" xml:space="preserve">
          <source>PCG-64 is a 128-bit implementation of O&amp;rsquo;Neill&amp;rsquo;s permutation congruential generator (&lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt;). PCG-64 has a period of</source>
          <target state="translated">PCG-64는 O'Neill의 순열 합동 생성기 ( &lt;a href=&quot;#r7c40bac0730f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;#r7c40bac0730f-2&quot; id=&quot;id2&quot;&gt;[2]&lt;/a&gt; ) 의 128 비트 구현입니다 . PCG-64의 기간은</target>
        </trans-unit>
        <trans-unit id="4af2a60ae4795c459c6aaf972e39b31efa85a47c" translate="yes" xml:space="preserve">
          <source>PCG64</source>
          <target state="translated">PCG64</target>
        </trans-unit>
        <trans-unit id="8b80c7ece909214affee51ebe9e335eee960dd93" translate="yes" xml:space="preserve">
          <source>PCG64 (class in numpy.random)</source>
          <target state="translated">PCG64 (numpy.random의 클래스)</target>
        </trans-unit>
        <trans-unit id="5d3f1df54c65ec3141b5ad7708d8f310bb35110f" translate="yes" xml:space="preserve">
          <source>PCG64.advance()</source>
          <target state="translated">PCG64.advance()</target>
        </trans-unit>
        <trans-unit id="f8024fbbc3a3aef5b6b9fb19f286aa8ddd8b1f19" translate="yes" xml:space="preserve">
          <source>PCG64.cffi</source>
          <target state="translated">PCG64.cffi</target>
        </trans-unit>
        <trans-unit id="b27789fa8622c7f5407c0a21c98dc4e2c03c99f5" translate="yes" xml:space="preserve">
          <source>PCG64.ctypes</source>
          <target state="translated">PCG64.ctypes</target>
        </trans-unit>
        <trans-unit id="010490775ec92003581521aea797462d39c6844f" translate="yes" xml:space="preserve">
          <source>PCG64.jumped()</source>
          <target state="translated">PCG64.jumped()</target>
        </trans-unit>
        <trans-unit id="e1d334c49d4a4c7a9578ef9b5cd8b69493afac43" translate="yes" xml:space="preserve">
          <source>PCG64.state</source>
          <target state="translated">PCG64.state</target>
        </trans-unit>
        <trans-unit id="b4ff946c27bb613726f09f76ac9051fb9b0f1727" translate="yes" xml:space="preserve">
          <source>PEP 3141 numeric objects (including builtins)</source>
          <target state="translated">PEP 3141 숫자 객체 (내장 포함)</target>
        </trans-unit>
        <trans-unit id="93b1d16c8417eaf68b67a446e7919aa4647e6c45" translate="yes" xml:space="preserve">
          <source>PINF (in module numpy)</source>
          <target state="translated">PINF (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="728c523d01503026dd65bbe13e4eb1af6cdeb12e" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL</source>
          <target state="translated">PY_ARRAY_UNIQUE_SYMBOL</target>
        </trans-unit>
        <trans-unit id="bf891340ec2a11d1acd9aa49c131d2652c5c5626" translate="yes" xml:space="preserve">
          <source>PY_ARRAY_UNIQUE_SYMBOL (C macro)</source>
          <target state="translated">PY_ARRAY_UNIQUE_SYMBOL (C 매크로)</target>
        </trans-unit>
        <trans-unit id="8adb71a4a1fa67dfff7b23658e29a4c4a31b4cbc" translate="yes" xml:space="preserve">
          <source>PY_UFUNC_UNIQUE_SYMBOL (C variable)</source>
          <target state="translated">PY_UFUNC_UNIQUE_SYMBOL (C 변수)</target>
        </trans-unit>
        <trans-unit id="d61443247e63f7e1c0daa436e40747dc59c5d67e" translate="yes" xml:space="preserve">
          <source>PZERO (in module numpy)</source>
          <target state="translated">PZERO (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="0a6424a476b9cde6f4b3f1412e542dd2b247eca9" translate="yes" xml:space="preserve">
          <source>PZERO : Defines positive zero.</source>
          <target state="translated">PZERO : 양의 0을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="3a39b68c35be609fae3db651a70893a29f102145" translate="yes" xml:space="preserve">
          <source>Packaging</source>
          <target state="translated">Packaging</target>
        </trans-unit>
        <trans-unit id="187a0323079ad9d1ef0a509dbcf41c04c294cb65" translate="yes" xml:space="preserve">
          <source>Packaging (&lt;code&gt;numpy.distutils&lt;/code&gt;)</source>
          <target state="translated">패키징 ( &lt;code&gt;numpy.distutils&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f08e1747044acab6d3f1cde93a671bbd941456b2" translate="yes" xml:space="preserve">
          <source>Packaging (numpy.distutils)</source>
          <target state="translated">패키징 (numpy.distutils)</target>
        </trans-unit>
        <trans-unit id="ed87cf15ee01e886c94b1a38b3e93dd2cc6fc493" translate="yes" xml:space="preserve">
          <source>Packs the elements of a binary-valued array into bits in a uint8 array.</source>
          <target state="translated">이진 값 배열의 요소를 uint8 배열의 비트로 묶습니다.</target>
        </trans-unit>
        <trans-unit id="bd1a1b48e12df64d08abc99d20b4177d10bc8831" translate="yes" xml:space="preserve">
          <source>Pad an array.</source>
          <target state="translated">배열을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="623338c7d8c79f8103d39448c8e5b48ec92bd71f" translate="yes" xml:space="preserve">
          <source>Pad the exponent with zeros until it contains at least this many digits. If omitted, the exponent will be at least 2 digits.</source>
          <target state="translated">적어도이 숫자가 포함될 때까지 지수를 0으로 채 웁니다. 생략하면 지수는 최소 2 자리입니다.</target>
        </trans-unit>
        <trans-unit id="b75a7faadf1505590310ce2efd9e725c23bd6630" translate="yes" xml:space="preserve">
          <source>Pad the left side of the string with whitespace until at least that many characters are to the left of the decimal point.</source>
          <target state="translated">최소한 문자 수가 소수점 왼쪽에 올 때까지 문자열의 왼쪽을 공백으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="5afbc760d761bf736b4d58352656b475cf0c23ca" translate="yes" xml:space="preserve">
          <source>Pad the right side of the string with whitespace until at least that many characters are to the right of the decimal point.</source>
          <target state="translated">최소한 문자 수가 소수점 오른쪽에 올 때까지 문자열의 오른쪽을 공백으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="d76599ff9339cbc70b09ca989f2b38f16c5bb949" translate="yes" xml:space="preserve">
          <source>Padded array of rank equal to &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; with shape increased according to &lt;code&gt;pad_width&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;pad_width&lt;/code&gt; 에 따라 모양이 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 과 동일한 순위의 패딩 배열이 증가 합니다.</target>
        </trans-unit>
        <trans-unit id="ee9a393873e0b61a69dbdfe6eb9af32cf2ca2765" translate="yes" xml:space="preserve">
          <source>Padding Arrays</source>
          <target state="translated">패딩 배열</target>
        </trans-unit>
        <trans-unit id="0e79fa15dcf3528049b2a29ae0606a9732799d3f" translate="yes" xml:space="preserve">
          <source>Padding arrays</source>
          <target state="translated">패딩 배열</target>
        </trans-unit>
        <trans-unit id="7d526b53b9f3056522af85f26a2d434f580eafad" translate="yes" xml:space="preserve">
          <source>Padding function, see Notes.</source>
          <target state="translated">패딩 기능은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ed38b70d664fac1df990b27835f8a3a31c0260f4" translate="yes" xml:space="preserve">
          <source>Pads with a constant value.</source>
          <target state="translated">일정한 값을 가진 패드.</target>
        </trans-unit>
        <trans-unit id="d9f2ac48720b42a9d74674f19c7f64e1c0499c32" translate="yes" xml:space="preserve">
          <source>Pads with the edge values of array.</source>
          <target state="translated">배열의 가장자리 값이있는 패드입니다.</target>
        </trans-unit>
        <trans-unit id="fca51805348b473c846607d0a2857abe02017fd5" translate="yes" xml:space="preserve">
          <source>Pads with the linear ramp between end_value and the array edge value.</source>
          <target state="translated">end_value와 배열 가장자리 값 사이의 선형 램프가있는 패드입니다.</target>
        </trans-unit>
        <trans-unit id="630cd57bb220770a2f515175c115bde03142bb98" translate="yes" xml:space="preserve">
          <source>Pads with the maximum value of all or part of the vector along each axis.</source>
          <target state="translated">각 축을 따라 벡터의 전체 또는 일부의 최대 값을 가진 패드입니다.</target>
        </trans-unit>
        <trans-unit id="d3b2120b9c4caeb3f445da36215883fca44003eb" translate="yes" xml:space="preserve">
          <source>Pads with the mean value of all or part of the vector along each axis.</source>
          <target state="translated">각 축을 따라 벡터의 전부 또는 일부의 평균값을 가진 패드입니다.</target>
        </trans-unit>
        <trans-unit id="65b8c9f7297b280c0b0ee0ea3cb9a6f56b7bac40" translate="yes" xml:space="preserve">
          <source>Pads with the median value of all or part of the vector along each axis.</source>
          <target state="translated">각 축을 따라 벡터의 전체 또는 일부의 중앙값을 가진 패드입니다.</target>
        </trans-unit>
        <trans-unit id="ec1953311c26ffb67e42015bdd267c1393f31365" translate="yes" xml:space="preserve">
          <source>Pads with the minimum value of all or part of the vector along each axis.</source>
          <target state="translated">각 축을 따라 벡터의 전부 또는 일부의 최소값을 가진 패드입니다.</target>
        </trans-unit>
        <trans-unit id="84bf3b9c4e883de4227d55b10846e004bac799fd" translate="yes" xml:space="preserve">
          <source>Pads with the reflection of the vector mirrored along the edge of the array.</source>
          <target state="translated">벡터의 반사가있는 패드는 배열의 가장자리를 따라 대칭됩니다.</target>
        </trans-unit>
        <trans-unit id="4b83447ca8923bd3b3b6c9f855b78e24ddedd519" translate="yes" xml:space="preserve">
          <source>Pads with the reflection of the vector mirrored on the first and last values of the vector along each axis.</source>
          <target state="translated">각 축을 따라 벡터의 첫 번째 값과 마지막 값에 미러링 된 벡터 반사 패드.</target>
        </trans-unit>
        <trans-unit id="ef5d2e46c3cd8911ff34acad9b1fd07efaafaa7f" translate="yes" xml:space="preserve">
          <source>Pads with the wrap of the vector along the axis. The first values are used to pad the end and the end values are used to pad the beginning.</source>
          <target state="translated">축을 따라 벡터를 감싸는 패드. 첫 번째 값은 끝을 채우는 데 사용되고 끝 값은 시작을 채우는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d9b9b2531a80866d4446740404b61350cb894e2" translate="yes" xml:space="preserve">
          <source>Pads with undefined values.</source>
          <target state="translated">값이 정의되지 않은 패드.</target>
        </trans-unit>
        <trans-unit id="30bf8ab0f9434e52331cad6b06732b0029f39c77" translate="yes" xml:space="preserve">
          <source>Paired indices, comma separated (not colon), specifying slices to reduce.</source>
          <target state="translated">쌍을 이루는 인덱스, 쉼표로 구분 (콜론 아님), 축소 할 슬라이스 지정.</target>
        </trans-unit>
        <trans-unit id="a438d0b43daa8f2d136f89cacc82c90b7152dea4" translate="yes" xml:space="preserve">
          <source>Papoulis, A., &amp;ldquo;Probability, Random Variables, and Stochastic Processes,&amp;rdquo; 3rd ed., New York: McGraw-Hill, 1991.</source>
          <target state="translated">Papoulis, A., &quot;확률, 랜덤 변수 및 확률 론적 과정&quot;, 뉴욕, McGraw-Hill, 1991.</target>
        </trans-unit>
        <trans-unit id="b8d6037f133c5f0d5c4523ae33087584f0a1405b" translate="yes" xml:space="preserve">
          <source>Parallel Applications</source>
          <target state="translated">병렬 응용</target>
        </trans-unit>
        <trans-unit id="aac167a2f3e07666230480dee8733fd1d08660a0" translate="yes" xml:space="preserve">
          <source>Parallel Congruent Generator (64-bit, PCG64)</source>
          <target state="translated">병렬 합동 발생기 (64 비트, PCG64)</target>
        </trans-unit>
        <trans-unit id="c11bc78976f584d51e758640f9947c4868085ffb" translate="yes" xml:space="preserve">
          <source>Parallel Generation</source>
          <target state="translated">병렬 생성</target>
        </trans-unit>
        <trans-unit id="28c385ef0bb17bc2f9b3f8a95422e1692d0ab57f" translate="yes" xml:space="preserve">
          <source>Parallel Random Number Generation</source>
          <target state="translated">병렬 난수 생성</target>
        </trans-unit>
        <trans-unit id="a05f67574ff8722f0c85f0dfa090ee3948151417" translate="yes" xml:space="preserve">
          <source>Parallel builds</source>
          <target state="translated">병렬 빌드</target>
        </trans-unit>
        <trans-unit id="9941199a0536bd27f4ba9e0cd3912352ab02906b" translate="yes" xml:space="preserve">
          <source>Parallel generation</source>
          <target state="translated">병렬 생성</target>
        </trans-unit>
        <trans-unit id="e68f24d053a783af78bf2916ad834b59d3272612" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution (k dimension for sample of dimension k).</source>
          <target state="translated">분포 모수 (치수 k의 표본에 대한 k 치수).</target>
        </trans-unit>
        <trans-unit id="5aa3c312bfd3d4206107887488694b91a51af27a" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution (length &lt;code&gt;k&lt;/code&gt; for sample of length &lt;code&gt;k&lt;/code&gt;).</source>
          <target state="translated">분포의 매개 변수 (길이 &lt;code&gt;k&lt;/code&gt; 의 표본에 대한 길이 &lt;code&gt;k&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="70f52333135962fba02933f939303deb96a3ad5b" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt; 0.</source>
          <target state="translated">분포의 모수,&amp;gt; 0.</target>
        </trans-unit>
        <trans-unit id="ea913350c134ad81bd1f5863f2b7b64acafebc1a" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt;= 0 and &amp;lt;=1.</source>
          <target state="translated">분포의 모수,&amp;gt; = 0 및 &amp;lt;= 1.</target>
        </trans-unit>
        <trans-unit id="617d0343737dbfbd0f0f6ec71b30f6e0961d6b3c" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution, &amp;gt;= 0. Floats are also accepted, but they will be truncated to integers.</source>
          <target state="translated">분포의 모수,&amp;gt; = 0. 부동 소수점도 허용되지만 정수로 잘립니다.</target>
        </trans-unit>
        <trans-unit id="41e8c4e61c4d4560f4c6864639517a272c9f4976" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Default is 0.</source>
          <target state="translated">분포의 모수. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="699574a6b4b57fab6065ea4b5f6ef3f03b3ea735" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must be non-negative.</source>
          <target state="translated">분포의 모수. 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="1b9843d14161f83cfaa303eb7a8d9c859f6d9f77" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must be non-negative. Default is 1.</source>
          <target state="translated">분포의 모수. 음수가 아니어야합니다. 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="e42d7698a7fc31da8e47db0ca607a272026fd177" translate="yes" xml:space="preserve">
          <source>Parameter of the distribution. Must satisfy 0 &amp;lt; p &amp;lt;= 1.</source>
          <target state="translated">분포 매개 변수. 0 &amp;lt;p &amp;lt;= 1을 충족해야합니다.</target>
        </trans-unit>
        <trans-unit id="e1c357c2b875b90cada80608cc164df535a0ecfc" translate="yes" xml:space="preserve">
          <source>Parameter, must be non-negative.</source>
          <target state="translated">매개 변수는 음수가 아니어야합니다.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="381c775599d6e4185d4410725809e360928357cd" translate="yes" xml:space="preserve">
          <source>Parameters:</source>
          <target state="translated">Parameters:</target>
        </trans-unit>
        <trans-unit id="9e0892c276c48dd008b5fe6e010bfd8cfb08da04" translate="yes" xml:space="preserve">
          <source>Parametric tests</source>
          <target state="translated">파라 메트릭 테스트</target>
        </trans-unit>
        <trans-unit id="768ae1b1301865b35eda7aa4c4ef56497e1e3a2c" translate="yes" xml:space="preserve">
          <source>Parent name.</source>
          <target state="translated">부모님 성함.</target>
        </trans-unit>
        <trans-unit id="0afd4ac6a1f194c4487e49e8f1f570664d022158" translate="yes" xml:space="preserve">
          <source>Pareto, V. (1896). Course of Political Economy. Lausanne.</source>
          <target state="translated">파레토, V. (1896). 정치 경제 과정. 로잔.</target>
        </trans-unit>
        <trans-unit id="5fa3e0d5937fa68006f8ed4ea820c3f856e05107" translate="yes" xml:space="preserve">
          <source>Parse and compare numpy version strings.</source>
          <target state="translated">numpy 버전 문자열을 구문 분석하고 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="89743befa343f135565af63acf81651d7fa56a28" translate="yes" xml:space="preserve">
          <source>Partial sort.</source>
          <target state="translated">부분 정렬.</target>
        </trans-unit>
        <trans-unit id="c9b347464deed01215a4b73f0c568de4c1b1f29c" translate="yes" xml:space="preserve">
          <source>Partial support for 64-bit f2py extensions with MinGW</source>
          <target state="translated">MinGW로 64 비트 f2py 확장에 대한 부분 지원</target>
        </trans-unit>
        <trans-unit id="cf1f476600e3b441461161e5761f11632e411e50" translate="yes" xml:space="preserve">
          <source>Partition (split) each element around the right-most separator.</source>
          <target state="translated">가장 오른쪽 구분 기호 주위에 각 요소를 분할 (분할)합니다.</target>
        </trans-unit>
        <trans-unit id="8e7a1711564903156f9d326524293916fcf5f95c" translate="yes" xml:space="preserve">
          <source>Partition each element in &lt;code&gt;a&lt;/code&gt; around &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">각 요소 분할 주위의 &lt;code&gt;sep&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8f7f9acaefcb4179a22219e6e4159e78558c3ee" translate="yes" xml:space="preserve">
          <source>Partition each element in &lt;code&gt;self&lt;/code&gt; around &lt;code&gt;sep&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;sep&lt;/code&gt; 주위 에 &lt;code&gt;self&lt;/code&gt; 의 각 요소를 분할합니다 .</target>
        </trans-unit>
        <trans-unit id="b9f060d2d7460c8bb8da409bb17ec782b77da6c8" translate="yes" xml:space="preserve">
          <source>Pass in &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; for axis in order to achieve the same effect that is obtained by passing in &lt;code&gt;axis=None&lt;/code&gt; in Python (treating the array as a 1-d array).</source>
          <target state="translated">전달할 &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 전달하여 얻어지는 동일한 효과를 달성하기 위해 축의 &lt;code&gt;axis=None&lt;/code&gt; (1-D 어레이로 배열 처리)를 파이썬.</target>
        </trans-unit>
        <trans-unit id="73cd8d136978e78fbd97dbe5ed74c150dbf70d53" translate="yes" xml:space="preserve">
          <source>Pass in &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; for axis in order to achieve the same effect that is obtained by passing in &lt;em&gt;axis&lt;/em&gt; = &lt;code&gt;None&lt;/code&gt; in Python (treating the array as a 1-d array).</source>
          <target state="translated">전달할 &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 전달하여 얻어지는 동일한 효과를 달성하기 위해 축의 &lt;em&gt;축&lt;/em&gt; = &lt;code&gt;None&lt;/code&gt; (1-D 어레이로 배열 처리)를 파이썬.</target>
        </trans-unit>
        <trans-unit id="58a3162e63c74cd0a5b9f30fee127febc4cf5551" translate="yes" xml:space="preserve">
          <source>Pass the data and shape information on to a subroutine or other section of code that actually performs the computation.</source>
          <target state="translated">데이터 및 모양 정보를 실제로 계산을 수행하는 코드의 서브 루틴 또는 다른 섹션으로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="156da705bee027f7cedec8eb9921a006c401c66c" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;shape=0&lt;/code&gt; to factory functions in &lt;code&gt;numpy.rec&lt;/code&gt; is deprecated</source>
          <target state="translated">&lt;code&gt;numpy.rec&lt;/code&gt; 의 공장 함수에 &lt;code&gt;shape=0&lt;/code&gt; 전달 은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d10d9cbcf594e625c1e314a82048242c6dbb90d" translate="yes" xml:space="preserve">
          <source>Passing &lt;code&gt;shape=None&lt;/code&gt; to functions with a non-optional shape argument is deprecated</source>
          <target state="translated">선택 사항이 아닌 shape 인수가있는 함수에 &lt;code&gt;shape=None&lt;/code&gt; 을 전달 하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d15e20b835ab140727ff8c5a5d6d26cf599eec85" translate="yes" xml:space="preserve">
          <source>Passing None for &lt;code&gt;dtype&lt;/code&gt; is different from omitting the parameter, since the former invokes &lt;code&gt;dtype(None)&lt;/code&gt; which is an alias for &lt;code&gt;dtype('float_')&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 에 None을 전달 하는 것은 매개 변수를 생략하는 것과 다릅니다. 전자는 &lt;code&gt;dtype('float_')&lt;/code&gt; 의 별칭 인 &lt;code&gt;dtype(None)&lt;/code&gt; 을 호출 하기 때문 입니다.</target>
        </trans-unit>
        <trans-unit id="b89022c4aa33577203e66e96c9430c9099309a83" translate="yes" xml:space="preserve">
          <source>Passing a single array in the &amp;lsquo;out&amp;rsquo; keyword argument to a ufunc with multiple outputs is deprecated, and will raise a warning in numpy 1.10, and an error in a future release.</source>
          <target state="translated">출력이 여러 개인 ufunc에 'out'키워드 인수의 단일 배열을 전달하는 것은 더 이상 사용되지 않으며 numpy 1.10에서는 경고가 발생하고 다음 릴리스에서는 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cc5f2cbfa94aa687203b7f58cf1ebb3635d8adf8" translate="yes" xml:space="preserve">
          <source>Passing in a unit will change the precision</source>
          <target state="translated">단위를 전달하면 정밀도가 변경됩니다</target>
        </trans-unit>
        <trans-unit id="0f7da55a06e16eb446ed0921edff81714e6fd8fa" translate="yes" xml:space="preserve">
          <source>Path to data files can be a function taking no arguments and returning path(s) to data files &amp;ndash; this is a useful when data files are generated while building the package. (XXX: explain the step when this function are called exactly)</source>
          <target state="translated">데이터 파일의 경로는 인수를 사용하지 않고 데이터 파일의 경로를 반환하는 함수일 수 있습니다. 이는 패키지를 빌드하는 동안 데이터 파일이 생성 될 때 유용합니다. (XXX :이 함수가 정확히 호출 될 때 단계를 설명하십시오)</target>
        </trans-unit>
        <trans-unit id="7b09e5c11956eb9c1498f52bbb0e9c021d2dd1d7" translate="yes" xml:space="preserve">
          <source>Path to install the library, relative to the current sub-package.</source>
          <target state="translated">현재 서브 패키지에 상대적인 라이브러리 설치 경로.</target>
        </trans-unit>
        <trans-unit id="bcea45c9bd2476c9e4cd30676023f4aeef1d6024" translate="yes" xml:space="preserve">
          <source>Path to test module, or None. By default, run the module from which this function is called.</source>
          <target state="translated">테스트 모듈 경로 또는 없음 기본적으로이 함수가 호출 된 모듈을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="5aaad5ad47911a6ee3698400062dbd905a7c854b" translate="yes" xml:space="preserve">
          <source>Path to the directory where the source file gets downloaded to for use. If &lt;code&gt;destpath&lt;/code&gt; is None, a temporary directory will be created. The default path is the current directory.</source>
          <target state="translated">소스 파일이 다운로드 될 디렉토리의 경로입니다. 경우 &lt;code&gt;destpath&lt;/code&gt; 은 없음입니다, 임시 디렉토리가 생성됩니다. 기본 경로는 현재 디렉토리입니다.</target>
        </trans-unit>
        <trans-unit id="f9f9dd4b0f8cff037993dd2cabb077c76f25ccdf" translate="yes" xml:space="preserve">
          <source>Path to the mapped file.</source>
          <target state="translated">매핑 된 파일의 경로입니다.</target>
        </trans-unit>
        <trans-unit id="469a6fbd3b07320fafdf1032dad3f5f283c78450" translate="yes" xml:space="preserve">
          <source>Pathlib support for &lt;code&gt;fromfile&lt;/code&gt;, &lt;code&gt;tofile&lt;/code&gt; and &lt;code&gt;ndarray.dump&lt;/code&gt;</source>
          <target state="translated">대한 Pathlib 지원 &lt;code&gt;fromfile&lt;/code&gt; , &lt;code&gt;tofile&lt;/code&gt; 및 &lt;code&gt;ndarray.dump&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="881e30b3dab6ac95c64ea97e026f084d13c834c1" translate="yes" xml:space="preserve">
          <source>Pauli Virtanen</source>
          <target state="translated">파울리 비르 타넨</target>
        </trans-unit>
        <trans-unit id="e03200e2fcb1cc9aa1208bae4cef4e55d8221f5a" translate="yes" xml:space="preserve">
          <source>Paver (pip)</source>
          <target state="translated">포장 재료 (pip)</target>
        </trans-unit>
        <trans-unit id="b5d38425a72fb16fe116f884b547ba73162e566c" translate="yes" xml:space="preserve">
          <source>Paver is used to build the source releases. It will create the &lt;code&gt;release&lt;/code&gt; and &lt;code&gt;release/installers&lt;/code&gt; directories and put the &lt;code&gt;*.zip&lt;/code&gt; and &lt;code&gt;*.tar.gz&lt;/code&gt; source releases in the latter.</source>
          <target state="translated">Paver는 소스 릴리스를 빌드하는 데 사용됩니다. 그것은 만듭니다 &lt;code&gt;release&lt;/code&gt; 와 &lt;code&gt;release/installers&lt;/code&gt; 디렉토리와 넣어 &lt;code&gt;*.zip&lt;/code&gt; 및 &lt;code&gt;*.tar.gz&lt;/code&gt; 의의 후자의 소스 출시.</target>
        </trans-unit>
        <trans-unit id="b41a92bed03261664717a6afdad4edf3d5d6ef6e" translate="yes" xml:space="preserve">
          <source>Payment</source>
          <target state="translated">Payment</target>
        </trans-unit>
        <trans-unit id="0e3a3cc21418fc90fe6ecc74f59b0c52c7573497" translate="yes" xml:space="preserve">
          <source>Payment against loan plus interest. If all input is scalar, returns a scalar float. If any input is array_like, returns payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">대출 +이자에 대한 지불. 모든 입력 값이 스칼라이면 스칼라 부동 소수점을 반환합니다. 입력이 array_like 인 경우 각 입력 요소에 대한 지불을 리턴합니다. 여러 입력이 array_like 인 경우 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="271672e73ea39752eac8cd415579fb64e6dce733" translate="yes" xml:space="preserve">
          <source>Peak to peak (maximum - minimum) value along a given axis.</source>
          <target state="translated">주어진 축을 따라 피크 대 피크 (최대-최소) 값.</target>
        </trans-unit>
        <trans-unit id="6440f5bac3611c7691e3f3b6096a90aded3cd7c7" translate="yes" xml:space="preserve">
          <source>Peak-to-peak (maximum - minimum) value along the given axis.</source>
          <target state="translated">주어진 축을 따라 피크 대 피크 (최대-최소) 값.</target>
        </trans-unit>
        <trans-unit id="a4d9b598086b2e4807ae948d1154096a596ee878" translate="yes" xml:space="preserve">
          <source>People use the terms &amp;ldquo;how-to&amp;rdquo; and &amp;ldquo;tutorial&amp;rdquo; interchangeably, but we draw a distinction, following Daniele Procida&amp;rsquo;s &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;taxonomy of documentation&lt;/a&gt;.</source>
          <target state="translated">사람들은 &quot;방법&quot;과 &quot;자습서&quot;라는 용어를 같은 의미로 사용하지만 Daniele Procida의 &lt;a href=&quot;https://documentation.divio.com/&quot;&gt;문서 분류 체계에&lt;/a&gt; 따라 구별 됩니다.</target>
        </trans-unit>
        <trans-unit id="f3cede1363e0d94b858cd773fa14f118d5eb0e6f" translate="yes" xml:space="preserve">
          <source>Percentile implemented in terms of &lt;code&gt;np.partition&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.partition&lt;/code&gt; 측면에서 구현 된 백분위 수</target>
        </trans-unit>
        <trans-unit id="0e770ebd82c1aff8fd49c8c27f132133320abb8f" translate="yes" xml:space="preserve">
          <source>Percentile or sequence of percentiles to compute, which must be between 0 and 100 inclusive.</source>
          <target state="translated">계산할 백분위 수 또는 백분위 수 시퀀스 (0과 100 사이) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="a255b994d23ac7634da6f95c324c497d0ac47849" translate="yes" xml:space="preserve">
          <source>Percentile output changes</source>
          <target state="translated">백분위 수 출력 변화</target>
        </trans-unit>
        <trans-unit id="591430971d8daa3533d8d46e03b21bb8d090d46c" translate="yes" xml:space="preserve">
          <source>Percentile supports more interpolation options</source>
          <target state="translated">백분위 수는 더 많은 보간 옵션을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="39e5a5c70ff7afff4f74e23e5b6f9bc7ce3c427f" translate="yes" xml:space="preserve">
          <source>Perform an indirect partition along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 키워드로 지정된 알고리즘을 사용하여 주어진 축을 따라 간접 파티션을 수행하십시오 .</target>
        </trans-unit>
        <trans-unit id="aa6a3a9823da0a46526f859015ecc6fb3fbea02b" translate="yes" xml:space="preserve">
          <source>Perform an indirect partition along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword. It returns an array of indices of the same shape as &lt;code&gt;a&lt;/code&gt; that index data along the given axis in partitioned order.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 키워드로 지정된 알고리즘을 사용하여 주어진 축을 따라 간접 파티션을 수행하십시오 . 주어진 축을 따라 분할 된 순서 &lt;code&gt;a&lt;/code&gt; 해당 인덱스 데이터와 동일한 모양의 인덱스 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="64032456cbe8319e7d98bde786ae8344738e1455" translate="yes" xml:space="preserve">
          <source>Perform an indirect sort along the given axis using the algorithm specified by the &lt;code&gt;kind&lt;/code&gt; keyword. It returns an array of indices of the same shape as &lt;code&gt;a&lt;/code&gt; that index data along the given axis in sorted order.</source>
          <target state="translated">&lt;code&gt;kind&lt;/code&gt; 키워드로 지정된 알고리즘을 사용하여 주어진 축을 따라 간접 정렬을 수행하십시오 . 이 같은 형태의 인덱스 배열 반환 정렬 된 순서에 따라 소정의 축을 그 인덱스 데이터. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e51a52f04a9140623599aa3b0b98ea5b1cc97dfc" translate="yes" xml:space="preserve">
          <source>Perform an indirect stable sort using a sequence of keys.</source>
          <target state="translated">일련의 키를 사용하여 간접 안정적인 정렬을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="67a1b7c0504ae299de04313d9433cb77c326b1c0" translate="yes" xml:space="preserve">
          <source>Perform consistency check of arguments by evaluating &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt;; if &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt; returns 0, an exception is raised.</source>
          <target state="translated">&lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt; 을 평가하여 인수의 일관성 검사를 수행합니다 . 만약 &lt;code&gt;&amp;lt;C-booleanexpr&amp;gt;&lt;/code&gt; 0을 반환은 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="63c904559993935c470f516c8b549ca7f3640dbb" translate="yes" xml:space="preserve">
          <source>Performance</source>
          <target state="translated">Performance</target>
        </trans-unit>
        <trans-unit id="6637203688f192cd4c7831fd72958ca38674eef7" translate="yes" xml:space="preserve">
          <source>Performance differs across platforms due to compiler and hardware availability (e.g., register width) differences. The default bit generator has been chosen to perform well on 64-bit platforms. Performance on 32-bit operating systems is very different.</source>
          <target state="translated">컴파일러 및 하드웨어 가용성 (예 : 레지스터 너비) 차이로 인해 플랫폼마다 성능이 다릅니다. 기본 비트 생성기는 64 비트 플랫폼에서 제대로 작동하도록 선택되었습니다. 32 비트 운영 체제의 성능은 매우 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9c52299828f379fa31ccf418c483aeec41f916ab" translate="yes" xml:space="preserve">
          <source>Performance improvement for &lt;code&gt;np.array&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.array&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="b0c97591e66a1a7ade5603056a75445a61446141" translate="yes" xml:space="preserve">
          <source>Performance improvement for &lt;code&gt;np.searchsorted&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.searchsorted&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="9603b88256d72407ab6e6c3f19a0ffa5841913bc" translate="yes" xml:space="preserve">
          <source>Performance improvements and changes</source>
          <target state="translated">성능 향상 및 변경</target>
        </trans-unit>
        <trans-unit id="b6f4578a97efb62d654157c29d267317ee2475b0" translate="yes" xml:space="preserve">
          <source>Performance improvements for &lt;code&gt;packbits&lt;/code&gt; and &lt;code&gt;unpackbits&lt;/code&gt;</source>
          <target state="translated">에 대한 성능 개선 &lt;code&gt;packbits&lt;/code&gt; 및 &lt;code&gt;unpackbits&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3dba14d8d4ce495c233d380d634d031e87a8cd0" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;isnan&lt;/code&gt;, &lt;code&gt;isinf&lt;/code&gt;, &lt;code&gt;isfinite&lt;/code&gt; and &lt;code&gt;byteswap&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;isnan&lt;/code&gt; , &lt;code&gt;isinf&lt;/code&gt; , &lt;code&gt;isfinite&lt;/code&gt; 및 &lt;code&gt;byteswap&lt;/code&gt; 에 대한 성능 향상</target>
        </trans-unit>
        <trans-unit id="b448d45ff6016d5c9cee889d533aea1f08a20b36" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;median&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;median&lt;/code&gt; 성능 향상</target>
        </trans-unit>
        <trans-unit id="ced4e57dc2a9cf06efc202bc15e74ab7476bdf9c" translate="yes" xml:space="preserve">
          <source>Performance improvements to &lt;code&gt;pad&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;pad&lt;/code&gt; 성능 향상</target>
        </trans-unit>
        <trans-unit id="7518fcdea1f898cd57fb2174ab71737760cfa801" translate="yes" xml:space="preserve">
          <source>Performance improvements via SSE2 vectorization</source>
          <target state="translated">SSE2 벡터화를 통한 성능 향상</target>
        </trans-unit>
        <trans-unit id="5c4d87af8409567870f0a8884054dba62da5530d" translate="yes" xml:space="preserve">
          <source>Performance on different Operating Systems</source>
          <target state="translated">다른 운영 체제에서의 성능</target>
        </trans-unit>
        <trans-unit id="5459d1c079af547b963e3b424e98d9eb9d73b000" translate="yes" xml:space="preserve">
          <source>Performance tuning</source>
          <target state="translated">성능 조정</target>
        </trans-unit>
        <trans-unit id="d8745def767a8cd0cac8c9e4b16803d5c76be3a9" translate="yes" xml:space="preserve">
          <source>Performance-Related Options</source>
          <target state="translated">성능 관련 옵션</target>
        </trans-unit>
        <trans-unit id="8b8da6105b8a6d69384985610612578b000a977b" translate="yes" xml:space="preserve">
          <source>Performs a (local) reduce with specified slices over a single axis.</source>
          <target state="translated">단일 축에서 지정된 슬라이스로 (로컬) 축소를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="793e356298f57d9115bf94bc021ff4af3ab35b36" translate="yes" xml:space="preserve">
          <source>Performs element-wise comparison of two string arrays using the comparison operator specified by &lt;code&gt;cmp_op&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;cmp_op&lt;/code&gt; 로 지정된 비교 연산자를 사용하여 두 문자열 배열의 요소 별 비교를 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="4c5da77705e71b95e951ed4d7ec45e06388841c4" translate="yes" xml:space="preserve">
          <source>Performs unbuffered in place operation on operand &amp;lsquo;a&amp;rsquo; for elements specified by &amp;lsquo;indices&amp;rsquo;.</source>
          <target state="translated">'indices'로 지정된 요소에 대해 피연산자 'a'에서 버퍼되지 않은 제자리 작업을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="64fcbb980b448111a78376527afea140c32d0b99" translate="yes" xml:space="preserve">
          <source>Performs unbuffered in place operation on operand &amp;lsquo;a&amp;rsquo; for elements specified by &amp;lsquo;indices&amp;rsquo;. For addition ufunc, this method is equivalent to &lt;code&gt;a[indices] += b&lt;/code&gt;, except that results are accumulated for elements that are indexed more than once. For example, &lt;code&gt;a[[0,0]] += 1&lt;/code&gt; will only increment the first element once because of buffering, whereas &lt;code&gt;add.at(a, [0,0], 1)&lt;/code&gt; will increment the first element twice.</source>
          <target state="translated">'indices'로 지정된 요소에 대해 피연산자 'a'에서 버퍼되지 않은 제자리 작업을 수행합니다. 또한 ufunc의 경우,이 방법은 &lt;code&gt;a[indices] += b&lt;/code&gt; 와 동일하지만 결과는 두 번 이상 색인화 된 요소에 대해 누적됩니다. 예를 들어, &lt;code&gt;a[[0,0]] += 1&lt;/code&gt; 은 버퍼링으로 인해 첫 번째 요소 만 한 번만 증가시키는 반면 &lt;code&gt;add.at(a, [0,0], 1)&lt;/code&gt; 은 첫 번째 요소를 두 번 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="170a28a9db6d27d7212fc6dc249434a57517e7bc" translate="yes" xml:space="preserve">
          <source>Period</source>
          <target state="translated">Period</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
