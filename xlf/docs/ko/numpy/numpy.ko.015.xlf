<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="cdf699c411308f89c9b3b067e51b1e307dfb7a9f" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt;.</source>
          <target state="translated">즉, &lt;code&gt;flags = divide + 2*over + 4*under + 8*invalid&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="f91eee16dbc3f050fa038e2c5209d53822e69e47" translate="yes" xml:space="preserve">
          <source>In other words, each entry &lt;code&gt;out[i,j,...,:]&lt;/code&gt; is an N-dimensional value drawn from the distribution.</source>
          <target state="translated">다시 말해서, 각 항목 &lt;code&gt;out[i,j,...,:]&lt;/code&gt; 은 분포에서 도출 된 N 차원 값입니다.</target>
        </trans-unit>
        <trans-unit id="b7dcdc5e279e7f5cb5fcdbe1eac1b3a0742ee26b" translate="yes" xml:space="preserve">
          <source>In other words, the usage of info is exactly the same as when using blas_info and co.</source>
          <target state="translated">즉, info 사용법은 blas_info 및 co를 사용할 때와 정확히 동일합니다.</target>
        </trans-unit>
        <trans-unit id="84851d19bec7dda86a1de5ddcd1548f32366d2fa" translate="yes" xml:space="preserve">
          <source>In our case,</source>
          <target state="translated">우리의 경우</target>
        </trans-unit>
        <trans-unit id="d08ff7590113d034602ad8a932c13f96f4f84856" translate="yes" xml:space="preserve">
          <source>In our case, we are approximating the grayscale portion of the image, so we will use the colormap &lt;code&gt;gray&lt;/code&gt;:</source>
          <target state="translated">우리의 경우 이미지의 회색조 부분을 근사화하고 있으므로 colormap &lt;code&gt;gray&lt;/code&gt; 를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="41f0de1dccddf6867cedf88d3dd90186911881e1" translate="yes" xml:space="preserve">
          <source>In our examples, we will treat the input array with a complex data type, so that we can take square roots of negative numbers. Without enabling copies or buffering mode, the iterator will raise an exception if the data type doesn&amp;rsquo;t match precisely.</source>
          <target state="translated">이 예에서는 입력 배열을 복잡한 데이터 유형으로 처리하여 음수의 제곱근을 취할 수 있습니다. 복사 또는 버퍼링 모드를 사용하지 않으면 데이터 유형이 정확하게 일치하지 않으면 반복자가 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="f3aea51c3c320aa437734a573490879eb2569913" translate="yes" xml:space="preserve">
          <source>In place fancy indexing for ufuncs</source>
          <target state="translated">ufuncs를위한 멋진 인덱싱</target>
        </trans-unit>
        <trans-unit id="f02a14688f33a1cd645cff2ad5ad3ea73913fd03" translate="yes" xml:space="preserve">
          <source>In place operations will perform the calculation using the precision decided by the data type of the two operands, but will silently downcast the result (if necessary) so it can fit back into the array. Therefore, for mixed precision calculations, &lt;code&gt;A {op}=
B&lt;/code&gt; can be different than &lt;code&gt;A = A {op} B&lt;/code&gt;. For example, suppose &lt;code&gt;a = ones((3,3))&lt;/code&gt;. Then, &lt;code&gt;a += 3j&lt;/code&gt; is different than &lt;code&gt;a = a +
3j&lt;/code&gt;: while they both perform the same computation, &lt;code&gt;a += 3&lt;/code&gt; casts the result to fit back in &lt;code&gt;a&lt;/code&gt;, whereas &lt;code&gt;a = a + 3j&lt;/code&gt; re-binds the name &lt;code&gt;a&lt;/code&gt; to the result.</source>
          <target state="translated">인플레 이스 연산은 두 피연산자의 데이터 유형에 의해 결정된 정밀도를 사용하여 계산을 수행하지만 필요한 경우 결과를 자동으로 다운 캐스트하여 배열에 다시 맞출 수 있습니다. 따라서 혼합 정밀도 계산의 경우 &lt;code&gt;A {op}= B&lt;/code&gt; 는 &lt;code&gt;A = A {op} B&lt;/code&gt; 와 다를 수 있습니다 . 예를 들어, &lt;code&gt;a = ones((3,3))&lt;/code&gt; 이라고 가정 하십시오 . 그리고, &lt;code&gt;a += 3j&lt;/code&gt; 다르다 &lt;code&gt;a = a + 3j&lt;/code&gt; : 그들은 모두 동일한 계산을 수행하면서 &lt;code&gt;a += 3&lt;/code&gt; 캐스트 다시 맞는 결과 반면, &lt;code&gt;a = a + 3j&lt;/code&gt; 재 바인딩 이름 받는을 결과. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ffbc219d4925b162d68445ad04161e81b80a2ae" translate="yes" xml:space="preserve">
          <source>In practice, we anticipate that for most Steering Council decisions (e.g., voting in new members) a more informal process will suffice.</source>
          <target state="translated">실제로 우리는 대부분의 운영위원회 결정 (예 : 신입 회원 투표)에 대해보다 비공식적 인 절차로 충분할 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="211d3795b0d3cedf14ae00bfdd7e3e38d86df021" translate="yes" xml:space="preserve">
          <source>In prior versions of NumPy, the datetime64 type always stored times in UTC. By default, creating a datetime64 object from a string or printing it would convert from or to local time:</source>
          <target state="translated">이전 버전의 NumPy에서 datetime64 유형은 항상 UTC로 시간을 저장했습니다. 기본적으로 문자열에서 datetime64 객체를 만들거나 인쇄하면 현지 시간으로 또는 현지 시간으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="bb94af890255a1752661e16a2eacce9c1ad12713" translate="yes" xml:space="preserve">
          <source>In row-major, C-style order, in two dimensions, the row index varies the slowest, and the column index the quickest. This can be generalized to multiple dimensions, where row-major order implies that the index along the first axis varies slowest, and the index along the last quickest. The opposite holds for column-major, Fortran-style index ordering.</source>
          <target state="translated">행 주요 C 스타일 순서에서 2 차원으로 행 인덱스는 가장 느리게 변하고 열 인덱스는 가장 빠릅니다. 이것은 여러 차원으로 일반화 될 수 있는데, 여기서 행-주요 순서는 첫 번째 축을 따라 인덱스가 가장 느리게 변하고 마지막으로 가장 빠른 인덱스를 나타냅니다. 열의 주요한 포트란 스타일 인덱스 순서와 반대입니다.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="translated">요컨대 :</target>
        </trans-unit>
        <trans-unit id="507aaff0e5cc21d7011bc819d2bd20f0b309484f" translate="yes" xml:space="preserve">
          <source>In single precision, &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; can be inaccurate:</source>
          <target state="translated">단 정밀도에서는 &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 이 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b1dbcac5dd55e1c7b0ed7b38aff1c0737c2f620" translate="yes" xml:space="preserve">
          <source>In single precision, std() can be inaccurate:</source>
          <target state="translated">단 정밀도에서는 std ()가 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca04a495cdff9e1119115547af374f5b2a4d64ac" translate="yes" xml:space="preserve">
          <source>In single precision, var() can be inaccurate:</source>
          <target state="translated">단 정밀도에서 var ()는 부정확 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="568553829625c2078673593fe2ee401327874ad7" translate="yes" xml:space="preserve">
          <source>In some cases, an appropriate use of the roll and the offset is necessary to get a desired answer.</source>
          <target state="translated">경우에 따라 원하는 답변을 얻으려면 롤과 오프셋을 적절히 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="bac6ec658cf559e360b3f959f986ce1e7d727c27" translate="yes" xml:space="preserve">
          <source>In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays.*</source>
          <target state="translated">경우에 따라 브로드 캐스팅은 두 어레이를 확장하여 초기 어레이 중 하나보다 큰 출력 어레이를 형성합니다. *</target>
        </trans-unit>
        <trans-unit id="ac0960cf0185d8fe7d74b182c3299905c5bc5818" translate="yes" xml:space="preserve">
          <source>In some cases, such as structured arrays and the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; interface, a data type needs to be used to make sense of the object. When this is needed, provide a Descr for &amp;lsquo;requested_dtype&amp;rsquo;, otherwise provide NULL. This reference is not stolen. Also, if the requested dtype doesn&amp;rsquo;t modify the interpretation of the input, out_dtype will still get the &amp;ldquo;innate&amp;rdquo; dtype of the object, not the dtype passed in &amp;lsquo;requested_dtype&amp;rsquo;.</source>
          <target state="translated">구조화 된 배열 및 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 인터페이스 와 같은 일부 경우 에는 객체를 이해하기 위해 데이터 유형을 사용해야합니다. 필요한 경우 'requested_dtype'에 대한 설명을 제공하고 그렇지 않으면 NULL을 제공하십시오. 이 참조는 도난되지 않았습니다. 또한 요청 된 dtype이 입력의 해석을 수정하지 않으면 out_dtype은 여전히 ​​'requested_dtype'에 전달 된 dtype이 아니라 객체의 &quot;고유&quot;dtype을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="facb6bd6062bf723ed24036374202b109145e308" translate="yes" xml:space="preserve">
          <source>In some cases, we are not interested in all the columns of the data but only a few of them. We can select which columns to import with the &lt;code&gt;usecols&lt;/code&gt; argument. This argument accepts a single integer or a sequence of integers corresponding to the indices of the columns to import. Remember that by convention, the first column has an index of 0. Negative integers behave the same as regular Python negative indexes.</source>
          <target state="translated">어떤 경우에는 데이터의 모든 열에 관심이있는 것이 아니라 일부 열에 만 관심이 있습니다. &lt;code&gt;usecols&lt;/code&gt; 인수를 사용하여 가져올 열을 선택할 수 있습니다 . 이 인수는 가져올 열의 인덱스에 해당하는 단일 정수 또는 정수 시퀀스를 허용합니다. 규칙에 따라 첫 번째 열의 인덱스는 0이라는 것을 기억하십시오. 음의 정수는 일반 Python 음의 인덱스와 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="ef2ea8dc139c52f2365b3742b195c7e8c88faf3c" translate="yes" xml:space="preserve">
          <source>In some cases, you will see this form of the commit command: &lt;code&gt;git commit
-a&lt;/code&gt;. The extra &lt;code&gt;-a&lt;/code&gt; flag automatically commits all modified files and removes all deleted files. This can save you some typing of numerous &lt;code&gt;git
add&lt;/code&gt; commands; however, it can add unwanted changes to a commit if you&amp;rsquo;re not careful. For more information, see &lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;why the -a flag?&lt;/a&gt; - and the helpful use-case description in the &lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;tangled working copy problem&lt;/a&gt;.</source>
          <target state="translated">어떤 경우에는 커밋 명령의 &lt;code&gt;git commit -a&lt;/code&gt; 형식이 표시됩니다 . 추가 &lt;code&gt;-a&lt;/code&gt; 플래그는 모든 수정 된 파일을 자동으로 커미트하고 삭제 된 모든 파일을 제거합니다. 이렇게하면 수많은 &lt;code&gt;git add&lt;/code&gt; 명령을 입력 할 필요가 없습니다 . 그러나주의하지 않으면 커밋에 원치 않는 변경 사항을 추가 할 수 있습니다. 자세한 정보 &lt;a href=&quot;http://www.gitready.com/beginner/2009/01/18/the-staging-area.html&quot;&gt;는 -a 플래그를 사용하는 이유를&lt;/a&gt; 참조하십시오 . - &lt;a href=&quot;https://tomayko.com/writings/the-thing-about-git&quot;&gt;얽힌 작업 카피 문제&lt;/a&gt; 의 유용한 사용 사례 설명 .</target>
        </trans-unit>
        <trans-unit id="341cdd9b0329316960c0e4cc444da230117b1062" translate="yes" xml:space="preserve">
          <source>In some future release, it will return a read/write view and writing to the returned array will alter your original array. The returned array will have the same type as the input array.</source>
          <target state="translated">향후 릴리스에서는 읽기 / 쓰기보기를 반환하고 반환 된 배열에 쓰면 원래 배열이 변경됩니다. 반환 된 배열은 입력 배열과 동일한 유형을 갖습니다.</target>
        </trans-unit>
        <trans-unit id="f5ee90b2a39e9fa80b16d394e14dd0a33a028120" translate="yes" xml:space="preserve">
          <source>In some situations, it is possible that you could use the &lt;code&gt;%numpy_typemaps&lt;/code&gt; macro to implement typemaps for your own types. See the &lt;a href=&quot;#other-common-types-bool&quot;&gt;Other Common Types: bool&lt;/a&gt; or &lt;a href=&quot;#other-common-types-complex&quot;&gt;Other Common Types: complex&lt;/a&gt; sections for examples. Another situation is if your dimensions are of a type other than &lt;code&gt;int&lt;/code&gt; (say &lt;code&gt;long&lt;/code&gt; for example):</source>
          <target state="translated">경우에 따라 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 매크로를 사용 하여 고유 한 유형에 대한 유형 맵을 구현할 수 있습니다. &lt;a href=&quot;#other-common-types-bool&quot;&gt;다른 일반적인 유형 : bool&lt;/a&gt; 또는 &lt;a href=&quot;#other-common-types-complex&quot;&gt;기타 일반적인 유형 : 복합&lt;/a&gt; 섹션을 참조하십시오 . 또 다른 상황은 치수가 &lt;code&gt;int&lt;/code&gt; 이외의 유형 인 경우입니다 ( 예 : &lt;code&gt;long&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6637a461a29946a77554fd519e0c6357a75130bb" translate="yes" xml:space="preserve">
          <source>In specifying the repeat rule for a named variable, &lt;code&gt;item*N&lt;/code&gt; is short- hand for &lt;code&gt;item, item, ..., item&lt;/code&gt; repeated N times. In addition, parenthesis in combination with &lt;code&gt;*N&lt;/code&gt; can be used for grouping several items that should be repeated. Thus, &lt;code&gt;#name=(item1, item2)*4#&lt;/code&gt; is equivalent to &lt;code&gt;#name=item1, item2, item1, item2, item1, item2, item1,
item2#&lt;/code&gt;.</source>
          <target state="translated">명명 된 변수에 대한 반복 규칙을 지정할 때 &lt;code&gt;item*N&lt;/code&gt; 은 &lt;code&gt;item, item, ..., item&lt;/code&gt; N 번 반복되는 것에 대한 약어입니다. 또한 &lt;code&gt;*N&lt;/code&gt; 과 함께 괄호를 사용하여 반복해야하는 여러 항목을 그룹화 할 수 있습니다. 따라서 &lt;code&gt;#name=(item1, item2)*4#&lt;/code&gt; 은 &lt;code&gt;#name=item1, item2, item1, item2, item1, item2, item1, item2#&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="ef54aceba82e6cd0b5d227cf1545504de22cdfa8" translate="yes" xml:space="preserve">
          <source>In that case, each item is associated to a column, in order.</source>
          <target state="translated">이 경우 각 항목은 순서대로 열에 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="4128e61e6436506814002ae295957c7fd56f0e0e" translate="yes" xml:space="preserve">
          <source>In that repository edit the files:</source>
          <target state="translated">해당 저장소에서 파일을 편집하십시오.</target>
        </trans-unit>
        <trans-unit id="3d0c88a0902d8f4e29b2260087b409a1f0c6bbf0" translate="yes" xml:space="preserve">
          <source>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</source>
          <target state="translated">1 차원 및 0 차원에서는 인덱싱 및 희소 키워드가 적용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="82b4d34298ee4da5c6486a950c439f010b328116" translate="yes" xml:space="preserve">
          <source>In the above example F2PY was able to guess accurately the signature of a call-back function. However, sometimes F2PY cannot establish the signature as one would wish and then the signature of a call-back function must be modified in the signature file manually. Namely, signature files may contain special modules (the names of such modules contain a substring &lt;code&gt;__user__&lt;/code&gt;) that collect various signatures of call-back functions. Callback arguments in routine signatures have attribute &lt;code&gt;external&lt;/code&gt; (see also &lt;code&gt;intent(callback)&lt;/code&gt; attribute). To relate a callback argument and its signature in &lt;code&gt;__user__&lt;/code&gt; module block, use &lt;code&gt;use&lt;/code&gt; statement as illustrated below. The same signature of a callback argument can be referred in different routine signatures.</source>
          <target state="translated">위의 예에서 F2PY는 콜백 함수의 서명을 정확하게 추측 할 수있었습니다. 그러나 때로는 F2PY가 원하는대로 서명을 설정할 수 없으며 콜백 함수의 서명을 서명 파일에서 수동으로 수정해야합니다. 즉, 서명 파일에는 콜백 함수의 다양한 서명을 수집 하는 특수 모듈 (이러한 모듈의 이름에는 하위 문자열 &lt;code&gt;__user__&lt;/code&gt; )이 포함될 수 있습니다 . 루틴 서명의 콜백 인수에는 &lt;code&gt;external&lt;/code&gt; 속성이 있습니다 ( &lt;code&gt;intent(callback)&lt;/code&gt; 속성 참조). &lt;code&gt;__user__&lt;/code&gt; 모듈 블록 에서 콜백 인수와 그 서명을 연결 하려면 다음을 &lt;code&gt;use&lt;/code&gt; 아래 그림과 같이 설명합니다. 콜백 인수의 동일한 서명이 다른 루틴 서명에서 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e263de7df2b576cf438fac441850586c983ab809" translate="yes" xml:space="preserve">
          <source>In the case of double precision tests, this will return the python function &lt;code&gt;Vector.doubleLength&lt;/code&gt;.</source>
          <target state="translated">배정 밀도 테스트의 경우 Python 함수 &lt;code&gt;Vector.doubleLength&lt;/code&gt; 가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="a0240da2483005a9c53b4aad1de6618f577c43aa" translate="yes" xml:space="preserve">
          <source>In the common 2-D case (N=1), the block structure can be visualized:</source>
          <target state="translated">일반적인 2 차원 경우 (N = 1), 블록 구조를 시각화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a985ec6ae1b21c700d18be39de4f40c82d97f8b" translate="yes" xml:space="preserve">
          <source>In the directory where you want the copy created, run</source>
          <target state="translated">복사본을 만들려는 디렉터리에서 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="e138055380190b3c93b794e532e7d0c34dce613a" translate="yes" xml:space="preserve">
          <source>In the end, which you do for Fortran or C depends on which is more important, not reordering data or preserving the indexing convention. For large images, reordering data is potentially expensive, and often the indexing convention is inverted to avoid that.</source>
          <target state="translated">결국, 포트란 또는 C에 대해 수행하는 작업은 데이터를 재정렬하지 않거나 색인 규칙을 유지하지 않고 어느 것이 더 중요한지에 달려 있습니다. 큰 이미지의 경우 데이터 순서를 바꾸면 비용이 많이들 수 있으며이를 피하기 위해 인덱싱 규칙이 바뀌는 경우가 많습니다.</target>
        </trans-unit>
        <trans-unit id="8930375040ab76aae34fb47c1b34d1c268b41dae" translate="yes" xml:space="preserve">
          <source>In the event of any conflict of interest, a committee member must immediately notify the other members, and recuse themselves if necessary.</source>
          <target state="translated">이해 상충이 발생하는 경우위원회 위원은 즉시 다른 위원에게 통보하고 필요한 경우 자신을 기권해야합니다.</target>
        </trans-unit>
        <trans-unit id="b1d5a2c6f7d9d2516af28db041f10097409dc991" translate="yes" xml:space="preserve">
          <source>In the example above, we used the fact that by default, &lt;code&gt;dtype=float&lt;/code&gt;. By giving a sequence of names, we are forcing the output to a structured dtype.</source>
          <target state="translated">위의 예에서는 기본적으로 &lt;code&gt;dtype=float&lt;/code&gt; 라는 사실을 사용했습니다 . 일련의 이름을 제공함으로써 출력을 구조화 된 dtype으로 강제합니다.</target>
        </trans-unit>
        <trans-unit id="6eb66ccf87f3461ec66b2cc1735ef182a062917a" translate="yes" xml:space="preserve">
          <source>In the file, array data starts at this offset. Since &lt;code&gt;offset&lt;/code&gt; is measured in bytes, it should normally be a multiple of the byte-size of &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;. When &lt;code&gt;mode != 'r'&lt;/code&gt;, even positive offsets beyond end of file are valid; The file will be extended to accommodate the additional data. By default, &lt;code&gt;memmap&lt;/code&gt; will start at the beginning of the file, even if &lt;code&gt;filename&lt;/code&gt; is a file pointer &lt;code&gt;fp&lt;/code&gt; and &lt;code&gt;fp.tell() != 0&lt;/code&gt;.</source>
          <target state="translated">파일에서이 오프셋에서 배열 데이터가 시작됩니다. &lt;code&gt;offset&lt;/code&gt; 은 바이트 단위로 측정 되므로 일반적으로 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 의 바이트 크기의 배수 여야 합니다. 때 &lt;code&gt;mode != 'r'&lt;/code&gt; , 파일의 끝을 넘어도 긍정적 인 오프셋이 유효; 추가 데이터를 수용 할 수 있도록 파일이 확장됩니다. &lt;code&gt;filename&lt;/code&gt; 이 파일 포인터 &lt;code&gt;fp&lt;/code&gt; 이고 &lt;code&gt;fp.tell() != 0&lt;/code&gt; &lt;code&gt;memmap&lt;/code&gt; 기본적으로 memmap 은 파일 시작 부분에서 시작됩니다 .</target>
        </trans-unit>
        <trans-unit id="6d51d7e744b66162bcb271fa8e86dbafebc0e214" translate="yes" xml:space="preserve">
          <source>In the first case the lower bound of the integration is set to -1 and the integration constant is 0. In the second the constant of integration is set to 1 as well. Differentiation is simpler since the only option is the number of times the polynomial is differentiated:</source>
          <target state="translated">첫 번째 경우 적분의 하한은 -1로 설정되고 적분 상수는 0입니다. 두 번째 경우에도 적분 상수는 1로 설정됩니다. 유일한 옵션은 다항식이 구별되는 횟수이기 때문에 차별화가 더 간단합니다.</target>
        </trans-unit>
        <trans-unit id="39042dbdcabf0496e03a08644bb7e129fe61d278" translate="yes" xml:space="preserve">
          <source>In the first case, the dimensions resulting from the advanced indexing operation come first in the result array, and the subspace dimensions after that. In the second case, the dimensions from the advanced indexing operations are inserted into the result array at the same spot as they were in the initial array (the latter logic is what makes simple advanced indexing behave just like slicing).</source>
          <target state="translated">첫 번째 경우, 고급 인덱싱 작업으로 인해 생성 된 차원이 결과 배열에서 먼저 나오고 그 이후의 부분 공간 차원으로 나타납니다. 두 번째 경우, 고급 인덱싱 작업의 차원은 초기 배열과 같은 위치에 결과 배열에 삽입됩니다 (후자의 논리는 단순 고급 인덱싱이 슬라이싱과 같은 방식으로 작동하도록하는 것입니다).</target>
        </trans-unit>
        <trans-unit id="fee9951c9cac899e8dc4b73ca21eaf580eee1e11" translate="yes" xml:space="preserve">
          <source>In the following descriptions, we reference a generic &lt;code&gt;DATA_TYPE&lt;/code&gt;, which could be any of the C data types listed above, and &lt;code&gt;DIM_TYPE&lt;/code&gt; which should be one of the many types of integers.</source>
          <target state="translated">다음 설명에서는 위에 나열된 C 데이터 유형 중 하나 일 수 있는 일반 &lt;code&gt;DATA_TYPE&lt;/code&gt; 및 여러 유형의 정수 중 하나 &lt;code&gt;DIM_TYPE&lt;/code&gt; 하는 DIM_TYPE 을 참조합니다.</target>
        </trans-unit>
        <trans-unit id="0a77a218f61bf2d19822ca93ebcee58f5aa1e669" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size during the broadcast operation:</source>
          <target state="translated">다음 예제에서 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 배열은 모두 브로드 캐스트 작업 중에 더 큰 크기로 확장되는 길이가 1 인 축을 가지고 있습니다.</target>
        </trans-unit>
        <trans-unit id="56c7aa7e2fe12577360a1a373c78ed632827aefd" translate="yes" xml:space="preserve">
          <source>In the following example, both the &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; arrays have axes with length one that are expanded to a larger size in a broadcast operation.</source>
          <target state="translated">다음 예제에서 &lt;code&gt;A&lt;/code&gt; 및 &lt;code&gt;B&lt;/code&gt; 배열에는 브로드 캐스트 작업에서 더 큰 크기로 확장되는 길이가 1 인 축이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7b0aabec281905f99f49d1bbd6f2c64a2c3c69d5" translate="yes" xml:space="preserve">
          <source>In the following example, the second column is converted from as string representing a percentage to a float between 0 and 1:</source>
          <target state="translated">다음 예에서 두 번째 열은 백분율을 나타내는 문자열에서 0과 1 사이의 부동 소수점으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="4b029336d8b412b884840fa6a1fbeb3e45d0f30b" translate="yes" xml:space="preserve">
          <source>In the following example, we suppose that the missing values are flagged with &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; in the first column and by &lt;code&gt;&quot;???&quot;&lt;/code&gt; in the third column. We wish to transform these missing values to 0 if they occur in the first and second column, and to -999 if they occur in the last column:</source>
          <target state="translated">다음 예에서는 누락 된 값이 첫 번째 열에 &lt;code&gt;&quot;N/A&quot;&lt;/code&gt; 로 표시되고 &lt;code&gt;&quot;???&quot;&lt;/code&gt; 로 플래그가 지정되었다고 가정합니다. 세 번째 열에서. 이러한 누락 된 값이 첫 번째 및 두 번째 열에서 발생하면 0으로 변환하고 마지막 열에서 발생하는 경우 -999로 변환하려고합니다.</target>
        </trans-unit>
        <trans-unit id="fceed6223bcf512a691c7903c36d65343ab22b97" translate="yes" xml:space="preserve">
          <source>In the graph, we can see that although we have 768 singular values in &lt;code&gt;s&lt;/code&gt;, most of those (after the 150th entry or so) are pretty small. So it might make sense to use only the information related to the first (say, 50) &lt;em&gt;singular values&lt;/em&gt; to build a more economical approximation to our image.</source>
          <target state="translated">그래프에서 &lt;code&gt;s&lt;/code&gt; 에 768 개의 특이 값이 있지만 대부분 (150 번째 항목 이후)이 매우 작다는 것을 알 수 있습니다. 따라서 첫 번째 (예 : 50 개) &lt;em&gt;특이 값&lt;/em&gt; 과 관련된 정보 만 사용하여 이미지에 더 경제적 인 근사치를 구축하는 것이 합리적 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66d2fff5a851e4221aa19362249b2b84c5964134" translate="yes" xml:space="preserve">
          <source>In the next several sections we give example code that can be easily modified to create your own ufuncs. The examples are successively more complete or complicated versions of the logit function, a common function in statistical modeling. Logit is also interesting because, due to the magic of IEEE standards (specifically IEEE 754), all of the logit functions created below automatically have the following behavior.</source>
          <target state="translated">다음 여러 섹션에서는 사용자 고유의 ufunc를 만들기 위해 쉽게 수정할 수있는 예제 코드를 제공합니다. 예제는 통계 모델링의 공통 함수 인 로짓 함수의 연속적으로 더 완전하거나 복잡한 버전입니다. Logit은 또한 IEEE 표준 (특히 IEEE 754)의 마법으로 인해 아래에 생성 된 모든 logit 함수가 다음과 같은 동작을 자동으로 수행하기 때문에 흥미 롭습니다.</target>
        </trans-unit>
        <trans-unit id="1dc319444395eeb97927a05649519246dd32d72d" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">과거에는 대부분의 구현에서 &lt;code&gt;PyCObject&lt;/code&gt; 자체 의 &quot;desc&quot;멤버 ( 위 의 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; 구조 의 &quot;descr&quot;멤버와 혼동하지 마십시오. 두 가지 별도의 요소 임)를 사용하여 인터페이스를 노출하는 오브젝트에 대한 포인터를 보유했습니다. 이것은 이제 인터페이스의 명백한 부분입니다. 하여 객체에 대한 참조를 소유해야합니다 &lt;code&gt;PyCObject&lt;/code&gt; 를 사용하여 만들어집니다 &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="2cb71d475f8be6120fc976bd353b076b792b7f77" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &amp;ldquo;desc&amp;rdquo; member of the &lt;code&gt;PyCObject&lt;/code&gt; itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to own a reference to the object when the &lt;code&gt;PyCObject&lt;/code&gt; is created using &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt;.</source>
          <target state="translated">과거에는 대부분의 구현에서 &lt;code&gt;PyCObject&lt;/code&gt; 자체 의 &quot;desc&quot;멤버를 사용했습니다 ( 위 의 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; 구조 의 &quot;descr&quot;멤버와 혼동하지 마십시오. 두 개의 개별 항목입니다). 이것은 이제 인터페이스의 명시적인 부분입니다. &lt;code&gt;PyCObject&lt;/code&gt; _FromVoidPtrAndDesc 를 사용하여 &lt;code&gt;PyCObject_FromVoidPtrAndDesc&lt;/code&gt; 만들 때 개체에 대한 참조를 소유해야합니다 .</target>
        </trans-unit>
        <trans-unit id="dd96631acab4a4c78f25e82e30e4074e25691d52" translate="yes" xml:space="preserve">
          <source>In the past most implementations used the &lt;code&gt;desc&lt;/code&gt; member of the &lt;code&gt;PyCObject&lt;/code&gt; (now &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt;) itself (do not confuse this with the &amp;ldquo;descr&amp;rdquo; member of the &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure above &amp;mdash; they are two separate things) to hold the pointer to the object exposing the interface. This is now an explicit part of the interface. Be sure to take a reference to the object and call &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule_SetContext&quot;&gt;&lt;code&gt;PyCapsule_SetContext&lt;/code&gt;&lt;/a&gt; before returning the &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt;, and configure a destructor to decref this reference.</source>
          <target state="translated">과거에 대부분의 구현 은 &lt;code&gt;PyCObject&lt;/code&gt; (현재 &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; &lt;/a&gt; ) 자체 의 &lt;code&gt;desc&lt;/code&gt; 멤버를 사용 했습니다 ( 위 의 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; &lt;/a&gt; 구조 의 &quot;descr&quot;멤버와 혼동하지 마십시오. 두 개의 개별 항목입니다). . 이것은 이제 인터페이스의 명시적인 부분입니다. 객체에 대한 참조를 가지고 호출해야합니다 &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule_SetContext&quot;&gt; &lt;code&gt;PyCapsule_SetContext&lt;/code&gt; 를&lt;/a&gt; 복귀하기 전에 &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; 을&lt;/a&gt; ,이 기준을 decref하는 소멸자를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="cfcf82ced52f76044f84d6258de886b7808506ff" translate="yes" xml:space="preserve">
          <source>In the range -1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 they are nice, equiripple functions lying between +/- 1. The same plots over the range -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 look very different:</source>
          <target state="translated">-1 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 1 범위에서는 +/- 1 사이에있는 등가 함수가 훌륭합니다. -2 &amp;lt;= &lt;code&gt;x&lt;/code&gt; &amp;lt;= 2 범위에 대한 동일한 플롯 은 매우 다르게 보입니다.</target>
        </trans-unit>
        <trans-unit id="8d2fb588d0d5207847c4495ec3e5ed9b60e1f12d" translate="yes" xml:space="preserve">
          <source>In the same way, if we don&amp;rsquo;t give enough names to match the length of the dtype, the missing names will be defined with this default template:</source>
          <target state="translated">같은 방식으로 dtype의 길이와 일치하는 충분한 이름을 제공하지 않으면 누락 된 이름이 다음 기본 템플릿으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="9664dec4c702af778eb236a77580a7bb3b836b54" translate="yes" xml:space="preserve">
          <source>In the simplest case, there is only a &lt;em&gt;single&lt;/em&gt; advanced index. A single advanced index can for example replace a slice and the result array will be the same, however, it is a copy and may have a different memory layout. A slice is preferable when it is possible.</source>
          <target state="translated">가장 간단한 경우에는 &lt;em&gt;단일&lt;/em&gt; 고급 인덱스 만 있습니다. 예를 들어 단일 고급 인덱스는 슬라이스를 대체 할 수 있으며 결과 배열은 동일하지만 사본이며 다른 메모리 레이아웃을 가질 수 있습니다. 가능하면 슬라이스가 바람직하다.</target>
        </trans-unit>
        <trans-unit id="eaceaaeb778efa3a74e32f0e07667ae3c3a1ce24" translate="yes" xml:space="preserve">
          <source>In the source code, be sure to preface any issue or PR reference with &lt;code&gt;gh-xxxx&lt;/code&gt;.</source>
          <target state="translated">소스 코드에서 모든 문제 또는 PR 참조를 &lt;code&gt;gh-xxxx&lt;/code&gt; 로 시작해야 합니다.</target>
        </trans-unit>
        <trans-unit id="c94924098b3009fa708b6c1aec49764e87be7477" translate="yes" xml:space="preserve">
          <source>In the table below, it is assumed that you have executed the following commands in Python:</source>
          <target state="translated">아래 표에서는 Python에서 다음 명령을 실행했다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="d8a45b3135fa0c84b41da4d210f43fe96826517e" translate="yes" xml:space="preserve">
          <source>In the tables below, &lt;code&gt;platform?&lt;/code&gt; means that the type may not be available on all platforms. Compatibility with different C or Python types is indicated: two types are compatible if their data is of the same size and interpreted in the same way.</source>
          <target state="translated">아래 표에서 &lt;code&gt;platform?&lt;/code&gt; 유형이 모든 플랫폼에서 사용 가능하지 않을 수 있음을 의미합니다. 다른 C 또는 Python 유형과의 호환성이 표시됩니다. 데이터의 크기가 동일하고 동일한 방식으로 해석되는 경우 두 유형이 호환됩니다.</target>
        </trans-unit>
        <trans-unit id="97b2743d166cdad8253bc15ad591949789d4af86" translate="yes" xml:space="preserve">
          <source>In the worst case, if a Contributor is genuinely misusing their veto in an obstructive fashion to the detriment of the project, then they can be ejected from the project by consensus of the Steering Council &amp;ndash; see below.</source>
          <target state="translated">최악의 경우, 기여자가 프로젝트에 해를 끼치는 방해가되는 방식으로 거부권을 진정으로 오용하는 경우 운영위원회의 합의에 따라 프로젝트에서 퇴출 될 수 있습니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="3a7fe7582d8015e2df7c05da1f3a915ff663edd3" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">이 계산에서는 각 스트림에서 가져온 숫자의 양을 무시할 수 있습니다. 우리가 제공하는 각 PRNG에는 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 풀이 조금씩 다를 경우 겹침을 방지하는 추가 보호 기능이 내장되어 있습니다. &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="65a0a52b3e0dac0b940f22ccbd59e595b0b91828" translate="yes" xml:space="preserve">
          <source>In this calculation, we can ignore the amount of numbers drawn from each stream. Each of the PRNGs we provide has some extra protection built in that avoids overlaps if the &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; pools differ in the slightest bit. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; has</source>
          <target state="translated">이 계산에서는 각 스트림에서 가져온 숫자의 양을 무시할 수 있습니다. 우리가 제공하는 각 PRNG에는 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 풀이 조금씩 다를 경우 겹침을 피하기위한 추가 보호 기능이 내장되어 있습니다. &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 는</target>
        </trans-unit>
        <trans-unit id="fcdf80c260003d781b3489e23716b20d73cd0927" translate="yes" xml:space="preserve">
          <source>In this case, if the index arrays have a matching shape, and there is an index array for each dimension of the array being indexed, the resultant array has the same shape as the index arrays, and the values correspond to the index set for each position in the index arrays. In this example, the first index value is 0 for both index arrays, and thus the first value of the resultant array is y[0,0]. The next value is y[2,1], and the last is y[4,2].</source>
          <target state="translated">이 경우 인덱스 배열의 모양이 일치하고 인덱스되는 배열의 각 차원에 대한 인덱스 배열이있는 경우 결과 배열은 인덱스 배열과 동일한 모양을 가지며 값은 각각의 인덱스 집합에 해당합니다. 인덱스 배열의 위치. 이 예에서 첫 번째 인덱스 값은 두 인덱스 배열 모두에 대해 0이므로 결과 배열의 첫 번째 값은 y [0,0]입니다. 다음 값은 y [2,1]이고 마지막 값은 y [4,2]입니다.</target>
        </trans-unit>
        <trans-unit id="89c8dba17ad2bf90a54597788476417de6721a53" translate="yes" xml:space="preserve">
          <source>In this case, we wanted to test solving a linear algebra problem using matrices of several data types, using &lt;code&gt;linalg.solve&lt;/code&gt; and &lt;code&gt;linalg.inv&lt;/code&gt;. The common test cases (for single-precision, double-precision, etc. matrices) are collected in &lt;code&gt;LinalgTestCase&lt;/code&gt;.</source>
          <target state="translated">이 경우 &lt;code&gt;linalg.solve&lt;/code&gt; 및 &lt;code&gt;linalg.inv&lt;/code&gt; 를 사용하여 여러 데이터 유형의 행렬을 사용하여 선형 대수 문제 해결을 테스트하려고했습니다 . &lt;code&gt;LinalgTestCase&lt;/code&gt; 에서 일반적인 테스트 사례 (단 정밀도, 배정 밀도 등의 행렬)가 수집됩니다 .</target>
        </trans-unit>
        <trans-unit id="a876e5a0c738a8e265b4a962587a67aa3cabc3ca" translate="yes" xml:space="preserve">
          <source>In this chapter routine docstrings are presented, grouped by functionality. Many docstrings contain example code, which demonstrates basic usage of the routine. The examples assume that NumPy is imported with:</source>
          <target state="translated">이 장에서는 기능별로 그룹화 된 일상적인 docstring이 제공됩니다. 많은 docstring에는 루틴의 기본 사용법을 보여주는 예제 코드가 포함되어 있습니다. 예제에서는 NumPy를 다음과 같이 가져 왔다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="4030b7d01040d7db2670bc21cd8e6f75987d1ae6" translate="yes" xml:space="preserve">
          <source>In this context, consensus does &lt;em&gt;not&lt;/em&gt; require:</source>
          <target state="translated">이러한 맥락에서 합의에는 다음이 필요 하지 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="fb82fb6aef1a39fd7c11a037068f12eca825f3ae" translate="yes" xml:space="preserve">
          <source>In this example if &lt;code&gt;a&lt;/code&gt; is an ndarray, &amp;ldquo;fancy&amp;rdquo; indexing can be used.</source>
          <target state="translated">이 예에서 &lt;code&gt;a&lt;/code&gt; 가 ndarray 인 경우 &quot;팬시&quot;인덱싱을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8f824e9ad2dd27432acf7adb45ed2442b89417d6" translate="yes" xml:space="preserve">
          <source>In this example the spacing is also specified: uniform for axis=0 and non uniform for axis=1</source>
          <target state="translated">이 예제에서 간격도 지정됩니다 : 축 = 0에 균일하고 축 = 1에 비 균일</target>
        </trans-unit>
        <trans-unit id="6f53f611701fca845a45b96236c3247acdc3fe03" translate="yes" xml:space="preserve">
          <source>In this example we generate two random arrays, &lt;code&gt;xarr&lt;/code&gt; and &lt;code&gt;yarr&lt;/code&gt;, and compute the row-wise and column-wise Pearson correlation coefficients, &lt;code&gt;R&lt;/code&gt;. Since &lt;code&gt;rowvar&lt;/code&gt; is true by default, we first find the row-wise Pearson correlation coefficients between the variables of &lt;code&gt;xarr&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 두 개의 임의 배열 &lt;code&gt;xarr&lt;/code&gt; 및 &lt;code&gt;yarr&lt;/code&gt; 을 생성 하고 행 및 열별 Pearson 상관 계수 &lt;code&gt;R&lt;/code&gt; 을 계산 합니다. &lt;code&gt;rowvar&lt;/code&gt; 는 기본적으로 true 이므로 먼저 &lt;code&gt;xarr&lt;/code&gt; 변수 간의 행별 Pearson 상관 계수를 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="328c265783b83eb29747b7db6d81add31503c3ba" translate="yes" xml:space="preserve">
          <source>In this example, I will show how the addition function and the filter function implemented previously using the other approaches can be implemented using ctypes. First, the C code which implements the algorithms contains the functions &lt;code&gt;zadd&lt;/code&gt;, &lt;code&gt;dadd&lt;/code&gt;, &lt;code&gt;sadd&lt;/code&gt;, &lt;code&gt;cadd&lt;/code&gt;, and &lt;code&gt;dfilter2d&lt;/code&gt;. The &lt;code&gt;zadd&lt;/code&gt; function is:</source>
          <target state="translated">이 예제에서는 이전에 다른 접근 방식을 사용하여 구현 한 더하기 함수와 필터 함수를 ctypes를 사용하여 구현할 수있는 방법을 보여줍니다. 첫째, 알고리즘을 구현하는 C 코드에는 &lt;code&gt;zadd&lt;/code&gt; , &lt;code&gt;dadd&lt;/code&gt; , &lt;code&gt;sadd&lt;/code&gt; , &lt;code&gt;cadd&lt;/code&gt; 및 &lt;code&gt;dfilter2d&lt;/code&gt; 함수가 포함되어 있습니다 . &lt;code&gt;zadd&lt;/code&gt; 기능은 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="97c094638bd844d3fa04f0e228195eec44c93a4f" translate="yes" xml:space="preserve">
          <source>In this example, a tuple of arrays was returned: one for each dimension. The first array represents the row indices where these values are found, and the second array represents the column indices where the values are found.</source>
          <target state="translated">이 예에서는 각 차원에 대해 하나씩 배열의 튜플이 반환되었습니다. 첫 번째 배열은 이러한 값이있는 행 인덱스를 나타내고 두 번째 배열은 값이있는 열 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2729241cb81ad5eb6d0653ad987658266f4094e0" translate="yes" xml:space="preserve">
          <source>In this example, both the predictions and labels vectors contain three values, meaning &lt;code&gt;n&lt;/code&gt; has a value of three. After we carry out subtractions the values in the vector are squared. Then NumPy sums the values, and your result is the error value for that prediction and a score for the quality of the model.</source>
          <target state="translated">이 예에서 예측 벡터와 레이블 벡터는 모두 3 개의 값을 포함합니다. 즉, &lt;code&gt;n&lt;/code&gt; 은 3의 값을가집니다. 빼기를 수행하면 벡터의 값이 제곱됩니다. 그런 다음 NumPy는 값을 합산하고 결과는 해당 예측에 대한 오류 값과 모델 품질에 대한 점수입니다.</target>
        </trans-unit>
        <trans-unit id="e415859b6bc51789a95cf9e8d4d1433827763e1d" translate="yes" xml:space="preserve">
          <source>In this example, real input has an FFT which is Hermitian, i.e., symmetric in the real part and anti-symmetric in the imaginary part, as described in the &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; documentation:</source>
          <target state="translated">이 예제에서 실제 입력은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; 문서에 설명 된대로 허미 시안 (Hermitian) 인 FFT, 즉 실수 부분에서 대칭이고 허수 부분에서 반대 칭 인 FFT를 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="29fea9a7cda62d1da60b8f6659f247ccebc09681" translate="yes" xml:space="preserve">
          <source>In this example, the values within each row (i.e. the values along &lt;code&gt;axis=1&lt;/code&gt;) have been shuffled independently. This is not a &amp;ldquo;bulk&amp;rdquo; shuffle of the columns.</source>
          <target state="translated">이 예에서 각 행 내의 값 (즉, &lt;code&gt;axis=1&lt;/code&gt; 의 값 )은 독립적으로 셔플되었습니다. 이것은 열의 &quot;대량&quot;셔플이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ceae5efa8d3a6692e49c8c2886b52adb07addf1c" translate="yes" xml:space="preserve">
          <source>In this example, weight has more impact on the distance calculation than height because of the larger values. In practice, it is important to normalize the height and weight, often by their standard deviation across the data set, so that both have equal influence on the distance calculation.</source>
          <target state="translated">이 예에서 가중치는 더 큰 값으로 인해 높이보다 거리 계산에 더 많은 영향을 미칩니다. 실제로는 키와 몸무게를 데이터 세트의 표준 편차로 정규화하여 둘 다 거리 계산에 동일한 영향을 미치도록하는 것이 중요합니다.</target>
        </trans-unit>
        <trans-unit id="621a7738a5786c3d0bc05ac14226a4d89a893dbf" translate="yes" xml:space="preserve">
          <source>In this part, we check the compiler and platform architecture and cache some of the intermediary results to speed up rebuilding.</source>
          <target state="translated">이 부분에서는 컴파일러 및 플랫폼 아키텍처를 확인하고 일부 중간 결과를 캐시하여 재 구축 속도를 높입니다.</target>
        </trans-unit>
        <trans-unit id="2c3e40fb7708f540adaa0b760c857b87aaa0e15a" translate="yes" xml:space="preserve">
          <source>In this shorthand notation any of the &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;string dtype specifications&lt;/a&gt; may be used in a string and separated by commas. The itemsize and byte offsets of the fields are determined automatically, and the field names are given the default names &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt;, etc.</source>
          <target state="translated">이 약식 표기법에서 &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes-constructing&quot;&gt;문자열 dtype 사양&lt;/a&gt; 은 문자열에서 사용하고 쉼표로 구분할 수 있습니다. 필드의 항목 크기 및 바이트 오프셋은 자동으로 결정되며 필드 이름에는 기본 이름 &lt;code&gt;f0&lt;/code&gt; , &lt;code&gt;f1&lt;/code&gt; 등이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="03bc9d15047b673ea201dcf5663747af818d9b11" translate="yes" xml:space="preserve">
          <source>In this tutorial, we will use a &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;matrix decomposition&lt;/a&gt; from linear algebra, the Singular Value Decomposition, to generate a compressed approximation of an image. We&amp;rsquo;ll use the &lt;code&gt;face&lt;/code&gt; image from the &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt;&lt;code&gt;scipy.misc&lt;/code&gt;&lt;/a&gt; module:</source>
          <target state="translated">이 튜토리얼에서는 선형 대수에서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Matrix_decomposition&quot;&gt;행렬 분해&lt;/a&gt; , 특이 값 분해를 사용하여 이미지의 압축 된 근사치를 생성합니다. &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/misc.html#module-scipy.misc&quot;&gt; &lt;code&gt;scipy.misc&lt;/code&gt; &lt;/a&gt; 모듈 의 &lt;code&gt;face&lt;/code&gt; 이미지를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="7b71631798c22c7379ee16411ed600d40ef635fc" translate="yes" xml:space="preserve">
          <source>In two dimensions, the DFT is defined as</source>
          <target state="translated">2 차원에서 DFT는 다음과 같이 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="e78643ae03c902815fce8ed7873dad947453bab7" translate="yes" xml:space="preserve">
          <source>In versions 1.6 and earlier of NumPy, the following flags did not have the _ARRAY_ macro namespace in them. That form of the constant names is deprecated in 1.7.</source>
          <target state="translated">NumPy 1.6 및 이전 버전에서 다음 플래그에는 _ARRAY_ 매크로 네임 스페이스가 없습니다. 상수 이름의 해당 형식은 1.7에서 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2eb3748bd4c40ee385c34a340546b34ff09c6d0f" translate="yes" xml:space="preserve">
          <source>In versions of NumPy prior to 1.7, this function always returned a new, independent array containing a copy of the values in the diagonal.</source>
          <target state="translated">1.7 이전의 NumPy 버전에서이 함수는 항상 대각선에 값의 사본을 포함하는 새로운 독립 배열을 리턴했습니다.</target>
        </trans-unit>
        <trans-unit id="0dd37ad2fb32e65c87fa0dbb4334407e5e86a994" translate="yes" xml:space="preserve">
          <source>In what NumPy version the object was deprecated, and when it will be removed.</source>
          <target state="translated">어떤 NumPy 버전에서 객체가 더 이상 사용되지 않았는지, 언제 제거 될 것인지.</target>
        </trans-unit>
        <trans-unit id="7e3012fb521e71655f173862b6d8385b1b505394" translate="yes" xml:space="preserve">
          <source>In-Place Arrays</source>
          <target state="translated">내부 배열</target>
        </trans-unit>
        <trans-unit id="4515cac8ae9188e7e6a2adf0d7162014d11595d3" translate="yes" xml:space="preserve">
          <source>In-place arrays are defined as arrays that are modified in-place. The input values may or may not be used, but the values at the time the function returns are significant. The provided Python argument must therefore be a NumPy array of the required type. The in-place signatures are</source>
          <target state="translated">제자리 배열은 제자리에서 수정되는 배열로 정의됩니다. 입력 값이 사용되거나 사용되지 않을 수 있지만 함수가 반환 될 때의 값은 중요합니다. 제공된 Python 인수는 필수 유형의 NumPy 배열이어야합니다. 전체 서명은</target>
        </trans-unit>
        <trans-unit id="e156e5cac1a2d58a18cbdda52494e20ca1917186" translate="yes" xml:space="preserve">
          <source>In-place sort.</source>
          <target state="translated">전체 정렬.</target>
        </trans-unit>
        <trans-unit id="1b17facd69825957b71025146a41a688f572e12c" translate="yes" xml:space="preserve">
          <source>In-place vs. copy</source>
          <target state="translated">내부 및 복사</target>
        </trans-unit>
        <trans-unit id="79b98df32c7e9b7cb0e464788719f6ba70f3ff64" translate="yes" xml:space="preserve">
          <source>Incident reporting resolution &amp;amp; Code of Conduct enforcement</source>
          <target state="translated">사고보고 해결 및 행동 강령 시행</target>
        </trans-unit>
        <trans-unit id="39926c846ddd25391c819a29fabc7871561feccd" translate="yes" xml:space="preserve">
          <source>Include subheadings. They help readers grasp what&amp;rsquo;s coming and return where they left off.</source>
          <target state="translated">부제목을 포함하십시오. 독자가 앞으로 올 내용을 파악하고 중단 한 부분으로 돌아갈 수 있도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="b4bca44476188a1ecb19a525fa3cea9a4f2c6b0a" translate="yes" xml:space="preserve">
          <source>Included in the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function call, we have selected the &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; for each subset of the data (either an integer - &lt;a href=&quot;../reference/arrays.scalars#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; - or a string of characters - &lt;a href=&quot;../reference/arrays.scalars#numpy.unicode_&quot;&gt;&lt;code&gt;numpy.unicode_&lt;/code&gt;&lt;/a&gt;). We have also used the &lt;code&gt;encoding&lt;/code&gt; argument to select &lt;code&gt;utf-8-sig&lt;/code&gt; as the encoding for the file (read more about encoding in the &lt;a href=&quot;https://docs.python.org/3/library/codecs.html#encodings-and-unicode&quot;&gt;official Python documentation&lt;/a&gt;). You can read more about the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function from the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;Reference Documentation&lt;/code&gt;&lt;/a&gt; or from the &lt;a href=&quot;basics.io.genfromtxt&quot;&gt;Basic IO tutorial&lt;/a&gt;.</source>
          <target state="translated">에 포함 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; 의&lt;/a&gt; 함수 호출, 우리는 선택한 &lt;a href=&quot;../reference/generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; 를&lt;/a&gt; 데이터의 각 부분 집합 (- 중 정수에 대한 &lt;a href=&quot;../reference/arrays.scalars#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; - 또는 문자열 - &lt;a href=&quot;../reference/arrays.scalars#numpy.unicode_&quot;&gt; &lt;code&gt;numpy.unicode_&lt;/code&gt; &lt;/a&gt; ). 또한 &lt;code&gt;encoding&lt;/code&gt; 인수를 사용하여 &lt;code&gt;utf-8-sig&lt;/code&gt; 를 파일 인코딩으로 선택했습니다 (인코딩에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/library/codecs.html#encodings-and-unicode&quot;&gt;공식 Python 문서 참조&lt;/a&gt; ). &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;Reference Documentation&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;basics.io.genfromtxt&quot;&gt;기본 IO 자습서&lt;/a&gt; 에서 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt; 함수 에 대한 자세한 내용을 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c1195d8c8b6b9e2d6ec4d935a14c881a29bcc75" translate="yes" xml:space="preserve">
          <source>Incorrect &lt;code&gt;threshold&lt;/code&gt; in &lt;code&gt;np.set_printoptions&lt;/code&gt; raises &lt;code&gt;TypeError&lt;/code&gt; or &lt;code&gt;ValueError&lt;/code&gt;</source>
          <target state="translated">잘못된 &lt;code&gt;threshold&lt;/code&gt; 에 &lt;code&gt;np.set_printoptions&lt;/code&gt; 이 제기 &lt;code&gt;TypeError&lt;/code&gt; 또는 &lt;code&gt;ValueError&lt;/code&gt; 를을</target>
        </trans-unit>
        <trans-unit id="2070997d3a1215cd23a07fdeb2caa1389920935f" translate="yes" xml:space="preserve">
          <source>Increased performance in &lt;code&gt;random.permutation&lt;/code&gt; for multidimensional arrays</source>
          <target state="translated">다차원 배열에 대한 &lt;code&gt;random.permutation&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="e7086e912a42ead51516c8a8180bf48b02a02ed8" translate="yes" xml:space="preserve">
          <source>Incremement the index and the dataptr members of the &lt;em&gt;iterator&lt;/em&gt; to point to the next element of the array. If the array is not (C-style) contiguous, also increment the N-dimensional coordinates array.</source>
          <target state="translated">배열의 다음 요소를 가리 키도록 &lt;em&gt;반복자&lt;/em&gt; 와 인덱스 및 dataptr 멤버를 증가시킵니다 . 배열이 (C 스타일) 연속이 아닌 경우 N 차원 좌표 배열도 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="7a7d2f744a7296cdaea426008f157d69008c6d52" translate="yes" xml:space="preserve">
          <source>Increment items 0 and 1, and increment item 2 twice:</source>
          <target state="translated">항목 0과 1을 늘리고 항목 2를 두 번 늘리십시오.</target>
        </trans-unit>
        <trans-unit id="aa0f6e205ff77646c8e4c26a5cd802d06b0ed1ab" translate="yes" xml:space="preserve">
          <source>Increment the multi-dimensional index by one.</source>
          <target state="translated">다차원 인덱스를 1 씩 증가시킵니다.</target>
        </trans-unit>
        <trans-unit id="1431536c5cec1e86a2b496f9aea15a2431b6da9a" translate="yes" xml:space="preserve">
          <source>Increment the release number in setup.py. Release candidates should have &amp;ldquo;rc1&amp;rdquo; (or &amp;ldquo;rc2&amp;rdquo;, &amp;ldquo;rcN&amp;rdquo;) appended to the X.Y.Z format.</source>
          <target state="translated">setup.py에서 릴리스 번호를 늘리십시오. 릴리스 후보에는 XYZ 형식에 &quot;rc1&quot;(또는 &quot;rc2&quot;, &quot;rcN&quot;)이 추가되어야합니다.</target>
        </trans-unit>
        <trans-unit id="47bbbc7bbd392dc811939b0ca8df290ae66b6625" translate="yes" xml:space="preserve">
          <source>Indeed, the fact is that Python indexing on lists and other sequences naturally leads to an outside-to inside ordering (the first index gets the largest grouping, the next the next largest, and the last gets the smallest element). Since image data are normally stored by rows, this corresponds to position within rows being the last item indexed.</source>
          <target state="translated">사실, 목록과 다른 시퀀스에서 파이썬 인덱싱은 자연적으로 외부에서 내부 순서로 이어진다는 것입니다 (첫 번째 인덱스는 가장 큰 그룹화, 다음은 가장 큰 그룹화, 마지막은 가장 작은 요소). 이미지 데이터는 일반적으로 행별로 저장되므로 마지막으로 색인이 생성 된 행 내의 위치에 해당합니다.</target>
        </trans-unit>
        <trans-unit id="a955748860a9401904eff7aeb318142866860450" translate="yes" xml:space="preserve">
          <source>Independent Streams</source>
          <target state="translated">독립 스트림</target>
        </trans-unit>
        <trans-unit id="c2df9b932637fe9d32a0f16da1c11873398f873d" translate="yes" xml:space="preserve">
          <source>Index</source>
          <target state="translated">Index</target>
        </trans-unit>
        <trans-unit id="9362b6e75e3f28d4a83666c8ba00890a4d410bc7" translate="yes" xml:space="preserve">
          <source>Index arrays</source>
          <target state="translated">인덱스 배열</target>
        </trans-unit>
        <trans-unit id="8b7ef6cce7547dfa6d1e0bda509869536452ee0c" translate="yes" xml:space="preserve">
          <source>Index arrays may be combined with slices. For example:</source>
          <target state="translated">인덱스 배열은 슬라이스와 결합 될 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="c44a201623d0e3d087173369dce55b524d144281" translate="yes" xml:space="preserve">
          <source>Index arrays must be of integer type. Each value in the array indicates which value in the array to use in place of the index. To illustrate:</source>
          <target state="translated">인덱스 배열은 정수 유형이어야합니다. 배열의 각 값은 인덱스 대신 사용할 배열의 값을 나타냅니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1a35691c6c1bb32304626e5515963a9a6c7ec2da" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 (the default) refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">대각선 색인 : 0 (기본값)은 주 대각선을 나타내고 양수 값은 상단 대각선을, 음수 값은 하단 대각선을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="119920061dcb691e0fcbed0a1783c9e871f11ec5" translate="yes" xml:space="preserve">
          <source>Index of the diagonal: 0 refers to the main diagonal, a positive value refers to an upper diagonal, and a negative value to a lower diagonal.</source>
          <target state="translated">대각선의 인덱스 : 0은 주 대각선, 양수 값은 상단 대각선을, 음수 값은 하단 대각선을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="383b324a3291b51f1e54ef9c0d763010fbc5e171" translate="yes" xml:space="preserve">
          <source>IndexError</source>
          <target state="translated">IndexError</target>
        </trans-unit>
        <trans-unit id="57f71bf775773f532dceb2dabadcde07069670df" translate="yes" xml:space="preserve">
          <source>Indexes of the maximal elements of a N-dimensional array:</source>
          <target state="translated">N 차원 배열의 최대 요소의 인덱스 :</target>
        </trans-unit>
        <trans-unit id="c30b085b29907fc8dd1fcc4ba9d8f5fab779ff0b" translate="yes" xml:space="preserve">
          <source>Indexes of the maximum values along an axis.</source>
          <target state="translated">축을 따른 최대 값의 인덱스.</target>
        </trans-unit>
        <trans-unit id="f9b599db4bf0df8d9bbcf7c5db6a037f6e6e69aa" translate="yes" xml:space="preserve">
          <source>Indexes of the minimum values along an axis.</source>
          <target state="translated">축을 따른 최소값의 인덱스.</target>
        </trans-unit>
        <trans-unit id="9951861c21df18489a5872209655d6f9039b5e2a" translate="yes" xml:space="preserve">
          <source>Indexing</source>
          <target state="translated">Indexing</target>
        </trans-unit>
        <trans-unit id="ca22a585bfdf222b22aaead59f3666212fc40ce0" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">인덱싱 &lt;code&gt;x['field-name']&lt;/code&gt; 새 반환 &lt;a href=&quot;../glossary#term-view&quot;&gt;뷰&lt;/a&gt; 와 동일한 형상 인 배열로 &lt;em&gt;(X)를&lt;/em&gt; (필드는 서브 어레이 인 경우는 제외)이지만 데이터 유형의 &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 지정된 필드에있는 데이터의 일부만 포함합니다. 또한 &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;레코드 배열&lt;/a&gt; 스칼라는 이러한 방식으로 &quot;인덱싱&quot;될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b59c12801d6fa741bd0be2abcd90167bf71d161c" translate="yes" xml:space="preserve">
          <source>Indexing &lt;code&gt;x['field-name']&lt;/code&gt; returns a new &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt; to the array, which is of the same shape as &lt;em&gt;x&lt;/em&gt; (except when the field is a sub-array) but of data type &lt;code&gt;x.dtype['field-name']&lt;/code&gt; and contains only the part of the data in the specified field. Also &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record array&lt;/a&gt; scalars can be &amp;ldquo;indexed&amp;rdquo; this way.</source>
          <target state="translated">인덱싱 &lt;code&gt;x['field-name']&lt;/code&gt; 새 반환 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;뷰&lt;/a&gt; 와 동일한 형상 인 배열로 &lt;em&gt;(X)를&lt;/em&gt; (필드는 서브 어레이 인 경우는 제외)이지만 데이터 유형의 &lt;code&gt;x.dtype['field-name']&lt;/code&gt; 지정된 필드에 데이터의 일부만 포함합니다. 또한 &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;레코드 배열&lt;/a&gt; 스칼라를 이런 식으로 &quot;인덱싱&quot;할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9542b665971d159d6c17d4f34752698e601626e8" translate="yes" xml:space="preserve">
          <source>Indexing MaskedArrays/Constants with &lt;code&gt;...&lt;/code&gt; (ellipsis) now returns MaskedArray</source>
          <target state="translated">&lt;code&gt;...&lt;/code&gt; (줄임표)를 사용 하여 MaskedArrays / Constants를 인덱싱하면 이제 MaskedArray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a956de2c65434dac2e3f2395af98a63c09e0e921" translate="yes" xml:space="preserve">
          <source>Indexing Multi-dimensional arrays</source>
          <target state="translated">다차원 배열 인덱싱</target>
        </trans-unit>
        <trans-unit id="d29f8c2cdcd3c7159d7617a4b4b26d63a3389924" translate="yes" xml:space="preserve">
          <source>Indexing Structured Arrays</source>
          <target state="translated">구조화 된 배열 인덱싱</target>
        </trans-unit>
        <trans-unit id="370bbc588e0d38b8f416d5dcc2dcf3fc93d26630" translate="yes" xml:space="preserve">
          <source>Indexing a single element of a structured array (with an integer index) returns a structured scalar:</source>
          <target state="translated">구조화 배열의 단일 요소 (정수 인덱스 사용)를 인덱싱하면 구조화 스칼라가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1544ebdc7ceef1dd43c207ab5e502bb881e63b2a" translate="yes" xml:space="preserve">
          <source>Indexing and Assignment to Structured arrays</source>
          <target state="translated">구조화 된 배열에 대한 인덱싱 및 할당</target>
        </trans-unit>
        <trans-unit id="3b75e279fb5c7684c193076341ad2da99a787445" translate="yes" xml:space="preserve">
          <source>Indexing and slicing</source>
          <target state="translated">인덱싱 및 슬라이싱</target>
        </trans-unit>
        <trans-unit id="c620de8536d4e92665cc1da6338b0e3c9ccd772a" translate="yes" xml:space="preserve">
          <source>Indexing and slicing operations are useful when you&amp;rsquo;re manipulating matrices:</source>
          <target state="translated">인덱싱 및 슬라이싱 작업은 행렬을 조작 할 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="9f16e8a5deb5dca320283bcd174b16dd9a73b2c2" translate="yes" xml:space="preserve">
          <source>Indexing arrays</source>
          <target state="translated">인덱싱 배열</target>
        </trans-unit>
        <trans-unit id="32cfd79e57bf8a3877f833f091f428533e7b10d7" translate="yes" xml:space="preserve">
          <source>Indexing basics</source>
          <target state="translated">인덱싱 기본 사항</target>
        </trans-unit>
        <trans-unit id="1462dc0b9b6cce394c3657c4670ba55a345bb68a" translate="yes" xml:space="preserve">
          <source>Indexing errors will be reported even when index result is empty</source>
          <target state="translated">색인 결과가 비어있는 경우에도 색인 오류가보고됩니다.</target>
        </trans-unit>
        <trans-unit id="43bc37d1483f275b849fa10b51ee75dd7340e249" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">구조화 된 배열로의 인덱싱은 필드 이름 목록 ( &lt;em&gt;예 : &lt;/em&gt; &lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 사용하여 수행 할 수도 있습니다 . NumPy 1.16부터는 해당 필드 만 포함하는 뷰를 반환합니다. 이전 버전의 numpy에서는 복사본을 반환했습니다. 다중 필드 인덱싱에 대한 자세한 내용은 &lt;a href=&quot;../user/basics.rec#structured-arrays&quot;&gt;구조화 된 배열에&lt;/a&gt; 대한 사용자 가이드 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="287cc46fe81b17127e826e2dc4d460f956256411" translate="yes" xml:space="preserve">
          <source>Indexing into a structured array can also be done with a list of field names, &lt;em&gt;e.g.&lt;/em&gt;&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt;. As of NumPy 1.16 this returns a view containing only those fields. In older versions of numpy it returned a copy. See the user guide section on &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt; for more information on multifield indexing.</source>
          <target state="translated">&lt;code&gt;x[['field-name1','field-name2']]&lt;/code&gt; 와 &lt;em&gt;같은&lt;/em&gt; 필드 이름 목록을 사용하여 구조화 된 배열로 인덱싱 할 수도 있습니다 . NumPy 1.16부터는 해당 필드 만 포함하는보기를 리턴합니다. 이전 버전의 numpy에서는 복사본을 반환했습니다. 다중 필드 인덱싱에 대한 자세한 내용은 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/user/basics.rec.html#structured-arrays&quot;&gt;구조적 배열에&lt;/a&gt; 대한 사용자 안내서 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f9931083a6e7f53e9bc486a3df5e5e7c8488e9d6" translate="yes" xml:space="preserve">
          <source>Indexing routines</source>
          <target state="translated">인덱싱 루틴</target>
        </trans-unit>
        <trans-unit id="6e79a0e3c54ea0ceb91b9669283adab9f2147f0b" translate="yes" xml:space="preserve">
          <source>Indexing with Arrays of Indices</source>
          <target state="translated">인덱스 배열로 인덱싱</target>
        </trans-unit>
        <trans-unit id="a5b7926d0e1062fbea55528bbcec6310b0c56043" translate="yes" xml:space="preserve">
          <source>Indexing with Boolean Arrays</source>
          <target state="translated">부울 배열로 인덱싱</target>
        </trans-unit>
        <trans-unit id="3484dfe82dee2e7bac292b6534b5cbe2647cd408" translate="yes" xml:space="preserve">
          <source>Indexing with an Integer to get a Structured Scalar</source>
          <target state="translated">구조화 된 스칼라를 얻기 위해 정수로 인덱싱</target>
        </trans-unit>
        <trans-unit id="090d4c4fc948bc8eed34fc6e8ddf8e7bd5be023c" translate="yes" xml:space="preserve">
          <source>Indexing with strings</source>
          <target state="translated">문자열로 인덱싱</target>
        </trans-unit>
        <trans-unit id="2794b9b37dd0d88704ab33758cd5ea559027c74f" translate="yes" xml:space="preserve">
          <source>Indexing, Slicing and Iterating</source>
          <target state="translated">인덱싱, 슬라이싱 및 반복</target>
        </trans-unit>
        <trans-unit id="a0b6ddf08f9938b1aef1c27a89f039c34d4ed175" translate="yes" xml:space="preserve">
          <source>Indexing-like operations</source>
          <target state="translated">인덱싱 같은 작업</target>
        </trans-unit>
        <trans-unit id="0454b105259e523f13a84d0a1ff2499fbf44bf18" translate="yes" xml:space="preserve">
          <source>Indicate how the user of the iterator will read or write to &lt;code&gt;op[i]&lt;/code&gt;. Exactly one of these flags must be specified per operand. Using &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; or &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; for a user-provided operand may trigger &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; semantics. The data will be written back to the original array when &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; is called.</source>
          <target state="translated">반복자의 사용자가 &lt;code&gt;op[i]&lt;/code&gt; 를 읽거나 쓰는 방법을 나타냅니다 . 피연산자마다 이러한 플래그 중 하나를 지정해야합니다. 사용 &lt;code&gt;NPY_ITER_READWRITE&lt;/code&gt; 또는 &lt;code&gt;NPY_ITER_WRITEONLY&lt;/code&gt; 을 트리거 할 수있는 사용자 제공 피연산자 &lt;code&gt;WRITEBACKIFCOPY`&lt;/code&gt; 의 의미. &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 가 호출 되면 데이터가 원래 배열에 다시 쓰여집니다 .</target>
        </trans-unit>
        <trans-unit id="ba89764e8d83fcb18f052ec54405d196f55000ee" translate="yes" xml:space="preserve">
          <source>Indicate indices of sub-arrays to remove along the specified axis.</source>
          <target state="translated">지정된 축을 따라 제거 할 하위 배열의 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ff289ba1c19ab34e00eb1d52160a46b6efb2713b" translate="yes" xml:space="preserve">
          <source>Indicates arrays of this data-type must be converted to a list before pickling.</source>
          <target state="translated">이 데이터 유형의 배열을 산세하기 전에 목록으로 변환해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="327748da6a9d945d96e091b8e7383b60afba1da7" translate="yes" xml:space="preserve">
          <source>Indicates memory for this data-type must be initialized (set to 0) on creation.</source>
          <target state="translated">작성시이 데이터 유형의 메모리를 초기화 (0으로 설정)해야 함을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="4bc4530525549adc3e6afe819ca6b79c82a0ab71" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with a size of zero should be permitted. Since the typical iteration loop does not naturally work with zero-sized arrays, you must check that the IterSize is larger than zero before entering the iteration loop. Currently only the operands are checked, not a forced shape.</source>
          <target state="translated">크기가 0 인 배열이 허용되어야 함을 나타냅니다. 일반적인 반복 루프는 크기가 0 인 배열에서는 자연스럽게 작동하지 않으므로 반복 루프에 들어가기 전에 IterSize가 0보다 큰지 확인해야합니다. 현재 피연산자 만 검사되며 강제 모양은 검사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3f20ca03a166ca2b12eed667d0c9d43d498dcabe" translate="yes" xml:space="preserve">
          <source>Indicates that arrays with reference types (object arrays or structured arrays containing an object type) may be accepted and used in the iterator. If this flag is enabled, the caller must be sure to check whether &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; is true, in which case it may not release the GIL during iteration.</source>
          <target state="translated">참조 유형 (객체 배열 또는 객체 유형을 포함하는 구조화 된 배열)을 가진 배열이 반복자에서 승인되어 사용될 수 있음을 나타냅니다. 이 플래그를 사용하면 호출자는 &lt;code&gt;NpyIter_IterationNeedsAPI(iter)&lt;/code&gt; 가 true 인지 확인해야하며 ,이 경우 반복 중에 GIL을 해제하지 못할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e809396a40c3ec96fdae3328ed0a31c66576c7c0" translate="yes" xml:space="preserve">
          <source>Indicates that items of this data-type must be reference counted (using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">이 데이터 유형의 항목이 참조 계산되어야 함을 나타냅니다 ( &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; 사용&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="03ad2756a493f01508378680f8d907e50dad0e86" translate="yes" xml:space="preserve">
          <source>Indicates that this operand is the mask to use for selecting elements when writing to operands which have the &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt;&lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt;&lt;/a&gt; flag applied to them. Only one operand may have &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt;&lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt;&lt;/a&gt; flag applied to it.</source>
          <target state="translated">이 피연산자는 요소에 &lt;a href=&quot;#c.NPY_ITER_WRITEMASKED&quot;&gt; &lt;code&gt;NPY_ITER_WRITEMASKED&lt;/code&gt; &lt;/a&gt; 플래그가 적용된 피연산자에 쓸 때 요소를 선택하는 데 사용할 마스크임을 나타냅니다 . 한 피연산자에만 &lt;a href=&quot;#c.NPY_ITER_ARRAYMASK&quot;&gt; &lt;code&gt;NPY_ITER_ARRAYMASK&lt;/code&gt; &lt;/a&gt; 플래그가 적용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="613ac9b34fa48eda3d48ba0a932ba15f0204a86f" translate="yes" xml:space="preserve">
          <source>Indicates the item is a pointer to some other data-type</source>
          <target state="translated">항목이 다른 데이터 유형에 대한 포인터임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6f07bb702873a42eecec00d6bf9d09bfd0c31b06" translate="yes" xml:space="preserve">
          <source>Indicates this data-type requires the Python C-API during access (so don&amp;rsquo;t give up the GIL if array access is going to be needed).</source>
          <target state="translated">이 데이터 유형에 액세스하는 동안 Python C-API가 필요함을 나타냅니다 (따라서 배열 액세스가 필요한 경우 GIL을 포기하지 마십시오).</target>
        </trans-unit>
        <trans-unit id="d5ca13d01e4aee97ba5ebf7dbc18794ab7e82eae" translate="yes" xml:space="preserve">
          <source>Indicating whether the intervals include the right or the left bin edge. Default behavior is (right==False) indicating that the interval does not include the right edge. The left bin end is open in this case, i.e., bins[i-1] &amp;lt;= x &amp;lt; bins[i] is the default behavior for monotonically increasing bins.</source>
          <target state="translated">간격에 오른쪽 또는 왼쪽 빈 가장자리가 포함되는지 여부를 나타냅니다. 기본 동작은 간격이 오른쪽 가장자리를 포함하지 않음을 나타내는 (right == False)입니다. 이 경우 왼쪽 빈 끝이 열려 있습니다. 즉, bins [i-1] &amp;lt;= x &amp;lt;bins [i]는 단조롭게 증가하는 빈의 기본 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ca9cfe4e704c12c6c1fa5c4b576973839a44850c" translate="yes" xml:space="preserve">
          <source>Indices can also be grouped by element.</source>
          <target state="translated">요소별로 인덱스를 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="14ad131012032e9e04ca04f6d1ddd8fbcaa3e2c0" translate="yes" xml:space="preserve">
          <source>Indices for the upper-triangle of &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 의 상위 삼각형에 대한 인덱스입니다 .</target>
        </trans-unit>
        <trans-unit id="05056f495c02c0b518e0436ff12d0703c782c034" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero.</source>
          <target state="translated">0이 아닌 요소의 인덱스.</target>
        </trans-unit>
        <trans-unit id="91841f1f82f1c15d4b5be121831bfdfa7d539a5a" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element.</source>
          <target state="translated">0이 아닌 요소의 인덱스. 인덱스는 요소별로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="7756fd7ee8f7161ab914664d39dc9bedefea080d" translate="yes" xml:space="preserve">
          <source>Indices of elements that are non-zero. Indices are grouped by element. This array will have shape &lt;code&gt;(N, a.ndim)&lt;/code&gt; where &lt;code&gt;N&lt;/code&gt; is the number of non-zero items.</source>
          <target state="translated">0이 아닌 요소의 인덱스입니다. 인덱스는 요소별로 그룹화됩니다. 이 배열은 모양 &lt;code&gt;(N, a.ndim)&lt;/code&gt; 여기서 &lt;code&gt;N&lt;/code&gt; 은 0이 아닌 항목의 수입니다.</target>
        </trans-unit>
        <trans-unit id="b94c56d6a6bfbdfee7bbd9db799f4cac5be86fa1" translate="yes" xml:space="preserve">
          <source>Indices of the minimum elements of a N-dimensional array:</source>
          <target state="translated">N 차원 배열의 최소 요소 인덱스 :</target>
        </trans-unit>
        <trans-unit id="764406c1c2d21f5c9a93e6d3d66afbc9de92b722" translate="yes" xml:space="preserve">
          <source>Indices of the sorted elements of a N-dimensional array:</source>
          <target state="translated">N 차원 배열의 정렬 된 요소 인덱스 :</target>
        </trans-unit>
        <trans-unit id="d010fa85fcc511735fc1ba118d8c9fa77c46fb33" translate="yes" xml:space="preserve">
          <source>Indices to change along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions in Ni and Nj may be 1 to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 의 각 1d 슬라이스를 따라 변경되는 인덱스 입니다. 이 편곡의 크기와 일치해야하지만, 니켈과 뉴저지의 치수에 대한 방송을 일을 할 수있다 &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd4ed66b25e3e81f7c09020b3e15317e8ebab751" translate="yes" xml:space="preserve">
          <source>Indices to take along each 1d slice of &lt;code&gt;arr&lt;/code&gt;. This must match the dimension of arr, but dimensions Ni and Nj only need to broadcast against &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 의 각 1d 슬라이스를 따라갈 인덱스 입니다. 이 편곡의 크기와 일치해야하지만, 크기 Ni 및 뉴저지 만에 방송에 필요한 &lt;code&gt;arr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dfac1d76acfef8a43ec3bb5c63e278bd2c2aa5a" translate="yes" xml:space="preserve">
          <source>Indirect partial sort.</source>
          <target state="translated">간접적 인 부분 정렬.</target>
        </trans-unit>
        <trans-unit id="67b91131b038b258475621be16da6d4bad633d9d" translate="yes" xml:space="preserve">
          <source>Indirect partition.</source>
          <target state="translated">간접 파티션.</target>
        </trans-unit>
        <trans-unit id="ceed8c74919b3d66cbcd799fe2d4bb252d0af6a7" translate="yes" xml:space="preserve">
          <source>Indirect sort.</source>
          <target state="translated">간접 정렬.</target>
        </trans-unit>
        <trans-unit id="7a7f09efc9fe3734b3bf1afc86adc2e542a21680" translate="yes" xml:space="preserve">
          <source>Indirect stable sort on multiple keys.</source>
          <target state="translated">여러 키에 대한 안정적인 안정적인 정렬</target>
        </trans-unit>
        <trans-unit id="80cc0e6eec2203fc2c38742d008a3fb864036a7b" translate="yes" xml:space="preserve">
          <source>Indirect stable sort with multiple keys.</source>
          <target state="translated">여러 키를 사용한 간접 안정적인 정렬.</target>
        </trans-unit>
        <trans-unit id="f2d326af87bc022a272e7d1fdc4716803c23e396" translate="yes" xml:space="preserve">
          <source>Individual fields of a structured array may be accessed and modified by indexing the array with the field name.</source>
          <target state="translated">구조화 된 배열의 개별 필드는 필드 이름으로 배열을 인덱싱하여 액세스하고 수정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8e9e048443c76eaece9af376ed6551264b94a4e9" translate="yes" xml:space="preserve">
          <source>Individual values are not stripped of spaces by default. When using a custom converter, make sure the function does remove spaces.</source>
          <target state="translated">개별 값은 기본적으로 공백이 제거되지 않습니다. 사용자 정의 변환기를 사용할 때 함수가 공백을 제거하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5888912f1820a7f863f2cf1064c7ab5b1a9a9baa" translate="yes" xml:space="preserve">
          <source>Individuals come from different cultural backgrounds and native languages. Try to identify any honest misunderstandings caused by a non-native speaker and help them understand the issue and what they can change to avoid causing offence. Complex discussion in a foreign language can be very intimidating, and we want to grow our diversity also across nationalities and cultures.</source>
          <target state="translated">개인은 서로 다른 문화적 배경과 모국어를 가지고 있습니다. 원어민이 아닌 사람으로 인해 발생한 정직한 오해를 식별하고 문제를 이해하고 위반을 피하기 위해 변경할 수있는 사항을 이해하도록 돕습니다. 외국어로 된 복잡한 토론은 매우 위협적 일 수 있으며, 우리는 국적과 문화에 걸쳐 다양성을 키우고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="f5284e6b831163b2d6ffbcfab454c705546fdd5b" translate="yes" xml:space="preserve">
          <source>Inexact matches for &lt;code&gt;mode&lt;/code&gt; and &lt;code&gt;searchside&lt;/code&gt; are deprecated</source>
          <target state="translated">&lt;code&gt;mode&lt;/code&gt; 및 검색 &lt;code&gt;searchside&lt;/code&gt; 대한 정확하지 않은 일치 는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6e461615b9c8d1c487d2584ede06e5dc724ae1a4" translate="yes" xml:space="preserve">
          <source>Inexact types</source>
          <target state="translated">정확하지 않은 유형</target>
        </trans-unit>
        <trans-unit id="a28ed132c608e3b4681e944b25690757eebfc33f" translate="yes" xml:space="preserve">
          <source>Inf (in module numpy)</source>
          <target state="translated">Inf (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="5b675f1c2537bc4e7587a11173af58141e3f3972" translate="yes" xml:space="preserve">
          <source>Infinity (in module numpy)</source>
          <target state="translated">무한대 (numpy 모듈)</target>
        </trans-unit>
        <trans-unit id="fbf064be21246c8a34df5396396140e055f24f53" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt; function in &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">정보는 &lt;a href=&quot;distutils/misc_util#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; 의 &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; &lt;/a&gt; 함수에서 쉽게 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ecae1f8d30472c9a7f54d4130dc7c3b85605f125" translate="yes" xml:space="preserve">
          <source>Info are easily retrieved from the &lt;code&gt;get_info&lt;/code&gt; function in &lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt;&lt;code&gt;numpy.distutils.misc_util&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#module-numpy.distutils.misc_util&quot;&gt; &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;get_info&lt;/code&gt; 함수에서 정보를 쉽게 검색 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce47f6aad749dde8c374d70dfb4bb3378d690b1b" translate="yes" xml:space="preserve">
          <source>Information (via the dtype object) about the interpretation of the basic data element. The basic data element may be as simple as a int or a float, or it may be a compound object (e.g., struct-like), a fixed character field, or Python object pointers.</source>
          <target state="translated">기본 데이터 요소의 해석에 대한 정보 (dtype 객체를 통해) 기본 데이터 요소는 int 또는 float만큼 간단하거나 복합 객체 (예 : struct-like), 고정 문자 필드 또는 Python 객체 포인터 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bfbba3e12af5ea2c7741d834d66f7c560456f725" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;구조화 된 데이터 유형의&lt;/a&gt; 하위 데이터 유형에 대한 정보 :</target>
        </trans-unit>
        <trans-unit id="87749b5a0427424240dbd899baaf24bccac8d963" translate="yes" xml:space="preserve">
          <source>Information about sub-data-types in a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;구조화 된 데이터 유형의&lt;/a&gt; 하위 데이터 유형에 대한 정보 :</target>
        </trans-unit>
        <trans-unit id="feb91fe9e3a82284bbc774141950eade27079231" translate="yes" xml:space="preserve">
          <source>Information about the memory layout of the array.</source>
          <target state="translated">배열의 메모리 레이아웃에 대한 정보</target>
        </trans-unit>
        <trans-unit id="6c6da40785b1a9277377a0ac6b35aa661e1efec5" translate="yes" xml:space="preserve">
          <source>Information may include:</source>
          <target state="translated">정보에는 다음이 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3e4c562ef15584e2226342046a4759c392aba8" translate="yes" xml:space="preserve">
          <source>Inherits?</source>
          <target state="translated">Inherits?</target>
        </trans-unit>
        <trans-unit id="b590718892221849c4b4d49b1a5feaa2b8ce90e3" translate="yes" xml:space="preserve">
          <source>Initialize all function pointers and members to &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">모든 함수 포인터와 멤버를 &lt;code&gt;NULL&lt;/code&gt; 로 초기화하십시오 .</target>
        </trans-unit>
        <trans-unit id="32bc5b2fd4039aefa8f94877a70e63431f9d15f4" translate="yes" xml:space="preserve">
          <source>Inner product</source>
          <target state="translated">내부 제품</target>
        </trans-unit>
        <trans-unit id="1dba54e0b565dd813bcf7f4dd26137c8252036b6" translate="yes" xml:space="preserve">
          <source>Inner product of two arrays.</source>
          <target state="translated">두 어레이의 내부 제품.</target>
        </trans-unit>
        <trans-unit id="064057f93ed4cdc0c2704e960d9c6d25cbbcac22" translate="yes" xml:space="preserve">
          <source>Inplace partition.</source>
          <target state="translated">대체 파티션.</target>
        </trans-unit>
        <trans-unit id="5afc0baf08aba247f1b2f3cdc0980c0ea2b6e83d" translate="yes" xml:space="preserve">
          <source>Inplace sort.</source>
          <target state="translated">적절한 정렬.</target>
        </trans-unit>
        <trans-unit id="d72a097ccb9c0003ebff6189ebb422b954b438f2" translate="yes" xml:space="preserve">
          <source>Input 1-D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">입력 1D &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="80930bf11175241ae29fe59d0d272e2dd3fda246" translate="yes" xml:space="preserve">
          <source>Input &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; for which the mask is required.</source>
          <target state="translated">마스크가 필요한 입력 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="abfa0de453f55ea46910c5cb072561c46c566eda" translate="yes" xml:space="preserve">
          <source>Input &lt;code&gt;MaskedArray&lt;/code&gt;, alternatively a ndarray or a subclass thereof.</source>
          <target state="translated">Input &lt;code&gt;MaskedArray&lt;/code&gt; , 또는 ndarray 또는 해당 서브 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ef6caaf1ffac65c55e3879237f23b9e4cd5b35fe" translate="yes" xml:space="preserve">
          <source>Input Arrays</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="c77783bb0c7d4d2f9b2b8bd6478b069981c0866f" translate="yes" xml:space="preserve">
          <source>Input and output</source>
          <target state="translated">입력과 출력</target>
        </trans-unit>
        <trans-unit id="43fab0b785a955e5195e8f3f11f33f3ad7b432bc" translate="yes" xml:space="preserve">
          <source>Input argument, can be of any type and shape.</source>
          <target state="translated">입력 인수는 모든 유형과 모양이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df78d5709935001a8bf74fe47ed30fca9beafae5" translate="yes" xml:space="preserve">
          <source>Input array</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="d573fb86d82f5065edfc4ca49f5112f03928d672" translate="yes" xml:space="preserve">
          <source>Input array in degrees.</source>
          <target state="translated">배열을도 단위로 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="c7b020a842b9509ee12f3acbb189d43b5a5c8e2b" translate="yes" xml:space="preserve">
          <source>Input array in radians.</source>
          <target state="translated">라디안으로 입력 배열.</target>
        </trans-unit>
        <trans-unit id="f139b5d61b47039d6645fe901089b8d7348e059e" translate="yes" xml:space="preserve">
          <source>Input array of size 1.</source>
          <target state="translated">크기가 1 인 입력 배열.</target>
        </trans-unit>
        <trans-unit id="4fabb62ebf0299b3a11dc8870c6ebb3a76ef6ff9" translate="yes" xml:space="preserve">
          <source>Input array of strings to capitalize.</source>
          <target state="translated">대문자로 입력 할 문자열 배열을 입력하십시오.</target>
        </trans-unit>
        <trans-unit id="8088eb90e795502e434844cfa6cdf9e95d4c9437" translate="yes" xml:space="preserve">
          <source>Input array of the same size as &lt;code&gt;condition&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 과 크기가 같은 입력 배열 .</target>
        </trans-unit>
        <trans-unit id="f46407fd3e6fc3c69904fb1af7940d31883ac983" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored</source>
          <target state="translated">무시할 nan 값을 포함하는 배열로 변환 될 수있는 입력 배열 또는 객체</target>
        </trans-unit>
        <trans-unit id="49d0fb63038b2721f65a3fb79be1b2a9aa62e9d2" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array, containing nan values to be ignored.</source>
          <target state="translated">무시할 nan 값을 포함하는 배열로 변환 할 수있는 입력 배열 또는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="1e12f84194e4961e84959b469b0f8a65e2620351" translate="yes" xml:space="preserve">
          <source>Input array or object that can be converted to an array.</source>
          <target state="translated">배열로 변환 할 수있는 입력 배열 또는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="a14df91a899a43d15ec0d5b0ebc8a2a56f832cef" translate="yes" xml:space="preserve">
          <source>Input array to be binned. Prior to NumPy 1.10.0, this array had to be 1-dimensional, but can now have any shape.</source>
          <target state="translated">비닝 할 입력 배열입니다. NumPy 1.10.0 이전에는이 ​​배열이 1 차원이어야했지만 이제는 모든 모양을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bf15a8f66c7dacebdd89b7241fd4d11919829ad3" translate="yes" xml:space="preserve">
          <source>Input array to compute determinants for.</source>
          <target state="translated">행렬식을 계산할 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="9eff9d201dcac2141e1679ca23a312d5c7800681" translate="yes" xml:space="preserve">
          <source>Input array to extend.</source>
          <target state="translated">확장 할 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7e287445198fc945368949e1412f5d8cb686139f" translate="yes" xml:space="preserve">
          <source>Input array to integrate.</source>
          <target state="translated">통합 할 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="85b9cb3f5f032dd1e9e0718bbfaa4576f72e78eb" translate="yes" xml:space="preserve">
          <source>Input array whose fields must be modified.</source>
          <target state="translated">필드를 수정해야하는 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="42226304be73817a4e285cb433d2b7bb659c59a4" translate="yes" xml:space="preserve">
          <source>Input array with datetime or timedelta data type.</source>
          <target state="translated">datetime 또는 timedelta 데이터 형식의 입력 배열입니다.</target>
        </trans-unit>
        <trans-unit id="7c1847566b14607f43160463914cca58e1d1e0d6" translate="yes" xml:space="preserve">
          <source>Input array, a (subclass of) ndarray.</source>
          <target state="translated">입력 배열, ndarray의 (하위 클래스)</target>
        </trans-unit>
        <trans-unit id="a4f57e9a75e6d26f7e8f35eb55623a7c6ae8a1b9" translate="yes" xml:space="preserve">
          <source>Input array, can be complex</source>
          <target state="translated">입력 배열, 복잡 할 수 있음</target>
        </trans-unit>
        <trans-unit id="1b7a137c8182cfa54895f3372cda87fe7e3932e7" translate="yes" xml:space="preserve">
          <source>Input array, can be complex.</source>
          <target state="translated">입력 배열은 복잡 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6d76cf24117a4b5288f54769d468e637657f37e2" translate="yes" xml:space="preserve">
          <source>Input array, from which the diagonals are taken.</source>
          <target state="translated">대각선을 가져 오는 입력 배열.</target>
        </trans-unit>
        <trans-unit id="2204886fc1fe79484a18e95229b508e3a16d8a88" translate="yes" xml:space="preserve">
          <source>Input array, has to be a square 2-D array.</source>
          <target state="translated">입력 배열은 정사각형 2 차원 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4e7ee35a9b27cc189fd5faf36b937d455a1aa919" translate="yes" xml:space="preserve">
          <source>Input array, must be at least 2-D.</source>
          <target state="translated">입력 배열은 2D 이상이어야합니다.</target>
        </trans-unit>
        <trans-unit id="b7ba46399772c3a420055c71f8f5dda1e65da7f0" translate="yes" xml:space="preserve">
          <source>Input array, taken to be real.</source>
          <target state="translated">실제 입력 배열.</target>
        </trans-unit>
        <trans-unit id="16ca749420dd58126c1f3f4ccf95ce2fc49387c9" translate="yes" xml:space="preserve">
          <source>Input array.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="05370e4965d51e56f1347351509792a8c2d8443c" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D, unless &lt;code&gt;ord&lt;/code&gt; is None. If both &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;ord&lt;/code&gt; are None, the 2-norm of &lt;code&gt;x.ravel&lt;/code&gt; will be returned.</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;axis&lt;/code&gt; 것도없고, &lt;code&gt;x&lt;/code&gt; 않는, 1-D 또는 2-D이어야 &lt;code&gt;ord&lt;/code&gt; 포함되지 않은 경우. 두 경우 &lt;code&gt;axis&lt;/code&gt; 과 &lt;code&gt;ord&lt;/code&gt; 아무도 없다,의 2 규범 &lt;code&gt;x.ravel&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e22a13f0e68b42a409027fe2f016234b4ec5feb3" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;x&lt;/code&gt; must be 1-D or 2-D.</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;axis&lt;/code&gt; 것도없고, &lt;code&gt;x&lt;/code&gt; 1-D 또는 2-D이어야한다.</target>
        </trans-unit>
        <trans-unit id="a823c846105b9c9719fbae89a64d485cac5a4b66" translate="yes" xml:space="preserve">
          <source>Input array. If &lt;code&gt;sorter&lt;/code&gt; is None, then it must be sorted in ascending order, otherwise &lt;code&gt;sorter&lt;/code&gt; must be an array of indices that sort it.</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;sorter&lt;/code&gt; 없음입니다, 그렇지 않으면, 오름차순으로 정렬해야 &lt;code&gt;sorter&lt;/code&gt; 는 그런 종류의 인덱스의 배열이어야합니다.</target>
        </trans-unit>
        <trans-unit id="9358104d5c139fb6025e6e3c499456297f4494b9" translate="yes" xml:space="preserve">
          <source>Input array. It must conform to the Python-side of the array interface.</source>
          <target state="translated">입력 배열. 배열 인터페이스의 Python 측을 준수해야합니다.</target>
        </trans-unit>
        <trans-unit id="6eef0d989b2fd6fdf464d508f694dc4a0a6a6caa" translate="yes" xml:space="preserve">
          <source>Input array. The elements in &lt;code&gt;a&lt;/code&gt; are read in the order specified by &lt;code&gt;order&lt;/code&gt;, and packed as a 1-D array.</source>
          <target state="translated">입력 배열. 의 요소 &lt;code&gt;a&lt;/code&gt; 에 의해 지정된 순서대로 판독 &lt;code&gt;order&lt;/code&gt; 및 1-D 어레이로 포장.</target>
        </trans-unit>
        <trans-unit id="88c5aa449f45fc85917596c4004dffe23e0b86ac" translate="yes" xml:space="preserve">
          <source>Input array. Unless &lt;code&gt;axis&lt;/code&gt; is specified, this will be flattened if it is not already 1-D.</source>
          <target state="translated">입력 배열. &lt;code&gt;axis&lt;/code&gt; 이 지정되어 있지 않으면 1D가 아닌 경우 평평하게됩니다.</target>
        </trans-unit>
        <trans-unit id="c937c57a4f225878ef9dec01334ff4466710291e" translate="yes" xml:space="preserve">
          <source>Input arrays</source>
          <target state="translated">입력 배열</target>
        </trans-unit>
        <trans-unit id="d4ab162cfec9e7e5f511b1323f2a38dced9855a6" translate="yes" xml:space="preserve">
          <source>Input arrays are defined as arrays of data that are passed into a routine but are not altered in-place or returned to the user. The Python input array is therefore allowed to be almost any Python sequence (such as a list) that can be converted to the requested type of array. The input array signatures are</source>
          <target state="translated">입력 배열은 루틴으로 전달되지만 그 자리에서 변경되거나 사용자에게 반환되지 않는 데이터 배열로 정의됩니다. 따라서 Python 입력 배열은 요청 된 배열 유형으로 변환 할 수있는 거의 모든 Python 시퀀스 (예 : 목록) 일 수 있습니다. 입력 배열 서명은</target>
        </trans-unit>
        <trans-unit id="098168471a46df6606b6ff9c9cd3ead3422de613" translate="yes" xml:space="preserve">
          <source>Input arrays of the same shape.</source>
          <target state="translated">같은 모양의 입력 배열.</target>
        </trans-unit>
        <trans-unit id="27f64d53a246ed11a85c01a61d0a931b1d50a817" translate="yes" xml:space="preserve">
          <source>Input arrays to be compared.</source>
          <target state="translated">비교할 입력 배열.</target>
        </trans-unit>
        <trans-unit id="6fed91f1bcdfc2569325e9089bbd325328b5c5e9" translate="yes" xml:space="preserve">
          <source>Input arrays to be multiplied. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">곱할 입력 배열입니다. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="4a8e2cbe86fa87773992dad5fc91ec0f376d5ef6" translate="yes" xml:space="preserve">
          <source>Input arrays to compare.</source>
          <target state="translated">비교할 입력 배열.</target>
        </trans-unit>
        <trans-unit id="66d649cf79701276da2a390f23e474c6ab2aff7f" translate="yes" xml:space="preserve">
          <source>Input arrays, scalars not allowed.</source>
          <target state="translated">입력 배열, 스칼라는 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="556a7ea15ff0974e693ba20b38993284bf2034ec" translate="yes" xml:space="preserve">
          <source>Input arrays.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="ad9b94d855384626461316d89dd8037bff8db7bd" translate="yes" xml:space="preserve">
          <source>Input arrays. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">입력 배열. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="d784452f6247a01f2c79aa8a172590665da159e0" translate="yes" xml:space="preserve">
          <source>Input arrays. They are flattened if they are not already 1D.</source>
          <target state="translated">입력 배열. 아직 1D가 아닌 경우 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="e48eae13547040a1f74bd1dc543d4762a4b7970d" translate="yes" xml:space="preserve">
          <source>Input arrays. Will be flattened if not already 1D.</source>
          <target state="translated">입력 배열. 아직 1D가 아닌 경우 전개됩니다.</target>
        </trans-unit>
        <trans-unit id="670ce16c58ae415abf92889322038709e2fa68ca" translate="yes" xml:space="preserve">
          <source>Input cash flows per time period. By convention, net &amp;ldquo;deposits&amp;rdquo; are negative and net &amp;ldquo;withdrawals&amp;rdquo; are positive. Thus, for example, at least the first element of &lt;code&gt;values&lt;/code&gt;, which represents the initial investment, will typically be negative.</source>
          <target state="translated">기간 당 입력 현금 흐름. 일반적으로 순 &quot;예금&quot;은 음수이고 순 &quot;인출&quot;은 양수입니다. 따라서, 예를 들어, 초기 투자를 나타내는 적어도 제 1 &lt;code&gt;values&lt;/code&gt; 요소 는 전형적으로 음일 것이다.</target>
        </trans-unit>
        <trans-unit id="00f0d4d4fb6b101c2c16fbc5749470d99cd4de8c" translate="yes" xml:space="preserve">
          <source>Input class. If a tuple of classes, True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of any of the tuple elements.</source>
          <target state="translated">입력 클래스. 클래스의 튜플 인 경우 &lt;code&gt;arg1&lt;/code&gt; 이 튜플 요소의 하위 클래스 인 경우 True가 반환됩니다 .</target>
        </trans-unit>
        <trans-unit id="2bad44bea0aeffb47c89150e3263bb8f1abd9181" translate="yes" xml:space="preserve">
          <source>Input class. True is returned if &lt;code&gt;arg1&lt;/code&gt; is a subclass of &lt;code&gt;arg2&lt;/code&gt;.</source>
          <target state="translated">입력 클래스. &lt;code&gt;arg1&lt;/code&gt; 이 &lt;code&gt;arg2&lt;/code&gt; 의 서브 클래스 인 경우 True가 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="56f0cc662add4c7f0901841588673883d4d29d17" translate="yes" xml:space="preserve">
          <source>Input comparison array.</source>
          <target state="translated">입력 비교 배열.</target>
        </trans-unit>
        <trans-unit id="64be30841013bc47e9c3850c4b6a7fded4a86ac4" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to a masked array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists, ndarrays and masked arrays.</source>
          <target state="translated">마스크 배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록, ndarray 및 마스크 배열이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="81eacae9b22a55fbd594cc3dd8bc53a24b4e16f7" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터</target>
        </trans-unit>
        <trans-unit id="2ed4e1316aa603c005ccf7b9b354de1cad7aa423" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록 및 ndarray가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="c935f3a4d2949a1b2d5a11eb7de8a0fed4bd8dc0" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes lists, lists of tuples, tuples, tuples of tuples, tuples of lists and ndarrays. Success requires no NaNs or Infs.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록 및 ndarray가 포함됩니다. 성공에는 NaN이나 Infs가 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ebe3314c250fe9acc710492a54a53defc42ce5bf" translate="yes" xml:space="preserve">
          <source>Input data, in any form that can be converted to an array. This includes scalars, lists, lists of tuples, tuples, tuples of tuples, tuples of lists, and ndarrays.</source>
          <target state="translated">배열로 변환 할 수있는 모든 형식의 입력 데이터 여기에는 스칼라, 목록, 튜플 목록, 튜플, 튜플 튜플, 튜플 목록 및 ndarray가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d430a3ba769bee8e9797da35defb2f32aa2749a3" translate="yes" xml:space="preserve">
          <source>Input data, which is flattened and set as the &lt;code&gt;k&lt;/code&gt;-th diagonal of the output.</source>
          <target state="translated">평평하게되어 입력의 &lt;code&gt;k&lt;/code&gt; 번째 대각선으로 설정되는 입력 데이터 .</target>
        </trans-unit>
        <trans-unit id="260753716624ad2077f13f38ada17a33c0f48cba" translate="yes" xml:space="preserve">
          <source>Input data.</source>
          <target state="translated">입력 데이터.</target>
        </trans-unit>
        <trans-unit id="110e3a721161e503e06852d0b67d62808bcf14b0" translate="yes" xml:space="preserve">
          <source>Input data. If a string, variables in the current scope may be referenced by name.</source>
          <target state="translated">입력 데이터. 문자열 인 경우 현재 범위의 변수는 이름으로 참조 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="50ef3fe01b042bdbfb18f290684475887aff6e69" translate="yes" xml:space="preserve">
          <source>Input data. The histogram is computed over the flattened array.</source>
          <target state="translated">입력 데이터. 히스토그램은 평평한 배열을 통해 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="479157011c9bc4b0c174d6c627dd634e47f423a6" translate="yes" xml:space="preserve">
          <source>Input datatype</source>
          <target state="translated">입력 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c3661c49bb4714e36d1ea68c6778013ac4b2c966" translate="yes" xml:space="preserve">
          <source>Input masks.</source>
          <target state="translated">입력 마스크.</target>
        </trans-unit>
        <trans-unit id="49c6112477838697a8b42892713d1ff818dab05e" translate="yes" xml:space="preserve">
          <source>Input must be an ndarray (or have similar attributes) for it to be considered a valid mask.</source>
          <target state="translated">입력이 유효한 마스크로 간주 되려면 ndarray이거나 유사한 속성을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="cdda590be17222720d3dca31ac32ec20a4bd2027" translate="yes" xml:space="preserve">
          <source>Input object or name to get information about. If &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; is a numpy object, its docstring is given. If it is a string, available modules are searched for matching objects. If None, information about &lt;a href=&quot;#numpy.info&quot;&gt;&lt;code&gt;info&lt;/code&gt;&lt;/a&gt; itself is returned.</source>
          <target state="translated">정보를 얻을 객체 또는 이름을 입력하십시오. 경우 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; NumPy와 목적, 그 문서화 문자열이 주어진다. 문자열 인 경우 사용 가능한 모듈에서 일치하는 객체를 검색합니다. None이면 &lt;a href=&quot;#numpy.info&quot;&gt; &lt;code&gt;info&lt;/code&gt; &lt;/a&gt; 자체 에 대한 정보 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="1412dec2d6e9b98e67083c400ddbdc1693058e9a" translate="yes" xml:space="preserve">
          <source>Input object. See Notes for details on how various input types are treated.</source>
          <target state="translated">입력 개체입니다. 다양한 입력 유형이 처리되는 방법에 대한 자세한 내용은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="884c8a0c5d0944c72ee0463c3eae0abb376b5e70" translate="yes" xml:space="preserve">
          <source>Input object. This can be any object (function, class, module, &amp;hellip;).</source>
          <target state="translated">입력 객체. 이것은 어떤 객체 (함수, 클래스, 모듈 등) 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bf2f1c9ba1965ca26f274218714e854f9f8439e" translate="yes" xml:space="preserve">
          <source>Input parameters.</source>
          <target state="translated">입력 매개 변수.</target>
        </trans-unit>
        <trans-unit id="f281e3f644ef1c6e22e0e862f4156eee5c382d75" translate="yes" xml:space="preserve">
          <source>Input polynomials.</source>
          <target state="translated">다항식을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="d68cab221829e2198b605b4996fba557e5ff14b8" translate="yes" xml:space="preserve">
          <source>Input sequences.</source>
          <target state="translated">입력 순서.</target>
        </trans-unit>
        <trans-unit id="103b73f8b8612de7f92ed544d130aab2ccb3dead" translate="yes" xml:space="preserve">
          <source>Input value.</source>
          <target state="translated">입력 값.</target>
        </trans-unit>
        <trans-unit id="cf14e71217c8a7f10324a53bd5825d3d1b8701ee" translate="yes" xml:space="preserve">
          <source>Input values</source>
          <target state="translated">입력 값</target>
        </trans-unit>
        <trans-unit id="4191049318f63b6c3a85211b91a5c1cecb649bdb" translate="yes" xml:space="preserve">
          <source>Input values.</source>
          <target state="translated">입력 값.</target>
        </trans-unit>
        <trans-unit id="07feb5a3916677b58c8f1860e3f940ccc64ab2f3" translate="yes" xml:space="preserve">
          <source>Input values. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">입력 값. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="75826edc2e28e338fe2b7ee2851bc98b65454f08" translate="yes" xml:space="preserve">
          <source>Input vector or stack of matrices.</source>
          <target state="translated">입력 벡터 또는 행렬 스택.</target>
        </trans-unit>
        <trans-unit id="31df6d6470f1b56cda7e136be4be3e1c6dd63188" translate="yes" xml:space="preserve">
          <source>Input-only, in-place, argout, argoutview, and memory managed argoutview behavior.</source>
          <target state="translated">입력 전용, 전체, argout, argoutview 및 메모리 관리 argoutview 동작.</target>
        </trans-unit>
        <trans-unit id="f0c077a272f1db74eb4547826e2fa78b80131915" translate="yes" xml:space="preserve">
          <source>Inputs array.</source>
          <target state="translated">입력 배열.</target>
        </trans-unit>
        <trans-unit id="35b236db313f77f4ec031a91db5c8c986efb6cc5" translate="yes" xml:space="preserve">
          <source>Inputs arrays.</source>
          <target state="translated">배열을 입력합니다.</target>
        </trans-unit>
        <trans-unit id="b698f1874b3f648c9ca7483478e5a5187dbc4214" translate="yes" xml:space="preserve">
          <source>Insert a new axis that will appear at the &lt;code&gt;axis&lt;/code&gt; position in the expanded array shape.</source>
          <target state="translated">확장 배열 모양으로 &lt;code&gt;axis&lt;/code&gt; 위치에 나타날 새 축을 삽입하십시오 .</target>
        </trans-unit>
        <trans-unit id="af781fb10a00be46a34d9311756bc61e0afddfa8" translate="yes" xml:space="preserve">
          <source>Insert elements into an array.</source>
          <target state="translated">배열에 요소를 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="62cc157d912a7ebc384c4d505230255340ab3ae0" translate="yes" xml:space="preserve">
          <source>Insert scalar into an array (scalar is cast to array&amp;rsquo;s dtype, if possible)</source>
          <target state="translated">스칼라를 배열에 삽입하십시오 (가능한 경우 스칼라가 배열의 dtype으로 캐스트 됨)</target>
        </trans-unit>
        <trans-unit id="6f263a0b1fde8fabbe156179a3331b4bc254ecbf" translate="yes" xml:space="preserve">
          <source>Insert values along the given axis before the given indices.</source>
          <target state="translated">주어진 인덱스 앞에 주어진 축을 따라 값을 삽입하십시오.</target>
        </trans-unit>
        <trans-unit id="6c05692f04b1e8c9bcb190b107c8a7b51796744b" translate="yes" xml:space="preserve">
          <source>Insert, remove, and combine dimensions, and resize existing ones</source>
          <target state="translated">치수 삽입, 제거 및 결합 및 기존 크기 조정</target>
        </trans-unit>
        <trans-unit id="5ca6174fce3b04b3d69345d6264017af5ed2d820" translate="yes" xml:space="preserve">
          <source>Inserted between elements.</source>
          <target state="translated">요소 사이에 삽입됩니다.</target>
        </trans-unit>
        <trans-unit id="e6afa88e6a63d5a7ba7fb743473b463e1d9a17d0" translate="yes" xml:space="preserve">
          <source>Inserting data into arrays</source>
          <target state="translated">배열에 데이터 삽입</target>
        </trans-unit>
        <trans-unit id="0f2b8c85b4203c61d3146e95e582c267d771f003" translate="yes" xml:space="preserve">
          <source>Inserting directives in Fortran source</source>
          <target state="translated">Fortran 소스에 지시문 삽입</target>
        </trans-unit>
        <trans-unit id="d078b8bceaffb54addedcd30ef388e1bc3bf477b" translate="yes" xml:space="preserve">
          <source>Inserts newlines if text is longer than &lt;code&gt;max_line_width&lt;/code&gt;. Defaults to &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt;.</source>
          <target state="translated">텍스트가 &lt;code&gt;max_line_width&lt;/code&gt; 보다 긴 경우 줄 바꿈을 삽입합니다 . 기본값은 &lt;code&gt;numpy.get_printoptions()['linewidth']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="512c14336bae01c78c358939c0fa3a2e95db7538" translate="yes" xml:space="preserve">
          <source>Inside the block to be repeated, the variables that should be expanded are specified as &lt;code&gt;@name@&lt;/code&gt;.</source>
          <target state="translated">반복 될 블록 내에서 확장되어야하는 변수는 &lt;code&gt;@name@&lt;/code&gt; 로 지정됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e503f860ac4f65121fead950747f4fcea390ed6" translate="yes" xml:space="preserve">
          <source>Inspecting the array</source>
          <target state="translated">배열 검사</target>
        </trans-unit>
        <trans-unit id="60da80156a5d0a6bae59ac9116ec4cab69c6184c" translate="yes" xml:space="preserve">
          <source>Install git</source>
          <target state="translated">git 설치</target>
        </trans-unit>
        <trans-unit id="c81b79df3c6448eae7c4f80428b54cd5692a17d7" translate="yes" xml:space="preserve">
          <source>Installation</source>
          <target state="translated">Installation</target>
        </trans-unit>
        <trans-unit id="b8e853cc56e81f34b9860e59d86983f00754c7d4" translate="yes" xml:space="preserve">
          <source>Installation of the new package is easy using:</source>
          <target state="translated">다음을 사용하여 새 패키지를 쉽게 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2b894e265fdd7f5a67dff5c1fc33dcfbd31481f9" translate="yes" xml:space="preserve">
          <source>Installing NumPy</source>
          <target state="translated">NumPy 설치</target>
        </trans-unit>
        <trans-unit id="aee4fe0a13da73153ed829e66d85c46397091399" translate="yes" xml:space="preserve">
          <source>Instances of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; subclasses are passed through as-is:</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 서브 클래스의 인스턴스는있는 그대로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="449be076c28f2ad0824dc5cabdcb20c6b823dcf2" translate="yes" xml:space="preserve">
          <source>Instances of classes that are part of the NumPy API (for example &lt;code&gt;np.r_&lt;/code&gt;&lt;code&gt;np,c_&lt;/code&gt;, &lt;code&gt;np.index_exp&lt;/code&gt;, etc.) may require some care. To give these instances a useful docstring, we do the following:</source>
          <target state="translated">NumPy API의 일부인 클래스 인스턴스 (예 : &lt;code&gt;np.r_&lt;/code&gt; &lt;code&gt;np,c_&lt;/code&gt; , &lt;code&gt;np.index_exp&lt;/code&gt; 등)는 약간의주의가 필요할 수 있습니다. 이러한 인스턴스에 유용한 독 스트링을 제공하기 위해 다음을 수행합니다.</target>
        </trans-unit>
        <trans-unit id="e39a6352ce81aec018b2a3acbf6b2a0e689c1611" translate="yes" xml:space="preserve">
          <source>Instead of plain &lt;code&gt;gdb&lt;/code&gt; you can of course use your favourite alternative debugger; run it on the python binary with arguments &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt;.</source>
          <target state="translated">일반 &lt;code&gt;gdb&lt;/code&gt; 대신 좋아하는 대체 디버거를 사용할 수 있습니다. &lt;code&gt;runtests.py -g --python mytest.py&lt;/code&gt; 인수를 사용하여 Python 바이너리에서 실행합니다 .</target>
        </trans-unit>
        <trans-unit id="eb90e39d52c4ed3cde5408270177895a426f7a11" translate="yes" xml:space="preserve">
          <source>Instead of special method names which define behavior for Python classes, there are &amp;ldquo;function tables&amp;rdquo; which point to functions that implement the desired results. Since Python 2.2, the PyTypeObject itself has become dynamic which allows C types that can be &amp;ldquo;sub-typed &amp;ldquo;from other C-types in C, and sub-classed in Python. The children types inherit the attributes and methods from their parent(s).</source>
          <target state="translated">Python 클래스의 동작을 정의하는 특수 메소드 이름 대신 원하는 결과를 구현하는 함수를 가리키는 &quot;함수 테이블&quot;이 있습니다. Python 2.2부터 PyTypeObject 자체가 동적으로 바뀌어 C의 다른 C 유형에서 &quot;하위 유형&quot;이 될 수 있고 Python에서 하위 클래스가 될 수있는 C 유형을 허용합니다. 자식 형식은 부모로부터 특성과 메서드를 상속합니다.</target>
        </trans-unit>
        <trans-unit id="1a76aa17748f84d4f0a3ce05629dc02de8fc5860" translate="yes" xml:space="preserve">
          <source>Instead of specifying the full covariance matrix, popular approximations include:</source>
          <target state="translated">전체 공분산 행렬을 지정하는 대신 널리 사용되는 근사값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="569af2f9677e0019350ea2c63399c035e782231b" translate="yes" xml:space="preserve">
          <source>Instead of the Python traditional &amp;lsquo;floor division&amp;rsquo;, this returns a true division. True division adjusts the output type to present the best answer, regardless of input types.</source>
          <target state="translated">파이썬의 전통적인 'floor division'대신에 이것은 진정한 division을 반환합니다. 완전 분할은 입력 유형에 관계없이 최상의 응답을 제공하도록 출력 유형을 조정합니다.</target>
        </trans-unit>
        <trans-unit id="2a07db57033cceb88c4be20433a8c922b8ebe578" translate="yes" xml:space="preserve">
          <source>Instead of the above, you can also do:</source>
          <target state="translated">위의 대신 다음을 수행 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="50b73dbdc0cbb3f8f1706a51e59d5b72389beaee" translate="yes" xml:space="preserve">
          <source>Instead of this function &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; should be used. The above function differs from this because it ignores support for non-array, or array subclasses as inputs. To ensure identical behaviour, it may be necessary to convert all inputs using &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt;.</source>
          <target state="translated">이 함수 대신 &lt;code&gt;PyObject_Call(ufunc, args, kwds)&lt;/code&gt; 사용해야합니다. 위의 함수는 비 배열 또는 배열 서브 클래스에 대한 지원을 입력으로 무시하기 때문에 이것과 다릅니다. 동일한 동작을 보장하려면 &lt;code&gt;PyArray_FromAny(obj, NULL, 0, 0, NPY_ARRAY_ENSUREARRAY, NULL)&lt;/code&gt; 사용하여 모든 입력을 변환해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="93d352d3764b7602f9edf496f491993157b0351d" translate="yes" xml:space="preserve">
          <source>Institutional Neutrality</source>
          <target state="translated">기관 중립성</target>
        </trans-unit>
        <trans-unit id="6e8f68e1ce3b53a860ea6246ace5d16aba4fb2d5" translate="yes" xml:space="preserve">
          <source>Institutional Partner benefits are:</source>
          <target state="translated">기관 파트너 혜택은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="36318fd5786e4e1f35ed034e1d3f5b6a4d87922c" translate="yes" xml:space="preserve">
          <source>Institutional Partners</source>
          <target state="translated">기관 파트너</target>
        </trans-unit>
        <trans-unit id="228367a5efa47fc0ca88237f73f231005624c438" translate="yes" xml:space="preserve">
          <source>Institutional Partners and Funding</source>
          <target state="translated">기관 파트너 및 자금 지원</target>
        </trans-unit>
        <trans-unit id="415e24116e418ab9260b5d4870a4577bbf2a9dc5" translate="yes" xml:space="preserve">
          <source>Institutions become eligible to become an Institutional Partner by employing individuals who actively contribute to The Project as part of their official duties. To state this another way, the only way for a Partner to influence the project is by actively contributing to the open development of the project, in equal terms to any other member of the community of Contributors and Council Members. Merely using Project Software in institutional context does not allow an entity to become an Institutional Partner. Financial gifts do not enable an entity to become an Institutional Partner. Once an institution becomes eligible for Institutional Partnership, the Steering Council must nominate and approve the Partnership.</source>
          <target state="translated">기관은 공식 업무의 일환으로 프로젝트에 적극적으로 기여하는 개인을 고용함으로써 기관 파트너가 될 수 있습니다. 이를 다른 방식으로 설명하기 위해 파트너가 프로젝트에 영향을 미칠 수있는 유일한 방법은 기여자 및위원회 구성원 커뮤니티의 다른 구성원과 동등하게 프로젝트의 공개 개발에 적극적으로 기여하는 것입니다. 단순히 기관 적 맥락에서 프로젝트 소프트웨어를 사용한다고해서 기관이 기관 파트너가되는 것은 아닙니다. 금전적 선물은 법인이 기관 파트너가되는 것을 허용하지 않습니다. 기관이 기관 파트너십 자격이되면 운영위원회는 파트너십을 지명하고 승인해야합니다.</target>
        </trans-unit>
        <trans-unit id="ed58f29743f8e14b9c8e13d41e070a1cc1d1c9f5" translate="yes" xml:space="preserve">
          <source>Instructions</source>
          <target state="translated">Instructions</target>
        </trans-unit>
        <trans-unit id="987d64b35cc2b94395724f62d16f3a187b63fb14" translate="yes" xml:space="preserve">
          <source>Insufficient bit width parameter to &lt;code&gt;binary_repr&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;binary_repr&lt;/code&gt; 에 대한 비트 너비 매개 변수가 충분하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9edcffff4461c9083fbff857f8dcee0f0769cbd4" translate="yes" xml:space="preserve">
          <source>Integer</source>
          <target state="translated">Integer</target>
        </trans-unit>
        <trans-unit id="5796f99d3f819f045b29a1c73196d8c40b12d9d3" translate="yes" xml:space="preserve">
          <source>Integer (-2147483648 to 2147483647)</source>
          <target state="translated">정수 (-2147483648 ~ 2147483647)</target>
        </trans-unit>
        <trans-unit id="4710e6c81ea3d854c2dc7806935816c50a107107" translate="yes" xml:space="preserve">
          <source>Integer (-32768 to 32767)</source>
          <target state="translated">정수 (-32768 ~ 32767)</target>
        </trans-unit>
        <trans-unit id="d944b6a3d689ab2dee3e16b0c8d8d941fd887e9b" translate="yes" xml:space="preserve">
          <source>Integer (-9223372036854775808 to 9223372036854775807)</source>
          <target state="translated">정수 (-9223372036854775808 ~ 9223372036854775807)</target>
        </trans-unit>
        <trans-unit id="e8fe5938766ae937144b5f55575793bff2ec8f88" translate="yes" xml:space="preserve">
          <source>Integer and Void scalars are now unaffected by &lt;code&gt;np.set_string_function&lt;/code&gt;</source>
          <target state="translated">Integer 및 Void 스칼라는 이제 &lt;code&gt;np.set_string_function&lt;/code&gt; 의 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a61c09200238e7c60e4949f4f742cd3529f52bfd" translate="yes" xml:space="preserve">
          <source>Integer array indexing</source>
          <target state="translated">정수형 배열 인덱싱</target>
        </trans-unit>
        <trans-unit id="a764d9440def338d1a721af2c9bc3cf9203fd57a" translate="yes" xml:space="preserve">
          <source>Integer array indexing allows selection of arbitrary items in the array based on their &lt;em&gt;N&lt;/em&gt;-dimensional index. Each integer array represents a number of indexes into that dimension.</source>
          <target state="translated">정수 배열 인덱싱을 사용하면 &lt;em&gt;N&lt;/em&gt; 차원 인덱스를 기준으로 배열에서 임의의 항목을 선택할 수 있습니다 . 각 정수 배열은 해당 차원에 대한 여러 인덱스를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a46c6037b6ed3e2034603c23c6f4211c22a945c1" translate="yes" xml:space="preserve">
          <source>Integer exponents of 2. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">정수 지수 2. &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="a3173b86433d0db1fb5b647328822672be728221" translate="yes" xml:space="preserve">
          <source>Integer indicating how this dtype relates to the built-in dtypes.</source>
          <target state="translated">이 dtype이 내장 dtype과 어떤 관련이 있는지를 나타내는 정수입니다.</target>
        </trans-unit>
        <trans-unit id="201042a920a1327277fe1dda0e55cd37046acf9f" translate="yes" xml:space="preserve">
          <source>Integer large enough to hold a pointer</source>
          <target state="translated">포인터를 담을 수있을만큼 큰 정수</target>
        </trans-unit>
        <trans-unit id="c0ad68cb65f108515f3a5b364ab814f280978530" translate="yes" xml:space="preserve">
          <source>Integer performance has a similar ordering.</source>
          <target state="translated">정수 성능은 비슷한 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="006c632da5c7b1582b36540c57330b631facab3d" translate="yes" xml:space="preserve">
          <source>Integer that can hold a pointer</source>
          <target state="translated">포인터를 담을 수있는 정수</target>
        </trans-unit>
        <trans-unit id="876569ad85ebaf17d9149dea5706aba22e882fe8" translate="yes" xml:space="preserve">
          <source>Integer types</source>
          <target state="translated">정수 유형</target>
        </trans-unit>
        <trans-unit id="b13be07f7abad8e811e3c73cea1a525a627e0bc2" translate="yes" xml:space="preserve">
          <source>Integer ufuncs vectorized with AVX2</source>
          <target state="translated">AVX2로 벡터화 된 정수 ufunc</target>
        </trans-unit>
        <trans-unit id="a334f0e07c1be58e6996ea133d59f4da9faac7a9" translate="yes" xml:space="preserve">
          <source>Integer used for indexing, typically the same as &lt;code&gt;ssize_t&lt;/code&gt;</source>
          <target state="translated">인덱싱에 사용되는 정수 (일반적으로 &lt;code&gt;ssize_t&lt;/code&gt; 와 동일)</target>
        </trans-unit>
        <trans-unit id="654f37af768fdf3bb70ca69e758a2fe80f1abf09" translate="yes" xml:space="preserve">
          <source>Integers:</source>
          <target state="translated">Integers:</target>
        </trans-unit>
        <trans-unit id="84cede945b07b48bcb97421b3eb8bd4f5bd269e0" translate="yes" xml:space="preserve">
          <source>Integral part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 필수 부분 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="1ea3c0d26d1c5d1b53eb099b2c1cf7972b99ebe8" translate="yes" xml:space="preserve">
          <source>Integrate &lt;code&gt;y&lt;/code&gt; (&lt;code&gt;x&lt;/code&gt;) along given axis.</source>
          <target state="translated">주어진 축을 따라 &lt;code&gt;y&lt;/code&gt; ( &lt;code&gt;x&lt;/code&gt; )를 적분합니다 .</target>
        </trans-unit>
        <trans-unit id="cc54f713576053888447a5aa6f2b6660db759e79" translate="yes" xml:space="preserve">
          <source>Integrate a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="f7e0820ca3cf5b80cf75499d63a15279548b4395" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite series.</source>
          <target state="translated">Hermite 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="09cdc33ab9232f32b3ffa23eec0555fd0aad884d" translate="yes" xml:space="preserve">
          <source>Integrate a Hermite_e series.</source>
          <target state="translated">Hermite_e 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="28e01e90e39bcd5c5a200d36b330a9fb8a0cc2c8" translate="yes" xml:space="preserve">
          <source>Integrate a Laguerre series.</source>
          <target state="translated">Laguerre 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="e45d1046a79d8f27551599eaeb79cbfa5c322286" translate="yes" xml:space="preserve">
          <source>Integrate a Legendre series.</source>
          <target state="translated">Legendre 시리즈를 통합하십시오.</target>
        </trans-unit>
        <trans-unit id="51617b9fadb594aa47fc197fa4afb1a0d12a97e3" translate="yes" xml:space="preserve">
          <source>Integrate a polynomial.</source>
          <target state="translated">다항식을 통합합니다.</target>
        </trans-unit>
        <trans-unit id="1b28e42d25bb1781655bdbd732badc274759c37c" translate="yes" xml:space="preserve">
          <source>Integrate along the given axis using the composite trapezoidal rule.</source>
          <target state="translated">복합 사다리꼴 규칙을 사용하여 주어진 축을 따라 적분합니다.</target>
        </trans-unit>
        <trans-unit id="f6bc7be2c5b5072601573fb92ccbc047dff88160" translate="yes" xml:space="preserve">
          <source>Integrate.</source>
          <target state="translated">Integrate.</target>
        </trans-unit>
        <trans-unit id="a77970f26b3a19856dc6d676e2149a78243716b5" translate="yes" xml:space="preserve">
          <source>Integrated squared error (ISE) estimator added to &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;histogram&lt;/code&gt; 추가 된 통합 제곱 오차 (ISE) 추정기</target>
        </trans-unit>
        <trans-unit id="24640b86177ce52879242a4e3855fb7330a6f367" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at &lt;code&gt;lbnd&lt;/code&gt; is the first value in the list, the value of the second integral at &lt;code&gt;lbnd&lt;/code&gt; is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">적분 상수. &lt;code&gt;lbnd&lt;/code&gt; 의 첫 번째 적분 값이 목록의 첫 번째 값이고 &lt;code&gt;lbnd&lt;/code&gt; 의 두 번째 적분 값이 두 번째 값 등입니다. &lt;code&gt;k == []&lt;/code&gt; (기본값)이면 모든 상수가 0으로 설정됩니다. &lt;code&gt;m == 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="faa7aa2d13f47c8dc8e8d870349e9f9bbf12fee6" translate="yes" xml:space="preserve">
          <source>Integration constant(s). The value of the first integral at zero is the first value in the list, the value of the second integral at zero is the second value, etc. If &lt;code&gt;k == []&lt;/code&gt; (the default), all constants are set to zero. If &lt;code&gt;m == 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">적분 상수. 0의 첫 번째 적분 값이 목록의 첫 번째 값이고, 0의 두 번째 적분 값이 두 번째 값 등입니다. &lt;code&gt;k == []&lt;/code&gt; (기본값)이면 모든 상수가 0으로 설정됩니다. &lt;code&gt;m == 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="79199da79d91b1fb5aeec3ae95134c32578dd203" translate="yes" xml:space="preserve">
          <source>Integration constants. The first constant is applied to the first integration, the second to the second, and so on. The list of values must less than or equal to &lt;code&gt;m&lt;/code&gt; in length and any missing values are set to zero.</source>
          <target state="translated">적분 상수. 첫 번째 상수는 첫 번째 적분에 적용되고 두 번째 상수는 두 번째 정수에 적용됩니다. 값 목록의 길이 는 &lt;code&gt;m&lt;/code&gt; 보다 작거나 같아야하며 누락 된 값은 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="99a973b23f26b788591e237471230a61bc42bfca" translate="yes" xml:space="preserve">
          <source>Integration constants. They are given in the order of integration: those corresponding to highest-order terms come first.</source>
          <target state="translated">적분 상수. 그것들은 통합의 순서로 주어진다 : 최상위 순서에 해당하는 것이 우선이다.</target>
        </trans-unit>
        <trans-unit id="f1b63b1b837d115daafc12c34b184fde445bf116" translate="yes" xml:space="preserve">
          <source>Integration of array values using the composite trapezoidal rule.</source>
          <target state="translated">합성 사다리꼴 규칙을 사용한 배열 값의 통합.</target>
        </trans-unit>
        <trans-unit id="272bd8e11d9a2557b005814cbc8295b6bce05913" translate="yes" xml:space="preserve">
          <source>Interaction with &lt;code&gt;scipy.sparse&lt;/code&gt; is a bit cleaner.</source>
          <target state="translated">&lt;code&gt;scipy.sparse&lt;/code&gt; 와의 상호 작용 은 조금 더 깨끗합니다.</target>
        </trans-unit>
        <trans-unit id="cf5308846512dd05b3fe349862b884d3dad34184" translate="yes" xml:space="preserve">
          <source>Interchange two axes of an array.</source>
          <target state="translated">배열의 두 축을 교환합니다.</target>
        </trans-unit>
        <trans-unit id="487fafdb343a2fa07aa1e904de9985413e377451" translate="yes" xml:space="preserve">
          <source>Interest paid against the loan changes during the life or the loan. The &lt;code&gt;per&lt;/code&gt; is the payment period to calculate the interest amount.</source>
          <target state="translated">일생 동안의 대출 변경 또는 대출에 대한 지불이자. &lt;code&gt;per&lt;/code&gt; 이자 금액을 계산하기 위해 지불 기간입니다.</target>
        </trans-unit>
        <trans-unit id="94a1603aa26be2dbffaf8cf5c3954f0266df1988" translate="yes" xml:space="preserve">
          <source>Interest portion of payment. If all input is scalar, returns a scalar float. If any input is array_like, returns interest payment for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">지불의이자 부분. 모든 입력 값이 스칼라이면 스칼라 부동 소수점을 반환합니다. 입력이 array_like 인 경우 각 입력 요소에 대한이자 지불을 리턴합니다. 여러 입력이 array_like 인 경우 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="fae2c1a639317094eef5fc0747acae252e47559d" translate="yes" xml:space="preserve">
          <source>Interest rate paid on the cash flows</source>
          <target state="translated">현금 흐름에 지불 된 이자율</target>
        </trans-unit>
        <trans-unit id="bac9f8f12cdd23938b9506adf721b640d1387b0f" translate="yes" xml:space="preserve">
          <source>Interest rate received on the cash flows upon reinvestment</source>
          <target state="translated">재투자시 현금 흐름에 대한 이자율</target>
        </trans-unit>
        <trans-unit id="acbc7801b292b22fd84bb969c2c0f9ee879becf9" translate="yes" xml:space="preserve">
          <source>Interfacing to C</source>
          <target state="translated">C와의 인터페이스</target>
        </trans-unit>
        <trans-unit id="5669f1ef998cb57e98a6c7c64ced935f3a20e1ba" translate="yes" xml:space="preserve">
          <source>Interfacing to C++:</source>
          <target state="translated">C ++ 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="0ef0659c2c669af8efd19f667b98f55614307e8e" translate="yes" xml:space="preserve">
          <source>Interfacing to Fortran:</source>
          <target state="translated">Fortran과의 인터페이스 :</target>
        </trans-unit>
        <trans-unit id="5a1eb29a8757da9ba26cf2dfef44ad676331c673" translate="yes" xml:space="preserve">
          <source>Internal Flexibility</source>
          <target state="translated">내부 유연성</target>
        </trans-unit>
        <trans-unit id="ac2251ff80e959c9a76b1d8e25426050ad978681" translate="yes" xml:space="preserve">
          <source>Internal Rate of Return for periodic input values.</source>
          <target state="translated">주기적 입력 값에 대한 내부 수익률.</target>
        </trans-unit>
        <trans-unit id="70e52d12f616579455cc3db6303a1fc61cf8ea38" translate="yes" xml:space="preserve">
          <source>Internal changes</source>
          <target state="translated">내부 변화</target>
        </trans-unit>
        <trans-unit id="811920182b71e4d6c39f62829f0533afa24b5bfb" translate="yes" xml:space="preserve">
          <source>Internal functions</source>
          <target state="translated">내부 기능</target>
        </trans-unit>
        <trans-unit id="ecdbace78f65adf7ab79aea820093f0235b38c83" translate="yes" xml:space="preserve">
          <source>Internal memory layout of an ndarray</source>
          <target state="translated">ndarray의 내부 메모리 레이아웃</target>
        </trans-unit>
        <trans-unit id="4c771d77fd8a74b74dbd14733dbe89a221191139" translate="yes" xml:space="preserve">
          <source>Internal organization of numpy arrays</source>
          <target state="translated">numpy 배열의 내부 조직</target>
        </trans-unit>
        <trans-unit id="8693ac81d62075b90be2f5012ceac7d5e0960c71" translate="yes" xml:space="preserve">
          <source>Internally used structures</source>
          <target state="translated">내부적으로 사용되는 구조</target>
        </trans-unit>
        <trans-unit id="353f9272117a257bd48156e257afe86724ce335c" translate="yes" xml:space="preserve">
          <source>Internally, buffers are used for misaligned data, swapped data, and data that has to be converted from one data type to another. The size of internal buffers is settable on a per-thread basis. There can be up to</source>
          <target state="translated">내부적으로 버퍼는 잘못 정렬 된 데이터, 스왑 된 데이터 및 한 데이터 유형에서 다른 데이터 유형으로 변환해야하는 데이터에 사용됩니다. 내부 버퍼의 크기는 스레드별로 설정할 수 있습니다. 최대 수</target>
        </trans-unit>
        <trans-unit id="0b9562a5febab6388bcaad8af8913734a30e5c69" translate="yes" xml:space="preserve">
          <source>Internally, the code uses some additional Python objects primarily for memory management. These types are not accessible directly from Python, and are not exposed to the C-API. They are included here only for completeness and assistance in understanding the code.</source>
          <target state="translated">내부적으로 코드는 주로 메모리 관리를 위해 일부 추가 Python 객체를 사용합니다. 이러한 유형은 Python에서 직접 액세스 할 수 없으며 C-API에 노출되지 않습니다. 여기에는 코드 이해에 대한 완전성 및 지원을 위해서만 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="88c585f236f03e4d85467407665675347bdfa2c1" translate="yes" xml:space="preserve">
          <source>Internally, these #defines work as follows:</source>
          <target state="translated">내부적으로 이러한 #define은 다음과 같이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="2e02d69fdcfa7dd47d4e20a9c3718e372f145dcc" translate="yes" xml:space="preserve">
          <source>Interoperability-Related Options</source>
          <target state="translated">상호 운용성 관련 옵션</target>
        </trans-unit>
        <trans-unit id="b400cd2b32800b89445114d966c1ee1e1e2f5b22" translate="yes" xml:space="preserve">
          <source>Interpolate a function at the Chebyshev points of the first kind.</source>
          <target state="translated">첫 번째 종류의 체비 쇼프 지점에서 함수를 보간합니다.</target>
        </trans-unit>
        <trans-unit id="b0124a6fa4961521e8ff39aa6c372018194a4ebf" translate="yes" xml:space="preserve">
          <source>Interpolating Chebyshev instance.</source>
          <target state="translated">체비 쇼프 인스턴스 보간.</target>
        </trans-unit>
        <trans-unit id="1427e61ed742cbf9aa91a5c0cf7909917aab75eb" translate="yes" xml:space="preserve">
          <source>Interpolation with periodic x-coordinates:</source>
          <target state="translated">주기적 x 좌표를 사용한 보간 :</target>
        </trans-unit>
        <trans-unit id="437831e765e33b0f2fa769dfde52d2c581b5cfbf" translate="yes" xml:space="preserve">
          <source>Interpret a buffer as a 1-dimensional array.</source>
          <target state="translated">버퍼를 1 차원 배열로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="9feed02e3d661ed814b67ed529ab9195e31b0cb4" translate="yes" xml:space="preserve">
          <source>Interpret the input as a matrix.</source>
          <target state="translated">입력을 행렬로 해석하십시오.</target>
        </trans-unit>
        <trans-unit id="a0422cc647bba954b177a29fbf1305b2895860e3" translate="yes" xml:space="preserve">
          <source>Interrupt Handling</source>
          <target state="translated">인터럽트 처리</target>
        </trans-unit>
        <trans-unit id="e5f5d0f73f8dc2d6363a75fe32ba76d7d8dff9cc" translate="yes" xml:space="preserve">
          <source>Intrinsic NumPy Array Creation</source>
          <target state="translated">내장 NumPy 배열 생성</target>
        </trans-unit>
        <trans-unit id="7e2ea7ccd882296e2e16cdecb01f04008d30cfc7" translate="yes" xml:space="preserve">
          <source>Intrinsic numpy array creation objects (e.g., arange, ones, zeros, etc.)</source>
          <target state="translated">고유 한 numpy 배열 생성 객체 (예 : 범위, 1, 0 등)</target>
        </trans-unit>
        <trans-unit id="dcd3fd94e72c882e4eaa006cb5da780542c07011" translate="yes" xml:space="preserve">
          <source>Introduce yourself to Git:</source>
          <target state="translated">Git 소개 :</target>
        </trans-unit>
        <trans-unit id="2473e96bc614a911821242119918a241a41836d6" translate="yes" xml:space="preserve">
          <source>Introduction</source>
          <target state="translated">Introduction</target>
        </trans-unit>
        <trans-unit id="b6ab6d57043280ab296716031275867d148d3ca7" translate="yes" xml:space="preserve">
          <source>Introduction to byte ordering and ndarrays</source>
          <target state="translated">바이트 순서 및 ndarray 소개</target>
        </trans-unit>
        <trans-unit id="24583ffa86b443c7a55325e4b25e34083f63ac92" translate="yes" xml:space="preserve">
          <source>Invalid arguments for array ordering</source>
          <target state="translated">배열 순서에 대한 잘못된 인수</target>
        </trans-unit>
        <trans-unit id="8a8e0797ccef44760e0a1c564f5097faaf0a6cb9" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../constants#numpy.inf&quot;&gt;&lt;code&gt;inf&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">유효하지 않은 데이터는 &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../constants#numpy.inf&quot;&gt; &lt;code&gt;inf&lt;/code&gt; &lt;/a&gt; 등의 값을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="46dbc8721ef190eab06879ef282ac69a2d11056b" translate="yes" xml:space="preserve">
          <source>Invalid data means values of &lt;code&gt;nan&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt;, etc.</source>
          <target state="translated">유효하지 않은 데이터는 &lt;code&gt;nan&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 등의 값을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="b66a9668314f5851a31b3926b89142340d67c1e0" translate="yes" xml:space="preserve">
          <source>Invalid fill value exceptions</source>
          <target state="translated">유효하지 않은 채우기 값 예외</target>
        </trans-unit>
        <trans-unit id="6dd811ad3cf2203333b0468d5361ce3f92b716aa" translate="yes" xml:space="preserve">
          <source>Invalid operation: result is not an expressible number, typically indicates that a NaN was produced.</source>
          <target state="translated">잘못된 작업 : 결과는 표현 가능한 숫자가 아니며 일반적으로 NaN이 생성되었음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dfed6b5bd73798f6efbc4f77cde7ac568bd5cdfb" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic cosine, element-wise.</source>
          <target state="translated">요소 별 역 쌍곡 코사인.</target>
        </trans-unit>
        <trans-unit id="21de990f2f734fbb43aa31870f6cebb10139a34e" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic sine element-wise.</source>
          <target state="translated">요소 별 역 쌍곡 사인.</target>
        </trans-unit>
        <trans-unit id="ae6bb16d1805cc3ebef5cfaf633f1f868061a8dc" translate="yes" xml:space="preserve">
          <source>Inverse hyperbolic tangent element-wise.</source>
          <target state="translated">요소 별 역 쌍곡 탄젠트.</target>
        </trans-unit>
        <trans-unit id="2c6d3ed37e9c36a516eafee4d6cf6bce8fa583e5" translate="yes" xml:space="preserve">
          <source>Inverse sine, element-wise.</source>
          <target state="translated">요소 별 역사 인.</target>
        </trans-unit>
        <trans-unit id="9b049bc33b3f3b47e868bbdc217dc4db5fb5be2d" translate="yes" xml:space="preserve">
          <source>Inverses of several matrices can be computed at once:</source>
          <target state="translated">여러 행렬의 역을 한 번에 계산할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bafff722f42fe9db3b595ab6ea0bb84953a6e8ad" translate="yes" xml:space="preserve">
          <source>Investigate. Change directory to your new repo: &lt;code&gt;cd numpy&lt;/code&gt;. Then &lt;code&gt;git branch -a&lt;/code&gt; to show you all branches. You&amp;rsquo;ll get something like:</source>
          <target state="translated">조사하다. 디렉토리를 새 저장소로 변경하십시오 : &lt;code&gt;cd numpy&lt;/code&gt; . 그런 다음 &lt;code&gt;git branch -a&lt;/code&gt; 를 사용하여 모든 분기를 표시하십시오. 다음과 같은 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="525b73c1bc26402f8fe2106a7fc0623195c4b729" translate="yes" xml:space="preserve">
          <source>Is equivalent to &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt;, but allows further use of &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">동등 &lt;code&gt;np.delete(arr, [0,2,4], axis=0)&lt;/code&gt; ,하지만 더 사용할 수 있도록 &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24c5caf7c1723177101292b0ec91f3f69f7573df" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that he has been given without much documentation.</source>
          <target state="translated">리버스 엔지니어링은 간단합니다. 데이터 세트는 종종 데이터 세트를 생성 한 프로그램보다 오래 지속됩니다. 유능한 개발자는 선호하는 프로그래밍 언어로 솔루션을 만들어서 많은 문서없이 제공받은 대부분의 &lt;code&gt;.npy&lt;/code&gt; 파일 을 읽을 수 있어야 합니다.</target>
        </trans-unit>
        <trans-unit id="4ba294d10b61eb96747cb70e6af5cde8e38ba66a" translate="yes" xml:space="preserve">
          <source>Is straightforward to reverse engineer. Datasets often live longer than the programs that created them. A competent developer should be able to create a solution in their preferred programming language to read most &lt;code&gt;.npy&lt;/code&gt; files that they have been given without much documentation.</source>
          <target state="translated">리버스 엔지니어링이 간단합니다. 데이터 세트는 종종 데이터 세트를 생성 한 프로그램보다 오래 유지됩니다. 유능한 개발자는 많은 문서없이 제공된 대부분의 &lt;code&gt;.npy&lt;/code&gt; 파일 을 읽을 수 있도록 선호하는 프로그래밍 언어로 솔루션을 만들 수 있어야합니다 .</target>
        </trans-unit>
        <trans-unit id="1a81d4101d801108adb8aad8206475022e2e35b0" translate="yes" xml:space="preserve">
          <source>Is the given function something that we know how to overload?</source>
          <target state="translated">주어진 함수가 오버로드하는 방법을 알고 있습니까?</target>
        </trans-unit>
        <trans-unit id="90d345365af762034873b91bc86108d3934ff16a" translate="yes" xml:space="preserve">
          <source>Is the intended behavior clear under all conditions? Some things to watch:</source>
          <target state="translated">모든 조건에서 의도 된 동작이 분명합니까? 주목할 몇 가지 :</target>
        </trans-unit>
        <trans-unit id="cc7ae1466afcaa0ca1796c357dfcb90adbea07a4" translate="yes" xml:space="preserve">
          <source>Is this page an example of a how-to?</source>
          <target state="translated">이 페이지가 방법의 예입니까?</target>
        </trans-unit>
        <trans-unit id="b10180fbee8cac98fb1ea7940ed518f48a70dee3" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Vandermonde 행렬의 순위가 &lt;a href=&quot;generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; 때 polyfit에 의해 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="2c7da8ef717a7e944f5132cdc9e7ea084630c1b8" translate="yes" xml:space="preserve">
          <source>Issued by &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt; when the Vandermonde matrix is rank deficient.</source>
          <target state="translated">Vandermonde 행렬의 순위가 &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; &lt;/a&gt; 때 polyfit에 의해 발행됩니다 .</target>
        </trans-unit>
        <trans-unit id="62ecce1ee2f04057e107579d5bef99ec7e6758b0" translate="yes" xml:space="preserve">
          <source>Issued by chebfit when the design matrix is rank deficient.</source>
          <target state="translated">설계 행렬에 순위가 부족할 때 chebfit이 발행합니다.</target>
        </trans-unit>
        <trans-unit id="ed3a53b09f923a24c6dd04195732883fc05144f5" translate="yes" xml:space="preserve">
          <source>Issued by the generic Poly class when two domains don&amp;rsquo;t match.</source>
          <target state="translated">두 도메인이 일치하지 않는 경우 일반 Poly 클래스에서 발행합니다.</target>
        </trans-unit>
        <trans-unit id="f00ecef77fb41ae5e26098e89f064e811f1d6ae9" translate="yes" xml:space="preserve">
          <source>Issues Fixed</source>
          <target state="translated">해결 된 문제</target>
        </trans-unit>
        <trans-unit id="b19e94cfda274542200371fca470c64546558300" translate="yes" xml:space="preserve">
          <source>Issues a DeprecationWarning, adds warning to &lt;code&gt;old_name&lt;/code&gt;&amp;rsquo;s docstring, rebinds &lt;code&gt;old_name.__name__&lt;/code&gt; and returns the new function object.</source>
          <target state="translated">발행 DeprecationWarning에 경고 추가합니다 &lt;code&gt;old_name&lt;/code&gt; 리 바인드 '의 문서화 문자열을 &lt;code&gt;old_name.__name__&lt;/code&gt; 새로운 기능 개체를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="9ddf288870dda342df98b4b9313d3dcfea4defcb" translate="yes" xml:space="preserve">
          <source>Issues fixed</source>
          <target state="translated">해결 된 문제</target>
        </trans-unit>
        <trans-unit id="671076d691ff47550497ef45340afd4f09d3d6a6" translate="yes" xml:space="preserve">
          <source>It also contains extra C definitions that are used for defining NumPy&amp;rsquo;s Python-level module attributes &lt;code&gt;__cpu_baseline__&lt;/code&gt; and &lt;code&gt;__cpu_dispaٍtch__&lt;/code&gt;.</source>
          <target state="translated">또한 NumPy의 Python 수준 모듈 속성 &lt;code&gt;__cpu_baseline__&lt;/code&gt; 및 &lt;code&gt;__cpu_dispaٍtch__&lt;/code&gt; 정의에 사용되는 추가 C 정의가 포함되어 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dee1de34f5e6dfdd4c0e68ce69b1f31528f724f6" translate="yes" xml:space="preserve">
          <source>It can also be used in places of &lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt;&lt;code&gt;atleast_1d&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt;&lt;code&gt;atleast_2d&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.atleast_1d#numpy.atleast_1d&quot;&gt; &lt;code&gt;atleast_1d&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;numpy.atleast_2d#numpy.atleast_2d&quot;&gt; &lt;code&gt;atleast_2d&lt;/code&gt; &lt;/a&gt; 장소에서도 사용할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="378d5136b02c66ae2366b0871c9dc87a59e458eb" translate="yes" xml:space="preserve">
          <source>It can be considered as a generalization of EPS: &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt;, and there should not be any representable number between &lt;code&gt;x + spacing(x)&lt;/code&gt; and x for any finite x.</source>
          <target state="translated">: 그것은 EPS의 일반화로서 간주 될 수있다 &lt;code&gt;spacing(np.float64(1)) == np.finfo(np.float64).eps&lt;/code&gt; , 및 사이 표현할 수가 없어야 &lt;code&gt;x + spacing(x)&lt;/code&gt; 과 X 유한 x.</target>
        </trans-unit>
        <trans-unit id="1ef0650f598bd8c46d6488dc9e1ecf7f36a57c12" translate="yes" xml:space="preserve">
          <source>It can be shown that a convolution</source>
          <target state="translated">컨볼 루션</target>
        </trans-unit>
        <trans-unit id="3a39f7205319edd1c303f4671f99c8c35d8b49e6" translate="yes" xml:space="preserve">
          <source>It can be shown that if</source>
          <target state="translated">그것은 경우에 표시 될 수 있습니다</target>
        </trans-unit>
        <trans-unit id="c085102ad00314d621def87ff2d6f64f13992fcf" translate="yes" xml:space="preserve">
          <source>It can be used at most once; &lt;code&gt;a[...,0,...]&lt;/code&gt; raises an &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#IndexError&quot;&gt;&lt;code&gt;IndexError&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">한 번만 사용할 수 있습니다. &lt;code&gt;a[...,0,...]&lt;/code&gt; 은 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#IndexError&quot;&gt; &lt;code&gt;IndexError&lt;/code&gt; 를 발생&lt;/a&gt; 시킵니다.</target>
        </trans-unit>
        <trans-unit id="6680413ecf8178af7a6bc1c7bc275bc8809885e1" translate="yes" xml:space="preserve">
          <source>It differs from the forward transform by the sign of the exponential argument and the default normalization by</source>
          <target state="translated">지수 인수의 부호와 기본 정규화에 의해 정방향 변환과 다릅니다.</target>
        </trans-unit>
        <trans-unit id="d2a43fea3528f404f8930330d870fe7079aa62c4" translate="yes" xml:space="preserve">
          <source>It does &lt;em&gt;not&lt;/em&gt; generally hold that &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; for C-style contiguous arrays or &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; for Fortran-style contiguous arrays is true.</source>
          <target state="translated">일반적으로 C 스타일 연속 배열의 경우 &lt;code&gt;self.strides[-1] == self.itemsize&lt;/code&gt; 또는 Fortran 스타일 연속 배열의 &lt;code&gt;self.strides[0] == self.itemsize&lt;/code&gt; 가 true 라는 것을 일반적으로 주장 하지는 &lt;em&gt;않습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="47be37fff5f8f22af765f82be2c6bfbaf9c3032a" translate="yes" xml:space="preserve">
          <source>It has the following structure:</source>
          <target state="translated">다음과 같은 구조로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d66b7021aa904bae4cfae41aeb4ea6450db47e9" translate="yes" xml:space="preserve">
          <source>It has the probability density function</source>
          <target state="translated">확률 밀도 기능이 있습니다</target>
        </trans-unit>
        <trans-unit id="8df067c80d1dbac7caebbaa192d51d71072198f4" translate="yes" xml:space="preserve">
          <source>It helps to understand a bit about how numpy arrays are handled under the covers to help understand numpy better. This section will not go into great detail. Those wishing to understand the full details are referred to Travis Oliphant&amp;rsquo;s book &amp;ldquo;Guide to NumPy&amp;rdquo;.</source>
          <target state="translated">numpy 배열을 다루는 방법에 대해 조금 이해하면 numpy를 더 잘 이해하는 데 도움이됩니다. 이 섹션은 자세하게 설명하지 않습니다. 자세한 내용을 이해하려는 사람들은 Travis Oliphant의 &quot;Guide to NumPy&quot;를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2fbb89405ce29cc8160fa307e221950fa152cd3e" translate="yes" xml:space="preserve">
          <source>It is also possible to select more than one item at a time, using &lt;em&gt;slicing&lt;/em&gt;:</source>
          <target state="translated">&lt;em&gt;슬라이싱을&lt;/em&gt; 사용하여 한 번에 둘 이상의 항목을 선택할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6785902c796379d2b6f1ca680d1350c037d297a" translate="yes" xml:space="preserve">
          <source>It is an error to have index values out of bounds:</source>
          <target state="translated">인덱스 값이 범위를 벗어난 것은 오류입니다.</target>
        </trans-unit>
        <trans-unit id="9bd3e350ace36c053f4770c254bc8bbc0ed59492" translate="yes" xml:space="preserve">
          <source>It is assumed that all indices of &lt;code&gt;x&lt;/code&gt; are summed over in the product, together with the rightmost indices of &lt;code&gt;a&lt;/code&gt;, as is done in, for example, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt;.</source>
          <target state="translated">모든 인덱스 것으로한다 &lt;code&gt;x&lt;/code&gt; 함께 우측의 인덱스와, 제품에 합산된다 로서 이루어, 예를 들면, &lt;code&gt;tensordot(a, x, axes=b.ndim)&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="58008c74c97fe4d3ae3f9ae78ab47043dddec099" translate="yes" xml:space="preserve">
          <source>It is available from:</source>
          <target state="translated">다음에서 구할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7dcbab26b74b24d5b23e3d1dfbaa7bb550a61f" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects for dealing with polynomials:</source>
          <target state="translated">다항식을 처리 하기 위해 &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; 객체 를 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="ee3d89b7c311757a10611a623afead7359a99d73" translate="yes" xml:space="preserve">
          <source>It is convenient to use &lt;code&gt;poly1d&lt;/code&gt; objects for dealing with polynomials:</source>
          <target state="translated">다항식을 처리 하기 위해 &lt;code&gt;poly1d&lt;/code&gt; 객체 를 사용하는 것이 편리합니다 .</target>
        </trans-unit>
        <trans-unit id="f0b5d505c1b6aa0449adcda591bae28c54d28b79" translate="yes" xml:space="preserve">
          <source>It is difficult to distribute an extension module made using ctypes because of a lack of support for building shared libraries in distutils (but I suspect this will change in time).</source>
          <target state="translated">distutils에서 공유 라이브러리를 빌드하는 데 대한 지원이 부족하기 때문에 ctypes를 사용하여 만든 확장 모듈을 배포하기가 어렵습니다 (하지만 시간이 지나면 바뀔 것이라고 생각합니다).</target>
        </trans-unit>
        <trans-unit id="f6233db9ea353c629e411da73701b45f43b34d4b" translate="yes" xml:space="preserve">
          <source>It is easy to lose a clean separation between Python and C which makes re-using your C-code for other non-Python-related projects more difficult.</source>
          <target state="translated">Python과 C 사이의 명확한 분리를 잃기 쉽기 때문에 Python과 관련이없는 다른 프로젝트에 C 코드를 재사용하기가 더 어려워집니다.</target>
        </trans-unit>
        <trans-unit id="09772c45572066c0ab1839c5da61b341c459c08d" translate="yes" xml:space="preserve">
          <source>It is equivalent to &lt;code&gt;reshape(-1, order=order)&lt;/code&gt;.</source>
          <target state="translated">또한 동등 &lt;code&gt;reshape(-1, order=order)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8649182deb90f9e5b82c97ccd124c9f5e91bbefa" translate="yes" xml:space="preserve">
          <source>It is expected that function &lt;code&gt;func&lt;/code&gt; has been defined externally. In order to use a Python function as &lt;code&gt;func&lt;/code&gt;, it must have an attribute &lt;code&gt;intent(callback)&lt;/code&gt; (it must be specified before the &lt;code&gt;external&lt;/code&gt; statement).</source>
          <target state="translated">함수 &lt;code&gt;func&lt;/code&gt; 가 외부에서 정의 된 것으로 예상 됩니다. Python 함수를 &lt;code&gt;func&lt;/code&gt; 로 사용하려면 인 &lt;code&gt;intent(callback)&lt;/code&gt; 속성 이 있어야합니다 ( &lt;code&gt;external&lt;/code&gt; 문 앞에 지정되어야 함 ).</target>
        </trans-unit>
        <trans-unit id="41074d06eaa1aca6cfcc81add0a6d4a0de1496e0" translate="yes" xml:space="preserve">
          <source>It is expected that the Council Members will be employed at a wide range of companies, universities and non-profit organizations. Because of this, it is possible that Members will have conflict of interests. Such conflict of interests include, but are not limited to:</source>
          <target state="translated">위원회 회원은 다양한 회사, 대학 및 비영리 단체에서 고용 될 것으로 예상됩니다. 이로 인해 회원의 이해 상충이 발생할 수 있습니다. 이러한 이해 상충에는 다음이 포함되지만 이에 국한되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="e897ba8d8d1e35fdbcdafccfd6dd8ffccaf71314" translate="yes" xml:space="preserve">
          <source>It is good practice to tell &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; who you are, for labeling any changes you make to the code. The simplest way to do this is from the command line:</source>
          <target state="translated">코드에 대한 변경 사항에 레이블을 지정하기 위해 자신이 누구 인지 &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; 에게 알리는 것이 좋습니다 . 이 작업을 수행하는 가장 간단한 방법은 명령 줄을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9c72b281ec77874c2a8219572de87ebec10916f2" translate="yes" xml:space="preserve">
          <source>It is important to keep in mind that you get a &lt;em&gt;borrowed&lt;/em&gt; reference to the object when using the &amp;ldquo;O&amp;rdquo; format string. However, the converter functions usually require some form of memory handling. In this example, if the conversion is successful, &lt;em&gt;dtype&lt;/em&gt; will hold a new reference to a &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr *&lt;/code&gt;&lt;/a&gt; object, while &lt;em&gt;input&lt;/em&gt; will hold a borrowed reference. Therefore, if this conversion were mixed with another conversion (say to an integer) and the data-type conversion was successful but the integer conversion failed, then you would need to release the reference count to the data-type object before returning. A typical way to do this is to set &lt;em&gt;dtype&lt;/em&gt; to &lt;code&gt;NULL&lt;/code&gt; before calling &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; and then use &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt;&lt;code&gt;Py_XDECREF&lt;/code&gt;&lt;/a&gt; on &lt;em&gt;dtype&lt;/em&gt; before returning.</source>
          <target state="translated">&quot;O&quot;형식 문자열을 사용할 때 객체에 대한 &lt;em&gt;차용 된&lt;/em&gt; 참조를 얻는다는 점을 명심하는 것이 중요 합니다. 그러나 변환기 기능에는 일반적으로 어떤 형태의 메모리 처리가 필요합니다. 이 예제에서 변환이 성공하면 &lt;em&gt;dtype&lt;/em&gt; 은 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr *&lt;/code&gt; &lt;/a&gt; 객체에 대한 새 참조를 보유하고 &lt;em&gt;입력&lt;/em&gt; 은 빌린 참조를 보유합니다. 따라서이 변환이 다른 변환 (예 : 정수)과 혼합되고 데이터 유형 변환이 성공했지만 정수 변환이 실패한 경우 반환하기 전에 데이터 유형 개체에 대한 참조 횟수를 해제해야합니다. 이를 수행하는 일반적인 방법은 호출하기 전에 &lt;em&gt;dtype&lt;/em&gt; 을 &lt;code&gt;NULL&lt;/code&gt; 로 설정 하는 것입니다.&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 다음반환하기 전에&lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_XDECREF&quot;&gt; &lt;code&gt;Py_XDECREF&lt;/code&gt; &lt;/a&gt; 에&lt;em&gt; Py_XDECREF&lt;/em&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="68e5e295697e350544ce52515eda2757f41a1612" translate="yes" xml:space="preserve">
          <source>It is important to keep the flags updated (using &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt;&lt;code&gt;PyArray_UpdateFlags&lt;/code&gt;&lt;/a&gt; can help) whenever a manipulation with an array is performed that might cause them to change. Later calculations in NumPy that rely on the state of these flags do not repeat the calculation to update them.</source>
          <target state="translated">배열을 조작 할 때마다 변경 될 수 있는 플래그를 &lt;a href=&quot;#c.PyArray_UpdateFlags&quot;&gt; &lt;code&gt;PyArray_UpdateFlags&lt;/code&gt; &lt;/a&gt; 를 사용하여 업데이트 된 상태로 유지하는 것이 중요합니다 . 이 플래그의 상태에 의존하는 NumPy의 이후 계산은 계산을 반복하여 업데이트하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6dd28e38486b7b23cc628bcffec168f7a3e2908d" translate="yes" xml:space="preserve">
          <source>It is important to note that once the iterator is exited, dangling references (like &lt;code&gt;x&lt;/code&gt; in the example) may or may not share data with the original data &lt;code&gt;a&lt;/code&gt;. If writeback semantics were active, i.e. if &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt;, then exiting the iterator will sever the connection between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt;, writing to &lt;code&gt;x&lt;/code&gt; will no longer write to &lt;code&gt;a&lt;/code&gt;. If writeback semantics are not active, then &lt;code&gt;x.data&lt;/code&gt; will still point at some part of &lt;code&gt;a.data&lt;/code&gt;, and writing to one will affect the other.</source>
          <target state="translated">반복자가 종료되면 매달려있는 참조 (예 : &lt;code&gt;x&lt;/code&gt; 와 같은 )가 원본 데이터 &lt;code&gt;a&lt;/code&gt; 와 데이터를 공유하거나 공유하지 않을 수 있습니다 . 라이트 백 의미가 활성 인 경우에 경우, 즉 &lt;code&gt;x.base.flags.writebackifcopy&lt;/code&gt; 이 있다 &lt;code&gt;True&lt;/code&gt; , 그 반복자 사이의 연결이 끊어 것이다 종료 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 쓰기하지, &lt;code&gt;x&lt;/code&gt; 로는 더 이상 쓰기 . 후기 입 시맨틱이 활성화되지 않은 경우 &lt;code&gt;x.data&lt;/code&gt; 는 여전히 &lt;code&gt;a.data&lt;/code&gt; 의 일부를 가리키며 하나에 쓰면 다른 쪽에도 영향을 미칩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="63bda28ddda57fde741844f509673a49e4004752" translate="yes" xml:space="preserve">
          <source>It is important to retain an archive of all activities of this committee to ensure consistency in behavior and provide institutional memory for the project. To assist in this, the default channel of discussion for this committee will be a private mailing list accessible to current and future members of the committee as well as members of the Steering Council upon justified request. If the Committee finds the need to use off-list communications (e.g. phone calls for early/rapid response), it should in all cases summarize these back to the list so there&amp;rsquo;s a good record of the process.</source>
          <target state="translated">행동의 일관성을 보장하고 프로젝트에 대한 제도적 기억을 제공하기 위해이위원회의 모든 활동에 대한 아카이브를 유지하는 것이 중요합니다. 이를 지원하기 위해이위원회의 기본 토론 채널은 정당한 요청에 따라 현재 및 미래의위원회 구성원과 운영위원회 구성원이 액세스 할 수있는 비공개 메일 링 목록입니다. 위원회가 목록에서 벗어난 커뮤니케이션 (예 : 조기 / 신속 대응을위한 전화 통화)을 사용해야한다고 판단하면 모든 경우에이를 목록에 다시 요약하여 프로세스에 대한 좋은 기록을 확보해야합니다.</target>
        </trans-unit>
        <trans-unit id="a263f6ef91dbde8a42fa624ef445c812e662a622" translate="yes" xml:space="preserve">
          <source>It is intended that all polynomial instances are immutable, therefore augmented operations (&lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, etc.) and any other functionality that would violate the immutablity of a polynomial instance are intentionally unimplemented.</source>
          <target state="translated">모든 다항식 인스턴스는 변경할 수 없으므로 확장 연산 ( &lt;code&gt;+=&lt;/code&gt; , &lt;code&gt;-=&lt;/code&gt; 등) 및 다항식 인스턴스의 불변성을 위반하는 기타 기능은 의도적으로 구현되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b8f2e17893170efcb86b57f32479a3f40a7b944" translate="yes" xml:space="preserve">
          <source>It is named for the American linguist George Kingsley Zipf, who noted that the frequency of any word in a sample of a language is inversely proportional to its rank in the frequency table.</source>
          <target state="translated">그것은 언어학자인 조지 킹슬리 지프 (George Kingsley Zipf)의 이름을 따서 명명되었습니다.</target>
        </trans-unit>
        <trans-unit id="21e4b23be2d40c69036b3d2e468ea13e53868304" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear</source>
          <target state="translated">더 이상이 클래스를 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="c8350ce47be17c20baa97fc4d0754bec81b2f208" translate="yes" xml:space="preserve">
          <source>It is no longer recommended to use this class, even for linear algebra. Instead use regular arrays. The class may be removed in the future.</source>
          <target state="translated">선형 대수에도이 클래스를 사용하지 않는 것이 좋습니다. 대신 일반 배열을 사용하십시오. 수업은 나중에 제거 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c5239a5bff654c37cc55078706d5d6b20118c0c" translate="yes" xml:space="preserve">
          <source>It is not always possible to change the shape of an array without copying the data. If you want an error to be raised when the data is copied, you should assign the new shape to the shape attribute of the array:</source>
          <target state="translated">데이터를 복사하지 않고 배열의 모양을 변경할 수있는 것은 아닙니다. 데이터를 복사 할 때 오류가 발생하도록하려면 배열의 모양 속성에 새 모양을 지정해야합니다.</target>
        </trans-unit>
        <trans-unit id="656bf2f4ae8187e5defb4f5552faf2fbd1f5fad1" translate="yes" xml:space="preserve">
          <source>It is not difficult to create your own ufunc. All that is required is a 1-d loop for each data-type you want to support. Each 1-d loop must have a specific signature, and only ufuncs for fixed-size data-types can be used. The function call used to create a new ufunc to work on built-in data-types is given below. A different mechanism is used to register ufuncs for user-defined data-types.</source>
          <target state="translated">자신 만의 ufunc를 만드는 것은 어렵지 않습니다. 필요한 것은 지원하려는 각 데이터 유형에 대한 1-d 루프입니다. 각 1-d 루프에는 특정 서명이 있어야하며 고정 크기 데이터 유형에 대한 ufunc 만 사용할 수 있습니다. 내장 데이터 유형에서 작업 할 새 ufunc를 만드는 데 사용되는 함수 호출은 다음과 같습니다. 사용자 정의 데이터 유형에 대한 ufunc를 등록하는 데 다른 메커니즘이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8b548648b06bad09d9ab843a8e5797d1798c5b5" translate="yes" xml:space="preserve">
          <source>It is not necessary to use the doctest markup &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; to indicate empty lines in the output. Note that the option to run the examples through &lt;code&gt;numpy.test&lt;/code&gt; is provided for checking if the examples work, not for making the examples part of the testing framework.</source>
          <target state="translated">출력에서 빈 줄을 나타 내기 위해 doctest 마크 업 &lt;code&gt;&amp;lt;BLANKLINE&amp;gt;&lt;/code&gt; 을 사용할 필요는 없습니다 . &lt;code&gt;numpy.test&lt;/code&gt; 를 통해 예제를 실행하는 옵션은 예제를 테스트 프레임 워크의 일부로 만드는 것이 아니라 예제가 작동하는지 확인하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="b37f77a2246e7fcb1e0b4774efe6b903d4205875" translate="yes" xml:space="preserve">
          <source>It is often seen in Bayesian inference and order statistics.</source>
          <target state="translated">베이지안 추론 및 순서 통계에서 종종 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7bef780e922069dd57c2e5a08856175d82409e4f" translate="yes" xml:space="preserve">
          <source>It is one of a class of extreme value distributions, the Generalized Extreme Value (GEV) distributions, which also includes the Weibull and Frechet.</source>
          <target state="translated">이는 Weibull 및 Frechet을 포함하는 GEV (Generalized Extreme Value) 분포의 극한값 분포 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="5071b59a11ab8c54d2368dbe31b14e825424a9ec" translate="yes" xml:space="preserve">
          <source>It is possible to index arrays with other arrays for the purposes of selecting lists of values out of arrays into new arrays. There are two different ways of accomplishing this. One uses one or more arrays of index values. The other involves giving a boolean array of the proper shape to indicate the values to be selected. Index arrays are a very powerful tool that allow one to avoid looping over individual elements in arrays and thus greatly improve performance.</source>
          <target state="translated">배열에서 값 목록을 새 배열로 선택하기 위해 다른 배열로 배열을 인덱싱 할 수 있습니다. 이를 수행하는 방법에는 두 가지가 있습니다. 하나는 하나 이상의 인덱스 값 배열을 사용합니다. 다른 하나는 선택할 값을 나타 내기 위해 적절한 모양의 부울 배열을 제공하는 것입니다. 인덱스 배열은 배열의 개별 요소에 대한 반복을 방지하여 성능을 크게 향상시킬 수있는 매우 강력한 도구입니다.</target>
        </trans-unit>
        <trans-unit id="36000cdc40cdbba3e0e5f28ba7dcb30e267b4506" translate="yes" xml:space="preserve">
          <source>It is possible to load a library using &amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll[&amp;lt;full_path_name&amp;gt;] # doctest: +SKIP</source>
          <target state="translated">&amp;gt;&amp;gt;&amp;gt; lib = ctypes.cdll [&amp;lt;full_path_name&amp;gt;] # doctest : + SKIP를 사용하여 라이브러리를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38fbbd2c67dc08fbfcb5c5de50ecf788043a91ae" translate="yes" xml:space="preserve">
          <source>It is possible to slice and stride arrays to extract arrays of the same number of dimensions, but of different sizes than the original. The slicing and striding works exactly the same way it does for lists and tuples except that they can be applied to multiple dimensions as well. A few examples illustrates best:</source>
          <target state="translated">슬라이스 및 스트라이드 배열을 사용하여 크기는 동일하지만 원본과 다른 크기의 배열을 추출 할 수 있습니다. 슬라이싱 및 스트 라이딩은 여러 차원에도 적용 할 수 있다는 점을 제외하면 목록과 튜플에 대해 수행하는 것과 똑같은 방식으로 작동합니다. 몇 가지 예가 가장 좋습니다.</target>
        </trans-unit>
        <trans-unit id="0a211923eef6c9018ec875b45f1ee8aa7feb24f0" translate="yes" xml:space="preserve">
          <source>It is possible to specify config_fc options in setup.py scripts. For example, using</source>
          <target state="translated">setup.py 스크립트에서 config_fc 옵션을 지정할 수 있습니다. 예를 들어</target>
        </trans-unit>
        <trans-unit id="3af7692eade07c544a49c1e0a3fa2b4f67d86e02" translate="yes" xml:space="preserve">
          <source>It is possible to specify how boundaries are treated using &lt;code&gt;edge_order&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;edge_order&lt;/code&gt; 를 사용하여 경계를 처리하는 방법을 지정할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="425695dd90c5cd68dc182714b9d0871e6107582e" translate="yes" xml:space="preserve">
          <source>It is possible to use methods from linear algebra to approximate an existing set of data. Here, we will use the &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/a&gt; to try to rebuild an image that uses less singular value information than the original one, while still retaining some of its features.</source>
          <target state="translated">선형 대수의 방법을 사용하여 기존 데이터 세트를 근사화 할 수 있습니다. 여기에서는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;SVD (Singular Value Decomposition)&lt;/a&gt; 를 사용하여 원본보다 더 적은 특이 값 정보를 사용하는 이미지를 재 구축하면서 일부 기능은 그대로 유지합니다.</target>
        </trans-unit>
        <trans-unit id="9279d7909405dcb9e4e547b0701fbd4a212eac71" translate="yes" xml:space="preserve">
          <source>It is possible to use special features to effectively increase the number of dimensions in an array through indexing so the resulting array acquires the shape needed for use in an expression or with a specific function.</source>
          <target state="translated">특수 기능을 사용하여 인덱싱을 통해 배열의 차원 수를 효과적으로 늘릴 수 있으므로 결과 배열이 표현식 또는 특정 함수에 사용하는 데 필요한 모양을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="006848dc30e65d20b3919e74b2fa41c8170663f6" translate="yes" xml:space="preserve">
          <source>It is recommended to use one of &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt;&lt;code&gt;assert_allclose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt;&lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt;&lt;code&gt;assert_array_max_ulp&lt;/code&gt;&lt;/a&gt; instead of this function for more consistent floating point comparisons.</source>
          <target state="translated">보다 일관된 부동 소수점 비교를 위해이 함수 대신 &lt;a href=&quot;numpy.testing.assert_allclose#numpy.testing.assert_allclose&quot;&gt; &lt;code&gt;assert_allclose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.testing.assert_array_almost_equal_nulp#numpy.testing.assert_array_almost_equal_nulp&quot;&gt; &lt;code&gt;assert_array_almost_equal_nulp&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.testing.assert_array_max_ulp#numpy.testing.assert_array_max_ulp&quot;&gt; &lt;code&gt;assert_array_max_ulp&lt;/code&gt; &lt;/a&gt; 중 하나를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="e411ddee11ac634d5c4281835040dc7466b061ac" translate="yes" xml:space="preserve">
          <source>It is strongly advised &lt;em&gt;not&lt;/em&gt; to use the matrix subclass. As described below, it makes writing functions that deal consistently with matrices and regular arrays very difficult. Currently, they are mainly used for interacting with &lt;code&gt;scipy.sparse&lt;/code&gt;. We hope to provide an alternative for this use, however, and eventually remove the &lt;code&gt;matrix&lt;/code&gt; subclass.</source>
          <target state="translated">매트릭스 서브 클래스를 사용 &lt;em&gt;하지 않는&lt;/em&gt; 것이 좋습니다 . 아래에서 설명하는 것처럼 행렬과 일반 배열을 일관되게 처리하는 함수를 작성하는 것은 매우 어렵습니다. 현재 주로 &lt;code&gt;scipy.sparse&lt;/code&gt; 와 상호 작용하는 데 사용됩니다 . 그러나이 사용에 대한 대안을 제공하고 결국 &lt;code&gt;matrix&lt;/code&gt; 서브 클래스를 제거하기를 희망합니다 .</target>
        </trans-unit>
        <trans-unit id="7669de0e65d605729606ade6c00d09dc551353c4" translate="yes" xml:space="preserve">
          <source>It is used, for example, in modeling the over-reporting of insurance claims.</source>
          <target state="translated">예를 들어 보험 청구의 초과보고를 모델링하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="ca0ecc89a435e5703a52f043959e28e66dbb2433" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 에서 상속하지 않는 클래스를 작성하는 데 유용 하지만 &lt;a href=&quot;../../neps/nep-0013-ufunc-overrides&quot;&gt;Ufuncs 재정의 메커니즘에&lt;/a&gt; 설명 된대로 배열과 같은 산술 및 numpy 범용 함수를 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e32c0ef1527073446df56f2f6fdb74c9774fe25a" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 에서 상속되지 않지만 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/neps/nep-0013-ufunc-overrides.html&quot;&gt;Ufuncs를 재정의하는 메커니즘에&lt;/a&gt; 설명 된 것처럼 배열과 같은 산술 및 numpy 범용 함수를 지원 해야하는 클래스를 작성하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="9bbe090da186f95bac0feca86884d8bee85c4509" translate="yes" xml:space="preserve">
          <source>It is useful for writing classes that do not inherit from &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, but that should support arithmetic and numpy universal functions like arrays as described in &lt;a href=&quot;https://numpy.org/neps/nep-0013-ufunc-overrides.html&quot;&gt;A Mechanism for Overriding Ufuncs&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 에서 상속하지 않는 클래스를 작성하는 데 유용 하지만 &lt;a href=&quot;https://numpy.org/neps/nep-0013-ufunc-overrides.html&quot;&gt;Ufuncs 재정의 메커니즘에&lt;/a&gt; 설명 된대로 배열과 같은 산술 및 numpy 범용 함수를 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="d3b8ad76686cc18b830ba552fba24082c4f933e5" translate="yes" xml:space="preserve">
          <source>It is worth noting that if</source>
          <target state="translated">만약에</target>
        </trans-unit>
        <trans-unit id="29b82dd1d6f270f96b8bc45104bc41a8e589f966" translate="yes" xml:space="preserve">
          <source>It isn&amp;rsquo;t always convenient to explicitly use Polynomial instances, so tuples, lists, arrays, and scalars are automatically cast in the arithmetic operations:</source>
          <target state="translated">다항식 인스턴스를 명시 적으로 사용하는 것이 항상 편리한 것은 아니므로 튜플, 목록, 배열 및 스칼라는 산술 연산에서 자동으로 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="cf495221779c2163a5e7a39d1bf1b540324c978b" translate="yes" xml:space="preserve">
          <source>It landed 4 times on 1, once on 2, etc.</source>
          <target state="translated">1에 4 번, 2 번에 1 번 착륙했습니다.</target>
        </trans-unit>
        <trans-unit id="d1653963d10a9096aa75746f96dbe0fd1387381e" translate="yes" xml:space="preserve">
          <source>It may also be convenient to define a custom decorators (&lt;code&gt;implements&lt;/code&gt; below) for registering &lt;code&gt;__array_function__&lt;/code&gt; implementations.</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 구현 을 등록하기 위해 사용자 정의 데코레이터 ( 아래 &lt;code&gt;implements&lt;/code&gt; ) 를 정의하는 것이 편리 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15b8b5878ae11de1a6686f5f6b72cb728b7b2d6b" translate="yes" xml:space="preserve">
          <source>It may be helpful to have a copy of the pull request code checked out on your own machine so that you can play with it locally. You can use the &lt;a href=&quot;https://docs.github.com/en/github/getting-started-with-github/github-cli&quot;&gt;GitHub CLI&lt;/a&gt; to do this by clicking the &lt;code&gt;Open with&lt;/code&gt; button in the upper right-hand corner of the PR page.</source>
          <target state="translated">로컬에서 플레이 할 수 있도록 풀 리퀘스트 코드의 사본을 자신의 머신에서 체크 아웃하는 것이 도움이 될 수 있습니다. 당신은 사용할 수 &lt;a href=&quot;https://docs.github.com/en/github/getting-started-with-github/github-cli&quot;&gt;GitHub의 CLI를&lt;/a&gt; 딸깍하여이 작업을 수행 할 수 &lt;code&gt;Open with&lt;/code&gt; 홍보 페이지의 오른쪽 상단에있는 버튼을 누릅니다.</target>
        </trans-unit>
        <trans-unit id="3598c5e5543d6be85e81adfe21a8be7084de89d0" translate="yes" xml:space="preserve">
          <source>It may be preferable to split the projected cashflow into an initial investment and expected future cashflows. In this case, the value of the initial cashflow is zero and the initial investment is later added to the future cashflows net present value:</source>
          <target state="translated">예상 현금 흐름을 초기 투자와 예상 미래 현금 흐름으로 나누는 것이 바람직 할 수 있습니다. 이 경우 초기 현금 흐름의 가치는 0이고 초기 투자는 나중에 미래 현금 흐름의 순 현재 가치에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="0c144448b26d1bb5e1e573955f886137b35b8bc6" translate="yes" xml:space="preserve">
          <source>It may be the case that while you were working on your edits, new commits have been added to &lt;code&gt;upstream&lt;/code&gt; that affect your work. In this case, follow the &lt;a href=&quot;#rebasing-on-master&quot;&gt;Rebasing on master&lt;/a&gt; section of this document to apply those changes to your branch.</source>
          <target state="translated">편집 작업을하는 동안 작업에 영향을 미치는 새 커밋이 &lt;code&gt;upstream&lt;/code&gt; 에 추가 된 경우 일 수 있습니다. 이 경우이 문서의 &lt;a href=&quot;#rebasing-on-master&quot;&gt;마스터에 기반하기&lt;/a&gt; 섹션 에 따라 변경 사항을 브랜치에 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="61a2cf7173d1c99310b82e23b09fc16ccfa711fb" translate="yes" xml:space="preserve">
          <source>It often happens that the memory that you want to view with an array is not of the same byte ordering as the computer on which you are running Python.</source>
          <target state="translated">배열로 보려는 메모리가 Python을 실행하는 컴퓨터와 동일한 바이트 순서가 아닌 경우가 종종 발생합니다.</target>
        </trans-unit>
        <trans-unit id="72a7758d8c4a1616265a421ff54b57ab65811e7b" translate="yes" xml:space="preserve">
          <source>It permits an elegant do-what-I-mean behavior where, for instance, adding a scalar to a vector adds the scalar value to every element.</source>
          <target state="translated">예를 들어 벡터에 스칼라를 추가하면 모든 요소에 스칼라 값이 추가되는 우아한 do-what-I-mean 동작이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="eaadd007be7687e8c25f3eb461c4399e71de7888" translate="yes" xml:space="preserve">
          <source>It should be clear that any structured type could be described using this interface.</source>
          <target state="translated">이 인터페이스를 사용하여 구조화 된 유형을 설명 할 수 있음을 분명히해야합니다.</target>
        </trans-unit>
        <trans-unit id="40b700e9c3136bc2579dd22e6d2f087fce1952e9" translate="yes" xml:space="preserve">
          <source>It should be emphasized at this point that you may not need the array iterator if your array is already contiguous (using an array iterator will work but will be slower than the fastest code you could write). The major purpose of array iterators is to encapsulate iteration over N-dimensional arrays with arbitrary strides. They are used in many, many places in the NumPy source code itself. If you already know your array is contiguous (Fortran or C), then simply adding the element- size to a running pointer variable will step you through the array very efficiently. In other words, code like this will probably be faster for you in the contiguous case (assuming doubles).</source>
          <target state="translated">이 시점에서 배열이 이미 연속적인 경우 배열 반복기가 필요하지 않을 수 있다는 점을 강조해야합니다 (배열 반복기를 사용하면 작동하지만 작성할 수있는 가장 빠른 코드보다 느립니다). 배열 반복기의 주요 목적은 임의의 보폭으로 N 차원 배열에 대한 반복을 캡슐화하는 것입니다. NumPy 소스 코드 자체의 많은 곳에서 사용됩니다. 배열이 연속적임을 이미 알고있는 경우 (Fortran 또는 C) 실행중인 포인터 변수에 element-size를 추가하면 배열을 매우 효율적으로 진행할 수 있습니다. 즉, 이와 같은 코드는 연속적인 경우 (복식 가정)에서 더 빠를 것입니다.</target>
        </trans-unit>
        <trans-unit id="026d73ab6dffc63b48ab1902fa6d889c8def5bcb" translate="yes" xml:space="preserve">
          <source>It uses a &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; rather than the more modern &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">보다 현대적인 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 대신 &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="18504c66aebcc566a9cf5db146c843b0920c0fed" translate="yes" xml:space="preserve">
          <source>It uses global state, which means results will change as the code changes</source>
          <target state="translated">전역 상태를 사용하므로 코드가 변경되면 결과가 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="f377563feb8e5b75d15a1cc4f00304a3153cefc3" translate="yes" xml:space="preserve">
          <source>It works in 2-D as well:</source>
          <target state="translated">2D에서도 작동합니다.</target>
        </trans-unit>
        <trans-unit id="61cf279216973943c4725d4d79877589268acf41" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s clear that masked arrays are the right solution here. We cannot represent the missing data without mischaracterizing the evolution of the curve.</source>
          <target state="translated">여기서 마스킹 된 배열이 올바른 솔루션이라는 것은 분명합니다. 곡선의 진화를 잘못 파악하지 않고는 누락 된 데이터를 나타낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e168152d8a6d565c340c6f98aabefe43987e5068" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s common to need to transpose your matrices. NumPy arrays have the property &lt;code&gt;T&lt;/code&gt; that allows you to transpose a matrix.</source>
          <target state="translated">행렬을 전치해야하는 것이 일반적입니다. NumPy 배열에는 행렬을 전치 할 수있는 &lt;code&gt;T&lt;/code&gt; 속성 이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a604443bcd6724527af1c5d434ed815a21fd057" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s easy to save and load and array with &lt;code&gt;np.save()&lt;/code&gt;. Just make sure to specify the array you want to save and a file name. For example, if you create this array:</source>
          <target state="translated">&lt;code&gt;np.save()&lt;/code&gt; 로 저장하고로드하고 배열하는 것은 쉽습니다 . 저장하려는 배열과 파일 이름을 지정하십시오. 예를 들어, 다음 배열을 생성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="bb5dacd50e546c91bb0023917cb217930a8f4581" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to assign to copy-on-write array, but values are only written into the memory copy of the array, and not written to disk:</source>
          <target state="translated">COW (Copy-On-Write) 배열에 할당 할 수 있지만 값은 배열의 메모리 사본에만 기록되고 디스크에는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a0ce98ff31bde352ed1c0c91f62805b6675f308" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with &lt;code&gt;numpy.distutils&lt;/code&gt; with the &lt;code&gt;-j&lt;/code&gt; option; see &lt;a href=&quot;../user/building#parallel-builds&quot;&gt;Parallel builds&lt;/a&gt; for more details.</source>
          <target state="translated">&lt;code&gt;-j&lt;/code&gt; 옵션을 사용하여 &lt;code&gt;numpy.distutils&lt;/code&gt; 로 병렬 빌드를 수행 할 수 있습니다. 자세한 내용 은 &lt;a href=&quot;../user/building#parallel-builds&quot;&gt;병렬 빌드&lt;/a&gt; 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="4121d3718e690b8fea8d720656c256ae8ee8cf80" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to do a parallel build with:</source>
          <target state="translated">다음을 사용하여 병렬 빌드를 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="964de6d6253a84ec110383e1255be2951c5d85d8" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s possible to mutate the dtype of an array at runtime. For example, the following code is valid:</source>
          <target state="translated">런타임에 배열의 dtype을 변경할 수 있습니다. 예를 들어 다음 코드는 유효합니다.</target>
        </trans-unit>
        <trans-unit id="2a92fc5de8c1d7511c762594edc421f16b236424" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s recommended to specify only those config_fc options in such a way that are compiler independent.</source>
          <target state="translated">컴파일러와 독립적 인 방식으로 해당 config_fc 옵션 만 지정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d6aa98a684b303867919f656c9319be29d7ca44f" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="translated">기존 정보가 포함 된 CSV로 쉽게 읽을 수 있습니다. 이를 수행하는 가장 쉽고 쉬운 방법은 &lt;a href=&quot;https://pandas.pydata.org&quot;&gt;Pandas&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="0753c18f0b1243f25af624a4511a2035947276c3" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to read in a CSV that contains existing information. The best and easiest way to do this is to use &lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt;.</source>
          <target state="translated">기존 정보가 포함 된 CSV로 쉽게 읽을 수 있습니다. 이를 수행하는 가장 쉽고 쉬운 방법은 &lt;a href=&quot;https://pandas.pydata.org/getpandas.html&quot;&gt;Pandas&lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="14495a2289a19a1e28ed57bed5a4a3a49edf0b4e" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s simple to use Pandas in order to export your array as well. If you are new to NumPy, you may want to create a Pandas dataframe from the values in your array and then write the data frame to a CSV file with Pandas.</source>
          <target state="translated">배열을 내보내기 위해 Pandas를 사용하는 것은 간단합니다. NumPy를 처음 사용하는 경우 배열의 값에서 Pandas 데이터 프레임을 만든 다음 Pandas를 사용하여 데이터 프레임을 CSV 파일에 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060cec9479c0c03cb8146120d17fc1e1fd50e074" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s usually a good idea to use the &lt;code&gt;-n&lt;/code&gt; flag to &lt;code&gt;git push&lt;/code&gt; to check first that you&amp;rsquo;re about to push the changes you want to the place you want.</source>
          <target state="translated">일반적으로 &lt;code&gt;-n&lt;/code&gt; 플래그 를 사용하여 &lt;code&gt;git push&lt;/code&gt; 를 사용하여 원하는 변경 사항을 원하는 위치로 푸시 할 것인지 먼저 확인 하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="85be1e8acbcf441a36b9c0c869cff5476c693c32" translate="yes" xml:space="preserve">
          <source>It&amp;rsquo;s very common to want to aggregate along a row or column. By default, every NumPy aggregation function will return the aggregate of the entire array. To find the sum or the minimum of the elements in your array, run:</source>
          <target state="translated">행이나 열을 따라 집계하는 것은 매우 일반적입니다. 기본적으로 모든 NumPy 집계 함수는 전체 배열의 집계를 반환합니다. 배열에서 요소의 합계 또는 최소값을 찾으려면 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c3a9e71b0cabb8c3a03cd16e13045b08078788b6" translate="yes" xml:space="preserve">
          <source>Item selection and manipulation</source>
          <target state="translated">품목 선택 및 조작</target>
        </trans-unit>
        <trans-unit id="867490709f6ff3383fa1fcfac4368fffd68d75ba" translate="yes" xml:space="preserve">
          <source>Items of an array of this data type are wrapped in an &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;array scalar&lt;/a&gt; type that also has two fields:</source>
          <target state="translated">이 데이터 형식의 배열 항목 은 두 개의 필드가 있는 &lt;a href=&quot;arrays.scalars#arrays-scalars&quot;&gt;배열 스칼라&lt;/a&gt; 형식으로 래핑 됩니다.</target>
        </trans-unit>
        <trans-unit id="7b5cbf04c6d27c2ce2fa2026bd76b8e62a482e6d" translate="yes" xml:space="preserve">
          <source>Iterating Over Arrays</source>
          <target state="translated">배열 반복</target>
        </trans-unit>
        <trans-unit id="61c7e36ee871033d37342fea4c9a477a22a3ad15" translate="yes" xml:space="preserve">
          <source>Iterating as a Specific Data Type</source>
          <target state="translated">특정 데이터 유형으로 반복</target>
        </trans-unit>
        <trans-unit id="d0332abd31d07a7d02dd3e33350dc402dcd2926d" translate="yes" xml:space="preserve">
          <source>Iterating over all but one axis</source>
          <target state="translated">하나를 제외한 모든 축에 대해 반복</target>
        </trans-unit>
        <trans-unit id="1844648c4af60a1a170cdaf38688443ce7ba666d" translate="yes" xml:space="preserve">
          <source>Iterating over arrays</source>
          <target state="translated">배열을 반복</target>
        </trans-unit>
        <trans-unit id="b05284699d8fb62b19954c2a16145ceb83ef59a3" translate="yes" xml:space="preserve">
          <source>Iterating over elements in the array</source>
          <target state="translated">배열의 요소 반복</target>
        </trans-unit>
        <trans-unit id="ab8467929e39862040c3a1bba747525fbb89952c" translate="yes" xml:space="preserve">
          <source>Iterating over multiple arrays</source>
          <target state="translated">여러 배열에서 반복</target>
        </trans-unit>
        <trans-unit id="3c8101d6360b4040707379e2577c7a16fa0bf84e" translate="yes" xml:space="preserve">
          <source>Iteration is done in row-major, C-style order (the last index varying the fastest). The iterator can also be indexed using basic slicing or advanced indexing.</source>
          <target state="translated">반복은 행 전공 C 스타일 순서로 수행됩니다 (마지막 색인이 가장 빠르게 변함). 반복자는 기본 슬라이싱 또는 고급 인덱싱을 사용하여 인덱싱 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acbcdc45d250ba7dd26edab06186cf3962745972" translate="yes" xml:space="preserve">
          <source>Iterator Data Types</source>
          <target state="translated">반복자 데이터 유형</target>
        </trans-unit>
        <trans-unit id="21aa412ed70b91ee6a2ff89a4abea36c2af42360" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt;&lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">반복자 플래그 &lt;a href=&quot;#c.NPY_ITER_COMMON_DTYPE&quot;&gt; &lt;code&gt;NPY_ITER_COMMON_DTYPE&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a1116d7dda5125208b276ad5471ddd5d08e64ba8" translate="yes" xml:space="preserve">
          <source>Iterator flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">반복자 플래그 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1b6f69b38ac0228e9245d67b9b1d09ee42bc5dcb" translate="yes" xml:space="preserve">
          <source>Iterator for broadcasting</source>
          <target state="translated">방송용 반복자</target>
        </trans-unit>
        <trans-unit id="6425854ab104811d699d59fa557478463a96d42e" translate="yes" xml:space="preserve">
          <source>Iterator-Allocated Output Arrays</source>
          <target state="translated">반복기 할당 출력 어레이</target>
        </trans-unit>
        <trans-unit id="3ea20b9878659e33fbac6ee844497cef84a926f4" translate="yes" xml:space="preserve">
          <source>Iterators are a powerful concept for array processing. Essentially, iterators implement a generalized for-loop. If &lt;em&gt;myiter&lt;/em&gt; is an iterator object, then the Python code:</source>
          <target state="translated">반복자는 배열 처리를위한 강력한 개념입니다. 기본적으로 반복자는 일반화 된 for-loop를 구현합니다. 경우 &lt;em&gt;myiter는&lt;/em&gt; 반복자 객체, 다음 파이썬 코드는 다음과 같습니다</target>
        </trans-unit>
        <trans-unit id="796f6321f3f35af9085ef4cf35c1d4e6f0e4b4dc" translate="yes" xml:space="preserve">
          <source>Its disadvantages include</source>
          <target state="translated">단점은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57d54f82f4390510a92d95c53ba668fb5b8d3f93" translate="yes" xml:space="preserve">
          <source>Its probability density function is</source>
          <target state="translated">확률 밀도 함수는</target>
        </trans-unit>
        <trans-unit id="58668e7669fd564d99db5d581fcdb6a5618440b5" translate="yes" xml:space="preserve">
          <source>J</source>
          <target state="translated">J</target>
        </trans-unit>
        <trans-unit id="a2cbec366193e4ee99c0016c5fe79f216b41e583" translate="yes" xml:space="preserve">
          <source>J. F. Kaiser, &amp;ldquo;Digital Filters&amp;rdquo; - Ch 7 in &amp;ldquo;Systems analysis by digital computer&amp;rdquo;, Editors: F.F. Kuo and J.F. Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</source>
          <target state="translated">JF Kaiser,&amp;ldquo;디지털 필터&amp;rdquo;&amp;ndash;&amp;ldquo;디지털 컴퓨터를 통한 시스템 분석&amp;rdquo;의 7 장, 편집자 : FF Kuo 및 JF Kaiser, p 218-285. John Wiley and Sons, New York, (1966).</target>
        </trans-unit>
        <trans-unit id="f458212a67f9dc847550889da59b7be8169fde2a" translate="yes" xml:space="preserve">
          <source>Jaime Fern&amp;aacute;ndez del R&amp;iacute;o</source>
          <target state="translated">하이메 페르난데스 델 리오</target>
        </trans-unit>
        <trans-unit id="ac739039ef04b0889d2ee40b8300f86d60f0119f" translate="yes" xml:space="preserve">
          <source>January 31, 2021</source>
          <target state="translated">2021 년 1 월 31 일</target>
        </trans-unit>
        <trans-unit id="d85b6dd0eee475b31af984e7ef5b76c826173395" translate="yes" xml:space="preserve">
          <source>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw, &amp;ldquo;Parallel Random Numbers: As Easy as 1, 2, 3,&amp;rdquo; Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis (SC11), New York, NY: ACM, 2011.</source>
          <target state="translated">John K. Salmon, Mark A. Moraes, Ron O. Dror 및 David E. Shaw,&amp;ldquo;병렬 난수 : 1, 2, 3만큼 쉬움&amp;rdquo;, 고성능 컴퓨팅, 네트워킹, 스토리지 및 분석 (SC11), 뉴욕, NY : ACM, 2011.</target>
        </trans-unit>
        <trans-unit id="5955c7d39672a39a399f419793e9d4b2998a0ae1" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along a new axis.</source>
          <target state="translated">새로운 축을 따라 일련의 배열을 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="4ea1c9ee9a15b3dcbf6e5bf8c6f47b37d396752b" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays along an existing axis.</source>
          <target state="translated">기존 축을 따라 일련의 배열을 결합합니다.</target>
        </trans-unit>
        <trans-unit id="c169b65bb5e75fcaa26f3cb74e710ac8d05e200a" translate="yes" xml:space="preserve">
          <source>Join a sequence of arrays together.</source>
          <target state="translated">일련의 배열을 함께 결합하십시오.</target>
        </trans-unit>
        <trans-unit id="a0cbf31ae389d3a2da5d14e49f527c1cd6c82518" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">key &lt;code&gt;key&lt;/code&gt; 에 배열 &lt;code&gt;r1&lt;/code&gt; 및 &lt;code&gt;r2&lt;/code&gt; 를 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="23191121c5e72da7ca4394cebd036d5824a4bf84" translate="yes" xml:space="preserve">
          <source>Join arrays &lt;code&gt;r1&lt;/code&gt; and &lt;code&gt;r2&lt;/code&gt; on keys. Alternative to join_by, that always returns a np.recarray.</source>
          <target state="translated">키에서 배열 &lt;code&gt;r1&lt;/code&gt; 및 &lt;code&gt;r2&lt;/code&gt; 를 결합합니다. join_by의 대안으로 항상 np.recarray를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ace77e0ad40f2680b6aa7f69f4dfbec0108a72b3" translate="yes" xml:space="preserve">
          <source>Join the sequence of objects in &lt;em&gt;obj&lt;/em&gt; together along &lt;em&gt;axis&lt;/em&gt; into a single array. If the dimensions or types are not compatible an error is raised.</source>
          <target state="translated">&lt;em&gt;obj&lt;/em&gt; 의 객체 시퀀스를 &lt;em&gt;축을&lt;/em&gt; 따라 단일 배열로 결합합니다. 치수 또는 유형이 호환되지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0b145a058f4f708ddeea141e56d4c1c7cea2454f" translate="yes" xml:space="preserve">
          <source>Join two or more pathname components + - convert a /-separated pathname to one using the OS&amp;rsquo;s path separator. - resolve  and  from path.</source>
          <target state="translated">둘 이상의 경로 이름 구성 요소 결합 +-OS의 경로 구분 기호를 사용하여 /로 구분 된 경로 이름을 하나로 변환합니다. -해결 및 경로에서.</target>
        </trans-unit>
        <trans-unit id="930021877100c692fce1a3c6407a5fca82ef8115" translate="yes" xml:space="preserve">
          <source>Joining arrays</source>
          <target state="translated">배열 결합</target>
        </trans-unit>
        <trans-unit id="853683e5afe4c33d14d4fe25be2e7a31fcdb24ae" translate="yes" xml:space="preserve">
          <source>Julian Taylor</source>
          <target state="translated">줄리안 테일러</target>
        </trans-unit>
        <trans-unit id="1ad4711cdf3c76bf58efbbfffae229363be1de78" translate="yes" xml:space="preserve">
          <source>July 26, 2019</source>
          <target state="translated">2019 년 7 월 26 일</target>
        </trans-unit>
        <trans-unit id="0ea4fce60f72408c555e74c1176fd49b9f6f546a" translate="yes" xml:space="preserve">
          <source>Jump Size</source>
          <target state="translated">점프 크기</target>
        </trans-unit>
        <trans-unit id="2f4eece64596ae5728be928b098daa67afdcbd49" translate="yes" xml:space="preserve">
          <source>Jumping the BitGenerator state</source>
          <target state="translated">BitGenerator 상태 점프</target>
        </trans-unit>
        <trans-unit id="edaececa3ce78905da5d0c8d3e5c155d40b3049c" translate="yes" xml:space="preserve">
          <source>Jumping to the next level of complexity, it is possible to only partially index an array with index arrays. It takes a bit of thought to understand what happens in such cases. For example if we just use one index array with y:</source>
          <target state="translated">다음 단계의 복잡성으로 넘어 가면 인덱스 배열로 배열을 부분적으로 만 인덱싱 할 수 있습니다. 그러한 경우에 어떤 일이 발생하는지 이해하려면 약간의 생각이 필요합니다. 예를 들어 y와 함께 하나의 인덱스 배열을 사용하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d3780087bf4b8552cfaeefd4ae432b76ab3d8ec4" translate="yes" xml:space="preserve">
          <source>Jumps the state as-if jumps * 210306068529402873165736369884012333109 random numbers have been generated.</source>
          <target state="translated">상태 그대로 점프 점프 * 210306068529402873165736369884012333109 난수가 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="e66b5685b9897c71dad3170faecd2518dfadece3" translate="yes" xml:space="preserve">
          <source>June 29, 2020</source>
          <target state="translated">2020 년 6 월 29 일</target>
        </trans-unit>
        <trans-unit id="f9d305a937478453054f4a6c27158c776273985e" translate="yes" xml:space="preserve">
          <source>Just for your own satisfaction, show yourself that you now have a new &amp;lsquo;remote&amp;rsquo;, with &lt;code&gt;git remote -v show&lt;/code&gt;, giving you something like:</source>
          <target state="translated">자신의 만족을 위해 &lt;code&gt;git remote -v show&lt;/code&gt; 를 사용하여 다음과 같은 새로운 '원격'이 있음을 보여 주세요.</target>
        </trans-unit>
        <trans-unit id="f8882074cfd8e824bd17a6e53a5a926e124e1b9b" translate="yes" xml:space="preserve">
          <source>Just like in other Python container objects, the contents of an array can be accessed and modified by indexing or slicing the array. Unlike the typical container objects, different arrays can share the same data, so changes made on one array might be visible in another.</source>
          <target state="translated">다른 Python 컨테이너 객체와 마찬가지로 배열의 내용은 배열을 인덱싱하거나 슬라이스하여 액세스하고 수정할 수 있습니다. 일반적인 컨테이너 객체와 달리 서로 다른 배열이 동일한 데이터를 공유 할 수 있으므로 한 배열에서 변경 한 내용이 다른 배열에서 표시 될 수 있습니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="c5a2ccc2c43427a5df3aae2525cebca91213ce58" translate="yes" xml:space="preserve">
          <source>Just like the case for builtin special methods like &lt;code&gt;__add__&lt;/code&gt;, properly written &lt;code&gt;__array_function__&lt;/code&gt; methods should always return &lt;code&gt;NotImplemented&lt;/code&gt; when an unknown type is encountered. Otherwise, it will be impossible to correctly override NumPy functions from another object if the operation also includes one of your objects.</source>
          <target state="translated">그냥 경우처럼 같은 특별한 방법 내장에 대한 &lt;code&gt;__add__&lt;/code&gt; 제대로 작성 &lt;code&gt;__array_function__&lt;/code&gt; 의 방법은 항상 반환해야 &lt;code&gt;NotImplemented&lt;/code&gt; 를 알 수없는 유형이 발견 될 때. 그렇지 않으면 작업에 개체 중 하나가 포함되어 있으면 다른 개체에서 NumPy 함수를 올바르게 재정의하는 것이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="a7ee38bb7be4fc44198cb2685d9601dcf2b9f569" translate="yes" xml:space="preserve">
          <source>K</source>
          <target state="translated">K</target>
        </trans-unit>
        <trans-unit id="fea9c97b23d277bbc25a4ecec464e976ad73c9d8" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike &lt;code&gt;seed&lt;/code&gt;, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Philox 주에서 사용하는 키입니다. &lt;code&gt;seed&lt;/code&gt; 와 달리 key의 값은 직접 설정됩니다. [0, 2 ** 128)의 Python int 또는 2 요소 uint64 배열 일 수 있습니다. &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;seed&lt;/code&gt; 를 모두 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="04e171a322d7a93c71ab2aebd91bfaf316577346" translate="yes" xml:space="preserve">
          <source>Key to use in the Philox state. Unlike seed, the value in key is directly set. Can be either a Python int in [0, 2**128) or a 2-element uint64 array. &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;seed&lt;/code&gt; cannot both be used.</source>
          <target state="translated">Philox 상태에서 사용하는 키입니다. 시드와 달리 키의 값은 직접 설정됩니다. [0, 2 ** 128)의 Python int 또는 2 요소 uint64 배열 일 수 있습니다. &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;seed&lt;/code&gt; 를 모두 사용할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="14feafb160591699224306cc83a22ae926c4f9db" translate="yes" xml:space="preserve">
          <source>Keyword arguments for &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;func&lt;/code&gt; 에 대한 키워드 인수 .</target>
        </trans-unit>
        <trans-unit id="a4f25f4e01bab825ac7968a35cf2573aecf46441" translate="yes" xml:space="preserve">
          <source>Keyword arguments passed to &lt;code&gt;func&lt;/code&gt;.</source>
          <target state="translated">키워드 인수가 &lt;code&gt;func&lt;/code&gt; 에 전달되었습니다 .</target>
        </trans-unit>
        <trans-unit id="936d17141932bddd8cdbe3cf3d8e6417d18816b5" translate="yes" xml:space="preserve">
          <source>Keyword arguments used in calling &lt;a href=&quot;#numpy.piecewise&quot;&gt;&lt;code&gt;piecewise&lt;/code&gt;&lt;/a&gt; are passed to the functions upon execution, i.e., if called &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt;, then each function is called as &lt;code&gt;f(x, alpha=1)&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.piecewise&quot;&gt; &lt;code&gt;piecewise&lt;/code&gt; &lt;/a&gt; 호출에 사용되는 키워드 인수 는 실행시 함수에 전달됩니다. 즉 &lt;code&gt;piecewise(..., ..., alpha=1)&lt;/code&gt; 이면 각 함수는 &lt;code&gt;f(x, alpha=1)&lt;/code&gt; 로 호출됩니다 .</target>
        </trans-unit>
        <trans-unit id="94796302f2d6010802da8fc83c102abd3d91e59b" translate="yes" xml:space="preserve">
          <source>Keyword arguments with the value &lt;code&gt;None&lt;/code&gt; are not checked. Specifying a keyword enforces checking of that aspect of the ndarray on conversion to a ctypes-compatible object. The dtype keyword can be any object understood as a data-type object. The ndim keyword should be an integer, and the shape keyword should be an integer or a sequence of integers. The flags keyword specifies the minimal flags that are required on any array passed in. This can be specified as a string of comma separated requirements, an integer indicating the requirement bits OR&amp;rsquo;d together, or a flags object returned from the flags attribute of an array with the necessary requirements.</source>
          <target state="translated">값이 &lt;code&gt;None&lt;/code&gt; 키워드 인수 는 확인되지 않습니다. 키워드를 지정하면 ctypes 호환 객체로 변환 할 때 ndarray의 해당 측면을 검사합니다. dtype 키워드는 데이터 유형 개체로 이해되는 모든 개체가 될 수 있습니다. ndim 키워드는 정수 여야하고 shape 키워드는 정수 또는 정수 시퀀스 여야합니다. flags 키워드는 전달 된 모든 배열에 필요한 최소 플래그를 지정합니다. 이는 쉼표로 구분 된 요구 사항의 문자열, 함께 OR로 결합 된 요구 사항 비트를 나타내는 정수 또는의 flags 속성에서 반환 된 플래그 객체로 지정 될 수 있습니다. 필요한 요구 사항을 갖춘 어레이.</target>
        </trans-unit>
        <trans-unit id="7b38351b3da46b01757fe5df0b763a6ba88d3175" translate="yes" xml:space="preserve">
          <source>Keyword arguments. The valid keywords are the possible floating-point exceptions. Each keyword should have a string value that defines the treatment for the particular error. Possible values are {&amp;lsquo;ignore&amp;rsquo;, &amp;lsquo;warn&amp;rsquo;, &amp;lsquo;raise&amp;rsquo;, &amp;lsquo;call&amp;rsquo;, &amp;lsquo;print&amp;rsquo;, &amp;lsquo;log&amp;rsquo;}.</source>
          <target state="translated">키워드 인수. 유효한 키워드는 가능한 부동 소수점 예외입니다. 각 키워드에는 특정 오류에 대한 처리를 정의하는 문자열 값이 있어야합니다. 가능한 값은 { 'ignore', 'warn', 'raise', 'call', 'print', 'log'}입니다.</target>
        </trans-unit>
        <trans-unit id="cca3dd937ca64fcc731c3b76e10a3a59e197b380" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">키워드 이외의 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 전달됩니다 &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd51c0cf5320b73d3ff55b2176ad245d2d7397b1" translate="yes" xml:space="preserve">
          <source>Keywords other than &lt;code&gt;dtype&lt;/code&gt; are passed to &lt;code&gt;function&lt;/code&gt;.</source>
          <target state="translated">키워드 이외의 &lt;code&gt;dtype&lt;/code&gt; 전달됩니다 &lt;code&gt;function&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c23ce94abbcda9863c972bac23c6a2a76bdd7d1" translate="yes" xml:space="preserve">
          <source>Kind of floating point data-type about which to get information.</source>
          <target state="translated">정보를 얻을 수있는 부동 소수점 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="31be8fd23c00b4b851fa5f224f6fd4dac29e08c9" translate="yes" xml:space="preserve">
          <source>Known bugs:</source>
          <target state="translated">알려진 버그 :</target>
        </trans-unit>
        <trans-unit id="26db35f7eb95d8b793f4df612e64a0ce6b5afd47" translate="yes" xml:space="preserve">
          <source>Known failures &amp;amp; skipping tests</source>
          <target state="translated">알려진 실패 및 테스트 건너 뛰기</target>
        </trans-unit>
        <trans-unit id="d54ed0ae4c90f25216ec62895c50ba0c59603696" translate="yes" xml:space="preserve">
          <source>Kotz, Samuel, et. al. &amp;ldquo;The Laplace Distribution and Generalizations, &amp;rdquo; Birkhauser, 2001.</source>
          <target state="translated">Kotz, Samuel 등 알. Birkhauser, 2001 년&amp;ldquo;Laplace 배포 및 일반화&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="9b54aa8ed101113f4ff654653787cb490d5956f9" translate="yes" xml:space="preserve">
          <source>Kronecker product of two arrays.</source>
          <target state="translated">두 배열의 크로네 커 곱.</target>
        </trans-unit>
        <trans-unit id="d160e0986aca4714714a16f29ec605af90be704d" translate="yes" xml:space="preserve">
          <source>L</source>
          <target state="translated">L</target>
        </trans-unit>
        <trans-unit id="0c5ca7c9489e795d6e344494ca6012e6c5e6c94a" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 346.</source>
          <target state="translated">LJ Gitman,&amp;ldquo;관리 재무 원칙, 요약&amp;rdquo;, 3 판, Addison-Wesley, 2003, pg. 346.</target>
        </trans-unit>
        <trans-unit id="dad744be14f4bac6567fee2e00e8179f1cafc777" translate="yes" xml:space="preserve">
          <source>L. J. Gitman, &amp;ldquo;Principles of Managerial Finance, Brief,&amp;rdquo; 3rd ed., Addison-Wesley, 2003, pg. 348.</source>
          <target state="translated">LJ Gitman,&amp;ldquo;관리 재무 원칙, 요약&amp;rdquo;, 3 판, Addison-Wesley, 2003, pg. 348.</target>
        </trans-unit>
        <trans-unit id="c9abe91342431b93d138f7615d16985673f94ddb" translate="yes" xml:space="preserve">
          <source>L2 norm of vector &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">벡터 &lt;code&gt;v&lt;/code&gt; 의 L2 노름</target>
        </trans-unit>
        <trans-unit id="cf9e7dcbce935737e3132c8567095e62b32e357d" translate="yes" xml:space="preserve">
          <source>LAPACK</source>
          <target state="translated">LAPACK</target>
        </trans-unit>
        <trans-unit id="a3fb459b8d25a6646ccd3006470636c4394d2fa7" translate="yes" xml:space="preserve">
          <source>LAPACK (NetLIB)</source>
          <target state="translated">LAPACK (NetLIB)</target>
        </trans-unit>
        <trans-unit id="21d5b247623a47d3ffff1da535ef4461b811d560" translate="yes" xml:space="preserve">
          <source>LSB integer 1</source>
          <target state="translated">LSB 정수 1</target>
        </trans-unit>
        <trans-unit id="17bcd0c5595da0e7eb910f67673f577b1f83f0f7" translate="yes" xml:space="preserve">
          <source>LSB integer 2</source>
          <target state="translated">LSB 정수 2</target>
        </trans-unit>
        <trans-unit id="ee3f4ac8c9031369c0019ec76911e81f54ff04c4" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(MATLAB) == transpose(P(NumPy)))</source>
          <target state="translated">LU 분해 (참고 : P (MATLAB) == 전치 (P (NumPy)))</target>
        </trans-unit>
        <trans-unit id="eec57c77bc60eb78065b6605060bb41430b8e7ce" translate="yes" xml:space="preserve">
          <source>LU decomposition (note: P(Matlab) == transpose(P(numpy)) )</source>
          <target state="translated">LU 분해 (참고 : P (Matlab) == 전치 (P (numpy)))</target>
        </trans-unit>
        <trans-unit id="f50beb264ce7d144bf1ce0f2f4d3f272a300b7de" translate="yes" xml:space="preserve">
          <source>Label a test as &amp;lsquo;slow&amp;rsquo;.</source>
          <target state="translated">테스트에 '느린'레이블을 붙입니다.</target>
        </trans-unit>
        <trans-unit id="369c34c1729b62dec5c01c92266ffbd20a59873d" translate="yes" xml:space="preserve">
          <source>Labeling tests</source>
          <target state="translated">라벨링 테스트</target>
        </trans-unit>
        <trans-unit id="4bebfc5e6e36da81205979cf627ca2083b60eab7" translate="yes" xml:space="preserve">
          <source>Laguerre</source>
          <target state="translated">Laguerre</target>
        </trans-unit>
        <trans-unit id="e97fc7286288e61e2979e3135f28bb8c533a9b55" translate="yes" xml:space="preserve">
          <source>Laguerre (class in numpy.polynomial.laguerre)</source>
          <target state="translated">Laguerre (numpy.polynomial.laguerre의 클래스)</target>
        </trans-unit>
        <trans-unit id="5e57606aead53cf91effb25cd081645a48be4c71" translate="yes" xml:space="preserve">
          <source>Laguerre Class</source>
          <target state="translated">라게 레 클래스</target>
        </trans-unit>
        <trans-unit id="ba379f482d893a166d54a2acffc47cc917ce664e" translate="yes" xml:space="preserve">
          <source>Laguerre Module (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Laguerre 모듈 ( &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1fa1d2e4107d4f18290f33c4164e9ffd20858112" translate="yes" xml:space="preserve">
          <source>Laguerre Module (numpy.polynomial.laguerre)</source>
          <target state="translated">Laguerre 모듈 (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="2a936707907aefc2336791e67e0a362c7a6f2893" translate="yes" xml:space="preserve">
          <source>Laguerre Series (&lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt;)</source>
          <target state="translated">Laguerre 시리즈 ( &lt;code&gt;numpy.polynomial.laguerre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="df257db6a3d424bc3a9e921bbaaa3ba0ba50dac3" translate="yes" xml:space="preserve">
          <source>Laguerre Series (numpy.polynomial.laguerre)</source>
          <target state="translated">Laguerre 시리즈 (numpy.polynomial.laguerre)</target>
        </trans-unit>
        <trans-unit id="99466c13dff878e880a6ce449247757d575c46d1" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서대로 Laguerre 계수, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 은 &lt;code&gt;1*L_0(x) + 2*L_1(X) + 3*L_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="96781eb22440929e4bf56e8413b2c4b2ee004cfa" translate="yes" xml:space="preserve">
          <source>Laguerre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Laguerre 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="203d5e91f105ffb95930f626e1d302a193aeaa68" translate="yes" xml:space="preserve">
          <source>Laguerre series</source>
          <target state="translated">라게 레 시리즈</target>
        </trans-unit>
        <trans-unit id="a347ea54d317cc577991ec7bf8e660f33b29ea5f" translate="yes" xml:space="preserve">
          <source>Laguerre series coefficients of the integral.</source>
          <target state="translated">적분의 Laguerre 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="d470a6ac507868056b6fb97be3c38f8e66fd3f73" translate="yes" xml:space="preserve">
          <source>Laguerre series of power.</source>
          <target state="translated">Laguerre 시리즈의 힘.</target>
        </trans-unit>
        <trans-unit id="077697f66c66782d4ef98066ee75e7065a9fd35e" translate="yes" xml:space="preserve">
          <source>Laguerre series of the derivative.</source>
          <target state="translated">Laguerre 계열의 파생 상품.</target>
        </trans-unit>
        <trans-unit id="9a5deb2e7228ec3244f92981a2f639bd0074c61e" translate="yes" xml:space="preserve">
          <source>Laguerre series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 Laguerre 계열.</target>
        </trans-unit>
        <trans-unit id="40be499dbcfef954b53f79728a280796ea6c4f1b" translate="yes" xml:space="preserve">
          <source>Laguerre weight function.</source>
          <target state="translated">Laguerre 무게 기능.</target>
        </trans-unit>
        <trans-unit id="19b66881a109c4450aeadcaedc080b0375d2ecf9" translate="yes" xml:space="preserve">
          <source>Laguerre.__call__()</source>
          <target state="translated">Laguerre.__call__()</target>
        </trans-unit>
        <trans-unit id="b79eed7b566471b5b98d5403131d5fcccb9ccdd6" translate="yes" xml:space="preserve">
          <source>Laguerre.basis()</source>
          <target state="translated">Laguerre.basis()</target>
        </trans-unit>
        <trans-unit id="8450b9cd56cfc84841f9b6a7b3ce8b6553391224" translate="yes" xml:space="preserve">
          <source>Laguerre.cast()</source>
          <target state="translated">Laguerre.cast()</target>
        </trans-unit>
        <trans-unit id="27a50de57a0c19215d0a40ab26d7fc3244818104" translate="yes" xml:space="preserve">
          <source>Laguerre.convert()</source>
          <target state="translated">Laguerre.convert()</target>
        </trans-unit>
        <trans-unit id="ba2566270efed850de8b718e7293f07a260b676d" translate="yes" xml:space="preserve">
          <source>Laguerre.copy()</source>
          <target state="translated">Laguerre.copy()</target>
        </trans-unit>
        <trans-unit id="3b52ca7dceafcdacc78576d128623ad1866249fc" translate="yes" xml:space="preserve">
          <source>Laguerre.cutdeg()</source>
          <target state="translated">Laguerre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="d2b6b76b4b9ee361106b2c94187d00faaf8bec52" translate="yes" xml:space="preserve">
          <source>Laguerre.degree()</source>
          <target state="translated">Laguerre.degree()</target>
        </trans-unit>
        <trans-unit id="00ba5991cdfe21416f272ddb4e2fd2ee48ba1e73" translate="yes" xml:space="preserve">
          <source>Laguerre.deriv()</source>
          <target state="translated">Laguerre.deriv()</target>
        </trans-unit>
        <trans-unit id="3774c67b9a36d28184dc80e1b4d2486ea1e1f36a" translate="yes" xml:space="preserve">
          <source>Laguerre.domain</source>
          <target state="translated">Laguerre.domain</target>
        </trans-unit>
        <trans-unit id="b85b503244ce55e050a887342980da72b2e9ad78" translate="yes" xml:space="preserve">
          <source>Laguerre.fit()</source>
          <target state="translated">Laguerre.fit()</target>
        </trans-unit>
        <trans-unit id="23af0332e2c429442e5afb68340fa4aeef4545dc" translate="yes" xml:space="preserve">
          <source>Laguerre.fromroots()</source>
          <target state="translated">Laguerre.fromroots()</target>
        </trans-unit>
        <trans-unit id="a2a6581abb5a91aaeac7e93a2a256734282432d3" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samecoef()</source>
          <target state="translated">Laguerre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="7dd4d8134966100274e963f0060bfab576b5fddf" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samedomain()</source>
          <target state="translated">Laguerre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="e5e59e81443c19ac8f19e8c2fdccb120a1c9224f" translate="yes" xml:space="preserve">
          <source>Laguerre.has_sametype()</source>
          <target state="translated">Laguerre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="3d138070a5021011806b89098bbe766378b10e7e" translate="yes" xml:space="preserve">
          <source>Laguerre.has_samewindow()</source>
          <target state="translated">Laguerre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="6f69d4698823efec4ccf07af22829cc894b0b98c" translate="yes" xml:space="preserve">
          <source>Laguerre.identity()</source>
          <target state="translated">Laguerre.identity()</target>
        </trans-unit>
        <trans-unit id="f1f6d872a178e7692b45f4ccbfd34fbbf6ed5f91" translate="yes" xml:space="preserve">
          <source>Laguerre.integ()</source>
          <target state="translated">Laguerre.integ()</target>
        </trans-unit>
        <trans-unit id="068cb46402017cfb3dd18164c9b41f89c700f799" translate="yes" xml:space="preserve">
          <source>Laguerre.linspace()</source>
          <target state="translated">Laguerre.linspace()</target>
        </trans-unit>
        <trans-unit id="100d51943018ffa8eadce404d26cfaa31b915872" translate="yes" xml:space="preserve">
          <source>Laguerre.mapparms()</source>
          <target state="translated">Laguerre.mapparms()</target>
        </trans-unit>
        <trans-unit id="de9dd46ebdab9f670b65d8cedb81c132ac30c276" translate="yes" xml:space="preserve">
          <source>Laguerre.roots()</source>
          <target state="translated">Laguerre.roots()</target>
        </trans-unit>
        <trans-unit id="9779fb4f29c73da5d6cee5ec234239b97271c1ae" translate="yes" xml:space="preserve">
          <source>Laguerre.trim()</source>
          <target state="translated">Laguerre.trim()</target>
        </trans-unit>
        <trans-unit id="76a59bb3d54a6db3b464f00c41f8b5a8b4767c11" translate="yes" xml:space="preserve">
          <source>Laguerre.truncate()</source>
          <target state="translated">Laguerre.truncate()</target>
        </trans-unit>
        <trans-unit id="36198a8897031e87556aee045b29805731052142" translate="yes" xml:space="preserve">
          <source>Laplaces</source>
          <target state="translated">Laplaces</target>
        </trans-unit>
        <trans-unit id="82f5e1511892c7fb01c75144ac000d62f83d5a77" translate="yes" xml:space="preserve">
          <source>Large allocations marked as suitable for transparent hugepages</source>
          <target state="translated">투명한 hugepage에 적합한 것으로 표시된 대규모 할당</target>
        </trans-unit>
        <trans-unit id="b681a7171a5bce2d6bad9d307b09a9ccc2c281db" translate="yes" xml:space="preserve">
          <source>Large arrays</source>
          <target state="translated">대형 어레이</target>
        </trans-unit>
        <trans-unit id="5be94f77cefc792ba9a8a12749b2ab34d4d7de5d" translate="yes" xml:space="preserve">
          <source>Large parts of the NumPy API have PEP-484-style type annotations. In addition a number of type aliases are available to users, most prominently the two below:</source>
          <target state="translated">NumPy API의 많은 부분에는 PEP-484 스타일 유형 주석이 있습니다. 또한 사용자는 여러 유형 별칭을 사용할 수 있습니다. 가장 눈에 띄는 것은 아래 두 가지입니다.</target>
        </trans-unit>
        <trans-unit id="da46491a1118285dbcf5975a2a3f36f864e4e6eb" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant&amp;rsquo;s book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;Guide to NumPy&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">이 매뉴얼의 대부분은 Travis E. Oliphant의 &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;NumPy에 대한 안내서&lt;/a&gt; (2008 년 8 월에 Public Domain에 넉넉하게 도입 됨)에서 시작되었습니다. 많은 기능에 대한 참조 문서는 NumPy의 많은 기고자 및 개발자가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="eab5c44c0f0e22a5c5510649d34e17cb192d1603" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered Public Domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">이 설명서의 대부분은 Travis E. Oliphant의 책 &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (2008 년 8 월에 퍼블릭 도메인에 관대하게 입력) 에서 발췌 한 것입니다. 많은 함수에 대한 참조 문서는 NumPy의 수많은 기여자와 개발자가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="461e005b11043acdc64bcd7d33f04e9a4a706ce0" translate="yes" xml:space="preserve">
          <source>Large parts of this manual originate from Travis E. Oliphant's book &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (which generously entered public domain in August 2008). The reference documentation for many of the functions are written by numerous contributors and developers of NumPy.</source>
          <target state="translated">이 설명서의 대부분은 Travis E. Oliphant의 책 &lt;a href=&quot;https://archive.org/details/NumPyBook&quot;&gt;&quot;Guide to NumPy&quot;&lt;/a&gt; (2008 년 8 월에 공개 도메인에 관대하게 입력 됨) 에서 발췌 한 것입니다. 많은 함수에 대한 참조 문서는 NumPy의 수많은 기여자와 개발자가 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="2fdae5c61df170eabed81dff27bfb3678199f99b" translate="yes" xml:space="preserve">
          <source>Largest size allowed for the user-settable buffers.</source>
          <target state="translated">사용자 설정 가능 버퍼에 허용되는 최대 크기입니다.</target>
        </trans-unit>
        <trans-unit id="8da87d373f111f7e103693ae24e8a07ffa7a91e2" translate="yes" xml:space="preserve">
          <source>Last processed field name (used internally during recursion).</source>
          <target state="translated">마지막으로 처리 된 필드 이름 (재귀 동안 내부적으로 사용됨).</target>
        </trans-unit>
        <trans-unit id="688c183c0553e7f8897c3da631ac608e3281e20b" translate="yes" xml:space="preserve">
          <source>Learn about concepts and submodules</source>
          <target state="translated">개념 및 하위 모듈에 대해 알아보기</target>
        </trans-unit>
        <trans-unit id="7e1c2c8a281b93c2a756aa5c5b0dde7c93d58559" translate="yes" xml:space="preserve">
          <source>Learn about what NumPy is and how to install it</source>
          <target state="translated">NumPy가 무엇이며 설치 방법에 대해 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="1893b40e2e74ded8d87e7668bb8ea0e85b265882" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;input and output routines here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;../reference/routines.io#routines-io&quot;&gt;여기에서 입력 및 출력 루틴&lt;/a&gt; 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="42d6db2ec75c1bd30bb52b2e73819209cb308cc1" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;indexing and slicing here&lt;/a&gt; and &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;quickstart#quickstart-indexing-slicing-and-iterating&quot;&gt;여기&lt;/a&gt; 와 &lt;a href=&quot;basics.indexing#basics-indexing&quot;&gt;여기 &lt;/a&gt;에서 인덱싱 및 슬라이싱 에 대해 자세히 알아보십시오 .</target>
        </trans-unit>
        <trans-unit id="2a595050bddab4e4c46cb1e0dc7dff5874ac8e5f" translate="yes" xml:space="preserve">
          <source>Learn more about &lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;NumPy here&lt;/a&gt;!</source>
          <target state="translated">&lt;a href=&quot;whatisnumpy#whatisnumpy&quot;&gt;여기에서 NumPy에&lt;/a&gt; 대해 자세히 알아보십시오 !</target>
        </trans-unit>
        <trans-unit id="eccf892e3b309e4f27b805fda73ba6310c691f1f" translate="yes" xml:space="preserve">
          <source>Learn more about creating arrays here</source>
          <target state="translated">여기에서 어레이 생성에 대해 자세히 알아보십시오.</target>
        </trans-unit>
        <trans-unit id="98c632c8b787bef56a52b5a8399e5f77771145f9" translate="yes" xml:space="preserve">
          <source>Learner profile</source>
          <target state="translated">학습자 프로필</target>
        </trans-unit>
        <trans-unit id="1394be7b7b406c4f13516595eb91b7dcfd8ff79c" translate="yes" xml:space="preserve">
          <source>Learning Objectives</source>
          <target state="translated">학습 목표</target>
        </trans-unit>
        <trans-unit id="e9f285095a214517cc70148a152aa9ce3bfb1555" translate="yes" xml:space="preserve">
          <source>Least squares fit of Chebyshev series to data.</source>
          <target state="translated">체비 쇼프 시리즈의 최소 제곱은 데이터에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="5eede6c92597c6ad1ec14f2a50e868bfa8dbcef5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Hermite series to data.</source>
          <target state="translated">Hermite 시리즈의 최소 제곱은 데이터에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="f9834397596bb1c91a60ebd7bed6c56b93f210b5" translate="yes" xml:space="preserve">
          <source>Least squares fit of Laguerre series to data.</source>
          <target state="translated">Laguerre 시리즈의 최소 제곱은 데이터에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="60abe6780ea6293285c10210c3c968485e58937b" translate="yes" xml:space="preserve">
          <source>Least squares fit of Legendre series to data.</source>
          <target state="translated">Legendre 시리즈의 데이터에 적합한 최소 제곱.</target>
        </trans-unit>
        <trans-unit id="f70b890f268681837dd642a40e85f47d99c8ef5c" translate="yes" xml:space="preserve">
          <source>Least squares fit to data.</source>
          <target state="translated">최소 제곱은 데이터에 적합합니다.</target>
        </trans-unit>
        <trans-unit id="82d4ad107d684ab9ad44770f05b7a2542d27bae6" translate="yes" xml:space="preserve">
          <source>Least squares polynomial fit.</source>
          <target state="translated">최소 제곱 다항식 적합.</target>
        </trans-unit>
        <trans-unit id="66b99a01120f0770d01e2e70f30aa7b3e6d8760b" translate="yes" xml:space="preserve">
          <source>Least-squares fit of a polynomial to data.</source>
          <target state="translated">다항식의 데이터에 가장 적합한 제곱입니다.</target>
        </trans-unit>
        <trans-unit id="004f7153cd5215d911c25b804b9cb64fc053135e" translate="yes" xml:space="preserve">
          <source>Least-squares solution. If &lt;code&gt;b&lt;/code&gt; is two-dimensional, the solutions are in the &lt;code&gt;K&lt;/code&gt; columns of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">최소 제곱 솔루션. 경우 &lt;code&gt;b&lt;/code&gt; 2 차원의 솔루션은에 &lt;code&gt;K&lt;/code&gt; 용 의 열 &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e3bf79d3ac96cdf89ed0ca352f8850960c3aecf" translate="yes" xml:space="preserve">
          <source>Leg of the triangle(s). If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">삼각형의 다리. 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="a3da3f26242bb8617087ec4d4fb9fafcb77635dc" translate="yes" xml:space="preserve">
          <source>Legacy Generator (RandomState)</source>
          <target state="translated">레거시 생성기 (RandomState)</target>
        </trans-unit>
        <trans-unit id="7a03f0fe89c9579b9b2b236650c98185edc2fe62" translate="yes" xml:space="preserve">
          <source>Legacy Random Generation</source>
          <target state="translated">레거시 랜덤 생성</target>
        </trans-unit>
        <trans-unit id="47a5d89b5a8a2f363ca5b4a1476eb173fc07ab11" translate="yes" xml:space="preserve">
          <source>Legendre</source>
          <target state="translated">Legendre</target>
        </trans-unit>
        <trans-unit id="358ed7a487a2a55bfa9556bbf8f4fe1f6f4c1094" translate="yes" xml:space="preserve">
          <source>Legendre (class in numpy.polynomial.legendre)</source>
          <target state="translated">Legendre (numpy.polynomial.legendre의 클래스)</target>
        </trans-unit>
        <trans-unit id="4120cea9b471c879abda7b1336aba3d61c52e3bc" translate="yes" xml:space="preserve">
          <source>Legendre Class</source>
          <target state="translated">레전드 클래스</target>
        </trans-unit>
        <trans-unit id="b4a47072941f51eec5be92fa7536302b1cd27189" translate="yes" xml:space="preserve">
          <source>Legendre Module (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">Legendre 모듈 ( &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a6b7c39b7f03fb5bf1916b89cb05334bb7660fc8" translate="yes" xml:space="preserve">
          <source>Legendre Module (numpy.polynomial.legendre)</source>
          <target state="translated">Legendre 모듈 (numpy.polynomial.legendre)</target>
        </trans-unit>
        <trans-unit id="5cf0b728017026cd3633f8023ba22356ac49e8e9" translate="yes" xml:space="preserve">
          <source>Legendre Series (&lt;code&gt;numpy.polynomial.legendre&lt;/code&gt;)</source>
          <target state="translated">르장 드르 시리즈 ( &lt;code&gt;numpy.polynomial.legendre&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3fc1f7294028d411cdbd64652dfec514ea719176" translate="yes" xml:space="preserve">
          <source>Legendre Series (numpy.polynomial.legendre)</source>
          <target state="translated">르장 드르 시리즈 (numpy.polynomial.legendre)</target>
        </trans-unit>
        <trans-unit id="72a4b81826e99e6fe744c1d98416a1d24f591803" translate="yes" xml:space="preserve">
          <source>Legendre coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt;.</source>
          <target state="translated">증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 범례 계수 는 &lt;code&gt;1*P_0(x) + 2*P_1(x) + 3*P_2(x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="dd1aecb7d54479faf64417ed750dd54dbc48134e" translate="yes" xml:space="preserve">
          <source>Legendre coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;. If &lt;code&gt;deg&lt;/code&gt; is specified as a list, coefficients for terms not included in the fit are set equal to zero in the returned &lt;code&gt;coef&lt;/code&gt;.</source>
          <target state="translated">Legendre 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; . &lt;code&gt;deg&lt;/code&gt; &lt;code&gt;coef&lt;/code&gt; 지정된 경우 , 적합치에 포함되지 않은 항의 계수는 반환 된 coef 에서 0으로 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="36661c8b6df50f0810e8abcd38c911e37700210a" translate="yes" xml:space="preserve">
          <source>Legendre series</source>
          <target state="translated">레전드 르 시리즈</target>
        </trans-unit>
        <trans-unit id="cff0f8c14f012c4d84feceb1b721e76e38f2b7e7" translate="yes" xml:space="preserve">
          <source>Legendre series coefficient array of the integral.</source>
          <target state="translated">적분의 Legendre 시리즈 계수 배열.</target>
        </trans-unit>
        <trans-unit id="e423b1233d9fcd2c8894e66b68b4670d1797fcf6" translate="yes" xml:space="preserve">
          <source>Legendre series of power.</source>
          <target state="translated">Legendre 파워 시리즈.</target>
        </trans-unit>
        <trans-unit id="cbfaa0f2130ef078276a68c292602bd146355698" translate="yes" xml:space="preserve">
          <source>Legendre series of the derivative.</source>
          <target state="translated">파생 상품의 Legendre 시리즈.</target>
        </trans-unit>
        <trans-unit id="0c94fd4bbecdfa33cfa2085e96aaf27eb258cb91" translate="yes" xml:space="preserve">
          <source>Legendre series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 Legendre 시리즈.</target>
        </trans-unit>
        <trans-unit id="9c6dd8780cca130b14ebf98dc6a58e0b8fde7f4f" translate="yes" xml:space="preserve">
          <source>Legendre weight function (= 1).</source>
          <target state="translated">레전드 웨이트 기능 (= 1).</target>
        </trans-unit>
        <trans-unit id="11838d713a7ca74c36db28fb9741ab01b38fc2f4" translate="yes" xml:space="preserve">
          <source>Legendre, Laguerre, Hermite, HermiteE polynomials in &lt;code&gt;numpy.polynomial&lt;/code&gt;</source>
          <target state="translated">에서 르장 드르, Laguerre, 미트, HermiteE 다항식 &lt;code&gt;numpy.polynomial&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4086e8682b0af8e09d2dfa82cd2fdc76b5bc8f8d" translate="yes" xml:space="preserve">
          <source>Legendre.__call__()</source>
          <target state="translated">Legendre.__call__()</target>
        </trans-unit>
        <trans-unit id="38dffd4eba846de64c001288fae359b48ca7be06" translate="yes" xml:space="preserve">
          <source>Legendre.basis()</source>
          <target state="translated">Legendre.basis()</target>
        </trans-unit>
        <trans-unit id="03d79bdd0c244e4a8685e0cc2ed8f9bba14f2e75" translate="yes" xml:space="preserve">
          <source>Legendre.cast()</source>
          <target state="translated">Legendre.cast()</target>
        </trans-unit>
        <trans-unit id="c3757be303c19145dd4cdc1f1fdbe7778af7a9b8" translate="yes" xml:space="preserve">
          <source>Legendre.convert()</source>
          <target state="translated">Legendre.convert()</target>
        </trans-unit>
        <trans-unit id="30694a9a60e1750eef89dd48cd213d03dc835778" translate="yes" xml:space="preserve">
          <source>Legendre.copy()</source>
          <target state="translated">Legendre.copy()</target>
        </trans-unit>
        <trans-unit id="67fd9bca2a23484298ecfc5a44e6dbe767f8deee" translate="yes" xml:space="preserve">
          <source>Legendre.cutdeg()</source>
          <target state="translated">Legendre.cutdeg()</target>
        </trans-unit>
        <trans-unit id="de6280bafa05de1ba0dc2f4ee315b2f1c3f376c2" translate="yes" xml:space="preserve">
          <source>Legendre.degree()</source>
          <target state="translated">Legendre.degree()</target>
        </trans-unit>
        <trans-unit id="065d87c76a899767772e29e52989a91f8e7a3c94" translate="yes" xml:space="preserve">
          <source>Legendre.deriv()</source>
          <target state="translated">Legendre.deriv()</target>
        </trans-unit>
        <trans-unit id="dc4f96a4666e84f37c719b2fad25d196a612cc45" translate="yes" xml:space="preserve">
          <source>Legendre.domain</source>
          <target state="translated">Legendre.domain</target>
        </trans-unit>
        <trans-unit id="11c2423446ff507ce6eb98675dde94c735489c69" translate="yes" xml:space="preserve">
          <source>Legendre.fit()</source>
          <target state="translated">Legendre.fit()</target>
        </trans-unit>
        <trans-unit id="e21bd7963e9b515a9f4b47a6bcd09e263e8089ee" translate="yes" xml:space="preserve">
          <source>Legendre.fromroots()</source>
          <target state="translated">Legendre.fromroots()</target>
        </trans-unit>
        <trans-unit id="d5d912a486cc7b8f50ccecabe4f025c8e6390336" translate="yes" xml:space="preserve">
          <source>Legendre.has_samecoef()</source>
          <target state="translated">Legendre.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="6666d87ba29b4b8ae40e97a1bf2868d699324607" translate="yes" xml:space="preserve">
          <source>Legendre.has_samedomain()</source>
          <target state="translated">Legendre.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="3760f41cb73e83c63c3b041fb1850faaf75fa051" translate="yes" xml:space="preserve">
          <source>Legendre.has_sametype()</source>
          <target state="translated">Legendre.has_sametype()</target>
        </trans-unit>
        <trans-unit id="776a3387bba3bfaabfedc34f80f56441350be257" translate="yes" xml:space="preserve">
          <source>Legendre.has_samewindow()</source>
          <target state="translated">Legendre.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="d270c39a15f9cf84d450407eca8d04e34120a21a" translate="yes" xml:space="preserve">
          <source>Legendre.identity()</source>
          <target state="translated">Legendre.identity()</target>
        </trans-unit>
        <trans-unit id="a025b9af1289248a2a7d813cd3249b6c59a1b90e" translate="yes" xml:space="preserve">
          <source>Legendre.integ()</source>
          <target state="translated">Legendre.integ()</target>
        </trans-unit>
        <trans-unit id="b1309f9dd6fba8397cba7645c87fd874d753067f" translate="yes" xml:space="preserve">
          <source>Legendre.linspace()</source>
          <target state="translated">Legendre.linspace()</target>
        </trans-unit>
        <trans-unit id="3b41ed00816bbf0ea94cb8ce7b846f9374dce867" translate="yes" xml:space="preserve">
          <source>Legendre.mapparms()</source>
          <target state="translated">Legendre.mapparms()</target>
        </trans-unit>
        <trans-unit id="498206cc30a61e0936daddec7420065e1fb22906" translate="yes" xml:space="preserve">
          <source>Legendre.roots()</source>
          <target state="translated">Legendre.roots()</target>
        </trans-unit>
        <trans-unit id="c917ded9bfb105e1d1214678489c4d2d643e0789" translate="yes" xml:space="preserve">
          <source>Legendre.trim()</source>
          <target state="translated">Legendre.trim()</target>
        </trans-unit>
        <trans-unit id="4b818047b63ac1fb3abbf9ee09b84ccf39af0370" translate="yes" xml:space="preserve">
          <source>Legendre.truncate()</source>
          <target state="translated">Legendre.truncate()</target>
        </trans-unit>
        <trans-unit id="c92dc32e98f74178230da6c9cf3f1619baf0cae9" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;a href=&quot;../arrays.scalars#numpy.int32&quot;&gt;&lt;code&gt;numpy.int32&lt;/code&gt;&lt;/a&gt; and the the second &lt;a href=&quot;../arrays.scalars#numpy.int64&quot;&gt;&lt;code&gt;numpy.int64&lt;/code&gt;&lt;/a&gt;, with both returning &lt;a href=&quot;../arrays.scalars#numpy.bool_&quot;&gt;&lt;code&gt;numpy.bool_&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">길이 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; 배열 의 해당 함수가 허용 하는 &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt; (내장 전용)을 인코딩하는 &lt;code&gt;char&lt;/code&gt; ntypes 배열입니다 . 예를 들어, 3 개 ufunc 비교를 위해 &lt;code&gt;ntypes&lt;/code&gt; 두 &lt;code&gt;nin&lt;/code&gt; 하나 &lt;code&gt;nout&lt;/code&gt; 제 함수 받아 &lt;a href=&quot;../arrays.scalars#numpy.int32&quot;&gt; &lt;code&gt;numpy.int32&lt;/code&gt; &lt;/a&gt; 및 제 &lt;a href=&quot;../arrays.scalars#numpy.int64&quot;&gt; &lt;code&gt;numpy.int64&lt;/code&gt; 를&lt;/a&gt; 모두 복귀와 &lt;a href=&quot;../arrays.scalars#numpy.bool_&quot;&gt; &lt;code&gt;numpy.bool_&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;types&lt;/code&gt; 것 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; 보낸 &lt;code&gt;NPY_INT32&lt;/code&gt; 는 , 5 &lt;code&gt;NPY_INT64&lt;/code&gt; 는 7이고, &lt;code&gt;NPY_BOOL&lt;/code&gt; 는 0이다.</target>
        </trans-unit>
        <trans-unit id="d96ebfedf4c36cbda183cd7a457b02a6edaca923" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">길이 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; 배열 의 해당 함수가 허용 하는 &lt;a href=&quot;../generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt; (내장 전용)을 인코딩하는 &lt;code&gt;char&lt;/code&gt; ntypes 배열입니다 . 예를 들어, 3 개 ufunc 비교를 위해 &lt;code&gt;ntypes&lt;/code&gt; 두 &lt;code&gt;nin&lt;/code&gt; 하나 &lt;code&gt;nout&lt;/code&gt; 제 함수 받아 &lt;code&gt;numpy.int32&lt;/code&gt; 및 제 &lt;code&gt;numpy.int64&lt;/code&gt; 를 모두 복귀와 &lt;code&gt;numpy.bool_&lt;/code&gt; , &lt;code&gt;types&lt;/code&gt; 것 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; 보낸 &lt;code&gt;NPY_INT32&lt;/code&gt; 는 , 5 &lt;code&gt;NPY_INT64&lt;/code&gt; 는 7이고, &lt;code&gt;NPY_BOOL&lt;/code&gt; 는 0이다.</target>
        </trans-unit>
        <trans-unit id="a0ba05a259a8b34022dc6e1b217b0390cf104e0b" translate="yes" xml:space="preserve">
          <source>Length &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; array of &lt;code&gt;char&lt;/code&gt; encoding the &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt;&lt;code&gt;numpy.dtype.num&lt;/code&gt;&lt;/a&gt; (built-in only) that the corresponding function in the &lt;code&gt;func&lt;/code&gt; array accepts. For instance, for a comparison ufunc with three &lt;code&gt;ntypes&lt;/code&gt;, two &lt;code&gt;nin&lt;/code&gt; and one &lt;code&gt;nout&lt;/code&gt;, where the first function accepts &lt;code&gt;numpy.int32&lt;/code&gt; and the the second &lt;code&gt;numpy.int64&lt;/code&gt;, with both returning &lt;code&gt;numpy.bool_&lt;/code&gt;, &lt;code&gt;types&lt;/code&gt; would be &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; since &lt;code&gt;NPY_INT32&lt;/code&gt; is 5, &lt;code&gt;NPY_INT64&lt;/code&gt; is 7, and &lt;code&gt;NPY_BOOL&lt;/code&gt; is 0.</source>
          <target state="translated">길이 &lt;code&gt;(nin + nout) * ntypes&lt;/code&gt; &lt;code&gt;func&lt;/code&gt; 배열 의 해당 함수가 허용 하는 &lt;a href=&quot;generated/numpy.dtype.num#numpy.dtype.num&quot;&gt; &lt;code&gt;numpy.dtype.num&lt;/code&gt; &lt;/a&gt; (내장 전용)을 인코딩하는 &lt;code&gt;char&lt;/code&gt; 의ntypes 배열입니다 . 예를 들어, 3 개 ufunc 비교를 위해 &lt;code&gt;ntypes&lt;/code&gt; 두 &lt;code&gt;nin&lt;/code&gt; 하나 &lt;code&gt;nout&lt;/code&gt; 제 함수 받아 &lt;code&gt;numpy.int32&lt;/code&gt; 및 제 &lt;code&gt;numpy.int64&lt;/code&gt; 를 모두 복귀와 &lt;code&gt;numpy.bool_&lt;/code&gt; , &lt;code&gt;types&lt;/code&gt; 것 &lt;code&gt;(char[]) {5, 5, 0, 7, 7, 0}&lt;/code&gt; 보낸 &lt;code&gt;NPY_INT32&lt;/code&gt; 는 , 5 &lt;code&gt;NPY_INT64&lt;/code&gt; 는 7이고, &lt;code&gt;NPY_BOOL&lt;/code&gt; 는 0이다.</target>
        </trans-unit>
        <trans-unit id="e599dfd0500969f55b8c9d010461f8e1fcc41925" translate="yes" xml:space="preserve">
          <source>Length of each array element, in number of characters. Default is 1.</source>
          <target state="translated">각 배열 요소의 길이 (문자 수) 기본값은 1입니다.</target>
        </trans-unit>
        <trans-unit id="6dbef5ea0e7b53958b8a2d75b0863dd2996ea77a" translate="yes" xml:space="preserve">
          <source>Length of one array element in bytes.</source>
          <target state="translated">한 배열 요소의 길이 (바이트)</target>
        </trans-unit>
        <trans-unit id="ebd0316d087a92fa193507d4dfe490f6483edcaf" translate="yes" xml:space="preserve">
          <source>Length of the inverse FFT, the number of points along transformation axis in the input to use. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">역 FFT의 길이, 사용할 입력에서 변환 축을 따르는 포인트 수. 경우 &lt;code&gt;n&lt;/code&gt; 은 입력의 길이보다 작은 경우, 입력이 잘려있다. 더 큰 경우 입력이 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지에 의해 지정된 축 방향 입력의 길이 &lt;code&gt;axis&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="c0386e146b5b66f11c90240baf5f54bbd4a84b7b" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">출력의 변환 된 축의 길이입니다. 들면 &lt;code&gt;n&lt;/code&gt; 개의 출력 지점을, &lt;code&gt;n//2 + 1&lt;/code&gt; 입력 포인트가 필요하다. 입력이 이보다 길면 잘립니다. 이보다 짧으면 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지 않는, 그것은에 의해 지정된 축 방향 입력의 길이로부터 결정되는 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f13f9612cce3a275a1186d10417cbf86f8f9b46" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2 + 1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">출력의 변환 된 축 길이입니다. 들면 &lt;code&gt;n&lt;/code&gt; 개의 출력 지점을, &lt;code&gt;n//2 + 1&lt;/code&gt; 입력 포인트가 필요하다. 입력이 이보다 길면 잘립니다. 이보다 짧으면 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지 않는, 그것으로 촬영 &lt;code&gt;2*(m-1)&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 는 에 의해 지정된 축 방향 입력의 길이 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef669ab3a842002f9a1fb7bac5550ccceaa27247" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is determined from the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">출력의 변환 된 축의 길이입니다. 들면 &lt;code&gt;n&lt;/code&gt; 개의 출력 지점을, &lt;code&gt;n//2+1&lt;/code&gt; 입력 포인트가 필요하다. 입력이 이보다 길면 잘립니다. 이보다 짧으면 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지 않는, 그것은에 의해 지정된 축 방향 입력의 길이로부터 결정되는 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1393d388a3302d35f0092d404b2ba089179672a7" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. For &lt;code&gt;n&lt;/code&gt; output points, &lt;code&gt;n//2+1&lt;/code&gt; input points are necessary. If the input is longer than this, it is cropped. If it is shorter than this, it is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, it is taken to be &lt;code&gt;2*(m-1)&lt;/code&gt; where &lt;code&gt;m&lt;/code&gt; is the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">출력의 변환 된 축 길이입니다. 들면 &lt;code&gt;n&lt;/code&gt; 개의 출력 지점을, &lt;code&gt;n//2+1&lt;/code&gt; 입력 포인트가 필요하다. 입력이 이보다 길면 잘립니다. 이보다 짧으면 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지 않는, 그것으로 촬영 &lt;code&gt;2*(m-1)&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; 는 에 의해 지정된 축 방향 입력의 길이 &lt;code&gt;axis&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9649fc48731a6d9a87c71452f8efbcb7f76b78d4" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used.</source>
          <target state="translated">출력의 변환 된 축의 길이입니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 입력의 길이보다 작은 경우, 입력이 잘려있다. 더 큰 경우 입력이 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지에 의해 지정된 축 방향 입력의 길이 &lt;code&gt;axis&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="838e5e82eb9b3c833687dc387dbd43309bd32602" translate="yes" xml:space="preserve">
          <source>Length of the transformed axis of the output. If &lt;code&gt;n&lt;/code&gt; is smaller than the length of the input, the input is cropped. If it is larger, the input is padded with zeros. If &lt;code&gt;n&lt;/code&gt; is not given, the length of the input along the axis specified by &lt;code&gt;axis&lt;/code&gt; is used. See notes about padding issues.</source>
          <target state="translated">출력의 변환 된 축의 길이입니다. 경우 &lt;code&gt;n&lt;/code&gt; 은 입력의 길이보다 작은 경우, 입력이 잘려있다. 더 큰 경우 입력이 0으로 채워집니다. 경우 &lt;code&gt;n&lt;/code&gt; 주어지지에 의해 지정된 축 방향 입력의 길이 &lt;code&gt;axis&lt;/code&gt; 사용된다. 패딩 문제에 대한 참고 사항을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="20b7b6096b899f364abc1b0ab113ac1d88c95817" translate="yes" xml:space="preserve">
          <source>Lentner, Marvin, &amp;ldquo;Elementary Applied Statistics&amp;rdquo;, Bogden and Quigley, 1972.</source>
          <target state="translated">Lentner, Marvin,&amp;ldquo;초등 응용 통계&amp;rdquo;, Bogden and Quigley, 1972.</target>
        </trans-unit>
        <trans-unit id="ad48dd4be642df433d10c28592cb939dc42a109f" translate="yes" xml:space="preserve">
          <source>Less Basic</source>
          <target state="translated">덜 기본</target>
        </trans-unit>
        <trans-unit id="e99e5b627f7ed42d45bd8cf2acdec386f4c6174c" translate="yes" xml:space="preserve">
          <source>Less robust estimator that that takes into account data variability and data size.</source>
          <target state="translated">데이터 변동성과 데이터 크기를 고려한 덜 강력한 추정량.</target>
        </trans-unit>
        <trans-unit id="ef5fe1edf37940bd463fee8eda068dc8d66b0f8a" translate="yes" xml:space="preserve">
          <source>Let</source>
          <target state="translated">Let</target>
        </trans-unit>
        <trans-unit id="a718bc5ba689b0611826e8a00c42db91a4cc33c1" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;M = A.ndim&lt;/code&gt;, &lt;code&gt;N = B.ndim&lt;/code&gt;. Then the result, &lt;code&gt;C&lt;/code&gt;, of &lt;code&gt;op.outer(A, B)&lt;/code&gt; is an array of dimension M + N such that:</source>
          <target state="translated">&lt;code&gt;M = A.ndim&lt;/code&gt; , &lt;code&gt;N = B.ndim&lt;/code&gt; 이라고하자 . 결과는, &lt;code&gt;C&lt;/code&gt; 는 ,의 &lt;code&gt;op.outer(A, B)&lt;/code&gt; 사이즈 M + N되도록 배열이다 :</target>
        </trans-unit>
        <trans-unit id="c21492f5c1039f68826ed62d8fddcbe2ecf43d60" translate="yes" xml:space="preserve">
          <source>Let &lt;code&gt;x.shape&lt;/code&gt; be (10,20,30,40,50) and suppose &lt;code&gt;ind_1&lt;/code&gt; and &lt;code&gt;ind_2&lt;/code&gt; can be broadcast to the shape (2,3,4). Then &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; has shape (10,2,3,4,40,50) because the (20,30)-shaped subspace from X has been replaced with the (2,3,4) subspace from the indices. However, &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; has shape (2,3,4,10,30,50) because there is no unambiguous place to drop in the indexing subspace, thus it is tacked-on to the beginning. It is always possible to use &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt;&lt;code&gt;.transpose()&lt;/code&gt;&lt;/a&gt; to move the subspace anywhere desired. Note that this example cannot be replicated using &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">하자 &lt;code&gt;x.shape&lt;/code&gt; 이 수 (10,20,30,40,50)와 가정 &lt;code&gt;ind_1&lt;/code&gt; 및 &lt;code&gt;ind_2&lt;/code&gt; 모양 (2,3,4)에 방송 될 수 있습니다. 그런 다음 &lt;code&gt;x[:,ind_1,ind_2]&lt;/code&gt; 모양은 (10,2,3,4,40,50)입니다. X의 (20,30) 모양 부분 공간이 (2,3,4) 부분 공간으로 대체 되었기 때문입니다. 지수. 그러나 &lt;code&gt;x[:,ind_1,:,ind_2]&lt;/code&gt; 모양은 (2,3,4,10,30,50)이며, 색인 부분 공간에서 드롭 할 곳이 없기 때문에 처음부터 시작됩니다. &lt;a href=&quot;generated/numpy.ndarray.transpose#numpy.ndarray.transpose&quot;&gt; &lt;code&gt;.transpose()&lt;/code&gt; &lt;/a&gt; 를 사용 하여 원하는 곳으로 부분 공간을 이동할 수 있습니다. 이 예제는 &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; 를&lt;/a&gt; 사용하여 복제 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c5de9d97cc2b507966a716e78a84203d66bead94" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s apply the steps of wrapping Fortran functions to Python one by one.</source>
          <target state="translated">Fortran 함수를 Python에 하나씩 래핑하는 단계를 적용 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="91c6bd95be9fba42070138c60bc544f63be79cf2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s check that this is what we expected:</source>
          <target state="translated">이것이 우리가 기대 한 것인지 확인합시다.</target>
        </trans-unit>
        <trans-unit id="d53ca7c39e959075c64a326e51c71e27bb307d6d" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider a list of elements, &lt;code&gt;x&lt;/code&gt;, where values of -9999. represent missing data. We wish to compute the average value of the data and the vector of anomalies (deviations from the average):</source>
          <target state="translated">요소 목록 &lt;code&gt;x&lt;/code&gt; 를 고려해 봅시다 . 여기서 값은 -9999입니다. 누락 된 데이터를 나타냅니다. 데이터의 평균값과 이상 벡터 (평균과의 편차)를 계산하려고합니다.</target>
        </trans-unit>
        <trans-unit id="2913bcf139d6f47d02c0ac2f1be4a80f4a447c13" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.2, 0.9]&lt;/code&gt;:</source>
          <target state="translated">0과 1 사이의 부동 소수점 배열 &lt;code&gt;d&lt;/code&gt; 를 생각해 봅시다 . &lt;code&gt;[0.2, 0.9]&lt;/code&gt; 범위를 벗어난 데이터는 무시하면서 &lt;code&gt;d&lt;/code&gt; 값의 평균을 계산하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="ab1ea5de1d1447221ec240c0905b303173635736" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s consider an array &lt;code&gt;d&lt;/code&gt; of random floats between 0 and 1. We wish to compute the average of the values of &lt;code&gt;d&lt;/code&gt; while ignoring any data outside the range &lt;code&gt;[0.1, 0.9]&lt;/code&gt;:</source>
          <target state="translated">0과 1 사이의 임의의 부동 소수점 배열 &lt;code&gt;d&lt;/code&gt; 를 고려해 봅시다 . &lt;code&gt;[0.1, 0.9]&lt;/code&gt; 범위 밖의 데이터는 무시하고 &lt;code&gt;d&lt;/code&gt; 값의 평균을 계산하려고합니다 .</target>
        </trans-unit>
        <trans-unit id="39281dff86138ded282e6212c34eb9cda8834f15" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s do 20,000 trials of the model, and count the number that generate zero positive results.</source>
          <target state="translated">모델의 20,000 회 시도를 수행하고 0의 양수 결과를 생성하는 수를 세겠습니다.</target>
        </trans-unit>
        <trans-unit id="1b9b5278ac2afa5e3136c310885e0f8fd06a8be2" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore a more advanced concept in numpy called broadcasting. The term broadcasting describes how numpy treats arrays with different shapes during arithmetic operations. Subject to certain constraints, the smaller array is &amp;ldquo;broadcast&amp;rdquo; across the larger array so that they have compatible shapes. Broadcasting provides a means of vectorizing array operations so that looping occurs in C instead of Python. It does this without making needless copies of data and usually leads to efficient algorithm implementations. There are also cases where broadcasting is a bad idea because it leads to inefficient use of memory that slows computation. This article provides a gentle introduction to broadcasting with numerous examples ranging from simple to involved. It also provides hints on when and when not to use broadcasting.</source>
          <target state="translated">브로드 캐스팅이라고하는 numpy의 고급 개념을 살펴 보겠습니다. 브로드 캐스팅이라는 용어는 산술 연산 중에 numpy가 다른 모양의 배열을 처리하는 방법을 설명합니다. 특정 제약 조건에 따라 더 작은 배열은 더 큰 배열에 &quot;브로드 캐스트&quot;되어 호환되는 모양을 갖습니다. 브로드 캐스팅은 배열 작업을 벡터화하는 수단을 제공하여 Python 대신 C에서 루핑이 발생하도록합니다. 불필요한 데이터 복사본을 만들지 않고이를 수행하며 일반적으로 효율적인 알고리즘 구현으로 이어집니다. 또한 브로드 캐스팅이 메모리를 비효율적으로 사용하여 계산 속도를 늦추기 때문에 나쁜 생각 인 경우도 있습니다. 이 기사는 간단한 것부터 관련된 것까지 다양한 예를 통해 방송에 대한 부드러운 소개를 제공합니다. 또한 방송을 사용하지 않는시기와시기에 대한 힌트를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="dc7e8c8d4a2c6c3d30346acb9b8c343d014c9595" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s explore the data inside this file for the first 14 days of records. To gather data from the &lt;code&gt;.csv&lt;/code&gt; file, we will use the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function, making sure we select only the columns with actual numbers instead of the first three columns which contain location data. We also skip the first 7 rows of this file, since they contain other data we are not interested in. Separately, we will extract the information about dates and location for this data.</source>
          <target state="translated">기록의 처음 14 일 동안이 파일 내의 데이터를 살펴 보겠습니다. &lt;code&gt;.csv&lt;/code&gt; 파일 에서 데이터를 수집하기 위해 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 위치 데이터를 포함하는 처음 세 열 대신 실제 숫자가있는 열만 선택합니다. 또한이 파일의 처음 7 개 행에는 관심이없는 다른 데이터가 포함되어 있으므로 건너 뜁니다. 별도로이 데이터의 날짜 및 위치에 대한 정보를 추출합니다.</target>
        </trans-unit>
        <trans-unit id="f8b59fac8428f8c1733e5af773d6cbf876149f27" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s look at two examples we&amp;rsquo;ve seen before to see how they might be implemented using Cython. These examples were compiled into extension modules using Cython 0.21.1.</source>
          <target state="translated">Cython을 사용하여 구현할 수있는 방법을 알아보기 위해 이전에 본 두 가지 예를 살펴 보겠습니다. 이 예제는 Cython 0.21.1을 사용하여 확장 모듈로 컴파일되었습니다.</target>
        </trans-unit>
        <trans-unit id="ddfef2ee46e1e4256e10013c995a2b4530178cef" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say the two integers were in fact 1 and 770. Because 770 = 256 * 3 + 2, the 4 bytes in memory would contain respectively: 0, 1, 3, 2. The bytes I have loaded from the file would have these contents:</source>
          <target state="translated">두 개의 정수가 실제로 1과 770이라고 가정 해 보겠습니다. 770 = 256 * 3 + 2이기 때문에 메모리의 4 바이트에는 각각 0, 1, 3, 2가 포함됩니다. 파일에서로드 한 바이트에는 이러한 내용이 포함됩니다. :</target>
        </trans-unit>
        <trans-unit id="95938c655542a69cb7228f0ca9c4b635920085cc" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you create this array:</source>
          <target state="translated">이 배열을 생성한다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="6b85caabf5e3eeb59af1ba993281156e38d2a215" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s say you have this array:</source>
          <target state="translated">이 배열이 있다고 가정 해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="d641e5a95c4dff41b3615beef8a44670fd8d8071" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this goes for our array:</source>
          <target state="translated">이것이 우리 배열에 어떻게 적용되는지 봅시다 :</target>
        </trans-unit>
        <trans-unit id="663e98c256d28e922f69b08f25c6c3b896decad0" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s see how this works in practice with just one matrix first. Note that according to &lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;colorimetry&lt;/a&gt;, it is possible to obtain a fairly reasonable grayscale version of our color image if we apply the formula</source>
          <target state="translated">먼저 하나의 행렬 만 사용하여 실제로 어떻게 작동하는지 살펴 보겠습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Grayscale#Colorimetric_(perceptual_luminance-preserving)_conversion_to_grayscale&quot;&gt;비색계&lt;/a&gt; 에 따르면 공식을 적용하면 색상 이미지의 상당히 합리적인 회색조 버전을 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ba48f83aec5246b87728fc21ac0f71842c7f7846" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s start with this array, called &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">&quot;a&quot;라고하는이 배열부터 시작하겠습니다.</target>
        </trans-unit>
        <trans-unit id="b44d168c64d4a917f033ec6ef3339ce41baeaa0e" translate="yes" xml:space="preserve">
          <source>Let&amp;rsquo;s try and see what the data looks like excluding the first row (data from the Hubei province in China) so we can look at the missing data more closely:</source>
          <target state="translated">누락 된 데이터를 더 자세히 살펴볼 수 있도록 첫 번째 행 (중국 후베이 성 데이터)을 제외한 데이터가 어떻게 보이는지 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="3229609e15436ec51bcf00818a69a84dbc58a0c2" translate="yes" xml:space="preserve">
          <source>License</source>
          <target state="translated">License</target>
        </trans-unit>
        <trans-unit id="8be2fdf380d9d18148fd2ad94dc354c20768a219" translate="yes" xml:space="preserve">
          <source>License of NumPy</source>
          <target state="translated">NumPy 라이센스</target>
        </trans-unit>
        <trans-unit id="538c09161b8497f998404cafc34964ed3a445575" translate="yes" xml:space="preserve">
          <source>Licensed under the 3-clause BSD License.</source>
          <target state="translated">3 절 BSD 라이센스에 따라 라이센스가 부여됩니다.</target>
        </trans-unit>
        <trans-unit id="b0484b837c9aac64b9b4f0cbb8a409c60f826cd6" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt;&lt;code&gt;PyArray_DescrConverter&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_DescrConverter&quot;&gt; &lt;code&gt;PyArray_DescrConverter&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 컴파일러 와 마찬가지로 C 경계와 유사한 객체를 단어 경계에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="2bf9a983b58a3025088acd0d34cc34c35bed8eba" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt;&lt;code&gt;PyArray_DescrConverter2&lt;/code&gt;&lt;/a&gt; except it aligns C-struct-like objects on word-boundaries as the compiler would.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_DescrConverter2&quot;&gt; &lt;code&gt;PyArray_DescrConverter2&lt;/code&gt; &lt;/a&gt; 와 마찬가지로 컴파일러 와 마찬가지로 C 경계와 유사한 객체를 단어 경계에 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="98e8d5db12d0ec6df75e2b77dc6308321b737245" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;generated/numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 있지만, 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열이 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="8cac4055aba9315ef35a508ccbff6fd2fccbce50" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;generated/numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; 하지만 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열 때 &lt;code&gt;sub&lt;/code&gt; 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="bfb637364ad5b206ba50bed21f3142c132fe9341" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.find.html#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 있지만, 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열이 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="6f8c624e10b2f68f4700be90af9ceef9f419abcf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/reference/generated/numpy.chararray.rfind.html#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; 하지만 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열 때 &lt;code&gt;sub&lt;/code&gt; 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1a6f4f4130f44366224ec12564a5bb81c67b452b" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.chararray.find#numpy.char.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;numpy.char.chararray.find#numpy.char.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 있지만, 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열이 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="c7dc3c1cf09460e0fca6be797b8cde3f51564be9" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.chararray.rfind#numpy.char.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;numpy.char.chararray.rfind#numpy.char.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; 하지만 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열 때 &lt;code&gt;sub&lt;/code&gt; 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="74d7df04563822c7d8ad24dbe267870b77fbb351" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;numpy.char.find#numpy.char.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 있지만, 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열이 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="b35ea9f95fe9a083c883dcd6041e1ed2b46d8192" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;numpy.char.rfind#numpy.char.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; 하지만 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열 때 &lt;code&gt;sub&lt;/code&gt; 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1381300ae7e04647799c4d29476d81d2674e1d00" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt;&lt;code&gt;find&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;numpy.chararray.find#numpy.chararray.find&quot;&gt; &lt;code&gt;find&lt;/code&gt; &lt;/a&gt; 있지만, 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열이 발견되지 않을 때.</target>
        </trans-unit>
        <trans-unit id="b6baf9238888e49aa859d8fb862f39242936cfbf" translate="yes" xml:space="preserve">
          <source>Like &lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt;&lt;code&gt;rfind&lt;/code&gt;&lt;/a&gt;, but raises &lt;code&gt;ValueError&lt;/code&gt; when the substring &lt;code&gt;sub&lt;/code&gt; is not found.</source>
          <target state="translated">마찬가지로 &lt;a href=&quot;numpy.chararray.rfind#numpy.chararray.rfind&quot;&gt; &lt;code&gt;rfind&lt;/code&gt; &lt;/a&gt; 하지만 제기 &lt;code&gt;ValueError&lt;/code&gt; 를을 문자열 때 &lt;code&gt;sub&lt;/code&gt; 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="8f6786bbc0e6826ccf967ce3d26832cec08da525" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;catch_warnings&lt;/code&gt; this context manager is not threadsafe.</source>
          <target state="translated">&lt;code&gt;catch_warnings&lt;/code&gt; 와 마찬가지로이 컨텍스트 관리자는 스레드로부터 안전하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4988e06267fc3ad462b8b1372828e98aa6abe4ae" translate="yes" xml:space="preserve">
          <source>Like &lt;code&gt;recfromtxt&lt;/code&gt;, but with a default &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;recfromtxt&lt;/code&gt; 와 비슷 하지만 기본 &lt;code&gt;delimiter=&quot;,&quot;&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0fa83334e9080fab8905202d2a0b49831c3f225" translate="yes" xml:space="preserve">
          <source>Like for other types, NumPy includes a typedef npy_half for the 16 bit float. Unlike for most of the other types, you cannot use this as a normal type in C, since it is a typedef for npy_uint16. For example, 1.0 looks like 0x3c00 to C, and if you do an equality comparison between the different signed zeros, you will get -0.0 != 0.0 (0x8000 != 0x0000), which is incorrect.</source>
          <target state="translated">다른 유형과 마찬가지로 NumPy에는 16 비트 부동 소수점에 대한 typedef npy_half가 포함됩니다. 대부분의 다른 유형과 달리 npy_uint16의 typedef이므로 C에서 일반 유형으로 사용할 수 없습니다. 예를 들어, 1.0은 0x3c00 ~ C처럼 보이며 다른 부호있는 0 사이에서 동등 비교를 수행하면 -0.0! = 0.0 (0x8000! = 0x0000)이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e112999c2cd378720fa09f5bf6d3cb8761f7e014" translate="yes" xml:space="preserve">
          <source>Like with some other special methods in python, such as &lt;code&gt;__hash__&lt;/code&gt; and &lt;code&gt;__iter__&lt;/code&gt;, it is possible to indicate that your class does &lt;em&gt;not&lt;/em&gt; support ufuncs by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;. Ufuncs always raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; when called on an object that sets &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;__hash__&lt;/code&gt; 및 &lt;code&gt;__iter__&lt;/code&gt; 와 같은 파이썬의 다른 특수 메소드와 마찬가지로 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 을 설정 하여 클래스가 ufunc를 지원 하지 &lt;em&gt;않음&lt;/em&gt; 을 나타낼 수 있습니다 . Ufuncs 는 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 을 설정하는 객체에서 호출 될 때 항상 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; 를&lt;/a&gt; 발생 시킵니다 .</target>
        </trans-unit>
        <trans-unit id="4aa7900482808a9df749231293505b57d3e3de9c" translate="yes" xml:space="preserve">
          <source>Likewise, ellipsis can be specified by code by using the Ellipsis object:</source>
          <target state="translated">마찬가지로 Ellipsis 개체를 사용하여 코드에서 줄임표를 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3297842e50729fb77f4f0545de2f9ff7aa3909b6" translate="yes" xml:space="preserve">
          <source>Likewise, slicing can be combined with broadcasted boolean indices:</source>
          <target state="translated">마찬가지로 슬라이싱은 브로드 캐스트 된 부울 인덱스와 결합 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a7c04c64ed3f2a9374590c76c50d3b7f1b18e3da" translate="yes" xml:space="preserve">
          <source>Limitations</source>
          <target state="translated">Limitations</target>
        </trans-unit>
        <trans-unit id="aed0f783a12a4ca0992442cfbd711f6845a91b7b" translate="yes" xml:space="preserve">
          <source>Limpert, E., Stahel, W. A., and Abbt, M., &amp;ldquo;Log-normal Distributions across the Sciences: Keys and Clues,&amp;rdquo; BioScience, Vol. 51, No. 5, May, 2001. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</source>
          <target state="translated">Limpert, E., Stahel, WA 및 Abbt, M.,&amp;ldquo;과학 전반의 로그 정규 분포 : 키와 단서&amp;rdquo;, BioScience, Vol. 51, No. 5, 2001 년 5 월. &lt;a href=&quot;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&quot;&gt;https://stat.ethz.ch/~stahel/lognormal/bioscience.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2c6327e28944d450d23eb12c3f0eb10b95ac744a" translate="yes" xml:space="preserve">
          <source>LinAlgError</source>
          <target state="translated">LinAlgError</target>
        </trans-unit>
        <trans-unit id="fbfdf4025591ea0589baa96d7f54fd5d7f0a5dbd" translate="yes" xml:space="preserve">
          <source>Line breaks are not included in the resulting list unless keepends is given and true.</source>
          <target state="translated">keepends가 지정되어 있지 않으면 줄 바꿈은 결과 목록에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fd8f1853d29d8157d704e36102bd70d85ec315bd" translate="yes" xml:space="preserve">
          <source>Line spacing and indentation are significant and should be carefully followed.</source>
          <target state="translated">줄 간격과 들여 쓰기는 중요하므로주의 깊게 따라야합니다.</target>
        </trans-unit>
        <trans-unit id="fcb739908d0a50031f680d3b4fffc6749c4002d3" translate="yes" xml:space="preserve">
          <source>Linear Algebra</source>
          <target state="translated">선형 대수</target>
        </trans-unit>
        <trans-unit id="4c2d7925777b262f78b0ed1ceeb1f07eef61acc7" translate="yes" xml:space="preserve">
          <source>Linear Algebra Equivalents</source>
          <target state="translated">선형 대수 등가물</target>
        </trans-unit>
        <trans-unit id="c77bb2c05a2dcf0461045da9b6109d509594fc9a" translate="yes" xml:space="preserve">
          <source>Linear Algebra libraries</source>
          <target state="translated">선형 대수 라이브러리</target>
        </trans-unit>
        <trans-unit id="06d74260ba46e8ed76ff22dda956f18a7b66203c" translate="yes" xml:space="preserve">
          <source>Linear algebra</source>
          <target state="translated">선형 대수</target>
        </trans-unit>
        <trans-unit id="ef4be3efd16d5b211ab89b5efbf030ca1bafba61" translate="yes" xml:space="preserve">
          <source>Linear algebra (&lt;code&gt;numpy.linalg&lt;/code&gt;)</source>
          <target state="translated">선형 대수 ( &lt;code&gt;numpy.linalg&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="e2be6b18cf91c04a7b6c400bd00876f94a2389cb" translate="yes" xml:space="preserve">
          <source>Linear algebra (numpy.linalg)</source>
          <target state="translated">선형 대수 (numpy.linalg)</target>
        </trans-unit>
        <trans-unit id="1e4376126e3fa3a9245e1b149d174565d532409e" translate="yes" xml:space="preserve">
          <source>Linear algebra equivalents</source>
          <target state="translated">선형 대수 등가물</target>
        </trans-unit>
        <trans-unit id="b624aab78757a9b353883b1449d6df824049976b" translate="yes" xml:space="preserve">
          <source>Linear algebra on several matrices at once</source>
          <target state="translated">한 번에 여러 행렬의 선형 대수</target>
        </trans-unit>
        <trans-unit id="991cbbcb4b1ecb2172a95ff800353dc3c4b54edd" translate="yes" xml:space="preserve">
          <source>Linear map parameters between domains.</source>
          <target state="translated">도메인 간 선형 맵 매개 변수</target>
        </trans-unit>
        <trans-unit id="eb36eb210c8667bae908d8f0d19ef3098c4c1701" translate="yes" xml:space="preserve">
          <source>Link extension module with &amp;lt;resource&amp;gt; as defined by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. E.g. to link with optimized LAPACK libraries (vecLib on MacOSX, ATLAS elsewhere), use &lt;code&gt;--link-lapack_opt&lt;/code&gt;. See also &lt;code&gt;--help-link&lt;/code&gt; switch.</source>
          <target state="translated">&lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt; 에 정의 된대로 확장 모듈을 &amp;lt;resource&amp;gt;와 연결합니다 . 예를 들어 최적화 된 LAPACK 라이브러리 (MacOSX에서는 vecLib, 다른 곳에서는 ATLAS)와 연결하려면 &lt;code&gt;--link-lapack_opt&lt;/code&gt; 를 사용 하십시오 . &lt;code&gt;--help-link&lt;/code&gt; 스위치 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26958b7c786c621d84d02830a0b14f77df5b2d9e" translate="yes" xml:space="preserve">
          <source>Linking against the core math library in an extension</source>
          <target state="translated">확장에서 핵심 수학 라이브러리에 대한 링크</target>
        </trans-unit>
        <trans-unit id="f9ddb8c3deec44cd98e047bb68bdaf188f3b72f8" translate="yes" xml:space="preserve">
          <source>Linking your repository to the upstream repo</source>
          <target state="translated">리포지토리를 업스트림 리포지토리에 연결</target>
        </trans-unit>
        <trans-unit id="014bcd654c60d5250fad2123b073b9c0ac3340f6" translate="yes" xml:space="preserve">
          <source>Links</source>
          <target state="translated">Links</target>
        </trans-unit>
        <trans-unit id="2d54756ca8573af092113bb3435c0903eeb35dd6" translate="yes" xml:space="preserve">
          <source>Links : If you need to include hyperlinks in your docstring, note that some docstring sections are not parsed as standard reST, and in these sections, numpydoc may become confused by hyperlink targets such as:</source>
          <target state="translated">링크 : 독 스트링에 하이퍼 링크를 포함해야하는 경우 일부 독 스트링 섹션은 표준 reST로 구문 분석되지 않으며 이러한 섹션에서 numpydoc은 다음과 같은 하이퍼 링크 대상과 혼동 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="518ed7ba947b32b000717c46a46d61dd856bd112" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://kerneltrap.org/Linux/Git_Management&quot;&gt;git 관리&lt;/a&gt; 에 대한 Linus Torvalds</target>
        </trans-unit>
        <trans-unit id="6cf86d6b89c993ef56513045443e84088de16799" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://web.archive.org/web/20090328043540/http://kerneltrap.org/Linux/Git_Management&quot;&gt;git management&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://web.archive.org/web/20090328043540/http://kerneltrap.org/Linux/Git_Management&quot;&gt;git 관리&lt;/a&gt; 에 대한 Linus Torvalds</target>
        </trans-unit>
        <trans-unit id="965d93d3a9947030cc756b2db0fcacc76437a993" translate="yes" xml:space="preserve">
          <source>Linus Torvalds on &lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;linux git workflow&lt;/a&gt; . Summary; use the git tools to make the history of your edits as clean as possible; merge from upstream edits as little as possible in branches where you are doing active development.</source>
          <target state="translated">&lt;a href=&quot;https://www.mail-archive.com/dri-devel@lists.sourceforge.net/msg39091.html&quot;&gt;Linux git 워크 플로의&lt;/a&gt; Linus Torvalds . 요약; git 도구를 사용하여 편집 내역을 가능한 한 깔끔하게 만드십시오. 활발한 개발을하고있는 브랜치에서 가능한 한 적게 업스트림 편집에서 병합합니다.</target>
        </trans-unit>
        <trans-unit id="83ad8510bbd3f22363d068e1c96f82fd0fcccd31" translate="yes" xml:space="preserve">
          <source>Linux</source>
          <target state="translated">Linux</target>
        </trans-unit>
        <trans-unit id="d1400c37d080d60eab76dbcb84834f7292aae696" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on a i5-3570 processor.</source>
          <target state="translated">Linux 타이밍은 Ubuntu 18.04 및 GCC 7.4를 사용했습니다. Windows 타이밍은 Microsoft C / C ++ 최적화 컴파일러 버전 19 (Visual Studio 2015)를 사용하여 Windows 10에서 이루어졌습니다. 모든 타이밍은 i5-3570 프로세서에서 생성되었습니다.</target>
        </trans-unit>
        <trans-unit id="56d0cc5c207ff297b983e9b52ef59aa241b28b67" translate="yes" xml:space="preserve">
          <source>Linux timings used Ubuntu 18.04 and GCC 7.4. Windows timings were made on Windows 10 using Microsoft C/C++ Optimizing Compiler Version 19 (Visual Studio 2015). All timings were produced on an i5-3570 processor.</source>
          <target state="translated">Linux 타이밍은 Ubuntu 18.04 및 GCC 7.4를 사용했습니다. Windows 타이밍은 Microsoft C / C ++ 최적화 컴파일러 버전 19 (Visual Studio 2015)를 사용하여 Windows 10에서 작성되었습니다. 모든 타이밍은 i5-3570 프로세서에서 제작되었습니다.</target>
        </trans-unit>
        <trans-unit id="87860891be4cddda593f0fa03126f25fb568db9f" translate="yes" xml:space="preserve">
          <source>Linux: 32-bit and 64-bit Manylinux1 wheels built using travis-ci.</source>
          <target state="translated">Linux : 32 비트 및 64 비트 Travis-ci를 사용하여 빌드 된 Manylinux1 휠.</target>
        </trans-unit>
        <trans-unit id="97d9791ab8737c4211f3e78630cca56638f02eb1" translate="yes" xml:space="preserve">
          <source>List available Fortran compilers.</source>
          <target state="translated">사용 가능한 Fortran 컴파일러를 나열합니다.</target>
        </trans-unit>
        <trans-unit id="eb5d7118db68e7b8996c3d0844e8e2d779102b13" translate="yes" xml:space="preserve">
          <source>List of array-like objects (such as lists, tuples, and ndarrays).</source>
          <target state="translated">배열과 유사한 객체 목록 (예 : 목록, 튜플 및 ndarray).</target>
        </trans-unit>
        <trans-unit id="decb4e37dac06b0a04b2b5a1ce16d06dbaf9430d" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg, z_deg].</source>
          <target state="translated">[x_deg, y_deg, z_deg] 형식의 최대 각도 목록입니다.</target>
        </trans-unit>
        <trans-unit id="16b40ddc35115642a1ebd2b343c063499d9e736a" translate="yes" xml:space="preserve">
          <source>List of maximum degrees of the form [x_deg, y_deg].</source>
          <target state="translated">[x_deg, y_deg] 형식의 최대 각도 목록입니다.</target>
        </trans-unit>
        <trans-unit id="3946ce7ee00307be1e56a351d33b3682868445a4" translate="yes" xml:space="preserve">
          <source>List of roots.</source>
          <target state="translated">뿌리의 목록.</target>
        </trans-unit>
        <trans-unit id="4e5a894ae66af5e5eb828b13d596e0e9298ff835" translate="yes" xml:space="preserve">
          <source>List of source file locations relative to the top directory of the package.</source>
          <target state="translated">패키지의 최상위 디렉토리에 상대적인 소스 파일 위치 목록입니다.</target>
        </trans-unit>
        <trans-unit id="2c7afb1b33d8f0bf102c5fdc5f3bfa27a81be1cb" translate="yes" xml:space="preserve">
          <source>List of the library&amp;rsquo;s source files. See &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt;&lt;code&gt;add_library&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">라이브러리의 소스 파일 목록 자세한 내용은 &lt;a href=&quot;#numpy.distutils.misc_util.Configuration.add_library&quot;&gt; &lt;code&gt;add_library&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5754e63d6ae44ac265c0defe49c460674a2539b7" translate="yes" xml:space="preserve">
          <source>List of the most important terms</source>
          <target state="translated">가장 중요한 용어 목록</target>
        </trans-unit>
        <trans-unit id="6519aa721c25f67c763afcfac03293aba9cab8a8" translate="yes" xml:space="preserve">
          <source>List of the sources. The list of sources may contain functions (called source generators) which must take an extension instance and a build directory as inputs and return a source file or list of source files or None. If None is returned then no sources are generated. If the Extension instance has no sources after processing all source generators, then no extension module is built.</source>
          <target state="translated">출처 목록. 소스 목록에는 확장 인스턴스와 빌드 디렉토리를 입력으로 사용하여 소스 파일 또는 소스 파일 목록을 리턴하거나 없음을 리턴해야하는 함수 (소스 생성기라고 함)가 포함될 수 있습니다. None이 반환되면 소스가 생성되지 않습니다. 모든 소스 생성기를 처리 한 후 Extension 인스턴스에 소스가 없으면 확장 모듈이 빌드되지 않은 것입니다.</target>
        </trans-unit>
        <trans-unit id="2485a7cc99c4617bf66ce59e5b75a2d0c1ccfb4b" translate="yes" xml:space="preserve">
          <source>List system resources found by &lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt;. For example, try &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;numpy_distutils/system_info.py&lt;/code&gt; 에서 찾은 시스템 리소스를 나열합니다 . 예를 들어 &lt;code&gt;f2py --help-link lapack_opt&lt;/code&gt; 를 시도 하십시오 .</target>
        </trans-unit>
        <trans-unit id="50800b4f18e2a927baac61501f7e23170e957be0" translate="yes" xml:space="preserve">
          <source>List with any extra arguments to pass to nosetests.</source>
          <target state="translated">nosetest에 전달할 추가 인수와 함께 나열하십시오.</target>
        </trans-unit>
        <trans-unit id="70836ea6cfbd010e5c69675c6ed9768657e90763" translate="yes" xml:space="preserve">
          <source>Literal string representation.</source>
          <target state="translated">리터럴 문자열 표현.</target>
        </trans-unit>
        <trans-unit id="d40f76f0ffb9625ea51482e91de953541d5c3201" translate="yes" xml:space="preserve">
          <source>Load MATLAB variables saved to the file &lt;code&gt;data.mat&lt;/code&gt;. (Note: When saving arrays to &lt;code&gt;data.mat&lt;/code&gt; in MATLAB/Octave, use a recent binary format. &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat&quot;&gt;&lt;code&gt;scipy.io.loadmat&lt;/code&gt;&lt;/a&gt; will create a dictionary with the saved arrays and further information.)</source>
          <target state="translated">&lt;code&gt;data.mat&lt;/code&gt; 파일에 저장된 MATLAB 변수를 불러 옵니다 . (참고 : MATLAB / Octave의 &lt;code&gt;data.mat&lt;/code&gt; 에 배열을 저장할 때 최신 바이너리 형식을 사용하십시오. &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat&quot;&gt; &lt;code&gt;scipy.io.loadmat&lt;/code&gt; &lt;/a&gt; 는 저장된 배열과 추가 정보로 사전을 생성합니다.)</target>
        </trans-unit>
        <trans-unit id="d75a54184aa53b5be4e832c635455d88f3cdc5e6" translate="yes" xml:space="preserve">
          <source>Load a pickle from the current string.</source>
          <target state="translated">현재 문자열에서 피클을로드합니다.</target>
        </trans-unit>
        <trans-unit id="3a504cdc1122f04029c4d408c355532536995f45" translate="yes" xml:space="preserve">
          <source>Load arrays or pickled objects from &lt;code&gt;.npy&lt;/code&gt;, &lt;code&gt;.npz&lt;/code&gt; or pickled files.</source>
          <target state="translated">&lt;code&gt;.npy&lt;/code&gt; , &lt;code&gt;.npz&lt;/code&gt; 또는 pickled 파일 에서 배열 또는 절인 객체를로드 합니다.</target>
        </trans-unit>
        <trans-unit id="9d2a30e3c587d0309a2b15e920e2381e52d3b73a" translate="yes" xml:space="preserve">
          <source>Load data from a text file, with missing values handled as specified.</source>
          <target state="translated">지정된대로 처리 된 결 측값으로 텍스트 파일에서 데이터를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="671e399a95a295b1b112f2ec88bde3aa682ce01d" translate="yes" xml:space="preserve">
          <source>Load data from a text file.</source>
          <target state="translated">텍스트 파일에서 데이터를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="ede7696890a000813048b7b45d0ec4e8eaa41ac3" translate="yes" xml:space="preserve">
          <source>Load data with missing values handled as specified.</source>
          <target state="translated">지정된대로 처리 된 결 측값이있는 데이터를로드하십시오.</target>
        </trans-unit>
        <trans-unit id="0fb4575d68b4fb0f498f6ef6cd58ad29dfef99ec" translate="yes" xml:space="preserve">
          <source>Load the files created by savez_compressed.</source>
          <target state="translated">savez_compressed에 의해 작성된 파일을로드하십시오.</target>
        </trans-unit>
        <trans-unit id="00e2276e50083512489893c74a3667bfb2f8d261" translate="yes" xml:space="preserve">
          <source>Load the memmap and verify data was stored:</source>
          <target state="translated">memmap을로드하고 데이터가 저장되었는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f5bde0422e688546d3fcbda903a1675bdef859be" translate="yes" xml:space="preserve">
          <source>Load the shared library.</source>
          <target state="translated">공유 라이브러리를로드합니다.</target>
        </trans-unit>
        <trans-unit id="4f1b35f9beeb82ff23b55bdd7e4bccbaa09655da" translate="yes" xml:space="preserve">
          <source>Loading files that contain object arrays uses the &lt;code&gt;pickle&lt;/code&gt; module, which is not secure against erroneous or maliciously constructed data. Consider passing &lt;code&gt;allow_pickle=False&lt;/code&gt; to load data that is known not to contain object arrays for the safer handling of untrusted sources.</source>
          <target state="translated">객체 배열이 포함 된 파일을로드하면 &lt;code&gt;pickle&lt;/code&gt; 모듈이 사용되며 잘못되었거나 악의적으로 구성된 데이터에 대해서는 안전하지 않습니다. 신뢰할 수없는 소스를보다 안전하게 처리하기 위해 객체 배열을 포함하지 않는 것으로 알려진 데이터를로드하려면 &lt;code&gt;allow_pickle=False&lt;/code&gt; 를 전달하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="dc43ff557f7299b63c00a5f98241bc55534a0318" translate="yes" xml:space="preserve">
          <source>Loading the shared library</source>
          <target state="translated">공유 라이브러리로드</target>
        </trans-unit>
        <trans-unit id="dcd21227c7ed1f7628c4569c3c3b1f97f5e4a3e0" translate="yes" xml:space="preserve">
          <source>Local file path or URL to open.</source>
          <target state="translated">열 로컬 파일 경로 또는 URL</target>
        </trans-unit>
        <trans-unit id="399e1ff0ce348a172dad0b088afb4891c55b0357" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same BitGenerator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">동일한 BitGenerator를 상태를 손상시키지 않고 여러 생성기에서 사용할 수 있도록 공유 된 인스턴스를 잠급니다. 비트 생성기에서 값을 생성하는 코드는 비트 생성기의 잠금을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="2d415fb960b72005c6491287e9aedba95abd331c" translate="yes" xml:space="preserve">
          <source>Lock instance that is shared so that the same bit git generator can be used in multiple Generators without corrupting the state. Code that generates values from a bit generator should hold the bit generator&amp;rsquo;s lock.</source>
          <target state="translated">동일한 비트 git 생성기가 상태를 손상시키지 않고 여러 생성기에서 사용될 수 있도록 공유 된 인스턴스를 잠급니다. 비트 생성기에서 값을 생성하는 코드는 비트 생성기의 잠금을 유지해야합니다.</target>
        </trans-unit>
        <trans-unit id="107cbe58cd70b9b9564b7a980ec9a134ba83ff37" translate="yes" xml:space="preserve">
          <source>Log error message:</source>
          <target state="translated">로그 오류 메시지 :</target>
        </trans-unit>
        <trans-unit id="4eb269913863abecf02addc638fee893d2c7588f" translate="yes" xml:space="preserve">
          <source>Log into your &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 계정에 로그인하십시오 .</target>
        </trans-unit>
        <trans-unit id="68562d9439407512f691d4a23d6d20e4c6852435" translate="yes" xml:space="preserve">
          <source>Log into your GitHub account.</source>
          <target state="translated">GitHub 계정에 로그인하십시오.</target>
        </trans-unit>
        <trans-unit id="5b18e27bd081f5e88f5467d9d05245be1522ecbd" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;10**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">대수는 다중 값 함수입니다. 각 &lt;code&gt;x&lt;/code&gt; 에 대해 &lt;code&gt;10**z = x&lt;/code&gt; 와 같은 &lt;code&gt;z&lt;/code&gt; 의 무한 수가 있습니다. 관습은 가상 부분이 &lt;code&gt;[-pi, pi]&lt;/code&gt; 에 있는 &lt;code&gt;z&lt;/code&gt; 를 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="5a52fe88f1d34f63b32537a63132c16ed59948f4" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;2**z = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">대수는 다중 값 함수입니다. 각 &lt;code&gt;x&lt;/code&gt; 에 대해 &lt;code&gt;2**z = x&lt;/code&gt; 와 같은 &lt;code&gt;z&lt;/code&gt; 의 무한 수가 있습니다. 관습은 가상 부분이 &lt;code&gt;[-pi, pi]&lt;/code&gt; 에 있는 &lt;code&gt;z&lt;/code&gt; 를 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="04517496328a3b4c1d39612790fc59d3b950de57" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = 1 + x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">대수는 다중 값 함수입니다. 각 &lt;code&gt;x&lt;/code&gt; 에 대해 &lt;code&gt;exp(z) = 1 + x&lt;/code&gt; 와 같은 무한 수의 &lt;code&gt;z&lt;/code&gt; 가 있습니다. 관습은 가상 부분이 &lt;code&gt;[-pi, pi]&lt;/code&gt; 있는 &lt;code&gt;z&lt;/code&gt; 를 반환하는 것입니다 . 입니다.</target>
        </trans-unit>
        <trans-unit id="8f044358a356b12f8f04d65ec46fba2c711db9ca" translate="yes" xml:space="preserve">
          <source>Logarithm is a multivalued function: for each &lt;code&gt;x&lt;/code&gt; there is an infinite number of &lt;code&gt;z&lt;/code&gt; such that &lt;code&gt;exp(z) = x&lt;/code&gt;. The convention is to return the &lt;code&gt;z&lt;/code&gt; whose imaginary part lies in &lt;code&gt;[-pi, pi]&lt;/code&gt;.</source>
          <target state="translated">대수는 다중 값 함수입니다. 각 &lt;code&gt;x&lt;/code&gt; 에 대해 &lt;code&gt;exp(z) = x&lt;/code&gt; 와 같은 &lt;code&gt;z&lt;/code&gt; 의 무한 수가 있습니다. 관습은 가상 부분이 &lt;code&gt;[-pi, pi]&lt;/code&gt; 에 있는 &lt;code&gt;z&lt;/code&gt; 를 반환하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="166930005429709b3b373125970bc9f001b57f22" translate="yes" xml:space="preserve">
          <source>Logarithm of &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt;. This is a scalar if both &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt; are scalars.</source>
          <target state="translated">대수의 &lt;code&gt;exp(x1) + exp(x2)&lt;/code&gt; . &lt;code&gt;x1&lt;/code&gt; 과 &lt;code&gt;x2&lt;/code&gt; 가 모두 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="0df50307c119146d5dc714638f54a5eccd592099" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of inputs in base 2.</source>
          <target state="translated">밑이 2 인 입력의 지수 합의 로그입니다.</target>
        </trans-unit>
        <trans-unit id="3a29b9b1054fef950824734dd96565e57e322c96" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs in base-2.</source>
          <target state="translated">밑이 2 인 입력의 지수 합의 로그입니다.</target>
        </trans-unit>
        <trans-unit id="273c857a62012f5708232560c688d9c8f7c28ba5" translate="yes" xml:space="preserve">
          <source>Logarithm of the sum of exponentiations of the inputs.</source>
          <target state="translated">입력 지수 합의 로그입니다.</target>
        </trans-unit>
        <trans-unit id="e7b8fad3893b278189df782f86ba4d32084ced17" translate="yes" xml:space="preserve">
          <source>Logarithm to base 10 of the Euler constant (</source>
          <target state="translated">오일러 상수의 밑이 10 인 로그</target>
        </trans-unit>
        <trans-unit id="80963c1ddcee26932e512e1ef164c3f919eb6773" translate="yes" xml:space="preserve">
          <source>Logarithm to base 2 of the Euler constant (</source>
          <target state="translated">오일러 상수의 밑이 2 인 로그</target>
        </trans-unit>
        <trans-unit id="dca3308567585813d8c4516ae0b5df7d6382aa24" translate="yes" xml:space="preserve">
          <source>Logic functions</source>
          <target state="translated">논리 기능</target>
        </trans-unit>
        <trans-unit id="acdcdb17721480a7efeeb33b0138faad218dbf31" translate="yes" xml:space="preserve">
          <source>Logical NOT is applied to the elements of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">논리 NOT은 &lt;code&gt;x&lt;/code&gt; 의 요소에 적용됩니다 .</target>
        </trans-unit>
        <trans-unit id="98ddc2178009c7731c8ae53ab405983c8f38c802" translate="yes" xml:space="preserve">
          <source>Logical OR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">논리 OR은 &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용됩니다 . 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="f5bd72920a8d92e6480e74978ed9235cd1d3ad95" translate="yes" xml:space="preserve">
          <source>Logical XOR is applied to the elements of &lt;code&gt;x1&lt;/code&gt; and &lt;code&gt;x2&lt;/code&gt;. If &lt;code&gt;x1.shape != x2.shape&lt;/code&gt;, they must be broadcastable to a common shape (which becomes the shape of the output).</source>
          <target state="translated">논리 XOR은 &lt;code&gt;x1&lt;/code&gt; 및 &lt;code&gt;x2&lt;/code&gt; 의 요소에 적용됩니다 . 경우 &lt;code&gt;x1.shape != x2.shape&lt;/code&gt; 들은 (출력의 모양이된다) 공통 캐스트 가능한 형상이어야한다.</target>
        </trans-unit>
        <trans-unit id="ab411408fbd29ad68b53700b2e7826c03e6703f0" translate="yes" xml:space="preserve">
          <source>Logical operations</source>
          <target state="translated">논리 연산</target>
        </trans-unit>
        <trans-unit id="f9360627c5984485d4c34bec86c9dfebc0835bd0" translate="yes" xml:space="preserve">
          <source>Logspace is equivalent to the code</source>
          <target state="translated">로그 공간은 코드와 동일합니다</target>
        </trans-unit>
        <trans-unit id="05614c0010510d48dea6823d792acc33ba6daeb2" translate="yes" xml:space="preserve">
          <source>Long answer</source>
          <target state="translated">긴 대답</target>
        </trans-unit>
        <trans-unit id="cfff3eff895eee45ffb53c164dd9129e264c6241" translate="yes" xml:space="preserve">
          <source>Long arrays can be summarised:</source>
          <target state="translated">긴 배열을 요약하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="57c8d49665e2668f2033281dda387f2cad2ecde8" translate="yes" xml:space="preserve">
          <source>Look it over</source>
          <target state="translated">봐봐</target>
        </trans-unit>
        <trans-unit id="985f144664017939330de9e8e7013e16b8babbcb" translate="yes" xml:space="preserve">
          <source>Looking at the data, here&amp;rsquo;s what we find: there is a period with &lt;strong&gt;missing data&lt;/strong&gt;:</source>
          <target state="translated">데이터를 살펴보면 다음과 같습니다. &lt;strong&gt;누락 된 데이터&lt;/strong&gt; 가있는 기간이 &lt;strong&gt;있습니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="8677f57b867596167599f15cd53463b229e648c6" translate="yes" xml:space="preserve">
          <source>Lots of learning overhead:</source>
          <target state="translated">많은 학습 오버 헤드 :</target>
        </trans-unit>
        <trans-unit id="dcabfd17cd19c7e1ebdad9125ee467aec3f27671" translate="yes" xml:space="preserve">
          <source>Low-level floating point manipulation</source>
          <target state="translated">저수준 부동 소수점 조작</target>
        </trans-unit>
        <trans-unit id="20bd4a379661919ac01507844a8735e9e7029b21" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 32-bit single-precision float, stored as a uint32.</source>
          <target state="translated">16 비트 반 정밀도 부동 소수점을 32 비트 단 정밀도 부동 소수점으로 변환하는 저수준 함수로, uint32로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="e475f5fc68e395b56437c0cdf65cca2d5aa08147" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 16-bit half-precision float into a 64-bit double-precision float, stored as a uint64.</source>
          <target state="translated">16 비트 반 정밀도 부동 소수점을 64 비트 배정 밀도 부동 소수점으로 변환하는 저수준 기능으로 uint64로 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="96bea3d344730e551ebce7080101c44ce0f90690" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 32-bit single-precision float, stored as a uint32, into a 16-bit half-precision float.</source>
          <target state="translated">uint32로 저장된 32 비트 단 정밀도 부동 소수점을 16 비트 반 정밀도 부동 소수점으로 변환하는 저수준 기능입니다.</target>
        </trans-unit>
        <trans-unit id="ff645f12bfda22b17ebed86ab48b65f035e74b8d" translate="yes" xml:space="preserve">
          <source>Low-level function which converts a 64-bit double-precision float, stored as a uint64, into a 16-bit half-precision float.</source>
          <target state="translated">uint64로 저장된 64 비트 배정 밀도 부동 소수점을 16 비트 반 정밀도 부동 소수점으로 변환하는 저수준 함수입니다.</target>
        </trans-unit>
        <trans-unit id="352aca4d37f9444dfec5d82c349a1052e7d84651" translate="yes" xml:space="preserve">
          <source>Lower boundary of the output interval. All values generated will be greater than or equal to low. The default value is 0.</source>
          <target state="translated">출력 간격의 하한. 생성 된 모든 값은 low보다 크거나 같습니다. 기본값은 0입니다.</target>
        </trans-unit>
        <trans-unit id="4bf35d3bbb54e1377461549a2939f7d0b3e69b61" translate="yes" xml:space="preserve">
          <source>Lower limit.</source>
          <target state="translated">하한.</target>
        </trans-unit>
        <trans-unit id="7de9677832dcede5ad99fb5a80acb920b62eed43" translate="yes" xml:space="preserve">
          <source>Lower triangle of &lt;code&gt;m&lt;/code&gt;, of same shape and data-type as &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">삼각형 낮추 &lt;code&gt;m&lt;/code&gt; 동일한 형상과 같은 데이터 타입, &lt;code&gt;m&lt;/code&gt; 이 .</target>
        </trans-unit>
        <trans-unit id="2daaaf38d1f5ab90fa4560a3de14f582045a565c" translate="yes" xml:space="preserve">
          <source>Lower triangle of an array.</source>
          <target state="translated">배열의 아래쪽 삼각형.</target>
        </trans-unit>
        <trans-unit id="83251c72d4ba0cc804bd754996e879943acb761e" translate="yes" xml:space="preserve">
          <source>Lowest (signed) integer to be drawn from the distribution (unless &lt;code&gt;high=None&lt;/code&gt;, in which case this parameter is the &lt;em&gt;highest&lt;/em&gt; such integer).</source>
          <target state="translated">분포에서 추출 할 가장 낮은 (부호있는) 정수 ( &lt;code&gt;high=None&lt;/code&gt; 이 아닌 경우이 매개 변수가 &lt;em&gt;가장 높은&lt;/em&gt; 정수)&lt;em&gt;&lt;/em&gt; 정수).</target>
        </trans-unit>
        <trans-unit id="b68fc5877ebf9c93e957bc6591a72c392406bb37" translate="yes" xml:space="preserve">
          <source>Lowest (signed) integers to be drawn from the distribution (unless &lt;code&gt;high=None&lt;/code&gt;, in which case this parameter is 0 and this value is used for &lt;code&gt;high&lt;/code&gt;).</source>
          <target state="translated">분포에서 추출 할 가장 낮은 (부호있는) 정수 ( &lt;code&gt;high=None&lt;/code&gt; 이 아닌 경우이 매개 변수는 0이고이 값은 &lt;code&gt;high&lt;/code&gt; 에 사용됨 ).</target>
        </trans-unit>
        <trans-unit id="b948a7f8849519063c3bff20a99bb0099ed30eea" translate="yes" xml:space="preserve">
          <source>Lowest (signed) integers to be drawn from the distribution (unless &lt;code&gt;high=None&lt;/code&gt;, in which case this parameter is one above the &lt;em&gt;highest&lt;/em&gt; such integer).</source>
          <target state="translated">분포에서 추출 할 가장 낮은 (부호있는) 정수 ( &lt;code&gt;high=None&lt;/code&gt; 이 아닌 경우이 매개 변수가 이러한 정수 보다 &lt;em&gt;높은&lt;/em&gt; 정수보다 큼)</target>
        </trans-unit>
        <trans-unit id="c63ae6dd4fc9f9dda66970e827d13f7c73fe841c" translate="yes" xml:space="preserve">
          <source>M</source>
          <target state="translated">M</target>
        </trans-unit>
        <trans-unit id="796395a2ce2426bed5b8f2309da7f84c477d5434" translate="yes" xml:space="preserve">
          <source>M. Abramovitz and I. A. Stegun, &amp;ldquo;Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables,&amp;rdquo; Dover, 1964, p. 69, &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_69.htm&quot;&gt;http://www.math.sfu.ca/~cbm/aands/page_69.htm&lt;/a&gt;</source>
          <target state="translated">M. Abramovitz 및 IA Stegun,&amp;ldquo;수식, 그래프 및 수학 표가있는 수학 함수 핸드북&amp;rdquo;, Dover, 1964, p. 69, &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_69.htm&quot;&gt;http://www.math.sfu.ca/~cbm/aands/page_69.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="14d9022ecb1d459d96a2cc474aaed3bd680af3c4" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, &lt;em&gt;Handbook of Mathematical Functions&lt;/em&gt;, 10th printing, New York: Dover, 1964, pp. 379. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_379.htm&quot;&gt;http://www.math.sfu.ca/~cbm/aands/page_379.htm&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz와 IA Stegun, &lt;em&gt;수학 함수 핸드북&lt;/em&gt; , 10 번째 인쇄, 뉴욕 : Dover, 1964, pp. 379. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/page_379.htm&quot;&gt;http://www.math.sfu.ca/~cbm/aands/page_379.htm&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0cb7cd22c76edc78df8480ba3d6f4832ff91ded4" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972, pg. 83.</source>
          <target state="translated">M. Abramowitz와 IA Stegun, 수학 함수 핸드북. 뉴욕, 뉴욕 : 도버, 1972, pg. 83.</target>
        </trans-unit>
        <trans-unit id="43e43bd133d6863cb7a9de2d689e513b6c81217e" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972, pg. 83. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz와 IA Stegun, 수학 함수 핸드북. 뉴욕, 뉴욕 : 도버, 1972, pg. 83. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="53b1c9c8eb0cf262b57729e4b91b33dc7f1eea81" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I. A. Stegun, Handbook of Mathematical Functions. New York, NY: Dover, 1972.</source>
          <target state="translated">M. Abramowitz와 IA Stegun, 수학 함수 핸드북. 뉴욕, 뉴욕 : 1972 년 도버.</target>
        </trans-unit>
        <trans-unit id="ee284bd1edf39da7accb49887b022f2a6880ffff" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun, &amp;ldquo;Handbook of Mathematical Functions&amp;rdquo;, 10th printing, 1964, pp. 67. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz와 IA Stegun,&amp;ldquo;수학적 기능 핸드북&amp;rdquo;, 10 회 인쇄, 1964, pp. 67. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b4d7af77e2474b1e03deb4c841c43fa44b4fa670" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun, &amp;ldquo;Handbook of Mathematical Functions&amp;rdquo;, 10th printing, 1964, pp. 79. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz와 IA Stegun,&amp;ldquo;수학 기능 안내서&amp;rdquo;, 10 회 인쇄, 1964, pp. 79. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1000d3b7bf23c3293db40f1e12e55a155eb71f88" translate="yes" xml:space="preserve">
          <source>M. Abramowitz and I.A. Stegun, &amp;ldquo;Handbook of Mathematical Functions&amp;rdquo;, 10th printing, 1964, pp. 86. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">M. Abramowitz와 IA Stegun,&amp;ldquo;수학적 기능 핸드북&amp;rdquo;, 10 회 인쇄, 1964, pp. 86. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="10401d4904a530878ef500d4c01e13971fc1a5ec" translate="yes" xml:space="preserve">
          <source>M. Matsumoto and T. Nishimura, &amp;ldquo;Mersenne Twister: A 623-dimensionally equidistributed uniform pseudorandom number generator,&amp;rdquo; &lt;em&gt;ACM Trans. on Modeling and Computer Simulation&lt;/em&gt;, Vol. 8, No. 1, pp. 3-30, Jan. 1998.</source>
          <target state="translated">M. Matsumoto 및 T. Nishimura,&amp;ldquo;Mersenne Twister : 623 차원으로 균일하게 분포 된 균일 한 의사 난수 생성기&amp;rdquo; &lt;em&gt;ACM Trans. 모델링 및 컴퓨터 시뮬레이션&lt;/em&gt; , Vol. 8, No. 1, 3-30 페이지, 1998 년 1 월</target>
        </trans-unit>
        <trans-unit id="a563fa6014f9030bc1091eda42860c70e53a75fd" translate="yes" xml:space="preserve">
          <source>M. Sullivan and M. Sullivan, III, &amp;ldquo;Algebra and Trignometry, Enhanced With Graphing Utilities,&amp;rdquo; Prentice-Hall, pg. 318, 1996.</source>
          <target state="translated">M. Sullivan 및 M. Sullivan, III,&amp;ldquo;그래프 유틸리티를 사용하여 개선 된 대수 및 삼각법,&amp;rdquo;Prentice-Hall, pg. 318, 1996.</target>
        </trans-unit>
        <trans-unit id="57cfa503fff95bbc068ee0b81926d66666383d31" translate="yes" xml:space="preserve">
          <source>M.S. Bartlett, &amp;ldquo;Periodogram Analysis and Continuous Spectra&amp;rdquo;, Biometrika 37, 1-16, 1950.</source>
          <target state="translated">MS Bartlett, &quot;주기도 분석 및 연속 스펙트럼&quot;, Biometrika 37, 1-16, 1950.</target>
        </trans-unit>
        <trans-unit id="07c4259d5179cff418840e647fb277f309829dc5" translate="yes" xml:space="preserve">
          <source>MATLAB</source>
          <target state="translated">MATLAB</target>
        </trans-unit>
        <trans-unit id="4f18c8e8809688b9c079f7f16f35ca10cf7359eb" translate="yes" xml:space="preserve">
          <source>MATLAB array slicing uses pass-by-value semantics, with a lazy copy-on-write scheme to prevent creating copies until they are needed. Slicing operations copy parts of the array.</source>
          <target state="translated">MATLAB 배열 슬라이싱은 필요할 때까지 복사본 생성을 방지하기 위해 lazy copy-on-write 체계와 함께 값에 의한 전달 의미 체계를 사용합니다. 슬라이싱 작업은 어레이의 일부를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="117ac3761ded4c3563f6597cdc0e0c754c1f485f" translate="yes" xml:space="preserve">
          <source>MATLAB numbers indices from 1; &lt;code&gt;a(1)&lt;/code&gt; is the first element. &lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;See note INDEXING&lt;/a&gt;</source>
          <target state="translated">1에서 MATLAB 숫자 인덱스; &lt;code&gt;a(1)&lt;/code&gt; 은 첫 번째 요소입니다. &lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;INDEXING 참고 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6774190d7f255e538acfbf2555afa1d8c09f5542" translate="yes" xml:space="preserve">
          <source>MATLAB reference documention, &amp;ldquo;Rank&amp;rdquo; &lt;a href=&quot;https://www.mathworks.com/help/techdoc/ref/rank.html&quot;&gt;https://www.mathworks.com/help/techdoc/ref/rank.html&lt;/a&gt;</source>
          <target state="translated">MATLAB 참조 문서,&amp;ldquo;순위&amp;rdquo; &lt;a href=&quot;https://www.mathworks.com/help/techdoc/ref/rank.html&quot;&gt;https://www.mathworks.com/help/techdoc/ref/rank.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9af4fc7b8138d2f8740cae99324e5b71bdbe2bdd" translate="yes" xml:space="preserve">
          <source>MATLAB work-a-like for 1-D and 2-D arrays.</source>
          <target state="translated">MATLAB은 1-D 및 2-D 배열과 유사합니다.</target>
        </trans-unit>
        <trans-unit id="808ffbf65afa62d125344d9b3e8790439801c809" translate="yes" xml:space="preserve">
          <source>MATLAB work-alike for 1-D and 2-D arrays.</source>
          <target state="translated">MATLAB은 1 차원 배열과 2 차원 배열에서 동일하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="f85414cd1f82e383cd03828ac004e023cb0d7588" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and NumPy have a lot in common, but NumPy was created to work with Python, not to be a MATLAB clone. This guide will help MATLAB users get started with NumPy.</source>
          <target state="translated">MATLAB&amp;reg;과 NumPy는 공통점이 많지만 NumPy는 MATLAB 복제본이 아니라 Python과 함께 작동하도록 만들어졌습니다. 이 가이드는 MATLAB 사용자가 NumPy를 시작하는 데 도움이됩니다.</target>
        </trans-unit>
        <trans-unit id="36217387e89303860875aacac815f82055244ac7" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and NumPy/SciPy have a lot in common. But there are many differences. NumPy and SciPy were created to do numerical and scientific computing in the most natural way with Python, not to be MATLAB&amp;reg; clones. This page is intended to be a place to collect wisdom about the differences, mostly for the purpose of helping proficient MATLAB&amp;reg; users become proficient NumPy and SciPy users.</source>
          <target state="translated">MATLAB&amp;reg;과 NumPy / SciPy는 공통점이 많습니다. 그러나 많은 차이점이 있습니다. NumPy와 SciPy는 MATLAB&amp;reg; 클론이 아닌 Python을 사용하여 가장 자연스러운 방식으로 수치 및 과학 컴퓨팅을 수행하기 위해 만들어졌습니다. 이 페이지는 주로 숙련 된 MATLAB&amp;reg; 사용자가 숙련 된 NumPy 및 SciPy 사용자가되도록 돕기위한 목적으로 차이점에 대한 지혜를 모으는 곳입니다.</target>
        </trans-unit>
        <trans-unit id="4949e46f6b446cc2d4c1cff7ce5d91bf57727683" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and SimuLink&amp;reg; are registered trademarks of The MathWorks, Inc.</source>
          <target state="translated">MATLAB&amp;reg; 및 SimuLink&amp;reg;는 The MathWorks, Inc.의 등록 상표입니다.</target>
        </trans-unit>
        <trans-unit id="348e38df00b7a1cc73c6aa94f3dd10f19504f95a" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; and SimuLink&amp;reg; are registered trademarks of The MathWorks.</source>
          <target state="translated">MATLAB&amp;reg; 및 SimuLink&amp;reg;는 The MathWorks의 등록 상표입니다.</target>
        </trans-unit>
        <trans-unit id="23e174a57119e5a3f04b46115861ffc425aa73cd" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg; uses 1 (one) based indexing. The initial element of a sequence is found using a(1). &lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;See note INDEXING&lt;/a&gt;</source>
          <target state="translated">MATLAB&amp;reg;은 1 (일) 기반 인덱싱을 사용합니다. 시퀀스의 초기 요소는 a (1)을 사용하여 찾습니다. &lt;a href=&quot;#numpy-for-matlab-users-notes&quot;&gt;INDEXING 참고 참조&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="37a37fef1923ff7adb20853a92ca72292154b746" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;reg;&amp;rsquo;s scripting language was created for doing linear algebra. The syntax for basic matrix operations is nice and clean, but the API for adding GUIs and making full-fledged applications is more or less an afterthought.</source>
          <target state="translated">MATLAB&amp;reg;의 스크립팅 언어는 선형 대수를 수행하기 위해 만들어졌습니다. 기본 매트릭스 작업의 구문은 훌륭하고 깔끔하지만 GUI를 추가하고 본격적인 애플리케이션을 만들기위한 API는 다소 사후 고려 사항입니다.</target>
        </trans-unit>
        <trans-unit id="234b442375293b94744d2c885f1d43fdb8320c37" translate="yes" xml:space="preserve">
          <source>MATLAB&amp;rsquo;s scripting language was created for linear algebra so the syntax for some array manipulations is more compact than NumPy&amp;rsquo;s. On the other hand, the API for adding GUIs and creating full-fledged applications is more or less an afterthought.</source>
          <target state="translated">MATLAB의 스크립팅 언어는 선형 대수를 위해 만들어 졌으므로 일부 배열 조작에 대한 구문은 NumPy보다 더 간결합니다. 반면에 GUI를 추가하고 본격적인 애플리케이션을 생성하기위한 API는 다소 사후 고려 사항입니다.</target>
        </trans-unit>
        <trans-unit id="33379c640ef1bcb7b4dbc3ceb61d0f9854342e44" translate="yes" xml:space="preserve">
          <source>MKL</source>
          <target state="translated">MKL</target>
        </trans-unit>
        <trans-unit id="664ffa3bb754768f0d60ca47af28fa5f412d2bcd" translate="yes" xml:space="preserve">
          <source>MSB integer 1</source>
          <target state="translated">MSB 정수 1</target>
        </trans-unit>
        <trans-unit id="a80ef4b2a5180584bd6aa3ad3c6bf4d8c37965ae" translate="yes" xml:space="preserve">
          <source>MSB integer 2</source>
          <target state="translated">MSB 정수 2</target>
        </trans-unit>
        <trans-unit id="e6d7ea525d9c1cb77d6dada4577419a88b5aaac1" translate="yes" xml:space="preserve">
          <source>MT19937</source>
          <target state="translated">MT19937</target>
        </trans-unit>
        <trans-unit id="6717e938ed840001469fd51dfb2c139d0adfb7ae" translate="yes" xml:space="preserve">
          <source>MT19937 (class in numpy.random)</source>
          <target state="translated">MT19937 (numpy.random의 클래스)</target>
        </trans-unit>
        <trans-unit id="88d75e50800aeca584cabd974a5a06de32fe6777" translate="yes" xml:space="preserve">
          <source>MT19937 - The standard Python BitGenerator. Adds a &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt;&lt;code&gt;MT19937.jumped&lt;/code&gt;&lt;/a&gt; function that returns a new generator with state as-if</source>
          <target state="translated">MT19937-표준 Python BitGenerator. as-if 상태로 새 생성기를 반환 하는 &lt;a href=&quot;generated/numpy.random.mt19937.jumped#numpy.random.MT19937.jumped&quot;&gt; &lt;code&gt;MT19937.jumped&lt;/code&gt; &lt;/a&gt; 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="7bce0d7ca3c21db35ede8db2f12fac05579372a1" translate="yes" xml:space="preserve">
          <source>MT19937 - The standard Python BitGenerator. Adds a &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt;&lt;code&gt;jumped&lt;/code&gt;&lt;/a&gt; function that returns a new generator with state as-if</source>
          <target state="translated">MT19937-표준 Python BitGenerator. 상태를 그대로 사용하여 새 생성기를 반환 하는 &lt;a href=&quot;generated/numpy.random.mt19937.mt19937.jumped#numpy.random.mt19937.MT19937.jumped&quot;&gt; &lt;code&gt;jumped&lt;/code&gt; &lt;/a&gt; 함수를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="f07c8771fb3a7c7f33effbe38f0f59fb2b7a1664" translate="yes" xml:space="preserve">
          <source>MT19937.cffi</source>
          <target state="translated">MT19937.cffi</target>
        </trans-unit>
        <trans-unit id="4b48a5628ec9fca0df3fd9eaa04078cf1112d33c" translate="yes" xml:space="preserve">
          <source>MT19937.ctypes</source>
          <target state="translated">MT19937.ctypes</target>
        </trans-unit>
        <trans-unit id="d3960fe8caf716caa3faa711048f8eaf2c190c8f" translate="yes" xml:space="preserve">
          <source>MT19937.jumped()</source>
          <target state="translated">MT19937.jumped()</target>
        </trans-unit>
        <trans-unit id="70c54bc2b37814767b0b16267d4e49e0eaa1c1c3" translate="yes" xml:space="preserve">
          <source>MT19937.state</source>
          <target state="translated">MT19937.state</target>
        </trans-unit>
        <trans-unit id="0740034935988e0ce2668a5cf091a9adb98836bf" translate="yes" xml:space="preserve">
          <source>MachAr (class in numpy)</source>
          <target state="translated">MachAr (numpy의 클래스)</target>
        </trans-unit>
        <trans-unit id="b222baa318eb3fe2118a721645104a17a2e12508" translate="yes" xml:space="preserve">
          <source>Machine epsilon varies from machine to machine and between data types but Python floats on most platforms have a machine epsilon equal to 2.2204460492503131e-16. You can use &amp;lsquo;np.finfo(float).eps&amp;rsquo; to print out the machine epsilon for floats.</source>
          <target state="translated">머신 엡실론은 머신마다 그리고 데이터 유형에 따라 다르지만 대부분의 플랫폼에서 파이썬 플로트의 머신 엡실론은 2.2204460492503131e-16과 같습니다. 'np.finfo (float) .eps'를 사용하여 수레를위한 기계 엡실론을 인쇄 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9bdb316446a309b3484ba517636f47e09d947903" translate="yes" xml:space="preserve">
          <source>Machine limits for floating point types.</source>
          <target state="translated">부동 소수점 유형의 기계 한계.</target>
        </trans-unit>
        <trans-unit id="73e3d143745510a6549d96b020546b5898bd3c32" translate="yes" xml:space="preserve">
          <source>Machine limits for integer types.</source>
          <target state="translated">정수 유형의 기계 한계.</target>
        </trans-unit>
        <trans-unit id="368e3c884a3e6998248ff9097641dc2397f91307" translate="yes" xml:space="preserve">
          <source>Macro form of &lt;a href=&quot;#c.PyArray_Empty&quot;&gt;&lt;code&gt;PyArray_Empty&lt;/code&gt;&lt;/a&gt; which takes a type-number, &lt;em&gt;typenum&lt;/em&gt;, instead of a data-type object.</source>
          <target state="translated">매크로 형태 &lt;a href=&quot;#c.PyArray_Empty&quot;&gt; &lt;code&gt;PyArray_Empty&lt;/code&gt; &lt;/a&gt; 형식 번호, 소요 &lt;em&gt;typenum를&lt;/em&gt; 대신 데이터 타입 오브젝트.</target>
        </trans-unit>
        <trans-unit id="d915b8d6481f66730d8c850695157c13eec17e68" translate="yes" xml:space="preserve">
          <source>Macro form of &lt;a href=&quot;#c.PyArray_Zeros&quot;&gt;&lt;code&gt;PyArray_Zeros&lt;/code&gt;&lt;/a&gt; which takes a type-number instead of a data-type object.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_Zeros&quot;&gt; &lt;code&gt;PyArray_Zeros&lt;/code&gt; 의&lt;/a&gt; 매크로 형식 , 데이터 형식 개체 대신 형식 번호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="899bd694d29ace1be956ab35177075021977560b" translate="yes" xml:space="preserve">
          <source>Macros</source>
          <target state="translated">Macros</target>
        </trans-unit>
        <trans-unit id="8bebd0ebb56dc9f842a18e7b970fa8970cc84b64" translate="yes" xml:space="preserve">
          <source>Macros to allocate, free, and reallocate dimension and strides memory.</source>
          <target state="translated">차원을 할당, 해제 및 재 할당하는 매크로 및 메모리를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="992eddad2fa60737c0e7d9f0d9c8fd77cb0a2291" translate="yes" xml:space="preserve">
          <source>Macros to allocate, free, and reallocate memory. These macros are used internally to create arrays.</source>
          <target state="translated">메모리를 할당, 해제 및 재 할당하는 매크로 이 매크로는 내부적으로 배열을 만드는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="e8ab07caca0e626b10ef9247265ea63e24ca5cd9" translate="yes" xml:space="preserve">
          <source>Madvise Hugepage on Linux</source>
          <target state="translated">Linux의 Madvise Hugepage</target>
        </trans-unit>
        <trans-unit id="a5772095bad3f5f510b46aeea40178c90cb9d2f9" translate="yes" xml:space="preserve">
          <source>Mailing lists</source>
          <target state="translated">메일 링리스트</target>
        </trans-unit>
        <trans-unit id="41c3032490e05b7582198a7d382a11e14cafbdbb" translate="yes" xml:space="preserve">
          <source>Main difference between &lt;a href=&quot;#numpy.linalg.eigvals&quot;&gt;&lt;code&gt;eigvals&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.linalg.eig#numpy.linalg.eig&quot;&gt;&lt;code&gt;eig&lt;/code&gt;&lt;/a&gt;: the eigenvectors aren&amp;rsquo;t returned.</source>
          <target state="translated">&lt;a href=&quot;#numpy.linalg.eigvals&quot;&gt; &lt;code&gt;eigvals&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;numpy.linalg.eig#numpy.linalg.eig&quot;&gt; &lt;code&gt;eig&lt;/code&gt; 의&lt;/a&gt; 주요 차이점 : 고유 벡터는 반환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="17f0481e62f92478758daba6f45708b9902f91ce" translate="yes" xml:space="preserve">
          <source>Main difference from eigh: the eigenvectors are not computed.</source>
          <target state="translated">eigh와의 주요 차이점 : 고유 벡터는 계산되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="589abefef4e6719e397197cb478d2737f78ba6e4" translate="yes" xml:space="preserve">
          <source>Mainly for backwards compatibility to the Numeric C-API and for simple casts to non-flexible types. Return a new array object with the elements of &lt;em&gt;arr&lt;/em&gt; cast to the data-type &lt;em&gt;typenum&lt;/em&gt; which must be one of the enumerated types and not a flexible type.</source>
          <target state="translated">주로 Numeric C-API와의 하위 호환성 및 비 유연한 유형으로의 간단한 캐스트 용입니다. &lt;em&gt;arr&lt;/em&gt; 요소를 데이터 유형 &lt;em&gt;typenum으로&lt;/em&gt; 캐스트 한 새로운 배열 객체를 리턴합니다 .이 유형은 유연한 유형이 아닌 열거 된 유형 중 하나 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1131b2784624bc64cf6e16859feb39fadf3df101" translate="yes" xml:space="preserve">
          <source>Major additions to the documentation (e.g. new tutorials) should be proposed to the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt;.</source>
          <target state="translated">문서에 대한 주요 추가 사항 (예 : 새 자습서)은 &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;메일 링리스트에&lt;/a&gt; 제안되어야 합니다 .</target>
        </trans-unit>
        <trans-unit id="7f52e3105dfcc1e64146f131b70d4ac8a75b94c2" translate="yes" xml:space="preserve">
          <source>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,&amp;hellip;, xn.</source>
          <target state="translated">1 차원 좌표 배열 x1, x2,&amp;hellip;, xn이 주어지면 ND 그리드에서 ND 스칼라 / 벡터 필드의 벡터화 된 평가를 위해 ND 좌표 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a9929b5560d41717cc4e17b183714853c07910d6" translate="yes" xml:space="preserve">
          <source>Make a (&lt;em&gt;very&lt;/em&gt; coarse) grid for computing a Mandelbrot set:</source>
          <target state="translated">Mandelbrot 세트를 계산하기 위해 ( &lt;em&gt;매우&lt;/em&gt; 거친) 그리드를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="793de80198f3e7d633a262558162ceb1ded1e015" translate="yes" xml:space="preserve">
          <source>Make a new copy of the data-type object. If &lt;code&gt;False&lt;/code&gt;, the result may just be a reference to a built-in data-type object.</source>
          <target state="translated">데이터 유형 오브젝트의 새 사본을 작성하십시오. 경우 &lt;code&gt;False&lt;/code&gt; , 결과는 내장 데이터 타입 객체에 대한 참조 할 수있다.</target>
        </trans-unit>
        <trans-unit id="f6031db018f8e5da7675cd178a0678a4fc3fce08" translate="yes" xml:space="preserve">
          <source>Make decisions about specific technical issues, features, bugs and pull requests. They are the primary mechanism of guiding the code review process and merging pull requests.</source>
          <target state="translated">특정 기술 문제, 기능, 버그 및 풀 요청에 대한 결정을 내립니다. 코드 검토 프로세스를 안내하고 pull 요청을 병합하는 기본 메커니즘입니다.</target>
        </trans-unit>
        <trans-unit id="906c28c76e31c9a492cffb57b2a16103952d3b9a" translate="yes" xml:space="preserve">
          <source>Make decisions about strategic collaborations with other organizations or individuals.</source>
          <target state="translated">다른 조직 또는 개인과의 전략적 협업에 대한 결정을 내립니다.</target>
        </trans-unit>
        <trans-unit id="67dbbe53e453467605499ccb2835fb3c7302eb10" translate="yes" xml:space="preserve">
          <source>Make decisions about the Services that are run by The Project and manage those Services for the benefit of the Project and Community.</source>
          <target state="translated">The Project에서 운영하는 서비스에 대한 결정을 내리고 프로젝트 및 커뮤니티의 이익을 위해 해당 서비스를 관리합니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="755abc90a42cd2d1d43291c25413e31792f6e799" translate="yes" xml:space="preserve">
          <source>Make decisions about the overall scope, vision and direction of the project.</source>
          <target state="translated">프로젝트의 전체 범위, 비전 및 방향에 대한 결정을 내립니다.</target>
        </trans-unit>
        <trans-unit id="09da7faa6aced59b5226e61d16a4d476b63512be" translate="yes" xml:space="preserve">
          <source>Make decisions when regular community discussion doesn&amp;rsquo;t produce consensus on an issue in a reasonable time frame.</source>
          <target state="translated">정기적 인 커뮤니티 토론이 합리적인 시간 내에 문제에 대한 합의를 얻지 못할 때 결정을 내립니다.</target>
        </trans-unit>
        <trans-unit id="a831e4a92979555625b23c66a3d09803048cd6ec" translate="yes" xml:space="preserve">
          <source>Make function raise KnownFailureException exception if given condition is true.</source>
          <target state="translated">주어진 조건이 참이면 함수에서 KnownFailureException 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9a732c043a4153afa349bff5ecfd6f57666bdf5e" translate="yes" xml:space="preserve">
          <source>Make function raise SkipTest exception if a given condition is true.</source>
          <target state="translated">주어진 조건이 참이면 함수가 SkipTest 예외를 발생시킵니다.</target>
        </trans-unit>
        <trans-unit id="9e9f63f3d661cfbb8ace1436845ed7a6bc72848c" translate="yes" xml:space="preserve">
          <source>Make some changes. When you feel that you&amp;rsquo;ve made a complete, working set of related changes, move on to the next steps.</source>
          <target state="translated">약간 변경하십시오. 관련 변경 사항의 완전하고 작업 세트를 작성했다고 생각되면 다음 단계로 이동하십시오.</target>
        </trans-unit>
        <trans-unit id="6858d151467d19f1cb2875295def91538137e0f5" translate="yes" xml:space="preserve">
          <source>Make sure a copy is made of &lt;em&gt;op&lt;/em&gt;. If this flag is not present, data is not copied if it can be avoided.</source>
          <target state="translated">사본이 &lt;em&gt;op&lt;/em&gt; 로 만들어 졌는지 확인하십시오 . 이 플래그가 없으면 피할 수 있으면 데이터가 복사되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="760b0011b94d0a23e85b76c7cd06e7ecba5cf0b4" translate="yes" xml:space="preserve">
          <source>Make sure all automated CI tests pass before merging a PR, and that the &lt;a href=&quot;index#building-docs&quot;&gt;documentation builds&lt;/a&gt; without any errors.</source>
          <target state="translated">PR을 병합하기 전에 모든 자동화 된 CI 테스트를 통과하고 &lt;a href=&quot;index#building-docs&quot;&gt;문서&lt;/a&gt; 가 오류없이 빌드 되는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="9640026add93a577095656e1a0ba0914c72a1267" translate="yes" xml:space="preserve">
          <source>Make sure current branch builds a package correctly</source>
          <target state="translated">현재 분기가 패키지를 올바르게 빌드하는지 확인</target>
        </trans-unit>
        <trans-unit id="fa253a65eff13dcd45a6381940ea3d563851c87f" translate="yes" xml:space="preserve">
          <source>Make sure that &lt;code&gt;actual_type&lt;/code&gt; is compatible with &lt;code&gt;desired_type&lt;/code&gt;. For example, this allows character and byte types, or int and long types, to match. This is now equivalent to &lt;code&gt;PyArray_EquivTypenums()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;actual_type&lt;/code&gt; 이 &lt;code&gt;desired_type&lt;/code&gt; 과 호환 되는지 확인하십시오 . 예를 들어, 문자 및 바이트 유형 또는 int 및 long 유형을 일치시킬 수 있습니다. 이제 &lt;code&gt;PyArray_EquivTypenums()&lt;/code&gt; 와 같습니다. .</target>
        </trans-unit>
        <trans-unit id="d395ece8635aaa0e36d9dc4023c7fb1cb5ed9a09" translate="yes" xml:space="preserve">
          <source>Make sure that the release tag has been pushed.</source>
          <target state="translated">릴리스 태그를 눌렀는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="9b2a551f742bd2a7cf675451084c5fbd575db246" translate="yes" xml:space="preserve">
          <source>Make sure the result is a base-class ndarray. By default, if &lt;em&gt;op&lt;/em&gt; is an instance of a subclass of ndarray, an instance of that same subclass is returned. If this flag is set, an ndarray object will be returned instead.</source>
          <target state="translated">결과가 기본 클래스 ndarray인지 확인하십시오. 기본적으로 &lt;em&gt;op&lt;/em&gt; 가 ndarray의 서브 클래스 인스턴스 인 경우 동일한 서브 클래스의 인스턴스가 리턴됩니다. 이 플래그를 설정하면 대신 ndarray 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a66f646163bc787161e9da29b0a054fbc6624c6d" translate="yes" xml:space="preserve">
          <source>Make sure the resulting array is a copy of the original.</source>
          <target state="translated">결과 배열이 원본의 사본인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8fc11ce7d79cdf71bcb67e124e7fa1c1b139a0a5" translate="yes" xml:space="preserve">
          <source>Make sure the resulting object is an actual ndarray and not a sub- class.</source>
          <target state="translated">결과 개체가 하위 클래스가 아닌 실제 ndarray인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="39d90f5a018cb286b90a3644f5e4eda749a94075" translate="yes" xml:space="preserve">
          <source>Make sure the resulting object is an actual ndarray, and not a sub-class.</source>
          <target state="translated">결과 객체가 하위 클래스가 아닌 실제 ndarray인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="dc2a4442b24ed7738f50875398d3eedbc2d1aafc" translate="yes" xml:space="preserve">
          <source>Make sure the returned array can be written to.</source>
          <target state="translated">반환 된 배열을 쓸 수 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="f2cb8de0de4ac461ccef8b3f6699d7773164c9a7" translate="yes" xml:space="preserve">
          <source>Make sure the returned array has a data-type descriptor that is in machine byte-order, over-riding any specification in the &lt;em&gt;dtype&lt;/em&gt; argument. Normally, the byte-order requirement is determined by the &lt;em&gt;dtype&lt;/em&gt; argument. If this flag is set and the dtype argument does not indicate a machine byte-order descriptor (or is NULL and the object is already an array with a data-type descriptor that is not in machine byte- order), then a new data-type descriptor is created and used with its byte-order field set to native.</source>
          <target state="translated">반환 된 배열에 &lt;em&gt;dtype&lt;/em&gt; 인수의 사양을 &lt;em&gt;재정 의하여&lt;/em&gt; 컴퓨터 바이트 순서의 데이터 형식 설명자가 있는지 확인하십시오 . 일반적으로 바이트 순서 요구 사항은 &lt;em&gt;dtype&lt;/em&gt; 인수에 의해 결정됩니다 . 이 플래그가 설정되고 dtype 인수가 기계 바이트 순서 디스크립터를 나타내지 않거나 (또는 ​​NULL이고 오브젝트가 이미 기계 바이트 순서가 아닌 데이터 유형 디스크립터가있는 배열 인 경우) 새 데이터 type descriptor는 바이트 순서 필드를 native로 설정하여 생성 및 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="cc7b28e40eab8c8cfe24c22e8e90c3868c988c89" translate="yes" xml:space="preserve">
          <source>Make sure the returned array has strides that are multiples of the element size.</source>
          <target state="translated">반환 된 배열에 요소 크기의 배수 인 보폭이 있는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="ff416e45483051472f44c5631669234da57230ad" translate="yes" xml:space="preserve">
          <source>Make sure the returned array is C-style contiguous</source>
          <target state="translated">반환 된 배열이 C 스타일 연속인지 확인하십시오</target>
        </trans-unit>
        <trans-unit id="76ac22505382624e9142f85a5dd50a913b6940a1" translate="yes" xml:space="preserve">
          <source>Make sure the returned array is Fortran-style contiguous.</source>
          <target state="translated">반환 된 배열이 포트란 스타일의 연속인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3fb7cfe1b008b6ba165b89e7102a19142fa050d" translate="yes" xml:space="preserve">
          <source>Make sure the returned array is aligned on proper boundaries for its data type. An aligned array has the data pointer and every strides factor as a multiple of the alignment factor for the data-type- descriptor.</source>
          <target state="translated">반환 된 배열이 해당 데이터 형식에 적합한 경계에 정렬되어 있는지 확인하십시오. 정렬 된 배열에는 데이터 포인터와 모든 보폭 요소가 데이터 유형 설명자에 대한 정렬 요소의 배수로 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="69b378647f1ea83317efaa51bb3b654effbedd36" translate="yes" xml:space="preserve">
          <source>Make sure to test your builds. To ensure everything stays in shape, see if all tests pass:</source>
          <target state="translated">빌드를 테스트해야합니다. 모든 것이 제대로 유지되도록하려면 모든 테스트를 통과했는지 확인하세요.</target>
        </trans-unit>
        <trans-unit id="62da4918e5f62625894d937e2e3a7fe6b005b2b9" translate="yes" xml:space="preserve">
          <source>Make the local copy</source>
          <target state="translated">로컬 사본 만들기</target>
        </trans-unit>
        <trans-unit id="c48a45c41752973d88a462b08b11d9bc755ea64e" translate="yes" xml:space="preserve">
          <source>Make the release</source>
          <target state="translated">릴리스 만들기</target>
        </trans-unit>
        <trans-unit id="e191446d7cb1daa2fc91f55d604a91404a3bfcc4" translate="yes" xml:space="preserve">
          <source>Make the window functions exactly symmetric</source>
          <target state="translated">창 기능을 정확히 대칭으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="8243dc037100f878288a764547cbc0e678b232cd" translate="yes" xml:space="preserve">
          <source>Makes a copy of the given iterator. This function is provided primarily to enable multi-threaded iteration of the data.</source>
          <target state="translated">주어진 반복자의 사본을 만듭니다. 이 기능은 주로 데이터의 다중 스레드 반복을 가능하게하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="024d1b814e91d1479a513e542438675be42871e1" translate="yes" xml:space="preserve">
          <source>Making a new feature branch</source>
          <target state="translated">새로운 기능 브랜치 만들기</target>
        </trans-unit>
        <trans-unit id="9994f58a6845d6543e990f0db03b5691b328bb3d" translate="yes" xml:space="preserve">
          <source>Making changes to the view changes the underlying array</source>
          <target state="translated">뷰를 변경하면 기본 배열이 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="7a8542defa1f2f46558700bed760e59b4ae9473a" translate="yes" xml:space="preserve">
          <source>Making proper sets</source>
          <target state="translated">적절한 세트 만들기</target>
        </trans-unit>
        <trans-unit id="1f882dac1dece4867b9fd6e24e50469f91a6a8c5" translate="yes" xml:space="preserve">
          <source>Making your own copy (fork) of NumPy</source>
          <target state="translated">NumPy의 복사본 (포크) 만들기</target>
        </trans-unit>
        <trans-unit id="f072320f52e480cd4cee7848612d896de0342201" translate="yes" xml:space="preserve">
          <source>Manipulating a MaskedArray</source>
          <target state="translated">마스크 배열 조작</target>
        </trans-unit>
        <trans-unit id="b69b809ef0c7c1f9959ac303f434b38d1178af50" translate="yes" xml:space="preserve">
          <source>Manipulating and Displaying Structured Datatypes</source>
          <target state="translated">구조화 된 데이터 유형 조작 및 표시</target>
        </trans-unit>
        <trans-unit id="37cb8d5fc1a8a147eb37587df7287a57d2924596" translate="yes" xml:space="preserve">
          <source>Manipulations</source>
          <target state="translated">Manipulations</target>
        </trans-unit>
        <trans-unit id="8d9fbdf134eaac3b76a99337507116859ebbef42" translate="yes" xml:space="preserve">
          <source>Manual pages online</source>
          <target state="translated">온라인 매뉴얼 페이지</target>
        </trans-unit>
        <trans-unit id="186df05b293e739802129eb3df4baaf8fda61676" translate="yes" xml:space="preserve">
          <source>Manually adding two vectors, using broadcasting:</source>
          <target state="translated">방송을 사용하여 두 개의 벡터를 수동으로 추가 :</target>
        </trans-unit>
        <trans-unit id="24b85b2e484e6f827cf479e7935e6715b5367776" translate="yes" xml:space="preserve">
          <source>Many changes to array printing, disableable with the new &amp;ldquo;legacy&amp;rdquo; printing mode</source>
          <target state="translated">새로운 &quot;레거시&quot;인쇄 모드로 비활성화 할 수있는 어레이 인쇄에 대한 많은 변경 사항</target>
        </trans-unit>
        <trans-unit id="30ff36cb17e64d96a4194df0b29c86b8a889d3aa" translate="yes" xml:space="preserve">
          <source>Many of the RandomState methods above are exported as functions in &lt;a href=&quot;index#module-numpy.random&quot;&gt;&lt;code&gt;numpy.random&lt;/code&gt;&lt;/a&gt; This usage is discouraged, as it is implemented via a global &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance which is not advised on two counts:</source>
          <target state="translated">위의 함수로 수출하는 RandomState 방법의 많은 &lt;a href=&quot;index#module-numpy.random&quot;&gt; &lt;code&gt;numpy.random&lt;/code&gt; &lt;/a&gt; 가 글로벌을 통해 구현 될 때이 사용은 권장되지 &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 의&lt;/a&gt; 두 카운트에서 권고하지 않습니다 예 :</target>
        </trans-unit>
        <trans-unit id="7ff15d6fb98077a9b63faafb800abb9fe78fcf46" translate="yes" xml:space="preserve">
          <source>Many of these methods take an argument named &lt;em&gt;axis&lt;/em&gt;. In such cases,</source>
          <target state="translated">이러한 메소드 중 다수는 &lt;em&gt;axis&lt;/em&gt; 라는 인수를 사용 합니다. 그런 경우는,</target>
        </trans-unit>
        <trans-unit id="baf4a8743470327c4600513b810018ef2c55fcf7" translate="yes" xml:space="preserve">
          <source>Many operations can take place along one of these axes. For example, we can sum each row of an array, in which case we operate along columns, or axis 1:</source>
          <target state="translated">이러한 축 중 하나를 따라 많은 작업이 수행 될 수 있습니다. 예를 들어 배열의 각 행을 합산 할 수 있습니다.이 경우 열 또는 축 1을 따라 작업합니다.</target>
        </trans-unit>
        <trans-unit id="9ede0036fbda2644b0badedec4f5663550b9b1ac" translate="yes" xml:space="preserve">
          <source>Many other distributions are also supported.</source>
          <target state="translated">다른 많은 배포판도 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="bf803fbf10619fd778459bc01e332b6ee0d8b941" translate="yes" xml:space="preserve">
          <source>Many people like to say that Python is a fantastic glue language. Hopefully, this Chapter will convince you that this is true. The first adopters of Python for science were typically people who used it to glue together large application codes running on super-computers. Not only was it much nicer to code in Python than in a shell script or Perl, in addition, the ability to easily extend Python made it relatively easy to create new classes and types specifically adapted to the problems being solved. From the interactions of these early contributors, Numeric emerged as an array-like object that could be used to pass data between these applications.</source>
          <target state="translated">많은 사람들이 파이썬이 환상적인 접착제 언어라고 말하고 싶어합니다. 바라건대,이 장이 이것이 사실임을 확신시켜 줄 것입니다. 과학을 위해 Python을 처음 채택한 사람은 일반적으로 슈퍼 컴퓨터에서 실행되는 대규모 애플리케이션 코드를 연결하는 데 Python을 사용한 사람들이었습니다. 쉘 스크립트 나 Perl에서보다 Python으로 코딩하는 것이 훨씬 더 좋았을뿐만 아니라, Python을 쉽게 확장 할 수있는 기능으로 인해 해결되는 문제에 특별히 적합한 새로운 클래스와 유형을 비교적 쉽게 만들 수있었습니다. 이러한 초기 기여자들의 상호 작용을 통해 Numeric은 이러한 응용 프로그램간에 데이터를 전달하는 데 사용할 수있는 배열과 같은 객체로 등장했습니다.</target>
        </trans-unit>
        <trans-unit id="5b80222964fcc4594c09147e0b7ae65980724b47" translate="yes" xml:space="preserve">
          <source>Many unary operations, such as computing the sum of all the elements in the array, are implemented as methods of the &lt;code&gt;ndarray&lt;/code&gt; class.</source>
          <target state="translated">배열에있는 모든 요소의 합계를 계산하는 것과 같은 많은 단항 연산은 &lt;code&gt;ndarray&lt;/code&gt; 클래스의 메서드로 구현됩니다 .</target>
        </trans-unit>
        <trans-unit id="a73bcf30ee540d20aa6caf9854834e68102f531d" translate="yes" xml:space="preserve">
          <source>Manylinux1 wheels use the gcc provided on the Manylinux docker images.</source>
          <target state="translated">Manylinux1 휠은 Manylinux docker 이미지에 제공된 gcc를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e0c534a05742cb00dc61fd7a287ca60edf0922d2" translate="yes" xml:space="preserve">
          <source>Marketing</source>
          <target state="translated">Marketing</target>
        </trans-unit>
        <trans-unit id="b6a9029c64b412740bceba8fc1ba7afc803f28fd" translate="yes" xml:space="preserve">
          <source>Marten van Kerkwijk</source>
          <target state="translated">Marten van Kerkwijk</target>
        </trans-unit>
        <trans-unit id="60df02e5f0d607ed31f13075db7cca76392b09be" translate="yes" xml:space="preserve">
          <source>Marten van Kerkwijk (2017-2019)</source>
          <target state="translated">Marten van Kerkwijk (2017-2019)</target>
        </trans-unit>
        <trans-unit id="8e22a4dd259d1679b0a51f9039d6bfdead73e93b" translate="yes" xml:space="preserve">
          <source>Mask an array inside a given interval.</source>
          <target state="translated">주어진 간격 내에서 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="da9a1c569bf731b67119f643ede378ad4e3f1519" translate="yes" xml:space="preserve">
          <source>Mask an array outside a given interval.</source>
          <target state="translated">지정된 간격을 벗어난 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="6cfe071d1d905293fc1a86d3d41da5c8b38fd4a8" translate="yes" xml:space="preserve">
          <source>Mask an array where &lt;code&gt;not&lt;/code&gt; equal to a given value.</source>
          <target state="translated">주어진 값과 같지 &lt;code&gt;not&lt;/code&gt; 배열을 마스크합니다 .</target>
        </trans-unit>
        <trans-unit id="bfd71c8af0182463deeb8b929bb8db010e999aa1" translate="yes" xml:space="preserve">
          <source>Mask an array where a condition is met.</source>
          <target state="translated">조건이 충족되는 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="745c1555706e0f77e6ffe2c2813a3fb36374ff35" translate="yes" xml:space="preserve">
          <source>Mask an array where equal to a given value.</source>
          <target state="translated">주어진 값과 동일한 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="f9729990c0e40052af76c9e13494e2abd95504a0" translate="yes" xml:space="preserve">
          <source>Mask an array where greater than a given value.</source>
          <target state="translated">주어진 값보다 큰 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="ec4efca3f5e96d9a3bd62aaca7a5391e583c37d0" translate="yes" xml:space="preserve">
          <source>Mask an array where greater than or equal to a given value.</source>
          <target state="translated">주어진 값보다 크거나 같은 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="c0c78b88c4cc26e562d4c01312db539d600c13b8" translate="yes" xml:space="preserve">
          <source>Mask an array where invalid values occur (NaNs or infs).</source>
          <target state="translated">유효하지 않은 값이 발생하는 배열을 마스킹하십시오 (NaN 또는 infs).</target>
        </trans-unit>
        <trans-unit id="bafddbcc3a701d825f4b8c81b4a6586eda8f72f6" translate="yes" xml:space="preserve">
          <source>Mask an array where less than a given value.</source>
          <target state="translated">주어진 값보다 작은 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="cf298275c5da246fc15e63b817a590139fdfaf20" translate="yes" xml:space="preserve">
          <source>Mask an array where less than or equal to a given value.</source>
          <target state="translated">주어진 값보다 작거나 같은 배열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="f25a93425a69cec34a64e945a78ff3354d106c87" translate="yes" xml:space="preserve">
          <source>Mask array &lt;code&gt;b&lt;/code&gt; conditional on &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">어레이 마스크 &lt;code&gt;b&lt;/code&gt; 조건부 &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6351290c3e2bd1325051b50aa84be0096715800" translate="yes" xml:space="preserve">
          <source>Mask cols of a 2D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2D 배열의 마스크 열.</target>
        </trans-unit>
        <trans-unit id="5989c0ba273f4fa26213980d7a2122d0b5463f7a" translate="yes" xml:space="preserve">
          <source>Mask columns of a 2D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2D 배열의 열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="888fa953c6e1c3b95fb32020739a8fb7290b6a16" translate="yes" xml:space="preserve">
          <source>Mask inside a given interval.</source>
          <target state="translated">주어진 간격 내에서 마스크.</target>
        </trans-unit>
        <trans-unit id="8875894bb1277ca00fff30f310af81531740e9e5" translate="yes" xml:space="preserve">
          <source>Mask invalid values (NaNs or infs).</source>
          <target state="translated">유효하지 않은 값 (NaN 또는 infs)을 마스크하십시오.</target>
        </trans-unit>
        <trans-unit id="3c5cc469c703297ad73e0cbd2085f332b3c12da4" translate="yes" xml:space="preserve">
          <source>Mask outside a given interval.</source>
          <target state="translated">지정된 간격을 벗어난 마스크.</target>
        </trans-unit>
        <trans-unit id="00af5e48341996dadc0cdb5fdf0842273fe5b864" translate="yes" xml:space="preserve">
          <source>Mask rows and/or columns of a 2D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2D 배열의 행 및 / 또는 열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="036b308dd6f036875453ed63e39c90f458b31d97" translate="yes" xml:space="preserve">
          <source>Mask rows and/or columns of a 2D array.</source>
          <target state="translated">2D 배열의 행 및 / 또는 열을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="fa07a97e90fa3a048da5dc5176f7f8f08808a1e7" translate="yes" xml:space="preserve">
          <source>Mask rows of a 2D array that contain masked values.</source>
          <target state="translated">마스크 된 값을 포함하는 2D 배열의 행을 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="cdcf6bd79fa7623a0f0d4537e494029fd7cec8d6" translate="yes" xml:space="preserve">
          <source>Mask the array &lt;code&gt;x&lt;/code&gt; where the data are exactly equal to value.</source>
          <target state="translated">데이터가 정확히 값과 동일한 배열 &lt;code&gt;x&lt;/code&gt; 를 마스크하십시오 .</target>
        </trans-unit>
        <trans-unit id="6d4dbf0aaf4fae78661a0147024893bc953fbf99" translate="yes" xml:space="preserve">
          <source>Mask using floating point equality.</source>
          <target state="translated">부동 소수점 동등성을 사용하여 마스크합니다.</target>
        </trans-unit>
        <trans-unit id="1a7c6742714332311a709c878556f33860c1ca12" translate="yes" xml:space="preserve">
          <source>Mask where &lt;code&gt;not&lt;/code&gt; equal to a given value.</source>
          <target state="translated">여기서 마스크 &lt;code&gt;not&lt;/code&gt; 소정 값과 동일.</target>
        </trans-unit>
        <trans-unit id="6a25717d456c673a4a868df938fb9bd46105d77b" translate="yes" xml:space="preserve">
          <source>Mask where a condition is met.</source>
          <target state="translated">조건이 충족되는 마스크.</target>
        </trans-unit>
        <trans-unit id="2e77dd6d757e07506b660bea8d79d9b375bb9e96" translate="yes" xml:space="preserve">
          <source>Mask where equal to a given value (integers).</source>
          <target state="translated">주어진 값 (정수)과 같은 곳에 마스크.</target>
        </trans-unit>
        <trans-unit id="819bdc07b0b19e7e594b197983e674371983eb93" translate="yes" xml:space="preserve">
          <source>Mask where equal to a given value.</source>
          <target state="translated">주어진 값과 동일한 곳에서 마스크.</target>
        </trans-unit>
        <trans-unit id="99e92ea0dacc268463873d122e4916bac3c6166d" translate="yes" xml:space="preserve">
          <source>Mask where greater than a given value.</source>
          <target state="translated">주어진 값보다 큰 곳을 가리십시오.</target>
        </trans-unit>
        <trans-unit id="377f44d52c44c29b0aa5a55900c31b4b9e499dd4" translate="yes" xml:space="preserve">
          <source>Mask where greater than or equal to a given value.</source>
          <target state="translated">지정된 값 이상인 마스크.</target>
        </trans-unit>
        <trans-unit id="f0e79008b6bfb135c14c930dd9b5fa3a89ff7ec3" translate="yes" xml:space="preserve">
          <source>Mask where less than a given value.</source>
          <target state="translated">주어진 값보다 작은 곳에 마스크.</target>
        </trans-unit>
        <trans-unit id="c86db9f027cb5e25560c169de275edc638940064" translate="yes" xml:space="preserve">
          <source>Mask where less than or equal to a given value.</source>
          <target state="translated">주어진 값 이하의 마스크.</target>
        </trans-unit>
        <trans-unit id="0d15a34ef50017c16ffef8d56380f0190f6e4176" translate="yes" xml:space="preserve">
          <source>Mask whole rows and/or columns of a 2D array that contain masked values. The masking behavior is selected using the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">마스크 된 값을 포함하는 2D 배열의 전체 행 및 / 또는 열을 마스크합니다. 마스킹 동작은 &lt;code&gt;axis&lt;/code&gt; 매개 변수를 사용하여 선택 됩니다.</target>
        </trans-unit>
        <trans-unit id="fcd2fc9f9e2cbbcb1423bbce02ea7377a87d9394" translate="yes" xml:space="preserve">
          <source>Mask. Must be convertible to an array of booleans with the same shape as &lt;code&gt;data&lt;/code&gt;. True indicates a masked (i.e. invalid) data.</source>
          <target state="translated">마스크. &lt;code&gt;data&lt;/code&gt; 와 모양이 같은 부울 배열로 변환 할 수 있어야합니다 . True는 마스크 된 (즉, 유효하지 않은) 데이터를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="56d91486aefab83c4b7a8aafb6822eb7b0d14e2c" translate="yes" xml:space="preserve">
          <source>MaskType (in module numpy.ma)</source>
          <target state="translated">MaskType (numpy.ma 모듈)</target>
        </trans-unit>
        <trans-unit id="77690385e03cf5be1602ed7d25dbb1c74983e23a" translate="yes" xml:space="preserve">
          <source>Masked array interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 마스크 배열 해석 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2736171df63d3cbe517f0bae324f23b6232dfa60" translate="yes" xml:space="preserve">
          <source>Masked array operations</source>
          <target state="translated">마스크 배열 연산</target>
        </trans-unit>
        <trans-unit id="2d4d75f30e0b052c284673be22985a3e26fd2369" translate="yes" xml:space="preserve">
          <source>Masked arrays</source>
          <target state="translated">마스크 배열</target>
        </trans-unit>
        <trans-unit id="26652000ec64c331ba43c810f4acf18412b0f68b" translate="yes" xml:space="preserve">
          <source>Masked arrays (&lt;code&gt;numpy.ma&lt;/code&gt;)</source>
          <target state="translated">마스크 배열 ( &lt;code&gt;numpy.ma&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="078e11437b77503c6af41321e9f5a89af35fcaa3" translate="yes" xml:space="preserve">
          <source>Masked arrays (numpy.ma)</source>
          <target state="translated">마스크 배열 (numpy.ma)</target>
        </trans-unit>
        <trans-unit id="52d21a15b7bc961fe34264bd95fc89878c193c0a" translate="yes" xml:space="preserve">
          <source>Masked arrays &lt;a href=&quot;../reference/generated/numpy.ma.maskedarray.tofile#numpy.ma.MaskedArray.tofile&quot;&gt;&lt;code&gt;can't currently be saved&lt;/code&gt;&lt;/a&gt;, nor can other arbitrary array subclasses.</source>
          <target state="translated">마스킹 된 배열 &lt;a href=&quot;../reference/generated/numpy.ma.maskedarray.tofile#numpy.ma.MaskedArray.tofile&quot;&gt; &lt;code&gt;can't currently be saved&lt;/code&gt; &lt;/a&gt; 수 없으며 다른 임의의 배열 하위 클래스도 저장할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="7153e6f35343b699d95430ff8793f79f62547cd2" translate="yes" xml:space="preserve">
          <source>Masked arrays also support standard numpy ufuncs. The output is then a masked array. The result of a unary ufunc is masked wherever the input is masked. The result of a binary ufunc is masked wherever any of the input is masked. If the ufunc also returns the optional context output (a 3-element tuple containing the name of the ufunc, its arguments and its domain), the context is processed and entries of the output masked array are masked wherever the corresponding input fall outside the validity domain:</source>
          <target state="translated">마스크 배열은 표준 numpy ufunc도 지원합니다. 그러면 출력이 마스킹 된 배열입니다. 단항 ufunc의 결과는 입력이 마스킹 될 때마다 마스킹됩니다. 이진 ufunc의 결과는 입력이 마스킹 될 때마다 마스킹됩니다. ufunc가 선택적 컨텍스트 출력 (ufunc의 이름, 인수 및 도메인을 포함하는 3 요소 튜플)도 반환하는 경우 컨텍스트가 처리되고 출력 마스킹 된 배열의 항목이 해당 입력이 유효성을 벗어난 곳이면 마스킹됩니다 도메인:</target>
        </trans-unit>
        <trans-unit id="65927f39316e88f57788fd2eb5136f42b5cf0bdc" translate="yes" xml:space="preserve">
          <source>Masked arrays are also a good idea since the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module also comes with a specific implementation of most &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;NumPy universal functions (ufuncs)&lt;/a&gt;, which means that you can still apply fast vectorized functions and operations on masked data. The output is then a masked array. We&amp;rsquo;ll see some examples of how this works in practice below.</source>
          <target state="translated">&lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; 모듈에는 대부분의 &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;NumPy 범용 함수 (ufuncs)&lt;/a&gt; 의 특정 구현이 함께 제공 되기 때문에 마스킹 된 배열도 좋은 생각 입니다. 즉 , 마스킹 된 데이터에 빠른 벡터화 된 함수와 연산을 계속 적용 할 수 있습니다. 그러면 출력은 마스크 된 배열입니다. 아래에서 이것이 실제로 어떻게 작동하는지에 대한 몇 가지 예를 살펴 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="2feff57b9d5e5a78c57621737acc9551d5fb918f" translate="yes" xml:space="preserve">
          <source>Masked arrays are arrays that may have missing or invalid entries. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a nearly work-alike replacement for numpy that supports data arrays with masks.</source>
          <target state="translated">마스크 배열은 항목이 없거나 유효하지 않은 배열입니다. &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈은 NumPy와의 거의 작업 모두 대체를 제공 마스크가 지원하는 데이터 배열이.</target>
        </trans-unit>
        <trans-unit id="3f5b01b275571ce9babfb349e3e312bc47fa839e" translate="yes" xml:space="preserve">
          <source>Masked arrays are arrays that may have missing or invalid entries. The &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a nearly work-alike replacement for numpy that supports data arrays with masks.</source>
          <target state="translated">마스크 배열은 항목이 없거나 유효하지 않은 배열입니다. &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈은 NumPy와의 거의 작업 모두 대체를 제공 마스크가 지원하는 데이터 배열이.</target>
        </trans-unit>
        <trans-unit id="95c3a7b724956ad14eb8d4eaa01adbe13df7006e" translate="yes" xml:space="preserve">
          <source>Masked arrays are often used when operating on arrays containing missing or invalid entries.</source>
          <target state="translated">마스킹 된 배열은 누락되거나 유효하지 않은 항목이 포함 된 배열에서 작동 할 때 자주 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="0540687eb24d38593064d3dec8d6776ae8362128" translate="yes" xml:space="preserve">
          <source>Masked arrays arithmetics</source>
          <target state="translated">마스크 배열 산술</target>
        </trans-unit>
        <trans-unit id="1b98b3e1595ab0387c4f0bf412ece270fde73e27" translate="yes" xml:space="preserve">
          <source>Masked arrays containing objects with arrays</source>
          <target state="translated">배열이있는 객체를 포함하는 마스킹 된 배열</target>
        </trans-unit>
        <trans-unit id="9bb05590ea9fc4f5a59f3cc6510307a040a1ef71" translate="yes" xml:space="preserve">
          <source>Masked dot product of two arrays. Note that &lt;code&gt;out&lt;/code&gt; and &lt;code&gt;strict&lt;/code&gt; are located in different positions than in &lt;code&gt;ma.dot&lt;/code&gt;. In order to maintain compatibility with the functional version, it is recommended that the optional arguments be treated as keyword only. At some point that may be mandatory.</source>
          <target state="translated">두 배열의 마스킹 된 내적. 참고 &lt;code&gt;out&lt;/code&gt; 및 &lt;code&gt;strict&lt;/code&gt; 보다 다른 위치에 있습니다 &lt;code&gt;ma.dot&lt;/code&gt; . 기능 버전과의 호환성을 유지하려면 선택적 인수를 키워드로만 처리하는 것이 좋습니다. 어떤 시점에서 그것은 필수 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2a10f17f192630fac9e2659b01202ca989fcde7d" translate="yes" xml:space="preserve">
          <source>Masked elements are ignored.</source>
          <target state="translated">마스크 된 요소는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a1ab6894299ae6aae7ef94e3acf9c5526b0895b9" translate="yes" xml:space="preserve">
          <source>Masked elements are set to 0 internally.</source>
          <target state="translated">마스크 된 요소는 내부적으로 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="97b5ab568e51a37efa7e81ef1c6b7490d9852f4c" translate="yes" xml:space="preserve">
          <source>Masked elements are set to 1 internally for computation.</source>
          <target state="translated">마스크 된 요소는 계산을 위해 내부적으로 1로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f459802409051eaa7a4da3a38b8b3e649cb95c03" translate="yes" xml:space="preserve">
          <source>Masked entries are ignored, and result elements which are not finite will be masked.</source>
          <target state="translated">마스크 된 항목은 무시되며 유한하지 않은 결과 요소는 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="b67c6e592961bc4088100d1e724368d014dd740f" translate="yes" xml:space="preserve">
          <source>Masked entries are ignored.</source>
          <target state="translated">마스크 된 항목은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="a553f9a17153e944aa3ccf0663ddf7bdd834bdc5" translate="yes" xml:space="preserve">
          <source>Masked values are considered as False during computation.</source>
          <target state="translated">마스크 된 값은 계산 중에 False로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="6c8cae7fd974732de54350b0ecabf2b49f4bd07f" translate="yes" xml:space="preserve">
          <source>Masked values are not compared directly.</source>
          <target state="translated">마스크 된 값은 직접 비교되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8b7bd1ffbc4df578f27392c4f72e5f827148711a" translate="yes" xml:space="preserve">
          <source>Masked values are replaced by 0.</source>
          <target state="translated">마스크 된 값은 0으로 대체됩니다.</target>
        </trans-unit>
        <trans-unit id="594673afbc6460668c76a5b5a60900b4eb69ed4e" translate="yes" xml:space="preserve">
          <source>Masked values are set to 0 internally during the computation. However, their position is saved, and the result will be masked at the same locations.</source>
          <target state="translated">마스크 된 값은 계산 중에 내부적으로 0으로 설정됩니다. 그러나 위치가 저장되고 결과가 같은 위치에 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="c62cda838d0dd89db4f7db7a848bed90b8a35029" translate="yes" xml:space="preserve">
          <source>Masked values are set to 1 internally during the computation. However, their position is saved, and the result will be masked at the same locations.</source>
          <target state="translated">마스킹 된 값은 계산 중에 내부적으로 1로 설정됩니다. 그러나 위치가 저장되고 결과가 같은 위치에 숨겨집니다.</target>
        </trans-unit>
        <trans-unit id="0d54b7cdcf2aacde324dff6e5bfaee0441c90af7" translate="yes" xml:space="preserve">
          <source>Masked values in the input array result in rows of zeros.</source>
          <target state="translated">입력 배열의 마스크 된 값은 0의 행을 초래합니다.</target>
        </trans-unit>
        <trans-unit id="46f85aa5a353da87d3752c17130ba68a2f9115ff" translate="yes" xml:space="preserve">
          <source>Masked values of True exclude the corresponding element from any computation.</source>
          <target state="translated">마스크 된 True 값은 해당 요소를 계산에서 제외합니다.</target>
        </trans-unit>
        <trans-unit id="c4e097b58ceb08dc3f974c8e6307eeef8e3013c5" translate="yes" xml:space="preserve">
          <source>Masked-array output</source>
          <target state="translated">마스킹 된 어레이 출력</target>
        </trans-unit>
        <trans-unit id="d841064c28c03dbff8c2613367c727f3c3c8975a" translate="yes" xml:space="preserve">
          <source>MaskedArray</source>
          <target state="translated">MaskedArray</target>
        </trans-unit>
        <trans-unit id="3df5c7bf77a07f0823127c257a4194f48584b074" translate="yes" xml:space="preserve">
          <source>MaskedArray (class in numpy.ma)</source>
          <target state="translated">MaskedArray (numpy.ma의 클래스)</target>
        </trans-unit>
        <trans-unit id="e483ca2e474474c0115e70cf1df3652e7e71e77d" translate="yes" xml:space="preserve">
          <source>MaskedArray interpretation of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">의 MaskedArray 해석 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="20350351979da6675c245e446543b5c06d79da69" translate="yes" xml:space="preserve">
          <source>MaskedArray methods</source>
          <target state="translated">MaskedArray 메서드</target>
        </trans-unit>
        <trans-unit id="9be96da49a55b5657adb2ecea5fac909f3ac8f8e" translate="yes" xml:space="preserve">
          <source>MaskedArray support for more complicated base classes</source>
          <target state="translated">보다 복잡한 기본 클래스에 대한 MaskedArray 지원</target>
        </trans-unit>
        <trans-unit id="36eef88f9e59e296f6ba9abe6367cd57b8fabee2" translate="yes" xml:space="preserve">
          <source>MaskedArray.T</source>
          <target state="translated">MaskedArray.T</target>
        </trans-unit>
        <trans-unit id="e17190e574e1c6de156753c9b065e38a9376c85f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__abs__()</source>
          <target state="translated">MaskedArray.__abs__()</target>
        </trans-unit>
        <trans-unit id="4c5beb6649fcf04681433a7ebdca9956aed5ec6d" translate="yes" xml:space="preserve">
          <source>MaskedArray.__add__()</source>
          <target state="translated">MaskedArray.__add__()</target>
        </trans-unit>
        <trans-unit id="421e10c77680329d49bb9737bb7abc28463207e4" translate="yes" xml:space="preserve">
          <source>MaskedArray.__and__()</source>
          <target state="translated">MaskedArray.__and__()</target>
        </trans-unit>
        <trans-unit id="fada5de9b74bd344d17ff17846c4bd7d09dc8ec5" translate="yes" xml:space="preserve">
          <source>MaskedArray.__array__()</source>
          <target state="translated">MaskedArray.__array__()</target>
        </trans-unit>
        <trans-unit id="090520da30f28f47ff34b0675dc4cfba52313678" translate="yes" xml:space="preserve">
          <source>MaskedArray.__array_priority__</source>
          <target state="translated">MaskedArray.__array_priority__</target>
        </trans-unit>
        <trans-unit id="3850984710cdf39034ba996313c98f23d5b2df9a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__array_wrap__()</source>
          <target state="translated">MaskedArray.__array_wrap__()</target>
        </trans-unit>
        <trans-unit id="777801a9212371f85a428b465acd2c96402cbfb0" translate="yes" xml:space="preserve">
          <source>MaskedArray.__bool__()</source>
          <target state="translated">MaskedArray.__bool__()</target>
        </trans-unit>
        <trans-unit id="efb175793e0186c34683a4fcb1d1cf5491acc106" translate="yes" xml:space="preserve">
          <source>MaskedArray.__contains__()</source>
          <target state="translated">MaskedArray.__contains__()</target>
        </trans-unit>
        <trans-unit id="05bac951e4103953d43b28841001972c2c09a472" translate="yes" xml:space="preserve">
          <source>MaskedArray.__copy__()</source>
          <target state="translated">MaskedArray.__copy__()</target>
        </trans-unit>
        <trans-unit id="48e8b4072b356b5f6fb2ea3cc4a44eb836ce6d39" translate="yes" xml:space="preserve">
          <source>MaskedArray.__deepcopy__()</source>
          <target state="translated">MaskedArray.__deepcopy__()</target>
        </trans-unit>
        <trans-unit id="2e0879e5e2662c5b7bec6d8240c414de65e1878a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__delitem__()</source>
          <target state="translated">MaskedArray.__delitem__()</target>
        </trans-unit>
        <trans-unit id="ab799a52b2b144674a2920b57d6fb16fd77e185f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__div__()</source>
          <target state="translated">MaskedArray.__div__()</target>
        </trans-unit>
        <trans-unit id="c40d7cec7bfe9dd6ab450d46b504989d029ed2f1" translate="yes" xml:space="preserve">
          <source>MaskedArray.__divmod__()</source>
          <target state="translated">MaskedArray.__divmod__()</target>
        </trans-unit>
        <trans-unit id="31b2f1c182adb284ba514a01be32170ad7fca9d8" translate="yes" xml:space="preserve">
          <source>MaskedArray.__eq__()</source>
          <target state="translated">MaskedArray.__eq__()</target>
        </trans-unit>
        <trans-unit id="c0a1ce4250661dd853b1e06f87ab8dac408d08ad" translate="yes" xml:space="preserve">
          <source>MaskedArray.__float__()</source>
          <target state="translated">MaskedArray.__float__()</target>
        </trans-unit>
        <trans-unit id="c760fe1447ecc3aa37cfb9102932a85018b3dafc" translate="yes" xml:space="preserve">
          <source>MaskedArray.__floordiv__()</source>
          <target state="translated">MaskedArray.__floordiv__()</target>
        </trans-unit>
        <trans-unit id="ee7563ffce3b171861962dcda9493c8d6ea3ed49" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ge__()</source>
          <target state="translated">MaskedArray.__ge__()</target>
        </trans-unit>
        <trans-unit id="82fcceeb833f853fcf31878a9b2755ca3b83dad5" translate="yes" xml:space="preserve">
          <source>MaskedArray.__getitem__()</source>
          <target state="translated">MaskedArray.__getitem__()</target>
        </trans-unit>
        <trans-unit id="9ed68261ffa77dc15fd5c9bb460e16946aa3df57" translate="yes" xml:space="preserve">
          <source>MaskedArray.__getstate__()</source>
          <target state="translated">MaskedArray.__getstate__()</target>
        </trans-unit>
        <trans-unit id="5a94e729c8538503cbcb25ba506eda001f10eef6" translate="yes" xml:space="preserve">
          <source>MaskedArray.__gt__()</source>
          <target state="translated">MaskedArray.__gt__()</target>
        </trans-unit>
        <trans-unit id="5bf01a17a65fea68034c80a57ef6ea67f24bf648" translate="yes" xml:space="preserve">
          <source>MaskedArray.__iadd__()</source>
          <target state="translated">MaskedArray.__iadd__()</target>
        </trans-unit>
        <trans-unit id="3f290bfa30bdb27d86e902d735f6bd7a3ebdd997" translate="yes" xml:space="preserve">
          <source>MaskedArray.__iand__()</source>
          <target state="translated">MaskedArray.__iand__()</target>
        </trans-unit>
        <trans-unit id="a013bde0bc2086e80993b2e6453749be7566713a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__idiv__()</source>
          <target state="translated">MaskedArray.__idiv__()</target>
        </trans-unit>
        <trans-unit id="6b16248d7544de200904fad546fc0e0bf49d5d30" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ifloordiv__()</source>
          <target state="translated">MaskedArray.__ifloordiv__()</target>
        </trans-unit>
        <trans-unit id="e867a020a9a28fcaaaeebcd0b9a09276f34baacb" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ilshift__()</source>
          <target state="translated">MaskedArray.__ilshift__()</target>
        </trans-unit>
        <trans-unit id="a6177a6fe00279423505c3d2049817ef902c9f89" translate="yes" xml:space="preserve">
          <source>MaskedArray.__imod__()</source>
          <target state="translated">MaskedArray.__imod__()</target>
        </trans-unit>
        <trans-unit id="b2c2e20491238cbe7365526c778bb2bbeb1a9d92" translate="yes" xml:space="preserve">
          <source>MaskedArray.__imul__()</source>
          <target state="translated">MaskedArray.__imul__()</target>
        </trans-unit>
        <trans-unit id="8a9abb4f5e69b652a91dedbea90a17391081121c" translate="yes" xml:space="preserve">
          <source>MaskedArray.__int__()</source>
          <target state="translated">MaskedArray.__int__()</target>
        </trans-unit>
        <trans-unit id="89500ad2db959507c40e092a4338242970ecf920" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ior__()</source>
          <target state="translated">MaskedArray.__ior__()</target>
        </trans-unit>
        <trans-unit id="f6e0374c35f94019edb4b446250c41ffb2f2fed6" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ipow__()</source>
          <target state="translated">MaskedArray.__ipow__()</target>
        </trans-unit>
        <trans-unit id="464e0df1d1343a8a83ded812b19b8824e3be674f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__irshift__()</source>
          <target state="translated">MaskedArray.__irshift__()</target>
        </trans-unit>
        <trans-unit id="93662970a9f68651b0f13dddd859eee1c0cc852a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__isub__()</source>
          <target state="translated">MaskedArray.__isub__()</target>
        </trans-unit>
        <trans-unit id="97afb01534849ce41926c144adb54602527c52de" translate="yes" xml:space="preserve">
          <source>MaskedArray.__itruediv__()</source>
          <target state="translated">MaskedArray.__itruediv__()</target>
        </trans-unit>
        <trans-unit id="e96f966e7a5dbcf51d23a0d0e3ddedabf690b6a0" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ixor__()</source>
          <target state="translated">MaskedArray.__ixor__()</target>
        </trans-unit>
        <trans-unit id="bfe0157861dd1f9b0a231126eaf62a9189b87c49" translate="yes" xml:space="preserve">
          <source>MaskedArray.__le__()</source>
          <target state="translated">MaskedArray.__le__()</target>
        </trans-unit>
        <trans-unit id="dfcf580e54d121ccd612e4d1a45624b4bf8d1bc1" translate="yes" xml:space="preserve">
          <source>MaskedArray.__len__()</source>
          <target state="translated">MaskedArray.__len__()</target>
        </trans-unit>
        <trans-unit id="7d5ce46d9782038b232fd02c47b999130a7413d8" translate="yes" xml:space="preserve">
          <source>MaskedArray.__long__()</source>
          <target state="translated">MaskedArray.__long__()</target>
        </trans-unit>
        <trans-unit id="663699b5db72d62ee50222aef2e15e6ad8befaa7" translate="yes" xml:space="preserve">
          <source>MaskedArray.__lshift__()</source>
          <target state="translated">MaskedArray.__lshift__()</target>
        </trans-unit>
        <trans-unit id="981e3ec8c47bf66b67cbcfc222695e682740ef5c" translate="yes" xml:space="preserve">
          <source>MaskedArray.__lt__()</source>
          <target state="translated">MaskedArray.__lt__()</target>
        </trans-unit>
        <trans-unit id="e012d6b8cd5b77bcbe0a7677af22fead34c5e6bc" translate="yes" xml:space="preserve">
          <source>MaskedArray.__mod__()</source>
          <target state="translated">MaskedArray.__mod__()</target>
        </trans-unit>
        <trans-unit id="621981dba1b2c2c21d05b7718ab7bc6b94dde4de" translate="yes" xml:space="preserve">
          <source>MaskedArray.__mul__()</source>
          <target state="translated">MaskedArray.__mul__()</target>
        </trans-unit>
        <trans-unit id="451a40eda1d0439b5952565ebd5be0b93178765b" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ne__()</source>
          <target state="translated">MaskedArray.__ne__()</target>
        </trans-unit>
        <trans-unit id="449fa0f7176203d64b7688836d07d289af8aaada" translate="yes" xml:space="preserve">
          <source>MaskedArray.__or__()</source>
          <target state="translated">MaskedArray.__or__()</target>
        </trans-unit>
        <trans-unit id="74a1bdc16196c2ca4cb42e9ddf2dfa11e81379c0" translate="yes" xml:space="preserve">
          <source>MaskedArray.__pow__()</source>
          <target state="translated">MaskedArray.__pow__()</target>
        </trans-unit>
        <trans-unit id="628ddbd485b2a3c762a1acfa9b1ed8ea95f6ae2a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__radd__()</source>
          <target state="translated">MaskedArray.__radd__()</target>
        </trans-unit>
        <trans-unit id="e614928ac12233029fee60e611f9fd93534a1549" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rand__()</source>
          <target state="translated">MaskedArray.__rand__()</target>
        </trans-unit>
        <trans-unit id="60d56dcc3079a28858f7341d86340a9f6456c4ae" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rdivmod__()</source>
          <target state="translated">MaskedArray.__rdivmod__()</target>
        </trans-unit>
        <trans-unit id="58cfbddeeee8f3d20b2cb0a7c8e4b95d69260328" translate="yes" xml:space="preserve">
          <source>MaskedArray.__reduce__()</source>
          <target state="translated">MaskedArray.__reduce__()</target>
        </trans-unit>
        <trans-unit id="22bff568add5c50c81a9b76411f74a0165340bc3" translate="yes" xml:space="preserve">
          <source>MaskedArray.__repr__()</source>
          <target state="translated">MaskedArray.__repr__()</target>
        </trans-unit>
        <trans-unit id="37da21dfefb5612acac5c5b158edd891d71eaa33" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rfloordiv__()</source>
          <target state="translated">MaskedArray.__rfloordiv__()</target>
        </trans-unit>
        <trans-unit id="ba081ab522355f8c737fc96eeefb42e5ff706d35" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rlshift__()</source>
          <target state="translated">MaskedArray.__rlshift__()</target>
        </trans-unit>
        <trans-unit id="556c4be401c91f224ede894f1fd54e9f20d1b10a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rmod__()</source>
          <target state="translated">MaskedArray.__rmod__()</target>
        </trans-unit>
        <trans-unit id="d258f963823807ebafdac4bd7b4899a4ad5b3d81" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rmul__()</source>
          <target state="translated">MaskedArray.__rmul__()</target>
        </trans-unit>
        <trans-unit id="6c3504184a32bdc300bf50151f75a50cfb6319e8" translate="yes" xml:space="preserve">
          <source>MaskedArray.__ror__()</source>
          <target state="translated">MaskedArray.__ror__()</target>
        </trans-unit>
        <trans-unit id="b16d994e6cc6bacd92021c5be6a1f21c448c82be" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rpow__()</source>
          <target state="translated">MaskedArray.__rpow__()</target>
        </trans-unit>
        <trans-unit id="c263bb6b6626def1b808e0fb37da7db4a0ebdd03" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rrshift__()</source>
          <target state="translated">MaskedArray.__rrshift__()</target>
        </trans-unit>
        <trans-unit id="2024b9cd2546c77971dd14447cc764030b99e828" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rshift__()</source>
          <target state="translated">MaskedArray.__rshift__()</target>
        </trans-unit>
        <trans-unit id="9b18fd997fad99869943ae5ae86581115d42c76a" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rsub__()</source>
          <target state="translated">MaskedArray.__rsub__()</target>
        </trans-unit>
        <trans-unit id="1f99227921386926b66e1c80505362e37c730585" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rtruediv__()</source>
          <target state="translated">MaskedArray.__rtruediv__()</target>
        </trans-unit>
        <trans-unit id="f78ffc8f65b81494cb55cee0002a4b0ada2f7ea9" translate="yes" xml:space="preserve">
          <source>MaskedArray.__rxor__()</source>
          <target state="translated">MaskedArray.__rxor__()</target>
        </trans-unit>
        <trans-unit id="e2418f087c527a32587d4136ae5e11918bd6852f" translate="yes" xml:space="preserve">
          <source>MaskedArray.__setitem__()</source>
          <target state="translated">MaskedArray.__setitem__()</target>
        </trans-unit>
        <trans-unit id="fd4da74423f8b70de86f76a2c1393f4543b02dca" translate="yes" xml:space="preserve">
          <source>MaskedArray.__setmask__()</source>
          <target state="translated">MaskedArray.__setmask__()</target>
        </trans-unit>
        <trans-unit id="3f08573f36e15c86d5119deeed078db9cf2f9c35" translate="yes" xml:space="preserve">
          <source>MaskedArray.__setstate__()</source>
          <target state="translated">MaskedArray.__setstate__()</target>
        </trans-unit>
        <trans-unit id="bf1a7de4e02395cb1d82eb3102a1b212087fb9cc" translate="yes" xml:space="preserve">
          <source>MaskedArray.__str__()</source>
          <target state="translated">MaskedArray.__str__()</target>
        </trans-unit>
        <trans-unit id="36b295d86fb340a017c207e36c8ebf83a6e16a78" translate="yes" xml:space="preserve">
          <source>MaskedArray.__sub__()</source>
          <target state="translated">MaskedArray.__sub__()</target>
        </trans-unit>
        <trans-unit id="a89d7e18e21d53f656570951adaedf72a5d05f92" translate="yes" xml:space="preserve">
          <source>MaskedArray.__truediv__()</source>
          <target state="translated">MaskedArray.__truediv__()</target>
        </trans-unit>
        <trans-unit id="a9754cec53ed0199a3d0e11dd63f20ddf46718a9" translate="yes" xml:space="preserve">
          <source>MaskedArray.__xor__()</source>
          <target state="translated">MaskedArray.__xor__()</target>
        </trans-unit>
        <trans-unit id="e5c6d58a06d7326fe5c3b8675bf582f779908979" translate="yes" xml:space="preserve">
          <source>MaskedArray.all()</source>
          <target state="translated">MaskedArray.all()</target>
        </trans-unit>
        <trans-unit id="8e1c2703f802467d9be6b41fd4750421b30e4e78" translate="yes" xml:space="preserve">
          <source>MaskedArray.anom()</source>
          <target state="translated">MaskedArray.anom()</target>
        </trans-unit>
        <trans-unit id="ceaaae3b924788c52bbc3430b2ea479db323a8fa" translate="yes" xml:space="preserve">
          <source>MaskedArray.any()</source>
          <target state="translated">MaskedArray.any()</target>
        </trans-unit>
        <trans-unit id="b63e7e734845f2e2d00786798d483b6f14625034" translate="yes" xml:space="preserve">
          <source>MaskedArray.argmax()</source>
          <target state="translated">MaskedArray.argmax()</target>
        </trans-unit>
        <trans-unit id="1d5ecf97f71ab691cf38b6c6ce5d2340f025638f" translate="yes" xml:space="preserve">
          <source>MaskedArray.argmin()</source>
          <target state="translated">MaskedArray.argmin()</target>
        </trans-unit>
        <trans-unit id="5f36204da3705060bd71f1d51d51b88f55d27d4b" translate="yes" xml:space="preserve">
          <source>MaskedArray.argsort()</source>
          <target state="translated">MaskedArray.argsort()</target>
        </trans-unit>
        <trans-unit id="553ea17b1dc12eebdf6169924b18d2d2f67e5e36" translate="yes" xml:space="preserve">
          <source>MaskedArray.astype()</source>
          <target state="translated">MaskedArray.astype()</target>
        </trans-unit>
        <trans-unit id="8b903ed2f76d12382ddb4618a18e0d58c21ed045" translate="yes" xml:space="preserve">
          <source>MaskedArray.base</source>
          <target state="translated">MaskedArray.base</target>
        </trans-unit>
        <trans-unit id="a41536928c95f5bbcde8ddd69d27b894c4f41213" translate="yes" xml:space="preserve">
          <source>MaskedArray.baseclass</source>
          <target state="translated">MaskedArray.baseclass</target>
        </trans-unit>
        <trans-unit id="e9f76b44c9ca3946a8973c001ef5105ca5c0a87a" translate="yes" xml:space="preserve">
          <source>MaskedArray.byteswap()</source>
          <target state="translated">MaskedArray.byteswap()</target>
        </trans-unit>
        <trans-unit id="6d6d5940ea9cd2aa53d30efb8451b5d30eb2cde7" translate="yes" xml:space="preserve">
          <source>MaskedArray.choose()</source>
          <target state="translated">MaskedArray.choose()</target>
        </trans-unit>
        <trans-unit id="15f1f394124b62be99d1e91448f88c1ef69b9f14" translate="yes" xml:space="preserve">
          <source>MaskedArray.clip()</source>
          <target state="translated">MaskedArray.clip()</target>
        </trans-unit>
        <trans-unit id="cf476639b180537cbfa338fde8bb6d05c515b926" translate="yes" xml:space="preserve">
          <source>MaskedArray.compress()</source>
          <target state="translated">MaskedArray.compress()</target>
        </trans-unit>
        <trans-unit id="2ee7894999c452973a3887d5a0c1ffb1b8b3389f" translate="yes" xml:space="preserve">
          <source>MaskedArray.compressed()</source>
          <target state="translated">MaskedArray.compressed()</target>
        </trans-unit>
        <trans-unit id="35832e57568e0633c816ac034fbb4ab85736d2c2" translate="yes" xml:space="preserve">
          <source>MaskedArray.conj()</source>
          <target state="translated">MaskedArray.conj()</target>
        </trans-unit>
        <trans-unit id="8161480b13b89c370614b9b7777fdfda08ce6c7d" translate="yes" xml:space="preserve">
          <source>MaskedArray.conjugate()</source>
          <target state="translated">MaskedArray.conjugate()</target>
        </trans-unit>
        <trans-unit id="cb7ea380c906751da3d908d0bc4c7d88be3c4655" translate="yes" xml:space="preserve">
          <source>MaskedArray.copy()</source>
          <target state="translated">MaskedArray.copy()</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
