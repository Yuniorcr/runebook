<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="86d8d5f0414d9a23442dad9a8767153d6dc63973" translate="yes" xml:space="preserve">
          <source>F2PY has basic support for Fortran 90 module allocatable arrays.</source>
          <target state="translated">F2PY는 Fortran 90 모듈 할당 가능 어레이에 대한 기본 지원을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="70ca3b53756dbec8defd4dadba9010e32a75e058" translate="yes" xml:space="preserve">
          <source>F2PY implements basic compatibility checks between related arguments in order to avoid any unexpected crashes.</source>
          <target state="translated">F2PY는 예기치 않은 충돌을 피하기 위해 관련 인수 간의 기본 호환성 검사를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="d254f0a276a232e34acfb47e3326523f334f058d" translate="yes" xml:space="preserve">
          <source>F2PY may lower cases also in C expressions when scanning Fortran codes (see &lt;code&gt;--[no]-lower&lt;/code&gt; option).</source>
          <target state="translated">F2PY는 Fortran 코드를 스캔 할 때 C 표현식에서도 대소 문자를 소문자로 지정할 수 있습니다 ( &lt;code&gt;--[no]-lower&lt;/code&gt; 옵션 참조).</target>
        </trans-unit>
        <trans-unit id="ec756cae82276f06410c3a4d2b35a06f369bcafa" translate="yes" xml:space="preserve">
          <source>F2PY provides &lt;code&gt;intent(inplace)&lt;/code&gt; attribute that would modify the attributes of an input array so that any changes made by Fortran routine will be effective also in input argument. For example, if one specifies &lt;code&gt;intent(inplace) a&lt;/code&gt; (see below, how), then the example above would read:</source>
          <target state="translated">F2PY는 입력 배열의 속성을 수정하는 &lt;code&gt;intent(inplace)&lt;/code&gt; 속성을 제공 하므로 Fortran 루틴에 의해 변경된 사항은 입력 인수에서도 적용됩니다. 예를 들어 &lt;code&gt;intent(inplace) a&lt;/code&gt; (아래, 방법 참조 )를 지정하면 위의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fca2006682a608b9e1b2b53bb3bb49e7143a70f2" translate="yes" xml:space="preserve">
          <source>F2PY reads a signature file and writes a Python C/API module containing Fortran/C/Python bindings.</source>
          <target state="translated">F2PY는 서명 파일을 읽고 Fortran / C / Python 바인딩을 포함하는 Python C / API 모듈을 작성합니다.</target>
        </trans-unit>
        <trans-unit id="33d34cb52e571436cd929620cb006187918c3090" translate="yes" xml:space="preserve">
          <source>F2PY supports calling Python functions from Fortran or C codes.</source>
          <target state="translated">F2PY는 Fortran 또는 C 코드에서 Python 함수 호출을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="a50f97135d3a00f9c97ae354c1ab19960a6943cf" translate="yes" xml:space="preserve">
          <source>F2Py Guide</source>
          <target state="translated">F2Py 가이드</target>
        </trans-unit>
        <trans-unit id="780b1e049709bc720bf18c99d71f2cd4235c8e49" translate="yes" xml:space="preserve">
          <source>F2Py guide</source>
          <target state="translated">F2Py 가이드</target>
        </trans-unit>
        <trans-unit id="db0e0f2556443edbd8b7072d8289833837b00763" translate="yes" xml:space="preserve">
          <source>F2py allows you to automatically construct an extension module that interfaces to routines in Fortran 77/90/95 code. It has the ability to parse Fortran 77/90/95 code and automatically generate Python signatures for the subroutines it encounters, or you can guide how the subroutine interfaces with Python by constructing an interface-definition-file (or modifying the f2py-produced one).</source>
          <target state="translated">F2py를 사용하면 Fortran 77/90/95 코드의 루틴에 인터페이스하는 확장 모듈을 자동으로 구성 할 수 있습니다. Fortran 77/90/95 코드를 구문 분석하고 만나는 서브 루틴에 대한 Python 서명을 자동으로 생성하는 기능이 있습니다. 또는 인터페이스 정의 파일을 구성 (또는 f2py 생성 파일을 수정하여 서브 루틴이 Python과 인터페이스하는 방법)을 안내 할 수 있습니다. ).</target>
        </trans-unit>
        <trans-unit id="bf8300dc1be4d8761c3816eeb71051b6b621dd6e" translate="yes" xml:space="preserve">
          <source>FFT</source>
          <target state="translated">FFT</target>
        </trans-unit>
        <trans-unit id="ca600c25350318c92a93eef893cdd109ac18c10d" translate="yes" xml:space="preserve">
          <source>FFT (Fast Fourier Transform) refers to a way the discrete Fourier Transform (DFT) can be calculated efficiently, by using symmetries in the calculated terms. The symmetry is highest when &lt;code&gt;n&lt;/code&gt; is a power of 2, and the transform is therefore most efficient for these sizes.</source>
          <target state="translated">FFT (Fast Fourier Transform)는 계산 된 용어의 대칭을 사용하여 이산 푸리에 변환 (DFT)을 효율적으로 계산할 수있는 방법을 나타냅니다. &lt;code&gt;n&lt;/code&gt; 이 2의 거듭 제곱 인 경우 대칭이 가장 높 으므로 이러한 크기에 대해 변환이 가장 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="1e904f6af52956913c4ff703c15d71d4683c8dd0" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS / F / FORTRAN</source>
          <target state="translated">F_CONTIGUOUS / F / 포트란</target>
        </trans-unit>
        <trans-unit id="10ba031202732234b30a39bc920cbaa6d821ef6b" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS and not C_CONTIGUOUS.</source>
          <target state="translated">C_CONTIGUOUS가 아닌 F_CONTIGUOUS</target>
        </trans-unit>
        <trans-unit id="542219cc1d690d05adfbb2e51a8b3ccb1985fddc" translate="yes" xml:space="preserve">
          <source>F_CONTIGUOUS or C_CONTIGUOUS (one-segment test).</source>
          <target state="translated">F_CONTIGUOUS 또는 C_CONTIGUOUS (1 세그먼트 테스트).</target>
        </trans-unit>
        <trans-unit id="85c6c271be69ba94867c22f54f57654f454c41b4" translate="yes" xml:space="preserve">
          <source>Factor the matrix &lt;code&gt;a&lt;/code&gt; as &lt;em&gt;qr&lt;/em&gt;, where &lt;code&gt;q&lt;/code&gt; is orthonormal and &lt;code&gt;r&lt;/code&gt; is upper-triangular.</source>
          <target state="translated">행렬 &lt;code&gt;a&lt;/code&gt; 를 &lt;em&gt;qr&lt;/em&gt; 로 인수 분해 합니다 . 여기서 &lt;code&gt;q&lt;/code&gt; 는 정규직 선이고 &lt;code&gt;r&lt;/code&gt; 은 상위 삼각형입니다.</target>
        </trans-unit>
        <trans-unit id="fb318cde14ee94b6e5d32ac7d527c0788644b0e1" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class and with message that matches expected_regexp is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">argument_class 클래스와 exception_regexp와 일치하는 메시지를 가진 예외가 인수 args 및 키워드 인수 kwargs와 함께 호출 될 때 호출 가능에 의해 발생하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="021d84299e2248496708e7d1e546ad6c2c18b0ba" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs.</source>
          <target state="translated">인수 args 및 키워드 인수 kwargs를 사용하여 호출 할 때 exception_class 클래스의 예외가 호출 가능에 의해 발생하지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="88591071684d50acd16039be01f0c08d81ea457a" translate="yes" xml:space="preserve">
          <source>Fail unless an exception of class exception_class is thrown by callable when invoked with arguments args and keyword arguments kwargs. If a different type of exception is thrown, it will not be caught, and the test case will be deemed to have suffered an error, exactly as for an unexpected exception.</source>
          <target state="translated">인수 args 및 키워드 인수 kwargs를 사용하여 호출 할 때 exception_class 클래스의 예외가 호출 가능에 의해 발생하지 않으면 실패합니다. 다른 유형의 예외가 발생하면 예외가 포착되지 않으며 예상치 않은 예외와 마찬가지로 테스트 사례에 오류가 발생한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="719788786f4bf9fa2ee26b39d5371d0a438935c3" translate="yes" xml:space="preserve">
          <source>Fail unless the given callable throws the specified warning.</source>
          <target state="translated">주어진 콜 러블이 지정된 경고를 던지지 않으면 실패합니다.</target>
        </trans-unit>
        <trans-unit id="552c13b4b3257ae89f519cb962e935c59da9aa88" translate="yes" xml:space="preserve">
          <source>Fanaticism consists of redoubling your efforts when you have forgotten your aim. &amp;mdash; &lt;em&gt;George Santayana&lt;/em&gt;</source>
          <target state="translated">광신주의는 당신이 목표를 잊었을 때 당신의 노력을 배가시키는 것입니다. &amp;mdash; &lt;em&gt;조지 산타 야나&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c67baf5f0ace8714e24d83b916518b08cd541740" translate="yes" xml:space="preserve">
          <source>Fast element-wise operations, called a &lt;a href=&quot;#term-ufunc&quot;&gt;ufunc&lt;/a&gt;, operate on arrays.</source>
          <target state="translated">&lt;a href=&quot;#term-ufunc&quot;&gt;ufunc&lt;/a&gt; 라고하는 빠른 요소 별 연산 은 배열에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a35d6e8cdee3fab38ad9c3056a80a39fdb1d90ea" translate="yes" xml:space="preserve">
          <source>Faster version of &lt;a href=&quot;#numpy.base_repr&quot;&gt;&lt;code&gt;base_repr&lt;/code&gt;&lt;/a&gt; for base 2.</source>
          <target state="translated">기본 2에 대한 더 빠른 버전의 &lt;a href=&quot;#numpy.base_repr&quot;&gt; &lt;code&gt;base_repr&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="450b0ab74bf6b08b6fed235cfac5fd255dd761eb" translate="yes" xml:space="preserve">
          <source>Fasttake and fastputmask slots are deprecated and NULL&amp;rsquo;ed</source>
          <target state="translated">Fasttake 및 fastputmask 슬롯은 더 이상 사용되지 않으며 NULL입니다.</target>
        </trans-unit>
        <trans-unit id="ad565d9d01d0e0bf91fd6a8532f6d81613338901" translate="yes" xml:space="preserve">
          <source>Feature</source>
          <target state="translated">Feature</target>
        </trans-unit>
        <trans-unit id="fc338f87a058158eb824b53705961801516a9460" translate="yes" xml:space="preserve">
          <source>Features</source>
          <target state="translated">Features</target>
        </trans-unit>
        <trans-unit id="cba8e75130f021ad02ee54a4acd20b3b023d217d" translate="yes" xml:space="preserve">
          <source>Fernando Perez&amp;rsquo; git page - &lt;a href=&quot;http://www.fperez.org/py4science/git.html&quot;&gt;Fernando&amp;rsquo;s git page&lt;/a&gt; - many links and tips</source>
          <target state="translated">Fernando Perez의 자식 페이지 &lt;a href=&quot;http://www.fperez.org/py4science/git.html&quot;&gt;-Fernando의 자식 페이지&lt;/a&gt; -많은 링크와 팁</target>
        </trans-unit>
        <trans-unit id="5c6f34280b7f890c09c370b6ae106bab782a8ea7" translate="yes" xml:space="preserve">
          <source>Field Access</source>
          <target state="translated">필드 액세스</target>
        </trans-unit>
        <trans-unit id="783edc3ed85699bf943ebb957a288a27bf6fa548" translate="yes" xml:space="preserve">
          <source>Field Titles</source>
          <target state="translated">필드 제목</target>
        </trans-unit>
        <trans-unit id="1f20e66b17a6eb7c2baf1ab68337d91eaf6f4f80" translate="yes" xml:space="preserve">
          <source>Figure</source>
          <target state="translated">Figure</target>
        </trans-unit>
        <trans-unit id="6810ab68c484c234e459c4fd42ee6ddebf48e9df" translate="yes" xml:space="preserve">
          <source>File bug reports or feature requests, and make contributions (e.g. code patches), by opening a &amp;ldquo;new issue&amp;rdquo; on GitHub:</source>
          <target state="translated">GitHub에서 &quot;새로운 문제&quot;를 열어 버그 보고서 또는 기능 요청을 제출하고 기여 (예 : 코드 패치)를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="373ecfdf236324d2c0d2c0966daa4376bd84ecc7" translate="yes" xml:space="preserve">
          <source>File extensions</source>
          <target state="translated">파일 확장자</target>
        </trans-unit>
        <trans-unit id="d09479e812c08194a796ba5cf0534018f31d75df" translate="yes" xml:space="preserve">
          <source>File like object that the output is written to, default is &lt;code&gt;stdout&lt;/code&gt;. The object has to be opened in &amp;lsquo;w&amp;rsquo; or &amp;lsquo;a&amp;rsquo; mode.</source>
          <target state="translated">출력이 작성된 오브젝트와 같은 파일이며 기본값은 &lt;code&gt;stdout&lt;/code&gt; 입니다. 개체는 'w'또는 'a'모드에서 열어야합니다.</target>
        </trans-unit>
        <trans-unit id="87eae4c8fed58e613f33763392061f9f060bfb3a" translate="yes" xml:space="preserve">
          <source>File mode.</source>
          <target state="translated">파일 모드.</target>
        </trans-unit>
        <trans-unit id="fd757708817417e6d160c4d854e159b642dde015" translate="yes" xml:space="preserve">
          <source>File name or file object to read.</source>
          <target state="translated">읽을 파일 이름 또는 파일 객체.</target>
        </trans-unit>
        <trans-unit id="a9cb7966c21c4ba3f863696ad8ce671f4f627493" translate="yes" xml:space="preserve">
          <source>File object.</source>
          <target state="translated">파일 객체.</target>
        </trans-unit>
        <trans-unit id="4a94520c92dda87c31025fbdcee94cc740835e3c" translate="yes" xml:space="preserve">
          <source>File on disk is unchanged:</source>
          <target state="translated">디스크의 파일은 변경되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="0031f1b0b3ec78263f049edb5bf2d9bd62cb7daa" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the file name if it does not already have one.</source>
          <target state="translated">데이터가 저장되는 파일 또는 파일 이름입니다. 파일이 파일 객체 인 경우 파일 이름은 변경되지 않습니다. 파일이 문자열 또는 경로 인 경우 파일 이름에 &lt;code&gt;.npy&lt;/code&gt; 확장자가없는 경우 파일 이름에 .npy 확장자가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="1eb6e34596962a0a844dec399c9d41368523ad02" translate="yes" xml:space="preserve">
          <source>File or filename to which the data is saved. If file is a file-object, then the filename is unchanged. If file is a string or Path, a &lt;code&gt;.npy&lt;/code&gt; extension will be appended to the filename if it does not already have one.</source>
          <target state="translated">데이터가 저장되는 파일 또는 파일 이름입니다. 파일이 파일 객체 인 경우 파일 이름은 변경되지 않습니다. 파일이 문자열 또는 경로 인 경우 &lt;code&gt;.npy&lt;/code&gt; 확장자가 아직없는 경우 파일 이름에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="e820f26629f1b163437a25da45907f2a0bdeef89" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings in Python 3k. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="translated">읽을 파일, 파일 이름, 목록 또는 생성기. 파일 이름 확장자가 &lt;code&gt;gz&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 인 경우 파일의 압축이 먼저 풀립니다. 생성기는 Python 3k에서 바이트 문자열을 반환해야합니다. 목록의 문자열 또는 생성기에 의해 생성 된 문자열은 라인으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="fab43e32c1dfae0973539d24c1436cb574228947" translate="yes" xml:space="preserve">
          <source>File, filename, list, or generator to read. If the filename extension is &lt;code&gt;gz&lt;/code&gt; or &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt;&lt;code&gt;bz2&lt;/code&gt;&lt;/a&gt;, the file is first decompressed. Note that generators must return byte strings. The strings in a list or produced by a generator are treated as lines.</source>
          <target state="translated">읽을 파일, 파일 이름, 목록 또는 생성기입니다. 파일 이름 확장자가 &lt;code&gt;gz&lt;/code&gt; 또는 &lt;a href=&quot;https://docs.python.org/dev/library/bz2.html#module-bz2&quot;&gt; &lt;code&gt;bz2&lt;/code&gt; &lt;/a&gt; 이면 파일이 먼저 압축 해제됩니다. 생성기는 바이트 문자열을 반환해야합니다. 목록에 있거나 생성자가 생성 한 문자열은 행으로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="822b222e1d15e367e3952f91b983db03e9a7813a" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings for Python 3k.</source>
          <target state="translated">읽을 파일, 파일 이름 또는 생성기 파일 이름 확장자가 &lt;code&gt;.gz&lt;/code&gt; 또는 &lt;code&gt;.bz2&lt;/code&gt; 인 경우 파일의 압축이 먼저 풀립니다. 생성기는 Python 3k에 대한 바이트 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="7c2d62ffff5fbd690a9400522b7a8e17b68bb40c" translate="yes" xml:space="preserve">
          <source>File, filename, or generator to read. If the filename extension is &lt;code&gt;.gz&lt;/code&gt; or &lt;code&gt;.bz2&lt;/code&gt;, the file is first decompressed. Note that generators should return byte strings.</source>
          <target state="translated">읽을 파일, 파일 이름 또는 생성기. 파일 이름 확장자가 &lt;code&gt;.gz&lt;/code&gt; 또는 &lt;code&gt;.bz2&lt;/code&gt; 인 경우 파일이 먼저 압축 해제됩니다. 생성기는 바이트 문자열을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="c13aad6dcb77e8786c02dc6c8f0cc3a100a87f10" translate="yes" xml:space="preserve">
          <source>File-like object to write the output to. If omitted, use a pager.</source>
          <target state="translated">출력을 쓸 파일과 같은 객체입니다. 생략하면 호출기를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="3b5057522ae1af734e89a0b5dfbff160729789a2" translate="yes" xml:space="preserve">
          <source>Filename extension if &lt;code&gt;source_fn&lt;/code&gt; is not provided. The extension tells which fortran standard is used. The default is &lt;code&gt;f&lt;/code&gt;, which implies F77 standard.</source>
          <target state="translated">&lt;code&gt;source_fn&lt;/code&gt; 이 제공되지 않은 경우 파일 이름 확장자 입니다. 확장은 어떤 포트란 표준이 사용되는지 알려줍니다. 기본값은 &lt;code&gt;f&lt;/code&gt; 이며 F77 표준을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="529e452aa227b660fcf372199a15e8d7d5c2906a" translate="yes" xml:space="preserve">
          <source>Filename or file object to read.</source>
          <target state="translated">읽을 파일 이름 또는 파일 개체입니다.</target>
        </trans-unit>
        <trans-unit id="441bea0f99295363abddd57e69579a4d7e166597" translate="yes" xml:space="preserve">
          <source>Files output by &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; (that is, using the numpy format) can be read using &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt; with the &lt;code&gt;mmap_mode&lt;/code&gt; keyword argument:</source>
          <target state="translated">&lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; (즉, numpy 형식 사용)에 의해 출력 된 파일 은 &lt;code&gt;mmap_mode&lt;/code&gt; 키워드 인수 와 함께 &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; &lt;/a&gt; 를 사용하여 읽을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cafc76c090d17de83480422080a28bd0d7fd39f0" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">객체 데이터 유형으로 구조의 모든 위치에서 단일 값 obj로 새로 생성 된 배열을 채 웁니다. 점검은 수행되지 않지만 &lt;em&gt;arr&lt;/em&gt; 은 데이터 유형 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; 이어야&lt;/a&gt; 하며 단일 세그먼트이고 초기화되지 않아야합니다 (이전의 오브젝트는 제 위치에 없음). 이 함수를 호출하기 전에 객체 배열의 모든 항목을 줄여야하는 경우 &lt;code&gt;PyArray_DECREF&lt;/code&gt; ( &lt;em&gt;arr&lt;/em&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="612fab5ef5d07ab4ae826c3e92e57f0933c1a153" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;a href=&quot;#c.PyArray_XDECREF&quot;&gt;&lt;code&gt;PyArray_XDECREF&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">새로 생성 된 배열을 객체 데이터 유형으로 구조의 모든 위치에서 단일 값 obj로 채 웁니다. 검사는 수행되지 않지만 &lt;em&gt;arr&lt;/em&gt; 은 &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 데이터 유형 이어야 하며 단일 세그먼트이고 초기화되지 않아야합니다 (위치에 이전 개체가 없음). 이 함수를 호출하기 전에 객체 배열의 모든 항목을 줄여야하는 경우 &lt;a href=&quot;#c.PyArray_XDECREF&quot;&gt; &lt;code&gt;PyArray_XDECREF&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;arr&lt;/em&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb9c4c9e7ee887e06f557b25790d19437a193098" translate="yes" xml:space="preserve">
          <source>Fill a newly created array with a single value obj at all locations in the structure with object data-types. No checking is performed but &lt;em&gt;arr&lt;/em&gt; must be of data-type &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; and be single-segment and uninitialized (no previous objects in position). Use &lt;code&gt;PyArray_DECREF&lt;/code&gt; (&lt;em&gt;arr&lt;/em&gt;) if you need to decrement all the items in the object array prior to calling this function.</source>
          <target state="translated">새로 생성 된 배열을 객체 데이터 유형으로 구조의 모든 위치에서 단일 값 obj로 채 웁니다. 검사는 수행되지 않지만 &lt;em&gt;arr&lt;/em&gt; 은 &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 데이터 유형 이어야 하며 단일 세그먼트이고 초기화되지 않아야합니다 (위치에 이전 개체가 없음). 이 함수를 호출하기 전에 객체 배열의 모든 항목을 줄여야하는 경우 &lt;code&gt;PyArray_DECREF&lt;/code&gt; ( &lt;em&gt;arr&lt;/em&gt; )를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="2dddc689c840b0f704b5fbfeacd8ef3c5403555f" translate="yes" xml:space="preserve">
          <source>Fill in a new Python type-object structure with pointers to new functions that will over-ride the default behavior while leaving any function that should remain the same unfilled (or NULL). The tp_name element should be different.</source>
          <target state="translated">기본 동작을 재정의하는 새 함수에 대한 포인터로 새 Python 유형 객체 구조를 채우고 동일한 채움 (또는 NULL) 상태로 유지해야하는 함수는 그대로 둡니다. tp_name 요소는 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="522f873213d8106cc0a4bcd37cf77275093b44ed" translate="yes" xml:space="preserve">
          <source>Fill in the tp_base member of the new type-object structure with a pointer to the (main) parent type object. For multiple-inheritance, also fill in the tp_bases member with a tuple containing all of the parent objects in the order they should be used to define inheritance. Remember, all parent-types must have the same C-structure for multiple inheritance to work properly.</source>
          <target state="translated">새로운 유형 객체 구조의 tp_base 멤버를 (주) 부모 유형 객체에 대한 포인터로 채 웁니다. 다중 상속의 경우 상속을 정의하는 데 사용해야하는 순서대로 모든 부모 개체를 포함하는 튜플로 tp_bases 멤버를 채 웁니다. 다중 상속이 제대로 작동하려면 모든 상위 유형이 동일한 C 구조를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="b5a170286ef4b261aa8d713f55afdd2bfdd31a79" translate="yes" xml:space="preserve">
          <source>Fill out the release note &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; calling out significant changes.</source>
          <target state="translated">중요한 변경 사항을 설명하는 릴리스 노트 &lt;code&gt;doc/release/1.14.5-notes.rst&lt;/code&gt; 를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="7b1b896be57d746740e7bb01641621fc3fcf97bb" translate="yes" xml:space="preserve">
          <source>Fill out the release note &lt;code&gt;doc/release/1.19.0-notes.rst&lt;/code&gt; calling out significant changes.</source>
          <target state="translated">중요한 변경 사항을 설명하는 릴리스 노트 &lt;code&gt;doc/release/1.19.0-notes.rst&lt;/code&gt; 를 작성합니다.</target>
        </trans-unit>
        <trans-unit id="260366fdf73d36b977576943b4aedf90420566c3" translate="yes" xml:space="preserve">
          <source>Fill the array pointed to by &lt;em&gt;obj&lt;/em&gt; &amp;mdash;which must be a (subclass of) ndarray&amp;mdash;with the contents of &lt;em&gt;val&lt;/em&gt; (evaluated as a byte). This macro calls memset, so obj must be contiguous.</source>
          <target state="translated">&lt;em&gt;val&lt;/em&gt; (바이트로 평가 된) 의 내용 으로 &lt;em&gt;obj가&lt;/em&gt; 가리키는 배열 (ndarray의 (하위 클래스)이어야 함)을 채 웁니다 . 이 매크로는 memset을 호출하므로 obj는 연속적이어야합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="1cc72d434ca66ec2855e95222b47cf34ee62d6a9" translate="yes" xml:space="preserve">
          <source>Fill the array with a scalar value.</source>
          <target state="translated">배열을 스칼라 값으로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="a5d5966e608173a9667b1c1fac892e66538c72e9" translate="yes" xml:space="preserve">
          <source>Fill the array, &lt;em&gt;arr&lt;/em&gt;, with the given scalar object, &lt;em&gt;obj&lt;/em&gt;. The object is first converted to the data type of &lt;em&gt;arr&lt;/em&gt;, and then copied into every location. A -1 is returned if an error occurs, otherwise 0 is returned.</source>
          <target state="translated">주어진 스칼라 객체 &lt;em&gt;obj로&lt;/em&gt; 배열 &lt;em&gt;arr을 채 웁니다&lt;/em&gt; . 객체는 먼저 데이터 유형 &lt;em&gt;arr&lt;/em&gt; 로 변환 된 후 모든 위치에 복사됩니다. 오류가 발생하면 -1이 반환되고, 그렇지 않으면 0이 반환됩니다.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bee882405d3a5e1e28b315ab4a7baab2498c486" translate="yes" xml:space="preserve">
          <source>Fill the main diagonal of the given array of any dimensionality.</source>
          <target state="translated">해당 차원의 주어진 배열의 주 대각선을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b0054199bd21115b17143e2277b55874769f1942" translate="yes" xml:space="preserve">
          <source>Fill value.</source>
          <target state="translated">값을 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="b3edc087fa7c92433208963d028502658cb11c3c" translate="yes" xml:space="preserve">
          <source>Filling a masked array</source>
          <target state="translated">마스크 배열 채우기</target>
        </trans-unit>
        <trans-unit id="b16b1c014bc041df050e0baec2b30b9a58147141" translate="yes" xml:space="preserve">
          <source>Filling in the missing data</source>
          <target state="translated">누락 된 데이터 작성</target>
        </trans-unit>
        <trans-unit id="f534a9943c59ee88bfbaa91a174f38f23a434db7" translate="yes" xml:space="preserve">
          <source>Filling value used to pad missing data on the shorter arrays.</source>
          <target state="translated">더 짧은 배열에서 누락 된 데이터를 채우는 데 사용되는 채우기 값입니다.</target>
        </trans-unit>
        <trans-unit id="4473d8b6f530a08d5d328b58cdecfd819be6ec67" translate="yes" xml:space="preserve">
          <source>Filling value. A consistency test is performed to make sure the value is compatible with the dtype of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">충전 가치. 일관성 검사는 반드시 값의 DTYPE와 호환되는지 확인하기 위해 수행된다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13227282778cd8d20999d32a512e651e3ee07193" translate="yes" xml:space="preserve">
          <source>Filling value. Default is None.</source>
          <target state="translated">충전 가치. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="6c1d42d50fc7e4074f490614ad1bcf00ba471b76" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outreadflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be read from, and to 0 if not.</source>
          <target state="translated">&lt;code&gt;nop&lt;/code&gt; 플래그를 채 웁니다 . &lt;code&gt;op[i]&lt;/code&gt; 를 읽을 수 있으면 &lt;code&gt;outreadflags[i]&lt;/code&gt; 를 1로 설정 하고, 그렇지 않으면 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="749d04ce696c047f8e1f31d9e0905d115c8ee6f7" translate="yes" xml:space="preserve">
          <source>Fills &lt;code&gt;nop&lt;/code&gt; flags. Sets &lt;code&gt;outwriteflags[i]&lt;/code&gt; to 1 if &lt;code&gt;op[i]&lt;/code&gt; can be written to, and to 0 if not.</source>
          <target state="translated">&lt;code&gt;nop&lt;/code&gt; 플래그를 채 웁니다 . &lt;code&gt;op[i]&lt;/code&gt; 쓸 수 있으면 &lt;code&gt;outwriteflags[i]&lt;/code&gt; 를 1로 설정 하고, 그렇지 않으면 0으로 설정합니다.</target>
        </trans-unit>
        <trans-unit id="488079b1696f7e1612a42c6bc0389bc81283467e" translate="yes" xml:space="preserve">
          <source>Fills fields from output with fields from input, with support for nested structures.</source>
          <target state="translated">중첩 된 구조를 지원하여 출력의 필드를 입력의 필드로 채 웁니다.</target>
        </trans-unit>
        <trans-unit id="8d3ad1e9024ff38aba4d75bcdff8761b89757502" translate="yes" xml:space="preserve">
          <source>Filter deprecation warnings while running the test suite.</source>
          <target state="translated">테스트 스위트를 실행하는 동안 사용 중단 경고를 필터링하십시오.</target>
        </trans-unit>
        <trans-unit id="53d64090d55b3e9e6c51d2a5eb3eec10a8e6734d" translate="yes" xml:space="preserve">
          <source>Filters added inside the context manager will be discarded again when leaving it. Upon entering all filters defined outside a context will be applied automatically.</source>
          <target state="translated">컨텍스트 관리자 내에 추가 된 필터는 그대로두면 다시 삭제됩니다. 컨텍스트 외부에 정의 된 모든 필터를 입력하면 자동으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="1f7718a6ac69fd3c4dc296189cd48158349007af" translate="yes" xml:space="preserve">
          <source>Final output manipulation</source>
          <target state="translated">최종 출력 조작</target>
        </trans-unit>
        <trans-unit id="e9f53f9791e6b436e0f9b0c9184addd1c942785e" translate="yes" xml:space="preserve">
          <source>Final words</source>
          <target state="translated">마지막 단어</target>
        </trans-unit>
        <trans-unit id="00438430543507877599066cb88e3248f61081f4" translate="yes" xml:space="preserve">
          <source>Finally if we use the option &lt;code&gt;rowvar=False&lt;/code&gt;, the columns are now being treated as the variables and we will find the column-wise Pearson correlation coefficients between variables in &lt;code&gt;xarr&lt;/code&gt; and &lt;code&gt;yarr&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;rowvar=False&lt;/code&gt; 옵션을 사용하면 열이 이제 변수로 처리되고 &lt;code&gt;xarr&lt;/code&gt; 및 &lt;code&gt;yarr&lt;/code&gt; 변수 간의 열별 Pearson 상관 계수를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f8cf825450130b603f61a294cd870952ff541ac0" translate="yes" xml:space="preserve">
          <source>Finally make a pull request using Github. Make sure it is against the maintenance branch and not master, Github will usually suggest you make the pull request against master.</source>
          <target state="translated">마지막으로 Github를 사용하여 pull 요청을합니다. 마스터가 아닌 유지 보수 브랜치에 대한 것인지 확인하십시오. Github는 일반적으로 마스터에 대한 풀 요청을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="ba468d0ce6c90f05fb67a4c2a63c164ebea004bd" translate="yes" xml:space="preserve">
          <source>Finally, &lt;code&gt;Configuration&lt;/code&gt; has &lt;code&gt;.todict()&lt;/code&gt; method that returns all the configuration data as a dictionary suitable for passing on to the &lt;code&gt;setup(..)&lt;/code&gt; function.</source>
          <target state="translated">마지막으로 &lt;code&gt;Configuration&lt;/code&gt; 에는 모든 구성 데이터를 &lt;code&gt;setup(..)&lt;/code&gt; 함수 로 전달하기에 적합한 사전으로 반환하는 &lt;code&gt;.todict()&lt;/code&gt; 메서드가 있습니다.</target>
        </trans-unit>
        <trans-unit id="889c8c42cccc1d124561a48d8ca41abb6ac29d7b" translate="yes" xml:space="preserve">
          <source>Finally, a data type can describe items that are themselves arrays of items of another data type. These sub-arrays must, however, be of a fixed size.</source>
          <target state="translated">마지막으로, 데이터 유형은 다른 데이터 유형의 항목 배열 인 항목을 설명 할 수 있습니다. 그러나 이러한 하위 배열은 크기가 고정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="aa9d6cc4ce78cfcc5632e894bf62475be204d2f2" translate="yes" xml:space="preserve">
          <source>Finally, build an extension module using &lt;code&gt;f2py -c -m foo calculate.f&lt;/code&gt;</source>
          <target state="translated">마지막으로 &lt;code&gt;f2py -c -m foo calculate.f&lt;/code&gt; 를 사용하여 확장 모듈을 빌드합니다.</target>
        </trans-unit>
        <trans-unit id="8c4822ed4109421c2e3621bdd61e51416dfd1386" translate="yes" xml:space="preserve">
          <source>Finally, build the extension module using &lt;code&gt;f2py -c callback2.pyf callback.f&lt;/code&gt;.</source>
          <target state="translated">마지막으로 &lt;code&gt;f2py -c callback2.pyf callback.f&lt;/code&gt; 를 사용하여 확장 모듈을 빌드하십시오 .</target>
        </trans-unit>
        <trans-unit id="a4dd8d197deae557aaf37f23e5e903c7287b1045" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of NumPy, for example, the &lt;code&gt;core&lt;/code&gt; module, use the following:</source>
          <target state="translated">마지막으로 NumPy의 하위 집합 (예 : &lt;code&gt;core&lt;/code&gt; 모듈) 만 테스트하려는 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="591676022a4d7afed7631e7209e11f88a0c70ca2" translate="yes" xml:space="preserve">
          <source>Finally, if you are only interested in testing a subset of SciPy, for example, the &lt;code&gt;integrate&lt;/code&gt; module, use the following:</source>
          <target state="translated">마지막으로 &lt;code&gt;integrate&lt;/code&gt; 모듈과 같은 SciPy의 서브 세트 만 테스트하려는 경우 다음을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="7ffdd7c64bfdacea7dacfdba32a5f08b8fc22860" translate="yes" xml:space="preserve">
          <source>Finally, if you detect a typo or an error in the documentation, or would like to suggest a different approach, you can also open an issue or submit a pull request with your suggestion. Keep in mind that changes fixing grammatical/spelling errors are welcome but not necessarily the highest priority. &amp;ldquo;Grammatical correctness&amp;rdquo; often gets confused with &amp;ldquo;style&amp;rdquo; which can result in unfruitful discussions that don&amp;rsquo;t necessarily improve anything. Changes that modify wording or rearrange phrasing without changing the technical content are discouraged. If you think that a different wording improves clarity, you should open an issue as noted above, but again, changes along these lines very often tend to be highly subjective and not necessarily do much to improve the quality of the documentation.</source>
          <target state="translated">마지막으로 문서에서 오타 또는 오류를 감지하거나 다른 접근 방식을 제안하려는 경우 문제를 열거 나 제안과 함께 풀 요청을 제출할 수도 있습니다. 문법 / 맞춤법 오류를 수정하는 변경은 환영하지만 반드시 최우선 순위는 아님을 염두에 두시기 바랍니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ &quot;문법적 정확성&quot;은 &quot;스타일&quot;과 혼동되는 경우가 많기 때문에 반드시 어떤 것도 개선 할 수는없는 결실없는 토론으로 이어질 수 있습니다. 기술적 내용을 변경하지 않고 문구를 수정하거나 문구를 재배 열하는 변경은 권장되지 않습니다. 다른 표현이 명확성을 향상 시킨다고 생각하는 경우 위에서 언급 한대로 문제를 열어야하지만, 이러한 행을 따라 변경하는 것은 매우 주관적인 경향이 있으며 반드시 문서의 품질을 향상시키는 데 많은 도움이되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="3cd9ab198daaf3fb255075968e2a8d87bc37a3b9" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="translated">마지막으로, 그 강조 &lt;code&gt;v&lt;/code&gt; 의 이루어져 &lt;em&gt;오른쪽&lt;/em&gt; 의 고유 벡터 (우측에서와 같이) . 벡터 &lt;code&gt;y&lt;/code&gt; 를 만족하는 &lt;code&gt;dot(y.T, a) = z * y.T&lt;/code&gt; 어떤 번호에 대해 &lt;code&gt;z&lt;/code&gt; 불리며 &lt;em&gt;왼쪽&lt;/em&gt; 의 고유 벡터 각각 일반적으로 행렬의 좌측 및 우측 고유 벡터는 반드시 (아마도 접합체) 아니다, 및 전치 다른. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d65f378e68ed6a19a18dfdea402e5e3481327cbe" translate="yes" xml:space="preserve">
          <source>Finally, it is emphasized that &lt;code&gt;v&lt;/code&gt; consists of the &lt;em&gt;right&lt;/em&gt; (as in right-hand side) eigenvectors of &lt;code&gt;a&lt;/code&gt;. A vector &lt;code&gt;y&lt;/code&gt; satisfying &lt;code&gt;y.T @ a = z * y.T&lt;/code&gt; for some number &lt;code&gt;z&lt;/code&gt; is called a &lt;em&gt;left&lt;/em&gt; eigenvector of &lt;code&gt;a&lt;/code&gt;, and, in general, the left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate) transposes of each other.</source>
          <target state="translated">마지막으로, 그 강조 &lt;code&gt;v&lt;/code&gt; 의 이루어져 &lt;em&gt;오른쪽&lt;/em&gt; 의 고유 벡터 (우측에서와 같이) . 벡터 &lt;code&gt;y&lt;/code&gt; 를 만족 &lt;code&gt;y.T @ a = z * y.T&lt;/code&gt; 몇몇 개수에 대한 &lt;code&gt;z&lt;/code&gt; 착신되는 &lt;em&gt;왼쪽&lt;/em&gt; 의 고유 벡터 일반적으로 행렬의 좌측 및 우측 고유 벡터가 반드시 서로의 (아마도 접합체) 전치 아닌, 및. &lt;code&gt;a&lt;/code&gt; &lt;em&gt;&lt;/em&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7cc16b6bd7f60859052f3d3e721d3a31f9f6a180" translate="yes" xml:space="preserve">
          <source>Finally, now you are confident this tag correctly defines the source code that you released you can push the tag and release commit up to github:</source>
          <target state="translated">마지막으로 이제이 태그가 릴리스 한 소스 코드를 올바르게 정의한다고 확신합니다. 태그를 푸시하고 커밋을 github까지 릴리스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6153981fb1186c6a6c180fa5791ae775d104d070" translate="yes" xml:space="preserve">
          <source>Finally, remove the backup branch upon a successful rebase:</source>
          <target state="translated">마지막으로 리베이스가 성공하면 백업 브랜치를 제거합니다.</target>
        </trans-unit>
        <trans-unit id="98d9a64e4784c058720be52ad39c03d39a9fcbd1" translate="yes" xml:space="preserve">
          <source>Finally, specific entries can be masked and/or unmasked by assigning to the mask a sequence of booleans:</source>
          <target state="translated">마지막으로 특정 항목을 마스크에 일련의 부울을 할당하여 마스크 및 / 또는 마스크 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d63661f6815f6c84ea80e3487b297638030ca91" translate="yes" xml:space="preserve">
          <source>Finally, the committee will make a report to the NumPy Steering Council (as well as the NumPy core team in the event of an ongoing resolution, such as a ban).</source>
          <target state="translated">마지막으로위원회는 NumPy 운영위원회 (금지와 같은 지속적인 해결책이있는 경우 NumPy 핵심 팀)에보고 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="d4ee797bc2c97cc8f17d94ef802f458cb35c39bc" translate="yes" xml:space="preserve">
          <source>Finally, the decision is made about how to execute the looping mechanism to ensure that all elements of the input arrays are combined to produce the output arrays of the correct type. The options for loop execution are one-loop (for contiguous, aligned, and correct data type), strided-loop (for non-contiguous but still aligned and correct data type), and a buffered loop (for mis-aligned or incorrect data type situations). Depending on which execution method is called for, the loop is then setup and computed.</source>
          <target state="translated">마지막으로, 루핑 메커니즘을 실행하여 입력 배열의 모든 요소가 결합되어 올바른 유형의 출력 배열을 생성하는 방법에 대한 결정이 내려집니다. 루프 실행 옵션은 단일 루프 (연속, 정렬 및 올바른 데이터 유형의 경우), strided-loop (비 연속이지만 여전히 정렬 및 올바른 데이터 유형의 경우) 및 버퍼 루프 (오정렬 또는 잘못된 데이터의 경우)입니다. 유형 상황). 어떤 실행 방법이 필요한지에 따라 루프가 설정되고 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="75d671d62eb366ddccfcb1e2724191d1a472b131" translate="yes" xml:space="preserve">
          <source>Finally, the two functions to be exported by the interface can be written simply as:</source>
          <target state="translated">마지막으로 인터페이스에서 내보낼 두 함수는 다음과 같이 간단하게 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f06dcc2f32047bb203bf95d18ff9fb7501e8c9e4" translate="yes" xml:space="preserve">
          <source>Finally, to obtain the full approximated image, we need to reassemble these matrices into the approximation. Now, note that</source>
          <target state="translated">마지막으로 전체 근사 이미지를 얻으려면 이러한 행렬을 근사값으로 재 조립해야합니다. 이제</target>
        </trans-unit>
        <trans-unit id="9c273592d00189e2853888104625c36c4333a6db" translate="yes" xml:space="preserve">
          <source>Finally, we can use the &lt;a href=&quot;../reference/generated/numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;numpy.polyfit&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.polyval#numpy.polyval&quot;&gt;&lt;code&gt;numpy.polyval&lt;/code&gt;&lt;/a&gt; functions to create a cubic polynomial that fits the data as best as possible:</source>
          <target state="translated">마지막으로 &lt;a href=&quot;../reference/generated/numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;numpy.polyfit&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.polyval#numpy.polyval&quot;&gt; &lt;code&gt;numpy.polyval&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 가능한 한 데이터에 가장 잘 맞는 3 차 다항식을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3616e9f1dcf861efd823c12b4478a31e6b82b402" translate="yes" xml:space="preserve">
          <source>Financial functions</source>
          <target state="translated">재무 기능</target>
        </trans-unit>
        <trans-unit id="53f4aed5ee4b6d593eda026d381266350f216eeb" translate="yes" xml:space="preserve">
          <source>Financial functions removed</source>
          <target state="translated">재무 기능 제거</target>
        </trans-unit>
        <trans-unit id="e6c50d99742741634b01369176b77e9bcc5af665" translate="yes" xml:space="preserve">
          <source>Financial interests, such as investments, employment or contracting work, outside of The Project that may influence their work on The Project.</source>
          <target state="translated">프로젝트 작업에 영향을 미칠 수있는 프로젝트 외부의 투자, 고용 또는 계약 작업과 같은 재정적 이해 관계.</target>
        </trans-unit>
        <trans-unit id="eddebdeca9f674c3a8bdff9147a750bce04b0b48" translate="yes" xml:space="preserve">
          <source>Find a candidate who can serve as a mediator.</source>
          <target state="translated">중재자 역할을 할 수있는 후보자를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="75334f040026f76d3eebb8839bcb303508014551" translate="yes" xml:space="preserve">
          <source>Find a domain suitable for a polynomial or Chebyshev series defined at the values supplied.</source>
          <target state="translated">제공된 값으로 정의 된 다항식 또는 체비 쇼프 시리즈에 적합한 도메인을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="ed86545ba6a43e29b3c6f7f80bac3bf11a762f81" translate="yes" xml:space="preserve">
          <source>Find city hall</source>
          <target state="translated">시청 찾기</target>
        </trans-unit>
        <trans-unit id="c2a6e9c15d888c380a37d1831fa7891adeb9bb51" translate="yes" xml:space="preserve">
          <source>Find contiguous unmasked data in a masked array along the given axis.</source>
          <target state="translated">주어진 축을 따라 마스크 배열에서 연속 된 마스크되지 않은 데이터를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="a4ea5a445ce3dee9c559f1f1b3b7f52dca61477d" translate="yes" xml:space="preserve">
          <source>Find elements in a sorted array.</source>
          <target state="translated">정렬 된 배열에서 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="48cd38efe59f33f3a5f798ed6a4cf4880d549aa4" translate="yes" xml:space="preserve">
          <source>Find elements in sorted array.</source>
          <target state="translated">정렬 된 배열에서 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="849cceaee0015c567cd2b639a437c51378f0d9cf" translate="yes" xml:space="preserve">
          <source>Find historic buildings</source>
          <target state="translated">역사적인 건물 찾기</target>
        </trans-unit>
        <trans-unit id="f6a5d00a32b708a9fb964c2d1da18b0ebb9fba20" translate="yes" xml:space="preserve">
          <source>Find indices where elements of v should be inserted in a to maintain order.</source>
          <target state="translated">순서를 유지하기 위해 v의 요소를 삽입해야하는 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="18d914d41d09d92c97e462c896bc6019f8705e89" translate="yes" xml:space="preserve">
          <source>Find indices where elements should be inserted to maintain order.</source>
          <target state="translated">순서를 유지하기 위해 요소를 삽입해야하는 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="9f16fd78492b0e655d9646c090e0277fb4bab8b3" translate="yes" xml:space="preserve">
          <source>Find more information about &lt;a href=&quot;../reference/arrays.indexing#arrays-indexing&quot;&gt;newaxis here&lt;/a&gt; and &lt;code&gt;expand_dims&lt;/code&gt; at &lt;a href=&quot;../reference/generated/numpy.expand_dims#numpy.expand_dims&quot;&gt;&lt;code&gt;expand_dims&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 대한 추가 정보 찾기 &lt;a href=&quot;../reference/arrays.indexing#arrays-indexing&quot;&gt;여기 newaxis&lt;/a&gt; 및 &lt;code&gt;expand_dims&lt;/code&gt; 에서 &lt;a href=&quot;../reference/generated/numpy.expand_dims#numpy.expand_dims&quot;&gt; &lt;code&gt;expand_dims&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bffc9a9c895a2c22f043f2185910781b7e64c839" translate="yes" xml:space="preserve">
          <source>Find scenic lookouts</source>
          <target state="translated">경치 좋은 전망대 찾기</target>
        </trans-unit>
        <trans-unit id="4372485b0452a2bbbc2898c490d8eaeffc724caf" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with a given sequence of roots.</source>
          <target state="translated">주어진 근의 순서로 다항식의 계수를 구합니다.</target>
        </trans-unit>
        <trans-unit id="faa2e8dff7b7635f67ecf147d005df15f99ba737" translate="yes" xml:space="preserve">
          <source>Find the coefficients of a polynomial with the given sequence of roots.</source>
          <target state="translated">주어진 근의 순서로 다항식의 계수를 구합니다.</target>
        </trans-unit>
        <trans-unit id="026efa8f3fd4dbc6fed13cabe723d18d76b4e840" translate="yes" xml:space="preserve">
          <source>Find the court house</source>
          <target state="translated">법원 찾기</target>
        </trans-unit>
        <trans-unit id="4eb3d9e0549601789e7c859dc2344bd2a9cd19fd" translate="yes" xml:space="preserve">
          <source>Find the derivative of order &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">차수 &lt;code&gt;m&lt;/code&gt; 의 미분을 구합니다 .</target>
        </trans-unit>
        <trans-unit id="d4ef9328264dc057bcc77daf8eddd203dc0e44a3" translate="yes" xml:space="preserve">
          <source>Find the duplicates in a structured array along a given key</source>
          <target state="translated">주어진 키를 따라 구조화 된 배열에서 중복을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="8b2e68d5137b01880925e686f099633be3e06dde" translate="yes" xml:space="preserve">
          <source>Find the indices into a sorted array &lt;code&gt;a&lt;/code&gt; such that, if the corresponding elements in &lt;code&gt;v&lt;/code&gt; were inserted before the indices, the order of &lt;code&gt;a&lt;/code&gt; would be preserved.</source>
          <target state="translated">정렬 된 배열의 인덱스 찾기 의 해당 요소 경우 그에 따라, &lt;code&gt;v&lt;/code&gt; 인덱스 앞에 삽입하고, 순서 &lt;code&gt;a&lt;/code&gt; 유지 될있다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a9d95dd2166bd57167eb2521a394d4c2313d8ed" translate="yes" xml:space="preserve">
          <source>Find the indices of array elements that are non-zero, grouped by element.</source>
          <target state="translated">0이 아닌 배열 요소의 색인을 요소별로 그룹화하십시오.</target>
        </trans-unit>
        <trans-unit id="2515b150e246a2efffb14706325a36534baa7e52" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values along an axis.</source>
          <target state="translated">축을 따라 마스크되지 않은 첫 번째 값과 마지막 값의 인덱스를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="696f121ac590832370778adcb2254fdcf409cf46" translate="yes" xml:space="preserve">
          <source>Find the indices of the first and last unmasked values.</source>
          <target state="translated">마스크되지 않은 첫 번째 값과 마지막 값의 인덱스를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="8c77cbf79b427711a4234d92c8cd55031f045a5a" translate="yes" xml:space="preserve">
          <source>Find the intersection of two arrays.</source>
          <target state="translated">두 배열의 교집합을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1d747b61a4dca9ab1a6c9357e1706a93f4e98f6e" translate="yes" xml:space="preserve">
          <source>Find the product of two polynomials.</source>
          <target state="translated">두 다항식의 곱을 구합니다.</target>
        </trans-unit>
        <trans-unit id="f141aa841d4a25a7614625f7b95555f03b44cb1f" translate="yes" xml:space="preserve">
          <source>Find the roots:</source>
          <target state="translated">뿌리를 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="e641c4ed98de6b655c0148c1b174236bccd25db9" translate="yes" xml:space="preserve">
          <source>Find the set difference of two arrays.</source>
          <target state="translated">두 배열의 차 집합을 구합니다.</target>
        </trans-unit>
        <trans-unit id="1d47458289ee93eb8b76d9bd5fb051fb0ed38ef9" translate="yes" xml:space="preserve">
          <source>Find the set exclusive-or of two arrays.</source>
          <target state="translated">배타적 또는 두 배열의 집합을 찾습니다.</target>
        </trans-unit>
        <trans-unit id="40c6faf7e08f7eff45fa7f2fb510420c1dd0653b" translate="yes" xml:space="preserve">
          <source>Find the sum of two polynomials.</source>
          <target state="translated">두 다항식의 합을 구합니다.</target>
        </trans-unit>
        <trans-unit id="d221aaf14e3a3bbc1bc2f14e135dc72373d17a12" translate="yes" xml:space="preserve">
          <source>Find the town center</source>
          <target state="translated">타운 센터 찾기</target>
        </trans-unit>
        <trans-unit id="bc296de5854442d0290915421679a6d44da683c5" translate="yes" xml:space="preserve">
          <source>Find the union of two arrays.</source>
          <target state="translated">두 배열의 합집합을 찾으십시오.</target>
        </trans-unit>
        <trans-unit id="1c2a1d48695ed18506cd6bf1d2bc59c3cfb89875" translate="yes" xml:space="preserve">
          <source>Find the unique elements of an array.</source>
          <target state="translated">배열의 고유 한 요소를 찾습니다.</target>
        </trans-unit>
        <trans-unit id="3c5a640c918941c9e6a6ecbfe984c3f4bfbed0d7" translate="yes" xml:space="preserve">
          <source>Finding help</source>
          <target state="translated">도움 찾기</target>
        </trans-unit>
        <trans-unit id="5b7033e44afb091d2adc537dc898dc007a565a8f" translate="yes" xml:space="preserve">
          <source>Finding masked data</source>
          <target state="translated">마스크 된 데이터 찾기</target>
        </trans-unit>
        <trans-unit id="3f98684f09d3dc8ddcf467b643533c39f6675211" translate="yes" xml:space="preserve">
          <source>Finds the data type of smallest size and kind to which &lt;em&gt;type1&lt;/em&gt; and &lt;em&gt;type2&lt;/em&gt; may be safely converted. This function is symmetric and associative. A string or unicode result will be the proper size for storing the max value of the input types converted to a string or unicode.</source>
          <target state="translated">&lt;em&gt;type1&lt;/em&gt; 과 &lt;em&gt;type2&lt;/em&gt; 가 안전하게 변환 될 수있는 가장 작은 크기와 종류의 데이터 유형을 찾습니다 . 이 기능은 대칭적이고 연관성이 있습니다. 문자열 또는 유니 코드 결과는 문자열 또는 유니 코드로 변환 된 입력 유형의 최대 값을 저장하기에 적합한 크기입니다.</target>
        </trans-unit>
        <trans-unit id="ce819b28621d52328ceb9faf1bacb0b89098499a" translate="yes" xml:space="preserve">
          <source>Finds the polynomial resulting from the multiplication of the two input polynomials. Each input must be either a poly1d object or a 1D sequence of polynomial coefficients, from highest to lowest degree.</source>
          <target state="translated">두 입력 다항식의 곱셈에 따른 다항식을 찾습니다. 각 입력은 poly1d 객체이거나 다항식 계수의 1D 시퀀스 (최고도에서 최저도) 여야합니다.</target>
        </trans-unit>
        <trans-unit id="1b46b96bf59323c910259f84d4d30f9baf994f09" translate="yes" xml:space="preserve">
          <source>Finish the Release Note</source>
          <target state="translated">릴리스 노트 완료</target>
        </trans-unit>
        <trans-unit id="7f34df28a801d8ac2bf79f8d990420b3ba51454a" translate="yes" xml:space="preserve">
          <source>First adjusts the date to fall on a valid day according to the &lt;code&gt;roll&lt;/code&gt; rule, then applies offsets to the given dates counted in valid days.</source>
          <target state="translated">먼저 &lt;code&gt;roll&lt;/code&gt; 규칙 에 따라 유효 날짜에 해당하는 날짜를 조정 한 다음 유효 날짜로 계산 된 지정된 날짜에 오프셋을 적용합니다.</target>
        </trans-unit>
        <trans-unit id="3d783583ca6eea2b3fefbcfe238ea095a9cef1e3" translate="yes" xml:space="preserve">
          <source>First argument.</source>
          <target state="translated">첫 번째 주장.</target>
        </trans-unit>
        <trans-unit id="b0d88798d2f2c8c94dabdac74a6e61e0c6a796bf" translate="yes" xml:space="preserve">
          <source>First array</source>
          <target state="translated">첫 번째 배열</target>
        </trans-unit>
        <trans-unit id="6ac9adbced8bb3d28582fadcfc79411667f91541" translate="yes" xml:space="preserve">
          <source>First array elements raised to powers from second array, element-wise.</source>
          <target state="translated">첫 번째 배열 요소는 두 번째 배열에서 요소 단위로 제곱됩니다.</target>
        </trans-unit>
        <trans-unit id="2e663054d84a3a5ee1c34a1c08db3c0840bbd3a5" translate="yes" xml:space="preserve">
          <source>First axis.</source>
          <target state="translated">첫 번째 축.</target>
        </trans-unit>
        <trans-unit id="683b791e072100a372b3bb52b18b0195b72f135d" translate="yes" xml:space="preserve">
          <source>First data type.</source>
          <target state="translated">첫 번째 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="2f5593286aa09632868779a76ded4fea07d63a2f" translate="yes" xml:space="preserve">
          <source>First fork NumPy into your account, as from &lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;Create a NumPy fork&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;NumPy 포크 만들기&lt;/a&gt; 에서와 같이 먼저 NumPy를 계정에 포크하십시오 .</target>
        </trans-unit>
        <trans-unit id="380b7446c9b92904f875ef654f53dbe5211d262c" translate="yes" xml:space="preserve">
          <source>First fork NumPy into your account, as from &lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;.</source>
          <target state="translated">먼저 NumPy를 &lt;a href=&quot;gitwash/development_setup#forking&quot;&gt;자신의 복사본 (포크) 만들기&lt;/a&gt; 에서와 같이 계정에 NumPy를 포크 합니다.</target>
        </trans-unit>
        <trans-unit id="c696689a14b681bedf220e6fcb537947492362e7" translate="yes" xml:space="preserve">
          <source>First input vector. Input is flattened if not already 1-dimensional.</source>
          <target state="translated">첫 번째 입력 벡터. 1 차원이 아닌 경우 입력이 전개됩니다.</target>
        </trans-unit>
        <trans-unit id="4da5db5b8e385a1ee882571360fd0091e5988af4" translate="yes" xml:space="preserve">
          <source>First mode, &lt;code&gt;buffer&lt;/code&gt; is None:</source>
          <target state="translated">첫 번째 모드, &lt;code&gt;buffer&lt;/code&gt; 는 없음 :</target>
        </trans-unit>
        <trans-unit id="79fb79c693534cb9180b2dc2b3dd92f6526ad678" translate="yes" xml:space="preserve">
          <source>First of all, if confused or uncertain, definitely look at the Examples - in its full generality, this function is less simple than it might seem from the following code description (below ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt;):</source>
          <target state="translated">우선, 혼란 스럽거나 불확실한 경우에는 예제를 살펴보십시오. 전체적으로 일반적으로이 함수는 다음 코드 설명 (ndi = &lt;code&gt;numpy.lib.index_tricks&lt;/code&gt; 아래)에서 볼 수있는 것보다 덜 간단합니다 .</target>
        </trans-unit>
        <trans-unit id="9433246b482b8fe4fa411d4c3c0f41d069086c3e" translate="yes" xml:space="preserve">
          <source>First of all, we can plot the whole set of data we have and see what it looks like. In order to get a readable plot, we select only a few of the dates to show in our &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.xticks.html#matplotlib.pyplot.xticks&quot;&gt;&lt;code&gt;x-axis ticks&lt;/code&gt;&lt;/a&gt;. Note also that in our plot command, we use &lt;code&gt;nbcases.T&lt;/code&gt; (the transpose of the &lt;code&gt;nbcases&lt;/code&gt; array) since this means we will plot each row of the file as a separate line. We choose to plot a dashed line (using the &lt;code&gt;'--'&lt;/code&gt; line style). See the &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; documentation for more info on this.</source>
          <target state="translated">우선, 우리가 가지고있는 전체 데이터 세트를 플로팅하고 그것이 어떻게 생겼는지 볼 수 있습니다. 읽을 수있는 플롯을 얻기 위해 &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.xticks.html#matplotlib.pyplot.xticks&quot;&gt; &lt;code&gt;x-axis ticks&lt;/code&gt; &lt;/a&gt; 에 표시 할 날짜 중 몇 개만 선택합니다 . 또한 plot 명령에서 &lt;code&gt;nbcases.T&lt;/code&gt; ( &lt;code&gt;nbcases&lt;/code&gt; 배열 의 전치)를 사용합니다. 이는 파일의 각 행을 별도의 줄로 플로팅한다는 것을 의미하기 때문입니다. &lt;code&gt;'--'&lt;/code&gt; 선 스타일을 사용하여 점선을 플로팅하도록 선택합니다 . 이에 대한 자세한 정보 는 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9507aadaef3c19b4ad781014173284bb4bf64a4d" translate="yes" xml:space="preserve">
          <source>First one-dimensional input array.</source>
          <target state="translated">최초의 1 차원 입력 배열.</target>
        </trans-unit>
        <trans-unit id="563237e589c4b3a10445b43e30dbcdf140e6cad9" translate="yes" xml:space="preserve">
          <source>First we need a polynomial class and a polynomial instance to play with. The classes can be imported directly from the polynomial package or from the module of the relevant type. Here we import from the package and use the conventional Polynomial class because of its familiarity:</source>
          <target state="translated">먼저 다항식 클래스와 다항식 인스턴스가 필요합니다. 클래스는 다항식 패키지 또는 관련 유형의 모듈에서 직접 가져올 수 있습니다. 여기서 우리는 패키지에서 가져 와서 친숙 함으로 인해 기존의 다항식 클래스를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b0f42fa2b5b73e0d242583740b22144cb029b3bc" translate="yes" xml:space="preserve">
          <source>First you follow the instructions for &lt;a href=&quot;#forking&quot;&gt;Making your own copy (fork) of NumPy&lt;/a&gt;.</source>
          <target state="translated">먼저 &lt;a href=&quot;#forking&quot;&gt;NumPy 자신 만의 복사본 만들기 (포크)&lt;/a&gt; 지침을 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="a78e460dd4b928f74942152fb57a017ad1190035" translate="yes" xml:space="preserve">
          <source>First, change/check the following variables in &lt;code&gt;pavement.py&lt;/code&gt; depending on the release version:</source>
          <target state="translated">먼저 릴리스 버전에 따라 &lt;code&gt;pavement.py&lt;/code&gt; 에서 다음 변수를 변경 / 확인합니다 .</target>
        </trans-unit>
        <trans-unit id="5de2ca0c3525a19f6ce453df437f39312ae63f64" translate="yes" xml:space="preserve">
          <source>First, fetch new commits from the &lt;code&gt;upstream&lt;/code&gt; repository:</source>
          <target state="translated">먼저 &lt;code&gt;upstream&lt;/code&gt; 저장소 에서 새 커밋을 가져옵니다 .</target>
        </trans-unit>
        <trans-unit id="cb7560a3397ca22e9994a5b8700ca3649fe54f4e" translate="yes" xml:space="preserve">
          <source>First, let&amp;rsquo;s check for the shape of the data in our array. Since this image is two-dimensional (the pixels in the image form a rectangle), we might expect a two-dimensional array to represent it (a matrix). However, using the &lt;code&gt;shape&lt;/code&gt; property of this NumPy array gives us a different result:</source>
          <target state="translated">먼저 배열에서 데이터의 모양을 확인하겠습니다. 이 이미지는 2 차원 (이미지의 픽셀이 직사각형을 형성 함)이므로이를 나타내는 2 차원 배열 (행렬)을 기대할 수 있습니다. 그러나이 NumPy 배열 의 &lt;code&gt;shape&lt;/code&gt; 속성을 사용하면 다른 결과를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e842f4efdaf87bde11917dd06d4d96aa743693a2" translate="yes" xml:space="preserve">
          <source>First, merge or rebase on the target branch.</source>
          <target state="translated">먼저 대상 브랜치를 병합하거나 리베이스하십시오.</target>
        </trans-unit>
        <trans-unit id="3d50e07ef0974f6c61f9887836f0cd195c4b8ffe" translate="yes" xml:space="preserve">
          <source>First, we create a signature file from &lt;code&gt;fib1.f&lt;/code&gt; by running</source>
          <target state="translated">먼저 &lt;code&gt;fib1.f&lt;/code&gt; 을 실행 하여 fib1.f 에서 서명 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="0b5747b08f0749ca8d3f849c4ccb46feb2a535fd" translate="yes" xml:space="preserve">
          <source>First, we solve for</source>
          <target state="translated">먼저 우리는</target>
        </trans-unit>
        <trans-unit id="e249ead6928b839ca62de533f2a7083c8c2ba345" translate="yes" xml:space="preserve">
          <source>First, we&amp;rsquo;ll identify the indices of locations in mainland China:</source>
          <target state="translated">먼저 중국 본토의 위치 색인을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="2db03d669f6d38f72ba0afd2d06c9fa6852bb990" translate="yes" xml:space="preserve">
          <source>First, you need to make the branch you will work on. This needs to be based on the older version of NumPy (not master):</source>
          <target state="translated">먼저 작업 할 브랜치를 만들어야합니다. 이는 이전 버전의 NumPy (마스터가 아님)를 기반으로해야합니다.</target>
        </trans-unit>
        <trans-unit id="2b876747d103212266850792bf08c2d985fdb7ec" translate="yes" xml:space="preserve">
          <source>Fisher, R.A,, A.S. Corbet, and C.B. Williams. 1943. The relation between the number of species and the number of individuals in a random sample of an animal population. Journal of Animal Ecology, 12:42-58.</source>
          <target state="translated">Fisher, RA, AS Corbet 및 CB Williams. 동물 집단의 무작위 표본에서 종의 수와 개인의 수 사이의 관계. 동물 생태 저널, 12 : 42-58.</target>
        </trans-unit>
        <trans-unit id="1c009756385026adf817423fdf3347327b7bcadd" translate="yes" xml:space="preserve">
          <source>Fit a line, &lt;code&gt;y = mx + c&lt;/code&gt;, through some noisy data-points:</source>
          <target state="translated">노이즈가 많은 데이터 포인트를 통해 &lt;code&gt;y = mx + c&lt;/code&gt; 선을 맞추십시오 .</target>
        </trans-unit>
        <trans-unit id="04b6a58e5360946679575e2105b73e661e63702d" translate="yes" xml:space="preserve">
          <source>Fit a polynomial &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; of degree &lt;code&gt;deg&lt;/code&gt; to points &lt;code&gt;(x, y)&lt;/code&gt;. Returns a vector of coefficients &lt;code&gt;p&lt;/code&gt; that minimises the squared error in the order &lt;code&gt;deg&lt;/code&gt;, &lt;code&gt;deg-1&lt;/code&gt;, &amp;hellip; &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">맞는 다항식 &lt;code&gt;p(x) = p[0] * x**deg + ... + p[deg]&lt;/code&gt; 정도 &lt;code&gt;deg&lt;/code&gt; 점 &lt;code&gt;(x, y)&lt;/code&gt; . &lt;code&gt;deg&lt;/code&gt; , &lt;code&gt;deg-1&lt;/code&gt; ,&amp;hellip; &lt;code&gt;0&lt;/code&gt; 순서로 제곱 오차를 최소화하는 계수 &lt;code&gt;p&lt;/code&gt; 로 구성된 벡터를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="c63bb8e80d7458f568a44355aa0204375070cb16" translate="yes" xml:space="preserve">
          <source>Fits using Chebyshev series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">체비 쇼프 시리즈를 사용하는 피팅은 일반적으로 파워 시리즈를 사용하는 피팅보다 더 잘 조절되지만 샘플 포인트의 분포와 데이터의 부드러움에 따라 달라질 수 있습니다. 피팅의 품질이 적절하지 않으면 스플라인이 좋은 대안이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aed614e2e664ebb51dcf5d13afb77c7acb23c65a" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Hermite 시리즈를 사용하는 피팅은 데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사화 될 수있을 때 가장 유용 할 것입니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 Hermite 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt; 와 함께 사용해야합니다 . 무게 기능은 &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt; &lt;code&gt;hermweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7ac350719f356e32b4a5aa08bc22f253d0d0c702" translate="yes" xml:space="preserve">
          <source>Fits using Hermite series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Hermite weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt;&lt;code&gt;hermweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터를 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사 할 수있을 때 Hermite 시리즈를 사용한 피팅이 가장 유용 할 수 있습니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 Hermite 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 와 함께 사용해야하며 가중치 함수는 &lt;a href=&quot;numpy.polynomial.hermite.hermweight#numpy.polynomial.hermite.hermweight&quot;&gt; &lt;code&gt;hermweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2a56ae26ef02f4f89e7f11d94ca2c9c2304108b1" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HermiteE 시리즈를 사용하는 피팅은 아마도 데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사화 될 수있을 때 가장 유용 할 것입니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 HermiteE 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt; 와 함께 사용해야합니다 . 무게 기능은 &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt; &lt;code&gt;hermeweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="676d43f6371871e1abab21b58a8b9ef9e5c444e9" translate="yes" xml:space="preserve">
          <source>Fits using HermiteE series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the HermiteE weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt;&lt;code&gt;hermeweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사 될 수있는 경우 HermiteE 계열을 사용한 적합이 가장 유용 할 수 있습니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 HermiteE 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 와 함께 사용해야합니다 . 가중 함수는 &lt;a href=&quot;numpy.polynomial.hermite_e.hermeweight#numpy.polynomial.hermite_e.hermeweight&quot;&gt; &lt;code&gt;hermeweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ce120ffeca412ba96243f730c358ebc5c1bfbf99" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Laguerre 시리즈를 사용하는 적합치는 아마도 데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사화 될 수있을 때 가장 유용 할 것입니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 Laguerre 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i]))&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i]))&lt;/code&gt; 와 함께 사용해야합니다 . 가중치 함수는 &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt; &lt;code&gt;lagweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a6ad2d45b7ba84d02856af83a31db48500b6c521" translate="yes" xml:space="preserve">
          <source>Fits using Laguerre series are probably most useful when the data can be approximated by &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt;, where &lt;code&gt;w(x)&lt;/code&gt; is the Laguerre weight. In that case the weight &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; should be used together with data values &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt;. The weight function is available as &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt;&lt;code&gt;lagweight&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 &lt;code&gt;sqrt(w(x)) * p(x)&lt;/code&gt; 로 근사 될 수있을 때 Laguerre 계열을 사용한 적합이 가장 유용 할 수 있습니다 . 여기서 &lt;code&gt;w(x)&lt;/code&gt; 는 Laguerre 가중치입니다. 이 경우 가중치 &lt;code&gt;sqrt(w(x[i])&lt;/code&gt; 는 데이터 값 &lt;code&gt;y[i]/sqrt(w(x[i])&lt;/code&gt; 와 함께 사용해야하며 가중치 함수는 &lt;a href=&quot;numpy.polynomial.laguerre.lagweight#numpy.polynomial.laguerre.lagweight&quot;&gt; &lt;code&gt;lagweight&lt;/code&gt; &lt;/a&gt; 로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a49cebd2c0a64b6ed696a25d8e9c66d10c8d54a0" translate="yes" xml:space="preserve">
          <source>Fits using Legendre series are usually better conditioned than fits using power series, but much can depend on the distribution of the sample points and the smoothness of the data. If the quality of the fit is inadequate splines may be a good alternative.</source>
          <target state="translated">Legendre 계열을 사용한 적합은 일반적으로 검정력 계열을 사용하는 적합보다 잘 조정되지만 표본 점의 분포와 데이터의 평활도에 따라 크게 달라질 수 있습니다. 피팅의 품질이 적절하지 않으면 스플라인이 좋은 대안이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5165daf49b08b1322899a60f534d050a344807b1" translate="yes" xml:space="preserve">
          <source>Fitting</source>
          <target state="translated">Fitting</target>
        </trans-unit>
        <trans-unit id="64c14ba9774170afd08838cb0f853f190269a6cb" translate="yes" xml:space="preserve">
          <source>Fitting Data</source>
          <target state="translated">피팅 데이터</target>
        </trans-unit>
        <trans-unit id="5e51f96db68dc8fabd62d003884216322595fc6f" translate="yes" xml:space="preserve">
          <source>Fitting is the reason that the &lt;code&gt;domain&lt;/code&gt; and &lt;code&gt;window&lt;/code&gt; attributes are part of the convenience classes. To illustrate the problem, the values of the Chebyshev polynomials up to degree 5 are plotted below.</source>
          <target state="translated">피팅은 &lt;code&gt;domain&lt;/code&gt; 및 &lt;code&gt;window&lt;/code&gt; 속성이 편의 클래스의 일부인 이유입니다 . 문제를 설명하기 위해 최대 5도까지 체비 쇼프 다항식의 값이 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a882b40f9b004c60f42b6ed77cd0d0cb856640fe" translate="yes" xml:space="preserve">
          <source>Fix for PPC long double floating point information</source>
          <target state="translated">PPC long double 부동 소수점 정보 수정</target>
        </trans-unit>
        <trans-unit id="919c4e1e9eb76e3cc1d2c2a8e361176acc1a9a4a" translate="yes" xml:space="preserve">
          <source>Fix regression in matmul (&lt;code&gt;@&lt;/code&gt; operator) for boolean types</source>
          <target state="translated">부울 유형에 대한 matmul ( &lt;code&gt;@&lt;/code&gt; 연산자)의 회귀 수정</target>
        </trans-unit>
        <trans-unit id="0f0d59fd522286a2d4031174470931df04c244c1" translate="yes" xml:space="preserve">
          <source>Fix swig bug in &lt;code&gt;numpy.i&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 에서 swig 버그 수정</target>
        </trans-unit>
        <trans-unit id="f95e31f1005ee116c93848080ddafc6a63474e8a" translate="yes" xml:space="preserve">
          <source>Fix to financial.npv</source>
          <target state="translated">financial.npv 수정</target>
        </trans-unit>
        <trans-unit id="fe4ad4288a37cfec787d6b9ab856b537a200ab81" translate="yes" xml:space="preserve">
          <source>Fixed &lt;code&gt;eigh&lt;/code&gt; and &lt;code&gt;cholesky&lt;/code&gt; methods in &lt;code&gt;numpy.random.multivariate_normal&lt;/code&gt;</source>
          <target state="translated">고정 &lt;code&gt;eigh&lt;/code&gt; 및 &lt;code&gt;cholesky&lt;/code&gt; 의 방법 &lt;code&gt;numpy.random.multivariate_normal&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4fa2ab2730080c4d8658ad57247e52d05152019e" translate="yes" xml:space="preserve">
          <source>Fixed stride displacement from the beginning of an axis? Default is 0. Needs to be &amp;gt;=0.</source>
          <target state="translated">축의 시작에서 보폭이 수정 되었습니까? 기본값은 0입니다.&amp;gt; = 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb2453cbdd88f7c5dbf744844c92b0eb5d9399b7" translate="yes" xml:space="preserve">
          <source>Fixed the jumping implementation in &lt;code&gt;MT19937.jumped&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;MT19937.jumped&lt;/code&gt; 에서 점프 구현을 수정했습니다.</target>
        </trans-unit>
        <trans-unit id="8028cdac733fedf53d18c62ba8dde19dd4874832" translate="yes" xml:space="preserve">
          <source>Fixes Merged</source>
          <target state="translated">병합 된 수정</target>
        </trans-unit>
        <trans-unit id="988fef1858095167d23aba7f3c43fc27915118e8" translate="yes" xml:space="preserve">
          <source>Fixing Warnings</source>
          <target state="translated">경고 수정</target>
        </trans-unit>
        <trans-unit id="35076585aaced59b92c591cb61ebdef18acdfe9a" translate="yes" xml:space="preserve">
          <source>Flag checking</source>
          <target state="translated">플래그 확인</target>
        </trans-unit>
        <trans-unit id="a59933a6089d6095752a4cce71d3ac903e7e62ac" translate="yes" xml:space="preserve">
          <source>Flag indicating the return a legacy tuple state when the BitGenerator is MT19937.</source>
          <target state="translated">BitGenerator가 MT19937 일 때 레거시 튜플 상태를 반환 함을 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="ed451b4de2e9f4e89792baf70b0beefe2ddce512" translate="yes" xml:space="preserve">
          <source>Flag indicating to return a legacy tuple state when the BitGenerator is MT19937, instead of a dict.</source>
          <target state="translated">BitGenerator가 dict 대신 MT19937 일 때 레거시 튜플 상태를 반환하도록 나타내는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="9eae779d408b29132a4d17f05274c96311b19164" translate="yes" xml:space="preserve">
          <source>Flag indicating whether a tuple &lt;code&gt;(result, sum of weights)&lt;/code&gt; should be returned as output (True), or just the result (False). Default is False.</source>
          <target state="translated">튜플 &lt;code&gt;(result, sum of weights)&lt;/code&gt; 을 출력 (True) 또는 결과 (False)로 반환 해야하는지 여부를 나타내는 플래그 입니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="cba3c052d7e9a9fd1a29828876ef83802ed53ad9" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark test as deprecated or not. If the condition is a callable, it is used at runtime to dynamically make the decision. Default is True.</source>
          <target state="translated">테스트를 더 이상 사용되지 않는 것으로 표시할지 여부를 결정하는 플래그입니다. 조건이 호출 가능한 경우 런타임에 동적으로 결정을 내리는 데 사용됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="fc63716a41208b1dbc0ebbf61137c2d0ff0fbfd4" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to mark the decorated test as a known failure (if True) or not (if False).</source>
          <target state="translated">데코 레이팅 된 테스트를 알려진 실패로 표시할지 (True 인 경우) 표시하지 않을지 (False 인 경우)를 결정하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="3a36aef11ecfbbf2d82d57b5084b3ab96e773b04" translate="yes" xml:space="preserve">
          <source>Flag to determine whether to skip the decorated test.</source>
          <target state="translated">데코 레이팅 된 테스트를 건너 뛸지 여부를 결정하는 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="75e57359674e825c88bcaaa1bf354a5ba42abc10" translate="yes" xml:space="preserve">
          <source>Flag-like constants</source>
          <target state="translated">플래그와 같은 상수</target>
        </trans-unit>
        <trans-unit id="684f757afc22b26a0ad180a11e58599da12d805b" translate="yes" xml:space="preserve">
          <source>Flags indicating how the memory pointed to by data is to be interpreted. Possible flags are &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터가 가리키는 메모리를 해석하는 방법을 나타내는 플래그. 가능한 플래그는 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_C_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_C_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="a25e18657a4cd94e4091eda9ea0dfb9fbc2878ec" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt; are any combination of the global and per-operand flags documented in &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;, except for &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">에 전달 될 수 플래그 &lt;code&gt;flags&lt;/code&gt; 에서 설명하는 글로벌 및 당 연산 플래그의 조합입니다 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; 를 제외하고, &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="edc811e4e9d890d1a74c59122b943f93451db31b" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;flags&lt;/code&gt;, applying to the whole iterator, are:</source>
          <target state="translated">전체 반복자에 적용 되는 &lt;code&gt;flags&lt;/code&gt; 로 전달 될 수있는 플래그 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e576896ed3787e8ae91c02c3fee7275b55ae4f5d" translate="yes" xml:space="preserve">
          <source>Flags that may be passed in &lt;code&gt;op_flags[i]&lt;/code&gt;, where &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;op_flags[i]&lt;/code&gt; 로 전달 될 수있는 플래그 , 여기서 &lt;code&gt;0 &amp;lt;= i &amp;lt; nop&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0902dde9b75159ba7b0f6af69bd12aa3aed3ab46" translate="yes" xml:space="preserve">
          <source>Flags to control the behavior of the iterator.</source>
          <target state="translated">반복자의 동작을 제어하는 ​​플래그입니다.</target>
        </trans-unit>
        <trans-unit id="1bbaad527fcacc3d77ae0f546c2f20b2e4ef2d71" translate="yes" xml:space="preserve">
          <source>Flat Iterator indexing</source>
          <target state="translated">플랫 이터레이터 인덱싱</target>
        </trans-unit>
        <trans-unit id="ca0541280577eeacfb45501ad1950007e690905f" translate="yes" xml:space="preserve">
          <source>Flat array iterator.</source>
          <target state="translated">플랫 배열 반복자.</target>
        </trans-unit>
        <trans-unit id="3f8292fdeb383ecef90303832ffb1117799af185" translate="yes" xml:space="preserve">
          <source>Flat iteration</source>
          <target state="translated">플랫 반복</target>
        </trans-unit>
        <trans-unit id="666002e8705384831180e281fa74a843e3206b27" translate="yes" xml:space="preserve">
          <source>Flat iterator object to iterate over arrays.</source>
          <target state="translated">배열을 반복하는 플랫 반복자 객체.</target>
        </trans-unit>
        <trans-unit id="7d04e81220d975aa709532a3862f6c1a6f4a3f05" translate="yes" xml:space="preserve">
          <source>Flatten a structured data-type description.</source>
          <target state="translated">구조화 된 데이터 유형 설명을 평면화합니다.</target>
        </trans-unit>
        <trans-unit id="ec4ad130c0f4e03f5e84c5e86d9264a95dc6c3f6" translate="yes" xml:space="preserve">
          <source>Flattened version of this function.</source>
          <target state="translated">이 기능의 평탄화 된 버전.</target>
        </trans-unit>
        <trans-unit id="7b96969ab0c9b27da6b409485f5b0236b7c2a6ed" translate="yes" xml:space="preserve">
          <source>Flattening collapses a multimdimensional array to a single dimension; details of how this is done (for instance, whether &lt;code&gt;a[n+1]&lt;/code&gt; should be the next row or next column) are parameters.</source>
          <target state="translated">병합은 다차원 배열을 단일 차원으로 축소합니다. 이것이 수행되는 방법에 대한 세부 사항 (예 : &lt;code&gt;a[n+1]&lt;/code&gt; 이 다음 행인지 다음 열 인지 여부 )는 매개 변수입니다.</target>
        </trans-unit>
        <trans-unit id="21fe615f2b66ecf8096308ee67f646d6664a1077" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally (axis=1).</source>
          <target state="translated">배열을 가로로 뒤집습니다 (축 = 1).</target>
        </trans-unit>
        <trans-unit id="7849c3ad46cd56097aefd350ce5a24872c1a9619" translate="yes" xml:space="preserve">
          <source>Flip an array horizontally.</source>
          <target state="translated">배열을 가로로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="a25cec9261711d7c64f4f0328d27630ff4251008" translate="yes" xml:space="preserve">
          <source>Flip an array vertically (axis=0).</source>
          <target state="translated">배열을 세로로 뒤집습니다 (축 = 0).</target>
        </trans-unit>
        <trans-unit id="58f1196dc69384b1c0ff7122abf54115c6fe24e6" translate="yes" xml:space="preserve">
          <source>Flip an array vertically.</source>
          <target state="translated">배열을 수직으로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="054ba7b0cd3f0b3aa1e4b17f975a52c4e03f8b87" translate="yes" xml:space="preserve">
          <source>Flip array in the left/right direction.</source>
          <target state="translated">왼쪽 / 오른쪽 방향으로 배열을 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="a71aa214a7a981c7e5292f4c8603043e9a55d042" translate="yes" xml:space="preserve">
          <source>Flip array in the up/down direction.</source>
          <target state="translated">어레이를 위 / 아래 방향으로 뒤집습니다.</target>
        </trans-unit>
        <trans-unit id="d6b601389a5cfb7f115ef7332083ae3431e4e4e3" translate="yes" xml:space="preserve">
          <source>Flip the entries in each column in the up/down direction. Rows are preserved, but appear in a different order than before.</source>
          <target state="translated">각 열의 항목을 위 / 아래 방향으로 뒤집습니다. 행은 유지되지만 이전과 다른 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="f14bb6de935d5a8cea7f1dc6e4323a38f4e11462" translate="yes" xml:space="preserve">
          <source>Flip the entries in each row in the left/right direction. Columns are preserved, but appear in a different order than before.</source>
          <target state="translated">각 행의 항목을 왼쪽 / 오른쪽 방향으로 뒤집습니다. 열은 유지되지만 이전과 다른 순서로 나타납니다.</target>
        </trans-unit>
        <trans-unit id="a806413f7b898c72fd5e92970c2a0a0a31830c28" translate="yes" xml:space="preserve">
          <source>Float printing now uses &amp;ldquo;dragon4&amp;rdquo; algorithm for shortest decimal representation</source>
          <target state="translated">플로트 인쇄는 이제 최단 십진 표현을 위해 &quot;dragon4&quot;알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3a7d4f9efa22847d513f86cb336f4d917bb3ff00" translate="yes" xml:space="preserve">
          <source>Float type code to coerce input array &lt;code&gt;a&lt;/code&gt;. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is one of the &amp;lsquo;int&amp;rsquo; dtypes, it is replaced with float64.</source>
          <target state="translated">입력 배열을 강제 변환하는 부동 유형 코드 &lt;code&gt;a&lt;/code&gt; . &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 'int'dtype 중 하나 인 경우 float64로 바뀝니다.</target>
        </trans-unit>
        <trans-unit id="01625a6e71519a2c19afcda12e2e9da94df799dc" translate="yes" xml:space="preserve">
          <source>Floating functions</source>
          <target state="translated">플로팅 기능</target>
        </trans-unit>
        <trans-unit id="0c47a1b436ef0cc135c28b0dd8fa381311e23c7a" translate="yes" xml:space="preserve">
          <source>Floating point</source>
          <target state="translated">부동 소수점</target>
        </trans-unit>
        <trans-unit id="1229245ed91cf5c1f6662011b64e640e64679fd2" translate="yes" xml:space="preserve">
          <source>Floating point classification</source>
          <target state="translated">부동 소수점 분류</target>
        </trans-unit>
        <trans-unit id="82951541de1b33acb443a62a7f1b908de9e19ba0" translate="yes" xml:space="preserve">
          <source>Floating point error handling</source>
          <target state="translated">부동 소수점 오류 처리</target>
        </trans-unit>
        <trans-unit id="dbe05d916add7aed11140c3ac753c505841f4681" translate="yes" xml:space="preserve">
          <source>Floating point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] usable floating value).</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;beta**minexp&lt;/code&gt; (사용 가능한 가장 작은 [크기]) 부동 값.</target>
        </trans-unit>
        <trans-unit id="1fd86bfd9f81a559ed8b4c9674c5d1f9e823b143" translate="yes" xml:space="preserve">
          <source>Floating point precision can be set:</source>
          <target state="translated">부동 소수점 정밀도를 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="481d82b2ccb68e7d8e1fe5eda973bb77f53833f0" translate="yes" xml:space="preserve">
          <source>Floating point precision. Defaults to &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 정밀도. 기본값은 &lt;code&gt;numpy.get_printoptions()['precision']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="6770ad9e8703a79e53fa3beb7d8e8f53215f921c" translate="yes" xml:space="preserve">
          <source>Floating point routines</source>
          <target state="translated">부동 소수점 루틴</target>
        </trans-unit>
        <trans-unit id="a8d35036268d7e5fa8b38b4abd4d049aeafa51d6" translate="yes" xml:space="preserve">
          <source>Floating point scalars implement &lt;code&gt;as_integer_ratio&lt;/code&gt; to match the builtin float</source>
          <target state="translated">부동 소수점 스칼라 는 내장 부동 소수점과 일치하도록 &lt;code&gt;as_integer_ratio&lt;/code&gt; 를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="bbb20a81d8b5780d9de2483bc5cafd120d0cd965" translate="yes" xml:space="preserve">
          <source>Floating point values are not demoted to integers, and complex values are not demoted to floats.</source>
          <target state="translated">부동 소수점 값은 정수로 강등되지 않으며 복소수 값은 부동 소수점으로 강등되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2a6aa48e3a6c80756547c7551fe79b07bb4f3a1c" translate="yes" xml:space="preserve">
          <source>Floating values between -1 and 1. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">-1과 1 사이의 부동 소수점 값 &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="e6f0281f3f5728d7cb1a3465fbf569e0196bf3cd" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**machep&lt;/code&gt; (floating point precision)</source>
          <target state="translated">부동 소수 점수 &lt;code&gt;beta**machep&lt;/code&gt; (부동 소수 점수)</target>
        </trans-unit>
        <trans-unit id="8c170a74ff7bf0743ef67475a7fd14e3feeea278" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**minexp&lt;/code&gt; (the smallest [in magnitude] positive floating point number with full precision).</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;beta**minexp&lt;/code&gt; (전체 정밀도의 가장 작은 [크기] 양의 부동 소수점 숫자).</target>
        </trans-unit>
        <trans-unit id="f8899b4f72c4b482d21d27616c70625d6596dd90" translate="yes" xml:space="preserve">
          <source>Floating-point number &lt;code&gt;beta**negep&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 숫자 &lt;code&gt;beta**negep&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2eae9dc4dc291f4562016bea57ea67a7a3b1f88f" translate="yes" xml:space="preserve">
          <source>Floating-point numbers:</source>
          <target state="translated">부동 소수점 숫자 :</target>
        </trans-unit>
        <trans-unit id="2a9bb411b345b451f4de56294a2e04b8bb44acd7" translate="yes" xml:space="preserve">
          <source>Floating-point types</source>
          <target state="translated">부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="55734ad7ec5ec7776c0a844d3df4e815b482074b" translate="yes" xml:space="preserve">
          <source>Floats uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">플로트는 &lt;code&gt;[0, 1)&lt;/code&gt; 균일하게 분포되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c505c67e9b4dbb54495e1dc42c80f1a7a1c454f" translate="yes" xml:space="preserve">
          <source>Floor divide self by other in-place.</source>
          <target state="translated">바닥은 다른 장소로 자기를 나눕니다.</target>
        </trans-unit>
        <trans-unit id="1ddc7d58e45f89f16199c2075dcd43275a50c059" translate="yes" xml:space="preserve">
          <source>Floor division, &amp;lsquo;//&amp;rsquo;, is the division operator for the polynomial classes, polynomials are treated like integers in this regard. For Python versions &amp;lt; 3.x the &amp;lsquo;/&amp;rsquo; operator maps to &amp;lsquo;//&amp;rsquo;, as it does for Python, for later versions the &amp;lsquo;/&amp;rsquo; will only work for division by scalars. At some point it will be deprecated:</source>
          <target state="translated">플로어 나누기 '//'는 다항식 클래스의 나누기 연산자이며, 다항식은 이와 관련하여 정수처럼 취급됩니다. Python 버전 &amp;lt;3.x의 경우 '/'연산자는 Python과 마찬가지로 '//'에 매핑됩니다. 이후 버전의 경우 '/'는 스칼라로 나누기 만 가능합니다. 언젠가는 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="79e1726f42029777852db20a843c6cc2473daaca" translate="yes" xml:space="preserve">
          <source>Flush the memmap instance to write the changes to the file. Currently there is no API to close the underlying &lt;code&gt;mmap&lt;/code&gt;. It is tricky to ensure the resource is actually closed, since it may be shared between different memmap instances.</source>
          <target state="translated">memmap 인스턴스를 플러시하여 변경 사항을 파일에 씁니다. 현재 기본 &lt;code&gt;mmap&lt;/code&gt; 을 닫는 API가 없습니다 . 리소스가 다른 memmap 인스턴스간에 공유 될 수 있으므로 실제로 닫혀 있는지 확인하는 것은 까다 롭습니다.</target>
        </trans-unit>
        <trans-unit id="da34386f35923e2e352d15ed19fcb86185028b70" translate="yes" xml:space="preserve">
          <source>Flushes memory changes to disk in order to read them back</source>
          <target state="translated">다시 읽기 위해 메모리 변경 사항을 디스크에 플러시합니다.</target>
        </trans-unit>
        <trans-unit id="977e7ae24b1ce53baf0769e85a5d553c0c1ba1a9" translate="yes" xml:space="preserve">
          <source>Following each integration the result is &lt;em&gt;multiplied&lt;/em&gt; by &lt;code&gt;scl&lt;/code&gt; before the integration constant is added. (Default: 1)</source>
          <target state="translated">각 적분 후에 적분 상수가 추가되기 전에 결과 에 &lt;code&gt;scl&lt;/code&gt; 이 &lt;em&gt;곱해&lt;/em&gt; 집니다 . (기본값 : 1)</target>
        </trans-unit>
        <trans-unit id="0edda5efdca0ba777ab89777b73ae8abb0ac8170" translate="yes" xml:space="preserve">
          <source>Following the header comes the array data. If the dtype contains Python objects (i.e. &lt;code&gt;dtype.hasobject is True&lt;/code&gt;), then the data is a Python pickle of the array. Otherwise the data is the contiguous (either C- or Fortran-, depending on &lt;code&gt;fortran_order&lt;/code&gt;) bytes of the array. Consumers can figure out the number of bytes by multiplying the number of elements given by the shape (noting that &lt;code&gt;shape=()&lt;/code&gt; means there is 1 element) by &lt;code&gt;dtype.itemsize&lt;/code&gt;.</source>
          <target state="translated">헤더 다음에는 배열 데이터가옵니다. dtype에 Python 객체가 포함 된 경우 (예 : &lt;code&gt;dtype.hasobject is True&lt;/code&gt; ) 데이터는 배열의 Python 피클입니다. 그렇지 않으면 데이터는 배열 의 연속 (fortran_order에 따라 C- 또는 &lt;code&gt;fortran_order&lt;/code&gt; ) 바이트입니다. 소비자는 모양에 주어진 요소의 수 ( &lt;code&gt;shape=()&lt;/code&gt; 는 1 요소가 있음을 &lt;code&gt;dtype.itemsize&lt;/code&gt; )에 dtype.itemsize 를 곱하여 바이트 수를 알아낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ec0c3b76630fd745381cc215a284820af75a683a" translate="yes" xml:space="preserve">
          <source>Footnotes</source>
          <target state="translated">Footnotes</target>
        </trans-unit>
        <trans-unit id="1e3737ce90be5e40d3542337b2a16d0ddfea15fe" translate="yes" xml:space="preserve">
          <source>For 18 of the 21 types this number is fixed by the data-type. For the flexible data-types, this number can be anything.</source>
          <target state="translated">21 개 유형 중 18 개에 대해이 숫자는 데이터 유형으로 고정됩니다. 융통성있는 데이터 유형의 경우이 숫자는 무엇이든 가능합니다.</target>
        </trans-unit>
        <trans-unit id="6fe31cdcb6c6646809088d5903655d52a55d450e" translate="yes" xml:space="preserve">
          <source>For 2-D arrays it is the matrix product:</source>
          <target state="translated">2 차원 배열의 경우 행렬 곱입니다.</target>
        </trans-unit>
        <trans-unit id="3f962aedbf83ef9d65d44b9e69490919cc79f9a0" translate="yes" xml:space="preserve">
          <source>For 2-D mixed with 1-D, the result is the usual.</source>
          <target state="translated">2-D가 1-D와 혼합 된 경우 결과는 일반적입니다.</target>
        </trans-unit>
        <trans-unit id="249d7389fa64403ab6c1fc03103e6db107907e49" translate="yes" xml:space="preserve">
          <source>For 8-bit strings, this method is locale-dependent.</source>
          <target state="translated">8 비트 문자열의 경우이 방법은 로캘에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="e9823fecc87a84ebddb341139f0bf48490868833" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;#how-to-io-pickle-file&quot;&gt;security and portability&lt;/a&gt;, set &lt;code&gt;allow_pickle=False&lt;/code&gt; unless the dtype contains Python objects, which requires pickling.</source>
          <target state="translated">들어 &lt;a href=&quot;#how-to-io-pickle-file&quot;&gt;보안과 이동성&lt;/a&gt; , 세트 &lt;code&gt;allow_pickle=False&lt;/code&gt; DTYPE은 산세 필요 파이썬 객체를 포함하지 않는.</target>
        </trans-unit>
        <trans-unit id="e34d3054bfe352b99ce08082d1411334b317ca53" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; one-dimensional, this is equivalent to:</source>
          <target state="translated">들면 및 &lt;code&gt;B&lt;/code&gt; 일차원,이 동등하다 : &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a6fa074fdf944e6525f90fb53e3868628cc3a171" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;a.view(some_dtype)&lt;/code&gt;, if &lt;code&gt;some_dtype&lt;/code&gt; has a different number of bytes per entry than the previous dtype (for example, converting a regular array to a structured array), then the behavior of the view cannot be predicted just from the superficial appearance of &lt;code&gt;a&lt;/code&gt; (shown by &lt;code&gt;print(a)&lt;/code&gt;). It also depends on exactly how &lt;code&gt;a&lt;/code&gt; is stored in memory. Therefore if &lt;code&gt;a&lt;/code&gt; is C-ordered versus fortran-ordered, versus defined as a slice or transpose, etc., the view may give different results.</source>
          <target state="translated">들면 &lt;code&gt;a.view(some_dtype)&lt;/code&gt; 경우 &lt;code&gt;some_dtype&lt;/code&gt; 은 (구조적 배열에 규칙적인 배열로 변환 예) 이전 DTYPE보다 엔트리 당 바이트의 다른 번호를 가지고, 그 볼의 동작은 단지 표면 외관으로부터 예측 될 수 없다 의 (도시 의해 &lt;code&gt;print(a)&lt;/code&gt; ). 또한 &lt;code&gt;a&lt;/code&gt; 가 메모리에 어떻게 저장 되는지에 달려 있습니다. 따라서 만약 &lt;code&gt;a&lt;/code&gt; 가 C- 순서 대 포트란 순서, 대 슬라이스 또는 조옮김 등으로 정의되면, 뷰는 다른 결과를 줄 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="915d1e6dbac63dd7367ad9288b59958e7383b198" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, &lt;strong&gt;``*`` means element-wise multiplication&lt;/strong&gt;, while &lt;strong&gt;``@`` means matrix multiplication&lt;/strong&gt;; they have associated functions &lt;code&gt;multiply()&lt;/code&gt; and &lt;code&gt;dot()&lt;/code&gt;. (Before Python 3.5, &lt;code&gt;@&lt;/code&gt; did not exist and one had to use &lt;code&gt;dot()&lt;/code&gt; for matrix multiplication).</source>
          <target state="translated">용 &lt;code&gt;array&lt;/code&gt; , &lt;strong&gt;``* 수단 소자 현명한 승산&lt;/strong&gt; 하면서, &lt;strong&gt;``@ 행렬 곱셈 수단&lt;/strong&gt; ; 관련 함수 &lt;code&gt;multiply()&lt;/code&gt; 및 &lt;code&gt;dot()&lt;/code&gt; 있습니다. (Python 3.5 이전에는 &lt;code&gt;@&lt;/code&gt; 가 존재하지 않았고 행렬 곱셈 을 위해 &lt;code&gt;dot()&lt;/code&gt; 을 사용해야했습니다 ).</target>
        </trans-unit>
        <trans-unit id="e46f2d6f5fe5e7ec999c5f95aef2596fb69e222c" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, &lt;strong&gt;``*`` means element-wise multiplication&lt;/strong&gt;, while &lt;strong&gt;``@`` means matrix multiplication&lt;/strong&gt;; they have associated functions &lt;code&gt;multiply()&lt;/code&gt; and &lt;code&gt;dot()&lt;/code&gt;. (Before python 3.5, &lt;code&gt;@&lt;/code&gt; did not exist and one had to use &lt;code&gt;dot()&lt;/code&gt; for matrix multiplication).</source>
          <target state="translated">용 &lt;code&gt;array&lt;/code&gt; , &lt;strong&gt;``* 수단 소자 현명한 승산&lt;/strong&gt; 하면서, &lt;strong&gt;``@ 행렬 곱셈 수단&lt;/strong&gt; ; 관련 함수 &lt;code&gt;multiply()&lt;/code&gt; 및 &lt;code&gt;dot()&lt;/code&gt; 있습니다. (파이썬 3.5 이전에는 &lt;code&gt;@&lt;/code&gt; 가 존재하지 않았고 행렬 곱셈 을 위해 &lt;code&gt;dot()&lt;/code&gt; 을 사용해야했습니다 ).</target>
        </trans-unit>
        <trans-unit id="3105b82282a4b74064eec805ba7d2c290a53d304" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;array&lt;/code&gt;, the &lt;strong&gt;vector shapes 1xN, Nx1, and N are all different things&lt;/strong&gt;. Operations like &lt;code&gt;A[:,1]&lt;/code&gt; return a one-dimensional array of shape N, not a two-dimensional array of shape Nx1. Transpose on a one-dimensional &lt;code&gt;array&lt;/code&gt; does nothing.</source>
          <target state="translated">들면 &lt;code&gt;array&lt;/code&gt; 는 &lt;strong&gt;벡터 1xN, NX1, 및 N은 모든 다른 것들 모양&lt;/strong&gt; . &lt;code&gt;A[:,1]&lt;/code&gt; 과 같은 연산은 Nx1 모양의 2 차원 배열이 아니라 모양 N의 1 차원 배열을 반환합니다. 1 차원 &lt;code&gt;array&lt;/code&gt; 에서 전치하면 아무 작업도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="272593adff1434bde1d4cd33b0346e0c6d20e042" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;e, E&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; specifiers, the number of digits to print after the decimal point.</source>
          <target state="translated">를 들어 &lt;code&gt;e, E&lt;/code&gt; 및 &lt;code&gt;f&lt;/code&gt; 지정자 자릿수 소수점 후 인쇄한다.</target>
        </trans-unit>
        <trans-unit id="a8b87fa4bee96c31297a2faf4474562d50259437" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;g&lt;/code&gt; and &lt;code&gt;G&lt;/code&gt;, the maximum number of significant digits.</source>
          <target state="translated">용 &lt;code&gt;g&lt;/code&gt; 및 &lt;code&gt;G&lt;/code&gt; , 유효 숫자의 최대 수.</target>
        </trans-unit>
        <trans-unit id="d98628f7394ff0daa3811e58311c01f9a29ca826" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;matrix&lt;/code&gt;, &lt;strong&gt;``*`` means matrix multiplication&lt;/strong&gt;, and for element-wise multiplication one has to use the &lt;code&gt;multiply()&lt;/code&gt; function.</source>
          <target state="translated">들면 &lt;code&gt;matrix&lt;/code&gt; , &lt;strong&gt;``* 수단 행렬 곱셈&lt;/strong&gt; 및 요소 - 방식 승산 하나를 사용하는 &lt;code&gt;multiply()&lt;/code&gt; 함수.</target>
        </trans-unit>
        <trans-unit id="637ce924b991228068be8a9a9fc01722cca48f39" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;matrix&lt;/code&gt;, &lt;strong&gt;one-dimensional arrays are always upconverted to 1xN or Nx1 matrices&lt;/strong&gt; (row or column vectors). &lt;code&gt;A[:,1]&lt;/code&gt; returns a two-dimensional matrix of shape Nx1.</source>
          <target state="translated">들면 &lt;code&gt;matrix&lt;/code&gt; , &lt;strong&gt;일차원 어레이 항상 1xN NX1 또는 매트릭스로 상향 변환된다&lt;/strong&gt; (행 또는 열 벡터). &lt;code&gt;A[:,1]&lt;/code&gt; 은 Nx1 모양의 2 차원 행렬을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2f16f572df2de5dbe71ab6b482a26aade3788153" translate="yes" xml:space="preserve">
          <source>For &lt;code&gt;s&lt;/code&gt;, the maximum number of characters.</source>
          <target state="translated">대한 &lt;code&gt;s&lt;/code&gt; , 문자의 최대 수.</target>
        </trans-unit>
        <trans-unit id="aa1840d454c362488b42bf5829f92b6d701a9c1e" translate="yes" xml:space="preserve">
          <source>For Arch</source>
          <target state="translated">아치 용</target>
        </trans-unit>
        <trans-unit id="1fe382b5886c1f7f86eb9563a948b171f688012e" translate="yes" xml:space="preserve">
          <source>For C code, see &lt;a href=&quot;https://numpy.org/neps/nep-0045-c_style_guide.html#nep45&quot;&gt;NEP 45&lt;/a&gt;.</source>
          <target state="translated">C 코드는 &lt;a href=&quot;https://numpy.org/neps/nep-0045-c_style_guide.html#nep45&quot;&gt;NEP 45를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="99d20f637f3a6e1d55b90d0390d938da13e44f35" translate="yes" xml:space="preserve">
          <source>For C code, see the &lt;a href=&quot;style_guide#style-guide&quot;&gt;numpy-c-style-guide&lt;/a&gt;</source>
          <target state="translated">C 코드의 &lt;a href=&quot;style_guide#style-guide&quot;&gt;경우 numpy-c-style-guide를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="96de2b474663e4b27c100d387c234e173e9360ba" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0 a view of &lt;code&gt;a&lt;/code&gt; is always returned. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">NumPy&amp;gt; = 1.10.0의 &lt;code&gt;a&lt;/code&gt; 항상 a의보기 가 리턴됩니다. NumPy와 이전의 버전의 도면 &lt;code&gt;a&lt;/code&gt; 축의 순서가 변경되고, 그렇지 않으면 입력 배열을 반환만을 반환한다.</target>
        </trans-unit>
        <trans-unit id="187181bc029dad6f61070b7f6592eecd79b97aa5" translate="yes" xml:space="preserve">
          <source>For NumPy &amp;gt;= 1.10.0, if &lt;code&gt;a&lt;/code&gt; is an ndarray, then a view of &lt;code&gt;a&lt;/code&gt; is returned; otherwise a new array is created. For earlier NumPy versions a view of &lt;code&gt;a&lt;/code&gt; is returned only if the order of the axes is changed, otherwise the input array is returned.</source>
          <target state="translated">만약 NumPy와 내용&amp;gt; = 1.10.0, &lt;code&gt;a&lt;/code&gt; ndarray 된 다음의 도면 &lt;code&gt;a&lt;/code&gt; 리턴되고; 그렇지 않으면 새 배열이 작성됩니다. NumPy와 이전의 버전의 도면 &lt;code&gt;a&lt;/code&gt; 축의 순서가 변경되고, 그렇지 않으면 입력 배열을 반환만을 반환한다.</target>
        </trans-unit>
        <trans-unit id="0a5eeed134b0ceb1a540af21c6c13d1f0f7c9d88" translate="yes" xml:space="preserve">
          <source>For PRs that add new features or are in some way complex, wait at least a day or two before merging it. That way, others get a chance to comment before the code goes in. Consider adding it to the release notes.</source>
          <target state="translated">새로운 기능을 추가하거나 어떤 방식 으로든 복잡한 PR의 경우 병합하기 전에 적어도 하루 이틀을 기다리십시오. 이렇게하면 다른 사람들이 코드가 들어가기 전에 주석을 달 수 있습니다. 릴리스 노트에 추가하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="54f70af9beed617bc137c199798e6f21c9093a8c" translate="yes" xml:space="preserve">
          <source>For Python, the preferred way of handling contiguous (or technically, &lt;em&gt;strided&lt;/em&gt;) blocks of homogeneous data is with NumPy, which provides full object-oriented access to multidimensial arrays of data. Therefore, the most logical Python interface for the &lt;code&gt;rms&lt;/code&gt; function would be (including doc string):</source>
          <target state="translated">파이썬의 경우, 균질 한 데이터의 연속적 (또는 기술적으로 &lt;em&gt;스트 라이딩 된&lt;/em&gt; ) 블록 을 처리하는 선호되는 방법은 NumPy를 사용하는 것입니다. NumPy는 다차원 데이터 배열에 대한 객체 지향 액세스를 제공합니다. 따라서 &lt;code&gt;rms&lt;/code&gt; 함수에 대한 가장 논리적 인 파이썬 인터페이스 는 다음과 같습니다 (doc 문자열 포함).</target>
        </trans-unit>
        <trans-unit id="55f9e5f045d92376c7d38dda0f2622f9b6352be6" translate="yes" xml:space="preserve">
          <source>For a 1-D array this has no effect, as a transposed vector is simply the same vector. To convert a 1-D array into a 2D column vector, an additional dimension must be added. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; achieves this, as does &lt;code&gt;a[:, np.newaxis]&lt;/code&gt;. For a 2-D array, this is a standard matrix transpose. For an n-D array, if axes are given, their order indicates how the axes are permuted (see Examples). If axes are not provided and &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt;, then &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt;.</source>
          <target state="translated">1 차원 배열의 경우, 조옮김 벡터는 단순히 동일한 벡터이므로 효과가 없습니다. 1 차원 배열을 2 차원 열 벡터로 변환하려면 추가 차원을 추가해야합니다. &lt;code&gt;np.atleast2d(a).T&lt;/code&gt; 는 &lt;code&gt;a[:, np.newaxis]&lt;/code&gt; 와 같이 이것을 달성합니다 . 2 차원 배열의 경우 이것은 표준 행렬 전치입니다. nD 배열의 경우 축이 제공되는 경우 순서는 축이 치환되는 방식을 나타냅니다 (예 참조). 축이 제공되지 않고 &lt;code&gt;a.shape = (i[0], i[1], ... i[n-2], i[n-1])&lt;/code&gt; 인 경우 &lt;code&gt;a.transpose().shape = (i[n-1], i[n-2], ... i[1], i[0])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c37103fe1630ecb51bfbc7a903129e1d60dd7ed" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;, except that &lt;code&gt;tolist&lt;/code&gt; changes numpy scalars to Python scalars:</source>
          <target state="translated">1D 배열의 경우 &lt;code&gt;a.tolist()&lt;/code&gt; 는 &lt;code&gt;tolist&lt;/code&gt; 가 numpy 스칼라를 Python 스칼라로 변경 한다는 점을 제외하면 &lt;code&gt;list(a)&lt;/code&gt; 와 거의 동일 합니다 .</target>
        </trans-unit>
        <trans-unit id="d3f2a60e0b01b84231d8024aebcc5e084e0ba27d" translate="yes" xml:space="preserve">
          <source>For a 1D array, &lt;code&gt;a.tolist()&lt;/code&gt; is almost the same as &lt;code&gt;list(a)&lt;/code&gt;:</source>
          <target state="translated">1D 배열의 경우 &lt;code&gt;a.tolist()&lt;/code&gt; 는 &lt;code&gt;list(a)&lt;/code&gt; 와 거의 같습니다.</target>
        </trans-unit>
        <trans-unit id="cf0f7c81098fcc87863f3be5d59395a987825914" translate="yes" xml:space="preserve">
          <source>For a complete discussion of creation methods for masked arrays please see section &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;Constructing masked arrays&lt;/a&gt;.</source>
          <target state="translated">마스크 배열의 생성 방법에 대한 자세한 내용은 &lt;a href=&quot;#maskedarray-generic-constructing&quot;&gt;마스크 배열 구성&lt;/a&gt; 섹션을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0bdfc3356f177e5d7773cb796069c781e6c3ff20" translate="yes" xml:space="preserve">
          <source>For a description of the &lt;code&gt;.npy&lt;/code&gt; format, see &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt;&lt;code&gt;numpy.lib.format&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 설명은 &lt;code&gt;.npy&lt;/code&gt; 형식을 참조 &lt;a href=&quot;numpy.lib.format#module-numpy.lib.format&quot;&gt; &lt;code&gt;numpy.lib.format&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="197692467968599b779c0574e1302cadc5d30a4f" translate="yes" xml:space="preserve">
          <source>For a full description of these options, see &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt;&lt;code&gt;set_printoptions&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 옵션에 대한 자세한 설명은 &lt;a href=&quot;numpy.set_printoptions#numpy.set_printoptions&quot;&gt; &lt;code&gt;set_printoptions&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b040ed436e354a6dfab8e28023d68c6eed7a06c2" translate="yes" xml:space="preserve">
          <source>For a function that returns a 1D array, the number of dimensions in &lt;code&gt;outarr&lt;/code&gt; is the same as &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">1D 배열을 반환하는 함수의 경우 &lt;code&gt;outarr&lt;/code&gt; 의 차원 수는 &lt;code&gt;arr&lt;/code&gt; 과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="9409ae5300d15907687b38139959611e06963f16" translate="yes" xml:space="preserve">
          <source>For a function that returns a higher dimensional array, those dimensions are inserted in place of the &lt;code&gt;axis&lt;/code&gt; dimension.</source>
          <target state="translated">더 높은 차원의 배열을 반환하는 함수의 경우 해당 차원이 &lt;code&gt;axis&lt;/code&gt; 차원 대신 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bc58e9722ab208094239d52118be4b4466da131" translate="yes" xml:space="preserve">
          <source>For a log() that returns &lt;code&gt;NAN&lt;/code&gt; when real &lt;code&gt;x &amp;lt; 0&lt;/code&gt;, use &lt;a href=&quot;numpy.log#numpy.log&quot;&gt;&lt;code&gt;numpy.log&lt;/code&gt;&lt;/a&gt; (note, however, that otherwise &lt;a href=&quot;numpy.log#numpy.log&quot;&gt;&lt;code&gt;numpy.log&lt;/code&gt;&lt;/a&gt; and this &lt;a href=&quot;numpy.log#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; are identical, i.e., both return &lt;code&gt;-inf&lt;/code&gt; for &lt;code&gt;x = 0&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt; for &lt;code&gt;x = inf&lt;/code&gt;, and, notably, the complex principle value if &lt;code&gt;x.imag != 0&lt;/code&gt;).</source>
          <target state="translated">로그 ()를 들어 그 반환 &lt;code&gt;NAN&lt;/code&gt; 때 실제 &lt;code&gt;x &amp;lt; 0&lt;/code&gt; , 사용 &lt;a href=&quot;numpy.log#numpy.log&quot;&gt; &lt;code&gt;numpy.log&lt;/code&gt; &lt;/a&gt; (단, 다른 것을 &lt;a href=&quot;numpy.log#numpy.log&quot;&gt; &lt;code&gt;numpy.log&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;numpy.log#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 동일, 즉, 모두 반환됩니다 &lt;code&gt;-inf&lt;/code&gt; 에 대한 &lt;code&gt;x = 0&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 를 위한 &lt;code&gt;x = inf&lt;/code&gt; , 그리고 특히 &lt;code&gt;x.imag != 0&lt;/code&gt; 경우 복잡한 원리 값 ).</target>
        </trans-unit>
        <trans-unit id="7fb6c973e282321a695eebb55d28fd847e02e71f" translate="yes" xml:space="preserve">
          <source>For a log10() that returns &lt;code&gt;NAN&lt;/code&gt; when real &lt;code&gt;x &amp;lt; 0&lt;/code&gt;, use &lt;a href=&quot;numpy.log10#numpy.log10&quot;&gt;&lt;code&gt;numpy.log10&lt;/code&gt;&lt;/a&gt; (note, however, that otherwise &lt;a href=&quot;numpy.log10#numpy.log10&quot;&gt;&lt;code&gt;numpy.log10&lt;/code&gt;&lt;/a&gt; and this &lt;a href=&quot;numpy.log10#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; are identical, i.e., both return &lt;code&gt;-inf&lt;/code&gt; for &lt;code&gt;x = 0&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt; for &lt;code&gt;x = inf&lt;/code&gt;, and, notably, the complex principle value if &lt;code&gt;x.imag != 0&lt;/code&gt;).</source>
          <target state="translated">LOG10 ()의 경우 그 반환 &lt;code&gt;NAN&lt;/code&gt; 때 실제 &lt;code&gt;x &amp;lt; 0&lt;/code&gt; , 사용 &lt;a href=&quot;numpy.log10#numpy.log10&quot;&gt; &lt;code&gt;numpy.log10&lt;/code&gt; &lt;/a&gt; 그렇지 않은 것을 그러나 (주, &lt;a href=&quot;numpy.log10#numpy.log10&quot;&gt; &lt;code&gt;numpy.log10&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;numpy.log10#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; , 즉, 모두 반환 동일 &lt;code&gt;-inf&lt;/code&gt; 에 대한 &lt;code&gt;x = 0&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 를 위한 &lt;code&gt;x = inf&lt;/code&gt; , 그리고 특히 &lt;code&gt;x.imag != 0&lt;/code&gt; 경우 복잡한 원리 값 ).</target>
        </trans-unit>
        <trans-unit id="3d2c7a157db6f37c8448fa48835b35d5b5709f3a" translate="yes" xml:space="preserve">
          <source>For a log2() that returns &lt;code&gt;NAN&lt;/code&gt; when real &lt;code&gt;x &amp;lt; 0&lt;/code&gt;, use &lt;a href=&quot;numpy.log2#numpy.log2&quot;&gt;&lt;code&gt;numpy.log2&lt;/code&gt;&lt;/a&gt; (note, however, that otherwise &lt;a href=&quot;numpy.log2#numpy.log2&quot;&gt;&lt;code&gt;numpy.log2&lt;/code&gt;&lt;/a&gt; and this &lt;a href=&quot;numpy.log2#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; are identical, i.e., both return &lt;code&gt;-inf&lt;/code&gt; for &lt;code&gt;x = 0&lt;/code&gt;, &lt;code&gt;inf&lt;/code&gt; for &lt;code&gt;x = inf&lt;/code&gt;, and, notably, the complex principle value if &lt;code&gt;x.imag != 0&lt;/code&gt;).</source>
          <target state="translated">LOG2 ()의 경우 그 반환 &lt;code&gt;NAN&lt;/code&gt; 때 실제 &lt;code&gt;x &amp;lt; 0&lt;/code&gt; , 사용 &lt;a href=&quot;numpy.log2#numpy.log2&quot;&gt; &lt;code&gt;numpy.log2&lt;/code&gt; &lt;/a&gt; 그렇지 않은 것을 그러나 (주, &lt;a href=&quot;numpy.log2#numpy.log2&quot;&gt; &lt;code&gt;numpy.log2&lt;/code&gt; &lt;/a&gt; 이 &lt;a href=&quot;numpy.log2#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; , 즉, 모두 반환 동일 &lt;code&gt;-inf&lt;/code&gt; 에 대한 &lt;code&gt;x = 0&lt;/code&gt; , &lt;code&gt;inf&lt;/code&gt; 를 위한 &lt;code&gt;x = inf&lt;/code&gt; , 그리고 특히 &lt;code&gt;x.imag != 0&lt;/code&gt; 경우 복잡한 원칙 값 ).</target>
        </trans-unit>
        <trans-unit id="17b694669442e700bd635063d9a03b4ef4365eec" translate="yes" xml:space="preserve">
          <source>For a more detailed discussion, read on and follow the links at the bottom of this page.</source>
          <target state="translated">더 자세한 논의는이 페이지 하단의 링크를 읽고 따르십시오.</target>
        </trans-unit>
        <trans-unit id="7adc015d596be980abdfb7f52ddd54b20d9ed4e4" translate="yes" xml:space="preserve">
          <source>For a multi-dimensional array, accumulate is applied along only one axis (axis zero by default; see Examples below) so repeated use is necessary if one wants to accumulate over multiple axes.</source>
          <target state="translated">다차원 배열의 경우 누적은 한 축 (기본적으로 축 0, 아래 예 참조)을 따라 적용되므로 여러 축에 누적하려면 반복적으로 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="4a70a58adc76a39cce5a267ab70438cf75b9572e" translate="yes" xml:space="preserve">
          <source>For a non-trivial signature, &lt;code&gt;dimensions&lt;/code&gt; will also contain the sizes of the core dimensions as well, starting at the second entry. Only one size is provided for each unique dimension name and the sizes are given according to the first occurrence of a dimension name in the signature.</source>
          <target state="translated">사소한 서명의 경우 &lt;code&gt;dimensions&lt;/code&gt; 에는 두 번째 항목부터 시작하여 핵심 차원의 크기도 포함됩니다. 고유 한 각 차원 이름에 대해 하나의 크기 만 제공되며 서명에서 처음 나타나는 차원 이름에 따라 크기가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="8218bd5d7a6649aa63226e5b622d4b8efad4dc34" translate="yes" xml:space="preserve">
          <source>For a one-dimensional array, accumulate produces results equivalent to:</source>
          <target state="translated">1 차원 배열의 경우 누적은 다음과 같은 결과를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0424b9224931152a35a50c93d8cc0ece880de71a" translate="yes" xml:space="preserve">
          <source>For a one-sided t-test, how far out in the distribution does the t statistic appear?</source>
          <target state="translated">단측 t- 검정의 경우 t 통계가 분포에서 얼마나 멀리 표시됩니까?</target>
        </trans-unit>
        <trans-unit id="3911c3b2407712ae47f85ee3fb1ac557138ff00b" translate="yes" xml:space="preserve">
          <source>For a possible future loop selector with a different signature.</source>
          <target state="translated">다른 서명을 가진 가능한 미래 루프 선택기.</target>
        </trans-unit>
        <trans-unit id="c991a419f14da45f93fac679b2b79a552dc6a583" translate="yes" xml:space="preserve">
          <source>For a simple example, consider taking the sum of all elements in an array.</source>
          <target state="translated">간단한 예를 들어, 배열의 모든 요소의 합을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="65b58d63b284139c1918d1c4f188a0cdc07b3bf2" translate="yes" xml:space="preserve">
          <source>For advanced assignments, there is in general no guarantee for the iteration order. This means that if an element is set more than once, it is not possible to predict the final result.</source>
          <target state="translated">고급 과제의 경우 일반적으로 반복 순서를 보장하지 않습니다. 즉, 요소가 두 번 이상 설정되면 최종 결과를 예측할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="d08105fb315fdfa97977e494fc0f07ee6275d676" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;, but no checking is done.</source>
          <target state="translated">이러한 모든 매크로에서 &lt;em&gt;arr&lt;/em&gt; 은 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 (하위 클래스) 인스턴스 여야 하지만 검사는 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e1f0a94de943c1efcc57e0ced39bb6353a416723" translate="yes" xml:space="preserve">
          <source>For all of these macros &lt;em&gt;arr&lt;/em&gt; must be an instance of a (subclass of) &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;PyArray_Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이러한 모든 매크로에 대해 &lt;em&gt;arr&lt;/em&gt; 은 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;PyArray_Type&lt;/code&gt; &lt;/a&gt; 의 (하위 클래스) 인스턴스 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="24c98e7efdd0450f6d403ff7e88bf2f5b1a932b5" translate="yes" xml:space="preserve">
          <source>For all-NaN slices or slices with zero degrees of freedom, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">자유도가 0 인 모든 NaN 슬라이스 또는 슬라이스의 경우 NaN이 반환되고 &lt;code&gt;RuntimeWarning&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="b523336c8d394d1599c127fd9600cfe28ac8e406" translate="yes" xml:space="preserve">
          <source>For all-NaN slices, NaN is returned and a &lt;code&gt;RuntimeWarning&lt;/code&gt; is raised.</source>
          <target state="translated">모든 NaN 슬라이스의 경우 NaN이 반환되고 &lt;code&gt;RuntimeWarning&lt;/code&gt; 이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cdcb9c3fa272c68c7dc5e676247f2291a44c1673" translate="yes" xml:space="preserve">
          <source>For an accompanying example, see &lt;a href=&quot;#example&quot;&gt;example.py&lt;/a&gt;.</source>
          <target state="translated">함께 제공되는 예는 &lt;a href=&quot;#example&quot;&gt;example.py를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8b1bbf030efb52ebb2db7a903c9ad2ca87ea6a57" translate="yes" xml:space="preserve">
          <source>For an arccos() that returns &lt;code&gt;NAN&lt;/code&gt; when real &lt;code&gt;x&lt;/code&gt; is not in the interval &lt;code&gt;[-1,1]&lt;/code&gt;, use &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;numpy.arccos&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">실수 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;[-1,1]&lt;/code&gt; 구간에 없을 때 &lt;code&gt;NAN&lt;/code&gt; 을 반환하는 arccos ()의 경우 &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt; &lt;code&gt;numpy.arccos&lt;/code&gt; 를&lt;/a&gt; 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="28dbf3891d965be0dd027e5198aef3d68b36d0eb" translate="yes" xml:space="preserve">
          <source>For an arcsin() that returns &lt;code&gt;NAN&lt;/code&gt; when real &lt;code&gt;x&lt;/code&gt; is not in the interval &lt;code&gt;[-1,1]&lt;/code&gt;, use &lt;a href=&quot;numpy.arcsin#numpy.arcsin&quot;&gt;&lt;code&gt;numpy.arcsin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">실수 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;[-1,1]&lt;/code&gt; 구간에 없을 때 &lt;code&gt;NAN&lt;/code&gt; 을 반환하는 arcsin ()의 경우 &lt;a href=&quot;numpy.arcsin#numpy.arcsin&quot;&gt; &lt;code&gt;numpy.arcsin&lt;/code&gt; 을&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="715a39a94a66dfb176679504297f4cbe2940279b" translate="yes" xml:space="preserve">
          <source>For an arctanh() that returns &lt;code&gt;NAN&lt;/code&gt; when real &lt;code&gt;x&lt;/code&gt; is not in the interval &lt;code&gt;(-1,1)&lt;/code&gt;, use &lt;a href=&quot;numpy.arctanh#numpy.arctanh&quot;&gt;&lt;code&gt;numpy.arctanh&lt;/code&gt;&lt;/a&gt; (this latter, however, does return +/-inf for &lt;code&gt;x = +/-1&lt;/code&gt;).</source>
          <target state="translated">실수 &lt;code&gt;x&lt;/code&gt; 가 &lt;code&gt;(-1,1)&lt;/code&gt; 구간에 없을 때 &lt;code&gt;NAN&lt;/code&gt; 을 반환하는 arctanh ()의 경우 &lt;a href=&quot;numpy.arctanh#numpy.arctanh&quot;&gt; &lt;code&gt;numpy.arctanh&lt;/code&gt; 를&lt;/a&gt; 사용 합니다 (그러나 후자는 &lt;code&gt;x = +/-1&lt;/code&gt; 대해 +/- inf를 반환합니다 ).</target>
        </trans-unit>
        <trans-unit id="f544bc19358af783f5828a5e5053cd2cf057f05c" translate="yes" xml:space="preserve">
          <source>For an array &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;, the diagonal is the list of locations with indices &lt;code&gt;a[i, ..., i]&lt;/code&gt; all identical. This function modifies the input array in-place, it does not return a value.</source>
          <target state="translated">어레이 들어 와 &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; , 지수는 대각선으로 위치 목록은 &lt;code&gt;a[i, ..., i]&lt;/code&gt; 모든 동일. 이 함수는 입력 배열을 내부에서 수정하며 값을 반환하지 않습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3aca4d8fb9611bde95449f6380639b52b005e231" translate="yes" xml:space="preserve">
          <source>For an array a with two axes, transpose(a) gives the matrix transpose.</source>
          <target state="translated">축이 두 개인 배열 a의 경우 transpose (a)는 행렬 전치를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="836b756b5d814f029c077f0578ba6c0e58a3c672" translate="yes" xml:space="preserve">
          <source>For an array with rank greater than 1, some of the padding of later axes is calculated from padding of previous axes. This is easiest to think about with a rank 2 array where the corners of the padded array are calculated by using padded values from the first axis.</source>
          <target state="translated">순위가 1보다 큰 배열의 경우 이후 축의 일부 패딩은 이전 축의 패딩에서 계산됩니다. 패딩 배열의 모서리가 첫 번째 축의 패딩 값을 사용하여 계산되는 순위 2 배열을 생각하면 가장 쉽습니다.</target>
        </trans-unit>
        <trans-unit id="6e96c6b0d98bc68cbd820a41e54b4b8abe37a921" translate="yes" xml:space="preserve">
          <source>For an even number of input points, &lt;code&gt;A[n//2]&lt;/code&gt; represents the sum of the values at the positive and negative Nyquist frequencies, as the two are aliased together. See &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt;&lt;code&gt;numpy.fft&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">짝수의 입력 포인트에 대해, &lt;code&gt;A[n//2]&lt;/code&gt; 는 양과 음의 나이 퀴 스트 주파수에서의 값의 합을 나타냅니다. 자세한 내용은 &lt;a href=&quot;../routines.fft#module-numpy.fft&quot;&gt; &lt;code&gt;numpy.fft&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="57743d92673c43f581b946774bebcebd154a8f73" translate="yes" xml:space="preserve">
          <source>For an example, see &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt;&lt;code&gt;Arrayterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;numpy.lib.arrayterator#numpy.lib.Arrayterator&quot;&gt; &lt;code&gt;Arrayterator&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c782854d522cc47b6ef0aa24c79c91b4278be4a" translate="yes" xml:space="preserve">
          <source>For an optional array argument, all its dimensions must be bounded.</source>
          <target state="translated">선택적 배열 인수의 경우 모든 차원이 제한되어야합니다.</target>
        </trans-unit>
        <trans-unit id="6fe48c8702effa07c62fb464257e567d9ddc8002" translate="yes" xml:space="preserve">
          <source>For any index combination, including slicing and axis insertion, &lt;code&gt;a[indices]&lt;/code&gt; is the same as &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; for any array &lt;code&gt;a&lt;/code&gt;. However, &lt;code&gt;np.index_exp[indices]&lt;/code&gt; can be used anywhere in Python code and returns a tuple of slice objects that can be used in the construction of complex index expressions.</source>
          <target state="translated">슬라이싱 및 축 삽입을 포함한 인덱스 조합의 경우 &lt;code&gt;a[indices]&lt;/code&gt; 는 모든 배열 &lt;code&gt;a&lt;/code&gt; 의 &lt;code&gt;a[np.index_exp[indices]]&lt;/code&gt; 와 같습니다 . 그러나 &lt;code&gt;np.index_exp[indices]&lt;/code&gt; 는 Python 코드의 어느 곳에서나 사용할 수 있으며 복잡한 인덱스 표현식을 구성하는 데 사용할 수있는 슬라이스 객체 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="befc2c9b3e9174a0e95946cae12589b779a18421" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;code&gt;axis&lt;/code&gt; keyword, it defaults to None. If axis is None, then the array is treated as a 1-D array. Any other value for &lt;code&gt;axis&lt;/code&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 키워드 를 사용하는 배열 메서드의 경우 기본값은 None입니다. axis가 None이면 배열은 1 차원 배열로 처리됩니다. 다른 &lt;code&gt;axis&lt;/code&gt; 값 은 작업을 진행해야하는 치수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="ec5bdb26c08f7af1b31abb9fd2aadbeeef092f4f" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;code&gt;None&lt;/code&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">&lt;em&gt;축&lt;/em&gt; 키워드 를 사용하는 배열 메서드의 경우 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다. axis가 &lt;em&gt;None&lt;/em&gt; 이면 배열은 1 차원 배열로 처리됩니다. &lt;em&gt;축의&lt;/em&gt; 다른 값 은 작업이 진행되는 차원을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d57067c37de796c57ab86aba446833670680acd2" translate="yes" xml:space="preserve">
          <source>For array methods that take an &lt;em&gt;axis&lt;/em&gt; keyword, it defaults to &lt;em&gt;None&lt;/em&gt;. If axis is &lt;em&gt;None&lt;/em&gt;, then the array is treated as a 1-D array. Any other value for &lt;em&gt;axis&lt;/em&gt; represents the dimension along which the operation should proceed.</source>
          <target state="translated">&lt;em&gt;axis&lt;/em&gt; 키워드 를 사용하는 배열 메서드의 경우 기본값은 &lt;em&gt;None&lt;/em&gt; 입니다. axis가 &lt;em&gt;None&lt;/em&gt; 이면 배열은 1 차원 배열로 처리됩니다. 다른 &lt;em&gt;축&lt;/em&gt; 값 은 작업을 진행해야하는 치수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dcba10981a70013794c3901be17ecdedebc27a1a" translate="yes" xml:space="preserve">
          <source>For backward compatibility and as a standard &amp;ldquo;container &amp;ldquo;class, the UserArray from Numeric has been brought over to NumPy and named &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt;&lt;code&gt;numpy.lib.user_array.container&lt;/code&gt;&lt;/a&gt; The container class is a Python class whose self.array attribute is an ndarray. Multiple inheritance is probably easier with numpy.lib.user_array.container than with the ndarray itself and so it is included by default. It is not documented here beyond mentioning its existence because you are encouraged to use the ndarray class directly if you can.</source>
          <target state="translated">이전 버전과의 호환성 및 표준 &quot;컨테이너&quot;클래스로 Numeric의 UserArray가 NumPy로 가져와 이름이 &lt;a href=&quot;generated/numpy.lib.user_array.container#numpy.lib.user_array.container&quot;&gt; &lt;code&gt;numpy.lib.user_array.container&lt;/code&gt; &lt;/a&gt; 컨테이너 클래스는 self.array 속성이 ndarray 인 Python 클래스입니다. numpy.lib.user_array.container를 사용하면 ndarray 자체보다 다중 상속이 더 쉬울 수 있으므로 기본적으로 포함됩니다. 가능한 경우 ndarray 클래스를 직접 사용하도록 권장되기 때문에 여기에 존재를 언급하는 것 이상으로 문서화되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="744029ca149005a975825793a2c75c6e9d0e08e3" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;a href=&quot;arrays.scalars#numpy.string_&quot;&gt;&lt;code&gt;numpy.string_&lt;/code&gt;&lt;/a&gt; continues to alias &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt;&lt;code&gt;numpy.bytes_&lt;/code&gt;&lt;/a&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt;&lt;code&gt;numpy.str_&lt;/code&gt;&lt;/a&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="translated">파이썬 2 이전 버전과의 호환성을 위해 &lt;code&gt;S&lt;/code&gt; 와 typestrings 제로 종료 바이트를 유지하고 &lt;a href=&quot;arrays.scalars#numpy.string_&quot;&gt; &lt;code&gt;numpy.string_&lt;/code&gt; 는&lt;/a&gt; 별칭 계속 &lt;a href=&quot;arrays.scalars#numpy.bytes_&quot;&gt; &lt;code&gt;numpy.bytes_&lt;/code&gt; &lt;/a&gt; . Python 3에서 실제 문자열을 사용하려면 &lt;code&gt;U&lt;/code&gt; 또는 &lt;a href=&quot;arrays.scalars#numpy.str_&quot;&gt; &lt;code&gt;numpy.str_&lt;/code&gt; 을&lt;/a&gt; 사용 하십시오 . 0 종료가 필요하지 않은 부호있는 바이트의 경우 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;i1&lt;/code&gt; 을 사용할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1756e23a025872fd532e8ba6c08bb9a4085acd5e" translate="yes" xml:space="preserve">
          <source>For backward compatibility with Python 2 the &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; typestrings remain zero-terminated bytes and &lt;code&gt;np.string_&lt;/code&gt; continues to map to &lt;code&gt;np.bytes_&lt;/code&gt;. To use actual strings in Python 3 use &lt;code&gt;U&lt;/code&gt; or &lt;code&gt;np.unicode_&lt;/code&gt;. For signed bytes that do not need zero-termination &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;i1&lt;/code&gt; can be used.</source>
          <target state="translated">파이썬 2와 이전 버전과의 호환성을 위해 &lt;code&gt;S&lt;/code&gt; 와 typestrings 제로 종료 바이트 남아 &lt;code&gt;np.string_&lt;/code&gt; 가 매핑 계속 &lt;code&gt;np.bytes_&lt;/code&gt; . Python 3에서 실제 문자열을 사용하려면 &lt;code&gt;U&lt;/code&gt; 또는 &lt;code&gt;np.unicode_&lt;/code&gt; 를 사용 하십시오 . 제로 종료가 필요없는 부호있는 바이트의 경우 &lt;code&gt;b&lt;/code&gt; 또는 &lt;code&gt;i1&lt;/code&gt; 을 사용할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0671395c42986a8a806aaa184ebf9d547a0731c6" translate="yes" xml:space="preserve">
          <source>For backward compatible legacy reasons, we cannot change this. See &lt;a href=&quot;index#random-quick-start&quot;&gt;Quick Start&lt;/a&gt;.</source>
          <target state="translated">이전 버전과 호환되는 레거시 이유로 인해이를 변경할 수 없습니다. &lt;a href=&quot;index#random-quick-start&quot;&gt;빠른 시작을&lt;/a&gt; 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="2f4c86851229c177d560fbdf1b8fb4dd2c3ff306" translate="yes" xml:space="preserve">
          <source>For backward compatible legacy reasons, we cannot change this. See &lt;code&gt;random-quick-start&lt;/code&gt;.</source>
          <target state="translated">이전 버전과 호환되는 레거시 이유로 인해이를 변경할 수 없습니다. &lt;code&gt;random-quick-start&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c77dfb74768b5914a720e322bd9c4f4d3188beb4" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, datetime64 still parses timezone offsets, which it handles by converting to UTC. However, the resulting datetime is timezone naive:</source>
          <target state="translated">이전 버전과의 호환성을 위해 datetime64는 여전히 표준 시간대 오프셋을 구문 분석하여 UTC로 변환하여 처리합니다. 그러나 결과 날짜 시간은 표준 시간대입니다.</target>
        </trans-unit>
        <trans-unit id="1c64f15e60882d9539499a036901b91bc24bc19f" translate="yes" xml:space="preserve">
          <source>For backwards compatibility, the form (str, array of 624 uints, int) is also accepted although it is missing some information about the cached Gaussian value: &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt;.</source>
          <target state="translated">이전 버전과의 호환성을 위해 캐시 된 가우시안 값에 대한 정보 &lt;code&gt;state = ('MT19937', keys, pos)&lt;/code&gt; 가 누락되었지만 양식 (str, 624 uints, int의 배열)도 허용 됩니다.</target>
        </trans-unit>
        <trans-unit id="4eb2208bc27c7545536cb93635c9264ced09a6ad" translate="yes" xml:space="preserve">
          <source>For bandlimited interpolation of discrete-time signals, the ideal interpolation kernel is proportional to the sinc function.</source>
          <target state="translated">불연속 시간 신호의 대역 제한 보간의 경우 이상적인 보간 커널은 sinc 함수에 비례합니다.</target>
        </trans-unit>
        <trans-unit id="0640d05a7ef317b56adcd70bde409c84daf4b12d" translate="yes" xml:space="preserve">
          <source>For buffered loops, care must be taken to copy and cast data before the loop function is called because the underlying loop expects aligned data of the correct data-type (including byte-order). The buffered loop must handle this copying and casting prior to calling the loop function on chunks no greater than the user-specified bufsize.</source>
          <target state="translated">버퍼링 된 루프의 경우 루프 함수가 호출되기 전에 기본 루프가 올바른 데이터 유형 (바이트 순서 포함)의 정렬 된 데이터를 기대하기 때문에 데이터를 복사하고 캐스트하기 위해주의를 기울여야합니다. 버퍼링 된 루프는 사용자 지정 bufsize보다 크지 않은 청크에서 루프 함수를 호출하기 전에이 복사 및 캐스팅을 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="cb4713bd95be47f513cc79d1a6764009b9a70f10" translate="yes" xml:space="preserve">
          <source>For building NumPy, you&amp;rsquo;ll need a recent version of Cython.</source>
          <target state="translated">NumPy를 빌드하려면 최신 버전의 Cython이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="78ea569e34a0a0f36b8d0d5224e34f847b3cf085" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="translated">명확성을 위해 유형 설명 및 해당 &lt;a href=&quot;#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 'descr'항목의 몇 가지 예를 제공하는 것이 좋습니다 . 이 예제에 대해 Scott Gilbert에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="59d48df0acbcb87d68438ff4bcf04c859beab44c" translate="yes" xml:space="preserve">
          <source>For clarity it is useful to provide some examples of the type description and corresponding &lt;a href=&quot;#object.__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt; &amp;lsquo;descr&amp;rsquo; entries. Thanks to Scott Gilbert for these examples:</source>
          <target state="translated">명확성을 위해 유형 설명 및 해당 &lt;a href=&quot;#object.__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 'descr'항목의 몇 가지 예를 제공하는 것이 유용 합니다. 다음 예제에 대해 Scott Gilbert에게 감사드립니다.</target>
        </trans-unit>
        <trans-unit id="cf57e9a465ef336bb9e191a7bcc71c622dd7e36c" translate="yes" xml:space="preserve">
          <source>For clearly intentional breaches, report those to the Code of Conduct committee (see below). For possibly unintentional breaches, you may reply to the person and point out this code of conduct (either in public or in private, whatever is most appropriate). If you would prefer not to do that, please feel free to report to the Code of Conduct Committee directly, or ask the Committee for advice, in confidence.</source>
          <target state="translated">분명히 의도적 인 위반에 대해서는 행동 강령위원회에보고하십시오 (아래 참조). 의도하지 않은 위반 일 가능성이있는 경우, 귀하는 그 사람에게 회신하고이 행동 강령을 지적 할 수 있습니다 (가장 적절한 곳에서 공개 또는 비공개로). 그렇게하고 싶지 않다면 행동 강령위원회에 직접보고하거나위원회에 자신있게 조언을 구하십시오.</target>
        </trans-unit>
        <trans-unit id="fa38704d039a01dbf3beb91b9abfe39ad94c5927" translate="yes" xml:space="preserve">
          <source>For code changes, at least one maintainer (i.e. someone with commit rights) should review and approve a pull request. If you are the first to review a PR and approve of the changes use the GitHub &lt;a href=&quot;https://help.github.com/articles/reviewing-changes-in-pull-requests/&quot;&gt;approve review&lt;/a&gt; tool to mark it as such. If a PR is straightforward, for example it&amp;rsquo;s a clearly correct bug fix, it can be merged straight away. If it&amp;rsquo;s more complex or changes public API, please leave it open for at least a couple of days so other maintainers get a chance to review.</source>
          <target state="translated">코드 변경의 경우 적어도 한 명의 유지 관리자 (예 : 커밋 권한이있는 사람)가 풀 요청을 검토하고 승인해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ PR을 처음으로 검토하고 변경 사항을 &lt;a href=&quot;https://help.github.com/articles/reviewing-changes-in-pull-requests/&quot;&gt;승인&lt;/a&gt; 하는 경우 GitHub 승인 검토 도구를 사용하여 이를 표시합니다. PR이 간단하다면, 예를 들어 명확하게 올바른 버그 수정 인 경우 바로 병합 할 수 있습니다. 더 복잡하거나 공개 API가 변경된 경우 다른 관리자가 검토 할 수 있도록 최소한 며칠 동안 열어 두십시오.</target>
        </trans-unit>
        <trans-unit id="f79e4e860ac02f7665b97a2330e074b2889f9891" translate="yes" xml:space="preserve">
          <source>For comparison and general edification of the reader we provide a simple implementation of a C extension of logit that uses no numpy.</source>
          <target state="translated">독자의 비교 및 ​​일반 수정을 위해 numpy를 사용하지 않는 로짓의 C 확장의 간단한 구현을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="90d52548b7d82f8c08562b9cefe270c672ec6067" translate="yes" xml:space="preserve">
          <source>For comparison with the other methods to be discussed. Here is another example of a function that filters a two-dimensional array of double precision floating-point numbers using a fixed averaging filter. The advantage of using Fortran to index into multi-dimensional arrays should be clear from this example.</source>
          <target state="translated">논의 할 다른 방법과의 비교를 위해. 다음은 고정 평균화 필터를 사용하여 배정 밀도 부동 소수점 숫자의 2 차원 배열을 필터링하는 함수의 또 다른 예입니다. Fortran을 사용하여 다차원 배열로 인덱싱 할 때의 이점은이 예제에서 분명합니다.</target>
        </trans-unit>
        <trans-unit id="aefcdcec95bb0a9f49c3ea43d81c147b480f4a1a" translate="yes" xml:space="preserve">
          <source>For complete documentation of the types of floating-point exceptions and treatment options, see &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt;&lt;code&gt;seterr&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">부동 소수점 예외 유형 및 처리 옵션에 대한 전체 문서는 &lt;a href=&quot;numpy.seterr#numpy.seterr&quot;&gt; &lt;code&gt;seterr&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6638e7aa649639c70b61a262d3fcb528e530dcc" translate="yes" xml:space="preserve">
          <source>For completeness, we&amp;rsquo;ll also add the &amp;lsquo;external_loop&amp;rsquo; and &amp;lsquo;buffered&amp;rsquo; flags, as these are what you will typically want for performance reasons.</source>
          <target state="translated">완성도를 높이기 위해 'external_loop'및 'buffered'플래그를 추가합니다.이 플래그는 일반적으로 성능상의 이유로 원하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="823eefe35591ae1ef0928dcf4115410e8d28b81a" translate="yes" xml:space="preserve">
          <source>For complex arguments, &lt;code&gt;x = a + ib&lt;/code&gt;, we can write</source>
          <target state="translated">복잡한 인수 &lt;code&gt;x = a + ib&lt;/code&gt; 과 같이 쓸 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="00d19b01697a76f9042f9abe787cb066622b4409" translate="yes" xml:space="preserve">
          <source>For complex dtypes, the above is applied to each of the real and imaginary components of &lt;code&gt;x&lt;/code&gt; separately.</source>
          <target state="translated">복소수 dtype의 경우, 위의 &lt;code&gt;x&lt;/code&gt; 의 실제 및 가상의 구성 요소 각각에 개별적으로 적용 됩니다.</target>
        </trans-unit>
        <trans-unit id="7aabc240767fa8c38770aded9994dbfb9309fc85" translate="yes" xml:space="preserve">
          <source>For complex inputs, the &lt;a href=&quot;#numpy.sign&quot;&gt;&lt;code&gt;sign&lt;/code&gt;&lt;/a&gt; function returns &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt;.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;#numpy.sign&quot;&gt; &lt;code&gt;sign&lt;/code&gt; &lt;/a&gt; 함수는 &lt;code&gt;sign(x.real) + 0j if x.real != 0 else sign(x.imag) + 0j&lt;/code&gt; 반환 하고, 그렇지 않으면 sign (x.imag) + 0j를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="37a57514466afa09fc7538317ff0a405ada2d56e" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has branch cuts &lt;code&gt;[-inf, -1]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, -1]&lt;/code&gt; 및 &lt;code&gt;[1, inf]&lt;/code&gt; 를 갖는 복소수 분석 함수이며 전자에서 위와 후에서 연속됩니다.</target>
        </trans-unit>
        <trans-unit id="ff44215d073bf2342406439d430f9b3eb5cc308c" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 1]&lt;/code&gt; and is continuous from above on it.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; &lt;/a&gt; 는 브랜치 컷 &lt;code&gt;[-inf, 1]&lt;/code&gt; 있고 위에서부터 연속되는 복잡한 분석 함수입니다 .</target>
        </trans-unit>
        <trans-unit id="64f377fde8ecd4efebbb4d5831dcc8bc678877a9" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arcsin&quot;&gt;&lt;code&gt;arcsin&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has, by convention, the branch cuts [-inf, -1] and [1, inf] and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;#numpy.arcsin&quot;&gt; &lt;code&gt;arcsin&lt;/code&gt; &lt;/a&gt; 은 일반적으로 브랜치 컷 [-inf, -1] 및 [1, inf]를 가지며 복소수에서 위와 아래에서 연속되는 복소수 분석 함수입니다.</target>
        </trans-unit>
        <trans-unit id="57038706eece9d133e1f92cf4c0e30653094f94f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; is a complex analytic function that has [&lt;code&gt;1j, infj&lt;/code&gt;] and [&lt;code&gt;-1j, -infj&lt;/code&gt;] as branch cuts, and is continuous from the left on the former and from the right on the latter.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; &lt;/a&gt; 은 분기 컷으로 [ &lt;code&gt;1j, infj&lt;/code&gt; ] 및 [ &lt;code&gt;-1j, -infj&lt;/code&gt; ] 가있는 복소수 분석 함수이며 전자의 왼쪽부터 후자의 오른쪽부터 연속됩니다.</target>
        </trans-unit>
        <trans-unit id="4c701e0e2c7136fbf8b3d11659944481b8208402" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[-1, -inf]&lt;/code&gt; and &lt;code&gt;[1, inf]&lt;/code&gt; and is continuous from above on the former and from below on the latter.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-1, -inf]&lt;/code&gt; 및 &lt;code&gt;[1, inf]&lt;/code&gt; 를 갖는 복소수 분석 함수이며 전자에서 위와 후에서 연속됩니다.</target>
        </trans-unit>
        <trans-unit id="159e5638a9f1467d3dd2785cf39347fd2d548d9f" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, 0]&lt;/code&gt; 있고 위에서 연속 된 복소수 분석 함수입니다 . &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 는 C99 표준에 따라 부동 소수점 음수 0을 무한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="5ba7031abf7f62c036d84ca3e657ff0bbe63c9b4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; 은 분기 컷 &lt;code&gt;[-inf, 0]&lt;/code&gt; 가지며 위에서부터 연속되는 복소수 분석 함수입니다 . &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; &lt;/a&gt; 은 부동 소수점 음수 0을 C99 표준에 따라 무한한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="1d03218ffbd2a27086f21639f1e5d2c57e1fdb96" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, -1]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우 &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, -1]&lt;/code&gt; 있고 위에서부터 연속되는 복소수 분석 함수입니다 . &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 는 C99 표준에 따라 부동 소수점 음수 0을 무한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="714b21ba8fb7b3f93db097558f921f5a3cc7d7e7" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has a branch cut &lt;code&gt;[-inf, 0]&lt;/code&gt; and is continuous from above on it. &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; handles the floating-point negative zero as an infinitesimal negative number, conforming to the C99 standard.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[-inf, 0]&lt;/code&gt; 가지며 위에서부터 연속되는 복잡한 분석 함수입니다 . &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; &lt;/a&gt; 는 C99 표준에 따라 부동 소수점 음수 0을 무한 음수로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="a557bc2da4dcaaf761d30f4619e8e0d4a2f4e8f4" translate="yes" xml:space="preserve">
          <source>For complex-valued input, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; is a complex analytical function that has branch cuts &lt;code&gt;[1j, infj]&lt;/code&gt; and &lt;code&gt;[-1j, -infj]&lt;/code&gt; and is continuous from the right on the former and from the left on the latter.</source>
          <target state="translated">복소수 입력의 경우, &lt;a href=&quot;numpy.arccos#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; &lt;/a&gt; 는 분기 컷 &lt;code&gt;[1j, infj]&lt;/code&gt; 및 &lt;code&gt;[-1j, -infj]&lt;/code&gt; 를 갖는 복소수 분석 함수이며 전자의 오른쪽과 후자의 왼쪽에서 연속적입니다.</target>
        </trans-unit>
        <trans-unit id="3c5f909f0d078490d8b615f107e16ec3bc3a188b" translate="yes" xml:space="preserve">
          <source>For computing the ULP difference, this API does not differentiate between various representations of NAN (ULP difference between 0x7fc00000 and 0xffc00000 is zero).</source>
          <target state="translated">ULP 차이를 계산하기 위해이 API는 NAN의 다양한 표현을 구별하지 않습니다 (0x7fc00000과 0xffc00000 사이의 ULP 차이는 0 임).</target>
        </trans-unit>
        <trans-unit id="a35bd636b338ea1ca16af81a4f3e7ff1a1051ba2" translate="yes" xml:space="preserve">
          <source>For consistency we also pluralize &lt;em&gt;matrix&lt;/em&gt; as &lt;em&gt;matrices&lt;/em&gt;.</source>
          <target state="translated">일관성을 위해 &lt;em&gt;행렬&lt;/em&gt; 을 &lt;em&gt;행렬&lt;/em&gt; 로 복수화 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="e81428e8e562739a6cb03d81d7a49ece97991e48" translate="yes" xml:space="preserve">
          <source>For consistency with histogram, an array of pre-computed bins is passed through unmodified:</source>
          <target state="translated">히스토그램과 일관성을 유지하기 위해 사전 계산 된 빈 배열이 수정되지 않은 상태로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="67034429080fa2a52e171f0ea36b0dba67f26dbe" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="translated">편의성과 이전 버전과의 호환성을 위해 단일 &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 인스턴스의 메서드를 numpy.random 네임 스페이스로 가져옵니다 . 전체 목록 은 &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; 을 참조 하세요.</target>
        </trans-unit>
        <trans-unit id="eed4c585fafb6282979d170d7fc49312f2240470" translate="yes" xml:space="preserve">
          <source>For convenience and backward compatibility, a single &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; instance&amp;rsquo;s methods are imported into the numpy.random namespace, see &lt;a href=&quot;legacy#legacy&quot;&gt;Legacy Random Generation&lt;/a&gt; for the complete list.</source>
          <target state="translated">편의성과 이전 버전과의 호환성을 위해 단일 &lt;a href=&quot;legacy#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 인스턴스의 메서드를 numpy.random 네임 스페이스로 가져옵니다 . 전체 목록 은 &lt;a href=&quot;legacy#legacy&quot;&gt;레거시 임의 생성&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c5ee4a5df11f7bfc54cc9624f04508c5055fa329" translate="yes" xml:space="preserve">
          <source>For convenience, dtype-like objects are allowed too:</source>
          <target state="translated">편의상 dtype과 유사한 객체도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d4b499147b3255a0848424ec58891503672c9043" translate="yes" xml:space="preserve">
          <source>For convenience, viewing an ndarray as type &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;numpy.recarray&lt;/code&gt;&lt;/a&gt; will automatically convert to &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt;&lt;code&gt;numpy.record&lt;/code&gt;&lt;/a&gt; datatype, so the dtype can be left out of the view:</source>
          <target state="translated">편의를 위해, 형 같은 ndarray보기 &lt;a href=&quot;../reference/generated/numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;numpy.recarray&lt;/code&gt; 하면&lt;/a&gt; 자동으로 변환됩니다 &lt;a href=&quot;../reference/generated/numpy.record#numpy.record&quot;&gt; &lt;code&gt;numpy.record&lt;/code&gt; &lt;/a&gt; DTYPE는 견해를 생략 할 수 있도록, 데이터 타입 :</target>
        </trans-unit>
        <trans-unit id="5d0d8cd3e47bac7d4c34c5ffeca248e53bd90070" translate="yes" xml:space="preserve">
          <source>For convenience, viewing an ndarray as type &lt;code&gt;np.recarray&lt;/code&gt; will automatically convert to &lt;code&gt;np.record&lt;/code&gt; datatype, so the dtype can be left out of the view:</source>
          <target state="translated">편의를 위해, 형 같은 ndarray보기 &lt;code&gt;np.recarray&lt;/code&gt; 하면 자동으로 변환됩니다 &lt;code&gt;np.record&lt;/code&gt; DTYPE는 견해를 생략 할 수 있도록, 데이터 타입 :</target>
        </trans-unit>
        <trans-unit id="96d19661d614c330e3a9e7e16801d7b1d4abdea7" translate="yes" xml:space="preserve">
          <source>For data types that are always the same size (such as long), this holds the size of the data type. For flexible data types where different arrays can have a different elementsize, this should be 0.</source>
          <target state="translated">항상 같은 크기 (예 : long) 인 데이터 형식의 경우 데이터 형식의 크기가 유지됩니다. 다른 배열이 다른 요소 화를 가질 수있는 유연한 데이터 유형의 경우 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="88871b72e212455bd0a3305f24c658a9086cd65b" translate="yes" xml:space="preserve">
          <source>For data types that describe sub-arrays:</source>
          <target state="translated">하위 배열을 설명하는 데이터 형식의 경우 :</target>
        </trans-unit>
        <trans-unit id="665e908efd043172f3a61d4025a859ec2c83aba8" translate="yes" xml:space="preserve">
          <source>For definition of the DFT and conventions used.</source>
          <target state="translated">사용 된 DFT 및 규칙의 정의</target>
        </trans-unit>
        <trans-unit id="ab3224da37c952c7ee78825693d56ab41a6cbfcf" translate="yes" xml:space="preserve">
          <source>For detailed info on testing, see &lt;a href=&quot;../dev/development_environment#testing-builds&quot;&gt;Testing builds&lt;/a&gt;</source>
          <target state="translated">테스트에 대한 자세한 내용 &lt;a href=&quot;../dev/development_environment#testing-builds&quot;&gt;은 빌드&lt;/a&gt; 테스트를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="ec4950c0b9d4572d83c373887e2dc02d9903faa1" translate="yes" xml:space="preserve">
          <source>For detailed info on testing, see &lt;a href=&quot;../dev/development_environment#testing-builds&quot;&gt;Testing builds&lt;/a&gt;.</source>
          <target state="translated">테스트에 대한 자세한 내용 &lt;a href=&quot;../dev/development_environment#testing-builds&quot;&gt;은 빌드&lt;/a&gt; 테스트를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="7a502ff1fedca44e300edcd6fc726294bd80e3a6" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;reference/arrays.indexing#combining-advanced-and-basic-indexing&quot;&gt;Combining advanced and basic indexing&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;reference/arrays.indexing#combining-advanced-and-basic-indexing&quot;&gt;고급 및 기본 색인 결합을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6701df0a65502fea701e9eaccf014eb1fd8330e1" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;reference/generated/numpy.ndarray.strides&quot;&gt;numpy.ndarray.strides&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;reference/generated/numpy.ndarray.strides&quot;&gt;numpy.ndarray.strides를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ee181d2e905ec980587d0f6f8baa5bee416075ef" translate="yes" xml:space="preserve">
          <source>For details, see &lt;a href=&quot;reference/maskedarray&quot;&gt;Masked arrays.&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;reference/maskedarray&quot;&gt;마스킹 된 배열을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="fb5f8bb3afe673736236ecca5864cdc9f7fc37e1" translate="yes" xml:space="preserve">
          <source>For developers of NumPy: do not instantiate this at the module level. The initial calculation of these parameters is expensive and negatively impacts import times. These objects are cached, so calling &lt;code&gt;finfo()&lt;/code&gt; repeatedly inside your functions is not a problem.</source>
          <target state="translated">NumPy 개발자의 경우 : 모듈 수준에서이를 인스턴스화하지 마십시오. 이러한 매개 변수의 초기 계산은 비용이 많이 들고 가져 오기 시간에 부정적인 영향을 미칩니다. 이러한 객체는 캐시되므로 함수 내에서 반복적으로 &lt;code&gt;finfo()&lt;/code&gt; 호출 하는 것은 문제가되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="83549bc3ff37e9fd5f340310941a033ae7a10e48" translate="yes" xml:space="preserve">
          <source>For development, you can set up an in-place build so that changes made to &lt;code&gt;.py&lt;/code&gt; files have effect without rebuild. First, run:</source>
          <target state="translated">개발의 경우 &lt;code&gt;.py&lt;/code&gt; 파일에 대한 변경 사항이 다시 빌드하지 않고도 적용 되도록 인플레 이스 빌드를 설정할 수 있습니다 . 먼저 다음을 실행하십시오.</target>
        </trans-unit>
        <trans-unit id="c58f9c7b61fa3d8a2763dc4a797daee41cc03eb8" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, a set of &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; flags</source>
          <target state="translated">각각의 개별 코어 차원에 대해 &lt;code&gt;UFUNC_CORE_DIM*&lt;/code&gt; 플래그 세트</target>
        </trans-unit>
        <trans-unit id="396b05c439db2438a9382de672b6fa8e95c31893" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="translated">각각의 개별 코어 치수에 대해 &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; 가 0 인 경우 가능한 &lt;a href=&quot;c-api.generalized-ufuncs#frozen&quot;&gt;고정&lt;/a&gt; 크기</target>
        </trans-unit>
        <trans-unit id="8b65708e0333bae4a0da4450d76b725e5999f9f5" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;a href=&quot;#c.UFUNC_CORE_DIM_SIZE_INFERRED&quot;&gt;&lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">고유 한 각 코어 차원에 대해 &lt;a href=&quot;#c.UFUNC_CORE_DIM_SIZE_INFERRED&quot;&gt; &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;0&lt;/code&gt; 인 경우 가능한 &lt;a href=&quot;generalized-ufuncs#frozen&quot;&gt;고정&lt;/a&gt; 크기</target>
        </trans-unit>
        <trans-unit id="69d98b78325a9c10a5d66de529392752b9338931" translate="yes" xml:space="preserve">
          <source>For each distinct core dimension, the possible &lt;a href=&quot;generalized-ufuncs#frozen&quot;&gt;frozen&lt;/a&gt; size if &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; is 0</source>
          <target state="translated">고유 한 각 코어 차원에 대해 &lt;code&gt;UFUNC_CORE_DIM_SIZE_INFERRED&lt;/code&gt; 가 0 인 경우 가능한 &lt;a href=&quot;generalized-ufuncs#frozen&quot;&gt;고정&lt;/a&gt; 크기</target>
        </trans-unit>
        <trans-unit id="eb98f2bacd6f2ddd2321b31d6e02518d57ef1a01" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 선택적 인수 &lt;code&gt;deletechars&lt;/code&gt; 에서 발생하는 모든 문자 가 제거되고 나머지 문자는 지정된 변환 표를 통해 매핑 된 문자열의 복사본을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="6fd82d55a1666ac371b70f835404bd2254f11112" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 모든 하위 문자열 &lt;code&gt;old&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 로 대체 된 문자열의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="a0072392849c4a29d135980cb1732127fb7c8293" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 선행 및 후행 문자가 제거 된 사본을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="ce017fa2090bd21769500e23616f51df45b2cf16" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 선행 문자가 제거 된 사본을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="bcc8c5cf0a4ab8429da79ab635d524c5cd68a8b9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 후행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="b48d2d67a82f24a073bc0fd48d1c7c812f1f1bea" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">의 각 요소에 대해 , 라인 경계에서 파괴, 요소의 라인의 목록을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d96129628d06f13e5afb8f18fe53cee0a045c865" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">의 각 요소에 &lt;code&gt;a&lt;/code&gt; 구분 기호 문자열로 &lt;code&gt;sep&lt;/code&gt; 를 사용하여 문자열의 단어 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="53321b75d28930691a06237aff36907b43cca790" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">각 요소 서브 스트링, 여기서 스트링에서 가장 높은 인덱스를 반환 &lt;code&gt;sub&lt;/code&gt; 발견되도록, &lt;code&gt;sub&lt;/code&gt; [내에 포함 된 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ]. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e01fe9cacbc57867bf7b4b4ec2f69fefe5c4a037" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the first occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 각 요소에 대해 요소 를 &lt;code&gt;sep&lt;/code&gt; 의 첫 번째 발생으로 분할하고 구분 기호 앞 부분, 구분자 자체 및 구분 기호 뒤 부분을 포함하는 3 개의 문자열을 반환합니다. 구분 기호를 찾을 수 없으면 문자열 자체를 포함하는 3 개의 문자열과 두 개의 빈 문자열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7288d8c0ac4641f453c7b03f986690cbb92d91ab" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;a&lt;/code&gt;, split the element as the last occurrence of &lt;code&gt;sep&lt;/code&gt;, and return 3 strings containing the part before the separator, the separator itself, and the part after the separator. If the separator is not found, return 3 strings containing the string itself, followed by two empty strings.</source>
          <target state="translated">각 요소 , 마지막에 검출 소자로 분할 &lt;code&gt;sep&lt;/code&gt; 및 세퍼레이터 세퍼레이터 자체 세퍼레이터 뒷부분 전에 수용 부 (3 개) 스트링을 반환한다. 구분 기호를 찾을 수 없으면 문자열 자체를 포함하는 3 개의 문자열과 두 개의 빈 문자열을 반환합니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2be6980f0e55faed04690c7996e6d49756d7224" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only decimal characters in the element.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 요소에 10 진수 만 있으면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b59ff6bcceb7225ac9cadb07484ec0465abb9c2a" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return True if there are only numeric characters in the element.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 요소에 숫자 만있는 경우 True를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="9058afe727e5f02cb1c2a82daba2773477e47ab5" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string where all characters occurring in the optional argument &lt;code&gt;deletechars&lt;/code&gt; are removed, and the remaining characters have been mapped through the given translation table.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 선택적 인수 &lt;code&gt;deletechars&lt;/code&gt; 에서 발생하는 모든 문자 가 제거되고 나머지 문자가 제공된 변환 표를 통해 맵핑 된 문자열의 사본을 리턴 하십시오.</target>
        </trans-unit>
        <trans-unit id="ef526a1c4bb908663ee9a7ed64b48415ce75d7c1" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with all occurrences of substring &lt;code&gt;old&lt;/code&gt; replaced by &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 모든 하위 문자열 &lt;code&gt;old&lt;/code&gt; 가 &lt;code&gt;new&lt;/code&gt; 로 대체 된 문자열의 복사본을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="9e51c79c7e0159f28fc2312e8504acece61be2e0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy of the string with uppercase characters converted to lowercase and vice versa.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 대문자를 소문자로 변환 한 문자열의 복사본을 반환하고 그 반대의 경우도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="563e89160eca98fee13c4e654d4638943cb7ede0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading and trailing characters removed.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 선행 및 후행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="a46f8951acf83f33ee77a16371dbcf5fcea54c99" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the leading characters removed.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 선행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="c528552cf6666391ba164c6c98e3136c037ac0d0" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a copy with the trailing characters removed.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 후행 문자가 제거 된 사본을 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="f3c87a7be827172789e8630db0faa9be334e4260" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the lines in the element, breaking at line boundaries.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 요소 의 행 목록을 리턴하고 행 경계를 끊습니다.</target>
        </trans-unit>
        <trans-unit id="3ca0a78fe28a9ed4242353e9fcde6e632b8bffa9" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a list of the words in the string, using &lt;code&gt;sep&lt;/code&gt; as the delimiter string.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 &lt;code&gt;sep&lt;/code&gt; 를 구분 기호 문자열로 사용하여 문자열의 단어 목록을 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="41b923cc154e9a0efebee6038be59b5d66a9e904" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return a titlecased version of the string: words start with uppercase characters, all remaining cased characters are lowercase.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 의 각 요소에 대해 제목이 지정된 문자열 버전을 반환합니다. 단어는 대문자로 시작하고 나머지 모든 대문자는 소문자입니다.</target>
        </trans-unit>
        <trans-unit id="a4fdbaa4039cefb583d1742ab7a44dc37da553da" translate="yes" xml:space="preserve">
          <source>For each element in &lt;code&gt;self&lt;/code&gt;, return the highest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained within [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">각 요소에 대하여 &lt;code&gt;self&lt;/code&gt; 서브 스트링, 여기서 스트링에서 가장 높은 인덱스를 반환 &lt;code&gt;sub&lt;/code&gt; 발견되도록, &lt;code&gt;sub&lt;/code&gt; [내에 포함 된 &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="66977f41b0aa64aabf235a79a75dcf6b6472f8b1" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only decimal characters in the element.</source>
          <target state="translated">각 요소에 대해 요소에 10 진수 만 있으면 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b1bf891f44f7ba1a69d9acfd1c67a586b04384f4" translate="yes" xml:space="preserve">
          <source>For each element, return True if there are only numeric characters in the element.</source>
          <target state="translated">각 요소에 대해 요소에 숫자 만있는 경우 True를 리턴하십시오.</target>
        </trans-unit>
        <trans-unit id="de1f34aa0e69ee353932bddbc1b5178f2575078b" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found, such that &lt;code&gt;sub&lt;/code&gt; is contained in the range [&lt;code&gt;start&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;].</source>
          <target state="translated">각 요소에 대해 substring &lt;code&gt;sub&lt;/code&gt; 가 있는 문자열에서 가장 낮은 인덱스를 반환하여 &lt;code&gt;sub&lt;/code&gt; 가 [ &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;end&lt;/code&gt; ] 범위에 포함되도록합니다 .</target>
        </trans-unit>
        <trans-unit id="2d0516f761ea835ae249621609400fab8f420640" translate="yes" xml:space="preserve">
          <source>For each element, return the lowest index in the string where substring &lt;code&gt;sub&lt;/code&gt; is found.</source>
          <target state="translated">각 요소에 대해 하위 문자열 &lt;code&gt;sub&lt;/code&gt; 가 있는 문자열에서 가장 낮은 인덱스를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1a1da4bbdbc0f0985083d16493c494b0cdbca1db" translate="yes" xml:space="preserve">
          <source>For efficient memory alignment, &lt;code&gt;np.longdouble&lt;/code&gt; is usually stored padded with zero bits, either to 96 or 128 bits. Which is more efficient depends on hardware and development environment; typically on 32-bit systems they are padded to 96 bits, while on 64-bit systems they are typically padded to 128 bits. &lt;code&gt;np.longdouble&lt;/code&gt; is padded to the system default; &lt;code&gt;np.float96&lt;/code&gt; and &lt;code&gt;np.float128&lt;/code&gt; are provided for users who want specific padding. In spite of the names, &lt;code&gt;np.float96&lt;/code&gt; and &lt;code&gt;np.float128&lt;/code&gt; provide only as much precision as &lt;code&gt;np.longdouble&lt;/code&gt;, that is, 80 bits on most x86 machines and 64 bits in standard Windows builds.</source>
          <target state="translated">효율적인 메모리 정렬을 위해 &lt;code&gt;np.longdouble&lt;/code&gt; 은 일반적으로 0 비트 (96 비트 또는 128 비트)로 채워져 저장됩니다. 더 효율적인 것은 하드웨어 및 개발 환경에 따라 다릅니다. 일반적으로 32 비트 시스템에서는 96 비트로 패딩되고 64 비트 시스템에서는 일반적으로 128 비트로 패딩됩니다. &lt;code&gt;np.longdouble&lt;/code&gt; 은 시스템 기본값으로 채워집니다. &lt;code&gt;np.float96&lt;/code&gt; 및 &lt;code&gt;np.float128&lt;/code&gt; 은 특정 패딩을 원하는 사용자를 위해 제공됩니다. 이름,에도 불구하고 &lt;code&gt;np.float96&lt;/code&gt; 및 &lt;code&gt;np.float128&lt;/code&gt; 만큼 정밀로만 제공 &lt;code&gt;np.longdouble&lt;/code&gt; 이며, 대부분의 x86 시스템에서 80 비트 및 Windows 빌드 표준 64 비트.</target>
        </trans-unit>
        <trans-unit id="42afabee0f54dc6a738be8285f1c8adb1a389c2c" translate="yes" xml:space="preserve">
          <source>For events with an expected separation</source>
          <target state="translated">분리가 예상되는 이벤트의 경우</target>
        </trans-unit>
        <trans-unit id="69f5ea3c2094e2e0d29f615dbd5f1be3db9e9635" translate="yes" xml:space="preserve">
          <source>For example &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;slicing&lt;/a&gt; can produce views of the array:</source>
          <target state="translated">예를 들어 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;슬라이싱&lt;/a&gt; 은 배열의 뷰를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ba61c52342c8ca357f9b025f520786b1e36f952" translate="yes" xml:space="preserve">
          <source>For example suppose the source directory contains fun/foo.dat and fun/bar/car.dat:</source>
          <target state="translated">예를 들어 소스 디렉토리에 fun / foo.dat 및 fun / bar / car.dat가 있다고 가정하십시오.</target>
        </trans-unit>
        <trans-unit id="1b62eba4a89119c28458eb16bfa619aca8aa8969" translate="yes" xml:space="preserve">
          <source>For example you might make a startup script that looks like this (Note: this is just an example, not a statement of &amp;ldquo;best practices&amp;rdquo;):</source>
          <target state="translated">예를 들어 다음과 같은 시작 스크립트를 만들 수 있습니다 (참고 : 이것은 &quot;모범 사례&quot;가 아닌 예일뿐입니다).</target>
        </trans-unit>
        <trans-unit id="290de80d5fc36b01dd67ceeb09359da7bf8e0291" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 에는 624 개의 &lt;code&gt;uint32&lt;/code&gt; 정수 로 구성된 상태가 있습니다. 32 비트 정수 시드를 사용하는 순진한 방법은 상태의 마지막 요소를 32 비트 시드로 설정하고 나머지는 0으로 두는 것입니다. 이것은 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 의 유효한 상태 이지만 좋은 상태는 아닙니다 . Mersenne Twister 알고리즘 &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;은 0이 너무 많으면 문제가 발생&lt;/a&gt; 합니다. 유사하게, 2 개의 인접한 32 비트 정수 시드 (즉, &lt;code&gt;12345&lt;/code&gt; 및 &lt;code&gt;12346&lt;/code&gt; )는 매우 유사한 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c528a73750dc2b0ea8c9a4908a64744d7d47416a" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; has a state consisting of 624 &lt;code&gt;uint32&lt;/code&gt; integers. A naive way to take a 32-bit integer seed would be to just set the last element of the state to the 32-bit seed and leave the rest 0s. This is a valid state for &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt;, but not a good one. The Mersenne Twister algorithm &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;suffers if there are too many 0s&lt;/a&gt;. Similarly, two adjacent 32-bit integer seeds (i.e. &lt;code&gt;12345&lt;/code&gt; and &lt;code&gt;12346&lt;/code&gt;) would produce very similar streams.</source>
          <target state="translated">예를 들어 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 의 상태는 624 개의 &lt;code&gt;uint32&lt;/code&gt; 정수 로 구성 됩니다. 32 비트 정수 시드를 사용하는 순진한 방법은 상태의 마지막 요소를 32 비트 시드로 설정하고 나머지는 0으로 두는 것입니다. 이것은 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; 에&lt;/a&gt; 유효한 상태 이지만 좋은 상태는 아닙니다 . Mersenne Twister 알고리즘 &lt;a href=&quot;http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/MT2002/emt19937ar.html&quot;&gt;은 0이 너무 많으면 어려움을 겪습니다&lt;/a&gt; . 유사하게, 2 개의 인접한 32 비트 정수 시드 (즉, &lt;code&gt;12345&lt;/code&gt; 및 &lt;code&gt;12346&lt;/code&gt; )는 매우 유사한 스트림을 생성 할 것이다.</target>
        </trans-unit>
        <trans-unit id="c92ea12ee3f0aa3697d45f7df6d6af24fc7fd6b1" translate="yes" xml:space="preserve">
          <source>For example, F2PY generates from</source>
          <target state="translated">예를 들어, F2PY는 다음에서 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="30f8823abb19bf71600d2b51cdc69b652a8cdb6f" translate="yes" xml:space="preserve">
          <source>For example, I might be working on a computer with a little-endian CPU - such as an Intel Pentium, but I have loaded some data from a file written by a computer that is big-endian. Let&amp;rsquo;s say I have loaded 4 bytes from a file written by a Sun (big-endian) computer. I know that these 4 bytes represent two 16-bit integers. On a big-endian machine, a two-byte integer is stored with the Most Significant Byte (MSB) first, and then the Least Significant Byte (LSB). Thus the bytes are, in memory order:</source>
          <target state="translated">예를 들어, Intel Pentium과 같은 little-endian CPU가있는 컴퓨터에서 작업 할 수 있지만 big-endian 컴퓨터에서 작성한 파일에서 일부 데이터를로드했습니다. Sun (big-endian) 컴퓨터에서 작성한 파일에서 4 바이트를로드했다고 가정 해 보겠습니다. 이 4 바이트는 두 개의 16 비트 정수를 나타냅니다. 빅 엔디안 머신에서 2 바이트 정수는 MSB (Most Significant Byte)를 먼저 저장 한 다음 LBS (Least Significant Byte)를 사용하여 저장합니다. 따라서 바이트는 메모리 순서로 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="214075869a9c515ee07024b57bc4ea923a1819de" translate="yes" xml:space="preserve">
          <source>For example, a 2x2 array &lt;code&gt;A&lt;/code&gt; is Fortran-contiguous if its elements are stored in memory in the following order:</source>
          <target state="translated">예를 들어, 2x2 배열 &lt;code&gt;A&lt;/code&gt; 는 해당 요소가 다음 순서로 메모리에 저장되는 경우 포트란에 인접합니다.</target>
        </trans-unit>
        <trans-unit id="e8f7cf41730b21d0b9a823684d400d6bc79bd0dc" translate="yes" xml:space="preserve">
          <source>For example, a function &lt;code&gt;myrange(n)&lt;/code&gt; generated from the following signature</source>
          <target state="translated">예를 들어, 다음 서명에서 생성 된 &lt;code&gt;myrange(n)&lt;/code&gt; 함수</target>
        </trans-unit>
        <trans-unit id="32bc5e66732d4344162eb54fb50c625865f9eafb" translate="yes" xml:space="preserve">
          <source>For example, add.accumulate() is equivalent to np.cumsum().</source>
          <target state="translated">예를 들어 add.accumulate ()는 np.cumsum ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9a8d227d278d37b6250f8f06b0e4ddba59ee6707" translate="yes" xml:space="preserve">
          <source>For example, add.reduce() is equivalent to sum().</source>
          <target state="translated">예를 들어 add.reduce ()는 sum ()과 같습니다.</target>
        </trans-unit>
        <trans-unit id="10dea8dee68a389bd052fd52669dfbae04bf6a1e" translate="yes" xml:space="preserve">
          <source>For example, calculating 3*a, where a is an array of 32-bit floats, intuitively should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy rules indicate it can&amp;rsquo;t convert losslessly into a 32-bit float, so a 64-bit float should be the result type. By examining the value of the constant, &amp;lsquo;3&amp;rsquo;, we see that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit float.</source>
          <target state="translated">예를 들어, a가 32 비트 부동 소수점의 배열 인 3 * a를 계산하면 직관적으로 32 비트 부동 출력이 발생합니다. 3이 32 비트 정수인 경우 NumPy 규칙은 손실없이 32 비트 부동 소수점으로 변환 할 수 없음을 나타내므로 64 비트 부동 소수점이 결과 유형이어야합니다. 상수 '3'의 값을 살펴보면 32 비트 부동 소수점으로 손실없이 캐스팅 할 수있는 8 비트 정수에 맞는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e896d341feb39ad2e94789a2fa3a61f98c1ab6de" translate="yes" xml:space="preserve">
          <source>For example, consider a ufunc with signature &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt;. In this case, &lt;code&gt;args&lt;/code&gt; will contain three pointers to the data of the input/output arrays &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;. Furthermore, &lt;code&gt;dimensions&lt;/code&gt; will be &lt;code&gt;[N, I, J]&lt;/code&gt; to define the size of &lt;code&gt;N&lt;/code&gt; of the loop and the sizes &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;J&lt;/code&gt; for the core dimensions &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt;. Finally, &lt;code&gt;steps&lt;/code&gt; will be &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt;, containing all necessary strides.</source>
          <target state="translated">예를 들어, 서명이 &lt;code&gt;(i,j),(i)-&amp;gt;()&lt;/code&gt; 인 ufunc를 고려하십시오 . 이 경우 &lt;code&gt;args&lt;/code&gt; 에는 입력 / 출력 배열 &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;b&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; 의 데이터에 대한 세 개의 포인터가 포함됩니다 . 또한 루프 의 &lt;code&gt;N&lt;/code&gt; 크기 와 코어 치수 &lt;code&gt;i&lt;/code&gt; 및 &lt;code&gt;j&lt;/code&gt; 의 크기 &lt;code&gt;I&lt;/code&gt; 및 &lt;code&gt;J&lt;/code&gt; 를 정의하는 &lt;code&gt;dimensions&lt;/code&gt; 는 &lt;code&gt;[N, I, J]&lt;/code&gt; 입니다. 마지막으로, &lt;code&gt;steps&lt;/code&gt; 는 필요한 모든 보폭을 포함하는 &lt;code&gt;[a_N, b_N, c_N, a_i, a_j, b_i]&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="dcfa362f844d8235742ab06beea7b0f26a111d9a" translate="yes" xml:space="preserve">
          <source>For example, consider the following Python code:</source>
          <target state="translated">예를 들어 다음 Python 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fd012d2c6f8f118e1400f5580ac6116fd761a668" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;a href=&quot;generated/numpy.lib.scimath.log#numpy.lib.scimath.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="translated">예를 들어 분기 컷이있는 &lt;a href=&quot;generated/numpy.lib.scimath.log#numpy.lib.scimath.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 와 같은 함수의 경우이 모듈의 버전은 복잡한 평면에서 수학적으로 유효한 답을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="65c761c5136870def0974489fd65a1f38ad92d78" translate="yes" xml:space="preserve">
          <source>For example, for functions like &lt;code&gt;log&lt;/code&gt; with branch cuts, the versions in this module provide the mathematically valid answers in the complex plane:</source>
          <target state="translated">예를 들어 분기 컷이있는 &lt;code&gt;log&lt;/code&gt; 와 같은 함수의 경우이 모듈의 버전은 복잡한 평면에서 수학적으로 유효한 답을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1ae012c1a0fdd5d83c39490663637fce0836fd8c" translate="yes" xml:space="preserve">
          <source>For example, here is a typical source generator function:</source>
          <target state="translated">예를 들어, 일반적인 소스 생성기 기능은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8b8fb16e550a85407367bfc6afd6fdca65ea7296" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3 x &lt;code&gt;N&lt;/code&gt; array, an operation along axis 0 behaves as if its argument were an array containing slices of each row:</source>
          <target state="translated">예를 들어 &lt;code&gt;a&lt;/code&gt; 가 3 x &lt;code&gt;N&lt;/code&gt; 배열 인 경우 축 0을 따른 연산은 인수가 각 행의 조각을 포함하는 배열 인 것처럼 동작합니다.</target>
        </trans-unit>
        <trans-unit id="5f16b11fb1616884a1f7f0284cf2a3ad3bd24f37" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;a&lt;/code&gt; is a 3x3 array:</source>
          <target state="translated">예를 들어, &lt;code&gt;a&lt;/code&gt; 가 3x3 배열 인 경우 :</target>
        </trans-unit>
        <trans-unit id="7e1eba6b832e945c1e4ddb165d50f426b3bfee26" translate="yes" xml:space="preserve">
          <source>For example, if an iterator was created with a single array as its input, and it was possible to rearrange all its axes and then collapse it into a single strided iteration, this would return a view that is a one-dimensional array.</source>
          <target state="translated">예를 들어, 단일 배열을 입력으로 사용하여 반복자가 생성되고 모든 축을 재정렬 한 다음 단일 스트라이드 반복으로 축소 할 수 있으면 1 차원 배열 인 뷰가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a7f0071af46179382458b34ec09b89b95e091389" translate="yes" xml:space="preserve">
          <source>For example, if we choose</source>
          <target state="translated">예를 들어, 우리가 선택하면</target>
        </trans-unit>
        <trans-unit id="2ff87dba0f6e77925be276fcef4c7c831b8ea504" translate="yes" xml:space="preserve">
          <source>For example, if we want to import only the first and the last columns, we can use &lt;code&gt;usecols=(0, -1)&lt;/code&gt;:</source>
          <target state="translated">예를 들어 첫 번째 열과 마지막 열만 가져 오려면 &lt;code&gt;usecols=(0, -1)&lt;/code&gt; 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd3d9bd14f229a7eb91aaf840c6ac1f84467537b" translate="yes" xml:space="preserve">
          <source>For example, if you create this array:</source>
          <target state="translated">예를 들어, 다음 배열을 생성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="16f1b7e404a82b7d866b4be0ca94013f93955314" translate="yes" xml:space="preserve">
          <source>For example, if you create this function:</source>
          <target state="translated">예를 들어,이 함수를 생성하는 경우 :</target>
        </trans-unit>
        <trans-unit id="d4336a303ad0f6a2b1bcee09892c8545dcc3ff9f" translate="yes" xml:space="preserve">
          <source>For example, if you start with this array:</source>
          <target state="translated">예를 들어 다음 배열로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="302f8b44862add9c44dd094ba5ef88c857733962" translate="yes" xml:space="preserve">
          <source>For example, if you want your sub-class or duck-type to be compatible with numpy&amp;rsquo;s &lt;code&gt;sum&lt;/code&gt; function, the method signature for this object&amp;rsquo;s &lt;code&gt;sum&lt;/code&gt; method should be the following:</source>
          <target state="translated">예를 들어, 하위 클래스 또는 덕 유형이 numpy의 &lt;code&gt;sum&lt;/code&gt; 함수 와 호환되도록 하려면이 객체의 &lt;code&gt;sum&lt;/code&gt; 메소드에 대한 메소드 서명 은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="77b454223ff8bed8a9b0c67509f246c5fba091e9" translate="yes" xml:space="preserve">
          <source>For example, on a (typical linux x64 gcc) system, the numpy &lt;code&gt;complex64&lt;/code&gt; datatype is implemented as &lt;code&gt;struct { float real, imag; }&lt;/code&gt;. This has &amp;ldquo;true&amp;rdquo; alignment of 4 and &amp;ldquo;uint&amp;rdquo; alignment of 8 (equal to the true alignment of &lt;code&gt;uint64&lt;/code&gt;).</source>
          <target state="translated">예를 들어 (일반 Linux x64 gcc) 시스템에서 numpy &lt;code&gt;complex64&lt;/code&gt; 데이터 유형은 &lt;code&gt;struct { float real, imag; }&lt;/code&gt; . 이것은 &quot;true&quot;정렬이 4이고 &quot;uint&quot;정렬이 8입니다 ( &lt;code&gt;uint64&lt;/code&gt; 의 실제 정렬과 동일 ).</target>
        </trans-unit>
        <trans-unit id="4ae14922ef64a97a2775a05d3077ba74da55d933" translate="yes" xml:space="preserve">
          <source>For example, the coordinates of a point in 3D space &lt;code&gt;[1,&amp;nbsp;2,&amp;nbsp;1]&lt;/code&gt; has one axis. That axis has 3 elements in it, so we say it has a length of 3. In the example pictured below, the array has 2 axes. The first axis has a length of 2, the second axis has a length of 3.</source>
          <target state="translated">예를 들어, 3D 공간 &lt;code&gt;[1,&amp;nbsp;2,&amp;nbsp;1]&lt;/code&gt; 의 점 좌표 에는 하나의 축이 있습니다. 이 축에는 3 개의 요소가 있으므로 길이가 3이라고합니다. 아래 그림의 예에서 배열에는 2 개의 축이 있습니다. 첫 번째 축의 길이는 2이고 두 번째 축의 길이는 3입니다.</target>
        </trans-unit>
        <trans-unit id="a172b13cb31313d38b209503a58e68588770858e" translate="yes" xml:space="preserve">
          <source>For example, this is the mean square error formula (a central formula used in supervised machine learning models that deal with regression):</source>
          <target state="translated">예를 들어 다음은 평균 제곱 오차 공식 (회귀를 다루는지도 머신 러닝 모델에 사용되는 중심 공식)입니다.</target>
        </trans-unit>
        <trans-unit id="0368fcdf7406da31a66eddfd11e72598360ada41" translate="yes" xml:space="preserve">
          <source>For example, using a 2-D boolean array of shape (2,3) with four True elements to select rows from a 3-D array of shape (2,3,5) results in a 2-D result of shape (4,5):</source>
          <target state="translated">예를 들어, 4 개의 True 요소가있는 2 차원 부울 모양 배열 (2,3)을 사용하여 3 차원 모양 배열 (2,3,5)에서 행을 선택하면 모양 (4 , 5) :</target>
        </trans-unit>
        <trans-unit id="54b9b1c9d703092f2621c55a5b2cd1e1eddf85b5" translate="yes" xml:space="preserve">
          <source>For example, you can create an array from a regular Python list or tuple using the &lt;code&gt;array&lt;/code&gt; function. The type of the resulting array is deduced from the type of the elements in the sequences.</source>
          <target state="translated">예를 들어, &lt;code&gt;array&lt;/code&gt; 함수를 사용하여 일반 Python 목록 또는 튜플에서 배열을 만들 수 있습니다 . 결과 배열의 유형은 시퀀스의 요소 유형에서 추론됩니다.</target>
        </trans-unit>
        <trans-unit id="3fad2cb39c870a9de4b9e44ed99144a88481e6ec" translate="yes" xml:space="preserve">
          <source>For example, you can plot a 1D array like this:</source>
          <target state="translated">예를 들어 다음과 같이 1D 배열을 플로팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="390c0f644804c3940d2b75b4dff6f12c284b252d" translate="yes" xml:space="preserve">
          <source>For example, you may have an array like this one:</source>
          <target state="translated">예를 들어 다음과 같은 배열이있을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d24b595e5b1e7c226dfee05c7297047fa32fe9c1" translate="yes" xml:space="preserve">
          <source>For example, you might well want to be able to shorten &lt;code&gt;git checkout&lt;/code&gt; to &lt;code&gt;git co&lt;/code&gt;. Or you may want to alias &lt;code&gt;git diff --color-words&lt;/code&gt; (which gives a nicely formatted output of the diff) to &lt;code&gt;git wdiff&lt;/code&gt;</source>
          <target state="translated">예를 들어 &lt;code&gt;git checkout&lt;/code&gt; 을 &lt;code&gt;git co&lt;/code&gt; 로 단축 할 수 있습니다 . 또는 &lt;code&gt;git diff --color-words&lt;/code&gt; (diff의 형식이 잘 지정된 출력을 제공함)을 &lt;code&gt;git wdiff&lt;/code&gt; 로 별칭을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 :</target>
        </trans-unit>
        <trans-unit id="8b82f8996b94b3076d2602f80a0b8a902b3a3586" translate="yes" xml:space="preserve">
          <source>For examples, see the various functions.</source>
          <target state="translated">예를 들어 다양한 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="13b2e9c534395e7c5f78b138c5b0b5d135b327e2" translate="yes" xml:space="preserve">
          <source>For finite values, isclose uses the following equation to test whether two floating point values are equivalent.</source>
          <target state="translated">유한 값의 경우 isclose는 다음 방정식을 사용하여 두 부동 소수점 값이 동일한 지 테스트합니다.</target>
        </trans-unit>
        <trans-unit id="e9eda33d9c06cab528c6194c742df4404b1ba711" translate="yes" xml:space="preserve">
          <source>For fixed format Fortran codes, &lt;code&gt;&amp;lt;comment char&amp;gt;&lt;/code&gt; must be at the first column of a file, of course. For free format Fortran codes, F2PY directives can appear anywhere in a file.</source>
          <target state="translated">고정 형식 Fortran 코드의 경우, 물론 &lt;code&gt;&amp;lt;comment char&amp;gt;&lt;/code&gt; 는 파일의 첫 번째 열에 있어야합니다. 자유 형식의 Fortran 코드의 경우 F2PY 지시문은 파일의 어느 위치 에나 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d62c0e35a11ece55b5adf0e9c849759b322d0ed9" translate="yes" xml:space="preserve">
          <source>For floating point arguments, the length of the result is &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt;. Because of floating point overflow, this rule may result in the last element of &lt;code&gt;out&lt;/code&gt; being greater than &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 인수의 경우 결과 길이는 &lt;code&gt;ceil((stop - start)/step)&lt;/code&gt; 입니다. 포인트 오버플 부동하므로이 규칙의 마지막 요소가 발생할 수 &lt;code&gt;out&lt;/code&gt; 보다 큰 &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e732260153a191a109ea04ea332dadcf16bcef7" translate="yes" xml:space="preserve">
          <source>For floating point arrays, inaccurate results may appear due to usual round-off and floating point comparison issues.</source>
          <target state="translated">부동 소수점 배열의 경우 일반적인 반올림 및 부동 소수점 비교 문제로 인해 부정확 한 결과가 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e9208c67472507d398cb8a93a13859f9ce375088" translate="yes" xml:space="preserve">
          <source>For floating point numbers the numerical precision of sum (and &lt;code&gt;np.add.reduce&lt;/code&gt;) is in general limited by directly adding each number individually to the result causing rounding errors in every step. However, often numpy will use a numerically better approach (partial pairwise summation) leading to improved precision in many use-cases. This improved precision is always provided when no &lt;code&gt;axis&lt;/code&gt; is given. When &lt;code&gt;axis&lt;/code&gt; is given, it will depend on which axis is summed. Technically, to provide the best speed possible, the improved precision is only used when the summation is along the fast axis in memory. Note that the exact precision may vary depending on other parameters. In contrast to NumPy, Python&amp;rsquo;s &lt;code&gt;math.fsum&lt;/code&gt; function uses a slower but more precise approach to summation. Especially when summing a large number of lower precision floating point numbers, such as &lt;code&gt;float32&lt;/code&gt;, numerical errors can become significant. In such cases it can be advisable to use &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; to use a higher precision for the output.</source>
          <target state="translated">부동 소수점 숫자의 경우 합계 (및 &lt;code&gt;np.add.reduce&lt;/code&gt; ) 의 숫자 정밀도는 일반적으로 각 숫자를 개별적으로 직접 추가하여 모든 단계에서 반올림 오류를 발생시킴으로써 제한됩니다. 그러나 종종 numpy는 많은 유스 케이스에서 정밀도를 향상시키기 위해 수치 적으로 더 나은 접근 방식 (부분 쌍별 합계)을 사용합니다. 이 개선 된 정밀도는 &lt;code&gt;axis&lt;/code&gt; 이 제공되지 않을 때 항상 제공됩니다 . 경우 &lt;code&gt;axis&lt;/code&gt; 주어, 그 축이 합산 된 의존 할 것이다. 기술적으로 가능한 최고 속도를 제공하기 위해 향상된 정밀도는 메모리에서 요약이 빠른 축을 따르는 경우에만 사용됩니다. 정확한 정밀도는 다른 매개 변수에 따라 달라질 수 있습니다. Python의 &lt;code&gt;math.fsum&lt;/code&gt; 인 NumPy와 달리함수는 더 느리지 만 더 정확한 합계 방법을 사용합니다. 특히 &lt;code&gt;float32&lt;/code&gt; 와 같이 많은 수의 낮은 정밀도 부동 소수점 수를 합하면 숫자 오류가 커질 수 있습니다. 이러한 경우 출력에 더 높은 정밀도를 사용 하려면 &lt;code&gt;dtype=&amp;rdquo;float64&amp;rdquo;&lt;/code&gt; 를 사용하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="f41c623cdcb4a0e7f4eb2e6a140ca19a3b6cef7a" translate="yes" xml:space="preserve">
          <source>For floating-point input, the &lt;em&gt;std&lt;/em&gt; is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for float32 (see example below). Specifying a higher-accuracy accumulator using the &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 &lt;em&gt;std&lt;/em&gt; 는 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 float32의 경우 결과가 정확하지 않을 수 있습니다 (아래 예 참조). &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 키워드를 사용하여 고 정확도 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ef01297e4ccbe941536586d94ab8ef1e22c230bf" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 분산은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 &lt;a href=&quot;../arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; 의&lt;/a&gt; 경우 결과가 부정확해질 수 있습니다 (아래 예 참조). &lt;code&gt;dtype&lt;/code&gt; 키워드를 사용하여 더 높은 정확도의 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="effdce45ed2fe7c4c7447e7c5d6ed579806ca2bd" translate="yes" xml:space="preserve">
          <source>For floating-point input, the variance is computed using the same precision the input has. Depending on the input data, this can cause the results to be inaccurate, especially for &lt;code&gt;float32&lt;/code&gt; (see example below). Specifying a higher-accuracy accumulator using the &lt;code&gt;dtype&lt;/code&gt; keyword can alleviate this issue.</source>
          <target state="translated">부동 소수점 입력의 경우 분산은 입력과 동일한 정밀도를 사용하여 계산됩니다. 입력 데이터에 따라 특히 &lt;code&gt;float32&lt;/code&gt; 의 경우 결과가 정확하지 않을 수 있습니다 (아래 예 참조). &lt;code&gt;dtype&lt;/code&gt; 키워드를 사용하여 고 정확도 누산기를 지정 하면이 문제를 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d9b2341f620f885d0f8ab294ce3abbf3b1a90c60" translate="yes" xml:space="preserve">
          <source>For full documentation, see &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;numpy.searchsorted&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">전체 설명서는 &lt;a href=&quot;numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;numpy.searchsorted&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8407df90b73fe86cd7253f98195431a6f813b267" translate="yes" xml:space="preserve">
          <source>For further details, consult the numpy reference documentation on array indexing.</source>
          <target state="translated">자세한 내용은 배열 인덱싱에 대한 numpy 참조 문서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="77c711733607bfc1bae041078b86f27ea8766c29" translate="yes" xml:space="preserve">
          <source>For further information, see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;memmap&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;memmap&lt;/code&gt; 을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e11475a277ae3113deb33326346ecfc8620fa4bf" translate="yes" xml:space="preserve">
          <source>For general resources for learning &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; see &lt;a href=&quot;git_resources#git-resources&quot;&gt;Additional Git Resources&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; 학습을위한 일반 리소스는 &lt;a href=&quot;git_resources#git-resources&quot;&gt;추가 Git 리소스를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="8e32d40cffc64e1d0297c17e549d89391273d13d" translate="yes" xml:space="preserve">
          <source>For help in printing, the following strings are defined as the correct format specifier in printf and related commands.</source>
          <target state="translated">인쇄에 도움이되도록 다음 문자열은 printf 및 관련 명령에서 올바른 형식 지정자로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="489d6f9ad36355f45e025471f49df88064ca87ee" translate="yes" xml:space="preserve">
          <source>For higher dimensional arrays summing a single axis can be done with ellipsis:</source>
          <target state="translated">고차원 배열의 경우 단일 축을 줄임표로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6a424dcac51ca8b201228fd393c244dbeb8c5216" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="translated">난 속 &lt;code&gt;range(len(indices))&lt;/code&gt; , &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt; &lt;code&gt;reduceat&lt;/code&gt; &lt;/a&gt; 계산해 &lt;code&gt;ufunc.reduce(a[indices[i]:indices[i+1]])&lt;/code&gt; 를 i 번째의 일반화 된 &quot;행&quot;과 평행하게되고, &lt;code&gt;axis&lt;/code&gt; 최종 결과에 (예를 들어, 2 차원 배열에서, &lt;code&gt;axis = 0&lt;/code&gt; 이면 i 번째 행이되고 &lt;code&gt;axis = 1&lt;/code&gt; 이면 i 번째 열이됩니다). 이에 대한 세 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="a335acbc4ceafdd98dc502fc47e116da880da129" translate="yes" xml:space="preserve">
          <source>For i in &lt;code&gt;range(len(indices))&lt;/code&gt;, &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt;&lt;code&gt;reduceat&lt;/code&gt;&lt;/a&gt; computes &lt;code&gt;ufunc.reduce(array[indices[i]:indices[i+1]])&lt;/code&gt;, which becomes the i-th generalized &amp;ldquo;row&amp;rdquo; parallel to &lt;code&gt;axis&lt;/code&gt; in the final result (i.e., in a 2-D array, for example, if &lt;code&gt;axis = 0&lt;/code&gt;, it becomes the i-th row, but if &lt;code&gt;axis = 1&lt;/code&gt;, it becomes the i-th column). There are three exceptions to this:</source>
          <target state="translated">난에있어 &lt;code&gt;range(len(indices))&lt;/code&gt; , &lt;a href=&quot;#numpy.ufunc.reduceat&quot;&gt; &lt;code&gt;reduceat&lt;/code&gt; &lt;/a&gt; 계산해 &lt;code&gt;ufunc.reduce(array[indices[i]:indices[i+1]])&lt;/code&gt; , 이는의 제 i 일반화 된 &quot;행&quot;과 평행하게 &lt;code&gt;axis&lt;/code&gt; 최종 결과하여 (예를 들어 2 차원 배열에서 &lt;code&gt;axis = 0&lt;/code&gt; 이면 i 번째 행이되지만 &lt;code&gt;axis = 1&lt;/code&gt; 이면 i 번째 열이됩니다.) 이에 대한 세 가지 예외가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3e2d688963af310435591977ab9e45596586b894" translate="yes" xml:space="preserve">
          <source>For initializing an array &lt;code&gt;&amp;lt;array name&amp;gt;&lt;/code&gt;, F2PY generates a loop over all indices and dimensions that executes the following pseudo-statement:</source>
          <target state="translated">배열 &lt;code&gt;&amp;lt;array name&amp;gt;&lt;/code&gt; 을 초기화하기 위해 F2PY는 다음 의사 문을 실행하는 모든 인덱스 및 차원에 대해 루프를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="05f651225304ab9158ee3f9e677f8c577d092edf" translate="yes" xml:space="preserve">
          <source>For input arrays that are smaller than the specified buffer size, copies are made of all non-contiguous, mis-aligned, or out-of- byteorder arrays to ensure that for small arrays, a single loop is used. Then, array iterators are created for all the input arrays and the resulting collection of iterators is broadcast to a single shape.</source>
          <target state="translated">지정된 버퍼 크기보다 작은 입력 배열의 경우 작은 배열의 경우 단일 루프가 사용되도록 복사본이 연속되지 않거나 잘못 정렬되거나 바이트 순서가 아닌 모든 배열로 만들어집니다. 그런 다음 모든 입력 배열에 대해 배열 반복자가 작성되고 결과 반복자 콜렉션이 단일 모양으로 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="0c7b69e69466d27c81eb277802b5fd2ba93ef1f2" translate="yes" xml:space="preserve">
          <source>For instructions on building for source package, see &lt;a href=&quot;building&quot;&gt;Building from source&lt;/a&gt;. This information is useful mainly for advanced users.</source>
          <target state="translated">소스 패키지 작성에 대한 자세한 내용은 참조 &lt;a href=&quot;building&quot;&gt;소스에서 건물&lt;/a&gt; . 이 정보는 주로 고급 사용자에게 유용합니다.</target>
        </trans-unit>
        <trans-unit id="37dbe6dc0691b61b379d0a2afb8134a45871395a" translate="yes" xml:space="preserve">
          <source>For integer arguments with absolute value larger than 1 the result is always zero because of the way Python handles integer division. For integer zero the result is an overflow.</source>
          <target state="translated">절대 값이 1보다 큰 정수 인수의 경우 Python이 정수 나누기를 처리하는 방식으로 인해 결과는 항상 0입니다. 정수 0의 경우 결과는 오버플로입니다.</target>
        </trans-unit>
        <trans-unit id="117e2f99abde5ef34211f008976cf994cee261a9" translate="yes" xml:space="preserve">
          <source>For integer input the return values are floats.</source>
          <target state="translated">정수 입력의 경우 반환 값은 부동 소수점입니다.</target>
        </trans-unit>
        <trans-unit id="51f2302ae3afa42e90f16f1c35bbd2af61213570" translate="yes" xml:space="preserve">
          <source>For integer specifiers (eg. &lt;code&gt;d,i,o,x&lt;/code&gt;), the minimum number of digits.</source>
          <target state="translated">정수 지정자 (예 : &lt;code&gt;d,i,o,x&lt;/code&gt; )의 경우 최소 자릿수입니다.</target>
        </trans-unit>
        <trans-unit id="7401aba5507b33d4914d20070660b9faa95209c3" translate="yes" xml:space="preserve">
          <source>For integer types, exact equality is used, in the same way as &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt;&lt;code&gt;masked_equal&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 유형의 경우 &lt;a href=&quot;numpy.ma.masked_equal#numpy.ma.masked_equal&quot;&gt; &lt;code&gt;masked_equal&lt;/code&gt; &lt;/a&gt; 과 동일한 방식으로 정확한 동등성이 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="1e54c6af26706ff283ff28256c72b54eb26fbc6b" translate="yes" xml:space="preserve">
          <source>For integers, the fill value will be different in general to the result of &lt;code&gt;masked_equal&lt;/code&gt;.</source>
          <target state="translated">정수의 경우 채우기 값은 일반적으로 &lt;code&gt;masked_equal&lt;/code&gt; 결과와 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="7781ca86f57d2a847663467143f9629dfc0e85e1" translate="yes" xml:space="preserve">
          <source>For maintainers</source>
          <target state="translated">관리자 용</target>
        </trans-unit>
        <trans-unit id="975c748e73022344a91bd2ac6e7a0ad355e993bc" translate="yes" xml:space="preserve">
          <source>For many applications using a sliding window view can be convenient, but potentially very slow. Often specialized solutions exist, for example:</source>
          <target state="translated">슬라이딩 창보기를 사용하는 많은 응용 프로그램의 경우 편리 할 수 ​​있지만 잠재적으로 매우 느릴 수 있습니다. 종종 다음과 같은 특수 솔루션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7d049cee37488c14a6b5c65b1da77ab9e42f2daa" translate="yes" xml:space="preserve">
          <source>For matrices that are not square or that (for negative powers) cannot be inverted numerically.</source>
          <target state="translated">정사각형이 아니거나 (음수의 경우) 행렬의 경우 숫자로 반전 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="582e5fdc5986730f5cfb2129f1c085cdd20f4ef0" translate="yes" xml:space="preserve">
          <source>For monotonically _increasing_ &lt;code&gt;bins&lt;/code&gt;, the following are equivalent:</source>
          <target state="translated">단조롭게 _increasing_ &lt;code&gt;bins&lt;/code&gt; 의 경우 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="83fdf15871a7264e4f60e9ab78a977dea92e1a03" translate="yes" xml:space="preserve">
          <source>For more detailed documentation.</source>
          <target state="translated">보다 자세한 설명서</target>
        </trans-unit>
        <trans-unit id="3e4c0a1cf85610ffab772dbfe49c64f181ea813e" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;linalg.lstsq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;linalg.lstsq&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="be083226b3be888a488ff117c61816dc72280048" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;numpy.linalg.lstsq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;numpy.linalg.lstsq&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="37ae37abcab4e25dbfe5d8b108d91993462a8cf5" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;numpy.random.mtrand.randomstate.set_state#numpy.random.mtrand.RandomState.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e9028a5b9ca3eb796d7014cf44685275c5239e16" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.randomstate.set_state#numpy.random.RandomState.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;numpy.random.randomstate.set_state#numpy.random.RandomState.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51a8eedb7d395c27948e4922d0fabc18aafcf5ff" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;a href=&quot;numpy.random.set_state#numpy.random.set_state&quot;&gt;&lt;code&gt;set_state&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;numpy.random.set_state#numpy.random.set_state&quot;&gt; &lt;code&gt;set_state&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8f7f38b00189236c28757faab4aba491a5544afa" translate="yes" xml:space="preserve">
          <source>For more details, see &lt;code&gt;linalg.lstsq&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;linalg.lstsq&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e8a8f4e50fa887cbbddc19a83dfdf91655b33341" translate="yes" xml:space="preserve">
          <source>For more extensive information, see &lt;a href=&quot;../reference/testing#testing-guidelines&quot;&gt;Testing Guidelines&lt;/a&gt;</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../reference/testing#testing-guidelines&quot;&gt;테스트 지침을&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="95cf6089ff82991425d6efdc0504169843591543" translate="yes" xml:space="preserve">
          <source>For more help on this function please see section 1.8 (Keyword Parameters for Extension Functions) of the Extending and Embedding tutorial in the Python documentation.</source>
          <target state="translated">이 함수에 대한 자세한 도움말은 Python 문서에서 확장 및 포함 자습서의 1.8 (확장 함수에 대한 키워드 매개 변수) 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="61db67fed17b10d2110b06ec89aa13d261ade260" translate="yes" xml:space="preserve">
          <source>For more information on dictionaries, read the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;.</source>
          <target state="translated">사전에 대한 자세한 내용은 &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python 가이드를 참조하세요&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="03f4a148b39366545cf97da19167eb00139c5efc" translate="yes" xml:space="preserve">
          <source>For more information on the qr factorization, see for example: &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</source>
          <target state="translated">qr 인수 분해에 대한 자세한 정보는 다음을 참조하십시오 : &lt;a href=&quot;https://en.wikipedia.org/wiki/QR_factorization&quot;&gt;https://en.wikipedia.org/wiki/QR_factorization&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17921f717812e3320e8a7f42f4f17f79981316f9" translate="yes" xml:space="preserve">
          <source>For more information see:</source>
          <target state="translated">자세한 내용은 다음을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3985651be63157e0b3fd0f006d48347a4d4ad484" translate="yes" xml:space="preserve">
          <source>For more information, a way to suppress the warning, and an example of &lt;a href=&quot;#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; being issued, see &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt;&lt;code&gt;polyfit&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 경고를 억제 할 수있는 방법, 그리고 예를 들어 &lt;a href=&quot;#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt; 발행되는 참조 &lt;a href=&quot;numpy.polyfit#numpy.polyfit&quot;&gt; &lt;code&gt;polyfit&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8581f2666047bb23a92c8e690d1acad362013f23" translate="yes" xml:space="preserve">
          <source>For more information, read the section on lists in the &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python tutorial&lt;/a&gt;. For a mapping type (key-value), see &lt;em&gt;dictionary&lt;/em&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.python.org/tutorial/&quot;&gt;Python 가이드의&lt;/a&gt; 목록 섹션을 참조 하세요 . 매핑 유형 (키-값)은 &lt;em&gt;dictionary를&lt;/em&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6c4cae020b6b04928ab8186f1d73c1c26eba4002" translate="yes" xml:space="preserve">
          <source>For more information, refer to the &lt;a href=&quot;../index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt; module and examine the methods and attributes of an array.</source>
          <target state="translated">자세한 정보는 &lt;a href=&quot;../index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; &lt;/a&gt; 모듈을 참조 하고 배열의 메소드 및 속성을 검사하십시오.</target>
        </trans-unit>
        <trans-unit id="d0fe83d89b7a0207c98cafeb4a0d87c2838e97b1" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://docs.python.org/3/extending/building.html&quot;&gt;Building C and C++ Extensions&lt;/a&gt; Python documentation for details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://docs.python.org/3/extending/building.html&quot;&gt;C 및 C ++ 확장&lt;/a&gt; Python 문서 빌드 를 참조하세요.</target>
        </trans-unit>
        <trans-unit id="fa1433baa3f08eec4628310de483f3180d604e64" translate="yes" xml:space="preserve">
          <source>For more information, see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-push.html&quot;&gt;git push&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-push.html&quot;&gt;git push를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b974edc2834bd1e574341abd9ce885d0e7a2979b" translate="yes" xml:space="preserve">
          <source>For more information, see F2Py source code &lt;code&gt;numpy/f2py/capi_maps.py&lt;/code&gt;.</source>
          <target state="translated">자세한 내용은 F2Py 소스 코드 &lt;code&gt;numpy/f2py/capi_maps.py&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d8acef7e82b687b4dec2e9998b5824ee5ddcb0de" translate="yes" xml:space="preserve">
          <source>For more on tutorials, see the &lt;a href=&quot;https://github.com/numpy/numpy-tutorials/blob/master/tutorial_style.ipynb&quot;&gt;tutorial how-to&lt;/a&gt;.</source>
          <target state="translated">자습서에 대한 자세한 내용은 &lt;a href=&quot;https://github.com/numpy/numpy-tutorials/blob/master/tutorial_style.ipynb&quot;&gt;자습서 방법을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e76406825a4b6cfa9648b9c913c853786d5a9103" translate="yes" xml:space="preserve">
          <source>For negative input elements, a complex value is returned (unlike &lt;a href=&quot;numpy.sqrt#numpy.sqrt&quot;&gt;&lt;code&gt;numpy.sqrt&lt;/code&gt;&lt;/a&gt; which returns NaN).</source>
          <target state="translated">음수 입력 요소의 경우 복잡한 값이 반환됩니다 ( NaN을 반환하는 &lt;a href=&quot;numpy.sqrt#numpy.sqrt&quot;&gt; &lt;code&gt;numpy.sqrt&lt;/code&gt; &lt;/a&gt; 와 달리 ).</target>
        </trans-unit>
        <trans-unit id="b32b573b8f00ce30b3419ec834d75448d214948d" translate="yes" xml:space="preserve">
          <source>For negative numbers, if width is not given, a minus sign is added to the front. If width is given, the two&amp;rsquo;s complement of the number is returned, with respect to that width.</source>
          <target state="translated">음수의 경우 너비를 지정하지 않으면 빼기 부호가 앞에 추가됩니다. 너비를 지정하면 해당 너비와 관련하여 숫자의 2의 보수가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="5fc06ff1428a67551e7039c42cd5b569afbb759c" translate="yes" xml:space="preserve">
          <source>For non-Hermitian normal matrices the SciPy function &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html#scipy.linalg.schur&quot;&gt;&lt;code&gt;scipy.linalg.schur&lt;/code&gt;&lt;/a&gt; is preferred because the matrix &lt;code&gt;v&lt;/code&gt; is guaranteed to be unitary, which is not the case when using &lt;a href=&quot;#numpy.linalg.eig&quot;&gt;&lt;code&gt;eig&lt;/code&gt;&lt;/a&gt;. The Schur factorization produces an upper triangular matrix rather than a diagonal matrix, but for normal matrices only the diagonal of the upper triangular matrix is needed, the rest is roundoff error.</source>
          <target state="translated">정상적인 비 - 에르 미트 행렬 들어 SciPy 함수 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html#scipy.linalg.schur&quot;&gt; &lt;code&gt;scipy.linalg.schur&lt;/code&gt; 는&lt;/a&gt; 매트릭스 때문에 바람직하다 &lt;code&gt;v&lt;/code&gt; 사용하는 경우 그렇지 않은 어느 하나의 보장된다 &lt;a href=&quot;#numpy.linalg.eig&quot;&gt; &lt;code&gt;eig&lt;/code&gt; &lt;/a&gt; . Schur 분해는 대각 행렬이 아닌 상위 삼각형 행렬을 생성하지만 일반 행렬의 경우 상위 삼각형 행렬의 대각 행렬 만 필요하고 나머지는 반올림 오차입니다.</target>
        </trans-unit>
        <trans-unit id="e980d1d5cc881398767c8c741a7e8066463af6ac" translate="yes" xml:space="preserve">
          <source>For now, the only data formats accepted by NumPy are those also used by other Python scientific libraries like pandas, SciPy, or Matplotlib. We&amp;rsquo;re developing a package to accept more formats; contact us for details.</source>
          <target state="translated">현재 NumPy에서 허용하는 유일한 데이터 형식은 pandas, SciPy 또는 Matplotlib와 같은 다른 Python 과학 라이브러리에서도 사용되는 형식입니다. 우리는 더 많은 형식을 수용 할 수있는 패키지를 개발하고 있습니다. 자세한 내용은 당사에 문의하십시오.</target>
        </trans-unit>
        <trans-unit id="1e6d9fefb02ae78e90327bf08c7741fd4d7aad3c" translate="yes" xml:space="preserve">
          <source>For one-dimensional arrays these notions coincide.</source>
          <target state="translated">1 차원 배열의 경우 이러한 개념이 일치합니다.</target>
        </trans-unit>
        <trans-unit id="6a2721282deb17b4500d92138a510cdb4754bcd3" translate="yes" xml:space="preserve">
          <source>For operations which are either not commutative or not associative, doing a reduction over multiple axes is not well-defined. The ufuncs do not currently raise an exception in this case, but will likely do so in the future.</source>
          <target state="translated">정류 적이 지 않거나 연관성이없는 작업의 경우 여러 축에 대해 축소를 수행하는 것은 잘 정의되어 있지 않습니다. ufuncs는 현재이 경우 예외를 제기하지 않지만 앞으로는 그렇게 할 것입니다.</target>
        </trans-unit>
        <trans-unit id="cce08ac0d595dc1fc36977f113db0494cd013706" translate="yes" xml:space="preserve">
          <source>For other keyword-only arguments, see the &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs&lt;/a&gt;.</source>
          <target state="translated">다른 키워드 전용 인수는 &lt;a href=&quot;../ufuncs#ufuncs-kwargs&quot;&gt;ufunc docs를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0c08ef249ec6e440d6a8f4e999cc7fb84e271c54" translate="yes" xml:space="preserve">
          <source>For our example, we&amp;rsquo;ll create a sum of squares function. To start, let&amp;rsquo;s implement this function in straightforward Python. We want to support an &amp;lsquo;axis&amp;rsquo; parameter similar to the numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; function, so we will need to construct a list for the &lt;code&gt;op_axes&lt;/code&gt; parameter. Here&amp;rsquo;s how this looks.</source>
          <target state="translated">이 예에서는 제곱합 함수를 만듭니다. 시작하기 위해이 함수를 간단한 파이썬으로 구현해 봅시다. numpy &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 함수 와 유사한 'axis'매개 변수를 지원하려고 하므로 &lt;code&gt;op_axes&lt;/code&gt; 매개 변수에 대한 목록을 구성해야합니다 . 이것이 어떻게 보이는지 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="1bfec23fd3b5a8e4feecb9f5b43f562b252ee813" translate="yes" xml:space="preserve">
          <source>For paragraphs, indentation is significant and indicates indentation in the output. New paragraphs are marked with a blank line.</source>
          <target state="translated">단락의 경우 들여 쓰기가 중요하며 출력에서 ​​들여 쓰기를 나타냅니다. 새 단락은 빈 줄로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f8e34004cd49470f698985ea088603e79d6737af" translate="yes" xml:space="preserve">
          <source>For pickling.</source>
          <target state="translated">산세.</target>
        </trans-unit>
        <trans-unit id="45d056f2d6dc25af69ffd36f748681cb1b37bcb7" translate="yes" xml:space="preserve">
          <source>For positive integers &lt;code&gt;n&lt;/code&gt;, the power is computed by repeated matrix squarings and matrix multiplications. If &lt;code&gt;n == 0&lt;/code&gt;, the identity matrix of the same shape as M is returned. If &lt;code&gt;n &amp;lt; 0&lt;/code&gt;, the inverse is computed and then raised to the &lt;code&gt;abs(n)&lt;/code&gt;.</source>
          <target state="translated">양의 정수 &lt;code&gt;n&lt;/code&gt; 에 대해 거듭 제곱 행렬 반복과 행렬 곱셈으로 검정력을 계산합니다. &lt;code&gt;n == 0&lt;/code&gt; 인 경우 M과 동일한 모양의 항등 행렬이 반환됩니다. 경우 &lt;code&gt;n &amp;lt; 0&lt;/code&gt; , 역수 계산 된 다음에 발생 &lt;code&gt;abs(n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2868f608509a0fb880318bfa1ea537e24b697cca" translate="yes" xml:space="preserve">
          <source>For private use, NumPy also constructs a &lt;code&gt;config.h&lt;/code&gt; in the NumPy include directory, which is not exported by NumPy (that is a python extension which use the numpy C API will not see those symbols), to avoid namespace pollution.</source>
          <target state="translated">NumPy는 개인용으로 네임 스페이스 오염을 피하기 위해 NumPy include 디렉토리에 &lt;code&gt;config.h&lt;/code&gt; 를 구성합니다.이 디렉토리는 NumPy에서 내 보내지 않습니다 (즉, numpy C API를 사용하는 python 확장 프로그램은 해당 기호를 표시하지 않음).</target>
        </trans-unit>
        <trans-unit id="3cba0cef0ecc3bf15466cf0b613737ac43d7cf46" translate="yes" xml:space="preserve">
          <source>For random samples from</source>
          <target state="translated">에서 무작위 샘플</target>
        </trans-unit>
        <trans-unit id="b2439f993cba90b7273c04e2cb2a757ef0e179bf" translate="yes" xml:space="preserve">
          <source>For real, non-negative inputs this works just like &lt;a href=&quot;numpy.sqrt#numpy.sqrt&quot;&gt;&lt;code&gt;numpy.sqrt&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">음이 아닌 실제 입력의 경우 &lt;a href=&quot;numpy.sqrt#numpy.sqrt&quot;&gt; &lt;code&gt;numpy.sqrt&lt;/code&gt; &lt;/a&gt; 처럼 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="3b14ea0275a3817032fbdd7fbc1e7bdb06b2af67" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccos&quot;&gt;&lt;code&gt;arccos&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arccos&quot;&gt; &lt;code&gt;arccos&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f985096374044eb3c8f423921e1ca43a25a0a64a" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arccosh&quot;&gt;&lt;code&gt;arccosh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arccosh&quot;&gt; &lt;code&gt;arccosh&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1bd6dae91050b378f422d64d0fd3d06caee7dc76" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arcsinh&quot;&gt;&lt;code&gt;arcsinh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it returns &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arcsinh&quot;&gt; &lt;code&gt;arcsinh&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 반환 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="f1a3e2a79ac88302cd49ced01b5ae36cb593f786" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctan&quot;&gt;&lt;code&gt;arctan&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arctan&quot;&gt; &lt;code&gt;arctan&lt;/code&gt; 은&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="4e59a4a7e10620a1dcf06247438f5e136a0933eb" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.arctanh&quot;&gt;&lt;code&gt;arctanh&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.arctanh&quot;&gt; &lt;code&gt;arctanh&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="00463e3d9bf72a8660310a707c972e6c6b2f2a87" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log&quot;&gt;&lt;code&gt;log&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log&quot;&gt; &lt;code&gt;log&lt;/code&gt; &lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="1dd401d005377ef79add082427bec36bd76d7d40" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log10&quot;&gt;&lt;code&gt;log10&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log10&quot;&gt; &lt;code&gt;log10&lt;/code&gt; 은&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="18c562bcbaf668e2b82c801663121e7d15eaaa37" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="cb65926ba3df7c570cfbf88879b3b9d563294100" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;a href=&quot;#numpy.log2&quot;&gt;&lt;code&gt;log2&lt;/code&gt;&lt;/a&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;a href=&quot;#numpy.log2&quot;&gt; &lt;code&gt;log2&lt;/code&gt; 는&lt;/a&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="5a691d6f039d37de2f424c2292fd24a2e8849ab5" translate="yes" xml:space="preserve">
          <source>For real-valued input data types, &lt;em&gt;arcsin&lt;/em&gt; always returns real output. For each value that cannot be expressed as a real number or infinity, it yields &lt;code&gt;nan&lt;/code&gt; and sets the &lt;code&gt;invalid&lt;/code&gt; floating point error flag.</source>
          <target state="translated">실수 입력 데이터 유형의 경우 &lt;em&gt;arcsin은&lt;/em&gt; 항상 실제 출력을 반환합니다. 실수 또는 무한대로 표현할 수없는 각 값에 대해 &lt;code&gt;nan&lt;/code&gt; 을 생성 하고 &lt;code&gt;invalid&lt;/code&gt; 부동 소수점 오류 플래그를 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="ac8dda629e47802177efe000a2d093f5e016a0cb" translate="yes" xml:space="preserve">
          <source>For real-valued input, &lt;a href=&quot;#numpy.log1p&quot;&gt;&lt;code&gt;log1p&lt;/code&gt;&lt;/a&gt; is accurate also for &lt;code&gt;x&lt;/code&gt; so small that &lt;code&gt;1 + x == 1&lt;/code&gt; in floating-point accuracy.</source>
          <target state="translated">실수 입력의 경우, &lt;a href=&quot;#numpy.log1p&quot;&gt; &lt;code&gt;log1p&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;x&lt;/code&gt; 에 대해서도 정확 하므로 부동 소수점 정확도에서 &lt;code&gt;1 + x == 1&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="8718e777159adb99e6030aa86f73aaa6419d14ea" translate="yes" xml:space="preserve">
          <source>For repeatability and readability, the dictionary keys are sorted in alphabetic order. This is for convenience only. A writer SHOULD implement this if possible. A reader MUST NOT depend on this.</source>
          <target state="translated">반복성과 가독성을 위해 사전 키는 알파벳 순서로 정렬됩니다. 이것은 단지 편의를위한 것입니다. 작가는 가능하다면 이것을 구현해야한다. 독자는 이것에 의존해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="6bd239911d468099089301c7ec88d5d1667469b6" translate="yes" xml:space="preserve">
          <source>For reshape, resize, and transpose, the single tuple argument may be replaced with &lt;code&gt;n&lt;/code&gt; integers which will be interpreted as an n-tuple.</source>
          <target state="translated">형태 변경, 크기 조정 및 전치의 경우, 단일 튜플 인수는 n 개의 튜플로 해석되는 &lt;code&gt;n&lt;/code&gt; 개의 정수 로 대체 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6fe957d6ccb5cf28dddb483265ed8d862961930a" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value.</source>
          <target state="translated">스칼라 &lt;code&gt;a&lt;/code&gt; 의 경우 값을 보유 할 수있는 가장 작은 크기와 가장 작은 스칼라 종류의 데이터 형식을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="22863dbfbfce9a1b2c0c06d8e441eed6ee432e4b" translate="yes" xml:space="preserve">
          <source>For scalar &lt;code&gt;a&lt;/code&gt;, returns the data type with the smallest size and smallest scalar kind which can hold its value. For non-scalar array &lt;code&gt;a&lt;/code&gt;, returns the vector&amp;rsquo;s dtype unmodified.</source>
          <target state="translated">스칼라 &lt;code&gt;a&lt;/code&gt; 의 경우 값을 보유 할 수있는 가장 작은 크기와 가장 작은 스칼라 종류의 데이터 형식을 반환합니다. 스칼라가 아닌 배열 &lt;code&gt;a&lt;/code&gt; 의 경우 벡터의 dtype을 수정하지 않고 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5642e4133974cc82494c6e2e1a04d4f6b4435c53" translate="yes" xml:space="preserve">
          <source>For several methods, an optional &lt;em&gt;out&lt;/em&gt; argument can also be provided and the result will be placed into the output array given. The &lt;em&gt;out&lt;/em&gt; argument must be an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; and have the same number of elements. It can have a different data type in which case casting will be performed.</source>
          <target state="translated">여러 메소드의 경우 선택적 &lt;em&gt;out&lt;/em&gt; 인수도 제공 할 수 있으며 결과는 제공된 출력 배열에 배치됩니다. &lt;em&gt;아웃&lt;/em&gt; 인수는해야 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 와 같은 수의 원소를 가지고있다. 캐스팅이 수행되는 다른 데이터 유형을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b0753b0fcbeca94ce7630240e047138c854a65dd" translate="yes" xml:space="preserve">
          <source>For signed integer inputs, the two&amp;rsquo;s complement is returned. In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">부호있는 정수 입력의 경우 2의 보수가 반환됩니다. 2의 보수 시스템에서 음수는 2의 절대 값의 보수로 표시됩니다. 이것은 컴퓨터에서 부호있는 정수를 나타내는 가장 일반적인 방법입니다 &lt;a href=&quot;#rde927b304c4f-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N 비트 2의 보수 시스템은 범위 내의 모든 정수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a7f873acfba66a72d1ce69253d776c71ca10e17" translate="yes" xml:space="preserve">
          <source>For simplicity we give a ufunc for a single dtype, the &amp;lsquo;f8&amp;rsquo; double. As in the previous section, we first give the .c file and then the setup.py file used to create the module containing the ufunc.</source>
          <target state="translated">간단하게하기 위해 우리는 단일 dtype, 'f8'double에 대해 ufunc를 제공합니다. 이전 섹션에서와 같이 먼저 .c 파일을 제공 한 다음 ufunc를 포함하는 모듈을 만드는 데 사용되는 setup.py 파일을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1790f111eccdfcb9badd8e72bbfbae78adf5ee18" translate="yes" xml:space="preserve">
          <source>For standard library functions:</source>
          <target state="translated">표준 라이브러리 기능의 경우 :</target>
        </trans-unit>
        <trans-unit id="e58c1a1b97b83acb57ac2ac307ed0d7c16b3baf7" translate="yes" xml:space="preserve">
          <source>For structured arrays, all fields are combined, with masked values ignored. The result is masked if all fields were masked, with self and other considered equal only if both were fully masked.</source>
          <target state="translated">구조화 된 배열의 경우 모든 필드는 마스크 된 값을 무시하고 결합됩니다. 모든 필드가 마스킹 된 경우 결과가 마스킹되며, 자체 및 다른 필드가 모두 마스킹 된 경우에만 동일한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="60753f45a63d90af610aa65f98fdd4ce690bf30a" translate="yes" xml:space="preserve">
          <source>For structured datatypes with no fields this function now returns False.</source>
          <target state="translated">필드가없는 구조화 된 데이터 유형의 경우이 함수는 이제 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="54b403ec15e745ce9b0d408a4253b0a3db036c37" translate="yes" xml:space="preserve">
          <source>For structured types, a structured scalar is returned, with each field the default fill value for its type.</source>
          <target state="translated">구조화 된 유형의 경우 구조화 된 스칼라가 리턴되며 각 필드에는 해당 유형의 기본 채우기 값이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c0b7d9c35a991bbf7b4be3304607a91761fd2e6" translate="yes" xml:space="preserve">
          <source>For subarray types, the fill value is an array of the same size containing the default scalar fill value.</source>
          <target state="translated">서브 어레이 유형의 경우 채우기 값은 기본 스칼라 채우기 값을 포함하는 동일한 크기의 배열입니다.</target>
        </trans-unit>
        <trans-unit id="fa1668cc4f1ad2127afa574513a965e4f8de0bd1" translate="yes" xml:space="preserve">
          <source>For tall matrices in NumPy version up to 1.6.2, the diagonal &amp;ldquo;wrapped&amp;rdquo; after N columns. You can have this behavior with this option. This affects only tall matrices.</source>
          <target state="translated">NumPy 버전에서 1.6.2까지의 키가 큰 행렬의 경우 N 열 뒤에 대각선이 &quot;줄 바꿈&quot;됩니다. 이 옵션으로이 동작을 수행 할 수 있습니다. 이것은 키가 큰 행렬에만 영향을줍니다.</target>
        </trans-unit>
        <trans-unit id="15797574f39fa9a94e6a6ba0f1322211577809c1" translate="yes" xml:space="preserve">
          <source>For tests with a result that is random or platform-dependent, mark the output as such:</source>
          <target state="translated">결과가 무작위이거나 플랫폼에 따라 달라지는 테스트의 경우 출력을 다음과 같이 표시하십시오.</target>
        </trans-unit>
        <trans-unit id="571561584fb9de04ee089fbe39a5ff6d6bc01c7a" translate="yes" xml:space="preserve">
          <source>For the explicit constructor call, our subclass will need to create a new ndarray instance of its own class. In practice this means that we, the authors of the code, will need to make a call to &lt;code&gt;ndarray.__new__(MySubClass,...)&lt;/code&gt;, a class-hierarchy prepared call to &lt;code&gt;super(MySubClass, cls).__new__(cls, ...)&lt;/code&gt;, or do view casting of an existing array (see below)</source>
          <target state="translated">명시 적 생성자 호출의 경우 하위 클래스는 자체 클래스의 새 ndarray 인스턴스를 만들어야합니다. 실제로 우리, 코드의 저자는, 호출 할 수 있도록해야합니다이 의미하는 것이 &lt;code&gt;ndarray.__new__(MySubClass,...)&lt;/code&gt; 에 클래스 계층 구조 준비 통화 &lt;code&gt;super(MySubClass, cls).__new__(cls, ...)&lt;/code&gt; , 또는 기존 배열의 뷰 캐스팅을 수행합니다 (아래 참조).</target>
        </trans-unit>
        <trans-unit id="18e3d7bba1f8f57e3e3d0698a1673d2f7dbd0218" translate="yes" xml:space="preserve">
          <source>For the first run, we threw 3 times 1, 4 times 2, etc. For the second, we threw 2 times 1, 4 times 2, etc.</source>
          <target state="translated">첫 번째 실행에서는 3 번 1, 4 번 2 등을 던졌습니다. 두 번째 실행에서는 2 번 1, 4 번 2 등을 던졌습니다.</target>
        </trans-unit>
        <trans-unit id="72f9e5e8e38fa061436e99d12c2a915135e47ac9" translate="yes" xml:space="preserve">
          <source>For the following methods there are also corresponding functions in &lt;a href=&quot;index#module-numpy&quot;&gt;&lt;code&gt;numpy&lt;/code&gt;&lt;/a&gt;: &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt;&lt;code&gt;argmax&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt;&lt;code&gt;argmin&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt;&lt;code&gt;choose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt;&lt;code&gt;clip&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt;&lt;code&gt;compress&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt;&lt;code&gt;cumprod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt;&lt;code&gt;cumsum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt;&lt;code&gt;diagonal&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt;&lt;code&gt;imag&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt;&lt;code&gt;nonzero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt;&lt;code&gt;partition&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt;&lt;code&gt;put&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt;&lt;code&gt;real&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt;&lt;code&gt;repeat&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt;&lt;code&gt;reshape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt;&lt;code&gt;searchsorted&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt;&lt;code&gt;squeeze&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt;&lt;code&gt;swapaxes&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt;&lt;code&gt;take&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt;&lt;code&gt;trace&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt;&lt;code&gt;transpose&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">다음 방법에는 &lt;a href=&quot;index#module-numpy&quot;&gt; &lt;code&gt;numpy&lt;/code&gt; 에&lt;/a&gt; 해당하는 함수가 있습니다 . &lt;a href=&quot;generated/numpy.all#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.any#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmax#numpy.argmax&quot;&gt; &lt;code&gt;argmax&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argmin#numpy.argmin&quot;&gt; &lt;code&gt;argmin&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.choose#numpy.choose&quot;&gt; &lt;code&gt;choose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.clip#numpy.clip&quot;&gt; &lt;code&gt;clip&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.compress#numpy.compress&quot;&gt; &lt;code&gt;compress&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumprod#numpy.cumprod&quot;&gt; &lt;code&gt;cumprod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.cumsum#numpy.cumsum&quot;&gt; &lt;code&gt;cumsum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.diagonal#numpy.diagonal&quot;&gt; &lt;code&gt;diagonal&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.imag#numpy.imag&quot;&gt; &lt;code&gt;imag&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amax#numpy.amax&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.amin#numpy.amin&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.nonzero#numpy.nonzero&quot;&gt; &lt;code&gt;nonzero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.partition#numpy.partition&quot;&gt; &lt;code&gt;partition&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.prod#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.ptp#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.put#numpy.put&quot;&gt; &lt;code&gt;put&lt;/code&gt; &lt;/a&gt; ,&lt;a href=&quot;generated/numpy.ravel#numpy.ravel&quot;&gt; &lt;code&gt;ravel&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;generated/numpy.real#numpy.real&quot;&gt; &lt;code&gt;real&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.repeat#numpy.repeat&quot;&gt; &lt;code&gt;repeat&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.reshape#numpy.reshape&quot;&gt; &lt;code&gt;reshape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.around#numpy.around&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.searchsorted#numpy.searchsorted&quot;&gt; &lt;code&gt;searchsorted&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.sort#numpy.sort&quot;&gt; &lt;code&gt;sort&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.squeeze#numpy.squeeze&quot;&gt; &lt;code&gt;squeeze&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.std#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.swapaxes#numpy.swapaxes&quot;&gt; &lt;code&gt;swapaxes&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.take#numpy.take&quot;&gt; &lt;code&gt;take&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.trace#numpy.trace&quot;&gt; &lt;code&gt;trace&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.transpose#numpy.transpose&quot;&gt; &lt;code&gt;transpose&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f398fd04d9f322afdba477002ec5cde7b5d2d1b" translate="yes" xml:space="preserve">
          <source>For the general case, the iteration works by keeping track of a list of coordinate counters in the iterator object. At each iteration, the last coordinate counter is increased (starting from 0). If this counter is smaller than one less than the size of the array in that dimension (a pre-computed and stored value), then the counter is increased and the dataptr member is increased by the strides in that dimension and the macro ends. If the end of a dimension is reached, the counter for the last dimension is reset to zero and the dataptr is moved back to the beginning of that dimension by subtracting the strides value times one less than the number of elements in that dimension (this is also pre-computed and stored in the backstrides member of the iterator object). In this case, the macro does not end, but a local dimension counter is decremented so that the next-to-last dimension replaces the role that the last dimension played and the previously-described tests are executed again on the next-to-last dimension. In this way, the dataptr is adjusted appropriately for arbitrary striding.</source>
          <target state="translated">일반적인 경우 반복 작업은 반복자 객체의 좌표 카운터 목록을 추적하여 작동합니다. 반복 할 때마다 마지막 좌표 카운터가 증가합니다 (0부터 시작). 이 카운터가 해당 차원의 배열 크기 (사전 계산 및 저장된 값)보다 1보다 작 으면 카운터가 증가하고 해당 차원의 보폭에 의해 dataptr 멤버가 증가하고 매크로가 종료됩니다. 차원의 끝에 도달하면 마지막 차원의 카운터가 0으로 재설정되고 해당 차원의 요소 수보다 보폭 값을 1만큼 뺀 값으로 dataptr이 해당 차원의 시작으로 다시 이동합니다. 또한 미리 계산되어 반복자 객체의 백스트리트 멤버에 저장됩니다). 이 경우 매크로는 끝나지 않습니다.그러나 로컬 차원 카운터는 마지막 차원이 마지막 차원의 역할을 대체하고 이전에 설명 된 테스트가 다음 차원에서 다시 실행되도록 로컬 차원 카운터가 감소됩니다. 이러한 방식으로, dataptr은 임의의 보폭에 적합하게 조정됩니다.</target>
        </trans-unit>
        <trans-unit id="a106ff191577f5e49df4ba4a5b92a5dff872216c" translate="yes" xml:space="preserve">
          <source>For the most part, the rules for dispatch with &lt;code&gt;__array_function__&lt;/code&gt; match those for &lt;code&gt;__array_ufunc__&lt;/code&gt;. In particular:</source>
          <target state="translated">대부분의 경우, 디스패치에 대한 규칙 &lt;code&gt;__array_function__&lt;/code&gt; 을 위한 그 일치 &lt;code&gt;__array_ufunc__&lt;/code&gt; 을 . 특히:</target>
        </trans-unit>
        <trans-unit id="4180b0d2e31dfed11719fe695b4c67afcfef466f" translate="yes" xml:space="preserve">
          <source>For the parameter types, be as precise as possible. Below are a few examples of parameters and their types.</source>
          <target state="translated">매개 변수 유형의 경우 가능한 한 정확해야합니다. 다음은 매개 변수 및 유형의 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="5aabe002787ac5ab3c2a4862f3aa6c788cd300e2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">typenum 매크로의 경우 인수는 열거 된 배열 데이터 유형을 나타내는 정수입니다. 매크로를 확인 배열 유형의 인수가 있어야합니다 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 직접으로 해석 될 수 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="62fce29176d606bc6dce1d1603810532e05edeb2" translate="yes" xml:space="preserve">
          <source>For the typenum macros, the argument is an integer representing an enumerated array data type. For the array type checking macros the argument must be a &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; that can be directly interpreted as a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">typenum 매크로의 경우 인수는 열거 형 배열 데이터 유형을 나타내는 정수입니다. 배열 유형 검사 매크로의 경우 인수는 &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; 로 직접 해석 될 수있는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="5d3c40fa5c98be8aa15b70b390891bf28a170212" translate="yes" xml:space="preserve">
          <source>For these reasons it is advisable to avoid &lt;code&gt;as_strided&lt;/code&gt; when possible.</source>
          <target state="translated">이러한 이유로 가능한 경우 &lt;code&gt;as_strided&lt;/code&gt; 를 피하는 것이 좋습니다 .</target>
        </trans-unit>
        <trans-unit id="eb33fc8c29e1bd562bffb815c2697c66a036bae2" translate="yes" xml:space="preserve">
          <source>For these reasons, NumPy provides an API to work with npy_half values accessible by including &amp;lt;numpy/halffloat.h&amp;gt; and linking to &amp;lsquo;npymath&amp;rsquo;. For functions that are not provided directly, such as the arithmetic operations, the preferred method is to convert to float or double and back again, as in the following example.</source>
          <target state="translated">이러한 이유로 NumPy는 &amp;lt;numpy / halffloat.h&amp;gt;를 포함하고 'npymath'에 연결하여 액세스 가능한 npy_half 값으로 작업 할 수있는 API를 제공합니다. 산술 연산과 같이 직접 제공되지 않은 함수의 경우 선호되는 방법은 다음 예와 같이 부동 또는 이중으로 변환 한 후 다시 변환하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="104d0cf2eb8de1110539af70bd2855adaa34b9c0" translate="yes" xml:space="preserve">
          <source>For this example we will only handle the method &lt;code&gt;__call__&lt;/code&gt;</source>
          <target state="translated">이 예에서는 &lt;code&gt;__call__&lt;/code&gt; 메소드 만 처리합니다.</target>
        </trans-unit>
        <trans-unit id="684c1e70d951c1d84a7330eb5d5d620e2e0f3ef5" translate="yes" xml:space="preserve">
          <source>For this example we will only handle the method &lt;code&gt;__call__&lt;/code&gt;.</source>
          <target state="translated">이 예에서는 &lt;code&gt;__call__&lt;/code&gt; 메서드 만 처리합니다 .</target>
        </trans-unit>
        <trans-unit id="c5b0d8b34011752e4113aaa6a6fce2b3c78d19e5" translate="yes" xml:space="preserve">
          <source>For this function to work on sub-classes of ndarray, they must define &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; with the kwarg &lt;code&gt;keepdims&lt;/code&gt;</source>
          <target state="translated">이 함수가 ndarray의 하위 클래스에서 작동 하려면 kwarg &lt;code&gt;keepdims&lt;/code&gt; 로&lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 을 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="bffe6d0d22813c5a9e09a6444b12ab5f734f3a30" translate="yes" xml:space="preserve">
          <source>For this reason it is possible to use the output from the np.nonzero() function directly as an index since it always returns a tuple of index arrays.</source>
          <target state="translated">이러한 이유로 항상 인덱스 배열의 튜플을 반환하므로 np.nonzero () 함수의 출력을 인덱스로 직접 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7b38cff3c38a7296ea244a6f149ab3fa89299cb" translate="yes" xml:space="preserve">
          <source>For this reason, it is equivalent to (but faster than) the following use of &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt;&lt;code&gt;apply_along_axis&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이러한 이유로, 다음 &lt;a href=&quot;numpy.apply_along_axis#numpy.apply_along_axis&quot;&gt; &lt;code&gt;apply_along_axis&lt;/code&gt; &lt;/a&gt; 사용과 동일하지만 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="77bbee921f7bbec73ea6da64c3957049942fe48c" translate="yes" xml:space="preserve">
          <source>For this sample array</source>
          <target state="translated">이 샘플 배열의 경우</target>
        </trans-unit>
        <trans-unit id="445c5367719257e79fe070e306aba792eba52dd0" translate="yes" xml:space="preserve">
          <source>For tradeoffs among memmap, Zarr, and HDF5, see &lt;a href=&quot;https://pythonspeed.com/articles/mmap-vs-zarr-hdf5/&quot;&gt;pythonspeed.com&lt;/a&gt;.</source>
          <target state="translated">memmap, Zarr 및 HDF5 간의 장단점에 대해서는 &lt;a href=&quot;https://pythonspeed.com/articles/mmap-vs-zarr-hdf5/&quot;&gt;pythonspeed.com을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ef360ecaea0bceb4141bc860c62269adcea43126" translate="yes" xml:space="preserve">
          <source>For two dimensional arrays, the return will be two arrays ordered by axis. In this example the first array stands for the gradient in rows and the second one in columns direction:</source>
          <target state="translated">2 차원 배열의 경우 반환되는 축은 2 개의 배열입니다. 이 예제에서 첫 번째 배열은 행의 그라데이션을 나타내고 두 번째 배열은 열 방향의 그라데이션을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="5688be18895d1ed44e4e4ac9ea5a009f3d8f644d" translate="yes" xml:space="preserve">
          <source>For ufuncs dynamically created from python functions, this member holds a reference to the underlying Python function.</source>
          <target state="translated">파이썬 함수에서 동적으로 생성 된 ufunc의 경우이 멤버는 기본 파이썬 함수에 대한 참조를 보유합니다.</target>
        </trans-unit>
        <trans-unit id="f51d3a13e3a61d2cfd5f82478bfc77249b90c3e8" translate="yes" xml:space="preserve">
          <source>For ufuncs, it is hoped to eventually deprecate this method in favour of &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">ufunc의 경우 __array_ufunc__ 대신이 메소드를 더 이상 사용하지 않기를 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1700b828b7fc4fece4693f8692514304a9ff235c" translate="yes" xml:space="preserve">
          <source>For uniformity in handling operands, NumPy treats a &lt;a href=&quot;reference/arrays.scalars&quot;&gt;scalar&lt;/a&gt; as an array of zero dimension.</source>
          <target state="translated">피연산자 처리의 균일 성을 위해 NumPy는 &lt;a href=&quot;reference/arrays.scalars&quot;&gt;스칼라&lt;/a&gt; 를 0 차원 배열로 처리 합니다.</target>
        </trans-unit>
        <trans-unit id="3fec4c12c09d2caf632487f32e741d15fde50a70" translate="yes" xml:space="preserve">
          <source>For unpickling.</source>
          <target state="translated">산 세척 용.</target>
        </trans-unit>
        <trans-unit id="f5a617d92aada34c5b1b91d32c80426c8f059f29" translate="yes" xml:space="preserve">
          <source>For unsigned integer arrays, the results will also be unsigned. This should not be surprising, as the result is consistent with calculating the difference directly:</source>
          <target state="translated">부호없는 정수 배열의 경우 결과도 부호가 없습니다. 결과가 직접 차이를 계산하는 것과 일치하기 때문에 이것은 놀라운 일이 아닙니다.</target>
        </trans-unit>
        <trans-unit id="6e4eba9645d784baff280ba41b2a35d0eb68b9c9" translate="yes" xml:space="preserve">
          <source>For us, what consensus means is that we entrust &lt;em&gt;everyone&lt;/em&gt; with the right to veto any change if they feel it necessary. While this may sound like a recipe for obstruction and pain, this is not what happens. Instead, we find that most people take this responsibility seriously, and only invoke their veto when they judge that a serious problem is being ignored, and that their veto is necessary to protect the project. And in practice, it turns out that such vetoes are almost never formally invoked, because their mere possibility ensures that Contributors are motivated from the start to find some solution that everyone can live with &amp;ndash; thus accomplishing our goal of ensuring that all interested perspectives are taken into account.</source>
          <target state="translated">우리에게 합의가 의미하는 것은 &lt;em&gt;모든 사람&lt;/em&gt; 이 필요하다고 생각하는 경우 변경을 거부 할 권리를 &lt;em&gt;모든 사람&lt;/em&gt; 에게 맡긴다는 것입니다 . 이것이 방해와 고통에 대한 조리법처럼 들릴지 모르지만 이것은 일어나는 일이 아닙니다. 대신 우리는 대부분의 사람들이이 책임을 진지하게 받아들이고 심각한 문제가 무시되고 있고 프로젝트를 보호하기 위해 거부권이 필요하다고 판단 할 때만 거부권을 행사합니다. 실제로 그러한 거부권은 거의 공식적으로 실행되지 않는 것으로 나타났습니다. 왜냐하면 단순한 가능성은 기여자가 처음부터 모든 사람이 함께 살 수있는 해결책을 찾도록 동기를 부여하여 모든 관심있는 관점을 취하도록 보장하는 우리의 목표를 달성 할 수 있기 때문입니다. 계정에.</target>
        </trans-unit>
        <trans-unit id="4b61801e49c04aeb574dfd6c0384db9e70e2d05c" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">RandomState 인스턴스에서 사용하는 비트 생성기의 내부 상태를 수동으로 (재설정) 할 이유가있는 경우에 사용합니다. 기본적으로 RandomState는 &quot;Mersenne Twister&quot; &lt;a href=&quot;#r0933ec43c7c9-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 의사 난수 생성 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="897febe53ee6bd5d25313858b98b8601f29d1bc3" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#rd62dfb5ffa26-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">RandomState 인스턴스에서 사용하는 비트 생성기의 내부 상태를 수동 (재설정)해야하는 이유가있는 경우 사용합니다. 기본적으로 RandomState는 &quot;Mersenne Twister&quot; &lt;a href=&quot;#rd62dfb5ffa26-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 의사 난수 생성 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ea29248ff311f62cfdcca5534fc099ca5bcc6b8e" translate="yes" xml:space="preserve">
          <source>For use if one has reason to manually (re-)set the internal state of the bit generator used by the RandomState instance. By default, RandomState uses the &amp;ldquo;Mersenne Twister&amp;rdquo;&lt;a href=&quot;#rf0f3f75f485b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; pseudo-random number generating algorithm.</source>
          <target state="translated">RandomState 인스턴스에서 사용하는 비트 생성기의 내부 상태를 수동 (재설정)해야하는 이유가있는 경우 사용합니다. 기본적으로 RandomState는 &quot;Mersenne Twister&quot; &lt;a href=&quot;#rf0f3f75f485b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 의사 난수 생성 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="23f7c1942ce335813533514ab6d97be522e99c17" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt;&lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt;&lt;/a&gt;, this flag disables allocating an array subtype for the output, forcing it to be a straight ndarray.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_ALLOCATE&quot;&gt; &lt;code&gt;NPY_ITER_ALLOCATE&lt;/code&gt; &lt;/a&gt; 와 함께 사용하는 경우이 플래그는 출력에 배열 하위 유형 할당을 비활성화하여 직선 ndarray가되도록합니다.</target>
        </trans-unit>
        <trans-unit id="4f63cfae8856e0c1b4c745d806a5044a1d2050ad" translate="yes" xml:space="preserve">
          <source>For use with &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 과 함께 사용</target>
        </trans-unit>
        <trans-unit id="703ab6c203bc4f7c082f6639ec9949c363231487" translate="yes" xml:space="preserve">
          <source>For use with &lt;code&gt;PyArg_ParseTuple&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PyArg_ParseTuple&lt;/code&gt; 과 함께 사용</target>
        </trans-unit>
        <trans-unit id="8cb254f53813d4f5ed5d47fcd78786e6b4efd30e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc.</source>
          <target state="translated">반올림 된 십진수 값 사이의 정확히 중간 값의 경우 NumPy는 가장 가까운 짝수 값으로 반올림합니다. 따라서 1.5 및 2.5는 2.0으로, -0.5 및 0.5는 0.0으로 반올림됩니다.</target>
        </trans-unit>
        <trans-unit id="30f0a5ecb33fee954cb51300dbd6244641e9062e" translate="yes" xml:space="preserve">
          <source>For values exactly halfway between rounded decimal values, NumPy rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0, -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due to the inexact representation of decimal fractions in the IEEE floating point standard &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; and errors introduced when scaling by powers of ten.</source>
          <target state="translated">반올림 된 십진수 값의 중간에있는 값의 경우 NumPy는 가장 가까운 짝수 값으로 반올림합니다. 따라서 1.5 및 2.5는 2.0으로 반올림하고, -0.5 및 0.5는 0.0으로 반올림합니다. IEEE 부동 소수점 표준 &lt;a href=&quot;#r907366b089c1-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 에서 소수점 이하 자릿수의 부정확 한 표현 및 10의 거듭 제곱으로 스케일링 할 때 발생하는 오류 로 인해 결과가 놀랍 습니다.</target>
        </trans-unit>
        <trans-unit id="a7513a1115d30c3b715a3ca9a5ba6b73db8ad275" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt; 1&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="translated">&lt;code&gt;ord &amp;lt; 1&lt;/code&gt; 값의 경우 결과는 엄밀히 말하면 수학적 '표준'이 아니지만 다양한 수치 목적에 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4b8df8eb2541671de725aa87916abd483ac03487" translate="yes" xml:space="preserve">
          <source>For values of &lt;code&gt;ord &amp;lt;= 0&lt;/code&gt;, the result is, strictly speaking, not a mathematical &amp;lsquo;norm&amp;rsquo;, but it may still be useful for various numerical purposes.</source>
          <target state="translated">&lt;code&gt;ord &amp;lt;= 0&lt;/code&gt; 값의 경우 결과는 엄밀히 말하면 수학적인 '노름'이 아니지만 다양한 수치 목적에 여전히 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6c5fe59c42bb96e8794f338a14a9afba25af3e6" translate="yes" xml:space="preserve">
          <source>For vectors (1-D arrays) it computes the ordinary inner-product:</source>
          <target state="translated">벡터 (1 차원 배열)의 경우 일반 내부 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f31afbaa8abd3ce58c5bf83aec637268a269a63d" translate="yes" xml:space="preserve">
          <source>For vectors &lt;code&gt;x1&lt;/code&gt;, &lt;code&gt;x2&lt;/code&gt;,&amp;hellip;, &amp;lsquo;xn&amp;rsquo; with lengths &lt;code&gt;Ni=len(xi)&lt;/code&gt; , return &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;ij&amp;rsquo; or &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; shaped arrays if indexing=&amp;rsquo;xy&amp;rsquo; with the elements of &lt;code&gt;xi&lt;/code&gt; repeated to fill the matrix along the first dimension for &lt;code&gt;x1&lt;/code&gt;, the second for &lt;code&gt;x2&lt;/code&gt; and so on.</source>
          <target state="translated">벡터를 들어 &lt;code&gt;x1&lt;/code&gt; , &lt;code&gt;x2&lt;/code&gt; , ..., &quot;XN&quot;와 길이 &lt;code&gt;Ni=len(xi)&lt;/code&gt; , 창 &lt;code&gt;(N1, N2, N3,...Nn)&lt;/code&gt; 모양의 배열 인덱스 = 'IJ'또는 경우 &lt;code&gt;(N2, N1, N3,...Nn)&lt;/code&gt; 형 배열의 요소 인덱스 = &quot;XY&quot;경우 &lt;code&gt;xi&lt;/code&gt; 위한 제 차원에 따른 행렬 채우기 위해 반복 &lt;code&gt;x1&lt;/code&gt; 위한 제 &lt;code&gt;x2&lt;/code&gt; 등이있다.</target>
        </trans-unit>
        <trans-unit id="51b960f61f40e8cc6aeabaf2a1735fbc2b9ac25d" translate="yes" xml:space="preserve">
          <source>For view casting and new-from-template, the equivalent of &lt;code&gt;ndarray.__new__(MySubClass,...&lt;/code&gt; is called, at the C level.</source>
          <target state="translated">뷰 캐스팅과 new-from-template의 경우 &lt;code&gt;ndarray.__new__(MySubClass,...&lt;/code&gt; 와 동등한 것이 C 레벨에서 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="1f6242c0a79a41aa81490f6fd1ec86280110a2af" translate="yes" xml:space="preserve">
          <source>Force a cast to the output type even if it cannot be done safely. Without this flag, a data cast will occur only if it can be done safely, otherwise an error is raised.</source>
          <target state="translated">안전하게 수행 할 수없는 경우에도 출력 유형으로 캐스트를 수행하십시오. 이 플래그가 없으면 데이터 캐스트는 안전하게 수행 할 수있는 경우에만 발생하며, 그렇지 않으면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="d3ec8aad2bec1b3220d7b727c3bf434f0d55bc18" translate="yes" xml:space="preserve">
          <source>Force the mask to hard.</source>
          <target state="translated">마스크를 세게 누릅니다.</target>
        </trans-unit>
        <trans-unit id="cd0355317a1ab931fccb7ea5788f7a01c8683490" translate="yes" xml:space="preserve">
          <source>Force the mask to soft.</source>
          <target state="translated">마스크를 부드럽게 만듭니다.</target>
        </trans-unit>
        <trans-unit id="46e07bf1dcba4f22fb0998d98afd707eecb583d3" translate="yes" xml:space="preserve">
          <source>Format Version 1.0</source>
          <target state="translated">형식 버전 1.0</target>
        </trans-unit>
        <trans-unit id="9c5ba690bca66f9b43bf7dce492a8ecc14116342" translate="yes" xml:space="preserve">
          <source>Format Version 2.0</source>
          <target state="translated">형식 버전 2.0</target>
        </trans-unit>
        <trans-unit id="6d476621018ad05f5efc66b66f9628e71614d77b" translate="yes" xml:space="preserve">
          <source>Format Version 3.0</source>
          <target state="translated">형식 버전 3.0</target>
        </trans-unit>
        <trans-unit id="082aa72e2e80659bc0dafa9d8a6a53207113bd45" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in positional notation.</source>
          <target state="translated">부동 소수점 스칼라를 위치 표기법으로 10 진수 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="63ec1825c81674406abf9c065439398606f8e9c4" translate="yes" xml:space="preserve">
          <source>Format a floating-point scalar as a decimal string in scientific notation.</source>
          <target state="translated">과학적 표기법으로 부동 소수점 스칼라를 10 진수 문자열로 형식화하십시오.</target>
        </trans-unit>
        <trans-unit id="2ba865544cbf6ad122958e97b9cb7e6ee2fca0ce" translate="yes" xml:space="preserve">
          <source>Format string for text file output. Each entry in the array is formatted to text by first converting it to the closest Python type, and then using &amp;ldquo;format&amp;rdquo; % item.</source>
          <target state="translated">텍스트 파일 출력을위한 형식 문자열입니다. 배열의 각 항목은 먼저 가장 가까운 Python 유형으로 변환 한 다음 &quot;format&quot;% 항목을 사용하여 텍스트로 형식이 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="fa2f2df30c13aa4a41041d5692c011a5dcf268be" translate="yes" xml:space="preserve">
          <source>Formats for &lt;strong&gt;exchanging data&lt;/strong&gt; with other tools include HDF5, Zarr, and NetCDF (see &lt;a href=&quot;#how-to-io-large-arrays&quot;&gt;Write or read large arrays&lt;/a&gt;).</source>
          <target state="translated">다른 도구와 &lt;strong&gt;데이터&lt;/strong&gt; 를 &lt;strong&gt;교환하기&lt;/strong&gt; 위한 형식 에는 HDF5, Zarr 및 NetCDF가 있습니다 ( &lt;a href=&quot;#how-to-io-large-arrays&quot;&gt;대형 배열 쓰기 또는 읽기&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="a3b7bf2b2380c4418912a52f4b2af945c3ac0459" translate="yes" xml:space="preserve">
          <source>Formatting issues</source>
          <target state="translated">서식 문제</target>
        </trans-unit>
        <trans-unit id="0325ffe49050757f639a952be911aab3da5eaa12" translate="yes" xml:space="preserve">
          <source>Formula writing</source>
          <target state="translated">수식 작성</target>
        </trans-unit>
        <trans-unit id="e5a92b78c74fdad3772b95c0bef006808c6f5062" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="translated">Fornberg B. (1988) 임의로 이격 된 격자에서 유한 차 분식의 생성, 계산의 수학 51, no. 184 : 699-706. &lt;a href=&quot;http://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6874cc14b70854fb8cca90f27670bd2abb51cfb5" translate="yes" xml:space="preserve">
          <source>Fornberg B. (1988) Generation of Finite Difference Formulas on Arbitrarily Spaced Grids, Mathematics of Computation 51, no. 184 : 699-706. &lt;a href=&quot;https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt;.</source>
          <target state="translated">Fornberg B. (1988) 임의 간격 그리드의 유한 차분 공식 생성, 계산 수학 51, no. 184 : 699-706. &lt;a href=&quot;https://www.ams.org/journals/mcom/1988-51-184/S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf&quot;&gt;PDF&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1cc558102f286f771795f2da7cbcbf5ba1b6328" translate="yes" xml:space="preserve">
          <source>Fortran 90 module data</source>
          <target state="translated">Fortran 90 모듈 데이터</target>
        </trans-unit>
        <trans-unit id="b62f0c388a951d6d6803e4d2dc48f368bb1a5685" translate="yes" xml:space="preserve">
          <source>Fortran assumed shape array and size function support in &lt;code&gt;numpy.f2py&lt;/code&gt;</source>
          <target state="translated">Fortran은 &lt;code&gt;numpy.f2py&lt;/code&gt; 에서 모양 배열 및 크기 함수 지원을 가정했습니다.</target>
        </trans-unit>
        <trans-unit id="b756e1ed184faeae9981dd9378f750e8c6c0e04f" translate="yes" xml:space="preserve">
          <source>Fortran files</source>
          <target state="translated">포트란 파일</target>
        </trans-unit>
        <trans-unit id="443b7dd908046f637f8adbdcefe50ee302b6f087" translate="yes" xml:space="preserve">
          <source>Fortran order if all the inputs are Fortran, C otherwise.</source>
          <target state="translated">모든 입력이 포트란이면 포트란 순서, 그렇지 않으면 C</target>
        </trans-unit>
        <trans-unit id="0dbb13a4208640c43e953aa1ecfe0492f9b453d1" translate="yes" xml:space="preserve">
          <source>Fortran order.</source>
          <target state="translated">포트란 주문.</target>
        </trans-unit>
        <trans-unit id="458144d44956123a91798b5242d7c298d549eb1b" translate="yes" xml:space="preserve">
          <source>Fortran source of module / subroutine to compile</source>
          <target state="translated">컴파일 할 모듈 / 서브 루틴의 포트란 소스</target>
        </trans-unit>
        <trans-unit id="e6b7af163ec1d9df45d457b3365dd7a8bb154117" translate="yes" xml:space="preserve">
          <source>Fortran to Python Interface Generator.</source>
          <target state="translated">Fortran에서 Python 인터페이스 생성기로.</target>
        </trans-unit>
        <trans-unit id="c97ded998a0ca595e9b4695a113a861855f88705" translate="yes" xml:space="preserve">
          <source>Fortran-contiguous arrays when data is stored column-wise, i.e. indexing of data as stored in memory starts from the lowest dimension;</source>
          <target state="translated">데이터가 열 단위로 저장 될 때 포트란 연속 배열, 즉 메모리에 저장된 데이터의 인덱싱은 최하위 차원에서 시작됩니다.</target>
        </trans-unit>
        <trans-unit id="3c103a2ce4fa5c4bdfbfca73532b43fd7c1242b6" translate="yes" xml:space="preserve">
          <source>Fortran-order</source>
          <target state="translated">Fortran-order</target>
        </trans-unit>
        <trans-unit id="01f074f9b2b7da2704c7bf16c64348fbe5aff689" translate="yes" xml:space="preserve">
          <source>Fortran/C routine signatures</source>
          <target state="translated">Fortran / C 루틴 서명</target>
        </trans-unit>
        <trans-unit id="fa529d42774f0768730f12bc0880f9965a988000" translate="yes" xml:space="preserve">
          <source>Forward bytes from a subprocess call to the console, without attempting to decode them.</source>
          <target state="translated">디코딩을 시도하지 않고 서브 프로세스 호출에서 콘솔로 바이트를 전달합니다.</target>
        </trans-unit>
        <trans-unit id="ececb946a3ffd8fb7cf57101d577f7acf1341e58" translate="yes" xml:space="preserve">
          <source>Forward port changes in the release branch to release notes and release scripts, if any, to master branch.</source>
          <target state="translated">릴리스 브랜치의 포트 변경 사항을 릴리스 정보로 전달하고 릴리스 스크립트가있는 경우 마스터 브랜치로 전달합니다.</target>
        </trans-unit>
        <trans-unit id="2982346b57dba0536f8cd38d08e71e22e03b5068" translate="yes" xml:space="preserve">
          <source>Four values of the output are invalid: the first one comes from taking the square root of a negative number, the second from the division by zero, and the last two where the inputs were masked.</source>
          <target state="translated">네 가지 출력 값은 유효하지 않습니다. 첫 번째 값은 음수의 제곱근을 취하고 두 번째 값은 0으로 나눈 값과 입력이 마스크 된 마지막 두 값을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f163a620e6be53409bc7d6c8a56980a06cc8552e" translate="yes" xml:space="preserve">
          <source>Fourier analysis is fundamentally a method for expressing a function as a sum of periodic components, and for recovering the function from those components. When both the function and its Fourier transform are replaced with discretized counterparts, it is called the discrete Fourier transform (DFT). The DFT has become a mainstay of numerical computing in part because of a very fast algorithm for computing it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and was brought to light in its current form by Cooley and Tukey &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt;. Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; provide an accessible introduction to Fourier analysis and its applications.</source>
          <target state="translated">푸리에 분석은 기본적으로 함수를 주기적 구성 요소의 합으로 표현하고 해당 구성 요소에서 기능을 복구하는 방법입니다. 함수와 푸리에 변환이 모두 이산화 된 대응으로 대체 될 때,이를 DFT (Discrete Fourier Transform)라고합니다. DFT는 FFT (Fast Fourier Transform)라고 불리는 매우 빠른 컴퓨팅 알고리즘 덕분에 수치 컴퓨팅의 주류가되었으며, 이는 Gauss (1805)에게 알려졌으며 Cooley와 터키 &lt;a href=&quot;#rfb1dc64dd6a5-ct&quot; id=&quot;id1&quot;&gt;[CT]&lt;/a&gt; . Press et al. &lt;a href=&quot;#rfb1dc64dd6a5-nr&quot; id=&quot;id2&quot;&gt;[NR]&lt;/a&gt; 은 푸리에 분석 및 응용에 대한 접근성있는 소개를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="69fe683adb41f9ba1a3873187fd6c76482148e01" translate="yes" xml:space="preserve">
          <source>Fourier transform of &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">푸리에 변환의 &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">제공된 유형 맵에 포함되지 않은 사례를 처리하는 특수 유형 맵, 확장 또는 인라인 된 함수를 작성하는 데 사용할 수있는 14 개의 C 매크로 및 15 개의 C 함수 매크로 및 함수는 버전 1.6 이후 API의 일부 측면이 더 이상 사용되지 않기 전후에 NumPy 버전 번호에 관계없이 NumPy C / API와 함께 작동하도록 특별히 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 분수 부분 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Sourceforge 프로젝트의 파레토 배포에 관한 Francis Hunt와 Paul Johnson.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">주어진 FFT 매개 변수에 대한 주파수 구간.</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">프로 베니 우스 표준</target>
        </trans-unit>
        <trans-unit id="6e155909e8a05199128c1964fad95f6222feb7b1" translate="yes" xml:space="preserve">
          <source>From &lt;a href=&quot;https://www.kaggle.com/atilamadai/covid19&quot;&gt;Kaggle&lt;/a&gt; it is possible to download a dataset with initial data about the COVID-19 outbreak in the beginning of 2020. We are going to look at a small subset of this data, contained in the file &lt;code&gt;who_covid_19_sit_rep_time_series.csv&lt;/code&gt;.</source>
          <target state="translated">에서 &lt;a href=&quot;https://www.kaggle.com/atilamadai/covid19&quot;&gt;Kaggle&lt;/a&gt; 이 파일에 포함 된 우리는이 데이터의 작은 하위 집합을보고가는 2020 년의 시작 부분에서 COVID-19 발발에 대한 초기 데이터와 데이터 집합을 다운로드 할 수 있습니다 &lt;code&gt;who_covid_19_sit_rep_time_series.csv&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b496ebf456418bea6f72b4dd532369d14b955f9b" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r755c9bae090e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard 페이지 83 &lt;a href=&quot;#r755c9bae090e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; 에서 11 명의 여성을위한 킬로 줄 (kJ)의 일일 에너지 섭취량은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="aeadfde385f544a91cc8eaeeffa0c5ba93e6dc7d" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r89f5270d198b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard 페이지 83 &lt;a href=&quot;#r89f5270d198b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; 에서 11 명의 여성을위한 킬로 줄 (kJ)의 일일 에너지 섭취량은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard page 83에서 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , 킬로 줄 (kJ)의 여성 11 명의 일일 에너지 섭취량은 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard page 83에서 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , 킬로 줄 (kJ)의 여성 11 명의 일일 에너지 섭취량은 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">4x3 배열에서 고급 인덱싱을 사용하여 모서리 요소를 선택해야합니다. 따라서 열이 &lt;code&gt;[0, 2]&lt;/code&gt; 중 하나이고 행이 &lt;code&gt;[0, 3]&lt;/code&gt; 중 하나 인 모든 요소를 선택해야합니다. 고급 인덱싱을 사용하려면 모든 요소를 &lt;em&gt;명시 적으로&lt;/em&gt; 선택해야합니다 . 앞에서 설명한 방법을 사용하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a91be0fd97aa12da8097d28986c00ba2a4f3a53c" translate="yes" xml:space="preserve">
          <source>From a Fortran routine signature F2PY generates a Python/C extension function that has the following signature:</source>
          <target state="translated">Fortran 루틴 서명에서 F2PY는 다음 서명이있는 Python / C 확장 함수를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">날짜와 시간에서 :</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">배열에서 합계가 2보다 작거나 같은 모든 행을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">각 행에서 특정 요소를 선택해야합니다. 행 인덱스는 단지 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 이며 열 인덱스는 해당 행에 대해 선택할 요소를 지정합니다 (여기서는 &lt;code&gt;[0, 1, 0]&lt;/code&gt; . 두 가지를 함께 사용하면 고급 인덱싱을 사용하여 작업을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">기존 데이터에서</target>
        </trans-unit>
        <trans-unit id="1978da17047230ecfb709900d093fe2bc00bb2a8" translate="yes" xml:space="preserve">
          <source>From now on &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; will know that &lt;code&gt;my-new-feature&lt;/code&gt; is related to the &lt;code&gt;my-new-feature&lt;/code&gt; branch in your own &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo. Subsequent push calls are then simplified to the following:</source>
          <target state="translated">이제부터 &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; 은 &lt;code&gt;my-new-feature&lt;/code&gt; 가 자체 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 저장소 의 &lt;code&gt;my-new-feature&lt;/code&gt; 브랜치 와 관련되어 있음을 알게됩니다 . 이후의 푸시 호출은 다음과 같이 단순화됩니다.</target>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">다른 물체에서</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">기스로부터</target>
        </trans-unit>
        <trans-unit id="5cb06afc42e126aeee1dca21c5d08d384848538d" translate="yes" xml:space="preserve">
          <source>From the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;Reference Guide&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">로부터 &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;Reference Guide&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="translated">명령 줄에서 :</target>
        </trans-unit>
        <trans-unit id="e8689c1f53f242e3e2ed351ba13d4443b972a335" translate="yes" xml:space="preserve">
          <source>From the output above, we can see that every value in &lt;code&gt;img[:,:,0]&lt;/code&gt; is an integer value between 0 and 255, representing the level of red in each corresponding image pixel (keep in mind that this might be different if you use your own image instead of &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face&quot;&gt;&lt;code&gt;scipy.misc.face&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">위의 출력에서 &lt;code&gt;img[:,:,0]&lt;/code&gt; 값이 0에서 255 사이의 정수 값임을 알 수 있으며, 각 해당 이미지 픽셀의 빨간색 수준을 나타냅니다. &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face&quot;&gt; &lt;code&gt;scipy.misc.face&lt;/code&gt; &lt;/a&gt; 대신 자신의 이미지를 사용하십시오 ).</target>
        </trans-unit>
        <trans-unit id="487083148a4854e5ec264b4e7603e6d383b8513e" translate="yes" xml:space="preserve">
          <source>From time to time you may want to pull down the latest code. Do this with:</source>
          <target state="translated">수시로 최신 코드를 풀다운 할 수 있습니다. 다음과 같이하십시오.</target>
        </trans-unit>
        <trans-unit id="541d68d9d4a26a74b3b1aec38602641c99c42b4f" translate="yes" xml:space="preserve">
          <source>Full broadcasting support for &lt;code&gt;np.cross&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.cross&lt;/code&gt; 에 대한 전체 방송 지원</target>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">완전 간접 정렬</target>
        </trans-unit>
        <trans-unit id="b5dd204ac7b63984bfca215999235cdddc1cbe34" translate="yes" xml:space="preserve">
          <source>Full indirect sort.</source>
          <target state="translated">전체 간접 정렬.</target>
        </trans-unit>
        <trans-unit id="c5e895c2415cf527427d487d13723da42a4ffc8d" translate="yes" xml:space="preserve">
          <source>Full path to the package to test.</source>
          <target state="translated">테스트 할 패키지의 전체 경로입니다.</target>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">완전한 종류.</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">전체 정렬</target>
        </trans-unit>
        <trans-unit id="b375e36a5e2c847719599e1c9bc607f532495b26" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;median&lt;/code&gt; used with &lt;code&gt;overwrite_input&lt;/code&gt; only partially sorts array</source>
          <target state="translated">&lt;code&gt;overwrite_input&lt;/code&gt; 과 함께 사용되는 함수 &lt;code&gt;median&lt;/code&gt; 배열을 부분적으로 만 정렬합니다.</target>
        </trans-unit>
        <trans-unit id="b35686e8529228454146ad9f9eb6c40fa0abbf7c" translate="yes" xml:space="preserve">
          <source>Function and macro call style: &lt;code&gt;foo(a, b, c)&lt;/code&gt;, no space before the open paren, no spaces inside the parens, no spaces before commas, one space after each comma.</source>
          <target state="translated">함수 및 매크로 호출 스타일 : &lt;code&gt;foo(a, b, c)&lt;/code&gt; , 열린 괄호 앞 공백 없음, 괄호 내부 공백 없음, 쉼표 앞 공백 없음, 각 쉼표 뒤에 공백 하나.</target>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">전체 기능에 특정 억제를 적용하는 함수 데코레이터.</target>
        </trans-unit>
        <trans-unit id="1ace8a404ff1b1cae179e78198d969ee763553f5" translate="yes" xml:space="preserve">
          <source>Function definition style: function name in column 1, outermost curly braces in column 1, blank line after local variable declarations:</source>
          <target state="translated">함수 정의 스타일 : 1 열의 함수 이름, 1 열의 가장 바깥 쪽 중괄호, 지역 변수 선언 뒤의 빈 줄 :</target>
        </trans-unit>
        <trans-unit id="eaf873f24ebe960e5f8ab96d1bf1dafec8236126" translate="yes" xml:space="preserve">
          <source>Function documentation</source>
          <target state="translated">기능 문서</target>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">ndarray에서 작동하는 기능.</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 의&lt;/a&gt; 함수 포인터</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">float 배열을 float로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 입니다. 이것은 현재 구현에 유용한 것으로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">float 또는 float 배열을 정수 또는 정수 배열로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">단일 float를 문자열로 변환하는 함수입니다. 기본값은 &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 또는 정수 배열을 부동 또는 부동 배열로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81aebc7824dc558f5740b2294a8d328bfb265c12" translate="yes" xml:space="preserve">
          <source>Function to apply on the &amp;ldquo;field&amp;rdquo; dimension. This function must support an &lt;code&gt;axis&lt;/code&gt; argument, like np.mean, np.sum, etc.</source>
          <target state="translated">&quot;필드&quot;차원에 적용 할 기능입니다. 이 함수는 np.mean, np.sum 등과 같은 &lt;code&gt;axis&lt;/code&gt; 인수를 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">배열을 예쁘게 인쇄하는 데 사용되는 기능입니다. 함수는 단일 배열 인수를 예상하고 배열 표현의 문자열을 리턴해야합니다. None 인 경우, 기능은 기본 NumPy 기능으로 재설정되어 배열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 기능에서 사용되는 빈의 가장자리 만 계산하는 기능.</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 기능에서 사용되는 빈의 가장자리 만 계산하는 기능.</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">부동 소수점 오류 ( 'call'-mode) 또는'write '메소드가 이러한 메시지를 기록하는 데 사용되는 객체 ('log'-mode)에 대해 호출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">ufunc에 대한 마스크 된 내부 루프를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">기능적 프로그래밍</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">반복 함수</target>
        </trans-unit>
        <trans-unit id="c9d64db1884b2fd4f353a105874e4c3957322b65" translate="yes" xml:space="preserve">
          <source>Functions and Methods Overview</source>
          <target state="translated">기능 및 방법 개요</target>
        </trans-unit>
        <trans-unit id="cf6da2fb68f3db64f0a7a53228a8721f52f6134f" translate="yes" xml:space="preserve">
          <source>Functions available from numpy.ma.testutils have changed</source>
          <target state="translated">numpy.ma.testutils에서 사용할 수있는 기능이 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">내부 기능을 구현하는 기능. 이 함수 포인터를 모두 주어진 유형에 대해 정의해야하는 것은 아닙니다. 필수 멤버는 &lt;code&gt;nonzero&lt;/code&gt; 이 아닌 , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;setitem&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; 및 &lt;code&gt;cast&lt;/code&gt; 입니다. 이들은 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 것으로 가정 되며 &lt;code&gt;NULL&lt;/code&gt; 항목은 프로그램 충돌을 일으 킵니다. 다른 함수는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있으며, 이는 해당 데이터 유형의 기능이 축소되었음을 의미합니다. 또한 사용자 정의 데이터 유형을 등록 할 때 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 0이 아닌 함수는 기본 함수로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="f48c175b4673c0bc456bc9f1ba654da2d9542a5c" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;numpy.random&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.random&lt;/code&gt; 의 함수</target>
        </trans-unit>
        <trans-unit id="516c584b732d36ebda7d25fae38b326dc6d202ae" translate="yes" xml:space="preserve">
          <source>Functions in numpy.random</source>
          <target state="translated">numpy.random의 함수</target>
        </trans-unit>
        <trans-unit id="c724fd9678ed45fd313d6c7db38a089943643ca5" translate="yes" xml:space="preserve">
          <source>Functions may be listed without descriptions, and this is preferable if the functionality is clear from the function name:</source>
          <target state="translated">기능은 설명없이 나열 될 수 있으며, 기능 이름에서 기능이 명확 할 경우 선호됩니다.</target>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">축을 따라 인덱스를 반환하는 함수 &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt;함수는이 함수에 적합한 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">numpy 네임 스페이스에 있고 함수를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="95335a3a51e2f80868a95521fb5668b275263818" translate="yes" xml:space="preserve">
          <source>Functions that don&amp;rsquo;t accept keyword arguments should be written as:</source>
          <target state="translated">키워드 인수를 허용하지 않는 함수는 다음과 같이 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="7d214954501f7e7519692e45acb1bf64805c41e6" translate="yes" xml:space="preserve">
          <source>Functions that operate element by element on whole arrays.</source>
          <target state="translated">전체 배열에서 요소별로 작동하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="f7888c5dcdff069b34a3486459892edd2f262c97" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments</source>
          <target state="translated">키워드 인수가있는 함수</target>
        </trans-unit>
        <trans-unit id="6020fb8e5272b3356bebe72ae19a144383754b4e" translate="yes" xml:space="preserve">
          <source>Functions without keyword arguments</source>
          <target state="translated">키워드 인수가없는 함수</target>
        </trans-unit>
        <trans-unit id="6dad1764839322eb03eab6b07936a589482f90c1" translate="yes" xml:space="preserve">
          <source>Fundraising</source>
          <target state="translated">Fundraising</target>
        </trans-unit>
        <trans-unit id="4647f887db448ba6bb11f7136147a60fabe16fc4" translate="yes" xml:space="preserve">
          <source>Further Numeric Style types Deprecated</source>
          <target state="translated">더 이상 사용되지 않는 숫자 스타일 유형</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">에 대한 추가 설명 &lt;code&gt;fmt&lt;/code&gt; 매개 변수에 ( &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="3abcbfb793b7e40f09b0f5479b45936952f0ec59" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;np.ctypeslib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.ctypeslib&lt;/code&gt; 의 &lt;code&gt;ctypes&lt;/code&gt; 지원에 대한 추가 개선</target>
        </trans-unit>
        <trans-unit id="8b7e1185b0b79852815db7f42a86a47fec5e9990" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;numpy.ctypeslib&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.ctypeslib&lt;/code&gt; 의 &lt;code&gt;ctypes&lt;/code&gt; 지원에 대한 추가 개선</target>
        </trans-unit>
        <trans-unit id="f8a0b7626837b22f011ce8c7c63d65ca89984821" translate="yes" xml:space="preserve">
          <source>Further members are considered private and version dependend. If the size of the struct is important for your code, special care must be taken. A possible use-case when this is relevant is subclassing in C. If your code relies on &lt;code&gt;sizeof(PyArrayObject)&lt;/code&gt; to be constant, you must add the following check at import time:</source>
          <target state="translated">추가 멤버는 비공개로 간주되며 버전에 따라 다릅니다. 구조체의 크기가 코드에 중요한 경우 특별한주의가 필요합니다. 이것이 관련 될 때 가능한 유스 케이스는 C에서 서브 클래 싱하는 것입니다. 코드가 &lt;code&gt;sizeof(PyArrayObject)&lt;/code&gt; 가 상수 에 의존하는 경우 임포트시 다음 검사를 추가해야합니다.</target>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="translated">추가 읽기</target>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">또한 어떻게 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 결합 .</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">또한이 함수로 생성 된 어레이에는 종종 자체 중복 메모리가 포함되므로 두 요소가 동일합니다. 이러한 어레이에서 벡터화 된 쓰기 작업은 일반적으로 예측할 수 없습니다. 작은 배열, 큰 배열 또는 바뀐 배열에 대해 다른 결과를 제공 할 수도 있습니다. 이러한 어레이에 대한 쓰기는 매우주의해서 테스트하고 수행해야하므로 우발적 인 쓰기 작업을 피하기 위해 &lt;code&gt;writeable=False&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12143faa25aabfe7fe468016abec86297c6fcf15" translate="yes" xml:space="preserve">
          <source>Furthermore, numpy now provides a new function &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt; which is a safer and more efficient alternative for users who wish to convert structured arrays to unstructured arrays, as the view above is often indeded to do. This function allows safe conversion to an unstructured type taking into account padding, often avoids a copy, and also casts the datatypes as needed, unlike the view. Code such as:</source>
          <target state="translated">또한, numpy는 위의보기가 종종 수행 할 수 있도록 구조화 된 배열을 구조화되지 않은 배열로 변환하려는 사용자에게 더 안전하고 효율적인 대안 인 새로운 함수 &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt; &lt;/a&gt; 를 제공합니다 . 이 함수를 사용하면 패딩을 고려하여 구조화되지 않은 유형으로 안전하게 변환 할 수 있으며, 종종 복사를 피하고 뷰와 달리 필요에 따라 데이터 유형을 캐스트합니다. 다음과 같은 코드 :</target>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">또한 콜백 함수는 이전과 동일한 유형, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; 입니다. &lt;code&gt;args&lt;/code&gt; 는 호출 될 때 모든 입력 / 출력 인수의 데이터를 포함하는 길이 &lt;code&gt;nargs&lt;/code&gt; 의 목록입니다 . 스칼라 기본 함수의 경우 &lt;code&gt;steps&lt;/code&gt; 길이가 &lt;code&gt;nargs&lt;/code&gt; 는 인수에 사용 된 보폭을 나타내는 입니다. &lt;code&gt;dimensions&lt;/code&gt; 는 루프 될 축의 크기를 정의하는 단일 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c462e5cfdac7c4df78636f70346d506c3e424749" translate="yes" xml:space="preserve">
          <source>Furthermore, using the &lt;code&gt;ndim&lt;/code&gt; property of this array, we can see that</source>
          <target state="translated">또한 이 배열 의 &lt;code&gt;ndim&lt;/code&gt; 속성을 사용하여</target>
        </trans-unit>
        <trans-unit id="22552b8bf29fce0c52d5fcd39548010b9e76338c" translate="yes" xml:space="preserve">
          <source>Future Changes</source>
          <target state="translated">미래의 변화</target>
        </trans-unit>
        <trans-unit id="acb0dc3b9f8b3f5bdca8fc1d87183e1bba912790" translate="yes" xml:space="preserve">
          <source>Future changes</source>
          <target state="translated">미래의 변화</target>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">미래 가치</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">미래 가치 (기본 = 0)</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">미래 가치. 모든 입력 값이 스칼라이면 스칼라 부동 소수점을 반환합니다. 입력이 array_like 인 경우 각 입력 요소에 대한 미래 값을 리턴합니다. 여러 입력이 array_like 인 경우 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="722af3dc654f5b03462276f1ddc84a2ecf2baa12" translate="yes" xml:space="preserve">
          <source>Future very uncertain: it&amp;rsquo;s the only part of Scipy not ported to Python 3 and is effectively deprecated in favor of Cython.</source>
          <target state="translated">미래는 매우 불확실합니다. Scipy의 유일한 부분은 Python 3로 이식되지 않았으며 Cython을 위해 효과적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d739c24bbd3b77640efa7aa653675284eae750ca" translate="yes" xml:space="preserve">
          <source>FutureWarning to changed behavior</source>
          <target state="translated">변경된 동작에 대한 FutureWarning</target>
        </trans-unit>
        <trans-unit id="a6cee77152a751b028de81f7755bdc87bacc5925" translate="yes" xml:space="preserve">
          <source>FutureWarnings</source>
          <target state="translated">FutureWarnings</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">GH Golub 및 CF Van Loan, &lt;em&gt;매트릭스 계산&lt;/em&gt; , Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">G. Strang,&amp;ldquo;선형 대수와 그 응용, 2 판&amp;rdquo;Academic Press, pg. 182, 1980.</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">G. Strang, &lt;em&gt;선형 대수 및 그 응용&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, 다양한 pp.</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, 139-142 쪽.</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">G. Strang, &lt;em&gt;선형 대수 및 그 응용&lt;/em&gt; , Orlando, FL, Academic Press, Inc., 1980, pg. 285.</target>
        </trans-unit>
        <trans-unit id="2fe46435d8800606efbbb4738ea49577e004f01c" translate="yes" xml:space="preserve">
          <source>GUfuncs on empty arrays and NpyIter axis removal</source>
          <target state="translated">빈 배열의 GUfuncs 및 NpyIter 축 제거</target>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="d85fb4eb9b5275137b92e9c14d3dd2b6f13641af" translate="yes" xml:space="preserve">
          <source>Gather</source>
          <target state="translated">Gather</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">가우스 체비 쇼프 구적법.</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">가우스-허 마이트 구적법.</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">Gauss-HermiteE 구적법.</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">가우스-라게 레 구적법.</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">Gauss-Legendre 직교.</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="0cffb2d4275e42dba57746961ea67052aaeef334" translate="yes" xml:space="preserve">
          <source>General Broadcasting Rules</source>
          <target state="translated">일반 방송 규칙</target>
        </trans-unit>
        <trans-unit id="a2ff3c8e4686a4c021328dd784ede1cb72d7755f" translate="yes" xml:space="preserve">
          <source>General Purpose Equivalents</source>
          <target state="translated">범용 등가물</target>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">파이썬 타입의 일반적인 점검</target>
        </trans-unit>
        <trans-unit id="e9497e2601f7c982d6f4ec6cdfd6bc52f316c4cf" translate="yes" xml:space="preserve">
          <source>General purpose equivalents</source>
          <target state="translated">범용 등가물</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">파이썬의 예외에서 파생 된 범용 예외 클래스. 예외 클래스는 선형 대수 관련 조건이 함수의 올바른 실행을 방해 할 때 linalg 함수에서 프로그래밍 방식으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 두 번째 마지막 차원을 사용하는 일반화 된 행렬 곱 .</target>
        </trans-unit>
        <trans-unit id="172636dd07a5cf344fc718f14e5f8bac9163a8d1" translate="yes" xml:space="preserve">
          <source>Generalized &lt;code&gt;flip&lt;/code&gt;</source>
          <target state="translated">일반화 &lt;code&gt;flip&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4d7eab60b5c5966c3521dbaae99dc8efbf97f6cb" translate="yes" xml:space="preserve">
          <source>Generalized Ufuncs will now unlock the GIL</source>
          <target state="translated">일반화 된 Ufunc는 이제 GIL을 잠금 해제합니다.</target>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">일반화 된 범용 함수 API</target>
        </trans-unit>
        <trans-unit id="e299d19ac7292c1bf7156bae2d6dd21bd9fba291" translate="yes" xml:space="preserve">
          <source>Generalized axis support for median and percentile</source>
          <target state="translated">중앙값 및 백분위 수에 대한 일반화 된 축 지원</target>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">일반화 된 함수 클래스.</target>
        </trans-unit>
        <trans-unit id="1a1bc0e8d9d246a721e301167a79c68d6cdef5b2" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow fixed-size dimensions</source>
          <target state="translated">일반화 된 ufunc 서명은 이제 고정 크기 차원을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d2d28b03b171fb860aee83a82f532e58c4e9fba3" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow flexible dimensions</source>
          <target state="translated">일반화 된 ufunc 서명은 이제 유연한 차원을 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0046ab62e86cdc207bdc51ed66f39ae439778565" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs</source>
          <target state="translated">일반화 된 ufunc</target>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">일반화 된 ufunc는 많은 linalg 함수와 테스트 스위트에서 내부적으로 사용됩니다. 아래의 예는 이들에서 가져온 것입니다. 스칼라에서 작동하는 ufunc의 경우 서명은 &lt;code&gt;None&lt;/code&gt; 이며 모든 인수에 대해 '()'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0078c3e5a20e2fad81f2acb827abe758030ac9d" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is None, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">일반화 된 ufunc는 많은 linalg 함수와 테스트 스위트에서 내부적으로 사용됩니다. 아래의 예는 이들에서 가져온 것입니다. 스칼라에서 작동하는 ufunc의 경우 서명은 None이며 모든 인수에 대해 '()'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="bf9c0fe98002f4322da923b10684f6d5d099ff33" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs now accept &lt;code&gt;axes&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt; arguments</source>
          <target state="translated">일반화 된 ufunc는 이제 &lt;code&gt;axes&lt;/code&gt; , &lt;code&gt;axis&lt;/code&gt; 및 &lt;code&gt;keepdims&lt;/code&gt; 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">벡터화 된 행렬-벡터 곱셈을위한 일반화 된 범용 함수 서명, 예를 들어 &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; . 제공되는 경우 &lt;code&gt;pyfunc&lt;/code&gt; 는 해당 코어 크기의 크기로 주어진 모양을 가진 배열로 호출됩니다 (그리고 반환 될 것으로 예상됩니다). 기본적으로 &lt;code&gt;pyfunc&lt;/code&gt; 는 스칼라를 입력 및 출력으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="4bdfd56723e2a4630d0aa40f0eab7e7e821379e3" translate="yes" xml:space="preserve">
          <source>Generally speaking, what is returned when index arrays are used is an array with the same shape as the index array, but with the type and values of the array being indexed. As an example, we can use a multidimensional index array instead:</source>
          <target state="translated">일반적으로 인덱스 배열을 사용할 때 반환되는 것은 인덱스 배열과 모양이 같지만 배열의 유형과 값이 인덱싱되는 배열입니다. 예를 들어 다차원 인덱스 배열을 대신 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2257faa28ea2af0838b36329ac81b4299b5a11a1" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">일반적으로 파일은 빌드시에만 알려진 정보 (예 : 접두사)가 필요하기 때문에 빌드 중에 생성되어야합니다. &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 메소드 &lt;code&gt;add_npy_pkg_config&lt;/code&gt; 를 사용하는 경우 대부분 자동 입니다. 다음과 같은 템플릿 파일 foo.ini.in이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">일반적으로 파일은 빌드시에만 알려진 일부 정보 (예 : 접두사)가 필요하므로 빌드 중에 생성해야합니다. &lt;code&gt;Configuration&lt;/code&gt; 방법 &lt;code&gt;add_npy_pkg_config&lt;/code&gt; 를 사용하는 경우 대부분 자동 입니다. 다음과 같이 템플릿 파일 foo.ini.in이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">3 개의 다른 하한으로 1 x 3 배열 생성</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">3 가지 상한으로 1 x 3 배열 생성</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">dtype이 uint8 인 브로드 캐스팅을 사용하여 2 x 4 배열 생성</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">다음을 포함하여 0에서 4 사이의 정수로 2 x 4 배열을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 체비 쇼프 시리즈를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 은자 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 HermiteE 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 Laguerre 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 Legendre 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">Vandermonde 매트릭스를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">주어진 근을 가진 음의 다항식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">대체하지 않고 크기 3의 np.arange (5)에서 비 균일 랜덤 샘플을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">크기 3의 np.arange (5)에서 비 균일 랜덤 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="15beef8541c11b005861875826a071b16faf6c61" translate="yes" xml:space="preserve">
          <source>Generate a single integer</source>
          <target state="translated">단일 정수 생성</target>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">대체하지 않고 크기 3의 np.arange (5)에서 균일 한 랜덤 샘플을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">크기 3의 np.arange (5)에서 균일 한 랜덤 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">템플릿에서 npy-pkg 구성 파일을 생성하고 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">패키지를 빌드하는 동안 사용 된 system_info 정보가 포함 된 config.py 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">패키지를 빌드하는 동안 사용 된 system_info 정보를 포함하는 패키지 __config__.py 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">SVN 개정 번호에서 __svn_version__.py 패키지 패키지를 생성하십시오. 파이썬이 종료되면 제거되지만 sdist 등 명령이 실행될 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60ff5f05cec532a7f8f7d819baeeb92b41c5296d" translate="yes" xml:space="preserve">
          <source>Generate random uint64 numbers in closed interval [off, off + rng].</source>
          <target state="translated">닫힌 간격 [off, off + rng]에서 임의의 uint64 숫자를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="c8045f4bbe378a7866506cc0ecb5d877bf5eaf96" translate="yes" xml:space="preserve">
          <source>Generate the README files</source>
          <target state="translated">README 파일 생성</target>
        </trans-unit>
        <trans-unit id="7412730131bc368e3c0dcb289c20fbf2554245c4" translate="yes" xml:space="preserve">
          <source>Generate variates from a multivariate hypergeometric distribution.</source>
          <target state="translated">다변량 초기 하 분포에서 변량을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">주어진 1 차원 배열에서 무작위 표본을 생성합니다</target>
        </trans-unit>
        <trans-unit id="d332ac6845c5273c1195174ec786fa2289b9b752" translate="yes" xml:space="preserve">
          <source>Generating author/pr lists</source>
          <target state="translated">저자 / 홍보 목록 생성</target>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">인덱스 배열 생성</target>
        </trans-unit>
        <trans-unit id="4bc72cf76a431fc1b67a969426c355ba5d2b3044" translate="yes" xml:space="preserve">
          <source>Generating random numbers</source>
          <target state="translated">난수 생성</target>
        </trans-unit>
        <trans-unit id="1d20de03126b297e05c13a7d280f33e24c72c537" translate="yes" xml:space="preserve">
          <source>Generator</source>
          <target state="translated">Generator</target>
        </trans-unit>
        <trans-unit id="1a0d1bad0186174ecfcdc9782f2116277b7b05e0" translate="yes" xml:space="preserve">
          <source>Generator (class in numpy.random)</source>
          <target state="translated">생성기 (numpy.random의 클래스)</target>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="b9790b2a609e0a0a9945eb7f9ff37cc7c5acb58d" translate="yes" xml:space="preserve">
          <source>Generators should be documented just as functions are documented. The only difference is that one should use the &lt;strong&gt;Yields&lt;/strong&gt; section instead of the &lt;strong&gt;Returns&lt;/strong&gt; section. Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="translated">생성기는 함수가 문서화 된 것처럼 문서화되어야합니다. 유일한 차이점은 하나가 사용되어야한다는 것이다 &lt;strong&gt;수익률의&lt;/strong&gt; 의 대신 섹션을 &lt;strong&gt;반환&lt;/strong&gt; 섹션을 참조하십시오. &lt;strong&gt;수율&lt;/strong&gt; 섹션에 대한 지원 은 &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; 버전 0.6 에서 추가되었습니다 .</target>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">생성기 : BitGenerator의 임의 비트 시퀀스를 지정된 간격 내에서 특정 확률 분포 (예 : 균일, 정규 또는 이항)를 따르는 숫자 시퀀스로 변환하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">linalg 함수에 의해 생성 된 일반 파이썬 예외 파생 객체.</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">일반 함수</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">itemptr이 가리키는 위치에서 ndarray &lt;em&gt;arr&lt;/em&gt; 에서 내장 유형의 Python 객체를 가져옵니다. 실패 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">반복자의 사본을 1 차원 배열로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">반복자의 사본을 현재 상태로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87007e132eebf348c07afe83a50790715b0d7b52" translate="yes" xml:space="preserve">
          <source>Get a serializable descriptor from the dtype.</source>
          <target state="translated">dtype에서 직렬화 가능한 설명자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="6ebe75c1446477b5a3f24473d32f0a3cde8a8998" translate="yes" xml:space="preserve">
          <source>Get array data-descriptor.</source>
          <target state="translated">배열 데이터 설명자를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 로컬 변수에 대한 포인터가 전달되어 상태를 설정하는 코드와 관련하여 공격적인 컴파일러 최적화에서이 함수 호출을 다시 지정하지 못하게되어 잘못된 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c919c3aaf29bde2f7fadef95afc3436e547fc4bb" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 로컬 변수에 대한 포인터가 전달되어 공격적인 컴파일러 최적화가 상태를 설정하는 코드와 관련하여이 함수 호출을 재정렬하지 못하도록하여 잘못된 결과를 초래할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 다음과 같은 플래그로 비트 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">함수, 클래스 또는 모듈에 대한 도움말 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">날짜 또는 시간 유형의 단계 크기에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d0d9c57e1b16aa99fa5d9ab014f87b4ec73ded17" translate="yes" xml:space="preserve">
          <source>Get number of parallel build jobs set by the &amp;ndash;parallel command line argument of setup.py If the command did not receive a setting the environment variable NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of processors on the system, with a maximum of 8 (to prevent overloading the system if there a lot of CPUs).</source>
          <target state="translated">setup.py의 &amp;ndash;parallel 명령 줄 인수로 설정된 병렬 빌드 작업 수 가져 오기 명령이 설정을 수신하지 못한 경우 환경 변수 NPY_NUM_BUILD_JOBS가 확인됩니다. 설정되지 않은 경우 시스템의 프로세서 수를 최대 8 개로 반환합니다 (CPU가 많은 경우 시스템 과부하를 방지하기 위해).</target>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">PRNG 상태 가져 오기 또는 설정</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">명명 된 필드가없는 배열의 마스크를 가져 오거나 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">명명 된 필드가없는 배열의 마스크를 가져 오거나 설정하십시오. 구조화 된 배열의 경우 &lt;strong&gt;모든&lt;/strong&gt; 필드가 마스크 된 경우 항목이 &lt;code&gt;True&lt;/code&gt; 인 부울의 ndarray를 반환하고 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">자원 정보를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">이름 조회가 무시되는 경우 기본값이 설정되지 않은 경우 스레드 로컬 저장 영역에서 ufunc 처리에 사용되는 Python 값을 가져옵니다. 이름은 &lt;em&gt;* errobj&lt;/em&gt; 의 첫 번째 요소에 문자열로 배치됩니다 . 두 번째 요소는 오류 콜백을 호출하는 조회 기능입니다. 조회 할 버퍼 크기 의 값은 &lt;em&gt;bufsize&lt;/em&gt; 로 전달되고 오류 마스크의 값은 &lt;em&gt;errmask에&lt;/em&gt; 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">부동 소수점 오류를 처리하는 현재 방법을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="a3515ff2e2849783558090ab689766335d448845" translate="yes" xml:space="preserve">
          <source>Get the dictionary of header metadata from a numpy.ndarray.</source>
          <target state="translated">numpy.ndarray에서 헤더 메타 데이터 사전을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1ad2852f86c694e329d03e73d07b76a105a8cebc" translate="yes" xml:space="preserve">
          <source>Get the local copy of the code</source>
          <target state="translated">코드의 로컬 사본 가져 오기</target>
        </trans-unit>
        <trans-unit id="2a1b740f8025f19530f67b712588ba731f33b4b5" translate="yes" xml:space="preserve">
          <source>Get the mailing list&amp;rsquo;s opinion</source>
          <target state="translated">메일 링리스트의 의견 받기</target>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">배열의 차원 수를 구합니다</target>
        </trans-unit>
        <trans-unit id="38abfcd88f93b84356fd5ce9430a9a3bce6aa97e" translate="yes" xml:space="preserve">
          <source>Get the shape of the array and a pointer to its actual data.</source>
          <target state="translated">배열의 모양과 실제 데이터에 대한 포인터를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Getitem / setitem / copyswap 함수 : ufuncs와 유사하게이 함수에는 일반적으로 두 개의 코드 경로가 있습니다. 경우 &lt;code&gt;ALIGNED&lt;/code&gt; 거짓입니다 그들은 진정한 정렬 그래서 인수를 버퍼링 코드 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">고정되거나 전체 반복 중에 변경되지 않는 보폭 배열을 가져옵니다. 변경 가능한 보폭의 경우 NPY_MAX_INTP 값이 보폭에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">가져 &lt;code&gt;iterindex&lt;/code&gt; 반복기의 반복 순서와 일치하는 인덱스 반복기의이.</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">반복되는 &lt;code&gt;iterindex&lt;/code&gt; 하위 범위를 가져옵니다 . 경우 &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; 가&lt;/a&gt; 지정되지 않았습니다이 항상 범위를 반환 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">반복 인덱스 0에 해당하는 데이터 포인터의 배열을 버퍼로 절대 배열에 직접 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">지정된 축에 대한 보폭 배열을 가져옵니다. 반복자가 다중 색인을 추적하고 버퍼링을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">생성기에서 사용하는 비트 생성기 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d159fd31101fbca3940d95031521a0aa1cca2dba" translate="yes" xml:space="preserve">
          <source>Getting at ndarray memory and accessing elements of the ndarray</source>
          <target state="translated">ndarray 메모리 가져 오기 및 ndarray 요소 액세스</target>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">소스에서 추가 포트란 77 컴파일러 옵션 얻기</target>
        </trans-unit>
        <trans-unit id="40231bcdbc4a93a29a6d8b82096fcd17f9064444" translate="yes" xml:space="preserve">
          <source>Getting started with Git development</source>
          <target state="translated">Git 개발 시작하기</target>
        </trans-unit>
        <trans-unit id="44a67759e2faf7084b39d19d3457bdd8b15ee0fc" translate="yes" xml:space="preserve">
          <source>Getting your PR reviewed</source>
          <target state="translated">PR 검토 받기</target>
        </trans-unit>
        <trans-unit id="16e47f4c54647389b910573011e6826ea1e0a912" translate="yes" xml:space="preserve">
          <source>Git Basics</source>
          <target state="translated">힘내 기초</target>
        </trans-unit>
        <trans-unit id="dfff37d55b9830b2f87d05fbf99d4f09fbfa666c" translate="yes" xml:space="preserve">
          <source>Git configuration</source>
          <target state="translated">힘내 구성</target>
        </trans-unit>
        <trans-unit id="1c5717316487921ed9c21d808282281daa39b5a4" translate="yes" xml:space="preserve">
          <source>Git for development</source>
          <target state="translated">개발 용 Git</target>
        </trans-unit>
        <trans-unit id="62cbb73206931d6c5b9ae31c184bc49486ee1eb6" translate="yes" xml:space="preserve">
          <source>Git will then immediately bring up an editor for editing the commit message. After revising it, we get the output:</source>
          <target state="translated">그런 다음 Git은 커밋 메시지를 편집 할 수있는 편집기를 즉시 표시합니다. 수정 한 후 출력을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="b921f982571c01ce7cb6f536b3e77eda32e15376" translate="yes" xml:space="preserve">
          <source>GitHub Workflow</source>
          <target state="translated">GitHub 워크 플로</target>
        </trans-unit>
        <trans-unit id="1adcbfda881a779a35ee45bce592fd5b70ba61b5" translate="yes" xml:space="preserve">
          <source>Give a brief but explicit answer</source>
          <target state="translated">간단하지만 명시적인 답변을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="41715e18a150ce4ffd8181520dab988c818a96bb" translate="yes" xml:space="preserve">
          <source>Give the name &lt;code&gt;upstream&lt;/code&gt; to the main NumPy repo:</source>
          <target state="translated">메인 NumPy 리포지토리에 &lt;code&gt;upstream&lt;/code&gt; 이름 을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">다항식 0의 시퀀스가 ​​주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">같은 모양 의 배열 ( &lt;em&gt;sort_keys&lt;/em&gt; ) 시퀀스가 주어지면 배열을 사전 식으로 정렬하는 인덱스 배열 ( &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 과 유사)을 반환 하십시오. 사전 식 정렬은 두 개의 키가 동일 할 때 순서가 후속 키의 비교를 기반으로 함을 지정합니다. 유형에 대해 병합 항목 (동일한 항목을 그대로 유지)을 정의해야합니다. 정렬 먼저 인덱스 선별 제를 사용하여 달성된다 &lt;em&gt;sort_key을&lt;/em&gt; 다음 두 번째 사용 &lt;em&gt;sort_key를&lt;/em&gt; 등등과. 이것은 lexsort ( &lt;em&gt;sort_keys&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) Python 명령과 동일합니다. 병합 정렬이 작동하는 방식 때문에 &lt;em&gt;sort_keys&lt;/em&gt; 의 순서를 이해해야합니다.&lt;em&gt;&lt;/em&gt; 에 있어야합니다 (두 요소를 비교할 때 사용하는 순서와 반대로).</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">일련의 조건과 해당 기능이 주어지면 입력 데이터의 각 기능이 조건에 맞는지 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">예컨대 형상, 주어진 &lt;code&gt;(m,n,k)&lt;/code&gt; , &lt;code&gt;m*n*k&lt;/code&gt; 샘플을 생성 및 포장 &lt;code&gt;m&lt;/code&gt; -by- &lt;code&gt;n&lt;/code&gt; -by- &lt;code&gt;k&lt;/code&gt; 배열. 각 표본은 &lt;code&gt;N&lt;/code&gt; 차원이므로 출력 모양은 &lt;code&gt;(m,n,k,N)&lt;/code&gt; 입니다. 모양을 지정하지 않으면 단일 ( &lt;code&gt;N&lt;/code&gt; -D) 샘플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">정사각형 배열 객체가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;a&lt;/code&gt; 가 주어지면 &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; 만족 하는 행렬 &lt;code&gt;ainv&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 &lt;code&gt;q&lt;/code&gt; 번째 백분위 수의 &lt;code&gt;V&lt;/code&gt; 되는 값 &lt;code&gt;q/100&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법 &lt;code&gt;V&lt;/code&gt; . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않으면 가장 가까운 두 이웃 및 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 의 값과 거리에 따라 백분위 수가 결정 됩니다. 이 함수는 &lt;code&gt;q=50&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=100&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 평균 &lt;code&gt;V&lt;/code&gt; 의 정렬 된 사본 &lt;code&gt;V&lt;/code&gt; 의 &lt;code&gt;V_sorted&lt;/code&gt; - 즉 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; 의 중간 값이며 &lt;code&gt;N&lt;/code&gt; 이 홀수 일 때 &lt;code&gt;N&lt;/code&gt; 이 짝수 일 때 &lt;code&gt;V_sorted&lt;/code&gt; 의 두 중간 값 .</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이의 &lt;code&gt;N&lt;/code&gt; 의 평균 &lt;code&gt;V&lt;/code&gt; 정렬 된 복사본의 중간 값 인 &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - 즉 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , 경우 &lt;code&gt;N&lt;/code&gt; 이 홀수 개의 중간 값의 평균이며 의 &lt;code&gt;V_sorted&lt;/code&gt; 때 &lt;code&gt;N&lt;/code&gt; 은 짝수이다.</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 Q 번째 백분위 &lt;code&gt;V&lt;/code&gt; 는 값이다 &lt;code&gt;q/100&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법 &lt;code&gt;V&lt;/code&gt; . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않으면 가장 가까운 두 이웃 및 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 의 값과 거리에 따라 백분위 수가 결정 됩니다. 이 함수는 &lt;code&gt;q=50&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=100&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 Q 번째 분위수 &lt;code&gt;V&lt;/code&gt; 는 값이다 &lt;code&gt;q&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법은 &lt;code&gt;V&lt;/code&gt; 는 . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않는 경우 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 뿐만 아니라 가장 가까운 두 이웃의 값과 거리가 Quantile을 결정합니다 . 이 함수는 &lt;code&gt;q=0.5&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0.0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=1.0&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 와 &lt;code&gt;N&lt;/code&gt; 의 값을 마스크 비의 평균 &lt;code&gt;V&lt;/code&gt; 는 정렬 된 복사본의 중간 값 인 &lt;code&gt;V&lt;/code&gt; ( &lt;code&gt;Vs&lt;/code&gt; 즉 -) &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 이 홀수 또는 &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; &lt;code&gt;N&lt;/code&gt; 이 짝수 인 경우 / 2-1] + Vs [N / 2]} / 2</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">창 길이 &lt;code&gt;n&lt;/code&gt; 과 샘플 간격 &lt;code&gt;d&lt;/code&gt; 가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">정수 의 &quot;인덱스&quot;어레이 ( &lt;code&gt;a&lt;/code&gt; ) 및 &lt;code&gt;n&lt;/code&gt; 개의 어레이 ( &lt;code&gt;choices&lt;/code&gt; ) 의 시퀀스가 주어지면 , &lt;code&gt;a&lt;/code&gt; 및 각 선택 어레이는 필요에 따라 공통 형상의 어레이로 먼저 브로드 캐스트된다; 이것을 호출&lt;em&gt; Ba&lt;/em&gt; 와 &lt;em&gt;Bchoices [i], i = 0,&amp;hellip;, n-1&lt;/em&gt; 이라고 &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; 반드시 각 &lt;code&gt;i&lt;/code&gt; 에 대해 Ba.shape == Bchoices [i] .shape 가됩니다 . 그런 다음 모양이 &lt;code&gt;Ba.shape&lt;/code&gt; 인 새 배열이 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">정수 배열과 n 개의 선택 배열 집합이 주어지면이 메소드는 각 선택 배열을 병합하는 새 배열을 만듭니다. 의 값 여기서 &lt;code&gt;a&lt;/code&gt; I 인 새로운 배열을 선택 [I]이 동일 위치에 포함 된 값을 가질 것이다.</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">간격이 주어지면 간격 밖의 값이 간격 가장자리에 잘립니다. 예를 들어, 간격 &lt;code&gt;[0, 1]&lt;/code&gt; 을 지정하면 0보다 작은 값은 0이되고 1보다 큰 값은 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">스프레드 시트에서 열로 해석 될 수있는 여러 정렬 키가 제공되면 lexsort는 여러 열의 정렬 순서를 설명하는 정수 인덱스 배열을 반환합니다. 시퀀스의 마지막 키는 기본 정렬 순서에 사용되며, 두 번째에서 마지막 키는 보조 정렬 순서에 사용됩니다. keys 인수는 동일한 모양의 배열로 변환 될 수있는 일련의 객체 여야합니다. keys 인수에 2D 배열이 제공되는 경우 행은 정렬 키로 해석되며 정렬은 마지막 행, 두 번째 마지막 행 등에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="bcbd60ed302ecb4de642c2dac63a654ff76626bc" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, its rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">스프레드 시트의 열로 해석 될 수있는 여러 정렬 키가 주어지면 lexsort는 여러 열의 정렬 순서를 설명하는 정수 인덱스 배열을 반환합니다. 시퀀스의 마지막 키는 기본 정렬 순서에 사용되며 두 번째에서 마지막 키는 보조 정렬 순서에 사용됩니다. keys 인수는 동일한 모양의 배열로 변환 할 수있는 일련의 객체 여야합니다. keys 인수에 2D 배열이 제공되는 경우 해당 행은 정렬 키로 해석되고 정렬은 마지막 행, 두 번째 마지막 행 등을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">직각 삼각형의&amp;ldquo;다리&amp;rdquo;가 주어지면 빗변을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65f0e0f7ab08e6e7d473538fe0c4ef0f86fa2404" translate="yes" xml:space="preserve">
          <source>Given the above, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="translated">위와 같이 우리는 결국 &lt;code&gt;matrix&lt;/code&gt; 을 폐기 할 계획 입니다.</target>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">배열의 모양이 &lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 인스턴스의 N 차원 인덱스를 반복합니다. 각 반복에서 튜플 인덱스가 반환되고 마지막 차원이 먼저 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">두 개의 &lt;em&gt;n&lt;/em&gt; 길이의 정수 배열이 주어지면 &lt;em&gt;l1&lt;/em&gt; 및 &lt;em&gt;L2&lt;/em&gt; , 복귀 한리스트가 동일한 경우; 그렇지 않으면 0을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 동일하고 첫 번째 객체의 모든 요소가 두 번째 객체의 요소보다 엄격하게 작은 지 확인하십시오. 모양이 일치하지 않거나 잘못 정렬 된 값에서 예외가 발생합니다. 개체의 치수가 0이면 모양 불일치가 발생하지 않습니다. Numpy의 표준 사용법과 달리 NaN은 비교되며 두 개체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33ed5b3e4d203313d72bfb61344b0ef20252735e" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal (but see the Notes for the special handling of a scalar). An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 같고 이러한 객체의 모든 요소가 동일한 지 확인합니다 (하지만 스칼라의 특수 처리에 대해서는 Notes 참조). 모양이 일치하지 않거나 값이 충돌하면 예외가 발생합니다. numpy의 표준 사용과 달리 NaN은 숫자처럼 비교되며 두 개체가 동일한 위치에 NaN을 가지고 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 동일하고 이러한 객체의 모든 요소가 동일한 지 확인하십시오. 모양 불일치 또는 충돌하는 값에서 예외가 발생합니다. Numpy의 표준 사용법과 달리 NaN은 숫자처럼 비교되며 두 객체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">두 개의 숫자가 주어지면 대략 같은지 확인하십시오. 대략적인 숫자는 동의하는 유효 자릿수로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">두 개의 객체 (스칼라,리스트, 튜플, 사전 또는 numpy 배열)가 주어지면이 객체의 모든 요소가 동일한 지 확인하십시오. 첫 번째 충돌 값에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">두 개의 다항식 &lt;code&gt;a1&lt;/code&gt; 과 &lt;code&gt;a2&lt;/code&gt; 가 주어지면 &lt;code&gt;a1 - a2&lt;/code&gt; 반환합니다 . &lt;code&gt;a1&lt;/code&gt; 및 &lt;code&gt;a2&lt;/code&gt; 는 다항식 계수 (0과 같은 계수 포함)의 array_like 시퀀스이거나 &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">두 텐서 주어진 및 &lt;code&gt;b&lt;/code&gt; , 및 물체 array_like 두 함유 array_like 오브젝트 &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; ,의 제품 합계 'S 및 &lt;code&gt;b&lt;/code&gt; 로 지정된 축상에서의 구성 요소 (부품) &lt;code&gt;a_axes&lt;/code&gt; 및 &lt;code&gt;b_axes&lt;/code&gt; . 세 번째 인수는 음이 아닌 단일 integer_like 스칼라 &lt;code&gt;N&lt;/code&gt; 일 수 있습니다 . 그러한 경우, &lt;code&gt;a&lt;/code&gt; 의 마지막 &lt;code&gt;N&lt;/code&gt; 치수 와 &lt;code&gt;b&lt;/code&gt; 의 첫 번째 &lt;code&gt;N&lt;/code&gt; 치수 가 합산됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="882e099811dae6ac151e6bf8446fa672be3c6225" translate="yes" xml:space="preserve">
          <source>Gives a list of the names to exclude, such as &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;&amp;hellip; If one of the input name is part of this list, an underscore character (&lt;code&gt;'_'&lt;/code&gt;) will be appended to it.</source>
          <target state="translated">제외 할 이름 목록을 제공합니다 (예 : &lt;code&gt;return&lt;/code&gt; , &lt;code&gt;file&lt;/code&gt; , &lt;code&gt;print&lt;/code&gt; &amp;hellip;) 입력 이름 중 하나가이 목록의 일부인 경우 밑줄 문자 ( &lt;code&gt;'_'&lt;/code&gt; )가 여기에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1175f81a358d9e3f38210901aaa9e95baea2d5bc" translate="yes" xml:space="preserve">
          <source>Gives a string combining all the characters that must be deleted from the name. By default, invalid characters are &lt;code&gt;~!@#$%^&amp;amp;*()-=+~\|]}[{';:
/?.&amp;gt;,&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">이름에서 삭제해야하는 모든 문자를 결합한 문자열을 제공합니다. 기본적으로 잘못된 문자는 &lt;code&gt;~!@#$%^&amp;amp;*()-=+~\|]}[{';: /?.&amp;gt;,&amp;lt;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Glantz, Stanton A.&amp;ldquo;생체 통계학 전문가&amp;rdquo;, McGraw-Hill, 5 판, 2002.</target>
        </trans-unit>
        <trans-unit id="98ce8e321806dbb3b91df4ce336400b327d82b05" translate="yes" xml:space="preserve">
          <source>Global State</source>
          <target state="translated">글로벌 상태</target>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="b5455baaf8bb77490bac48f282fc705e080b078c" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;https://github.com/numpy/numpy&lt;/a&gt; and click the &amp;ldquo;fork&amp;rdquo; button to create your own copy of the project.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;https://github.com/numpy/numpy로&lt;/a&gt; 이동 하여 &quot;포크&quot;버튼을 클릭하여 프로젝트 사본을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="e307ec71f941bf50bb0ca58211aaf38b07c21cec" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases&lt;/a&gt;, there should be a &lt;code&gt;v1.14.5
tag&lt;/code&gt;, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases로&lt;/a&gt; 이동 하면 &lt;code&gt;v1.14.5 tag&lt;/code&gt; 가 있어야합니다. 태그 를 클릭하고 해당 태그에 대한 수정 버튼을 누르세요. 파일을 추가하는 방법에는 편집 가능한 텍스트 창을 사용하는 방법과 바이너리 업로드 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed8a62e7348cf073697e66839cff7484d1d38105" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases&lt;/a&gt;, there should be a &lt;code&gt;v1.19.0
tag&lt;/code&gt;, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads. Cut and paste the &lt;code&gt;release/README.md&lt;/code&gt; file contents into the text window. You will probably need to make some edits to get it to look right. Then</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases로&lt;/a&gt; 이동 하면 &lt;code&gt;v1.19.0 tag&lt;/code&gt; 가 있어야합니다. 태그 를 클릭하고 해당 태그에 대한 수정 버튼을 누르세요. 파일을 추가하는 방법에는 편집 가능한 텍스트 창을 사용하는 방법과 바이너리 업로드 방법이 있습니다. &lt;code&gt;release/README.md&lt;/code&gt; 파일 내용을 잘라내어 텍스트 창에 붙여 넣습니다 . 제대로 보이게하려면 약간의 수정이 필요할 것입니다. 그때</target>
        </trans-unit>
        <trans-unit id="5a55f17953adb4e53b1ccccc7c663a01a1165b91" translate="yes" xml:space="preserve">
          <source>Go to GitHub. The new branch will show up with a green Pull Request button. Make sure the title and message are clear, concise, and self- explanatory. Then click the button to submit it.</source>
          <target state="translated">GitHub로 이동합니다. 새 브랜치는 녹색 Pull Request 버튼과 함께 표시됩니다. 제목과 메시지는 명확하고 간결하며 자명해야합니다. 그런 다음 버튼을 클릭하여 제출하십시오.</target>
        </trans-unit>
        <trans-unit id="69980c4426505922b99957185231ede61f777564" translate="yes" xml:space="preserve">
          <source>Go to github and make a PR.</source>
          <target state="translated">github로 이동하여 PR을하십시오.</target>
        </trans-unit>
        <trans-unit id="bb0c75662080ceb97dedb20703369eded0631af1" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy GitHub home&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy GitHub 홈으로&lt;/a&gt; 이동합니다 .</target>
        </trans-unit>
        <trans-unit id="a46869e8de50d59c9c1645cda5ce89ba58d2c65a" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; github home at &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt;.</source>
          <target state="translated">로 이동 &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy와의&lt;/a&gt; 에서 GitHub의 집 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy와 GitHub의&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb3f0c82f9a531318bc29fd46c7f891f5c55b9a1" translate="yes" xml:space="preserve">
          <source>Good for wrapping large (many functions) existing C libraries</source>
          <target state="translated">큰 (많은 함수) 기존 C 라이브러리를 래핑하는 데 적합합니다.</target>
        </trans-unit>
        <trans-unit id="7575b45e9c9e8a73a854ae2b8b5199197bc11d2e" translate="yes" xml:space="preserve">
          <source>Google has no guidance, or</source>
          <target state="translated">Google에 지침이 없거나</target>
        </trans-unit>
        <trans-unit id="69bb06bd200ddbdceda42084b415b9a92259f61a" translate="yes" xml:space="preserve">
          <source>Google offers two free &lt;a href=&quot;https://developers.google.com/tech-writing&quot;&gt;Technical Writing Courses&lt;/a&gt;</source>
          <target state="translated">Google은 두 가지 무료 &lt;a href=&quot;https://developers.google.com/tech-writing&quot;&gt;기술 문서 작성 과정을 제공합니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">그라디언트는 주어진 축을 따라서 만 계산됩니다. 기본값 (축 = 없음)은 입력 배열의 모든 축에 대한 그라디언트를 계산하는 것입니다. 축은 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">그라디언트는 경계에서 N 차의 정확한 차를 사용하여 계산됩니다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="f8982c84d1a3d63e1d8553471af2f5475b02499f" translate="yes" xml:space="preserve">
          <source>Grammatical issues inadequately addressed by the NumPy or Google rules are decided by the section on &amp;ldquo;Grammar and Usage&amp;rdquo; in the most recent edition of the &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Chicago_Manual_of_Style&quot;&gt;Chicago Manual of Style&lt;/a&gt;.</source>
          <target state="translated">NumPy 또는 Google 규칙에 의해 부적절하게 해결 된 문법 문제는 &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Chicago_Manual_of_Style&quot;&gt;Chicago Manual of Style&lt;/a&gt; 최신판의 &quot;문법 및 사용법&quot;섹션에 의해 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 매개 변수 의 그래픽 그림 :</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">그래픽 일러스트 :</target>
        </trans-unit>
        <trans-unit id="4a52fe6ab66ec52ee6bfd51d48518f7de2e194f9" translate="yes" xml:space="preserve">
          <source>Greater consistency in &lt;code&gt;assert_almost_equal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;assert_almost_equal&lt;/code&gt; 의 일관성 향상</target>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (빠른 최적 경로 근사치) : ~ 160ms</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">N- 차원으로 균일 한 간격의 숫자로 이루어진 격자 모양의 배열.</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">그룹 1</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">그룹 2</target>
        </trans-unit>
        <trans-unit id="843698a0f4f972fb83c7b6d5ba379d852811fab9" translate="yes" xml:space="preserve">
          <source>Groups and Policies</source>
          <target state="translated">그룹 및 정책</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">ufuncs / setitem / casting code에 대한 안전한 정렬 된 액세스 보장</target>
        </trans-unit>
        <trans-unit id="f454c80c182290ac641c3ab02a9edcdbe149e617" translate="yes" xml:space="preserve">
          <source>Guide to writing Tutorials (TODO)</source>
          <target state="translated">튜토리얼 작성 가이드 (TODO)</target>
        </trans-unit>
        <trans-unit id="7d49ac2fe6a93b218baff7cae5e0e60393e7661a" translate="yes" xml:space="preserve">
          <source>Guide to writing reference (API) documentation: the numpydoc docstring guide</source>
          <target state="translated">참조 (API) 문서 작성 가이드 : numpydoc 독 스트링 가이드</target>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">Gumbel, EJ,&amp;ldquo;극단 통계&amp;rdquo;, 뉴욕 : Columbia University Press, 1958.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="a23a715b33c5262fe3d1b937504a94f4b675a4b6" translate="yes" xml:space="preserve">
          <source>H() (numpy.matrix property)</source>
          <target state="translated">H () (numpy.matrix 속성)</target>
        </trans-unit>
        <trans-unit id="b40b37f0341f572e1998e910b25532a92af5b558" translate="yes" xml:space="preserve">
          <source>Hack away! See &lt;a href=&quot;#editing-workflow&quot;&gt;below&lt;/a&gt;</source>
          <target state="translated">해킹하세요! 참조 &lt;a href=&quot;#editing-workflow&quot;&gt;아래&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3ecd57d6fb3350fcd694b91496d526594622dbb6" translate="yes" xml:space="preserve">
          <source>Half precision float: sign bit, 5 bits exponent, 10 bits mantissa</source>
          <target state="translated">반 정밀도 부동 : 부호 비트, 지수 5 비트, 가수 10 비트</target>
        </trans-unit>
        <trans-unit id="297ad7f2c6ead81564e94efe3061b8f926b4dea8" translate="yes" xml:space="preserve">
          <source>Half-precision floating-point number type.</source>
          <target state="translated">반 정밀도 부동 소수점 숫자 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">반 정밀도 함수</target>
        </trans-unit>
        <trans-unit id="188b61888bd344a019188c5ddd9af8e491599b6a" translate="yes" xml:space="preserve">
          <source>Hand-generated wrappers</source>
          <target state="translated">손으로 만든 래퍼</target>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; 에&lt;/a&gt; 의해 처리</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">복소수 처리</target>
        </trans-unit>
        <trans-unit id="0294f5e8c997832af6154aa5a34d3bc487dacc89" translate="yes" xml:space="preserve">
          <source>Handling of higher-dimensional arrays (ndim &amp;gt; 2)</source>
          <target state="translated">고차원 배열 처리 (ndim&amp;gt; 2)</target>
        </trans-unit>
        <trans-unit id="29536b0ea00b813744dd07cc20d7e2d652df9775" translate="yes" xml:space="preserve">
          <source>Handling of vectors (one-dimensional arrays)</source>
          <target state="translated">벡터 처리 (1 차원 배열)</target>
        </trans-unit>
        <trans-unit id="e090b4f7922057771e37447008f952ba8b43192c" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;axis&lt;/code&gt; parameter</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 매개 변수 처리</target>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 처리</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">마스크 취급</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">하드 코딩 된 치수, 데이터 버퍼-치수-치수 사양 및 크기-그린-데이터-버퍼 규격.</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">마스크의 경도</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">효과가 없으며 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 와 모양이 같습니다 . &lt;code&gt;element[isin]&lt;/code&gt; 값 은 &lt;code&gt;test_elements&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d794659e95706af6481a92a9285f876ae1c7d63" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; install help pages available from &lt;a href=&quot;https://help.github.com&quot;&gt;github help&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://help.github.com&quot;&gt;github 도움말&lt;/a&gt; 에서 사용할 수 있는 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 설치 도움말 페이지를 살펴보십시오.</target>
        </trans-unit>
        <trans-unit id="2ab4d88ad951423d45baeab75192e5801e748751" translate="yes" xml:space="preserve">
          <source>Have a shared library.</source>
          <target state="translated">공유 라이브러리가 있습니다.</target>
        </trans-unit>
        <trans-unit id="d944005e31393bd466d7655b38df2b420878ca75" translate="yes" xml:space="preserve">
          <source>Having a shared library</source>
          <target state="translated">공유 라이브러리 보유</target>
        </trans-unit>
        <trans-unit id="f62bdff9b904bdda1a1ed9ed602657769f3345fd" translate="yes" xml:space="preserve">
          <source>Having compiled code also means that importing NumPy from the development sources needs some additional steps, which are explained below. For the rest of this chapter we assume that you have set up your git repo as described in &lt;a href=&quot;gitwash/index#using-git&quot;&gt;Git for development&lt;/a&gt;.</source>
          <target state="translated">코드를 컴파일했다는 것은 개발 소스에서 NumPy를 가져 오려면 아래에 설명 된 몇 가지 추가 단계가 필요함을 의미합니다. 이 장의 나머지 부분에서는 &lt;a href=&quot;gitwash/index#using-git&quot;&gt;개발 용 Git에&lt;/a&gt; 설명 된대로 git 저장소를 설정했다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Heckert, NA 및 Filliben, James J.&amp;ldquo;NIST 핸드북 148 : 데이터 플롯 참조 매뉴얼, 제 2 권 : 부속 명령 및 라이브러리 기능 사용&amp;rdquo;, 2003 년 6 월 National Institute of Standards and Technology Handbook Series, &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https : //www.itl.nist. gov / div898 / software / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f25b2d1977ec1a7cc15a3fe3ee364cef6feeebb6" translate="yes" xml:space="preserve">
          <source>Help increase engagement in good discussion practice: try to identify where discussion may have broken down and provide actionable information, pointers and resources that can lead to positive change on these points.</source>
          <target state="translated">좋은 토론 관행에 대한 참여도를 높이는 데 도움이됩니다. 토론이 중단되었을 수있는 부분을 식별하고 이러한 점에 대해 긍정적 인 변화로 이어질 수있는 실행 가능한 정보, 지침 및 리소스를 제공하십시오.</target>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">피클 도우미.</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">도우미 루틴</target>
        </trans-unit>
        <trans-unit id="591b0ee67a75bdd05c2441f5d821e72ac5abd9ff" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; may also contain signature files. Among other options (see below), the following options can be used in this mode:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 에는 서명 파일도 포함될 수 있습니다. 다른 옵션 (아래 참조) 중에서이 모드에서 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4ad119f3969c50ae36c69dfd7a8f2258a296a9e4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; is a one-dimensional array of length two whose datatype is a structure with three fields: 1. A string of length 10 or less named &amp;lsquo;name&amp;rsquo;, 2. a 32-bit integer named &amp;lsquo;age&amp;rsquo;, and 3. a 32-bit float named &amp;lsquo;weight&amp;rsquo;.</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 길이 2의 1 차원 배열이며 데이터 유형은 3 개의 필드가있는 구조입니다. 1. 'name'이라는 이름의 길이가 10 이하인 문자열, 2. 'age'라는 이름의 32 비트 정수 및 3. a 'weight'라는 32 비트 부동 소수점.</target>
        </trans-unit>
        <trans-unit id="05d939cfc36f7e101c6969543d3aa4fc112af1c5" translate="yes" xml:space="preserve">
          <source>Here appropriately means at least two tabs. It isn&amp;rsquo;t necessary to line everything up with the opening parenthesis of the function call.</source>
          <target state="translated">여기에서 적절하게 적어도 두 개의 탭을 의미합니다. 함수 호출의 여는 괄호로 모든 것을 정렬 할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="41762c3a1457e94bd62a7f7522c1df055434f548" translate="yes" xml:space="preserve">
          <source>Here are examples of shapes that do not broadcast:</source>
          <target state="translated">다음은 브로드 캐스트하지 않는 셰이프의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">다음은 사용자 정의 주 마스크 값의 몇 가지 예입니다. 이 예에서는 월요일부터 금요일까지의 &quot;버스 데이&quot;기본값을 유효한 날짜로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">서명의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7c80754b6ccbe7d6353c18ee79360b34170e3a5" translate="yes" xml:space="preserve">
          <source>Here are some more examples:</source>
          <target state="translated">다음은 몇 가지 예입니다.</target>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">날짜 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcedd65241f400ab6b9cead2ae708d4ee0595afe" translate="yes" xml:space="preserve">
          <source>Here brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional part, dots &lt;code&gt;...&lt;/code&gt; indicate one or more of a previous part. So, &lt;code&gt;[]...&lt;/code&gt; reads zero or more of a previous part.</source>
          <target state="translated">여기에서 대괄호 &lt;code&gt;[]&lt;/code&gt; 는 선택적 부분을 나타내고 점 &lt;code&gt;...&lt;/code&gt; 은 하나 이상의 이전 부분을 나타냅니다. 따라서 &lt;code&gt;[]...&lt;/code&gt; 는 0 개 이상의 이전 부분을 읽습니다.</target>
        </trans-unit>
        <trans-unit id="9a598f6524593a5ce80868abd4ad9058d26e6370" translate="yes" xml:space="preserve">
          <source>Here is a class that takes a standard ndarray that already exists, casts as our type, and adds an extra attribute.</source>
          <target state="translated">다음은 이미 존재하는 표준 ndarray를 가져 와서 우리 유형으로 캐스트하고 추가 속성을 추가하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">새 반복자와 함께 사용할 함수에 대한 변환 표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae703a87217d209b99ae68f8790ce06f1f882b70" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful NumPy functions and methods names ordered in categories. See &lt;a href=&quot;../reference/routines#routines&quot;&gt;Routines&lt;/a&gt; for the full list.</source>
          <target state="translated">다음은 몇 가지 유용한 NumPy 함수 및 메서드 이름을 범주로 정렬 한 목록입니다. 전체 목록 은 &lt;a href=&quot;../reference/routines#routines&quot;&gt;루틴&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c2fbbb0f1468c183a40201806e4aca9dcb3c7060" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">다음은 반복자를 사용하는 간단한 복사 기능입니다. &lt;code&gt;order&lt;/code&gt; 파라미터가 할당 결과의 메모리 레이아웃을 제어하는 데 사용되는 통상적 &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 가&lt;/a&gt; 바람직하다.</target>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">반복자를 사용하는 간단한 복사 기능은 다음과 같습니다. &lt;code&gt;order&lt;/code&gt; 파라미터가 할당 결과의 메모리 레이아웃을 제어하는 데 사용되는 통상적 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 가&lt;/a&gt; 바람직하다.</target>
        </trans-unit>
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">비 연속적 뷰 대신 연속적인 사본을 얻는 데 유용한 관용구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">다음은 &quot;lambda&quot;ufunc처럼 작동하는 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">외부 제품 기능의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">위의 변수를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">샘플 배열과 함께 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">파이썬 반복자 프로토콜을 사용하여 &lt;code&gt;iter_add&lt;/code&gt; 함수를 작성하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="82ebceae19f8e179d652196db8007bed9b016e84" translate="yes" xml:space="preserve">
          <source>Here is part of a Cython module named &lt;code&gt;add.pyx&lt;/code&gt; which implements the complex addition functions we previously implemented using f2py:</source>
          <target state="translated">다음은 이전에 f2py를 사용하여 구현 한 복잡한 추가 기능을 구현하는 &lt;code&gt;add.pyx&lt;/code&gt; 라는 Cython 모듈의 일부입니다 .</target>
        </trans-unit>
        <trans-unit id="f27fb417254a59c4a73469e0d501f40b87bdc16a" translate="yes" xml:space="preserve">
          <source>Here is shown a modified version of the previous Fortran code, save it as &lt;code&gt;fib3.f&lt;/code&gt;:</source>
          <target state="translated">다음은 이전 Fortran 코드의 수정 된 버전입니다. &lt;code&gt;fib3.f&lt;/code&gt; 로 저장합니다 .</target>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">다음은 동일한 기능이지만 C 스타일 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d4daff3ad7f47434c82a5051360f6f8f9147bcdd" translate="yes" xml:space="preserve">
          <source>Here the 4th and 5th rows are selected from the indexed array and combined to make a 2-D array.</source>
          <target state="translated">여기서 4 번째와 5 번째 행은 인덱스 배열에서 선택되고 결합되어 2D 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="879104127602f2f170c22fa52acd13e1c1a2bd91" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;newaxis&lt;/code&gt; index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional &lt;code&gt;4x1&lt;/code&gt; array. Combining the &lt;code&gt;4x1&lt;/code&gt; array with &lt;code&gt;b&lt;/code&gt;, which has shape &lt;code&gt;(3,)&lt;/code&gt;, yields a &lt;code&gt;4x3&lt;/code&gt; array.</source>
          <target state="translated">여기 &lt;code&gt;newaxis&lt;/code&gt; 의 지수 연산자에 새로운 축을 삽입 이를 이차원 제작 &lt;code&gt;4x1&lt;/code&gt; 어레이. 모양이 &lt;code&gt;(3,)&lt;/code&gt; 인 &lt;code&gt;b&lt;/code&gt; 와 &lt;code&gt;4x1&lt;/code&gt; 배열을 결합하면 &lt;code&gt;4x3&lt;/code&gt; 배열이 생성 됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="386e95414daee162c67ba2f23612c05957e9c9fa" translate="yes" xml:space="preserve">
          <source>Here the newaxis index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional 4x1 array. &lt;a href=&quot;#figure-4&quot;&gt;Figure 4&lt;/a&gt; illustrates the stretching of both arrays to produce the desired 4x3 output array.</source>
          <target state="translated">여기 newaxis 지수 연산자에 새로운 축을 삽입 이를 이차원의 4x1 어레이 제작. &lt;a href=&quot;#figure-4&quot;&gt;그림 4&lt;/a&gt; 는 원하는 4x3 출력 어레이를 생성하기 위해 두 어레이의 확장을 보여줍니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="948564e37f936b7d719e03a725d3b08432712a65" translate="yes" xml:space="preserve">
          <source>Here we give a list of short and useful tips.</source>
          <target state="translated">여기에 짧고 유용한 팁 목록이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e461e985122b46693ef966cb6f20d16d3ced03f1" translate="yes" xml:space="preserve">
          <source>Here we specify a seed so that we have reproducible results:</source>
          <target state="translated">재현 가능한 결과를 얻을 수 있도록 시드를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="cb190a2b97f5232f09df36f69c4083c62f9d6c52" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; to create an instance of &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to generate 3 random integers between 0 (inclusive) and 10 (exclusive):</source>
          <target state="translated">여기서 &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt; &lt;code&gt;default_rng&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 인스턴스를 생성하여 0 (포함)과 10 (배타적) 사이의 임의의 정수 3 개를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a08cc7d7c18f3c3475f96b8b3d6b43f3958b42f1" translate="yes" xml:space="preserve">
          <source>Here we use &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; to create an instance of &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; to generate a random float:</source>
          <target state="translated">여기서 &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt; &lt;code&gt;default_rng&lt;/code&gt; &lt;/a&gt; 를 사용하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 인스턴스 를 생성하여 임의의 부동 소수점을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a3c11b66e685970faed2b0dab8dcc9874e6f710a" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;default_rng&lt;/code&gt; to generate 3 random integers between 0 (inclusive) and 10 (exclusive):</source>
          <target state="translated">여기서 &lt;code&gt;default_rng&lt;/code&gt; 를 사용 하여 0 (포함)과 10 (배타적) 사이의 임의의 정수 3 개를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="8d3f8866347f301a5bb87019f0f0d018be7f046c" translate="yes" xml:space="preserve">
          <source>Here we use &lt;code&gt;default_rng&lt;/code&gt; to generate a random float:</source>
          <target state="translated">여기서 &lt;code&gt;default_rng&lt;/code&gt; 를 사용하여 임의의 부동 소수점을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">sum_squares.pyx의 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f05498cc571c5e0811d261874316f4fcd69c560" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the short summary, complete TOC links are below:</source>
          <target state="translated">다음은 짧은 요약이며 전체 TOC 링크는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="30babd25e27e87a901a32627496afe119a238cc9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; is a dictionary mapping keys to values, in this case the integer 1 to the string &amp;ldquo;one&amp;rdquo;, and the string &amp;ldquo;two&amp;rdquo; to the list &lt;code&gt;[1, 2]&lt;/code&gt;. The values may be accessed using their corresponding keys:</source>
          <target state="translated">여기서 &lt;code&gt;x&lt;/code&gt; 는 키를 값에 매핑하는 사전입니다.이 경우 정수 1은 문자열 &quot;one&quot;에, 문자열 &quot;two&quot;는 목록 &lt;code&gt;[1, 2]&lt;/code&gt; 됩니다. 값은 해당 키를 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">여기서는 내장 열거 반복자를 사용하여 반복 색인과 값을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">여기서 U는 (0,1]에 대한 균일 분포에서 도출됩니다.</target>
        </trans-unit>
        <trans-unit id="b81e3c833ac1c20cf33999c717a7683fc509fd53" translate="yes" xml:space="preserve">
          <source>Here, you grabbed a section of your array from index position 3 through index position 8.</source>
          <target state="translated">여기에서 인덱스 위치 3에서 인덱스 위치 8까지 배열의 섹션을 가져 왔습니다.</target>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="3e97b960fb6669c7ce3d868bc1ee39fbd840fc5f" translate="yes" xml:space="preserve">
          <source>Hermite (class in numpy.polynomial.hermite)</source>
          <target state="translated">Hermite (numpy.polynomial.hermite의 클래스)</target>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">은자 반</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; 모듈, &quot;물리학 자&quot;( numpy.polynomial.hermite )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">은자 모듈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">은자 모듈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="7e732e7a329c7f9da3eef2d091dd68d62fa1ae1a" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">Hermite 시리즈,&amp;ldquo;물리학 자&amp;rdquo;( &lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d4d4eab91a42ee672e761807e2ccfac51f95da47" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">Hermite 시리즈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 은자 계수 는 &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">은자 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">은자 시리즈</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">적분의 은자 (Hermite) 계열 계수.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">은자 시리즈의 힘.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">파생 품의 은자 시리즈.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 Hermite 시리즈.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">은둔 무게 기능</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="213b3add1699deb17fd0362b28ee9eaa1e08297e" translate="yes" xml:space="preserve">
          <source>HermiteE (class in numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE (numpy.polynomial.hermite_e의 클래스)</target>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">은자 클래스</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">HermiteE 모듈,&amp;ldquo;Probabilists&amp;rdquo;( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="a7da5893b105551d489e12a654065cc1aa5b0de0" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">HermiteE 시리즈,&amp;ldquo;Probabilists&amp;rdquo;( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="01652b3974c2bf789bf8511d4ddd036a45eab615" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 시리즈,&amp;ldquo;Probabilists&amp;rdquo;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 HermiteE 계수 는 &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">HermiteE 시리즈</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">은자 무게 기능.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">적분의 Hermite_e 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Hermitian (모든 요소가 실제 인 경우 대칭), 양의 한정된 입력 행렬.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">은둔자 FFT</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">고유 값과 고유 벡터를 계산할 수있는 은자 또는 실수 대칭 행렬.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">고차 다항식이 크게 진동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">더 큰 치수</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
