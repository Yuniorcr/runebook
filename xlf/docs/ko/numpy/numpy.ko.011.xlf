<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="55427a60a4bc7584f941291fc8f1c78e3b48892c" translate="yes" xml:space="preserve">
          <source>Fourteen C macros and fifteen C functions that can be used to write specialized typemaps, extensions, or inlined functions that handle cases not covered by the provided typemaps. Note that the macros and functions are coded specifically to work with the NumPy C/API regardless of NumPy version number, both before and after the deprecation of some aspects of the API after version 1.6.</source>
          <target state="translated">제공된 유형 맵에 포함되지 않은 사례를 처리하는 특수 유형 맵, 확장 또는 인라인 된 함수를 작성하는 데 사용할 수있는 14 개의 C 매크로 및 15 개의 C 함수 매크로 및 함수는 버전 1.6 이후 API의 일부 측면이 더 이상 사용되지 않기 전후에 NumPy 버전 번호에 관계없이 NumPy C / API와 함께 작동하도록 특별히 코딩되었습니다.</target>
        </trans-unit>
        <trans-unit id="a55119325a9e50ab95a500e00074b97b1b9e36d5" translate="yes" xml:space="preserve">
          <source>Fractional part of &lt;code&gt;x&lt;/code&gt;. This is a scalar if &lt;code&gt;x&lt;/code&gt; is a scalar.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 분수 부분 . &lt;code&gt;x&lt;/code&gt; 가 스칼라 인 경우 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="3ef0af518168c89e00d0d671000eff79ef6d0866" translate="yes" xml:space="preserve">
          <source>Francis Hunt and Paul Johnson, On the Pareto Distribution of Sourceforge projects.</source>
          <target state="translated">Sourceforge 프로젝트의 파레토 배포에 관한 Francis Hunt와 Paul Johnson.</target>
        </trans-unit>
        <trans-unit id="1702d7b8bdd07fbea0c5cab99e1759e69160609f" translate="yes" xml:space="preserve">
          <source>Frequency bins for given FFT parameters.</source>
          <target state="translated">주어진 FFT 매개 변수에 대한 주파수 구간.</target>
        </trans-unit>
        <trans-unit id="8c7beab7a6d84d3a1004bcc75ccd72648a4866a0" translate="yes" xml:space="preserve">
          <source>Frobenius norm</source>
          <target state="translated">프로 베니 우스 표준</target>
        </trans-unit>
        <trans-unit id="b496ebf456418bea6f72b4dd532369d14b955f9b" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r755c9bae090e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeadfde385f544a91cc8eaeeffa0c5ba93e6dc7d" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r89f5270d198b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb8d23120bc74b1cfb060aa5332c0996e661cf6" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard page 83에서 &lt;a href=&quot;#r9f872b3c913b-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , 킬로 줄 (kJ)의 여성 11 명의 일일 에너지 섭취량은 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="449b24b6007276ad9bb465db2968bb8f2f82cb23" translate="yes" xml:space="preserve">
          <source>From Dalgaard page 83 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt;, suppose the daily energy intake for 11 women in kilojoules (kJ) is:</source>
          <target state="translated">Dalgaard page 83에서 &lt;a href=&quot;#rb7c952f3992e-1&quot; id=&quot;id3&quot;&gt;[1]&lt;/a&gt; , 킬로 줄 (kJ)의 여성 11 명의 일일 에너지 섭취량은 다음과 같다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="e91799328361ed7f1f3c997458139cffb3209540" translate="yes" xml:space="preserve">
          <source>From a 4x3 array the corner elements should be selected using advanced indexing. Thus all elements for which the column is one of &lt;code&gt;[0, 2]&lt;/code&gt; and the row is one of &lt;code&gt;[0, 3]&lt;/code&gt; need to be selected. To use advanced indexing one needs to select all elements &lt;em&gt;explicitly&lt;/em&gt;. Using the method explained previously one could write:</source>
          <target state="translated">4x3 배열에서 고급 인덱싱을 사용하여 모서리 요소를 선택해야합니다. 따라서 열이 &lt;code&gt;[0, 2]&lt;/code&gt; 중 하나이고 행이 &lt;code&gt;[0, 3]&lt;/code&gt; 중 하나 인 모든 요소를 선택해야합니다. 고급 인덱싱을 사용하려면 모든 요소를 &lt;em&gt;명시 적으로&lt;/em&gt; 선택해야합니다 . 앞에서 설명한 방법을 사용하면 다음과 같이 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a91be0fd97aa12da8097d28986c00ba2a4f3a53c" translate="yes" xml:space="preserve">
          <source>From a Fortran routine signature F2PY generates a Python/C extension function that has the following signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f43663857b3b074086e6a5458d7eeb8cc710716c" translate="yes" xml:space="preserve">
          <source>From a date and time:</source>
          <target state="translated">날짜와 시간에서 :</target>
        </trans-unit>
        <trans-unit id="b27ac815b804369e0e908095a8f60fb839b9ffbc" translate="yes" xml:space="preserve">
          <source>From an array, select all rows which sum up to less or equal two:</source>
          <target state="translated">배열에서 합계가 2보다 작거나 같은 모든 행을 선택하십시오.</target>
        </trans-unit>
        <trans-unit id="0b1e37af40ab4883a1e4a8a3dc83bcc94bb649dc" translate="yes" xml:space="preserve">
          <source>From each row, a specific element should be selected. The row index is just &lt;code&gt;[0, 1, 2]&lt;/code&gt; and the column index specifies the element to choose for the corresponding row, here &lt;code&gt;[0, 1, 0]&lt;/code&gt;. Using both together the task can be solved using advanced indexing:</source>
          <target state="translated">각 행에서 특정 요소를 선택해야합니다. 행 인덱스는 단지 &lt;code&gt;[0, 1, 2]&lt;/code&gt; 이며 열 인덱스는 해당 행에 대해 선택할 요소를 지정합니다 (여기서는 &lt;code&gt;[0, 1, 0]&lt;/code&gt; . 두 가지를 함께 사용하면 고급 인덱싱을 사용하여 작업을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2bdc929241ee7611d7ce8654d5c0e7a97c5922e2" translate="yes" xml:space="preserve">
          <source>From existing data</source>
          <target state="translated">기존 데이터에서</target>
        </trans-unit>
        <trans-unit id="1978da17047230ecfb709900d093fe2bc00bb2a8" translate="yes" xml:space="preserve">
          <source>From now on &lt;a href=&quot;https://git-scm.com/&quot;&gt;git&lt;/a&gt; will know that &lt;code&gt;my-new-feature&lt;/code&gt; is related to the &lt;code&gt;my-new-feature&lt;/code&gt; branch in your own &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; repo. Subsequent push calls are then simplified to the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d7dc9b3626b3cb541c458a7c7758c637090adb4" translate="yes" xml:space="preserve">
          <source>From other objects</source>
          <target state="translated">다른 물체에서</target>
        </trans-unit>
        <trans-unit id="5dce71950093c2ccd6198a0075dc3e5ee84cb7ec" translate="yes" xml:space="preserve">
          <source>From scratch</source>
          <target state="translated">기스로부터</target>
        </trans-unit>
        <trans-unit id="374969a1bf6cf09ab316c531b85ee98729ec817d" translate="yes" xml:space="preserve">
          <source>From the command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8689c1f53f242e3e2ed351ba13d4443b972a335" translate="yes" xml:space="preserve">
          <source>From the output above, we can see that every value in &lt;code&gt;img[:,:,0]&lt;/code&gt; is an integer value between 0 and 255, representing the level of red in each corresponding image pixel (keep in mind that this might be different if you use your own image instead of &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.misc.face.html#scipy.misc.face&quot;&gt;&lt;code&gt;scipy.misc.face&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="487083148a4854e5ec264b4e7603e6d383b8513e" translate="yes" xml:space="preserve">
          <source>From time to time you may want to pull down the latest code. Do this with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541d68d9d4a26a74b3b1aec38602641c99c42b4f" translate="yes" xml:space="preserve">
          <source>Full broadcasting support for &lt;code&gt;np.cross&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6cd09bf0f40761ab28ccaa4cab2a4c6c336752" translate="yes" xml:space="preserve">
          <source>Full indirect sort</source>
          <target state="translated">완전 간접 정렬</target>
        </trans-unit>
        <trans-unit id="b5dd204ac7b63984bfca215999235cdddc1cbe34" translate="yes" xml:space="preserve">
          <source>Full indirect sort.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d106cfe968d6ee1cdc60bee01550735688b85f7" translate="yes" xml:space="preserve">
          <source>Full sort.</source>
          <target state="translated">완전한 종류.</target>
        </trans-unit>
        <trans-unit id="733bce60654becd4d4e1700d743ab7573d5f2742" translate="yes" xml:space="preserve">
          <source>Full sorting</source>
          <target state="translated">전체 정렬</target>
        </trans-unit>
        <trans-unit id="b375e36a5e2c847719599e1c9bc607f532495b26" translate="yes" xml:space="preserve">
          <source>Function &lt;code&gt;median&lt;/code&gt; used with &lt;code&gt;overwrite_input&lt;/code&gt; only partially sorts array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b35686e8529228454146ad9f9eb6c40fa0abbf7c" translate="yes" xml:space="preserve">
          <source>Function and macro call style: &lt;code&gt;foo(a, b, c)&lt;/code&gt;, no space before the open paren, no spaces inside the parens, no spaces before commas, one space after each comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f14045db7fd843c69383648cf94f75fb3d176a15" translate="yes" xml:space="preserve">
          <source>Function call</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="5fafc2ca93d61a962accac1563a05d9b48e0a23a" translate="yes" xml:space="preserve">
          <source>Function decorator to apply certain suppressions to a whole function.</source>
          <target state="translated">전체 기능에 특정 억제를 적용하는 함수 데코레이터.</target>
        </trans-unit>
        <trans-unit id="1ace8a404ff1b1cae179e78198d969ee763553f5" translate="yes" xml:space="preserve">
          <source>Function definition style: function name in column 1, outermost curly braces in column 1, blank line after local variable declarations:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf873f24ebe960e5f8ab96d1bf1dafec8236126" translate="yes" xml:space="preserve">
          <source>Function documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6611eada8817f5f656a38dbcf1f891cb71be30b3" translate="yes" xml:space="preserve">
          <source>Function operating on ndarrays.</source>
          <target state="translated">ndarray에서 작동하는 기능.</target>
        </trans-unit>
        <trans-unit id="7fb4f2de4dfb1639014358c3b7015d9c6a5f5d6b" translate="yes" xml:space="preserve">
          <source>Function pointer from &lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt;&lt;code&gt;NpyIter_GetIterNext&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_GetIterNext&quot;&gt; &lt;code&gt;NpyIter_GetIterNext&lt;/code&gt; 의&lt;/a&gt; 함수 포인터</target>
        </trans-unit>
        <trans-unit id="636b3b392dcabee45d972282bc714f124a2984ee" translate="yes" xml:space="preserve">
          <source>Function that converts a float array to float. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;. Note that this does not seem to do anything useful in the current implementation.</source>
          <target state="translated">float 배열을 float로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 입니다. 이것은 현재 구현에 유용한 것으로 보이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="25f491198ced438a979dee0c06f7b99f4c27522c" translate="yes" xml:space="preserve">
          <source>Function that converts a float or float array to an integer or integer array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">float 또는 float 배열을 정수 또는 정수 배열로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="c1c65cb38bc5533518bfad836c738613691b12bd" translate="yes" xml:space="preserve">
          <source>Function that converts a single float to a string. Default is &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt;.</source>
          <target state="translated">단일 float를 문자열로 변환하는 함수입니다. 기본값은 &lt;code&gt;lambda v:'%24.16e' %v&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="49e035248ad61f94c49b3411ced40a15d03e994b" translate="yes" xml:space="preserve">
          <source>Function that converts an integer or integer array to a float or float array. Default is &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">정수 또는 정수 배열을 부동 또는 부동 배열로 변환하는 함수입니다. 기본값은 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="81aebc7824dc558f5740b2294a8d328bfb265c12" translate="yes" xml:space="preserve">
          <source>Function to apply on the &amp;ldquo;field&amp;rdquo; dimension. This function must support an &lt;code&gt;axis&lt;/code&gt; argument, like np.mean, np.sum, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cdbff65d2dcd6dbb1f176839d343d5cd6740b77" translate="yes" xml:space="preserve">
          <source>Function to be used to pretty print arrays. The function should expect a single array argument and return a string of the representation of the array. If None, the function is reset to the default NumPy function to print arrays.</source>
          <target state="translated">배열을 예쁘게 인쇄하는 데 사용되는 기능입니다. 함수는 단일 배열 인수를 예상하고 배열 표현의 문자열을 리턴해야합니다. None 인 경우, 기능은 기본 NumPy 기능으로 재설정되어 배열을 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="2e5428e59d421faf071ea47a590fb561ece5a39d" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 기능에서 사용되는 빈의 가장자리 만 계산하는 기능.</target>
        </trans-unit>
        <trans-unit id="ecfa9e590ef0d3ed65da85a7cdda1af66b824ea3" translate="yes" xml:space="preserve">
          <source>Function to calculate only the edges of the bins used by the &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">&lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 기능에서 사용되는 빈의 가장자리 만 계산하는 기능.</target>
        </trans-unit>
        <trans-unit id="3daae79264ded053c68caf5a77aad1db49558306" translate="yes" xml:space="preserve">
          <source>Function to call upon floating-point errors (&amp;lsquo;call&amp;rsquo;-mode) or object whose &amp;lsquo;write&amp;rsquo; method is used to log such message (&amp;lsquo;log&amp;rsquo;-mode).</source>
          <target state="translated">부동 소수점 오류 ( 'call'-mode) 또는'write '메소드가 이러한 메시지를 기록하는 데 사용되는 객체 ('log'-mode)에 대해 호출하는 함수입니다.</target>
        </trans-unit>
        <trans-unit id="936e3c682ce34cc0f0f7b3b6776919fc933d5fe1" translate="yes" xml:space="preserve">
          <source>Function which returns a masked inner loop for the ufunc</source>
          <target state="translated">ufunc에 대한 마스크 된 내부 루프를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="deb4e042b9d6249db97e6680ab8276b237985bd9" translate="yes" xml:space="preserve">
          <source>Functional programming</source>
          <target state="translated">기능적 프로그래밍</target>
        </trans-unit>
        <trans-unit id="2b961dea1dc0c60ddf9a2c8e9d090f6f7d082483" translate="yes" xml:space="preserve">
          <source>Functions</source>
          <target state="translated">Functions</target>
        </trans-unit>
        <trans-unit id="5a31942f8f4b1c24c2cf2f6e11f8f96977c918a6" translate="yes" xml:space="preserve">
          <source>Functions For Iteration</source>
          <target state="translated">반복 함수</target>
        </trans-unit>
        <trans-unit id="c9d64db1884b2fd4f353a105874e4c3957322b65" translate="yes" xml:space="preserve">
          <source>Functions and Methods Overview</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6da2fb68f3db64f0a7a53228a8721f52f6134f" translate="yes" xml:space="preserve">
          <source>Functions available from numpy.ma.testutils have changed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7916ccc48b7ce0f25ff69e01c25e39ce11de03b" translate="yes" xml:space="preserve">
          <source>Functions implementing internal features. Not all of these function pointers must be defined for a given type. The required members are &lt;code&gt;nonzero&lt;/code&gt;, &lt;code&gt;copyswap&lt;/code&gt;, &lt;code&gt;copyswapn&lt;/code&gt;, &lt;code&gt;setitem&lt;/code&gt;, &lt;code&gt;getitem&lt;/code&gt;, and &lt;code&gt;cast&lt;/code&gt;. These are assumed to be non- &lt;code&gt;NULL&lt;/code&gt; and &lt;code&gt;NULL&lt;/code&gt; entries will cause a program crash. The other functions may be &lt;code&gt;NULL&lt;/code&gt; which will just mean reduced functionality for that data-type. (Also, the nonzero function will be filled in with a default function if it is &lt;code&gt;NULL&lt;/code&gt; when you register a user-defined data-type).</source>
          <target state="translated">내부 기능을 구현하는 기능. 이 함수 포인터를 모두 주어진 유형에 대해 정의해야하는 것은 아닙니다. 필수 멤버는 &lt;code&gt;nonzero&lt;/code&gt; 이 아닌 , &lt;code&gt;copyswap&lt;/code&gt; , &lt;code&gt;copyswapn&lt;/code&gt; , &lt;code&gt;setitem&lt;/code&gt; , &lt;code&gt;getitem&lt;/code&gt; 및 &lt;code&gt;cast&lt;/code&gt; 입니다. 이들은 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 것으로 가정 되며 &lt;code&gt;NULL&lt;/code&gt; 항목은 프로그램 충돌을 일으 킵니다. 다른 함수는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있으며, 이는 해당 데이터 유형의 기능이 축소되었음을 의미합니다. 또한 사용자 정의 데이터 유형을 등록 할 때 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 0이 아닌 함수는 기본 함수로 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="f48c175b4673c0bc456bc9f1ba654da2d9542a5c" translate="yes" xml:space="preserve">
          <source>Functions in &lt;code&gt;numpy.random&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="516c584b732d36ebda7d25fae38b326dc6d202ae" translate="yes" xml:space="preserve">
          <source>Functions in numpy.random</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c724fd9678ed45fd313d6c7db38a089943643ca5" translate="yes" xml:space="preserve">
          <source>Functions may be listed without descriptions, and this is preferable if the functionality is clear from the function name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="786d8b1defa125829799bc249caf1adda1184b6a" translate="yes" xml:space="preserve">
          <source>Functions returning an index along an axis, like &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt;&lt;code&gt;argsort&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt;&lt;code&gt;argpartition&lt;/code&gt;&lt;/a&gt;, produce suitable indices for this function.</source>
          <target state="translated">축을 따라 인덱스를 반환하는 함수 &lt;a href=&quot;numpy.argsort#numpy.argsort&quot;&gt; &lt;code&gt;argsort&lt;/code&gt; &lt;/a&gt; 및&lt;a href=&quot;numpy.argpartition#numpy.argpartition&quot;&gt; &lt;code&gt;argpartition&lt;/code&gt; &lt;/a&gt;함수는이 함수에 적합한 인덱스를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="7961218e053edec8b5fc62ef3005af10a3415803" translate="yes" xml:space="preserve">
          <source>Functions that are also in the numpy namespace and return matrices</source>
          <target state="translated">numpy 네임 스페이스에 있고 함수를 반환하는 함수</target>
        </trans-unit>
        <trans-unit id="95335a3a51e2f80868a95521fb5668b275263818" translate="yes" xml:space="preserve">
          <source>Functions that don&amp;rsquo;t accept keyword arguments should be written as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7888c5dcdff069b34a3486459892edd2f262c97" translate="yes" xml:space="preserve">
          <source>Functions with keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6020fb8e5272b3356bebe72ae19a144383754b4e" translate="yes" xml:space="preserve">
          <source>Functions without keyword arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dad1764839322eb03eab6b07936a589482f90c1" translate="yes" xml:space="preserve">
          <source>Fundraising</source>
          <target state="translated">Fundraising</target>
        </trans-unit>
        <trans-unit id="6da76886d65d87e4650f5c14ec791f8c2f676112" translate="yes" xml:space="preserve">
          <source>Further explanation of the &lt;code&gt;fmt&lt;/code&gt; parameter (&lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt;):</source>
          <target state="translated">에 대한 추가 설명 &lt;code&gt;fmt&lt;/code&gt; 매개 변수에 ( &lt;code&gt;%[flag]width[.precision]specifier&lt;/code&gt; ) :</target>
        </trans-unit>
        <trans-unit id="3abcbfb793b7e40f09b0f5479b45936952f0ec59" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;np.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7e1185b0b79852815db7f42a86a47fec5e9990" translate="yes" xml:space="preserve">
          <source>Further improvements to &lt;code&gt;ctypes&lt;/code&gt; support in &lt;code&gt;numpy.ctypeslib&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e44c8b638baa470dbb5f127964c092cc77ea465" translate="yes" xml:space="preserve">
          <source>Further reading</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fad9659f7e2980db9b405ad20b3c5294ccc96416" translate="yes" xml:space="preserve">
          <source>Further, note how &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are combined:</source>
          <target state="translated">또한 어떻게 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 결합 .</target>
        </trans-unit>
        <trans-unit id="9af0aaaf4de03972531671e0eb9bb87000ba4e1d" translate="yes" xml:space="preserve">
          <source>Furthermore, arrays created with this function often contain self overlapping memory, so that two elements are identical. Vectorized write operations on such arrays will typically be unpredictable. They may even give different results for small, large, or transposed arrays. Since writing to these arrays has to be tested and done with great care, you may want to use &lt;code&gt;writeable=False&lt;/code&gt; to avoid accidental write operations.</source>
          <target state="translated">또한이 함수로 생성 된 어레이에는 종종 자체 중복 메모리가 포함되므로 두 요소가 동일합니다. 이러한 어레이에서 벡터화 된 쓰기 작업은 일반적으로 예측할 수 없습니다. 작은 배열, 큰 배열 또는 바뀐 배열에 대해 다른 결과를 제공 할 수도 있습니다. 이러한 어레이에 대한 쓰기는 매우주의해서 테스트하고 수행해야하므로 우발적 인 쓰기 작업을 피하기 위해 &lt;code&gt;writeable=False&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="12143faa25aabfe7fe468016abec86297c6fcf15" translate="yes" xml:space="preserve">
          <source>Furthermore, numpy now provides a new function &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt; which is a safer and more efficient alternative for users who wish to convert structured arrays to unstructured arrays, as the view above is often indeded to do. This function allows safe conversion to an unstructured type taking into account padding, often avoids a copy, and also casts the datatypes as needed, unlike the view. Code such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f84a7ca85b2fada9bdf949e608abf006366bb0e" translate="yes" xml:space="preserve">
          <source>Furthermore, the callback function is of the same type as before, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt;. When invoked, &lt;code&gt;args&lt;/code&gt; is a list of length &lt;code&gt;nargs&lt;/code&gt; containing the data of all input/output arguments. For a scalar elementary function, &lt;code&gt;steps&lt;/code&gt; is also of length &lt;code&gt;nargs&lt;/code&gt;, denoting the strides used for the arguments. &lt;code&gt;dimensions&lt;/code&gt; is a pointer to a single integer defining the size of the axis to be looped over.</source>
          <target state="translated">또한 콜백 함수는 이전과 동일한 유형, &lt;code&gt;void (*foo)(char **args, intp *dimensions, intp *steps, void *func)&lt;/code&gt; 입니다. &lt;code&gt;args&lt;/code&gt; 는 호출 될 때 모든 입력 / 출력 인수의 데이터를 포함하는 길이 &lt;code&gt;nargs&lt;/code&gt; 의 목록입니다 . 스칼라 기본 함수의 경우 &lt;code&gt;steps&lt;/code&gt; 길이가 &lt;code&gt;nargs&lt;/code&gt; 는 인수에 사용 된 보폭을 나타내는 입니다. &lt;code&gt;dimensions&lt;/code&gt; 는 루프 될 축의 크기를 정의하는 단일 정수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="c462e5cfdac7c4df78636f70346d506c3e424749" translate="yes" xml:space="preserve">
          <source>Furthermore, using the &lt;code&gt;ndim&lt;/code&gt; property of this array, we can see that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22552b8bf29fce0c52d5fcd39548010b9e76338c" translate="yes" xml:space="preserve">
          <source>Future Changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acb0dc3b9f8b3f5bdca8fc1d87183e1bba912790" translate="yes" xml:space="preserve">
          <source>Future changes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7285e0cef5e4daf805eb913ea140d9a03dc8d07" translate="yes" xml:space="preserve">
          <source>Future value</source>
          <target state="translated">미래 가치</target>
        </trans-unit>
        <trans-unit id="0d44fa727f9b3f4d912a98a3e170b462f52557e6" translate="yes" xml:space="preserve">
          <source>Future value (default = 0)</source>
          <target state="translated">미래 가치 (기본 = 0)</target>
        </trans-unit>
        <trans-unit id="ba4092807d491bea64803fff0c7e477eac372847" translate="yes" xml:space="preserve">
          <source>Future values. If all input is scalar, returns a scalar float. If any input is array_like, returns future values for each input element. If multiple inputs are array_like, they all must have the same shape.</source>
          <target state="translated">미래 가치. 모든 입력 값이 스칼라이면 스칼라 부동 소수점을 반환합니다. 입력이 array_like 인 경우 각 입력 요소에 대한 미래 값을 리턴합니다. 여러 입력이 array_like 인 경우 모두 같은 모양이어야합니다.</target>
        </trans-unit>
        <trans-unit id="722af3dc654f5b03462276f1ddc84a2ecf2baa12" translate="yes" xml:space="preserve">
          <source>Future very uncertain: it&amp;rsquo;s the only part of Scipy not ported to Python 3 and is effectively deprecated in favor of Cython.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d739c24bbd3b77640efa7aa653675284eae750ca" translate="yes" xml:space="preserve">
          <source>FutureWarning to changed behavior</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6cee77152a751b028de81f7755bdc87bacc5925" translate="yes" xml:space="preserve">
          <source>FutureWarnings</source>
          <target state="translated">FutureWarnings</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="2f44d78e0bf8d58385fdcde50f5d5e7baff3d944" translate="yes" xml:space="preserve">
          <source>G. H. Golub and C. F. Van Loan, &lt;em&gt;Matrix Computations&lt;/em&gt;, Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</source>
          <target state="translated">GH Golub 및 CF Van Loan, &lt;em&gt;매트릭스 계산&lt;/em&gt; , Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</target>
        </trans-unit>
        <trans-unit id="cbd53064adb7ff38d27c336291f9eaba7270aacd" translate="yes" xml:space="preserve">
          <source>G. Strang, &amp;ldquo;Linear Algebra and Its Applications, 2nd Edition,&amp;rdquo; Academic Press, pg. 182, 1980.</source>
          <target state="translated">G. Strang,&amp;ldquo;선형 대수와 그 응용, 2 판&amp;rdquo;Academic Press, pg. 182, 1980.</target>
        </trans-unit>
        <trans-unit id="0fee945837fcad5efdf449e24366c4e1f7b65d37" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, Various pp.</source>
          <target state="translated">G. Strang, &lt;em&gt;선형 대수 및 그 응용&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, 다양한 pp.</target>
        </trans-unit>
        <trans-unit id="4d62050a6efa830b0646c86cf65d2a276c097206" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 22.</target>
        </trans-unit>
        <trans-unit id="8a5685424a4a906ee371dfacdea6a5b47dc7b3ff" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pg. 222.</target>
        </trans-unit>
        <trans-unit id="db937a0ed23b9cf712fadda8ce2d53e90fb3fb34" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, pp. 139-142.</source>
          <target state="translated">G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt; , 2nd Ed., Orlando, FL, Academic Press, Inc., 1980, 139-142 쪽.</target>
        </trans-unit>
        <trans-unit id="d923f5047de7db54bb0494345e02c3e60011f631" translate="yes" xml:space="preserve">
          <source>G. Strang, &lt;em&gt;Linear Algebra and Its Applications&lt;/em&gt;, Orlando, FL, Academic Press, Inc., 1980, pg. 285.</source>
          <target state="translated">G. Strang, &lt;em&gt;선형 대수 및 그 응용&lt;/em&gt; , Orlando, FL, Academic Press, Inc., 1980, pg. 285.</target>
        </trans-unit>
        <trans-unit id="2fe46435d8800606efbbb4738ea49577e004f01c" translate="yes" xml:space="preserve">
          <source>GUfuncs on empty arrays and NpyIter axis removal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a5e73fba8665db50a8e3577ecf8eb28b80e421" translate="yes" xml:space="preserve">
          <source>Gammas</source>
          <target state="translated">Gammas</target>
        </trans-unit>
        <trans-unit id="027498996e260dbd9c33778f3168019dfde3d4cc" translate="yes" xml:space="preserve">
          <source>Gauss-Chebyshev quadrature.</source>
          <target state="translated">가우스 체비 쇼프 구적법.</target>
        </trans-unit>
        <trans-unit id="372d4c8be97b59c2965354454eaf80e844e74e50" translate="yes" xml:space="preserve">
          <source>Gauss-Hermite quadrature.</source>
          <target state="translated">가우스-허 마이트 구적법.</target>
        </trans-unit>
        <trans-unit id="90aa100cf157ec594ce20f650ca9a1d9019f03be" translate="yes" xml:space="preserve">
          <source>Gauss-HermiteE quadrature.</source>
          <target state="translated">Gauss-HermiteE 구적법.</target>
        </trans-unit>
        <trans-unit id="9d10f081127b50e1f17e0a5c3971976017840cbe" translate="yes" xml:space="preserve">
          <source>Gauss-Laguerre quadrature.</source>
          <target state="translated">가우스-라게 레 구적법.</target>
        </trans-unit>
        <trans-unit id="88f1f37c698b12eaffdc9bbccbc77d8b6246ccd8" translate="yes" xml:space="preserve">
          <source>Gauss-Legendre quadrature.</source>
          <target state="translated">Gauss-Legendre 직교.</target>
        </trans-unit>
        <trans-unit id="9239ee2cda84eca4c3440e2a7b50148af67da3d4" translate="yes" xml:space="preserve">
          <source>General</source>
          <target state="translated">General</target>
        </trans-unit>
        <trans-unit id="0cffb2d4275e42dba57746961ea67052aaeef334" translate="yes" xml:space="preserve">
          <source>General Broadcasting Rules</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ff3c8e4686a4c021328dd784ede1cb72d7755f" translate="yes" xml:space="preserve">
          <source>General Purpose Equivalents</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d731fc16d10c539de3eb06ab7ca854e8f4dd60e" translate="yes" xml:space="preserve">
          <source>General check of Python Type</source>
          <target state="translated">파이썬 타입의 일반적인 점검</target>
        </trans-unit>
        <trans-unit id="1b31f308f2ce85a33700b95c3da21fcb018ed716" translate="yes" xml:space="preserve">
          <source>General purpose exception class, derived from Python&amp;rsquo;s exception.Exception class, programmatically raised in linalg functions when a Linear Algebra-related condition would prevent further correct execution of the function.</source>
          <target state="translated">파이썬의 예외에서 파생 된 범용 예외 클래스. 예외 클래스는 선형 대수 관련 조건이 함수의 올바른 실행을 방해 할 때 linalg 함수에서 프로그래밍 방식으로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6a5d5977ff7dabeb26104f13133251775857ac24" translate="yes" xml:space="preserve">
          <source>Generalised matrix product, using second last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;b&lt;/code&gt; 의 두 번째 마지막 차원을 사용하는 일반화 된 행렬 곱 .</target>
        </trans-unit>
        <trans-unit id="172636dd07a5cf344fc718f14e5f8bac9163a8d1" translate="yes" xml:space="preserve">
          <source>Generalized &lt;code&gt;flip&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d7eab60b5c5966c3521dbaae99dc8efbf97f6cb" translate="yes" xml:space="preserve">
          <source>Generalized Ufuncs will now unlock the GIL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9332c2d546d63dda92dba61cafe3df82f0dd8b19" translate="yes" xml:space="preserve">
          <source>Generalized Universal Function API</source>
          <target state="translated">일반화 된 범용 함수 API</target>
        </trans-unit>
        <trans-unit id="e299d19ac7292c1bf7156bae2d6dd21bd9fba291" translate="yes" xml:space="preserve">
          <source>Generalized axis support for median and percentile</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04b50941190dd87fa655dc29ac5df20dd7d7c66f" translate="yes" xml:space="preserve">
          <source>Generalized function class.</source>
          <target state="translated">일반화 된 함수 클래스.</target>
        </trans-unit>
        <trans-unit id="1a1bc0e8d9d246a721e301167a79c68d6cdef5b2" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow fixed-size dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2d28b03b171fb860aee83a82f532e58c4e9fba3" translate="yes" xml:space="preserve">
          <source>Generalized ufunc signatures now allow flexible dimensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0046ab62e86cdc207bdc51ed66f39ae439778565" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a042cdeb42f3ae672017ab4c672646772ccf00" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is &lt;code&gt;None&lt;/code&gt;, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="translated">일반화 된 ufunc는 많은 linalg 함수와 테스트 스위트에서 내부적으로 사용됩니다. 아래의 예는 이들에서 가져온 것입니다. 스칼라에서 작동하는 ufunc의 경우 서명은 &lt;code&gt;None&lt;/code&gt; 이며 모든 인수에 대해 '()'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="b0078c3e5a20e2fad81f2acb827abe758030ac9d" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs are used internally in many linalg functions, and in the testing suite; the examples below are taken from these. For ufuncs that operate on scalars, the signature is None, which is equivalent to &amp;lsquo;()&amp;rsquo; for every argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf9c0fe98002f4322da923b10684f6d5d099ff33" translate="yes" xml:space="preserve">
          <source>Generalized ufuncs now accept &lt;code&gt;axes&lt;/code&gt;, &lt;code&gt;axis&lt;/code&gt; and &lt;code&gt;keepdims&lt;/code&gt; arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d96ae300222cf76379f354819a4df06d3fbfa490" translate="yes" xml:space="preserve">
          <source>Generalized universal function signature, e.g., &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; for vectorized matrix-vector multiplication. If provided, &lt;code&gt;pyfunc&lt;/code&gt; will be called with (and expected to return) arrays with shapes given by the size of corresponding core dimensions. By default, &lt;code&gt;pyfunc&lt;/code&gt; is assumed to take scalars as input and output.</source>
          <target state="translated">벡터화 된 행렬-벡터 곱셈을위한 일반화 된 범용 함수 서명, 예를 들어 &lt;code&gt;(m,n),(n)-&amp;gt;(m)&lt;/code&gt; . 제공되는 경우 &lt;code&gt;pyfunc&lt;/code&gt; 는 해당 코어 크기의 크기로 주어진 모양을 가진 배열로 호출됩니다 (그리고 반환 될 것으로 예상됩니다). 기본적으로 &lt;code&gt;pyfunc&lt;/code&gt; 는 스칼라를 입력 및 출력으로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="4bdfd56723e2a4630d0aa40f0eab7e7e821379e3" translate="yes" xml:space="preserve">
          <source>Generally speaking, what is returned when index arrays are used is an array with the same shape as the index array, but with the type and values of the array being indexed. As an example, we can use a multidimensional index array instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2257faa28ea2af0838b36329ac81b4299b5a11a1" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57b3bfe4a96aaf1f0210aadbf43dc393e3a362c6" translate="yes" xml:space="preserve">
          <source>Generally, the file needs to be generated during the build, since it needs some information known at build time only (e.g. prefix). This is mostly automatic if one uses the &lt;code&gt;Configuration&lt;/code&gt; method &lt;code&gt;add_npy_pkg_config&lt;/code&gt;. Assuming we have a template file foo.ini.in as follows:</source>
          <target state="translated">일반적으로 파일은 빌드시에만 알려진 일부 정보 (예 : 접두사)가 필요하므로 빌드 중에 생성해야합니다. &lt;code&gt;Configuration&lt;/code&gt; 방법 &lt;code&gt;add_npy_pkg_config&lt;/code&gt; 를 사용하는 경우 대부분 자동 입니다. 다음과 같이 템플릿 파일 foo.ini.in이 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="ba56532a4a3fb8146e876e1d3659dfdac724a189" translate="yes" xml:space="preserve">
          <source>Generate a 1 by 3 array with 3 different lower bounds</source>
          <target state="translated">3 개의 다른 하한으로 1 x 3 배열 생성</target>
        </trans-unit>
        <trans-unit id="3724c74e69c85b7924eab36b9e17078ea85e817c" translate="yes" xml:space="preserve">
          <source>Generate a 1 x 3 array with 3 different upper bounds</source>
          <target state="translated">3 가지 상한으로 1 x 3 배열 생성</target>
        </trans-unit>
        <trans-unit id="c78b4920f6305013e33283131f3991e4d5dda157" translate="yes" xml:space="preserve">
          <source>Generate a 2 by 4 array using broadcasting with dtype of uint8</source>
          <target state="translated">dtype이 uint8 인 브로드 캐스팅을 사용하여 2 x 4 배열 생성</target>
        </trans-unit>
        <trans-unit id="52ec8bca285ae5da030ea4680d276692f61c3804" translate="yes" xml:space="preserve">
          <source>Generate a 2 x 4 array of ints between 0 and 4, inclusive:</source>
          <target state="translated">다음을 포함하여 0에서 4 사이의 정수로 2 x 4 배열을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9e541c44f7aa5d7ed7acb09f3c0fe019e268af5e" translate="yes" xml:space="preserve">
          <source>Generate a Chebyshev series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 체비 쇼프 시리즈를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="0c791c1439e16e2fd0efb50c6644249b5b3eebb5" translate="yes" xml:space="preserve">
          <source>Generate a Hermite series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 은자 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="8bd121a27d585c3734742539ee143a52ac9b73de" translate="yes" xml:space="preserve">
          <source>Generate a HermiteE series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 HermiteE 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="a9d697582320e7c884bbfd6a03995e4b278f2c74" translate="yes" xml:space="preserve">
          <source>Generate a Laguerre series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 Laguerre 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="9fd152ea5ebdb08e6cd481a5737f68bdf9d18ad6" translate="yes" xml:space="preserve">
          <source>Generate a Legendre series with given roots.</source>
          <target state="translated">주어진 뿌리를 가진 Legendre 시리즈를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="67cead80b0965ee4736c5f23fba251df4f3ebe37" translate="yes" xml:space="preserve">
          <source>Generate a Vandermonde matrix.</source>
          <target state="translated">Vandermonde 매트릭스를 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="f4b901c2336926f254f07d1ab7b60e0386e5b58c" translate="yes" xml:space="preserve">
          <source>Generate a monic polynomial with given roots.</source>
          <target state="translated">주어진 근을 가진 음의 다항식을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="2e173a5f3c2204af8ef7b9a77d34afee8c360a27" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">대체하지 않고 크기 3의 np.arange (5)에서 비 균일 랜덤 샘플을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="3b032abdb8bc3ee596986f951aad13aeb29eff03" translate="yes" xml:space="preserve">
          <source>Generate a non-uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">크기 3의 np.arange (5)에서 비 균일 랜덤 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="15beef8541c11b005861875826a071b16faf6c61" translate="yes" xml:space="preserve">
          <source>Generate a single integer</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22ecb4243c3f96a98ea55b6a9b74781792dce996" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3 without replacement:</source>
          <target state="translated">대체하지 않고 크기 3의 np.arange (5)에서 균일 한 랜덤 샘플을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="7e7e8cdcfbc5d1d81d3a8108edeaf14a80335951" translate="yes" xml:space="preserve">
          <source>Generate a uniform random sample from np.arange(5) of size 3:</source>
          <target state="translated">크기 3의 np.arange (5)에서 균일 한 랜덤 샘플을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="382b425e693319395299c741c143ce2398939efe" translate="yes" xml:space="preserve">
          <source>Generate and install a npy-pkg config file from a template.</source>
          <target state="translated">템플릿에서 npy-pkg 구성 파일을 생성하고 설치하십시오.</target>
        </trans-unit>
        <trans-unit id="19a90f1dba170779ac0befe5afd3d6d9c884c6d1" translate="yes" xml:space="preserve">
          <source>Generate config.py file containing system_info information used during building the package.</source>
          <target state="translated">패키지를 빌드하는 동안 사용 된 system_info 정보가 포함 된 config.py 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="34c49c62f8886e09ca6e64b9c96074bf60926d62" translate="yes" xml:space="preserve">
          <source>Generate package __config__.py file containing system_info information used during building the package.</source>
          <target state="translated">패키지를 빌드하는 동안 사용 된 system_info 정보를 포함하는 패키지 __config__.py 파일을 생성하십시오.</target>
        </trans-unit>
        <trans-unit id="14952923eed9a754d36fbf7d9df88e59880c6dad" translate="yes" xml:space="preserve">
          <source>Generate package __svn_version__.py file from SVN revision number, it will be removed after python exits but will be available when sdist, etc commands are executed.</source>
          <target state="translated">SVN 개정 번호에서 __svn_version__.py 패키지 패키지를 생성하십시오. 파이썬이 종료되면 제거되지만 sdist 등 명령이 실행될 때 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60ff5f05cec532a7f8f7d819baeeb92b41c5296d" translate="yes" xml:space="preserve">
          <source>Generate random uint64 numbers in closed interval [off, off + rng].</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8045f4bbe378a7866506cc0ecb5d877bf5eaf96" translate="yes" xml:space="preserve">
          <source>Generate the README files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7412730131bc368e3c0dcb289c20fbf2554245c4" translate="yes" xml:space="preserve">
          <source>Generate variates from a multivariate hypergeometric distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd9212c9f1d53d55d853a3b264e1b6b858f35fd" translate="yes" xml:space="preserve">
          <source>Generates a random sample from a given 1-D array</source>
          <target state="translated">주어진 1 차원 배열에서 무작위 표본을 생성합니다</target>
        </trans-unit>
        <trans-unit id="d332ac6845c5273c1195174ec786fa2289b9b752" translate="yes" xml:space="preserve">
          <source>Generating author/pr lists</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="150ce9aa76a74d0a43ead917a8c785193ed877b1" translate="yes" xml:space="preserve">
          <source>Generating index arrays</source>
          <target state="translated">인덱스 배열 생성</target>
        </trans-unit>
        <trans-unit id="4bc72cf76a431fc1b67a969426c355ba5d2b3044" translate="yes" xml:space="preserve">
          <source>Generating random numbers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a0d1bad0186174ecfcdc9782f2116277b7b05e0" translate="yes" xml:space="preserve">
          <source>Generator (class in numpy.random)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb174c2f425e0d1a36b6da19833f5708052f5b2" translate="yes" xml:space="preserve">
          <source>Generator.beta()</source>
          <target state="translated">Generator.beta()</target>
        </trans-unit>
        <trans-unit id="5c54211367d38fc1c657f1a2b11682aa7073f8a0" translate="yes" xml:space="preserve">
          <source>Generator.binomial()</source>
          <target state="translated">Generator.binomial()</target>
        </trans-unit>
        <trans-unit id="d222082a3e85bc085f3813830709c1091b870201" translate="yes" xml:space="preserve">
          <source>Generator.bit_generator</source>
          <target state="translated">Generator.bit_generator</target>
        </trans-unit>
        <trans-unit id="ccf1aa45703830ef34744bdb91c5ee84eb339af2" translate="yes" xml:space="preserve">
          <source>Generator.bytes()</source>
          <target state="translated">Generator.bytes()</target>
        </trans-unit>
        <trans-unit id="a1e223f39e59656efb6dcd2b450fd1f3d11e0f5b" translate="yes" xml:space="preserve">
          <source>Generator.chisquare()</source>
          <target state="translated">Generator.chisquare()</target>
        </trans-unit>
        <trans-unit id="a2cf011c29fcb364a340b0b0739ed3940f0415ce" translate="yes" xml:space="preserve">
          <source>Generator.choice()</source>
          <target state="translated">Generator.choice()</target>
        </trans-unit>
        <trans-unit id="acb19d66e8b5e00bd8ab9eaa938d00f3718515fe" translate="yes" xml:space="preserve">
          <source>Generator.dirichlet()</source>
          <target state="translated">Generator.dirichlet()</target>
        </trans-unit>
        <trans-unit id="81c841ae15f138b1059c14b8ebc34f2ceb6506da" translate="yes" xml:space="preserve">
          <source>Generator.exponential()</source>
          <target state="translated">Generator.exponential()</target>
        </trans-unit>
        <trans-unit id="ceb6ee1b51ecd1875248d0ca388e0fb1daabb181" translate="yes" xml:space="preserve">
          <source>Generator.f()</source>
          <target state="translated">Generator.f()</target>
        </trans-unit>
        <trans-unit id="9a5544f1f1d846a0215be8277752788b52f5d5ae" translate="yes" xml:space="preserve">
          <source>Generator.gamma()</source>
          <target state="translated">Generator.gamma()</target>
        </trans-unit>
        <trans-unit id="cb698152656074b26c2b514594b6841ba98646e0" translate="yes" xml:space="preserve">
          <source>Generator.geometric()</source>
          <target state="translated">Generator.geometric()</target>
        </trans-unit>
        <trans-unit id="fbe271ee0cdf14a0b127e97b8a754332b21122bf" translate="yes" xml:space="preserve">
          <source>Generator.gumbel()</source>
          <target state="translated">Generator.gumbel()</target>
        </trans-unit>
        <trans-unit id="1bb4c4773f6c2e362f6bdc12b4738edbd30f23d2" translate="yes" xml:space="preserve">
          <source>Generator.hypergeometric()</source>
          <target state="translated">Generator.hypergeometric()</target>
        </trans-unit>
        <trans-unit id="c50dbdf77399f33f0754452bd827d7d9972e1f6e" translate="yes" xml:space="preserve">
          <source>Generator.integers()</source>
          <target state="translated">Generator.integers()</target>
        </trans-unit>
        <trans-unit id="2ac6ee43d1992ed473a404e92103ad981ee56dd8" translate="yes" xml:space="preserve">
          <source>Generator.laplace()</source>
          <target state="translated">Generator.laplace()</target>
        </trans-unit>
        <trans-unit id="9a01e0244542efabb99865e59014bd47d50fe182" translate="yes" xml:space="preserve">
          <source>Generator.logistic()</source>
          <target state="translated">Generator.logistic()</target>
        </trans-unit>
        <trans-unit id="c320801600fb9c31cc3d790a76584f303a266f0d" translate="yes" xml:space="preserve">
          <source>Generator.lognormal()</source>
          <target state="translated">Generator.lognormal()</target>
        </trans-unit>
        <trans-unit id="2133a52d0f531222ffd5b10595265bd407d65eae" translate="yes" xml:space="preserve">
          <source>Generator.logseries()</source>
          <target state="translated">Generator.logseries()</target>
        </trans-unit>
        <trans-unit id="3fb5b968b7c3c6e4334e366ce81b7d1c72dd0587" translate="yes" xml:space="preserve">
          <source>Generator.multinomial()</source>
          <target state="translated">Generator.multinomial()</target>
        </trans-unit>
        <trans-unit id="ee77530caf29c96157f8b247c28bc2729509bc1f" translate="yes" xml:space="preserve">
          <source>Generator.multivariate_normal()</source>
          <target state="translated">Generator.multivariate_normal()</target>
        </trans-unit>
        <trans-unit id="e4accfbbf5411ba4e6ed6190c6c4a4f347889476" translate="yes" xml:space="preserve">
          <source>Generator.negative_binomial()</source>
          <target state="translated">Generator.negative_binomial()</target>
        </trans-unit>
        <trans-unit id="f5c86d9e1ec54b1f6ceef69c6b35acbc51980bb9" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_chisquare()</source>
          <target state="translated">Generator.noncentral_chisquare()</target>
        </trans-unit>
        <trans-unit id="4ffb9eb22957bfe4ccb8d5eb67072da9ed2c8fe8" translate="yes" xml:space="preserve">
          <source>Generator.noncentral_f()</source>
          <target state="translated">Generator.noncentral_f()</target>
        </trans-unit>
        <trans-unit id="155766b36ed963438beae39d25dc848285e67bec" translate="yes" xml:space="preserve">
          <source>Generator.normal()</source>
          <target state="translated">Generator.normal()</target>
        </trans-unit>
        <trans-unit id="b6ff7a92707e2ef9f9f69eb28c0f2a89afd2fb30" translate="yes" xml:space="preserve">
          <source>Generator.pareto()</source>
          <target state="translated">Generator.pareto()</target>
        </trans-unit>
        <trans-unit id="76efb5ddfe9997620fd07ade2a0e0cee44bb8c62" translate="yes" xml:space="preserve">
          <source>Generator.permutation()</source>
          <target state="translated">Generator.permutation()</target>
        </trans-unit>
        <trans-unit id="7a00012743deaf56311a785e2b3c42ad040930cb" translate="yes" xml:space="preserve">
          <source>Generator.poisson()</source>
          <target state="translated">Generator.poisson()</target>
        </trans-unit>
        <trans-unit id="9ebe8ebc29357762dc172bd7a50a6d2bbec0bbc0" translate="yes" xml:space="preserve">
          <source>Generator.power()</source>
          <target state="translated">Generator.power()</target>
        </trans-unit>
        <trans-unit id="760d539be436a9fd5786ef5406b94bdadd320519" translate="yes" xml:space="preserve">
          <source>Generator.random()</source>
          <target state="translated">Generator.random()</target>
        </trans-unit>
        <trans-unit id="4fe55f2eb5b58a57536abac4e6392ebd311bfe6e" translate="yes" xml:space="preserve">
          <source>Generator.rayleigh()</source>
          <target state="translated">Generator.rayleigh()</target>
        </trans-unit>
        <trans-unit id="3fff1d63fa4122d609dcfb229ec0499ef08a14a7" translate="yes" xml:space="preserve">
          <source>Generator.shuffle()</source>
          <target state="translated">Generator.shuffle()</target>
        </trans-unit>
        <trans-unit id="9b1634a618bfbc7c72035711945372ce07c3fe19" translate="yes" xml:space="preserve">
          <source>Generator.standard_cauchy()</source>
          <target state="translated">Generator.standard_cauchy()</target>
        </trans-unit>
        <trans-unit id="34db4ce80b61d7d21ff61b89aa2d2d63aa910f5c" translate="yes" xml:space="preserve">
          <source>Generator.standard_exponential()</source>
          <target state="translated">Generator.standard_exponential()</target>
        </trans-unit>
        <trans-unit id="34031ad3432250f012a4d89407bba35b84a16c3c" translate="yes" xml:space="preserve">
          <source>Generator.standard_gamma()</source>
          <target state="translated">Generator.standard_gamma()</target>
        </trans-unit>
        <trans-unit id="87dab3cf1af1d204bcf4e1ac664f4ea0ea2557c9" translate="yes" xml:space="preserve">
          <source>Generator.standard_normal()</source>
          <target state="translated">Generator.standard_normal()</target>
        </trans-unit>
        <trans-unit id="f906f6a0afddbf8cdbe07f5b8f0720c2656e3a0d" translate="yes" xml:space="preserve">
          <source>Generator.standard_t()</source>
          <target state="translated">Generator.standard_t()</target>
        </trans-unit>
        <trans-unit id="b0b2b3ce2c0360b1a89e482830d2d3c0cbab9581" translate="yes" xml:space="preserve">
          <source>Generator.triangular()</source>
          <target state="translated">Generator.triangular()</target>
        </trans-unit>
        <trans-unit id="ab3025f762e986dfbed9abf7722d638afcbcac65" translate="yes" xml:space="preserve">
          <source>Generator.uniform()</source>
          <target state="translated">Generator.uniform()</target>
        </trans-unit>
        <trans-unit id="41234839ae9e6c31f86b35be70f95dd2edfdb45f" translate="yes" xml:space="preserve">
          <source>Generator.vonmises()</source>
          <target state="translated">Generator.vonmises()</target>
        </trans-unit>
        <trans-unit id="524f7ff03bcd2538def6c2fcd08d18e053cd0a0d" translate="yes" xml:space="preserve">
          <source>Generator.wald()</source>
          <target state="translated">Generator.wald()</target>
        </trans-unit>
        <trans-unit id="e7d43ca17b95d21950576674e14eac05300d6600" translate="yes" xml:space="preserve">
          <source>Generator.weibull()</source>
          <target state="translated">Generator.weibull()</target>
        </trans-unit>
        <trans-unit id="425fdb323ea262485eeead85528e77951596ac23" translate="yes" xml:space="preserve">
          <source>Generator.zipf()</source>
          <target state="translated">Generator.zipf()</target>
        </trans-unit>
        <trans-unit id="b9790b2a609e0a0a9945eb7f9ff37cc7c5acb58d" translate="yes" xml:space="preserve">
          <source>Generators should be documented just as functions are documented. The only difference is that one should use the &lt;strong&gt;Yields&lt;/strong&gt; section instead of the &lt;strong&gt;Returns&lt;/strong&gt; section. Support for the &lt;strong&gt;Yields&lt;/strong&gt; section was added in &lt;a href=&quot;https://github.com/numpy/numpydoc&quot;&gt;numpydoc&lt;/a&gt; version 0.6.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e162e441d1aa68e920c4da50498c7a00cc1ca" translate="yes" xml:space="preserve">
          <source>Generators: Objects that transform sequences of random bits from a BitGenerator into sequences of numbers that follow a specific probability distribution (such as uniform, Normal or Binomial) within a specified interval.</source>
          <target state="translated">생성기 : BitGenerator의 임의 비트 시퀀스를 지정된 간격 내에서 특정 확률 분포 (예 : 균일, 정규 또는 이항)를 따르는 숫자 시퀀스로 변환하는 객체입니다.</target>
        </trans-unit>
        <trans-unit id="fcca6d928c0647f440353ba62ca89c9a77b6389a" translate="yes" xml:space="preserve">
          <source>Generic Python-exception-derived object raised by linalg functions.</source>
          <target state="translated">linalg 함수에 의해 생성 된 일반 파이썬 예외 파생 객체.</target>
        </trans-unit>
        <trans-unit id="37f5365cdbef14515226dcd384583192170cc525" translate="yes" xml:space="preserve">
          <source>Generic functions</source>
          <target state="translated">일반 함수</target>
        </trans-unit>
        <trans-unit id="36687e3d4c6e89be61413141c9001bd1269ea61f" translate="yes" xml:space="preserve">
          <source>Generic types</source>
          <target state="translated">일반 유형</target>
        </trans-unit>
        <trans-unit id="4725fc543850e19ff2039cda197dd7e9e18cc3b7" translate="yes" xml:space="preserve">
          <source>Get a Python object of a builtin type from the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the location pointed to by itemptr. Return &lt;code&gt;NULL&lt;/code&gt; on failure.</source>
          <target state="translated">itemptr이 가리키는 위치에서 ndarray &lt;em&gt;arr&lt;/em&gt; 에서 내장 유형의 Python 객체를 가져옵니다. 실패 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="89bba80c206cb8084a11e65d5dc5c897b6a8a686" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator as a 1-D array.</source>
          <target state="translated">반복자의 사본을 1 차원 배열로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="f7e3ab2dfabd54e64b9ac5580bc305e9c24165dc" translate="yes" xml:space="preserve">
          <source>Get a copy of the iterator in its current state.</source>
          <target state="translated">반복자의 사본을 현재 상태로 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="87b8e4a6c47eabed3fcd4c264f91d248484dbd8e" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 로컬 변수에 대한 포인터가 전달되어 상태를 설정하는 코드와 관련하여 공격적인 컴파일러 최적화에서이 함수 호출을 다시 지정하지 못하게되어 잘못된 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c919c3aaf29bde2f7fadef95afc3436e547fc4bb" translate="yes" xml:space="preserve">
          <source>Get floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call relative to the code setting the status, which could lead to incorrect results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b27b9509ff4121a0e1b9f0986d9920de57d819f0" translate="yes" xml:space="preserve">
          <source>Get floating point status. Returns a bitmask with following possible flags:</source>
          <target state="translated">부동 소수점 상태를 가져옵니다. 다음과 같은 플래그로 비트 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ddfceaf39034459b039832aa5e0f88a5294c648e" translate="yes" xml:space="preserve">
          <source>Get help information for a function, class, or module.</source>
          <target state="translated">함수, 클래스 또는 모듈에 대한 도움말 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="ec25cf47cdd55b9b521bbdadbef69d3ea1d8e5a4" translate="yes" xml:space="preserve">
          <source>Get information about the step size of a date or time type.</source>
          <target state="translated">날짜 또는 시간 유형의 단계 크기에 대한 정보를 얻습니다.</target>
        </trans-unit>
        <trans-unit id="d0d9c57e1b16aa99fa5d9ab014f87b4ec73ded17" translate="yes" xml:space="preserve">
          <source>Get number of parallel build jobs set by the &amp;ndash;parallel command line argument of setup.py If the command did not receive a setting the environment variable NPY_NUM_BUILD_JOBS is checked. If that is unset, return the number of processors on the system, with a maximum of 8 (to prevent overloading the system if there a lot of CPUs).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="693a41351204b667429ed1f8f87172706e8b4a91" translate="yes" xml:space="preserve">
          <source>Get or set the PRNG state</source>
          <target state="translated">PRNG 상태 가져 오기 또는 설정</target>
        </trans-unit>
        <trans-unit id="09c0240016b842d9be6c9625e5a572e040565a6a" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields.</source>
          <target state="translated">명명 된 필드가없는 배열의 마스크를 가져 오거나 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="0a74bcddcc3142595e265c6f91c54ba0941f6e3f" translate="yes" xml:space="preserve">
          <source>Get or set the mask of the array if it has no named fields. For structured arrays, returns a ndarray of booleans where entries are &lt;code&gt;True&lt;/code&gt; if &lt;strong&gt;all&lt;/strong&gt; the fields are masked, &lt;code&gt;False&lt;/code&gt; otherwise:</source>
          <target state="translated">명명 된 필드가없는 배열의 마스크를 가져 오거나 설정하십시오. 구조화 된 배열의 경우 &lt;strong&gt;모든&lt;/strong&gt; 필드가 마스크 된 경우 항목이 &lt;code&gt;True&lt;/code&gt; 인 부울의 ndarray를 반환하고 그렇지 않으면 &lt;code&gt;False&lt;/code&gt; 를 반환합니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0ab6b2bea51cfebc1977ab8830dcd90e5d8f56d" translate="yes" xml:space="preserve">
          <source>Get resources information.</source>
          <target state="translated">자원 정보를 얻으십시오.</target>
        </trans-unit>
        <trans-unit id="7d41ad59188f890aeb1ed8209e30d553a33f1536" translate="yes" xml:space="preserve">
          <source>Get the Python values used for ufunc processing from the thread-local storage area unless the defaults have been set in which case the name lookup is bypassed. The name is placed as a string in the first element of &lt;em&gt;*errobj&lt;/em&gt;. The second element is the looked-up function to call on error callback. The value of the looked-up buffer-size to use is passed into &lt;em&gt;bufsize&lt;/em&gt;, and the value of the error mask is placed into &lt;em&gt;errmask&lt;/em&gt;.</source>
          <target state="translated">이름 조회가 무시되는 경우 기본값이 설정되지 않은 경우 스레드 로컬 저장 영역에서 ufunc 처리에 사용되는 Python 값을 가져옵니다. 이름은 &lt;em&gt;* errobj&lt;/em&gt; 의 첫 번째 요소에 문자열로 배치됩니다 . 두 번째 요소는 오류 콜백을 호출하는 조회 기능입니다. 조회 할 버퍼 크기 의 값은 &lt;em&gt;bufsize&lt;/em&gt; 로 전달되고 오류 마스크의 값은 &lt;em&gt;errmask에&lt;/em&gt; 배치됩니다 .</target>
        </trans-unit>
        <trans-unit id="b42cef4d77cbf66bab7c534b082e6107163dee92" translate="yes" xml:space="preserve">
          <source>Get the current way of handling floating-point errors.</source>
          <target state="translated">부동 소수점 오류를 처리하는 현재 방법을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="1ad2852f86c694e329d03e73d07b76a105a8cebc" translate="yes" xml:space="preserve">
          <source>Get the local copy of the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="695f3e243afdf261b45538304791ad040f8d34f0" translate="yes" xml:space="preserve">
          <source>Get the number of dimensions of an array</source>
          <target state="translated">배열의 차원 수를 구합니다</target>
        </trans-unit>
        <trans-unit id="38abfcd88f93b84356fd5ce9430a9a3bce6aa97e" translate="yes" xml:space="preserve">
          <source>Get the shape of the array and a pointer to its actual data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b4332f0fd288d9a8660cb9b90eb2d70399cb30" translate="yes" xml:space="preserve">
          <source>Getitem/setitem/copyswap function: Similar to ufuncs, these functions generally have two code paths. If &lt;code&gt;ALIGNED&lt;/code&gt; is False they will use a code path that buffers the arguments so they are true-aligned.</source>
          <target state="translated">Getitem / setitem / copyswap 함수 : ufuncs와 유사하게이 함수에는 일반적으로 두 개의 코드 경로가 있습니다. 경우 &lt;code&gt;ALIGNED&lt;/code&gt; 거짓입니다 그들은 진정한 정렬 그래서 인수를 버퍼링 코드 경로를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="be9042cc4b8d1c2a38a88090c5bbf827e249e726" translate="yes" xml:space="preserve">
          <source>Gets an array of strides which are fixed, or will not change during the entire iteration. For strides that may change, the value NPY_MAX_INTP is placed in the stride.</source>
          <target state="translated">고정되거나 전체 반복 중에 변경되지 않는 보폭 배열을 가져옵니다. 변경 가능한 보폭의 경우 NPY_MAX_INTP 값이 보폭에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="30fc1fed71b9648bc39ebe85c632c9c96d68765c" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; of the iterator, which is an index matching the iteration order of the iterator.</source>
          <target state="translated">가져 &lt;code&gt;iterindex&lt;/code&gt; 반복기의 반복 순서와 일치하는 인덱스 반복기의이.</target>
        </trans-unit>
        <trans-unit id="c9217aeddd13f7d6ea905e46252fcb27732c6211" translate="yes" xml:space="preserve">
          <source>Gets the &lt;code&gt;iterindex&lt;/code&gt; sub-range that is being iterated. If &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt;&lt;code&gt;NPY_ITER_RANGED&lt;/code&gt;&lt;/a&gt; was not specified, this always returns the range &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt;.</source>
          <target state="translated">반복되는 &lt;code&gt;iterindex&lt;/code&gt; 하위 범위를 가져옵니다 . 경우 &lt;a href=&quot;#c.NPY_ITER_RANGED&quot;&gt; &lt;code&gt;NPY_ITER_RANGED&lt;/code&gt; 가&lt;/a&gt; 지정되지 않았습니다이 항상 범위를 반환 &lt;code&gt;[0, NpyIter_IterSize(iter))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29099a868ef51a061ab01f34d141a4b26e68b87" translate="yes" xml:space="preserve">
          <source>Gets the array of data pointers directly into the arrays (never into the buffers), corresponding to iteration index 0.</source>
          <target state="translated">반복 인덱스 0에 해당하는 데이터 포인터의 배열을 버퍼로 절대 배열에 직접 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="ad1880ff271cb91c83bb908e9bec8d5e682e13f9" translate="yes" xml:space="preserve">
          <source>Gets the array of strides for the specified axis. Requires that the iterator be tracking a multi-index, and that buffering not be enabled.</source>
          <target state="translated">지정된 축에 대한 보폭 배열을 가져옵니다. 반복자가 다중 색인을 추적하고 버퍼링을 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cbcc80db035da4f014fe2b35abfcfb7fdf954c8c" translate="yes" xml:space="preserve">
          <source>Gets the bit generator instance used by the generator</source>
          <target state="translated">생성기에서 사용하는 비트 생성기 인스턴스를 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="d159fd31101fbca3940d95031521a0aa1cca2dba" translate="yes" xml:space="preserve">
          <source>Getting at ndarray memory and accessing elements of the ndarray</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a46b1f79c63a304cb32357fb767b2f9f13f63b7" translate="yes" xml:space="preserve">
          <source>Getting extra Fortran 77 compiler options from source</source>
          <target state="translated">소스에서 추가 포트란 77 컴파일러 옵션 얻기</target>
        </trans-unit>
        <trans-unit id="40231bcdbc4a93a29a6d8b82096fcd17f9064444" translate="yes" xml:space="preserve">
          <source>Getting started with Git development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e47f4c54647389b910573011e6826ea1e0a912" translate="yes" xml:space="preserve">
          <source>Git Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfff37d55b9830b2f87d05fbf99d4f09fbfa666c" translate="yes" xml:space="preserve">
          <source>Git configuration</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5717316487921ed9c21d808282281daa39b5a4" translate="yes" xml:space="preserve">
          <source>Git for development</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cbb73206931d6c5b9ae31c184bc49486ee1eb6" translate="yes" xml:space="preserve">
          <source>Git will then immediately bring up an editor for editing the commit message. After revising it, we get the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fed2b47c2eb6fcb9566d8e5b338ef20c663258ac" translate="yes" xml:space="preserve">
          <source>Give a new shape to an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="a577ea656c2f3aa2b8af6ec81a5f57008704a3bb" translate="yes" xml:space="preserve">
          <source>Give a new shape to the array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 부여하십시오.</target>
        </trans-unit>
        <trans-unit id="5633a94c306e1317df951f106e430c35db17233f" translate="yes" xml:space="preserve">
          <source>Given a sequence of a polynomial&amp;rsquo;s zeros:</source>
          <target state="translated">다항식 0의 시퀀스가 ​​주어진 경우 :</target>
        </trans-unit>
        <trans-unit id="4cc543f62ec648afbd60f8c46e36515054ff8b40" translate="yes" xml:space="preserve">
          <source>Given a sequence of arrays (&lt;em&gt;sort_keys&lt;/em&gt;) of the same shape, return an array of indices (similar to &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt;&lt;code&gt;PyArray_ArgSort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;)) that would sort the arrays lexicographically. A lexicographic sort specifies that when two keys are found to be equal, the order is based on comparison of subsequent keys. A merge sort (which leaves equal entries unmoved) is required to be defined for the types. The sort is accomplished by sorting the indices first using the first &lt;em&gt;sort_key&lt;/em&gt; and then using the second &lt;em&gt;sort_key&lt;/em&gt; and so forth. This is equivalent to the lexsort(&lt;em&gt;sort_keys&lt;/em&gt;, &lt;em&gt;axis&lt;/em&gt;) Python command. Because of the way the merge-sort works, be sure to understand the order the &lt;em&gt;sort_keys&lt;/em&gt; must be in (reversed from the order you would use when comparing two elements).</source>
          <target state="translated">같은 모양 의 배열 ( &lt;em&gt;sort_keys&lt;/em&gt; ) 시퀀스가 주어지면 배열을 사전 식으로 정렬하는 인덱스 배열 ( &lt;a href=&quot;#c.PyArray_ArgSort&quot;&gt; &lt;code&gt;PyArray_ArgSort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;) 과 유사)을 반환 하십시오. 사전 식 정렬은 두 개의 키가 동일 할 때 순서가 후속 키의 비교를 기반으로 함을 지정합니다. 유형에 대해 병합 항목 (동일한 항목을 그대로 유지)을 정의해야합니다. 정렬 먼저 인덱스 선별 제를 사용하여 달성된다 &lt;em&gt;sort_key을&lt;/em&gt; 다음 두 번째 사용 &lt;em&gt;sort_key를&lt;/em&gt; 등등과. 이것은 lexsort ( &lt;em&gt;sort_keys&lt;/em&gt; , &lt;em&gt;axis&lt;/em&gt; ) Python 명령과 동일합니다. 병합 정렬이 작동하는 방식 때문에 &lt;em&gt;sort_keys&lt;/em&gt; 의 순서를 이해해야합니다.&lt;em&gt;&lt;/em&gt; 에 있어야합니다 (두 요소를 비교할 때 사용하는 순서와 반대로).</target>
        </trans-unit>
        <trans-unit id="675ac4930884c9f7a3554ad9fd66c39834a06013" translate="yes" xml:space="preserve">
          <source>Given a set of conditions and corresponding functions, evaluate each function on the input data wherever its condition is true.</source>
          <target state="translated">일련의 조건과 해당 기능이 주어지면 입력 데이터의 각 기능이 조건에 맞는지 평가하십시오.</target>
        </trans-unit>
        <trans-unit id="9104557d433ccbecbd40d5b471167b269afd4924" translate="yes" xml:space="preserve">
          <source>Given a shape of, for example, &lt;code&gt;(m,n,k)&lt;/code&gt;, &lt;code&gt;m*n*k&lt;/code&gt; samples are generated, and packed in an &lt;code&gt;m&lt;/code&gt;-by-&lt;code&gt;n&lt;/code&gt;-by-&lt;code&gt;k&lt;/code&gt; arrangement. Because each sample is &lt;code&gt;N&lt;/code&gt;-dimensional, the output shape is &lt;code&gt;(m,n,k,N)&lt;/code&gt;. If no shape is specified, a single (&lt;code&gt;N&lt;/code&gt;-D) sample is returned.</source>
          <target state="translated">예컨대 형상, 주어진 &lt;code&gt;(m,n,k)&lt;/code&gt; , &lt;code&gt;m*n*k&lt;/code&gt; 샘플을 생성 및 포장 &lt;code&gt;m&lt;/code&gt; -by- &lt;code&gt;n&lt;/code&gt; -by- &lt;code&gt;k&lt;/code&gt; 배열. 각 표본은 &lt;code&gt;N&lt;/code&gt; 차원이므로 출력 모양은 &lt;code&gt;(m,n,k,N)&lt;/code&gt; 입니다. 모양을 지정하지 않으면 단일 ( &lt;code&gt;N&lt;/code&gt; -D) 샘플이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="cd43bd0b568c4a20eb55e09b56aec26e4bcf57e8" translate="yes" xml:space="preserve">
          <source>Given a square array object:</source>
          <target state="translated">정사각형 배열 객체가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="c727e55b5284efd4b0f949a20f79f07a731a7def" translate="yes" xml:space="preserve">
          <source>Given a square matrix &lt;code&gt;a&lt;/code&gt;, return the matrix &lt;code&gt;ainv&lt;/code&gt; satisfying &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt;.</source>
          <target state="translated">정사각 행렬 &lt;code&gt;a&lt;/code&gt; 가 주어지면 &lt;code&gt;dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])&lt;/code&gt; 만족 하는 행렬 &lt;code&gt;ainv&lt;/code&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fc3ba91f03af5d3e0b135a4d459d0b8c153beab2" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the &lt;code&gt;q&lt;/code&gt;-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 &lt;code&gt;q&lt;/code&gt; 번째 백분위 수의 &lt;code&gt;V&lt;/code&gt; 되는 값 &lt;code&gt;q/100&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법 &lt;code&gt;V&lt;/code&gt; . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않으면 가장 가까운 두 이웃 및 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 의 값과 거리에 따라 백분위 수가 결정 됩니다. 이 함수는 &lt;code&gt;q=50&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=100&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="1966cedf9ce61fd3a211e32f4abbb9573112f3e8" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 평균 &lt;code&gt;V&lt;/code&gt; 의 정렬 된 사본 &lt;code&gt;V&lt;/code&gt; 의 &lt;code&gt;V_sorted&lt;/code&gt; - 즉 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; 의 중간 값이며 &lt;code&gt;N&lt;/code&gt; 이 홀수 일 때 &lt;code&gt;N&lt;/code&gt; 이 짝수 일 때 &lt;code&gt;V_sorted&lt;/code&gt; 의 두 중간 값 .</target>
        </trans-unit>
        <trans-unit id="a11a60c1be0b2a1a4251da19f3ebb410f0917d80" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt;, &lt;code&gt;V_sorted&lt;/code&gt; - i.e., &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd and the average of the two middle values of &lt;code&gt;V_sorted&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이의 &lt;code&gt;N&lt;/code&gt; 의 평균 &lt;code&gt;V&lt;/code&gt; 정렬 된 복사본의 중간 값 인 &lt;code&gt;V&lt;/code&gt; , &lt;code&gt;V_sorted&lt;/code&gt; - 즉 &lt;code&gt;V_sorted[(N-1)/2]&lt;/code&gt; , 경우 &lt;code&gt;N&lt;/code&gt; 이 홀수 개의 중간 값의 평균이며 의 &lt;code&gt;V_sorted&lt;/code&gt; 때 &lt;code&gt;N&lt;/code&gt; 은 짝수이다.</target>
        </trans-unit>
        <trans-unit id="d76c2715df60bdab25092c54104462a6d39f23bb" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th percentile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q/100&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the percentile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=50&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=100&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 Q 번째 백분위 &lt;code&gt;V&lt;/code&gt; 는 값이다 &lt;code&gt;q/100&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법 &lt;code&gt;V&lt;/code&gt; . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않으면 가장 가까운 두 이웃 및 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 의 값과 거리에 따라 백분위 수가 결정 됩니다. 이 함수는 &lt;code&gt;q=50&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=100&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="dfd59ffc41fbed91404c5101ddfa184c5392006b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; of length &lt;code&gt;N&lt;/code&gt;, the q-th quantile of &lt;code&gt;V&lt;/code&gt; is the value &lt;code&gt;q&lt;/code&gt; of the way from the minimum to the maximum in a sorted copy of &lt;code&gt;V&lt;/code&gt;. The values and distances of the two nearest neighbors as well as the &lt;code&gt;interpolation&lt;/code&gt; parameter will determine the quantile if the normalized ranking does not match the location of &lt;code&gt;q&lt;/code&gt; exactly. This function is the same as the median if &lt;code&gt;q=0.5&lt;/code&gt;, the same as the minimum if &lt;code&gt;q=0.0&lt;/code&gt; and the same as the maximum if &lt;code&gt;q=1.0&lt;/code&gt;.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 길이 &lt;code&gt;N&lt;/code&gt; 의 Q 번째 분위수 &lt;code&gt;V&lt;/code&gt; 는 값이다 &lt;code&gt;q&lt;/code&gt; 의 정렬 된 복사본의 최대 최소의 방법은 &lt;code&gt;V&lt;/code&gt; 는 . 정규화 된 순위가 &lt;code&gt;q&lt;/code&gt; 의 위치와 정확히 일치하지 않는 경우 &lt;code&gt;interpolation&lt;/code&gt; 매개 변수 뿐만 아니라 가장 가까운 두 이웃의 값과 거리가 Quantile을 결정합니다 . 이 함수는 &lt;code&gt;q=0.5&lt;/code&gt; 의 경우 중앙값 과 같고 &lt;code&gt;q=0.0&lt;/code&gt; 의 경우 최소값 과 같고 &lt;code&gt;q=1.0&lt;/code&gt; 의 경우 최대 값과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="97afe1ab394be8a96329790e96c805504acf970b" translate="yes" xml:space="preserve">
          <source>Given a vector &lt;code&gt;V&lt;/code&gt; with &lt;code&gt;N&lt;/code&gt; non masked values, the median of &lt;code&gt;V&lt;/code&gt; is the middle value of a sorted copy of &lt;code&gt;V&lt;/code&gt; (&lt;code&gt;Vs&lt;/code&gt;) - i.e. &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt;, when &lt;code&gt;N&lt;/code&gt; is odd, or &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; when &lt;code&gt;N&lt;/code&gt; is even.</source>
          <target state="translated">벡터 주어 &lt;code&gt;V&lt;/code&gt; 와 &lt;code&gt;N&lt;/code&gt; 의 값을 마스크 비의 평균 &lt;code&gt;V&lt;/code&gt; 는 정렬 된 복사본의 중간 값 인 &lt;code&gt;V&lt;/code&gt; ( &lt;code&gt;Vs&lt;/code&gt; 즉 -) &lt;code&gt;Vs[(N-1)/2]&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 이 홀수 또는 &lt;code&gt;{Vs[N/2 - 1] + Vs[N/2]}/2&lt;/code&gt; &lt;code&gt;N&lt;/code&gt; 이 짝수 인 경우 / 2-1] + Vs [N / 2]} / 2</target>
        </trans-unit>
        <trans-unit id="2f958084a15b1cea997fb4f3882497b30e2d92da" translate="yes" xml:space="preserve">
          <source>Given a window length &lt;code&gt;n&lt;/code&gt; and a sample spacing &lt;code&gt;d&lt;/code&gt;:</source>
          <target state="translated">창 길이 &lt;code&gt;n&lt;/code&gt; 과 샘플 간격 &lt;code&gt;d&lt;/code&gt; 가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="3cf50be3014d334ce381b3182c6e22be99505ba7" translate="yes" xml:space="preserve">
          <source>Given an &amp;ldquo;index&amp;rdquo; array (&lt;code&gt;a&lt;/code&gt;) of integers and a sequence of &lt;code&gt;n&lt;/code&gt; arrays (&lt;code&gt;choices&lt;/code&gt;), &lt;code&gt;a&lt;/code&gt; and each choice array are first broadcast, as necessary, to arrays of a common shape; calling these &lt;em&gt;Ba&lt;/em&gt; and &lt;em&gt;Bchoices[i], i = 0,&amp;hellip;,n-1&lt;/em&gt; we have that, necessarily, &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; for each &lt;code&gt;i&lt;/code&gt;. Then, a new array with shape &lt;code&gt;Ba.shape&lt;/code&gt; is created as follows:</source>
          <target state="translated">정수 의 &quot;인덱스&quot;어레이 ( &lt;code&gt;a&lt;/code&gt; ) 및 &lt;code&gt;n&lt;/code&gt; 개의 어레이 ( &lt;code&gt;choices&lt;/code&gt; ) 의 시퀀스가 주어지면 , &lt;code&gt;a&lt;/code&gt; 및 각 선택 어레이는 필요에 따라 공통 형상의 어레이로 먼저 브로드 캐스트된다; 이것을 호출&lt;em&gt; Ba&lt;/em&gt; 와 &lt;em&gt;Bchoices [i], i = 0,&amp;hellip;, n-1&lt;/em&gt; 이라고 &lt;code&gt;Ba.shape == Bchoices[i].shape&lt;/code&gt; 반드시 각 &lt;code&gt;i&lt;/code&gt; 에 대해 Ba.shape == Bchoices [i] .shape 가됩니다 . 그런 다음 모양이 &lt;code&gt;Ba.shape&lt;/code&gt; 인 새 배열이 다음과 같이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="182d11d96136738a2da66eeca81246c173e18b8d" translate="yes" xml:space="preserve">
          <source>Given an array of integers and a set of n choice arrays, this method will create a new array that merges each of the choice arrays. Where a value in &lt;code&gt;a&lt;/code&gt; is i, the new array will have the value that choices[i] contains in the same place.</source>
          <target state="translated">정수 배열과 n 개의 선택 배열 집합이 주어지면이 메소드는 각 선택 배열을 병합하는 새 배열을 만듭니다. 의 값 여기서 &lt;code&gt;a&lt;/code&gt; I 인 새로운 배열을 선택 [I]이 동일 위치에 포함 된 값을 가질 것이다.</target>
        </trans-unit>
        <trans-unit id="e37e450d620d60b14cee7269755ab57ba8f06da4" translate="yes" xml:space="preserve">
          <source>Given an interval, values outside the interval are clipped to the interval edges. For example, if an interval of &lt;code&gt;[0, 1]&lt;/code&gt; is specified, values smaller than 0 become 0, and values larger than 1 become 1.</source>
          <target state="translated">간격이 주어지면 간격 밖의 값이 간격 가장자리에 잘립니다. 예를 들어, 간격 &lt;code&gt;[0, 1]&lt;/code&gt; 을 지정하면 0보다 작은 값은 0이되고 1보다 큰 값은 1이됩니다.</target>
        </trans-unit>
        <trans-unit id="38e44e10395d6cbc3f11e11b2660a79eed5fd62a" translate="yes" xml:space="preserve">
          <source>Given multiple sorting keys, which can be interpreted as columns in a spreadsheet, lexsort returns an array of integer indices that describes the sort order by multiple columns. The last key in the sequence is used for the primary sort order, the second-to-last key for the secondary sort order, and so on. The keys argument must be a sequence of objects that can be converted to arrays of the same shape. If a 2D array is provided for the keys argument, it&amp;rsquo;s rows are interpreted as the sorting keys and sorting is according to the last row, second last row etc.</source>
          <target state="translated">스프레드 시트에서 열로 해석 될 수있는 여러 정렬 키가 제공되면 lexsort는 여러 열의 정렬 순서를 설명하는 정수 인덱스 배열을 반환합니다. 시퀀스의 마지막 키는 기본 정렬 순서에 사용되며, 두 번째에서 마지막 키는 보조 정렬 순서에 사용됩니다. keys 인수는 동일한 모양의 배열로 변환 될 수있는 일련의 객체 여야합니다. keys 인수에 2D 배열이 제공되는 경우 행은 정렬 키로 해석되며 정렬은 마지막 행, 두 번째 마지막 행 등에 따릅니다.</target>
        </trans-unit>
        <trans-unit id="67d67e5173e989786e884148ab1ee5c292352200" translate="yes" xml:space="preserve">
          <source>Given the &amp;ldquo;legs&amp;rdquo; of a right triangle, return its hypotenuse.</source>
          <target state="translated">직각 삼각형의&amp;ldquo;다리&amp;rdquo;가 주어지면 빗변을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="65f0e0f7ab08e6e7d473538fe0c4ef0f86fa2404" translate="yes" xml:space="preserve">
          <source>Given the above, we intend to deprecate &lt;code&gt;matrix&lt;/code&gt; eventually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd7a5a167593ffa963306f804bdee09ec39e8fd9" translate="yes" xml:space="preserve">
          <source>Given the shape of an array, an &lt;a href=&quot;#numpy.ndindex&quot;&gt;&lt;code&gt;ndindex&lt;/code&gt;&lt;/a&gt; instance iterates over the N-dimensional index of the array. At each iteration a tuple of indices is returned, the last dimension is iterated over first.</source>
          <target state="translated">배열의 모양이 &lt;a href=&quot;#numpy.ndindex&quot;&gt; &lt;code&gt;ndindex&lt;/code&gt; &lt;/a&gt; 인스턴스의 N 차원 인덱스를 반복합니다. 각 반복에서 튜플 인덱스가 반환되고 마지막 차원이 먼저 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="6d84cece4ac6198159f79505d6fa6346cdc3c584" translate="yes" xml:space="preserve">
          <source>Given two &lt;em&gt;n&lt;/em&gt; -length arrays of integers, &lt;em&gt;l1&lt;/em&gt;, and &lt;em&gt;l2&lt;/em&gt;, return 1 if the lists are identical; otherwise, return 0.</source>
          <target state="translated">두 개의 &lt;em&gt;n&lt;/em&gt; 길이의 정수 배열이 주어지면 &lt;em&gt;l1&lt;/em&gt; 및 &lt;em&gt;L2&lt;/em&gt; , 복귀 한리스트가 동일한 경우; 그렇지 않으면 0을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="b4d93ad7919330e367279622118fac9cd99eb66a" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of the first object are strictly smaller than those of the second object. An exception is raised at shape mismatch or incorrectly ordered values. Shape mismatch does not raise if an object has zero dimension. In contrast to the standard usage in numpy, NaNs are compared, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 동일하고 첫 번째 객체의 모든 요소가 두 번째 객체의 요소보다 엄격하게 작은 지 확인하십시오. 모양이 일치하지 않거나 잘못 정렬 된 값에서 예외가 발생합니다. 개체의 치수가 0이면 모양 불일치가 발생하지 않습니다. Numpy의 표준 사용법과 달리 NaN은 비교되며 두 개체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="33ed5b3e4d203313d72bfb61344b0ef20252735e" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal (but see the Notes for the special handling of a scalar). An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90fdf131a8e234662a4baf7342d5cbfdd8815673" translate="yes" xml:space="preserve">
          <source>Given two array_like objects, check that the shape is equal and all elements of these objects are equal. An exception is raised at shape mismatch or conflicting values. In contrast to the standard usage in numpy, NaNs are compared like numbers, no assertion is raised if both objects have NaNs in the same positions.</source>
          <target state="translated">두 개의 array_like 객체가 주어지면 모양이 동일하고 이러한 객체의 모든 요소가 동일한 지 확인하십시오. 모양 불일치 또는 충돌하는 값에서 예외가 발생합니다. Numpy의 표준 사용법과 달리 NaN은 숫자처럼 비교되며 두 객체가 NaN이 동일한 위치에 있으면 어설 션이 발생하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="03c045ae56fa8df86b5ce72f657667f3cc594e54" translate="yes" xml:space="preserve">
          <source>Given two numbers, check that they are approximately equal. Approximately equal is defined as the number of significant digits that agree.</source>
          <target state="translated">두 개의 숫자가 주어지면 대략 같은지 확인하십시오. 대략적인 숫자는 동의하는 유효 자릿수로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="d9d002c83204235df23caf3ec14f4354842036c7" translate="yes" xml:space="preserve">
          <source>Given two objects (scalars, lists, tuples, dictionaries or numpy arrays), check that all elements of these objects are equal. An exception is raised at the first conflicting values.</source>
          <target state="translated">두 개의 객체 (스칼라,리스트, 튜플, 사전 또는 numpy 배열)가 주어지면이 객체의 모든 요소가 동일한 지 확인하십시오. 첫 번째 충돌 값에서 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="9d61f0f6669477d0eddf6043188e0f420dad8728" translate="yes" xml:space="preserve">
          <source>Given two polynomials &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt;, returns &lt;code&gt;a1 - a2&lt;/code&gt;. &lt;code&gt;a1&lt;/code&gt; and &lt;code&gt;a2&lt;/code&gt; can be either array_like sequences of the polynomials&amp;rsquo; coefficients (including coefficients equal to zero), or &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt;&lt;code&gt;poly1d&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">두 개의 다항식 &lt;code&gt;a1&lt;/code&gt; 과 &lt;code&gt;a2&lt;/code&gt; 가 주어지면 &lt;code&gt;a1 - a2&lt;/code&gt; 반환합니다 . &lt;code&gt;a1&lt;/code&gt; 및 &lt;code&gt;a2&lt;/code&gt; 는 다항식 계수 (0과 같은 계수 포함)의 array_like 시퀀스이거나 &lt;a href=&quot;numpy.poly1d#numpy.poly1d&quot;&gt; &lt;code&gt;poly1d&lt;/code&gt; &lt;/a&gt; 객체 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8737cb46ba6778426f460962013153a76a798f04" translate="yes" xml:space="preserve">
          <source>Given two tensors, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;, and an array_like object containing two array_like objects, &lt;code&gt;(a_axes, b_axes)&lt;/code&gt;, sum the products of &lt;code&gt;a&lt;/code&gt;&amp;rsquo;s and &lt;code&gt;b&lt;/code&gt;&amp;rsquo;s elements (components) over the axes specified by &lt;code&gt;a_axes&lt;/code&gt; and &lt;code&gt;b_axes&lt;/code&gt;. The third argument can be a single non-negative integer_like scalar, &lt;code&gt;N&lt;/code&gt;; if it is such, then the last &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;a&lt;/code&gt; and the first &lt;code&gt;N&lt;/code&gt; dimensions of &lt;code&gt;b&lt;/code&gt; are summed over.</source>
          <target state="translated">두 텐서 주어진 및 &lt;code&gt;b&lt;/code&gt; , 및 물체 array_like 두 함유 array_like 오브젝트 &lt;code&gt;(a_axes, b_axes)&lt;/code&gt; ,의 제품 합계 'S 및 &lt;code&gt;b&lt;/code&gt; 로 지정된 축상에서의 구성 요소 (부품) &lt;code&gt;a_axes&lt;/code&gt; 및 &lt;code&gt;b_axes&lt;/code&gt; . 세 번째 인수는 음이 아닌 단일 integer_like 스칼라 &lt;code&gt;N&lt;/code&gt; 일 수 있습니다 . 그러한 경우, &lt;code&gt;a&lt;/code&gt; 의 마지막 &lt;code&gt;N&lt;/code&gt; 치수 와 &lt;code&gt;b&lt;/code&gt; 의 첫 번째 &lt;code&gt;N&lt;/code&gt; 치수 가 합산됩니다. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bcbaa6d418fa3c95df027de6ff9d3bb5387a091" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#r14e6c54b746b-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3854728349ae7af32452ae7e4400a155448f9794" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#r863504129d6e-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="80ea28027215a4aa397564db3b7818bf4ec592b8" translate="yes" xml:space="preserve">
          <source>Given two vectors, &lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; and &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt;, the outer product &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is:</source>
          <target state="translated">&lt;code&gt;a = [a0, a1, ..., aM]&lt;/code&gt; 및 &lt;code&gt;b = [b0, b1, ..., bN]&lt;/code&gt; 두 벡터가 주어지면 외부 곱 &lt;a href=&quot;#rf0d57dd5badd-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4975cd64a92e88880758085eef7772db2bdb4f4d" translate="yes" xml:space="preserve">
          <source>Given:</source>
          <target state="translated">Given:</target>
        </trans-unit>
        <trans-unit id="882e099811dae6ac151e6bf8446fa672be3c6225" translate="yes" xml:space="preserve">
          <source>Gives a list of the names to exclude, such as &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;print&lt;/code&gt;&amp;hellip; If one of the input name is part of this list, an underscore character (&lt;code&gt;'_'&lt;/code&gt;) will be appended to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8020f30b057521f3745170a52c99adab4537c734" translate="yes" xml:space="preserve">
          <source>Gives a new shape to an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열에 새로운 모양을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1175f81a358d9e3f38210901aaa9e95baea2d5bc" translate="yes" xml:space="preserve">
          <source>Gives a string combining all the characters that must be deleted from the name. By default, invalid characters are &lt;code&gt;~!@#$%^&amp;amp;*()-=+~\|]}[{';:
/?.&amp;gt;,&amp;lt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6df81d1943f224253f7e8824d4f6d90b5a6fd6" translate="yes" xml:space="preserve">
          <source>Glantz, Stanton A. &amp;ldquo;Primer of Biostatistics.&amp;rdquo;, McGraw-Hill, Fifth Edition, 2002.</source>
          <target state="translated">Glantz, Stanton A.&amp;ldquo;생체 통계학 전문가&amp;rdquo;, McGraw-Hill, 5 판, 2002.</target>
        </trans-unit>
        <trans-unit id="98ce8e321806dbb3b91df4ce336400b327d82b05" translate="yes" xml:space="preserve">
          <source>Global State</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7427cf697be16a4ec1d916910128a59d920125e7" translate="yes" xml:space="preserve">
          <source>Glossary</source>
          <target state="translated">Glossary</target>
        </trans-unit>
        <trans-unit id="b5455baaf8bb77490bac48f282fc705e080b078c" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;https://github.com/numpy/numpy&lt;/a&gt; and click the &amp;ldquo;fork&amp;rdquo; button to create your own copy of the project.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e307ec71f941bf50bb0ca58211aaf38b07c21cec" translate="yes" xml:space="preserve">
          <source>Go to &lt;a href=&quot;https://github.com/numpy/numpy/releases&quot;&gt;https://github.com/numpy/numpy/releases&lt;/a&gt;, there should be a &lt;code&gt;v1.14.5
tag&lt;/code&gt;, click on it and hit the edit button for that tag. There are two ways to add files, using an editable text window and as binary uploads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a55f17953adb4e53b1ccccc7c663a01a1165b91" translate="yes" xml:space="preserve">
          <source>Go to GitHub. The new branch will show up with a green Pull Request button. Make sure the title and message are clear, concise, and self- explanatory. Then click the button to submit it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69980c4426505922b99957185231ede61f777564" translate="yes" xml:space="preserve">
          <source>Go to github and make a PR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a46869e8de50d59c9c1645cda5ce89ba58d2c65a" translate="yes" xml:space="preserve">
          <source>Go to the &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; github home at &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;NumPy github&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb3f0c82f9a531318bc29fd46c7f891f5c55b9a1" translate="yes" xml:space="preserve">
          <source>Good for wrapping large (many functions) existing C libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69bb06bd200ddbdceda42084b415b9a92259f61a" translate="yes" xml:space="preserve">
          <source>Google offers two free &lt;a href=&quot;https://developers.google.com/tech-writing&quot;&gt;Technical Writing Courses&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="823619e079c311b099f1d0e427a584eafcd6ed06" translate="yes" xml:space="preserve">
          <source>Governance</source>
          <target state="translated">Governance</target>
        </trans-unit>
        <trans-unit id="99a7f06ad80d74e23ee701e64001d24ce844ca07" translate="yes" xml:space="preserve">
          <source>Gradient is calculated only along the given axis or axes The default (axis = None) is to calculate the gradient for all the axes of the input array. axis may be negative, in which case it counts from the last to the first axis.</source>
          <target state="translated">그라디언트는 주어진 축을 따라서 만 계산됩니다. 기본값 (축 = 없음)은 입력 배열의 모든 축에 대한 그라디언트를 계산하는 것입니다. 축은 음수 일 수 있으며,이 경우 마지막 축부터 첫 번째 축까지 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="61aa58c2b09a3034acae73f52494d42574c0ca1c" translate="yes" xml:space="preserve">
          <source>Gradient is calculated using N-th order accurate differences at the boundaries. Default: 1.</source>
          <target state="translated">그라디언트는 경계에서 N 차의 정확한 차를 사용하여 계산됩니다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="ea0fcf87d2287941521d49f814fee6c705ce244c" translate="yes" xml:space="preserve">
          <source>Graphical illustration of &lt;code&gt;endpoint&lt;/code&gt; parameter:</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; 매개 변수 의 그래픽 그림 :</target>
        </trans-unit>
        <trans-unit id="bb4d80637c2066c9e7bffa72841d8f27a47b292b" translate="yes" xml:space="preserve">
          <source>Graphical illustration:</source>
          <target state="translated">그래픽 일러스트 :</target>
        </trans-unit>
        <trans-unit id="4a52fe6ab66ec52ee6bfd51d48518f7de2e194f9" translate="yes" xml:space="preserve">
          <source>Greater consistency in &lt;code&gt;assert_almost_equal&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d14a2a20cf23aef24c6cf5ba97cf49567e1739" translate="yes" xml:space="preserve">
          <source>Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; (faster optimal path approximation): ~160ms</source>
          <target state="translated">Greedy &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; (빠른 최적 경로 근사치) : ~ 160ms</target>
        </trans-unit>
        <trans-unit id="f6534be852374768c36e7beef74b1f4199fef68a" translate="yes" xml:space="preserve">
          <source>Grid-shaped arrays of evenly spaced numbers in N-dimensions.</source>
          <target state="translated">N- 차원으로 균일 한 간격의 숫자로 이루어진 격자 모양의 배열.</target>
        </trans-unit>
        <trans-unit id="d291656cb315e59b3437432c3e771768a130826d" translate="yes" xml:space="preserve">
          <source>Group 1</source>
          <target state="translated">그룹 1</target>
        </trans-unit>
        <trans-unit id="374327355d21f90b289f6f435aa2da5d797f0ae6" translate="yes" xml:space="preserve">
          <source>Group 2</source>
          <target state="translated">그룹 2</target>
        </trans-unit>
        <trans-unit id="f5ac35811e25f377d3ea665e7f41177582e5b116" translate="yes" xml:space="preserve">
          <source>Guaranteeing safe aligned access for ufuncs/setitem/casting code</source>
          <target state="translated">ufuncs / setitem / casting code에 대한 안전한 정렬 된 액세스 보장</target>
        </trans-unit>
        <trans-unit id="f454c80c182290ac641c3ab02a9edcdbe149e617" translate="yes" xml:space="preserve">
          <source>Guide to writing Tutorials (TODO)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d49ac2fe6a93b218baff7cae5e0e60393e7661a" translate="yes" xml:space="preserve">
          <source>Guide to writing reference (API) documentation: the numpydoc docstring guide</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="141d1d74d8a6b3e7a7f1418ef539a53ce746ef34" translate="yes" xml:space="preserve">
          <source>Guidelines</source>
          <target state="translated">Guidelines</target>
        </trans-unit>
        <trans-unit id="fefaa04c360e4a9e3930a2840029cc9f56039f5f" translate="yes" xml:space="preserve">
          <source>Gumbel, E. J., &amp;ldquo;Statistics of Extremes,&amp;rdquo; New York: Columbia University Press, 1958.</source>
          <target state="translated">Gumbel, EJ,&amp;ldquo;극단 통계&amp;rdquo;, 뉴욕 : Columbia University Press, 1958.</target>
        </trans-unit>
        <trans-unit id="7cf184f4c67ad58283ecb19349720b0cae756829" translate="yes" xml:space="preserve">
          <source>H</source>
          <target state="translated">H</target>
        </trans-unit>
        <trans-unit id="a23a715b33c5262fe3d1b937504a94f4b675a4b6" translate="yes" xml:space="preserve">
          <source>H() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b40b37f0341f572e1998e910b25532a92af5b558" translate="yes" xml:space="preserve">
          <source>Hack away! See &lt;a href=&quot;#editing-workflow&quot;&gt;below&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ecd57d6fb3350fcd694b91496d526594622dbb6" translate="yes" xml:space="preserve">
          <source>Half precision float: sign bit, 5 bits exponent, 10 bits mantissa</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c895f403bde1ed69e17f92c19862768cc5f5de8d" translate="yes" xml:space="preserve">
          <source>Half-precision functions</source>
          <target state="translated">반 정밀도 함수</target>
        </trans-unit>
        <trans-unit id="188b61888bd344a019188c5ddd9af8e491599b6a" translate="yes" xml:space="preserve">
          <source>Hand-generated wrappers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="636dbc8830ea645ecf6015e1f4a6dd1accda26f4" translate="yes" xml:space="preserve">
          <source>Handled by &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; 에&lt;/a&gt; 의해 처리</target>
        </trans-unit>
        <trans-unit id="7178628eaa2183565412d3981a3508d31193d4b5" translate="yes" xml:space="preserve">
          <source>Handling complex numbers</source>
          <target state="translated">복소수 처리</target>
        </trans-unit>
        <trans-unit id="0294f5e8c997832af6154aa5a34d3bc487dacc89" translate="yes" xml:space="preserve">
          <source>Handling of higher-dimensional arrays (ndim &amp;gt; 2)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29536b0ea00b813744dd07cc20d7e2d652df9775" translate="yes" xml:space="preserve">
          <source>Handling of vectors (one-dimensional arrays)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="210d84fcc7fb5c4b75800916312424c57f881c7b" translate="yes" xml:space="preserve">
          <source>Handling the &lt;code&gt;fill_value&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 처리</target>
        </trans-unit>
        <trans-unit id="7e59976d95e4c0283fbcfa38c1a2f893c3bfd15d" translate="yes" xml:space="preserve">
          <source>Handling the mask</source>
          <target state="translated">마스크 취급</target>
        </trans-unit>
        <trans-unit id="78dcc8157bbf5d134fc488651952052da7016437" translate="yes" xml:space="preserve">
          <source>Hard-coded dimensions, data-buffer-then-dimensions specification, and dimensions-then-data-buffer specification.</source>
          <target state="translated">하드 코딩 된 치수, 데이터 버퍼-치수-치수 사양 및 크기-그린-데이터-버퍼 규격.</target>
        </trans-unit>
        <trans-unit id="edfcf418a2bb124e6b8ce652d8bb7600c0be7269" translate="yes" xml:space="preserve">
          <source>Hardness of the mask</source>
          <target state="translated">마스크의 경도</target>
        </trans-unit>
        <trans-unit id="a06e8ccba0be0394ad2df2eedd04a51d1a1039c5" translate="yes" xml:space="preserve">
          <source>Has no effect, do not use.</source>
          <target state="translated">효과가 없으며 사용하지 마십시오.</target>
        </trans-unit>
        <trans-unit id="4669500ffada7a9acbed3d1bf7fceec5a930f074" translate="yes" xml:space="preserve">
          <source>Has the same shape as &lt;code&gt;element&lt;/code&gt;. The values &lt;code&gt;element[isin]&lt;/code&gt; are in &lt;code&gt;test_elements&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;element&lt;/code&gt; 와 모양이 같습니다 . &lt;code&gt;element[isin]&lt;/code&gt; 값 은 &lt;code&gt;test_elements&lt;/code&gt; 에 있습니다.</target>
        </trans-unit>
        <trans-unit id="2d794659e95706af6481a92a9285f876ae1c7d63" translate="yes" xml:space="preserve">
          <source>Have a look at the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; install help pages available from &lt;a href=&quot;https://help.github.com&quot;&gt;github help&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ab4d88ad951423d45baeab75192e5801e748751" translate="yes" xml:space="preserve">
          <source>Have a shared library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d944005e31393bd466d7655b38df2b420878ca75" translate="yes" xml:space="preserve">
          <source>Having a shared library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62bdff9b904bdda1a1ed9ed602657769f3345fd" translate="yes" xml:space="preserve">
          <source>Having compiled code also means that importing NumPy from the development sources needs some additional steps, which are explained below. For the rest of this chapter we assume that you have set up your git repo as described in &lt;a href=&quot;gitwash/index#using-git&quot;&gt;Git for development&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce7b6e9a18227e2359efe8c98f693affe997e690" translate="yes" xml:space="preserve">
          <source>Heckert, N. A. and Filliben, James J. &amp;ldquo;NIST Handbook 148: Dataplot Reference Manual, Volume 2: Let Subcommands and Library Functions&amp;rdquo;, National Institute of Standards and Technology Handbook Series, June 2003. &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&lt;/a&gt;</source>
          <target state="translated">Heckert, NA 및 Filliben, James J.&amp;ldquo;NIST 핸드북 148 : 데이터 플롯 참조 매뉴얼, 제 2 권 : 부속 명령 및 라이브러리 기능 사용&amp;rdquo;, 2003 년 6 월 National Institute of Standards and Technology Handbook Series, &lt;a href=&quot;https://www.itl.nist.gov/div898/software/dataplot/refman2/auxillar/powpdf.pdf&quot;&gt;https : //www.itl.nist. gov / div898 / software / dataplot / refman2 / auxillar / powpdf.pdf&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f25b2d1977ec1a7cc15a3fe3ee364cef6feeebb6" translate="yes" xml:space="preserve">
          <source>Help increase engagement in good discussion practice: try to identify where discussion may have broken down and provide actionable information, pointers and resources that can lead to positive change on these points.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="334c16fc9ac63595f080f7bbcdf324a43ffd5267" translate="yes" xml:space="preserve">
          <source>Helper Functions</source>
          <target state="translated">도우미 기능</target>
        </trans-unit>
        <trans-unit id="3cffecba0fc696fb0b452757e50e8d2d6aa15660" translate="yes" xml:space="preserve">
          <source>Helper for pickle.</source>
          <target state="translated">피클 도우미.</target>
        </trans-unit>
        <trans-unit id="8e0ce1fc0fa49364a15481aa8d6e74b5ad646a8c" translate="yes" xml:space="preserve">
          <source>Helper routines</source>
          <target state="translated">도우미 루틴</target>
        </trans-unit>
        <trans-unit id="591b0ee67a75bdd05c2441f5d821e72ac5abd9ff" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; may also contain signature files. Among other options (see below), the following options can be used in this mode:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad119f3969c50ae36c69dfd7a8f2258a296a9e4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;x&lt;/code&gt; is a one-dimensional array of length two whose datatype is a structure with three fields: 1. A string of length 10 or less named &amp;lsquo;name&amp;rsquo;, 2. a 32-bit integer named &amp;lsquo;age&amp;rsquo;, and 3. a 32-bit float named &amp;lsquo;weight&amp;rsquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05d939cfc36f7e101c6969543d3aa4fc112af1c5" translate="yes" xml:space="preserve">
          <source>Here appropriately means at least two tabs. It isn&amp;rsquo;t necessary to line everything up with the opening parenthesis of the function call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41762c3a1457e94bd62a7f7522c1df055434f548" translate="yes" xml:space="preserve">
          <source>Here are examples of shapes that do not broadcast:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f2d508ec85c3c97b5a1229502e255e40023669a" translate="yes" xml:space="preserve">
          <source>Here are several examples of custom weekmask values. These examples specify the &amp;ldquo;busday&amp;rdquo; default of Monday through Friday being valid days.</source>
          <target state="translated">다음은 사용자 정의 주 마스크 값의 몇 가지 예입니다. 이 예에서는 월요일부터 금요일까지의 &quot;버스 데이&quot;기본값을 유효한 날짜로 지정합니다.</target>
        </trans-unit>
        <trans-unit id="4cc8d83645ead10353d3c11cd3d81d28f5fe4bc7" translate="yes" xml:space="preserve">
          <source>Here are some examples of signatures:</source>
          <target state="translated">서명의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="c7c80754b6ccbe7d6353c18ee79360b34170e3a5" translate="yes" xml:space="preserve">
          <source>Here are some more examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edcf4d32cc0d6364c8d8b907e9c3e1d6fd286f96" translate="yes" xml:space="preserve">
          <source>Here are the date units:</source>
          <target state="translated">날짜 단위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="fcedd65241f400ab6b9cead2ae708d4ee0595afe" translate="yes" xml:space="preserve">
          <source>Here brackets &lt;code&gt;[]&lt;/code&gt; indicate an optional part, dots &lt;code&gt;...&lt;/code&gt; indicate one or more of a previous part. So, &lt;code&gt;[]...&lt;/code&gt; reads zero or more of a previous part.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a598f6524593a5ce80868abd4ad9058d26e6370" translate="yes" xml:space="preserve">
          <source>Here is a class that takes a standard ndarray that already exists, casts as our type, and adds an extra attribute.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e64dc50ed3c98bebd079533bedfe8d3d04f0a87" translate="yes" xml:space="preserve">
          <source>Here is a conversion table for which functions to use with the new iterator:</source>
          <target state="translated">새 반복자와 함께 사용할 함수에 대한 변환 표는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ae703a87217d209b99ae68f8790ce06f1f882b70" translate="yes" xml:space="preserve">
          <source>Here is a list of some useful NumPy functions and methods names ordered in categories. See &lt;a href=&quot;../reference/routines#routines&quot;&gt;Routines&lt;/a&gt; for the full list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fbbb0f1468c183a40201806e4aca9dcb3c7060" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f499cb9c92d0a44a206fb77f5f29cb1c19da659" translate="yes" xml:space="preserve">
          <source>Here is a simple copy function using the iterator. The &lt;code&gt;order&lt;/code&gt; parameter is used to control the memory layout of the allocated result, typically &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt; is desired.</source>
          <target state="translated">반복자를 사용하는 간단한 복사 기능은 다음과 같습니다. &lt;code&gt;order&lt;/code&gt; 파라미터가 할당 결과의 메모리 레이아웃을 제어하는 데 사용되는 통상적 &lt;a href=&quot;c-api.array#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 가&lt;/a&gt; 바람직하다.</target>
        </trans-unit>
        <trans-unit id="955a08b4bff95343601789d2bf6e0369ccf3f1b3" translate="yes" xml:space="preserve">
          <source>Here is a useful idiom for getting contiguous copies instead of non-contiguous views.</source>
          <target state="translated">비 연속적 뷰 대신 연속적인 사본을 얻는 데 유용한 관용구가 있습니다.</target>
        </trans-unit>
        <trans-unit id="9908262441b7f09837e1f501a21d5cc69908d615" translate="yes" xml:space="preserve">
          <source>Here is an example function which operates like a &amp;ldquo;lambda&amp;rdquo; ufunc:</source>
          <target state="translated">다음은 &quot;lambda&quot;ufunc처럼 작동하는 함수의 예입니다.</target>
        </trans-unit>
        <trans-unit id="1e3d31fc803b806643f783a13be59435e8ec2879" translate="yes" xml:space="preserve">
          <source>Here is an example outer product function:</source>
          <target state="translated">외부 제품 기능의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="3e01528c46f09f5f5d5be27407d90af619b21250" translate="yes" xml:space="preserve">
          <source>Here is how the variables above are used:</source>
          <target state="translated">위의 변수를 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1637a3171b3e141604dedb2e68519a7e5432d5d7" translate="yes" xml:space="preserve">
          <source>Here is how they can be used with a sample array:</source>
          <target state="translated">샘플 배열과 함께 사용하는 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b9c4a8ea1157853e06ffc2f25fe3f9b079de55b6" translate="yes" xml:space="preserve">
          <source>Here is how we might write an &lt;code&gt;iter_add&lt;/code&gt; function, using the Python iterator protocol:</source>
          <target state="translated">파이썬 반복자 프로토콜을 사용하여 &lt;code&gt;iter_add&lt;/code&gt; 함수를 작성하는 방법은 다음과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="82ebceae19f8e179d652196db8007bed9b016e84" translate="yes" xml:space="preserve">
          <source>Here is part of a Cython module named &lt;code&gt;add.pyx&lt;/code&gt; which implements the complex addition functions we previously implemented using f2py:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27fb417254a59c4a73469e0d501f40b87bdc16a" translate="yes" xml:space="preserve">
          <source>Here is shown a modified version of the previous Fortran code, save it as &lt;code&gt;fib3.f&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26ce084ba97f0fb601f4ee822ae6a8abc564ba7d" translate="yes" xml:space="preserve">
          <source>Here is the same function, but following the C-style pattern:</source>
          <target state="translated">다음은 동일한 기능이지만 C 스타일 패턴을 따릅니다.</target>
        </trans-unit>
        <trans-unit id="d4daff3ad7f47434c82a5051360f6f8f9147bcdd" translate="yes" xml:space="preserve">
          <source>Here the 4th and 5th rows are selected from the indexed array and combined to make a 2-D array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="879104127602f2f170c22fa52acd13e1c1a2bd91" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;newaxis&lt;/code&gt; index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional &lt;code&gt;4x1&lt;/code&gt; array. Combining the &lt;code&gt;4x1&lt;/code&gt; array with &lt;code&gt;b&lt;/code&gt;, which has shape &lt;code&gt;(3,)&lt;/code&gt;, yields a &lt;code&gt;4x3&lt;/code&gt; array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="386e95414daee162c67ba2f23612c05957e9c9fa" translate="yes" xml:space="preserve">
          <source>Here the newaxis index operator inserts a new axis into &lt;code&gt;a&lt;/code&gt;, making it a two-dimensional 4x1 array. &lt;a href=&quot;#figure-4&quot;&gt;Figure 4&lt;/a&gt; illustrates the stretching of both arrays to produce the desired 4x3 output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="948564e37f936b7d719e03a725d3b08432712a65" translate="yes" xml:space="preserve">
          <source>Here we give a list of short and useful tips.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a43ab7c4c94ff9df3968be0c3da83726730e60b3" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the listing of sum_squares.pyx:</source>
          <target state="translated">sum_squares.pyx의 목록은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4f05498cc571c5e0811d261874316f4fcd69c560" translate="yes" xml:space="preserve">
          <source>Here&amp;rsquo;s the short summary, complete TOC links are below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30babd25e27e87a901a32627496afe119a238cc9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;x&lt;/code&gt; is a dictionary mapping keys to values, in this case the integer 1 to the string &amp;ldquo;one&amp;rdquo;, and the string &amp;ldquo;two&amp;rdquo; to the list &lt;code&gt;[1, 2]&lt;/code&gt;. The values may be accessed using their corresponding keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bb0a1675e1ab72957846b002b2ccbd5daaee32d" translate="yes" xml:space="preserve">
          <source>Here, I&amp;rsquo;ve used the built-in enumerate iterator to return the iterator index as well as the value.</source>
          <target state="translated">여기서는 내장 열거 반복자를 사용하여 반복 색인과 값을 반환했습니다.</target>
        </trans-unit>
        <trans-unit id="423ebc2c2e7601fe55f4484a7fb3dc69ce69a81b" translate="yes" xml:space="preserve">
          <source>Here, U is drawn from the uniform distribution over (0,1].</source>
          <target state="translated">여기서 U는 (0,1]에 대한 균일 분포에서 도출됩니다.</target>
        </trans-unit>
        <trans-unit id="b81e3c833ac1c20cf33999c717a7683fc509fd53" translate="yes" xml:space="preserve">
          <source>Here, you grabbed a section of your array from index position 3 through index position 8.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9958f2320c4c020dbe0ba918682ede328e6342d6" translate="yes" xml:space="preserve">
          <source>Hermite</source>
          <target state="translated">Hermite</target>
        </trans-unit>
        <trans-unit id="3e97b960fb6669c7ce3d868bc1ee39fbd840fc5f" translate="yes" xml:space="preserve">
          <source>Hermite (class in numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666fe7ebc09d7395dcf2297ae16799bfb275707b" translate="yes" xml:space="preserve">
          <source>Hermite Class</source>
          <target state="translated">은자 반</target>
        </trans-unit>
        <trans-unit id="78bcd4fcaaa0c27a38e217337ec719b8d794b08b" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="translated">&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt; 모듈, &quot;물리학 자&quot;( numpy.polynomial.hermite )</target>
        </trans-unit>
        <trans-unit id="20e36a23caee8661ea5087eb6b2833159c8b55f9" translate="yes" xml:space="preserve">
          <source>Hermite Module, &amp;ldquo;Physicists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="translated">은자 모듈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="4e51cfc7050a81e8b6b2247a7d2dcbdd5d5665a8" translate="yes" xml:space="preserve">
          <source>Hermite Module, “Physicists’” (numpy.polynomial.hermite)</source>
          <target state="translated">은자 모듈, &quot;물리학 자&quot;(numpy.polynomial.hermite)</target>
        </trans-unit>
        <trans-unit id="7e732e7a329c7f9da3eef2d091dd68d62fa1ae1a" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4d4eab91a42ee672e761807e2ccfac51f95da47" translate="yes" xml:space="preserve">
          <source>Hermite Series, &amp;ldquo;Physicists&amp;rdquo; (numpy.polynomial.hermite)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="321f1ab84f3ad6f4602b6463648250d7c017db66" translate="yes" xml:space="preserve">
          <source>Hermite coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 은자 계수 는 &lt;code&gt;1*H_0(x) + 2*H_1(X) + 3*H_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="030c6d9cd5a3996624a5dedd47cce0a8b255a2e1" translate="yes" xml:space="preserve">
          <source>Hermite coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">은자 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdaeee3c1bfcab3d833e2cd601bbef119c7ca375" translate="yes" xml:space="preserve">
          <source>Hermite series</source>
          <target state="translated">은자 시리즈</target>
        </trans-unit>
        <trans-unit id="5d7c6da49173b96e3654eaebdb82df4267a07cd8" translate="yes" xml:space="preserve">
          <source>Hermite series coefficients of the integral.</source>
          <target state="translated">적분의 은자 (Hermite) 계열 계수.</target>
        </trans-unit>
        <trans-unit id="f178c08ed0e44e86c3dcdcdd94165f4d2159704d" translate="yes" xml:space="preserve">
          <source>Hermite series of power.</source>
          <target state="translated">은자 시리즈의 힘.</target>
        </trans-unit>
        <trans-unit id="4b1ee605707018d73fef71e944f33b064cb30198" translate="yes" xml:space="preserve">
          <source>Hermite series of the derivative.</source>
          <target state="translated">파생 품의 은자 시리즈.</target>
        </trans-unit>
        <trans-unit id="f3b525d4a933addff05d89e23fb102c4771100af" translate="yes" xml:space="preserve">
          <source>Hermite series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 Hermite 시리즈.</target>
        </trans-unit>
        <trans-unit id="f15ba129dfce798b05af2ecf87c4c56e141a51c6" translate="yes" xml:space="preserve">
          <source>Hermite weight function</source>
          <target state="translated">은둔 무게 기능</target>
        </trans-unit>
        <trans-unit id="e91ac76ec50377772a4d0a0fad317ac36bda67d9" translate="yes" xml:space="preserve">
          <source>Hermite.__call__()</source>
          <target state="translated">Hermite.__call__()</target>
        </trans-unit>
        <trans-unit id="e00caea2e8b760013383648bd7a0c8356ad2d21a" translate="yes" xml:space="preserve">
          <source>Hermite.basis()</source>
          <target state="translated">Hermite.basis()</target>
        </trans-unit>
        <trans-unit id="510f491be62b2a7e3419873aabcc929cba4aad0a" translate="yes" xml:space="preserve">
          <source>Hermite.cast()</source>
          <target state="translated">Hermite.cast()</target>
        </trans-unit>
        <trans-unit id="0bbb26adb9485391c59073a0150f1aeb28250175" translate="yes" xml:space="preserve">
          <source>Hermite.convert()</source>
          <target state="translated">Hermite.convert()</target>
        </trans-unit>
        <trans-unit id="46e59fa3efb39aa8de99b77595a66c5aca6f95af" translate="yes" xml:space="preserve">
          <source>Hermite.copy()</source>
          <target state="translated">Hermite.copy()</target>
        </trans-unit>
        <trans-unit id="150883af29979fdad32a1485afaa265ae485116d" translate="yes" xml:space="preserve">
          <source>Hermite.cutdeg()</source>
          <target state="translated">Hermite.cutdeg()</target>
        </trans-unit>
        <trans-unit id="6e3addaaf8a990d63bd9644e879a45bfaaa3d048" translate="yes" xml:space="preserve">
          <source>Hermite.degree()</source>
          <target state="translated">Hermite.degree()</target>
        </trans-unit>
        <trans-unit id="1898e27484be79666c2d0d0671ff99bb73c61fb0" translate="yes" xml:space="preserve">
          <source>Hermite.deriv()</source>
          <target state="translated">Hermite.deriv()</target>
        </trans-unit>
        <trans-unit id="74d98daf1082d857dc8043ef7d611943987bcbf6" translate="yes" xml:space="preserve">
          <source>Hermite.domain</source>
          <target state="translated">Hermite.domain</target>
        </trans-unit>
        <trans-unit id="69a9477b050cf5e84517bc3ba4b2540b289809dd" translate="yes" xml:space="preserve">
          <source>Hermite.fit()</source>
          <target state="translated">Hermite.fit()</target>
        </trans-unit>
        <trans-unit id="ee377bb8277d3cc87539518382039049d3434ab2" translate="yes" xml:space="preserve">
          <source>Hermite.fromroots()</source>
          <target state="translated">Hermite.fromroots()</target>
        </trans-unit>
        <trans-unit id="f3d364e431135afb3032332cc59ddec1d0087c65" translate="yes" xml:space="preserve">
          <source>Hermite.has_samecoef()</source>
          <target state="translated">Hermite.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="4f5a15af827e1a34e56c335924bc117f06d9550b" translate="yes" xml:space="preserve">
          <source>Hermite.has_samedomain()</source>
          <target state="translated">Hermite.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="5c6b35ea3f6249366ad14a64bf61b1e2f4ef3fa2" translate="yes" xml:space="preserve">
          <source>Hermite.has_sametype()</source>
          <target state="translated">Hermite.has_sametype()</target>
        </trans-unit>
        <trans-unit id="51595f8a76f511b51c25db7ca6799c30af573ff1" translate="yes" xml:space="preserve">
          <source>Hermite.has_samewindow()</source>
          <target state="translated">Hermite.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="fae0683eb07169c7856c805873bd384998f4ce23" translate="yes" xml:space="preserve">
          <source>Hermite.identity()</source>
          <target state="translated">Hermite.identity()</target>
        </trans-unit>
        <trans-unit id="6d7f1a135c9fd7bdb20e45551f21a01a1b98749d" translate="yes" xml:space="preserve">
          <source>Hermite.integ()</source>
          <target state="translated">Hermite.integ()</target>
        </trans-unit>
        <trans-unit id="87c4ac5818fcc034b0a86594470677888839404b" translate="yes" xml:space="preserve">
          <source>Hermite.linspace()</source>
          <target state="translated">Hermite.linspace()</target>
        </trans-unit>
        <trans-unit id="e4e8e042f2bff68022c1506a796ae1f2b1a45e62" translate="yes" xml:space="preserve">
          <source>Hermite.mapparms()</source>
          <target state="translated">Hermite.mapparms()</target>
        </trans-unit>
        <trans-unit id="dd2d324dc15bd07b8d8eba7c1b9a303c6e61cbe9" translate="yes" xml:space="preserve">
          <source>Hermite.roots()</source>
          <target state="translated">Hermite.roots()</target>
        </trans-unit>
        <trans-unit id="357de88ac6a59383fa4db68dc02a30a97aa55b31" translate="yes" xml:space="preserve">
          <source>Hermite.trim()</source>
          <target state="translated">Hermite.trim()</target>
        </trans-unit>
        <trans-unit id="ded6de456aef1c9f3f0dbb030eecbec360a2a3d9" translate="yes" xml:space="preserve">
          <source>Hermite.truncate()</source>
          <target state="translated">Hermite.truncate()</target>
        </trans-unit>
        <trans-unit id="bfa82105a95ddf719538cbbbc2136f5bdc652b85" translate="yes" xml:space="preserve">
          <source>HermiteE</source>
          <target state="translated">HermiteE</target>
        </trans-unit>
        <trans-unit id="213b3add1699deb17fd0362b28ee9eaa1e08297e" translate="yes" xml:space="preserve">
          <source>HermiteE (class in numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6628b3304670336395ae6732f06085678ac90c72" translate="yes" xml:space="preserve">
          <source>HermiteE Class</source>
          <target state="translated">은자 클래스</target>
        </trans-unit>
        <trans-unit id="da640bfdcf0affcdb1cb3e699294b822aff50f4d" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="translated">HermiteE 모듈,&amp;ldquo;Probabilists&amp;rdquo;( &lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="93c34719e313928a50611a43ea25a148a84b264b" translate="yes" xml:space="preserve">
          <source>HermiteE Module, &amp;ldquo;Probabilists&amp;rsquo;&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="56f6680ec7b317dd6ae3f4dbb7e9720ab2e6af02" translate="yes" xml:space="preserve">
          <source>HermiteE Module, “Probabilists’” (numpy.polynomial.hermite_e)</source>
          <target state="translated">HermiteE 모듈, &quot;Probabilists&quot;(numpy.polynomial.hermite_e)</target>
        </trans-unit>
        <trans-unit id="a7da5893b105551d489e12a654065cc1aa5b0de0" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (&lt;code&gt;numpy.polynomial.hermite_e&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01652b3974c2bf789bf8511d4ddd036a45eab615" translate="yes" xml:space="preserve">
          <source>HermiteE Series, &amp;ldquo;Probabilists&amp;rdquo; (numpy.polynomial.hermite_e)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7090e745bd4427b0619b5249b32836cf9e710c91" translate="yes" xml:space="preserve">
          <source>HermiteE coefficients in order of increasing degree, i.e, &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 의 HermiteE 계수 는 &lt;code&gt;1*He_0(x) + 2*He_1(X) + 3*He_2(x)&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="8fdce93a022f8c8da6190fdc0f7e0fa2783e7c6d" translate="yes" xml:space="preserve">
          <source>HermiteE series</source>
          <target state="translated">HermiteE 시리즈</target>
        </trans-unit>
        <trans-unit id="f8a256fa19026169a866b5809900fc5fb915e807" translate="yes" xml:space="preserve">
          <source>HermiteE weight function.</source>
          <target state="translated">은자 무게 기능.</target>
        </trans-unit>
        <trans-unit id="f2a1b68f303ab3a67abc7b2e4c4c8451183b7095" translate="yes" xml:space="preserve">
          <source>HermiteE.__call__()</source>
          <target state="translated">HermiteE.__call__()</target>
        </trans-unit>
        <trans-unit id="45c27d16e911c80a7d363f3c39ba54997fd020cd" translate="yes" xml:space="preserve">
          <source>HermiteE.basis()</source>
          <target state="translated">HermiteE.basis()</target>
        </trans-unit>
        <trans-unit id="b45b6525bda44ccf736a4ef59137ed1b81c51100" translate="yes" xml:space="preserve">
          <source>HermiteE.cast()</source>
          <target state="translated">HermiteE.cast()</target>
        </trans-unit>
        <trans-unit id="4ddefc1ce033e171e5d4661134688bd82e8bc5af" translate="yes" xml:space="preserve">
          <source>HermiteE.convert()</source>
          <target state="translated">HermiteE.convert()</target>
        </trans-unit>
        <trans-unit id="002903a3a64a57beced04a1c5706dd609af411f5" translate="yes" xml:space="preserve">
          <source>HermiteE.copy()</source>
          <target state="translated">HermiteE.copy()</target>
        </trans-unit>
        <trans-unit id="b24cf643ce7571c11b38beb07f1dba60d0898965" translate="yes" xml:space="preserve">
          <source>HermiteE.cutdeg()</source>
          <target state="translated">HermiteE.cutdeg()</target>
        </trans-unit>
        <trans-unit id="564634c0d69d527c3b8fbcf352579c91cc6babc0" translate="yes" xml:space="preserve">
          <source>HermiteE.degree()</source>
          <target state="translated">HermiteE.degree()</target>
        </trans-unit>
        <trans-unit id="b0998c48dfd3e6da9f8d9a094fe9026de37d9068" translate="yes" xml:space="preserve">
          <source>HermiteE.deriv()</source>
          <target state="translated">HermiteE.deriv()</target>
        </trans-unit>
        <trans-unit id="e3b7e4ce40140bfad9d15417ff37a5918c3d9ee7" translate="yes" xml:space="preserve">
          <source>HermiteE.domain</source>
          <target state="translated">HermiteE.domain</target>
        </trans-unit>
        <trans-unit id="b9a9cf1e6530dd58c8fe754b4c5e909f051929ea" translate="yes" xml:space="preserve">
          <source>HermiteE.fit()</source>
          <target state="translated">HermiteE.fit()</target>
        </trans-unit>
        <trans-unit id="4a10eb67a6e8118b67d08f9c1672e5c1ef31f7e7" translate="yes" xml:space="preserve">
          <source>HermiteE.fromroots()</source>
          <target state="translated">HermiteE.fromroots()</target>
        </trans-unit>
        <trans-unit id="f215586092039a3f249d19a38ef5f2e5c8b9fe46" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samecoef()</source>
          <target state="translated">HermiteE.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="e303961ece2b00de2ea59d3add859f3b9afba3be" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samedomain()</source>
          <target state="translated">HermiteE.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="56c531828abb17c1fa8561b9e8274772104c7875" translate="yes" xml:space="preserve">
          <source>HermiteE.has_sametype()</source>
          <target state="translated">HermiteE.has_sametype()</target>
        </trans-unit>
        <trans-unit id="f597206a0348307571c5766a04f0329e0e5977a6" translate="yes" xml:space="preserve">
          <source>HermiteE.has_samewindow()</source>
          <target state="translated">HermiteE.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="edecbdf0322d9c36d15b82f596749f9baa998818" translate="yes" xml:space="preserve">
          <source>HermiteE.identity()</source>
          <target state="translated">HermiteE.identity()</target>
        </trans-unit>
        <trans-unit id="50879495edc6ec638987e4aab2fb5c3ff2693ffc" translate="yes" xml:space="preserve">
          <source>HermiteE.integ()</source>
          <target state="translated">HermiteE.integ()</target>
        </trans-unit>
        <trans-unit id="7644c7d4879b67345881eccc21f74f5ac1d76221" translate="yes" xml:space="preserve">
          <source>HermiteE.linspace()</source>
          <target state="translated">HermiteE.linspace()</target>
        </trans-unit>
        <trans-unit id="71240e92395878a17c98ad6cabf8e728e1e375a7" translate="yes" xml:space="preserve">
          <source>HermiteE.mapparms()</source>
          <target state="translated">HermiteE.mapparms()</target>
        </trans-unit>
        <trans-unit id="918dc10943107e5fa1f93651ccb4cc1d4ca399a0" translate="yes" xml:space="preserve">
          <source>HermiteE.roots()</source>
          <target state="translated">HermiteE.roots()</target>
        </trans-unit>
        <trans-unit id="6c5620ec0bf2dc54449e61b049184a2294791751" translate="yes" xml:space="preserve">
          <source>HermiteE.trim()</source>
          <target state="translated">HermiteE.trim()</target>
        </trans-unit>
        <trans-unit id="8b9f703c9558cb71c68ad02c3049b60b8b59198b" translate="yes" xml:space="preserve">
          <source>HermiteE.truncate()</source>
          <target state="translated">HermiteE.truncate()</target>
        </trans-unit>
        <trans-unit id="a2691f3b6c74bc9be228ebe1bfd4aaa8b167edac" translate="yes" xml:space="preserve">
          <source>Hermite_e series coefficients of the integral.</source>
          <target state="translated">적분의 Hermite_e 시리즈 계수.</target>
        </trans-unit>
        <trans-unit id="cb6305ebb37efa97b74f55f04adb878c2cfd6823" translate="yes" xml:space="preserve">
          <source>Hermitian (symmetric if all elements are real), positive-definite input matrix.</source>
          <target state="translated">Hermitian (모든 요소가 실제 인 경우 대칭), 양의 한정된 입력 행렬.</target>
        </trans-unit>
        <trans-unit id="559550c9b0251579dbef6add2f3cc35db020af9a" translate="yes" xml:space="preserve">
          <source>Hermitian FFTs</source>
          <target state="translated">은둔자 FFT</target>
        </trans-unit>
        <trans-unit id="d6600c2342a8053253425f9846737e2bf29ea82c" translate="yes" xml:space="preserve">
          <source>Hermitian or real symmetric matrices whose eigenvalues and eigenvectors are to be computed.</source>
          <target state="translated">고유 값과 고유 벡터를 계산할 수있는 은자 또는 실수 대칭 행렬.</target>
        </trans-unit>
        <trans-unit id="2e330e11eac48710d52dc39e422ecae197585b4d" translate="yes" xml:space="preserve">
          <source>High-order polynomials may oscillate wildly:</source>
          <target state="translated">고차 다항식이 크게 진동 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4be99f1c1557117aa5c64902eb10d5b0886a0d69" translate="yes" xml:space="preserve">
          <source>Higher dimensions</source>
          <target state="translated">더 큰 치수</target>
        </trans-unit>
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">하라 모토 히로시, 마츠모토 마코 모토, 니시무라 타쿠 지, 프랑수아 판네, 피에르 레쿠 에르 20, No. 3, 2008 년 여름, pp. 385-390.</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">호너의 계획 &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다항식을 평가하는 데 사용됩니다. 그럼에도 불구하고 높은 다항식의 경우 반올림 오류로 인해 값이 정확하지 않을 수 있습니다. 신중하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">차원의 끝에서 시작으로 다시 이동하는 데 필요한 바이트 수 참고 &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; 있지만,이 최적화 여기에 저장된다.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">한 번의 실행 후 몇 번의 시도가 성공 했습니까?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">유효하지 않은 날짜를 처리하는 방법 기본값은 '올림'입니다.</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 레벨에서 배열 반복자를 사용하는 방법은 이후 섹션에서 자세히 설명합니다. 일반적으로 반복자 객체의 내부 구조에 신경 쓸 필요가 없으며 매크로 &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) 또는 &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index) 매크로를 사용하여 상호 작용할 필요가 없습니다 . 이 매크로는 모두 인수 필요 &lt;em&gt;가&lt;/em&gt; 될 &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">그러나 배열 스칼라는 변경할 수 없으므로 배열 스칼라 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">그러나 2D 배열의 경우 &lt;code&gt;tolist&lt;/code&gt; 는 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">그러나 단계 길이가 &lt;strong&gt;복소수&lt;/strong&gt; (예 : 5j) 인 경우, 그 크기의 정수 부분은 시작 값과 중지 값 사이에 작성할 포인트 수를 지정하는 것으로 해석되며 여기서 중지 값 &lt;strong&gt;은 포함&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt; 에서 작동하는 필터 메커니즘도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">그러나 위의 인덱싱 배열은 반복되기 때문에 브로드 캐스트를 사용하여 ( &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; 와 같은 작업 비교 )이를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">그러나이 클래스는 직접 실행되지 않습니다. 오히려 여러 다른 파이썬 클래스에 대한 기본 클래스로 사용되며 각각은 특정 데이터 유형에 고유합니다. &lt;code&gt;VectorTestCase&lt;/code&gt; 의 클래스를 저장 입력 정보에 대한 두 개의 문자열 :</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">요소 별 쌍곡 코사인.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">쌍곡선 함수</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">요소 별 쌍곡 사인.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">Bronshtein, KA Semendyayev 및 KA Hirsch (Eng. trans. Ed.), 뉴욕 &lt;em&gt;핸드북 수학&lt;/em&gt; , Van Nostrand Reinhold Co., 1985, pg. 720.</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">(양의) 무한대의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">NaN (Not a Number)의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">음의 무한대의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">음수 0의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">양수 0의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">ISO / IEC 표준 9899 : 1999,&amp;ldquo;프로그래밍 언어 C&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">신원 기능.</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">'왼쪽'이면 발견 된 첫 번째 적합한 위치의 색인이 제공됩니다. 'right'이면 마지막 인덱스를 반환하십시오. 어떠한 적절한 인덱스가없는 경우 (N은의 길이 0 또는 N 리턴 &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">'out'이 None (기본값)이면 초기화되지 않은 리턴 배열이 작성됩니다. 그런 다음 출력 배열은 브로드 캐스트 'where'가 True 인 위치에서 ufunc의 결과로 채워집니다. 'where'가 스칼라 True (기본값)이면 채워지는 전체 출력에 해당합니다. 명시 적으로 채워지지 않은 출력은 초기화되지 않은 값으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">/ NULL 값을 전달하는 경우 -1 &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; 및 &lt;code&gt;buffersize&lt;/code&gt; , 그것은 동등 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; 가&lt;/a&gt; #define에 의해 정의되어 여부에 관계없이의 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; 이&lt;/a&gt; 되면, C-API는 선언한다 &lt;code&gt;extern void**&lt;/code&gt; 가 다른 컴파일 단위에서 정의 될 것으로 예상된다, 그래서.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; 이&lt;/a&gt; 불렀다, 당신은 플래그를 활성화 할 수 있습니다 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 을&lt;/a&gt; . 이 플래그는 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 허용되지 않으므로이 함수는 &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 기능을 사용하도록 제공됩니다 . 이 기능은 반복기를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; 가&lt;/a&gt; #define에 의해 정의되어 있지만 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; 이&lt;/a&gt; 아니다는 C-API는 선언한다 &lt;code&gt;void**&lt;/code&gt; 가 다른 컴파일 단위로 표시됩니다 그래서.</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 설정되어 DTYPE이 일치하지 않는 경우, 배열은 복사 :</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 가 1 차원이 아닌 경우 출력에도이 차원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">하면 &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 문자열이고, 그것이 콤마 컬럼 분리 공간 행 분리 세미콜론 매트릭스로 해석된다.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">경우에 &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 이미 인 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; ,이 플래그는 데이터가 (기본)에 복사할지 여부를 결정하거나, 뷰가 구성되어 있는지.</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">경우 &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , &lt;code&gt;reps&lt;/code&gt; 승격된다 그것의 1 사전이 출원하여 .ndim. 따라서 (2, 3, 4, 5) 모양 &lt;code&gt;A&lt;/code&gt; 의 경우 (2, 2) 의 &lt;code&gt;reps&lt;/code&gt; 은 (1, 1, 2, 2)로 처리됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">경우 &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 를 D 차원 새로운 축을 붙이는 것으로 의해 촉진된다. 따라서 2D 복제의 경우 모양 (3,) 배열이 (1, 3)으로, 3D 복제의 경우 모양 (1, 1, 3)으로 승격됩니다. 이것이 원하는 동작이 아닌 경우이 함수를 호출하기 전에 &lt;code&gt;A&lt;/code&gt; 를 d 차원으로 수동으로 승격하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">경우 &lt;code&gt;False&lt;/code&gt; , 결과는 각 빈에있는 샘플의 수를 포함합니다. 경우 &lt;code&gt;True&lt;/code&gt; , 결과 확률의 값 &lt;em&gt;밀도&lt;/em&gt; 되도록 정규화 빈의 함수, &lt;em&gt;적분&lt;/em&gt; 범위에서 히스토그램 값들의 합이 1과 같지 않을 것이다 1 주되어 선택된다 폭 화합의 빈들 않는; 확률 &lt;em&gt;질량&lt;/em&gt; 함수 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">경우 &lt;code&gt;None&lt;/code&gt; (기본값)은 모든 상수 가정하지 않습니다 제로가 될 수 있습니다. &lt;code&gt;m = 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; , 스왑이 자리에서 바이트, 기본값은 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;precision&lt;/code&gt; 자릿수는 소수점 이하 자릿수 (앞의 0 포함)를 나타냅니다. &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;code&gt;precision&lt;/code&gt; 는 선행 0을 무시하고 소수점 앞뒤에있는 유효 유효 자릿수의 총 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; 후 출력하는 경우의 수를 결정하는 제 1 함수 호출 캐시 &lt;code&gt;otypes&lt;/code&gt; 이 설치되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 신중하게 반올림하여 같은 유형의 다른 값에서 부동 소수점 숫자를 고유하게 식별하는 가장 짧은 표현을 제공하는 숫자 생성 전략을 사용하십시오. &lt;code&gt;precision&lt;/code&gt; 가 생략 된 경우 필요한 모든 자릿수를 인쇄하고 그렇지 않으면 자릿수 생성이 잘립니다. &lt;code&gt;precision&lt;/code&gt; 숫자 나머지 값이 반올림됩니다. 경우 &lt;code&gt;False&lt;/code&gt; , 숫자 무한 밀도 값을 인쇄 한 후 정지 것처럼 생성 &lt;code&gt;precision&lt;/code&gt; 숫자, 나머지 값을 반올림.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 신중하게 반올림하여 같은 유형의 다른 값에서 부동 소수점 숫자를 고유하게 식별하는 가장 짧은 표현을 제공하는 숫자 생성 전략을 사용하십시오. &lt;code&gt;precision&lt;/code&gt; 가 생략 된 경우 , 필요한 모든 숫자를 인쇄하십시오. 그렇지 않으면 &lt;code&gt;precision&lt;/code&gt; 후에 숫자 생성이 잘립니다. 자릿수 나머지 값이 반올림됩니다. 경우 &lt;code&gt;False&lt;/code&gt; , 숫자 무한 밀도 값을 인쇄 한 후 정지 것처럼 생성 &lt;code&gt;precision&lt;/code&gt; 숫자, 나머지 값을 반올림.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 의 다음 컬럼 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형상 (xdeg + 1 ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형상 (xdeg + 1 ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">경우 &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; 채우기 값을 반환, 그렇지 않으면 None을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">경우 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 다음에 의해 지정된 차원 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 제거되고, 새로운 축은 대각선에 대응하는 단부에 삽입 하였다.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">경우 &lt;code&gt;a.ndim&lt;/code&gt; 가 0이고, 중첩 된 목록의 깊이가 0 그 이후, 모든의 목록,하지만 간단한 파이썬 스칼라되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">경우 &lt;code&gt;a.shape&lt;/code&gt; 는 (5,1)이다 &lt;code&gt;b.shape&lt;/code&gt; 가 있다 (1,6), &lt;code&gt;c.shape&lt;/code&gt; 는 (6)이고 &lt;code&gt;d.shape&lt;/code&gt; 는 그 () 그렇다 &lt;em&gt;D는&lt;/em&gt; 다음 스칼라 , &lt;em&gt;B&lt;/em&gt; , &lt;em&gt;C&lt;/em&gt; , 및 &lt;em&gt;D는&lt;/em&gt; 치수 (5,6)에 대한 모든 캐스트 가능한이고; 과&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 스칼라가 아닌 경우 마지막 차원이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 각각의 선택 배열이 모두 같은 모양으로 브로드 캐스트되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 자신의 데이터 또는 참조 또는 그것에 전망을 보유하고 있지 않습니다 존재하고, 데이터 메모리 변경해야합니다. PyPy 만 해당 : 데이터 메모리에 대한 참조 또는 뷰가 존재하는지 판별 할 수있는 확실한 방법이 없으므로 데이터 메모리를 변경해야하는 경우 항상 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 두 개 이상의 차원이에 설명 된대로 다음 방송 규칙이 적용 &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;번에 여러 행렬에 선형 대수학&lt;/a&gt; . 이는 SVD가 &quot;스택&quot;모드에서 작동한다는 것을 의미합니다. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원 의 모든 인덱스를 반복하며 각 조합에 대해 SVD는 마지막 두 인덱스에 적용됩니다. 행렬 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; 또는 &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; 를 사용하여 분해에서 재구성 할 수 있습니다 . 합니다 ( &lt;code&gt;@&lt;/code&gt; 의 연산자는 함수로 대체 될 수 &lt;code&gt;np.matmul&lt;/code&gt; 3.5 이하 파이썬 버전).</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 차원이 두 개를 초과 하면 axis1 및 axis2로 지정된 축을 사용하여 트레이스가 반환되는 2 차원 하위 ​​배열을 결정합니다. 생성 된 어레이의 형상은 동일하다 와 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 제거. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 1-D의 함수이다 &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; 것과 동일하다 &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; 여기서, &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 되는 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 제로와마다 배치 다른 요소 : &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 2-D이고, 대각선의 반환 &lt;code&gt;a&lt;/code&gt; 오프셋으로 주어진, 즉, 폼 요소들의 집합 &lt;code&gt;a[i, i+offset]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 의 차원이 두 개를 초과 하면 &lt;code&gt;axis1&lt;/code&gt; 및 &lt;code&gt;axis2&lt;/code&gt; 로 지정된 축 이 대각선이 반환되는 2 차원 하위 ​​배열을 결정하는 데 사용됩니다. 결과 배열의 모양은 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 를 제거 하고 결과 대각선의 크기와 동일한 오른쪽에 인덱스를 추가하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 1, 리턴 오프셋은 주어진 요소의 합 즉, 2-D, 그 대각선을 따라 합 &lt;code&gt;a[i,i+offset]&lt;/code&gt; 모든 I에 대해.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 2-D이고, 대각선을 따라 합이 반환된다. 경우 &lt;code&gt;a&lt;/code&gt; 큰 크기를 가지며, 사선을 따라 합계 다음 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 다음 2-D는 대각선을 함유하는 1-D 배열이다 동일한 유형의 &lt;code&gt;a&lt;/code&gt; 않는 리턴 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 1-D 어레이보다는 (2-D)이 경우에, &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 리턴 이전 버전과의 호환성을 유지하기 위해.</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;matrix&lt;/code&gt; 객체 (AN 반대로 &lt;code&gt;ndarray&lt;/code&gt; )하고 있으므로 모든 리턴 값이다.</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 의 하위 클래스 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 그 클래스는 보존된다. 입력이 이미 &lt;code&gt;ndarray&lt;/code&gt; 이면 복사가 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; ND 어레이이고, &lt;code&gt;b&lt;/code&gt; 는 1-D 어레이, 그것의 마지막 축 위에 합 제품 및 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; ND 어레이이고, &lt;code&gt;b&lt;/code&gt; (여기서 멀티 디스크 배열 &lt;code&gt;M&amp;gt;=2&lt;/code&gt; )가 마지막 축 위에 합 제품 및 마지막에서 두 번째 축 &lt;code&gt;b&lt;/code&gt; : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 복잡 켤레 복소수는 내적을 계산하기 전에 촬영됩니다.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 하지 않은 것입니다 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 자체가 반환됩니다. 경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;fill_value&lt;/code&gt; 를가 없음입니다, &lt;code&gt;fill_value&lt;/code&gt; 를가 로 설정되어 &lt;code&gt;a.fill_value&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 사각형이 나 반전에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 진짜, 유형 &lt;code&gt;a&lt;/code&gt; 출력에 사용됩니다. 경우 &lt;code&gt;a&lt;/code&gt; 복잡한 요소를 가지고, 반환 타입은 부동이다.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 단수이거나 '사각형'이 아닌 경우 (위의 의미에서).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 단수이거나 정사각형이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 에 모양 속성이없는 경우 (즉, ndarray가 아님)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;axes&lt;/code&gt; 마지막 축보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 0 만 행이 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 1 또는 -1 열만이 마스크된다.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 없음입니다, 행 &lt;em&gt;과&lt;/em&gt; 열이 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 정수이고, 그것의 축 지정 &lt;code&gt;x&lt;/code&gt; 벡터 기준을 계산을 따라. 경우 &lt;code&gt;axis&lt;/code&gt; 2- 튜플, 그것은 2-D 행렬을 길게 축을 지정하고, 이들 매트릭스의 매트릭스 기준이 계산된다. 경우 &lt;code&gt;axis&lt;/code&gt; 중에 어느 한 다음 벡터 놈 없다 (경우 &lt;code&gt;x&lt;/code&gt; 1-D이다) 또는 매트릭스 표준은 (경우 &lt;code&gt;x&lt;/code&gt; 2-D이다)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 주어, 가변 인자의 수는 축의 수와 같아야한다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 의 마지막 축보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 및 압착되는 축 길이가 1이 아닌</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 행렬이고, 모든 배열 행렬 결과로서 리턴된다.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 이 아래 목록의 문자열 인 경우 &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; 는 선택된 방법을 사용하여 최적의 bin 너비와 결과적으로 요청 된 범위 내에있는 데이터에서 bin 수 ( 추정자에 대한 자세한 내용 은 &lt;code&gt;Notes&lt;/code&gt; 참조 )를 계산합니다. 빈 너비가 범위의 실제 데이터에 최적 인 반면 빈 수는 빈 부분을 포함하여 전체 범위를 채우도록 계산됩니다. 시각화를 위해 '자동'옵션을 사용하는 것이 좋습니다. 자동 출력 함 크기 선택에는 가중치 데이터가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 문자열이고, 그것이 의해 정의 된 최적 빈의 폭을 계산하기 위해 사용되는 방법을 정의 &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 의 int는, 그것 (기본적으로, 10)을 소정 범위가 동일한 폭 빈들의 수를 정의한다. 경우 &lt;code&gt;bins&lt;/code&gt; 시퀀스는, 그 불균일 함을 허용 폭의 우측 에지를 포함 함 가장자리 일정하게 증가하는 배열을 정의한다.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 의 int는, 그것 (기본적으로, 10)을 소정 범위가 동일한 폭 빈들의 수를 정의한다. 경우 &lt;code&gt;bins&lt;/code&gt; 시퀀스이며, 그 불균일 함을 허용 폭의 우측 가장자리를 포함하는 빈 에지를 정의한다.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 단조롭지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 없음, 만없는 &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;order&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 버퍼 인터페이스를 노출하는 객체입니다, 모든 키워드는 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">경우 &lt;code&gt;buffersize&lt;/code&gt; 제로, 크기 버퍼 기본 그렇지 않으면 사용에 대한 버퍼의 얼마나 큰 지정, 사용됩니다. 4096 또는 8192와 같이 2의 거듭 제곱 버퍼가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 미만 3 차원이, 사람은 암시 적으로는 3-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [3 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 세 개 미만의 크기를 가지고, 사람은 암시 적으로는 3-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [3 :] + x.shape + y.shape + z.shape입니다.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 두 개 미만의 크기를 가지고, 사람은 암시 적으로는 2-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [2 :] + x.shape + y.shape입니다.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 두 개 미만의 크기를 가지고, 사람은 암시 적으로는 2-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [2 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 하나의 암시는 2-D 있도록 그 형상에 부가 된 1-D 배열이다. 결과의 모양은 c.shape [2 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; 다음, &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;hermeval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 많은 HermiteE 시리즈의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; 다음, &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;hermval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Hermite 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;lagval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Laguerre 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = legvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;legval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Legendre 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 행렬이고 &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;chebval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 같은 정도 및 샘플 포인트의 다수의 체비 쇼프 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 행렬이고 &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;polyval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 같은 정도의 많은 수의 다항식 및 샘플 포인트의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 1-D 배열은 다음 &lt;code&gt;p(x)&lt;/code&gt; 와 같은 것 같은 형상 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;c&lt;/code&gt; 다차원이고, 결과의 형상의 값에 따라 &lt;code&gt;tensor&lt;/code&gt; . 경우 &lt;code&gt;tensor&lt;/code&gt; + x.shape : 참 형상 c.shape [1]가 될 것이다. 경우 &lt;code&gt;tensor&lt;/code&gt; 거짓 형상 c.shape [1]가 될 것이다. 스칼라의 모양은 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이이며 &lt;code&gt;n + 1&lt;/code&gt; 이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이이며 &lt;code&gt;n + 1&lt;/code&gt; 이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 이 부울 인 경우 :</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 제공되며,이 배열의 삶을 위해 살아 남기해야합니다. 이를 관리하는 한 가지 방법은 &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; 를 사용하는 것입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 인 경우 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 해당 데이터 유형이 필요합니다. 복사가 허용되면 데이터를 캐스트 할 수있는 경우 임시 복사를합니다. 경우 &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 그것은 또한 반복자 파괴에 따라 다른 캐스트와 데이터 등을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">경우 &lt;code&gt;enddates&lt;/code&gt; 의 지정 대응보다 이전 날짜 값 &lt;code&gt;begindates&lt;/code&gt; 의 날짜 값, 카운트는 제외 할 것이다.</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 가 정렬 정수 1-D 어레이이고, 항목은 어디 함께 나타내는 &lt;code&gt;axis&lt;/code&gt; 배열이 분리된다. 예를 들어 &lt;code&gt;[2, 3]&lt;/code&gt; 은 &lt;code&gt;axis=0&lt;/code&gt; 의 경우</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">만약 &lt;code&gt;indices_or_sections&lt;/code&gt; 는 정수 N 인 배열을 따라 N 동일한 배열로 분할 될 &lt;code&gt;axis&lt;/code&gt; . 그러한 분할이 불가능하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 는 정수로 주어되지만 분할 동등한 분할을 초래하지 않는다.</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">만약 &lt;code&gt;legacy&lt;/code&gt; 거짓이다, 또는 BitGenerator이 NT19937되어 있지 않은 경우, 상태는 사전로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 또는 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; , 또는 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">만약 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 에 다른 유연한 dtype이있는</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 에 단일 열이 있으면 해당 열이 행렬의 단일 행으로 반환됩니다. 그렇지 않으면 &lt;code&gt;m&lt;/code&gt; 이 반환됩니다. 반환 된 행렬은 항상 &lt;code&gt;m&lt;/code&gt; 자체이거나 &lt;code&gt;m&lt;/code&gt; . 축 키워드 인수를 제공하면 반환 된 행렬에 영향을 미치지 않지만 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">경우 &lt;code&gt;maxsplit&lt;/code&gt; 는 기껏 주어진다 &lt;code&gt;maxsplit&lt;/code&gt; 분할이 수행됩니다 (가장 오른쪽).</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">경우 &lt;code&gt;maxsplit&lt;/code&gt; 이 주어진에서 가장 &lt;code&gt;maxsplit&lt;/code&gt; 의 분할이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 짝수이고, &lt;code&gt;A[-1]&lt;/code&gt; 양극과 음극 나이키 스트 주파수 (FS + / 2, -fs / 2) 모두를 표현하는 용어를 포함하고, 또한 실제 순수해야한다. 경우 &lt;code&gt;n&lt;/code&gt; 이 홀수, FS / 2에서 어떤 용어는 없다; &lt;code&gt;A[-1]&lt;/code&gt; 은 가장 큰 양의 주파수 (fs / 2 * (n-1) / n)를 포함하며 일반적인 경우에는 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">경우 &lt;code&gt;names&lt;/code&gt; True 인, 필드 이름은 첫 번째 후 첫 번째 줄에서 읽 &lt;code&gt;skip_header&lt;/code&gt; 의 라인. 이 행은 선택적으로 주석 분리 문자로 진행될 수 있습니다. 경우 &lt;code&gt;names&lt;/code&gt; 순서 또는 쉼표로 구분 명칭의 단일 스트링이고, 이름은 구성 DTYPE에 필드 명을 정의하는 데 사용된다. 만약 &lt;code&gt;names&lt;/code&gt; 없음입니다 (있는 경우) DTYPE 필드의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">경우 &lt;code&gt;obj.flags&lt;/code&gt; 가 있다 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 (사용되지 않음) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; ,이 기능은 플래그, 지 웁니다 &lt;code&gt;DECREF&lt;/code&gt; 의 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 하고 쓰기 가능하게하고, 세트 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULL한다. &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 에서 데이터를 복사하려고 시도하지 않습니다 . &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; 를&lt;/a&gt; 실행 취소 합니다 . 일반적으로 이것은 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 직전에 &lt;code&gt;obj&lt;/code&gt; 로 끝나면 오류 후에 호출됩니다 . 여러 번 호출되거나 &lt;code&gt;NULL&lt;/code&gt; 입력 으로 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.flags&lt;/code&gt; 가 있다 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 (사용되지 않음) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; ,이 기능은 플래그, 지 웁니다 &lt;code&gt;DECREF&lt;/code&gt; 의 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 하고 쓰기 가능하게하고, 세트 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULL한다. 그런 다음 &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; 를 &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; 로 복사하고 복사 작업의 오류 상태를 리턴합니다. 이것은 &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; 와 반대입니다 . 일반적으로 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 직전에 &lt;code&gt;obj&lt;/code&gt; 로 완료하면 호출 됩니다. 여러 번 호출되거나 &lt;code&gt;NULL&lt;/code&gt; 입력 으로 호출 될 수 있습니다 . &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 참조.</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; 요소로 채워진 1 차원 어레이 반환 &lt;em&gt;X&lt;/em&gt; 에 대응하는 &lt;code&gt;True&lt;/code&gt; 값 &lt;em&gt;OBJ를&lt;/em&gt; . 검색 순서는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt; , C 스타일입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 의 경계 외부에있는 항목에 값을 &lt;em&gt;X&lt;/em&gt; , 다음 인덱스 오류가 발생합니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 보다 작은 &lt;em&gt;X&lt;/em&gt; 는 그것을 채우는 동일 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 적합한 숫자 유형이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 작성된 ndarray에 대한 새 참조를 포함 하거나 변환 중에 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 을 포함 합니다. 그렇지 않으면 out에는 &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; 에&lt;/a&gt; 대한 빌린 참조가 포함되며 오류 조건이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 작성된 ndarray에 대한 새 참조를 포함 하거나 변환 중에 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 을 포함 합니다. 그렇지 않으면 out에는 Py_NotImplemented에 대한 빌린 참조가 포함되며 오류 조건이 설정되지 않습니다. 이 버전에서는 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 속성 을 찾는 배열 인터페이스 부분에서 유형과 컨텍스트를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">경우 &lt;code&gt;op&lt;/code&gt; 이미 (C 식)이며, 인접 단지 참조를 반환 한 후 잘 행동 그렇지는 (연속 및 품행) 배열의 카피 반환. op 매개 변수는 ndarray의 (하위 클래스)이어야하며 이에 대한 점검은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;op_dtypes&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 각 &lt;code&gt;op[i]&lt;/code&gt; 에 대해 데이터 유형 또는 &lt;code&gt;NULL&lt;/code&gt; 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">경우 &lt;code&gt;otypes&lt;/code&gt; 가 지정되어 있지 않은 경우, 상기 제 인수 함수 호출은 출력의 개수를 결정하는 데 사용된다. 이 호출의 결과 는 함수가 두 번 호출되지 않도록 &lt;code&gt;cache&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 캐시 됩니다. 그러나 캐시를 구현하려면 원래 함수를 랩핑해야 후속 호출 속도가 느려질 수 있으므로 함수가 비싼 경우에만 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 표준 편차를 포함하는 새로운 배열을 반환한다.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 표준 편차를 포함하는 새로운 배열을 반환한다. ddof가&amp;gt; =이면 슬라이스의 비 NaN 요소 수 또는 슬라이스에 NaN 만 포함 된 경우 해당 슬라이스의 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 분산을 포함하는 새로운 배열을 반환한다. ddof가&amp;gt; =이면 슬라이스의 비 NaN 요소 수 또는 슬라이스에 NaN 만 포함 된 경우 해당 슬라이스의 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 제공되며,이 함수에 그 결과를 기록하고 참조 반환 &lt;code&gt;out&lt;/code&gt; . (실시 예 참조)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 평균값이 포함 된 새 배열을 반환하고, 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 평균값이 포함 된 새 배열을 반환하고, 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다. NaN 만 포함 된 슬라이스에 대해서는 Nan이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 분산을 포함하는 새 배열을 반환합니다. 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">경우에 &lt;code&gt;output&lt;/code&gt; 한 후 공급되지 소스 코드가 화면 (sys.stdout)에 출력된다. 파일 개체는 쓰기 'w'또는 추가 'a'모드로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 길이 N이며,이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 리턴 시리즈는 다음 &lt;code&gt;p(x) == x&lt;/code&gt; X의 모든 값에 대해.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; URL이, 그것은, 다운로드에 저장 될 &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리와 거기에서 열었다.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; URL이며, 다음 &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; 돌아갑니다 어느 위치에 파일을 로컬에 존재하거나 사용하여 열 때 위치가 존재 것이다 &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 퍼센트이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 백분위 수가 여러 개인 경우 결과의 첫 번째 축은 백분위 수에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 퍼센트이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 다중 Quantile이 제공되면 결과의 첫 번째 축이 Quantile에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 분위수이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 다중 Quantile이 제공되면 결과의 첫 번째 축이 Quantile에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 은 1-D 배열은 다음 &lt;code&gt;p(x)&lt;/code&gt; 와 같은 것 같은 형상 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;r&lt;/code&gt; 다차원, 결과의 형상의 값에 따라 &lt;code&gt;tensor&lt;/code&gt; . 경우 &lt;code&gt;tensor is ``True`&lt;/code&gt; 형상 r.shape [1] + x.shape 것; 즉, 각 다항식은 모든 &lt;code&gt;x&lt;/code&gt; 값에서 평가됩니다 . 경우 &lt;code&gt;tensor&lt;/code&gt; 인 &lt;code&gt;False&lt;/code&gt; , 형상 r.shape [1]가 될 것이다; 즉, 각 다항식은 해당 브로드 캐스트 값 &lt;code&gt;x&lt;/code&gt; 에 대해서만 평가됩니다 . 스칼라의 모양은 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 길이 인 &lt;code&gt;N&lt;/code&gt; ,이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">경우 &lt;code&gt;rep&lt;/code&gt; 스칼라 DTYPE의 인스턴스, 사실이 반환됩니다. 그렇지 않으면 False가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">경우에는 &lt;code&gt;reps&lt;/code&gt; 길이 갖는 &lt;code&gt;d&lt;/code&gt; , 결과의 치수 것이다 &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">경우 &lt;code&gt;rowvar&lt;/code&gt; 이 참 (기본값), 각 행은 열에서 관측 변수를 나타냅니다. 그렇지 않으면 관계가 바뀝니다. 각 열은 변수를 나타내며 행에는 관측치가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;axes&lt;/code&gt; 서로 다른 길이, 또는이 &lt;code&gt;axes&lt;/code&gt; 하지 주어 &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;axes&lt;/code&gt; 길이가 다른 경우</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">&lt;code&gt;sctype&lt;/code&gt; 이 유형을 유추 할 수없는 객체 인 경우</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">만약 &lt;code&gt;self.shape[k] == 1&lt;/code&gt; 다음 법적 인덱스에 대한 &lt;code&gt;index[k] == 0&lt;/code&gt; . 이것은 오프셋 공식에서</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수가 아닌 경우 &lt;code&gt;ret&lt;/code&gt; 은 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; 모두 &lt;code&gt;True&lt;/code&gt; 를 반환하도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수 인 경우 .</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 지정되거나되지 않은 &lt;code&gt;None&lt;/code&gt; , 공백 문자열 세퍼레이터이다.</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;shape&lt;/code&gt; 길이를 갖는 하나의 예 &lt;code&gt;(N,)&lt;/code&gt; , 또는 스칼라 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; 형상의 단일 행 행렬이된다 &lt;code&gt;(1,N)&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">&lt;code&gt;tol&lt;/code&gt; &amp;lt;0 인 경우</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 2-D 어레이, 그 사본 반환 &lt;code&gt;k&lt;/code&gt; 번째 대각선. 경우 &lt;code&gt;v&lt;/code&gt; 1-D 어레이는 함께 2-D 배열을 반환 &lt;code&gt;v&lt;/code&gt; 상의 &lt;code&gt;k&lt;/code&gt; 번째 대각.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 보다 긴 , 배열은 계산하기 전에 교체된다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 같은 크기되지 및 &lt;code&gt;mask&lt;/code&gt; 그것은 반복됩니다. 이것은 &lt;code&gt;a[mask] = values&lt;/code&gt; 와 다른 동작을 제공 합니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 보다 작은 이 반복된다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x2&lt;/code&gt; 스칼라, 그 기호의 모든 요소에 복사됩니다 &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 목록 또는 튜플은, 그것은 그렇지 않으면 변경되지 스칼라로 취급 ndarray로 변환된다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소를 더한 곱셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 목록 또는 튜플은, 그것은 그렇지 않으면 변경되지 스칼라로 취급 ndarray로 변환된다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;r&lt;/code&gt; 요소를 더한 곱셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 다차원 어레이이며, 이는 단지 첫 번째 인덱스에 따라 셔플 링된다.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; poly1d 인스턴스이며, 그 결과는 두 다항식의 조성, 즉,이고 &lt;code&gt;x&lt;/code&gt; 에 &quot;치환&quot;되는 &lt;code&gt;p&lt;/code&gt; 및 단순화 된 결과가 복귀된다. 또한 &lt;code&gt;x&lt;/code&gt; -array_like 또는 poly1d 유형은 출력 유형을 제어합니다. &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; poly1d 객체 =&amp;gt; &lt;code&gt;values&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 연속하고있다 &lt;code&gt;p(x)&lt;/code&gt; 의 각 요소에 대해 리턴되는 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 다음 다른 다항식 복합 다항식 &lt;code&gt;p(x(t))&lt;/code&gt; 복귀된다.</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 의 하위 유형입니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 반환 값은 같은 유형이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 정수이고, 임의로 변경하다 &lt;code&gt;np.arange(x)&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 배열 인, 복사본을 만들고 무작위 요소를 섞는다.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 부정확 NaN이 제로에 의해 또는 사용자 정의 된 값으로 대체 &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; 키워드 무한대 부동 소수점 값으로 표현 가능한 최대 유한으로 대체 &lt;code&gt;x.dtype&lt;/code&gt; 또는 사용자 정의 값 &lt;code&gt;posinf&lt;/code&gt; 키워드 무한대가로 대체 &lt;code&gt;x.dtype&lt;/code&gt; 또는 &lt;code&gt;neginf&lt;/code&gt; 키워드 의 사용자 정의 값으로 표시 할 수있는 가장 음의 유한 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 정확하지 않습니다, 다음에는 교체가 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 부호있는 정수 타입이다, 출력 유형은 기본 플랫폼의 정수입니다 :</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;xp&lt;/code&gt; 및 &lt;code&gt;fp&lt;/code&gt; 상이한 길이를 갖는 경우 &lt;code&gt;xp&lt;/code&gt; 또는 &lt;code&gt;fp&lt;/code&gt; 1-D의 순서가 아닌 경우 &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">경우 &lt;em&gt;도착을&lt;/em&gt; 배열하고, 그 데이터 형식 디스크립터를 반환하지만 경우 &lt;em&gt;도착은&lt;/em&gt; (0 차원을 갖는다) 배열 스칼라이고,이 값은 정수 오버플로 또는 절단없이 전환 될 수도있는 가장 작은 크기의 데이터 유형을 발견한다.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">경우 &lt;em&gt;축이&lt;/em&gt; 없는 &lt;em&gt;없음&lt;/em&gt; (디폴트), 어레이는 1-D 어레이로 처리하고, 동작은 전체 어레이에 걸쳐 수행된다. self가 0 차원 배열 또는 배열 스칼라 인 경우에도이 동작이 기본값입니다. 배열 스칼라는 float32, float64 등의 유형 / 클래스 인스턴스이며 0 차원 배열은 정확히 하나의 배열 스칼라를 포함하는 ndarray 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">경우 &lt;em&gt;축&lt;/em&gt; 정수이고, 그 동작은 (소정의 축선을 따라 생성 될 수있는 각각의 1-D 서브 어레이에 대한) 주어진 축상에서 이루어진다.</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 의 경우 , 새로운 단위 화 메모리가 할당되어 , 포트란 스타일의 연속적인 배열을 나타내는 &lt;em&gt;플래그&lt;/em&gt; 가 제로 이외의 값이 될 수 있습니다. &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; 를 사용 하여 메모리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 배열에 사용될 메모리를 가리키는 것으로 가정하고 &lt;em&gt;flags&lt;/em&gt; 인수는 배열의 새 플래그로 사용됩니다 ( &lt;code&gt;NPY_OWNDATA&lt;/code&gt; 상태 , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 및 새 배열의 &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그 제외) 재설정).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">경우 &lt;em&gt;DESCR이&lt;/em&gt; NULL 인의 데이터 타입 &lt;em&gt;프로토 타입을&lt;/em&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">경우 &lt;em&gt;DTYPE이&lt;/em&gt; 있다 &lt;code&gt;NULL&lt;/code&gt; 을 , 다음 반환되는 배열은 같은 데이터 유형 것 &lt;em&gt;자체&lt;/em&gt; . 새로운 데이터 유형은 &lt;em&gt;self&lt;/em&gt; 의 크기와 일치해야합니다 . 항목 크기는 동일하거나 &lt;em&gt;self&lt;/em&gt; 는 단일 세그먼트 여야하고 총 바이트 수는 같아야합니다. 후자의 경우 반환 된 배열의 차원은 마지막 (또는 첫 번째 포트란 스타일의 연속 배열) 차원에서 변경됩니다. 반환 된 배열과 self의 데이터 영역은 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">경우 &lt;em&gt;연산이&lt;/em&gt; 이미 배열이지만, 조건을 만족하지 않고, 다음 복사 (요건을 만족하는 것)한다. 이 플래그가 존재하고 (이미 배열 인 오브젝트의) 사본이 작성되어야하는 경우, 대응하는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 리턴 된 사본에 설정되고 &lt;em&gt;op&lt;/em&gt; 는 읽기 전용이됩니다. 당신은 호출해야합니다 &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 을&lt;/a&gt; 내용으로 다시 복사 &lt;em&gt;연산&lt;/em&gt; 과 &lt;em&gt;연산&lt;/em&gt; 배열을 다시 쓰기 될 것이다. 경우 &lt;em&gt;영업 이익은&lt;/em&gt; 시작하는 쓰기가 아니거나 이미 배열이 아닌 경우, 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">경우 &lt;em&gt;변경하다는&lt;/em&gt; 것입니다 &lt;code&gt;NULL&lt;/code&gt; 이 결과의 모양입니다</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">경우 &lt;em&gt;subok가&lt;/em&gt; 1이고, 새로 생성 된 배열의 하위 유형 사용하는 &lt;em&gt;프로토 타입&lt;/em&gt; 그렇지 않으면 기본 수준의 배열을 만들 때, 새로운 배열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">경우 &lt;em&gt;아류&lt;/em&gt; 어레이 서브 대신 염기이다 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; 후 &lt;em&gt;OBJ&lt;/em&gt; 받는 전달할 목적 &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; 의&lt;/a&gt; 서브 클래스의 방법.</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">q가 정규 직교가되도록 A = qr 인 경우 (Gram-Schmidt를 통해 항상 가능) &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; 입니다. 그러나 numpy 연습에서는 &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; 만&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">False이면 메모리를 보존하기 위해 원래 배열에 대한보기가 반환됩니다. 기본값은 True입니다. 제발 참고 &lt;code&gt;sparse=False, copy=False&lt;/code&gt; 가능성이 비 연속 배열을 반환합니다. 또한, 방송 어레이의 하나 이상의 요소는 단일 메모리 위치를 지칭 할 수있다. 배열에 쓰려면 먼저 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">False이면 참조 횟수를 확인하지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">기본값 인 False이면 각 빈의 샘플 수를 반환합니다. True이면 &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; 에서 확률 &lt;em&gt;밀도&lt;/em&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">기본값 인 False이면 각 빈의 샘플 수를 반환합니다. True이면 &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; 에서 확률 &lt;em&gt;밀도&lt;/em&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">K = min (M, N)이면</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">None 인 경우 인덱스는 전개 된 배열에 있고, 그렇지 않으면 지정된 축을 따라</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">None 인 경우 경로는 로컬 경로에 subpackage_name을 더한 것으로 가정합니다. subpackage_path에 setup.py 파일이 없으면 기본 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">None 인 경우 MaskType 인스턴스를 사용하십시오. 그렇지 않으면 부울 유형으로 변환 된 &lt;code&gt;dtype&lt;/code&gt; 과 동일한 필드를 가진 새 데이터 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">SVD 계산이 수렴되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">진정한 (기본값)의 사본 한 경우 &lt;code&gt;a&lt;/code&gt; 결과에. 거짓하다면 수정 &lt;code&gt;a&lt;/code&gt; 장소와 뷰를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">True (기본값) 인 경우 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;vh&lt;/code&gt; 의 모양은 각각 &lt;code&gt;(..., M, M)&lt;/code&gt; 및 &lt;code&gt;(..., N, N)&lt;/code&gt; 입니다. 그렇지 않으면 모양은 각각 &lt;code&gt;(..., M, K)&lt;/code&gt; 및 &lt;code&gt;(..., K, N)&lt;/code&gt; 이며 여기서 &lt;code&gt;K = min(M, N)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">True (기본값)이면 예쁜 인쇄 기능 ( &lt;code&gt;__repr__&lt;/code&gt; )이 설정되고 False이면 기본 문자열 표현 ( &lt;code&gt;__str__&lt;/code&gt; ) 을 반환하는 기능 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">True 인 경우 메모리를 절약하기 위해 스파 스 그리드가 반환됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;M&lt;/code&gt; 은 Hermitian (실제 값인 경우 대칭) 인 것으로 가정하여 특이 값을 찾기위한보다 효율적인 방법을 제공합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;a&lt;/code&gt; 는 Hermitian (실제 값인 경우 대칭) 인 것으로 가정하여 특이 값을 찾기위한보다 효율적인 방법을 제공합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;c_or_r&lt;/code&gt; 은 다항식의 근을 지정합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">True이면 &lt;code&gt;stop&lt;/code&gt; 이 마지막 샘플입니다. 그렇지 않으면 포함되지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">True이면 NaN이 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">True 인 경우 C- 컴파일러와 같이 패딩하여 필드를 정렬하십시오. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">True 인 경우 고유 한 배열을 제공하는 &lt;code&gt;ar&lt;/code&gt; (지정된 축을 따라 또는 평면 배열로) 의 인덱스도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 &lt;code&gt;ar&lt;/code&gt; 재구성에 사용할 수있는 고유 배열 (제공된 경우 지정된 축에 대한)의 인덱스도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 각 고유 항목이 &lt;code&gt;ar&lt;/code&gt; 에 나타나는 횟수도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">True 인 경우 항상 고정 소수점 표기법을 사용하여 부동 소수점 숫자를 인쇄합니다.이 경우 현재 정밀도에서 0과 같은 숫자는 0으로 인쇄됩니다. False 인 경우, 가장 작은 수의 절대 값이 &amp;lt;1e-4이거나 최대 절대 값과 최소값의 비율이&amp;gt; 1e3 일 때 과학 표기법이 사용됩니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">True이면 항상 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">True 인 경우 열 수에서 불일치가 감지되면 예외가 발생합니다. False이면 경고가 발생하고 문제가되는 행을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">True 인 경우 유효하지 않은 값에 대해 오류를 발생시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">True 인 경우 필드 이름은 대소 문자를 구분합니다. False 또는 'upper'이면 필드 이름이 대문자로 변환됩니다. '낮음'이면 필드 이름이 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">True이면 마스킹 된 값이 쌍으로 전파됩니다. 값이 &lt;code&gt;x&lt;/code&gt; 로 마스킹 되면 해당 값이 &lt;code&gt;y&lt;/code&gt; 로 마스킹됩니다 . False이면 일부 값이 없을 때 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">True이면 마스킹 된 값이 쌍으로 전파됩니다. 값이 &lt;code&gt;x&lt;/code&gt; 로 마스킹 되면 해당 값이 &lt;code&gt;y&lt;/code&gt; 로 마스킹됩니다 . False이면 예외가 발생합니다. 때문에 &lt;code&gt;bias&lt;/code&gt; 되지 않습니다,이 인수는 경고를 피하기 위해 키워드로 취급 될 필요가있다.</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">True 인 경우 ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; )을 반환 합니다. 여기서 &lt;code&gt;step&lt;/code&gt; 은 샘플 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">True이면 마스크 된 배열을 반환합니다. False이면 일반 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">True 인 경우 데코레이션 된 콜 러블이 테스트임을 지정합니다. False 인 경우 데코레이션 된 콜 러블이 테스트가 아님을 지정합니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">True이면 서브 클래스가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 축소 된 축은 크기가 1 인 치수로 결과에 남습니다. 이 옵션을 사용하면 결과가 원래 &lt;code&gt;arr&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">True 인 경우 충돌하는 값이 오류 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">True이면 두 배열의 교집합에 해당하는 인덱스가 반환됩니다. 값이 여러 개인 경우 값의 첫 번째 인스턴스가 사용됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">True 인 경우 입력 배열이 모두 고유 한 것으로 가정하여 계산 속도를 높일 수 있습니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">True 인 경우 반복자는 &lt;code&gt;c_index&lt;/code&gt; 또는 &lt;code&gt;f_index&lt;/code&gt; 플래그 를 사용하여 작성되었으며 특성 &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 사용하여이를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">True 인 경우, 이터레이터는 &lt;code&gt;delay_bufalloc&lt;/code&gt; 플래그 로 작성 되었으며 아직 reset () 함수가 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">True 인 경우, 반복자는 만들었습니다 &lt;code&gt;multi_index&lt;/code&gt; 의 플래그 및 속성 &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; 은&lt;/a&gt; 그것을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">True 인 경우 반환 된 배열이 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">True 인 경우, 반환 된 배열이 바뀌므로 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 . 구조화 된 데이터 유형과 함께 사용하면 각 필드에 대해 배열이 리턴됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">True 인 경우 계수 배열의 모양은 &lt;code&gt;x&lt;/code&gt; 의 각 차원마다 하나씩 오른쪽에있는 것으로 확장됩니다 . 스칼라는이 작업의 차원이 0입니다. 결과적으로 &lt;code&gt;c&lt;/code&gt; 의 모든 계수 열 은 &lt;code&gt;x&lt;/code&gt; 의 모든 요소에 대해 평가됩니다 . False이면 &lt;code&gt;x&lt;/code&gt; 는 평가를 위해 &lt;code&gt;c&lt;/code&gt; 의 열을 통해 브로드 캐스트 됩니다. 이 키워드는 &lt;code&gt;c&lt;/code&gt; 가 다차원 일 때 유용합니다 . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">True 인 경우, 루트 배열의 모양은 &lt;code&gt;x&lt;/code&gt; 의 각 차원마다 하나씩 오른쪽에있는 모양으로 확장됩니다 . 스칼라는이 작업의 차원이 0입니다. 결과는 &lt;code&gt;r&lt;/code&gt; 의 모든 계수 열 이 &lt;code&gt;x&lt;/code&gt; 의 모든 요소에 대해 평가됩니다 . False이면 &lt;code&gt;x&lt;/code&gt; 는 평가를 위해 &lt;code&gt;r&lt;/code&gt; 의 열을 통해 브로드 캐스트 됩니다. 이 키워드는 &lt;code&gt;r&lt;/code&gt; 이 다차원 일 때 유용합니다 . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">참이 반환 된 배열의 값이 반전되는 경우 (즉, 요소의 위치를 거짓 &lt;code&gt;ar1&lt;/code&gt; 되어 &lt;code&gt;ar2&lt;/code&gt; 달리 트루). 기본값은 거짓입니다. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; 는 &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; 와 동일하지만 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">True 인 경우, 반환 된 배열의 값 &lt;code&gt;element not in test_elements&lt;/code&gt; 계산하는 것처럼 반전됩니다 . 기본값은 거짓입니다. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; 는 &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; 와 동일하지만 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 를 중간 계산으로 수정하여 메모리를 절약 할 수 있습니다. 이 경우이 기능이 완료된 후 입력 &lt;code&gt;a&lt;/code&gt; 의 내용 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">참이면 계산에 입력 배열 (a)의 메모리 사용을 허용하십시오. 입력 배열은 중앙값 호출에 의해 수정됩니다. 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 해당 주 &lt;code&gt;overwrite_input&lt;/code&gt; 가 사실이고, 입력이 이미하지 &lt;code&gt;ndarray&lt;/code&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 의 메모리를 사용 하여 계산할 수 있습니다. 입력 배열은 &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 호출로 수정됩니다 . 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 &lt;code&gt;overwrite_input&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 이미 아니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 의 메모리를 사용 하여 계산할 수 있습니다. 입력 배열은 &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 호출로 수정됩니다 . 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 &lt;code&gt;overwrite_input&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 이미 아니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">True 인 경우 하위 클래스가 통과 (기본값)되며, 그렇지 않으면 반환 된 배열이 기본 클래스 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">True 인 경우 하위 클래스가 전달되고, 그렇지 않으면 반환 된 배열은 기본 클래스 배열이됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">True이면 하위 클래스가 전달되고, 그렇지 않으면 반환 된 배열이 기본 클래스 배열이됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">True 인 경우 새로 만든 배열은 하위 클래스 유형 'a'를 사용하고 그렇지 않으면 기본 클래스 배열입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">[배열, 배열]이면 각 차원의 빈 가장자리 (x_edges, y_edges = 빈)입니다.</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">[int, int] 인 경우 각 차원의 구간 수 (nx, ny = 구간).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">__svn_version__.py가 이미 존재하면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">&amp;lt;1 인 경우</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">갖는 클래스 (ndarray 서브 여부) 경우 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; 의&lt;/a&gt; 방법은 출력 오브젝트로서 사용된다 &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , 결과에 의해 리턴 된 객체에 기록한다 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . 입력 배열에서도 비슷한 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">클래스가 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메서드를 정의하면 ufunc에 대해 아래 설명 된 &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 메커니즘을 비활성화합니다 (결국 더 이상 사용되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">컴파일 타임 고정 버퍼가 사용되는 경우 ( &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 플래그 모두 ) 내부 크기도 신호로 사용될 수 있습니다. &lt;code&gt;iternext()&lt;/code&gt; 가 false를 리턴 하면 크기가 0이되어 다음 루프 구성을 사용할 수 있습니다. 이 구문을 사용하는 경우 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 를 플래그로 전달하면 안됩니다 . 일부 환경에서는 더 큰 크기가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">dtype 객체에이 속성이있는 필드를 검색하면 &lt;em&gt;모양&lt;/em&gt; 으로 암시 된 추가 차원 이 검색된 배열의 끝에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">특정 유형에 대해 포맷터가 지정된 경우 해당 유형에 대해 &lt;code&gt;precision&lt;/code&gt; 키워드가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">지정된 배열이 지정된 제한을 만족하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">a가 행렬 객체이면 반환 값도 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">a가 int이고 0보다 작은 경우 a 또는 p가 1 차원이 아닌 경우 a가 크기가 0 인 배열과 같거나 p가 확률의 벡터가 아닌 경우, a와 p의 길이가 다른 경우 또는 replace = 거짓이며 표본 크기가 모집단 크기보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">a가 int이고 0보다 작은 경우, p가 1 차원이 아닌 경우, a가 크기가 0 인 배열과 같은 경우, p가 확률 벡터가 아닌 경우, a와 p의 길이가 다르거 나 replace = 인 경우 False이고 표본 크기가 모집단 크기보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">문자열 목록 인 경우 각 문자열은 dtype을 나타내야합니다. array_like 인 경우 배열 dtype의 문자 표현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">스칼라 dtype 인 경우 해당 문자열 문자가 리턴됩니다. 객체 인 경우 &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; 는 스칼라 유형을 유추 한 다음 해당 문자열 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">스칼라 값이 전달 된 경우</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">두 번째 인수가 제공되면 결과가 저장됩니다. 해당 배열의 유형이 숫자 유형 인 경우 결과는 0과 1로 표시되며, 유형이 부울 인 경우 False 및 True로 표시됩니다. 리턴 값 &lt;code&gt;out&lt;/code&gt; 그 어레이에 대한 레퍼런스이다.</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">제로 차원 배열 인덱스에 존재하는 경우 &lt;em&gt;와&lt;/em&gt; 는 전체 정수 인덱스 인 결과가 될 것이다 &lt;em&gt;스칼라&lt;/em&gt; 아니라 제로 차원 어레이. (고급 인덱싱은 트리거되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">실제와 원하는 것이 지정된 정밀도와 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">실제와 원하는 것이 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">실제 및 원하는 객체가 동일하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">모든 경우 &lt;code&gt;__array_function__&lt;/code&gt; 방법은 반환 &lt;code&gt;NotImplemented&lt;/code&gt; 을 , NumPy와는 올릴 &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">모든 배열이 1 차원 인 &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">모든 값이 마스킹되면 None을 반환합니다. 그렇지 않으면, 첫 번째 마스크 값과 마지막 마스크되지 않은 값의 인덱스에 해당하는 두 개의 튜플 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">배열에 매우 작거나 큰 결정자가있는 경우 &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 호출 이 오버플로되거나 언더 플로 될 수 있습니다. 이 루틴은 결정자 자체가 아니라 결정자 로그를 계산하기 때문에 이러한 문제에 대해보다 강력합니다.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">배열에 요소가없는 경우 ( &lt;code&gt;self.size == 0&lt;/code&gt; ) 유효한 인덱스가없고 보폭이 사용되지 않습니다. 요소가없는 배열은 C 스타일과 포트란 스타일의 연속으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">하위 배열을 설명하는 데이터 형식을 사용하여 배열을 만들면 배열이 만들어 질 때 하위 배열의 차원이 배열 모양에 추가됩니다. 구조화 된 유형의 필드에있는 하위 배열은 다르게 동작합니다 ( &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;필드 액세스&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">이 방법으로 배열을 만들면 각 반복에 대해 'itemsize'를 추가하면 반복자와 일치하는 새 배열을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">소자의 경우 &lt;code&gt;axes&lt;/code&gt; 의 축수보다보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">index가 &lt;code&gt;axis&lt;/code&gt; 를 따라 배열의 차원을 초과하면 해당 하는 빈 하위 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">입력의 모양 크기가 1 인 경우 해당 차원의 첫 번째 데이터 항목이 해당 차원의 모든 계산에 사용됩니다. 다시 말해, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; 의 스테핑 기계 는 단순히 해당 치수를 따라 밟지 않습니다 (해당 치수의 &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;보폭&lt;/a&gt; 은 0입니다).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">ndarray 인 경우 요소에서 임의의 샘플이 생성됩니다. int 인 경우 a가 np.arange (a) 인 것처럼 임의 샘플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">객체가 제공되면 write 메소드는 하나의 인수 인 문자열을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">입력 값이 array_like이면 &lt;code&gt;pv&lt;/code&gt; 는 동일한 모양의 배열을 반환합니다. 위의 예에서 다른 금리를 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">입력이 array_like 인 경우 동일한 모양의 배열을 반환합니다. 위의 예와 다른 금리를 비교해 봅시다.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">읽기 / 쓰기 오버랩이 존재하면이 플래그는 연산 결과가 모든 피연산자가 복사 된 것과 동일하도록합니다. 복사가 필요한 경우, &lt;strong&gt;이 플래그없이 계산 결과가 정의되지 않을 수 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">알파 값이 0보다 작거나 같은 경우</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">쓰기 피연산자가 읽기 피연산자와 겹치는 경우 임시 복사본을 만들어 모든 겹침을 제거하십시오 (필요한 경우 쓰기 피연산자에 UPDATEIFCOPY 사용). 두 배열에 공통적 인 데이터를 포함하는 메모리 주소가 있으면 피연산자 쌍이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">인수가 int dtypes로만 구성된 경우</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">키워드없이 인수를 전달하면 &lt;code&gt;.npz&lt;/code&gt; 파일 의 해당 변수 이름 은 'arr_0', 'arr_1'등입니다. 키워드 인수가 제공되면 &lt;code&gt;.npz&lt;/code&gt; 파일 의 해당 변수 이름 은 키워드 이름.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">array_like 인 경우 2 차원의 빈 가장자리 (x_edges = y_edges = bins)</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">축이 0이면 행만 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">축이 1 또는 -1이면 열만 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">axis가 None이면 행과 열이 모두 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 제품이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 합계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 평균화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">axis가 int의 튜플 인 경우 튜플에 지정된 모든 축에서 반전이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 는 1-D 어레이이고, 그것은 (복소 공액)없이 벡터의 내적이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 2-D 어레이이고,는 매트릭스 승산이지만, 사용 &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; 을&lt;/a&gt; 하거나 &lt;code&gt;a @ b&lt;/code&gt; 바람직하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 있는 &lt;code&gt;NULL&lt;/code&gt; , 다음 반환 &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;상태&lt;/em&gt; ). 그렇지 않으면, &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 가 모두 주어져야하고 반환 된 객체는 &lt;em&gt;조건&lt;/em&gt; 과 같은 모양 이며 &lt;em&gt;조건&lt;/em&gt; 이 각각 True 또는 False 인 &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y의&lt;/em&gt; 요소를 갖습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">두 인수가 모두 2 차원이면 기존 행렬과 같이 곱해집니다.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">양의 무한대와 음의 무한대가 모두 존재하면 합계는 NaN (Not A Number)이됩니다.</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">경고 클래스 이외의 모든 인수를 생략하고 호출하면 컨텍스트 관리자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">복잡한 부분이 0에 가까우면 복잡한 입력이 실제 배열을 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">계산이 수렴하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">condition이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 인&lt;/a&gt; 경우 누락 된 값은 &lt;code&gt;False&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">copy가 False이고 입력 중 하나가 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 이면 다른 입력 마스크의보기를 리턴하십시오. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">데이터가 &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; 로 전달 되면 새 배열을 삭제할 때까지이 메모리를 할당 해제해서는 안됩니다. 이 데이터가 다른 Python 객체에서 온 경우 해당 객체에서 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; 를 사용하여 새 객체의 기본 멤버를 해당 객체를 가리 키도록 설정하면됩니다. 보폭이 전달되면 치수, 항목 크기 및 배열의 ​​데이터와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">정의한 경우의 축 , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 을 정의하는 벡터 (들) 및 외적 (들) 즉. 오버라이드 (override) &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; 및 &lt;code&gt;axisc&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">어느 경우 또는 &lt;code&gt;b&lt;/code&gt; 는 0 D (라), 그것과 동등하다 &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; 및 사용 &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; 또는 &lt;code&gt;a * b&lt;/code&gt; 바람직하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">인수 중 하나가 ND, N&amp;gt; 2 인 경우, 마지막 두 인덱스에 상주하는 행렬의 스택으로 취급되어 그에 따라 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">배열에 하나 이상의 NaN이 포함되어 있으면 False가 반환됩니다. Infs는 두 배열에서 같은 위치에 있고 같은 부호를 가진다면 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">요소의 복소수가 0 인 복소수 유형 인 경우 해당 요소의 리턴 값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">팩토링이 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">파일이 문자열 또는 경로와 유사한 객체 인 경우 해당 파일이 열리면 파일 객체 인 것으로 간주됩니다. 파일 객체는 랜덤 액세스를 지원해야합니다 (즉, tell 및 seek 메소드가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">필터가 추가되고 &lt;code&gt;module&lt;/code&gt; 키워드가 제공되면이 모듈의 경고 레지스트리는 적용, 컨텍스트 입력 또는 종료시 추가로 지워집니다. 이로 인해 컨텍스트가 한 번 인쇄되도록 구성되고 (기본값) 컨텍스트가 입력되기 전에 이미 인쇄 된 경우 컨텍스트를 떠난 후 경고가 두 번째로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">형식이 없음이면 형식이 자동 감지됩니다. 빠른 처리를 위해 목록 목록 대신 튜플 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 가 아니라 주어진 경우 추정값뿐만 아니라 공분산 행렬도 반환합니다. 공분산은 기본적으로 chi2 / sqrt (N-dof)로 스케일링됩니다. 즉, 상대적 의미를 제외하고 가중치는 신뢰할 수없는 것으로 추정되며 감소 된 chi2가 단일하도록 모든 것이 스케일됩니다. 이 스케일링은 가중치가 1 / sigma ** 2 인 경우와 관련하여 sivma가 불확실성의 신뢰할 수있는 추정치 인 것으로 알려진 &lt;code&gt;cov='unscaled'&lt;/code&gt; 인 경우 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">제공된 경우 &lt;code&gt;@key@&lt;/code&gt; 형식의 문자열은 설치시 템플릿 파일에서 &lt;code&gt;subst_dict[key]&lt;/code&gt; 로 바뀝니다 . 설치 접두사는 setup.py에서 안정적으로 얻기 쉽지 않기 때문에 항상 &lt;code&gt;@prefix@&lt;/code&gt; 변수를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">주어진 경우 배열은 &lt;code&gt;[beg, end]&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;beg&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 도메인의 끝점입니다. None이 주어지면 클래스 도메인이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">주어진 경우, 결과 배열은 &lt;code&gt;[beg, end]&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;beg&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 창의 끝점입니다. None이 주어지면 클래스 창이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">주어진 경우, 유형을 판별 할 수없는 오브젝트에 대해 리턴됩니다. 지정하지 않으면 해당 오브젝트에 대해 없음이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">입력 배열 &lt;code&gt;a&lt;/code&gt; 가 2D가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">입력이 잘못된 모양 인 경우 (입력은 1D 또는 사각형 2D 배열이어야합니다).</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">int 인 경우 2 차원의 구간 수 (nx = ny = bins)입니다.</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">키워드 인수가 제공되면 파일 이름이 키워드에서 가져옵니다. 키워드없이 인수를 전달하면 저장된 파일 이름은 arr_0, arr_1 등입니다.</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">예를 들어, &lt;code&gt;[[a, b], c]&lt;/code&gt; 와 같이 목록 깊이가 일치하지 않으면 &lt;code&gt;[[a, b], [c]]&lt;/code&gt; 철자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">목록이 비어있는 경우 (예 : &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">다중 차원 입력 인 경우 지정된 축을 따라 새 인덱스의 ndarray를 최소값으로 반환합니다. 그렇지 않으면 주어진 축을 따라 인덱스의 스칼라를 최소값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">필요한 경우 차이가 발생하기 전에 평평해질 것입니다.</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">둘 다 정의되지 않은 경우 C-API는 &lt;code&gt;static void**&lt;/code&gt; 선언 되므로 #includes numpy / arrayobject.h를 컴파일 유닛 내에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 메소드가 없으면 NumPy는 NumPy 배열에서 사용하기 위해 자체 구현을 호출하도록 기본 설정됩니다. 이 경우는 예를 들어 모든 배열과 같은 인수가 Python 숫자 또는 목록 인 경우에 발생합니다. (NumPy와 배열이 있습니까 &lt;code&gt;__array_function__&lt;/code&gt; 의 아래, 방법을, 그러나 항상 반환 &lt;code&gt;NotImplemented&lt;/code&gt; 의 다른 인수가 NumPy와 배열 서브 클래스 구현이보다 경우 &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">입력 중 어느 것도 모든 출력 어레이가 전달 될 ufunc 재정의 없으면 &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 입력 방법 (또한 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 및 스칼라)하도록 정의를 &lt;strong&gt;하고&lt;/strong&gt; 가장 갖고 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 범용 기능 다른 입력한다. &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 의 기본 __array_priority__ 는 0.0이고 하위 유형 의 기본 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 는 0.0입니다. 행렬의 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 는 10.0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 정상화는 것입니다 &lt;code&gt;(N - ddof)&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 은 관찰의 수이고; 이 값은 &lt;code&gt;bias&lt;/code&gt; 에 의해 암시 된 값보다 우선합니다 . 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">그렇지 않을 경우 &lt;code&gt;None&lt;/code&gt; 에 의해 암시 기본값 &lt;code&gt;bias&lt;/code&gt; 무시됩니다. 참고 &lt;code&gt;ddof=1&lt;/code&gt; 심지어 두 경우 공정한 평가를 반환합니다 &lt;code&gt;fweights&lt;/code&gt; 가 및 &lt;code&gt;aweights&lt;/code&gt; 가 지정되고, &lt;code&gt;ddof=0&lt;/code&gt; 단순 평균을 반환합니다. 자세한 내용은 참고 사항을 참조하십시오. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">None이 아닌 경우 키는 각 형식 지정 기능이 적용되는 유형을 나타냅니다. 콜 러블은 문자열을 반환해야합니다. 해당 키로 지정되지 않은 유형은 기본 포맷터에서 처리합니다. 포맷터를 설정할 수있는 개별 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">None이 아닌 경우, 지정된 도메인이 호출 인스턴스의 도메인 대신 사용됩니다. &lt;code&gt;[beg,end]&lt;/code&gt; 형식이어야합니다 . 기본값은 없음이며 클래스 도메인이 사용되는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">None이 아니라면 주어진 모드를 사용하여 파일을 메모리에 매핑합니다 (참조 &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt;에 대한 자세한 설명 numpy.memmap). 메모리 매핑 된 어레이는 디스크에 보관됩니다. 그러나 ndarray와 같이 액세스하고 슬라이스 할 수 있습니다. 메모리 매핑은 전체 파일을 메모리로 읽지 않고 큰 파일의 작은 조각에 액세스하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">하나의 인수가 스칼라 인 경우에만 사용됩니다. &lt;code&gt;a&lt;/code&gt; 의 크기가 1 인 경우 . 두 개의 인수 : 마지막 인수가 설정 될 값이고 스칼라 여야하는 경우 첫 번째 인수는 단일 배열 요소 위치를 지정합니다. int 또는 tuple입니다.</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">입력 또는 출력 인수 중 하나에 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메소드 가 있으면 ufunc&lt;em&gt; 대신&lt;/em&gt; 실행 &lt;em&gt;됩니다&lt;/em&gt; . 둘 이상의 인수가 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; 를&lt;/a&gt; 구현 하면 수퍼 클래스 이전의 서브 클래스, 출력 이전의 입력, 그렇지 않으면 왼쪽에서 오른쪽으로 순서대로 시도됩니다. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 이외의 것을 반환하는 첫 번째 루틴 이 결과를 결정합니다. 의 모든 경우 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 작업이 반환 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 을&lt;/a&gt; 하는&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 요소가 &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">세 번째에 &quot;1&quot;이 나타날 때까지 주사위를 반복해서 던지면 세 번째 &quot;1&quot;이전에 나타나는 &quot;1&quot;이 아닌 숫자의 확률 분포는 음의 이항 분포입니다.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">여러 위치에서 동일한 차원 이름을 사용하는 경우 동일한 크기의 해당 차원이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">피연산자 플래그 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; 를 사용하는 경우 피연산자는 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그 를 사용하여 원래 데이터를 볼 수 있습니다 . 이 경우 nditer를 컨텍스트 관리자로 사용하거나 결과를 사용하기 전에 nditer.close 메소드를 호출해야합니다. &lt;code&gt;__exit__&lt;/code&gt; 함수가 호출되었지만 이전이 아닌 임시 데이터는 원래 데이터에 다시 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">out이 주어지고 마스크 속성이 없으면 a의 마스크가 손실됩니다!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">단일 ndarray 또는 스칼라 (깊이 0의 중첩 된 목록)를 전달하면 수정되지 않은 (복사되지 않은) 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">양의 int_like 인수가 제공되면 &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 은 평균 0 및 분산 1의 일 변량 &quot;정상&quot;(가우시안) 분포에서 샘플링 된 임의의 부동 소수점으로 채워진 모양 배열 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 생성합니다 . 단일 부동 인수가 제공되지 않으면 분포에서 무작위로 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">제공된 경우 지정된 데이터 유형을 사용하도록 계산합니다. 더 자유로운 &lt;code&gt;casting&lt;/code&gt; 을해야 할 수도 있습니다.변환을 허용하기 위해 매개 변수를 . 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공되는 경우 각 피연산자에 대한 정수 목록 또는 없음입니다. 피연산자의 축 목록은 반복자의 차원에서 피연산자의 차원으로의 맵핑입니다. 항목에 -1 값을 배치하면 해당 차원이 &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">제공되는 경우, 분포에서 추출 할 가장 큰 (부호있는) 정수 위의 하나 ( &lt;code&gt;high=None&lt;/code&gt; 인 경우 동작은 위 참조 ). 배열과 같은 경우 정수 값을 포함해야합니다</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">제공된 경우 계산은이 배열로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">제공된 경우 결과를 배치 할 대상입니다. out 인수가 지정되지 않은 경우 연결된 모양과 일치하는 모양이 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">제공된 경우 결과를 배치 할 대상입니다. out 인수가 지정되지 않은 경우 스택이 반환 한 것과 일치하는 형태가 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">제공된 경우 분포에서 추출 할 가장 큰 부호있는 정수 ( &lt;code&gt;high=None&lt;/code&gt; 인 경우 동작 참조 ).</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 &lt;code&gt;dtype&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 dtype이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 dtype이어야합니다. 참고 것을 &lt;code&gt;out&lt;/code&gt; 항상 버퍼링 경우 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; 더 나은 성능을 위해 다른 모드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">제공된 경우 결과가이 배열에 배치됩니다. 적절한 모양과 dtype이어야합니다. 참고 것을 &lt;code&gt;out&lt;/code&gt; 항상 버퍼링 경우 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; 더 나은 성능을 위해 다른 모드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">제공된 경우이 배열은 결과로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">False로 설정하면 반환 된 배열은 항상 읽기 전용입니다. 그렇지 않으면 원래 배열이면 쓸 수 있습니다. 가능하면이를 False로 설정하는 것이 좋습니다 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">문자열 &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; 하면 1.13 레거시 인쇄 모드가 활성화됩니다. 이것은 float의 부호 위치에 공백을 포함하고 0d 배열의 다른 동작으로 numpy 1.13 인쇄 출력과 비슷합니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 레거시 모드가 비활성화됩니다. 인식 할 수없는 문자열은 앞으로 호환성에 대한 경고와 함께 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">슬라이스 표기법을 사용하는 경우 구문 &lt;code&gt;start:stop:step&lt;/code&gt; 은 괄호 안의 &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; 와 같습니다 . 그러나, &lt;code&gt;step&lt;/code&gt; 가 허수 (즉, 100j) 인 경우, 정수 부분은 원하는 수의 포인트로 해석되며 시작 및 중지는 포함됩니다. 즉, &lt;code&gt;start:stop:stepj&lt;/code&gt; 는 괄호 안에 &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; 로 해석 됩니다. 슬라이스 표기법의 확장 후, 모든 쉼표로 구분 된 시퀀스는 함께 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아 무시되는 경우 (및 &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ) &lt;code&gt;RankWarning&lt;/code&gt; 가 발생합니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 하위 다항식에 피팅하면 일반적으로 경고가 제거됩니다 (물론 원하는 것은 아닐 수도 있습니다. 작동하지 않는 정도를 선택하기위한 독립적 인 이유가있는 경우 : a) 그 이유를 재고하고 /하거나 b) 데이터 품질을 재고하십시오. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아 무시되는 경우 &lt;code&gt;RankWarning&lt;/code&gt; 이 발행됩니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 낮은 차수를 사용하면 일반적으로 경고가 사라집니다. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">스파 스가 False 인 경우 :</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">스파 스가 참인 경우 :</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">스파 스가 true로 설정된 경우 그리드는 스파 스 표현으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정하면 모든 필드가 제공된 바이트 순서로 변경됩니다. 그렇지 않으면 기본 바이트 순서가 사용됩니다. 사용 가능한 모든 문자열 지정자에 대해서는 &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">state가 사전 인 경우 BitGenerators &lt;code&gt;state&lt;/code&gt; 속성을 사용하여 직접 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">(더 이상 사용되지 않는) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 설정된 경우, 이는 다른 의미를 갖습니다. 즉 base는 복사 배열시 현재 배열이 복사 될 배열입니다. 이 두 함수에 대한 기본 속성의 오버로드는 향후 버전의 NumPy에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">경우] &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체는 구조화 된 배열 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;필드&lt;/a&gt; 배열의 사전과 같은, 문자열 배열을 인덱싱하여 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">경우 &lt;code&gt;order&lt;/code&gt; 키워드 인수가 지정됩니다. 이 동작은 NumPy의 버그입니다.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">상기 중간 &lt;code&gt;width&lt;/code&gt; 값이 불충분하고, 무시되며, &lt;code&gt;num&lt;/code&gt; 이진 (리턴한다 &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) 또는 2의 보수 ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) 양식을 그것의 수를 나타내는 데 필요한 비트들의 최소 수와 동일한 폭 지정된 양식. 이 동작은 더 이상 사용되지 않으며 나중에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">SVD 계산이 수렴하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">액세스 한 필드가 하위 배열 인 경우 하위 배열의 크기가 결과 모양에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">누산기가 너무 작은 경우 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">배열에 마스크가 없으면 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 의 주소 가 반환됩니다. 이 주소는 일반적으로 메모리의 데이터에 가깝지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">NumPy의 방송 규칙에 따라 어레이가 새 모양과 호환되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">버퍼에 머신 바이트 순서가 아닌 데이터가있는 경우 데이터 유형의 일부로 지정해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">공통 데이터 유형을 미리 알고 있으면이 플래그를 사용하지 마십시오. 대신, 모든 피연산자에 요청 된 dtype을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">조건이 호출 가능한 경우 런타임에 동적으로 결정을 내리는 데 사용됩니다. 이는 테스트 스위트가 실제로 실행될 때까지 비용을 지연시키기 위해 값 비싼 가져 오기가 필요한 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">변환이 불가능한 경우</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">ctypes 모듈을 사용할 수없는 경우 배열 객체의 ctypes 속성은 여전히 ​​유용한 것을 반환하지만 ctypes 객체는 반환되지 않으며 대신 오류가 발생할 수 있습니다. 특히 객체에는 여전히 &lt;code&gt;as_parameter&lt;/code&gt; 속성이 있으며이 속성은 data 속성과 동일한 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">현재 도메인이 구간 &lt;code&gt;[l1, r1]&lt;/code&gt; 이고 윈도우가 &lt;code&gt;[l2, r2]&lt;/code&gt; 인 경우 선형 맵핑 함수 &lt;code&gt;L&lt;/code&gt; 은 다음 방정식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">데이터 유형이 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 인 경우 다른 데이터 유형의 집계 ( &lt;em&gt;예 :&lt;/em&gt; 정수 및 부동 소수점으로 구성된 배열 항목 설명)</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">데이터 유형이 하위 배열 인 경우 해당 모양 및 데이터 유형은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">예를 들어, 분해가 실패 &lt;code&gt;a&lt;/code&gt; 경우 a 가 양의 한정이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가&lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가&lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 의 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가&lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;code&gt;ndarray&lt;/code&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가 &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 으로 전달되지 않습니다. 하위 클래스의 메소드&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가 &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; 로 전달되지 않습니다. 하위 클래스의 메소드&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;code&gt;ndarray&lt;/code&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">치수가 &lt;code&gt;a&lt;/code&gt; 는 2 이하이다.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 불연속성 이 &lt;code&gt;pi&lt;/code&gt; 보다 작은 경우 보다 &lt;code&gt;discont&lt;/code&gt; 보다 큰 경우 2 * pi 보수를 사용하면 불연속성이 더 커지므로 언 래핑이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">고유 값 계산이 수렴하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">파일에 피클 데이터가 포함되어 있으면 피클에 저장된 모든 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">파일이 &lt;code&gt;.npy&lt;/code&gt; 인 경우 파일이면 단일 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">파일이 &lt;code&gt;.npz&lt;/code&gt; 파일 인 경우, 리턴 된 값은 열린 함수와 유사한 방식으로 컨텍스트 관리자 프로토콜을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">파일이 &lt;code&gt;.npz&lt;/code&gt; 파일 인 경우 &lt;code&gt;{filename: array}&lt;/code&gt; 키-값 쌍 (아카이브의 각 파일에 대해 하나씩)을 포함하는 사전과 유사한 오브젝트가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">파일 이름이 &lt;code&gt;.gz&lt;/code&gt; 로 끝나면 파일은 자동으로 압축 된 gzip 형식으로 저장됩니다. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; 는 gzip으로 압축 된 파일을 투명하게 이해합니다.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">첫 번째 인수가 1 차원 인 경우 행 벡터로 처리됩니다. 마지막 인수가 1 차원 인 경우 열 벡터로 처리됩니다. 다른 인수는 2 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">첫 번째 인수가 1 차원 인 경우 행 벡터로 취급됩니다. 마지막 인수가 1 차원 인 경우 열 벡터로 처리됩니다. 다른 인수는 2 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">첫 번째 인수가 1-D이면 1을 차원 앞에 추가하여 행렬로 승격합니다. 행렬 곱셈 후 앞에 붙인 1이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">첫 번째 인수가 튜플이면 다른 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">다음 방정식이 요소 별 True이면 &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">다음 방정식이 요소 별 True이면 allclose는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">주어진 문자열이 같으면 &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; 은 아무 것도 수행하지 않습니다. 동일하지 않으면 AssertionError가 발생하고 문자열 사이의 차이가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double dot()&lt;/code&gt; 용 프로토 타입이 포함 된 헤더 파일 에 래핑하려는 다른 프로토 타입도 포함되어 있으므로이 헤더 파일 을 &lt;code&gt;%include&lt;/code&gt; 해야하는 경우 &lt;code&gt;%ignore dot;&lt;/code&gt; 도 필요합니다 . 지시문은 &lt;code&gt;%rename&lt;/code&gt; 뒤 및 &lt;code&gt;%include&lt;/code&gt; 지시문 앞에 배치 됩니다 . 또는 해당 함수가 클래스 메서드 인 경우 &lt;code&gt;%ignore&lt;/code&gt; 외에도 &lt;code&gt;%inline&lt;/code&gt; 대신 &lt;code&gt;%extend&lt;/code&gt; 를 사용하려고합니다. .</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">인덱스 표현식에 쉼표로 구분 된 배열이 있으면 첫 번째 축을 따라 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">인덱스 표현식에 슬라이스 표기법 또는 스칼라가 포함 된 경우 슬라이스 표기법으로 표시되는 범위로 1 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">입력 &lt;code&gt;a&lt;/code&gt; 에 허수 부가 포함되어 있으면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">입력 파일이 없거나 읽을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">입력에 정수 유형이 있으면 함수는 np.max와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">입력에 정수 유형이 있으면 함수는 np.min과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">입력이 2d이고 축이 지정된 경우 결과는 목록의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">입력이 1 차원이 아니거나 음수 값을 가진 요소를 포함하거나 &lt;code&gt;minlength&lt;/code&gt; 가 음수 인 경우</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 매개 변수 &lt;code&gt;n&lt;/code&gt; 이 입력 크기보다 큰 경우 끝에 0을 추가하여 입력을 채 웁니다. 이것이 일반적인 접근이지만 놀라운 결과를 초래할 수 있습니다. 다른 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 수행해야합니다. .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">입력이 ndarray이면 np.greater는 '&amp;gt;'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">입력 또는 dtype이 복잡한 경우 출력은 복잡한 평면의 로그 나선형을 따릅니다. (두 점을 통과하는 나선의 수는 무한합니다. 출력은 가장 짧은 경로를 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">반복자가 버퍼링되면 사용중인 버퍼의 크기를 반환하고, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">반복자가 다중 색인을 추적하는 경우, 다중 색인을 지원하지 않으며 다중 표시가 필요하지 않은 경우 가능한 반복기 최적화를 수행합니다. 이 기능은 반복기를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 마지막 치수 가 다른 경우.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
