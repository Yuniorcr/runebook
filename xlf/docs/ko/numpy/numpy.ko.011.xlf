<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="79b6b61d48a464831755d05e96c5b24edef1de03" translate="yes" xml:space="preserve">
          <source>Calculates which of the given dates are valid days, and which are not.</source>
          <target state="translated">주어진 날짜 중 어느 날짜가 유효한지 계산하고 그렇지 않은 날짜를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="dc6751bd6532a841494c31d2cb271a6c23434bcc" translate="yes" xml:space="preserve">
          <source>Calculation</source>
          <target state="translated">Calculation</target>
        </trans-unit>
        <trans-unit id="05d27dcc239bf9ea22989ad95d110b65fd4d9edb" translate="yes" xml:space="preserve">
          <source>Calculations</source>
          <target state="translated">Calculations</target>
        </trans-unit>
        <trans-unit id="c0b95ddbd1bbdb09cd17ce1c430a7adeedcc6050" translate="yes" xml:space="preserve">
          <source>Calculus</source>
          <target state="translated">Calculus</target>
        </trans-unit>
        <trans-unit id="dde8f3e3d46e069dd8c9fb51c5a6b6c4238ef493" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt;&lt;code&gt;default_rng&lt;/code&gt;&lt;/a&gt; to get a new instance of a &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, then call its methods to obtain samples from different distributions. By default, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt; uses bits provided by &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; which has better statistical properties than the legacy &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; used in &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generator#numpy.random.default_rng&quot;&gt; &lt;code&gt;default_rng&lt;/code&gt; &lt;/a&gt; 를 호출 하여 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 의 새 인스턴스를 가져온 다음 해당 메서드를 호출하여 다른 분포에서 샘플을 얻습니다. 기본적으로, &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 에 의해 제공되는 비트 사용 &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 기존보다 통계적 특성 갖는다 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 에 사용 &lt;a href=&quot;legacy#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f6b577a771e51546f11b433f88a97b7ef013570b" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt;&lt;code&gt;PyType_Ready&lt;/code&gt;&lt;/a&gt; (&amp;lt;pointer_to_new_type&amp;gt;). If this function returns a negative number, a failure occurred and the type is not initialized. Otherwise, the type is ready to be used. It is generally important to place a reference to the new type into the module dictionary so it can be accessed from Python.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/type.html#c.PyType_Ready&quot;&gt; &lt;code&gt;PyType_Ready&lt;/code&gt; &lt;/a&gt; (&amp;lt;pointer_to_new_type&amp;gt;)를 호출합니다 . 이 함수가 음수를 반환하면 오류가 발생한 것이며 유형이 초기화되지 않은 것입니다. 그렇지 않으면 유형을 사용할 수 있습니다. Python에서 액세스 할 수 있도록 모듈 사전에 새 유형에 대한 참조를 배치하는 것이 일반적으로 중요합니다.</target>
        </trans-unit>
        <trans-unit id="a7ae805fe3a980ab68679634a23dd94bc9a8df1d" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.istitle&quot;&gt;&lt;code&gt;str.istitle&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.istitle&quot;&gt; &lt;code&gt;str.istitle&lt;/code&gt; &lt;/a&gt; 요소별로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="06bc728b5e5b35273ca51712ef8ae8852bdbd2d2" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isupper&quot;&gt;&lt;code&gt;str.isupper&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isupper&quot;&gt; &lt;code&gt;str.isupper&lt;/code&gt; &lt;/a&gt; 요소별로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="701a114d7859731737d975ce4c73a842f922137d" translate="yes" xml:space="preserve">
          <source>Call &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.lower&quot;&gt;&lt;code&gt;str.lower&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.lower&quot;&gt; &lt;code&gt;str.lower&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="bdf175380f108b91b68b35d6cba860e239285fd3" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.istitle&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.istitle&lt;/code&gt; 을 요소별로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="d5bbdd4afe52a03da69e768bb6350617fd2c2fe8" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.isupper&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isupper&lt;/code&gt; 를 요소 단위로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="204bec18a0c758d4b92300d3ccfda2d8f2d41215" translate="yes" xml:space="preserve">
          <source>Call &lt;code&gt;str.lower&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.lower&lt;/code&gt; 를 요소 단위로 호출 하십시오 .</target>
        </trans-unit>
        <trans-unit id="eef266f410d282365eeaef6f6541415ad4d67585" translate="yes" xml:space="preserve">
          <source>Call self as a function.</source>
          <target state="translated">자신을 함수라고 부릅니다.</target>
        </trans-unit>
        <trans-unit id="0ce1402d6ef90df67129aaaa626b1d87878afa44" translate="yes" xml:space="preserve">
          <source>Call the function from the library with the ctypes arguments.</source>
          <target state="translated">ctypes 인수를 사용하여 라이브러리에서 함수를 호출합니다.</target>
        </trans-unit>
        <trans-unit id="ef89b4e2063118e4442bf0889dbb070ab91c9c17" translate="yes" xml:space="preserve">
          <source>Call-back arguments</source>
          <target state="translated">콜백 인수</target>
        </trans-unit>
        <trans-unit id="15c31ea3c3e58bb848d60b8d742bb0dbf90efb7a" translate="yes" xml:space="preserve">
          <source>Callable to test</source>
          <target state="translated">테스트 호출 가능</target>
        </trans-unit>
        <trans-unit id="8829f8e417cdbefc80e5f0018c56210ff40f16e6" translate="yes" xml:space="preserve">
          <source>Callback upon error:</source>
          <target state="translated">오류시 콜백 :</target>
        </trans-unit>
        <trans-unit id="095dfbda4be2a7c23470a2f28679717480fb723d" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;add&lt;/code&gt; then yields:</source>
          <target state="translated">&lt;code&gt;add&lt;/code&gt; 를 호출 하면 다음이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="11e32184ce81143ebb10c040c662152029bc28ed" translate="yes" xml:space="preserve">
          <source>Calling C-code from Python can result in Python crashes if you are not careful. None of the approaches in this chapter are immune. You have to know something about the way data is handled by both NumPy and by the third-party library being used.</source>
          <target state="translated">Python에서 C 코드를 호출하면주의하지 않으면 Python 충돌이 발생할 수 있습니다. 이 장의 어떤 접근 방식도 면역성이 없습니다. NumPy와 사용중인 타사 라이브러리 모두에서 데이터를 처리하는 방식에 대해 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="7a6041d361fd40eeecfd3b783ee25742eac73334" translate="yes" xml:space="preserve">
          <source>Calling f2py from Python</source>
          <target state="translated">Python에서 f2py 호출</target>
        </trans-unit>
        <trans-unit id="627187305b11d0b40ef311920110ebf177a808de" translate="yes" xml:space="preserve">
          <source>Calling other compiled libraries from Python</source>
          <target state="translated">Python에서 다른 컴파일 된 라이브러리 호출</target>
        </trans-unit>
        <trans-unit id="45cc60363cb41b7ffde77fcffd01fb398e2212aa" translate="yes" xml:space="preserve">
          <source>Calling the function</source>
          <target state="translated">함수 호출</target>
        </trans-unit>
        <trans-unit id="484348cd0323c316b9d2d9f701404a0240c07169" translate="yes" xml:space="preserve">
          <source>Calling this test function finds and runs all tests associated with the module and all its sub-modules.</source>
          <target state="translated">이 테스트 함수를 호출하면 모듈 및 모든 하위 모듈과 관련된 모든 테스트를 찾아 실행합니다.</target>
        </trans-unit>
        <trans-unit id="2512b69cd7f2bd72a4472fa70cc41b4cdce17964" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.capitalize&quot;&gt;&lt;code&gt;str.capitalize&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.capitalize&quot;&gt; &lt;code&gt;str.capitalize&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="83f157ca9da306e4292c0703de0af5cd433ea4cc" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.center&quot;&gt;&lt;code&gt;str.center&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.center&quot;&gt; &lt;code&gt;str.center&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f58c05e6164110da4631f4525ef9605fa4bc6a93" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.count&quot;&gt;&lt;code&gt;str.count&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.count&quot;&gt; &lt;code&gt;str.count&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f76a0fdbe900eef0f77fc7210a232c0754707b8b" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt;&lt;code&gt;str.encode&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.encode&quot;&gt; &lt;code&gt;str.encode&lt;/code&gt; 를&lt;/a&gt; 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="42c44c816f7d4cff3f63d8d28cd128395e2938b0" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.endswith&quot;&gt;&lt;code&gt;str.endswith&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.endswith&quot;&gt; &lt;code&gt;str.endswith&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5a84043cdb61087db55662a9b4240cf6bb9effed" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.expandtabs&quot;&gt;&lt;code&gt;str.expandtabs&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.expandtabs&quot;&gt; &lt;code&gt;str.expandtabs&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="07a99aafbaee2d00a12309b85e6a021f1bf285c9" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.find&quot;&gt;&lt;code&gt;str.find&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.find&quot;&gt; &lt;code&gt;str.find&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1305831dec98b91cd3d872f6bd529fd990949782" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.index&quot;&gt;&lt;code&gt;str.index&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.index&quot;&gt; &lt;code&gt;str.index&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="7ea4a1136902c95fed9ac866baf07e18e2d6d34d" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isalnum&quot;&gt;&lt;code&gt;str.isalnum&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isalnum&quot;&gt; &lt;code&gt;str.isalnum&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="debba3c522c2b0937155273812912efb89464dee" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isalpha&quot;&gt;&lt;code&gt;str.isalpha&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isalpha&quot;&gt; &lt;code&gt;str.isalpha&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="ad919c52074bf57251bd4e9a4b4675f7c898ec94" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isdigit&quot;&gt;&lt;code&gt;str.isdigit&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isdigit&quot;&gt; &lt;code&gt;str.isdigit&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="df6644a7f2da7cf89e130c3b720fa3f60b19bc0a" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.islower&quot;&gt;&lt;code&gt;str.islower&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.islower&quot;&gt; &lt;code&gt;str.islower&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a4016e51b01268a1571ce8593055cc5a641314ce" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isspace&quot;&gt;&lt;code&gt;str.isspace&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.isspace&quot;&gt; &lt;code&gt;str.isspace&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="756828056a0ca4138be656cb0dcebf1013855c58" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.join&quot;&gt;&lt;code&gt;str.join&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소별로 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.join&quot;&gt; &lt;code&gt;str.join&lt;/code&gt; 을&lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5dc17a87838148031e0e0867bb6e31047de25251" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.ljust&quot;&gt;&lt;code&gt;str.ljust&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.ljust&quot;&gt; &lt;code&gt;str.ljust&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="51a1aef779798a1d7610d6a4acb8ac625f08ed44" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.lstrip&quot;&gt;&lt;code&gt;str.lstrip&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.lstrip&quot;&gt; &lt;code&gt;str.lstrip&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="caf03bdd90f2ebcecca98c80098be0e875c15c59" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.partition&quot;&gt;&lt;code&gt;str.partition&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.partition&quot;&gt; &lt;code&gt;str.partition&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eff222bfdc3899d31267dc1d126953aa6bf2e1c9" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.replace&quot;&gt;&lt;code&gt;str.replace&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소별로 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.replace&quot;&gt; &lt;code&gt;str.replace&lt;/code&gt; 를&lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="02c95c24f3e60a10d4ae0baac24fcee4004f6cdd" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rfind&quot;&gt;&lt;code&gt;str.rfind&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rfind&quot;&gt; &lt;code&gt;str.rfind&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="33c0f700a3bd8aec1d5d0eabd66912f9fb7464dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rindex&quot;&gt;&lt;code&gt;str.rindex&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rindex&quot;&gt; &lt;code&gt;str.rindex&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c515ab3375ea39a7af2d741964e1365836831f74" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rjust&quot;&gt;&lt;code&gt;str.rjust&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rjust&quot;&gt; &lt;code&gt;str.rjust&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a810ab49c794e5f2009cb154e93d92f6a6efed36" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rpartition&quot;&gt;&lt;code&gt;str.rpartition&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rpartition&quot;&gt; &lt;code&gt;str.rpartition&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="d942f9d9e34c2fc49ae8c69ec2edb19b34ffd9bd" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rsplit&quot;&gt;&lt;code&gt;str.rsplit&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rsplit&quot;&gt; &lt;code&gt;str.rsplit&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dae1487311b6107ec19d129af4a8f28cdf4c2eb0" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rstrip&quot;&gt;&lt;code&gt;str.rstrip&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.rstrip&quot;&gt; &lt;code&gt;str.rstrip&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="940415b22c43472d38fc8462bc40a5e14c3913f9" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.split&quot;&gt;&lt;code&gt;str.split&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.split&quot;&gt; &lt;code&gt;str.split&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="dba3cb11b8018069d8942bdcc5c31246fc482f12" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.splitlines&quot;&gt;&lt;code&gt;str.splitlines&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.splitlines&quot;&gt; &lt;code&gt;str.splitlines&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="001acd3f226af596467a1ea2ade36812a8eb960d" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.startswith&quot;&gt;&lt;code&gt;str.startswith&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소별로 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.startswith&quot;&gt; &lt;code&gt;str.startswith&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="eb8c2c9905658b7020e96e32d2820c597706a134" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.strip&quot;&gt;&lt;code&gt;str.strip&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.strip&quot;&gt; &lt;code&gt;str.strip&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="11af8fcbaa838abf9ece09a05815c6f9d63d309f" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.swapcase&quot;&gt;&lt;code&gt;str.swapcase&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.swapcase&quot;&gt; &lt;code&gt;str.swapcase&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e478a251bc3c46e5793bc02f633fb866dd00237d" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.title&quot;&gt;&lt;code&gt;str.title&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.title&quot;&gt; &lt;code&gt;str.title&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f41bb1516554fd2525b8d737f1abbbe090abefa2" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.translate&quot;&gt;&lt;code&gt;str.translate&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.translate&quot;&gt; &lt;code&gt;str.translate&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="f9b5163f1c4284f94b1ab13c468461e0910a82ce" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.upper&quot;&gt;&lt;code&gt;str.upper&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.upper&quot;&gt; &lt;code&gt;str.upper&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="38ae0e49a6cde63eff5c849b53329876513490e3" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.zfill&quot;&gt;&lt;code&gt;str.zfill&lt;/code&gt;&lt;/a&gt; element-wise.</source>
          <target state="translated">요소 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#str.zfill&quot;&gt; &lt;code&gt;str.zfill&lt;/code&gt; &lt;/a&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="5ddbcf21043a5f353f23ca4baba1595ba4a4c298" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.capitalize&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.capitalize&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fac61b23fdecfba854b4b4efab7777fd152b2cd6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.center&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.center&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1314c79da136d136fb6bbb829ea41b9418ad141a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.count&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.count&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="4bdc60efe7fe548bd722d4044bc214b413e9d4dd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.decode&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.decode&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="065d9a82f4f8e8be749e189a1fda4fbbe3abbe4a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.encode&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.encode&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="c1788f723cdc513a1b82d19f6d756a8fad670e36" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.endswith&lt;/code&gt; element-wise.</source>
          <target state="translated">요소 &lt;code&gt;str.endswith&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1506c8828926db71b8ee1e63d0d49604826d93cb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.expandtabs&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.expandtabs&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3c7293ade2e69f10fa46947bf34f0b6e9553dda9" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.find&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.find&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="467102d858ecdef3b85b56bdb57ad38edb734308" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.index&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.index&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="9028b020672a2d11380a1f6acfdb2435aab492c0" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalnum&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isalnum&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="fd4a785af6221c540650fb70b847d1cefb209fda" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isalpha&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isalpha&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="656252d18256f4f02da62d1b2291d93d00dda7e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isdigit&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isdigit&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2a85e1b04f3860c701786f2c9eabf6a753b661de" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.islower&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.islower&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2bb68da644aa463ff4c1c36c7d9b40bf8b8f64bc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.isspace&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.isspace&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="741c3bea47e11f849d26dfea4d3d3a40eab3c129" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.join&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.join&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="a819deb9a44d524ac6731b6be53354ba9f42a375" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.ljust&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.ljust&lt;/code&gt; 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="be80be96a9f5d678d3f84ce0ae913fd30691c166" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.lstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.lstrip&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="3a06e70f258111f5ace799d0136012a728b9986f" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.partition&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.partition&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="887a34caef57804ead86c1cf188ead795251b5a4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.replace&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.replace&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="05d90debebac8c8e525b11c833af03b1809c3595" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rfind&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rfind&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="89bfa6c81f923111ab3ece5d1065bb7a8b18172a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rindex&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rindex&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="55188dcc2c20e117f83220adcd9445f8940213ba" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rjust&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rjust&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="19291c82bbc252e358dcd5efe30bebd4ce3f47fc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rpartition&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rpartition&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="e30544ad22292a0898136208de2fa5fc236f97f4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rsplit&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rsplit&lt;/code&gt; 호출 요소 단위로 .</target>
        </trans-unit>
        <trans-unit id="bf3f027903bcb2fa17e73f1d36c8446f531dbe5a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.rstrip&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.rstrip&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="739adfdb756eef5e48a6b103e3600e5bc999cb7a" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.split&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.split&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="b5e51ab4b44c03ea14d792300213b602772f9ea6" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.splitlines&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.splitlines&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="6c953fe5d272055ef6fdc5b65d12465c629e73e4" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.startswith&lt;/code&gt; element-wise.</source>
          <target state="translated">요소별로 &lt;code&gt;str.startswith&lt;/code&gt; 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="1827eeaf19d2fb7a578c669a1d5307476f133fcd" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.strip&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.strip&lt;/code&gt; 을 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="274bbb89ddefdfebcf8c0b98e05e899bc5eb9615" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.swapcase&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.swapcase&lt;/code&gt; 를 요소 단위로 호출합니다 .</target>
        </trans-unit>
        <trans-unit id="2bc28d6c4e67250d03ac5f9ac2fcd548d24d6297" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.title&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.title&lt;/code&gt; 호출 요소 단위로 .</target>
        </trans-unit>
        <trans-unit id="91315156a48280f48729eabe9ec7862779adc8d2" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.translate&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.translate&lt;/code&gt; 통화 요소 현명한.</target>
        </trans-unit>
        <trans-unit id="2440d757fee8b2705315ead5568e7af63f8335a3" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.upper&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.upper&lt;/code&gt; 호출 요소 단위로 .</target>
        </trans-unit>
        <trans-unit id="691e1fcbb97130e6abfe067256904d840bcc927b" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;str.zfill&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;str.zfill&lt;/code&gt; 호출 요소 단위로 .</target>
        </trans-unit>
        <trans-unit id="9c60fe9461b9d2c89f3c3e872dadf8ad18517837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isdecimal&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;unicode.isdecimal&lt;/code&gt; 을 호출합니다. 요소 단위로 .</target>
        </trans-unit>
        <trans-unit id="c6e0a82d42fca087f606e832d63a055b7b362137" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;unicode.isnumeric&lt;/code&gt; element-wise.</source>
          <target state="translated">&lt;code&gt;unicode.isnumeric&lt;/code&gt; 을 호출합니다. 요소 단위로 .</target>
        </trans-unit>
        <trans-unit id="79ab673318d7c81b7f76879d7f7e6d0f3ff543f1" translate="yes" xml:space="preserve">
          <source>Can be a local file or a remote URL.</source>
          <target state="translated">로컬 파일 또는 원격 URL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a90e6085e13ad6ee060ad3eac04d655f92454003" translate="yes" xml:space="preserve">
          <source>Can be read from a filelike stream object instead of an actual file.</source>
          <target state="translated">실제 파일 대신 파일과 같은 스트림 객체에서 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="22f6ea93b575f4da64882fc6b779b0f07dc62149" translate="yes" xml:space="preserve">
          <source>Can be scalar or non-scalar. If non-scalar, the resulting filled array should be broadcastable over input array. Default is None.</source>
          <target state="translated">스칼라 또는 비스 칼라일 수 있습니다. 스칼라가 아닌 경우 결과로 채워진 배열은 입력 배열을 통해 브로드 캐스팅 가능해야합니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="07932047b9de074a44eece379f541bd670890cdd" translate="yes" xml:space="preserve">
          <source>Can be used, for example, to add broadcasting to a built-in Python function (see Examples section).</source>
          <target state="translated">예를 들어 내장 Python 함수에 브로드 캐스트를 추가하는 데 사용할 수 있습니다 (예제 섹션 참조).</target>
        </trans-unit>
        <trans-unit id="7139132bf88ca6d9cbbfb32a613254727892bf7e" translate="yes" xml:space="preserve">
          <source>Can represent all NumPy arrays including nested record arrays and object arrays.</source>
          <target state="translated">중첩 된 레코드 배열 및 개체 배열을 포함하여 모든 NumPy 배열을 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f01b544f8ac201079e369764bc5d84163c794bad" translate="yes" xml:space="preserve">
          <source>Can write code in non-standard form which may become obsolete</source>
          <target state="translated">쓸모 없게 될 수있는 비표준 형식으로 코드를 작성할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="07c566972545483ecb8e809f4eb024c341423ec5" translate="yes" xml:space="preserve">
          <source>Can you reshape an array?</source>
          <target state="translated">배열의 형태를 변경할 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="a058457334819b9647916ad868c25fa88bc97117" translate="yes" xml:space="preserve">
          <source>Cartesian (&amp;lsquo;xy&amp;rsquo;, default) or matrix (&amp;lsquo;ij&amp;rsquo;) indexing of output. See Notes for more details.</source>
          <target state="translated">출력의 데카르트 ( 'xy', 기본값) 또는 행렬 ( 'ij') 인덱싱 자세한 내용은 참고를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b5599547be57585d8ed9f9e6e56fb372b94bf366" translate="yes" xml:space="preserve">
          <source>Cash flows (must contain at least one positive and one negative value) or nan is returned. The first value is considered a sunk cost at time zero.</source>
          <target state="translated">현금 흐름 (양수 및 음수 값을 하나 이상 포함해야 함) 또는 nan이 반환됩니다. 첫 번째 값은 시간이 0 일 때 가라 앉은 비용으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="4819b90bf3135701e4238f100f5eccaffb4cf77a" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;input&lt;/code&gt; to a &lt;code&gt;PyArrayObject*&lt;/code&gt; if legal, and ensure that it is of type &lt;code&gt;typecode&lt;/code&gt;. If &lt;code&gt;input&lt;/code&gt; cannot be cast, or the &lt;code&gt;typecode&lt;/code&gt; is wrong, set a Python error and return &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">유효한 경우 &lt;code&gt;PyArrayObject*&lt;/code&gt; &lt;code&gt;input&lt;/code&gt; 을 캐스트 하고 &lt;code&gt;typecode&lt;/code&gt; 유형인지 확인하십시오 . 경우 &lt;code&gt;input&lt;/code&gt; 캐스트 할 수없는, 또는 &lt;code&gt;typecode&lt;/code&gt; 잘못, 파이썬 오류 및 반환 설정 &lt;code&gt;NULL&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="66c23409ad11975a171ee62798652be7275d78b9" translate="yes" xml:space="preserve">
          <source>Cast &lt;code&gt;n&lt;/code&gt; elements &lt;code&gt;from&lt;/code&gt; one type &lt;code&gt;to&lt;/code&gt; another. The data to cast from is in a contiguous, correctly-swapped and aligned chunk of memory pointed to by from. The buffer to cast to is also contiguous, correctly-swapped and aligned. The fromarr and toarr arguments should only be used for flexible-element-sized arrays (string, unicode, void).</source>
          <target state="translated">한 유형 &lt;code&gt;to&lt;/code&gt; 다른 유형 으로 &lt;code&gt;n&lt;/code&gt; 개의 요소 &lt;code&gt;from&lt;/code&gt; 캐스트합니다 . 캐스트 할 데이터는 from이 가리키는 연속되고 올바르게 교체되고 정렬 된 메모리 청크에 있습니다. 캐스트 할 버퍼도 연속적이고 올바르게 교체되고 정렬됩니다. fromarr 및 toarr 인수는 유연한 요소 크기의 배열 (문자열, 유니 코드, 무효)에만 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="5da405e72e65e85b0a6ff9fb710530d444100461" translate="yes" xml:space="preserve">
          <source>Cast code: This checks for &amp;ldquo;true&amp;rdquo; alignment, as it does &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; if aligned. Otherwise, it does &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; where dstval/srcval are aligned.</source>
          <target state="translated">캐스트 코드 : 정렬되면 &lt;code&gt;*dst = CASTFUNC(*src)&lt;/code&gt; 와 같이 &quot;true&quot;정렬을 확인합니다 . 그렇지 않으면 &lt;code&gt;memmove(srcval, src); dstval = CASTFUNC(srcval); memmove(dst, dstval)&lt;/code&gt; dstval / srcval이 정렬되는 .</target>
        </trans-unit>
        <trans-unit id="4dbf7f264927d9ee6c0c9230f88c1b227f370d7c" translate="yes" xml:space="preserve">
          <source>Cast the elements of the array &lt;em&gt;in&lt;/em&gt; into the array &lt;em&gt;out&lt;/em&gt;. The output array should be writeable, have an integer-multiple of the number of elements in the input array (more than one copy can be placed in out), and have a data type that is one of the builtin types. Returns 0 on success and -1 if an error occurs.</source>
          <target state="translated">배열 요소 캐스트 &lt;em&gt;에&lt;/em&gt; 어레이로 &lt;em&gt;아웃&lt;/em&gt; . 출력 배열은 쓰기 가능해야하고, 입력 배열에 여러 요소의 정수 배수 (하나 이상의 사본을 배치 할 수 있음)가 있어야하며 내장 유형 중 하나 인 데이터 유형이 있어야합니다. 성공하면 0을, 에러가 발생하면 -1을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="e6a8277578137a1b27ee47f6d99dc6ac5a6c8df7" translate="yes" xml:space="preserve">
          <source>Cast to the desired type, even if it can&amp;rsquo;t be done without losing information.</source>
          <target state="translated">정보 손실없이 수행 할 수없는 경우에도 원하는 유형으로 캐스트하십시오.</target>
        </trans-unit>
        <trans-unit id="a945bfddda4f16646c0e1e8cf16a394a39e915e6" translate="yes" xml:space="preserve">
          <source>Casting Rules</source>
          <target state="translated">캐스팅 규칙</target>
        </trans-unit>
        <trans-unit id="d72261d318c306975d7f7d2ba5ecbeb1852c1279" translate="yes" xml:space="preserve">
          <source>Casting errors interrupt Iteration</source>
          <target state="translated">캐스팅 오류로 인해 반복이 중단됩니다.</target>
        </trans-unit>
        <trans-unit id="0e43fbb5b95b8e028055445bd4f061de51dc4a06" translate="yes" xml:space="preserve">
          <source>Casting must be done on one or more of the inputs whenever the ufunc does not have a core loop implementation for the input types provided. If an implementation for the input types cannot be found, then the algorithm searches for an implementation with a type signature to which all of the inputs can be cast &amp;ldquo;safely.&amp;rdquo; The first one it finds in its internal list of loops is selected and performed, after all necessary type casting. Recall that internal copies during ufuncs (even for casting) are limited to the size of an internal buffer (which is user settable).</source>
          <target state="translated">ufunc에 제공된 입력 유형에 대한 코어 루프 구현이 없을 때마다 하나 이상의 입력에서 캐스팅을 수행해야합니다. 입력 유형에 대한 구현을 찾을 수없는 경우 알고리즘은 모든 입력을 &quot;안전하게&quot;캐스팅 할 수있는 유형 서명이있는 구현을 검색합니다. 내부 루프 목록에서 찾은 첫 번째 루프는 필요한 모든 유형 캐스팅 후에 선택되어 수행됩니다. ufuncs 동안 (캐스팅에서도) 내부 복사본은 내부 버퍼의 크기 (사용자 설정 가능)로 제한됩니다.</target>
        </trans-unit>
        <trans-unit id="8748cec5513dc9c01c715b723dcb4b372a11fea9" translate="yes" xml:space="preserve">
          <source>Casting scalars</source>
          <target state="translated">스칼라 캐스팅</target>
        </trans-unit>
        <trans-unit id="cbb26092630998f6b4ebb2584d7e63c1ad783481" translate="yes" xml:space="preserve">
          <source>Casting the set to a list gives the expected result:</source>
          <target state="translated">세트를 목록으로 캐스트하면 예상 결과가 나타납니다.</target>
        </trans-unit>
        <trans-unit id="3b9cb47a9c04d9f04e8fb247efea4728b9f0825f" translate="yes" xml:space="preserve">
          <source>Casting to allow when changing between datetime units.</source>
          <target state="translated">날짜 / 시간 단위 사이를 변경할 때 허용되는 캐스팅.</target>
        </trans-unit>
        <trans-unit id="21d50099f4ef7f76fe962077ec52f3b66d36a662" translate="yes" xml:space="preserve">
          <source>Casts a structured array to a new dtype using assignment by field-name.</source>
          <target state="translated">field-name 별 할당을 사용하여 구조화 된 배열을 새 dtype으로 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="1b7e02730ebfcc85f5732a8be223fd80563fe083" translate="yes" xml:space="preserve">
          <source>Categories are determined by first checking which of boolean, integer (int/uint), or floating point (float/complex) the maximum kind of all the arrays and the scalars are.</source>
          <target state="translated">범주는 먼저 모든 배열과 스칼라의 최대 종류가 부울, 정수 (int / uint) 또는 부동 소수점 (float / complex)인지 확인하여 결정됩니다.</target>
        </trans-unit>
        <trans-unit id="3325b57bdda8f0731fcea923488b3e46095663f1" translate="yes" xml:space="preserve">
          <source>Causes the iterator to convert all the operands to a common data type, calculated based on the ufunc type promotion rules. Copying or buffering must be enabled.</source>
          <target state="translated">반복자가 ufunc 유형 승격 규칙에 따라 계산 된 모든 피연산자를 공통 데이터 유형으로 변환합니다. 복사 또는 버퍼링이 활성화되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="f6e47e97b987638e04e1741c9188448c0cda9575" translate="yes" xml:space="preserve">
          <source>Causes the iterator to provide data for &lt;code&gt;op[i]&lt;/code&gt; that is in native byte order, aligned according to the dtype requirements, contiguous, or any combination.</source>
          <target state="translated">반복자가 &lt;code&gt;op[i]&lt;/code&gt; 에 대한 데이터를 제공하게합니다 . dtype 요구 사항, 연속 또는 임의의 조합에 따라 정렬 된 원시 바이트 순서의 .</target>
        </trans-unit>
        <trans-unit id="78cd28e519e06a8be731a725d2ee50a3144a0620" translate="yes" xml:space="preserve">
          <source>Causes the iterator to skip iteration of the innermost loop, requiring the user of the iterator to handle it.</source>
          <target state="translated">반복자가 가장 안쪽 루프의 반복을 건너 뛰도록하여 반복자의 사용자가 처리하도록합니다.</target>
        </trans-unit>
        <trans-unit id="d748728383297b4bba46340904d34590fd3f0e6c" translate="yes" xml:space="preserve">
          <source>Causes the iterator to store buffering data, and use buffering to satisfy data type, alignment, and byte-order requirements. To buffer an operand, do not specify the &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt;&lt;code&gt;NPY_ITER_COPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags, because they will override buffering. Buffering is especially useful for Python code using the iterator, allowing for larger chunks of data at once to amortize the Python interpreter overhead.</source>
          <target state="translated">반복자가 버퍼링 데이터를 저장하고 버퍼링을 사용하여 데이터 유형, 정렬 및 바이트 순서 요구 사항을 충족시킵니다. 피연산자를 버퍼링하려면 &lt;a href=&quot;#c.NPY_ITER_COPY&quot;&gt; &lt;code&gt;NPY_ITER_COPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; 를&lt;/a&gt; 지정하지 마십시오 버퍼링을 무시하므로 플래그를 . 버퍼링은 반복자를 사용하는 Python 코드에 특히 유용하므로 한 번에 더 많은 데이터 청크가 파이썬 인터프리터 오버 헤드를 상각 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbe86966ee1567b8621995982683f047543e592a" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a multi-index. This prevents the iterator from coalescing axes to produce bigger inner loops. If the loop is also not buffered and no index is being tracked (&lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; can be called), then the iterator size can be &lt;code&gt;-1&lt;/code&gt; to indicate that the iterator is too large. This can happen due to complex broadcasting and will result in errors being created when the setting the iterator range, removing the multi index, or getting the next function. However, it is possible to remove axes again and use the iterator normally if the size is small enough after removal.</source>
          <target state="translated">반복자가 다중 색인을 추적하도록합니다. 이것은 반복자가 축을 합쳐서 더 큰 내부 루프를 생성하는 것을 방지합니다. 루프도 버퍼링되지 않고 인덱스가 추적되지 않으면 ( &lt;code&gt;NpyIter_RemoveAxis&lt;/code&gt; 를 호출 할 수 있음) 반복기 크기가 &lt;code&gt;-1&lt;/code&gt; 일 수 있으므로 반복기가 너무 크다는 것을 나타냅니다. 이는 복잡한 브로드 캐스트로 인해 발생할 수 있으며 반복기 범위를 설정하거나 다중 인덱스를 제거하거나 다음 기능을 가져올 때 오류가 발생합니다. 그러나 제거 후 크기가 충분히 작 으면 축을 다시 제거하고 반복기를 정상적으로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a78370684072181888bd07868c0ae200011c6b51" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching C order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복자가 C 순서와 일치하는 평면 인덱스를 추적하도록합니다. 이 옵션은 &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="d09f5eb17dd94e9b8185491d29ffd82541173b9e" translate="yes" xml:space="preserve">
          <source>Causes the iterator to track a raveled flat index matching Fortran order. This option cannot be used with &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복기가 포트란 순서와 일치하는 평면 인덱스를 추적하도록합니다. 이 옵션은 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 사용할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="c373af68347ef344e2a4047a6349667bfbe022fd" translate="yes" xml:space="preserve">
          <source>Chain exceptions to give better error messages for invalid PEP3118 format strings</source>
          <target state="translated">잘못된 PEP3118 형식 문자열에 대해 더 나은 오류 메시지를 제공하는 체인 예외</target>
        </trans-unit>
        <trans-unit id="c0df50e511723d6385d81becfe6c98c0ca2c5dad" translate="yes" xml:space="preserve">
          <source>Chained array operations, in efficient calculation order, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;numpy.einsum_path&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">효율적인 연산 순서 체인화 어레이 동작, &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;numpy.einsum_path&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9f53c2498e2f3ad3fca9000468a403dc1def6c7" translate="yes" xml:space="preserve">
          <source>Chained array operations. For more complicated contractions, speed ups might be achieved by repeatedly computing a &amp;lsquo;greedy&amp;rsquo; path or pre-computing the &amp;lsquo;optimal&amp;rsquo; path and repeatedly applying it, using an &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt;&lt;code&gt;einsum_path&lt;/code&gt;&lt;/a&gt; insertion (since version 1.12.0). Performance improvements can be particularly significant with larger arrays:</source>
          <target state="translated">체인 배열 연산. 더 복잡한 수축을 위해서는`` &lt;a href=&quot;numpy.einsum_path#numpy.einsum_path&quot;&gt; &lt;code&gt;einsum_path&lt;/code&gt; &lt;/a&gt; ''경로를 반복적으로 계산하거나`` sumal ''경로를 사전 계산하고 einsum_path 삽입 (버전 1.12.0 이후)을 사용하여 반복적으로 적용하여 속도를 높일 수 있습니다. 더 큰 어레이에서는 성능 향상이 특히 중요 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2f66124ffbf2b61dad435e8d896285892e43e6a" translate="yes" xml:space="preserve">
          <source>Chained dot product.</source>
          <target state="translated">연쇄 내적.</target>
        </trans-unit>
        <trans-unit id="4b14b1641c23a3ee01fb58fe8633eb893f1634ef" translate="yes" xml:space="preserve">
          <source>Change elements of an array based on conditional and input values.</source>
          <target state="translated">조건부 및 입력 값을 기준으로 배열의 요소를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="01dcb981588ac5e81e8962905c01357fef0a774b" translate="yes" xml:space="preserve">
          <source>Change output of &lt;code&gt;round&lt;/code&gt; on scalars to be consistent with Python</source>
          <target state="translated">Python과 일치하도록 스칼라에 대한 &lt;code&gt;round&lt;/code&gt; 출력 변경</target>
        </trans-unit>
        <trans-unit id="03e304dc68ffb07e8cb055b859df002401eafba4" translate="yes" xml:space="preserve">
          <source>Change shape and size of array in-place.</source>
          <target state="translated">배열의 모양과 크기를 제자리에서 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e18523f3dc9af0b0d781daa5529bbdd8c6b73861" translate="yes" xml:space="preserve">
          <source>Change the byte-ordering information in the array dtype so that it interprets the underlying data as being in a different byte order. This is the role of &lt;code&gt;arr.newbyteorder()&lt;/code&gt;</source>
          <target state="translated">기본 데이터를 다른 바이트 순서로 해석하도록 배열 dtype의 바이트 순서 정보를 변경합니다. 이것은 &lt;code&gt;arr.newbyteorder()&lt;/code&gt; 의 역할입니다.</target>
        </trans-unit>
        <trans-unit id="51d2004fb81c8f1c875ffbaa2ebee0d486f11763" translate="yes" xml:space="preserve">
          <source>Change the byte-ordering of the underlying data, leaving the dtype interpretation as it was. This is what &lt;code&gt;arr.byteswap()&lt;/code&gt; does.</source>
          <target state="translated">dtype 해석은 그대로두고 기본 데이터의 바이트 순서를 변경합니다. 이것이 &lt;code&gt;arr.byteswap()&lt;/code&gt; 는 일입니다.</target>
        </trans-unit>
        <trans-unit id="7c78cf8387f58f6da3c59f8db55e089f69c5453e" translate="yes" xml:space="preserve">
          <source>Change the directory:</source>
          <target state="translated">디렉토리 변경 :</target>
        </trans-unit>
        <trans-unit id="1baf38892b5a38369da2ab3d5066a1bc5faa26e9" translate="yes" xml:space="preserve">
          <source>Change the shape of an array without changing its data.</source>
          <target state="translated">데이터를 변경하지 않고 배열의 모양을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="57cca933dc4ae8712cc751b049a24d49a1cbe977" translate="yes" xml:space="preserve">
          <source>Change the sign of x1 to that of x2, element-wise.</source>
          <target state="translated">x1의 부호를 요소 별 x2의 부호로 바꿉니다.</target>
        </trans-unit>
        <trans-unit id="f1fd8269d290cf6173d8944feb182f6867a500ae" translate="yes" xml:space="preserve">
          <source>Change the vector definition of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; using &lt;code&gt;axisa&lt;/code&gt; and &lt;code&gt;axisb&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;axisa&lt;/code&gt; 및 &lt;code&gt;axisb&lt;/code&gt; 를 사용하여 &lt;code&gt;x&lt;/code&gt; 및 &lt;code&gt;y&lt;/code&gt; 의 벡터 정의를 변경하십시오 .</target>
        </trans-unit>
        <trans-unit id="e0071cc90960eebe1625885afe4b699fbc8d4d8b" translate="yes" xml:space="preserve">
          <source>Changed behavior of &lt;code&gt;divmod(1., 0.)&lt;/code&gt; and related functions</source>
          <target state="translated">&lt;code&gt;divmod(1., 0.)&lt;/code&gt; 및 관련 함수의 동작 변경</target>
        </trans-unit>
        <trans-unit id="0e76bac75a93f40062500cfe4d6d4594aea2a414" translate="yes" xml:space="preserve">
          <source>Changed in version 1.10.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">버전 1.10.0으로 변경 : 이전 NumPy 버전에는 dfnum&amp;gt; 1이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9e03441147d9c9bca84c6633efe853d678690f6f" translate="yes" xml:space="preserve">
          <source>Changed in version 1.11.0: When a single column has to be read it is possible to use an integer instead of a tuple. E.g &lt;code&gt;usecols = 3&lt;/code&gt; reads the fourth column the same way as &lt;code&gt;usecols = (3,)&lt;/code&gt; would.</source>
          <target state="translated">버전 1.11.0으로 변경 : 단일 열을 읽어야 할 때 튜플 대신 정수를 사용할 수 있습니다. 예를 들어 &lt;code&gt;usecols = 3&lt;/code&gt; 은 &lt;code&gt;usecols = (3,)&lt;/code&gt; 과 같은 방식으로 네 번째 열을 읽습니다 .</target>
        </trans-unit>
        <trans-unit id="4240cc617a1809505e609f22132a15e64d1b8364" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Previously, the default was documented to be -1, but that was in error. At some future date, the default will change to -1, as originally intended. Until then, the axis should be given explicitly when &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt;, to avoid a FutureWarning.</source>
          <target state="translated">버전 1.13.0으로 변경 : 이전에는 기본값이 -1로 문서화되었지만 오류가 발생했습니다. 향후에는 기본값이 원래 의도 한대로 -1로 변경됩니다. 그때까지는 &lt;code&gt;arr.ndim &amp;gt; 1&lt;/code&gt; 일 때 FutureWarning을 피하기 위해 축을 명시 적으로 지정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="7cf5dc6a75318b20c4a1e296708ff3954da61899" translate="yes" xml:space="preserve">
          <source>Changed in version 1.13.0: Tuples are allowed for keyword argument.</source>
          <target state="translated">버전 1.13.0으로 변경 : 키워드 인수에 튜플이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="8369be3972dcfca939d8870350211ef461655917" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: Earlier NumPy versions required dfnum &amp;gt; 1.</source>
          <target state="translated">버전 1.14.0으로 변경 : 이전 NumPy 버전에는 dfnum&amp;gt; 1이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="90df01afcc61c5a576cbe17f8aa7128ba6554b30" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14.0: If not set, a FutureWarning is given. The previous default of &lt;code&gt;-1&lt;/code&gt; will use the machine precision as &lt;code&gt;rcond&lt;/code&gt; parameter, the new default will use the machine precision times &lt;code&gt;max(M, N)&lt;/code&gt;. To silence the warning and use the new default, use &lt;code&gt;rcond=None&lt;/code&gt;, to keep using the old behavior, use &lt;code&gt;rcond=-1&lt;/code&gt;.</source>
          <target state="translated">버전 1.14.0으로 변경 : 설정되지 않은 경우 FutureWarning이 제공됩니다. 이전 기본값 &lt;code&gt;-1&lt;/code&gt; 은 기계 정밀도를 &lt;code&gt;rcond&lt;/code&gt; 매개 변수로 사용하고 새로운 기본값은 기계 정밀도 시간 &lt;code&gt;max(M, N)&lt;/code&gt; 합니다. 경고를 &lt;code&gt;rcond=None&lt;/code&gt; 새 기본값을 사용하려면 rcond = None 을 사용하고 이전 동작을 계속 사용하려면 &lt;code&gt;rcond=-1&lt;/code&gt; 을 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="1d2839d7d3bf87e0e23f5c67fc8d1ab0fe0551fd" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Broadcasted against the stack of matrices</source>
          <target state="translated">버전 1.14에서 변경 : 매트릭스 스택에 대해 브로드 캐스팅</target>
        </trans-unit>
        <trans-unit id="348ee8de383634f48f0728f5bfaf909f0982c324" translate="yes" xml:space="preserve">
          <source>Changed in version 1.14: Can now operate on stacks of matrices</source>
          <target state="translated">버전 1.14에서 변경 : 이제 매트릭스 스택에서 작동 할 수 있습니다</target>
        </trans-unit>
        <trans-unit id="05cf1c5d8f1269a7f5fa5c6cc3fc095bf8055509" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0.: The &amp;lsquo;stable&amp;rsquo; option was added.</source>
          <target state="translated">버전 1.15.0으로 변경 : 'stable'옵션이 추가되었습니다.</target>
        </trans-unit>
        <trans-unit id="0e6fb4664107937e52dcdbc13917b49d6b44f05c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: DeprecationWarnings are actually emitted.</source>
          <target state="translated">버전 1.15.0으로 변경 : DeprecationWarnings가 실제로 방출됩니다.</target>
        </trans-unit>
        <trans-unit id="5e3b221df91333bee6b9f5792109b32e7e70567b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: None and tuples of axes are supported</source>
          <target state="translated">버전 1.15.0으로 변경 : 축 없음 및 튜플 지원</target>
        </trans-unit>
        <trans-unit id="6624914a2e2a7b2534790ce8bdbacb5cde27dee9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.15.0: Now returns an empty list instead of None for a fully masked array</source>
          <target state="translated">버전 1.15.0에서 변경 : 이제 완전히 마스킹 된 배열에 대해 None 대신 빈 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="0a28aad38084ea97b7bc4890436cdfc6bcade503" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: A list of args may also be provided.</source>
          <target state="translated">버전 1.16.0에서 변경 : args 목록도 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf547a772cebc0e7496a5c76e49a36dae75a2d98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Accept str as well as bytes</source>
          <target state="translated">버전 1.16.0에서 변경 : str과 bytes 허용</target>
        </trans-unit>
        <trans-unit id="83d75b7f177288265577e6765abc146d2cecb0e7" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Non-scalar &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt; are now supported.</source>
          <target state="translated">버전 1.16.0에서 변경 : 이제 스칼라가 아닌 &lt;code&gt;start&lt;/code&gt; 및 &lt;code&gt;stop&lt;/code&gt; 가 지원됩니다.</target>
        </trans-unit>
        <trans-unit id="25985fe044545f9478af4af504ffd04c8801c6e6" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: Renamed from &lt;code&gt;dims&lt;/code&gt; to &lt;code&gt;shape&lt;/code&gt;.</source>
          <target state="translated">버전 1.16.0에서 변경 : &lt;code&gt;dims&lt;/code&gt; 에서 &lt;code&gt;shape&lt;/code&gt; 로 이름이 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="efbb6766c6fa3f5a86971d5c72ad18cb18aafc98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.0: This function works on subclasses of ndarray like &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;ma.array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">버전 1.16.0에서 변경 :이 함수는 ma.array와 같은 &lt;a href=&quot;numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;ma.array&lt;/code&gt; &lt;/a&gt; 서브 클래스에서 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="eef53483993b5fb29b126ef19278ead520adb6f9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.16.3: Made default False in response to CVE-2019-6446.</source>
          <target state="translated">버전 1.16.3으로 변경 : CVE-2019-6446에 대한 응답으로 기본 False가되었습니다.</target>
        </trans-unit>
        <trans-unit id="ff4dc328009aefab6de678232e1061e9bf30fb2d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;#numpy.errstate&quot;&gt;&lt;code&gt;errstate&lt;/code&gt;&lt;/a&gt; is also usable as a function decorator, saving a level of indentation if an entire function is wrapped. See &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt;&lt;code&gt;contextlib.ContextDecorator&lt;/code&gt;&lt;/a&gt; for more information.</source>
          <target state="translated">버전 1.17.0으로 변경 : &lt;a href=&quot;#numpy.errstate&quot;&gt; &lt;code&gt;errstate&lt;/code&gt; &lt;/a&gt; 는 함수 데코레이터로도 사용할 수 있으며 전체 함수가 랩핑 된 경우 들여 쓰기 레벨을 저장합니다. 자세한 정보는 &lt;a href=&quot;https://docs.python.org/dev/library/contextlib.html#contextlib.ContextDecorator&quot;&gt; &lt;code&gt;contextlib.ContextDecorator&lt;/code&gt; &lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="af2d1032fe2cc2a8c7b8fc21250999bf723a2b20" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt;&lt;code&gt;pathlib.Path&lt;/code&gt;&lt;/a&gt; objects are now accepted.</source>
          <target state="translated">버전 1.17.0에서 변경 : &lt;a href=&quot;https://docs.python.org/dev/library/pathlib.html#pathlib.Path&quot;&gt; &lt;code&gt;pathlib.Path&lt;/code&gt; &lt;/a&gt; 객체가 이제 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="61efb6f136dc51708e975673488296290e1e421b" translate="yes" xml:space="preserve">
          <source>Changed in version 1.17.0: Casting between a simple data type and a structured one is possible only for &amp;ldquo;unsafe&amp;rdquo; casting. Casting to multiple fields is allowed, but casting from multiple fields is not.</source>
          <target state="translated">버전 1.17.0으로 변경 : 단순 데이터 유형과 구조화 된 유형 간의 캐스트는 &quot;안전하지 않은&quot;캐스트에만 가능합니다. 여러 필드로 캐스트 할 수 있지만 여러 필드에서 캐스트 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c5df5da3e381a86308cf0cc4eb048541e70b1ac9" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.</source>
          <target state="translated">버전 1.18에서 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="6b373f41a3cb0188f798a19ca6f87e39244e1215" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0.</source>
          <target state="translated">버전 1.18.0에서 변경되었습니다.</target>
        </trans-unit>
        <trans-unit id="4eceee62f8c4c4b42b7dceb484f0880666ee869d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: &lt;a href=&quot;#numpy.lib.recfunctions.drop_fields&quot;&gt;&lt;code&gt;drop_fields&lt;/code&gt;&lt;/a&gt; returns an array with 0 fields if all fields are dropped, rather than returning &lt;code&gt;None&lt;/code&gt; as it did previously.</source>
          <target state="translated">버전 1.18.0에서 변경 : &lt;a href=&quot;#numpy.lib.recfunctions.drop_fields&quot;&gt; &lt;code&gt;drop_fields&lt;/code&gt; &lt;/a&gt; 는 이전처럼 &lt;code&gt;None&lt;/code&gt; 을 반환하는 대신 모든 필드가 삭제되면 0 필드가있는 배열을 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="89bfac0c966e6918532c5056416ce8c139bac641" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: A mix of scalars and zero-dimensional arrays now produces a type capable of holding the scalar value. Previously priority was given to the dtype of the arrays.</source>
          <target state="translated">버전 1.18.0에서 변경 : 스칼라와 0 차원 배열의 혼합은 이제 스칼라 값을 보유 할 수있는 유형을 생성합니다. 이전에는 배열의 dtype에 우선 순위가 주어졌습니다.</target>
        </trans-unit>
        <trans-unit id="19b458380fddb4902dee94f09f396c9a282f453d" translate="yes" xml:space="preserve">
          <source>Changed in version 1.18.0: A tuple of axes is now supported. Out of range axes as described above are now forbidden and raise an &lt;code&gt;AxisError&lt;/code&gt;.</source>
          <target state="translated">버전 1.18.0에서 변경 : 이제 축의 튜플이 지원됩니다. 위에서 설명한대로 범위를 벗어난 축은 이제 금지되며 &lt;code&gt;AxisError&lt;/code&gt; 를 발생시킵니다 .</target>
        </trans-unit>
        <trans-unit id="dccd9958f73e96cdb6901cdbf8dca831295ef22c" translate="yes" xml:space="preserve">
          <source>Changed in version 1.19.0: Boolean indices are now treated as a mask of elements to remove, rather than being cast to the integers 0 and 1.</source>
          <target state="translated">버전 1.19.0에서 변경 : 부울 인덱스는 이제 정수 0과 1로 캐스트되지 않고 제거 할 요소의 마스크로 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="d0001df8009c2db5c4b8e3c7e2f2808b1be9d839" translate="yes" xml:space="preserve">
          <source>Changed in version 1.20.0: Values are rounded towards &lt;code&gt;-inf&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt; when an integer &lt;code&gt;dtype&lt;/code&gt; is specified. The old behavior can still be obtained with &lt;code&gt;np.linspace(start, stop, num).astype(int)&lt;/code&gt;</source>
          <target state="translated">버전 1.20.0에서 변경 : 정수 &lt;code&gt;dtype&lt;/code&gt; 이 지정 되면 값이 &lt;code&gt;0&lt;/code&gt; 대신 &lt;code&gt;-inf&lt;/code&gt; 로 반올림 됩니다. 이전 동작은 &lt;code&gt;np.linspace(start, stop, num).astype(int)&lt;/code&gt; 여전히 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c9406124c2f89ed955f1ed4fdf79269cd807fab" translate="yes" xml:space="preserve">
          <source>Changed in version 1.8.0: Broadcasting rules apply, see the &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt;&lt;code&gt;numpy.linalg&lt;/code&gt;&lt;/a&gt; documentation for details.</source>
          <target state="translated">버전 1.8.0으로 변경 : 브로드 캐스트 규칙이 적용됩니다. 자세한 내용은 &lt;a href=&quot;../routines.linalg#module-numpy.linalg&quot;&gt; &lt;code&gt;numpy.linalg&lt;/code&gt; &lt;/a&gt; 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="442c1fd3d41745a2d4ec1e84a3657676ca62838e" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: A tuple of axes is supported</source>
          <target state="translated">버전 1.9.0에서 변경 : 축의 튜플이 지원됩니다</target>
        </trans-unit>
        <trans-unit id="73bab6415b0560ad9f839326ef0b98ed7906af98" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the max integer/float value converted.</source>
          <target state="translated">버전 1.9.0으로 변경 : '안전한'캐스팅 모드에서 숫자에서 문자열 유형으로 캐스팅하려면 변환 된 최대 정수 / 부동 값을 저장할 수있는 문자열 dtype 길이가 길어야합니다.</target>
        </trans-unit>
        <trans-unit id="8adc0d706675beb5229fbd846a1b85c2cfcca190" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9.0: Casting from numeric to string types in &amp;lsquo;safe&amp;rsquo; casting mode requires that the string dtype length is long enough to store the maximum integer/float value converted.</source>
          <target state="translated">버전 1.9.0에서 변경 : '안전한'캐스팅 모드에서 숫자에서 문자열 유형으로 캐스팅하려면 변환 된 최대 정수 / 부동 값을 저장할 수 있도록 문자열 dtype 길이가 길어야합니다.</target>
        </trans-unit>
        <trans-unit id="5a255433707dd5f70c7a4be8e1821141fe49e182" translate="yes" xml:space="preserve">
          <source>Changed in version 1.9: 1-D and 0-D cases are allowed.</source>
          <target state="translated">버전 1.9에서 변경 : 1-D 및 0-D 사례가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d65dbc46ba0aa85c5054bdc349b97636497c7d97" translate="yes" xml:space="preserve">
          <source>Changed in version NumPy: 1.19</source>
          <target state="translated">버전 NumPy에서 변경 : 1.19</target>
        </trans-unit>
        <trans-unit id="090cd0a4c0bdb025d9d082643a59f937e13d144c" translate="yes" xml:space="preserve">
          <source>Changed random variate stream from &lt;code&gt;numpy.random.Generator.dirichlet&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.random.Generator.dirichlet&lt;/code&gt; 에서 무작위 변량 스트림을 변경 했습니다.</target>
        </trans-unit>
        <trans-unit id="6c789b1f25e20176df4d2eb365c2cf355c4a907a" translate="yes" xml:space="preserve">
          <source>Changed random variate stream from &lt;code&gt;numpy.random.Generator.integers&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.random.Generator.integers&lt;/code&gt; 에서 무작위 변량 스트림을 변경 했습니다.</target>
        </trans-unit>
        <trans-unit id="164b3d4809f98d0458414f1bf9cf3c9dcba16bb5" translate="yes" xml:space="preserve">
          <source>Changelog</source>
          <target state="translated">Changelog</target>
        </trans-unit>
        <trans-unit id="8aa57de6dce6ee1c35c6aba7426503281876b258" translate="yes" xml:space="preserve">
          <source>Changes</source>
          <target state="translated">Changes</target>
        </trans-unit>
        <trans-unit id="d447e3c0af8f91b0b6d56c2803ffc2d885c25ac6" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the array data type.</source>
          <target state="translated">배열 데이터 유형의 모든 필드 및 하위 배열에서도 변경 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="d5c8653ebb3c65244702565331c9f825090ef108" translate="yes" xml:space="preserve">
          <source>Changes are also made in all fields and sub-arrays of the data type.</source>
          <target state="translated">데이터 유형의 모든 필드 및 하위 배열에서도 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="988d6dcf1558a60cf9e3df8c88bfbf9aa6476a76" translate="yes" xml:space="preserve">
          <source>Changes elements of an array based on conditional and input values.</source>
          <target state="translated">조건부 및 입력 값을 기준으로 배열의 요소를 변경합니다.</target>
        </trans-unit>
        <trans-unit id="2285dbb1d294a01028b75412567462886684b25a" translate="yes" xml:space="preserve">
          <source>Changes that have been marked for this release must be backported to the maintenance/1.14.x branch.</source>
          <target state="translated">이 릴리스에 대해 표시된 변경 사항은 maintenance / 1.14.x 분기로 백 포트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc4a676c4b81afb4bcc96bae666860852cdf8e00" translate="yes" xml:space="preserve">
          <source>Changes that have been marked for this release must be backported to the maintenance/1.19.x branch.</source>
          <target state="translated">이 릴리스에 대해 표시된 변경 사항은 maintenance / 1.19.x 분기로 백 포트되어야합니다.</target>
        </trans-unit>
        <trans-unit id="11f7d423e4a6c5aafe601b11f0668f2b9c2f00fa" translate="yes" xml:space="preserve">
          <source>Changes the variable used when printing &lt;code&gt;p&lt;/code&gt; from &lt;code&gt;x&lt;/code&gt; to &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt;&lt;code&gt;variable&lt;/code&gt;&lt;/a&gt; (see Examples).</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 를 &lt;code&gt;x&lt;/code&gt; 에서 &lt;a href=&quot;numpy.poly1d.variable#numpy.poly1d.variable&quot;&gt; &lt;code&gt;variable&lt;/code&gt; &lt;/a&gt; 인쇄 할 때 사용되는 변수를 변경합니다 (예 참조).</target>
        </trans-unit>
        <trans-unit id="79ec3dbe3c422f3862e5d024b983cec2214e99ca" translate="yes" xml:space="preserve">
          <source>Changes to &lt;code&gt;PyArray_GetDTypeTransferFunction&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;PyArray_GetDTypeTransferFunction&lt;/code&gt; 에 대한 변경 사항</target>
        </trans-unit>
        <trans-unit id="a6b7a5b4726b415eac4533ff4c785ffd43ff58e3" translate="yes" xml:space="preserve">
          <source>Changes with NumPy 1.11</source>
          <target state="translated">NumPy 1.11의 변경 사항</target>
        </trans-unit>
        <trans-unit id="f88e590a9d42082459bee2897052e8478444520a" translate="yes" xml:space="preserve">
          <source>Changing array shape</source>
          <target state="translated">배열 모양 변경</target>
        </trans-unit>
        <trans-unit id="d83babf52902d360c4710e39052681b9926c27c0" translate="yes" xml:space="preserve">
          <source>Changing byte ordering</source>
          <target state="translated">바이트 순서 변경</target>
        </trans-unit>
        <trans-unit id="bb5d57bb97464b7a41e90965a34fd558225f91df" translate="yes" xml:space="preserve">
          <source>Changing kind of array</source>
          <target state="translated">배열 종류 변경</target>
        </trans-unit>
        <trans-unit id="4dac00a1fdb9bc9e870465fcb8ac48e7a6f41092" translate="yes" xml:space="preserve">
          <source>Changing number of dimensions</source>
          <target state="translated">치수 수 변경</target>
        </trans-unit>
        <trans-unit id="26a89ebf1c1d895edaaec0f680290afde6188baf" translate="yes" xml:space="preserve">
          <source>Changing the number of dimensions</source>
          <target state="translated">치수 수 변경</target>
        </trans-unit>
        <trans-unit id="659708d4116763fca54f546304717111fc0dcdbc" translate="yes" xml:space="preserve">
          <source>Changing the shape</source>
          <target state="translated">모양 변경</target>
        </trans-unit>
        <trans-unit id="7d5cb72a6a27b93f3d464005b1595158876ad637" translate="yes" xml:space="preserve">
          <source>Changing the shape of an array</source>
          <target state="translated">배열 모양 변경</target>
        </trans-unit>
        <trans-unit id="472ea4d678f10230e80354665e55d5162f57e4eb" translate="yes" xml:space="preserve">
          <source>Character arrays (&lt;code&gt;numpy.char&lt;/code&gt;)</source>
          <target state="translated">문자형 배열 ( &lt;code&gt;numpy.char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c77510e827185d4da42fdcbd8730a318064afdff" translate="yes" xml:space="preserve">
          <source>Character arrays (numpy.char)</source>
          <target state="translated">문자형 배열 (numpy.char)</target>
        </trans-unit>
        <trans-unit id="92c1e393951a713a4c1c2df5523a5b76ef600358" translate="yes" xml:space="preserve">
          <source>Character code</source>
          <target state="translated">문자 코드</target>
        </trans-unit>
        <trans-unit id="64910425e1eab2c0d615f0db9e7769f7b3632856" translate="yes" xml:space="preserve">
          <source>Character codes or the names of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#type&quot;&gt;&lt;code&gt;type&lt;/code&gt;&lt;/a&gt; objects.</source>
          <target state="translated">문자 코드 또는 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#type&quot;&gt; &lt;code&gt;type&lt;/code&gt; &lt;/a&gt; 객체 의 이름 .</target>
        </trans-unit>
        <trans-unit id="ba3973797ea212e06b4bd3f28ecf46f8274e1229" translate="yes" xml:space="preserve">
          <source>Character(s) used in replacement of white spaces in the variables names. By default, use a &amp;lsquo;_&amp;rsquo;.</source>
          <target state="translated">변수 이름에서 공백을 대체하는 데 사용되는 문자. 기본적으로 '_'를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="5c50aa40fe135ae872479f3d463481aa7c8705fa" translate="yes" xml:space="preserve">
          <source>Charles Harris</source>
          <target state="translated">찰스 해리스</target>
        </trans-unit>
        <trans-unit id="faf08e2ed05138df0c2fc73c7cd9c35b89b1b4ee" translate="yes" xml:space="preserve">
          <source>Chebyshev</source>
          <target state="translated">Chebyshev</target>
        </trans-unit>
        <trans-unit id="ea61b1323fc64a9bb8d86a6aadc2fcb486ca4493" translate="yes" xml:space="preserve">
          <source>Chebyshev (class in numpy.polynomial.chebyshev)</source>
          <target state="translated">Chebyshev (numpy.polynomial.chebyshev의 클래스)</target>
        </trans-unit>
        <trans-unit id="b08808430b344bf934ff595f268dd7b3c9767d8c" translate="yes" xml:space="preserve">
          <source>Chebyshev Class</source>
          <target state="translated">체비 쇼프 클래스</target>
        </trans-unit>
        <trans-unit id="c805e26af7ca174190c79364ad41f4463c143779" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="translated">체비 쇼프 모듈 ( &lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="43b2dcb73cb4875580862bf8c8dd1ada4c4da4c6" translate="yes" xml:space="preserve">
          <source>Chebyshev Module (numpy.polynomial.chebyshev)</source>
          <target state="translated">체비 쇼프 모듈 (numpy.polynomial.chebyshev)</target>
        </trans-unit>
        <trans-unit id="2b074447d5337b1acd99539f1f78bf706c34ad9f" translate="yes" xml:space="preserve">
          <source>Chebyshev Series (&lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt;)</source>
          <target state="translated">체비 쇼프 시리즈 ( &lt;code&gt;numpy.polynomial.chebyshev&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="4a4e1fdfb1973afb318ee463fd302dbf6eb373c9" translate="yes" xml:space="preserve">
          <source>Chebyshev Series (numpy.polynomial.chebyshev)</source>
          <target state="translated">체비 쇼프 시리즈 (numpy.polynomial.chebyshev)</target>
        </trans-unit>
        <trans-unit id="0efbe54789bc84b8d4e58d69167610bd2675854f" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients in order of increasing degree, i.e., &lt;code&gt;(1, 2, 3)&lt;/code&gt; gives &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt;.</source>
          <target state="translated">정도가 증가하는 순서로 체비 쇼프 계수, 즉 &lt;code&gt;(1, 2, 3)&lt;/code&gt; 은 &lt;code&gt;1*T_0(x) + 2*T_1(x) + 3*T_2(x)&lt;/code&gt; 냅니다.</target>
        </trans-unit>
        <trans-unit id="cda36d3a5a7c1cf749fe8552f3ece2e37c1bde96" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients of the interpolating series ordered from low to high.</source>
          <target state="translated">보간 시리즈의 체비 쇼프 계수는 낮은 순서에서 높은 순서로 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="96032d11ffc294810d816c812b7d22b436c23b79" translate="yes" xml:space="preserve">
          <source>Chebyshev coefficients ordered from low to high. If &lt;code&gt;y&lt;/code&gt; was 2-D, the coefficients for the data in column k of &lt;code&gt;y&lt;/code&gt; are in column &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">체비 쇼프 계수는 낮은 순서에서 높은 순서로 정렬됩니다. 경우 &lt;code&gt;y&lt;/code&gt; 는 2-D이고, K의 열 내의 데이터에 대한 계수 &lt;code&gt;y&lt;/code&gt; 를 컬럼에 &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78471d8e84581a3113228c58d00d8316306213cc" translate="yes" xml:space="preserve">
          <source>Chebyshev points of the first kind.</source>
          <target state="translated">첫 번째 종류의 체비 쇼프 포인트.</target>
        </trans-unit>
        <trans-unit id="97b5ebecc93143ab3bacdf5e10cda1de1af56a39" translate="yes" xml:space="preserve">
          <source>Chebyshev points of the second kind.</source>
          <target state="translated">두 번째 종류의 체비 쇼프 점.</target>
        </trans-unit>
        <trans-unit id="1e63eba3c512c100441a580822bf3dee3fdc84ed" translate="yes" xml:space="preserve">
          <source>Chebyshev series</source>
          <target state="translated">체비 쇼프 시리즈</target>
        </trans-unit>
        <trans-unit id="f8c02252eba6ff12458afafb159b20cecff7478a" translate="yes" xml:space="preserve">
          <source>Chebyshev series of power.</source>
          <target state="translated">체비 쇼프 파워 시리즈.</target>
        </trans-unit>
        <trans-unit id="8a0ba9e6152e6c1500bb9491398112d62215acf4" translate="yes" xml:space="preserve">
          <source>Chebyshev series of the derivative.</source>
          <target state="translated">유도체의 체비 쇼프 시리즈.</target>
        </trans-unit>
        <trans-unit id="4f2d57204da6b30aece47fb6efed1a7b8e11e6b0" translate="yes" xml:space="preserve">
          <source>Chebyshev series whose graph is a straight line.</source>
          <target state="translated">그래프가 직선 인 체비 쇼프 시리즈.</target>
        </trans-unit>
        <trans-unit id="95aa0918943d1236cc6d32e54d1344d9d0be39c1" translate="yes" xml:space="preserve">
          <source>Chebyshev weight function.</source>
          <target state="translated">체비 쇼프 무게 기능.</target>
        </trans-unit>
        <trans-unit id="b18292f75bb94b7b116770748f5215372e100826" translate="yes" xml:space="preserve">
          <source>Chebyshev.__call__()</source>
          <target state="translated">Chebyshev.__call__()</target>
        </trans-unit>
        <trans-unit id="1bacc9adbf511d1e41a349b356ba0145d6ee7946" translate="yes" xml:space="preserve">
          <source>Chebyshev.basis()</source>
          <target state="translated">Chebyshev.basis()</target>
        </trans-unit>
        <trans-unit id="188210acd7ec982c8646fa316466c45a976f83f2" translate="yes" xml:space="preserve">
          <source>Chebyshev.cast()</source>
          <target state="translated">Chebyshev.cast()</target>
        </trans-unit>
        <trans-unit id="639e56acd1352c9b5b503ed1496fdb9a5d07c0c0" translate="yes" xml:space="preserve">
          <source>Chebyshev.convert()</source>
          <target state="translated">Chebyshev.convert()</target>
        </trans-unit>
        <trans-unit id="11392591347c8480770728aa505b563eccfa5f1d" translate="yes" xml:space="preserve">
          <source>Chebyshev.copy()</source>
          <target state="translated">Chebyshev.copy()</target>
        </trans-unit>
        <trans-unit id="41611d32208cae6870074acedaa6fe221b1b3446" translate="yes" xml:space="preserve">
          <source>Chebyshev.cutdeg()</source>
          <target state="translated">Chebyshev.cutdeg()</target>
        </trans-unit>
        <trans-unit id="8789ce0a4c5068fdfe534918cc2e90fdad042cd3" translate="yes" xml:space="preserve">
          <source>Chebyshev.degree()</source>
          <target state="translated">Chebyshev.degree()</target>
        </trans-unit>
        <trans-unit id="c6481905857e646a6d9c66a8532da7a6334a6377" translate="yes" xml:space="preserve">
          <source>Chebyshev.deriv()</source>
          <target state="translated">Chebyshev.deriv()</target>
        </trans-unit>
        <trans-unit id="6291088b6f8cbfecdb12bf2bdad126fa6f8f1e75" translate="yes" xml:space="preserve">
          <source>Chebyshev.domain</source>
          <target state="translated">Chebyshev.domain</target>
        </trans-unit>
        <trans-unit id="dd41304fdf8df9e37b5816500b41e22e66c61815" translate="yes" xml:space="preserve">
          <source>Chebyshev.fit()</source>
          <target state="translated">Chebyshev.fit()</target>
        </trans-unit>
        <trans-unit id="e4926f0eed8819f61f1604cce384a57795e1eabf" translate="yes" xml:space="preserve">
          <source>Chebyshev.fromroots()</source>
          <target state="translated">Chebyshev.fromroots()</target>
        </trans-unit>
        <trans-unit id="70d84e9f4f420d528a16ab4c0ba4755a5af5e65c" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samecoef()</source>
          <target state="translated">Chebyshev.has_samecoef()</target>
        </trans-unit>
        <trans-unit id="119c3a01c7179401c8123c868c9643da34d59174" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samedomain()</source>
          <target state="translated">Chebyshev.has_samedomain()</target>
        </trans-unit>
        <trans-unit id="1d9bea3b85c40da6ce150efb52fc340072577178" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_sametype()</source>
          <target state="translated">Chebyshev.has_sametype()</target>
        </trans-unit>
        <trans-unit id="21b9443d56e25c8c9434c2048384c54825cbad75" translate="yes" xml:space="preserve">
          <source>Chebyshev.has_samewindow()</source>
          <target state="translated">Chebyshev.has_samewindow()</target>
        </trans-unit>
        <trans-unit id="f72f56cc281db3fc06403b01e30cee59ef5f1b34" translate="yes" xml:space="preserve">
          <source>Chebyshev.identity()</source>
          <target state="translated">Chebyshev.identity()</target>
        </trans-unit>
        <trans-unit id="4320540c12f7d006eb6f49d8596f1304f5f9b17f" translate="yes" xml:space="preserve">
          <source>Chebyshev.integ()</source>
          <target state="translated">Chebyshev.integ()</target>
        </trans-unit>
        <trans-unit id="c6cc890aac4433ddc758056a7a1ec57ab680d9dd" translate="yes" xml:space="preserve">
          <source>Chebyshev.interpolate()</source>
          <target state="translated">Chebyshev.interpolate()</target>
        </trans-unit>
        <trans-unit id="7c5cc657b6a0749c5b79e78f062d99b7bfa79e2e" translate="yes" xml:space="preserve">
          <source>Chebyshev.linspace()</source>
          <target state="translated">Chebyshev.linspace()</target>
        </trans-unit>
        <trans-unit id="318403bb4b0c9579e1e22548291a889f9ceb1ac1" translate="yes" xml:space="preserve">
          <source>Chebyshev.mapparms()</source>
          <target state="translated">Chebyshev.mapparms()</target>
        </trans-unit>
        <trans-unit id="e3d230253c27dda3445e4aef41453767831a496b" translate="yes" xml:space="preserve">
          <source>Chebyshev.roots()</source>
          <target state="translated">Chebyshev.roots()</target>
        </trans-unit>
        <trans-unit id="a90771ff29f5d5fd6c72cd284a6221aaeee66dbc" translate="yes" xml:space="preserve">
          <source>Chebyshev.trim()</source>
          <target state="translated">Chebyshev.trim()</target>
        </trans-unit>
        <trans-unit id="5b40364d3cb3cca7f44236a76dfee86aa086098b" translate="yes" xml:space="preserve">
          <source>Chebyshev.truncate()</source>
          <target state="translated">Chebyshev.truncate()</target>
        </trans-unit>
        <trans-unit id="fa3b88952bbad94e7ad3a8b4bc8351fab6c23f70" translate="yes" xml:space="preserve">
          <source>Check Environment Variables</source>
          <target state="translated">환경 변수 확인</target>
        </trans-unit>
        <trans-unit id="0f1c2f66e836ebaf2af3cc3e88ba49176e5fc5ef" translate="yes" xml:space="preserve">
          <source>Check deprecations</source>
          <target state="translated">지원 중단 확인</target>
        </trans-unit>
        <trans-unit id="68b29a44de315b426add922aecd8f169abef4bb9" translate="yes" xml:space="preserve">
          <source>Check for a complex type or an array of complex numbers.</source>
          <target state="translated">복소수 유형 또는 복소수 배열을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4bce08324cf028acd33defa95adda2d8f712ca10" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 77 compiler.</source>
          <target state="translated">Fortran 77 컴파일러의 가용성을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8dfb4b491ef798ee13273ce6b905820e38be579c" translate="yes" xml:space="preserve">
          <source>Check for availability of Fortran 90 compiler.</source>
          <target state="translated">Fortran 90 컴파일러의 사용 가능 여부를 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="fc680846edbe0485cdd86c89e2d8ba596476a1dd" translate="yes" xml:space="preserve">
          <source>Check if coefficients match.</source>
          <target state="translated">계수가 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="d9700aa50368965f26007e9ef6dc12172f836968" translate="yes" xml:space="preserve">
          <source>Check if domains match.</source>
          <target state="translated">도메인이 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7cda7e0160467a48240d75643f9aa9dd2aa8c3ec" translate="yes" xml:space="preserve">
          <source>Check if the array is Fortran contiguous but &lt;em&gt;not&lt;/em&gt; C contiguous.</source>
          <target state="translated">배열이 Fortran 인접하지만 C 인접 &lt;em&gt;하지&lt;/em&gt; 않은지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="e7a996762c75a9633231bd44ab99dd3f19880ea7" translate="yes" xml:space="preserve">
          <source>Check if types match.</source>
          <target state="translated">유형이 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="8d606aa3664f58aff3cd51e12c1f4292532053db" translate="yes" xml:space="preserve">
          <source>Check if windows match.</source>
          <target state="translated">창이 일치하는지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2fb7aaaa0fefc98b63923082fcb9b881a92a1f09" translate="yes" xml:space="preserve">
          <source>Check that all items of arrays differ in at most N Units in the Last Place.</source>
          <target state="translated">마지막 배열에서 배열의 모든 항목이 최대 N 개 단위가 다른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="85d78e2e46b343ac5d95f102decec7f3757fea05" translate="yes" xml:space="preserve">
          <source>Check that the files in &lt;code&gt;release/installers&lt;/code&gt; have the correct versions, then push the tag upstream:</source>
          <target state="translated">&lt;code&gt;release/installers&lt;/code&gt; 의 파일에 올바른 버전이 있는지 확인한 다음 태그를 업스트림으로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="3d69ccd1b6fed474517fc60eaa1e007186d233c6" translate="yes" xml:space="preserve">
          <source>Check that the release notes are up-to-date.</source>
          <target state="translated">릴리스 정보가 최신인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="7eaa6b9db4d409e9c0e745dc239854957e8b786b" translate="yes" xml:space="preserve">
          <source>Check that the solution is correct:</source>
          <target state="translated">솔루션이 올바른지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="5caf476aaa67e250b5bea0e66db1d7432b8de4e4" translate="yes" xml:space="preserve">
          <source>Check that what you are going to push looks sensible:</source>
          <target state="translated">푸시하려는 내용이 합리적인지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="4b9add170f60f16261046081b4697b7c84e7d44a" translate="yes" xml:space="preserve">
          <source>Check the C API version number</source>
          <target state="translated">C API 버전 번호 확인</target>
        </trans-unit>
        <trans-unit id="b474fcfc20997061eb0dbec47b248cfc5e13a11e" translate="yes" xml:space="preserve">
          <source>Check the pre-release button if this is a pre-releases.</source>
          <target state="translated">시험판 인 경우 시험판 버튼을 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="13767ae2c1bd8cf1174421496546f179c6e6b424" translate="yes" xml:space="preserve">
          <source>Check the release notes</source>
          <target state="translated">릴리스 정보 확인</target>
        </trans-unit>
        <trans-unit id="abd3adad63a405998bb8027f9dd962bdd792cf51" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is Fortran contiguous. If so, return the input pointer and flag it as not a new object. If it is not Fortran contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; 가 포트란 연속 인지 확인하십시오 . 그렇다면 입력 포인터를 반환하고 새 객체가 아닌 것으로 플래그를 지정하십시오. 포트란이 연속적이지 않은 경우 , 원래 데이터를 사용하여 새 &lt;code&gt;PyArrayObject*&lt;/code&gt; 를 생성 하고 새 객체로 플래그를 지정하고 포인터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6deabec9ba29d971d99676bd19f94bb36aab8ebd" translate="yes" xml:space="preserve">
          <source>Check to see if &lt;code&gt;ary&lt;/code&gt; is contiguous. If so, return the input pointer and flag it as not a new object. If it is not contiguous, create a new &lt;code&gt;PyArrayObject*&lt;/code&gt; using the original data, flag it as a new object and return the pointer.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; 가 연속 되어 있는지 확인하십시오 . 그렇다면 입력 포인터를 반환하고 새 객체가 아닌 것으로 플래그를 지정하십시오. 연속적이지 않으면 원래 데이터를 사용하여 새 &lt;code&gt;PyArrayObject*&lt;/code&gt; 를 만들고 새 개체로 플래그를 지정하고 포인터를 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="7093331a27bd647ef152d8be9e2ae4a45e799c24" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result.</source>
          <target state="translated">반복이 남아 있는지 확인하고 결과를 리턴하지 않고 단일 내부 반복을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="4144c2e0e789ff4e5b95e42eba75f165eee47a48" translate="yes" xml:space="preserve">
          <source>Check whether iterations are left, and perform a single internal iteration without returning the result. Used in the C-style pattern do-while pattern. For an example, see &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">반복이 남아 있는지 확인하고 결과를 리턴하지 않고 단일 내부 반복을 수행하십시오. C 스타일 패턴 do-while 패턴에 사용됩니다. 예를 들어, &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ed69b345e7c215832e51813de9d917baa4aa81d3" translate="yes" xml:space="preserve">
          <source>Check whether other does not equal self elementwise.</source>
          <target state="translated">다른 사람이 자기 적으로 요소가 아닌지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="a3d82cd61f57b9f18ee0eb4fb316060ba43247d8" translate="yes" xml:space="preserve">
          <source>Check whether other equals self elementwise.</source>
          <target state="translated">다른 요소가 요소와 같은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="434cdb1d625c09ab1050578e35a57522602ea24b" translate="yes" xml:space="preserve">
          <source>Checking the API Version</source>
          <target state="translated">API 버전 확인</target>
        </trans-unit>
        <trans-unit id="938faf2c9d435685fe655f2c37238cf2efba6e4c" translate="yes" xml:space="preserve">
          <source>Checking whether two arrays share memory is NP-complete, and runtime may increase exponentially in the number of dimensions. Hence, &lt;code&gt;max_work&lt;/code&gt; should generally be set to a finite number, as it is possible to construct examples that take extremely long to run:</source>
          <target state="translated">두 배열이 메모리를 공유하는지 여부를 확인하는 것은 NP 완료이며 런타임은 차원 수에서 기하 급수적으로 증가 할 수 있습니다. 따라서 &lt;code&gt;max_work&lt;/code&gt; 는 실행하는 데 매우 오래 걸리는 예제를 구성 할 수 있으므로 일반적으로 유한 수로 설정되어야합니다.</target>
        </trans-unit>
        <trans-unit id="3d5c81d84347f45939c3f87f353382248652d10c" translate="yes" xml:space="preserve">
          <source>Checkout master and forward port the documentation changes:</source>
          <target state="translated">Checkout master 및 forward port the documentation changes :</target>
        </trans-unit>
        <trans-unit id="2399d5909395b34e8a1bce7efc3302c9102efa33" translate="yes" xml:space="preserve">
          <source>Checkout the branch for the release, make sure it is up to date, and clean the repository:</source>
          <target state="translated">릴리스의 브랜치를 확인하고 최신 상태인지 확인하고 저장소를 정리합니다.</target>
        </trans-unit>
        <trans-unit id="14a89a5ec16296d2593cf527477c76dd33040686" translate="yes" xml:space="preserve">
          <source>Checkout the new branch and edit the &lt;code&gt;azure-pipelines.yml&lt;/code&gt; and &lt;code&gt;.travis.yml&lt;/code&gt; files to make sure they have the correct version, and put in the commit hash for the &lt;code&gt;REL&lt;/code&gt; commit created above for &lt;code&gt;BUILD_COMMIT&lt;/code&gt;. The &lt;code&gt;azure/posix.yml&lt;/code&gt; and &lt;code&gt;.travis.yml&lt;/code&gt; files may also need the Cython versions updated to keep up with Python releases, but generally just do:</source>
          <target state="translated">새 분기를 확인하고 &lt;code&gt;azure-pipelines.yml&lt;/code&gt; 및 &lt;code&gt;.travis.yml&lt;/code&gt; 파일을 편집하여 올바른 버전인지 확인하고 &lt;code&gt;BUILD_COMMIT&lt;/code&gt; 에 대해 위에서 만든 &lt;code&gt;REL&lt;/code&gt; 커밋 에 대한 커밋 해시를 입력합니다 . &lt;code&gt;azure/posix.yml&lt;/code&gt; 및 &lt;code&gt;.travis.yml&lt;/code&gt; 도 바로 할 일반적으로 파이썬 버전으로 유지하지만, 할 업데이트 사이 썬 버전을해야 할 수도 있습니다 파일 :</target>
        </trans-unit>
        <trans-unit id="283049748626c9020e205907bb7476f70c9b37e7" translate="yes" xml:space="preserve">
          <source>Checks to see whether this is the first time the elements of the specified reduction operand which the iterator points at are being seen for the first time. The function returns a reasonable answer for reduction operands and when buffering is disabled. The answer may be incorrect for buffered non-reduction operands.</source>
          <target state="translated">반복자가 가리키는 지정된 축소 피연산자의 요소가 처음으로 보이는지 여부를 확인합니다. 이 함수는 축소 피연산자 및 버퍼링이 비활성화 된 경우 적절한 응답을 반환합니다. 버퍼링 된 비 환원 피연산자에 대한 대답이 올바르지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa157d59451a76fbaaa96b55717e70ff4070a919" translate="yes" xml:space="preserve">
          <source>Chhikara, Raj S., and Folks, J. Leroy, &amp;ldquo;The Inverse Gaussian Distribution: Theory : Methodology, and Applications&amp;rdquo;, CRC Press, 1988.</source>
          <target state="translated">Chkara, Raj S. 및 Folks, J. Leroy,&amp;ldquo;역 가우스 분포 : 이론 : 방법론 및 응용 프로그램&amp;rdquo;, CRC Press, 1988.</target>
        </trans-unit>
        <trans-unit id="fdf0f4fddeb5edfe094f89b612af6bf23fbbf5d9" translate="yes" xml:space="preserve">
          <source>Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects can also spawn to make grandchildren, and so on. Each &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; has its position in the tree of spawned &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; objects mixed in with the user-provided seed to generate independent (with very high probability) streams.</source>
          <target state="translated">Child &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 객체는 손자를 만들기 위해 생성 될 수도 있습니다. 각 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 는 생성 된 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 오브젝트 트리 에서 사용자 제공 시드와 혼합하여 독립적 (매우 높은 확률로) 스트림을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="3a10cdc107364498984b83536b7e81520a19b878" translate="yes" xml:space="preserve">
          <source>Choice arrays. &lt;code&gt;a&lt;/code&gt; and all of the choices must be broadcastable to the same shape. If &lt;code&gt;choices&lt;/code&gt; is itself an array (not recommended), then its outermost dimension (i.e., the one corresponding to &lt;code&gt;choices.shape[0]&lt;/code&gt;) is taken as defining the &amp;ldquo;sequence&amp;rdquo;.</source>
          <target state="translated">선택 배열. 선택과 모두 같은 모양 캐스트 가능한해야합니다. 경우 &lt;code&gt;choices&lt;/code&gt; 자체 배열 (권장하지 않음), 그 후 최 사이즈 (즉, 대응하는 하나 &lt;code&gt;choices.shape[0]&lt;/code&gt; )를 &quot;시퀀스&quot;를 정의로한다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5ad7147824c2ea94d6560122c459caa4f4c34051" translate="yes" xml:space="preserve">
          <source>Choice arrays. The index array and all of the choices should be broadcastable to the same shape.</source>
          <target state="translated">선택 배열. 인덱스 배열과 모든 선택 사항은 같은 모양으로 브로드 캐스트 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="dd2f912583e24992ccf957c7cba350640486480d" translate="yes" xml:space="preserve">
          <source>Choices in brackets, default first when optional.</source>
          <target state="translated">대괄호로 묶인 선택 사항, 선택 사항 인 경우 기본값이 먼저입니다.</target>
        </trans-unit>
        <trans-unit id="6a9a5941f5c4c9ca7cc742c4728cebf364d9d84a" translate="yes" xml:space="preserve">
          <source>Choices:</source>
          <target state="translated">Choices:</target>
        </trans-unit>
        <trans-unit id="2767cec7ad20032475822095cbe0813732009259" translate="yes" xml:space="preserve">
          <source>Cholesky decompose a banded Hermitian positive-definite matrix.</source>
          <target state="translated">Cholesky는 줄무늬 Hermitian 양의 정의 행렬을 분해합니다.</target>
        </trans-unit>
        <trans-unit id="71912e57e25688eeffa7fea1751238fb822cd096" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition of a matrix, to use in &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve&quot;&gt;&lt;code&gt;scipy.linalg.cho_solve&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cho_solve.html#scipy.linalg.cho_solve&quot;&gt; &lt;code&gt;scipy.linalg.cho_solve&lt;/code&gt; &lt;/a&gt; 에서 사용할 행렬의 촐레 스키 분해 .</target>
        </trans-unit>
        <trans-unit id="3423d9c2caf056a50af1e5e388fbc351b162a74e" translate="yes" xml:space="preserve">
          <source>Cholesky decomposition.</source>
          <target state="translated">hole 레 스키 분해.</target>
        </trans-unit>
        <trans-unit id="262b802653c150f513240a2c1e888b8a22344861" translate="yes" xml:space="preserve">
          <source>Cholesky factorization of a 2D array (&lt;code&gt;chol(a)&lt;/code&gt; in MATLAB returns an upper triangular 2D array, but &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cholesky.html#scipy.linalg.cholesky&quot;&gt;&lt;code&gt;cholesky&lt;/code&gt;&lt;/a&gt; returns a lower triangular 2D array)</source>
          <target state="translated">2D 배열의 촐레 스키 분해 &lt;code&gt;chol(a)&lt;/code&gt; MATLAB의 chol (a) 는 상부 삼각 2D 배열을 반환 하지만 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.cholesky.html#scipy.linalg.cholesky&quot;&gt; &lt;code&gt;cholesky&lt;/code&gt; &lt;/a&gt; 는 하부 삼각 2D 배열을 반환)</target>
        </trans-unit>
        <trans-unit id="12973bc24b90d6422a6f6089fc22e3ce9dfde18a" translate="yes" xml:space="preserve">
          <source>Choose &lt;code&gt;nsample&lt;/code&gt; items at random without replacement from a collection with &lt;code&gt;N&lt;/code&gt; distinct types. &lt;code&gt;N&lt;/code&gt; is the length of &lt;code&gt;colors&lt;/code&gt;, and the values in &lt;code&gt;colors&lt;/code&gt; are the number of occurrences of that type in the collection. The total number of items in the collection is &lt;code&gt;sum(colors)&lt;/code&gt;. Each random variate generated by this function is a vector of length &lt;code&gt;N&lt;/code&gt; holding the counts of the different types that occurred in the &lt;code&gt;nsample&lt;/code&gt; items.</source>
          <target state="translated">&lt;code&gt;N&lt;/code&gt; 개의 고유 한 유형이 있는 컬렉션에서 대체하지 않고 무작위로 &lt;code&gt;nsample&lt;/code&gt; 항목을 선택합니다 . &lt;code&gt;N&lt;/code&gt; 은 길이 인 &lt;code&gt;colors&lt;/code&gt; 및의 값 &lt;code&gt;colors&lt;/code&gt; 컬렉션 유형의 발생 횟수이다. 컬렉션의 총 항목 수는 &lt;code&gt;sum(colors)&lt;/code&gt; 입니다. 이 함수에 의해 생성 된 각 임의 변량 은 &lt;code&gt;nsample&lt;/code&gt; 항목 에서 발생한 여러 유형의 개수를 포함하는 길이 &lt;code&gt;N&lt;/code&gt; 의 벡터입니다 .</target>
        </trans-unit>
        <trans-unit id="2ca2864418456f81d23c002bcfa240f2d8fca295" translate="yes" xml:space="preserve">
          <source>Choose five random numbers from the set of five evenly-spaced numbers between 0 and 2.5, inclusive (&lt;em&gt;i.e.&lt;/em&gt;, from the set</source>
          <target state="translated">0에서 2.5 사이의 균등 간격 숫자 5 개 세트에서 5 개의 난수를 선택하십시오 ( &lt;em&gt;예 :&lt;/em&gt; 세트에서</target>
        </trans-unit>
        <trans-unit id="35c9a25e2ab923acd6164ad4d06282c1e090295d" translate="yes" xml:space="preserve">
          <source>Choose the type of path. If a tuple is provided, the second argument is assumed to be the maximum intermediate size created. If only a single argument is provided the largest input or output array size is used as a maximum intermediate size.</source>
          <target state="translated">경로 유형을 선택하십시오. 튜플이 제공되면 두 번째 인수는 작성된 최대 중간 크기 인 것으로 가정합니다. 단일 인수 만 제공되는 경우 가장 큰 입력 또는 출력 배열 크기가 최대 중간 크기로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d477c0a201a1ecd6208acd5e9d6a705b45b36661" translate="yes" xml:space="preserve">
          <source>Choosing the data type</source>
          <target state="translated">데이터 유형 선택</target>
        </trans-unit>
        <trans-unit id="fd3c5dfb5fbf5ecce869e29e990a70ecfaa87d5e" translate="yes" xml:space="preserve">
          <source>Choosing the fortran compiler</source>
          <target state="translated">포트란 컴파일러 선택</target>
        </trans-unit>
        <trans-unit id="6410e1ff6dea4bdf660fd03e09261c2e8c92a4a7" translate="yes" xml:space="preserve">
          <source>Christian Kleiber, Samuel Kotz, &amp;ldquo;Statistical size distributions in economics and actuarial sciences&amp;rdquo;, Wiley, 2003.</source>
          <target state="translated">Christian Kleiber, Samuel Kotz,&amp;ldquo;경제 및 계리 과학의 통계적 규모 분포&amp;rdquo;, Wiley, 2003.</target>
        </trans-unit>
        <trans-unit id="16460b81f71899d57eec8f9481e7178ad88e85b9" translate="yes" xml:space="preserve">
          <source>Chuck Harris</source>
          <target state="translated">척 해리스</target>
        </trans-unit>
        <trans-unit id="699bc38ae6b089e1e0d8975a9f6a7f01d31c2f18" translate="yes" xml:space="preserve">
          <source>Circular padding. Outside bounds values will be as if the array was repeated. For example, for the array [1, 2, 3, 4], x[-2] will be 3, x[-2] will be 4, x[4] will be 1, x[5] will be 2, etc&amp;hellip;</source>
          <target state="translated">원형 패딩. 경계를 벗어난 값은 배열이 반복 된 것과 같습니다. 예를 들어 배열 [1, 2, 3, 4]의 경우 x [-2]는 3, x [-2]는 4, x [4]는 1, x [5]는 2, 기타&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="eedc46b2680ee864ce515307f6a3ce30df0bb9e4" translate="yes" xml:space="preserve">
          <source>Cite the relevant literature, e.g. &lt;a href=&quot;#ree6d1ec14498-1&quot; id=&quot;id4&quot;&gt;[1]&lt;/a&gt;. You may also cite these references in the notes section above.</source>
          <target state="translated">관련 문헌을 인용하십시오 (예 : &lt;a href=&quot;#ree6d1ec14498-1&quot; id=&quot;id4&quot;&gt;[1])&lt;/a&gt; . 위의 참고 섹션에서 이러한 참조를 인용 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1e1a4f85c2ba4fe59c5c1669b393d40791072c87" translate="yes" xml:space="preserve">
          <source>Class docstring</source>
          <target state="translated">클래스 독 스트링</target>
        </trans-unit>
        <trans-unit id="e799166bb71b4dde11ab28b58f6eff13ee75f067" translate="yes" xml:space="preserve">
          <source>Class for one-dimensional polynomials.</source>
          <target state="translated">1 차원 다항식 클래스.</target>
        </trans-unit>
        <trans-unit id="310493804f159ad6d6aa1f8e1ced0b3298b9cc2c" translate="yes" xml:space="preserve">
          <source>Class from which most (all?) numpy scalar types are derived. For consistency, exposes the same API as &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, despite many consequent attributes being either &amp;ldquo;get-only,&amp;rdquo; or completely irrelevant. This is the class from which it is strongly suggested users should derive custom scalar types.</source>
          <target state="translated">대부분의 (모두?) numpy 스칼라 유형이 파생되는 클래스입니다. 일관성을 위해 많은 결과 속성이 &quot;get-only&quot;이거나 완전히 관련이 없음에도 불구하고 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 와 동일한 API를 노출합니다 . 이것은 사용자가 사용자 정의 스칼라 유형을 파생해야한다고 강력하게 제안하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="141f83ee32f213c3c3e30b940039c0256ca45642" translate="yes" xml:space="preserve">
          <source>Class from which most (all?) numpy scalar types are derived. For consistency, exposes the same API as &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, despite many consequent attributes being either &amp;ldquo;get-only,&amp;rdquo; or completely irrelevant. This is the class from which it is strongly suggested users should derive custom scalar types.</source>
          <target state="translated">대부분의 (모든?) numpy 스칼라 유형이 파생되는 클래스입니다. 일관성을 위해 많은 결과 속성이 &quot;get-only&quot;또는 완전히 관련이 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 와 동일한 API를 노출합니다 . 이 클래스는 사용자가 사용자 지정 스칼라 형식을 파생시켜야하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f3a9c0c7155c7f2627130b00e8664e0c47570c98" translate="yes" xml:space="preserve">
          <source>Class generic exists solely to derive numpy scalars from, and possesses, albeit unimplemented, all the attributes of the ndarray class so as to provide a uniform API.</source>
          <target state="translated">제네릭 클래스는 단일 API를 제공하기 위해 ndarray 클래스의 모든 속성에서 numpy 스칼라를 도출하고 구현하지는 않지만 존재합니다.</target>
        </trans-unit>
        <trans-unit id="50af8b2f53e369e6ce37192f4f707fa498a94b5e" translate="yes" xml:space="preserve">
          <source>Class instance.</source>
          <target state="translated">클래스 인스턴스.</target>
        </trans-unit>
        <trans-unit id="2785358c74196dd17652dd76c2cb1f0e3a27dcf4" translate="yes" xml:space="preserve">
          <source>Class of the underlying data (read-only).</source>
          <target state="translated">기본 데이터의 클래스 (읽기 전용).</target>
        </trans-unit>
        <trans-unit id="631eda8579e2970ff77106029d682f1124ccd882" translate="yes" xml:space="preserve">
          <source>Class to convert formats, names, titles description to a dtype.</source>
          <target state="translated">형식, 이름, 제목 설명을 dtype으로 변환하는 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="70956031e8aba40d5608418084c786b47da059e0" translate="yes" xml:space="preserve">
          <source>Class whose methods to decorate.</source>
          <target state="translated">메소드를 장식 할 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="ed1846afee3be21521286932b99e2aeae9e6414a" translate="yes" xml:space="preserve">
          <source>Classes</source>
          <target state="translated">Classes</target>
        </trans-unit>
        <trans-unit id="94a0e1eeea610589ba223c0aebbf56c35a8d5343" translate="yes" xml:space="preserve">
          <source>Classes (including ndarray subclasses) can override how ufuncs act on them by defining certain special methods. For details, see &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;Standard array subclasses&lt;/a&gt;.</source>
          <target state="translated">클래스 (ndarray 서브 클래스 포함)는 특정 특수 메소드를 정의하여 ufunc가 클래스에 대해 수행하는 방식을 대체 할 수 있습니다. 자세한 내용은 &lt;a href=&quot;arrays.classes#arrays-classes&quot;&gt;표준 배열 하위 클래스를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="39dc77f987229934cc60ecfa0809fc0d18f916fd" translate="yes" xml:space="preserve">
          <source>Classes specifying the information to be printed are defined in the &lt;code&gt;numpy.distutils.system_info&lt;/code&gt; module.</source>
          <target state="translated">인쇄 할 정보를 지정하는 클래스는 &lt;code&gt;numpy.distutils.system_info&lt;/code&gt; 모듈에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="70c66297b049e0748e33bac4e4aa71b028603811" translate="yes" xml:space="preserve">
          <source>Clear and severe breach actions</source>
          <target state="translated">명확하고 심각한 위반 조치</target>
        </trans-unit>
        <trans-unit id="0716551020b700fbc40d6da11a6a973469d6550e" translate="yes" xml:space="preserve">
          <source>Clear the IEEE error flags.</source>
          <target state="translated">IEEE 오류 플래그를 지우십시오.</target>
        </trans-unit>
        <trans-unit id="93188aa17cfb01f09e7b90afbdf16a0d09c57e22" translate="yes" xml:space="preserve">
          <source>Clearly, the signature of &lt;code&gt;fib2.fib&lt;/code&gt; now corresponds to the intention of Fortran subroutine &lt;code&gt;FIB&lt;/code&gt; more closely: given the number &lt;code&gt;n&lt;/code&gt;, &lt;code&gt;fib2.fib&lt;/code&gt; returns the first &lt;code&gt;n&lt;/code&gt; Fibonacci numbers as a NumPy array. Also, the new Python signature &lt;code&gt;fib2.fib&lt;/code&gt; rules out any surprises that we experienced with &lt;code&gt;fib1.fib&lt;/code&gt;.</source>
          <target state="translated">분명히 서명의 &lt;code&gt;fib2.fib&lt;/code&gt; 는 지금 포트란 서브 루틴의 의도에 대응 &lt;code&gt;FIB&lt;/code&gt; 더 밀접 : 소정 개수 &lt;code&gt;n&lt;/code&gt; , &lt;code&gt;fib2.fib&lt;/code&gt; 의 반환 제 &lt;code&gt;n&lt;/code&gt; NumPy와 배열과 피보나치 번호. 또한 새로운 Python 서명 &lt;code&gt;fib2.fib&lt;/code&gt; 는 &lt;code&gt;fib1.fib&lt;/code&gt; 에서 경험 한 놀라움을 배제 합니다.</target>
        </trans-unit>
        <trans-unit id="d54d8ffb592fd7551eb0fff09b91b8b03d14a55e" translate="yes" xml:space="preserve">
          <source>Clearly, this is not an expected behaviour. The fact that the above example worked with &lt;code&gt;dtype=float&lt;/code&gt; is considered accidental.</source>
          <target state="translated">분명히 이것은 예상되는 동작이 아닙니다. 위의 예제가 &lt;code&gt;dtype=float&lt;/code&gt; 와 함께 작동했다는 사실 은 우연한 것으로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="69cde09c8e5adab6b0a10f29c8e8089827660cd3" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reodering this function call. Returns the previous status mask.</source>
          <target state="translated">부동 소수점 상태를 지 웁니다. 공격적인 컴파일러 최적화가이 함수 호출을 다시 지정하지 못하도록 로컬 변수에 대한 포인터가 전달됩니다. 이전 상태 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="ed1f9109b874431402e7e242d58614b8508e6754" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. A pointer to a local variable is passed in to prevent aggressive compiler optimizations from reordering this function call. Returns the previous status mask.</source>
          <target state="translated">부동 소수점 상태를 지 웁니다. 적극적인 컴파일러 최적화가이 함수 호출의 순서를 변경하지 못하도록 로컬 변수에 대한 포인터가 전달됩니다. 이전 상태 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="85631dab84756553305933ab9884fa05e7033c9b" translate="yes" xml:space="preserve">
          <source>Clears the floating point status. Returns the previous status mask.</source>
          <target state="translated">부동 소수점 상태를 지 웁니다. 이전 상태 마스크를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="95fd8bb886c035e55cfc935aa6369ec4437d9dba" translate="yes" xml:space="preserve">
          <source>Clears the specified array flags. This function does no validation, and assumes that you know what you&amp;rsquo;re doing.</source>
          <target state="translated">지정된 배열 플래그를 지 웁니다. 이 함수는 유효성 검사를 수행하지 않으며 수행중인 작업을 알고 있다고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="87a966bc3a0e8b49349f2e74d267c1202d21bb69" translate="yes" xml:space="preserve">
          <source>Click on the &amp;lsquo;Admin&amp;rsquo; button, and add anyone else to the repo as a collaborator:</source>
          <target state="translated">'관리'버튼을 클릭하고 다른 사람을 공동 작업자로 저장소에 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b202685281d47a327156e53f1a2165efd9cbfc91" translate="yes" xml:space="preserve">
          <source>Click on the &lt;em&gt;fork&lt;/em&gt; button:</source>
          <target state="translated">&lt;em&gt;포크&lt;/em&gt; 버튼을 클릭 합니다 :</target>
        </trans-unit>
        <trans-unit id="0259cd63a54e3479014d0b233265a7cb8a0c929d" translate="yes" xml:space="preserve">
          <source>Clip (limit) the values in an array.</source>
          <target state="translated">배열의 값을 클립 (제한)합니다.</target>
        </trans-unit>
        <trans-unit id="10b5f7285e869f556c319cd6389b16c1806e6590" translate="yes" xml:space="preserve">
          <source>Clipping and rounding</source>
          <target state="translated">클리핑 및 반올림</target>
        </trans-unit>
        <trans-unit id="01110fe45ef307b0f0fc59a0a0494616ad2d9d3c" translate="yes" xml:space="preserve">
          <source>Clips an index to the valid range if it is out of bounds.</source>
          <target state="translated">범위를 벗어난 경우 인덱스를 유효한 범위로 자릅니다.</target>
        </trans-unit>
        <trans-unit id="179755c100537d42883bc546a8caf3a46a35f567" translate="yes" xml:space="preserve">
          <source>Clone the project to your local computer:</source>
          <target state="translated">프로젝트를 로컬 컴퓨터에 복제합니다.</target>
        </trans-unit>
        <trans-unit id="5b64cfe6be1411cd7fe0a76e5fb94142fcfb5262" translate="yes" xml:space="preserve">
          <source>Clone your fork</source>
          <target state="translated">포크 복제</target>
        </trans-unit>
        <trans-unit id="38bf2a1eaa30b34536c51de1b9b8ffd3a598c4f8" translate="yes" xml:space="preserve">
          <source>Clone your fork to the local computer with &lt;code&gt;git clone
https://github.com/your-user-name/numpy.git&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;git clone https://github.com/your-user-name/numpy.git&lt;/code&gt; 을 사용하여 포크를 로컬 컴퓨터에 복제하십시오.</target>
        </trans-unit>
        <trans-unit id="8fb1672895428c0262aba67a55bb99e8c779b32e" translate="yes" xml:space="preserve">
          <source>Cloning your NumPy fork repo required no password, because it read the remote repo without changing it. Later, though, submitting your pull requests will write to it, and GitHub will ask for your username and password &amp;ndash; even though it&amp;rsquo;s your own repo. You can eliminate this authentication without compromising security by &lt;a href=&quot;https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh&quot;&gt;setting up SSH keys &lt;/a&gt;.</source>
          <target state="translated">NumPy 포크 리포지토리를 복제하면 암호를 변경하지 않고 원격 리포지토리를 읽으므로 암호가 필요하지 않습니다. 하지만 나중에 풀 요청을 제출하면 여기에 기록되고 GitHub는 사용자 이름과 비밀번호를 요청합니다. 비록 자체 저장소이더라도 말입니다. &lt;a href=&quot;https://help.github.com/en/github/authenticating-to-github/connecting-to-github-with-ssh&quot;&gt;SSH 키&lt;/a&gt; 를 설정하여 보안을 손상시키지 않고이 인증을 제거 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="adac69379a626c2436948a4ef1792c7d719ef929" translate="yes" xml:space="preserve">
          <source>Code</source>
          <target state="translated">Code</target>
        </trans-unit>
        <trans-unit id="4d34b442277ac95d1b3d9daa9954264e3f92d0e3" translate="yes" xml:space="preserve">
          <source>Code is &lt;em&gt;written&lt;/em&gt; using the universal intrinsic macros, with guards that will enable use of the macros only when the compiler recognizes them. In NumPy, these are used to construct multiple ufunc loops. Current policy is to create three loops: One loop is the default and uses no intrinsics. One uses the minimum intrinsics required on the architecture. And the third is written using the maximum set of intrinsics possible.</source>
          <target state="translated">코드는 컴파일러가 매크로를 인식 할 때만 매크로를 사용할 수 있도록하는 가드와 함께 범용 내장 매크로를 사용하여 &lt;em&gt;작성&lt;/em&gt; 됩니다. NumPy에서 이들은 여러 ufunc 루프를 구성하는 데 사용됩니다. 현재 정책은 세 개의 루프를 만드는 것입니다. 하나의 루프가 기본값이며 내장 함수를 사용하지 않습니다. 하나는 아키텍처에 필요한 최소한의 내장 함수를 사용합니다. 세 번째는 가능한 최대 내장 함수 집합을 사용하여 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="62f18e281cfc29d9c7a7fc86dddda134af4ea798" translate="yes" xml:space="preserve">
          <source>Code lay-out</source>
          <target state="translated">코드 레이아웃</target>
        </trans-unit>
        <trans-unit id="4cda7c9faa3b5335f012c53a4a45daebecabe9c2" translate="yes" xml:space="preserve">
          <source>Code maintenance and development</source>
          <target state="translated">코드 유지 관리 및 개발</target>
        </trans-unit>
        <trans-unit id="4c6d56aa06140201b957d61e514a687a45637be2" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 32-bit system.</source>
          <target state="translated">32 비트 시스템의 &quot;안전하게 캐스트 가능&quot;테이블을 표시하는 코드 세그먼트입니다.</target>
        </trans-unit>
        <trans-unit id="6acd82038060af5c738afabbce906304f6a33338" translate="yes" xml:space="preserve">
          <source>Code segment showing the &amp;ldquo;can cast safely&amp;rdquo; table for a 64-bit system. Generally the output depends on the system; your system might result in a different table.</source>
          <target state="translated">64 비트 시스템에 대한 &quot;안전하게 캐스트 할 수 있음&quot;테이블을 보여주는 코드 세그먼트. 일반적으로 출력은 시스템에 따라 다릅니다. 시스템이 다른 테이블을 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9f6f12146c68ac2d13434f01199bc89b65cb5d95" translate="yes" xml:space="preserve">
          <source>Code structure: one space between keywords like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;for&lt;/code&gt; and the following left parenthesis; no spaces inside the parenthesis; braces around all &lt;code&gt;if&lt;/code&gt; branches and no statements on the same line as the &lt;code&gt;if&lt;/code&gt;. They should be formatted as shown:</source>
          <target state="translated">코드 구조 : &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;for&lt;/code&gt; 및 다음 왼쪽 괄호와 같은 키워드 사이에 하나의 공백 ; 괄호 안에 공백이 없습니다. 괄호 주위의 모든 &lt;code&gt;if&lt;/code&gt; 지점과 같은 줄에 아무런 진술 &lt;code&gt;if&lt;/code&gt; . 다음과 같은 형식이어야합니다.</target>
        </trans-unit>
        <trans-unit id="4880c50f2ea2d547641da09b4c0bf604cbaad4e6" translate="yes" xml:space="preserve">
          <source>Coefficient array of the integral.</source>
          <target state="translated">적분의 계수 배열.</target>
        </trans-unit>
        <trans-unit id="90095bbe595b4717b5f28520d7191bc7b67d082b" translate="yes" xml:space="preserve">
          <source>Coefficient matrix.</source>
          <target state="translated">계수 행렬.</target>
        </trans-unit>
        <trans-unit id="7ff4e0921ad16edc7282af8e661233be9efdef85" translate="yes" xml:space="preserve">
          <source>Coefficient tensor, of shape &lt;code&gt;b.shape + Q&lt;/code&gt;. &lt;code&gt;Q&lt;/code&gt;, a tuple, equals the shape of that sub-tensor of &lt;code&gt;a&lt;/code&gt; consisting of the appropriate number of its rightmost indices, and must be such that &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (in which sense &lt;code&gt;a&lt;/code&gt; is said to be &amp;lsquo;square&amp;rsquo;).</source>
          <target state="translated">모양이 &lt;code&gt;b.shape + Q&lt;/code&gt; 인 계수 텐서 . &lt;code&gt;Q&lt;/code&gt; , 튜플은, 그 서브 텐서의 형상과 동일 그 우측 인덱스의 적절한 수 이루어지는을 한 것이어야한다 &lt;code&gt;prod(Q) == prod(b.shape)&lt;/code&gt; (여기서 감지 라고 '평방'이어야합니다.) &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f7d7eca3d654d7516012e0321be8d2b34b3af6d" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the quotient.</source>
          <target state="translated">몫의 0을 포함하여 계수.</target>
        </trans-unit>
        <trans-unit id="b57ec6a0b2d77f8f2ef4d5e927f014b094bd79db" translate="yes" xml:space="preserve">
          <source>Coefficients, including those equal to zero, of the remainder.</source>
          <target state="translated">나머지의 0과 같은 것을 포함한 계수.</target>
        </trans-unit>
        <trans-unit id="3c2fcb20e68435f85b762cfd1d987d2533770ffc" translate="yes" xml:space="preserve">
          <source>Collapsed to a one-dimensional array. See &lt;a href=&quot;reference/generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt;&lt;code&gt;numpy.ndarray.flatten&lt;/code&gt;&lt;/a&gt; for details.</source>
          <target state="translated">1 차원 배열로 축소되었습니다. 자세한 내용은 &lt;a href=&quot;reference/generated/numpy.ndarray.flatten#numpy.ndarray.flatten&quot;&gt; &lt;code&gt;numpy.ndarray.flatten&lt;/code&gt; &lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="41175d152a9f45e2d3d903913dcac5478e50c120" translate="yes" xml:space="preserve">
          <source>Collection of utilities to manipulate structured arrays.</source>
          <target state="translated">구조화 된 배열을 조작하기위한 유틸리티 모음입니다.</target>
        </trans-unit>
        <trans-unit id="99b2f68944ffe47fe2c86e737221636b3c8e81e8" translate="yes" xml:space="preserve">
          <source>Column-major order is also known as the Fortran order, as the Fortran programming language uses it.</source>
          <target state="translated">열 주요 순서는 Fortran 프로그래밍 언어에서 사용하므로 Fortran 순서라고도합니다.</target>
        </trans-unit>
        <trans-unit id="3a433dc0365548604b9b44d97f7bfbf6e88d77aa" translate="yes" xml:space="preserve">
          <source>Combination of &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt;&lt;code&gt;PyArray_FROM_OF&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt;&lt;code&gt;PyArray_FROM_OT&lt;/code&gt;&lt;/a&gt; allowing both a &lt;em&gt;typenum&lt;/em&gt; and a &lt;em&gt;flags&lt;/em&gt; argument to be provided.</source>
          <target state="translated">조합 &lt;a href=&quot;#c.PyArray_FROM_OF&quot;&gt; &lt;code&gt;PyArray_FROM_OF&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.PyArray_FROM_OT&quot;&gt; &lt;code&gt;PyArray_FROM_OT&lt;/code&gt; 는&lt;/a&gt; 둘 다를 수 &lt;em&gt;typenum&lt;/em&gt; 와 &lt;em&gt;플래그&lt;/em&gt; 인수가 제공 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1825a72b8523c42869f6ed18e25b4d98c6db9809" translate="yes" xml:space="preserve">
          <source>Combinations of array flags</source>
          <target state="translated">배열 플래그의 조합</target>
        </trans-unit>
        <trans-unit id="003eeb3cc5852db3801153f1b44bcb67c74144f5" translate="yes" xml:space="preserve">
          <source>Combine the commits &lt;code&gt;2dec1ac&lt;/code&gt;, &lt;code&gt;a815645&lt;/code&gt;, &lt;code&gt;eadc391&lt;/code&gt; into a single one.</source>
          <target state="translated">커밋 &lt;code&gt;2dec1ac&lt;/code&gt; , &lt;code&gt;a815645&lt;/code&gt; , &lt;code&gt;eadc391&lt;/code&gt; 을 하나 의 커밋으로 결합합니다 .</target>
        </trans-unit>
        <trans-unit id="04f619e0125978268f6037fab0f4bee54fa7538a" translate="yes" xml:space="preserve">
          <source>Combine two masks with the &lt;code&gt;logical_or&lt;/code&gt; operator.</source>
          <target state="translated">두 개의 마스크를 &lt;code&gt;logical_or&lt;/code&gt; 연산자 와 결합하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac4e580a3225536b502c2bf6b739b38d8c6dc235" translate="yes" xml:space="preserve">
          <source>Combining advanced and basic indexing</source>
          <target state="translated">고급 인덱싱과 기본 인덱싱 결합</target>
        </trans-unit>
        <trans-unit id="127ce4975a7080b5ec675c2982d4f6e8310b7283" translate="yes" xml:space="preserve">
          <source>Combining index arrays with slices</source>
          <target state="translated">인덱스 배열과 슬라이스 결합</target>
        </trans-unit>
        <trans-unit id="6db9979c1fe0813b3eb2ee3a9a6ae24f7e5faea6" translate="yes" xml:space="preserve">
          <source>Combining multiple Boolean indexing arrays or a Boolean with an integer indexing array can best be understood with the &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt;&lt;code&gt;obj.nonzero()&lt;/code&gt;&lt;/a&gt; analogy. The function &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt;&lt;code&gt;ix_&lt;/code&gt;&lt;/a&gt; also supports boolean arrays and will work without any surprises.</source>
          <target state="translated">여러 부울 인덱싱 배열 또는 부울을 정수 인덱싱 배열과 결합하는 것은 &lt;a href=&quot;generated/numpy.ndarray.nonzero#numpy.ndarray.nonzero&quot;&gt; &lt;code&gt;obj.nonzero()&lt;/code&gt; &lt;/a&gt; 유추로 가장 잘 이해할 수 있습니다 . &lt;a href=&quot;generated/numpy.ix_#numpy.ix_&quot;&gt; &lt;code&gt;ix_&lt;/code&gt; &lt;/a&gt; 함수 는 부울 배열도 지원하며 놀라움없이 작동합니다.</target>
        </trans-unit>
        <trans-unit id="40b915799a646f155caf3ed37b1899def540e8a4" translate="yes" xml:space="preserve">
          <source>Combining with stepped slicing (&lt;code&gt;::step&lt;/code&gt;), this can be used to take sliding views which skip elements:</source>
          <target state="translated">단계별 슬라이싱 ( &lt;code&gt;::step&lt;/code&gt; ) 과 결합하여 요소를 건너 뛰는 슬라이딩 뷰를 가져 오는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="48361d97c401e366adbd5368490fd7ba9e87a2ae" translate="yes" xml:space="preserve">
          <source>Comma Separated Value files (CSV) are widely used (and an export and import option for programs like Excel). There are a number of ways of reading these files in Python. There are CSV functions in Python and functions in pylab (part of matplotlib).</source>
          <target state="translated">CSV (쉼표로 구분 된 값) 파일이 널리 사용됩니다 (그리고 Excel과 같은 프로그램의 내보내기 및 가져 오기 옵션). Python에서 이러한 파일을 읽는 방법에는 여러 가지가 있습니다. Python에는 CSV 함수가 있고 pylab에는 함수가 있습니다 (matplotlib의 일부).</target>
        </trans-unit>
        <trans-unit id="39a64d591310ffe84aa9b684771a7d278ba716a5" translate="yes" xml:space="preserve">
          <source>Comma delimited file with mixed dtype</source>
          <target state="translated">dtype이 혼합 된 쉼표로 구분 된 파일</target>
        </trans-unit>
        <trans-unit id="6a1f5ffc0ab313847c7fd16153c2c1f631a74c7f" translate="yes" xml:space="preserve">
          <source>Command &lt;code&gt;f2py&lt;/code&gt;</source>
          <target state="translated">명령 &lt;code&gt;f2py&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a442ff47616055a09385f87492675eec3f89c3c" translate="yes" xml:space="preserve">
          <source>Comments go before the code they describe. Multi-line comments should be like so:</source>
          <target state="translated">주석은 설명하는 코드 앞에옵니다. 여러 줄 주석은 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="84228a13dd8f0021fa36768dd176470923d0af72" translate="yes" xml:space="preserve">
          <source>Commit locally as you progress (&lt;code&gt;git add&lt;/code&gt; and &lt;code&gt;git commit&lt;/code&gt;) Use a &lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;properly formatted&lt;/a&gt; commit message, write tests that fail before your change and pass afterward, run all the &lt;a href=&quot;development_environment#development-environment&quot;&gt;tests locally&lt;/a&gt;. Be sure to document any changed behavior in docstrings, keeping to the NumPy docstring &lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;standard&lt;/a&gt;.</source>
          <target state="translated">진행하면서 로컬로 커밋 ( &lt;code&gt;git add&lt;/code&gt; 및 &lt;code&gt;git commit&lt;/code&gt; ) &lt;a href=&quot;development_workflow#writing-the-commit-message&quot;&gt;올바른 형식의&lt;/a&gt; 커밋 메시지를 사용하고 변경 전에 실패한 테스트를 작성하고 나중에 통과 한 다음 모든 &lt;a href=&quot;development_environment#development-environment&quot;&gt;테스트를 로컬&lt;/a&gt; 에서 실행합니다 . NumPy 독 스트링 &lt;a href=&quot;../docs/howto_document#howto-document&quot;&gt;표준을&lt;/a&gt; 유지하면서 독 스트링의 변경된 동작을 문서화해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0a32ce4cd17558c48ae2944590272943673a2335" translate="yes" xml:space="preserve">
          <source>Commit messages should be clear and follow a few basic rules. Example:</source>
          <target state="translated">커밋 메시지는 명확해야하며 몇 가지 기본 규칙을 따라야합니다. 예:</target>
        </trans-unit>
        <trans-unit id="a8981cd8f439f881e61c62a6482ca86e9bb4de5a" translate="yes" xml:space="preserve">
          <source>Commit the result:</source>
          <target state="translated">결과를 커밋합니다.</target>
        </trans-unit>
        <trans-unit id="47e4d165580c53bcc66b6184b36ff34e18c1fd45" translate="yes" xml:space="preserve">
          <source>Common ASCII Formats</source>
          <target state="translated">일반적인 ASCII 형식</target>
        </trans-unit>
        <trans-unit id="f951af1137a01c272e20259ce69b92a33cbe2c01" translate="yes" xml:space="preserve">
          <source>Common block statements:</source>
          <target state="translated">공통 블록 문 :</target>
        </trans-unit>
        <trans-unit id="f108ad260d0dee041e2947d7bef1a1ab5f773f80" translate="yes" xml:space="preserve">
          <source>Common blocks</source>
          <target state="translated">공통 블록</target>
        </trans-unit>
        <trans-unit id="67644de9822acbd842a9ed1592fafe3b76c5957a" translate="yes" xml:space="preserve">
          <source>Common reST concepts</source>
          <target state="translated">일반적인 reST 개념</target>
        </trans-unit>
        <trans-unit id="39a95105f6ae1d2c8ab5b77d2df7fa0bdc43b7b9" translate="yes" xml:space="preserve">
          <source>Common test support for all numpy test scripts.</source>
          <target state="translated">모든 numpy 테스트 스크립트에 대한 공통 테스트 지원.</target>
        </trans-unit>
        <trans-unit id="0566048715bf86dcee9d7676914441bbb777e1fb" translate="yes" xml:space="preserve">
          <source>Communication Guidelines</source>
          <target state="translated">커뮤니케이션 지침</target>
        </trans-unit>
        <trans-unit id="ed80df7539525d1ebd0e5bb91694075d97aa07d4" translate="yes" xml:space="preserve">
          <source>Community coordination</source>
          <target state="translated">커뮤니티 조정</target>
        </trans-unit>
        <trans-unit id="c2a68a63dc41f356e6d15c8c535eea2cf026660b" translate="yes" xml:space="preserve">
          <source>Companion matrix of dimensions (deg, deg).</source>
          <target state="translated">치수의 동반 행렬 (도,도).</target>
        </trans-unit>
        <trans-unit id="38428edac9ae2355adbd42053821bdf711ded835" translate="yes" xml:space="preserve">
          <source>Compare against built-in broadcasting:</source>
          <target state="translated">내장 된 방송과 비교 :</target>
        </trans-unit>
        <trans-unit id="b2a60fa70e9171ad22b67932b73a6ceaa9b40830" translate="yes" xml:space="preserve">
          <source>Compare change in benchmark results to another version/commit/branch:</source>
          <target state="translated">벤치 마크 결과의 변경 사항을 다른 버전 / 커밋 / 브랜치와 비교 :</target>
        </trans-unit>
        <trans-unit id="b5977dbb9726befd30db9317959bca3faeb91b26" translate="yes" xml:space="preserve">
          <source>Compare the power function distribution to the inverse of the Pareto.</source>
          <target state="translated">전력 함수 분포를 파레토의 역수와 비교합니다.</target>
        </trans-unit>
        <trans-unit id="abbe4b051440d5c3941fb5ca3a1c58883bee0b7d" translate="yes" xml:space="preserve">
          <source>Compare two array_like objects for equality with desired relative and/or absolute precision.</source>
          <target state="translated">두 개의 array_like 객체를 원하는 상대 및 / 또는 절대 정밀도와 같은지 비교하십시오.</target>
        </trans-unit>
        <trans-unit id="6e9c538fcc856b4c5b41ccf954d897e3fba11150" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최대 값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 해당 요소가 리턴됩니다. 두 요소가 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="52e468afc192be1b2f72e0bc9d7f9f138350a871" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise maxima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최대 값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 Nan이 아닌 요소가 반환됩니다. 두 요소가 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN은 가능한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ace9cb4b9063e509209a97ac371136964f6f7819" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then that element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are propagated.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최소값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 해당 요소가 리턴됩니다. 두 요소가 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN이 전파됩니다.</target>
        </trans-unit>
        <trans-unit id="89c593ddd4725e7eb3064d75c349a4174bbacd17" translate="yes" xml:space="preserve">
          <source>Compare two arrays and returns a new array containing the element-wise minima. If one of the elements being compared is a NaN, then the non-nan element is returned. If both elements are NaNs then the first is returned. The latter distinction is important for complex NaNs, which are defined as at least one of the real or imaginary parts being a NaN. The net effect is that NaNs are ignored when possible.</source>
          <target state="translated">두 배열을 비교하고 요소 별 최소값을 포함하는 새 배열을 반환합니다. 비교되는 요소 중 하나가 NaN이면 Nan이 아닌 요소가 반환됩니다. 두 요소가 NaN이면 첫 번째 요소가 반환됩니다. 후자의 구별은 복잡한 NaN에 중요하며, 이는 NaN 인 실수 부 또는 허수 부 중 적어도 하나로 정의됩니다. 결과적으로 NaN은 가능한 경우 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="bc6a4145f838627dea20878218beb3ec59a9a475" translate="yes" xml:space="preserve">
          <source>Compare two arrays relatively to their spacing.</source>
          <target state="translated">두 배열을 간격과 상대적으로 비교합니다.</target>
        </trans-unit>
        <trans-unit id="3aa05ceaaca50383ae3aabbf2a41d83e5da1cd94" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;code&gt;ndarray&lt;/code&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.char.chararray.item#numpy.char.chararray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">색인 구문에 비해 &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; 의 특정 위치에 스칼라를 배치 약간의 속도 증가 제공 &lt;code&gt;ndarray&lt;/code&gt; 이 작업을 수행해야하는 경우를. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서 코드의 모양을 복잡하게 만듭니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.char.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.char.chararray.item#numpy.char.chararray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메서드를 지역 변수에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="8520223908607ca37ab66be3e4ca795dd7020679" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.chararray.item#numpy.chararray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">색인 구문에 비해 &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; 의 특정 위치에 스칼라를 배치 약간의 속도 증가 제공 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 이 작업을 수행해야하는 경우를. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서 코드의 모양을 복잡하게 만듭니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.chararray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.chararray.item#numpy.chararray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메서드를 지역 변수에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="c0db5e8b47f9088d33c92f8b8df1d889c411c0de" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;code&gt;ndarray&lt;/code&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ma.masked_array.item#numpy.ma.masked_array.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">색인 구문에 비해 &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; 의 특정 위치에 스칼라를 배치 약간의 속도 증가 제공 &lt;code&gt;ndarray&lt;/code&gt; 이 작업을 수행해야하는 경우를. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서 코드의 모양을 복잡하게 만듭니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.ma.masked_array.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.ma.masked_array.item#numpy.ma.masked_array.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메서드를 지역 변수에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="38460977eefc5ad076607c73457ab20f90eef5d2" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">인덱싱 구문과 비교할 때 &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 은 스칼라를 ndarray 의 특정 위치에 배치하기 위해 약간의 속도 향상을 제공 합니다. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서도 코드의 모양이 복잡합니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.matrix.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.matrix.item#numpy.matrix.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메소드를 로컬 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="ae8fffbb1016256e2544794348c439996df8510c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.memmap.item#numpy.memmap.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">색인 구문에 비해 &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; 의 특정 위치에 스칼라를 배치 약간의 속도 증가 제공 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 이 작업을 수행해야하는 경우를. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서 코드의 모양을 복잡하게 만듭니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.memmap.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.memmap.item#numpy.memmap.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메서드를 지역 변수에 할당해야합니다.</target>
        </trans-unit>
        <trans-unit id="37a1ac805be872bfc7e003c20b71f2f1bbbc823c" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">인덱싱 구문과 비교할 때 &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 은 스칼라를 ndarray 의 특정 위치에 배치하기 위해 약간의 속도 향상을 제공 합니다. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서도 코드의 모양이 복잡합니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.ndarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.ndarray.item#numpy.ndarray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메소드를 로컬 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="d83995123f5ea98603e646a9178fcfffebb1958a" translate="yes" xml:space="preserve">
          <source>Compared to indexing syntax, &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; provides some speed increase for placing a scalar into a particular location in an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, if you must do this. However, generally this is discouraged: among other problems, it complicates the appearance of the code. Also, when using &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt;&lt;code&gt;itemset&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;numpy.recarray.item#numpy.recarray.item&quot;&gt;&lt;code&gt;item&lt;/code&gt;&lt;/a&gt;) inside a loop, be sure to assign the methods to a local variable to avoid the attribute look-up at each loop iteration.</source>
          <target state="translated">인덱싱 구문과 비교할 때 &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 은 스칼라를 ndarray 의 특정 위치에 배치하기 위해 약간의 속도 향상을 제공 합니다. 그러나 일반적으로 이것은 권장되지 않습니다. 다른 문제 중에서도 코드의 모양이 복잡합니다. 또한 루프 내에서 &lt;a href=&quot;#numpy.recarray.itemset&quot;&gt; &lt;code&gt;itemset&lt;/code&gt; &lt;/a&gt; (및 &lt;a href=&quot;numpy.recarray.item#numpy.recarray.item&quot;&gt; &lt;code&gt;item&lt;/code&gt; &lt;/a&gt; )을 사용할 때 각 루프 반복에서 속성 조회를 피하기 위해 메소드를 로컬 변수에 지정하십시오.</target>
        </trans-unit>
        <trans-unit id="c659be692ea2a97bb2ad6d27d767ba11002c5a0f" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 != h2).</source>
          <target state="translated">반 정밀도 부동 소수점 2 개 (h1! = h2)를 비교합니다.</target>
        </trans-unit>
        <trans-unit id="a8531600ccd3e5208344582224d725dc6447d471" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;gt; h2).</source>
          <target state="translated">반 정밀도 부동 소수점 2 개를 비교합니다 (h1&amp;gt; h2).</target>
        </trans-unit>
        <trans-unit id="1fe54d41d33ca7b444169273c69fa5061d6e3f69" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;gt;= h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1&amp;gt; = h2).</target>
        </trans-unit>
        <trans-unit id="09c74964a2a76ed9d39c659abab42ad8913ca62f" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;lt; h2).</source>
          <target state="translated">반 정밀도 부동 소수점 두 개를 비교합니다 (h1 &amp;lt;h2).</target>
        </trans-unit>
        <trans-unit id="09ca56b6c4b7cdb0aacabc3d8ecbb1eef0726cc8" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 &amp;lt;= h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;= h2).</target>
        </trans-unit>
        <trans-unit id="2a372af75f04fe5db91b2eb992a65a4b830bbcda" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats (h1 == h2).</source>
          <target state="translated">두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 == h2).</target>
        </trans-unit>
        <trans-unit id="6569476619ffc6f6e8942d6f762781ba11246ce3" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats that are known to not be NaN (h1 &amp;lt; h2). If a value is NaN, the result is undefined.</source>
          <target state="translated">NaN이 아닌 것으로 알려진 두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;h2). 값이 NaN이면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6caa81fd2bc3f158b7e80b5e938442169d219755" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats that are known to not be NaN (h1 &amp;lt;= h2). If a value is NaN, the result is undefined.</source>
          <target state="translated">NaN이 아닌 것으로 알려진 두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 &amp;lt;= h2). 값이 NaN이면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2488158fc090106e7c705b17853d535c32a0c590" translate="yes" xml:space="preserve">
          <source>Compares two half-precision floats that are known to not be NaN (h1 == h2). If a value is NaN, the result is undefined.</source>
          <target state="translated">NaN이 아닌 것으로 알려진 두 개의 반 정밀도 부동 소수점을 비교합니다 (h1 == h2). 값이 NaN이면 결과가 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dff584999fbb6cd5911aa30f1590245afbbe3b17" translate="yes" xml:space="preserve">
          <source>Comparing Performance</source>
          <target state="translated">성능 비교</target>
        </trans-unit>
        <trans-unit id="eea251154fb167c3cc620efaacead79a92ce4964" translate="yes" xml:space="preserve">
          <source>Comparing needs to be done against a valid version string or other &lt;a href=&quot;#numpy.lib.NumpyVersion&quot;&gt;&lt;code&gt;NumpyVersion&lt;/code&gt;&lt;/a&gt; instance. Note that all development versions of the same (pre-)release compare equal.</source>
          <target state="translated">유효한 버전 문자열 또는 다른 &lt;a href=&quot;#numpy.lib.NumpyVersion&quot;&gt; &lt;code&gt;NumpyVersion&lt;/code&gt; &lt;/a&gt; 인스턴스 와 비교해야 합니다. 동일한 (사전) 릴리스의 모든 개발 버전은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="2dfcf898a3bd4e011123eee87384ecb67d0919d4" translate="yes" xml:space="preserve">
          <source>Comparison</source>
          <target state="translated">Comparison</target>
        </trans-unit>
        <trans-unit id="b25204cbd4bfc02484e2851632d991b06eb495ce" translate="yes" xml:space="preserve">
          <source>Comparison functions</source>
          <target state="translated">비교 기능</target>
        </trans-unit>
        <trans-unit id="a7de33d110c915ab8e665813e77fafb72e84afb2" translate="yes" xml:space="preserve">
          <source>Comparison operators:</source>
          <target state="translated">비교 연산자 :</target>
        </trans-unit>
        <trans-unit id="701eaaa12ac0e8c94934fa420da9730a812c4f33" translate="yes" xml:space="preserve">
          <source>Comparison ufuncs accept &lt;code&gt;dtype=object&lt;/code&gt;, overriding the default &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">비교 ufuncs 는 기본 &lt;code&gt;bool&lt;/code&gt; 을 재정의하는 &lt;code&gt;dtype=object&lt;/code&gt; 허용</target>
        </trans-unit>
        <trans-unit id="60feb87fb86f2eac3632d24b989448287950576a" translate="yes" xml:space="preserve">
          <source>Comparison ufuncs will now error rather than return NotImplemented</source>
          <target state="translated">비교 ufuncs는 이제 NotImplemented를 반환하는 대신 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2f12ca1e5a55a63736464971fc76ee35d3a18342" translate="yes" xml:space="preserve">
          <source>Comparison value</source>
          <target state="translated">비교 가치</target>
        </trans-unit>
        <trans-unit id="5d57c5330d10b55140b0ca441a4e01cd9cdaa363" translate="yes" xml:space="preserve">
          <source>Compatibility Note</source>
          <target state="translated">호환성 참고</target>
        </trans-unit>
        <trans-unit id="7d648a6dff363974f754bb78876c2b10dadd8183" translate="yes" xml:space="preserve">
          <source>Compatibility notes</source>
          <target state="translated">호환성 참고</target>
        </trans-unit>
        <trans-unit id="0e6533ab3612d352e3a6bd4b64fa60d5ed1065f2" translate="yes" xml:space="preserve">
          <source>Compatibility to python &lt;code&gt;numbers&lt;/code&gt; module</source>
          <target state="translated">파이썬 &lt;code&gt;numbers&lt;/code&gt; 모듈과의 호환성</target>
        </trans-unit>
        <trans-unit id="7f4c99d898504a4d469f2c56fcd16f51caf889ab" translate="yes" xml:space="preserve">
          <source>Compatible with &lt;a href=&quot;https://docs.python.org/dev/library/random.html#random.random&quot;&gt;&lt;code&gt;random.random&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/random.html#random.random&quot;&gt; &lt;code&gt;random.random&lt;/code&gt; &lt;/a&gt; 과 호환</target>
        </trans-unit>
        <trans-unit id="01b44bc6c5eb611a5ad47d67043f3ab39a32c31b" translate="yes" xml:space="preserve">
          <source>Compatible with the C &lt;code&gt;intptr_t&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;intptr_t&lt;/code&gt; 와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="c6650e87a49448fb4a6012ba308708213b6b8ccb" translate="yes" xml:space="preserve">
          <source>Compatible with the C &lt;code&gt;uintptr_t&lt;/code&gt;.</source>
          <target state="translated">C &lt;code&gt;uintptr_t&lt;/code&gt; 와 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="4b140fca894bc166199628179929977e8e930e46" translate="yes" xml:space="preserve">
          <source>Compatible with the C99 &lt;code&gt;int8_t&lt;/code&gt;, &lt;code&gt;int16_t&lt;/code&gt;, &lt;code&gt;int32_t&lt;/code&gt;, and &lt;code&gt;int64_t&lt;/code&gt;, respectively.</source>
          <target state="translated">C99 &lt;code&gt;int8_t&lt;/code&gt; , &lt;code&gt;int16_t&lt;/code&gt; , &lt;code&gt;int32_t&lt;/code&gt; 및 &lt;code&gt;int64_t&lt;/code&gt; 와 각각 호환됩니다 .</target>
        </trans-unit>
        <trans-unit id="7e1100a75b694e6299dc8c7519337967f832f443" translate="yes" xml:space="preserve">
          <source>Compatible with the C99 &lt;code&gt;uint8_t&lt;/code&gt;, &lt;code&gt;uint16_t&lt;/code&gt;, &lt;code&gt;uint32_t&lt;/code&gt;, and &lt;code&gt;uint64_t&lt;/code&gt;, respectively.</source>
          <target state="translated">각각 C99 &lt;code&gt;uint8_t&lt;/code&gt; , &lt;code&gt;uint16_t&lt;/code&gt; , &lt;code&gt;uint32_t&lt;/code&gt; 및 &lt;code&gt;uint64_t&lt;/code&gt; 와 호환 됩니다.</target>
        </trans-unit>
        <trans-unit id="ea22f9a763556ea1f2361c2df834dbb06a8b8368" translate="yes" xml:space="preserve">
          <source>Compile one or more source files.</source>
          <target state="translated">하나 이상의 소스 파일을 컴파일하십시오.</target>
        </trans-unit>
        <trans-unit id="2be70e01f60942c9e24658741298f498509439ce" translate="yes" xml:space="preserve">
          <source>Compile with debugging information</source>
          <target state="translated">디버깅 정보로 컴파일</target>
        </trans-unit>
        <trans-unit id="b27fa290ca920bb1c99bebb756fd2de9f4610d26" translate="yes" xml:space="preserve">
          <source>Compile without arch-dependent optimization</source>
          <target state="translated">아치 의존적 최적화없이 컴파일</target>
        </trans-unit>
        <trans-unit id="5ecd4ab8f7ad7a6feb5b1c29b6881b6188694b84" translate="yes" xml:space="preserve">
          <source>Compile without optimization</source>
          <target state="translated">최적화없이 컴파일</target>
        </trans-unit>
        <trans-unit id="f9f8c316ab0c50a41a54a632e4f37af9a9c7bed4" translate="yes" xml:space="preserve">
          <source>Compiled testing modules renamed and made private</source>
          <target state="translated">컴파일 된 테스트 모듈의 이름이 변경되고 비공개로 설정 됨</target>
        </trans-unit>
        <trans-unit id="9674cbe94fc34b0813752dbf21ea3ff49c519ffa" translate="yes" xml:space="preserve">
          <source>Compiler directives</source>
          <target state="translated">컴파일러 지시문</target>
        </trans-unit>
        <trans-unit id="e1be83a7756a5bb6c9b11d838efbdc2b010f2edd" translate="yes" xml:space="preserve">
          <source>Compilers</source>
          <target state="translated">Compilers</target>
        </trans-unit>
        <trans-unit id="19e6a00c5d1d076b19873202250746217d5ee3ba" translate="yes" xml:space="preserve">
          <source>Compilers are auto-detected; building with a particular compiler can be done with &lt;code&gt;--fcompiler&lt;/code&gt;. E.g. to select gfortran:</source>
          <target state="translated">컴파일러는 자동 감지됩니다. &lt;code&gt;--fcompiler&lt;/code&gt; 를 사용하여 특정 컴파일러로 빌드 할 수 있습니다 . 예 : gfortran을 선택하려면 :</target>
        </trans-unit>
        <trans-unit id="647a61b7661823bee3e0fb318ccb983ea06af198" translate="yes" xml:space="preserve">
          <source>Complete example</source>
          <target state="translated">완전한 예</target>
        </trans-unit>
        <trans-unit id="ff834855dd2cb771e7308c2c45e567479f89e7e7" translate="yes" xml:space="preserve">
          <source>Complete path, including the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; destination directory.</source>
          <target state="translated">&lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 대상 디렉토리를 포함한 전체 경로</target>
        </trans-unit>
        <trans-unit id="df410ba7b1720b637f5c18968fb3a87767285ecc" translate="yes" xml:space="preserve">
          <source>Complex addition in Cython</source>
          <target state="translated">Cython의 복잡한 추가</target>
        </trans-unit>
        <trans-unit id="de68f54a7ada83b34c3c594c6d6dc315f2d1dff5" translate="yes" xml:space="preserve">
          <source>Complex dtypes are not supported, they will raise a TypeError.</source>
          <target state="translated">복잡한 dtype은 지원되지 않으며 TypeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="aa65be528af88fb5c8a75d1c112c51079bcd9e1b" translate="yes" xml:space="preserve">
          <source>Complex floating point</source>
          <target state="translated">복잡한 부동 소수점</target>
        </trans-unit>
        <trans-unit id="50b56f643c3c403eee6bc18311217c2110cfc3d1" translate="yes" xml:space="preserve">
          <source>Complex floating-point numbers:</source>
          <target state="translated">복잡한 부동 소수점 숫자 :</target>
        </trans-unit>
        <trans-unit id="e8cc2d53485b1cd057c225fc0f2c9637d61bd1f7" translate="yes" xml:space="preserve">
          <source>Complex floating-point types</source>
          <target state="translated">복잡한 부동 소수점 유형</target>
        </trans-unit>
        <trans-unit id="5b80d64d624d4f3ca65bbe7239e385812c1d03ee" translate="yes" xml:space="preserve">
          <source>Complex functions</source>
          <target state="translated">복잡한 기능</target>
        </trans-unit>
        <trans-unit id="0fa9ea03df83d22c3ed69e97864b69f2e7260411" translate="yes" xml:space="preserve">
          <source>Complex interpolation:</source>
          <target state="translated">복잡한 보간 :</target>
        </trans-unit>
        <trans-unit id="a65b5b7a1200ae7ef93272975b6c56910310c564" translate="yes" xml:space="preserve">
          <source>Complex is of a different type, so it up-casts the float in the &lt;code&gt;array_types&lt;/code&gt; argument:</source>
          <target state="translated">Complex는 다른 유형이므로 &lt;code&gt;array_types&lt;/code&gt; 인수 에서 float를 업 캐스트합니다 .</target>
        </trans-unit>
        <trans-unit id="28b304d77e09eac63c31735353e156b97c24f8e3" translate="yes" xml:space="preserve">
          <source>Complex number type composed of two double-precision floating-point numbers, compatible with Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; 와 호환되는 두 개의 배정 밀도 부동 소수점 숫자로 구성된 복소수 유형 .</target>
        </trans-unit>
        <trans-unit id="686aa43f1407c3b430efb4962a85f954d7ae8c01" translate="yes" xml:space="preserve">
          <source>Complex number type composed of two extended-precision floating-point numbers.</source>
          <target state="translated">두 개의 확장 정밀도 부동 소수점 숫자로 구성된 복소수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="baed674c46a3933a0863623cdfe74299cc3e430f" translate="yes" xml:space="preserve">
          <source>Complex number type composed of two single-precision floating-point numbers.</source>
          <target state="translated">두 개의 단 정밀도 부동 소수점 숫자로 구성된 복소수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="69f87237d33809159f47d1d133e1d70464aec740" translate="yes" xml:space="preserve">
          <source>Complex number, represented by two 32-bit floats (real and imaginary components)</source>
          <target state="translated">두 개의 32 비트 부동 소수점으로 표시되는 복소수 (실수 및 허수 구성 요소)</target>
        </trans-unit>
        <trans-unit id="8f5121e6148826628b346efc91040e8e1bf009fc" translate="yes" xml:space="preserve">
          <source>Complex number, represented by two double-precision floats (real and imaginary components).</source>
          <target state="translated">두 개의 배정 밀도 부동 소수점 (실수 및 허수 성분)으로 표현되는 복소수.</target>
        </trans-unit>
        <trans-unit id="95e775f958ed3272cf2a9c2fd5e4a1ac4fc419e7" translate="yes" xml:space="preserve">
          <source>Complex number, represented by two extended-precision floats (real and imaginary components).</source>
          <target state="translated">두 개의 확장 정밀도 부동 소수점 (실수 및 허수 구성 요소)으로 표시되는 복소수.</target>
        </trans-unit>
        <trans-unit id="737289b1db62088f4dcb89c7c7dcaab50b2e300b" translate="yes" xml:space="preserve">
          <source>Complex number, represented by two single-precision floats (real and imaginary components)</source>
          <target state="translated">두 개의 단 정밀도 부동 소수점으로 표현되는 복소수 (실수 및 허수 성분)</target>
        </trans-unit>
        <trans-unit id="44fc04a3b7819c72bdc8be8966689f3ecd87dbfd" translate="yes" xml:space="preserve">
          <source>Complex-conjugate all elements.</source>
          <target state="translated">모든 요소를 ​​복합적으로 활용합니다.</target>
        </trans-unit>
        <trans-unit id="3ff5cadccad2941be3aad490dcbf596e9e2f1f26" translate="yes" xml:space="preserve">
          <source>Complex-conjugating dot product.</source>
          <target state="translated">복잡한 복합 도트 제품.</target>
        </trans-unit>
        <trans-unit id="f14b349bf9b6f0598bc456bea6a626f511dd720b" translate="yes" xml:space="preserve">
          <source>Complex-valued matrix with real e-values (but complex-valued e-vectors); note that &lt;code&gt;a.conj().T == a&lt;/code&gt;, i.e., &lt;code&gt;a&lt;/code&gt; is Hermitian.</source>
          <target state="translated">실제 e- 값을 갖는 복소수 행렬 (그러나 복소수 e- 벡터); 참고 &lt;code&gt;a.conj().T == a&lt;/code&gt; , 즉, &lt;code&gt;a&lt;/code&gt; 에르 미트이다.</target>
        </trans-unit>
        <trans-unit id="4745229c055fca9c55de4f5e19158b64c4e46c7f" translate="yes" xml:space="preserve">
          <source>Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]</source>
          <target state="translated">콤플렉스 : [R + Rj, R + nanj, nan + Rj, nan + nanj]</target>
        </trans-unit>
        <trans-unit id="2f27e220078b637c5e347c7ab455867f7857e36c" translate="yes" xml:space="preserve">
          <source>ComplexWarning</source>
          <target state="translated">ComplexWarning</target>
        </trans-unit>
        <trans-unit id="07214e21bcf968861459229df35bdc3eb2301560" translate="yes" xml:space="preserve">
          <source>Components of the first vector(s).</source>
          <target state="translated">첫 번째 벡터의 구성 요소.</target>
        </trans-unit>
        <trans-unit id="034a68a3b46b5f19a8396a79ba6059edc518f621" translate="yes" xml:space="preserve">
          <source>Components of the second vector(s).</source>
          <target state="translated">두 번째 벡터의 구성 요소.</target>
        </trans-unit>
        <trans-unit id="45f45d1eb6794f5e653fdc744d97f27b67ca97c3" translate="yes" xml:space="preserve">
          <source>Compute &lt;code&gt;y = x1 * 2**x2&lt;/code&gt;, the inverse of &lt;a href=&quot;#numpy.frexp&quot;&gt;&lt;code&gt;frexp&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">계산 &lt;code&gt;y = x1 * 2**x2&lt;/code&gt; 의 역 &lt;a href=&quot;#numpy.frexp&quot;&gt; &lt;code&gt;frexp&lt;/code&gt; 와&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3d882304ea9d87add3f90e5be6baef45c39f37eb" translate="yes" xml:space="preserve">
          <source>Compute RQ decomposition of a matrix.</source>
          <target state="translated">행렬의 RQ 분해를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0c64182221e47c35867a7af81c848c36fa6d8bc1" translate="yes" xml:space="preserve">
          <source>Compute a matrix transpose, or reorder any number of axes:</source>
          <target state="translated">행렬 전치를 계산하거나 축의 수를 재정렬합니다.</target>
        </trans-unit>
        <trans-unit id="13e5ab403f3a3a2b71e3a1b4880046ec10502553" translate="yes" xml:space="preserve">
          <source>Compute a product-sum over the last dimension of &lt;em&gt;obj1&lt;/em&gt; and the second-to-last dimension of &lt;em&gt;obj2&lt;/em&gt;. For 2-d arrays this is a matrix-product. Neither array is conjugated.</source>
          <target state="translated">&lt;em&gt;obj1의&lt;/em&gt; 마지막 차원과 &lt;em&gt;obj2&lt;/em&gt; 의 두 번째 에서 마지막 차원에 대한 곱을 계산합니다 . 2 차원 배열의 경우 이것은 행렬 곱입니다. 배열이 켤레 없습니다.</target>
        </trans-unit>
        <trans-unit id="056b92ccdbc0e24b6f67de04cffc75083bf356ab" translate="yes" xml:space="preserve">
          <source>Compute a product-sum over the last dimensions of &lt;em&gt;obj1&lt;/em&gt; and &lt;em&gt;obj2&lt;/em&gt;. Neither array is conjugated.</source>
          <target state="translated">&lt;em&gt;obj1&lt;/em&gt; 및 &lt;em&gt;obj2&lt;/em&gt; 의 마지막 차원에 대해 곱셈 합계를 계산합니다 . 배열이 공액되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d7a1e013a739673e66d447edae1fe867b62d357" translate="yes" xml:space="preserve">
          <source>Compute an array where the subarrays contain index values 0, 1, &amp;hellip; varying only along the corresponding axis.</source>
          <target state="translated">서브 어레이에 인덱스 값 0, 1,&amp;hellip;이 해당 축을 따라서 만 변하는 배열을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="947fc265208178db651870062fcd800d2541aa5f" translate="yes" xml:space="preserve">
          <source>Compute bit-wise inversion, or bit-wise NOT, element-wise.</source>
          <target state="translated">비트 단위 반전 또는 비트 단위 NOT을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4fa591d9d9af402206493fb5fda8248cb6f1c024" translate="yes" xml:space="preserve">
          <source>Compute hyperbolic tangent element-wise.</source>
          <target state="translated">쌍곡선 탄젠트를 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a87a1fe24ae7fbea279764c44fdccdccf954c207" translate="yes" xml:space="preserve">
          <source>Compute polynomial values.</source>
          <target state="translated">다항식 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f40295322c0f8e7f8c3dbdd16628efca9b1a5086" translate="yes" xml:space="preserve">
          <source>Compute singular values of a matrix.</source>
          <target state="translated">행렬의 특이 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="068ac2c1a4127e2fed43429a48f36264cc85457c" translate="yes" xml:space="preserve">
          <source>Compute tangent element-wise.</source>
          <target state="translated">접선을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d300b4bcd09d963652013deebe8168c3c89562c2" translate="yes" xml:space="preserve">
          <source>Compute tensor dot product along specified axes.</source>
          <target state="translated">지정된 축을 따라 텐서 도트 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fa371bab50ec7f5949bcd135ca6f29870a08c615" translate="yes" xml:space="preserve">
          <source>Compute the &amp;lsquo;inverse&amp;rsquo; of an N-dimensional array.</source>
          <target state="translated">N 차원 배열의 '역'을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7b6b08dbde076bf3b0ddbc251649cd1e930237a9" translate="yes" xml:space="preserve">
          <source>Compute the (Moore-Penrose) pseudo-inverse of a Hermitian matrix.</source>
          <target state="translated">에르 미트 행렬의 (무어-펜로즈) 의사 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fc5bbebd14e559d5af2472fcb7cd8cae4c38dfea" translate="yes" xml:space="preserve">
          <source>Compute the (Moore-Penrose) pseudo-inverse of a matrix.</source>
          <target state="translated">행렬의 (무어-펜로즈) 의사 역수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7a0d3b8cffb38e55193b71b10895c89358380d6f" translate="yes" xml:space="preserve">
          <source>Compute the (multiplicative) inverse of a matrix.</source>
          <target state="translated">행렬의 (곱하기) 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ce317ec0f3a7246ebde3c56c949a94474c644f2c" translate="yes" xml:space="preserve">
          <source>Compute the 1-d correlation of the 1-d arrays &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; . The correlation is computed at each output point by multiplying &lt;em&gt;op1&lt;/em&gt; by a shifted version of &lt;em&gt;op2&lt;/em&gt; and summing the result. As a result of the shift, needed values outside of the defined range of &lt;em&gt;op1&lt;/em&gt; and &lt;em&gt;op2&lt;/em&gt; are interpreted as zero. The mode determines how many shifts to return: 0 - return only shifts that did not need to assume zero- values; 1 - return an object that is the same size as &lt;em&gt;op1&lt;/em&gt;, 2 - return all possible shifts (any overlap at all is accepted).</source>
          <target state="translated">1 차원 배열 &lt;em&gt;op1&lt;/em&gt; 과 &lt;em&gt;op2&lt;/em&gt; 의 1 차원 상관 관계를 계산합니다 . &lt;em&gt;op1&lt;/em&gt; 에 시프트 된 버전의 &lt;em&gt;op2&lt;/em&gt; 를 곱하고 결과를 합산하여 각 출력 지점에서 상관 관계가 계산됩니다 . 시프트 결과, 정의 된 &lt;em&gt;op1&lt;/em&gt; 및 &lt;em&gt;op2&lt;/em&gt; 범위를 벗어난 필요한 값 은 0으로 해석됩니다. 모드는 리턴 할 시프트 수를 결정합니다. 0-0 값을 가정 할 필요가없는 시프트 만 리턴합니다. 1- &lt;em&gt;op1&lt;/em&gt; 과 동일한 크기의 객체를 반환합니다 . 2-가능한 모든 시프트를 반환합니다 (모든 오버랩이 허용됨).</target>
        </trans-unit>
        <trans-unit id="c0d44872f577915a6980faf8dd21743d44adf9e2" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional FFT of a real array.</source>
          <target state="translated">실수 배열의 2 차원 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d178e7eb58c146939d28cee1561c739e0e5a7a6e" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional discrete Fourier Transform</source>
          <target state="translated">2 차원 이산 푸리에 변환 계산</target>
        </trans-unit>
        <trans-unit id="7b20a611a9e505422a6745f17858e51dc3b43736" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional discrete Fourier Transform.</source>
          <target state="translated">2 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="67a3a6e456306d80e1a85f7bd3abf35885e3417f" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional inverse FFT of a real array.</source>
          <target state="translated">실수 배열의 2 차원 역 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5dab8bf12f8acb88adf197e9679d392f9686e8f0" translate="yes" xml:space="preserve">
          <source>Compute the 2-dimensional inverse discrete Fourier Transform.</source>
          <target state="translated">2 차원 역 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e520eedb99a35ab7b8e9d96c9ee884bd6396de95" translate="yes" xml:space="preserve">
          <source>Compute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.</source>
          <target state="translated">에르 미트 (Hermitian) 대칭, 즉 실제 스펙트럼을 갖는 신호의 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8d0c346e5e8eee0d8b840c557de8c1fb49e608f2" translate="yes" xml:space="preserve">
          <source>Compute the Heaviside step function.</source>
          <target state="translated">헤비 사이드 단계 함수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="0af5dc6ec4bce95c7deeb2e22d43be085363a3c4" translate="yes" xml:space="preserve">
          <source>Compute the N-dimensional discrete Fourier Transform for real input.</source>
          <target state="translated">실제 입력을 위해 N 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="618a9fedeaaa9d126c314769627bca84416583fd" translate="yes" xml:space="preserve">
          <source>Compute the N-dimensional discrete Fourier Transform.</source>
          <target state="translated">N 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e7cb154cbbc3ce37f25f7537fe58a126b7946394" translate="yes" xml:space="preserve">
          <source>Compute the N-dimensional inverse discrete Fourier Transform.</source>
          <target state="translated">N 차원 역 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fdada9bbbb0e0feab597366ef4af60a51ac07565" translate="yes" xml:space="preserve">
          <source>Compute the absolute values element-wise.</source>
          <target state="translated">절대 값을 요소 단위로 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="854c7a30aceed6c65bd1930d3f73b4435d8fefe0" translate="yes" xml:space="preserve">
          <source>Compute the anomalies (deviations from the arithmetic mean) along the given axis.</source>
          <target state="translated">주어진 축을 따라 비정상 (산술 평균에서 벗어난)을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="032bf5a750caf3fcc37d976c4abec0978e892339" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic mean along the specified axis, ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 산술 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c27697f73833b9f50c1ae272faa6ca6a07b48429" translate="yes" xml:space="preserve">
          <source>Compute the arithmetic mean along the specified axis.</source>
          <target state="translated">지정된 축을 따라 산술 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d2a56a9fc18ac2ca14dd4e52739d766778e94a9f" translate="yes" xml:space="preserve">
          <source>Compute the bi-dimensional histogram of two data samples.</source>
          <target state="translated">두 데이터 샘플의 이차원 히스토그램을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8d0e71a5459a34a1c578cae96fc1cfe3bd566fe6" translate="yes" xml:space="preserve">
          <source>Compute the bit-wise AND of two arrays element-wise.</source>
          <target state="translated">두 배열의 비트 단위 AND를 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e7eb6c1c60d6349cc90d5c8c4320d954c000c524" translate="yes" xml:space="preserve">
          <source>Compute the bit-wise OR of two arrays element-wise.</source>
          <target state="translated">두 배열의 비트 단위 OR을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="55b35d5464c0530c89b3ec03e495b9078bf4cf47" translate="yes" xml:space="preserve">
          <source>Compute the bit-wise XOR of two arrays element-wise.</source>
          <target state="translated">두 배열의 비트 단위 XOR을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f5acd6ba924e2efb344c13dbed92e0c329da8c41" translate="yes" xml:space="preserve">
          <source>Compute the condition number of a matrix.</source>
          <target state="translated">행렬의 조건 번호를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b1c67fc04779c3f2a70b86099aedfddb41f66c14" translate="yes" xml:space="preserve">
          <source>Compute the determinant of an array.</source>
          <target state="translated">배열의 결정자를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="b702821ff84d14c559452b05bb97c2de7fb25e9d" translate="yes" xml:space="preserve">
          <source>Compute the differences between consecutive elements of an array.</source>
          <target state="translated">배열의 연속 요소 간 차이를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="951e81c96daf183677546cd31bf58f658274b345" translate="yes" xml:space="preserve">
          <source>Compute the dot product of two or more arrays in a single function call, while automatically selecting the fastest evaluation order.</source>
          <target state="translated">단일 함수 호출에서 둘 이상의 배열의 내적을 계산하면서 가장 빠른 평가 순서를 자동으로 선택합니다.</target>
        </trans-unit>
        <trans-unit id="6d2ef25b4e32887cf6b0d4b62f770b736c0bf3b1" translate="yes" xml:space="preserve">
          <source>Compute the eigenvalues and right eigenvectors of a square array.</source>
          <target state="translated">정사각형 배열의 고유 값과 오른쪽 고유 벡터를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="7972ade8ee96398f7c3dca6dc7f1e5fbe1dee9f0" translate="yes" xml:space="preserve">
          <source>Compute the eigenvalues of a complex Hermitian or real symmetric matrix.</source>
          <target state="translated">복잡한 Hermitian 또는 실제 대칭 행렬의 고유 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="df2018ad5cc925c4bd2d8d45424431e34663700a" translate="yes" xml:space="preserve">
          <source>Compute the eigenvalues of a general matrix.</source>
          <target state="translated">일반 행렬의 고유 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e2e2b6e6567897f80498047d4b073da0348b1fe0" translate="yes" xml:space="preserve">
          <source>Compute the future value.</source>
          <target state="translated">미래 가치를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ca53316c69a9d7dff355b503668c1872713b22a1" translate="yes" xml:space="preserve">
          <source>Compute the histogram of a set of data.</source>
          <target state="translated">데이터 집합의 히스토그램을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="089040bb2e30a76919dc623b5c63558c7963e5b8" translate="yes" xml:space="preserve">
          <source>Compute the interest portion of a payment.</source>
          <target state="translated">지불의이자 부분을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="deed0637d0888d671ccf558d5297ba636b52a784" translate="yes" xml:space="preserve">
          <source>Compute the inverse FFT of a signal that has Hermitian symmetry.</source>
          <target state="translated">Hermitian 대칭 신호의 역 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fff1d5868c63bf60c8e717cf4c50124e7b9bc125" translate="yes" xml:space="preserve">
          <source>Compute the inverse cosine of x.</source>
          <target state="translated">x의 역 코사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="680c3b04c05aca283c4622eb58afd6457ddd9b27" translate="yes" xml:space="preserve">
          <source>Compute the inverse hyperbolic tangent of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 역 쌍곡 탄젠트를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="5919808f0861ce5e5c6edd192558abd6cdeed04d" translate="yes" xml:space="preserve">
          <source>Compute the inverse of the N-dimensional FFT of real input.</source>
          <target state="translated">실제 입력의 N 차원 FFT의 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ce30e6918f57933fede9b196ab6208b5d99d43fe" translate="yes" xml:space="preserve">
          <source>Compute the inverse of the n-point DFT for real input.</source>
          <target state="translated">실제 입력에 대한 n- 포인트 DFT의 역을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="90f6f09a65183d68c32ce7f17ffb1fd28e445371" translate="yes" xml:space="preserve">
          <source>Compute the inverse sine of x.</source>
          <target state="translated">x의 역 사인을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="98f5799cb69bcbe06a99aa369a484a74648957df" translate="yes" xml:space="preserve">
          <source>Compute the logarithm base 10 of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑이 10 인 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="042628d2e4c91a444c9460090c4642143dd92c73" translate="yes" xml:space="preserve">
          <source>Compute the logarithm base 2 of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 밑이 2 인 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="146d4119420125716eb9e5162a664c6e708ec171" translate="yes" xml:space="preserve">
          <source>Compute the mean of the array.</source>
          <target state="translated">배열의 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="75b405fa34c2293f176a80e9455e345d4ea00995" translate="yes" xml:space="preserve">
          <source>Compute the median along the specified axis, while ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5f2fe82c20077c9d0997165620b7b7093677b74f" translate="yes" xml:space="preserve">
          <source>Compute the median along the specified axis.</source>
          <target state="translated">지정된 축을 따라 중앙값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f49f4e3eff991416a03a71efdb176b02ad137665" translate="yes" xml:space="preserve">
          <source>Compute the multidimensional histogram of some data.</source>
          <target state="translated">일부 데이터의 다차원 히스토그램을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8c10d725e0065cd6113bd749baa0deda925c5d4b" translate="yes" xml:space="preserve">
          <source>Compute the natural logarithm of &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 자연 로그를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="9f985f7023c691b407ddd9c38fd8d56c7f36cce8" translate="yes" xml:space="preserve">
          <source>Compute the number of periodic payments.</source>
          <target state="translated">정기적 인 지불 횟수를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="733b57cc1709b7cf6a9c1de104182ed36cee85e6" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional FFT for real input.</source>
          <target state="translated">실제 입력을위한 1 차원 FFT를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8f2e370b04711ab583709ac47d198ba4e79cbadd" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional discrete Fourier Transform for real input.</source>
          <target state="translated">실제 입력을 위해 1 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="e5e7857b86fdf420c15fe37d2645a15e124e2351" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional discrete Fourier Transform.</source>
          <target state="translated">1 차원 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="76b7badeb6481641dd13f6eaf394bb9c18c8cab1" translate="yes" xml:space="preserve">
          <source>Compute the one-dimensional inverse discrete Fourier Transform.</source>
          <target state="translated">1 차원 역 이산 푸리에 변환을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="9381b1752cc6a461f7e91077cdb6db7fe5a48f4d" translate="yes" xml:space="preserve">
          <source>Compute the outer product of two vectors.</source>
          <target state="translated">두 벡터의 외부 곱을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="cbc3ab7d3f6c89e7688a1bd6e4393422aa4c3b90" translate="yes" xml:space="preserve">
          <source>Compute the payment against loan principal plus interest.</source>
          <target state="translated">대출 원금과이자에 대한 지불을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="46ed86386ad333de82eb1b7762aabfed9c76dfaf" translate="yes" xml:space="preserve">
          <source>Compute the payment against loan principal.</source>
          <target state="translated">대출 원금에 대한 지불을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="5b94637940b6e09f6a444aac566b5cffb0ef7cc5" translate="yes" xml:space="preserve">
          <source>Compute the present value.</source>
          <target state="translated">현재 가치를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="ed2028550f82331ecb48f833083f7734128a7f0c" translate="yes" xml:space="preserve">
          <source>Compute the q-th percentile of the data along the specified axis.</source>
          <target state="translated">지정된 축을 따라 데이터의 q 번째 백분위 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c6ed1091760ac01a76bb052045201b29d9012406" translate="yes" xml:space="preserve">
          <source>Compute the q-th quantile of the data along the specified axis.</source>
          <target state="translated">지정된 축을 따라 데이터의 q 번째 Quantile을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a016c465eb4d3dc5939f0bdcc8907e529c903c76" translate="yes" xml:space="preserve">
          <source>Compute the qr factorization of a matrix.</source>
          <target state="translated">행렬의 qr 인수 분해를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="83309b8de9d230170ad49f73fb6a722aacbf72a8" translate="yes" xml:space="preserve">
          <source>Compute the qth percentile of the data along the specified axis, while ignoring nan values.</source>
          <target state="translated">nan 값을 무시하고 지정된 축을 따라 데이터의 q 번째 백분위 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4fe3d325fd56452aa7f5ecbc4f8b7dad9aae46d0" translate="yes" xml:space="preserve">
          <source>Compute the qth quantile of the data along the specified axis, while ignoring nan values.</source>
          <target state="translated">nan 값을 무시하고 지정된 축을 따라 데이터의 q 분위수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="de4cace71ddfe52eb9bc3f9b565cdbec00b48884" translate="yes" xml:space="preserve">
          <source>Compute the qth quantile of the data along the specified axis, while ignoring nan values. Returns the qth quantile(s) of the array elements.</source>
          <target state="translated">nan 값을 무시하고 지정된 축을 따라 데이터의 q 분위수를 계산합니다. 배열 요소의 q 번째 Quantile을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="5ed535359eae3077289b82f9fc67b3ffd54128d9" translate="yes" xml:space="preserve">
          <source>Compute the rate of interest per period.</source>
          <target state="translated">기간 당 이율을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="4a5f1b7538c28d59530b835e6055fa30abb75407" translate="yes" xml:space="preserve">
          <source>Compute the roots for the series. Note that the accuracy of the roots decrease the further outside the domain they lie.</source>
          <target state="translated">시리즈의 근을 계산합니다. 뿌리의 정확성은 그들이 놓인 도메인 바깥으로 멀어 질수록 감소합니다.</target>
        </trans-unit>
        <trans-unit id="5c8b9d5cf9d0408e56b56c50cb4c4ea45a908e79" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Chebyshev series.</source>
          <target state="translated">체비 쇼프 시리즈의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="2d641d9e2bcefe116338c34e7e9f40f95aa74cff" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Hermite series.</source>
          <target state="translated">은자 시리즈의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ae57b133f1570844585065d9e9104c93e1cbeadb" translate="yes" xml:space="preserve">
          <source>Compute the roots of a HermiteE series.</source>
          <target state="translated">HermiteE 시리즈의 근을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="43f37ce85ee2223f1cd749d722bfe6cde31f8d3f" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Laguerre series.</source>
          <target state="translated">Laguerre 계열의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d296ea609a31255dd2dbb79a4294986988e4db61" translate="yes" xml:space="preserve">
          <source>Compute the roots of a Legendre series.</source>
          <target state="translated">Legendre 시리즈의 근을 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="19abb563bbb5b6ab6c8e5baeecc0592cab5fb3b0" translate="yes" xml:space="preserve">
          <source>Compute the roots of a polynomial.</source>
          <target state="translated">다항식의 근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="5d39f1a875851670d9065e685e3c7e7e93824abb" translate="yes" xml:space="preserve">
          <source>Compute the sign and (natural) logarithm of the determinant of an array.</source>
          <target state="translated">배열 결정 요인의 부호와 (자연) 로그를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="62e207e799c660b05ba05cd6c6b1f3eb0ceddf6d" translate="yes" xml:space="preserve">
          <source>Compute the square root of x.</source>
          <target state="translated">x의 제곱근을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f10d7331dd9b2505d01acc79b5a5c28111413dab" translate="yes" xml:space="preserve">
          <source>Compute the standard deviation along the specified axis, while ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 표준 편차를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="66e310f2ac7182b1b997c8f29f43f4edc06f8e2a" translate="yes" xml:space="preserve">
          <source>Compute the standard deviation along the specified axis.</source>
          <target state="translated">지정된 축을 따라 표준 편차를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="88f78cc6a5ad581dc5a8fb410e447c660bd9fa8f" translate="yes" xml:space="preserve">
          <source>Compute the truth value of NOT x element-wise.</source>
          <target state="translated">NOT x의 진리 값을 요소 단위로 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="bea68d81fc2eb04da18ba084a78837621cebec88" translate="yes" xml:space="preserve">
          <source>Compute the truth value of x1 AND x2 element-wise.</source>
          <target state="translated">x1 및 x2의 진리 값을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="a79688781ca1781bce152cb44a9b15f66b72bfb1" translate="yes" xml:space="preserve">
          <source>Compute the truth value of x1 OR x2 element-wise.</source>
          <target state="translated">x1 또는 x2의 진리 값을 요소 단위로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="96e23b531f96b54840021483947c41a098b2ed1b" translate="yes" xml:space="preserve">
          <source>Compute the truth value of x1 XOR x2, element-wise.</source>
          <target state="translated">요소 별 x1 XOR x2의 진리 값을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="6a8a6092543ea859a93955c068e3715cc92a71ca" translate="yes" xml:space="preserve">
          <source>Compute the variance along the specified axis, while ignoring NaNs.</source>
          <target state="translated">NaN을 무시하고 지정된 축을 따라 분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ab67fb4895d59fdba2f3312d3f97f40d39b32dc1" translate="yes" xml:space="preserve">
          <source>Compute the variance along the specified axis.</source>
          <target state="translated">지정된 축을 따라 분산을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="8ad00c6a1c7489e8566fc76ef273931215436611" translate="yes" xml:space="preserve">
          <source>Compute the weighted average along the specified axis.</source>
          <target state="translated">지정된 축을 따라 가중 평균을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="79af5daa38dbf74799da93dffa5ef6f8fba6dccf" translate="yes" xml:space="preserve">
          <source>Compute two different sets of indices to access 4x4 arrays, one for the lower triangular part starting at the main diagonal, and one starting two diagonals further right:</source>
          <target state="translated">4 개의 배열에 액세스하기 위해 두 개의 다른 인덱스 세트를 계산합니다. 하나는 주 대각선에서 시작하는 아래쪽 삼각형 부분 용이고 다른 하나는 오른쪽에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="471eda8864ca36b1868976a6ed358ad1c7812441" translate="yes" xml:space="preserve">
          <source>Compute two different sets of indices to access 4x4 arrays, one for the upper triangular part starting at the main diagonal, and one starting two diagonals further right:</source>
          <target state="translated">4 개의 배열에 액세스하기 위해 두 개의 다른 인덱스 세트를 계산합니다. 하나는 주 대각선에서 시작하는 위쪽 삼각형 부분에 대한 것이고 다른 하나는 오른쪽에서 시작합니다.</target>
        </trans-unit>
        <trans-unit id="197392cccae8af7bf76b914db915fad3a803ed5b" translate="yes" xml:space="preserve">
          <source>Compute z as follows:</source>
          <target state="translated">다음과 같이 z를 계산하십시오.</target>
        </trans-unit>
        <trans-unit id="e5847ac2ac3c001c3a2cac8771b53202e9193405" translate="yes" xml:space="preserve">
          <source>Computes a least-squares fit from the matrix.</source>
          <target state="translated">행렬에서 최소 자승을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="d8ae02c2a1f37ef602fe9635ca3deb7ae7eff320" translate="yes" xml:space="preserve">
          <source>Computes a least-squares fit.</source>
          <target state="translated">최소 제곱 적합을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="fca5c893d0dd0095c803730ae984c8a5d1f22fbb" translate="yes" xml:space="preserve">
          <source>Computes spline fits.</source>
          <target state="translated">스플라인 맞춤을 계산합니다.</target>
        </trans-unit>
        <trans-unit id="39bd0877aee14479f84fa968669682d5f4bb55d6" translate="yes" xml:space="preserve">
          <source>Computes the &amp;ldquo;exact&amp;rdquo; solution, &lt;code&gt;x&lt;/code&gt;, of the well-determined, i.e., full rank, linear matrix equation &lt;code&gt;ax = b&lt;/code&gt;.</source>
          <target state="translated">잘 결정된, 즉 전체 순위 선형 행렬 방정식 &lt;code&gt;ax = b&lt;/code&gt; 의 &quot;정확한&quot;해 &lt;code&gt;x&lt;/code&gt; 를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="650917c230f0e3e59e23869cdea9804dfbb8e6f0" translate="yes" xml:space="preserve">
          <source>Computes the Kronecker product, a composite array made of blocks of the second array scaled by the first.</source>
          <target state="translated">두 번째 배열의 블록으로 구성된 복합 배열 인 Kronecker 곱을 첫 번째 축척으로 계산합니다.</target>
        </trans-unit>
        <trans-unit id="10cbc0814b0dd9715e5abe01e8dbaaa33fe8ad59" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise AND of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">입력 배열에있는 정수의 기본 이진 표현을 비트 단위 AND로 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;&amp;amp;&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="60c3fbdfba7bb7378090a32d8c51b3e9fca09817" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise NOT of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;~&lt;/code&gt;.</source>
          <target state="translated">입력 배열에서 정수의 기본 이진 표현의 비트 단위 NOT을 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;~&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="42722e323632d4f5d01bc926af28a1c22d5e0f95" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise OR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;|&lt;/code&gt;.</source>
          <target state="translated">입력 배열에서 정수의 기본 이진 표현에 대한 비트 단위 OR을 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;|&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67adfae8fffe1baa14f71537d861b7b2e85f7e48" translate="yes" xml:space="preserve">
          <source>Computes the bit-wise XOR of the underlying binary representation of the integers in the input arrays. This ufunc implements the C/Python operator &lt;code&gt;^&lt;/code&gt;.</source>
          <target state="translated">입력 배열에서 정수의 기본 이진 표현에 대한 비트 단위 XOR을 계산합니다. 이 ufunc는 C / Python 연산자 &lt;code&gt;^&lt;/code&gt; 를 구현합니다 .</target>
        </trans-unit>
        <trans-unit id="5b7985e5a610aecd1e2f0354b8e5d60012fb3122" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;a href=&quot;generated/numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 의 역을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a37e4878d0f3245e628152dd746e751b303f1077" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;a href=&quot;generated/numpy.fft.rfft2#numpy.fft.rfft2&quot;&gt;&lt;code&gt;rfft2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.rfft2#numpy.fft.rfft2&quot;&gt; &lt;code&gt;rfft2&lt;/code&gt; &lt;/a&gt; 의 역을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7a00d05c1fdb22156e674011ea28745b11bd5ccd" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;a href=&quot;generated/numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 의 역을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="cfd2909fcc5a07da9706315625adcbe780d00881" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt;&lt;code&gt;rfft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.rfft#numpy.fft.rfft&quot;&gt; &lt;code&gt;rfft&lt;/code&gt; &lt;/a&gt; 의 역을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="e95b7d0e0ca98d83c2c5fe3b97b956b5fa0c6134" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;a href=&quot;numpy.fft.rfft2#numpy.fft.rfft2&quot;&gt;&lt;code&gt;rfft2&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.rfft2#numpy.fft.rfft2&quot;&gt; &lt;code&gt;rfft2&lt;/code&gt; &lt;/a&gt; 의 역을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="d434e9babb5fb03d4aea7421e2772bfee48fd9b6" translate="yes" xml:space="preserve">
          <source>Computes the inverse of &lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt;&lt;code&gt;rfftn&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.fft.rfftn#numpy.fft.rfftn&quot;&gt; &lt;code&gt;rfftn&lt;/code&gt; &lt;/a&gt; 의 역을 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="7810254747fb57737310252a83ed1ecfa7ac7de1" translate="yes" xml:space="preserve">
          <source>Computes the remainder complementary to the &lt;a href=&quot;numpy.floor_divide#numpy.floor_divide&quot;&gt;&lt;code&gt;floor_divide&lt;/code&gt;&lt;/a&gt; function. It is equivalent to the Python modulus operator``x1 % x2`` and has the same sign as the divisor &lt;code&gt;x2&lt;/code&gt;. The MATLAB function equivalent to &lt;code&gt;np.remainder&lt;/code&gt; is &lt;code&gt;mod&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.floor_divide#numpy.floor_divide&quot;&gt; &lt;code&gt;floor_divide&lt;/code&gt; &lt;/a&gt; 함수를 보완하는 나머지를 계산합니다 . 파이썬 모듈러스 연산자``x1 % x2 ''와 동일하며 제수 &lt;code&gt;x2&lt;/code&gt; 와 같은 부호를 갖습니다 . &lt;code&gt;np.remainder&lt;/code&gt; 와 동등한 MATLAB 함수 는 &lt;code&gt;mod&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="531dbc47f0c42b16e91bc06f7934ffc0eee90d21" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Chebyshev quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">가우스 체비 쇼프 구적법에 대한 표본 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="d0825c93bd67fcabe34143f70ae3cf80cb8738d0" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Hermite quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-Hermite quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="9e720112e13fbc925fc36348970ddc09e09d43c8" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-HermiteE quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-HermiteE quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="01551c6580e6c7cd7da039752c76647a860146e9" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Laguerre quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-Laguerre 구적법에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="a1676ee2351ddea298864c94b5761c72628c1745" translate="yes" xml:space="preserve">
          <source>Computes the sample points and weights for Gauss-Legendre quadrature. These sample points and weights will correctly integrate polynomials of degree</source>
          <target state="translated">Gauss-Legendre quadrature에 대한 샘플 점과 가중치를 계산합니다. 이 샘플 포인트 및 가중치는 다항식 차수를 올바르게 통합합니다.</target>
        </trans-unit>
        <trans-unit id="16b7ced6d1fb17233cfcad9fc6b8ccfb3b6fa95d" translate="yes" xml:space="preserve">
          <source>Computes the vector x that approximatively solves the equation &lt;code&gt;a @ x = b&lt;/code&gt;. The equation may be under-, well-, or over-determined (i.e., the number of linearly independent rows of &lt;code&gt;a&lt;/code&gt; can be less than, equal to, or greater than its number of linearly independent columns). If &lt;code&gt;a&lt;/code&gt; is square and of full rank, then &lt;code&gt;x&lt;/code&gt; (but for round-off error) is the &amp;ldquo;exact&amp;rdquo; solution of the equation. Else, &lt;code&gt;x&lt;/code&gt; minimizes the Euclidean 2-norm</source>
          <target state="translated">방정식 &lt;code&gt;a @ x = b&lt;/code&gt; 를 근사 적으로 푸는 벡터 x를 계산합니다 . 방정식은 과소, 잘 또는 과다 결정될 수 있습니다 (즉, &lt;code&gt;a&lt;/code&gt; 의 선형 독립 행의 수는 선형 독립 열의 수보다 작거나 같거나 클 수 있습니다). 경우 &lt;code&gt;a&lt;/code&gt; , 광장과 전체 순위입니다 후 &lt;code&gt;x&lt;/code&gt; (그러나 반올림 오류에 대한) 방정식의 &quot;정확한&quot;솔루션입니다. 그렇지 않으면 &lt;code&gt;x&lt;/code&gt; 는 유클리드 2- 노름을 최소화합니다.</target>
        </trans-unit>
        <trans-unit id="54ad29fb2a5fef5a2e2b0f26f16821ff1f58a836" translate="yes" xml:space="preserve">
          <source>Computing determinants for a stack of matrices:</source>
          <target state="translated">행렬 스택에 대한 컴퓨팅 결정 요인 :</target>
        </trans-unit>
        <trans-unit id="5ffa5ce5ed5560b7502b21e2214468e10166aa18" translate="yes" xml:space="preserve">
          <source>Computing log-determinants for a stack of matrices:</source>
          <target state="translated">행렬 스택에 대한 로그 결정 요소 계산 :</target>
        </trans-unit>
        <trans-unit id="0fe14fa20a118f97b78bbb776b8e138eb54dc0e1" translate="yes" xml:space="preserve">
          <source>Computing the mean in float64 is more accurate:</source>
          <target state="translated">float64의 평균을 계산하는 것이 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="0a9983d1df747790eaf4d763cc8f1c4f963a34f1" translate="yes" xml:space="preserve">
          <source>Computing the standard deviation in float64 is more accurate:</source>
          <target state="translated">float64의 표준 편차를 계산하는 것이 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="0d25e4fdfb9f10d7770a29a84aa8fcf9d6cb64d3" translate="yes" xml:space="preserve">
          <source>Computing the variance in float64 is more accurate:</source>
          <target state="translated">float64의 분산을 계산하는 것이 더 정확합니다.</target>
        </trans-unit>
        <trans-unit id="750f4a65465f4b9d86986bbaa22fd86a632eb891" translate="yes" xml:space="preserve">
          <source>Concatenate a sequence of arrays along the given axis.</source>
          <target state="translated">주어진 축을 따라 일련의 배열을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="69f1f5039a9914b263cf71649e1821ac86e01220" translate="yes" xml:space="preserve">
          <source>Concatenate function that preserves input masks.</source>
          <target state="translated">입력 마스크를 유지하는 기능을 연결합니다.</target>
        </trans-unit>
        <trans-unit id="c97f764478b3a31df47737dc418c9221907f7d16" translate="yes" xml:space="preserve">
          <source>Concatenate supports providing an output dtype</source>
          <target state="translated">출력 dtype을 제공하는 Concatenate 지원</target>
        </trans-unit>
        <trans-unit id="ed6bd4fa614f6eb9503e5372178538f1d170fa87" translate="yes" xml:space="preserve">
          <source>Concatenation of 1d arrays along any but &lt;code&gt;axis=0&lt;/code&gt; raises &lt;code&gt;IndexError&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;axis=0&lt;/code&gt; 아닌 1d 배열을 연결 하면 &lt;code&gt;IndexError&lt;/code&gt; 가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="6f58d263f33944384921df8405fd4a36e06175e2" translate="yes" xml:space="preserve">
          <source>Concepts</source>
          <target state="translated">Concepts</target>
        </trans-unit>
        <trans-unit id="ba05e100e3bed4ff3109d1f54b0ad1cc52a86a51" translate="yes" xml:space="preserve">
          <source>Conceptually, &lt;code&gt;__array_wrap__&lt;/code&gt; &amp;ldquo;wraps up the action&amp;rdquo; in the sense of allowing a subclass to set the type of the return value and update attributes and metadata. Let&amp;rsquo;s show how this works with an example. First we return to the simpler example subclass, but with a different name and some print statements:</source>
          <target state="translated">개념적으로 &lt;code&gt;__array_wrap__&lt;/code&gt; 은 서브 클래스가 반환 값의 유형을 설정하고 속성 및 메타 데이터를 업데이트 할 수 있도록 허용한다는 의미에서 &quot;액션을 래핑&quot;합니다. 이것이 어떻게 작동하는지 예제를 통해 보여 드리겠습니다. 먼저 더 간단한 예제 하위 클래스로 돌아가지만 다른 이름과 일부 인쇄 문을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="e39262defe80a83fac1b793497417432c8b1a879" translate="yes" xml:space="preserve">
          <source>Conclusion</source>
          <target state="translated">Conclusion</target>
        </trans-unit>
        <trans-unit id="7dcf596bd4e5f4a9d24521f5f49fd79763f81495" translate="yes" xml:space="preserve">
          <source>Configuration (class in numpy.distutils.misc_util)</source>
          <target state="translated">구성 (numpy.distutils.misc_util의 클래스)</target>
        </trans-unit>
        <trans-unit id="e244b01ee3f64c2283fc876d0c8eda64a9141003" translate="yes" xml:space="preserve">
          <source>Configuration class</source>
          <target state="translated">구성 클래스</target>
        </trans-unit>
        <trans-unit id="c674b5e16e61274772b7e260d7eb4b0965503ffd" translate="yes" xml:space="preserve">
          <source>Configuration statements are sort of keywords combined together to determine the required optimization for the dispatch-able source.</source>
          <target state="translated">구성 명령문은 디스패치 가능 소스에 필요한 최적화를 결정하기 위해 함께 결합 된 일종의 키워드입니다.</target>
        </trans-unit>
        <trans-unit id="d9f7b6104d5a99c920921e621fa9d0c4103eb0da" translate="yes" xml:space="preserve">
          <source>Configuring the required optimization by the user before starting to build the source files via the two command arguments as explained above:</source>
          <target state="translated">위에서 설명한대로 두 개의 명령 인수를 통해 소스 파일 빌드를 시작하기 전에 사용자가 필요한 최적화를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="de104104bf202d8e985f48514d72c44013ff4e3f" translate="yes" xml:space="preserve">
          <source>Conflict of interest</source>
          <target state="translated">이해 상충</target>
        </trans-unit>
        <trans-unit id="184822ecb4734c964a62ae2e06e95f198b762b22" translate="yes" xml:space="preserve">
          <source>Conflicts of Interest</source>
          <target state="translated">이해 상충</target>
        </trans-unit>
        <trans-unit id="3b137999e92fb865b60d44d9df90d00a70159dda" translate="yes" xml:space="preserve">
          <source>Conjugate gradients solver</source>
          <target state="translated">켤레 기울기 솔버</target>
        </trans-unit>
        <trans-unit id="03aa9d5446588b4491e2deeb2d30f5f693fcd346" translate="yes" xml:space="preserve">
          <source>Consensus-based decision making by the community</source>
          <target state="translated">커뮤니티의 합의 기반 의사 결정</target>
        </trans-unit>
        <trans-unit id="da18f43cbda77c14c1135f5d6d7534517acba1bc" translate="yes" xml:space="preserve">
          <source>Consequences of alignment</source>
          <target state="translated">정렬의 결과</target>
        </trans-unit>
        <trans-unit id="ce820fa717bdda0c0deae589e1169e35d8472e60" translate="yes" xml:space="preserve">
          <source>Consequently, the likes of &lt;a href=&quot;arrays.scalars#numpy.float16&quot;&gt;&lt;code&gt;float16&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;arrays.scalars#numpy.float32&quot;&gt;&lt;code&gt;float32&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt; are still sub-types of &lt;a href=&quot;arrays.scalars#numpy.floating&quot;&gt;&lt;code&gt;floating&lt;/code&gt;&lt;/a&gt;, but, contrary to runtime, they&amp;rsquo;re not necessarily considered as sub-classes.</source>
          <target state="translated">결과적으로 &lt;a href=&quot;arrays.scalars#numpy.float16&quot;&gt; &lt;code&gt;float16&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;arrays.scalars#numpy.float32&quot;&gt; &lt;code&gt;float32&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; 같은&lt;/a&gt; 것은 여전히 &lt;a href=&quot;arrays.scalars#numpy.floating&quot;&gt; &lt;code&gt;floating&lt;/code&gt; 의&lt;/a&gt; 하위 유형 이지만 런타임과 달리 반드시 하위 클래스로 간주되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee60c103055af88b13ff323bc75bf150e6725271" translate="yes" xml:space="preserve">
          <source>Consider a Fortran 77 file &lt;code&gt;ftype.f&lt;/code&gt;:</source>
          <target state="translated">Fortran 77 파일 &lt;code&gt;ftype.f&lt;/code&gt; 를 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="823b148245451955fd9acdba548819ba7ce17047" translate="yes" xml:space="preserve">
          <source>Consider a potential project with an initial investment of $40 000 and projected cashflows of $5 000, $8 000, $12 000 and $30 000 at the end of each period discounted at a rate of 8% per period. To find the project&amp;rsquo;s net present value:</source>
          <target state="translated">초기 투자가 $ 40,000이고 각 기간 말에 $ 5,000, $ 8,000, $ 12,000 및 $ 30,000의 예상 현금 흐름이 기간 당 8 %의 비율로 할인 된 잠재적 프로젝트를 고려하십시오. 프로젝트의 순 현재 가치를 찾으려면 :</target>
        </trans-unit>
        <trans-unit id="e539f73473510ee53613700e677295e3dfb96cf9" translate="yes" xml:space="preserve">
          <source>Consider a reasonable prototype for a dot product function:</source>
          <target state="translated">내적 함수에 대한 합리적인 프로토 타입을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="cdfd5c5d52fe64ca5fe219ac6749930b18bf023b" translate="yes" xml:space="preserve">
          <source>Consider an urn with black and white marbles in it, &lt;code&gt;ngood&lt;/code&gt; of them are black and &lt;code&gt;nbad&lt;/code&gt; are white. If you draw &lt;code&gt;nsample&lt;/code&gt; balls without replacement, then the hypergeometric distribution describes the distribution of black balls in the drawn sample.</source>
          <target state="translated">검은 색과 흰색 대리석이있는 항아리를 고려하십시오 &lt;code&gt;ngood&lt;/code&gt; 는 검은 색이고 &lt;code&gt;nbad&lt;/code&gt; 는 흰색입니다. 교체하지 않고 &lt;code&gt;nsample&lt;/code&gt; 볼 을 그리는 경우 초 지오 분포 분포는 그린 샘플에서 검은 볼의 분포를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="d5c8a523867a9ff18dcaa82b3cff4222e0246a19" translate="yes" xml:space="preserve">
          <source>Consider breaking a step out into an individual how-to and linking to it.</source>
          <target state="translated">단계를 개별 방법으로 나누고 연결하는 것을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="0d56e4e8e5205e5f0b9d856e7027774cced155ea" translate="yes" xml:space="preserve">
          <source>Consider four points in different quadrants:</source>
          <target state="translated">다른 사분면에서 4 개의 점을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="fb2b6acc5ced685725fe745ef47154f819027b77" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;a href=&quot;https://numpy.org/doc/1.19/f2py/setup_example.py&quot;&gt;setup file&lt;/a&gt;:</source>
          <target state="translated">다음 &lt;a href=&quot;https://numpy.org/doc/1.19/f2py/setup_example.py&quot;&gt;설정 파일을&lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="ac9e63236f76602518a292e85149f4dbda738f44" translate="yes" xml:space="preserve">
          <source>Consider the following &lt;a href=&quot;https://numpy.org/doc/1.20/f2py/setup_example.py&quot;&gt;setup file&lt;/a&gt;:</source>
          <target state="translated">다음 &lt;a href=&quot;https://numpy.org/doc/1.20/f2py/setup_example.py&quot;&gt;설정 파일을&lt;/a&gt; 고려 하십시오 .</target>
        </trans-unit>
        <trans-unit id="7c9c1bf2d1a0768df8735aff97cc8590c9d13541" translate="yes" xml:space="preserve">
          <source>Consider the following Fortran 77 code:</source>
          <target state="translated">다음 Fortran 77 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8515017e84be54d053995a36d2cd6320bd302547" translate="yes" xml:space="preserve">
          <source>Consider the following Fortran 77 subroutine that takes an array and applies a function &lt;code&gt;func&lt;/code&gt; to its elements.</source>
          <target state="translated">배열을 취하고 요소에 함수 &lt;code&gt;func&lt;/code&gt; 를 적용하는 다음 Fortran 77 서브 루틴을 고려하십시오 .</target>
        </trans-unit>
        <trans-unit id="80412f62c2645f04f58643107077fefaf6e15221" translate="yes" xml:space="preserve">
          <source>Consider the following Fortran 77 subroutine:</source>
          <target state="translated">다음 Fortran 77 서브 루틴을 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="8ad9bdce0c23896df7965ad8c90acb9c29b310c2" translate="yes" xml:space="preserve">
          <source>Consider the following Fortran 90 code:</source>
          <target state="translated">다음 Fortran 90 코드를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="77e6ee6307bcd33eb5639f71fe8341e14a067362" translate="yes" xml:space="preserve">
          <source>Consider the following problem. You have a dataset with missing or invalid entries. If you&amp;rsquo;re doing any kind of processing on this data, and want to &lt;code&gt;skip&lt;/code&gt; or flag these unwanted entries without just deleting them, you may have to use conditionals or filter your data somehow. The &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides some of the same funcionality of &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;NumPy ndarrays&lt;/code&gt;&lt;/a&gt; with added structure to ensure invalid entries are not used in computation.</source>
          <target state="translated">다음 문제를 고려하십시오. 누락되거나 잘못된 항목이있는 데이터 세트가 있습니다. 이 데이터에 대해 어떤 종류의 처리를 수행하고 있고 원치 않는 항목을 삭제하지 않고 &lt;code&gt;skip&lt;/code&gt; 거나 플래그를 지정하려면 어떻게 든 조건을 사용하거나 데이터를 필터링해야 할 수 있습니다. &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈은 동일한 funcionality 일부 제공 &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;NumPy ndarrays&lt;/code&gt; &lt;/a&gt; 무효 엔트리를 보장하기 위해 추가 구조를 계산에 사용되지 않는다.</target>
        </trans-unit>
        <trans-unit id="ed0667d145092c432f907df7626ac668935a1be1" translate="yes" xml:space="preserve">
          <source>Consider two variables,</source>
          <target state="translated">두 가지 변수를 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e750e23dd4669e25e966e47bb3ecf6f06ddf394d" translate="yes" xml:space="preserve">
          <source>Const qualify UFunc inner loops</source>
          <target state="translated">Const Qualification UFunc 내부 루프</target>
        </trans-unit>
        <trans-unit id="e578be69fc8af5a2544b4a4596812e93693c1390" translate="yes" xml:space="preserve">
          <source>Constant padding. Outside bounds values will be the same as the first item in fill_value.</source>
          <target state="translated">일정한 패딩. 경계를 벗어난 값은 fill_value의 첫 번째 항목과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0f386d7e7881b32fa39cb7b62bdb15c0f3a4c0e1" translate="yes" xml:space="preserve">
          <source>Constants</source>
          <target state="translated">Constants</target>
        </trans-unit>
        <trans-unit id="40c1f81a4e69db7cd9d45c11cd781d9ad71dd11a" translate="yes" xml:space="preserve">
          <source>Constants of the &lt;code&gt;numpy.ma&lt;/code&gt; module</source>
          <target state="translated">&lt;code&gt;numpy.ma&lt;/code&gt; 모듈의 상수</target>
        </trans-unit>
        <trans-unit id="416f6fe7840ff98cc53cadbb77344b8df8be8efe" translate="yes" xml:space="preserve">
          <source>Constants of the numpy.ma module</source>
          <target state="translated">numpy.ma 모듈의 상수</target>
        </trans-unit>
        <trans-unit id="ff100071278ebc0dce3b27374571a0b6214de453" translate="yes" xml:space="preserve">
          <source>Construct Python bytes containing the raw data bytes in the array.</source>
          <target state="translated">배열에서 원시 데이터 바이트를 포함하는 Python 바이트를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2a92c9e90e58234afd363951b811ae566d58dd4a" translate="yes" xml:space="preserve">
          <source>Construct a 2-D histogram with variable bin width. First define the bin edges:</source>
          <target state="translated">빈 폭이 가변적 인 2 차원 히스토그램을 구성합니다. 먼저 빈 가장자리를 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="b11f0a82e16bcae98f2244ba4878813b908a4c4a" translate="yes" xml:space="preserve">
          <source>Construct a configuration instance for the given package name. If &lt;em&gt;parent_name&lt;/em&gt; is not None, then construct the package as a sub-package of the &lt;em&gt;parent_name&lt;/em&gt; package. If &lt;em&gt;top_path&lt;/em&gt; and &lt;em&gt;package_path&lt;/em&gt; are None then they are assumed equal to the path of the file this instance was created in. The setup.py files in the numpy distribution are good examples of how to use the &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt;&lt;code&gt;Configuration&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">주어진 패키지 이름에 대한 구성 인스턴스를 구성하십시오. &lt;em&gt;parent_name&lt;/em&gt; 이 None이 아닌 경우 패키지를 &lt;em&gt;parent_name&lt;/em&gt; 패키지 의 하위 패키지로 구성하십시오 . 경우 &lt;em&gt;top_path&lt;/em&gt; 및 &lt;em&gt;package_path은&lt;/em&gt; 아무도 없습니다 그들은이 인스턴스에서 생성 된 파일의 경로와 동일한 가정한다. NumPy와 유통의 setup.py 파일을 사용하는 방법의 좋은 예입니다 &lt;a href=&quot;#numpy.distutils.misc_util.Configuration&quot;&gt; &lt;code&gt;Configuration&lt;/code&gt; &lt;/a&gt; 인스턴스를.</target>
        </trans-unit>
        <trans-unit id="433d0814f344913efe3de8118404c8ba5f5d7e7f" translate="yes" xml:space="preserve">
          <source>Construct a dtype description list from a given dtype.</source>
          <target state="translated">주어진 dtype에서 dtype 설명 목록을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="699e78314482350bc4ad52e8b449dfd4bedbe2f6" translate="yes" xml:space="preserve">
          <source>Construct a multi-dimensional &amp;ldquo;meshgrid&amp;rdquo; using indexing notation.</source>
          <target state="translated">인덱싱 표기법을 사용하여 다차원 &quot;메쉬 그리드&quot;를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5f1a333c2b137d94f4c46546de94da2e32f2f8d9" translate="yes" xml:space="preserve">
          <source>Construct a new 1-dimensional array of data-type determined by &lt;code&gt;descr&lt;/code&gt;, that ranges from &lt;code&gt;start&lt;/code&gt; to &lt;code&gt;stop&lt;/code&gt; (exclusive) in increments of &lt;code&gt;step&lt;/code&gt;. Equivalent to arange( &lt;code&gt;start&lt;/code&gt;, &lt;code&gt;stop&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;, &lt;code&gt;typenum&lt;/code&gt; ).</source>
          <target state="translated">결정 데이터 타입의 새로운 1 차원 어레이 구축 &lt;code&gt;descr&lt;/code&gt; 범위 것과, &lt;code&gt;start&lt;/code&gt; 을 &lt;code&gt;stop&lt;/code&gt; 단위로 (단독) &lt;code&gt;step&lt;/code&gt; . &lt;code&gt;typenum&lt;/code&gt; ( &lt;code&gt;start&lt;/code&gt; , &lt;code&gt;stop&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; , typenum ) 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="fec9966593ee1edd10cbcd21d0622b1f630d401d" translate="yes" xml:space="preserve">
          <source>Construct a new 1-dimensional array of data-type, &lt;em&gt;typenum&lt;/em&gt;, that ranges from &lt;em&gt;start&lt;/em&gt; to &lt;em&gt;stop&lt;/em&gt; (exclusive) in increments of &lt;em&gt;step&lt;/em&gt; . Equivalent to &lt;strong&gt;arange&lt;/strong&gt; (&lt;em&gt;start&lt;/em&gt;, &lt;em&gt;stop&lt;/em&gt;, &lt;em&gt;step&lt;/em&gt;, dtype).</source>
          <target state="translated">&lt;em&gt;step&lt;/em&gt; 씩 증가하는 &lt;em&gt;시작&lt;/em&gt; 에서 &lt;em&gt;중지&lt;/em&gt; (제외) 범위 의 새로운 1 차원 배열의 데이터 유형 &lt;em&gt;typenum을 구성하십시오&lt;/em&gt; . 상당 &lt;strong&gt;arange에&lt;/strong&gt; ( &lt;em&gt;시작&lt;/em&gt; , &lt;em&gt;중지&lt;/em&gt; , &lt;em&gt;단계&lt;/em&gt; , DTYPE).&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;strong&gt;&lt;/strong&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="8a706c57cd0f57f685f10a9b48082253d3c7f348" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape given by &lt;em&gt;dims&lt;/em&gt; and data type given by &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;fortran&lt;/em&gt; is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. Fill the memory with zeros (or the 0 object if &lt;em&gt;dtype&lt;/em&gt; corresponds to &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">새로운 구축 &lt;em&gt;ND&lt;/em&gt; 에 의해 주어진 형상 차원 배열 &lt;em&gt;어두워&lt;/em&gt; 주어진 데이터 타입 &lt;em&gt;DTYPE를&lt;/em&gt; . &lt;em&gt;포트란&lt;/em&gt; 이 0이 아닌 경우 &lt;em&gt;포트란&lt;/em&gt; 배열이 작성되고, 그렇지 않으면 C 순서 배열이 작성됩니다. 메모리를 0 으로 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt;&lt;em&gt; 웁니다&lt;/em&gt; (또는 &lt;em&gt;dtype이 NPY_OBJECT에&lt;/em&gt; 해당하는 경우 0 객체 ).</target>
        </trans-unit>
        <trans-unit id="8d2687a5e2ca712d27ca98860cfa5c57dee1f046" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape given by &lt;em&gt;dims&lt;/em&gt; and data type given by &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;fortran&lt;/em&gt; is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. Fill the memory with zeros (or the 0 object if &lt;em&gt;dtype&lt;/em&gt; corresponds to &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; ).</source>
          <target state="translated">새로운 구축 &lt;em&gt;ND&lt;/em&gt; 에 의해 주어진 형상 차원 배열 &lt;em&gt;어두워&lt;/em&gt; 주어진 데이터 타입 &lt;em&gt;DTYPE를&lt;/em&gt; . 경우 &lt;em&gt;포트란&lt;/em&gt; , 파스칼 다음 순서 배열을 생성 비 - 제로이다 그렇지 C 차 배열이 생성된다. 0으로 메모리 (또는 만약 0 오브젝트 작성 &lt;em&gt;DTYPE의&lt;/em&gt; 대응에 &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8e79348d2a80859159fd1349201ec8444a12864b" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape given by &lt;em&gt;dims&lt;/em&gt; and data type given by &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;fortran&lt;/em&gt; is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. The array is uninitialized unless the data type corresponds to &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; in which case the array is filled with &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 구축 &lt;em&gt;ND&lt;/em&gt; 에 의해 주어진 형상 차원 배열 &lt;em&gt;어두워&lt;/em&gt; 주어진 데이터 타입 &lt;em&gt;DTYPE를&lt;/em&gt; . &lt;em&gt;포트란&lt;/em&gt; 이 0이 아닌 경우 &lt;em&gt;포트란&lt;/em&gt; 배열이 작성되고, 그렇지 않으면 C 순서 배열이 작성됩니다. 데이터 유형이 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 에 해당하지 않으면 배열이 초기화되지 않습니다. 이 경우 배열은 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; 으로 채워 집니다 .</target>
        </trans-unit>
        <trans-unit id="43bfc74ca97bf8504fbbd30400b5012bf38a52fb" translate="yes" xml:space="preserve">
          <source>Construct a new &lt;em&gt;nd&lt;/em&gt; -dimensional array with shape given by &lt;em&gt;dims&lt;/em&gt; and data type given by &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;fortran&lt;/em&gt; is non-zero, then a Fortran-order array is created, otherwise a C-order array is created. The array is uninitialized unless the data type corresponds to &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; in which case the array is filled with &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새로운 구축 &lt;em&gt;ND&lt;/em&gt; 에 의해 주어진 형상 차원 배열 &lt;em&gt;어두워&lt;/em&gt; 주어진 데이터 타입 &lt;em&gt;DTYPE를&lt;/em&gt; . 경우 &lt;em&gt;포트란&lt;/em&gt; , 파스칼 다음 순서 배열을 생성 비 - 제로이다 그렇지 C 차 배열이 생성된다. 데이터 유형이 &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 에 해당하지 않는 한 배열은 초기화되지 않습니다. 이 경우 배열은 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; 으로 채워 집니다 .</target>
        </trans-unit>
        <trans-unit id="dd48627fbdfc02f6cd5a744335a7b8a3ec7e74ff" translate="yes" xml:space="preserve">
          <source>Construct a new Generator with the default BitGenerator (PCG64).</source>
          <target state="translated">기본 BitGenerator (PCG64)를 사용하여 새 생성기를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="2293ee6e243af707ad818c946eb5f54c18c43217" translate="yes" xml:space="preserve">
          <source>Construct a one-dimensional ndarray of a single type from a binary or (ASCII) text &lt;code&gt;string&lt;/code&gt; of length &lt;code&gt;slen&lt;/code&gt;. The data-type of the array to-be-created is given by &lt;code&gt;dtype&lt;/code&gt;. If num is -1, then &lt;strong&gt;copy&lt;/strong&gt; the entire string and return an appropriately sized array, otherwise, &lt;code&gt;num&lt;/code&gt; is the number of items to &lt;strong&gt;copy&lt;/strong&gt; from the string. If &lt;code&gt;sep&lt;/code&gt; is NULL (or &amp;ldquo;&amp;rdquo;), then interpret the string as bytes of binary data, otherwise convert the sub-strings separated by &lt;code&gt;sep&lt;/code&gt; to items of data-type &lt;code&gt;dtype&lt;/code&gt;. Some data-types may not be readable in text mode and an error will be raised if that occurs. All errors return NULL.</source>
          <target state="translated">길이가 &lt;code&gt;slen&lt;/code&gt; 인 이진 또는 (ASCII) 텍스트 &lt;code&gt;string&lt;/code&gt; 에서 단일 유형의 1 차원 ndarray를 구성합니다 . 작성 될 배열의 데이터 유형은 &lt;code&gt;dtype&lt;/code&gt; 에 의해 제공됩니다 . num이 -1이면 전체 문자열 을 &lt;strong&gt;복사&lt;/strong&gt; 하고 적절한 크기의 배열을 반환합니다. 그렇지 않으면 &lt;code&gt;num&lt;/code&gt; 은 문자열에서 &lt;strong&gt;복사&lt;/strong&gt; 할 항목 수입니다 . 경우 &lt;code&gt;sep&lt;/code&gt; (또는 &quot;&quot;) NULL 인 후 이진 데이터의 바이트와 같은 문자열을 해석 달리 서브 문자열로 분리 변환 &lt;code&gt;sep&lt;/code&gt; 데이터 타입의 항목 &lt;code&gt;dtype&lt;/code&gt; . 일부 데이터 유형은 텍스트 모드에서 읽을 수 없으며 오류가 발생하면 오류가 발생합니다. 모든 오류는 NULL을 반환합니다.&lt;strong&gt;&lt;/strong&gt;&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5251a91820bd97dd4c2975d82383f312ad4f99bf" translate="yes" xml:space="preserve">
          <source>Construct a one-dimensional ndarray of a single type from a binary or text file. The open file pointer is &lt;code&gt;fp&lt;/code&gt;, the data-type of the array to be created is given by &lt;code&gt;dtype&lt;/code&gt;. This must match the data in the file. If &lt;code&gt;num&lt;/code&gt; is -1, then read until the end of the file and return an appropriately sized array, otherwise, &lt;code&gt;num&lt;/code&gt; is the number of items to read. If &lt;code&gt;sep&lt;/code&gt; is NULL (or &amp;ldquo;&amp;rdquo;), then read from the file in binary mode, otherwise read from the file in text mode with &lt;code&gt;sep&lt;/code&gt; providing the item separator. Some array types cannot be read in text mode in which case an error is raised.</source>
          <target state="translated">이진 또는 텍스트 파일에서 단일 유형의 1 차원 ndarray를 구성하십시오. 열린 파일 포인터는 &lt;code&gt;fp&lt;/code&gt; 이며 생성 할 배열의 데이터 유형은 &lt;code&gt;dtype&lt;/code&gt; 으로 제공됩니다 . 파일의 데이터와 일치해야합니다. 경우 &lt;code&gt;num&lt;/code&gt; -1, 다음, 그렇지 않으면 파일이 끝날 때까지 읽고 적절한 크기의 배열을 반환 &lt;code&gt;num&lt;/code&gt; 읽을 수있는 항목의 수입니다. 경우 &lt;code&gt;sep&lt;/code&gt; (또는 &quot;&quot;) NULL이다하고 그렇지 텍스트 모드에서 파일로부터 판독 된 바이너리 모드에서 파일로부터 판독 &lt;code&gt;sep&lt;/code&gt; 상품 분리를 제공한다. 일부 배열 유형은 텍스트 모드에서 읽을 수 없으며이 경우 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="5dade1b4bc430d7a08d1e500dc891669be329c17" translate="yes" xml:space="preserve">
          <source>Construct a one-dimensional ndarray of a single type from an object, &lt;code&gt;buf&lt;/code&gt;, that exports the (single-segment) buffer protocol (or has an attribute __buffer__ that returns an object that exports the buffer protocol). A writeable buffer will be tried first followed by a read- only buffer. The &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag of the returned array will reflect which one was successful. The data is assumed to start at &lt;code&gt;offset&lt;/code&gt; bytes from the start of the memory location for the object. The type of the data in the buffer will be interpreted depending on the data- type descriptor, &lt;code&gt;dtype.&lt;/code&gt; If &lt;code&gt;count&lt;/code&gt; is negative then it will be determined from the size of the buffer and the requested itemsize, otherwise, &lt;code&gt;count&lt;/code&gt; represents how many elements should be converted from the buffer.</source>
          <target state="translated">(단일 세그먼트) 버퍼 프로토콜을 내보내는 (또는 버퍼 프로토콜을 내보내는 객체를 반환하는 __buffer__ 속성이있는) 객체 &lt;code&gt;buf&lt;/code&gt; 에서 단일 유형의 1 차원 ndarray를 구성합니다 . 쓰기 가능한 버퍼가 먼저 시도 된 다음 읽기 전용 버퍼가 뒤 따릅니다. 반환 된 배열 의 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그는 성공한 것을 반영합니다. 데이터는 객체의 메모리 위치 시작부터 &lt;code&gt;offset&lt;/code&gt; 바이트 로 시작한다고 가정 합니다. 버퍼의 데이터 유형은 데이터 유형 설명자 &lt;code&gt;dtype.&lt;/code&gt; 에 따라 해석됩니다 . 경우에 &lt;code&gt;count&lt;/code&gt; 네거티브가 다음 인 것이 버퍼의 크기를 결정하고, 그렇지 않으면, itemsize 요청 될 &lt;code&gt;count&lt;/code&gt; 버퍼에서 변환해야하는 요소 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e92de9d29a116aa0b6d137e92f4fcc4342111c10" translate="yes" xml:space="preserve">
          <source>Construct a polynomial from its roots:</source>
          <target state="translated">뿌리에서 다항식을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="54108fca709f2e6aae97ceda0d8c265646c4b46b" translate="yes" xml:space="preserve">
          <source>Construct a record array from a wide-variety of objects.</source>
          <target state="translated">다양한 객체로 레코드 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="dddc1fb766bf2c0701978de30cc0096077f1469c" translate="yes" xml:space="preserve">
          <source>Construct a record array from data.</source>
          <target state="translated">데이터에서 레코드 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="d4864a011f7d33f5af39ef59a61e350cf80e6b72" translate="yes" xml:space="preserve">
          <source>Construct an array by executing a function on grid positions.</source>
          <target state="translated">그리드 위치에서 함수를 실행하여 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="eb2f5ef9eabc5b7b4a11f36c9da5468304049228" translate="yes" xml:space="preserve">
          <source>Construct an array by executing a function over each coordinate.</source>
          <target state="translated">각 좌표에 대해 함수를 실행하여 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="b8c37852e1d20c54f490e5d55d35d32a2e77d1a3" translate="yes" xml:space="preserve">
          <source>Construct an array by repeating A the number of times given by reps.</source>
          <target state="translated">A 회 반복 횟수를 반복하여 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="dbd2833638747627f536392fa321860afd1ae4eb" translate="yes" xml:space="preserve">
          <source>Construct an array from a text file, using regular expression parsing.</source>
          <target state="translated">정규식 구문 분석을 사용하여 텍스트 파일에서 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="001455fa868d0d982a84f3e1e1c5e71cab1576c5" translate="yes" xml:space="preserve">
          <source>Construct an array from an index array and a set of arrays to choose from.</source>
          <target state="translated">인덱스 배열과 선택할 배열 집합에서 배열을 구성합니다.</target>
        </trans-unit>
        <trans-unit id="bc43ce79bb40c8126c3a27887892f4214024c494" translate="yes" xml:space="preserve">
          <source>Construct an array from data in a text or binary file.</source>
          <target state="translated">텍스트 또는 이진 파일의 데이터로 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="899756aeb93d1b6aa9bd7c93436b76c0a22fadb6" translate="yes" xml:space="preserve">
          <source>Construct an array.</source>
          <target state="translated">배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c9c119fe2ffdbb682afbfd3d008f9fdd22f03e58" translate="yes" xml:space="preserve">
          <source>Construct an external function suitable for calling Python function from Fortran. &lt;code&gt;intent(callback)&lt;/code&gt; must be specified before the corresponding &lt;code&gt;external&lt;/code&gt; statement. If &amp;lsquo;argument&amp;rsquo; is not in argument list then it will be added to Python wrapper but only initializing external function.</source>
          <target state="translated">Fortran에서 Python 함수를 호출하는 데 적합한 외부 함수를 생성합니다. &lt;code&gt;intent(callback)&lt;/code&gt; 는 해당 &lt;code&gt;external&lt;/code&gt; 문 앞에 지정되어야합니다 . 'argument'가 인수 목록에 없으면 Python 래퍼에 추가되지만 외부 함수 만 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="46ee020e3e38edbb070e9ee58f67dfe44037398b" translate="yes" xml:space="preserve">
          <source>Construct an ndarray that allows field access using attributes.</source>
          <target state="translated">속성을 사용하여 필드 액세스를 허용하는 ndarray를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="fb44631c7aa67652764b1577b600ec14bbff21bf" translate="yes" xml:space="preserve">
          <source>Construct an ndarray:</source>
          <target state="translated">ndarray를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="1836b53e3c198fe2973be15630e978884dacc6c1" translate="yes" xml:space="preserve">
          <source>Construct an open mesh from multiple sequences.</source>
          <target state="translated">여러 시퀀스에서 열린 메시를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="d3f16aad1976f8f22c5c798dc38d30d79a5e094c" translate="yes" xml:space="preserve">
          <source>Construct an open multi-dimensional &amp;ldquo;meshgrid&amp;rdquo; using indexing notation.</source>
          <target state="translated">인덱싱 표기법을 사용하여 열린 다차원 &quot;메쉬 그리드&quot;를 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="55ed2507cc0269a472eaaccd89421410ab758bab" translate="yes" xml:space="preserve">
          <source>Construct index arrays.</source>
          <target state="translated">인덱스 배열을 구성하십시오.</target>
        </trans-unit>
        <trans-unit id="5a0c11bbbca8e4a4ea9ed0b83b66214ccecaa653" translate="yes" xml:space="preserve">
          <source>Construct the polynomial</source>
          <target state="translated">다항식 구성</target>
        </trans-unit>
        <trans-unit id="192cbc084f005ca610c67957b0697275db236d0b" translate="yes" xml:space="preserve">
          <source>Constructing arrays</source>
          <target state="translated">배열 구성</target>
        </trans-unit>
        <trans-unit id="892df0306b57e168d52112a1ac784f3daa7382c7" translate="yes" xml:space="preserve">
          <source>Constructing masked arrays</source>
          <target state="translated">마스크 배열 생성</target>
        </trans-unit>
        <trans-unit id="3b2acad01b35b6a4b590dd72299d537e83394aa4" translate="yes" xml:space="preserve">
          <source>Constructing polynomials by specifying coefficients is just one way of obtaining a polynomial instance, they may also be created by specifying their roots, by conversion from other polynomial types, and by least squares fits. Fitting is discussed in its own section, the other methods are demonstrated below:</source>
          <target state="translated">계수를 지정하여 다항식을 구성하는 것은 다항식 인스턴스를 얻는 한 가지 방법 일 뿐이며, 근을 지정하거나 다른 다항식 유형에서 변환하고 최소 자승법으로도 만들 수 있습니다. 피팅은 자체 섹션에서 논의되며 다른 방법은 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="5e3bd2707e230a54a78bfb480ed5e48501ad49b7" translate="yes" xml:space="preserve">
          <source>Construction and Destruction</source>
          <target state="translated">건축과 파괴</target>
        </trans-unit>
        <trans-unit id="94e201ee9bbe86594c4ceb5d0adfb75c739dc4ae" translate="yes" xml:space="preserve">
          <source>Construction:</source>
          <target state="translated">Construction:</target>
        </trans-unit>
        <trans-unit id="38e2be5fd7d5e892898904110f6fb600a6f2fc5e" translate="yes" xml:space="preserve">
          <source>Constructs Python bytes showing a copy of the raw contents of data memory. The bytes object can be produced in either &amp;lsquo;C&amp;rsquo; or &amp;lsquo;Fortran&amp;rsquo;, or &amp;lsquo;Any&amp;rsquo; order (the default is &amp;lsquo;C&amp;rsquo;-order). &amp;lsquo;Any&amp;rsquo; order means C-order unless the F_CONTIGUOUS flag in the array is set, in which case it means &amp;lsquo;Fortran&amp;rsquo; order.</source>
          <target state="translated">데이터 메모리의 원시 내용 사본을 보여주는 Python 바이트를 구성합니다. bytes 객체는 'C'또는 'Fortran'또는 'Any'순서 (기본값은 'C'순서)로 생성 할 수 있습니다. '모든'순서는 배열의 F_CONTIGUOUS 플래그가 설정되어 있지 않으면 C 순서를 의미하며,이 경우 'Fortran'순서를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="1bbbc318c447f4bc6924e0f1efc43adcd2ebbece" translate="yes" xml:space="preserve">
          <source>Constructs Python bytes showing a copy of the raw contents of data memory. The bytes object is produced in C-order by default. This behavior is controlled by the &lt;code&gt;order&lt;/code&gt; parameter.</source>
          <target state="translated">데이터 메모리의 원시 내용 사본을 표시하는 Python 바이트를 구성합니다. bytes 객체는 기본적으로 C 순서로 생성됩니다. 이 동작은 &lt;code&gt;order&lt;/code&gt; 매개 변수에 의해 제어됩니다 .</target>
        </trans-unit>
        <trans-unit id="ced0c9c71d4ab448d256e9755d975eecac83dca4" translate="yes" xml:space="preserve">
          <source>Container customization: (see &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;Indexing&lt;/a&gt;)</source>
          <target state="translated">컨테이너 사용자 정의 : ( &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;인덱싱&lt;/a&gt; 참조 )</target>
        </trans-unit>
        <trans-unit id="945b5909351c614284e294687fc5eed8d30bdfa8" translate="yes" xml:space="preserve">
          <source>Container for the BitGenerators.</source>
          <target state="translated">BitGenerators의 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="9518c0118e2383159ff89f0d3a6a9dc8b35e9445" translate="yes" xml:space="preserve">
          <source>Container for the Mersenne Twister pseudo-random number generator.</source>
          <target state="translated">Mersenne Twister 의사 난수 생성기를위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="d5e682207eece98b359f1e232839589a5bb83513" translate="yes" xml:space="preserve">
          <source>Container for the Philox (4x64) pseudo-random number generator.</source>
          <target state="translated">Philox (4x64) 의사 난수 생성기를위한 컨테이너입니다.</target>
        </trans-unit>
        <trans-unit id="a3a1e2e5587dcb37af6a475783aa40a7e9e982e2" translate="yes" xml:space="preserve">
          <source>Container for the slow Mersenne Twister pseudo-random number generator. Consider using a different BitGenerator with the Generator container instead.</source>
          <target state="translated">느린 Mersenne Twister 의사 난수 생성기를위한 컨테이너입니다. 대신 Generator 컨테이너와 함께 다른 BitGenerator를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d6d56c0715bcae84fdc288fbfdbc42c1f40a6702" translate="yes" xml:space="preserve">
          <source>Contains the new set of coefficients.</source>
          <target state="translated">새로운 계수 세트를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="4f9be057f0ea5d2ba72fd2c810e8d7b9aa98b469" translate="yes" xml:space="preserve">
          <source>Content</source>
          <target state="translated">Content</target>
        </trans-unit>
        <trans-unit id="e416e43f493dc03bd7f45d55965a398e7052a174" translate="yes" xml:space="preserve">
          <source>Contents:</source>
          <target state="translated">Contents:</target>
        </trans-unit>
        <trans-unit id="3643c1a8b97789cf4db3d875dc0365e5ddbc09e5" translate="yes" xml:space="preserve">
          <source>Context management and the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;close&lt;/code&gt;&lt;/a&gt; method appeared in version 1.15.0.</source>
          <target state="translated">컨텍스트 관리 및 &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt; &lt;code&gt;close&lt;/code&gt; &lt;/a&gt; 메소드는 버전 1.15.0에 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="28ea8c81849521c495649532e08b0b593de2159c" translate="yes" xml:space="preserve">
          <source>Context manager and decorator doing much the same as &lt;code&gt;warnings.catch_warnings&lt;/code&gt;.</source>
          <target state="translated">컨텍스트 관리자 및 데코레이터는 &lt;code&gt;warnings.catch_warnings&lt;/code&gt; 와 거의 동일한 작업을 수행합니다 .</target>
        </trans-unit>
        <trans-unit id="5df86c4c3ee2b6d151a9b289e9fec5a79fd29c69" translate="yes" xml:space="preserve">
          <source>Context manager for floating-point error handling.</source>
          <target state="translated">부동 소수점 오류 처리를위한 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="bd35c159334bf5d6e2fa5b1e59c4a7083dc1dc6f" translate="yes" xml:space="preserve">
          <source>Context manager for setting print options.</source>
          <target state="translated">인쇄 옵션 설정을위한 컨텍스트 관리자</target>
        </trans-unit>
        <trans-unit id="e74eade6a152d46f1eb9b2b5ababc0f77f6bb16e" translate="yes" xml:space="preserve">
          <source>Contiguous array of same shape and content as &lt;code&gt;a&lt;/code&gt;, with type &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; if specified.</source>
          <target state="translated">지정된 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; 을&lt;/a&gt; 가진 &lt;code&gt;a&lt;/code&gt; 와 동일한 모양과 내용의 연속 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="053873361447a3f60bca70c8480df2214f748216" translate="yes" xml:space="preserve">
          <source>Contrary to &lt;a href=&quot;numpy.asanyarray#numpy.asanyarray&quot;&gt;&lt;code&gt;asanyarray&lt;/code&gt;&lt;/a&gt;, ndarray subclasses are not passed through:</source>
          <target state="translated">&lt;a href=&quot;numpy.asanyarray#numpy.asanyarray&quot;&gt; &lt;code&gt;asanyarray&lt;/code&gt; &lt;/a&gt; 와 달리 ndarray 서브 클래스는 다음을 통해 전달되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="984adebaabb87efdb4e50c0f9cdb6d8a73c99ec4" translate="yes" xml:space="preserve">
          <source>Contributing fixes</source>
          <target state="translated">수정에 기여</target>
        </trans-unit>
        <trans-unit id="23fe843863a12807824439b1892f993e0e1df566" translate="yes" xml:space="preserve">
          <source>Contributing indirectly</source>
          <target state="translated">간접적으로 기여</target>
        </trans-unit>
        <trans-unit id="7c796d7c6b796de9e6951d079c160aac2e5028c7" translate="yes" xml:space="preserve">
          <source>Contributing new pages</source>
          <target state="translated">새 페이지 제공</target>
        </trans-unit>
        <trans-unit id="912ab78ea9e7be41b10dbd4b2c4778f1938464e6" translate="yes" xml:space="preserve">
          <source>Contributing to NumPy</source>
          <target state="translated">NumPy에 기여</target>
        </trans-unit>
        <trans-unit id="a60a223c98b2c36522f0b7f89f57ae14e144678a" translate="yes" xml:space="preserve">
          <source>Contributors</source>
          <target state="translated">Contributors</target>
        </trans-unit>
        <trans-unit id="e55585a604c550513c3afa02c0ebd3dbb5250133" translate="yes" xml:space="preserve">
          <source>Contributors to maintenance/1.11.3</source>
          <target state="translated">유지 보수 /1.11.3 기여자</target>
        </trans-unit>
        <trans-unit id="1fb6ba6e1303f6e5416d2c67796f8de91feba760" translate="yes" xml:space="preserve">
          <source>Controlling Iteration Order</source>
          <target state="translated">반복 순서 제어</target>
        </trans-unit>
        <trans-unit id="3381fbfd7109d41fe7b80cebebf3f59427289be0" translate="yes" xml:space="preserve">
          <source>Controls if intermediate optimization should occur. No optimization will occur if False and True will default to the &amp;lsquo;greedy&amp;rsquo; algorithm. Also accepts an explicit contraction list from the &lt;code&gt;np.einsum_path&lt;/code&gt; function. See &lt;code&gt;np.einsum_path&lt;/code&gt; for more details. Defaults to False.</source>
          <target state="translated">중간 최적화 발생 여부를 제어합니다. False 및 True가 기본적으로 'greedy'알고리즘으로 설정되면 최적화가 수행되지 않습니다. &lt;code&gt;np.einsum_path&lt;/code&gt; 함수 에서 명시 적 수축 목록도 허용합니다 . 자세한 내용은 &lt;code&gt;np.einsum_path&lt;/code&gt; 를 참조하십시오. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="962dce34fa4c991d8761b74453473e2047eb1a3f" translate="yes" xml:space="preserve">
          <source>Controls post-processing trimming of trailing digits, as follows:</source>
          <target state="translated">다음과 같이 후행 자릿수의 사후 처리 트리밍을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="d93cc903a5f85a76e394a8f4bb04305a43ea383d" translate="yes" xml:space="preserve">
          <source>Controls printing of the sign of floating-point types. If &amp;lsquo;+&amp;rsquo;, always print the sign of positive values. If &amp;lsquo; &amp;lsquo;, always prints a space (whitespace character) in the sign position of positive values. If &amp;lsquo;-&amp;lsquo;, omit the sign character of positive values. (default &amp;lsquo;-&amp;lsquo;)</source>
          <target state="translated">부동 소수점 유형의 부호 인쇄를 제어합니다. '+'이면 항상 양수의 부호를 인쇄하십시오. ''인 경우 항상 양수 값의 부호 위치에 공백 (공백 문자)을 인쇄합니다. '-'인 경우 양수의 부호 문자를 생략하십시오. (기본 '-')</target>
        </trans-unit>
        <trans-unit id="7e4e4469d00d85c02bbeabd4c04ac5324f9efb77" translate="yes" xml:space="preserve">
          <source>Controls printing of the sign of floating-point types. If &amp;lsquo;+&amp;rsquo;, always print the sign of positive values. If &amp;lsquo; &amp;lsquo;, always prints a space (whitespace character) in the sign position of positive values. If &amp;lsquo;-&amp;lsquo;, omit the sign character of positive values. Defaults to &lt;code&gt;numpy.get_printoptions()['sign']&lt;/code&gt;.</source>
          <target state="translated">부동 소수점 유형의 부호 인쇄를 제어합니다. '+'이면 항상 양수의 부호를 인쇄하십시오. ''인 경우 항상 양수 값의 부호 위치에 공백 (공백 문자)을 인쇄합니다. '-'인 경우 양수의 부호 문자를 생략하십시오. 기본값은 &lt;code&gt;numpy.get_printoptions()['sign']&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="841208ff2e453a067133b334501582310ba65939" translate="yes" xml:space="preserve">
          <source>Controls the interpretation of the &lt;code&gt;precision&lt;/code&gt; option for floating-point types. Can take the following values (default maxprec_equal):</source>
          <target state="translated">부동 소수점 유형에 대한 &lt;code&gt;precision&lt;/code&gt; 옵션 의 해석을 제어합니다 . 다음 값을 사용할 수 있습니다 (기본 maxprec_equal).</target>
        </trans-unit>
        <trans-unit id="bd5b6d8587399226c1239e4675c6dc1ac5b81996" translate="yes" xml:space="preserve">
          <source>Controls the interpretation of the &lt;code&gt;precision&lt;/code&gt; option for floating-point types. Defaults to &lt;code&gt;numpy.get_printoptions()['floatmode']&lt;/code&gt;. Can take the following values:</source>
          <target state="translated">부동 소수점 유형에 대한 &lt;code&gt;precision&lt;/code&gt; 옵션 의 해석을 제어합니다 . 기본값은 &lt;code&gt;numpy.get_printoptions()['floatmode']&lt;/code&gt; 입니다. 다음 값을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="053fc22cde7115d581a6dae5bcdbdffe93e520ff" translate="yes" xml:space="preserve">
          <source>Controls the iteration order. &amp;lsquo;C&amp;rsquo; means C order, &amp;lsquo;F&amp;rsquo; means Fortran order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; order if all the arrays are Fortran contiguous, &amp;lsquo;C&amp;rsquo; order otherwise, and &amp;lsquo;K&amp;rsquo; means as close to the order the array elements appear in memory as possible. This also affects the element memory order of &lt;code&gt;allocate&lt;/code&gt; operands, as they are allocated to be compatible with iteration order. Default is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">반복 순서를 제어합니다. 'C'는 C 순서, 'F'는 포트란 순서, 'A'는 모든 배열이 포트란 연속 인 경우 'F'순서, 그렇지 않으면 'C'순서, 'K'는 배열 요소가 나타나는 순서에 가까운 것을 의미합니다. 가능한 메모리에. 이는 반복 피연산자와 호환되도록 할당되므로 &lt;code&gt;allocate&lt;/code&gt; 피연산자 의 요소 메모리 순서에도 영향을줍니다 . 기본값은 'K'입니다.</target>
        </trans-unit>
        <trans-unit id="e40b08f0bbc0a663bb94e94902d07f9ee748e5cb" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the bytes object. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; (short for &lt;em&gt;Any&lt;/em&gt;) means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. Default is &amp;lsquo;C&amp;rsquo;.</source>
          <target state="translated">bytes 객체의 메모리 레이아웃을 제어합니다. 'C'는 C 순서를 의미하고, 'F'는 F 순서를 의미하고, 'A'( &lt;em&gt;Any의&lt;/em&gt; 약자 )는 &lt;code&gt;a&lt;/code&gt; 가 포트란 연속 이면 'F'를 의미 하고 , 그렇지 않으면 'C'를 의미합니다. 기본값은 'C'입니다.</target>
        </trans-unit>
        <trans-unit id="e9576b535389b3dbd06f435cca5164180f9065da" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the copy. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible. (Note that this function and &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt;&lt;code&gt;numpy.copy&lt;/code&gt;&lt;/a&gt; are very similar, but have different default values for their order= arguments.)</source>
          <target state="translated">사본의 메모리 레이아웃을 조정합니다. 'C'는 C 순서를, 'F'는 F 순서를, 'A'는 &lt;code&gt;a&lt;/code&gt; 가 포트란 연속 이면 'F' , 그렇지 않으면 'C'를 의미합니다. 'K'수단의 레이아웃과 일치 &lt;code&gt;a&lt;/code&gt; 가능한 가깝게한다. 이 함수와 &lt;a href=&quot;numpy.copy#numpy.copy&quot;&gt; &lt;code&gt;numpy.copy&lt;/code&gt; &lt;/a&gt; 는 매우 유사하지만 order = 인수의 기본값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="0444f926d86651cc3dd5611e09e50dadc271143c" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the copy. &amp;lsquo;C&amp;rsquo; means C-order, &amp;lsquo;F&amp;rsquo; means F-order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; if &lt;code&gt;a&lt;/code&gt; is Fortran contiguous, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means match the layout of &lt;code&gt;a&lt;/code&gt; as closely as possible. (Note that this function and &lt;a href=&quot;numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt;&lt;code&gt;ndarray.copy&lt;/code&gt;&lt;/a&gt; are very similar, but have different default values for their order= arguments.)</source>
          <target state="translated">사본의 메모리 레이아웃을 조정합니다. 'C'는 C 순서를, 'F'는 F 순서를, 'A'는 &lt;code&gt;a&lt;/code&gt; 가 포트란 연속 이면 'F' , 그렇지 않으면 'C'를 의미합니다. 'K'수단의 레이아웃과 일치 &lt;code&gt;a&lt;/code&gt; 가능한 가깝게한다. 이 함수와 &lt;a href=&quot;numpy.ndarray.copy#numpy.ndarray.copy&quot;&gt; &lt;code&gt;ndarray.copy&lt;/code&gt; &lt;/a&gt; 는 매우 유사하지만 order = 인수의 기본값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="87b34e8b0f8ba396e7a4855d6f683c663aa9e3a5" translate="yes" xml:space="preserve">
          <source>Controls the memory layout of the output. &amp;lsquo;C&amp;rsquo; means it should be C contiguous. &amp;lsquo;F&amp;rsquo; means it should be Fortran contiguous, &amp;lsquo;A&amp;rsquo; means it should be &amp;lsquo;F&amp;rsquo; if the inputs are all &amp;lsquo;F&amp;rsquo;, &amp;lsquo;C&amp;rsquo; otherwise. &amp;lsquo;K&amp;rsquo; means it should be as close to the layout as the inputs as is possible, including arbitrarily permuted axes. Default is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">출력의 메모리 레이아웃을 제어합니다. 'C'는 C가 연속적이어야 함을 의미합니다. 'F'는 포트란이 연속적이어야하고 'A'는 입력이 모두 'F'이면 'F'여야하고 그렇지 않으면 'C'임을 의미합니다. 'K'는 임의로 치환 된 축을 포함하여 가능한 한 입력이 레이아웃에 가까워 야 함을 의미합니다. 기본값은 'K'입니다.</target>
        </trans-unit>
        <trans-unit id="914761ad3f3f74151dc575c678b27db7c8a59e79" translate="yes" xml:space="preserve">
          <source>Controls the memory layout order of the result. &amp;lsquo;C&amp;rsquo; means C order, &amp;lsquo;F&amp;rsquo; means Fortran order, &amp;lsquo;A&amp;rsquo; means &amp;lsquo;F&amp;rsquo; order if all the arrays are Fortran contiguous, &amp;lsquo;C&amp;rsquo; order otherwise, and &amp;lsquo;K&amp;rsquo; means as close to the order the array elements appear in memory as possible. Default is &amp;lsquo;K&amp;rsquo;.</source>
          <target state="translated">결과의 메모리 레이아웃 순서를 제어합니다. 'C'는 C 순서, 'F'는 포트란 순서, 'A'는 모든 배열이 포트란 연속 인 경우 'F'순서, 그렇지 않으면 'C'순서, 'K'는 배열 요소가 나타나는 순서에 가까운 것을 의미합니다. 가능한 메모리에. 기본값은 'K'입니다.</target>
        </trans-unit>
        <trans-unit id="2bd2cad71e7b306729d33e9e77734a57f4c762bf" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur when copying.</source>
          <target state="translated">복사시 어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다.</target>
        </trans-unit>
        <trans-unit id="5ffcf55707605cdac52bac56460f15163fa86687" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur when making a copy or buffering. Setting this to &amp;lsquo;unsafe&amp;rsquo; is not recommended, as it can adversely affect accumulations.</source>
          <target state="translated">복사 또는 버퍼링을 수행 할 때 어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다. 이것을 '안전하지 않은'것으로 설정하면 누적에 악영향을 줄 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="fdeee7c21c5f079b8cf1347957a464129f951cd7" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur.</source>
          <target state="translated">어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다.</target>
        </trans-unit>
        <trans-unit id="0c59cf6cbb2c22b8f5a9859f9cb95dc96f349370" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur. Defaults to &amp;lsquo;same_kind&amp;rsquo;.</source>
          <target state="translated">발생할 수있는 데이터 캐스팅의 종류를 제어합니다. 기본값은 'same_kind'입니다.</target>
        </trans-unit>
        <trans-unit id="b10dae3006bf56317c0969243da6568e60665a36" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur. Defaults to &amp;lsquo;unsafe&amp;rsquo; for backwards compatibility.</source>
          <target state="translated">어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다. 이전 버전과의 호환성을 위해 기본값은 '안전하지 않음'입니다.</target>
        </trans-unit>
        <trans-unit id="ef9a6184cd0365349f0a3f3a85fd00227eeb5110" translate="yes" xml:space="preserve">
          <source>Controls what kind of data casting may occur. Setting this to &amp;lsquo;unsafe&amp;rsquo; is not recommended, as it can adversely affect accumulations.</source>
          <target state="translated">어떤 종류의 데이터 캐스팅이 발생할 수 있는지 제어합니다. 이것을 '안전하지 않은'것으로 설정하면 누적에 악영향을 줄 수 있으므로 권장하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a133c6e505fbc7f8c166ced5ad4ae7c59dc57fa0" translate="yes" xml:space="preserve">
          <source>Convenience attributes</source>
          <target state="translated">편의 속성</target>
        </trans-unit>
        <trans-unit id="22a76f139a596a6451b3c663e17254b67d893014" translate="yes" xml:space="preserve">
          <source>Convenience class</source>
          <target state="translated">편의 수업</target>
        </trans-unit>
        <trans-unit id="5b35dc829b5e273f3ad96397576fa3e7d4023d78" translate="yes" xml:space="preserve">
          <source>Convenience constructor</source>
          <target state="translated">편의 생성자</target>
        </trans-unit>
        <trans-unit id="d2fb0b32a197b1bc1c3268b6ce70b10c60d0e61b" translate="yes" xml:space="preserve">
          <source>Convenience function that accepts dimensions as input, e.g., &lt;code&gt;rand(2,2)&lt;/code&gt; would generate a 2-by-2 array of floats, uniformly distributed over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">차원을 입력으로 받아들이는 편의 함수, 예를 들어 &lt;code&gt;rand(2,2)&lt;/code&gt; 는 &lt;code&gt;[0, 1)&lt;/code&gt; 균일하게 분포 된 2x2 부동 소수점 배열을 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="a01257e80e28e1d2f9b1bc8f0a212e62ad583d28" translate="yes" xml:space="preserve">
          <source>Conventional C libraries (installed through &lt;code&gt;add_library&lt;/code&gt;) are not installed, and are just used during the build (they are statically linked). An installable C library is a pure C library, which does not depend on the python C runtime, and is installed such that it may be used by third-party packages. To build and install the C library, you just use the method &lt;code&gt;add_installed_library&lt;/code&gt; instead of &lt;code&gt;add_library&lt;/code&gt;, which takes the same arguments except for an additional &lt;code&gt;install_dir&lt;/code&gt; argument:</source>
          <target state="translated">&lt;code&gt;add_library&lt;/code&gt; 를 통해 설치된 기존의 C 라이브러리 는 설치되지 않으며 빌드 중에 만 사용됩니다 (정적으로 링크되어 있음). 설치 가능한 C 라이브러리는 순수 C 라이브러리이며, Python C 런타임에 의존하지 않으며 타사 패키지에서 사용할 수 있도록 설치됩니다. C 라이브러리를 빌드하고 설치하려면 &lt;code&gt;add_library&lt;/code&gt; 대신 &lt;code&gt;add_installed_library&lt;/code&gt; 메소드를 사용하면됩니다.이 메소드 는 추가 &lt;code&gt;install_dir&lt;/code&gt; 인수를 제외하고 동일한 인수를 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="61856b8c17a4ff32006fe4b7dcc6f96f253b2120" translate="yes" xml:space="preserve">
          <source>Conventions</source>
          <target state="translated">Conventions</target>
        </trans-unit>
        <trans-unit id="9151f8433f795cb0f0b5b6743aeb7de77ec49f00" translate="yes" xml:space="preserve">
          <source>Conversion</source>
          <target state="translated">Conversion</target>
        </trans-unit>
        <trans-unit id="a17fb47b245c5cba5d75f315922fb16fc043d307" translate="yes" xml:space="preserve">
          <source>Conversion Utilities</source>
          <target state="translated">변환 유틸리티</target>
        </trans-unit>
        <trans-unit id="2ca5120be678740ebd6b346bd8c35bf444fe811c" translate="yes" xml:space="preserve">
          <source>Conversion between domains and class types can result in numerically ill defined series.</source>
          <target state="translated">도메인과 클래스 유형 간의 변환으로 인해 숫자가 잘못 정의 된 계열이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d49759ae01851745446d678272b48f3f7fd7110" translate="yes" xml:space="preserve">
          <source>Conversion from other Python structures (e.g., lists, tuples)</source>
          <target state="translated">다른 Python 구조 (예 : 목록, 튜플)에서 변환</target>
        </trans-unit>
        <trans-unit id="164fb2dcb28e63dc48fff2c40f2e5257de488afc" translate="yes" xml:space="preserve">
          <source>Conversion of &lt;code&gt;.src&lt;/code&gt; files</source>
          <target state="translated">&lt;code&gt;.src&lt;/code&gt; 파일 변환</target>
        </trans-unit>
        <trans-unit id="e986bec62e3e7ecaf96128a9c0f40c8e67846882" translate="yes" xml:space="preserve">
          <source>Conversion of &lt;code&gt;.src&lt;/code&gt; files using Templates</source>
          <target state="translated">템플릿을 사용하여 &lt;code&gt;.src&lt;/code&gt; 파일 변환</target>
        </trans-unit>
        <trans-unit id="da46a4c4a17ed3ea61b3092dc001141780833a19" translate="yes" xml:space="preserve">
          <source>Conversion operations</source>
          <target state="translated">변환 작업</target>
        </trans-unit>
        <trans-unit id="e128594adc57501e77fbbaef1687264d9061ef95" translate="yes" xml:space="preserve">
          <source>Conversion; the operations &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt;&lt;code&gt;float()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt;&lt;code&gt;complex()&lt;/code&gt;&lt;/a&gt;. They work only on arrays that have one element in them and return the appropriate scalar.</source>
          <target state="translated">변환; 동작의 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#float&quot;&gt; &lt;code&gt;float()&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt; &lt;code&gt;complex()&lt;/code&gt; &lt;/a&gt; . 하나의 요소가있는 배열에서만 작동하며 적절한 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="10a7c46d2fe217029ff23b380edb9248c804a468" translate="yes" xml:space="preserve">
          <source>Conversion; the operations &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;float&lt;/code&gt; and &lt;code&gt;complex&lt;/code&gt;. . They work only on arrays that have one element in them and return the appropriate scalar.</source>
          <target state="translated">변환; 작업은 &lt;code&gt;int&lt;/code&gt; 로 , &lt;code&gt;float&lt;/code&gt; 과 &lt;code&gt;complex&lt;/code&gt; . . 하나의 요소를 가진 배열에서만 작동하며 적절한 스칼라를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b08eaadf77cfdba7944ddcaf69eee5a983b74af3" translate="yes" xml:space="preserve">
          <source>Conversions</source>
          <target state="translated">Conversions</target>
        </trans-unit>
        <trans-unit id="e5714517e2db28d492b0b79b54a5ada5c2a1521f" translate="yes" xml:space="preserve">
          <source>Conversions between types can be useful, but it is &lt;em&gt;not&lt;/em&gt; recommended for routine use. The loss of numerical precision in passing from a Chebyshev series of degree 50 to a Polynomial series of the same degree can make the results of numerical evaluation essentially random.</source>
          <target state="translated">유형 간 변환이 유용 할 수 있지만 일상적인 사용 &lt;em&gt;에는&lt;/em&gt; 권장 &lt;em&gt;되지 않습니다&lt;/em&gt; . 50 도의 체비 쇼프 계열에서 같은 정도의 다항식 계열로 전달할 때 수치 정밀도가 손실되면 수치 평가 결과가 본질적으로 무작위가 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c9d96d9186d6a7567db34b5b43c63fd3df97932" translate="yes" xml:space="preserve">
          <source>Convert &lt;a href=&quot;../arrays.scalars#numpy.number&quot;&gt;&lt;code&gt;number&lt;/code&gt;&lt;/a&gt; to the &lt;code&gt;base&lt;/code&gt; number system. The valid range is 2-36, the default value is 2.</source>
          <target state="translated">&lt;a href=&quot;../arrays.scalars#numpy.number&quot;&gt; &lt;code&gt;number&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;base&lt;/code&gt; 숫자 체계로 변환 합니다. 유효한 범위는 2-36이고 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="03825a0528753ecd6c491dd8eedf420a0d9f4294" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;bytes&lt;/code&gt; in the encoding used by a subprocess into a filesystem-appropriate &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">변환은 &lt;code&gt;bytes&lt;/code&gt; 파일 시스템에 적합한 구성 프로세스에 의해 사용되는 인코딩 &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c7bd2e378946ee0f1c802ac20f6bf36a9ba9143" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;input&lt;/code&gt; to a Fortran contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt; of the specified type. If the input object is not a Fortran contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt;, a new one will be created and the new object flag will be set.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 을 지정된 유형의 Fortran 연속 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 변환 합니다. 입력 객체가 Fortran 연속 &lt;code&gt;PyArrayObject*&lt;/code&gt; 가 아닌 경우 새로운 객체가 생성되고 새로운 객체 플래그가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="df4f3ea05c4d5f97fc6c549144dbe49c3b958747" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;input&lt;/code&gt; to a NumPy array with the given &lt;code&gt;typecode&lt;/code&gt;. On success, return a valid &lt;code&gt;PyArrayObject*&lt;/code&gt; with the correct type. On failure, the Python error string will be set and the routine returns &lt;code&gt;NULL&lt;/code&gt;.</source>
          <target state="translated">지정된 &lt;code&gt;typecode&lt;/code&gt; 를 사용하여 &lt;code&gt;input&lt;/code&gt; 을 NumPy 배열로 변환하십시오 . 성공하면 올바른 &lt;code&gt;PyArrayObject*&lt;/code&gt; 를 올바른 유형으로 반환 하십시오. 실패하면 Python 오류 문자열이 설정되고 루틴은 &lt;code&gt;NULL&lt;/code&gt; 을 반환 합니다 .</target>
        </trans-unit>
        <trans-unit id="57614032e1d034b46eca1c59ddd0f6d15bf36d4e" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;input&lt;/code&gt; to a contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt; of the specified type. If the input object is not a contiguous &lt;code&gt;PyArrayObject*&lt;/code&gt;, a new one will be created and the new object flag will be set.</source>
          <target state="translated">&lt;code&gt;input&lt;/code&gt; 을 지정된 형식의 인접한 &lt;code&gt;PyArrayObject*&lt;/code&gt; 로 변환 합니다. 입력 객체가 연속 &lt;code&gt;PyArrayObject*&lt;/code&gt; 가 아닌 경우 새로운 객체가 생성되고 새로운 객체 플래그가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="23cf93d55636e18fb2785cd6878809bff7d65f4b" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;number&lt;/code&gt; to the &lt;code&gt;base&lt;/code&gt; number system. The valid range is 2-36, the default value is 2.</source>
          <target state="translated">&lt;code&gt;number&lt;/code&gt; 를 &lt;code&gt;base&lt;/code&gt; 숫자 시스템으로 변환하십시오 . 유효한 범위는 2-36이며 기본값은 2입니다.</target>
        </trans-unit>
        <trans-unit id="f55fe4032611ab151ac35085a484ba4bedcc1c10" translate="yes" xml:space="preserve">
          <source>Convert &lt;code&gt;obj&lt;/code&gt; to an ndarray. The argument can be any nested sequence or object that exports the array interface. This is a macro form of &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; using &lt;code&gt;NULL&lt;/code&gt;, 0, 0, 0 for the other arguments. Your code must be able to handle any data-type descriptor and any combination of data-flags to use this macro.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 를 ndarray로 변환하십시오 . 인수는 배열 인터페이스를 내보내는 중첩 시퀀스 또는 객체 일 수 있습니다. 이것은 다른 인수에 &lt;code&gt;NULL&lt;/code&gt; , 0, 0, 0을 사용 하는 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; &lt;/a&gt; 의 매크로 형식입니다 . 이 매크로를 사용하려면 코드에서 모든 데이터 유형 설명자와 모든 데이터 플래그 조합을 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="03c66978e87b5a27b275061c368f5a6bcf66d726" translate="yes" xml:space="preserve">
          <source>Convert Python strings into one of &lt;a href=&quot;#c.NPY_QUICKSORT&quot;&gt;&lt;code&gt;NPY_QUICKSORT&lt;/code&gt;&lt;/a&gt; (starts with &amp;lsquo;q&amp;rsquo; or &amp;lsquo;Q&amp;rsquo;), &lt;a href=&quot;#c.NPY_HEAPSORT&quot;&gt;&lt;code&gt;NPY_HEAPSORT&lt;/code&gt;&lt;/a&gt; (starts with &amp;lsquo;h&amp;rsquo; or &amp;lsquo;H&amp;rsquo;), &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; (starts with &amp;lsquo;m&amp;rsquo; or &amp;lsquo;M&amp;rsquo;) or &lt;a href=&quot;#c.NPY_STABLESORT&quot;&gt;&lt;code&gt;NPY_STABLESORT&lt;/code&gt;&lt;/a&gt; (starts with &amp;lsquo;t&amp;rsquo; or &amp;lsquo;T&amp;rsquo;). &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt;&lt;code&gt;NPY_MERGESORT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_STABLESORT&quot;&gt;&lt;code&gt;NPY_STABLESORT&lt;/code&gt;&lt;/a&gt; are aliased to each other for backwards compatibility and may refer to one of several stable sorting algorithms depending on the data type.</source>
          <target state="translated">Python 문자열을 &lt;a href=&quot;#c.NPY_QUICKSORT&quot;&gt; &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; &lt;/a&gt; ( 'q'또는 'Q'로 시작 ), &lt;a href=&quot;#c.NPY_HEAPSORT&quot;&gt; &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; &lt;/a&gt; ( 'h'또는 'H'로 시작 ), &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt; ( 'm'또는 'M'로 시작 ) 또는 &lt;a href=&quot;#c.NPY_STABLESORT&quot;&gt; &lt;code&gt;NPY_STABLESORT&lt;/code&gt; &lt;/a&gt; ( '로 시작 ) 중 하나로 변환 합니다. 위법'). &lt;a href=&quot;#c.NPY_MERGESORT&quot;&gt; &lt;code&gt;NPY_MERGESORT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_STABLESORT&quot;&gt; &lt;code&gt;NPY_STABLESORT&lt;/code&gt; &lt;/a&gt; 는 하위 호환성을 위해 서로 별칭이 지정되며 데이터 유형에 따라 몇 가지 안정적인 정렬 알고리즘 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee47953ec8e468154d1d4ca5f75d48f2c6a9ee98" translate="yes" xml:space="preserve">
          <source>Convert Python strings into one of &lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt;&lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;&lt;/a&gt; (starts with &amp;lsquo;l&amp;rsquo; or &amp;lsquo;L&amp;rsquo;), or &lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt;&lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;&lt;/a&gt; (starts with &amp;lsquo;r&amp;rsquo; or &amp;lsquo;R&amp;rsquo;).</source>
          <target state="translated">Python 문자열을 &lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt; &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; &lt;/a&gt; ( 'l'또는 'L'로 시작 ) 또는 &lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt; &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; &lt;/a&gt; ( 'r'또는 'R'로 시작 ) 중 하나로 변환 합니다.</target>
        </trans-unit>
        <trans-unit id="e59da10540b8b045df108e94cbefc0a270a68b5c" translate="yes" xml:space="preserve">
          <source>Convert Python strings into one of &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; (starts with &amp;lsquo;q&amp;rsquo; or &amp;lsquo;Q&amp;rsquo;), &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; (starts with &amp;lsquo;h&amp;rsquo; or &amp;lsquo;H&amp;rsquo;), &lt;code&gt;NPY_MERGESORT&lt;/code&gt; (starts with &amp;lsquo;m&amp;rsquo; or &amp;lsquo;M&amp;rsquo;) or &lt;code&gt;NPY_STABLESORT&lt;/code&gt; (starts with &amp;lsquo;t&amp;rsquo; or &amp;lsquo;T&amp;rsquo;). &lt;code&gt;NPY_MERGESORT&lt;/code&gt; and &lt;code&gt;NPY_STABLESORT&lt;/code&gt; are aliased to each other for backwards compatibility and may refer to one of several stable sorting algorithms depending on the data type.</source>
          <target state="translated">Python 문자열을 &lt;code&gt;NPY_QUICKSORT&lt;/code&gt; ( 'q'또는 'Q'로 시작 ), &lt;code&gt;NPY_HEAPSORT&lt;/code&gt; ( 'h'또는 'H'로 시작 ), &lt;code&gt;NPY_MERGESORT&lt;/code&gt; ( 'm'또는 'M'로 시작 ) 또는 &lt;code&gt;NPY_STABLESORT&lt;/code&gt; ( '로 시작 ) 중 하나로 변환 위법'). &lt;code&gt;NPY_MERGESORT&lt;/code&gt; 와 &lt;code&gt;NPY_STABLESORT&lt;/code&gt; 는 이전 버전과의 호환성을 위해 서로 별명을 지정하며 데이터 유형에 따라 몇 가지 안정적인 정렬 알고리즘 중 하나를 참조 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3306f9c5860e043187dbc26b17cfa1986c3541ca" translate="yes" xml:space="preserve">
          <source>Convert Python strings into one of &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; (starts with &amp;lsquo;l&amp;rsquo; or &amp;lsquo;L&amp;rsquo;), or &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; (starts with &amp;lsquo;r&amp;rsquo; or &amp;lsquo;R&amp;rsquo;).</source>
          <target state="translated">Python 문자열을 &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; ( 'l'또는 'L'로 시작 ) 또는 &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; ( 'r'또는 'R'로 시작 ) 중 하나로 변환하십시오 .</target>
        </trans-unit>
        <trans-unit id="9665692749eb5f8271a8ef2c2766c29e0fe1a31a" translate="yes" xml:space="preserve">
          <source>Convert Python strings into the corresponding byte-order character: &amp;lsquo;&amp;gt;&amp;rsquo;, &amp;lsquo;&amp;lt;&amp;rsquo;, &amp;lsquo;s&amp;rsquo;, &amp;lsquo;=&amp;rsquo;, or &amp;lsquo;|&amp;rsquo;.</source>
          <target state="translated">Python 문자열을 해당 바이트 순서 문자 ( '&amp;gt;', '&amp;lt;', 's', '='또는 '|')로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="0249cb69b2094a04bbecaea9fed7d306da9e809a" translate="yes" xml:space="preserve">
          <source>Convert a /-separated pathname to one using the OS&amp;rsquo;s path separator.</source>
          <target state="translated">OS의 경로 구분 기호를 사용하여 /로 구분 된 경로 이름을 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="bbbde2984253b6c19463182f3ab3e49eacf0add1" translate="yes" xml:space="preserve">
          <source>Convert a Chebyshev series to a polynomial.</source>
          <target state="translated">Chebyshev 계열을 다항식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3b725963ae7233b84da188095a5261995f877a10" translate="yes" xml:space="preserve">
          <source>Convert a Hermite series to a polynomial.</source>
          <target state="translated">Hermite 계열을 다항식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c5774d379d320ad666e23c93d53c895b9282a781" translate="yes" xml:space="preserve">
          <source>Convert a Laguerre series to a polynomial.</source>
          <target state="translated">Laguerre 계열을 다항식으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="c0cba427e743f4d7f6bd18952bc7a604ed734f1a" translate="yes" xml:space="preserve">
          <source>Convert a Legendre series to a polynomial.</source>
          <target state="translated">Legendre 시리즈를 다항식으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="7303080b96152a0bf0712c8711af50deecda280f" translate="yes" xml:space="preserve">
          <source>Convert a Python object, &lt;em&gt;obj&lt;/em&gt;, representing an axis argument to the proper value for passing to the functions that take an integer axis. Specifically, if &lt;em&gt;obj&lt;/em&gt; is None, &lt;em&gt;axis&lt;/em&gt; is set to &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; which is interpreted correctly by the C-API functions that take axis arguments.</source>
          <target state="translated">축 인수를 나타내는 Python 객체 &lt;em&gt;obj를&lt;/em&gt; 정수 축을 취하는 함수에 전달하기위한 적절한 값으로 변환합니다 . 특히 &lt;em&gt;obj&lt;/em&gt; 가 None 인 경우 &lt;em&gt;축은 &lt;/em&gt;&lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 로 설정되며 축 인수를 사용하는 C-API 함수에 의해 올바르게 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="cb9724a7e14228c2698abcf68b1a251a0ae3b8f5" translate="yes" xml:space="preserve">
          <source>Convert a degree array to radians</source>
          <target state="translated">도 배열을 라디안으로 변환</target>
        </trans-unit>
        <trans-unit id="a5c1e0427139c907d167379333f020dfcf76dbc2" translate="yes" xml:space="preserve">
          <source>Convert a dtype into a ctypes type.</source>
          <target state="translated">dtype을 ctypes 유형으로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="04cea7e04fb2eca83318942c92f1c07b960f13bf" translate="yes" xml:space="preserve">
          <source>Convert a flat index into an index tuple.</source>
          <target state="translated">플랫 인덱스를 인덱스 튜플로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="608694c52c4ebed3a5e39984190479f5e8a306e1" translate="yes" xml:space="preserve">
          <source>Convert a list into an array. If all elements are finite &lt;code&gt;asarray_chkfinite&lt;/code&gt; is identical to &lt;code&gt;asarray&lt;/code&gt;.</source>
          <target state="translated">리스트를 배열로 변환합니다. 모든 요소가 유한 한 경우 &lt;code&gt;asarray_chkfinite&lt;/code&gt; 이 동일 &lt;code&gt;asarray&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c03ed6ac231e004466351d76fc80aa6d480fc3b7" translate="yes" xml:space="preserve">
          <source>Convert a list into an array:</source>
          <target state="translated">리스트를 배열로 변환합니다 :</target>
        </trans-unit>
        <trans-unit id="9c374ac29e69d14674f6d6142f266b0eef36664b" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Chebyshev series.</source>
          <target state="translated">다항식을 체비 쇼프 시리즈로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b5c9ed7a8b3e04ef89c09d23b7d0d8b444f0ef50" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Hermite series.</source>
          <target state="translated">다항식을 Hermite 시리즈로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4e3ec08396dbbd66882318c251a298df01079281" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Laguerre series.</source>
          <target state="translated">다항식을 Laguerre 계열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="04c048566837ee3c2a27ff8795d4c53f80b84281" translate="yes" xml:space="preserve">
          <source>Convert a polynomial to a Legendre series.</source>
          <target state="translated">다항식을 Legendre 시리즈로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="030db426d65b1085bdfe94fd49af9bb5148d5b11" translate="yes" xml:space="preserve">
          <source>Convert a radian array to degrees</source>
          <target state="translated">라디안 배열을도 단위로 변환</target>
        </trans-unit>
        <trans-unit id="1fe8f7480d0d47cc60a5977befc1bf0fb1c97374" translate="yes" xml:space="preserve">
          <source>Convert a sequence of Python objects contained in &lt;em&gt;op&lt;/em&gt; to an array of ndarrays each having the same data type. The type is selected based on the typenumber (larger type number is chosen over a smaller one) ignoring objects that are only scalars. The length of the sequence is returned in &lt;em&gt;n&lt;/em&gt;, and an &lt;em&gt;n&lt;/em&gt; -length array of &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; pointers is the return value (or &lt;code&gt;NULL&lt;/code&gt; if an error occurs). The returned array must be freed by the caller of this routine (using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; ) and all the array objects in it &lt;code&gt;DECREF&lt;/code&gt; &amp;lsquo;d or a memory-leak will occur. The example template-code below shows a typically usage:</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 에 포함 된 일련의 Python 객체를 각각 동일한 데이터 유형을 가진 ndarray의 배열로 변환합니다. 유형은 스칼라 만있는 객체를 무시하고 typenumber (작은 유형 번호가 작은 것보다 선택됨)를 기준으로 선택됩니다. 시퀀스의 길이는 &lt;em&gt;n&lt;/em&gt; 으로 리턴되고 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 포인터 의 &lt;em&gt;n&lt;/em&gt; 길이 배열은 리턴 값입니다 (또는 오류가 발생하면 &lt;code&gt;NULL&lt;/code&gt; ). 반환 된 배열은이 루틴의 호출자 ( &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt; &lt;code&gt;PyDataMem_FREE&lt;/code&gt; &lt;/a&gt; 사용 )에 의해 해제되어야 하고 &lt;code&gt;DECREF&lt;/code&gt; 'd에 있는 모든 배열 객체 가 발생하거나 메모리 누수가 발생합니다. 아래의 예제 코드는 일반적인 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="69e79437d732a587d606f77d7f2799ba6ddc4e29" translate="yes" xml:space="preserve">
          <source>Convert a sequence of Python objects contained in &lt;em&gt;op&lt;/em&gt; to an array of ndarrays each having the same data type. The type is selected in the same way as &lt;code&gt;PyArray_ResultType&lt;/code&gt;. The length of the sequence is returned in &lt;em&gt;n&lt;/em&gt;, and an &lt;em&gt;n&lt;/em&gt; -length array of &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; pointers is the return value (or &lt;code&gt;NULL&lt;/code&gt; if an error occurs). The returned array must be freed by the caller of this routine (using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; ) and all the array objects in it &lt;code&gt;DECREF&lt;/code&gt; &amp;lsquo;d or a memory-leak will occur. The example template-code below shows a typically usage:</source>
          <target state="translated">&lt;em&gt;op&lt;/em&gt; 에 포함 된 Python 객체 시퀀스를 각각 동일한 데이터 유형을 가진 ndarray 배열로 변환합니다. 유형은 &lt;code&gt;PyArray_ResultType&lt;/code&gt; 과 같은 방식으로 선택됩니다 . 시퀀스의 길이는 &lt;em&gt;n&lt;/em&gt; 으로 반환되고 , &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; &lt;/a&gt; 포인터 의 &lt;em&gt;n&lt;/em&gt; 길이 배열은 반환 값 (또는 오류가 발생하면 &lt;code&gt;NULL&lt;/code&gt; )입니다. 반환 된 배열은이 루틴의 호출자 ( &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt; &lt;code&gt;PyDataMem_FREE&lt;/code&gt; &lt;/a&gt; 사용 )에 의해 해제되어야하며 그 안의 모든 배열 객체는 &lt;code&gt;DECREF&lt;/code&gt; 'd 그렇지 않으면 메모리 누수가 발생합니다. 아래의 예제 템플릿 코드는 일반적인 사용법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="e101ec3d7ab1b665f48ac2d543089565c86aa54e" translate="yes" xml:space="preserve">
          <source>Convert all kinds of Python objects (including arrays and array scalars) to a (platform-pointer-sized) integer. On error, -1 is returned and an exception set.</source>
          <target state="translated">모든 종류의 Python 객체 (배열 및 배열 스칼라 포함)를 (플랫폼 포인터 크기) 정수로 변환합니다. 오류가 발생하면 -1이 반환되고 예외가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="1af2928a63dcb1e8b49b18ef5eb4581fbe6b1379" translate="yes" xml:space="preserve">
          <source>Convert all kinds of Python objects (including arrays and array scalars) to a standard integer. On error, -1 is returned and an exception set. You may find useful the macro:</source>
          <target state="translated">모든 종류의 Python 객체 (배열 및 배열 스칼라 포함)를 표준 정수로 변환합니다. 오류가 발생하면 -1이 반환되고 예외가 설정됩니다. 당신은 유용한 매크로를 찾을 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="ffbc378826f57347e9c8260b31120c1a5833498c" translate="yes" xml:space="preserve">
          <source>Convert an array of datetimes into an array of strings.</source>
          <target state="translated">날짜 시간 배열을 문자열 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="037f70609a1c007309e108da24f60e5d131632f5" translate="yes" xml:space="preserve">
          <source>Convert an array of size 1 to its scalar equivalent.</source>
          <target state="translated">크기가 1 인 배열을 스칼라 단위로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="53df29e4ff05ae420cc48926e99a3b9e70512010" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Chebyshev series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">체비 쇼프 계열의 계수를 나타내는 배열을 가장 낮은 차수에서 가장 높은 차수로 정렬하고 등가 다항식 ( &quot;표준&quot;기준과 비교하여)의 차수로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="6e39db716cf38d73c2e1474b5348e35ad5d45d64" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Hermite series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">최저 등급에서 최고 등급으로 정렬 된 Hermite 계열의 계수를 나타내는 배열을 최저 등급에서 최고 등급으로 정렬 된 등가 다항식 ( &quot;표준&quot;기준)의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="8d92a2c5d4792677ccffae0416bcb9beb6eb167c" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Laguerre series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">Laguerre 계열의 계수를 나타내는 배열을 가장 낮은 차수에서 가장 높은 차수로 정렬하고 등가 다항식 ( &quot;표준&quot;기준과 비교하여)의 차수로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="a288bed0f35723755d6a37566e44ab92c6ecb769" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a Legendre series, ordered from lowest degree to highest, to an array of the coefficients of the equivalent polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest to highest degree.</source>
          <target state="translated">Legendre 시리즈의 계수를 나타내는 배열을 가장 낮은 차수에서 가장 높은 차수로 정렬하고 등가 다항식 ( &quot;표준&quot;기준을 기준으로)의 차수로 배열합니다.</target>
        </trans-unit>
        <trans-unit id="8f863e3ceaa930790565bf1f263428f91f82dc05" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Chebyshev series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준에 따라)의 계수를 나타내는 배열을 최저에서 최고로 정렬 된 동등한 체비 쇼프 계열의 계수의 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="77ebeb329b7c408d6e1a1754f29dec3917a76884" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Hermite series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준에 따라)의 계수를 나타내는 배열을 최저에서 최고까지 정렬 된 동등한 Hermite 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="5d3f4ebc3ae40ac476278051222e82a2168385fe" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Laguerre series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준에 따라)의 계수를 나타내는 배열을 최저에서 최고로 정렬 된 동등한 Laguerre 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="cec81c86dbe89e8d496cab1ec6207291b41341cd" translate="yes" xml:space="preserve">
          <source>Convert an array representing the coefficients of a polynomial (relative to the &amp;ldquo;standard&amp;rdquo; basis) ordered from lowest degree to highest, to an array of the coefficients of the equivalent Legendre series, ordered from lowest to highest degree.</source>
          <target state="translated">최저에서 최고로 정렬 된 다항식 ( &quot;표준&quot;기준)의 계수를 나타내는 배열을 최저에서 최고로 정렬 된 동등한 Legendre 계열의 계수 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4b17b279b5dccfd644af2817f95777400cf1861d" translate="yes" xml:space="preserve">
          <source>Convert angles from degrees to radians.</source>
          <target state="translated">각도를도에서 라디안으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7b990b4a48262db5915c35fe0989adfb1e63af66" translate="yes" xml:space="preserve">
          <source>Convert angles from radians to degrees.</source>
          <target state="translated">각도를 라디안에서 각도로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="45815db69ac2df469f002b3c383b11df15d3fe0f" translate="yes" xml:space="preserve">
          <source>Convert any Python object to a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;obj&lt;/em&gt;) is TRUE then its reference count is incremented and a reference placed in &lt;em&gt;address&lt;/em&gt;. If &lt;em&gt;obj&lt;/em&gt; is not an array, then convert it to an array using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; . No matter what is returned, you must DECREF the object returned by this routine in &lt;em&gt;address&lt;/em&gt; when you are done with it.</source>
          <target state="translated">Python 객체를 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 로&lt;/a&gt; 변환하십시오 . 경우 &lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;obj가&lt;/em&gt; ) TRUE 인 다음의 기준 카운트는 증분되고 참조가 배치 &lt;em&gt;주소&lt;/em&gt; . &lt;em&gt;obj&lt;/em&gt; 가 배열이 아닌 경우 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 를&lt;/a&gt; 사용하여 배열로 변환하십시오 . 리턴 된 내용에 관계없이이 루틴이 리턴 한 오브젝트를 &lt;em&gt;주소&lt;/em&gt; 로 처리해야합니다.</target>
        </trans-unit>
        <trans-unit id="0b6da37e7cce779d1f71c021678852cf78adef4f" translate="yes" xml:space="preserve">
          <source>Convert any Python object to a &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;#c.PyArray_Check&quot;&gt;&lt;code&gt;PyArray_Check&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;obj&lt;/em&gt;) is TRUE then its reference count is incremented and a reference placed in &lt;em&gt;address&lt;/em&gt;. If &lt;em&gt;obj&lt;/em&gt; is not an array, then convert it to an array using &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt;&lt;code&gt;PyArray_FromAny&lt;/code&gt;&lt;/a&gt; . No matter what is returned, you must DECREF the object returned by this routine in &lt;em&gt;address&lt;/em&gt; when you are done with it.</source>
          <target state="translated">Python 객체를 &lt;a href=&quot;types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 로&lt;/a&gt; 변환합니다 . 경우 &lt;a href=&quot;#c.PyArray_Check&quot;&gt; &lt;code&gt;PyArray_Check&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;obj가&lt;/em&gt; ) TRUE 인 다음의 기준 카운트는 증분되고 참조가 배치 &lt;em&gt;주소&lt;/em&gt; . 경우 &lt;em&gt;obj가&lt;/em&gt; 배열이 아닌, 다음 사용하여 배열로 변환 &lt;a href=&quot;#c.PyArray_FromAny&quot;&gt; &lt;code&gt;PyArray_FromAny&lt;/code&gt; 을&lt;/a&gt; . 반환되는 내용에 관계없이이 루틴이 반환 한 객체를 &lt;em&gt;주소&lt;/em&gt; 에서 DECREF해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2c520cfad3eae214eac5cb30701aacd3d0256a7c" translate="yes" xml:space="preserve">
          <source>Convert any Python object, &lt;em&gt;obj&lt;/em&gt;, to &lt;a href=&quot;#c.NPY_TRUE&quot;&gt;&lt;code&gt;NPY_TRUE&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_FALSE&quot;&gt;&lt;code&gt;NPY_FALSE&lt;/code&gt;&lt;/a&gt;, and place the result in &lt;em&gt;value&lt;/em&gt;.</source>
          <target state="translated">Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;a href=&quot;#c.NPY_TRUE&quot;&gt; &lt;code&gt;NPY_TRUE&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_FALSE&quot;&gt; &lt;code&gt;NPY_FALSE&lt;/code&gt; 로&lt;/a&gt; 변환 하고 결과를 &lt;em&gt;value에&lt;/em&gt; 배치하십시오 .</target>
        </trans-unit>
        <trans-unit id="1f11d66b7da05915fa0d0dcb369cc6d4a2e56d6e" translate="yes" xml:space="preserve">
          <source>Convert any Python object, &lt;em&gt;obj&lt;/em&gt;, with a (single-segment) buffer interface to a variable with members that detail the object&amp;rsquo;s use of its chunk of memory. The &lt;em&gt;buf&lt;/em&gt; variable is a pointer to a structure with base, ptr, len, and flags members. The &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Chunk&quot;&gt;&lt;code&gt;PyArray_Chunk&lt;/code&gt;&lt;/a&gt; structure is binary compatible with the Python&amp;rsquo;s buffer object (through its len member on 32-bit platforms and its ptr member on 64-bit platforms or in Python 2.5). On return, the base member is set to &lt;em&gt;obj&lt;/em&gt; (or its base if &lt;em&gt;obj&lt;/em&gt; is already a buffer object pointing to another object). If you need to hold on to the memory be sure to INCREF the base member. The chunk of memory is pointed to by &lt;em&gt;buf&lt;/em&gt; -&amp;gt;ptr member and has length &lt;em&gt;buf&lt;/em&gt; -&amp;gt;len. The flags member of &lt;em&gt;buf&lt;/em&gt; is &lt;code&gt;NPY_BEHAVED_RO&lt;/code&gt; with the &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag set if &lt;em&gt;obj&lt;/em&gt; has a writeable buffer interface.</source>
          <target state="translated">(단일 세그먼트) 버퍼 인터페이스가있는 Python 객체 &lt;em&gt;obj를&lt;/em&gt; 객체의 메모리 청크 사용을 자세히 설명하는 멤버가있는 변수로 변환합니다. &lt;em&gt;버피&lt;/em&gt; 변수베이스 PTR, 렌 및 플래그 부재와 구조에 대한 포인터이다. &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Chunk&quot;&gt; &lt;code&gt;PyArray_Chunk&lt;/code&gt; 의&lt;/a&gt; 구조 (32 비트 플랫폼의 LEN 부재 및 64 비트 플랫폼 파이썬 2.5 PTR의 부재를 통해) 파이썬 버퍼 객체 바이너리 호환. 돌아 왔을 때,베이스 멤버는 &lt;em&gt;obj&lt;/em&gt; (또는 &lt;em&gt;obj&lt;/em&gt; 가 다른 오브젝트를 가리키는 버퍼 오브젝트 인 경우 는 그베이스 )로 설정됩니다. 메모리를 잡아야하는 경우 반드시베이스 멤버를 INCREF해야합니다. 메모리 청크는 &lt;em&gt;buf-&lt;/em&gt; &amp;gt; ptr 멤버로 가리키며 길이가 있습니다.&lt;em&gt;buf-&lt;/em&gt; &amp;gt; len. &lt;em&gt;obj&lt;/em&gt; 에 쓰기 가능한 버퍼 인터페이스가있는 경우 &lt;em&gt;buf&lt;/em&gt; 의 플래그 멤버 는 &lt;code&gt;NPY_BEHAVED_RO&lt;/code&gt; 이며 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그가 설정됩니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="40c32dc7f8fe2c5bf726d5fa1a1402d6dd61da0b" translate="yes" xml:space="preserve">
          <source>Convert any Python object, &lt;em&gt;obj&lt;/em&gt;, with a (single-segment) buffer interface to a variable with members that detail the object&amp;rsquo;s use of its chunk of memory. The &lt;em&gt;buf&lt;/em&gt; variable is a pointer to a structure with base, ptr, len, and flags members. The &lt;a href=&quot;types-and-structures#c.PyArray_Chunk&quot;&gt;&lt;code&gt;PyArray_Chunk&lt;/code&gt;&lt;/a&gt; structure is binary compatible with the Python&amp;rsquo;s buffer object (through its len member on 32-bit platforms and its ptr member on 64-bit platforms or in Python 2.5). On return, the base member is set to &lt;em&gt;obj&lt;/em&gt; (or its base if &lt;em&gt;obj&lt;/em&gt; is already a buffer object pointing to another object). If you need to hold on to the memory be sure to INCREF the base member. The chunk of memory is pointed to by &lt;em&gt;buf&lt;/em&gt; -&amp;gt;ptr member and has length &lt;em&gt;buf&lt;/em&gt; -&amp;gt;len. The flags member of &lt;em&gt;buf&lt;/em&gt; is &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt;&lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt;&lt;/a&gt; with the &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag set if &lt;em&gt;obj&lt;/em&gt; has a writeable buffer interface.</source>
          <target state="translated">(단일 세그먼트) 버퍼 인터페이스가있는 Python 객체 &lt;em&gt;obj를&lt;/em&gt; 객체의 메모리 청크 사용을 자세히 설명하는 멤버가있는 변수로 변환합니다. &lt;em&gt;버피&lt;/em&gt; 변수베이스 PTR, 렌 및 플래그 부재와 구조에 대한 포인터이다. &lt;a href=&quot;types-and-structures#c.PyArray_Chunk&quot;&gt; &lt;code&gt;PyArray_Chunk&lt;/code&gt; 의&lt;/a&gt; 구조 (32 비트 플랫폼의 LEN 부재 및 64 비트 플랫폼 파이썬 2.5 PTR의 부재를 통해) 파이썬 버퍼 객체 바이너리 호환. 반환시 기본 멤버는 &lt;em&gt;obj&lt;/em&gt; (또는 &lt;em&gt;obj&lt;/em&gt; 가 이미 다른 개체를 가리키는 버퍼 개체 인 경우 기본 멤버)로 설정됩니다 . 메모리를 유지해야하는 경우 기본 멤버를 INCREF해야합니다. 메모리 덩어리는 &lt;em&gt;buf-&lt;/em&gt; &amp;gt; ptr 멤버 가 가리키고 길이가 있습니다.&lt;em&gt;buf-&lt;/em&gt; &amp;gt; len. 플래그의 부재 &lt;em&gt;BUF가&lt;/em&gt; 된다 &lt;a href=&quot;#c.NPY_ARRAY_ALIGNED&quot;&gt; &lt;code&gt;NPY_ARRAY_ALIGNED&lt;/code&gt; &lt;/a&gt; 으로 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 경우 플래그가 설정 &lt;em&gt;obj가&lt;/em&gt; 기록 가능한 버퍼 인터페이스를 갖는다.</target>
        </trans-unit>
        <trans-unit id="569900dcf7d509c01e8e49d0b1d6eec3e381fdec" translate="yes" xml:space="preserve">
          <source>Convert any Python object, &lt;em&gt;obj&lt;/em&gt;, with a (single-segment) buffer interface to a variable with members that detail the object&amp;rsquo;s use of its chunk of memory. The &lt;em&gt;buf&lt;/em&gt; variable is a pointer to a structure with base, ptr, len, and flags members. The &lt;a href=&quot;types-and-structures#c.PyArray_Chunk&quot;&gt;&lt;code&gt;PyArray_Chunk&lt;/code&gt;&lt;/a&gt; structure is binary compatible with the Python&amp;rsquo;s buffer object (through its len member on 32-bit platforms and its ptr member on 64-bit platforms or in Python 2.5). On return, the base member is set to &lt;em&gt;obj&lt;/em&gt; (or its base if &lt;em&gt;obj&lt;/em&gt; is already a buffer object pointing to another object). If you need to hold on to the memory be sure to INCREF the base member. The chunk of memory is pointed to by &lt;em&gt;buf&lt;/em&gt; -&amp;gt;ptr member and has length &lt;em&gt;buf&lt;/em&gt; -&amp;gt;len. The flags member of &lt;em&gt;buf&lt;/em&gt; is &lt;code&gt;NPY_BEHAVED_RO&lt;/code&gt; with the &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag set if &lt;em&gt;obj&lt;/em&gt; has a writeable buffer interface.</source>
          <target state="translated">(단일 세그먼트) 버퍼 인터페이스가있는 Python 객체 &lt;em&gt;obj를&lt;/em&gt; 객체의 메모리 청크 사용을 자세히 설명하는 멤버가있는 변수로 변환합니다. &lt;em&gt;버피&lt;/em&gt; 변수베이스 PTR, 렌 및 플래그 부재와 구조에 대한 포인터이다. &lt;a href=&quot;types-and-structures#c.PyArray_Chunk&quot;&gt; &lt;code&gt;PyArray_Chunk&lt;/code&gt; 의&lt;/a&gt; 구조 (32 비트 플랫폼의 LEN 부재 및 64 비트 플랫폼 파이썬 2.5 PTR의 부재를 통해) 파이썬 버퍼 객체 바이너리 호환. 반환시 기본 멤버는 &lt;em&gt;obj&lt;/em&gt; (또는 &lt;em&gt;obj&lt;/em&gt; 가 이미 다른 개체를 가리키는 버퍼 개체 인 경우 기본 멤버)로 설정됩니다 . 메모리를 유지해야하는 경우 기본 멤버를 INCREF해야합니다. 메모리 덩어리는 &lt;em&gt;buf-&lt;/em&gt; &amp;gt; ptr 멤버 가 가리키고 길이가 있습니다.&lt;em&gt;buf-&lt;/em&gt; &amp;gt; len. 플래그의 부재 &lt;em&gt;BUF가&lt;/em&gt; 있다 &lt;code&gt;NPY_BEHAVED_RO&lt;/code&gt; 와 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 경우 플래그가 설정 &lt;em&gt;obj가&lt;/em&gt; 기록 가능한 버퍼 인터페이스를 갖는다.</target>
        </trans-unit>
        <trans-unit id="c75a292870c1a62f954752682b5e4d2572c8fb49" translate="yes" xml:space="preserve">
          <source>Convert any Python sequence (or single Python number) passed in as &lt;em&gt;seq&lt;/em&gt; to (up to) &lt;em&gt;maxvals&lt;/em&gt; pointer-sized integers and place them in the &lt;em&gt;vals&lt;/em&gt; array. The sequence can be smaller then &lt;em&gt;maxvals&lt;/em&gt; as the number of converted objects is returned.</source>
          <target state="translated">&lt;em&gt;seq&lt;/em&gt; 로 전달 된 모든 Python 시퀀스 (또는 단일 Python 번호) 를 최대 포인터 크기의 정수 (최대)까지 &lt;em&gt;변환&lt;/em&gt; 하고 &lt;em&gt;vals&lt;/em&gt; 배열 에 배치합니다 . 변환 된 오브젝트의 수가 리턴 될 때 순서는 &lt;em&gt;maxvals&lt;/em&gt; 보다 작을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fa9c12af167e2e17ab265f1ff4c7ad781660a664" translate="yes" xml:space="preserve">
          <source>Convert any Python sequence, &lt;em&gt;obj&lt;/em&gt;, smaller than &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; to a C-array of &lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt;&lt;code&gt;npy_intp&lt;/code&gt;&lt;/a&gt;. The Python object could also be a single number. The &lt;em&gt;seq&lt;/em&gt; variable is a pointer to a structure with members ptr and len. On successful return, &lt;em&gt;seq&lt;/em&gt; -&amp;gt;ptr contains a pointer to memory that must be freed, by calling &lt;a href=&quot;#c.PyDimMem_FREE&quot;&gt;&lt;code&gt;PyDimMem_FREE&lt;/code&gt;&lt;/a&gt;, to avoid a memory leak. The restriction on memory size allows this converter to be conveniently used for sequences intended to be interpreted as array shapes.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 보다 작은 Python 시퀀스 &lt;em&gt;obj&lt;/em&gt; 를 npy_intp 의 C- 배열로 &lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt; &lt;code&gt;npy_intp&lt;/code&gt; &lt;/a&gt; . Python 객체는 단일 숫자 일 수도 있습니다. &lt;em&gt;서열의&lt;/em&gt; 변수는 렌과 PTR 회원들과 구조에 대한 포인터입니다. 성공적인 복귀에 &lt;em&gt;서열&lt;/em&gt; -&amp;gt; PTR은 호출하여 해제해야 메모리에 대한 포인터를 포함 &lt;a href=&quot;#c.PyDimMem_FREE&quot;&gt; &lt;code&gt;PyDimMem_FREE&lt;/code&gt; 을&lt;/a&gt; 메모리 누수를 방지하기를. 메모리 크기 제한으로 인해이 변환기는 배열 형태로 해석되는 시퀀스에 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddbd151db3f713081a3e638e5a5727e61847e905" translate="yes" xml:space="preserve">
          <source>Convert any Python sequence, &lt;em&gt;obj&lt;/em&gt;, smaller than &lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt;&lt;code&gt;NPY_MAXDIMS&lt;/code&gt;&lt;/a&gt; to a C-array of &lt;a href=&quot;dtype#c.npy_intp&quot;&gt;&lt;code&gt;npy_intp&lt;/code&gt;&lt;/a&gt;. The Python object could also be a single number. The &lt;em&gt;seq&lt;/em&gt; variable is a pointer to a structure with members ptr and len. On successful return, &lt;em&gt;seq&lt;/em&gt; -&amp;gt;ptr contains a pointer to memory that must be freed, by calling &lt;a href=&quot;#c.PyDimMem_FREE&quot;&gt;&lt;code&gt;PyDimMem_FREE&lt;/code&gt;&lt;/a&gt;, to avoid a memory leak. The restriction on memory size allows this converter to be conveniently used for sequences intended to be interpreted as array shapes.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_MAXDIMS&quot;&gt; &lt;code&gt;NPY_MAXDIMS&lt;/code&gt; &lt;/a&gt; 보다 작은 Python 시퀀스 &lt;em&gt;obj&lt;/em&gt; 를 npy_intp 의 C 배열로 &lt;a href=&quot;dtype#c.npy_intp&quot;&gt; &lt;code&gt;npy_intp&lt;/code&gt; &lt;/a&gt; 합니다. Python 객체는 단일 숫자 일 수도 있습니다. &lt;em&gt;서열의&lt;/em&gt; 변수는 렌과 PTR 회원들과 구조에 대한 포인터입니다. 성공적인 복귀에 &lt;em&gt;서열&lt;/em&gt; -&amp;gt; PTR은 호출하여 해제해야 메모리에 대한 포인터를 포함 &lt;a href=&quot;#c.PyDimMem_FREE&quot;&gt; &lt;code&gt;PyDimMem_FREE&lt;/code&gt; 을&lt;/a&gt; 메모리 누수를 방지하기를. 메모리 크기에 대한 제한으로 인해이 변환기는 배열 모양으로 해석되는 시퀀스에 편리하게 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ed619a93f21a46ce5e25c505085d53ca9e82da5b" translate="yes" xml:space="preserve">
          <source>Convert any compatible Python object, &lt;em&gt;obj&lt;/em&gt;, to a data-type object in &lt;em&gt;dtype&lt;/em&gt;. A large number of Python objects can be converted to data-type objects. See &lt;a href=&quot;../arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt; for a complete description. This version of the converter converts None objects to a &lt;a href=&quot;dtype#c.NPY_DEFAULT_TYPE&quot;&gt;&lt;code&gt;NPY_DEFAULT_TYPE&lt;/code&gt;&lt;/a&gt; data-type object. This function can be used with the &amp;ldquo;O&amp;amp;&amp;rdquo; character code in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; processing.</source>
          <target state="translated">호환되는 Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;dtype&lt;/em&gt; 의 데이터 유형 객체로 &lt;em&gt;변환&lt;/em&gt; 합니다. 많은 수의 Python 객체를 데이터 유형 객체로 변환 할 수 있습니다. 자세한 설명은 &lt;a href=&quot;../arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체 (dtype)&lt;/a&gt; 를 참조하세요 . 이 버전의 변환기는 None 개체를 &lt;a href=&quot;dtype#c.NPY_DEFAULT_TYPE&quot;&gt; &lt;code&gt;NPY_DEFAULT_TYPE&lt;/code&gt; &lt;/a&gt; 데이터 형식 개체 로 변환 합니다. 이 함수는 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 처리 에서 &quot;O &amp;amp;&quot;문자 코드와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69da68263fbc339b854ebcf71b991e1eb9b1a25a" translate="yes" xml:space="preserve">
          <source>Convert any compatible Python object, &lt;em&gt;obj&lt;/em&gt;, to a data-type object in &lt;em&gt;dtype&lt;/em&gt;. A large number of Python objects can be converted to data-type objects. See &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt; for a complete description. This version of the converter converts None objects to a &lt;a href=&quot;c-api.dtype#c.NPY_DEFAULT_TYPE&quot;&gt;&lt;code&gt;NPY_DEFAULT_TYPE&lt;/code&gt;&lt;/a&gt; data-type object. This function can be used with the &amp;ldquo;O&amp;amp;&amp;rdquo; character code in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; processing.</source>
          <target state="translated">호환 가능한 Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;dtype&lt;/em&gt; 의 데이터 유형 객체로 &lt;em&gt;변환&lt;/em&gt; 합니다. 많은 수의 Python 객체를 데이터 유형 객체로 변환 할 수 있습니다. 자세한 설명은 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 오브젝트 (dtype)&lt;/a&gt; 를 참조하십시오 . 이 버전의 변환기는 None 개체를 &lt;a href=&quot;c-api.dtype#c.NPY_DEFAULT_TYPE&quot;&gt; &lt;code&gt;NPY_DEFAULT_TYPE&lt;/code&gt; &lt;/a&gt; 데이터 형식 개체 로 변환 합니다. 이 기능은 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; 처리 에서 &quot;O &amp;amp;&quot;문자 코드와 함께 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="76aa53d3435e68fd8a448322e838d44b487cd7d8" translate="yes" xml:space="preserve">
          <source>Convert any compatible Python object, &lt;em&gt;obj&lt;/em&gt;, to a data-type object in &lt;em&gt;dtype&lt;/em&gt;. This version of the converter converts None objects so that the returned data-type is &lt;code&gt;NULL&lt;/code&gt;. This function can also be used with the &amp;ldquo;O&amp;amp;&amp;rdquo; character in PyArg_ParseTuple processing.</source>
          <target state="translated">호환 가능한 Python 객체 &lt;em&gt;obj&lt;/em&gt; 를 &lt;em&gt;dtype&lt;/em&gt; 의 데이터 유형 객체로 &lt;em&gt;변환&lt;/em&gt; 합니다. 이 버전의 변환기는 반환 된 데이터 유형이 &lt;code&gt;NULL&lt;/code&gt; 이되도록 None 객체를 변환 합니다 . 이 기능은 PyArg_ParseTuple 처리에서 &quot;O &amp;amp;&quot;문자와 함께 사용할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="beb3f78a0c5e4cafecdb1fa9aa63f269f75d1341" translate="yes" xml:space="preserve">
          <source>Convert from a pandas DataFrame to a NumPy array</source>
          <target state="translated">Pandas DataFrame에서 NumPy 배열로 변환</target>
        </trans-unit>
        <trans-unit id="e9aec6c9ded5002efcbad399df89142237d7cc00" translate="yes" xml:space="preserve">
          <source>Convert input to a contiguous (C order) array.</source>
          <target state="translated">입력을 연속 (C 순서) 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="420fb690c0edc53e8debde6a0ec4d275687ce3ce" translate="yes" xml:space="preserve">
          <source>Convert input to a contiguous array.</source>
          <target state="translated">입력을 연속 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="33c1cb2e227b9bd61de344d0e7fbaab99233af47" translate="yes" xml:space="preserve">
          <source>Convert input to a floating point ndarray.</source>
          <target state="translated">입력을 부동 소수점 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a5f5c7c34bf3d8463c0f5b22aa43e1fd52fac998" translate="yes" xml:space="preserve">
          <source>Convert input to an ndarray with column-major memory order.</source>
          <target state="translated">열 주요 메모리 순서로 입력을 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="045aaccfe763e323c93890206739ec75aade7286" translate="yes" xml:space="preserve">
          <source>Convert input to an ndarray with either row or column-major memory order.</source>
          <target state="translated">행 또는 열 주요 메모리 순서로 입력을 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a4ef171cc954b4a91951ba1a6dda729099545ddf" translate="yes" xml:space="preserve">
          <source>Convert input to an ndarray.</source>
          <target state="translated">입력을 ndarray로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="ccd7aa35d1ae2b4dc3b90cbbf72ce01559391330" translate="yes" xml:space="preserve">
          <source>Convert inputs to arrays with at least one dimension.</source>
          <target state="translated">입력 값을 1 차원 이상의 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a6f15509196d96b84e75e30f612e180331511cb6" translate="yes" xml:space="preserve">
          <source>Convert obj and place it in the ndarray, &lt;em&gt;arr&lt;/em&gt;, at the place pointed to by itemptr. Return -1 if an error occurs or 0 on success.</source>
          <target state="translated">obj를 변환하고 itemptr이 가리키는 위치에서 ndarray &lt;em&gt;arr&lt;/em&gt; 에 배치하십시오. 에러가 발생하면 -1을, 성공하면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="576d85a9ac7f4bb463bcd686151b14889c6fa48b" translate="yes" xml:space="preserve">
          <source>Convert series to a different kind and/or domain and/or window.</source>
          <target state="translated">시리즈를 다른 종류 및 / 또는 도메인 및 / 또는 창으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3f437b5b2be6d379bf2552ef729b64b4968647ed" translate="yes" xml:space="preserve">
          <source>Convert series to series of this class.</source>
          <target state="translated">시리즈를이 클래스의 시리즈로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="93f475672abfd7c74c1d21e0dc046c2cf9328c3d" translate="yes" xml:space="preserve">
          <source>Convert the Python objects to ctypes-understood arguments.</source>
          <target state="translated">Python 객체를 ctypes가 이해할 수있는 인수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="11dd67ff4e76c78a832c4fe82ad1fa604de8aae0" translate="yes" xml:space="preserve">
          <source>Convert the Python strings &amp;lsquo;C&amp;rsquo;, &amp;lsquo;F&amp;rsquo;, &amp;lsquo;A&amp;rsquo;, and &amp;lsquo;K&amp;rsquo; into the &lt;a href=&quot;#c.NPY_ORDER&quot;&gt;&lt;code&gt;NPY_ORDER&lt;/code&gt;&lt;/a&gt; enumeration &lt;a href=&quot;#c.NPY_CORDER&quot;&gt;&lt;code&gt;NPY_CORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt;&lt;code&gt;NPY_FORTRANORDER&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt;&lt;code&gt;NPY_ANYORDER&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt;&lt;code&gt;NPY_KEEPORDER&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 문자열 'C', 'F', 'A'및 'K'를 &lt;a href=&quot;#c.NPY_ORDER&quot;&gt; &lt;code&gt;NPY_ORDER&lt;/code&gt; &lt;/a&gt; 열거 &lt;a href=&quot;#c.NPY_CORDER&quot;&gt; &lt;code&gt;NPY_CORDER&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_FORTRANORDER&quot;&gt; &lt;code&gt;NPY_FORTRANORDER&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ANYORDER&quot;&gt; &lt;code&gt;NPY_ANYORDER&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_KEEPORDER&quot;&gt; &lt;code&gt;NPY_KEEPORDER&lt;/code&gt; 로 변환하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e537ead60d0d43e6e588d78323ccc29eca3c8343" translate="yes" xml:space="preserve">
          <source>Convert the Python strings &amp;lsquo;clip&amp;rsquo;, &amp;lsquo;wrap&amp;rsquo;, and &amp;lsquo;raise&amp;rsquo; into the &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt;&lt;code&gt;NPY_CLIPMODE&lt;/code&gt;&lt;/a&gt; enumeration &lt;a href=&quot;#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 문자열 'clip', 'wrap'및 'raise'를 &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt; &lt;code&gt;NPY_CLIPMODE&lt;/code&gt; &lt;/a&gt; 열거 &lt;a href=&quot;#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; 로 변환하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc37cf0719273a042d912bf17405514329ce06ef" translate="yes" xml:space="preserve">
          <source>Convert the Python strings &amp;lsquo;no&amp;rsquo;, &amp;lsquo;equiv&amp;rsquo;, &amp;lsquo;safe&amp;rsquo;, &amp;lsquo;same_kind&amp;rsquo;, and &amp;lsquo;unsafe&amp;rsquo; into the &lt;a href=&quot;#c.NPY_CASTING&quot;&gt;&lt;code&gt;NPY_CASTING&lt;/code&gt;&lt;/a&gt; enumeration &lt;a href=&quot;#c.NPY_NO_CASTING&quot;&gt;&lt;code&gt;NPY_NO_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_EQUIV_CASTING&quot;&gt;&lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_SAFE_CASTING&quot;&gt;&lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_SAME_KIND_CASTING&quot;&gt;&lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_UNSAFE_CASTING&quot;&gt;&lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Python 문자열 'no', 'equiv', 'safe', 'same_kind'및 'unsafe'를 &lt;a href=&quot;#c.NPY_CASTING&quot;&gt; &lt;code&gt;NPY_CASTING&lt;/code&gt; &lt;/a&gt; 열거 &lt;a href=&quot;#c.NPY_NO_CASTING&quot;&gt; &lt;code&gt;NPY_NO_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_EQUIV_CASTING&quot;&gt; &lt;code&gt;NPY_EQUIV_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_SAFE_CASTING&quot;&gt; &lt;code&gt;NPY_SAFE_CASTING&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_SAME_KIND_CASTING&quot;&gt; &lt;code&gt;NPY_SAME_KIND_CASTING&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_UNSAFE_CASTING&quot;&gt; &lt;code&gt;NPY_UNSAFE_CASTING&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="815ebb3363dd660001d42495eb8ae85f74f839e8" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="89dd3b39429f0c57adb052e020bf83426fade26c" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="0806bab1a140533a0bd7db5d9d14e0735040e429" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="67269f13e308a6db3b56d40ddd223af107c28a3a" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 로&lt;/a&gt; 변환하고 필요한 경우에만 데이터를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="d7f61cec71e421e2035c68b35503551782f13e38" translate="yes" xml:space="preserve">
          <source>Convert the input to a &lt;code&gt;chararray&lt;/code&gt;, copying the data only if necessary.</source>
          <target state="translated">입력을 &lt;code&gt;chararray&lt;/code&gt; 로 변환하고 필요한 경우에만 데이터를 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="98730b39eb982a451cdb3b14184177191517f090" translate="yes" xml:space="preserve">
          <source>Convert the input to a masked array of the given data-type.</source>
          <target state="translated">입력을 주어진 데이터 유형의 마스크 배열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="049b0255d3e880a109ec0e5f8d964f2db189e876" translate="yes" xml:space="preserve">
          <source>Convert the input to a masked array, conserving subclasses.</source>
          <target state="translated">서브 클래스를 보존하면서 입력을 마스크 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ff8828938f9435e62b42845c72c1f7535705ef18" translate="yes" xml:space="preserve">
          <source>Convert the input to an array, checking for NaNs or Infs.</source>
          <target state="translated">NaN 또는 Infs를 확인하여 입력을 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a3dfbf8e7020f742fa20a33d892353893c53d156" translate="yes" xml:space="preserve">
          <source>Convert the input to an array.</source>
          <target state="translated">입력을 배열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="a8a1ee418db1bf6815f8924edb3f1ae12bdde4d6" translate="yes" xml:space="preserve">
          <source>Convert the input to an ndarray, but pass ndarray subclasses through.</source>
          <target state="translated">입력을 ndarray로 변환하지만 ndarray 서브 클래스를 전달하십시오.</target>
        </trans-unit>
        <trans-unit id="886f2026c6406a2793d6365ffa59384bbd4e87c7" translate="yes" xml:space="preserve">
          <source>Convert the python objects to ctypes-understood arguments.</source>
          <target state="translated">파이썬 객체를 ctypes가 이해할 수있는 인수로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="7e4e1bb160f7f12732c4b9f9c2fff13135191fc1" translate="yes" xml:space="preserve">
          <source>Convert to an ndarray, but pass through ndarray subclasses.</source>
          <target state="translated">ndarray로 변환하지만 ndarray 서브 클래스를 통과하십시오.</target>
        </trans-unit>
        <trans-unit id="0bf45673533df66645f8a1830f766ff21a3245ff" translate="yes" xml:space="preserve">
          <source>Convert to float.</source>
          <target state="translated">float로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4d25fc1fde9972ce3ca1a8543e86c1eba0e323da" translate="yes" xml:space="preserve">
          <source>Convert to int.</source>
          <target state="translated">int로 변환</target>
        </trans-unit>
        <trans-unit id="7cc45909f5c77c707373cc2714501a4d53754e23" translate="yes" xml:space="preserve">
          <source>Convert to long.</source>
          <target state="translated">길게 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="3ae1f71abfac0c88927feea8e530f4f046de5146" translate="yes" xml:space="preserve">
          <source>Convert typestring characters (with &lt;em&gt;itemsize&lt;/em&gt;) to basic enumerated data types. The typestring character corresponding to signed and unsigned integers, floating point numbers, and complex-floating point numbers are recognized and converted. Other values of gentype are returned. This function can be used to convert, for example, the string &amp;lsquo;f4&amp;rsquo; to &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT32&quot;&gt;&lt;code&gt;NPY_FLOAT32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">유형 문자열 문자 ( &lt;em&gt;itemsize 포함&lt;/em&gt; )를 기본 열거 데이터 유형으로 변환하십시오 . 부호있는 정수 및 부호없는 정수, 부동 소수점 숫자 및 복소수 부동 소수점 숫자에 해당하는 유형 문자열 문자가 인식되고 변환됩니다. gentype의 다른 값이 리턴됩니다. 이 함수는 예를 들어 문자열 'f4'를 &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT32&quot;&gt; &lt;code&gt;NPY_FLOAT32&lt;/code&gt; &lt;/a&gt; 로 변환하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="70c76df3e727c44cc42ff18ce9a9faa14245d650" translate="yes" xml:space="preserve">
          <source>Convert typestring characters (with &lt;em&gt;itemsize&lt;/em&gt;) to basic enumerated data types. The typestring character corresponding to signed and unsigned integers, floating point numbers, and complex-floating point numbers are recognized and converted. Other values of gentype are returned. This function can be used to convert, for example, the string &amp;lsquo;f4&amp;rsquo; to &lt;a href=&quot;dtype#c.NPY_FLOAT32&quot;&gt;&lt;code&gt;NPY_FLOAT32&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">typestring 문자 ( &lt;em&gt;itemsize 사용&lt;/em&gt; )를 기본 열거 데이터 유형으로 변환합니다. 부호있는 정수와 부호없는 정수, 부동 소수점 숫자 및 복소 부동 소수점 숫자에 해당하는 유형 문자열 문자가 인식되고 변환됩니다. gentype의 다른 값이 반환됩니다. 이 함수는 예를 들어 문자열 'f4'를 &lt;a href=&quot;dtype#c.NPY_FLOAT32&quot;&gt; &lt;code&gt;NPY_FLOAT32&lt;/code&gt; &lt;/a&gt; 로 변환하는 데 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3dad1560b74d1be07a243b82626281b4ea9ce03" translate="yes" xml:space="preserve">
          <source>Converters can also be used to provide a default for missing entries. In the following example, the converter &lt;code&gt;convert&lt;/code&gt; transforms a stripped string into the corresponding float or into -999 if the string is empty. We need to explicitly strip the string from white spaces as it is not done by default:</source>
          <target state="translated">변환기를 사용하여 누락 된 항목에 대한 기본값을 제공 할 수도 있습니다. 다음 예제에서 변환기 &lt;code&gt;convert&lt;/code&gt; 는 제거 된 문자열을 해당하는 부동 소수점으로 변환하거나 문자열이 비어있는 경우 -999 로 변환합니다. 기본적으로 수행되지 않으므로 공백에서 문자열을 명시 적으로 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="d294648838323eafa5d5de8807a68d2168b2c3dd" translate="yes" xml:space="preserve">
          <source>Converting Python array_like Objects to NumPy Arrays</source>
          <target state="translated">Python array_like 객체를 NumPy 배열로 변환</target>
        </trans-unit>
        <trans-unit id="8c2275396c9cff0a291777d1d13689b639dc64c6" translate="yes" xml:space="preserve">
          <source>Converting an arbitrary sequence object</source>
          <target state="translated">임의의 시퀀스 객체 변환</target>
        </trans-unit>
        <trans-unit id="81bfb14700a4e9e3d59d633b4a0dc102cc3ec25f" translate="yes" xml:space="preserve">
          <source>Converting arguments</source>
          <target state="translated">인수 변환</target>
        </trans-unit>
        <trans-unit id="9482d2a86e467faa5b2ef9c6c7ef5e719545adeb" translate="yes" xml:space="preserve">
          <source>Converting certain types to dtypes is Deprecated</source>
          <target state="translated">특정 유형을 dtypes로 변환하는 것은 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e546d48fddfc2b2309057fe0163a99c4890872bf" translate="yes" xml:space="preserve">
          <source>Converting data types</source>
          <target state="translated">데이터 타입 변환</target>
        </trans-unit>
        <trans-unit id="7742f5240e1d4873e47ef6d80ce8f9d7eed5d915" translate="yes" xml:space="preserve">
          <source>Converting from Previous NumPy Iterators</source>
          <target state="translated">이전 NumPy 반복자에서 변환</target>
        </trans-unit>
        <trans-unit id="938ed8e078016c5ba424e79f6b662e49a6f7f7b5" translate="yes" xml:space="preserve">
          <source>Converting of empty array-like objects to NumPy arrays</source>
          <target state="translated">빈 배열 유사 객체를 NumPy 배열로 변환</target>
        </trans-unit>
        <trans-unit id="39ce420f01e01a6e4767054eb7e780c8c56e6e83" translate="yes" xml:space="preserve">
          <source>Converts a double-precision float to a half-precision float. The value is rounded to the nearest representable half, with ties going to the nearest even. If the value is too small or too big, the system&amp;rsquo;s floating point underflow or overflow bit will be set.</source>
          <target state="translated">배정 밀도 부동 소수점을 반 정밀도 부동 소수점으로 변환합니다. 값은 가장 가까운 반올림으로 반올림되며, 가장 가까운 짝수로 연결됩니다. 값이 너무 작거나 크면 시스템의 부동 소수점 언더 플로 또는 오버플로 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="e78be2704a6f40b5c4f51bfc40fd50007ac5b7c1" translate="yes" xml:space="preserve">
          <source>Converts a flat index or array of flat indices into a tuple of coordinate arrays.</source>
          <target state="translated">플랫 인덱스 또는 플랫 인덱스 배열을 튜플 좌표 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="ff19be80738f9cb33fa734371385cb9e202a0fe3" translate="yes" xml:space="preserve">
          <source>Converts a half-precision float to a double-precision float.</source>
          <target state="translated">반 정밀도 부동 소수점을 배정 밀도 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="225d72d1ef1fe464a60bf24f2bcd8995f6d8fb0b" translate="yes" xml:space="preserve">
          <source>Converts a half-precision float to a single-precision float.</source>
          <target state="translated">반 정밀도 부동 소수점을 단 정밀도 부동 소수점으로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="b56df4d4b865c9ec05a120e856faf6520f962717" translate="yes" xml:space="preserve">
          <source>Converts a single-precision float to a half-precision float. The value is rounded to the nearest representable half, with ties going to the nearest even. If the value is too small or too big, the system&amp;rsquo;s floating point underflow or overflow bit will be set.</source>
          <target state="translated">단 정밀도 부동 소수점을 반 정밀도 부동 소수점으로 변환합니다. 값은 가장 가까운 반올림으로 반올림되며, 가장 가까운 짝수로 연결됩니다. 값이 너무 작거나 크면 시스템의 부동 소수점 언더 플로 또는 오버플로 비트가 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="5a3ee1fe16ee1828b519f490c6bae9191c320478" translate="yes" xml:space="preserve">
          <source>Converts a tuple of index arrays into an array of flat indices, applying boundary modes to the multi-index.</source>
          <target state="translated">인덱스 배열의 튜플을 다중 인덱스에 경계 모드를 적용하여 플랫 인덱스 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="94f15d51152b53417aff751d07d3008c9778e054" translate="yes" xml:space="preserve">
          <source>Converts an n-D structured array into an (n+1)-D unstructured array.</source>
          <target state="translated">nD 구조화 배열을 (n + 1) -D 구조화되지 않은 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="814504fc84ff95ba2d47a0e0edf50ea208724dc6" translate="yes" xml:space="preserve">
          <source>Converts an n-D unstructured array into an (n-1)-D structured array.</source>
          <target state="translated">nD 비정형 배열을 (n-1) -D 구조화 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="3287b73c0df552bf6b6089a1d54b770f5356f2db" translate="yes" xml:space="preserve">
          <source>Converts and n-D structured array into an (n+1)-D unstructured array.</source>
          <target state="translated">및 nD 구조화 배열을 (n + 1) -D 구조화되지 않은 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="a0bbc22b26c0355c31054b5aa961d0bd84c67edc" translate="yes" xml:space="preserve">
          <source>Converts and n-D unstructured array into an (n-1)-D structured array.</source>
          <target state="translated">및 nD 구조화되지 않은 배열을 (n-1) -D 구조화 배열로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="4d7fdb170c1f22bd4d4e265e352eb1cd10b68118" translate="yes" xml:space="preserve">
          <source>Converts either a sequence of clipmodes or a single clipmode into a C array of &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt;&lt;code&gt;NPY_CLIPMODE&lt;/code&gt;&lt;/a&gt; values. The number of clipmodes &lt;em&gt;n&lt;/em&gt; must be known before calling this function. This function is provided to help functions allow a different clipmode for each dimension.</source>
          <target state="translated">일련의 클립 모드 또는 단일 클립 모드를 &lt;a href=&quot;#c.NPY_CLIPMODE&quot;&gt; &lt;code&gt;NPY_CLIPMODE&lt;/code&gt; &lt;/a&gt; 값 의 C 배열로 변환 합니다. 이 함수를 호출하기 전에 클립 모드 수 &lt;em&gt;n을&lt;/em&gt; 알아야합니다. 이 기능은 각 차원마다 다른 클립 모드를 허용하는 기능을 제공하기 위해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="250dc78cc5a9ee71a58ec6ac7dd196d5163a36c3" translate="yes" xml:space="preserve">
          <source>Convolve two arrays using the Fast Fourier Transform.</source>
          <target state="translated">고속 푸리에 변환 (Fast Fourier Transform)을 사용하여 두 개의 배열을 연결하십시오.</target>
        </trans-unit>
        <trans-unit id="576bd4ebce16db77995374ff7c034483bd0ae542" translate="yes" xml:space="preserve">
          <source>Cooley, James W., and John W. Tukey, 1965, &amp;ldquo;An algorithm for the machine calculation of complex Fourier series,&amp;rdquo; &lt;em&gt;Math. Comput.&lt;/em&gt; 19: 297-301.</source>
          <target state="translated">Cooley, James W. 및 1965 년 John W. Tukey,&amp;ldquo;복잡한 푸리에 시리즈의 기계 계산 알고리즘&amp;rdquo; &lt;em&gt;Math. 계산. &lt;/em&gt;19 : 297-301.</target>
        </trans-unit>
        <trans-unit id="4f10880a810fc661c1a011a38c57406e757bc819" translate="yes" xml:space="preserve">
          <source>Coordinating voluntary mediation: if all involved parties agree, the Committee may facilitate a mediation process as detailed above.</source>
          <target state="translated">자발적 중재 조정 : 모든 관련 당사자가 동의하는 경우위원회는 위에 설명 된대로 중재 프로세스를 촉진 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c60c368d84ce78415fed3fba568bb8b1ea3d29ea" translate="yes" xml:space="preserve">
          <source>Copies and Views</source>
          <target state="translated">사본 및보기</target>
        </trans-unit>
        <trans-unit id="6c00b1c278cb1ce0a4df76e32fd03a9e07108220" translate="yes" xml:space="preserve">
          <source>Copies values from one array to another, broadcasting as necessary.</source>
          <target state="translated">필요에 따라 브로드 캐스트하여 한 배열에서 다른 배열로 값을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="c60275d5c5be7a657ffd107291e98055ec17c0e9" translate="yes" xml:space="preserve">
          <source>Copy an element of an array to a standard Python scalar and return it.</source>
          <target state="translated">배열의 요소를 표준 Python 스칼라에 복사하여 반환합니다.</target>
        </trans-unit>
        <trans-unit id="da203dab271c623df22148990806ffd79128f7db" translate="yes" xml:space="preserve">
          <source>Copy from the source array, &lt;code&gt;src&lt;/code&gt;, into the destination array, &lt;code&gt;dest&lt;/code&gt;, performing a data-type conversion if necessary. If an error occurs return -1 (otherwise 0). The shape of &lt;code&gt;src&lt;/code&gt; must be broadcastable to the shape of &lt;code&gt;dest&lt;/code&gt;. The data areas of dest and src must not overlap.</source>
          <target state="translated">소스 배열 &lt;code&gt;src&lt;/code&gt; 에서 대상 배열 &lt;code&gt;dest&lt;/code&gt; 로 복사하여 필요한 경우 데이터 유형 변환을 수행하십시오. 오류가 발생하면 -1을 반환하십시오 (그렇지 않으면 0). 의 모양 &lt;code&gt;src&lt;/code&gt; 의 형상 캐스트 가능한해야합니다 &lt;code&gt;dest&lt;/code&gt; . dest 및 src의 데이터 영역이 겹치지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="262c05dc573579847cb9294e40ece37b568232d5" translate="yes" xml:space="preserve">
          <source>Copy of &lt;code&gt;a&lt;/code&gt; with fields repacked, or &lt;code&gt;a&lt;/code&gt; itself if no repacking was needed.</source>
          <target state="translated">의 복사 필드는 재 포장, 또는 자체에는 재 포장이 필요하지 않은 경우. &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9cf4b88f8aea8dc3032e39289c48a6f6e4000cca" translate="yes" xml:space="preserve">
          <source>Copy of self.</source>
          <target state="translated">자기의 사본.</target>
        </trans-unit>
        <trans-unit id="0f7a2502580eeb2a37c3da78f6d85e2d28d19dcb" translate="yes" xml:space="preserve">
          <source>Copy of the array, cast to a specified type.</source>
          <target state="translated">지정된 유형으로 캐스트 된 배열의 사본</target>
        </trans-unit>
        <trans-unit id="1855ebfecee0e89a08817f0c462727dd9e51acd0" translate="yes" xml:space="preserve">
          <source>Copy the mask and set the sharedmask flag to False.</source>
          <target state="translated">마스크를 복사하고 sharedmask 플래그를 False로 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="eda7f5e21aefc109d198cff2108b69be2a88ea2f" translate="yes" xml:space="preserve">
          <source>Copy-on-write memmap:</source>
          <target state="translated">복사 중 쓰기 memmap :</target>
        </trans-unit>
        <trans-unit id="9efdf61f90e514f177252ac8197d7a3fecad778b" translate="yes" xml:space="preserve">
          <source>Copy-on-write: assignments affect data in memory, but changes are not saved to disk. The file on disk is read-only.</source>
          <target state="translated">기록 중 복사 : 할당은 메모리의 데이터에 영향을 주지만 변경 사항은 디스크에 저장되지 않습니다. 디스크의 파일이 읽기 전용입니다.</target>
        </trans-unit>
        <trans-unit id="86da9f97b2521b0d5afa29bd95ef4ddf151eeb02" translate="yes" xml:space="preserve">
          <source>Copyright (c) 2005, NumPy Developers</source>
          <target state="translated">Copyright (c) 2005, NumPy Developers</target>
        </trans-unit>
        <trans-unit id="5b33d787803ee72e85555afb13ca15c7e8e68b1e" translate="yes" xml:space="preserve">
          <source>Core Dimension</source>
          <target state="translated">핵심 치수</target>
        </trans-unit>
        <trans-unit id="a935f62f1a313ebc5f0b4349a182f187ea660c8d" translate="yes" xml:space="preserve">
          <source>Core dimensions assigned to the same label in the signature (e.g. the &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;inner1d&lt;/code&gt;&amp;rsquo;s &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;) must have exactly matching sizes, no broadcasting is performed.</source>
          <target state="translated">서명에 동일한 레이블 할당 코어 크기 (예 &lt;code&gt;i&lt;/code&gt; 에서 &lt;code&gt;inner1d&lt;/code&gt; 의 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; )을 정확하게 일치하는 크기를 가져야에는 방송이 수행되지 않는다.</target>
        </trans-unit>
        <trans-unit id="a85e68f4d74fe8012fbcc947dee9e830301ccda9" translate="yes" xml:space="preserve">
          <source>Core dimensions assigned to the same label in the signature must have exactly matching sizes, no broadcasting is performed.</source>
          <target state="translated">서명에서 동일한 레이블에 지정된 코어 크기는 정확히 일치하는 크기 여야하며 브로드 캐스트가 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="77d90b4a2e78538417c275f69722b0ac5a0a99f5" translate="yes" xml:space="preserve">
          <source>Core dimensions of each input or output array are represented by a list of dimension names in parentheses, &lt;code&gt;(i_1,...,i_N)&lt;/code&gt;; a scalar input/output is denoted by &lt;code&gt;()&lt;/code&gt;. Instead of &lt;code&gt;i_1&lt;/code&gt;, &lt;code&gt;i_2&lt;/code&gt;, etc, one can use any valid Python variable name.</source>
          <target state="translated">각 입력 또는 출력 배열의 코어 치수는 괄호 안에 치수 이름 목록으로 표시됩니다 &lt;code&gt;(i_1,...,i_N)&lt;/code&gt; . 스칼라 입력 / 출력은 &lt;code&gt;()&lt;/code&gt; 로 표시됩니다 . &lt;code&gt;i_1&lt;/code&gt; , &lt;code&gt;i_2&lt;/code&gt; 등 대신 유효한 Python 변수 이름을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74fda43cf5b94de17f1701a1daa8838cd689d1ac" translate="yes" xml:space="preserve">
          <source>Core signature string</source>
          <target state="translated">핵심 서명 문자열</target>
        </trans-unit>
        <trans-unit id="9a73d7eeec664afb4494a9c7d06291968be1807f" translate="yes" xml:space="preserve">
          <source>Cormen, &amp;ldquo;Introduction to Algorithms&amp;rdquo;, Chapter 15.2, p. 370-378</source>
          <target state="translated">Cormen,&amp;ldquo;알고리즘 소개&amp;rdquo;, 15.2 장, p. 370-378</target>
        </trans-unit>
        <trans-unit id="eac6a2ed482be56481c69c9e34966e627a3d0405" translate="yes" xml:space="preserve">
          <source>Correcting technical inaccuracies in the documentation are high priority. For example, if a docstring is missing a parameter or the description of a fuction/parameter/method etc. is incorrect. Other &amp;ldquo;structural&amp;rdquo; defects like broken links are also high priority.</source>
          <target state="translated">문서의 기술적 부정확성을 수정하는 것이 최우선 순위입니다. 예를 들어, 독 스트링에 매개 변수가 없거나 fuction / parameter / method 등에 대한 설명이 잘못된 경우입니다. 끊어진 링크와 같은 다른 &quot;구조적&quot;결함도 우선 순위가 높습니다.</target>
        </trans-unit>
        <trans-unit id="e09f45c90809a295b044ca045b6666387613a15c" translate="yes" xml:space="preserve">
          <source>Correlating</source>
          <target state="translated">Correlating</target>
        </trans-unit>
        <trans-unit id="c3ffb59304cd35f5989ecead23c1e787437b571d" translate="yes" xml:space="preserve">
          <source>Correspondingly, when the spectrum is purely real, the signal is Hermitian. The &lt;a href=&quot;generated/numpy.fft.hfft#numpy.fft.hfft&quot;&gt;&lt;code&gt;hfft&lt;/code&gt;&lt;/a&gt; family of functions exploits this symmetry by using &lt;code&gt;n/2+1&lt;/code&gt; complex points in the input (time) domain for &lt;code&gt;n&lt;/code&gt; real points in the frequency domain.</source>
          <target state="translated">이에 따라 스펙트럼이 순전히 실제 인 경우 신호는 에르 미트 (Hermitian)입니다. &lt;a href=&quot;generated/numpy.fft.hfft#numpy.fft.hfft&quot;&gt; &lt;code&gt;hfft&lt;/code&gt; 의&lt;/a&gt; 기능 가족 사용하여이 대칭성을 이용 &lt;code&gt;n/2+1&lt;/code&gt; 의 입력 (시간) 영역에서 복잡한 포인트 &lt;code&gt;n&lt;/code&gt; 주파수 영역에서 실시간 포인트.</target>
        </trans-unit>
        <trans-unit id="ef15bde640af7d5282d372b3668304d3b57605b8" translate="yes" xml:space="preserve">
          <source>Cosine element-wise.</source>
          <target state="translated">요소 별 코사인.</target>
        </trans-unit>
        <trans-unit id="bb2b145a0846bc476ba8ae803dd9b740cb6457fc" translate="yes" xml:space="preserve">
          <source>Council Members invited to NumPy Developer Meetings.</source>
          <target state="translated">NumPy 개발자 회의에 자문위원을 초대했습니다.</target>
        </trans-unit>
        <trans-unit id="aab7364e9bda4d60657cb8306378b5c5f960cc4a" translate="yes" xml:space="preserve">
          <source>Council decision making</source>
          <target state="translated">협의회 의사 결정</target>
        </trans-unit>
        <trans-unit id="e11cba1a9aa3f53d0063ccb87482cf72fbf79615" translate="yes" xml:space="preserve">
          <source>Council membership</source>
          <target state="translated">위원회 회원</target>
        </trans-unit>
        <trans-unit id="f85bd4ac12155f7ab384c763ede09ca77aca792b" translate="yes" xml:space="preserve">
          <source>Count masked elements in array or along a given axis.</source>
          <target state="translated">배열 또는 주어진 축을 따라 마스크 된 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="dc43a8e6604d12ce95e869b8a107c8a135d37cfb" translate="yes" xml:space="preserve">
          <source>Count non-masked elements.</source>
          <target state="translated">마스크되지 않은 요소를 세십시오.</target>
        </trans-unit>
        <trans-unit id="fcd7647bccacf473f6f7538a24a5d644b1446db8" translate="yes" xml:space="preserve">
          <source>Count number of occurrences of each value in array of non-negative ints.</source>
          <target state="translated">음수가 아닌 정수의 배열에서 각 값의 발생 횟수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="32c1e63927fc36a57080f439614d4f3a9e9a4010" translate="yes" xml:space="preserve">
          <source>Count the non-masked elements of the array along the given axis.</source>
          <target state="translated">주어진 축을 따라 배열의 마스크되지 않은 요소를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="f478aa803be450d56ad50466a52a872cccc5840c" translate="yes" xml:space="preserve">
          <source>Count the number of masked elements along the given axis.</source>
          <target state="translated">주어진 축을 따라 마스크 된 요소의 수를 센다.</target>
        </trans-unit>
        <trans-unit id="78bd22c42b14c011a02df9e7d1c6c3966b587ac6" translate="yes" xml:space="preserve">
          <source>Counter to use in the Philox state. Can be either a Python int (long in 2.x) in [0, 2**256) or a 4-element uint64 array. If not provided, the RNG is initialized at 0.</source>
          <target state="translated">Philox 상태에서 사용할 카운터. [0, 2 ** 256의 Python int (2.x에서 길게)) 또는 4 요소 uint64 배열 일 수 있습니다. 제공되지 않으면 RNG는 0으로 초기화됩니다.</target>
        </trans-unit>
        <trans-unit id="7810ca2eec9994e430b34bfbe7314516c25672d5" translate="yes" xml:space="preserve">
          <source>Counting</source>
          <target state="translated">Counting</target>
        </trans-unit>
        <trans-unit id="341d54df06a257a5db8eb7bb0f7914e4712491fe" translate="yes" xml:space="preserve">
          <source>Counting the missing elements</source>
          <target state="translated">누락 된 요소 계산</target>
        </trans-unit>
        <trans-unit id="e51f7ebad6498090d852d60e0437352e55df1b6d" translate="yes" xml:space="preserve">
          <source>Counts how many valid days are in a half-open date range.</source>
          <target state="translated">반 개방 날짜 범위에있는 유효 일수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="ab06dd416d9201cfa1a776030c3073f0f296ef5c" translate="yes" xml:space="preserve">
          <source>Counts the number of non-zero elements in the array object &lt;em&gt;self&lt;/em&gt;.</source>
          <target state="translated">배열 객체 &lt;em&gt;self&lt;/em&gt; 의 0이 아닌 요소의 수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="35b1783f22a005e4a0e9aa8326071116370e26da" translate="yes" xml:space="preserve">
          <source>Counts the number of non-zero elements in the input array.</source>
          <target state="translated">입력 배열에서 0이 아닌 요소의 수를 계산합니다.</target>
        </trans-unit>
        <trans-unit id="c93aeb4f5df8b4c7a7489b48cdc9da95b95d9241" translate="yes" xml:space="preserve">
          <source>Counts the number of non-zero values in the array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">배열 &lt;code&gt;a&lt;/code&gt; 의 0이 아닌 값의 개수를 계산합니다 .</target>
        </trans-unit>
        <trans-unit id="a82b9a1216f695b2de1af812d1dbbca1ab80309a" translate="yes" xml:space="preserve">
          <source>Counts the number of valid days between &lt;code&gt;begindates&lt;/code&gt; and &lt;code&gt;enddates&lt;/code&gt;, not including the day of &lt;code&gt;enddates&lt;/code&gt;.</source>
          <target state="translated">사이의 유효 기간 (일) 카운트 &lt;code&gt;begindates&lt;/code&gt; 및 &lt;code&gt;enddates&lt;/code&gt; 의 날을 포함하지 않는, &lt;code&gt;enddates&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="a0a5fdf81f7e55534496f51fe8e4d85151e98bfe" translate="yes" xml:space="preserve">
          <source>Covariance check in &lt;code&gt;np.random.multivariate_normal&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.random.multivariate_normal&lt;/code&gt; 의 공분산 검사</target>
        </trans-unit>
        <trans-unit id="2ef356fd3fb8d0846092b2d591c24bc20398772e" translate="yes" xml:space="preserve">
          <source>Covariance in &lt;code&gt;random.mvnormal&lt;/code&gt; cast to double</source>
          <target state="translated">&lt;code&gt;random.mvnormal&lt;/code&gt; 의 공분산은 double로 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="0acc19acc7d5ef1e19db778f62f9ff93707d13fa" translate="yes" xml:space="preserve">
          <source>Covariance indicates the level to which two variables vary together. From the multivariate normal distribution, we draw N-dimensional samples,</source>
          <target state="translated">공분산은 두 변수가 서로 다른 수준을 나타냅니다. 다변량 정규 분포에서 N 차원 표본을 그리고</target>
        </trans-unit>
        <trans-unit id="146d5410def5b1425b9181e3a3d6c9a98ceaffcd" translate="yes" xml:space="preserve">
          <source>Covariance indicates the level to which two variables vary together. If we examine N-dimensional samples,</source>
          <target state="translated">공분산은 두 변수가 서로 다른 수준을 나타냅니다. N 차원 샘플을 살펴보면</target>
        </trans-unit>
        <trans-unit id="7e3640f844cf3cff392814080ea6e4fc7ebf5942" translate="yes" xml:space="preserve">
          <source>Covariance matrix</source>
          <target state="translated">공분산 행렬</target>
        </trans-unit>
        <trans-unit id="ba1dce691b3dd8e45383b40c4c84fa04284a8fb4" translate="yes" xml:space="preserve">
          <source>Covariance matrix of the distribution. It must be symmetric and positive-semidefinite for proper sampling.</source>
          <target state="translated">분포의 공분산 행렬. 적절한 샘플링을 위해서는 대칭적이고 양의 반음 수 여야합니다.</target>
        </trans-unit>
        <trans-unit id="68e8573d798a126e105247a473e35026f11fa4f8" translate="yes" xml:space="preserve">
          <source>Create Fortran subroutine wrappers to Fortran functions. &lt;code&gt;--wrap-functions&lt;/code&gt; is default because it ensures maximum portability and compiler independence.</source>
          <target state="translated">Fortran 함수에 대한 Fortran 서브 루틴 래퍼를 만듭니다. &lt;code&gt;--wrap-functions&lt;/code&gt; 는 최대 이식성과 컴파일러 독립성을 보장하기 때문에 기본값입니다.</target>
        </trans-unit>
        <trans-unit id="e198169e22830014df6d95b3cbbb568dc11dce1f" translate="yes" xml:space="preserve">
          <source>Create a 2-D array with the flattened input as a diagonal.</source>
          <target state="translated">평평한 입력을 대각선으로 사용하여 2 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="45564d0f3cba42375351ce0e3f27f7308d83f0a3" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt;&lt;code&gt;numpy.random.Generator&lt;/code&gt;&lt;/a&gt; instance:</source>
          <target state="translated">&lt;a href=&quot;../generator#numpy.random.Generator&quot;&gt; &lt;code&gt;numpy.random.Generator&lt;/code&gt; &lt;/a&gt; 인스턴스를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a59869cacd92085b66bb144f1578d32820c3bbe9" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="e8c7020003f7473689a082f3999dbe024d7d290f" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="cf1fd6b11165877b30f8adf628ec7e27985f2765" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.char.chararray#numpy.char.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="996ba906ed4c73535bbad11e42d23df8d3cbf7f3" translate="yes" xml:space="preserve">
          <source>Create a &lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt;&lt;code&gt;chararray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.chararray#numpy.chararray&quot;&gt; &lt;code&gt;chararray&lt;/code&gt; 를&lt;/a&gt; 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="c66092d36950339cb427dfcbe2dfba19b7f580ca" translate="yes" xml:space="preserve">
          <source>Create a &lt;code&gt;chararray&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;chararray&lt;/code&gt; 를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a92356ac5b67faa988652eac8489bf3b3679b4fd" translate="yes" xml:space="preserve">
          <source>Create a GitHub account</source>
          <target state="translated">GitHub 계정 생성</target>
        </trans-unit>
        <trans-unit id="d3bb8f8e46a1fe69fa587519e7dee49793dad2ec" translate="yes" xml:space="preserve">
          <source>Create a NumPy fork</source>
          <target state="translated">NumPy 포크 만들기</target>
        </trans-unit>
        <trans-unit id="053bb3dd5cd61ee6d9da229f972809abcee13ee6" translate="yes" xml:space="preserve">
          <source>Create a boolean mask from an array.</source>
          <target state="translated">배열에서 부울 마스크를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="54302d91f2b68bad9fdaaab3e8712a1aa2f411dc" translate="yes" xml:space="preserve">
          <source>Create a branch for the feature you want to work on. Since the branch name will appear in the merge message, use a sensible name such as &amp;lsquo;linspace-speedups&amp;rsquo;:</source>
          <target state="translated">작업하려는 기능에 대한 분기를 만듭니다. 브랜치 이름이 병합 메시지에 표시되므로 'linspace-speedups'와 같은 적절한 이름을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="d93c678b3ed0b4d36476f41968f0182b90056627" translate="yes" xml:space="preserve">
          <source>Create a data type object.</source>
          <target state="translated">데이터 형식 개체를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a87756a536e33363736738458832ff08b923fefb" translate="yes" xml:space="preserve">
          <source>Create a data-type.</source>
          <target state="translated">데이터 유형을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="93eb0ae31609f0ed48c3c5dfd8b5a3cb8402ac97" translate="yes" xml:space="preserve">
          <source>Create a matrix of the given shape and propagate it with random samples from a uniform distribution over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">주어진 모양의 행렬을 만들고 &lt;code&gt;[0, 1)&lt;/code&gt; 대한 균일 분포의 랜덤 표본으로 전파합니다 .</target>
        </trans-unit>
        <trans-unit id="c295b748c8517694492f48fd31f9b376f9c645c8" translate="yes" xml:space="preserve">
          <source>Create a memmap with dtype and shape that matches our data:</source>
          <target state="translated">데이터와 일치하는 dtype과 shape로 memmap을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="19e2c3798e7032d352bdeb16a194e1b2b2271bab" translate="yes" xml:space="preserve">
          <source>Create a memory-map to an array stored in a &lt;em&gt;binary&lt;/em&gt; file on disk.</source>
          <target state="translated">디스크 의 &lt;em&gt;이진&lt;/em&gt; 파일에 저장된 배열에 메모리 맵을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="8a87bd8b7d3a950e18b45a000e101dc7d4817b57" translate="yes" xml:space="preserve">
          <source>Create a memory-map to an array stored in a binary file on disk.</source>
          <target state="translated">디스크의 이진 파일에 저장된 배열에 메모리 맵을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="177322a71483684c72dfc2b3215cca2baa8b7843" translate="yes" xml:space="preserve">
          <source>Create a memory-map to an array stored in a file on disk.</source>
          <target state="translated">디스크의 파일에 저장된 어레이에 메모리 맵을 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="dd122b2ab92f93dade4d0598cccec22c13f3cc51" translate="yes" xml:space="preserve">
          <source>Create a new 1-dimensional array from an iterable object.</source>
          <target state="translated">반복 가능한 객체에서 새로운 1 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="da0150ead372af08b1b57e37f89fc0a11de82d56" translate="yes" xml:space="preserve">
          <source>Create a new array with the provided data-type descriptor, &lt;em&gt;descr&lt;/em&gt;, of the shape determined by &lt;em&gt;nd&lt;/em&gt; and &lt;em&gt;dims&lt;/em&gt;.</source>
          <target state="translated">&lt;em&gt;nd&lt;/em&gt; 및 &lt;em&gt;dims로&lt;/em&gt; 결정된 형태 의 제공된 데이터 유형 설명자 &lt;em&gt;descr을&lt;/em&gt; 사용하여 새 배열을 작성하십시오 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="66aa9bc65510d6c47313fc8c574666e0fb6ecdf0" translate="yes" xml:space="preserve">
          <source>Create a new broadcasting universal function from required variables. Each ufunc builds around the notion of an element-by-element operation. Each ufunc object contains pointers to 1-d loops implementing the basic functionality for each supported type.</source>
          <target state="translated">필요한 변수에서 새로운 방송 범용 기능을 만듭니다. 각 ufunc는 요소 별 연산 개념을 기반으로합니다. 각 ufunc 객체에는 지원되는 각 유형의 기본 기능을 구현하는 1-d 루프에 대한 포인터가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a2f526f17ce7c95e1ecc2546f61cdc127fd9387" translate="yes" xml:space="preserve">
          <source>Create a new data-type object from the built-in (or user-registered) data-type indicated by &lt;em&gt;typenum&lt;/em&gt;. All builtin types should not have any of their fields changed. This creates a new copy of the &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure so that you can fill it in as appropriate. This function is especially needed for flexible data-types which need to have a new elsize member in order to be meaningful in array construction.</source>
          <target state="translated">&lt;em&gt;typenum으로&lt;/em&gt; 표시되는 내장 (또는 사용자 등록) 데이터 유형에서 새 데이터 유형 오브젝트를 작성하십시오 . 모든 내장 유형은 필드를 변경하지 않아야합니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 의 새 사본을 작성하여 적절하게 채울 수 있습니다. 이 기능은 배열 구성에서 의미가 있으려면 새로운 크기의 멤버가 필요한 유연한 데이터 유형에 특히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="9f73a3ca4eff6106e72eaaa362a06b983218e17c" translate="yes" xml:space="preserve">
          <source>Create a new data-type object from the built-in (or user-registered) data-type indicated by &lt;em&gt;typenum&lt;/em&gt;. All builtin types should not have any of their fields changed. This creates a new copy of the &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure so that you can fill it in as appropriate. This function is especially needed for flexible data-types which need to have a new elsize member in order to be meaningful in array construction.</source>
          <target state="translated">&lt;em&gt;typenum으로&lt;/em&gt; 표시된 내장 (또는 사용자 등록) 데이터 유형에서 새 데이터 유형 객체를 &lt;em&gt;만듭니다&lt;/em&gt; . 모든 내장 유형은 변경된 필드가 없어야합니다. 이렇게하면 &lt;a href=&quot;types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 의 새 복사본이 만들어 지므로 적절하게 채울 수 있습니다. 이 함수는 배열 구성에서 의미를 갖기 위해 새로운 elsize 멤버가 필요한 유연한 데이터 유형에 특히 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f8509ca60bfaea500690871b0d3aefa272f988a9" translate="yes" xml:space="preserve">
          <source>Create a new data-type object with the byteorder set according to &lt;em&gt;newendian&lt;/em&gt;. All referenced data-type objects (in subdescr and fields members of the data-type object) are also changed (recursively).</source>
          <target state="translated">&lt;em&gt;newendian&lt;/em&gt; 에 따라 설정된 바이트 순서로 새 데이터 유형 객체를 &lt;em&gt;만듭니다&lt;/em&gt; . 참조 된 모든 데이터 유형 객체 (데이터 유형 객체의 하위 디스크 및 필드 멤버)도 (재귀 적으로) 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="2566b193178a539463843e8aa80394649f42e4a2" translate="yes" xml:space="preserve">
          <source>Create a new data-type object with the byteorder set according to &lt;em&gt;newendian&lt;/em&gt;. All referenced data-type objects (in subdescr and fields members of the data-type object) are also changed (recursively). If a byteorder of &lt;code&gt;NPY_IGNORE&lt;/code&gt; is encountered it is left alone. If newendian is &lt;code&gt;NPY_SWAP&lt;/code&gt;, then all byte-orders are swapped. Other valid newendian values are &lt;code&gt;NPY_NATIVE&lt;/code&gt;, &lt;code&gt;NPY_LITTLE&lt;/code&gt;, and &lt;code&gt;NPY_BIG&lt;/code&gt; which all cause the returned data-typed descriptor (and all it&amp;rsquo;s referenced data-type descriptors) to have the corresponding byte- order.</source>
          <target state="translated">&lt;em&gt;newendian&lt;/em&gt; 에 따라 바이트 순서가 설정된 새 데이터 유형 객체를 &lt;em&gt;만듭니다&lt;/em&gt; . 참조 된 모든 데이터 유형 개체 (데이터 유형 개체의 하위 설명 및 필드 멤버)도 (재귀 적으로) 변경됩니다. &lt;code&gt;NPY_IGNORE&lt;/code&gt; 의 바이트 순서 가 발생하면 홀로 남습니다. newendian이 &lt;code&gt;NPY_SWAP&lt;/code&gt; 이면 모든 바이트 순서가 바뀝니다. 다른 유효한 뉴 엔디안 값은 &lt;code&gt;NPY_NATIVE&lt;/code&gt; , &lt;code&gt;NPY_LITTLE&lt;/code&gt; 및 &lt;code&gt;NPY_BIG&lt;/code&gt; 이며 , 이로 인해 반환 된 데이터 유형 설명자 (및 모든 참조 데이터 유형 설명자)가 해당 바이트 순서를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="85796bed1fe922ebc4f889f6e49424604f30d8c0" translate="yes" xml:space="preserve">
          <source>Create a new instance of &amp;lsquo;CCompilerOpt&amp;rsquo; and generate the dispatch header which contains the #definitions and headers of platform-specific instruction-sets for the enabled CPU baseline and dispatch-able features.</source>
          <target state="translated">'CCompilerOpt'의 새 인스턴스를 만들고 활성화 된 CPU 기준선 및 디스패치 가능 기능에 대한 플랫폼 별 명령어 세트의 #definitions 및 헤더를 포함하는 디스패치 헤더를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="f6986303dc6f9f6f31cfc3c9b4f4566a4e6fb42d" translate="yes" xml:space="preserve">
          <source>Create a new masked array from scratch.</source>
          <target state="translated">마스크 된 새 배열을 처음부터 만듭니다.</target>
        </trans-unit>
        <trans-unit id="db4af2ef3a8605462d0c80d1288e39839d7838af" translate="yes" xml:space="preserve">
          <source>Create a new uninitialized array of type, &lt;em&gt;typenum&lt;/em&gt;, whose size in each of &lt;em&gt;nd&lt;/em&gt; dimensions is given by the integer array, &lt;em&gt;dims&lt;/em&gt;.The memory for the array is uninitialized (unless typenum is &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; in which case each element in the array is set to NULL). The &lt;em&gt;typenum&lt;/em&gt; argument allows specification of any of the builtin data-types such as &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt;. The memory for the array can be set to zero if desired using &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; (return_object, 0).This function cannot be used to create a flexible-type array (no itemsize given).</source>
          <target state="translated">초기화되지 않은 새로운 유형의 &lt;em&gt;typenum&lt;/em&gt; 유형의 초기화 배열을 작성하십시오. 각 &lt;em&gt;nd&lt;/em&gt; 차원의 크기는 정수 배열 인 &lt;em&gt;dims로 지정됩니다&lt;/em&gt; . 배열 의 메모리가 초기화되지 않습니다 (typenum이 &lt;a href=&quot;c-api.dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 배열의 각 요소가 NULL로 설정 되지 않은 경우) ). &lt;em&gt;typenum의&lt;/em&gt; 인수 등의 내장 된 데이터 유형의 사양 허용 &lt;a href=&quot;c-api.dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;c-api.dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; 를&lt;/a&gt; . &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; (return_object, 0)를 사용하여 원하는 경우 배열의 메모리를 0으로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7aab9551cebdfb58f6a09ed773d97c8c60687ac0" translate="yes" xml:space="preserve">
          <source>Create a new uninitialized array of type, &lt;em&gt;typenum&lt;/em&gt;, whose size in each of &lt;em&gt;nd&lt;/em&gt; dimensions is given by the integer array, &lt;em&gt;dims&lt;/em&gt;.The memory for the array is uninitialized (unless typenum is &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt;&lt;code&gt;NPY_OBJECT&lt;/code&gt;&lt;/a&gt; in which case each element in the array is set to NULL). The &lt;em&gt;typenum&lt;/em&gt; argument allows specification of any of the builtin data-types such as &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt;&lt;code&gt;NPY_FLOAT&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt;&lt;code&gt;NPY_LONG&lt;/code&gt;&lt;/a&gt;. The memory for the array can be set to zero if desired using &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; (return_object, 0).This function cannot be used to create a flexible-type array (no itemsize given).</source>
          <target state="translated">유형의 새로운 초기화 배열 생성 &lt;em&gt;typenum&lt;/em&gt; 사이즈의 각각에, &lt;em&gt;ND&lt;/em&gt; 차원 정수 어레이에 의해 주어진다을 &lt;em&gt;흐리게&lt;/em&gt; typenum가 아닌 어레이에 대한 국지적 인 메모리 (초기화되지된다 &lt;a href=&quot;dtype#c.NPY_OBJECT&quot;&gt; &lt;code&gt;NPY_OBJECT&lt;/code&gt; &lt;/a&gt; 어레이의 각 요소는 NULL로 설정된 경우 ). &lt;em&gt;typenum의&lt;/em&gt; 인수 등의 내장 된 데이터 유형의 사양 허용 &lt;a href=&quot;dtype#c.NPY_FLOAT&quot;&gt; &lt;code&gt;NPY_FLOAT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;dtype#c.NPY_LONG&quot;&gt; &lt;code&gt;NPY_LONG&lt;/code&gt; 를&lt;/a&gt; . &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; (return_object, 0)를 사용하여 원하는 경우 배열의 메모리를 0으로 설정할 수 있습니다. 이 함수는 유연한 유형 배열을 만드는 데 사용할 수 없습니다 (항목 별 지정 없음).</target>
        </trans-unit>
        <trans-unit id="6c0c8b6de66490941ae490fc29850f004942457f" translate="yes" xml:space="preserve">
          <source>Create a new, empty record array:</source>
          <target state="translated">비어있는 새 레코드 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="12be6a102aebbe485e0f4ef96e897bf893ee3bfe" translate="yes" xml:space="preserve">
          <source>Create a numpy array from a ctypes array or POINTER.</source>
          <target state="translated">ctypes 배열 또는 POINTER에서 numpy 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9ee63618f71a45ca583020dce46ecb32ddd626d9" translate="yes" xml:space="preserve">
          <source>Create a recarray from a list of records in text form.</source>
          <target state="translated">텍스트 형식의 레코드 목록에서 재캐 레이를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="f87d9a4b85041e6a4b8d29381cf85414f7e3a747" translate="yes" xml:space="preserve">
          <source>Create a record array from a (flat) list of arrays</source>
          <target state="translated">(플랫) 배열 목록에서 레코드 배열 만들기</target>
        </trans-unit>
        <trans-unit id="74e43cb92af065a3e7ecff01e8979f35b3a0afd5" translate="yes" xml:space="preserve">
          <source>Create a record array from binary data</source>
          <target state="translated">이진 데이터에서 레코드 배열 만들기</target>
        </trans-unit>
        <trans-unit id="00bebe7beba9d200b07101646c92c66e5cd00025" translate="yes" xml:space="preserve">
          <source>Create a set of indices to access the diagonal of a (4, 4) array:</source>
          <target state="translated">(4, 4) 배열의 대각선에 액세스 할 인덱스 세트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="9d5ae4c652e16a858045884571cb6288cb7a826c" translate="yes" xml:space="preserve">
          <source>Create a sliding window view into the array with the given window shape.</source>
          <target state="translated">주어진 창 모양으로 배열에 슬라이딩 창보기를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="108a4b49ad391d95a892bf9a02c53f664759b30e" translate="yes" xml:space="preserve">
          <source>Create a standard ndarray and convert it to a record array, using &lt;code&gt;arr.view(np.recarray)&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;arr.view(np.recarray)&lt;/code&gt; 사용하여 표준 ndarray를 작성하고 레코드 배열로 변환하십시오.</target>
        </trans-unit>
        <trans-unit id="858fef149d40d2c2e3e8380d3482c3242b0b81ca" translate="yes" xml:space="preserve">
          <source>Create a test array:</source>
          <target state="translated">테스트 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="c5cd4653ebf1e7a39dd1a7fde57d136d86e370ff" translate="yes" xml:space="preserve">
          <source>Create a tuple of &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; objects which iterate in nested loops over different axes of the op argument. The first iterator is used in the outermost loop, the last in the innermost loop. Advancing one will change the subsequent iterators to point at its new element.</source>
          <target state="translated">op 인수의 다른 축에 대해 중첩 루프에서 반복되는 &lt;a href=&quot;numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 객체 의 튜플을 만듭니다 . 첫 번째 반복자는 가장 바깥 쪽 루프에서 사용되고 마지막 반복자는 가장 안쪽 루프에서 사용됩니다. 하나를 진행 시키면 다음 반복자가 새로운 요소를 가리 키도록 변경됩니다.</target>
        </trans-unit>
        <trans-unit id="0fc61fbee0ed5e8baf16ecef1179e57ba0313e61" translate="yes" xml:space="preserve">
          <source>Create a two-dimensional array with the flattened input as a diagonal.</source>
          <target state="translated">평평한 입력을 대각선으로 사용하여 2 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="137fea567dac73b2d57dd9dfb89ded4439c13d56" translate="yes" xml:space="preserve">
          <source>Create a view into the array with the given shape and strides.</source>
          <target state="translated">주어진 모양과 보폭으로 배열에 뷰를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="81d0dc00ee9f15e21759f9f0bec711bb9bd505df" translate="yes" xml:space="preserve">
          <source>Create an array from an iterator.</source>
          <target state="translated">반복자에서 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="925f773d387b010ea0e8a6321db588428ffb283e" translate="yes" xml:space="preserve">
          <source>Create an array from binary file data</source>
          <target state="translated">이진 파일 데이터에서 배열 만들기</target>
        </trans-unit>
        <trans-unit id="d2e4e179d70e58136861749bef7d847f8a1e83ea" translate="yes" xml:space="preserve">
          <source>Create an array of the given shape and populate it with random samples from a uniform distribution over &lt;code&gt;[0, 1)&lt;/code&gt;.</source>
          <target state="translated">주어진 모양의 배열을 만들고 &lt;code&gt;[0, 1)&lt;/code&gt; 대한 균일 분포의 무작위 표본으로 채 웁니다 .</target>
        </trans-unit>
        <trans-unit id="8ef83bcd085ae088871cf8b9cc78b6a1d61e3207" translate="yes" xml:space="preserve">
          <source>Create an array with two fields, &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 라는 두 개의 필드로 배열을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="1a31fd94f016f355d7832212f15cccc2bc9c1da3" translate="yes" xml:space="preserve">
          <source>Create an array wrapper around &lt;em&gt;data&lt;/em&gt; pointed to by the given pointer. The array flags will have a default that the data area is well-behaved and C-style contiguous. The shape of the array is given by the &lt;em&gt;dims&lt;/em&gt; c-array of length &lt;em&gt;nd&lt;/em&gt;. The data-type of the array is indicated by &lt;em&gt;typenum&lt;/em&gt;. If data comes from another reference-counted Python object, the reference count on this object should be increased after the pointer is passed in, and the base member of the returned ndarray should point to the Python object that owns the data. This will ensure that the provided memory is not freed while the returned array is in existence. To free memory as soon as the ndarray is deallocated, set the OWNDATA flag on the returned ndarray.</source>
          <target state="translated">주어진 포인터가 가리키는 &lt;em&gt;데이터&lt;/em&gt; 주위에 배열 래퍼를 만듭니다 . 배열 플래그는 기본적으로 데이터 영역이 올바르게 작동하고 C 스타일로 연속적입니다. 어레이의 형상은 길이 &lt;em&gt;nd&lt;/em&gt; 의 &lt;em&gt;딤&lt;/em&gt; c- 배열에 의해 주어진다 . 배열의 데이터 유형은 &lt;em&gt;typenum&lt;/em&gt; 으로 표시됩니다 . 데이터가 참조 횟수가 지정된 다른 Python 객체에서 가져온 경우 포인터가 전달 된 후이 객체의 참조 횟수를 늘려야하며 반환 된 ndarray의 기본 멤버는 데이터를 소유 한 Python 객체를 가리켜 야합니다. 이렇게하면 반환 된 배열이 존재하는 동안 제공된 메모리가 해제되지 않습니다. ndarray가 할당 해제 되 자마자 메모리를 해제하려면 반환 된 ndarray에서 OWNDATA 플래그를 설정하십시오.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="47d4d6e775fe88f4b80d5ea4c370f0f98678742c" translate="yes" xml:space="preserve">
          <source>Create an array x, with a reference y and a copy z:</source>
          <target state="translated">참조 y와 사본 z를 사용하여 배열 x를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="edf37af870193c853e5704f79fa46afda7f8ab49" translate="yes" xml:space="preserve">
          <source>Create an array, but leave its allocated memory unchanged (i.e., it contains &amp;ldquo;garbage&amp;rdquo;).</source>
          <target state="translated">배열을 만들되 할당 된 메모리를 변경하지 않은 채로 둡니다 (즉, &quot;쓰레기&quot;가 포함되어 있음).</target>
        </trans-unit>
        <trans-unit id="f8c0528bb084a014ea88bd25616f60c460edbaf2" translate="yes" xml:space="preserve">
          <source>Create an array, each element of which is zero.</source>
          <target state="translated">각 요소가 0 인 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="415b3ad3f5d5fec6811715fcb43c61600d019de3" translate="yes" xml:space="preserve">
          <source>Create an array.</source>
          <target state="translated">배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="efc38388dbd54fefe6577db0dc2a6d52f3139f02" translate="yes" xml:space="preserve">
          <source>Create and add an Extension instance to the ext_modules list. This method also takes the following optional keyword arguments that are passed on to the Extension constructor.</source>
          <target state="translated">확장 인스턴스를 작성하여 ext_modules 목록에 추가하십시오. 이 메소드는 또한 확장 생성자에 전달되는 다음 선택적 키워드 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="2ce4b69bed16e520597783987ce2ba31407bbf8f" translate="yes" xml:space="preserve">
          <source>Create and array.</source>
          <target state="translated">작성하고 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="47f0f6dfd19f6638cbffe16ed61164856442a40f" translate="yes" xml:space="preserve">
          <source>Create and plot a band-limited signal with random phases:</source>
          <target state="translated">랜덤 위상으로 대역 제한 신호를 생성하고 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="655209fbd053b66333cb2ad561c140174943d616" translate="yes" xml:space="preserve">
          <source>Create and plot an image with band-limited frequency content:</source>
          <target state="translated">대역 제한 주파수 내용으로 이미지를 작성하고 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="383101a807508f28ca3ca4eeb51cf4c39ba642f6" translate="yes" xml:space="preserve">
          <source>Create and return a ctypes object from a numpy array. Actually anything that exposes the __array_interface__ is accepted.</source>
          <target state="translated">numpy 배열에서 ctypes 객체를 만들고 반환합니다. 실제로 __array_interface__를 노출시키는 모든 것이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="a48e85aeb37d4861d852029c32e85348705a141a" translate="yes" xml:space="preserve">
          <source>Create and return a new object.</source>
          <target state="translated">새 객체를 만들어 반환합니다.</target>
        </trans-unit>
        <trans-unit id="4624b630f46c030fc80adec33ba7cfd098ce660b" translate="yes" xml:space="preserve">
          <source>Create and return a new object. See help(type) for accurate signature.</source>
          <target state="translated">새 객체를 만들어 반환합니다. 정확한 서명은 help (type)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0f91b98f5452e2c2460f51aa523deeb885a2d07f" translate="yes" xml:space="preserve">
          <source>Create diagonal arrays.</source>
          <target state="translated">대각선 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="391f555392e014f93bf9364fc1af0a11257ae60d" translate="yes" xml:space="preserve">
          <source>Create nditers for use in nested loops</source>
          <target state="translated">중첩 루프에 사용할 nditer 생성</target>
        </trans-unit>
        <trans-unit id="cae0d44191595c4c5d6b5d99613364849c4f295d" translate="yes" xml:space="preserve">
          <source>Create or load a memory-mapped &lt;code&gt;.npy&lt;/code&gt; file.</source>
          <target state="translated">메모리 매핑 된 &lt;code&gt;.npy&lt;/code&gt; 파일을 만들거나로드 하십시오.</target>
        </trans-unit>
        <trans-unit id="9040f175bb70c201bfb2817bf6bea6562fe6e4f5" translate="yes" xml:space="preserve">
          <source>Create or overwrite existing file for reading and writing.</source>
          <target state="translated">읽고 쓸 기존 파일을 작성하거나 덮어 씁니다.</target>
        </trans-unit>
        <trans-unit id="7d3e4465c7d12c41465d4474c631ce7fad0815ab" translate="yes" xml:space="preserve">
          <source>Create release notes for next release and edit them to set the version:</source>
          <target state="translated">다음 릴리스에 대한 릴리스 정보를 작성하고 편집하여 버전을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="717b0ffdfb69768de82b5a9ca6575ed22e884026" translate="yes" xml:space="preserve">
          <source>Create the fork repo</source>
          <target state="translated">포크 저장소 만들기</target>
        </trans-unit>
        <trans-unit id="ccfa8e99c8012683a7ba3bd391a6f3c7a84556b0" translate="yes" xml:space="preserve">
          <source>Create your own forked copy of &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; 의 분기 된 복사본 만들기</target>
        </trans-unit>
        <trans-unit id="61846b313aa9245b09505ad8b0e04ecefa609640" translate="yes" xml:space="preserve">
          <source>Create your own forked copy of NumPy</source>
          <target state="translated">NumPy의 분기 된 복사본 만들기</target>
        </trans-unit>
        <trans-unit id="58d0f155eb04fd57d6905d8542d41ea23a2730f2" translate="yes" xml:space="preserve">
          <source>Creates a copy of the array with its elements rearranged in such a way that the value of the element in k-th position is in the position it would be in a sorted array. All elements smaller than the k-th element are moved before this element and all equal or greater are moved behind it. The ordering of the elements in the two partitions is undefined.</source>
          <target state="translated">k 번째 위치에있는 요소의 값이 정렬 된 배열에있는 위치에있는 방식으로 요소가 재 배열 된 배열의 복사본을 만듭니다. k 번째 요소보다 작은 모든 요소는이 요소보다 먼저 이동하고 같거나 큰 요소는 그 뒤로 이동합니다. 두 파티션의 요소 순서는 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f7413e806f1e7017ca021144131a6ec01d636c42" translate="yes" xml:space="preserve">
          <source>Creates an iterator for broadcasting the &lt;code&gt;nop&lt;/code&gt; array objects provided in &lt;code&gt;op&lt;/code&gt;, using regular NumPy broadcasting rules.</source>
          <target state="translated">일반 NumPy 브로드 캐스트 규칙을 사용하여 &lt;code&gt;op&lt;/code&gt; 에 제공된 &lt;code&gt;nop&lt;/code&gt; 배열 객체 를 브로드 캐스팅하기위한 반복자를 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="a06033694dc7625f6a25df5e7e99097ece139dbb" translate="yes" xml:space="preserve">
          <source>Creates an iterator for the given numpy array object &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">지정된 numpy 배열 객체 &lt;code&gt;op&lt;/code&gt; 의 반복자를 작성합니다 .</target>
        </trans-unit>
        <trans-unit id="78828519e213a24466ffb5a259ee09315af2dd29" translate="yes" xml:space="preserve">
          <source>Creating a brand-new ndarray</source>
          <target state="translated">새로운 ndarray 만들기</target>
        </trans-unit>
        <trans-unit id="4c9a2fc32b270bbf859d7e8b444ca05b83cb8242" translate="yes" xml:space="preserve">
          <source>Creating a compiled extension module</source>
          <target state="translated">컴파일 된 확장 모듈 만들기</target>
        </trans-unit>
        <trans-unit id="820c06a933939c73d0a9ac20d7eebafd53283b18" translate="yes" xml:space="preserve">
          <source>Creating a mask</source>
          <target state="translated">마스크 만들기</target>
        </trans-unit>
        <trans-unit id="22c58c7da34bb9f0e0421a8ca349dd28b6296e32" translate="yes" xml:space="preserve">
          <source>Creating a new universal function</source>
          <target state="translated">새로운 범용 기능 생성</target>
        </trans-unit>
        <trans-unit id="021b57ac73287317d5590d713033a11127224262" translate="yes" xml:space="preserve">
          <source>Creating a view on a structured array so it can be used in calculations</source>
          <target state="translated">계산에 사용할 수 있도록 구조화 된 배열에서보기 만들기</target>
        </trans-unit>
        <trans-unit id="98d1b3c0571161e2acd40362a47356cdc1716fa1" translate="yes" xml:space="preserve">
          <source>Creating aligned structs: In order to know how to offset a field when &lt;code&gt;align=True&lt;/code&gt;, numpy looks up &lt;code&gt;field.dtype.alignment&lt;/code&gt;. This includes fields which are nested structured arrays.</source>
          <target state="translated">정렬 된 구조체 생성 : &lt;code&gt;align=True&lt;/code&gt; 일 때 필드를 오프셋하는 방법을 알기 위해 numpy는 &lt;code&gt;field.dtype.alignment&lt;/code&gt; 를 찾습니다 . 여기에는 중첩 구조화 된 배열 인 필드가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d41cf53fbab96d2f7a854a59cb350d9b2f249330" translate="yes" xml:space="preserve">
          <source>Creating an array from sub-classes:</source>
          <target state="translated">서브 클래스에서 배열 만들기 :</target>
        </trans-unit>
        <trans-unit id="8c75c1be94407cd0140876081367297865708e3a" translate="yes" xml:space="preserve">
          <source>Creating arrays</source>
          <target state="translated">배열 만들기</target>
        </trans-unit>
        <trans-unit id="c3f30a8cafd252b4d8cf955140bef8bdccce3b29" translate="yes" xml:space="preserve">
          <source>Creating arrays from raw bytes through the use of strings or buffers</source>
          <target state="translated">문자열 또는 버퍼를 사용하여 원시 바이트에서 배열 만들기</target>
        </trans-unit>
        <trans-unit id="b0ac33e8f2407adfe99099892032a5786f48a98d" translate="yes" xml:space="preserve">
          <source>Creating character arrays (&lt;code&gt;numpy.char&lt;/code&gt;)</source>
          <target state="translated">문자형 배열 만들기 ( &lt;code&gt;numpy.char&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="46432ea81a249419eb894b0e722ae04982146aa4" translate="yes" xml:space="preserve">
          <source>Creating character arrays (numpy.char)</source>
          <target state="translated">문자형 배열 만들기 (numpy.char)</target>
        </trans-unit>
        <trans-unit id="a79124329baf0d3880f6e8bd974face711ed90d3" translate="yes" xml:space="preserve">
          <source>Creating data types</source>
          <target state="translated">데이터 타입 생성</target>
        </trans-unit>
        <trans-unit id="041afd4fab4d27db13480cd70d8faa7a30aa36a4" translate="yes" xml:space="preserve">
          <source>Creating how-tos helps us see NumPy usability through new eyes.</source>
          <target state="translated">방법을 작성하면 새로운 시각을 통해 NumPy 유용성을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3623ceac932f771e89eb47270eaee4ca0c39adaa" translate="yes" xml:space="preserve">
          <source>Creating iterators for nested iteration requires some care. All the iterator operands must match exactly, or the calls to &lt;a href=&quot;#c.NpyIter_ResetBasePointers&quot;&gt;&lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt;&lt;/a&gt; will be invalid. This means that automatic copies and output allocation should not be used haphazardly. It is possible to still use the automatic data conversion and casting features of the iterator by creating one of the iterators with all the conversion parameters enabled, then grabbing the allocated operands with the &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; function and passing them into the constructors for the rest of the iterators.</source>
          <target state="translated">중첩 된 반복을위한 반복자를 작성하려면 약간의주의가 필요합니다. 모든 반복자 피연산자가 정확히 일치해야합니다 . &lt;a href=&quot;#c.NpyIter_ResetBasePointers&quot;&gt; &lt;code&gt;NpyIter_ResetBasePointers&lt;/code&gt; &lt;/a&gt; 대한 호출 이 유효하지 않습니다. 즉, 자동 사본 및 출력 할당을 우연히 사용해서는 안됩니다. 모든 변환 매개 변수가 활성화 된 반복자 중 하나를 만든 다음 &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; 함수를 사용하여 할당 된 피연산자를 잡고 나머지 반복기의 생성자에 전달 하여 반복자의 자동 데이터 변환 및 캐스트 기능을 계속 사용할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="c5120a7c7085b0117ed81c3444ff1fdacef6c111" translate="yes" xml:space="preserve">
          <source>Creating many similar tests</source>
          <target state="translated">많은 유사한 테스트 만들기</target>
        </trans-unit>
        <trans-unit id="cd65696c60dbcb551b3daf8b05a72fdadc9b03e3" translate="yes" xml:space="preserve">
          <source>Creating matrices</source>
          <target state="translated">행렬 만들기</target>
        </trans-unit>
        <trans-unit id="8ce41076023051e5ea6ac0164916e896e2479308" translate="yes" xml:space="preserve">
          <source>Creating new content</source>
          <target state="translated">새로운 콘텐츠 만들기</target>
        </trans-unit>
        <trans-unit id="f8566f4a691c15a8a1f5c39fe579a737ee96da57" translate="yes" xml:space="preserve">
          <source>Creating new from template</source>
          <target state="translated">템플릿에서 새로 만들기</target>
        </trans-unit>
        <trans-unit id="1dcddc1ce5a75de776531479edb4473eaa2354c5" translate="yes" xml:space="preserve">
          <source>Creating record arrays (&lt;code&gt;numpy.rec&lt;/code&gt;)</source>
          <target state="translated">레코드 배열 만들기 ( &lt;code&gt;numpy.rec&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="12ca61a4de400f605aa79c20a0e04cfbaf0dcca2" translate="yes" xml:space="preserve">
          <source>Creating source for a basic extension module</source>
          <target state="translated">기본 확장 모듈의 소스 생성</target>
        </trans-unit>
        <trans-unit id="63696d372e0aaf637bc994c371bc42b8f6e4087e" translate="yes" xml:space="preserve">
          <source>Creating structured datatypes with fields aligned like in a C-struct.</source>
          <target state="translated">C-struct에서와 같이 필드가 정렬 된 구조화 된 데이터 유형 작성</target>
        </trans-unit>
        <trans-unit id="2712464a5e2217c7128b08bcbdf2f7946d38c558" translate="yes" xml:space="preserve">
          <source>Creating sub-types</source>
          <target state="translated">하위 유형 생성</target>
        </trans-unit>
        <trans-unit id="96d205bb00cdfe3e870ea73a689c67cb6a768ed7" translate="yes" xml:space="preserve">
          <source>Creating the so-called signature file that contains descriptions of wrappers to Fortran or C functions, also called as signatures of the functions. In the case of Fortran routines, F2PY can create initial signature file by scanning Fortran source codes and catching all relevant information needed to create wrapper functions.</source>
          <target state="translated">함수의 서명이라고도하는 Fortran 또는 C 함수에 대한 래퍼에 대한 설명이 포함 된 소위 서명 파일을 만듭니다. Fortran 루틴의 경우 F2PY는 Fortran 소스 코드를 스캔하고 래퍼 함수를 ​​만드는 데 필요한 모든 관련 정보를 포착하여 초기 서명 파일을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e13e0554f557ba882751e261b5a60777b337bea6" translate="yes" xml:space="preserve">
          <source>Creation</source>
          <target state="translated">Creation</target>
        </trans-unit>
        <trans-unit id="992b553e540425ae3d718ae9cdd9d55e984ad9f2" translate="yes" xml:space="preserve">
          <source>Cross referencing issues</source>
          <target state="translated">상호 참조 문제</target>
        </trans-unit>
        <trans-unit id="5f939e5434d3a238da77ef47c3189ac69e40c937" translate="yes" xml:space="preserve">
          <source>Cross-correlation of two 1-dimensional sequences.</source>
          <target state="translated">두 개의 1 차원 시퀀스의 상호 상관.</target>
        </trans-unit>
        <trans-unit id="ce4fe4b7616cb7e3999589959d2a7bacb5e2b9bf" translate="yes" xml:space="preserve">
          <source>Cube each element in a list.</source>
          <target state="translated">목록에서 각 요소를 큐브로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="35d2dd9044075a5eeee0547937f5a104ae8c8661" translate="yes" xml:space="preserve">
          <source>Cube each element in an array.</source>
          <target state="translated">배열의 각 요소를 큐브합니다.</target>
        </trans-unit>
        <trans-unit id="cef7283ebb85e8146a8a72c4b6a145c8d059da03" translate="yes" xml:space="preserve">
          <source>Cumulative product across array propagating NaNs.</source>
          <target state="translated">어레이 전파 NaN에 걸친 누적 생성물.</target>
        </trans-unit>
        <trans-unit id="5e3b67811bb5290b6df8dbec735818173117ec67" translate="yes" xml:space="preserve">
          <source>Cumulative sum across array propagating NaNs.</source>
          <target state="translated">어레이 전파 NaN에 대한 누적 합계.</target>
        </trans-unit>
        <trans-unit id="7f04d49b0ca659708fb8cdf77308d17fd7ecaa88" translate="yes" xml:space="preserve">
          <source>Cumulative sum of array elements.</source>
          <target state="translated">배열 요소의 누적 합.</target>
        </trans-unit>
        <trans-unit id="be1f93951f8385e05b64a90a07a9e0bcf5915f65" translate="yes" xml:space="preserve">
          <source>Current build and release info</source>
          <target state="translated">현재 빌드 및 릴리스 정보</target>
        </trans-unit>
        <trans-unit id="140e87163ac45492f58df33d7f85da346c418f4c" translate="yes" xml:space="preserve">
          <source>Current flat index into the array.</source>
          <target state="translated">배열에 대한 현재 플랫 인덱스.</target>
        </trans-unit>
        <trans-unit id="ac8d8307cb5f245348dc52bf7e74dacfa1f5d300" translate="yes" xml:space="preserve">
          <source>Current mask.</source>
          <target state="translated">현재 마스크.</target>
        </trans-unit>
        <trans-unit id="6d822d8eae2a5586708d12f293da8fa609a9719e" translate="yes" xml:space="preserve">
          <source>Current steering council and institutional partners</source>
          <target state="translated">현재 운영위원회 및 기관 파트너</target>
        </trans-unit>
        <trans-unit id="cd5147b0a52164a4549e9b585f0ff08d7760a518" translate="yes" xml:space="preserve">
          <source>Current vision for the documentation: NEP 44</source>
          <target state="translated">문서에 대한 현재 비전 : NEP 44</target>
        </trans-unit>
        <trans-unit id="e18fc4f0ee67a5e9ebb69623c0e9e58a258e5764" translate="yes" xml:space="preserve">
          <source>Currently F2PY uses &lt;code&gt;use&lt;/code&gt; statement only for linking call-back modules and &lt;code&gt;external&lt;/code&gt; arguments (call-back functions), see &lt;a href=&quot;python-usage#call-back-arguments&quot;&gt;Call-back arguments&lt;/a&gt;.</source>
          <target state="translated">현재 F2PY는 콜백 모듈과 &lt;code&gt;external&lt;/code&gt; 인수 (콜백 함수) 를 연결하기 위해서만 &lt;code&gt;use&lt;/code&gt; 문을 사용 합니다 . &lt;a href=&quot;python-usage#call-back-arguments&quot;&gt;콜백 인수를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="df3e2af3c9d9f82f00a46adce3db218a6d9d7bd8" translate="yes" xml:space="preserve">
          <source>Currently SciPy project consists of two packages:</source>
          <target state="translated">현재 SciPy 프로젝트는 두 가지 패키지로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="4c8eba10595ddae0a34a9053064e392f6c153817" translate="yes" xml:space="preserve">
          <source>Currently unused. Reserved for future use in caching hash values.</source>
          <target state="translated">현재 미사용. 나중에 해시 값을 캐싱하는 데 사용하도록 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="145cfe69f9ee12a7e63bf71c0687c6ce0c39cf65" translate="yes" xml:space="preserve">
          <source>Currently, F2PY can handle only &lt;code&gt;&amp;lt;type spec&amp;gt;(kind=&amp;lt;kindselector&amp;gt;)&lt;/code&gt; declarations where &lt;code&gt;&amp;lt;kindselector&amp;gt;&lt;/code&gt; is a numeric integer (e.g. 1, 2, 4,&amp;hellip;), but not a function call &lt;code&gt;KIND(..)&lt;/code&gt; or any other expression. F2PY needs to know what would be the corresponding C type and a general solution for that would be too complicated to implement.</source>
          <target state="translated">현재 F2PY는 &lt;code&gt;&amp;lt;type spec&amp;gt;(kind=&amp;lt;kindselector&amp;gt;)&lt;/code&gt; 선언 만 처리 할 수 ​​있습니다. 여기서 &lt;code&gt;&amp;lt;kindselector&amp;gt;&lt;/code&gt; 는 숫자 정수 (예 : 1, 2, 4,&amp;hellip;)이지만 함수 호출 &lt;code&gt;KIND(..)&lt;/code&gt; 또는 기타 표현. F2PY는 해당 C 유형이 무엇인지 알아야하며 이에 대한 일반적인 솔루션은 구현하기 너무 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="f631f9b1db6465c5c04372152e01854b72379e32" translate="yes" xml:space="preserve">
          <source>Currently, if the dtypes of two void structured arrays are not equivalent the comparison fails, returning the scalar value &lt;code&gt;False&lt;/code&gt;. This behavior is deprecated as of numpy 1.10 and will raise an error or perform elementwise comparison in the future.</source>
          <target state="translated">현재, 두 개의 void 구조화 배열의 dtype이 동일하지 않으면 비교가 실패하고 스칼라 값 &lt;code&gt;False&lt;/code&gt; 를 반환합니다 . 이 동작은 numpy 1.10부터 더 이상 사용되지 않으며 오류가 발생하거나 향후 요소 별 비교를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="3f68764d7b78c95b99b7a50768f974a72eb6b57d" translate="yes" xml:space="preserve">
          <source>Currently, multiline blocks can be used in the following constructs:</source>
          <target state="translated">현재 여러 줄 블록은 다음 구성에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ec971cf59e41bf03ff0b8ea0be4953b0a386b53" translate="yes" xml:space="preserve">
          <source>Custom Binary Formats</source>
          <target state="translated">커스텀 바이너리 형식</target>
        </trans-unit>
        <trans-unit id="06783a663f807b884b2eb6d800592782869e00d8" translate="yes" xml:space="preserve">
          <source>Custom Weekmasks</source>
          <target state="translated">커스텀 위크 마스크</target>
        </trans-unit>
        <trans-unit id="1d0b954477df12202d9d55dc07f21f80ba093bd7" translate="yes" xml:space="preserve">
          <source>Custom formatter for printing arrays</source>
          <target state="translated">어레이 인쇄를위한 맞춤형 포맷터</target>
        </trans-unit>
        <trans-unit id="3966644e2ea8e16e33b47c7b0116b4a1b709d7fa" translate="yes" xml:space="preserve">
          <source>Customize compiler using distutils command.</source>
          <target state="translated">distutils 명령을 사용하여 컴파일러를 사용자 정의하십시오.</target>
        </trans-unit>
        <trans-unit id="64b498274251dc846a8266e75b8161b55fdddd9a" translate="yes" xml:space="preserve">
          <source>Customizing Your Environment</source>
          <target state="translated">환경 사용자 지정</target>
        </trans-unit>
        <trans-unit id="ef1b3465e9776c774ffa90581bb683aac3f7f945" translate="yes" xml:space="preserve">
          <source>Customizing your environment</source>
          <target state="translated">환경 사용자 지정</target>
        </trans-unit>
        <trans-unit id="de17aeb8ce7893d8e4e28838507dc6ef7fed1ff4" translate="yes" xml:space="preserve">
          <source>Cut and paste the &lt;code&gt;release/README.md&lt;/code&gt; file contents into the text window.</source>
          <target state="translated">&lt;code&gt;release/README.md&lt;/code&gt; 파일 내용을 잘라내어 텍스트 창에 붙여 넣습니다 .</target>
        </trans-unit>
        <trans-unit id="5794c902f31f869d8d4450d4791299177dd6f5bf" translate="yes" xml:space="preserve">
          <source>Cut-off ratio for small singular values of &lt;code&gt;a&lt;/code&gt;. For the purposes of rank determination, singular values are treated as zero if they are smaller than &lt;code&gt;rcond&lt;/code&gt; times the largest singular value of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">작은 특이 값에 대한 차단 비율 . 순위 결정을 위해 특이 값은 &lt;code&gt;rcond&lt;/code&gt; 의 최대 특이 값 &lt;code&gt;a&lt;/code&gt; 의rcond 보다 작 으면 0으로 처리됩니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="963e5a96bd3d87f0909e596539f6dfa7d84581ea" translate="yes" xml:space="preserve">
          <source>Cutoff for small singular values. Singular values less than or equal to &lt;code&gt;rcond * largest_singular_value&lt;/code&gt; are set to zero. Broadcasts against the stack of matrices.</source>
          <target state="translated">작은 특이 값에 대한 컷오프. &lt;code&gt;rcond * largest_singular_value&lt;/code&gt; 보다 작거나 같은 특이 값 은 0으로 설정됩니다. 행렬 스택에 대해 브로드 캐스트합니다.</target>
        </trans-unit>
        <trans-unit id="55b3718b804d3ea7ee851e585782dfffc4ddaa91" translate="yes" xml:space="preserve">
          <source>Cygwin 98-4.10, Python 2.1.1(MSC) - echo tests fail i.e. redefining environment variables may not work. FIXED: don&amp;rsquo;t use cygwin echo! Comment: also &lt;code&gt;cmd /c echo&lt;/code&gt; will not work but redefining environment variables do work.</source>
          <target state="translated">Cygwin 98-4.10, Python 2.1.1 (MSC)-에코 테스트가 실패합니다. 다시 정의하면 환경 변수가 재정의되지 않을 수 있습니다. 수정 : cygwin echo를 사용하지 마십시오! 주석 : 또한 &lt;code&gt;cmd /c echo&lt;/code&gt; 는 작동하지 않지만 재정의 환경 변수는 작동합니다.</target>
        </trans-unit>
        <trans-unit id="a512b3fa69c6f1d48fcf3a95fedda64e98719115" translate="yes" xml:space="preserve">
          <source>Cygwin 98-4.10, Python 2.3.3(cygming special)</source>
          <target state="translated">Cygwin 98-4.10, Python 2.3.3 (사이클링 스페셜)</target>
        </trans-unit>
        <trans-unit id="39b8f070b55c1bb2bcdf01997cdd384c00db9971" translate="yes" xml:space="preserve">
          <source>Cython</source>
          <target state="translated">Cython</target>
        </trans-unit>
        <trans-unit id="898ed53167a601efcad103a351ac74f0deab9018" translate="yes" xml:space="preserve">
          <source>Cython API for random</source>
          <target state="translated">랜덤을위한 Cython API</target>
        </trans-unit>
        <trans-unit id="5b09f0f52904095d26507661044a8d945b4a254e" translate="yes" xml:space="preserve">
          <source>Cython access to the random distributions is provided via a &lt;code&gt;pxd&lt;/code&gt; file</source>
          <target state="translated">무작위 분포에 대한 Cython 액세스는 &lt;code&gt;pxd&lt;/code&gt; 파일을 통해 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="cab171f549e39f88e9fb2ae5bfbde7bb14d36360" translate="yes" xml:space="preserve">
          <source>Cython can be used to directly access the functions in &lt;code&gt;numpy/random/c_distributions.pxd&lt;/code&gt;. This requires linking with the &lt;code&gt;npyrandom&lt;/code&gt; library located in &lt;code&gt;numpy/random/lib&lt;/code&gt;.</source>
          <target state="translated">Cython을 사용하여 &lt;code&gt;numpy/random/c_distributions.pxd&lt;/code&gt; 의 함수에 직접 액세스 할 수 있습니다 . 이를 위해서는 &lt;code&gt;numpy/random/lib&lt;/code&gt; 에 있는 &lt;code&gt;npyrandom&lt;/code&gt; 라이브러리 와 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d33edb994024c4ec1cd5e1f6bde059373980991" translate="yes" xml:space="preserve">
          <source>Cython can be used to unpack the &lt;code&gt;PyCapsule&lt;/code&gt; provided by a BitGenerator. This example uses &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; and the example from above. The usual caveats for writing high-performance code using Cython &amp;ndash; removing bounds checks and wrap around, providing array alignment information &amp;ndash; still apply.</source>
          <target state="translated">Cython을 사용하여 &lt;code&gt;PyCapsule&lt;/code&gt; 제공 하는 PyCapsule의 압축을 풀 수 있습니다 . 이 예에서는 &lt;a href=&quot;bit_generators/pcg64#numpy.random.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 와 위의 예를 사용합니다. Cython을 사용하여 고성능 코드를 작성하는 일반적인주의 사항 (경계 검사 및 랩 어라운드 제거, 배열 정렬 정보 제공)은 여전히 ​​적용됩니다.</target>
        </trans-unit>
        <trans-unit id="3b507900d710138d9fc14b9bf7ca033f1876815b" translate="yes" xml:space="preserve">
          <source>Cython can be used to unpack the &lt;code&gt;PyCapsule&lt;/code&gt; provided by a BitGenerator. This example uses &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt;&lt;code&gt;PCG64&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;random_gauss_zig&lt;/code&gt;, the Ziggurat-based generator for normals, to fill an array. The usual caveats for writing high-performance code using Cython &amp;ndash; removing bounds checks and wrap around, providing array alignment information &amp;ndash; still apply.</source>
          <target state="translated">Cython을 사용하여 &lt;code&gt;PyCapsule&lt;/code&gt; 제공 하는 PyCapsule의 압축을 풀 수 있습니다 . 이 예제는 배열을 채우기 위해 &lt;a href=&quot;bit_generators/pcg64#numpy.random.pcg64.PCG64&quot;&gt; &lt;code&gt;PCG64&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;random_gauss_zig&lt;/code&gt; 에 대한 Ziggurat 기반 생성기 random_gauss_zig 를 사용합니다. Cython을 사용하여 고성능 코드를 작성하는 일반적인주의 사항 &amp;ndash; 경계 검사 및 줄 바꿈 제거, 배열 정렬 정보 제공 &amp;ndash; 여전히 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="88359b7dfcae29dfe670a173f005b5e46f30ab8e" translate="yes" xml:space="preserve">
          <source>Cython is the extension mechanism of choice for several scientific Python libraries, including Scipy, Pandas, SAGE, scikit-image and scikit-learn, as well as the XML processing library LXML. The language and compiler are well-maintained.</source>
          <target state="translated">Cython은 Scipy, Pandas, SAGE, scikit-image 및 scikit-learn과 XML 처리 라이브러리 LXML을 포함한 여러 과학 Python 라이브러리에서 선택하는 확장 메커니즘입니다. 언어와 컴파일러는 잘 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="50c9e8d5fc98727b4bbc93cf5d64a68db647f04f" translate="yes" xml:space="preserve">
          <source>D</source>
          <target state="translated">D</target>
        </trans-unit>
        <trans-unit id="9c77f3b5da6a716c0c8711c7937fc207582f88d6" translate="yes" xml:space="preserve">
          <source>D. J. Hand, F. Daly, D. Lunn, E. Ostrowski, A Handbook of Small Data Sets, CRC Press, 1994.</source>
          <target state="translated">DJ Hand, F. Daly, D. Lunn, E. Ostrowski, 소형 데이터 세트 핸드북, CRC Press, 1994.</target>
        </trans-unit>
        <trans-unit id="9e1a42a64a9db004ac248d750b3e5535fe6705bf" translate="yes" xml:space="preserve">
          <source>DECREF&amp;rsquo;s an array object which may have the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set without causing the contents to be copied back into the original array. Resets the &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; flag on the base object. This is useful for recovering from an error condition when writeback semantics are used, but will lead to wrong results.</source>
          <target state="translated">DECREF는 (더 이상 사용되지 않는) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그를 설정하여 내용이 원래 배열로 다시 복사 되지 않도록하는 배열 객체입니다 . 기본 개체 에서 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 플래그를 재설정 합니다. 이것은 후기 입 의미론을 사용할 때 오류 조건에서 복구하는 데 유용하지만 잘못된 결과를 초래합니다.</target>
        </trans-unit>
        <trans-unit id="1432cc84312bd2af2149f0a870c96ad0e9bfb0d4" translate="yes" xml:space="preserve">
          <source>DTypeLike</source>
          <target state="translated">DTypeLike</target>
        </trans-unit>
        <trans-unit id="62c4f5e8f3e17d3ec22760be4806239a479b50bf" translate="yes" xml:space="preserve">
          <source>Dalgaard, Peter, &amp;ldquo;Introductory Statistics With R&amp;rdquo;, Springer, 2002.</source>
          <target state="translated">Dalgaard, Peter, &quot;R의 입문 통계&quot;, Springer, 2002.</target>
        </trans-unit>
        <trans-unit id="5101f6a6ee46d3f6405ba78646fba174a0c2beec" translate="yes" xml:space="preserve">
          <source>Dalgaard, Peter, &amp;ldquo;Introductory Statistics with R&amp;rdquo;, Springer-Verlag, 2002.</source>
          <target state="translated">Dalgaard, Peter, &quot;R에 대한 기초 통계&quot;, Springer-Verlag, 2002.</target>
        </trans-unit>
        <trans-unit id="4553061944cf001ceb7836359a71ad75f6dced22" translate="yes" xml:space="preserve">
          <source>Daniel Lemire., &amp;ldquo;Fast Random Integer Generation in an Interval&amp;rdquo;, ACM Transactions on Modeling and Computer Simulation 29 (1), 2019, &lt;a href=&quot;http://arxiv.org/abs/1805.10941&quot;&gt;http://arxiv.org/abs/1805.10941&lt;/a&gt;.</source>
          <target state="translated">Daniel Lemire.,&amp;ldquo;간격에서의 빠른 랜덤 정수 생성&amp;rdquo;, ACM 모델링 및 컴퓨터 시뮬레이션에 관한 29, 2019, &lt;a href=&quot;http://arxiv.org/abs/1805.10941&quot;&gt;http://arxiv.org/abs/1805.10941&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="113175791679ca4bf1437eb8dddcca9913bbf5b9" translate="yes" xml:space="preserve">
          <source>Daniel Lemire., &amp;ldquo;Fast Random Integer Generation in an Interval&amp;rdquo;, ACM Transactions on Modeling and Computer Simulation 29 (1), 2019, &lt;a href=&quot;https://arxiv.org/abs/1805.10941&quot;&gt;http://arxiv.org/abs/1805.10941&lt;/a&gt;.</source>
          <target state="translated">Daniel Lemire., &quot;간격의 빠른 임의 정수 생성&quot;, ACM Transactions on Modeling and Computer Simulation 29 (1), 2019, &lt;a href=&quot;https://arxiv.org/abs/1805.10941&quot;&gt;http://arxiv.org/abs/1805.10941&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4caaaf9cb8047a53fc77dfac273916c0e02f27d3" translate="yes" xml:space="preserve">
          <source>Darwin 7.2.0, Python 2.3</source>
          <target state="translated">다윈 7.2.0, 파이썬 2.3</target>
        </trans-unit>
        <trans-unit id="5022178af7e5aff72e419a94ea0af31d5816c478" translate="yes" xml:space="preserve">
          <source>Data Type API</source>
          <target state="translated">데이터 타입 API</target>
        </trans-unit>
        <trans-unit id="d173cb51d3ffa8369ddc5c7d9051236f920814da" translate="yes" xml:space="preserve">
          <source>Data access</source>
          <target state="translated">데이터 접근</target>
        </trans-unit>
        <trans-unit id="523c14055a678c599d9f00d61258747011db43d5" translate="yes" xml:space="preserve">
          <source>Data and dtype endianness don&amp;rsquo;t match, change dtype to match data</source>
          <target state="translated">데이터와 dtype 엔디안이 일치하지 않습니다. 데이터와 일치하도록 dtype을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="735479602dd9aae7423946b4c08fff04f057504a" translate="yes" xml:space="preserve">
          <source>Data and dtype endianness match, swap data and dtype</source>
          <target state="translated">데이터 및 dtype 엔디안 일치, 데이터 및 dtype 스왑</target>
        </trans-unit>
        <trans-unit id="835c3b4de5eb7adc697a6010300141561c8ef58d" translate="yes" xml:space="preserve">
          <source>Data and type endianness don&amp;rsquo;t match, change data to match dtype</source>
          <target state="translated">데이터와 엔디안 유형이 일치하지 않습니다. dtype과 일치하도록 데이터를 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="a459c7310b8e7648c0f1c03ad2fe7505060e920c" translate="yes" xml:space="preserve">
          <source>Data attribute containing the identity element for the ufunc, if it has one. If it does not, the attribute value is None.</source>
          <target state="translated">ufunc의 식별 요소 (있는 경우)를 포함하는 데이터 속성입니다. 그렇지 않은 경우 속성 값은 None입니다.</target>
        </trans-unit>
        <trans-unit id="e78e721c9c235ccee8159d0be9160af82084ef4c" translate="yes" xml:space="preserve">
          <source>Data attribute containing the number of arguments the ufunc takes, including optional ones.</source>
          <target state="translated">선택적 인수를 포함하여 ufunc가 인수의 수를 포함하는 데이터 속성입니다.</target>
        </trans-unit>
        <trans-unit id="03fe7a08b0b586a0b8eaaf0cdad9fc9b9cc9f6e6" translate="yes" xml:space="preserve">
          <source>Data attribute containing the number of arguments the ufunc treats as input.</source>
          <target state="translated">ufunc가 입력으로 취급하는 인수 수를 포함하는 데이터 속성.</target>
        </trans-unit>
        <trans-unit id="adfa3ffdeaf44e2dd6067b0132906bd6eef47e97" translate="yes" xml:space="preserve">
          <source>Data attribute containing the number of arguments the ufunc treats as output.</source>
          <target state="translated">ufunc가 출력으로 취급하는 인수 수를 포함하는 데이터 속성.</target>
        </trans-unit>
        <trans-unit id="692287ce05c432ce06118a7f5a56e29867abb305" translate="yes" xml:space="preserve">
          <source>Data attribute listing the data-type &amp;ldquo;Domain-Range&amp;rdquo; groupings the ufunc can deliver. The data-types are given using the character codes.</source>
          <target state="translated">ufunc가 제공 할 수있는 데이터 유형 &quot;도메인 범위&quot;그룹을 나열하는 데이터 속성입니다. 데이터 유형은 문자 코드를 사용하여 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="6f759d67f0ed55480a1c6b69e639c270645daf7f" translate="yes" xml:space="preserve">
          <source>Data in new &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; is in the &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; (C) order, unless otherwise specified, but, for example, &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;basic array slicing&lt;/a&gt; often produces &lt;a href=&quot;../glossary#term-view&quot;&gt;views&lt;/a&gt; in a different scheme.</source>
          <target state="translated">새로운 데이터 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; 는&lt;/a&gt; 에 &lt;a href=&quot;../glossary#term-row-major&quot;&gt;행 주요&lt;/a&gt; 예를 들어, 달리 명시하지 않는 한, (C) 순서 있지만 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;기본적인 어레이 슬라이스가&lt;/a&gt; 종종 발생 &lt;a href=&quot;../glossary#term-view&quot;&gt;뷰&lt;/a&gt; 다른 방식에있다.</target>
        </trans-unit>
        <trans-unit id="c0385a2191da01cdd85357b1f30dbba96a61452a" translate="yes" xml:space="preserve">
          <source>Data in new &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; is in the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt; (C) order, unless otherwise specified, but, for example, &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;basic array slicing&lt;/a&gt; often produces &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;views&lt;/a&gt; in a different scheme.</source>
          <target state="translated">달리 지정하지 않는 한 새 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 데이터 는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;행 메이저&lt;/a&gt; (C) 순서로되어 있지만, 예를 들어 &lt;a href=&quot;arrays.indexing#arrays-indexing&quot;&gt;기본 배열 슬라이싱은&lt;/a&gt; 종종 다른 방식으로 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;뷰&lt;/a&gt; 를 생성 합니다 .</target>
        </trans-unit>
        <trans-unit id="2d84a810e9789b8179eb08002b6e519db8fa8ce7" translate="yes" xml:space="preserve">
          <source>Data is always written in &amp;lsquo;C&amp;rsquo; order, independent of the order of &lt;code&gt;a&lt;/code&gt;. The data produced by this method can be recovered using the function fromfile().</source>
          <target state="translated">데이터는 항상 순서의 독립, 'C'순서로 작성 . 이 메소드로 생성 된 데이터는 fromfile () 함수를 사용하여 복구 할 수 있습니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e53167df8cb2fa7234110a0a44d40ca2cbd6313" translate="yes" xml:space="preserve">
          <source>Data items are converted to the nearest compatible Python type. Masked values are converted to &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is None, the corresponding entries in the output list will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">데이터 항목은 가장 가까운 호환 가능한 Python 유형으로 변환됩니다. 마스크 된 값은 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 . 경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 포함되지 않은 경우, 출력에서의 대응하는 엔트리가 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7267220cb18bbd3fbaa14cb18866618233c8d0a4" translate="yes" xml:space="preserve">
          <source>Data items are converted to the nearest compatible Python type. Masked values are converted to &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;. If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is None, the corresponding entries in the output list will be &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">데이터 항목은 가장 가까운 호환 가능한 Python 유형으로 변환됩니다. 마스크 된 값은 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 로 변환됩니다 . 경우 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 포함되지 않은 경우, 출력에서의 대응하는 엔트리가 없을 것 &lt;code&gt;None&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ac7e83183cb23b5999f887680eaa647e636fdc" translate="yes" xml:space="preserve">
          <source>Data read from the text file.</source>
          <target state="translated">텍스트 파일에서 읽은 데이터입니다.</target>
        </trans-unit>
        <trans-unit id="ab4616f27eff8ec482bc1f61a6613379d5019665" translate="yes" xml:space="preserve">
          <source>Data read from the text file. If &lt;code&gt;usemask&lt;/code&gt; is True, this is a masked array.</source>
          <target state="translated">텍스트 파일에서 읽은 데이터입니다. 경우 &lt;code&gt;usemask&lt;/code&gt; 은 True입니다,이 마스크 배열입니다.</target>
        </trans-unit>
        <trans-unit id="dadd6ac5ba02e2f7843ee180c516331cbdcd6a9f" translate="yes" xml:space="preserve">
          <source>Data sources</source>
          <target state="translated">데이터 소스</target>
        </trans-unit>
        <trans-unit id="c3c77ecb1755c1a69e821e1aaac71fd5ec5e7ec0" translate="yes" xml:space="preserve">
          <source>Data stored in the file. For &lt;code&gt;.npz&lt;/code&gt; files, the returned instance of NpzFile class must be closed to avoid leaking file descriptors.</source>
          <target state="translated">파일에 저장된 데이터. 들어 &lt;code&gt;.npz&lt;/code&gt; 파일, NpzFile 클래스의 반환 된 인스턴스는 파일 기술자 누수 방지하기 위해 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="b9d279299816a7c139a097762a532d3c7e26f292" translate="yes" xml:space="preserve">
          <source>Data to be averaged. Masked entries are not taken into account in the computation.</source>
          <target state="translated">평균화 할 데이터입니다. 마스크 된 항목은 계산에서 고려되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e03c72d9dcd23e4e11ad5552205bb89141629001" translate="yes" xml:space="preserve">
          <source>Data to be saved to a text file.</source>
          <target state="translated">텍스트 파일로 저장 될 데이터.</target>
        </trans-unit>
        <trans-unit id="ee503fe5765b8d9456bf21def7f9e06d2b12ebb6" translate="yes" xml:space="preserve">
          <source>Data type</source>
          <target state="translated">데이터 형식</target>
        </trans-unit>
        <trans-unit id="76ebf87ff7259b3fa1470e7263b48576e422cbfd" translate="yes" xml:space="preserve">
          <source>Data type code.</source>
          <target state="translated">데이터 타입 코드.</target>
        </trans-unit>
        <trans-unit id="5c6b1bdaee5cd22bebfa68fe22da8ae17ee32ebc" translate="yes" xml:space="preserve">
          <source>Data type containing field &lt;code&gt;col1&lt;/code&gt; (10-character string at byte position 0), &lt;code&gt;col2&lt;/code&gt; (32-bit float at byte position 10), and &lt;code&gt;col3&lt;/code&gt; (integers at byte position 14):</source>
          <target state="translated">&lt;code&gt;col1&lt;/code&gt; 필드 (바이트 위치 0에서 10 자 문자열), &lt;code&gt;col2&lt;/code&gt; (바이트 위치 10에서 32 비트 float) 및 &lt;code&gt;col3&lt;/code&gt; (바이트 위치 14의 정수 )을 포함하는 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="5323524ee17f1362827313c3d97940b4505408ab" translate="yes" xml:space="preserve">
          <source>Data type information</source>
          <target state="translated">데이터 타입 정보</target>
        </trans-unit>
        <trans-unit id="7f7a69abb16912ba94ab887a9c10ebbd9bc5371f" translate="yes" xml:space="preserve">
          <source>Data type objects</source>
          <target state="translated">데이터 타입 객체</target>
        </trans-unit>
        <trans-unit id="b653b6102e06af89505274160891e8ac6c604d2a" translate="yes" xml:space="preserve">
          <source>Data type objects (&lt;code&gt;dtype&lt;/code&gt;)</source>
          <target state="translated">데이터 유형 객체 ( &lt;code&gt;dtype&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="ac3315e5339816f58a1895e052b1e8c043da3b3c" translate="yes" xml:space="preserve">
          <source>Data type objects (dtype)</source>
          <target state="translated">데이터 타입 객체 (dtype)</target>
        </trans-unit>
        <trans-unit id="6823842611ba946501e490386387306a34e9ab02" translate="yes" xml:space="preserve">
          <source>Data type of the output.</source>
          <target state="translated">출력의 데이터 유형</target>
        </trans-unit>
        <trans-unit id="ad2794cd1bca0bb41de6b035d87955c6038747da" translate="yes" xml:space="preserve">
          <source>Data type of the output. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is None, the type of the data argument (&lt;code&gt;data.dtype&lt;/code&gt;) is used. If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not None and different from &lt;code&gt;data.dtype&lt;/code&gt;, a copy is performed.</source>
          <target state="translated">출력의 데이터 유형입니다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 아무도없는 데이터 인자 (유형 &lt;code&gt;data.dtype&lt;/code&gt; 는 ) 사용된다. 경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 에서 없음 다른되지 않습니다 &lt;code&gt;data.dtype&lt;/code&gt; , 사본이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="eae3a99bdeb47b16f78d7fea21224392e5ca6e46" translate="yes" xml:space="preserve">
          <source>Data type of the output. If &lt;code&gt;dtype&lt;/code&gt; is None, the type of the data argument (&lt;code&gt;data.dtype&lt;/code&gt;) is used. If &lt;code&gt;dtype&lt;/code&gt; is not None and different from &lt;code&gt;data.dtype&lt;/code&gt;, a copy is performed.</source>
          <target state="translated">출력의 데이터 유형 경우 &lt;code&gt;dtype&lt;/code&gt; 아무도없는 데이터 인자 (유형 &lt;code&gt;data.dtype&lt;/code&gt; 는 ) 사용된다. 경우 &lt;code&gt;dtype&lt;/code&gt; 에서 없음 다른되지 않습니다 &lt;code&gt;data.dtype&lt;/code&gt; , 사본이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9a65ce3721c38edabce27611aa8f46d66f3904ff" translate="yes" xml:space="preserve">
          <source>Data type of the result.</source>
          <target state="translated">결과의 데이터 유형</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
