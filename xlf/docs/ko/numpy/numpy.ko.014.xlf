<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="1f9c9c4e9b69dcd6586dbf80815cf3c44f18d220" translate="yes" xml:space="preserve">
          <source>Highlights</source>
          <target state="translated">Highlights</target>
        </trans-unit>
        <trans-unit id="00b07925679220cb801f1a4855d71039bbcccecc" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, Takuji Nishimura, Fran&amp;ccedil;ois Panneton, Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;Efficient Jump Ahead for F2-Linear Random Number Generators&amp;rdquo;, INFORMS JOURNAL ON COMPUTING, Vol. 20, No. 3, Summer 2008, pp. 385-390.</source>
          <target state="translated">하라 모토 히로시, 마츠모토 마코 모토, 니시무라 타쿠 지, 프랑수아 판네, 피에르 레쿠 에르 20, No. 3, 2008 년 여름, pp. 385-390.</target>
        </trans-unit>
        <trans-unit id="5fb511a742639c34c53d07c644e43f8a516d0a8b" translate="yes" xml:space="preserve">
          <source>Hiroshi Haramoto, Makoto Matsumoto, and Pierre L&amp;rsquo;Ecuyer, &amp;ldquo;A Fast Jump Ahead Algorithm for Linear Recurrences in a Polynomial Space&amp;rdquo;, Sequences and Their Applications - SETA, 290&amp;ndash;298, 2008.</source>
          <target state="translated">Hiroshi Haramoto, Makoto Matsumoto 및 Pierre L' Ecuyer, &quot;다항식 공간에서 선형 재발을위한 빠른 점프 어 헤드 알고리즘&quot;, 시퀀스 및 응용 프로그램-SETA, 290&amp;ndash;298, 2008.</target>
        </trans-unit>
        <trans-unit id="f16459104f92ab6b38aa265adb4ecbfc3768e303" translate="yes" xml:space="preserve">
          <source>Histogram</source>
          <target state="translated">Histogram</target>
        </trans-unit>
        <trans-unit id="9f573dd516c5fae818d100652937d22c8be8a33c" translate="yes" xml:space="preserve">
          <source>Histograms</source>
          <target state="translated">Histograms</target>
        </trans-unit>
        <trans-unit id="4ae9938f95b0f1ddca2c84e6c590258bb6c7a2fc" translate="yes" xml:space="preserve">
          <source>Historically, NumPy has provided a special matrix type, &lt;code&gt;np.matrix&lt;/code&gt;, which is a subclass of ndarray which makes binary operations linear algebra operations. You may see it used in some existing code instead of &lt;code&gt;np.array&lt;/code&gt;. So, which one to use?</source>
          <target state="translated">역사적으로 NumPy는 이진 연산을 선형 대수 연산으로 만드는 ndarray의 하위 클래스 인 특수 행렬 유형 &lt;code&gt;np.matrix&lt;/code&gt; 를 제공했습니다 . &lt;code&gt;np.array&lt;/code&gt; 대신 기존 코드에서 사용되는 것을 볼 수 있습니다 . 그래서 어떤 것을 사용할까요?</target>
        </trans-unit>
        <trans-unit id="08c95aa82b69eff297d0839c133733de00ba649c" translate="yes" xml:space="preserve">
          <source>Hit the &lt;code&gt;{Publish,Update} release&lt;/code&gt; button at the bottom.</source>
          <target state="translated">하단 의 &lt;code&gt;{Publish,Update} release&lt;/code&gt; 버튼을 누르세요.</target>
        </trans-unit>
        <trans-unit id="34329cbed12573fba3127f8cc749498a60eadbb9" translate="yes" xml:space="preserve">
          <source>Hook in &lt;code&gt;numpy/__init__.py&lt;/code&gt; to run distribution-specific checks</source>
          <target state="translated">에서 후크 &lt;code&gt;numpy/__init__.py&lt;/code&gt; 유통 관련 검사를 실행합니다</target>
        </trans-unit>
        <trans-unit id="02f07bc7a75153468adfa0658b0fd2c34d3ff7ae" translate="yes" xml:space="preserve">
          <source>Horner&amp;rsquo;s scheme &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; is used to evaluate the polynomial. Even so, for polynomials of high degree the values may be inaccurate due to rounding errors. Use carefully.</source>
          <target state="translated">호너의 계획 &lt;a href=&quot;#r138ee7027ddf-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; 은 다항식을 평가하는 데 사용됩니다. 그럼에도 불구하고 높은 다항식의 경우 반올림 오류로 인해 값이 정확하지 않을 수 있습니다. 신중하게 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="a0bb6d60bdafa1c8cd27af7d704ca6a159830aba" translate="yes" xml:space="preserve">
          <source>How Tos</source>
          <target state="translated">방법</target>
        </trans-unit>
        <trans-unit id="37544ef44c5ec43acf39ee75fa75aed3630c67b7" translate="yes" xml:space="preserve">
          <source>How can we pass our custom array type through this function? Numpy allows a class to indicate that it would like to handle computations in a custom-defined way through the interfaces &lt;code&gt;__array_ufunc__&lt;/code&gt; and &lt;code&gt;__array_function__&lt;/code&gt;. Let&amp;rsquo;s take one at a time, starting with &lt;code&gt;_array_ufunc__&lt;/code&gt;. This method covers &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;, a class of functions that includes, for example, &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;numpy.multiply&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt;&lt;code&gt;numpy.sin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 함수를 통해 사용자 지정 배열 유형을 어떻게 전달할 수 있습니까? Numpy를 사용하면 클래스가 &lt;code&gt;__array_ufunc__&lt;/code&gt; 및 &lt;code&gt;__array_function__&lt;/code&gt; 인터페이스를 통해 사용자 정의 방식으로 계산을 처리하고자 함을 나타낼 수 있습니다 . &lt;code&gt;_array_ufunc__&lt;/code&gt; 로 시작하여 한 번에 하나씩 가져와 보겠습니다 . 이 메서드는 예를 들어 &lt;a href=&quot;../reference/generated/numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;numpy.multiply&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.sin#numpy.sin&quot;&gt; &lt;code&gt;numpy.sin&lt;/code&gt; &lt;/a&gt; 을 포함하는 함수 클래스 인 &lt;a href=&quot;../reference/ufuncs#ufuncs&quot;&gt;범용 함수 (ufunc)를&lt;/a&gt; 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="6fb47cd6d16a30a926efe82eaad98fb5865139f5" translate="yes" xml:space="preserve">
          <source>How do we construct a 2D array from a list of equally-sized row vectors? In MATLAB this is quite easy: if &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are two vectors of the same length you only need do &lt;code&gt;m=[x;y]&lt;/code&gt;. In NumPy this works via the functions &lt;code&gt;column_stack&lt;/code&gt;, &lt;code&gt;dstack&lt;/code&gt;, &lt;code&gt;hstack&lt;/code&gt; and &lt;code&gt;vstack&lt;/code&gt;, depending on the dimension in which the stacking is to be done. For example:</source>
          <target state="translated">동일한 크기의 행 벡터 목록에서 2D 배열을 어떻게 구성합니까? MATLAB에서 이것은 매우 쉽습니다. &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 가 동일한 길이의 두 벡터 인 경우 &lt;code&gt;m=[x;y]&lt;/code&gt; 만 필요합니다 . NumPy 에서 이것은 스택이 수행되는 차원에 따라 &lt;code&gt;column_stack&lt;/code&gt; , &lt;code&gt;dstack&lt;/code&gt; , &lt;code&gt;hstack&lt;/code&gt; 및 &lt;code&gt;vstack&lt;/code&gt; 함수를 통해 작동 합니다. 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0c6749c478409711ffa23534cffe66364ec264e6" translate="yes" xml:space="preserve">
          <source>How do we know when consensus has been achieved? In principle, this is rather difficult, since consensus is defined by the absence of vetos, which requires us to somehow prove a negative. In practice, we use a combination of our best judgement (e.g., a simple and uncontroversial bug fix posted on GitHub and reviewed by a core developer is probably fine) and best efforts (e.g., all substantive API changes must be posted to the mailing list in order to give the broader community a chance to catch any problems and suggest improvements; we assume that anyone who cares enough about NumPy to invoke their veto right should be on the mailing list). If no-one bothers to comment on the mailing list after a few days, then it&amp;rsquo;s probably fine. And worst case, if a change is more controversial than expected, or a crucial critique is delayed because someone was on vacation, then it&amp;rsquo;s no big deal: we apologize for misjudging the situation, &lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;back up, and sort things out&lt;/a&gt;.</source>
          <target state="translated">합의가 언제 이루어 졌는지 어떻게 알 수 있습니까? 원칙적으로 이것은 합의가 베토의 부재로 정의되기 때문에 다소 어렵습니다. 실제로 우리는 최선의 판단 (예 : GitHub에 게시되고 핵심 개발자가 검토 한 간단하고 논란의 여지가없는 버그 수정)과 최선의 노력 (예 : 모든 실질적인 API 변경 사항은 메일 링리스트에 게시해야 함)을 조합하여 사용합니다. 더 넓은 커뮤니티에 문제를 포착하고 개선 사항을 제안 할 수있는 기회를 제공하기 위해 NumPy에 대해 거부권을 행사하는 데 충분히 관심이있는 사람은 메일 링리스트에 있어야한다고 가정합니다. 며칠 후 아무도 메일 링리스트에 댓글을 남기지 않는다면 괜찮을 것입니다. 최악의 경우, 변경이 예상보다 더 논쟁의 여지가 있다면누군가가 휴가 중이 라 결정적인 비판이 늦어진다면 큰 문제가 아닙니다. 상황을 잘못 판단한 것에 대해 사과합니다.&lt;a href=&quot;http://producingoss.com/en/producingoss.html#version-control-relaxation&quot;&gt;백업하고 정리합니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2fbb3731558c54237c322aa799a621ca3c7d2a1" translate="yes" xml:space="preserve">
          <source>How do you know the shape and size of an array?</source>
          <target state="translated">배열의 모양과 크기를 어떻게 알 수 있습니까?</target>
        </trans-unit>
        <trans-unit id="45e254592757b5e545a9eb104e6529f78a4c37d7" translate="yes" xml:space="preserve">
          <source>How many bytes needed to jump from the end of a dimension back to its beginning. Note that &lt;code&gt;backstrides[k] == strides[k] *
dims_m1[k]&lt;/code&gt;, but it is stored here as an optimization.</source>
          <target state="translated">차원의 끝에서 시작으로 다시 이동하는 데 필요한 바이트 수 참고 &lt;code&gt;backstrides[k] == strides[k] * dims_m1[k]&lt;/code&gt; 있지만,이 최적화 여기에 저장된다.</target>
        </trans-unit>
        <trans-unit id="50be7c0770c6ecdb4f48559d001a760ebacd49cf" translate="yes" xml:space="preserve">
          <source>How many trials succeeded after a single run?</source>
          <target state="translated">한 번의 실행 후 몇 번의 시도가 성공 했습니까?</target>
        </trans-unit>
        <trans-unit id="b58aa8864964e56b91e5cf3a16abe6db4861d007" translate="yes" xml:space="preserve">
          <source>How numpy handles numerical exceptions</source>
          <target state="translated">numpy가 숫자 예외를 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="769ef91e51259c0af4889f9e0ba44a7641bc888d" translate="yes" xml:space="preserve">
          <source>How the committee will respond to reports</source>
          <target state="translated">위원회가 보고서에 응답하는 방법</target>
        </trans-unit>
        <trans-unit id="8a9fac3d5f2ed22d26d8e65434409a64b568a19a" translate="yes" xml:space="preserve">
          <source>How to Prepare a Release</source>
          <target state="translated">릴리스를 준비하는 방법</target>
        </trans-unit>
        <trans-unit id="f2421f501c3d9da50b64e18ac9aabab538f44d78" translate="yes" xml:space="preserve">
          <source>How to access the docstring for more information</source>
          <target state="translated">더 많은 정보를 위해 독 스트링에 접근하는 방법</target>
        </trans-unit>
        <trans-unit id="acdb5801edd59835ce1589b37b87df7e5921dc32" translate="yes" xml:space="preserve">
          <source>How to check the ABI of BLAS/LAPACK libraries</source>
          <target state="translated">BLAS / LAPACK 라이브러리의 ABI를 확인하는 방법</target>
        </trans-unit>
        <trans-unit id="7aec4c512fe995b8565d4654ce7ac7f7406a4e3f" translate="yes" xml:space="preserve">
          <source>How to contribute to the NumPy documentation</source>
          <target state="translated">NumPy 문서에 기여하는 방법</target>
        </trans-unit>
        <trans-unit id="f9221bbb4c993e17b159a09a015a8cfb26163b6a" translate="yes" xml:space="preserve">
          <source>How to contribute to this documentation (user and API)</source>
          <target state="translated">이 문서에 기여하는 방법 (사용자 및 API)</target>
        </trans-unit>
        <trans-unit id="b16ba9588c01309cec829be39d4d7fa37da2d3d4" translate="yes" xml:space="preserve">
          <source>How to convert a 1D array into a 2D array (how to add a new axis to an array)</source>
          <target state="translated">1D 배열을 2D 배열로 변환하는 방법 (배열에 새 축을 추가하는 방법)</target>
        </trans-unit>
        <trans-unit id="767132203b56ed5a732938158524dc8930f4e863" translate="yes" xml:space="preserve">
          <source>How to create a basic array</source>
          <target state="translated">기본 배열을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="484181d716d9291c06f7d7ef08909d7d6fab3e0a" translate="yes" xml:space="preserve">
          <source>How to create an array from existing data</source>
          <target state="translated">기존 데이터에서 배열을 만드는 방법</target>
        </trans-unit>
        <trans-unit id="9cc4cf70f5442751464e426079ad36aeb36f19be" translate="yes" xml:space="preserve">
          <source>How to do common tasks with NumPy</source>
          <target state="translated">NumPy로 일반적인 작업을 수행하는 방법</target>
        </trans-unit>
        <trans-unit id="0cf433e8cb198db7bf7c955d6715ae5e9750b810" translate="yes" xml:space="preserve">
          <source>How to extend NumPy</source>
          <target state="translated">NumPy를 확장하는 방법</target>
        </trans-unit>
        <trans-unit id="666793dffdb7a87d947a14c2cbc94401669fb6a1" translate="yes" xml:space="preserve">
          <source>How to get unique items and counts</source>
          <target state="translated">고유 한 항목 및 개수를 얻는 방법</target>
        </trans-unit>
        <trans-unit id="85f78c1b7c6c2daa9f22d71b7624a2bf3c525a6f" translate="yes" xml:space="preserve">
          <source>How to import NumPy</source>
          <target state="translated">NumPy를 가져 오는 방법</target>
        </trans-unit>
        <trans-unit id="5f492f4c3e2bb0aa4c599fef867f4b321aedf559" translate="yes" xml:space="preserve">
          <source>How to read and write data using NumPy</source>
          <target state="translated">NumPy를 사용하여 데이터를 읽고 쓰는 방법</target>
        </trans-unit>
        <trans-unit id="25e26bd806025536efd64003099ee09d64aa0000" translate="yes" xml:space="preserve">
          <source>How to reverse an array</source>
          <target state="translated">배열을 뒤집는 방법</target>
        </trans-unit>
        <trans-unit id="9a0ae6b713025a426e1208163ee26bcb0e742b0a" translate="yes" xml:space="preserve">
          <source>How to save and load NumPy objects</source>
          <target state="translated">NumPy 객체를 저장하고로드하는 방법</target>
        </trans-unit>
        <trans-unit id="41cd522ba4633ce6d4277a1ec4fd27e9f6066b5f" translate="yes" xml:space="preserve">
          <source>How to treat dates that do not fall on a valid day. The default is &amp;lsquo;raise&amp;rsquo;.</source>
          <target state="translated">유효하지 않은 날짜를 처리하는 방법 기본값은 '올림'입니다.</target>
        </trans-unit>
        <trans-unit id="32eab6d31082447f7e78feb7ff06453c5204497b" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 수준에서 배열 반복기를 사용하는 방법은 이후 섹션에서 자세히 설명합니다. 일반적으로 반복기 객체의 내부 구조에 신경 쓸 필요가 없으며 매크로 &lt;a href=&quot;array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) 또는 &lt;a href=&quot;array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index) 매크로를 사용하여 상호 작용할 필요가 있습니다 . 이 매크로는 모두 인수 필요 &lt;em&gt;가&lt;/em&gt; 될 &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="031b673efec683dbe6f1648f1b6820d5445558f5" translate="yes" xml:space="preserve">
          <source>How to use an array iterator on a C-level is explained more fully in later sections. Typically, you do not need to concern yourself with the internal structure of the iterator object, and merely interact with it through the use of the macros &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; (it, dest), or &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; (it, index). All of these macros require the argument &lt;em&gt;it&lt;/em&gt; to be a &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt;&lt;code&gt;PyArrayIterObject *&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C 레벨에서 배열 반복자를 사용하는 방법은 이후 섹션에서 자세히 설명합니다. 일반적으로 반복자 객체의 내부 구조에 신경 쓸 필요가 없으며 매크로 &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it), &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; (it, dest) 또는 &lt;a href=&quot;c-api.array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; (it, index) 매크로를 사용하여 상호 작용할 필요가 없습니다 . 이 매크로는 모두 인수 필요 &lt;em&gt;가&lt;/em&gt; 될 &lt;a href=&quot;#c.PyArrayIterObject&quot;&gt; &lt;code&gt;PyArrayIterObject *&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fbdd9c0dbdc8228af43d264039755fa6f4f95d7" translate="yes" xml:space="preserve">
          <source>How to write a NumPy how-to</source>
          <target state="translated">NumPy 방법 작성 방법</target>
        </trans-unit>
        <trans-unit id="9bcd1bde0a6ac509c8c0a0f1ece3cf8687c68de6" translate="yes" xml:space="preserve">
          <source>How to write docstrings in the numpydoc format</source>
          <target state="translated">numpydoc 형식으로 독 스트링을 작성하는 방법</target>
        </trans-unit>
        <trans-unit id="a9ce4fa1ba9129e1c9bcea4c3de2267bc0616f3b" translate="yes" xml:space="preserve">
          <source>How-tos</source>
          <target state="translated">How-tos</target>
        </trans-unit>
        <trans-unit id="5a2138ee0afb6e0df456b908537065dae83cea13" translate="yes" xml:space="preserve">
          <source>How-tos bring people into the site and help them discover other information that&amp;rsquo;s here .</source>
          <target state="translated">방법은 사람들을 사이트로 안내하고 여기에있는 다른 정보를 찾을 수 있도록 도와줍니다.</target>
        </trans-unit>
        <trans-unit id="ba325398237c63a9d5322f9272d833f53cda40ea" translate="yes" xml:space="preserve">
          <source>How-tos get straight to the point &amp;ndash; they</source>
          <target state="translated">요점으로 바로가는 방법 &amp;ndash; 그들은</target>
        </trans-unit>
        <trans-unit id="e6a6228c232d3f69fb7834193a60b8402989b6d1" translate="yes" xml:space="preserve">
          <source>How-tos make the site less forbidding to non-experts.</source>
          <target state="translated">비전문가에게 사이트를 덜 금지하는 방법은 사이트를 만듭니다.</target>
        </trans-unit>
        <trans-unit id="a2e4974ddfecbf0d517a464e620b926746339cbe" translate="yes" xml:space="preserve">
          <source>However, F2PY provides a hook to overcome this difficulty, namely, users can define their own &amp;lt;Fortran type&amp;gt; to &amp;lt;C type&amp;gt; maps. For example, if Fortran 90 code contains:</source>
          <target state="translated">그러나 F2PY는 이러한 어려움을 극복하기위한 후크를 제공합니다. 즉, 사용자는 자신의 &amp;lt;포트란 유형&amp;gt;에서 &amp;lt;C 유형&amp;gt;에 대한 맵을 정의 할 수 있습니다. 예를 들어 Fortran 90 코드에 다음이 포함 된 경우 :</target>
        </trans-unit>
        <trans-unit id="1fba89386b8ecb89961d14d41f66fbec5ccd1d21" translate="yes" xml:space="preserve">
          <source>However, array scalars are immutable, so none of the array scalar attributes are settable.</source>
          <target state="translated">그러나 배열 스칼라는 변경할 수 없으므로 배열 스칼라 속성을 설정할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="1e80ea7cc9443be2dc987f1f00e1482c24f952ab" translate="yes" xml:space="preserve">
          <source>However, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">그러나 2D 배열의 경우 &lt;code&gt;tolist&lt;/code&gt; 는 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="015eddccae9844f7be37e7464bfea1ad89cd5089" translate="yes" xml:space="preserve">
          <source>However, if editing Fortran codes is acceptable, then the generation of an intermediate signature file can be skipped in most cases. Namely, F2PY specific attributes can be inserted directly to Fortran source codes using the so-called F2PY directive. A F2PY directive defines special comment lines (starting with &lt;code&gt;Cf2py&lt;/code&gt;, for example) which are ignored by Fortran compilers but F2PY interprets them as normal lines.</source>
          <target state="translated">그러나 Fortran 코드 편집이 허용되는 경우 대부분의 경우 중간 서명 파일 생성을 건너 뛸 수 있습니다. 즉, F2PY 특정 속성은 소위 F2PY 지시문을 사용하여 Fortran 소스 코드에 직접 삽입 할 수 있습니다. F2PY 지시문은 Fortran 컴파일러에서 무시되는 특수 주석 줄 ( 예 : &lt;code&gt;Cf2py&lt;/code&gt; 로 시작)을 정의 하지만 F2PY는이를 일반 줄로 해석합니다.</target>
        </trans-unit>
        <trans-unit id="b575af53d48fbf01519f17fa75457eb6160cea6e" translate="yes" xml:space="preserve">
          <source>However, if one wants to perform an operation on each element in the array, one can use the &lt;code&gt;flat&lt;/code&gt; attribute which is an &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;iterator&lt;/a&gt; over all the elements of the array:</source>
          <target state="translated">그러나 배열의 각 요소에 대해 작업을 수행하려는 경우 배열의 모든 요소에 대한 &lt;a href=&quot;https://docs.python.org/tutorial/classes.html#iterators&quot;&gt;반복자 인 &lt;/a&gt; &lt;code&gt;flat&lt;/code&gt; 속성을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="538a59374ec076485a1ecbe77f4b8f8bcaeb6930" translate="yes" xml:space="preserve">
          <source>However, if the step length is a &lt;strong&gt;complex number&lt;/strong&gt; (e.g. 5j), then the integer part of its magnitude is interpreted as specifying the number of points to create between the start and stop values, where the stop value &lt;strong&gt;is inclusive&lt;/strong&gt;.</source>
          <target state="translated">그러나 단계 길이가 &lt;strong&gt;복소수&lt;/strong&gt; (예 : 5j) 인 경우, 그 크기의 정수 부분은 시작 값과 중지 값 사이에 작성할 포인트 수를 지정하는 것으로 해석되며 여기서 중지 값 &lt;strong&gt;은 포함&lt;/strong&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="c7b350918e2c3c187f55b17296e6170af94589d5" translate="yes" xml:space="preserve">
          <source>However, it also provides a filter mechanism to work around &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt;.</source>
          <target state="translated">그러나 &lt;a href=&quot;https://bugs.python.org/issue4180&quot;&gt;https://bugs.python.org/issue4180&lt;/a&gt; 에서 작동하는 필터 메커니즘도 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="8a0d3e8aabdd09f6d1c5b5cc067196fd48077165" translate="yes" xml:space="preserve">
          <source>However, on Windows accessing an attribute of the &lt;code&gt;cdll&lt;/code&gt; method will load the first DLL by that name found in the current directory or on the PATH. Loading the absolute path name requires a little finesse for cross-platform work since the extension of shared libraries varies. There is a &lt;code&gt;ctypes.util.find_library&lt;/code&gt; utility available that can simplify the process of finding the library to load but it is not foolproof. Complicating matters, different platforms have different default extensions used by shared libraries (e.g. .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). This must also be taken into account if you are using ctypes to wrap code that needs to work on several platforms.</source>
          <target state="translated">그러나 Windows에서 &lt;code&gt;cdll&lt;/code&gt; 메서드 의 속성에 액세스 하면 현재 디렉터리 또는 PATH에있는 해당 이름으로 첫 번째 DLL을로드합니다. 절대 경로 이름을로드하려면 공유 라이브러리의 확장이 다양하기 때문에 크로스 플랫폼 작업에 약간의 정교함이 필요합니다. 로드 할 라이브러리를 찾는 프로세스를 단순화 할 수 있는 &lt;code&gt;ctypes.util.find_library&lt;/code&gt; 유틸리티를 사용할 수 있지만 완벽하지는 않습니다. 복잡한 문제는 플랫폼마다 공유 라이브러리에서 사용하는 기본 확장자가 다릅니다 (예 : .dll &amp;ndash; Windows, .so &amp;ndash; Linux, .dylib &amp;ndash; Mac OS X). 여러 플랫폼에서 작동해야하는 코드를 래핑하기 위해 ctypes를 사용하는 경우에도이 점을 고려해야합니다.</target>
        </trans-unit>
        <trans-unit id="72730352a2b8f129f65e5ce4d2975cad73414281" translate="yes" xml:space="preserve">
          <source>However, since the indexing arrays above just repeat themselves, broadcasting can be used (compare operations such as &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt;) to simplify this:</source>
          <target state="translated">그러나 위의 인덱싱 배열은 반복되기 때문에 브로드 캐스트를 사용하여 ( &lt;code&gt;rows[:, np.newaxis] + columns&lt;/code&gt; 와 같은 작업 비교 )이를 단순화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5598df37564d4f9b7b446978966b782318a91f69" translate="yes" xml:space="preserve">
          <source>However, the Council&amp;rsquo;s primary responsibility is to facilitate the ordinary community-based decision making procedure described above. If we ever have to step in and formally override the community for the health of the Project, then we will do so, but we will consider reaching this point to indicate a failure in our leadership.</source>
          <target state="translated">그러나위원회의 주요 책임은 위에서 설명한 일반적인 커뮤니티 기반 의사 결정 절차를 촉진하는 것입니다. 프로젝트의 건전성을 위해 커뮤니티에 참여하고 공식적으로 재정의해야한다면 그렇게 할 것이지만이 지점에 도달하여 리더십의 실패를 나타내는 것을 고려할 것입니다.</target>
        </trans-unit>
        <trans-unit id="148e0e3942c54a4e1382c28056e669f5ec70ca70" translate="yes" xml:space="preserve">
          <source>However, the recommended way to get changes made by Fortran subroutine back to Python is to use &lt;code&gt;intent(out)&lt;/code&gt; attribute. It is more efficient and a cleaner solution.</source>
          <target state="translated">그러나 Fortran 서브 루틴의 변경 사항을 Python으로 되 돌리는 권장 방법은 &lt;code&gt;intent(out)&lt;/code&gt; 속성 을 사용 하는 것입니다. 더 효율적이고 깨끗한 솔루션입니다.</target>
        </trans-unit>
        <trans-unit id="076196cf7f29cbacc06332dc3a19baa5b6deb43a" translate="yes" xml:space="preserve">
          <source>However, there are ways (see below) how to &amp;ldquo;teach&amp;rdquo; F2PY about the true intentions (among other things) of function arguments; and then F2PY is able to generate more Pythonic (more explicit, easier to use, and less error prone) wrappers to Fortran functions.</source>
          <target state="translated">그러나 함수 인수의 진정한 의도 (무엇보다도)에 대해 F2PY를 &quot;가르치는&quot;방법이 있습니다 (아래 참조). 그런 다음 F2PY는 Fortran 함수에 대해 더 많은 Pythonic (더 명시적이고 사용하기 쉽고 오류 발생 가능성이 적은) 래퍼를 생성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="517b2fc5c448904cbaf5099f9fa2e17572271c41" translate="yes" xml:space="preserve">
          <source>However, this class is not run directly. Rather, it serves as a base class to several other python classes, each one specific to a particular data type. The &lt;code&gt;VectorTestCase&lt;/code&gt; class stores two strings for typing information:</source>
          <target state="translated">그러나이 클래스는 직접 실행되지 않습니다. 오히려 여러 다른 파이썬 클래스에 대한 기본 클래스로 사용되며 각각은 특정 데이터 유형에 고유합니다. &lt;code&gt;VectorTestCase&lt;/code&gt; 의 클래스를 저장 입력 정보에 대한 두 개의 문자열 :</target>
        </trans-unit>
        <trans-unit id="2a6f4657816e90073e4efa70d32c1dabe823c21d" translate="yes" xml:space="preserve">
          <source>However, we can not do this by putting &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; into an array, because this array will be interpreted as indexing the first dimension of a.</source>
          <target state="translated">그러나 우리는 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 를 배열 에 넣는 것으로 이것을 할 수 없습니다 . 왜냐하면이 배열은 a의 첫 번째 차원을 인덱싱하는 것으로 해석 될 것이기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="d0b3b9f48e63d95c45789879b62e0b7dfb5a4009" translate="yes" xml:space="preserve">
          <source>However, when the list of indices contains repetitions, the assignment is done several times, leaving behind the last value:</source>
          <target state="translated">그러나 인덱스 목록에 반복이 포함 된 경우 마지막 값을 남기고 할당이 여러 번 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="521bc3c12a73492e24db294a1945beb730dec9cb" translate="yes" xml:space="preserve">
          <source>Human-readable</source>
          <target state="translated">Human-readable</target>
        </trans-unit>
        <trans-unit id="baf7f433a664b8146a9906ca7ff1abe3cab252ff" translate="yes" xml:space="preserve">
          <source>Hyperbolic cosine, element-wise.</source>
          <target state="translated">요소 별 쌍곡 코사인.</target>
        </trans-unit>
        <trans-unit id="f3ed3aadb3c9adb061d870e136cd1453348e8c73" translate="yes" xml:space="preserve">
          <source>Hyperbolic functions</source>
          <target state="translated">쌍곡선 함수</target>
        </trans-unit>
        <trans-unit id="b87cce3c91c3e9d2649c00af3ce0c941c00a9a8f" translate="yes" xml:space="preserve">
          <source>Hyperbolic sine, element-wise.</source>
          <target state="translated">요소 별 쌍곡 사인.</target>
        </trans-unit>
        <trans-unit id="ca73ab65568cd125c2d27a22bbd9e863c10b675d" translate="yes" xml:space="preserve">
          <source>I</source>
          <target state="translated">I</target>
        </trans-unit>
        <trans-unit id="32232530b1100268522739a98df9e054ce98ef4f" translate="yes" xml:space="preserve">
          <source>I() (numpy.matrix property)</source>
          <target state="translated">I () (numpy.matrix 속성)</target>
        </trans-unit>
        <trans-unit id="c586011e018241bf43412c51ec75d78e1897bbe7" translate="yes" xml:space="preserve">
          <source>I. N. Bronshtein, K. A. Semendyayev, and K. A. Hirsch (Eng. trans. Ed.), &lt;em&gt;Handbook of Mathematics&lt;/em&gt;, New York, Van Nostrand Reinhold Co., 1985, pg. 720.</source>
          <target state="translated">Bronshtein, KA Semendyayev 및 KA Hirsch (Eng. trans. Ed.), 뉴욕 &lt;em&gt;핸드북 수학&lt;/em&gt; , Van Nostrand Reinhold Co., 1985, pg. 720.</target>
        </trans-unit>
        <trans-unit id="447fb9923a27f15d934b8afdf5c0a4f010eb6dd4" translate="yes" xml:space="preserve">
          <source>I/O with NumPy</source>
          <target state="translated">NumPy를 사용한 I / O</target>
        </trans-unit>
        <trans-unit id="58fa487987fc3870763b0f9db01323f264726e65" translate="yes" xml:space="preserve">
          <source>IBM/POWER big-endian - CPU feature names</source>
          <target state="translated">IBM / POWER big-endian-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="2ccc4b37b2ad4aa5276bee6f26efc4659da58371" translate="yes" xml:space="preserve">
          <source>IBM/POWER little-endian - CPU feature names</source>
          <target state="translated">IBM / POWER little-endian-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="afc08020472b5f8bfb4430d0521200fb31b0b681" translate="yes" xml:space="preserve">
          <source>IEEE 754 Floating Point Special Values</source>
          <target state="translated">IEEE 754 부동 소수점 특수 값</target>
        </trans-unit>
        <trans-unit id="0ee225f319b80c76b05dae881594a3894bf4661e" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of (positive) infinity.</source>
          <target state="translated">(양의) 무한대의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="ff3e6480ff45af971d6b3762d77291c710637eb0" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of Not a Number (NaN).</source>
          <target state="translated">NaN (Not a Number)의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="824566ddb199752efcc7660bd7d421e1b2678da4" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative infinity.</source>
          <target state="translated">음의 무한대의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="2e340e10314a130edadd8cad9f96f416538b858d" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of negative zero.</source>
          <target state="translated">음수 0의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="b287f77a659c8b69b20168ee840f1a54628cc862" translate="yes" xml:space="preserve">
          <source>IEEE 754 floating point representation of positive zero.</source>
          <target state="translated">양수 0의 IEEE 754 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="8b686ac7097f2666dfedf8d88871747de97f1028" translate="yes" xml:space="preserve">
          <source>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2008, pp.1-70, 2008, &lt;a href=&quot;https://www.doi.org/10.1109/IEEESTD.2008.4610935&quot;&gt;http://www.doi.org/10.1109/IEEESTD.2008.4610935&lt;/a&gt;</source>
          <target state="translated">부동 소수점 연산을위한 IEEE 표준, IEEE Std 754-2008, pp.1-70, 2008, &lt;a href=&quot;https://www.doi.org/10.1109/IEEESTD.2008.4610935&quot;&gt;http://www.doi.org/10.1109/IEEESTD.2008.4610935&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="72cabc0c250f4a292eec84ba99be92816a937afe" translate="yes" xml:space="preserve">
          <source>INSTALL.rst.txt</source>
          <target state="translated">INSTALL.rst.txt</target>
        </trans-unit>
        <trans-unit id="ab585ec9c005c8ff11ee6135d8e5382d325fbd66" translate="yes" xml:space="preserve">
          <source>IO compatibility with large files</source>
          <target state="translated">대용량 파일과의 IO 호환성</target>
        </trans-unit>
        <trans-unit id="e274113d3320e2ddaa1955ecaa00f8ecd732ab0e" translate="yes" xml:space="preserve">
          <source>IO performance improvements</source>
          <target state="translated">IO 성능 향상</target>
        </trans-unit>
        <trans-unit id="a7aaaf8103e147f7508e66b5f7be824742d34faa" translate="yes" xml:space="preserve">
          <source>IOError</source>
          <target state="translated">IOError</target>
        </trans-unit>
        <trans-unit id="401e5d8be22ba7ec21a65d4ac42f63626cf30eac" translate="yes" xml:space="preserve">
          <source>ISO/IEC standard 9899:1999, &amp;ldquo;Programming language C.&amp;rdquo;</source>
          <target state="translated">ISO / IEC 표준 9899 : 1999,&amp;ldquo;프로그래밍 언어 C&amp;rdquo;</target>
        </trans-unit>
        <trans-unit id="a192903ac36265b2268a1b63fb4343f1bc34ccf1" translate="yes" xml:space="preserve">
          <source>ISeedSequence.generate_state()</source>
          <target state="translated">ISeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="7817ae1e33233084a2765c4156676391d76c8dd8" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.generate_state()</source>
          <target state="translated">ISpawnableSeedSequence.generate_state()</target>
        </trans-unit>
        <trans-unit id="266493f5f6f829a5601662541a1f5723f1a321cc" translate="yes" xml:space="preserve">
          <source>ISpawnableSeedSequence.spawn()</source>
          <target state="translated">ISpawnableSeedSequence.spawn()</target>
        </trans-unit>
        <trans-unit id="08673d1ddebe80d6502dff08e88d404531dbe20b" translate="yes" xml:space="preserve">
          <source>Identifies the benchmarks to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="translated">실행할 벤치 마크를 식별합니다. 이것은 '-A'옵션을 사용하여 nosetests 실행 파일에 전달할 문자열이거나 여러 특수 값 중 하나 일 수 있습니다. 특수 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2938dea7757a31542d1346c3f1074719ce51ad4d" translate="yes" xml:space="preserve">
          <source>Identifies the tests to run. This can be a string to pass to the nosetests executable with the &amp;lsquo;-A&amp;rsquo; option, or one of several special values. Special values are:</source>
          <target state="translated">실행할 테스트를 식별합니다. 이것은 '-A'옵션을 사용하여 nosetests 실행 파일에 전달할 문자열이거나 여러 특수 값 중 하나 일 수 있습니다. 특수 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="84791116b8cc2df6bbeaf0d85f3bf0937f9761c0" translate="yes" xml:space="preserve">
          <source>Identify the commit hash of the release, e.g. 1b2e1d63ff.</source>
          <target state="translated">릴리스의 커밋 해시를 식별합니다 (예 : 1b2e1d63ff).</target>
        </trans-unit>
        <trans-unit id="fd1dd04c1dd17aedd6c4e7a39f0e9308f130b433" translate="yes" xml:space="preserve">
          <source>Identity for reduction, when &lt;a href=&quot;#c.PyUFuncObject.identity&quot;&gt;&lt;code&gt;PyUFuncObject.identity&lt;/code&gt;&lt;/a&gt; is equal to &lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt;&lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">환원 신원 &lt;a href=&quot;#c.PyUFuncObject.identity&quot;&gt; &lt;code&gt;PyUFuncObject.identity&lt;/code&gt; 가&lt;/a&gt; 같은지 &lt;a href=&quot;ufunc#c.PyUFunc_IdentityValue&quot;&gt; &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="111e795804fa7bde03948ba63ec2cb3f6f402b39" translate="yes" xml:space="preserve">
          <source>Identity function.</source>
          <target state="translated">신원 기능.</target>
        </trans-unit>
        <trans-unit id="ef2cb61738111c3044b6a344dba03012a1f3066b" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;inner&amp;rsquo;, returns the elements common to both r1 and r2. If &amp;lsquo;outer&amp;rsquo;, returns the common elements as well as the elements of r1 not in r2 and the elements of not in r2. If &amp;lsquo;leftouter&amp;rsquo;, returns the common elements and the elements of r1 not in r2.</source>
          <target state="translated">'inner'인 경우 r1과 r2에 공통된 요소를 반환합니다. 'outer'인 경우 r2에없는 r1의 요소와 r2에없는 요소는 물론 공통 요소를 반환합니다. 'leftouter'인 경우 공통 요소와 r2에없는 r1의 요소를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c9a8c69d524e3737d8a52d7c063a710ab1820ab4" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;left&amp;rsquo;, the index of the first suitable location found is given. If &amp;lsquo;right&amp;rsquo;, return the last such index. If there is no suitable index, return either 0 or N (where N is the length of &lt;code&gt;a&lt;/code&gt;).</source>
          <target state="translated">'왼쪽'이면 발견 된 첫 번째 적합한 위치의 색인이 제공됩니다. 'right'이면 마지막 인덱스를 반환하십시오. 어떠한 적절한 인덱스가없는 경우 (N은의 길이 0 또는 N 리턴 &lt;code&gt;a&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b2ac55fdba7a6077870f65fb651eb209decd3f7" translate="yes" xml:space="preserve">
          <source>If &amp;lsquo;out&amp;rsquo; is None (the default), a uninitialized return array is created. The output array is then filled with the results of the ufunc in the places that the broadcast &amp;lsquo;where&amp;rsquo; is True. If &amp;lsquo;where&amp;rsquo; is the scalar True (the default), then this corresponds to the entire output being filled. Note that outputs not explicitly filled are left with their uninitialized values.</source>
          <target state="translated">'out'이 None (기본값)이면 초기화되지 않은 리턴 배열이 작성됩니다. 그런 다음 출력 배열은 브로드 캐스트 'where'가 True 인 위치에서 ufunc의 결과로 채워집니다. 'where'가 스칼라 True (기본값)이면 채워지는 전체 출력에 해당합니다. 명시 적으로 채워지지 않은 출력은 초기화되지 않은 값으로 남습니다.</target>
        </trans-unit>
        <trans-unit id="b221bc8f0d9f3564598fa735c4c298856c0dd2e9" translate="yes" xml:space="preserve">
          <source>If -1/NULL values are passed to &lt;code&gt;oa_ndim&lt;/code&gt;, &lt;code&gt;op_axes&lt;/code&gt;, &lt;code&gt;itershape&lt;/code&gt;, and &lt;code&gt;buffersize&lt;/code&gt;, it is equivalent to &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt;&lt;code&gt;NpyIter_MultiNew&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">/ NULL 값을 전달하는 경우 -1 &lt;code&gt;oa_ndim&lt;/code&gt; , &lt;code&gt;op_axes&lt;/code&gt; , &lt;code&gt;itershape&lt;/code&gt; 및 &lt;code&gt;buffersize&lt;/code&gt; , 그것은 동등 &lt;a href=&quot;#c.NpyIter_MultiNew&quot;&gt; &lt;code&gt;NpyIter_MultiNew&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07ab4829841dadccaa2d85de36af5f3925367c25" translate="yes" xml:space="preserve">
          <source>If 64-bit integers are still too small the result may be cast to a floating point number. Floating point numbers offer a larger, but inexact, range of possible values.</source>
          <target state="translated">64 비트 정수가 여전히 너무 작 으면 결과가 부동 소수점 숫자로 캐스트 될 수 있습니다. 부동 소수점 숫자는 더 크지 만 정확하지 않은 가능한 값 범위를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="79d46b4b066a6ba67bd08b99b0faa98132c0c54b" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is #defined, regardless of whether &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is, the C-API is declared to be &lt;code&gt;extern void**&lt;/code&gt;, so it is expected to be defined in another compilation unit.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; 가&lt;/a&gt; #define에 의해 정의되어 여부에 관계없이의 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; 이&lt;/a&gt; 되면, C-API는 선언한다 &lt;code&gt;extern void**&lt;/code&gt; 가 다른 컴파일 단위에서 정의 될 것으로 예상된다, 그래서.</target>
        </trans-unit>
        <trans-unit id="f636b5861ee4fae57e7d457d50fef770ecd7b810" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; was called, you may want to enable the flag &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;. This flag is not permitted together with &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt;&lt;/a&gt;, so this function is provided to enable the feature after &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt;&lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt;&lt;/a&gt; is called. This function also resets the iterator to its initial state.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; 이&lt;/a&gt; 불렀다, 당신은 플래그를 활성화 할 수 있습니다 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; 을&lt;/a&gt; . 이 플래그는 &lt;a href=&quot;#c.NPY_ITER_MULTI_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_MULTI_INDEX&lt;/code&gt; &lt;/a&gt; 와 함께 허용되지 않으므로이 함수는 &lt;a href=&quot;#c.NpyIter_RemoveMultiIndex&quot;&gt; &lt;code&gt;NpyIter_RemoveMultiIndex&lt;/code&gt; &lt;/a&gt; 가 호출 된 후 기능을 사용하도록 제공됩니다 . 이 기능은 반복기를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="1cac2a31adf2200c294f5c075bb6c153e55fa5a2" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt;&lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt;&lt;/a&gt; is #defined, but &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt;&lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt;&lt;/a&gt; is not, the C-API is declared to be &lt;code&gt;void**&lt;/code&gt;, so that it will also be visible to other compilation units.</source>
          <target state="translated">경우 &lt;a href=&quot;#c.PY_ARRAY_UNIQUE_SYMBOL&quot;&gt; &lt;code&gt;PY_ARRAY_UNIQUE_SYMBOL&lt;/code&gt; 가&lt;/a&gt; #define에 의해 정의되어 있지만 &lt;a href=&quot;#c.NO_IMPORT_ARRAY&quot;&gt; &lt;code&gt;NO_IMPORT_ARRAY&lt;/code&gt; 이&lt;/a&gt; 아니다는 C-API는 선언한다 &lt;code&gt;void**&lt;/code&gt; 가 다른 컴파일 단위로 표시됩니다 그래서.</target>
        </trans-unit>
        <trans-unit id="b3b296f263651378da8d936805870023810c7d29" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 지정되지 않은,하지만 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 지정됩니다 (그리고 ndarray 하위 클래스되지 않습니다)는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; MaskedArray의가 재설정됩니다. &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 지정 되지 않은 경우 (또는 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 ndarray 하위 클래스 인 경우) 채우기 값이 유지됩니다. 마지막으로 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 가 지정되었지만 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 지정 되지 않은 경우 채우기 값은 지정된 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="f0fe9dfd78027e91a1bff4d801d8eb87a4610a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">경우 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 지정되지 않은,하지만 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 지정됩니다 (그리고 ndarray 하위 클래스되지 않습니다)는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; MaskedArray의가 재설정됩니다. &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 지정 되지 않은 경우 (또는 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 ndarray 하위 클래스 인 경우) 채우기 값이 유지됩니다. 마지막으로 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 가 지정되었지만 &lt;a href=&quot;numpy.ma.maskedarray.dtype#numpy.ma.MaskedArray.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 지정 되지 않은 경우 채우기 값은 지정된 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="bd7a3692bd40eb6528a52fa63a028a54110d3c3d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(array)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(array, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(array) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(array))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 1-D의 함수이다 &lt;code&gt;ufunc.accumulate(array)&lt;/code&gt; 과 동일 &lt;code&gt;ufunc.reduceat(array, indices)[::2]&lt;/code&gt; 여기서, &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 되는 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 제로와마다 배치 다른 요소 : &lt;code&gt;indices = zeros(2 * len(array) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(array))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc062e126b3bd61e02f7b3e167657fb84a747f47" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 이러한 인수가 전달됩니다 &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt; DTYPE를 구성 할 수 있습니다. 자세한 문서는 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f05f58b7f416905ebe6f79d07e2a76e9b7837051" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 이러한 인수가 전달됩니다 &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt; DTYPE를 구성 할 수 있습니다. 자세한 문서는 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b6b83b00b9ce96c4a5e91132daa4d55535f9e96d" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is set, array is copied only if dtype does not match:</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 설정되어 DTYPE이 일치하지 않는 경우, 배열은 복사 :</target>
        </trans-unit>
        <trans-unit id="4fc8bcfc9864193d76a4195dd238fe6624ed9a71" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is not one dimensional, the output also has these dimensions.</source>
          <target state="translated">&lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 가 1 차원이 아닌 경우 출력에도이 차원이 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ede9f1a1e5701156394dbca76c84f8a340a9cea" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is not specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is specified (and is not an ndarray sub-class), the &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; of the MaskedArray will be reset. If neither &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; nor &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are specified (or if &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is an ndarray sub-class), then the fill value is preserved. Finally, if &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt; is specified, but &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; is not, the fill value is set to the specified value.</source>
          <target state="translated">경우 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 지정되지 않은,하지만 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 지정됩니다 (그리고 ndarray 하위 클래스되지 않습니다)는 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; MaskedArray의가 재설정됩니다. &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 지정 되지 않은 경우 (또는 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 ndarray 하위 클래스 인 경우) 채우기 값이 유지됩니다. 마지막으로 &lt;a href=&quot;numpy.ma.masked_array.fill_value#numpy.ma.masked_array.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; &lt;/a&gt; 가 지정되었지만 &lt;a href=&quot;numpy.ma.masked_array.dtype#numpy.ma.masked_array.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 이 지정 되지 않은 경우 채우기 값은 지정된 값으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="8d5ce8d43810f8659a3ffbe656fd3c96f0228399" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is a string, it is interpreted as a matrix with commas or spaces separating columns, and semicolons separating rows.</source>
          <target state="translated">하면 &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 문자열이고, 그것이 콤마 컬럼 분리 공간 행 분리 세미콜론 매트릭스로 해석된다.</target>
        </trans-unit>
        <trans-unit id="006799ea3355b83be37fd21ad89f661aac343125" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt;&lt;code&gt;data&lt;/code&gt;&lt;/a&gt; is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then this flag determines whether the data is copied (the default), or whether a view is constructed.</source>
          <target state="translated">경우에 &lt;a href=&quot;numpy.matrix.data#numpy.matrix.data&quot;&gt; &lt;code&gt;data&lt;/code&gt; &lt;/a&gt; 이미 인 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; ,이 플래그는 데이터가 (기본)에 복사할지 여부를 결정하거나, 뷰가 구성되어 있는지.</target>
        </trans-unit>
        <trans-unit id="ad28cc6c8a4f0eed400b04898af33bdfb6744bee" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 길이를 갖는 하나의 예 &lt;code&gt;(N,)&lt;/code&gt; , 또는 스칼라 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; 형상의 단일 행 행렬이된다 &lt;code&gt;(1,N)&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="f12c5c9464a76ef6881e238c0f45cc6cb56cab96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; is specified as &lt;code&gt;stdout&lt;/code&gt; then signatures are send to standard output instead of a file.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;filename.pyf&amp;gt;&lt;/code&gt; 가 로 지정된 &lt;code&gt;stdout&lt;/code&gt; 후 서명 대신 파일의 표준 출력으로 전송된다.</target>
        </trans-unit>
        <trans-unit id="22e7424cfa201c4ec783e98a6da198e97606627a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; contains a signature file, then a source for an extension module is constructed, all Fortran and C sources are compiled, and finally all object and library files are linked to the extension module &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; which is saved into the current directory.</source>
          <target state="translated">경우 &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 서명 파일, 확장 모듈에 대한 다음 소스 구성되어를 포함, 모든 포트란과 C 소스를 컴파일, 그리고 마지막으로 모든 개체 및 라이브러리 파일은 확장자에 연결된 모듈 &lt;code&gt;&amp;lt;modulename&amp;gt;.so&lt;/code&gt; 에 저장되어있는 현재 디렉토리.</target>
        </trans-unit>
        <trans-unit id="207fbf09fcd7223478aec74725e5d0380117e758" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; does not contain a signature file, then an extension module is constructed by scanning all Fortran source codes for routine signatures.</source>
          <target state="translated">만약 &lt;code&gt;&amp;lt;fortran files&amp;gt;&lt;/code&gt; 다음 확장 모듈은 루틴 서명에 대한 모든 포트란 소스 코드를 스캔하여 구성되어 서명 파일을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3b197e7232928483bec23ab77c22b02eb5eeb910" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt;, &lt;code&gt;reps&lt;/code&gt; is promoted to &lt;code&gt;A&lt;/code&gt;.ndim by pre-pending 1&amp;rsquo;s to it. Thus for an &lt;code&gt;A&lt;/code&gt; of shape (2, 3, 4, 5), a &lt;code&gt;reps&lt;/code&gt; of (2, 2) is treated as (1, 1, 2, 2).</source>
          <target state="translated">경우 &lt;code&gt;A.ndim &amp;gt; d&lt;/code&gt; , &lt;code&gt;reps&lt;/code&gt; 승격된다 그것의 1 사전이 출원하여 .ndim. 따라서 (2, 3, 4, 5) 모양 &lt;code&gt;A&lt;/code&gt; 의 경우 (2, 2) 의 &lt;code&gt;reps&lt;/code&gt; 은 (1, 1, 2, 2)로 처리됩니다. &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dbe88f61ce8f631b9b28c692a7753b41fb5fe9e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt; is promoted to be d-dimensional by prepending new axes. So a shape (3,) array is promoted to (1, 3) for 2-D replication, or shape (1, 1, 3) for 3-D replication. If this is not the desired behavior, promote &lt;code&gt;A&lt;/code&gt; to d-dimensions manually before calling this function.</source>
          <target state="translated">경우 &lt;code&gt;A.ndim &amp;lt; d&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; 를 D 차원 새로운 축을 붙이는 것으로 의해 촉진된다. 따라서 2D 복제의 경우 모양 (3,) 배열이 (1, 3)으로, 3D 복제의 경우 모양 (1, 1, 3)으로 승격됩니다. 이것이 원하는 동작이 아닌 경우이 함수를 호출하기 전에 &lt;code&gt;A&lt;/code&gt; 를 d 차원으로 수동으로 승격하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f85c71b217560bd561bde5602b4923ab34868ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;False&lt;/code&gt;, the result will contain the number of samples in each bin. If &lt;code&gt;True&lt;/code&gt;, the result is the value of the probability &lt;em&gt;density&lt;/em&gt; function at the bin, normalized such that the &lt;em&gt;integral&lt;/em&gt; over the range is 1. Note that the sum of the histogram values will not be equal to 1 unless bins of unity width are chosen; it is not a probability &lt;em&gt;mass&lt;/em&gt; function.</source>
          <target state="translated">경우 &lt;code&gt;False&lt;/code&gt; , 결과는 각 빈에있는 샘플의 수를 포함합니다. 경우 &lt;code&gt;True&lt;/code&gt; , 결과 확률의 값 &lt;em&gt;밀도&lt;/em&gt; 되도록 정규화 빈의 함수, &lt;em&gt;적분&lt;/em&gt; 범위에서 히스토그램 값들의 합이 1과 같지 않을 것이다 1 주되어 선택된다 폭 화합의 빈들 않는; 확률 &lt;em&gt;질량&lt;/em&gt; 함수 가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="ca7cba1e4456723daee790d09bd9b4e007a0b7f8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;None&lt;/code&gt; (default), all constants are assumed to be zero. If &lt;code&gt;m = 1&lt;/code&gt;, a single scalar can be given instead of a list.</source>
          <target state="translated">경우 &lt;code&gt;None&lt;/code&gt; (기본값)은 모든 상수 가정하지 않습니다 제로가 될 수 있습니다. &lt;code&gt;m = 1&lt;/code&gt; 인 경우 목록 대신 단일 스칼라를 제공 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aec21489ec4d901f1aa321dc3743c87fb290d768" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, swap bytes in-place, default is &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; , 스왑이 자리에서 바이트, 기본값은 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2e3fbb074311bdb46e2b67afbf7fb14e162de56" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, the cutoff of &lt;code&gt;precision&lt;/code&gt; digits refers to the total number of digits after the decimal point, including leading zeros. If &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;precision&lt;/code&gt; refers to the total number of significant digits, before or after the decimal point, ignoring leading zeros.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 &lt;code&gt;precision&lt;/code&gt; 자릿수는 소수점 이하 자릿수 (앞의 0 포함)를 나타냅니다. &lt;code&gt;False&lt;/code&gt; 인 경우 &lt;code&gt;precision&lt;/code&gt; 는 선행 0을 무시하고 소수점 앞뒤에있는 유효 유효 자릿수의 총 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="a29f76a184d9fb35f364bb63d222c84be040ac5b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, then cache the first function call that determines the number of outputs if &lt;code&gt;otypes&lt;/code&gt; is not provided.</source>
          <target state="translated">경우 &lt;code&gt;True&lt;/code&gt; 후 출력하는 경우의 수를 결정하는 제 1 함수 호출 캐시 &lt;code&gt;otypes&lt;/code&gt; 이 설치되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7faac3985b746b05ac26d42bd00cce4fcc2669d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 신중하게 반올림하여 같은 유형의 다른 값에서 부동 소수점 숫자를 고유하게 식별하는 가장 짧은 표현을 제공하는 숫자 생성 전략을 사용하십시오. &lt;code&gt;precision&lt;/code&gt; 가 생략 된 경우 필요한 모든 자릿수를 인쇄하고 그렇지 않으면 자릿수 생성이 잘립니다. &lt;code&gt;precision&lt;/code&gt; 숫자 나머지 값이 반올림됩니다. 경우 &lt;code&gt;False&lt;/code&gt; , 숫자 무한 밀도 값을 인쇄 한 후 정지 것처럼 생성 &lt;code&gt;precision&lt;/code&gt; 숫자, 나머지 값을 반올림.</target>
        </trans-unit>
        <trans-unit id="d46a903cfc558730b35e63368d27aca2360607f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;True&lt;/code&gt;, use a digit-generation strategy which gives the shortest representation which uniquely identifies the floating-point number from other values of the same type, by judicious rounding. If &lt;code&gt;precision&lt;/code&gt; was omitted, print out all necessary digits, otherwise digit generation is cut off after &lt;code&gt;precision&lt;/code&gt; digits and the remaining value is rounded. If &lt;code&gt;False&lt;/code&gt;, digits are generated as if printing an infinite-precision value and stopping after &lt;code&gt;precision&lt;/code&gt; digits, rounding the remaining value.</source>
          <target state="translated">&lt;code&gt;True&lt;/code&gt; 인 경우 신중하게 반올림하여 같은 유형의 다른 값에서 부동 소수점 숫자를 고유하게 식별하는 가장 짧은 표현을 제공하는 숫자 생성 전략을 사용하십시오. &lt;code&gt;precision&lt;/code&gt; 가 생략 된 경우 , 필요한 모든 숫자를 인쇄하십시오. 그렇지 않으면 &lt;code&gt;precision&lt;/code&gt; 후에 숫자 생성이 잘립니다. 자릿수 나머지 값이 반올림됩니다. 경우 &lt;code&gt;False&lt;/code&gt; , 숫자 무한 밀도 값을 인쇄 한 후 정지 것처럼 생성 &lt;code&gt;precision&lt;/code&gt; 숫자, 나머지 값을 반올림.</target>
        </trans-unit>
        <trans-unit id="e630a68b772e53281799a75b2daa484538be6573" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = chebvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; 의 다음 컬럼 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="8cbfd70f5cc4a9c80c1b3f4ac628ba80decf75d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = chebvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="00bfc10fc177e8c4f7b6b34693c411592fe272c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermevander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="a7c811e070f694575d65f49ba72909eaec417a6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermevander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="262fc8f05dc54d641c4705041f46d8b6c771c1fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="066ad3b1f4c835bc91d8b4d1ca954772c0457a46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = hermvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="6596fc02b05eb1b57c388bcee28f45c0fa647e79" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = lagvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="658f3ceb580a0341f1c8e14be933e5829c9b95b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = lagvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형상 (xdeg + 1 ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="102bddd53317314797d80d0b03e0de44ee8eec62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = legvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="f9e4383801f2b61b08f9300b1b7fdf17e1c3f488" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = legvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형상 (xdeg + 1 ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="c691cf5dd3bcc26326919122a716b1456743d83e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 2-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = polyvander2d(x, y, [xdeg, ydeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 2 차원 계수 어레이의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 순서 형상 (xdeg + 1 ydeg + 1)</target>
        </trans-unit>
        <trans-unit id="3795a0fc387856e1a4fb9463ff23e8e2dc033c86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt;, then the columns of &lt;code&gt;V&lt;/code&gt; correspond to the elements of a 3-D coefficient array &lt;code&gt;c&lt;/code&gt; of shape (xdeg + 1, ydeg + 1, zdeg + 1) in the order</source>
          <target state="translated">만약 &lt;code&gt;V = polyvander3d(x, y, z, [xdeg, ydeg, zdeg])&lt;/code&gt; , 다음의 열 &lt;code&gt;V&lt;/code&gt; 의 3-D 계수 배열의 요소에 대응하는 &lt;code&gt;c&lt;/code&gt; 형 (xdeg + 1, ydeg + 1 zdeg + 1) 순서대로</target>
        </trans-unit>
        <trans-unit id="f8959bef2f1f180cd1904ca3003b3eeaecf0bbcb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt;, return the fill value, otherwise return None.</source>
          <target state="translated">경우 &lt;code&gt;a.fill_value == b.fill_value&lt;/code&gt; 채우기 값을 반환, 그렇지 않으면 None을 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8f6e1a60280ed3603677c79dbcdebfa7ff398c42" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt;, then the dimensions specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are removed, and a new axis inserted at the end corresponding to the diagonal.</source>
          <target state="translated">경우 &lt;code&gt;a.ndim &amp;gt; 2&lt;/code&gt; 다음에 의해 지정된 차원 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 제거되고, 새로운 축은 대각선에 대응하는 단부에 삽입 하였다.</target>
        </trans-unit>
        <trans-unit id="64c4131bb0fe8a413fc2bc1ebe219f3e36ea1e9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.ndim&lt;/code&gt; is 0, then since the depth of the nested list is 0, it will not be a list at all, but a simple Python scalar.</source>
          <target state="translated">경우 &lt;code&gt;a.ndim&lt;/code&gt; 가 0이고, 중첩 된 목록의 깊이가 0 그 이후, 모든의 목록,하지만 간단한 파이썬 스칼라되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="355d7bac3059f5072f60fecea5ae0b7d9ef0b74d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a.shape&lt;/code&gt; is (5,1), &lt;code&gt;b.shape&lt;/code&gt; is (1,6), &lt;code&gt;c.shape&lt;/code&gt; is (6,) and &lt;code&gt;d.shape&lt;/code&gt; is () so that &lt;em&gt;d&lt;/em&gt; is a scalar, then &lt;em&gt;a&lt;/em&gt;, &lt;em&gt;b&lt;/em&gt;, &lt;em&gt;c&lt;/em&gt;, and &lt;em&gt;d&lt;/em&gt; are all broadcastable to dimension (5,6); and</source>
          <target state="translated">경우 &lt;code&gt;a.shape&lt;/code&gt; 는 (5,1)이다 &lt;code&gt;b.shape&lt;/code&gt; 가 있다 (1,6), &lt;code&gt;c.shape&lt;/code&gt; 는 (6)이고 &lt;code&gt;d.shape&lt;/code&gt; 는 그 () 그렇다 &lt;em&gt;D는&lt;/em&gt; 다음 스칼라 , &lt;em&gt;B&lt;/em&gt; , &lt;em&gt;C&lt;/em&gt; , 및 &lt;em&gt;D는&lt;/em&gt; 치수 (5,6)에 대한 모든 캐스트 가능한이고; 과&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="61914428b3107b079ee31cfc27e080d8a722c6a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are nonscalar, their last dimensions must match.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 가 스칼라가 아닌 경우 마지막 차원이 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="b4f4e526a35a19438379df1f3dbff9a3882d194d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; and each choice array are not all broadcastable to the same shape.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 각각의 선택 배열이 모두 같은 모양으로 브로드 캐스트되지 않는 경우 .</target>
        </trans-unit>
        <trans-unit id="6714bc3434562dda36e8035d926f1d408c7a5936" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; does not own its own data or references or views to it exist, and the data memory must be changed. PyPy only: will always raise if the data memory must be changed, since there is no reliable way to determine if references or views to it exist.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 자신의 데이터 또는 참조 또는 그것에 전망을 보유하고 있지 않습니다 존재하고, 데이터 메모리 변경해야합니다. PyPy 만 해당 : 데이터 메모리에 대한 참조 또는 뷰가 존재하는지 판별 할 수있는 확실한 방법이 없으므로 데이터 메모리를 변경해야하는 경우 항상 증가합니다.</target>
        </trans-unit>
        <trans-unit id="d46ad13c1a8181bf81ec49d29f19d0a4e8222929" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then broadcasting rules apply, as explained in &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;Linear algebra on several matrices at once&lt;/a&gt;. This means that SVD is working in &amp;ldquo;stacked&amp;rdquo; mode: it iterates over all indices of the first &lt;code&gt;a.ndim - 2&lt;/code&gt; dimensions and for each combination SVD is applied to the last two indices. The matrix &lt;code&gt;a&lt;/code&gt; can be reconstructed from the decomposition with either &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; or &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt;. (The &lt;code&gt;@&lt;/code&gt; operator can be replaced by the function &lt;code&gt;np.matmul&lt;/code&gt; for python versions below 3.5.)</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 두 개 이상의 차원이에 설명 된대로 다음 방송 규칙이 적용 &lt;a href=&quot;../routines.linalg#routines-linalg-broadcasting&quot;&gt;번에 여러 행렬에 선형 대수학&lt;/a&gt; . 이는 SVD가 &quot;스택&quot;모드에서 작동한다는 것을 의미합니다. 첫 번째 &lt;code&gt;a.ndim - 2&lt;/code&gt; 차원 의 모든 인덱스를 반복하며 각 조합에 대해 SVD는 마지막 두 인덱스에 적용됩니다. 행렬 &lt;code&gt;a&lt;/code&gt; 는 &lt;code&gt;(u * s[..., None, :]) @ vh&lt;/code&gt; 또는 &lt;code&gt;u @ (s[..., None] * vh)&lt;/code&gt; 를 사용하여 분해에서 재구성 할 수 있습니다 . 합니다 ( &lt;code&gt;@&lt;/code&gt; 의 연산자는 함수로 대체 될 수 &lt;code&gt;np.matmul&lt;/code&gt; 3.5 이하 파이썬 버전).</target>
        </trans-unit>
        <trans-unit id="0f5e97c2878caebdac54716045091816869ce6d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by axis1 and axis2 are used to determine the 2-D sub-arrays whose traces are returned. The shape of the resulting array is the same as that of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; removed.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 의 차원이 두 개를 초과 하면 axis1 및 axis2로 지정된 축을 사용하여 트레이스가 반환되는 2 차원 하위 ​​배열을 결정합니다. 생성 된 어레이의 형상은 동일하다 와 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 제거. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1b46ead587370435670ac4bc03b81d9c95e42b33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 1-D, the function &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; is the same as &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; where &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt;&lt;code&gt;indices&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;range(len(array) - 1)&lt;/code&gt; with a zero placed in every other element: &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt;, &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 1-D의 함수이다 &lt;code&gt;ufunc.accumulate(a)&lt;/code&gt; 것과 동일하다 &lt;code&gt;ufunc.reduceat(a, indices)[::2]&lt;/code&gt; 여기서, &lt;a href=&quot;numpy.indices#numpy.indices&quot;&gt; &lt;code&gt;indices&lt;/code&gt; &lt;/a&gt; 되는 &lt;code&gt;range(len(array) - 1)&lt;/code&gt; 제로와마다 배치 다른 요소 : &lt;code&gt;indices = zeros(2 * len(a) - 1)&lt;/code&gt; , &lt;code&gt;indices[1::2] = range(1, len(a))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b8db921b8261a5150c028a4a52e2a78422e254b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, returns the diagonal of &lt;code&gt;a&lt;/code&gt; with the given offset, i.e., the collection of elements of the form &lt;code&gt;a[i, i+offset]&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; has more than two dimensions, then the axes specified by &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; are used to determine the 2-D sub-array whose diagonal is returned. The shape of the resulting array can be determined by removing &lt;code&gt;axis1&lt;/code&gt; and &lt;code&gt;axis2&lt;/code&gt; and appending an index to the right equal to the size of the resulting diagonals.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 2-D이고, 대각선의 반환 &lt;code&gt;a&lt;/code&gt; 오프셋으로 주어진, 즉, 폼 요소들의 집합 &lt;code&gt;a[i, i+offset]&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt; 의 차원이 두 개를 초과 하면 &lt;code&gt;axis1&lt;/code&gt; 및 &lt;code&gt;axis2&lt;/code&gt; 로 지정된 축 이 대각선이 반환되는 2 차원 하위 ​​배열을 결정하는 데 사용됩니다. 결과 배열의 모양은 &lt;code&gt;axis1&lt;/code&gt; 과 &lt;code&gt;axis2&lt;/code&gt; 를 제거 하고 결과 대각선의 크기와 동일한 오른쪽에 인덱스를 추가하여 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="016f6a15e05ea7909f939f7c56abdd96bd940bcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along its diagonal with the given offset is returned, i.e., the sum of elements &lt;code&gt;a[i,i+offset]&lt;/code&gt; for all i.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 1, 리턴 오프셋은 주어진 요소의 합 즉, 2-D, 그 대각선을 따라 합 &lt;code&gt;a[i,i+offset]&lt;/code&gt; 모든 I에 대해.</target>
        </trans-unit>
        <trans-unit id="821330dbafd930ef241f18ef291a677b001e3d1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, the sum along the diagonal is returned. If &lt;code&gt;a&lt;/code&gt; has larger dimensions, then an array of sums along diagonals is returned.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 는 2-D이고, 대각선을 따라 합이 반환된다. 경우 &lt;code&gt;a&lt;/code&gt; 큰 크기를 가지며, 사선을 따라 합계 다음 어레이가 반환된다.</target>
        </trans-unit>
        <trans-unit id="20e0991e165d15052f7414c1d9067709a6741ba8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is 2-D, then a 1-D array containing the diagonal and of the same type as &lt;code&gt;a&lt;/code&gt; is returned unless &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt;, in which case a 1-D array rather than a (2-D) &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt;&lt;code&gt;matrix&lt;/code&gt;&lt;/a&gt; is returned in order to maintain backward compatibility.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 다음 2-D는 대각선을 함유하는 1-D 배열이다 동일한 유형의 &lt;code&gt;a&lt;/code&gt; 않는 리턴 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 1-D 어레이보다는 (2-D)이 경우에, &lt;a href=&quot;numpy.matrix#numpy.matrix&quot;&gt; &lt;code&gt;matrix&lt;/code&gt; &lt;/a&gt; 리턴 이전 버전과의 호환성을 유지하기 위해.</target>
        </trans-unit>
        <trans-unit id="65772464bb82fc9b6e011b51f1c71a9673e3a5fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a &lt;code&gt;matrix&lt;/code&gt; object (as opposed to an &lt;code&gt;ndarray&lt;/code&gt;), then so are all the return values.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;code&gt;matrix&lt;/code&gt; 객체 (AN 반대로 &lt;code&gt;ndarray&lt;/code&gt; )하고 있으므로 모든 리턴 값이다.</target>
        </trans-unit>
        <trans-unit id="cea4b92a7534a3149383f752281c310050f705b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a reference to &lt;code&gt;b&lt;/code&gt;, then &lt;code&gt;(a is b) == True&lt;/code&gt;. Therefore, &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are different names for the same Python object.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 참조 인 &lt;code&gt;b&lt;/code&gt; 다음 &lt;code&gt;(a is b) == True&lt;/code&gt; . 따라서 &lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 는 동일한 Python 객체에 대해 서로 다른 이름입니다.</target>
        </trans-unit>
        <trans-unit id="f198160018800c5362e7b3890cbfcb18e618a7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 의 하위 클래스 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 그 클래스는 보존된다. 입력이 이미 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 인&lt;/a&gt; 경우 복사가 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="edeed84f3c81e9ebf31ecd438474825302f801e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is a subclass of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, its class is conserved. No copy is performed if the input is already an &lt;code&gt;ndarray&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 의 하위 클래스 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 그 클래스는 보존된다. 입력이 이미 &lt;code&gt;ndarray&lt;/code&gt; 이면 복사가 수행되지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="79b3d97ca6a58beeb5178bade7556181ec643eb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is a 1-D array, it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; ND 어레이이고, &lt;code&gt;b&lt;/code&gt; 는 1-D 어레이, 그것의 마지막 축 위에 합 제품 및 &lt;code&gt;b&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41bd115d2530c0df6f893d58055a4e7bbeb51a86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is an N-D array and &lt;code&gt;b&lt;/code&gt; is an M-D array (where &lt;code&gt;M&amp;gt;=2&lt;/code&gt;), it is a sum product over the last axis of &lt;code&gt;a&lt;/code&gt; and the second-to-last axis of &lt;code&gt;b&lt;/code&gt;:</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; ND 어레이이고, &lt;code&gt;b&lt;/code&gt; (여기서 멀티 디스크 배열 &lt;code&gt;M&amp;gt;=2&lt;/code&gt; )가 마지막 축 위에 합 제품 및 마지막에서 두 번째 축 &lt;code&gt;b&lt;/code&gt; : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e2d3d6c358f256f08097a63c0a16dbce473bc638" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is complex the complex conjugate is taken before calculation of the dot product.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 복잡 켤레 복소수는 내적을 계산하기 전에 촬영됩니다.</target>
        </trans-unit>
        <trans-unit id="eccde6fba477d4d0328834eeb9139f4c209a7f8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;a&lt;/code&gt; itself is returned. If &lt;code&gt;a&lt;/code&gt; is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;fill_value&lt;/code&gt; is None, &lt;code&gt;fill_value&lt;/code&gt; is set to &lt;code&gt;a.fill_value&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 하지 않은 것입니다 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; , 자체가 반환됩니다. 경우 &lt;code&gt;a&lt;/code&gt; A는 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;fill_value&lt;/code&gt; 를가 없음입니다, &lt;code&gt;fill_value&lt;/code&gt; 를가 로 설정되어 &lt;code&gt;a.fill_value&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ac306a4eb2b5b20798f61a7b119dddd329017ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is not square or inversion fails.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 사각형이 나 반전에 실패합니다.</target>
        </trans-unit>
        <trans-unit id="dc36615c1be692990452f6adc2c02bec7979d9d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is real, the type of &lt;code&gt;a&lt;/code&gt; is used for the output. If &lt;code&gt;a&lt;/code&gt; has complex elements, the returned type is float.</source>
          <target state="translated">경우 &lt;code&gt;a&lt;/code&gt; 진짜, 유형 &lt;code&gt;a&lt;/code&gt; 출력에 사용됩니다. 경우 &lt;code&gt;a&lt;/code&gt; 복잡한 요소를 가지고, 반환 타입은 부동이다.</target>
        </trans-unit>
        <trans-unit id="49742c1cee8e9efafb1c7fbbe431a8e95469bbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not &amp;lsquo;square&amp;rsquo; (in the above sense).</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 단수이거나 '사각형'이 아닌 경우 (위의 의미에서).</target>
        </trans-unit>
        <trans-unit id="2e9b74892f6f35d0326c1dc235300557d874f5a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;a&lt;/code&gt; is singular or not square.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 단수이거나 정사각형이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ceece9b2545779310cb6355ec10529e551268898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=False&lt;/code&gt;, this method produces a &amp;ldquo;packed&amp;rdquo; memory layout in which each field starts at the byte the previous field ended, and any padding bytes are removed.</source>
          <target state="translated">경우 &lt;code&gt;align=False&lt;/code&gt; ,이 방법은 이전 필드 종료 바이트에서 각 필드의 개시 및 패딩 바이트가 제거되는 &quot;포장&quot;메모리 레이아웃을 생성한다.</target>
        </trans-unit>
        <trans-unit id="460932656f30d1ee879c1ced09e2eca3e1ff623d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt; is set, numpy will pad the structure in the same way many C compilers would pad a C-struct. Aligned structures can give a performance improvement in some cases, at the cost of increased datatype size. Padding bytes are inserted between fields such that each field&amp;rsquo;s byte offset will be a multiple of that field&amp;rsquo;s alignment, which is usually equal to the field&amp;rsquo;s size in bytes for simple datatypes, see &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt;&lt;code&gt;PyArray_Descr.alignment&lt;/code&gt;&lt;/a&gt;. The structure will also have trailing padding added so that its itemsize is a multiple of the largest field&amp;rsquo;s alignment.</source>
          <target state="translated">경우 &lt;code&gt;align=True&lt;/code&gt; 많은 C 컴파일러 패드는 C-구조체를하는 것과 같은 방식으로, NumPy와 의지 패드에게 구조를 설정합니다. 정렬 된 구조는 데이터 유형 크기가 증가하는 대신 일부 경우에 성능 향상을 제공 할 수 있습니다. 패딩 바이트는 각 필드의 바이트 오프셋이 해당 필드 정렬의 배수가되도록 필드 사이에 삽입됩니다. 이는 일반적으로 간단한 데이터 유형의 경우 필드 크기 (바이트 단위)와 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr.alignment&quot;&gt; &lt;code&gt;PyArray_Descr.alignment&lt;/code&gt; &lt;/a&gt; . PyArray_Descr.alignment를 참조하십시오 . 구조는 또한 항목 화가 가장 큰 필드 정렬의 배수가되도록 후행 패딩이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8c190caa583967ef3d50f42e6abb370b98e8c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;align=True&lt;/code&gt;, this methods produces an &amp;ldquo;aligned&amp;rdquo; memory layout in which each field&amp;rsquo;s offset is a multiple of its alignment, and the total itemsize is a multiple of the largest alignment, by adding padding bytes as needed.</source>
          <target state="translated">경우 &lt;code&gt;align=True&lt;/code&gt; ,이 방법의 오프셋 각 필드는 정렬의 배수 인에서 &quot;정렬&quot;의 메모리 레이아웃을 생성하고, 총 itemsize 필요에 따라 바이트 패딩을 부가함으로써, 최대 배향의 배수이다.</target>
        </trans-unit>
        <trans-unit id="18f554f1ca3b0160e94e964322795aa916ef0365" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;arr&lt;/code&gt; doesn&amp;rsquo;t have a shape attribute (i.e. not an ndarray)</source>
          <target state="translated">&lt;code&gt;arr&lt;/code&gt; 에 모양 속성이없는 경우 (즉, ndarray가 아님)</target>
        </trans-unit>
        <trans-unit id="6f94c014869b41cb6e3e090bab6cec3fc3652e46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axes&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;axes&lt;/code&gt; 마지막 축보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fb5967cac1f9c838f629289b9701f4f5d967c63e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 0, only rows are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 0 만 행이 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="e77d1c339b65acf6a89a949d1d50328c8561be33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is 1 or -1, only columns are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 1 또는 -1 열만이 마스크된다.</target>
        </trans-unit>
        <trans-unit id="527dba2aee917b7e820a9015382f439872829fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, rows &lt;em&gt;and&lt;/em&gt; columns are masked.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 없음입니다, 행 &lt;em&gt;과&lt;/em&gt; 열이 마스크됩니다.</target>
        </trans-unit>
        <trans-unit id="1c5e761c4a44d3d8422fc68aeed03dd9853a0a7f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is None, the result is a scalar. Otherwise, if &lt;code&gt;axis&lt;/code&gt; is given and the array is at least 2-D, the result is a masked array with dimension one smaller than the array on which &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt;&lt;code&gt;mini&lt;/code&gt;&lt;/a&gt; is called.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 아무도 없다, 결과는 스칼라이다. 그렇지 않고 &lt;code&gt;axis&lt;/code&gt; 이 주어지고 배열이 2 차원 이상이면 결과는 &lt;a href=&quot;#numpy.ma.masked_array.mini&quot;&gt; &lt;code&gt;mini&lt;/code&gt; &lt;/a&gt; 가 호출 되는 배열보다 1 차원이 작은 마스크 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="042bc001a4914cd7d0d232c6f0fb346989909740" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 정수이고, 그것의 축 지정 &lt;code&gt;x&lt;/code&gt; 벡터 기준을 계산을 따라. 경우 &lt;code&gt;axis&lt;/code&gt; 2- 튜플, 그것은 2-D 행렬을 길게 축을 지정하고, 이들 매트릭스의 매트릭스 기준이 계산된다. 경우 &lt;code&gt;axis&lt;/code&gt; 중에 어느 한 다음 벡터 놈 없다 (경우 &lt;code&gt;x&lt;/code&gt; 1-D이다) 또는 매트릭스 표준은 (경우 &lt;code&gt;x&lt;/code&gt; 2-D이다)이 반환된다.</target>
        </trans-unit>
        <trans-unit id="bfadfc7eb4a4188168e39022bbb71c1c25d02efa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is an integer, it specifies the axis of &lt;code&gt;x&lt;/code&gt; along which to compute the vector norms. If &lt;code&gt;axis&lt;/code&gt; is a 2-tuple, it specifies the axes that hold 2-D matrices, and the matrix norms of these matrices are computed. If &lt;code&gt;axis&lt;/code&gt; is None then either a vector norm (when &lt;code&gt;x&lt;/code&gt; is 1-D) or a matrix norm (when &lt;code&gt;x&lt;/code&gt; is 2-D) is returned. The default is None.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 정수이고, 그것의 축 지정 &lt;code&gt;x&lt;/code&gt; 벡터 기준을 계산을 따라. 경우 &lt;code&gt;axis&lt;/code&gt; 2- 튜플, 그것은 2-D 행렬을 길게 축을 지정하고, 이들 매트릭스의 매트릭스 기준이 계산된다. 경우 &lt;code&gt;axis&lt;/code&gt; 중에 어느 한 다음 벡터 놈 없다 (경우 &lt;code&gt;x&lt;/code&gt; 1-D이다) 또는 매트릭스 표준은 (경우 &lt;code&gt;x&lt;/code&gt; 2-D이다)이 반환된다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="523d86ecb59b40a9d925f2a1e78fa6cb76926a2b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is given, the number of varargs must equal the number of axes. Default: 1.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 주어, 가변 인자의 수는 축의 수와 같아야한다. 기본값 : 1</target>
        </trans-unit>
        <trans-unit id="86e33ec8c24f94e2430b0659a5ab81a91a91d564" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is larger than the last axis of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 의 마지막 축보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b10999639108c4b4999de59d1e8da7d5676f431c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not &lt;code&gt;None&lt;/code&gt;, and an axis being squeezed is not of length 1</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 하지 않습니다 &lt;code&gt;None&lt;/code&gt; 및 압착되는 축 길이가 1이 아닌</target>
        </trans-unit>
        <trans-unit id="048ac1275e643db0f79c87e34405c76349afe0b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;axis&lt;/code&gt; is not None, and an axis being squeezed is not of length 1</source>
          <target state="translated">경우 &lt;code&gt;axis&lt;/code&gt; 없음], 및 압착되는 축 길이가 1이 아닌</target>
        </trans-unit>
        <trans-unit id="62e5f5a4f466db64bba565371ecaf3c0accbb2cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b = a[:100]&lt;/code&gt; is used instead, &lt;code&gt;a&lt;/code&gt; is referenced by &lt;code&gt;b&lt;/code&gt; and will persist in memory even if &lt;code&gt;del a&lt;/code&gt; is executed.</source>
          <target state="translated">경우 &lt;code&gt;b = a[:100]&lt;/code&gt; 대신 사용하는 &lt;code&gt;a&lt;/code&gt; 가 참조하는 &lt;code&gt;b&lt;/code&gt; 및더라도 메모리에 유지한다 &lt;code&gt;del a&lt;/code&gt; 실행한다.</target>
        </trans-unit>
        <trans-unit id="b1ba1d797cf86b71e14a5b8da31b21199908a909" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;b&lt;/code&gt; is a matrix, then all array results are returned as matrices.</source>
          <target state="translated">경우 &lt;code&gt;b&lt;/code&gt; 행렬이고, 모든 배열 행렬 결과로서 리턴된다.</target>
        </trans-unit>
        <trans-unit id="ca0b482dcb07a6085a21a5bc1b0dde224b2f172c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string from the list below, &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt; will use the method chosen to calculate the optimal bin width and consequently the number of bins (see &lt;code&gt;Notes&lt;/code&gt; for more detail on the estimators) from the data that falls within the requested range. While the bin width will be optimal for the actual data in the range, the number of bins will be computed to fill the entire range, including the empty portions. For visualisation, using the &amp;lsquo;auto&amp;rsquo; option is suggested. Weighted data is not supported for automated bin size selection.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 이 아래 목록의 문자열 인 경우 &lt;a href=&quot;#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; &lt;/a&gt; 는 선택된 방법을 사용하여 최적의 bin 너비와 결과적으로 요청 된 범위 내에있는 데이터에서 bin 수 ( 추정자에 대한 자세한 내용 은 &lt;code&gt;Notes&lt;/code&gt; 참조 )를 계산합니다. 빈 너비가 범위의 실제 데이터에 최적 인 반면 빈 수는 빈 부분을 포함하여 전체 범위를 채우도록 계산됩니다. 시각화를 위해 '자동'옵션을 사용하는 것이 좋습니다. 자동 출력 함 크기 선택에는 가중치 데이터가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b70a91ff0eb4c89d18a81d985f393eb13ac7933f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is a string, it defines the method used to calculate the optimal bin width, as defined by &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt;&lt;code&gt;histogram_bin_edges&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 문자열이고, 그것이 의해 정의 된 최적 빈의 폭을 계산하기 위해 사용되는 방법을 정의 &lt;a href=&quot;numpy.histogram_bin_edges#numpy.histogram_bin_edges&quot;&gt; &lt;code&gt;histogram_bin_edges&lt;/code&gt; 를&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbffbf31546ec9af5b6fd778dfc3e0a7e49fc75c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines a monotonically increasing array of bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 의 int는, 그것 (기본적으로, 10)을 소정 범위가 동일한 폭 빈들의 수를 정의한다. 경우 &lt;code&gt;bins&lt;/code&gt; 시퀀스는, 그 불균일 함을 허용 폭의 우측 에지를 포함 함 가장자리 일정하게 증가하는 배열을 정의한다.</target>
        </trans-unit>
        <trans-unit id="b4024bb04b779936a7803a2173c03bd8c96f6ec1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is an int, it defines the number of equal-width bins in the given range (10, by default). If &lt;code&gt;bins&lt;/code&gt; is a sequence, it defines the bin edges, including the rightmost edge, allowing for non-uniform bin widths.</source>
          <target state="translated">경우 &lt;code&gt;bins&lt;/code&gt; 의 int는, 그것 (기본적으로, 10)을 소정 범위가 동일한 폭 빈들의 수를 정의한다. 경우 &lt;code&gt;bins&lt;/code&gt; 시퀀스이며, 그 불균일 함을 허용 폭의 우측 가장자리를 포함하는 빈 에지를 정의한다.</target>
        </trans-unit>
        <trans-unit id="f3d0d1457dc2c27ebf07eb8b8d37fdfe4b5b5f86" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;bins&lt;/code&gt; is not monotonic.</source>
          <target state="translated">&lt;code&gt;bins&lt;/code&gt; 단조롭지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="f1d57ef4cb7d5156a4314b6ea06d7045fe52a5fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 없음, 만없는 &lt;a href=&quot;numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;order&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="eb00c687c7393dfd8dae48855df788062a7f7eb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is None, then only &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;order&lt;/code&gt; are used.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 없음, 만없는 &lt;a href=&quot;numpy.shape#numpy.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;order&lt;/code&gt; 사용된다.</target>
        </trans-unit>
        <trans-unit id="a3f34c748ade1a438e4af494b9939bb52d6b65ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffer&lt;/code&gt; is an object exposing the buffer interface, then all keywords are interpreted.</source>
          <target state="translated">경우 &lt;code&gt;buffer&lt;/code&gt; 버퍼 인터페이스를 노출하는 객체입니다, 모든 키워드는 해석됩니다.</target>
        </trans-unit>
        <trans-unit id="f67df360e18cb83b99203eea7e5b2b66896eaba4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;buffersize&lt;/code&gt; is zero, a default buffer size is used, otherwise it specifies how big of a buffer to use. Buffers which are powers of 2 such as 4096 or 8192 are recommended.</source>
          <target state="translated">경우 &lt;code&gt;buffersize&lt;/code&gt; 제로, 크기 버퍼 기본 그렇지 않으면 사용에 대한 버퍼의 얼마나 큰 지정, 사용됩니다. 4096 또는 8192와 같이 2의 거듭 제곱 버퍼가 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="beb58b828353ed80b8e0bbe892a75cbfcebae43d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than 3 dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 미만 3 차원이, 사람은 암시 적으로는 3-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [3 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="f7c13f789159cee3609188e9f6918f23db3edd6c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than three dimensions, ones are implicitly appended to its shape to make it 3-D. The shape of the result will be c.shape[3:] + x.shape + y.shape + z.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 세 개 미만의 크기를 가지고, 사람은 암시 적으로는 3-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [3 :] + x.shape + y.shape + z.shape입니다.</target>
        </trans-unit>
        <trans-unit id="210c7187323274ff624491c071d18c59ba05eaa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape + y.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 두 개 미만의 크기를 가지고, 사람은 암시 적으로는 2-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [2 :] + x.shape + y.shape입니다.</target>
        </trans-unit>
        <trans-unit id="4b9c82b7f7444c244d3d87499e2e6abb52d1e818" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; has fewer than two dimensions, ones are implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 두 개 미만의 크기를 가지고, 사람은 암시 적으로는 2-D 만드는 모양에 추가됩니다. 결과의 모양은 c.shape [2 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="b813783672e3b8b110dcc3caed6943e29c499cf7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array a one is implicitly appended to its shape to make it 2-D. The shape of the result will be c.shape[2:] + x.shape.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 하나의 암시는 2-D 있도록 그 형상에 부가 된 1-D 배열이다. 결과의 모양은 c.shape [2 :] + x.shape입니다.</target>
        </trans-unit>
        <trans-unit id="9b697950a550c5d2ac6bfd1a90d0ee0cf3873621" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermevander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermeval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of HermiteE series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = hermevander(x, n)&lt;/code&gt; 다음, &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;hermeval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 많은 HermiteE 시리즈의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8795163ae21f93104b677b1ca18c8738fd9a209a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = hermvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;hermval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Hermite series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = hermvander(x, n)&lt;/code&gt; 다음, &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;hermval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Hermite 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="41e4b417db13b3be059bf5b8693dedddbf2d39c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = lagvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;lagval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Laguerre series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이는 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = lagvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;lagval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Laguerre 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="a1b597f29a3697113f705d9c197e77e09839d912" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the array &lt;code&gt;V = legvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;legval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Legendre series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 어레이 인 &lt;code&gt;V = legvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;legval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 동일한 정도 및 샘플 포인트의 다수의 Legendre 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="b7f0c7e082f8807f04eefbe2acbae592bdec65ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = chebvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;chebval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of Chebyshev series of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 행렬이고 &lt;code&gt;V = chebvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;chebval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 같은 정도 및 샘플 포인트의 다수의 체비 쇼프 시리즈 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="4e382928aa8d32a6b35f8adca3a6cffe61170326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array of coefficients of length &lt;code&gt;n + 1&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; is the matrix &lt;code&gt;V = polyvander(x, n)&lt;/code&gt;, then &lt;code&gt;np.dot(V, c)&lt;/code&gt; and &lt;code&gt;polyval(x, c)&lt;/code&gt; are the same up to roundoff. This equivalence is useful both for least squares fitting and for the evaluation of a large number of polynomials of the same degree and sample points.</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이 계수들의 1 차원 어레이이다 &lt;code&gt;n + 1&lt;/code&gt; 및 &lt;code&gt;V&lt;/code&gt; 는 행렬이고 &lt;code&gt;V = polyvander(x, n)&lt;/code&gt; , 다음 &lt;code&gt;np.dot(V, c)&lt;/code&gt; 및 &lt;code&gt;polyval(x, c)&lt;/code&gt; 동일한 최대이다 완전하게하다. 이 동등성은 최소 제곱 피팅과 같은 정도의 많은 수의 다항식 및 샘플 포인트의 평가에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="8e80660168c2556d80131aae5098ce463a202c8f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;c&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is true the shape will be c.shape[1:] + x.shape. If &lt;code&gt;tensor&lt;/code&gt; is false the shape will be c.shape[1:]. Note that scalars have shape (,).</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 1-D 배열은 다음 &lt;code&gt;p(x)&lt;/code&gt; 와 같은 것 같은 형상 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;c&lt;/code&gt; 다차원이고, 결과의 형상의 값에 따라 &lt;code&gt;tensor&lt;/code&gt; . 경우 &lt;code&gt;tensor&lt;/code&gt; + x.shape : 참 형상 c.shape [1]가 될 것이다. 경우 &lt;code&gt;tensor&lt;/code&gt; 거짓 형상 c.shape [1]가 될 것이다. 스칼라의 모양은 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="0a3728daa3b2e189e758d347ca0d72357650db3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이이며 &lt;code&gt;n + 1&lt;/code&gt; 이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="e3ad7dc6a355dfc8a1c8aa46843f5488897fd4ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;c&lt;/code&gt; is of length &lt;code&gt;n + 1&lt;/code&gt;, this function returns the value:</source>
          <target state="translated">경우 &lt;code&gt;c&lt;/code&gt; 길이이며 &lt;code&gt;n + 1&lt;/code&gt; 이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="6a970efb45caa036763049ac1a92ee21b5440b3b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;check(..)&lt;/code&gt; is not used then F2PY generates few standard checks (e.g. in a case of an array argument, check for the proper shape and size) automatically. Use &lt;code&gt;check()&lt;/code&gt; to disable checks generated by F2PY.</source>
          <target state="translated">경우 &lt;code&gt;check(..)&lt;/code&gt; 를 사용하지 않는 그 F2PY 자동으로 (적절한 형상 및 크기 배열 인수 검사의 경우에는 예를 들면)를 몇 표준 검사를 생성한다. F2PY에 의해 생성 된 검사를 비활성화 하려면 &lt;code&gt;check()&lt;/code&gt; 를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ce30f3388eee45516fb0d109b2a57581be93d2fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cmp_op&lt;/code&gt; is not valid.</source>
          <target state="translated">경우 &lt;code&gt;cmp_op&lt;/code&gt; 이 유효하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f3791f18c578dee37c08b1f05312986ce4a1234a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;condition&lt;/code&gt; is boolean:</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 이 부울 인 경우 :</target>
        </trans-unit>
        <trans-unit id="945ce76f24a4c673d6aa37d9ae7569a5f68abd37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;data&lt;/code&gt; is provided, it must stay alive for the life of the array. One way to manage this is through &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">경우 &lt;code&gt;data&lt;/code&gt; 제공되며,이 배열의 삶을 위해 살아 남기해야합니다. 이를 관리하는 한 가지 방법은 &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; 를 사용하는 것입니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="58463c629975ec8a9511dbc013fc3e05064ff197" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;device&lt;/code&gt; does not have a &lt;code&gt;write()&lt;/code&gt; or &lt;code&gt;flush()&lt;/code&gt; method.</source>
          <target state="translated">&lt;code&gt;device&lt;/code&gt; 에 &lt;code&gt;write()&lt;/code&gt; 또는 &lt;code&gt;flush()&lt;/code&gt; 메서드 가없는 경우 .</target>
        </trans-unit>
        <trans-unit id="799e69512e3ae47752ad1a4389491bce54790cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation</source>
          <target state="translated">경우 &lt;code&gt;dtype&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 이러한 인수가 전달됩니다 &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt; DTYPE를 구성 할 수 있습니다. 자세한 문서는 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="eb15e22b2a7d43231c255a7fc2569fdb2ab36892" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, these arguments are passed to &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt;&lt;code&gt;numpy.format_parser&lt;/code&gt;&lt;/a&gt; to construct a dtype. See that function for detailed documentation.</source>
          <target state="translated">경우 &lt;code&gt;dtype&lt;/code&gt; 없는 &lt;code&gt;None&lt;/code&gt; , 이러한 인수가 전달됩니다 &lt;a href=&quot;numpy.format_parser#numpy.format_parser&quot;&gt; &lt;code&gt;numpy.format_parser&lt;/code&gt; &lt;/a&gt; DTYPE를 구성 할 수 있습니다. 자세한 문서는 해당 기능을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="68051abdc74ce34a8cd57f65aadeda23f8c9fb89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;dtype&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, then it requires that data type. If copying is allowed, it will make a temporary copy if the data is castable. If &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; is enabled, it will also copy the data back with another cast upon iterator destruction.</source>
          <target state="translated">&lt;code&gt;dtype&lt;/code&gt; 인 경우 이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 해당 데이터 유형이 필요합니다. 복사가 허용되면 데이터를 캐스트 할 수있는 경우 임시 복사를합니다. 경우 &lt;a href=&quot;#c.NPY_ITER_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ITER_UPDATEIFCOPY&lt;/code&gt; 가&lt;/a&gt; 활성화되어, 그것은 또한 반복자 파괴에 따라 다른 캐스트와 데이터 등을 복사합니다.</target>
        </trans-unit>
        <trans-unit id="760548f2e1b1246d013e160a44370e64f44dc286" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enddates&lt;/code&gt; specifies a date value that is earlier than the corresponding &lt;code&gt;begindates&lt;/code&gt; date value, the count will be negative.</source>
          <target state="translated">경우 &lt;code&gt;enddates&lt;/code&gt; 의 지정 대응보다 이전 날짜 값 &lt;code&gt;begindates&lt;/code&gt; 의 날짜 값, 카운트는 제외 할 것이다.</target>
        </trans-unit>
        <trans-unit id="417859000cee8d29cc7044346e37933b08a0f1c4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fieldname&lt;/code&gt; is the empty string &lt;code&gt;''&lt;/code&gt;, the field will be given a default name of the form &lt;code&gt;f#&lt;/code&gt;, where &lt;code&gt;#&lt;/code&gt; is the integer index of the field, counting from 0 from the left:</source>
          <target state="translated">경우 &lt;code&gt;fieldname&lt;/code&gt; 빈 문자열이다 &lt;code&gt;''&lt;/code&gt; 필드는 형식의 기본 이름이 주어집니다 &lt;code&gt;f#&lt;/code&gt; , &lt;code&gt;#&lt;/code&gt; 은 왼쪽에서 0에서 필드의 정수 인덱스, 계산을 :</target>
        </trans-unit>
        <trans-unit id="ea2d55579b57bf31daf1f1c848f07e4ba4a33873" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;fortranname&lt;/code&gt; statement is used without &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; then a dummy wrapper is generated.</source>
          <target state="translated">경우 &lt;code&gt;fortranname&lt;/code&gt; 문이없이 사용 &lt;code&gt;&amp;lt;actual Fortran/C routine name&amp;gt;&lt;/code&gt; 생성 된 래퍼 다음 더미.</target>
        </trans-unit>
        <trans-unit id="cb4a6b4dd2e4a7b67147341a42f6c8197722c973" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is a 1-D array of sorted integers, the entries indicate where along &lt;code&gt;axis&lt;/code&gt; the array is split. For example, &lt;code&gt;[2, 3]&lt;/code&gt; would, for &lt;code&gt;axis=0&lt;/code&gt;, result in</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 가 정렬 정수 1-D 어레이이고, 항목은 어디 함께 나타내는 &lt;code&gt;axis&lt;/code&gt; 배열이 분리된다. 예를 들어 &lt;code&gt;[2, 3]&lt;/code&gt; 은 &lt;code&gt;axis=0&lt;/code&gt; 의 경우</target>
        </trans-unit>
        <trans-unit id="750e535a910db315f0680626cd7e38f07dd476ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is an integer, N, the array will be divided into N equal arrays along &lt;code&gt;axis&lt;/code&gt;. If such a split is not possible, an error is raised.</source>
          <target state="translated">만약 &lt;code&gt;indices_or_sections&lt;/code&gt; 는 정수 N 인 배열을 따라 N 동일한 배열로 분할 될 &lt;code&gt;axis&lt;/code&gt; . 그러한 분할이 불가능하면 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="c2fbdd32f871ea7c6656b8280d919dff6251170e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indices_or_sections&lt;/code&gt; is given as an integer, but a split does not result in equal division.</source>
          <target state="translated">경우 &lt;code&gt;indices_or_sections&lt;/code&gt; 는 정수로 주어되지만 분할 동등한 분할을 초래하지 않는다.</target>
        </trans-unit>
        <trans-unit id="64c4e0e507acd8c3f4b71cfa7cf2cf1d38b76639" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(c)&lt;/code&gt; is used as a statement but without an entity declaration list, then F2PY adds the &lt;code&gt;intent(c)&lt;/code&gt; attribute to all arguments.</source>
          <target state="translated">경우 &lt;code&gt;intent(c)&lt;/code&gt; 성명으로하지만, 엔티티 선언 목록없이 사용하고 F2PY은 추가 &lt;code&gt;intent(c)&lt;/code&gt; 모든 인수에 대한 속성을.</target>
        </trans-unit>
        <trans-unit id="820239142587f3701cc156b154b6624dd5007ecf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;intent(copy)&lt;/code&gt; or &lt;code&gt;intent(overwrite)&lt;/code&gt; is used, then an additional optional argument is introduced with a name &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; and a default value 0 or 1, respectively.</source>
          <target state="translated">인 &lt;code&gt;intent(copy)&lt;/code&gt; 또는 인 &lt;code&gt;intent(overwrite)&lt;/code&gt; 를 사용하는 경우 각각 &lt;code&gt;overwrite_&amp;lt;argument name&amp;gt;&lt;/code&gt; 과 기본값 0 또는 1 로 추가 선택적 인수가 도입 됩니다.</target>
        </trans-unit>
        <trans-unit id="c296e3258dbc49519e8602388ede880a24772142" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;gt; l&lt;/code&gt;, then only &lt;code&gt;x_1, ..., x_l&lt;/code&gt; are set.</source>
          <target state="translated">경우 &lt;code&gt;k &amp;gt; l&lt;/code&gt; , 만 &lt;code&gt;x_1, ..., x_l&lt;/code&gt; 설정된다.</target>
        </trans-unit>
        <trans-unit id="271207c6144fe7ced9054709b41446a9de60c700" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;k &amp;lt; l&lt;/code&gt;, then &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; are ignored.</source>
          <target state="translated">경우 &lt;code&gt;k &amp;lt; l&lt;/code&gt; 다음 &lt;code&gt;y_{k + 1}, ..., y_l&lt;/code&gt; 무시된다.</target>
        </trans-unit>
        <trans-unit id="e99e0454406f9add7ef291687419a1330612a513" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not MT19937, then state is returned as a dictionary.</source>
          <target state="translated">경우 &lt;code&gt;legacy&lt;/code&gt; 거짓이다, 또는 BitGenerator이 MT19937되어 있지 않은 경우, 상태는 사전로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce1a7ad82e3cfecd360d23c388ed9b15e3542af6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;legacy&lt;/code&gt; is False, or the BitGenerator is not NT19937, then state is returned as a dictionary.</source>
          <target state="translated">만약 &lt;code&gt;legacy&lt;/code&gt; 거짓이다, 또는 BitGenerator이 NT19937되어 있지 않은 경우, 상태는 사전로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="146abcde4c240659f226130b295dbaf50c55deac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 0&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;m &amp;lt; 0&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; 또는 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c2df004cd887df3e646568cfffdf17b3ac0ffbf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m &amp;lt; 1&lt;/code&gt;, &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt;, &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt;, or &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt;.</source>
          <target state="translated">만약 &lt;code&gt;m &amp;lt; 1&lt;/code&gt; , &lt;code&gt;len(k) &amp;gt; m&lt;/code&gt; , &lt;code&gt;np.ndim(lbnd) != 0&lt;/code&gt; , 또는 &lt;code&gt;np.ndim(scl) != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e220ffcadc52e486b28727579ddc1e86ad96fbcc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;m2&lt;/code&gt; have different flexible dtypes.</source>
          <target state="translated">만약 &lt;code&gt;m1&lt;/code&gt; 및 &lt;code&gt;m2&lt;/code&gt; 에 다른 유연한 dtype이있는</target>
        </trans-unit>
        <trans-unit id="0cda2eb48aaf0ad93b34e30066de3169d0688cac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m&lt;/code&gt; has a single column then that column is returned as the single row of a matrix. Otherwise &lt;code&gt;m&lt;/code&gt; is returned. The returned matrix is always either &lt;code&gt;m&lt;/code&gt; itself or a view into &lt;code&gt;m&lt;/code&gt;. Supplying an axis keyword argument will not affect the returned matrix but it may cause an error to be raised.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 에 단일 열이 있으면 해당 열이 행렬의 단일 행으로 반환됩니다. 그렇지 않으면 &lt;code&gt;m&lt;/code&gt; 이 반환됩니다. 반환 된 행렬은 항상 &lt;code&gt;m&lt;/code&gt; 자체이거나 &lt;code&gt;m&lt;/code&gt; . 축 키워드 인수를 제공하면 반환 된 행렬에 영향을 미치지 않지만 오류가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d089e6b20e99bc8aa35211116381511548d1fc6f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done, the rightmost ones.</source>
          <target state="translated">경우 &lt;code&gt;maxsplit&lt;/code&gt; 는 기껏 주어진다 &lt;code&gt;maxsplit&lt;/code&gt; 분할이 수행됩니다 (가장 오른쪽).</target>
        </trans-unit>
        <trans-unit id="f3a2beabba4d5e799494083ff0f67c424eaf8432" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maxsplit&lt;/code&gt; is given, at most &lt;code&gt;maxsplit&lt;/code&gt; splits are done.</source>
          <target state="translated">경우 &lt;code&gt;maxsplit&lt;/code&gt; 이 주어진에서 가장 &lt;code&gt;maxsplit&lt;/code&gt; 의 분할이 이루어집니다.</target>
        </trans-unit>
        <trans-unit id="6e310688fa6d65057ce51d85bd5439d15eeafd62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; is called.</source>
          <target state="translated">경우 &lt;code&gt;n + p &amp;lt;= m&lt;/code&gt; 후 &lt;code&gt;gun(a_1, ..., a_n, e_1, ..., e_p)&lt;/code&gt; 호출된다.</target>
        </trans-unit>
        <trans-unit id="75d4baac79ac0ec79605a8d87c557699bd33432f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n + p&lt;/code&gt; is less than the number of required arguments to &lt;code&gt;gun&lt;/code&gt; then an exception is raised.</source>
          <target state="translated">경우 &lt;code&gt;n + p&lt;/code&gt; 이하에 필요한 인자의 수보다 &lt;code&gt;gun&lt;/code&gt; 는 예외가 발생된다.</target>
        </trans-unit>
        <trans-unit id="a6773ebb7a73c0cf9641c3fc6c53898d5654dcdd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;n&lt;/code&gt; is even, &lt;code&gt;A[-1]&lt;/code&gt; contains the term representing both positive and negative Nyquist frequency (+fs/2 and -fs/2), and must also be purely real. If &lt;code&gt;n&lt;/code&gt; is odd, there is no term at fs/2; &lt;code&gt;A[-1]&lt;/code&gt; contains the largest positive frequency (fs/2*(n-1)/n), and is complex in the general case.</source>
          <target state="translated">경우 &lt;code&gt;n&lt;/code&gt; 이 짝수이고, &lt;code&gt;A[-1]&lt;/code&gt; 양극과 음극 나이키 스트 주파수 (FS + / 2, -fs / 2) 모두를 표현하는 용어를 포함하고, 또한 실제 순수해야한다. 경우 &lt;code&gt;n&lt;/code&gt; 이 홀수, FS / 2에서 어떤 용어는 없다; &lt;code&gt;A[-1]&lt;/code&gt; 은 가장 큰 양의 주파수 (fs / 2 * (n-1) / n)를 포함하며 일반적인 경우에는 복잡합니다.</target>
        </trans-unit>
        <trans-unit id="d002795222f44b6308a6ac63aedd1a3723557506" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names&lt;/code&gt; is True, the field names are read from the first line after the first &lt;code&gt;skip_header&lt;/code&gt; lines. This line can optionally be proceeded by a comment delimiter. If &lt;code&gt;names&lt;/code&gt; is a sequence or a single-string of comma-separated names, the names will be used to define the field names in a structured dtype. If &lt;code&gt;names&lt;/code&gt; is None, the names of the dtype fields will be used, if any.</source>
          <target state="translated">경우 &lt;code&gt;names&lt;/code&gt; True 인, 필드 이름은 첫 번째 후 첫 번째 줄에서 읽 &lt;code&gt;skip_header&lt;/code&gt; 의 라인. 이 행은 선택적으로 주석 분리 문자로 진행될 수 있습니다. 경우 &lt;code&gt;names&lt;/code&gt; 순서 또는 쉼표로 구분 명칭의 단일 스트링이고, 이름은 구성 DTYPE에 필드 명을 정의하는 데 사용된다. 만약 &lt;code&gt;names&lt;/code&gt; 없음입니다 (있는 경우) DTYPE 필드의 이름이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="07b76e3a08f68e2d41d08bcc90944dfb38bf1854" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;names=None&lt;/code&gt; but a structured dtype is expected, names are defined with the standard NumPy default of &lt;code&gt;&quot;f%i&quot;&lt;/code&gt;, yielding names like &lt;code&gt;f0&lt;/code&gt;, &lt;code&gt;f1&lt;/code&gt; and so forth:</source>
          <target state="translated">경우 &lt;code&gt;names=None&lt;/code&gt; 그러나이 구조 DTYPE이 예상되지 않으며, 이름의 표준 NumPy와 디폴트로 정의 된 &lt;code&gt;&quot;f%i&quot;&lt;/code&gt; 와 같은 이름 수득 &lt;code&gt;f0&lt;/code&gt; , &lt;code&gt;f1&lt;/code&gt; 등등과 :</target>
        </trans-unit>
        <trans-unit id="9d8d4bbddf580197e193ef2ab5f3260ca263687d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. In contrast to &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt; it makes no attempt to copy the data from &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; This undoes &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called after an error when you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input.</source>
          <target state="translated">경우 &lt;code&gt;obj.flags&lt;/code&gt; 가 있다 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 (사용되지 않음) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; ,이 기능은 플래그, 지 웁니다 &lt;code&gt;DECREF&lt;/code&gt; 의 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 하고 쓰기 가능하게하고, 세트 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULL한다. &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 와 달리 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 에서 데이터를 복사하려고 시도하지 않습니다 . &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; 를&lt;/a&gt; 실행 취소 합니다 . 일반적으로 이것은 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 직전에 &lt;code&gt;obj&lt;/code&gt; 로 끝나면 오류 후에 호출됩니다 . 여러 번 호출되거나 &lt;code&gt;NULL&lt;/code&gt; 입력 으로 호출 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8f43e6f1e973bd0d462747acc6303f4251ae23b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.flags&lt;/code&gt; has &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; or (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt;, this function clears the flags, &lt;code&gt;DECREF&lt;/code&gt; s &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; and makes it writeable, and sets &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; to NULL. It then copies &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; to &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt;, and returns the error state of the copy operation. This is the opposite of &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt;&lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt;&lt;/a&gt;. Usually this is called once you are finished with &lt;code&gt;obj&lt;/code&gt;, just before &lt;code&gt;Py_DECREF(obj)&lt;/code&gt;. It may be called multiple times, or with &lt;code&gt;NULL&lt;/code&gt; input. See also &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.flags&lt;/code&gt; 가 있다 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 (사용되지 않음) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; ,이 기능은 플래그, 지 웁니다 &lt;code&gt;DECREF&lt;/code&gt; 의 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; 하고 쓰기 가능하게하고, 세트 &lt;code&gt;obj-&amp;gt;base&lt;/code&gt; NULL한다. 그런 다음 &lt;code&gt;obj-&amp;gt;data&lt;/code&gt; 를 &lt;code&gt;obj-&amp;gt;base-&amp;gt;data&lt;/code&gt; 로 복사하고 복사 작업의 오류 상태를 리턴합니다. 이것은 &lt;a href=&quot;#c.PyArray_SetWritebackIfCopyBase&quot;&gt; &lt;code&gt;PyArray_SetWritebackIfCopyBase&lt;/code&gt; &lt;/a&gt; 와 반대입니다 . 일반적으로 &lt;code&gt;Py_DECREF(obj)&lt;/code&gt; 직전에 &lt;code&gt;obj&lt;/code&gt; 로 완료하면 호출 됩니다. 여러 번 호출되거나 &lt;code&gt;NULL&lt;/code&gt; 입력 으로 호출 될 수 있습니다 . &lt;a href=&quot;#c.PyArray_DiscardWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_DiscardWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 참조.</target>
        </trans-unit>
        <trans-unit id="90c51090e68a386a4d8166c7cdb0f79785d7f6e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt;&lt;code&gt;True&lt;/code&gt;&lt;/a&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#False&quot;&gt;&lt;code&gt;False&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; 요소로 채워진 1 차원 어레이 반환 &lt;em&gt;X&lt;/em&gt; 에 대응하는 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 값 &lt;em&gt;OBJ를&lt;/em&gt; . 검색 순서는 &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; , C 스타일입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 이 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#True&quot;&gt; &lt;code&gt;True&lt;/code&gt; &lt;/a&gt; 의 경계 외부에있는 항목에 값을 &lt;em&gt;X&lt;/em&gt; , 다음 인덱스 오류가 발생합니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 보다 작은 &lt;em&gt;X&lt;/em&gt; 는 그것을 채우는 동일 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#False&quot;&gt; &lt;code&gt;False&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19e346c07517b41525b586a4ff8685ed9ba6dbe8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; 요소로 채워진 1 차원 어레이 반환 &lt;em&gt;X&lt;/em&gt; 에 대응하는 &lt;code&gt;True&lt;/code&gt; 값 &lt;em&gt;OBJ를&lt;/em&gt; . 검색 순서는 &lt;a href=&quot;../glossary#term-row-major&quot;&gt;row-major&lt;/a&gt; , C 스타일입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 의 경계 외부에있는 항목에 값을 &lt;em&gt;X&lt;/em&gt; , 다음 인덱스 오류가 발생합니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 보다 작은 &lt;em&gt;X&lt;/em&gt; 는 그것을 채우는 동일 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9effe7f71bd1a595880c87c20422da0870723e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt;, &lt;code&gt;x[obj]&lt;/code&gt; returns a 1-dimensional array filled with the elements of &lt;em&gt;x&lt;/em&gt; corresponding to the &lt;code&gt;True&lt;/code&gt; values of &lt;em&gt;obj&lt;/em&gt;. The search order will be &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt;, C-style. If &lt;em&gt;obj&lt;/em&gt; has &lt;code&gt;True&lt;/code&gt; values at entries that are outside of the bounds of &lt;em&gt;x&lt;/em&gt;, then an index error will be raised. If &lt;em&gt;obj&lt;/em&gt; is smaller than &lt;em&gt;x&lt;/em&gt; it is identical to filling it with &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj.ndim == x.ndim&lt;/code&gt; , &lt;code&gt;x[obj]&lt;/code&gt; 요소로 채워진 1 차원 어레이 반환 &lt;em&gt;X&lt;/em&gt; 에 대응하는 &lt;code&gt;True&lt;/code&gt; 값 &lt;em&gt;OBJ를&lt;/em&gt; . 검색 순서는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-row-major&quot;&gt;row-major&lt;/a&gt; , C 스타일입니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 이 &lt;code&gt;True&lt;/code&gt; 의 경계 외부에있는 항목에 값을 &lt;em&gt;X&lt;/em&gt; , 다음 인덱스 오류가 발생합니다. 경우 &lt;em&gt;obj가&lt;/em&gt; 보다 작은 &lt;em&gt;X&lt;/em&gt; 는 그것을 채우는 동일 &lt;code&gt;False&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c24698bfa7f55b1863fd1ee853e61b9963b6226" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;, then call the &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; constructor. If &lt;code&gt;obj&lt;/code&gt; is a string, then call the &lt;a href=&quot;numpy.fromstring#numpy.fromstring&quot;&gt;&lt;code&gt;fromstring&lt;/code&gt;&lt;/a&gt; constructor. If &lt;code&gt;obj&lt;/code&gt; is a list or a tuple, then if the first object is an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, call &lt;a href=&quot;numpy.core.records.fromarrays#numpy.core.records.fromarrays&quot;&gt;&lt;code&gt;fromarrays&lt;/code&gt;&lt;/a&gt;, otherwise call &lt;a href=&quot;numpy.core.records.fromrecords#numpy.core.records.fromrecords&quot;&gt;&lt;code&gt;fromrecords&lt;/code&gt;&lt;/a&gt;. If &lt;code&gt;obj&lt;/code&gt; is a &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt;, then make a copy of the data in the recarray (if &lt;code&gt;copy=True&lt;/code&gt;) and use the new formats, names, and titles. If &lt;code&gt;obj&lt;/code&gt; is a file, then call &lt;a href=&quot;numpy.fromfile#numpy.fromfile&quot;&gt;&lt;code&gt;fromfile&lt;/code&gt;&lt;/a&gt;. Finally, if obj is an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, then return &lt;code&gt;obj.view(recarray)&lt;/code&gt;, making a copy of the data if &lt;code&gt;copy=True&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;obj&lt;/code&gt; 가 없습니다 &lt;code&gt;None&lt;/code&gt; , 다음 전화 &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt; 생성자를. 경우 &lt;code&gt;obj&lt;/code&gt; 가 문자열 인 다음 전화 &lt;a href=&quot;numpy.fromstring#numpy.fromstring&quot;&gt; &lt;code&gt;fromstring&lt;/code&gt; &lt;/a&gt; 생성자를. 경우 &lt;code&gt;obj&lt;/code&gt; 가 목록 또는 튜플이며, 그 첫 번째 개체는 경우 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 전화 &lt;a href=&quot;numpy.core.records.fromarrays#numpy.core.records.fromarrays&quot;&gt; &lt;code&gt;fromarrays&lt;/code&gt; &lt;/a&gt; , 그렇지 않으면 전화 &lt;a href=&quot;numpy.core.records.fromrecords#numpy.core.records.fromrecords&quot;&gt; &lt;code&gt;fromrecords&lt;/code&gt; 은&lt;/a&gt; . 경우 &lt;code&gt;obj&lt;/code&gt; 가 A는 &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; 은&lt;/a&gt; , 다음 (경우 recarray에있는 데이터의 복사본을 만들 &lt;code&gt;copy=True&lt;/code&gt; )와 새로운 형식, 이름 및 제목을 사용합니다. 경우 &lt;code&gt;obj&lt;/code&gt; 가 파일입니다, 다음 전화 &lt;a href=&quot;numpy.fromfile#numpy.fromfile&quot;&gt; &lt;code&gt;fromfile&lt;/code&gt; &lt;/a&gt; . 마지막으로 obj가 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 이면 다음을 반환합니다. &lt;code&gt;obj.view(recarray)&lt;/code&gt; , &lt;code&gt;copy=True&lt;/code&gt; 인 경우 데이터 복사본을 만듭니다 .</target>
        </trans-unit>
        <trans-unit id="0cb8b5f8682e528917b9dad63d5ce0f0a15864d5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;obj&lt;/code&gt; isn&amp;rsquo;t a suitable numeric type.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 가 적합한 숫자 유형이 아닌 경우</target>
        </trans-unit>
        <trans-unit id="bd67812cd1998c40abb29425bc518b926e6b0841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt;&lt;code&gt;Py_NotImplemented&lt;/code&gt;&lt;/a&gt; and no error condition is set.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 작성된 ndarray에 대한 새 참조를 포함 하거나 변환 중에 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 을 포함 합니다. 그렇지 않으면 out에는 &lt;a href=&quot;https://docs.python.org/dev/c-api/object.html#c.Py_NotImplemented&quot;&gt; &lt;code&gt;Py_NotImplemented&lt;/code&gt; 에&lt;/a&gt; 대한 빌린 참조가 포함되며 오류 조건이 설정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="12f75ca0900af5198142d436cbdd5e1ee389cfd4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the dtype in the part of the array interface that looks for the &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute. &lt;code&gt;context&lt;/code&gt; is unused.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 생성 된 ndarray에 대한 새 참조를 포함 하거나 변환 중 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 에 &lt;code&gt;NULL&lt;/code&gt; 이 포함 됩니다 . 그렇지 않으면 out은 Py_NotImplemented에 대한 빌린 참조를 포함하고 오류 조건이 설정되지 않습니다. 이 버전에서는 &lt;a href=&quot;../arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 속성 을 찾는 배열 인터페이스 부분에서 dtype을 설정할 수 있습니다 . &lt;code&gt;context&lt;/code&gt; 가 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="98dbfb53c5754a6749d968f5df5fe9eebecd4ff8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; implements any part of the array interface, then &lt;code&gt;out&lt;/code&gt; will contain a new reference to the newly created ndarray using the interface or &lt;code&gt;out&lt;/code&gt; will contain &lt;code&gt;NULL&lt;/code&gt; if an error during conversion occurs. Otherwise, out will contain a borrowed reference to Py_NotImplemented and no error condition is set. This version allows setting of the type and context in the part of the array interface that looks for the &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; attribute.</source>
          <target state="translated">&lt;code&gt;op&lt;/code&gt; 가 배열 인터페이스의 일부를 구현하는 경우 &lt;code&gt;out&lt;/code&gt; 은 인터페이스를 사용하여 새로 작성된 ndarray에 대한 새 참조를 포함 하거나 변환 중에 오류가 발생하면 &lt;code&gt;out&lt;/code&gt; 이 &lt;code&gt;NULL&lt;/code&gt; 을 포함 합니다. 그렇지 않으면 out에는 Py_NotImplemented에 대한 빌린 참조가 포함되며 오류 조건이 설정되지 않습니다. 이 버전에서는 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; 속성 을 찾는 배열 인터페이스 부분에서 유형과 컨텍스트를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ed83570f54caf00535275cbf2433364d3dc43b7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op&lt;/code&gt; is already (C-style) contiguous and well-behaved then just return a reference, otherwise return a (contiguous and well-behaved) copy of the array. The parameter op must be a (sub-class of an) ndarray and no checking for that is done.</source>
          <target state="translated">경우 &lt;code&gt;op&lt;/code&gt; 이미 (C 식)이며, 인접 단지 참조를 반환 한 후 잘 행동 그렇지는 (연속 및 품행) 배열의 카피 반환. op 매개 변수는 ndarray의 (하위 클래스)이어야하며 이에 대한 점검은 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3efc82f6eb8962f2bbdd61dd48e5d36f40ab01fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;op_dtypes&lt;/code&gt; isn&amp;rsquo;t &lt;code&gt;NULL&lt;/code&gt;, it specifies a data type or &lt;code&gt;NULL&lt;/code&gt; for each &lt;code&gt;op[i]&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;op_dtypes&lt;/code&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 각 &lt;code&gt;op[i]&lt;/code&gt; 에 대해 데이터 유형 또는 &lt;code&gt;NULL&lt;/code&gt; 을 지정합니다 .</target>
        </trans-unit>
        <trans-unit id="49913a9d3761c3c5184d0fb1b55beebafb026c1c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;otypes&lt;/code&gt; is not specified, then a call to the function with the first argument will be used to determine the number of outputs. The results of this call will be cached if &lt;code&gt;cache&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; to prevent calling the function twice. However, to implement the cache, the original function must be wrapped which will slow down subsequent calls, so only do this if your function is expensive.</source>
          <target state="translated">경우 &lt;code&gt;otypes&lt;/code&gt; 가 지정되어 있지 않은 경우, 상기 제 인수 함수 호출은 출력의 개수를 결정하는 데 사용된다. 이 호출의 결과 는 함수가 두 번 호출되지 않도록 &lt;code&gt;cache&lt;/code&gt; 가 &lt;code&gt;True&lt;/code&gt; 인 경우 캐시 됩니다. 그러나 캐시를 구현하려면 원래 함수를 랩핑해야 후속 호출 속도가 느려질 수 있으므로 함수가 비싼 경우에만 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="3aa37ff615f56f9b7e65eaa58699e643fd032326" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, a shuffled copy of &lt;code&gt;x&lt;/code&gt; is returned. Otherwise, the shuffled array is stored in &lt;code&gt;out&lt;/code&gt;, and &lt;code&gt;out&lt;/code&gt; is returned</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음입니다의 단행 사본 &lt;code&gt;x&lt;/code&gt; 반환됩니다. 그렇지 않으면 셔플 된 배열이 &lt;code&gt;out&lt;/code&gt; 에 저장 되고 &lt;code&gt;out&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6567b2686e797d9822a7bbf895363486cc94afc9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 표준 편차를 포함하는 새로운 배열을 반환한다.</target>
        </trans-unit>
        <trans-unit id="089152cfcf81b924028fc82e4f2ab4321cd32c01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the standard deviation, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 표준 편차를 포함하는 새로운 배열을 반환한다. ddof가&amp;gt; =이면 슬라이스의 비 NaN 요소 수 또는 슬라이스에 NaN 만 포함 된 경우 해당 슬라이스의 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="a3cf56d56f9711ddb9fe165ac4a15d1c897a7d62" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is None, return a new array containing the variance, otherwise return a reference to the output array. If ddof is &amp;gt;= the number of non-NaN elements in a slice or the slice contains only NaNs, then the result for that slice is NaN.</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 없음없고, 그렇지 출력 배열에 대한 참조를 반환 분산을 포함하는 새로운 배열을 반환한다. ddof가&amp;gt; =이면 슬라이스의 비 NaN 요소 수 또는 슬라이스에 NaN 만 포함 된 경우 해당 슬라이스의 결과는 NaN입니다.</target>
        </trans-unit>
        <trans-unit id="bd3ed46fb1ad18e3f54a87922d109c78bc224796" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out&lt;/code&gt; is provided, the function writes the result into it, and returns a reference to &lt;code&gt;out&lt;/code&gt;. (See Examples)</source>
          <target state="translated">경우 &lt;code&gt;out&lt;/code&gt; 제공되며,이 함수에 그 결과를 기록하고 참조 반환 &lt;code&gt;out&lt;/code&gt; . (실시 예 참조)</target>
        </trans-unit>
        <trans-unit id="d0b860961bc5b4a4c45189c0fd4de5c2d61f1ab4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 평균값이 포함 된 새 배열을 반환하고, 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d2bfee9ac0986058c6155b92fa93c7a62c8953a4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the mean values, otherwise a reference to the output array is returned. Nan is returned for slices that contain only NaNs.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 평균값이 포함 된 새 배열을 반환하고, 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다. NaN 만 포함 된 슬라이스에 대해서는 Nan이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="64277711f0130f08ef89a03256433633c6256165" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;out=None&lt;/code&gt;, returns a new array containing the variance; otherwise, a reference to the output array is returned.</source>
          <target state="translated">&lt;code&gt;out=None&lt;/code&gt; 인 경우 분산을 포함하는 새 배열을 반환합니다. 그렇지 않으면 출력 배열에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="9b1c9c61ff9f1ab4238c3c9129f3c3d7264b97ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;output&lt;/code&gt; not supplied then source code is printed to screen (sys.stdout). File object must be created with either write &amp;lsquo;w&amp;rsquo; or append &amp;lsquo;a&amp;rsquo; modes.</source>
          <target state="translated">경우에 &lt;code&gt;output&lt;/code&gt; 한 후 공급되지 소스 코드가 화면 (sys.stdout)에 출력된다. 파일 개체는 쓰기 'w'또는 추가 'a'모드로 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="710d73ebab70d58eff0ea577b59d52767457dc24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;gt; m&lt;/code&gt; then &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; is called.</source>
          <target state="translated">경우 &lt;code&gt;p &amp;gt; m&lt;/code&gt; 다음 &lt;code&gt;gun(e_1, ..., e_m)&lt;/code&gt; 라고합니다.</target>
        </trans-unit>
        <trans-unit id="7ffd83286f9552326735c9e9997d8b928bd7d08a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; is called, here &lt;code&gt;q=m-p&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;p &amp;lt;= m &amp;lt; n + p&lt;/code&gt; 다음 &lt;code&gt;gun(a_1, ..., a_q, e_1, ..., e_p)&lt;/code&gt; 여기라고 &lt;code&gt;q=m-p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16e928ca77781f5fb31deca2051e51b1031bced3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p == 0&lt;/code&gt; then &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; is called, here &lt;code&gt;q = min(m, n)&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;p == 0&lt;/code&gt; 다음 &lt;code&gt;gun(a_1, ..., a_q)&lt;/code&gt; 호출되며, 여기서 &lt;code&gt;q = min(m, n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04c444cb5aa197d63b68cfea78d90d29188a9456" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is of length N, this function returns the value:</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 길이 N이며,이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="fe3f05df5768add8f656a94f10e13fc6943b0c1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;p&lt;/code&gt; is the returned series, then &lt;code&gt;p(x) == x&lt;/code&gt; for all values of x.</source>
          <target state="translated">경우 &lt;code&gt;p&lt;/code&gt; 는 리턴 시리즈는 다음 &lt;code&gt;p(x) == x&lt;/code&gt; X의 모든 값에 대해.</target>
        </trans-unit>
        <trans-unit id="f5468a2ba10e85782ab3beca18220db469f1d944" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, it will be downloaded, stored in the &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt;&lt;code&gt;DataSource&lt;/code&gt;&lt;/a&gt; directory and opened from there.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; URL이, 그것은, 다운로드에 저장 될 &lt;a href=&quot;numpy.datasource#numpy.DataSource&quot;&gt; &lt;code&gt;DataSource&lt;/code&gt; &lt;/a&gt; 디렉토리와 거기에서 열었다.</target>
        </trans-unit>
        <trans-unit id="24260df7d2aad1e014a4c9af35e7ef7678f51548" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;path&lt;/code&gt; is an URL, then &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt;&lt;code&gt;abspath&lt;/code&gt;&lt;/a&gt; will return either the location the file exists locally or the location it would exist when opened using the &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt;&lt;code&gt;open&lt;/code&gt;&lt;/a&gt; method.</source>
          <target state="translated">경우 &lt;code&gt;path&lt;/code&gt; URL이며, 다음 &lt;a href=&quot;#numpy.DataSource.abspath&quot;&gt; &lt;code&gt;abspath&lt;/code&gt; &lt;/a&gt; 돌아갑니다 어느 위치에 파일을 로컬에 존재하거나 사용하여 열 때 위치가 존재 것이다 &lt;a href=&quot;numpy.datasource.open#numpy.DataSource.open&quot;&gt; &lt;code&gt;open&lt;/code&gt; &lt;/a&gt; 방법을.</target>
        </trans-unit>
        <trans-unit id="9e52fcae8c89336b9d76db6bc95e2d2ecd5abb9e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 퍼센트이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 백분위 수가 여러 개인 경우 결과의 첫 번째 축은 백분위 수에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4219d6c9d1025bc747faeaba10649824d1b4aa46" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single percentile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 퍼센트이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 다중 Quantile이 제공되면 결과의 첫 번째 축이 Quantile에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="adb7c2f1dd4ba6f271e782ab821bd6ce35c48378" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;q&lt;/code&gt; is a single quantile and &lt;code&gt;axis=None&lt;/code&gt;, then the result is a scalar. If multiple quantiles are given, first axis of the result corresponds to the quantiles. The other axes are the axes that remain after the reduction of &lt;code&gt;a&lt;/code&gt;. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, the output data-type is &lt;code&gt;float64&lt;/code&gt;. Otherwise, the output data-type is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">경우 &lt;code&gt;q&lt;/code&gt; 단일 분위수이고 &lt;code&gt;axis=None&lt;/code&gt; , 결과는 스칼라 없다. 다중 Quantile이 제공되면 결과의 첫 번째 축이 Quantile에 해당합니다. 다른 축은의 감소 후 유지 축입니다 . 입력 값에 &lt;code&gt;float64&lt;/code&gt; 보다 작은 정수 또는 float가 포함 된 경우 출력 데이터 유형은 &lt;code&gt;float64&lt;/code&gt; 입니다. 그렇지 않으면 출력 데이터 유형이 입력 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9da6831f27b77e8b6677e8aad5c341d985befa99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is a 1-D array, then &lt;code&gt;p(x)&lt;/code&gt; will have the same shape as &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; is multidimensional, then the shape of the result depends on the value of &lt;code&gt;tensor&lt;/code&gt;. If &lt;code&gt;tensor is ``True`&lt;/code&gt; the shape will be r.shape[1:] + x.shape; that is, each polynomial is evaluated at every value of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;tensor&lt;/code&gt; is &lt;code&gt;False&lt;/code&gt;, the shape will be r.shape[1:]; that is, each polynomial is evaluated only for the corresponding broadcast value of &lt;code&gt;x&lt;/code&gt;. Note that scalars have shape (,).</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 은 1-D 배열은 다음 &lt;code&gt;p(x)&lt;/code&gt; 와 같은 것 같은 형상 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;r&lt;/code&gt; 다차원, 결과의 형상의 값에 따라 &lt;code&gt;tensor&lt;/code&gt; . 경우 &lt;code&gt;tensor is ``True`&lt;/code&gt; 형상 r.shape [1] + x.shape 것; 즉, 각 다항식은 모든 &lt;code&gt;x&lt;/code&gt; 값에서 평가됩니다 . 경우 &lt;code&gt;tensor&lt;/code&gt; 인 &lt;code&gt;False&lt;/code&gt; , 형상 r.shape [1]가 될 것이다; 즉, 각 다항식은 해당 브로드 캐스트 값 &lt;code&gt;x&lt;/code&gt; 에 대해서만 평가됩니다 . 스칼라의 모양은 (,)입니다.</target>
        </trans-unit>
        <trans-unit id="16d6bbf3ace149a532102c10ab8ede2738b896bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;r&lt;/code&gt; is of length &lt;code&gt;N&lt;/code&gt;, this function returns the value</source>
          <target state="translated">경우 &lt;code&gt;r&lt;/code&gt; 길이 인 &lt;code&gt;N&lt;/code&gt; ,이 함수의 값을 반환</target>
        </trans-unit>
        <trans-unit id="6bc06c8f2ea0c3500f46f216948ca646bd403c39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rep&lt;/code&gt; is an instance of a scalar dtype, True is returned. If not, False is returned.</source>
          <target state="translated">경우 &lt;code&gt;rep&lt;/code&gt; 스칼라 DTYPE의 인스턴스, 사실이 반환됩니다. 그렇지 않으면 False가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="caf6ef0eb6bbcb3c4e7a4a5b04998bc1341e6eb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;reps&lt;/code&gt; has length &lt;code&gt;d&lt;/code&gt;, the result will have dimension of &lt;code&gt;max(d, A.ndim)&lt;/code&gt;.</source>
          <target state="translated">경우에는 &lt;code&gt;reps&lt;/code&gt; 길이 갖는 &lt;code&gt;d&lt;/code&gt; , 결과의 치수 것이다 &lt;code&gt;max(d, A.ndim)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d930e73a09a54bb69273b247bbe9349e70a0c0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;rowvar&lt;/code&gt; is True (default), then each row represents a variable, with observations in the columns. Otherwise, the relationship is transposed: each column represents a variable, while the rows contain observations.</source>
          <target state="translated">경우 &lt;code&gt;rowvar&lt;/code&gt; 이 참 (기본값), 각 행은 열에서 관측 변수를 나타냅니다. 그렇지 않으면 관계가 바뀝니다. 각 열은 변수를 나타내며 행에는 관측치가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="0e485a675b3c010a2a7eedd59e29811b56d30eeb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length, or &lt;code&gt;axes&lt;/code&gt; not given and &lt;code&gt;len(s) != 2&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;axes&lt;/code&gt; 서로 다른 길이, 또는이 &lt;code&gt;axes&lt;/code&gt; 하지 주어 &lt;code&gt;len(s) != 2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1a95f9d4c94712a6711035b0d38ca6007922134" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;s&lt;/code&gt; and &lt;code&gt;axes&lt;/code&gt; have different length.</source>
          <target state="translated">&lt;code&gt;s&lt;/code&gt; 와 &lt;code&gt;axes&lt;/code&gt; 길이가 다른 경우</target>
        </trans-unit>
        <trans-unit id="7c3cc7c092c11cc91fc3de1425949e6b1c9585a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sctype&lt;/code&gt; is an object for which the type can not be inferred.</source>
          <target state="translated">&lt;code&gt;sctype&lt;/code&gt; 이 유형을 유추 할 수없는 객체 인 경우</target>
        </trans-unit>
        <trans-unit id="9a8f382549c758d89f2c430b015281fc763e47f9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;seed&lt;/code&gt; is not a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, a new &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; is instantiated. This function does not manage a default global instance.</source>
          <target state="translated">&lt;code&gt;seed&lt;/code&gt; 가 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 가 아닌 경우 새 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 가 인스턴스화됩니다. 이 함수는 기본 전역 인스턴스를 관리하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0aeaeba3f41f378516fdce780d9277e8a4ccfffb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self.shape[k] == 1&lt;/code&gt; then for any legal index &lt;code&gt;index[k] == 0&lt;/code&gt;. This means that in the formula for the offset</source>
          <target state="translated">만약 &lt;code&gt;self.shape[k] == 1&lt;/code&gt; 다음 법적 인덱스에 대한 &lt;code&gt;index[k] == 0&lt;/code&gt; . 이것은 오프셋 공식에서</target>
        </trans-unit>
        <trans-unit id="5df5fe3df9ec97e65980a43dfd1884e4e357c660" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수가 아닌 경우 &lt;code&gt;ret&lt;/code&gt; 은 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size))&lt;/code&gt; 모두 &lt;code&gt;True&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="8e5eb20061bb0d5a1e031a6a1b5daa75d4a16cad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is non-singular, &lt;code&gt;ret&lt;/code&gt; is such that &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; all return &lt;code&gt;True&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수가 아닌 경우 &lt;code&gt;ret&lt;/code&gt; 은 &lt;code&gt;ret * self&lt;/code&gt; == &lt;code&gt;self * ret&lt;/code&gt; == &lt;code&gt;np.matrix(np.eye(self[0,:].size)&lt;/code&gt; 모두 &lt;code&gt;True&lt;/code&gt; 를 반환하도록하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="b27bb431dc045601d86e73a474de86c64d035384" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;self&lt;/code&gt; is singular.</source>
          <target state="translated">&lt;code&gt;self&lt;/code&gt; 가 단수 인 경우 .</target>
        </trans-unit>
        <trans-unit id="a097af1908df1ac936bba64c59e9507a0eb901d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or &lt;code&gt;None&lt;/code&gt;, any whitespace string is a separator.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 지정되거나되지 않은 &lt;code&gt;None&lt;/code&gt; , 공백 문자열 세퍼레이터이다.</target>
        </trans-unit>
        <trans-unit id="6b286f3e58c7b02612a4551d6a9dcb5406b09f75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sep&lt;/code&gt; is not specified or None, any whitespace string is a separator.</source>
          <target state="translated">경우 &lt;code&gt;sep&lt;/code&gt; 지정되지 않거나 것도 아니고, 공백 문자열 세퍼레이터이다.</target>
        </trans-unit>
        <trans-unit id="768a6e9085deaf336653d5c9857ddf9b254027d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;shape&lt;/code&gt; has length one i.e. &lt;code&gt;(N,)&lt;/code&gt;, or is a scalar &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;out&lt;/code&gt; becomes a single row matrix of shape &lt;code&gt;(1,N)&lt;/code&gt;.</source>
          <target state="translated">경우에 &lt;code&gt;shape&lt;/code&gt; 길이를 갖는 하나의 예 &lt;code&gt;(N,)&lt;/code&gt; , 또는 스칼라 &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;out&lt;/code&gt; 형상의 단일 행 행렬이된다 &lt;code&gt;(1,N)&lt;/code&gt; 를 .</target>
        </trans-unit>
        <trans-unit id="afe85dc9a909b4503b3e7da810ec90771fac4a7a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sources&lt;/code&gt; does not contain a signature files, then F2PY is used to scan Fortran source files for routine signatures to construct the wrappers to Fortran codes.</source>
          <target state="translated">경우 &lt;code&gt;sources&lt;/code&gt; 서명 파일을 포함하지 않는 루틴 서명 포트란 코드에 래퍼를 구성하기 위해, 다음 F2PY 스캔 포트란 소스 파일에 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="5d3a0815985e487dc8833e6a9544cd8f4d19132e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;tol&lt;/code&gt; &amp;lt; 0</source>
          <target state="translated">&lt;code&gt;tol&lt;/code&gt; &amp;lt;0 인 경우</target>
        </trans-unit>
        <trans-unit id="525464d43ab5c9d447229756137cbe7b0c9e5673" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;upstream&lt;/code&gt; isn&amp;rsquo;t there, it will be added after you access the NumPy repo with a command like &lt;code&gt;git fetch&lt;/code&gt; or &lt;code&gt;git pull&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;upstream&lt;/code&gt; 가없는 당신이 명령을 사용하여 NumPy와의 REPO에 액세스 한 후처럼, 그것은 추가됩니다 &lt;code&gt;git fetch&lt;/code&gt; 또는 &lt;code&gt;git pull&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cf15e83c2fdf72b1f29bfc75044966bd6bc1399" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is a 2-D array, return a copy of its &lt;code&gt;k&lt;/code&gt;-th diagonal. If &lt;code&gt;v&lt;/code&gt; is a 1-D array, return a 2-D array with &lt;code&gt;v&lt;/code&gt; on the &lt;code&gt;k&lt;/code&gt;-th diagonal.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 2-D 어레이, 그 사본 반환 &lt;code&gt;k&lt;/code&gt; 번째 대각선. 경우 &lt;code&gt;v&lt;/code&gt; 1-D 어레이는 함께 2-D 배열을 반환 &lt;code&gt;v&lt;/code&gt; 상의 &lt;code&gt;k&lt;/code&gt; 번째 대각.</target>
        </trans-unit>
        <trans-unit id="8349a8e04c4275fccf8d4c40bdfe6166a838f29e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;v&lt;/code&gt; is longer than &lt;code&gt;a&lt;/code&gt;, the arrays are swapped before computation.</source>
          <target state="translated">경우 &lt;code&gt;v&lt;/code&gt; 보다 긴 , 배열은 계산하기 전에 교체된다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bfdbe84100978bde6f35b9bd48d4f5ad4bf72c8d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is not the same size as &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;mask&lt;/code&gt; then it will repeat. This gives behavior different from &lt;code&gt;a[mask] = values&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 같은 크기되지 및 &lt;code&gt;mask&lt;/code&gt; 그것은 반복됩니다. 이것은 &lt;code&gt;a[mask] = values&lt;/code&gt; 와 다른 동작을 제공 합니다 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="54792a3abbf75ac3395cbad014c19ac2ff1595e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;values&lt;/code&gt; is smaller than &lt;code&gt;a&lt;/code&gt; it is repeated:</source>
          <target state="translated">경우 &lt;code&gt;values&lt;/code&gt; 보다 작은 이 반복된다 : &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d3b50be1f74d03f550d5fd9dbbf8a888d565797b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x2&lt;/code&gt; is a scalar, its sign will be copied to all elements of &lt;code&gt;x1&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x2&lt;/code&gt; 스칼라, 그 기호의 모든 요소에 복사됩니다 &lt;code&gt;x1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e770d7b527b709ad5e13ef5b77aecccd75244de" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; contains negative inputs, the answer is computed and returned in the complex domain.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 음수 입력이 포함되어 있으면 답이 계산되어 복소수 영역에 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="60fec046bd42368c53fb89df3120786c8d0bd4a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; contains negative values, the output is converted to the complex domain.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 에 음수 값이 포함되어 있으면 출력이 복합 도메인으로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="b5f780e2f5cb497ee27a4b50260d939ccb5e1976" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 목록 또는 튜플은, 그것은 그렇지 않으면 변경되지 스칼라로 취급 ndarray로 변환된다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;c&lt;/code&gt; 의 요소를 더한 곱셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e9289f94a42ce2a055130aa0322c6aa21e4c7a12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a list or tuple, it is converted to an ndarray, otherwise it is left unchanged and treated as a scalar. In either case, &lt;code&gt;x&lt;/code&gt; or its elements must support addition and multiplication with with themselves and with the elements of &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 목록 또는 튜플은, 그것은 그렇지 않으면 변경되지 스칼라로 취급 ndarray로 변환된다. 두 경우 모두 &lt;code&gt;x&lt;/code&gt; 또는 해당 요소는 자신과 &lt;code&gt;r&lt;/code&gt; 요소를 더한 곱셈을 지원해야합니다 .</target>
        </trans-unit>
        <trans-unit id="0f3c93ccc6b110d8957f1eff605f32da46911a50" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a multi-dimensional array, it is only shuffled along its first index.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 다차원 어레이이며, 이는 단지 첫 번째 인덱스에 따라 셔플 링된다.</target>
        </trans-unit>
        <trans-unit id="10902731cd32fb924a9fa6246d242dab230b11a1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a poly1d instance, the result is the composition of the two polynomials, i.e., &lt;code&gt;x&lt;/code&gt; is &amp;ldquo;substituted&amp;rdquo; in &lt;code&gt;p&lt;/code&gt; and the simplified result is returned. In addition, the type of &lt;code&gt;x&lt;/code&gt; - array_like or poly1d - governs the type of the output: &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; a poly1d object =&amp;gt; &lt;code&gt;values&lt;/code&gt; is also.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; poly1d 인스턴스이며, 그 결과는 두 다항식의 조성, 즉,이고 &lt;code&gt;x&lt;/code&gt; 에 &quot;치환&quot;되는 &lt;code&gt;p&lt;/code&gt; 및 단순화 된 결과가 복귀된다. 또한 &lt;code&gt;x&lt;/code&gt; -array_like 또는 poly1d 유형은 출력 유형을 제어합니다. &lt;code&gt;x&lt;/code&gt; array_like =&amp;gt; &lt;code&gt;values&lt;/code&gt; array_like, &lt;code&gt;x&lt;/code&gt; poly1d 객체 =&amp;gt; &lt;code&gt;values&lt;/code&gt; 도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d6a5280b73875b8ad0b036e2ed1535be94a86966" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a sequence, then &lt;code&gt;p(x)&lt;/code&gt; is returned for each element of &lt;code&gt;x&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is another polynomial then the composite polynomial &lt;code&gt;p(x(t))&lt;/code&gt; is returned.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 연속하고있다 &lt;code&gt;p(x)&lt;/code&gt; 의 각 요소에 대해 리턴되는 &lt;code&gt;x&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 다음 다른 다항식 복합 다항식 &lt;code&gt;p(x(t))&lt;/code&gt; 복귀된다.</target>
        </trans-unit>
        <trans-unit id="e418b1b9672c946b1ca5e8afc3125fd05c313b38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is a subtype of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; the return value will be of the same type.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 의 하위 유형입니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 반환 값은 같은 유형이 될 것입니다.</target>
        </trans-unit>
        <trans-unit id="2f55968163fb644f21e767c8ca56c7265582f682" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is an integer, randomly permute &lt;code&gt;np.arange(x)&lt;/code&gt;. If &lt;code&gt;x&lt;/code&gt; is an array, make a copy and shuffle the elements randomly.</source>
          <target state="translated">경우에 &lt;code&gt;x&lt;/code&gt; 는 정수이고, 임의로 변경하다 &lt;code&gt;np.arange(x)&lt;/code&gt; . 경우 &lt;code&gt;x&lt;/code&gt; 가 배열 인, 복사본을 만들고 무작위 요소를 섞는다.</target>
        </trans-unit>
        <trans-unit id="8675c9efb1c5ad5afa002d06cb6dcceef7c6f2a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is inexact, NaN is replaced by zero or by the user defined value in &lt;a href=&quot;../constants#numpy.nan&quot;&gt;&lt;code&gt;nan&lt;/code&gt;&lt;/a&gt; keyword, infinity is replaced by the largest finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;posinf&lt;/code&gt; keyword and -infinity is replaced by the most negative finite floating point values representable by &lt;code&gt;x.dtype&lt;/code&gt; or by the user defined value in &lt;code&gt;neginf&lt;/code&gt; keyword.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 부정확 NaN이 제로에 의해 또는 사용자 정의 된 값으로 대체 &lt;a href=&quot;../constants#numpy.nan&quot;&gt; &lt;code&gt;nan&lt;/code&gt; &lt;/a&gt; 키워드 무한대 부동 소수점 값으로 표현 가능한 최대 유한으로 대체 &lt;code&gt;x.dtype&lt;/code&gt; 또는 사용자 정의 값 &lt;code&gt;posinf&lt;/code&gt; 키워드 무한대가로 대체 &lt;code&gt;x.dtype&lt;/code&gt; 또는 &lt;code&gt;neginf&lt;/code&gt; 키워드 의 사용자 정의 값으로 표시 할 수있는 가장 음의 유한 부동 소수점 값</target>
        </trans-unit>
        <trans-unit id="a12bcfaac2b6a0d5eb775110eb5d113a7ffcf89b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is not inexact, then no replacements are made.</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 가 정확하지 않습니다, 다음에는 교체가 이루어지지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dab92b609c96bcdc43f19efa69fe1680ecbcb0cf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;x&lt;/code&gt; is of a signed integer type, then the output type is the default platform integer:</source>
          <target state="translated">경우 &lt;code&gt;x&lt;/code&gt; 는 부호있는 정수 타입이다, 출력 유형은 기본 플랫폼의 정수입니다 :</target>
        </trans-unit>
        <trans-unit id="9b8211170506c6269c7986617b768331c6cb9374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;xp&lt;/code&gt; and &lt;code&gt;fp&lt;/code&gt; have different length If &lt;code&gt;xp&lt;/code&gt; or &lt;code&gt;fp&lt;/code&gt; are not 1-D sequences If &lt;code&gt;period == 0&lt;/code&gt;</source>
          <target state="translated">경우 &lt;code&gt;xp&lt;/code&gt; 및 &lt;code&gt;fp&lt;/code&gt; 상이한 길이를 갖는 경우 &lt;code&gt;xp&lt;/code&gt; 또는 &lt;code&gt;fp&lt;/code&gt; 1-D의 순서가 아닌 경우 &lt;code&gt;period == 0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2455250a9da7702638a12b7e54e59f4d21fc53" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;arr&lt;/em&gt; is an array, returns its data type descriptor, but if &lt;em&gt;arr&lt;/em&gt; is an array scalar (has 0 dimensions), it finds the data type of smallest size to which the value may be converted without overflow or truncation to an integer.</source>
          <target state="translated">경우 &lt;em&gt;도착을&lt;/em&gt; 배열하고, 그 데이터 형식 디스크립터를 반환하지만 경우 &lt;em&gt;도착은&lt;/em&gt; (0 차원을 갖는다) 배열 스칼라이고,이 값은 정수 오버플로 또는 절단없이 전환 될 수도있는 가장 작은 크기의 데이터 유형을 발견한다.</target>
        </trans-unit>
        <trans-unit id="a70ed9437e4a5163189d25b472581eabce8d5ceb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is &lt;em&gt;None&lt;/em&gt; (the default), the array is treated as a 1-D array and the operation is performed over the entire array. This behavior is also the default if self is a 0-dimensional array or array scalar. (An array scalar is an instance of the types/classes float32, float64, etc., whereas a 0-dimensional array is an ndarray instance containing precisely one array scalar.)</source>
          <target state="translated">경우 &lt;em&gt;축이&lt;/em&gt; 없는 &lt;em&gt;없음&lt;/em&gt; (디폴트), 어레이는 1-D 어레이로 처리하고, 동작은 전체 어레이에 걸쳐 수행된다. self가 0 차원 배열 또는 배열 스칼라 인 경우에도이 동작이 기본값입니다. 배열 스칼라는 float32, float64 등의 유형 / 클래스 인스턴스이며 0 차원 배열은 정확히 하나의 배열 스칼라를 포함하는 ndarray 인스턴스입니다.</target>
        </trans-unit>
        <trans-unit id="9235232429102d093beb5f545c26b8fef229f79b" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;axis&lt;/em&gt; is an integer, then the operation is done over the given axis (for each 1-D subarray that can be created along the given axis).</source>
          <target state="translated">경우 &lt;em&gt;축&lt;/em&gt; 정수이고, 그 동작은 (소정의 축선을 따라 생성 될 수있는 각각의 1-D 서브 어레이에 대한) 주어진 축상에서 이루어진다.</target>
        </trans-unit>
        <trans-unit id="1b1a4ec186584bdfde20daf47a6283f1daa2a542" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then new unitinialized memory will be allocated and &lt;em&gt;flags&lt;/em&gt; can be non-zero to indicate a Fortran-style contiguous array. Use &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt;&lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt;&lt;/a&gt; to initialize the memory.</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 의 경우 , 새로운 단위 화 메모리가 할당되어 , 포트란 스타일의 연속적인 배열을 나타내는 &lt;em&gt;플래그&lt;/em&gt; 가 제로 이외의 값이 될 수 있습니다. &lt;a href=&quot;#c.PyArray_FILLWBYTE&quot;&gt; &lt;code&gt;PyArray_FILLWBYTE&lt;/code&gt; &lt;/a&gt; 를 사용 하여 메모리를 초기화하십시오.</target>
        </trans-unit>
        <trans-unit id="b7bd71ee3411fe6c23b731a500527ae1ac46e705" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt;&lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">경우 &lt;em&gt;데이터가&lt;/em&gt; 아닌 &lt;code&gt;NULL&lt;/code&gt; , 그것은 메모리에 지점으로 가정 어레이에 사용되는 상기 &lt;em&gt;플래그&lt;/em&gt; 인자의 상태를 제외하고는 (배열의 새로운 플래그로서 사용된다 &lt;a href=&quot;#c.NPY_ARRAY_OWNDATA&quot;&gt; &lt;code&gt;NPY_ARRAY_OWNDATA&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 새로운 배열 의지 플래그 재설정).</target>
        </trans-unit>
        <trans-unit id="6b3854bd1e23682951d79d6393e1c1b2b19835be" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;data&lt;/em&gt; is not &lt;code&gt;NULL&lt;/code&gt;, then it is assumed to point to the memory to be used for the array and the &lt;em&gt;flags&lt;/em&gt; argument is used as the new flags for the array (except the state of &lt;code&gt;NPY_OWNDATA&lt;/code&gt;, &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; flags of the new array will be reset).</source>
          <target state="translated">&lt;em&gt;data&lt;/em&gt; 가 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 , 배열에 사용될 메모리를 가리키는 것으로 가정하고 &lt;em&gt;flags&lt;/em&gt; 인수는 배열의 새 플래그로 사용됩니다 ( &lt;code&gt;NPY_OWNDATA&lt;/code&gt; 상태 , &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 및 새 배열의 &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그 제외) 재설정).</target>
        </trans-unit>
        <trans-unit id="9cebbbbcc1739892f8b12e053651c131570cd283" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;descr&lt;/em&gt; is NULL, the data type of &lt;em&gt;prototype&lt;/em&gt; is used.</source>
          <target state="translated">경우 &lt;em&gt;DESCR이&lt;/em&gt; NULL 인의 데이터 타입 &lt;em&gt;프로토 타입을&lt;/em&gt; 사용한다.</target>
        </trans-unit>
        <trans-unit id="aec9506a456027cf0203832745240a439d9ff187" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;dtype&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the returned array will have the same data type as &lt;em&gt;self&lt;/em&gt;. The new data-type must be consistent with the size of &lt;em&gt;self&lt;/em&gt;. Either the itemsizes must be identical, or &lt;em&gt;self&lt;/em&gt; must be single-segment and the total number of bytes must be the same. In the latter case the dimensions of the returned array will be altered in the last (or first for Fortran-style contiguous arrays) dimension. The data area of the returned array and self is exactly the same.</source>
          <target state="translated">경우 &lt;em&gt;DTYPE이&lt;/em&gt; 있다 &lt;code&gt;NULL&lt;/code&gt; 을 , 다음 반환되는 배열은 같은 데이터 유형 것 &lt;em&gt;자체&lt;/em&gt; . 새로운 데이터 유형은 &lt;em&gt;self&lt;/em&gt; 의 크기와 일치해야합니다 . 항목 크기는 동일하거나 &lt;em&gt;self&lt;/em&gt; 는 단일 세그먼트 여야하고 총 바이트 수는 같아야합니다. 후자의 경우 반환 된 배열의 차원은 마지막 (또는 첫 번째 포트란 스타일의 연속 배열) 차원에서 변경됩니다. 반환 된 배열과 self의 데이터 영역은 정확히 같습니다.</target>
        </trans-unit>
        <trans-unit id="b00215400909f507a463937ff52555cace4d8945" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;op&lt;/em&gt; is already an array, but does not satisfy the requirements, then a copy is made (which will satisfy the requirements). If this flag is present and a copy (of an object that is already an array) must be made, then the corresponding &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag is set in the returned copy and &lt;em&gt;op&lt;/em&gt; is made to be read-only. You must be sure to call &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; to copy the contents back into &lt;em&gt;op&lt;/em&gt; and the &lt;em&gt;op&lt;/em&gt; array will be made writeable again. If &lt;em&gt;op&lt;/em&gt; is not writeable to begin with, or if it is not already an array, then an error is raised.</source>
          <target state="translated">경우 &lt;em&gt;연산이&lt;/em&gt; 이미 배열이지만, 조건을 만족하지 않고, 다음 복사 (요건을 만족하는 것)한다. 이 플래그가 존재하고 (이미 배열 인 오브젝트의) 사본이 작성되어야하는 경우, 대응하는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 리턴 된 사본에 설정되고 &lt;em&gt;op&lt;/em&gt; 는 읽기 전용이됩니다. 당신은 호출해야합니다 &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; 을&lt;/a&gt; 내용으로 다시 복사 &lt;em&gt;연산&lt;/em&gt; 과 &lt;em&gt;연산&lt;/em&gt; 배열을 다시 쓰기 될 것이다. 경우 &lt;em&gt;영업 이익은&lt;/em&gt; 시작하는 쓰기가 아니거나 이미 배열이 아닌 경우, 다음 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2b3d523872c6239b2b47533fe932fb9b935c7ec9" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;permute&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, the shape of the result is</source>
          <target state="translated">경우 &lt;em&gt;변경하다는&lt;/em&gt; 것입니다 &lt;code&gt;NULL&lt;/code&gt; 이 결과의 모양입니다</target>
        </trans-unit>
        <trans-unit id="864a2871c8455778be67517dc3e9f63ae59a60fb" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subok&lt;/em&gt; is 1, the newly created array will use the sub-type of &lt;em&gt;prototype&lt;/em&gt; to create the new array, otherwise it will create a base-class array.</source>
          <target state="translated">경우 &lt;em&gt;subok가&lt;/em&gt; 1이고, 새로 생성 된 배열의 하위 유형 사용하는 &lt;em&gt;프로토 타입&lt;/em&gt; 그렇지 않으면 기본 수준의 배열을 만들 때, 새로운 배열을 만들 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d7c8774de40710ea170a99b3d842fc0b2a6f66b4" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">경우 &lt;em&gt;아류&lt;/em&gt; 어레이 서브 대신 염기이다 &lt;a href=&quot;c-api.types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; 후 &lt;em&gt;OBJ&lt;/em&gt; 받는 전달할 목적 &lt;a href=&quot;arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; 의&lt;/a&gt; 서브 클래스의 방법.</target>
        </trans-unit>
        <trans-unit id="3703a88bcd847e1448a723a502192b0e8fa8fa65" translate="yes" xml:space="preserve">
          <source>If &lt;em&gt;subtype&lt;/em&gt; is of an array subclass instead of the base &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt;&lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt;&lt;/a&gt;, then &lt;em&gt;obj&lt;/em&gt; is the object to pass to the &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; method of the subclass.</source>
          <target state="translated">경우 &lt;em&gt;아류&lt;/em&gt; 어레이 서브 대신 염기이다 &lt;a href=&quot;types-and-structures#c.PyArray_Type&quot;&gt; &lt;code&gt;&amp;amp;PyArray_Type&lt;/code&gt; &lt;/a&gt; 후 &lt;em&gt;OBJ&lt;/em&gt; 받는 전달할 목적 &lt;a href=&quot;../arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; 의&lt;/a&gt; 서브 클래스의 방법.</target>
        </trans-unit>
        <trans-unit id="c808aeb714f46484081440736a2f659eda1cb00f" translate="yes" xml:space="preserve">
          <source>If A = qr such that q is orthonormal (which is always possible via Gram-Schmidt), then &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt;. (In numpy practice, however, we simply use &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt;&lt;code&gt;lstsq&lt;/code&gt;&lt;/a&gt;.)</source>
          <target state="translated">q가 정규 직교가되도록 A = qr 인 경우 (Gram-Schmidt를 통해 항상 가능) &lt;code&gt;x = inv(r) * (q.T) * b&lt;/code&gt; 입니다. 그러나 numpy 연습에서는 &lt;a href=&quot;numpy.linalg.lstsq#numpy.linalg.lstsq&quot;&gt; &lt;code&gt;lstsq&lt;/code&gt; 만&lt;/a&gt; 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="a5523a2784c429b6ba47e45d47c8a0bb942c669e" translate="yes" xml:space="preserve">
          <source>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that &lt;code&gt;sparse=False, copy=False&lt;/code&gt; will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</source>
          <target state="translated">False이면 메모리를 보존하기 위해 원래 배열에 대한보기가 반환됩니다. 기본값은 True입니다. 제발 참고 &lt;code&gt;sparse=False, copy=False&lt;/code&gt; 가능성이 비 연속 배열을 반환합니다. 또한, 방송 어레이의 하나 이상의 요소는 단일 메모리 위치를 지칭 할 수있다. 배열에 쓰려면 먼저 복사하십시오.</target>
        </trans-unit>
        <trans-unit id="343caea52a4d2f3f220c6f641bc3ef525fc8ff10" translate="yes" xml:space="preserve">
          <source>If False, reference count will not be checked. Default is True.</source>
          <target state="translated">False이면 참조 횟수를 확인하지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="cc82a0ba7e27b536a6fe2ae6adeaa5a186566e3c" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt;.</source>
          <target state="translated">기본값 인 False이면 각 빈의 샘플 수를 반환합니다. True이면 &lt;code&gt;bin_count / sample_count / bin_area&lt;/code&gt; 에서 확률 &lt;em&gt;밀도&lt;/em&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="023ffe5319599a1faa2198b591752fc4467344db" translate="yes" xml:space="preserve">
          <source>If False, the default, returns the number of samples in each bin. If True, returns the probability &lt;em&gt;density&lt;/em&gt; function at the bin, &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt;.</source>
          <target state="translated">기본값 인 False이면 각 빈의 샘플 수를 반환합니다. True이면 &lt;code&gt;bin_count / sample_count / bin_volume&lt;/code&gt; 에서 확률 &lt;em&gt;밀도&lt;/em&gt; 함수를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="fff9762cd2d96487b93950bfb4f1067d252f526d" translate="yes" xml:space="preserve">
          <source>If GitHub indicates that the branch of your Pull Request can no longer be merged automatically, you have to incorporate changes that have been made since you started into your branch. Our recommended way to do this is to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="translated">GitHub에서 Pull Request의 브랜치를 더 이상 자동으로 병합 할 수 없다고 표시하는 경우 브랜치에 시작한 이후 변경된 사항을 통합해야합니다. 이를 수행하는 권장 방법은 &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;master&lt;/a&gt; 를 리베이스하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="a65d3c4015ca8415c134fa3b89bccc8e92003c36" translate="yes" xml:space="preserve">
          <source>If K = min(M, N), then</source>
          <target state="translated">K = min (M, N)이면</target>
        </trans-unit>
        <trans-unit id="c8fe35dc8be08c32dcc7a321c29a26e840a0b0cb" translate="yes" xml:space="preserve">
          <source>If None, the index is into the flattened array, otherwise along the specified axis</source>
          <target state="translated">None 인 경우 인덱스는 전개 된 배열에 있고, 그렇지 않으면 지정된 축을 따라</target>
        </trans-unit>
        <trans-unit id="b2ed776381411dcc06237a74c5e85611ae70c52e" translate="yes" xml:space="preserve">
          <source>If None, then the path is assumed to be the local path plus the subpackage_name. If a setup.py file is not found in the subpackage_path, then a default configuration is used.</source>
          <target state="translated">None 인 경우 경로는 로컬 경로에 subpackage_name을 더한 것으로 가정합니다. subpackage_path에 setup.py 파일이 없으면 기본 구성이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="7ed2128e955055b733a7b269ab15855f518690e5" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, converted to boolean types.</source>
          <target state="translated">None이면 MaskType 인스턴스를 사용합니다. 그렇지 않으면 부울 유형으로 변환 된 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 과 동일한 필드가있는 새 데이터 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f68badbcb18a0e633a2cc1aee70bc74cc566792" translate="yes" xml:space="preserve">
          <source>If None, use a MaskType instance. Otherwise, use a new datatype with the same fields as &lt;code&gt;dtype&lt;/code&gt;, converted to boolean types.</source>
          <target state="translated">None 인 경우 MaskType 인스턴스를 사용하십시오. 그렇지 않으면 부울 유형으로 변환 된 &lt;code&gt;dtype&lt;/code&gt; 과 동일한 필드를 가진 새 데이터 유형을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="858f084d421de6a09702f1940e95232bb37adf96" translate="yes" xml:space="preserve">
          <source>If Python &lt;code&gt;None&lt;/code&gt; object is used as a required argument, the argument is treated as optional. That is, in the case of array argument, the memory is allocated. And if &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; is given, the corresponding initialization is carried out.</source>
          <target state="translated">Python &lt;code&gt;None&lt;/code&gt; 객체가 필수 인수로 사용되는 경우 인수는 선택 사항으로 처리됩니다. 즉, 배열 인수의 경우 메모리가 할당됩니다. 그리고 &lt;code&gt;&amp;lt;init_expr&amp;gt;&lt;/code&gt; 이 주어지면 해당 초기화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b88b29f182ab4a1e89998e5d778c700419477eb5" translate="yes" xml:space="preserve">
          <source>If SVD computation does not converge.</source>
          <target state="translated">SVD 계산이 수렴되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1c8e91eba4c31b07d056c5e107cd3dbd66e73c1f" translate="yes" xml:space="preserve">
          <source>If True (default) make a copy of &lt;code&gt;a&lt;/code&gt; in the result. If False modify &lt;code&gt;a&lt;/code&gt; in place and return a view.</source>
          <target state="translated">진정한 (기본값)의 사본 한 경우 &lt;code&gt;a&lt;/code&gt; 결과에. 거짓하다면 수정 &lt;code&gt;a&lt;/code&gt; 장소와 뷰를 돌려줍니다.</target>
        </trans-unit>
        <trans-unit id="5f05298246a514cfbe30605192f5c3eec0c39e89" translate="yes" xml:space="preserve">
          <source>If True (default), &lt;code&gt;u&lt;/code&gt; and &lt;code&gt;vh&lt;/code&gt; have the shapes &lt;code&gt;(..., M, M)&lt;/code&gt; and &lt;code&gt;(..., N, N)&lt;/code&gt;, respectively. Otherwise, the shapes are &lt;code&gt;(..., M, K)&lt;/code&gt; and &lt;code&gt;(..., K, N)&lt;/code&gt;, respectively, where &lt;code&gt;K = min(M, N)&lt;/code&gt;.</source>
          <target state="translated">True (기본값) 인 경우 &lt;code&gt;u&lt;/code&gt; 및 &lt;code&gt;vh&lt;/code&gt; 의 모양은 각각 &lt;code&gt;(..., M, M)&lt;/code&gt; 및 &lt;code&gt;(..., N, N)&lt;/code&gt; 입니다. 그렇지 않으면 모양은 각각 &lt;code&gt;(..., M, K)&lt;/code&gt; 및 &lt;code&gt;(..., K, N)&lt;/code&gt; 이며 여기서 &lt;code&gt;K = min(M, N)&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b7193bd03fb8a4044e82de41b9072ea59ef18024" translate="yes" xml:space="preserve">
          <source>If True (default), the function for pretty printing (&lt;code&gt;__repr__&lt;/code&gt;) is set, if False the function that returns the default string representation (&lt;code&gt;__str__&lt;/code&gt;) is set.</source>
          <target state="translated">True (기본값)이면 예쁜 인쇄 기능 ( &lt;code&gt;__repr__&lt;/code&gt; )이 설정되고 False이면 기본 문자열 표현 ( &lt;code&gt;__str__&lt;/code&gt; ) 을 반환하는 기능 이 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="303e2928545dd79ae7d3ee948a353e0207edca4f" translate="yes" xml:space="preserve">
          <source>If True a sparse grid is returned in order to conserve memory. Default is False.</source>
          <target state="translated">True 인 경우 메모리를 절약하기 위해 스파 스 그리드가 반환됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="963fdb4eb1744c24416dda1302569ec977b1039b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;M&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;M&lt;/code&gt; 은 Hermitian (실제 값인 경우 대칭) 인 것으로 가정하여 특이 값을 찾기위한보다 효율적인 방법을 제공합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="7ff6382ed5c39a63563e9ed1fd085cab5037a2b5" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;a&lt;/code&gt; is assumed to be Hermitian (symmetric if real-valued), enabling a more efficient method for finding singular values. Defaults to False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;a&lt;/code&gt; 는 Hermitian (실제 값인 경우 대칭) 인 것으로 가정하여 특이 값을 찾기위한보다 효율적인 방법을 제공합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="e36b410b04f66dbee1ad8585d5ab761e08ac7f58" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;c_or_r&lt;/code&gt; specifies the polynomial&amp;rsquo;s roots; the default is False.</source>
          <target state="translated">True 인 경우 &lt;code&gt;c_or_r&lt;/code&gt; 은 다항식의 근을 지정합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="d928194afbe2c2b929bfedb481313d712d7c8b8b" translate="yes" xml:space="preserve">
          <source>If True, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">True이면 &lt;code&gt;stop&lt;/code&gt; 이 마지막 샘플입니다. 그렇지 않으면 포함되지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="7b47be5e3a5ad40d6f18921eb27fcceb85292f89" translate="yes" xml:space="preserve">
          <source>If True, NaNs will compare equal.</source>
          <target state="translated">True이면 NaN이 동일하게 비교됩니다.</target>
        </trans-unit>
        <trans-unit id="cf238e83938a09d87961a742f48c2f2620eb27d1" translate="yes" xml:space="preserve">
          <source>If True, align the fields by padding as the C-compiler would. Default is False.</source>
          <target state="translated">True 인 경우 C- 컴파일러와 같이 패딩하여 필드를 정렬하십시오. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="9aac1833ab9bd35419c20a57ebf8fcbcb3fe9e5b" translate="yes" xml:space="preserve">
          <source>If True, also repack nested structures.</source>
          <target state="translated">True 인 경우 중첩 된 구조도 다시 압축합니다.</target>
        </trans-unit>
        <trans-unit id="fac02997269b77136285be7a5e579ac29dadfffd" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of &lt;code&gt;ar&lt;/code&gt; (along the specified axis, if provided, or in the flattened array) that result in the unique array.</source>
          <target state="translated">True 인 경우 고유 한 배열을 제공하는 &lt;code&gt;ar&lt;/code&gt; (지정된 축을 따라 또는 평면 배열로) 의 인덱스도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="5ba4a4047dcee50611d5129a3a15323121b0e960" translate="yes" xml:space="preserve">
          <source>If True, also return the indices of the unique array (for the specified axis, if provided) that can be used to reconstruct &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 &lt;code&gt;ar&lt;/code&gt; 재구성에 사용할 수있는 고유 배열 (제공된 경우 지정된 축에 대한)의 인덱스도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="399ee9e74026589c23b2445da8094594d73ae5dd" translate="yes" xml:space="preserve">
          <source>If True, also return the number of times each unique item appears in &lt;code&gt;ar&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 각 고유 항목이 &lt;code&gt;ar&lt;/code&gt; 에 나타나는 횟수도 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="66852352128b1c7e34ad7789302cdfe6ede485bb" translate="yes" xml:space="preserve">
          <source>If True, always print floating point numbers using fixed point notation, in which case numbers equal to zero in the current precision will print as zero. If False, then scientific notation is used when absolute value of the smallest number is &amp;lt; 1e-4 or the ratio of the maximum absolute value to the minimum is &amp;gt; 1e3. The default is False.</source>
          <target state="translated">True 인 경우 항상 고정 소수점 표기법을 사용하여 부동 소수점 숫자를 인쇄합니다.이 경우 현재 정밀도에서 0과 같은 숫자는 0으로 인쇄됩니다. False 인 경우, 가장 작은 수의 절대 값이 &amp;lt;1e-4이거나 최대 절대 값과 최소값의 비율이&amp;gt; 1e3 일 때 과학 표기법이 사용됩니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="cbca430a42a0182aa9ea6441a3957e8ab3c8a25b" translate="yes" xml:space="preserve">
          <source>If True, always returns a tuple.</source>
          <target state="translated">True이면 항상 튜플을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="7f126462d85653c6dda1dce20f661e9fd87395a7" translate="yes" xml:space="preserve">
          <source>If True, an exception is raised if an inconsistency is detected in the number of columns. If False, a warning is emitted and the offending lines are skipped.</source>
          <target state="translated">True 인 경우 열 수에서 불일치가 감지되면 예외가 발생합니다. False이면 경고가 발생하고 문제가되는 행을 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="00dd94f809ecdc81e9a20bf00165ace3a76e2409" translate="yes" xml:space="preserve">
          <source>If True, do not raise errors for invalid values.</source>
          <target state="translated">True 인 경우 유효하지 않은 값에 대해 오류를 발생시키지 마십시오.</target>
        </trans-unit>
        <trans-unit id="75ba0a561e02b7ed5e7fa180639d41ec79419f2b" translate="yes" xml:space="preserve">
          <source>If True, field names are case sensitive. If False or &amp;lsquo;upper&amp;rsquo;, field names are converted to upper case. If &amp;lsquo;lower&amp;rsquo;, field names are converted to lower case.</source>
          <target state="translated">True 인 경우 필드 이름은 대소 문자를 구분합니다. False 또는 'upper'이면 필드 이름이 대문자로 변환됩니다. '낮음'이면 필드 이름이 소문자로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="d130bfc0ef6421a7c1dc4437f4b7a0f3775ccf94" translate="yes" xml:space="preserve">
          <source>If True, fields in the dst for which there was no matching field in the src are filled with the value 0 (zero). This was the behavior of numpy &amp;lt;= 1.13. If False, those fields are not modified.</source>
          <target state="translated">True 인 경우 src에 일치하는 필드가없는 dst의 필드는 값 0 (영)으로 채워집니다. 이것은 numpy &amp;lt;= 1.13의 동작이었습니다. False이면 해당 필드가 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d57971ed0ca8f21d400e58c76703f43cbfc417c" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises a &lt;code&gt;ValueError&lt;/code&gt; exception when some values are missing.</source>
          <target state="translated">True이면 마스킹 된 값이 쌍으로 전파됩니다. 값이 &lt;code&gt;x&lt;/code&gt; 로 마스킹 되면 해당 값이 &lt;code&gt;y&lt;/code&gt; 로 마스킹됩니다 . False이면 일부 값이 없을 때 &lt;code&gt;ValueError&lt;/code&gt; 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="73add7a762002fef273e9b4ffea7ca56d1fceed2" translate="yes" xml:space="preserve">
          <source>If True, masked values are propagated pair-wise: if a value is masked in &lt;code&gt;x&lt;/code&gt;, the corresponding value is masked in &lt;code&gt;y&lt;/code&gt;. If False, raises an exception. Because &lt;code&gt;bias&lt;/code&gt; is deprecated, this argument needs to be treated as keyword only to avoid a warning.</source>
          <target state="translated">True이면 마스킹 된 값이 쌍으로 전파됩니다. 값이 &lt;code&gt;x&lt;/code&gt; 로 마스킹 되면 해당 값이 &lt;code&gt;y&lt;/code&gt; 로 마스킹됩니다 . False이면 예외가 발생합니다. 때문에 &lt;code&gt;bias&lt;/code&gt; 되지 않습니다,이 인수는 경고를 피하기 위해 키워드로 취급 될 필요가있다.</target>
        </trans-unit>
        <trans-unit id="3151423c1b8495757a74a9c40933465afccfc94a" translate="yes" xml:space="preserve">
          <source>If True, report coverage of NumPy code. Default is False. (This requires the &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;coverage module&lt;/a&gt;).</source>
          <target state="translated">True 인 경우 NumPy 코드의 적용 범위를보고합니다. 기본값은 False입니다. (이를 위해서는 &lt;a href=&quot;https://nedbatchelder.com/code/modules/coveragehtml&quot;&gt;커버리지 모듈&lt;/a&gt; 이 필요합니다 ).</target>
        </trans-unit>
        <trans-unit id="3f2788b0d6fce7deb3124b031af49411eebfd85f" translate="yes" xml:space="preserve">
          <source>If True, return (&lt;code&gt;samples&lt;/code&gt;, &lt;code&gt;step&lt;/code&gt;), where &lt;code&gt;step&lt;/code&gt; is the spacing between samples.</source>
          <target state="translated">True 인 경우 ( &lt;code&gt;samples&lt;/code&gt; , &lt;code&gt;step&lt;/code&gt; )을 반환 합니다. 여기서 &lt;code&gt;step&lt;/code&gt; 은 샘플 사이의 간격입니다.</target>
        </trans-unit>
        <trans-unit id="273f09f29e0c5b2094a6e70e74f740f3fc0e31da" translate="yes" xml:space="preserve">
          <source>If True, return a &lt;a href=&quot;https://docs.python.org/dev/library/subprocess.html#subprocess.CompletedProcess&quot;&gt;&lt;code&gt;subprocess.CompletedProcess&lt;/code&gt;&lt;/a&gt; containing the stdout and stderr of the compile process, instead of just the status code.</source>
          <target state="translated">True 인 경우 상태 코드 대신 컴파일 프로세스의 stdout 및 stderr를 포함 하는 &lt;a href=&quot;https://docs.python.org/dev/library/subprocess.html#subprocess.CompletedProcess&quot;&gt; &lt;code&gt;subprocess.CompletedProcess&lt;/code&gt; &lt;/a&gt; 를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1ec0fbd07daef19f7914b14e4eca0f4fd562cd19" translate="yes" xml:space="preserve">
          <source>If True, return a masked array. If False, return a regular array.</source>
          <target state="translated">True이면 마스크 된 배열을 반환합니다. False이면 일반 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="6adea9a68fb349bf8bb3df130607e9340ead5b74" translate="yes" xml:space="preserve">
          <source>If True, run doctests in module. Default is False.</source>
          <target state="translated">True이면 모듈에서 doctests를 실행합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="23ec8ba9608d7abff50b6dc8fd3f7629dafcce5d" translate="yes" xml:space="preserve">
          <source>If True, specifies that the decorated callable is a test. If False, specifies that the decorated callable is not a test. Default is True.</source>
          <target state="translated">True 인 경우 데코레이션 된 콜 러블이 테스트임을 지정합니다. False 인 경우 데코레이션 된 콜 러블이 테스트가 아님을 지정합니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="528d6459701fb35380cbc7e9b626e72c7e5fe90f" translate="yes" xml:space="preserve">
          <source>If True, sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">True이면 하위 클래스가 통과되고, 그렇지 않으면 반환 된 배열이 강제로 기본 클래스 배열 (기본값)이됩니다.</target>
        </trans-unit>
        <trans-unit id="392d55a0a9d04db7b0ca9f8c7072e4cdcc499491" translate="yes" xml:space="preserve">
          <source>If True, subclasses are preserved.</source>
          <target state="translated">True이면 서브 클래스가 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="8d750c3ba08e3d89b81f148fbacf7cfd56b0a5f8" translate="yes" xml:space="preserve">
          <source>If True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">True 인 경우 축소 된 축은 크기가 1 인 치수로 결과에 남습니다. 이 옵션을 사용하면 결과가 원래 &lt;code&gt;arr&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="b2006dd9c76a3ff3a106ec273dd3c8e1e765c752" translate="yes" xml:space="preserve">
          <source>If True, the conflicting values are appended to the error message.</source>
          <target state="translated">True 인 경우 충돌하는 값이 오류 메시지에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="d8ba5d3712bb2ee2efcfc81e8a867c710618acda" translate="yes" xml:space="preserve">
          <source>If True, the indices which correspond to the intersection of the two arrays are returned. The first instance of a value is used if there are multiple. Default is False.</source>
          <target state="translated">True이면 두 배열의 교집합에 해당하는 인덱스가 반환됩니다. 값이 여러 개인 경우 값의 첫 번째 인스턴스가 사용됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="796c55d79196f76e9a5e82ed451d32129c18b457" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. Default is False.</source>
          <target state="translated">True 인 경우 입력 배열이 모두 고유 한 것으로 가정하여 계산 속도를 높일 수 있습니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="262ad12226b8d86b75ded0db8c7b0c32d50e89e8" translate="yes" xml:space="preserve">
          <source>If True, the input arrays are both assumed to be unique, which can speed up the calculation. If True but &lt;code&gt;ar1&lt;/code&gt; or &lt;code&gt;ar2&lt;/code&gt; are not unique, incorrect results and out-of-bounds indices could result. Default is False.</source>
          <target state="translated">True이면 입력 배열이 모두 고유 한 것으로 간주되어 계산 속도를 높일 수 있습니다. 진정한하지만 경우 &lt;code&gt;ar1&lt;/code&gt; 또는 &lt;code&gt;ar2&lt;/code&gt; 고유 잘못된 결과 및 범위를 벗어날 수없는 지표가 발생할 수 있습니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="4faadc5e6554004b31ce5928d5d80bd241c02388" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with either the &lt;code&gt;c_index&lt;/code&gt; or the &lt;code&gt;f_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt;&lt;code&gt;index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">True 인 경우 반복자는 &lt;code&gt;c_index&lt;/code&gt; 또는 &lt;code&gt;f_index&lt;/code&gt; 플래그 를 사용하여 작성되었으며 특성 &lt;a href=&quot;numpy.nditer.index#numpy.nditer.index&quot;&gt; &lt;code&gt;index&lt;/code&gt; &lt;/a&gt; 을 사용하여이를 검색 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="78e99fe24c914b8497fc3d013aec906afbe03579" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;delay_bufalloc&lt;/code&gt; flag, and no reset() function was called on it yet.</source>
          <target state="translated">True 인 경우, 이터레이터는 &lt;code&gt;delay_bufalloc&lt;/code&gt; 플래그 로 작성 되었으며 아직 reset () 함수가 호출되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="78a4539bda923dafd78fad0e5fb97c6b43556f2b" translate="yes" xml:space="preserve">
          <source>If True, the iterator was created with the &lt;code&gt;multi_index&lt;/code&gt; flag, and the property &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt;&lt;code&gt;multi_index&lt;/code&gt;&lt;/a&gt; can be used to retrieve it.</source>
          <target state="translated">True 인 경우, 반복자는 만들었습니다 &lt;code&gt;multi_index&lt;/code&gt; 의 플래그 및 속성 &lt;a href=&quot;numpy.nditer.multi_index#numpy.nditer.multi_index&quot;&gt; &lt;code&gt;multi_index&lt;/code&gt; 은&lt;/a&gt; 그것을 검색하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd78b05e62a74691621672060edfaaaf7c932b8a" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = genfromtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">True이면 반환 된 배열이 전치되므로 &lt;code&gt;x, y, z = genfromtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 . 구조화 된 데이터 유형과 함께 사용하면 각 필드에 대해 배열이 반환됩니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="f4229174699f5726402f68c65f4921612f023a93" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;</source>
          <target state="translated">True 인 경우 반환 된 배열이 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9bf7edcd483311b9596b9cc1a4efa43974ee453" translate="yes" xml:space="preserve">
          <source>If True, the returned array is transposed, so that arguments may be unpacked using &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt;. When used with a structured data-type, arrays are returned for each field. Default is False.</source>
          <target state="translated">True 인 경우, 반환 된 배열이 바뀌므로 &lt;code&gt;x, y, z = loadtxt(...)&lt;/code&gt; 사용하여 인수의 압축을 풀 수 있습니다 . 구조화 된 데이터 유형과 함께 사용하면 각 필드에 대해 배열이 리턴됩니다. 기본값은 거짓입니다.</target>
        </trans-unit>
        <trans-unit id="d43fcdb1c52440e31bff4cb2f390cb23f384392a" translate="yes" xml:space="preserve">
          <source>If True, the shape of the coefficient array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;c&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;c&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;c&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">True 인 경우 계수 배열의 모양은 &lt;code&gt;x&lt;/code&gt; 의 각 차원마다 하나씩 오른쪽에있는 것으로 확장됩니다 . 스칼라는이 작업의 차원이 0입니다. 결과적으로 &lt;code&gt;c&lt;/code&gt; 의 모든 계수 열 은 &lt;code&gt;x&lt;/code&gt; 의 모든 요소에 대해 평가됩니다 . False이면 &lt;code&gt;x&lt;/code&gt; 는 평가를 위해 &lt;code&gt;c&lt;/code&gt; 의 열을 통해 브로드 캐스트 됩니다. 이 키워드는 &lt;code&gt;c&lt;/code&gt; 가 다차원 일 때 유용합니다 . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="959391ebb6591b28733d37c72b179dc2ae1393e8" translate="yes" xml:space="preserve">
          <source>If True, the shape of the roots array is extended with ones on the right, one for each dimension of &lt;code&gt;x&lt;/code&gt;. Scalars have dimension 0 for this action. The result is that every column of coefficients in &lt;code&gt;r&lt;/code&gt; is evaluated for every element of &lt;code&gt;x&lt;/code&gt;. If False, &lt;code&gt;x&lt;/code&gt; is broadcast over the columns of &lt;code&gt;r&lt;/code&gt; for the evaluation. This keyword is useful when &lt;code&gt;r&lt;/code&gt; is multidimensional. The default value is True.</source>
          <target state="translated">True 인 경우, 루트 배열의 모양은 &lt;code&gt;x&lt;/code&gt; 의 각 차원마다 하나씩 오른쪽에있는 모양으로 확장됩니다 . 스칼라는이 작업의 차원이 0입니다. 결과는 &lt;code&gt;r&lt;/code&gt; 의 모든 계수 열 이 &lt;code&gt;x&lt;/code&gt; 의 모든 요소에 대해 평가됩니다 . False이면 &lt;code&gt;x&lt;/code&gt; 는 평가를 위해 &lt;code&gt;r&lt;/code&gt; 의 열을 통해 브로드 캐스트 됩니다. 이 키워드는 &lt;code&gt;r&lt;/code&gt; 이 다차원 일 때 유용합니다 . 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="6f56bb6f69c7a79b2fcb0eba261866b1784e5a91" translate="yes" xml:space="preserve">
          <source>If True, the spaces at the end of Strings are removed before the comparison.</source>
          <target state="translated">True 인 경우 비교 전에 문자열 끝에있는 공백이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="201e227337fd7a8180e5a7ed35ba4fd5fc02b88e" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted (that is, False where an element of &lt;code&gt;ar1&lt;/code&gt; is in &lt;code&gt;ar2&lt;/code&gt; and True otherwise). Default is False. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; is equivalent to (but is faster than) &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt;.</source>
          <target state="translated">참이 반환 된 배열의 값이 반전되는 경우 (즉, 요소의 위치를 거짓 &lt;code&gt;ar1&lt;/code&gt; 되어 &lt;code&gt;ar2&lt;/code&gt; 달리 트루). 기본값은 거짓입니다. &lt;code&gt;np.in1d(a, b, invert=True)&lt;/code&gt; 는 &lt;code&gt;np.invert(in1d(a, b))&lt;/code&gt; 와 동일하지만 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="259b3152dca6c438bfe50af972160ce0a4a1de26" translate="yes" xml:space="preserve">
          <source>If True, the values in the returned array are inverted, as if calculating &lt;code&gt;element not in test_elements&lt;/code&gt;. Default is False. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; is equivalent to (but faster than) &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt;.</source>
          <target state="translated">True 인 경우, 반환 된 배열의 값 &lt;code&gt;element not in test_elements&lt;/code&gt; 계산하는 것처럼 반전됩니다 . 기본값은 거짓입니다. &lt;code&gt;np.isin(a, b, invert=True)&lt;/code&gt; 는 &lt;code&gt;np.invert(np.isin(a, b))&lt;/code&gt; 와 동일하지만 더 빠릅니다 .</target>
        </trans-unit>
        <trans-unit id="945e8f6a0cee215b87f641fdb7d3287ee26a3bd1" translate="yes" xml:space="preserve">
          <source>If True, then allow the input array &lt;code&gt;a&lt;/code&gt; to be modified by intermediate calculations, to save memory. In this case, the contents of the input &lt;code&gt;a&lt;/code&gt; after this function completes is undefined.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 를 중간 계산으로 수정하여 메모리를 절약 할 수 있습니다. 이 경우이 기능이 완료된 후 입력 &lt;code&gt;a&lt;/code&gt; 의 내용 은 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3dbfbe1abf097059eac31485586e156e13dcab2c" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 계산을 위해 입력 배열 (a)의 메모리 사용을 허용합니다. 입력 배열은 중앙값을 호출하여 수정됩니다. 이렇게하면 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 처리하지만 전체 또는 부분적으로 정렬 될 수 있습니다. 기본값은 False입니다. 경우 해당 주 &lt;code&gt;overwrite_input&lt;/code&gt; 가 사실이고, 입력이 이미하지 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="efffbf4abfcfd3dab70b2b5adf8fd6ea45c7060a" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array (a) for calculations. The input array will be modified by the call to median. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. Note that, if &lt;code&gt;overwrite_input&lt;/code&gt; is True, and the input is not already an &lt;code&gt;ndarray&lt;/code&gt;, an error will be raised.</source>
          <target state="translated">참이면 계산에 입력 배열 (a)의 메모리 사용을 허용하십시오. 입력 배열은 중앙값 호출에 의해 수정됩니다. 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 해당 주 &lt;code&gt;overwrite_input&lt;/code&gt; 가 사실이고, 입력이 이미하지 &lt;code&gt;ndarray&lt;/code&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="453475060bdf9f6ca07ca2a9d367c0c72b7c7341" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 의 메모리를 사용 하여 계산할 수 있습니다. 입력 배열은 &lt;a href=&quot;#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 호출로 수정됩니다 . 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 &lt;code&gt;overwrite_input&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 이미 아니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="bf48ed6030d0efc488f7b3086097c6ad325b803d" translate="yes" xml:space="preserve">
          <source>If True, then allow use of memory of input array &lt;code&gt;a&lt;/code&gt; for calculations. The input array will be modified by the call to &lt;a href=&quot;numpy.median#numpy.median&quot;&gt;&lt;code&gt;median&lt;/code&gt;&lt;/a&gt;. This will save memory when you do not need to preserve the contents of the input array. Treat the input as undefined, but it will probably be fully or partially sorted. Default is False. If &lt;code&gt;overwrite_input&lt;/code&gt; is &lt;code&gt;True&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is not already an &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, an error will be raised.</source>
          <target state="translated">True이면 입력 배열 &lt;code&gt;a&lt;/code&gt; 의 메모리를 사용 하여 계산할 수 있습니다. 입력 배열은 &lt;a href=&quot;numpy.median#numpy.median&quot;&gt; &lt;code&gt;median&lt;/code&gt; &lt;/a&gt; 호출로 수정됩니다 . 입력 배열의 내용을 보존 할 필요가 없을 때 메모리가 절약됩니다. 입력을 정의되지 않은 것으로 취급하지만 완전히 또는 부분적으로 정렬 될 수 있습니다. 기본값은 거짓입니다. 경우 &lt;code&gt;overwrite_input&lt;/code&gt; 가 있다 &lt;code&gt;True&lt;/code&gt; 와 &lt;code&gt;a&lt;/code&gt; 이미 아니다 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="727bb21e15aa63ae35b6dc8fc80a632c45207cf3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through (default), otherwise the returned array will be forced to be a base-class array.</source>
          <target state="translated">True 인 경우 하위 클래스가 통과 (기본값)되며, 그렇지 않으면 반환 된 배열이 기본 클래스 배열이됩니다.</target>
        </trans-unit>
        <trans-unit id="4ceb06545ceed82d0fd2c4e74fddc1a8387d729b" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (default).</source>
          <target state="translated">True 인 경우 하위 클래스가 전달되고, 그렇지 않으면 반환 된 배열은 기본 클래스 배열이됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="7931866e33bf18d405c7c9da5047f41db3dc88c3" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned array will be forced to be a base-class array (defaults to False).</source>
          <target state="translated">True이면 하위 클래스가 통과되고, 그렇지 않으면 반환 된 배열이 기본 클래스 배열이됩니다 (기본값은 False).</target>
        </trans-unit>
        <trans-unit id="9752fe228ae3462d649576fdb0cd4757647ae348" translate="yes" xml:space="preserve">
          <source>If True, then sub-classes will be passed-through, otherwise the returned arrays will be forced to be a base-class array (default).</source>
          <target state="translated">True이면 하위 클래스가 전달되고, 그렇지 않으면 반환 된 배열이 기본 클래스 배열이됩니다 (기본값).</target>
        </trans-unit>
        <trans-unit id="066838f1ffe5aa12c7d71f9b1de32afdb88ee10e" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &amp;lsquo;a&amp;rsquo;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">True 인 경우 새로 만든 배열은 하위 클래스 유형 'a'를 사용하고 그렇지 않으면 기본 클래스 배열입니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="637f994c43dad54f98722e59d623faad4b72d12f" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &lt;code&gt;a&lt;/code&gt;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">True 인 경우, 다음 새로 만든 배열의 하위 클래스 유형 사용 &lt;code&gt;a&lt;/code&gt; 그렇지 않으면 기본 수준의 배열이됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="2dc991539e6e09a358dd637bc4a93159f28455ae" translate="yes" xml:space="preserve">
          <source>If True, then the newly created array will use the sub-class type of &lt;code&gt;prototype&lt;/code&gt;, otherwise it will be a base-class array. Defaults to True.</source>
          <target state="translated">True이면 새로 생성 된 배열이 &lt;code&gt;prototype&lt;/code&gt; 의 하위 클래스 유형을 사용하고 그렇지 않으면 기본 클래스 배열이됩니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="9ba9655ceab858d8e0fbfbe35222ace33db08fb2" translate="yes" xml:space="preserve">
          <source>If [array, array], the bin edges in each dimension (x_edges, y_edges = bins).</source>
          <target state="translated">[배열, 배열]이면 각 차원의 빈 가장자리 (x_edges, y_edges = 빈)입니다.</target>
        </trans-unit>
        <trans-unit id="74d7f2b29106e8ca088ed3ddc192d60c869742ea" translate="yes" xml:space="preserve">
          <source>If [int, int], the number of bins in each dimension (nx, ny = bins).</source>
          <target state="translated">[int, int] 인 경우 각 차원의 구간 수 (nx, ny = 구간).</target>
        </trans-unit>
        <trans-unit id="63952cde8568ab7ec41b2ac80ecf7fdc353a6855" translate="yes" xml:space="preserve">
          <source>If __svn_version__.py existed before, nothing is done.</source>
          <target state="translated">__svn_version__.py가 이미 존재하면 아무 것도 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2973727add43998ece2695a952786574b37deff8" translate="yes" xml:space="preserve">
          <source>If a &amp;lt; 1.</source>
          <target state="translated">&amp;lt;1 인 경우</target>
        </trans-unit>
        <trans-unit id="d6288450796b9bb41fb24a4a3b5f478c44715bdc" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;python module&lt;/code&gt; block contains two or more &lt;code&gt;common&lt;/code&gt; blocks with the same name, the variables from the additional declarations are appended. The types of variables in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; are defined using &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt;. Note that the corresponding &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; may contain array specifications; then you don&amp;rsquo;t need to specify these in &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">경우 &lt;code&gt;python module&lt;/code&gt; 블록이 두 개 이상 포함 &lt;code&gt;common&lt;/code&gt; 이름이 같은 블록을 추가 선언에서 변수가 추가된다. &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; 의 변수 유형은 &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; 를 사용하여 정의됩니다 . 해당하는 &lt;code&gt;&amp;lt;argument type declarations&amp;gt;&lt;/code&gt; 에는 배열 사양이 포함될 수 있습니다. 그러면 &lt;code&gt;&amp;lt;shortentitydecl&amp;gt;&lt;/code&gt; 에서 지정할 필요가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="949f92ee120b49054523e5f48bcc0be73d87cf4a" translate="yes" xml:space="preserve">
          <source>If a Council member becomes inactive in the project for a period of one year, they will be considered for removal from the Council. Before removal, inactive Member will be approached to see if they plan on returning to active participation. If not they will be removed immediately upon a Council vote. If they plan on returning to active participation soon, they will be given a grace period of one year. If they don&amp;rsquo;t return to active participation within that time period they will be removed by vote of the Council without further grace period. All former Council members can be considered for membership again at any time in the future, like any other Project Contributor. Retired Council members will be listed on the project website, acknowledging the period during which they were active in the Council.</source>
          <target state="translated">위원회 구성원이 1 년 동안 프로젝트에서 비활성 상태가되면위원회에서 제거 된 것으로 간주됩니다. 제거하기 전에 비활성 회원에게 연락하여 활성 참여로 돌아갈 계획인지 확인합니다. 그렇지 않은 경우위원회 투표시 즉시 제거됩니다. 곧 적극적으로 참여할 계획이라면 1 년의 유예 기간이 주어집니다. 해당 기간 내에 적극적으로 참여하지 않으면 추가 유예 기간없이위원회의 투표로 제거됩니다. 이전의 모든위원회 구성원은 다른 프로젝트 기여자와 마찬가지로 향후 언제든지 다시 구성원 자격으로 고려 될 수 있습니다. ㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 은퇴 한위원회 구성원은위원회에서 활동 한 기간을 인정하면서 프로젝트 웹 사이트에 나열됩니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="0f5ac51d599581ab3e8a496c55fdc29ce07640e8" translate="yes" xml:space="preserve">
          <source>If a F2PY generated wrapper function expects the following call-back argument:</source>
          <target state="translated">F2PY 생성 래퍼 함수가 다음 콜백 인수를 예상하는 경우 :</target>
        </trans-unit>
        <trans-unit id="736cfd31de35553aafebed98e2d227e880ff08c4" translate="yes" xml:space="preserve">
          <source>If a byteorder of &lt;a href=&quot;#c.NPY_IGNORE&quot;&gt;&lt;code&gt;NPY_IGNORE&lt;/code&gt;&lt;/a&gt; is encountered it is left alone. If newendian is &lt;a href=&quot;#c.NPY_SWAP&quot;&gt;&lt;code&gt;NPY_SWAP&lt;/code&gt;&lt;/a&gt;, then all byte-orders are swapped. Other valid newendian values are &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt;&lt;code&gt;NPY_NATIVE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt;&lt;code&gt;NPY_LITTLE&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#c.NPY_BIG&quot;&gt;&lt;code&gt;NPY_BIG&lt;/code&gt;&lt;/a&gt; which all cause the returned data-typed descriptor (and all it&amp;rsquo;s referenced data-type descriptors) to have the corresponding byte- order.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_IGNORE&quot;&gt; &lt;code&gt;NPY_IGNORE&lt;/code&gt; &lt;/a&gt; 의 바이트 순서 가 발견 되면 그대로 둡니다. newendian이 &lt;a href=&quot;#c.NPY_SWAP&quot;&gt; &lt;code&gt;NPY_SWAP&lt;/code&gt; &lt;/a&gt; 이면 모든 바이트 순서가 스왑됩니다. 다른 유효한 뉴 엔디안 값은 &lt;a href=&quot;#c.NPY_NATIVE&quot;&gt; &lt;code&gt;NPY_NATIVE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.NPY_LITTLE&quot;&gt; &lt;code&gt;NPY_LITTLE&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_BIG&quot;&gt; &lt;code&gt;NPY_BIG&lt;/code&gt; &lt;/a&gt; 이며, 모두 반환 된 데이터 유형 설명자 (및 참조 된 모든 데이터 유형 설명자)가 해당 바이트 순서를 갖도록합니다.</target>
        </trans-unit>
        <trans-unit id="ea1873bd2a58371aec0e3e9712cc84313c25ffe3" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will &lt;em&gt;not&lt;/em&gt; be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. This practice will return &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">갖는 클래스 (ndarray 서브 여부) 경우 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; 의&lt;/a&gt; 방법은 출력 오브젝트로서 사용된다 &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , 결과 것이다 &lt;em&gt;하지&lt;/em&gt; 의해 리턴 된 객체에 기록 될 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . 이 방법은 &lt;code&gt;TypeError&lt;/code&gt; 를 반환 합니다.</target>
        </trans-unit>
        <trans-unit id="c5279f6f16ca5cb6814a2ac00854340dc9cd2fbb" translate="yes" xml:space="preserve">
          <source>If a class (ndarray subclass or not) having the &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used as the output object of an &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt;, results will be written to the object returned by &lt;a href=&quot;#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Similar conversion is done on input arrays.</source>
          <target state="translated">갖는 클래스 (ndarray 서브 여부) 경우 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; 의&lt;/a&gt; 방법은 출력 오브젝트로서 사용된다 &lt;a href=&quot;ufuncs#ufuncs-output-type&quot;&gt;ufunc&lt;/a&gt; , 결과에 의해 리턴 된 객체에 기록한다 &lt;a href=&quot;#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . 입력 배열에서도 비슷한 변환이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="874568bcf37ebe0e2a8a8d54069b92c02f85f23a" translate="yes" xml:space="preserve">
          <source>If a class defines the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, this disables the &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; mechanism described below for ufuncs (which may eventually be deprecated).</source>
          <target state="translated">클래스가 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메서드를 정의하면 ufunc에 대해 아래 설명 된 &lt;a href=&quot;#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 메커니즘을 비활성화합니다 (결국 더 이상 사용되지 않을 수 있음).</target>
        </trans-unit>
        <trans-unit id="0577aaede06ac434e631d772788e0f369a956f02" translate="yes" xml:space="preserve">
          <source>If a compile-time fixed buffer is being used (both flags &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt;&lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;), the inner size may be used as a signal as well. The size is guaranteed to become zero when &lt;code&gt;iternext()&lt;/code&gt; returns false, enabling the following loop construct. Note that if you use this construct, you should not pass &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; as a flag, because it will cause larger sizes under some circumstances.</source>
          <target state="translated">컴파일 타임 고정 버퍼가 사용되는 경우 ( &lt;a href=&quot;#c.NPY_ITER_BUFFERED&quot;&gt; &lt;code&gt;NPY_ITER_BUFFERED&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 플래그 모두 ) 내부 크기도 신호로 사용될 수 있습니다. &lt;code&gt;iternext()&lt;/code&gt; 가 false를 리턴 하면 크기가 0이되어 다음 루프 구성을 사용할 수 있습니다. 이 구문을 사용하는 경우 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 를 플래그로 전달하면 안됩니다 . 일부 환경에서는 더 큰 크기가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9d666b71ab2db0f6cb052dc4a309c02e840cf132" translate="yes" xml:space="preserve">
          <source>If a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated:</source>
          <target state="translated">모양 변경 작업에서 차원이 -1로 지정되면 다른 차원이 자동으로 계산됩니다.</target>
        </trans-unit>
        <trans-unit id="769025cc778c9102b36d6a70ef7aed0a8fe51c05" translate="yes" xml:space="preserve">
          <source>If a field name in the required_dtype does not exist in the input array, that field is created and set to 0 in the output array.</source>
          <target state="translated">required_dtype의 필드 이름이 입력 배열에 없으면 해당 필드가 생성되고 출력 배열에서 0으로 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="4a3ce99d9611a27292277b44f279f72466bca938" translate="yes" xml:space="preserve">
          <source>If a field whose dtype object has this attribute is retrieved, then the extra dimensions implied by &lt;em&gt;shape&lt;/em&gt; are tacked on to the end of the retrieved array.</source>
          <target state="translated">dtype 객체에이 속성이있는 필드를 검색하면 &lt;em&gt;모양&lt;/em&gt; 으로 암시 된 추가 차원 이 검색된 배열의 끝에 고정됩니다.</target>
        </trans-unit>
        <trans-unit id="aa639d13854427042e288c4d7a227d11cd8e9453" translate="yes" xml:space="preserve">
          <source>If a file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; does not exist, the &lt;code&gt;include&lt;/code&gt; statement is ignored. Otherwise, the file &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; is included to a signature file. &lt;code&gt;include&lt;/code&gt; statements can be used in any part of a signature file, also outside the Fortran/C routine signature blocks.</source>
          <target state="translated">&lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 파일 이 없으면 &lt;code&gt;include&lt;/code&gt; 문이 무시됩니다. 그렇지 않으면 &lt;code&gt;&amp;lt;filename&amp;gt;&lt;/code&gt; 파일이 서명 파일에 포함됩니다. &lt;code&gt;include&lt;/code&gt; 문은 Fortran / C 루틴 서명 블록 외부에서도 서명 파일의 모든 부분에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="24439780a6864c35956999c18798d43f08d60388" translate="yes" xml:space="preserve">
          <source>If a formatter is specified for a certain type, the &lt;code&gt;precision&lt;/code&gt; keyword is ignored for that type.</source>
          <target state="translated">특정 유형에 대해 포맷터가 지정된 경우 해당 유형에 대해 &lt;code&gt;precision&lt;/code&gt; 키워드가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="687f359e5176c0f016578fb6a4154929ee305cd5" translate="yes" xml:space="preserve">
          <source>If a given array does not satisfy the specified restrictions.</source>
          <target state="translated">지정된 배열이 지정된 제한을 만족하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="516fd825a9c72297363bd8dd8c84b3bb2fcfe3f7" translate="yes" xml:space="preserve">
          <source>If a how-to has many steps:</source>
          <target state="translated">방법에 여러 단계가있는 경우 :</target>
        </trans-unit>
        <trans-unit id="0f9748bf845ac9d150692dd01c4e3cac7093889e" translate="yes" xml:space="preserve">
          <source>If a is a matrix object, then the return value is a matrix as well:</source>
          <target state="translated">a가 행렬 객체이면 반환 값도 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="8ca1d1baf4aebfbd38dd688686cce7228cb6bc88" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if a or p are not 1-dimensional, if a is an array-like of size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size</source>
          <target state="translated">a가 int이고 0보다 작은 경우 a 또는 p가 1 차원이 아닌 경우 a가 크기가 0 인 배열과 같거나 p가 확률의 벡터가 아닌 경우, a와 p의 길이가 다른 경우 또는 replace = 거짓이며 표본 크기가 모집단 크기보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="45d749c722fde2f54ef7349c75a2d911b0caf469" translate="yes" xml:space="preserve">
          <source>If a is an int and less than zero, if p is not 1-dimensional, if a is array-like with a size 0, if p is not a vector of probabilities, if a and p have different lengths, or if replace=False and the sample size is greater than the population size.</source>
          <target state="translated">a가 int이고 0보다 작은 경우, p가 1 차원이 아닌 경우, a가 크기가 0 인 배열과 같은 경우, p가 확률 벡터가 아닌 경우, a와 p의 길이가 다르거 나 replace = 인 경우 False이고 표본 크기가 모집단 크기보다 큽니다.</target>
        </trans-unit>
        <trans-unit id="6a821a28e324f16f0f4bf4708058f9a3d079d082" translate="yes" xml:space="preserve">
          <source>If a list of strings, each string should represent a dtype. If array_like, the character representation of the array dtype is used.</source>
          <target state="translated">문자열 목록 인 경우 각 문자열은 dtype을 나타내야합니다. array_like 인 경우 배열 dtype의 문자 표현이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="f0978a6e619ec2d43693907e27d2eb435814d97e" translate="yes" xml:space="preserve">
          <source>If a report doesn&amp;rsquo;t contain enough information, the committee will obtain all relevant data before acting. The committee is empowered to act on the Steering Council&amp;rsquo;s behalf in contacting any individuals involved to get a more complete account of events.</source>
          <target state="translated">보고서에 충분한 정보가 포함되어 있지 않은 경우위원회는 조치를 취하기 전에 모든 관련 데이터를 수집합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 위원회는 이벤트에 대한보다 완전한 설명을 얻기 위해 관련 개인에게 연락 할 때 운영위원회를 대신하여 행동 할 권한이 있습니다.</target>
        </trans-unit>
        <trans-unit id="63795a6ab48fcba94623b51f8a7753fc963d4b8e" translate="yes" xml:space="preserve">
          <source>If a scalar dtype, the corresponding string character is returned. If an object, &lt;a href=&quot;#numpy.sctype2char&quot;&gt;&lt;code&gt;sctype2char&lt;/code&gt;&lt;/a&gt; tries to infer its scalar type and then return the corresponding string character.</source>
          <target state="translated">스칼라 dtype 인 경우 해당 문자열 문자가 리턴됩니다. 객체 인 경우 &lt;a href=&quot;#numpy.sctype2char&quot;&gt; &lt;code&gt;sctype2char&lt;/code&gt; &lt;/a&gt; 는 스칼라 유형을 유추 한 다음 해당 문자열 문자를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="98a2233adc7ab93848107f159b490659bfa27e57" translate="yes" xml:space="preserve">
          <source>If a scalar value is passed in.</source>
          <target state="translated">스칼라 값이 전달 된 경우</target>
        </trans-unit>
        <trans-unit id="15bc103dab402117d3913395fb8b40bbeeb0b897" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. If the type of that array is a numeric type the result is represented as zeros and ones, if the type is boolean then as False and True. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">두 번째 인수가 제공되면 결과가 저장됩니다. 해당 배열의 유형이 숫자 유형 인 경우 결과는 0과 1로 표시되며, 유형이 부울 인 경우 False 및 True로 표시됩니다. 리턴 값 &lt;code&gt;out&lt;/code&gt; 그 어레이에 대한 레퍼런스이다.</target>
        </trans-unit>
        <trans-unit id="342304e655e812ee2a83e5789793e22172924b42" translate="yes" xml:space="preserve">
          <source>If a second argument is supplied the result is stored there. The return value &lt;code&gt;out&lt;/code&gt; is then a reference to that array.</source>
          <target state="translated">두 번째 인수가 제공되면 결과가 여기에 저장됩니다. &lt;code&gt;out&lt;/code&gt; 값 은 해당 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="ceb1ddfcab0f3cbec5d42431c301b1cc28fccf65" translate="yes" xml:space="preserve">
          <source>If a zero dimensional array is present in the index &lt;em&gt;and&lt;/em&gt; it is a full integer index the result will be a &lt;em&gt;scalar&lt;/em&gt; and not a zero dimensional array. (Advanced indexing is not triggered.)</source>
          <target state="translated">제로 차원 배열 인덱스에 존재하는 경우 &lt;em&gt;와&lt;/em&gt; 는 전체 정수 인덱스 인 결과가 될 것이다 &lt;em&gt;스칼라&lt;/em&gt; 아니라 제로 차원 어레이. (고급 인덱싱은 트리거되지 않습니다.)</target>
        </trans-unit>
        <trans-unit id="64c5c963ea9794eafa3b89f1dd216c6a8ebfd684" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal up to specified precision.</source>
          <target state="translated">실제와 원하는 것이 지정된 정밀도와 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="39bbb6143ab84f37b65c3d7880c2778b652d186d" translate="yes" xml:space="preserve">
          <source>If actual and desired are not equal.</source>
          <target state="translated">실제와 원하는 것이 같지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="fcebdf6acdb7662938a429c761fa5ad9e5471b67" translate="yes" xml:space="preserve">
          <source>If actual and desired objects are not equal.</source>
          <target state="translated">실제 및 원하는 객체가 동일하지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8aa394119b239dde7365c85e156833625438bfa9" translate="yes" xml:space="preserve">
          <source>If all &lt;code&gt;__array_function__&lt;/code&gt; methods return &lt;code&gt;NotImplemented&lt;/code&gt;, NumPy will raise &lt;code&gt;TypeError&lt;/code&gt;.</source>
          <target state="translated">모든 경우 &lt;code&gt;__array_function__&lt;/code&gt; 방법은 반환 &lt;code&gt;NotImplemented&lt;/code&gt; 을 , NumPy와는 올릴 &lt;code&gt;TypeError&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="454ac4064cbf860208005757a60b81b3482b89cb" translate="yes" xml:space="preserve">
          <source>If all of the commits are related, create a merge commit:</source>
          <target state="translated">모든 커밋이 관련되어 있으면 병합 커밋을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="85985aaa1b2d2d353f8a23ec019a6f4085543d14" translate="yes" xml:space="preserve">
          <source>If all proposals for resolving some issue are vetoed, then the status quo wins by default.</source>
          <target state="translated">일부 문제를 해결하기위한 모든 제안이 거부되면 기본적으로 현상 유지가 승리합니다.</target>
        </trans-unit>
        <trans-unit id="eab8ea3dfbb5bbbb71e7908ef2deef22ffee42c7" translate="yes" xml:space="preserve">
          <source>If all the arrays are 1-D, &lt;a href=&quot;#numpy.where&quot;&gt;&lt;code&gt;where&lt;/code&gt;&lt;/a&gt; is equivalent to:</source>
          <target state="translated">모든 배열이 1 차원 인 &lt;a href=&quot;#numpy.where&quot;&gt; &lt;code&gt;where&lt;/code&gt; &lt;/a&gt; 과 같습니다.</target>
        </trans-unit>
        <trans-unit id="4680fc5e031229cdb3ef2e322dccd91736ba09de" translate="yes" xml:space="preserve">
          <source>If all values are masked, return None. Otherwise, return a list of two tuples, corresponding to the indices of the first and last unmasked values respectively.</source>
          <target state="translated">모든 값이 마스킹되면 None을 반환합니다. 그렇지 않으면, 첫 번째 마스크 값과 마지막 마스크되지 않은 값의 인덱스에 해당하는 두 개의 튜플 목록을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="517ad1e00b3a93fbecfebfae5c6590d4c6fe64a9" translate="yes" xml:space="preserve">
          <source>If an argument has no &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt;, its type is determined by applying &lt;code&gt;implicit&lt;/code&gt; rules to its name.</source>
          <target state="translated">인수에 &lt;code&gt;&amp;lt;argument type declaration&amp;gt;&lt;/code&gt; 이 없으면 이름에 &lt;code&gt;implicit&lt;/code&gt; 규칙을 적용하여 해당 유형이 결정됩니다 .</target>
        </trans-unit>
        <trans-unit id="2edcb18bec5f7aa2d4bb57f912992d616edce150" translate="yes" xml:space="preserve">
          <source>If an array does not own its memory, then its &lt;a href=&quot;reference/generated/numpy.ndarray.base&quot;&gt;base&lt;/a&gt; attribute returns the object whose memory the array is referencing. That object may be referencing the memory from still another object, so the owning object may be &lt;code&gt;a.base.base.base...&lt;/code&gt;. Some writers erroneously claim that testing &lt;code&gt;base&lt;/code&gt; determines if arrays are &lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;s. For the correct way, see &lt;a href=&quot;reference/generated/numpy.shares_memory#numpy.shares_memory&quot;&gt;&lt;code&gt;numpy.shares_memory&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">배열이 메모리를 소유하지 않은 경우 &lt;a href=&quot;reference/generated/numpy.ndarray.base&quot;&gt;기본&lt;/a&gt; 속성은 배열이 참조하는 메모리를 가진 객체를 반환합니다. 해당 객체는 또 다른 객체의 메모리를 참조 할 수 있으므로 소유 객체는 &lt;code&gt;a.base.base.base...&lt;/code&gt; 일 수 있습니다 . 일부 작성자는 테스트 &lt;code&gt;base&lt;/code&gt; 이 어레이가 &lt;a href=&quot;#term-view&quot;&gt;뷰&lt;/a&gt; 인지 확인 한다고 잘못 주장합니다 . 올바른 방법은 &lt;a href=&quot;reference/generated/numpy.shares_memory#numpy.shares_memory&quot;&gt; &lt;code&gt;numpy.shares_memory&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6a0b2100814d2bab89059c0f2bc3adff904ee9a6" translate="yes" xml:space="preserve">
          <source>If an array has a very small or very large determinant, then a call to &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt;&lt;code&gt;det&lt;/code&gt;&lt;/a&gt; may overflow or underflow. This routine is more robust against such issues, because it computes the logarithm of the determinant rather than the determinant itself.</source>
          <target state="translated">배열에 매우 작거나 큰 결정자가있는 경우 &lt;a href=&quot;numpy.linalg.det#numpy.linalg.det&quot;&gt; &lt;code&gt;det&lt;/code&gt; &lt;/a&gt; 호출 이 오버플로되거나 언더 플로 될 수 있습니다. 이 루틴은 결정자 자체가 아니라 결정자 로그를 계산하기 때문에 이러한 문제에 대해보다 강력합니다.</target>
        </trans-unit>
        <trans-unit id="089dc283ee6bf525b9e1357cb2890636154add48" translate="yes" xml:space="preserve">
          <source>If an array has no elements (&lt;code&gt;self.size == 0&lt;/code&gt;) there is no legal index and the strides are never used. Any array with no elements may be considered C-style and Fortran-style contiguous.</source>
          <target state="translated">배열에 요소가없는 경우 ( &lt;code&gt;self.size == 0&lt;/code&gt; ) 유효한 인덱스가없고 보폭이 사용되지 않습니다. 요소가없는 배열은 C 스타일과 포트란 스타일의 연속으로 간주 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5c598efb3988281532c1be87569879df34d1935" translate="yes" xml:space="preserve">
          <source>If an array is created using a data-type describing a sub-array, the dimensions of the sub-array are appended to the shape of the array when the array is created. Sub-arrays in a field of a structured type behave differently, see &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;Field Access&lt;/a&gt;.</source>
          <target state="translated">하위 배열을 설명하는 데이터 형식을 사용하여 배열을 만들면 배열이 만들어 질 때 하위 배열의 차원이 배열 모양에 추가됩니다. 구조화 된 유형의 필드에있는 하위 배열은 다르게 동작합니다 ( &lt;a href=&quot;arrays.indexing#arrays-indexing-fields&quot;&gt;필드 액세스&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="bf36df6b09764d99c53b04e05c8fe53411949d03" translate="yes" xml:space="preserve">
          <source>If an array is created with this method, simply adding &amp;lsquo;itemsize&amp;rsquo; for each iteration will traverse the new array matching the iterator.</source>
          <target state="translated">이 방법으로 배열을 만들면 각 반복에 대해 'itemsize'를 추가하면 반복자와 일치하는 새 배열을 순회합니다.</target>
        </trans-unit>
        <trans-unit id="1497d51c68c81f921994ed240661dbb7879d05a8" translate="yes" xml:space="preserve">
          <source>If an array is too large to be printed, NumPy automatically skips the central part of the array and only prints the corners:</source>
          <target state="translated">배열이 너무 커서 인쇄 할 수없는 경우 NumPy는 배열의 중앙 부분을 자동으로 건너 뛰고 모서리 만 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="5e8325ebccad64f5436323a863f272d5f091c76c" translate="yes" xml:space="preserve">
          <source>If an element of &lt;code&gt;axes&lt;/code&gt; is larger than than the number of axes of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">소자의 경우 &lt;code&gt;axes&lt;/code&gt; 의 축수보다보다 큰 . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc51d7d23e7dc12f32f8e1785a950a943342d4c8" translate="yes" xml:space="preserve">
          <source>If an index exceeds the dimension of the array along &lt;code&gt;axis&lt;/code&gt;, an empty sub-array is returned correspondingly.</source>
          <target state="translated">index가 &lt;code&gt;axis&lt;/code&gt; 를 따라 배열의 차원을 초과하면 해당 하는 빈 하위 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="d50315439445c5e53d7c5cb2eca5a37deb22722b" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">입력의 형태가 차원 크기가 1 인 경우 해당 차원의 첫 번째 데이터 항목이 해당 차원의 모든 계산에 사용됩니다. 즉, &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; 의 스테핑 기계 는 단순히 해당 차원을 따라 이동하지 않습니다 (해당 차원에 대한 &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;보폭&lt;/a&gt; 은 0이됩니다).</target>
        </trans-unit>
        <trans-unit id="99fec5dbaf9a5723fb1db21784554641e2d086b8" translate="yes" xml:space="preserve">
          <source>If an input has a dimension size of 1 in its shape, the first data entry in that dimension will be used for all calculations along that dimension. In other words, the stepping machinery of the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; will simply not step along that dimension (the &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;stride&lt;/a&gt; will be 0 for that dimension).</source>
          <target state="translated">입력의 모양 크기가 1 인 경우 해당 차원의 첫 번째 데이터 항목이 해당 차원의 모든 계산에 사용됩니다. 다시 말해, &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; 의 스테핑 기계 는 단순히 해당 치수를 따라 밟지 않습니다 (해당 치수의 &lt;a href=&quot;arrays.ndarray#memory-layout&quot;&gt;보폭&lt;/a&gt; 은 0입니다).</target>
        </trans-unit>
        <trans-unit id="981216fcb80286728db3aa0467d4b1e8a655fef5" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated as if a were np.arange(a)</source>
          <target state="translated">ndarray 인 경우 요소에서 임의의 샘플이 생성됩니다. int 인 경우 a가 np.arange (a) 인 것처럼 임의 샘플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="6bcff738f855376346fed2a54471feef4ca0479d" translate="yes" xml:space="preserve">
          <source>If an ndarray, a random sample is generated from its elements. If an int, the random sample is generated from np.arange(a).</source>
          <target state="translated">ndarray의 경우 해당 요소에서 무작위 샘플이 생성됩니다. int 인 경우 np.arange (a)에서 임의 샘플이 생성됩니다.</target>
        </trans-unit>
        <trans-unit id="b055403a11a75cdadf358d2e4b16e4aaac100a0a" translate="yes" xml:space="preserve">
          <source>If an object is provided, its write method should take one argument, a string.</source>
          <target state="translated">객체가 제공되면 write 메소드는 하나의 인수 인 문자열을 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="c6eb2fb826e8cbc6182574444dd579783c5b9225" translate="yes" xml:space="preserve">
          <source>If any input is array_like, &lt;code&gt;pv&lt;/code&gt; returns an array of equal shape. Let&amp;rsquo;s compare different interest rates in the example above:</source>
          <target state="translated">입력 값이 array_like이면 &lt;code&gt;pv&lt;/code&gt; 는 동일한 모양의 배열을 반환합니다. 위의 예에서 다른 금리를 비교해 보겠습니다.</target>
        </trans-unit>
        <trans-unit id="ffa8ae9c8e4ca204b853aaf38ee0943c2276d1c9" translate="yes" xml:space="preserve">
          <source>If any input is array_like, returns an array of equal shape. Let&amp;rsquo;s compare different interest rates from the example above.</source>
          <target state="translated">입력이 array_like 인 경우 동일한 모양의 배열을 반환합니다. 위의 예와 다른 금리를 비교해 봅시다.</target>
        </trans-unit>
        <trans-unit id="dce7db3f12e1e92b36fcbe9af677f929557b423e" translate="yes" xml:space="preserve">
          <source>If any read/write overlap exists, this flag ensures the result of the operation is the same as if all operands were copied. In cases where copies would need to be made, &lt;strong&gt;the result of the computation may be undefined without this flag!&lt;/strong&gt;</source>
          <target state="translated">읽기 / 쓰기 오버랩이 존재하면이 플래그는 연산 결과가 모든 피연산자가 복사 된 것과 동일하도록합니다. 복사가 필요한 경우, &lt;strong&gt;이 플래그없이 계산 결과가 정의되지 않을 수 있습니다!&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3e0c40f81e19502941982ef1a412a173673233b4" translate="yes" xml:space="preserve">
          <source>If any value in &lt;code&gt;alpha&lt;/code&gt; is less than or equal to zero</source>
          <target state="translated">&lt;code&gt;alpha&lt;/code&gt; 값 이 0보다 작거나 같은 경우</target>
        </trans-unit>
        <trans-unit id="5a8f0d595ba6a3701f0ba4d0bf45fa3cd44ca9ce" translate="yes" xml:space="preserve">
          <source>If any value in alpha is less than or equal to zero</source>
          <target state="translated">알파 값이 0보다 작거나 같은 경우</target>
        </trans-unit>
        <trans-unit id="bc219d3a8300527c6efa92537ff8d0dcdb1108df" translate="yes" xml:space="preserve">
          <source>If any write operand has overlap with any read operand, eliminate all overlap by making temporary copies (enabling UPDATEIFCOPY for write operands, if necessary). A pair of operands has overlap if there is a memory address that contains data common to both arrays.</source>
          <target state="translated">쓰기 피연산자가 읽기 피연산자와 겹치는 경우 임시 복사본을 만들어 모든 겹침을 제거하십시오 (필요한 경우 쓰기 피연산자에 UPDATEIFCOPY 사용). 두 배열에 공통적 인 데이터를 포함하는 메모리 주소가 있으면 피연산자 쌍이 겹칩니다.</target>
        </trans-unit>
        <trans-unit id="2a45557faccf378e4b524258e3744f14e01d0549" translate="yes" xml:space="preserve">
          <source>If argument consists exclusively of int dtypes.</source>
          <target state="translated">인수가 int dtypes로만 구성된 경우</target>
        </trans-unit>
        <trans-unit id="c785d849c18fc327cf9bee37bc11741d006f8fa7" translate="yes" xml:space="preserve">
          <source>If arguments are passed in with no keywords, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file, are &amp;lsquo;arr_0&amp;rsquo;, &amp;lsquo;arr_1&amp;rsquo;, etc. If keyword arguments are given, the corresponding variable names, in the &lt;code&gt;.npz&lt;/code&gt; file will match the keyword names.</source>
          <target state="translated">키워드없이 인수를 전달하면 &lt;code&gt;.npz&lt;/code&gt; 파일 의 해당 변수 이름 은 'arr_0', 'arr_1'등입니다. 키워드 인수가 제공되면 &lt;code&gt;.npz&lt;/code&gt; 파일 의 해당 변수 이름 은 키워드 이름.</target>
        </trans-unit>
        <trans-unit id="3d1c7a0f1e977aad5bcdfcdc2989a2f748b0274f" translate="yes" xml:space="preserve">
          <source>If array_like, the bin edges for the two dimensions (x_edges=y_edges=bins).</source>
          <target state="translated">array_like 인 경우 2 차원의 빈 가장자리 (x_edges = y_edges = bins)</target>
        </trans-unit>
        <trans-unit id="8ad413f7fc8dfff3a6c2ee36c2613993e6279848" translate="yes" xml:space="preserve">
          <source>If at least one of &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is a non-string array</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 중 하나 이상 이 문자열이 아닌 배열 인 경우</target>
        </trans-unit>
        <trans-unit id="b3c56f840baa3a689fec388e92d6ba86ff952aa7" translate="yes" xml:space="preserve">
          <source>If at some point an existing Institutional Partner stops having any contributing employees, then a one year grace period commences. If at the end of this one year period they continue not to have any contributing employees, then their Institutional Partnership will lapse, and resuming it will require going through the normal process for new Partnerships.</source>
          <target state="translated">어느 시점에서 기존 기관 파트너가 기여하는 직원을 중단하면 1 년의 유예 기간이 시작됩니다. 이 1 년 기간이 끝날 때까지 직원이 계속 기여하지 않으면 기관 파트너십이 소멸되며 재개하려면 새로운 파트너십을위한 정상적인 프로세스를 거쳐야합니다.</target>
        </trans-unit>
        <trans-unit id="8a90d0b3d22bdc0f93b285a7398aa4703fe73214" translate="yes" xml:space="preserve">
          <source>If axis is 0, only rows are suppressed.</source>
          <target state="translated">축이 0이면 행만 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0782bc28993b5f00e72a0af1dcec69356d31839c" translate="yes" xml:space="preserve">
          <source>If axis is 1 or -1, only columns are suppressed.</source>
          <target state="translated">축이 1 또는 -1이면 열만 표시되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9506a7c18a807c059cd952ed93d5c51207a2a07d" translate="yes" xml:space="preserve">
          <source>If axis is None, both rows and columns are suppressed.</source>
          <target state="translated">axis가 None이면 행과 열이 모두 억제됩니다.</target>
        </trans-unit>
        <trans-unit id="c5149a1f08013bd4c50d9514785f4f44208d1f0b" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a product is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 제품이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="8de953aea1cde5c7cd7a932c7c1cd638dd5b48f8" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, a sum is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 합계가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="b7d9ad0b67d074ec073be5ef4e15eeecb68acdae" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, averaging is performed on all of the axes specified in the tuple instead of a single axis or all the axes as before.</source>
          <target state="translated">axis가 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 튜플에 지정된 모든 축에 대해 평균화가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="288d1e6c0a612db41ca8d2410d35c52a79ba7795" translate="yes" xml:space="preserve">
          <source>If axis is a tuple of ints, flipping is performed on all of the axes specified in the tuple.</source>
          <target state="translated">axis가 int의 튜플 인 경우 튜플에 지정된 모든 축에서 반전이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="4a67a427d1a7cbcfc229fb55b05bdd5b239d1bd3" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 1-D arrays, it is inner product of vectors (without complex conjugation).</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 는 1-D 어레이이고, 그것은 (복소 공액)없이 벡터의 내적이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c28be53ff292bd7a51506b92f27ed7a94fd2ec15" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; are 2-D arrays, it is matrix multiplication, but using &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;matmul&lt;/code&gt;&lt;/a&gt; or &lt;code&gt;a @ b&lt;/code&gt; is preferred.</source>
          <target state="translated">두 경우 및 &lt;code&gt;b&lt;/code&gt; 2-D 어레이이고,는 매트릭스 승산이지만, 사용 &lt;a href=&quot;numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;matmul&lt;/code&gt; 을&lt;/a&gt; 하거나 &lt;code&gt;a @ b&lt;/code&gt; 바람직하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="76c96acc4a781ea364ff42aad287e5f7651eee5d" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">두 경우 &lt;code&gt;formats&lt;/code&gt; 과 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 아무도 없다,이 의지는 포맷을 자동으로 감지합니다. 빠른 처리를 위해 목록 목록보다는 튜플 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="194f3cee9e7df2b602bf5ba80d6118fb502e2eaf" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;formats&lt;/code&gt; and &lt;code&gt;dtype&lt;/code&gt; are None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">두 경우 &lt;code&gt;formats&lt;/code&gt; 과 &lt;code&gt;dtype&lt;/code&gt; 아무도 없다,이 의지는 포맷을 자동으로 감지합니다. 빠른 처리를 위해 목록 목록보다는 튜플 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="368fd1e825cc7f1439018ab086e3ca74379697e1" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; are &lt;code&gt;NULL&lt;/code&gt;, then return &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt;&lt;code&gt;PyArray_Nonzero&lt;/code&gt;&lt;/a&gt; (&lt;em&gt;condition&lt;/em&gt;). Otherwise, both &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; must be given and the object returned is shaped like &lt;em&gt;condition&lt;/em&gt; and has elements of &lt;em&gt;x&lt;/em&gt; and &lt;em&gt;y&lt;/em&gt; where &lt;em&gt;condition&lt;/em&gt; is respectively True or False.</source>
          <target state="translated">두 경우 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 있는 &lt;code&gt;NULL&lt;/code&gt; , 다음 반환 &lt;a href=&quot;#c.PyArray_Nonzero&quot;&gt; &lt;code&gt;PyArray_Nonzero&lt;/code&gt; &lt;/a&gt; ( &lt;em&gt;상태&lt;/em&gt; ). 그렇지 않으면, &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y&lt;/em&gt; 가 모두 주어져야하고 반환 된 객체는 &lt;em&gt;조건&lt;/em&gt; 과 같은 모양 이며 &lt;em&gt;조건&lt;/em&gt; 이 각각 True 또는 False 인 &lt;em&gt;x&lt;/em&gt; 와 &lt;em&gt;y의&lt;/em&gt; 요소를 갖습니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7d34c61041bcc07e55093729fc859031c36d6999" translate="yes" xml:space="preserve">
          <source>If both arguments are 2-D they are multiplied like conventional matrices.</source>
          <target state="translated">두 인수가 모두 2 차원이면 기존 행렬과 같이 곱해집니다.</target>
        </trans-unit>
        <trans-unit id="bf26496158ed7aff00fe3f64e66aa6a508289463" translate="yes" xml:space="preserve">
          <source>If both positive and negative infinity are present, the sum will be Not A Number (NaN).</source>
          <target state="translated">양의 무한대와 음의 무한대가 모두 존재하면 합계는 NaN (Not A Number)이됩니다.</target>
        </trans-unit>
        <trans-unit id="c6be65ffe7d2b7c519b021c7a585a65d749c5cc8" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Returns&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Parameters&lt;/strong&gt; section:</source>
          <target state="translated">이름과 유형이 모두 지정된 경우 &lt;strong&gt;반환&lt;/strong&gt; 섹션은 &lt;strong&gt;매개 변수&lt;/strong&gt; 섹션 과 동일한 형식을 사용합니다 .</target>
        </trans-unit>
        <trans-unit id="10140359cb73a0890a92d9b94e958a4d9feb7bea" translate="yes" xml:space="preserve">
          <source>If both the name and type are specified, the &lt;strong&gt;Yields&lt;/strong&gt; section takes the same form as the &lt;strong&gt;Returns&lt;/strong&gt; section:</source>
          <target state="translated">이름과 형식을 모두 지정하는 경우, &lt;strong&gt;수익률의&lt;/strong&gt; 섹션은 같은 양식을 취 &lt;strong&gt;반환&lt;/strong&gt; 섹션 :</target>
        </trans-unit>
        <trans-unit id="4d89fb74ad22e53fe87d261e5d40a2d4a0331e92" translate="yes" xml:space="preserve">
          <source>If called with all arguments other than the warning class omitted, may be used as a context manager:</source>
          <target state="translated">경고 클래스 이외의 모든 인수를 생략하고 호출하면 컨텍스트 관리자로 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e1f9fb2b578de1420ef1d4182da3c75ca58e3552" translate="yes" xml:space="preserve">
          <source>If complex input returns a real array if complex parts are close to zero.</source>
          <target state="translated">복잡한 부분이 0에 가까우면 복잡한 입력이 실제 배열을 반환하는 경우</target>
        </trans-unit>
        <trans-unit id="4ec7acf826794e4e37207136e102eb50e7632b5f" translate="yes" xml:space="preserve">
          <source>If computation does not converge.</source>
          <target state="translated">계산이 수렴하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="66501fc9abcadb23835ebb60ef928268453bb410" translate="yes" xml:space="preserve">
          <source>If condition is a &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;, missing values are considered as &lt;code&gt;False&lt;/code&gt;.</source>
          <target state="translated">condition이 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 인&lt;/a&gt; 경우 누락 된 값은 &lt;code&gt;False&lt;/code&gt; 로 간주됩니다 .</target>
        </trans-unit>
        <trans-unit id="9bd71f3d3293e73ba78bbdd8102f9b41323ceaaa" translate="yes" xml:space="preserve">
          <source>If copy is False and one of the inputs is &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, return a view of the other input mask. Defaults to False.</source>
          <target state="translated">copy가 False이고 입력 중 하나가 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 이면 다른 입력 마스크의보기를 리턴하십시오. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="6d1cb15d43c2ba3971e5b54fc0a9bc261de3fb39" translate="yes" xml:space="preserve">
          <source>If data is passed to &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt;&lt;code&gt;PyArray_NewFromDescr&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#c.PyArray_New&quot;&gt;&lt;code&gt;PyArray_New&lt;/code&gt;&lt;/a&gt;, this memory must not be deallocated until the new array is deleted. If this data came from another Python object, this can be accomplished using &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt;&lt;code&gt;Py_INCREF&lt;/code&gt;&lt;/a&gt; on that object and setting the base member of the new array to point to that object. If strides are passed in they must be consistent with the dimensions, the itemsize, and the data of the array.</source>
          <target state="translated">데이터가 &lt;a href=&quot;#c.PyArray_NewFromDescr&quot;&gt; &lt;code&gt;PyArray_NewFromDescr&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.PyArray_New&quot;&gt; &lt;code&gt;PyArray_New&lt;/code&gt; &lt;/a&gt; 로 전달 되면 새 배열을 삭제할 때까지이 메모리를 할당 해제해서는 안됩니다. 이 데이터가 다른 Python 객체에서 온 경우 해당 객체에서 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_INCREF&quot;&gt; &lt;code&gt;Py_INCREF&lt;/code&gt; &lt;/a&gt; 를 사용하여 새 객체의 기본 멤버를 해당 객체를 가리 키도록 설정하면됩니다. 보폭이 전달되면 치수, 항목 크기 및 배열의 ​​데이터와 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cd71bec9bf23486f57ed709deb2da7e823cdd37" translate="yes" xml:space="preserve">
          <source>If defined, the axis of &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; and &lt;code&gt;c&lt;/code&gt; that defines the vector(s) and cross product(s). Overrides &lt;code&gt;axisa&lt;/code&gt;, &lt;code&gt;axisb&lt;/code&gt; and &lt;code&gt;axisc&lt;/code&gt;.</source>
          <target state="translated">정의한 경우의 축 , &lt;code&gt;b&lt;/code&gt; 및 &lt;code&gt;c&lt;/code&gt; 을 정의하는 벡터 (들) 및 외적 (들) 즉. 오버라이드 (override) &lt;code&gt;axisa&lt;/code&gt; , &lt;code&gt;axisb&lt;/code&gt; 및 &lt;code&gt;axisc&lt;/code&gt; . &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="13711ea532b05dfaebf7f20551317865f1c997fe" translate="yes" xml:space="preserve">
          <source>If dtype is not supplied, this specifies the field names for the output dtype, in order. The field dtypes will be the same as the input array.</source>
          <target state="translated">dtype이 제공되지 않으면 출력 dtype의 필드 이름을 순서대로 지정합니다. dtypes 필드는 입력 배열과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="1d0ca2bca36fd3ca611fb59e9f429be6ca1dfcef" translate="yes" xml:space="preserve">
          <source>If either &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; is 0-D (scalar), it is equivalent to &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt;&lt;code&gt;multiply&lt;/code&gt;&lt;/a&gt; and using &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; or &lt;code&gt;a * b&lt;/code&gt; is preferred.</source>
          <target state="translated">어느 경우 또는 &lt;code&gt;b&lt;/code&gt; 는 0 D (라), 그것과 동등하다 &lt;a href=&quot;numpy.multiply#numpy.multiply&quot;&gt; &lt;code&gt;multiply&lt;/code&gt; &lt;/a&gt; 및 사용 &lt;code&gt;numpy.multiply(a, b)&lt;/code&gt; 또는 &lt;code&gt;a * b&lt;/code&gt; 바람직하다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="849e7230439a12b395b3d9d948e074f889418b25" translate="yes" xml:space="preserve">
          <source>If either argument is N-D, N &amp;gt; 2, it is treated as a stack of matrices residing in the last two indexes and broadcast accordingly.</source>
          <target state="translated">인수 중 하나가 ND, N&amp;gt; 2 인 경우, 마지막 두 인덱스에 상주하는 행렬의 스택으로 취급되어 그에 따라 브로드 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="cc8e18e241d0267fb4cce88d0332bc823b722b5a" translate="yes" xml:space="preserve">
          <source>If either array contains one or more NaNs, False is returned. Infs are treated as equal if they are in the same place and of the same sign in both arrays.</source>
          <target state="translated">배열에 하나 이상의 NaN이 포함되어 있으면 False가 반환됩니다. Infs는 두 배열에서 같은 위치에 있고 같은 부호를 가진다면 동일하게 취급됩니다.</target>
        </trans-unit>
        <trans-unit id="281de8e5c6dae1e0aea9ae6d89d002bae88a2963" translate="yes" xml:space="preserve">
          <source>If element has complex type with zero complex part, the return value for that element is True.</source>
          <target state="translated">요소의 복소수가 0 인 복소수 유형 인 경우 해당 요소의 리턴 값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="5d17dff94d5eaef97820ea5c6ea029508947d3b9" translate="yes" xml:space="preserve">
          <source>If factoring fails.</source>
          <target state="translated">팩토링이 실패하는 경우.</target>
        </trans-unit>
        <trans-unit id="d31081e35606566d9542bf752ae043c7bb856921" translate="yes" xml:space="preserve">
          <source>If file is a string or a path-like object then that file is opened, else it is assumed to be a file object. The file object must support random access (i.e. it must have tell and seek methods).</source>
          <target state="translated">파일이 문자열 또는 경로와 유사한 객체 인 경우 해당 파일이 열리면 파일 객체 인 것으로 간주됩니다. 파일 객체는 랜덤 액세스를 지원해야합니다 (즉, tell 및 seek 메소드가 있어야 함).</target>
        </trans-unit>
        <trans-unit id="c92c0b980c98427841fd06fc2e90c17e3f8c8cf4" translate="yes" xml:space="preserve">
          <source>If filters are added and the &lt;code&gt;module&lt;/code&gt; keyword is given, the warning registry of this module will additionally be cleared when applying it, entering the context, or exiting it. This could cause warnings to appear a second time after leaving the context if they were configured to be printed once (default) and were already printed before the context was entered.</source>
          <target state="translated">필터가 추가되고 &lt;code&gt;module&lt;/code&gt; 키워드가 제공되면이 모듈의 경고 레지스트리는 적용, 컨텍스트 입력 또는 종료시 추가로 지워집니다. 이로 인해 컨텍스트가 한 번 인쇄되도록 구성되고 (기본값) 컨텍스트가 입력되기 전에 이미 인쇄 된 경우 컨텍스트를 떠난 후 경고가 두 번째로 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="aa86a09a4bd6f04a9393e4d4dd4d45d0b7a047d8" translate="yes" xml:space="preserve">
          <source>If formats is None, then this will auto-detect formats. Use list of tuples rather than list of lists for faster processing.</source>
          <target state="translated">형식이 없음이면 형식이 자동 감지됩니다. 빠른 처리를 위해 목록 목록 대신 튜플 목록을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="e7cf286f1082970c195a5ac9a9af060a6972f46c" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/dof, where dof = M - (deg + 1), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">주어진하지 않으면 &lt;code&gt;False&lt;/code&gt; , 추정뿐만 아니라 자사의 공분산 행렬 단지를 반환합니다. 기본적으로 공분산은 chi2 / dof에 의해 스케일링됩니다. 이 스케일링은 &lt;code&gt;cov='unscaled'&lt;/code&gt; 인 경우 생략됩니다. 이는 가중치가 1 / sigma ** 2이고 sigma가 불확실성의 신뢰할 수있는 추정치로 알려진 경우와 관련이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9c65522b5d0c56fc6284329915c9ff282e0a064e" translate="yes" xml:space="preserve">
          <source>If given and not &lt;code&gt;False&lt;/code&gt;, return not just the estimate but also its covariance matrix. By default, the covariance are scaled by chi2/sqrt(N-dof), i.e., the weights are presumed to be unreliable except in a relative sense and everything is scaled such that the reduced chi2 is unity. This scaling is omitted if &lt;code&gt;cov='unscaled'&lt;/code&gt;, as is relevant for the case that the weights are 1/sigma**2, with sigma known to be a reliable estimate of the uncertainty.</source>
          <target state="translated">&lt;code&gt;False&lt;/code&gt; 가 아니라 주어진 경우 추정값뿐만 아니라 공분산 행렬도 반환합니다. 공분산은 기본적으로 chi2 / sqrt (N-dof)로 스케일링됩니다. 즉, 상대적 의미를 제외하고 가중치는 신뢰할 수없는 것으로 추정되며 감소 된 chi2가 단일하도록 모든 것이 스케일됩니다. 이 스케일링은 가중치가 1 / sigma ** 2 인 경우와 관련하여 sivma가 불확실성의 신뢰할 수있는 추정치 인 것으로 알려진 &lt;code&gt;cov='unscaled'&lt;/code&gt; 인 경우 생략됩니다 .</target>
        </trans-unit>
        <trans-unit id="4a01bcc692f66d3a6d58bd9dd10d9c51e6240bfa" translate="yes" xml:space="preserve">
          <source>If given, any string of the form &lt;code&gt;@key@&lt;/code&gt; will be replaced by &lt;code&gt;subst_dict[key]&lt;/code&gt; in the template file when installed. The install prefix is always available through the variable &lt;code&gt;@prefix@&lt;/code&gt;, since the install prefix is not easy to get reliably from setup.py.</source>
          <target state="translated">제공된 경우 &lt;code&gt;@key@&lt;/code&gt; 형식의 문자열은 설치시 템플릿 파일에서 &lt;code&gt;subst_dict[key]&lt;/code&gt; 로 바뀝니다 . 설치 접두사는 setup.py에서 안정적으로 얻기 쉽지 않기 때문에 항상 &lt;code&gt;@prefix@&lt;/code&gt; 변수를 통해 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f229986316849fc58c19699184e093af0322102f" translate="yes" xml:space="preserve">
          <source>If given, should be a sequence of additional directories where to look for npy-pkg-config files. Those directories are searched prior to the NumPy directory.</source>
          <target state="translated">주어진 경우 npy-pkg-config 파일을 찾을 추가 디렉토리 시퀀스 여야합니다. 이러한 디렉토리는 NumPy 디렉토리보다 먼저 검색됩니다.</target>
        </trans-unit>
        <trans-unit id="282b0a219b18c48a317e72503d2100cde36f84f8" translate="yes" xml:space="preserve">
          <source>If given, the array must be of the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the domain. If None is given then the class domain is used. The default is None.</source>
          <target state="translated">주어진 경우 배열은 &lt;code&gt;[beg, end]&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;beg&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 도메인의 끝점입니다. None이 주어지면 클래스 도메인이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="0dd507ea0f76e3b5e94e32d9b92c028c04854d11" translate="yes" xml:space="preserve">
          <source>If given, the resulting array must be if the form &lt;code&gt;[beg, end]&lt;/code&gt;, where &lt;code&gt;beg&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; are the endpoints of the window. If None is given then the class window is used. The default is None.</source>
          <target state="translated">주어진 경우, 결과 배열은 &lt;code&gt;[beg, end]&lt;/code&gt; 형식이어야합니다 . 여기서 &lt;code&gt;beg&lt;/code&gt; 및 &lt;code&gt;end&lt;/code&gt; 는 창의 끝점입니다. None이 주어지면 클래스 창이 사용됩니다. 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="d16d5189bfa0fff58db67c1477d4b5ae0a2a03f6" translate="yes" xml:space="preserve">
          <source>If given, this is returned for objects whose types can not be determined. If not given, None is returned for those objects.</source>
          <target state="translated">주어진 경우, 유형을 판별 할 수없는 오브젝트에 대해 리턴됩니다. 지정하지 않으면 해당 오브젝트에 대해 없음이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="a5160dd116d677ef1f0e36c955a207aad3b93f5a" translate="yes" xml:space="preserve">
          <source>If given, this is the destinaton of the shuffled array. If &lt;code&gt;out&lt;/code&gt; is None, a shuffled copy of the array is returned.</source>
          <target state="translated">주어진 경우, 이것은 셔플 된 배열의 대상입니다. 경우 &lt;code&gt;out&lt;/code&gt; 없음입니다, 배열의 단행 사본이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="4c9471fb7a9f3abaf682e7276b2ee9a3f16f1ed9" translate="yes" xml:space="preserve">
          <source>If input array &lt;code&gt;a&lt;/code&gt; is not 2D.</source>
          <target state="translated">입력 배열 &lt;code&gt;a&lt;/code&gt; 가 2D가 아닌 경우</target>
        </trans-unit>
        <trans-unit id="03697161ee2c8ff90aa05356bdc85cfdd7ffe30e" translate="yes" xml:space="preserve">
          <source>If input is complex with all imaginary parts close to zero, return real parts.</source>
          <target state="translated">입력이 모든 허수 부가 0에 가까워 복잡한 경우 실수 부를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f96f22e66784df0c0e7c7e7a77f909c0ac407de2" translate="yes" xml:space="preserve">
          <source>If input is the wrong shape (the input must be a 1-D or square 2-D array).</source>
          <target state="translated">입력이 잘못된 모양 인 경우 (입력은 1D 또는 사각형 2D 배열이어야합니다).</target>
        </trans-unit>
        <trans-unit id="c9a78f52b99ab1c1f8aad79c5f4b73ab06b85a94" translate="yes" xml:space="preserve">
          <source>If instead, we replace our &lt;code&gt;super&lt;/code&gt; call with &lt;code&gt;getattr(ufunc, method)&lt;/code&gt;, we effectively do &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt;. Again, &lt;code&gt;B.__array_ufunc__&lt;/code&gt; will be called, but now it sees an &lt;code&gt;ndarray&lt;/code&gt; as the other argument. Likely, it will know how to handle this, and return a new instance of the &lt;code&gt;B&lt;/code&gt; class to us. Our example class is not set up to handle this, but it might well be the best approach if, e.g., one were to re-implement &lt;code&gt;MaskedArray&lt;/code&gt; using &lt;code&gt;__array_ufunc__&lt;/code&gt;.</source>
          <target state="translated">대신 &lt;code&gt;super&lt;/code&gt; 호출을 &lt;code&gt;getattr(ufunc, method)&lt;/code&gt; &lt;code&gt;np.add(a.view(np.ndarray), b)&lt;/code&gt; 효과적으로 수행 합니다. 다시 &lt;code&gt;B.__array_ufunc__&lt;/code&gt; 가 호출되지만 이제 &lt;code&gt;ndarray&lt;/code&gt; 가 다른 인수로 간주 됩니다. 아마도이를 처리하는 방법을 알고 &lt;code&gt;B&lt;/code&gt; 클래스 의 새 인스턴스 를 우리에게 반환 할 것입니다. 우리의 예제 클래스는 이것을 처리하도록 설정되지 않았지만, 예를 들어 &lt;code&gt;MaskedArray&lt;/code&gt; 사용하여 &lt;code&gt;__array_ufunc__&lt;/code&gt; 를 다시 구현하는 경우 가장 좋은 방법 일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="570a12b7ce63be7a2ce71fba3d8c9da77deb9d9d" translate="yes" xml:space="preserve">
          <source>If int, the number of bins for the two dimensions (nx=ny=bins).</source>
          <target state="translated">int 인 경우 2 차원의 구간 수 (nx = ny = bins)입니다.</target>
        </trans-unit>
        <trans-unit id="f4fb4d5bcb48df147e2cef0a0ea5928ac8067b9e" translate="yes" xml:space="preserve">
          <source>If it becomes necessary for the Steering Council to produce a formal decision, then they will use a form of the &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation voting process&lt;/a&gt;. This is a formalized version of consensus, in which +1 votes indicate agreement, -1 votes are vetoes (and must be accompanied with a rationale, as above), and one can also vote fractionally (e.g. -0.5, +0.5) if one wishes to express an opinion without registering a full veto. These numeric votes are also often used informally as a way of getting a general sense of people&amp;rsquo;s feelings on some issue, and should not normally be taken as formal votes. A formal vote only occurs if explicitly declared, and if this does occur then the vote should be held open for long enough to give all interested Council Members a chance to respond &amp;ndash; at least one week.</source>
          <target state="translated">운영위원회가 공식적인 결정을 내릴 필요가 생기면 &lt;a href=&quot;https://www.apache.org/foundation/voting.html&quot;&gt;Apache Foundation 투표 프로세스&lt;/a&gt; 형식을 사용합니다 . 이것은 공식화 된 합의 버전으로, +1 표는 동의를 나타내며, -1 표는 거부권 (위와 같이 근거가 있어야 함)이며, 한 사람은 부분적으로 (예 : -0.5, +0.5) 투표 할 수도 있습니다. 완전한 거부권을 등록하지 않고 의견을 표명하고자합니다. 이러한 숫자 투표는 종종 어떤 문제에 대한 사람들의 감정을 전반적으로 이해하는 방법으로 비공식적으로 사용되며 일반적으로 공식 투표로 간주해서는 안됩니다. 공식 투표는 명시 적으로 선언 된 경우에만 발생하며, 이것이 발생하면 관심있는 모든 자문위원이 응답 할 수있는 충분한 시간 (최소 1 주일) 동안 투표를 열어 두어야합니다.</target>
        </trans-unit>
        <trans-unit id="46b4bbe660909db346ad59c7951f05bdd8332431" translate="yes" xml:space="preserve">
          <source>If it is necessary to explain a private method (use with care!), it can be referred to in the &lt;strong&gt;Extended Summary&lt;/strong&gt; or the &lt;strong&gt;Notes&lt;/strong&gt; section. Do not list private methods in the &lt;strong&gt;methods&lt;/strong&gt; section.</source>
          <target state="translated">사적인 방법을 설명 할 필요가있는 경우 (주의해서 사용하십시오!), &lt;strong&gt;확장 요약&lt;/strong&gt; 또는 &lt;strong&gt;참고&lt;/strong&gt; 섹션 에서 참조 할 수 있습니다 . &lt;strong&gt;메소드&lt;/strong&gt; 섹션 에 개인 메소드를 나열하지 마십시오 .</target>
        </trans-unit>
        <trans-unit id="c2941a8c3ef7e42aa1704dd826466efd7a289a13" translate="yes" xml:space="preserve">
          <source>If it is not necessary to specify a keyword argument, use &lt;code&gt;optional&lt;/code&gt;:</source>
          <target state="translated">키워드 인수를 지정할 필요가 없으면 &lt;code&gt;optional&lt;/code&gt; 을 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="14206cf495608dab3bc0c9563f466018da9e1b11" translate="yes" xml:space="preserve">
          <source>If it went wrong, recovery is again possible as explained &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;above&lt;/a&gt;.</source>
          <target state="translated">문제가 발생한 경우 &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;위에서&lt;/a&gt; 설명한 대로 복구가 다시 가능합니다 .</target>
        </trans-unit>
        <trans-unit id="3a1bd74933e0b346982972b3334dd2af53c8b3cb" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored file names are arr_0, arr_1, etc.</source>
          <target state="translated">키워드 인수가 제공되면 파일 이름이 키워드에서 가져옵니다. 키워드없이 인수를 전달하면 저장된 파일 이름은 arr_0, arr_1 등입니다.</target>
        </trans-unit>
        <trans-unit id="a05e5457e182b0de28998599a17f81c2384bc52a" translate="yes" xml:space="preserve">
          <source>If keyword arguments are given, then filenames are taken from the keywords. If arguments are passed in with no keywords, then stored filenames are arr_0, arr_1, etc.</source>
          <target state="translated">키워드 인수가 제공되면 키워드에서 파일 이름을 가져옵니다. 인수가 키워드없이 전달되면 저장된 파일 이름은 arr_0, arr_1 등입니다.</target>
        </trans-unit>
        <trans-unit id="68f5690b1b20b80392957d2cc602580121727a3e" translate="yes" xml:space="preserve">
          <source>If list depths are mismatched - for instance, &lt;code&gt;[[a, b], c]&lt;/code&gt; is illegal, and should be spelt &lt;code&gt;[[a, b], [c]]&lt;/code&gt;</source>
          <target state="translated">예를 들어, &lt;code&gt;[[a, b], c]&lt;/code&gt; 와 같이 목록 깊이가 일치하지 않으면 &lt;code&gt;[[a, b], [c]]&lt;/code&gt; 철자를 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f609da24233a507af66f8b7969941dc9c31d8838" translate="yes" xml:space="preserve">
          <source>If lists are empty - for instance, &lt;code&gt;[[a, b], []]&lt;/code&gt;</source>
          <target state="translated">목록이 비어있는 경우 (예 : &lt;code&gt;[[a, b], []]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0fa6317253cb5f3105874e72d36c2e7ed1eb2af" translate="yes" xml:space="preserve">
          <source>If multi-dimension input, returns a new ndarray of indices to the minimum values along the given axis. Otherwise, returns a scalar of index to the minimum values along the given axis.</source>
          <target state="translated">다중 차원 입력 인 경우 지정된 축을 따라 새 인덱스의 ndarray를 최소값으로 반환합니다. 그렇지 않으면 주어진 축을 따라 인덱스의 스칼라를 최소값으로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="3be2da634ae4e1a50b6a61b6e2a72b4b4858161d" translate="yes" xml:space="preserve">
          <source>If necessary, will be flattened before the differences are taken.</source>
          <target state="translated">필요한 경우 차이가 발생하기 전에 평평해질 것입니다.</target>
        </trans-unit>
        <trans-unit id="301925ec926932bb64f4f4002e984f88f86a2131" translate="yes" xml:space="preserve">
          <source>If needed create a new C-structure to handle each instance of your type. A typical C-structure would be:</source>
          <target state="translated">필요한 경우 유형의 각 인스턴스를 처리 할 새 C 구조를 만듭니다. 일반적인 C 구조는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="0a3c8652ca0e3dccf381651d80f187b5ac1a5a74" translate="yes" xml:space="preserve">
          <source>If neither is defined, the C-API is declared to be &lt;code&gt;static void**&lt;/code&gt;, so it is only visible within the compilation unit that #includes numpy/arrayobject.h.</source>
          <target state="translated">둘 다 정의되지 않은 경우 C-API는 &lt;code&gt;static void**&lt;/code&gt; 선언 되므로 #includes numpy / arrayobject.h를 컴파일 유닛 내에서만 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="853b03d065feffbc6ac6731a7bbb396016c51c2b" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;__array_function__&lt;/code&gt; methods exists, NumPy will default to calling its own implementation, intended for use on NumPy arrays. This case arises, for example, when all array-like arguments are Python numbers or lists. (NumPy arrays do have a &lt;code&gt;__array_function__&lt;/code&gt; method, given below, but it always returns &lt;code&gt;NotImplemented&lt;/code&gt; if any argument other than a NumPy array subclass implements &lt;code&gt;__array_function__&lt;/code&gt;.)</source>
          <target state="translated">&lt;code&gt;__array_function__&lt;/code&gt; 메소드가 없으면 NumPy는 NumPy 배열에서 사용하기 위해 자체 구현을 호출하도록 기본 설정됩니다. 이 경우는 예를 들어 모든 배열과 같은 인수가 Python 숫자 또는 목록 인 경우에 발생합니다. (NumPy와 배열이 있습니까 &lt;code&gt;__array_function__&lt;/code&gt; 의 아래, 방법을, 그러나 항상 반환 &lt;code&gt;NotImplemented&lt;/code&gt; 의 다른 인수가 NumPy와 배열 서브 클래스 구현이보다 경우 &lt;code&gt;__array_function__&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="9e9935f1dd70f7a86b993ae6eeed6ce9464e1229" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; is specified, &lt;code&gt;intent(in)&lt;/code&gt; is assumed.</source>
          <target state="translated">인 &lt;code&gt;intent(in | inout | out | hide)&lt;/code&gt; 가 지정되지 않은 경우 인 &lt;code&gt;intent(in)&lt;/code&gt; 로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="505142361ce7d844b31c251e5147e86fce3849fd" translate="yes" xml:space="preserve">
          <source>If none of the inputs overrides the ufunc, then all output arrays will be passed to the &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; methods of the input (besides &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt;, and scalars) that defines it &lt;strong&gt;and&lt;/strong&gt; has the highest &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of any other input to the universal function. The default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of the ndarray is 0.0, and the default &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; of a subtype is 0.0. Matrices have &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt;&lt;code&gt;__array_priority__&lt;/code&gt;&lt;/a&gt; equal to 10.0.</source>
          <target state="translated">입력 중 어느 것도 모든 출력 어레이가 전달 될 ufunc 재정의 없으면 &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 입력 방법 (또한 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 및 스칼라)하도록 정의를 &lt;strong&gt;하고&lt;/strong&gt; 가장 갖고 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 범용 기능 다른 입력한다. &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 의 기본 __array_priority__ 는 0.0이고 하위 유형 의 기본 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 는 0.0입니다. 행렬의 &lt;a href=&quot;arrays.classes#numpy.class.__array_priority__&quot;&gt; &lt;code&gt;__array_priority__&lt;/code&gt; &lt;/a&gt; 는 10.0과 같습니다.</target>
        </trans-unit>
        <trans-unit id="96625db984c22cd52ed20b5b293895185469b2c4" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; normalization is by &lt;code&gt;(N - ddof)&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the number of observations; this overrides the value implied by &lt;code&gt;bias&lt;/code&gt;. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">그렇지 않으면 &lt;code&gt;None&lt;/code&gt; 정상화는 것입니다 &lt;code&gt;(N - ddof)&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; 은 관찰의 수이고; 이 값은 &lt;code&gt;bias&lt;/code&gt; 에 의해 암시 된 값보다 우선합니다 . 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="e98fcdb4d2a9bfdfbe2eeae9c39d82ef88da39fa" translate="yes" xml:space="preserve">
          <source>If not &lt;code&gt;None&lt;/code&gt; the default value implied by &lt;code&gt;bias&lt;/code&gt; is overridden. Note that &lt;code&gt;ddof=1&lt;/code&gt; will return the unbiased estimate, even if both &lt;code&gt;fweights&lt;/code&gt; and &lt;code&gt;aweights&lt;/code&gt; are specified, and &lt;code&gt;ddof=0&lt;/code&gt; will return the simple average. See the notes for the details. The default value is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">그렇지 않을 경우 &lt;code&gt;None&lt;/code&gt; 에 의해 암시 기본값 &lt;code&gt;bias&lt;/code&gt; 무시됩니다. 참고 &lt;code&gt;ddof=1&lt;/code&gt; 심지어 두 경우 공정한 평가를 반환합니다 &lt;code&gt;fweights&lt;/code&gt; 가 및 &lt;code&gt;aweights&lt;/code&gt; 가 지정되고, &lt;code&gt;ddof=0&lt;/code&gt; 단순 평균을 반환합니다. 자세한 내용은 참고 사항을 참조하십시오. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="fcf87e157fa41fe29ae78434e407f9e7ee68fcea" translate="yes" xml:space="preserve">
          <source>If not None, the keys should indicate the type(s) that the respective formatting function applies to. Callables should return a string. Types that are not specified (by their corresponding keys) are handled by the default formatters. Individual types for which a formatter can be set are:</source>
          <target state="translated">None이 아닌 경우 키는 각 형식 지정 기능이 적용되는 유형을 나타냅니다. 콜 러블은 문자열을 반환해야합니다. 해당 키로 지정되지 않은 유형은 기본 포맷터에서 처리합니다. 포맷터를 설정할 수있는 개별 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="bb477c8d5a32ba9dc9b4018fd2f3af6fa9009c49" translate="yes" xml:space="preserve">
          <source>If not None, the specified domain is used instead of that of the calling instance. It should be of the form &lt;code&gt;[beg,end]&lt;/code&gt;. The default is None which case the class domain is used.</source>
          <target state="translated">None이 아닌 경우, 지정된 도메인이 호출 인스턴스의 도메인 대신 사용됩니다. &lt;code&gt;[beg,end]&lt;/code&gt; 형식이어야합니다 . 기본값은 없음이며 클래스 도메인이 사용되는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="9fd5a8f72ea35597060cfb26a58e00837b4119cd" translate="yes" xml:space="preserve">
          <source>If not None, then memory-map the file, using the given mode (see &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt;&lt;code&gt;numpy.memmap&lt;/code&gt;&lt;/a&gt; for a detailed description of the modes). A memory-mapped array is kept on disk. However, it can be accessed and sliced like any ndarray. Memory mapping is especially useful for accessing small fragments of large files without reading the entire file into memory.</source>
          <target state="translated">None이 아니라면 주어진 모드를 사용하여 파일을 메모리에 매핑합니다 (참조 &lt;a href=&quot;numpy.memmap#numpy.memmap&quot;&gt; &lt;code&gt;numpy.memmap&lt;/code&gt; &lt;/a&gt;에 대한 자세한 설명 numpy.memmap). 메모리 매핑 된 어레이는 디스크에 보관됩니다. 그러나 ndarray와 같이 액세스하고 슬라이스 할 수 있습니다. 메모리 매핑은 전체 파일을 메모리로 읽지 않고 큰 파일의 작은 조각에 액세스하는 데 특히 유용합니다.</target>
        </trans-unit>
        <trans-unit id="1dde66b48fa13cf03c30ed219d07e5b09a8bd837" translate="yes" xml:space="preserve">
          <source>If obj is an ndarray (&lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject *&lt;/code&gt;&lt;/a&gt;), then the data-area of the ndarray is pointed to by the void* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt; (obj) or the char* pointer &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt;&lt;code&gt;PyArray_BYTES&lt;/code&gt;&lt;/a&gt; (obj). Remember that (in general) this data-area may not be aligned according to the data-type, it may represent byte-swapped data, and/or it may not be writeable. If the data area is aligned and in native byte-order, then how to get at a specific element of the array is determined only by the array of npy_intp variables, &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt;&lt;code&gt;PyArray_STRIDES&lt;/code&gt;&lt;/a&gt; (obj). In particular, this c-array of integers shows how many &lt;strong&gt;bytes&lt;/strong&gt; must be added to the current element pointer to get to the next element in each dimension. For arrays less than 4-dimensions there are &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj, &amp;hellip;) macros where {k} is the integer 1, 2, 3, or 4 that make using the array strides easier. The arguments &amp;hellip;. represent {k} non- negative integer indices into the array. For example, suppose &lt;code&gt;E&lt;/code&gt; is a 3-dimensional ndarray. A (void*) pointer to the element &lt;code&gt;E[i,j,k]&lt;/code&gt; is obtained as &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt;&lt;code&gt;PyArray_GETPTR3&lt;/code&gt;&lt;/a&gt; (E, i, j, k).</source>
          <target state="translated">obj가 ndarray ( &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject *&lt;/code&gt; &lt;/a&gt; )이면 ndarray 의 데이터 영역은 void * 포인터 &lt;a href=&quot;../reference/c-api/array#c.PyArray_DATA&quot;&gt; &lt;code&gt;PyArray_DATA&lt;/code&gt; &lt;/a&gt; (obj) 또는 char * 포인터 &lt;a href=&quot;../reference/c-api/array#c.PyArray_BYTES&quot;&gt; &lt;code&gt;PyArray_BYTES&lt;/code&gt; &lt;/a&gt; (obj)가 가리 킵니다 . (일반적으로)이 데이터 영역은 데이터 유형에 따라 정렬되지 않을 수 있고, 바이트 스왑 된 데이터를 나타낼 수 있으며, 쓰기가 불가능할 수 있습니다. 데이터 영역이 정렬되고 기본 바이트 순서로되어있는 경우 배열의 특정 요소를 가져 오는 방법은 npy_intp 변수의 배열 인 &lt;a href=&quot;../reference/c-api/array#c.PyArray_STRIDES&quot;&gt; &lt;code&gt;PyArray_STRIDES&lt;/code&gt; &lt;/a&gt; (obj)에 의해서만 결정됩니다 . 특히,이 정수의 c 배열은 각 차원의 다음 요소로 이동하기 위해 현재 요소 포인터에 추가해야하는 &lt;strong&gt;바이트&lt;/strong&gt; 수를 보여줍니다 . 4 차원 미만의 어레이에는 다음이 있습니다. &lt;code&gt;PyArray_GETPTR{k}&lt;/code&gt; (obj,&amp;hellip;) 매크로 여기서 {k}는 배열 스트라이드 사용을보다 쉽게 ​​해주는 정수 1, 2, 3 또는 4입니다. 논쟁&amp;hellip;. {k} 음이 아닌 정수 인덱스를 배열로 나타냅니다. 예를 들어 &lt;code&gt;E&lt;/code&gt; 가 3 차원 ndarray 라고 가정 합니다. 요소 &lt;code&gt;E[i,j,k]&lt;/code&gt; 대한 (void *) 포인터 는 &lt;a href=&quot;../reference/c-api/array#c.PyArray_GETPTR3&quot;&gt; &lt;code&gt;PyArray_GETPTR3&lt;/code&gt; &lt;/a&gt; (E, i, j, k) 로 얻습니다 .</target>
        </trans-unit>
        <trans-unit id="9280c1d0944bd8756c1f5111dc408efcc4ac592a" translate="yes" xml:space="preserve">
          <source>If offsets were specified using the optional &lt;code&gt;offsets&lt;/code&gt; key in the dictionary-based dtype specification, setting &lt;code&gt;align=True&lt;/code&gt; will check that each field&amp;rsquo;s offset is a multiple of its size and that the itemsize is a multiple of the largest field size, and raise an exception if not.</source>
          <target state="translated">사전 기반 dtype 사양에서 선택적 &lt;code&gt;offsets&lt;/code&gt; 키를 사용하여 오프셋을 지정한 경우 &lt;code&gt;align=True&lt;/code&gt; 를 설정 하면 각 필드의 오프셋이 해당 크기의 배수이고 항목 크기가 가장 큰 필드 크기의 배수인지 확인하고 예외가 발생합니다. 그렇지 않다면.</target>
        </trans-unit>
        <trans-unit id="7e8ee117c63f729e22bf227e3e07bb22de12fa90" translate="yes" xml:space="preserve">
          <source>If one argument: a scalar, only used in case &lt;code&gt;a&lt;/code&gt; is of size 1. If two arguments: the last argument is the value to be set and must be a scalar, the first argument specifies a single array element location. It is either an int or a tuple.</source>
          <target state="translated">하나의 인수가 스칼라 인 경우에만 사용됩니다. &lt;code&gt;a&lt;/code&gt; 의 크기가 1 인 경우 . 두 개의 인수 : 마지막 인수가 설정 될 값이고 스칼라 여야하는 경우 첫 번째 인수는 단일 배열 요소 위치를 지정합니다. int 또는 tuple입니다.</target>
        </trans-unit>
        <trans-unit id="57c6aeb84d68fcc852763a7a13de57615e4d20cf" translate="yes" xml:space="preserve">
          <source>If one does need to invoke a formal veto, then it should consist of:</source>
          <target state="translated">공식적인 거부권을 행사해야하는 경우 다음과 같이 구성되어야합니다.</target>
        </trans-unit>
        <trans-unit id="071afc2f1bb001ecc847b5f0833d4155cd8fca5d" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, which is not uncommon, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="translated">명령 중 하나가 중간에 중단되는 경우는 드물지 않습니다. PyPI에서는 동일한 파일을 두 번 업로드 할 수 없기 때문에 나머지 파일을 선택적으로 업로드해야 할 수 있습니다. pip 사용자가 처리 중에 파일에 액세스하는 경우 동기화 문제를 방지하려면 소스 파일을 마지막에 업로드해야합니다. PyPI는 단일 소스 배포 만 허용하므로 여기서는 zip 아카이브를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="6b366b75bdd6732eac035ef513f1831e74291371" translate="yes" xml:space="preserve">
          <source>If one of the commands breaks in the middle, you may need to selectively upload the remaining files because PyPI does not allow the same file to be uploaded twice. The source file should be uploaded last to avoid synchronization problems that might occur if pip users access the files while this is in process. Note that PyPI only allows a single source distribution, here we have chosen the zip archive.</source>
          <target state="translated">명령 중 하나가 중간에 중단되면 PyPI에서 동일한 파일을 두 번 업로드 할 수 없기 때문에 나머지 파일을 선택적으로 업로드해야 할 수 있습니다. pip 사용자가 처리 중에 파일에 액세스하는 경우 발생할 수있는 동기화 문제를 방지하려면 소스 파일을 마지막에 업로드해야합니다. PyPI는 단일 소스 배포 만 허용하므로 여기서는 zip 아카이브를 선택했습니다.</target>
        </trans-unit>
        <trans-unit id="6981fed895201194d2f8c788e92aaa4d462ed21a" translate="yes" xml:space="preserve">
          <source>If one of the input or output arguments has a &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; method, it is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc. If more than one of the arguments implements &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt;, they are tried in the order: subclasses before superclasses, inputs before outputs, otherwise left to right. The first routine returning something other than &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; determines the result. If all of the &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; operations return &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt; is raised.</source>
          <target state="translated">입력 또는 출력 인수 중 하나에 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 메소드 가 있으면 ufunc&lt;em&gt; 대신&lt;/em&gt; 실행 &lt;em&gt;됩니다&lt;/em&gt; . 둘 이상의 인수가 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; 를&lt;/a&gt; 구현 하면 수퍼 클래스 이전의 서브 클래스, 출력 이전의 입력, 그렇지 않으면 왼쪽에서 오른쪽으로 순서대로 시도됩니다. &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 이외의 것을 반환하는 첫 번째 루틴 이 결과를 결정합니다. 의 모든 경우 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 작업이 반환 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 을&lt;/a&gt; 하는&lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 발생합니다.</target>
        </trans-unit>
        <trans-unit id="078513303dc00f49a54bb48b4a05d01efff2507a" translate="yes" xml:space="preserve">
          <source>If one or more elements differ by more than &lt;code&gt;maxulp&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 요소가 &lt;code&gt;maxulp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00b891e47fe38237c020d297bb43b5693729c6dd" translate="yes" xml:space="preserve">
          <source>If one throws a die repeatedly until the third time a &amp;ldquo;1&amp;rdquo; appears, then the probability distribution of the number of non-&amp;ldquo;1&amp;rdquo;s that appear before the third &amp;ldquo;1&amp;rdquo; is a negative binomial distribution.</source>
          <target state="translated">세 번째에 &quot;1&quot;이 나타날 때까지 주사위를 반복해서 던지면 세 번째 &quot;1&quot;이전에 나타나는 &quot;1&quot;이 아닌 숫자의 확률 분포는 음의 이항 분포입니다.</target>
        </trans-unit>
        <trans-unit id="f25e55ccd77b879343ce3ca049a9d0e4b78987e8" translate="yes" xml:space="preserve">
          <source>If one uses the same dimension name in multiple locations, this enforces the same size of the corresponding dimensions.</source>
          <target state="translated">여러 위치에서 동일한 차원 이름을 사용하는 경우 동일한 크기의 해당 차원이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="341d0c5af878a988a0ac05e9410e510da00aae4c" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case &lt;a href=&quot;#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; must be used as a context manager or the &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt;&lt;code&gt;nditer.close&lt;/code&gt;&lt;/a&gt; method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">피연산자 플래그 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; 가 사용되는 경우 피연산자는 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그 를 사용하여 원래 데이터에 대한 뷰일 수 있습니다 . 이 경우 &lt;a href=&quot;#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 를 컨텍스트 관리자로 사용하거나 결과를 사용하기 전에 &lt;a href=&quot;numpy.nditer.close#numpy.nditer.close&quot;&gt; &lt;code&gt;nditer.close&lt;/code&gt; &lt;/a&gt; 메서드를 호출해야합니다. 임시 데이터는 &lt;code&gt;__exit__&lt;/code&gt; 함수가 호출 될 때 원래 데이터에 다시 기록 되지만 이전에는 기록되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9d0e3c2e03d57620541ba508399723e46a30af16" translate="yes" xml:space="preserve">
          <source>If operand flags &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; or &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; are used the operands may be views into the original data with the &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; flag. In this case nditer must be used as a context manager or the nditer.close method must be called before using the result. The temporary data will be written back to the original data when the &lt;code&gt;__exit__&lt;/code&gt; function is called but not before:</source>
          <target state="translated">피연산자 플래그 &lt;code&gt;&amp;ldquo;writeonly&amp;rdquo;&lt;/code&gt; 또는 &lt;code&gt;&amp;ldquo;readwrite&amp;rdquo;&lt;/code&gt; 를 사용하는 경우 피연산자는 &lt;code&gt;WRITEBACKIFCOPY&lt;/code&gt; 플래그 를 사용하여 원래 데이터를 볼 수 있습니다 . 이 경우 nditer를 컨텍스트 관리자로 사용하거나 결과를 사용하기 전에 nditer.close 메소드를 호출해야합니다. &lt;code&gt;__exit__&lt;/code&gt; 함수가 호출되었지만 이전이 아닌 임시 데이터는 원래 데이터에 다시 기록됩니다 .</target>
        </trans-unit>
        <trans-unit id="6bcdbb4b2db72f15cd471674f6106b51d73bea1c" translate="yes" xml:space="preserve">
          <source>If our array has more than two dimensions, then the SVD can be applied to all axes at once. However, the linear algebra functions in NumPy expect to see an array of the form &lt;code&gt;(N, M, M)&lt;/code&gt;, where the first axis represents the number of matrices.</source>
          <target state="translated">배열의 차원이 두 개 이상이면 SVD를 모든 축에 한 번에 적용 할 수 있습니다. 그러나 NumPy의 선형 대수 함수는 &lt;code&gt;(N, M, M)&lt;/code&gt; 형식의 배열을 볼 것으로 예상합니다 . 여기서 첫 번째 축은 행렬의 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="7979a86d632f406a43fda9a7bbc242f0b6aa48c1" translate="yes" xml:space="preserve">
          <source>If out is given and does not have a mask attribute, the mask of a is lost!</source>
          <target state="translated">out이 주어지고 마스크 속성이 없으면 a의 마스크가 손실됩니다!</target>
        </trans-unit>
        <trans-unit id="540ba134ebef3a60b12504ba1dddaea7cf0cec06" translate="yes" xml:space="preserve">
          <source>If passed a single ndarray or scalar (a nested list of depth 0), this is returned unmodified (and not copied).</source>
          <target state="translated">단일 ndarray 또는 스칼라 (깊이 0의 중첩 된 목록)를 전달하면 수정되지 않은 (복사되지 않은) 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="2ca82b5f657729109e0a486900feb42978dd8189" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">양의 int_like 인수가 제공되면 &lt;a href=&quot;#numpy.random.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 은 평균 0 및 분산 1의 일 변량 &quot;정규&quot;(가우스) 분포에서 샘플링 된 임의의 부동 소수점으로 채워진 모양 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 의 배열을 생성합니다 . 단일 부동 소수점 인수가 제공되지 않으면 분포에서 무작위로 샘플링 된 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="96808216b5aaeeafcea0d1c6dd5a1e0894eaaeca" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">양의 int_like 인수가 제공되면 &lt;a href=&quot;#numpy.random.mtrand.RandomState.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 은 평균 0 및 분산 1의 일 변량 &quot;정상&quot;(가우시안) 분포에서 샘플링 된 임의의 부동 소수점으로 채워진 모양 배열 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 생성합니다 . 단일 부동 인수가 제공되지 않으면 분포에서 무작위로 샘플링됩니다.</target>
        </trans-unit>
        <trans-unit id="6cd43f42d93868c2f881ad2d0e04b27cc3b3d230" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">양의 int_like 인수가 제공되면 &lt;a href=&quot;#numpy.random.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 은 평균 0 및 분산 1의 일 변량 &quot;정규&quot;(가우스) 분포에서 샘플링 된 임의의 부동 소수점으로 채워진 모양 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 의 배열을 생성합니다 . 단일 부동 소수점 인수가 제공되지 않으면 분포에서 무작위로 샘플링 된 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="bfcb0d73efeb90f5b4e3ce5ebdfcfa5192159dee" translate="yes" xml:space="preserve">
          <source>If positive int_like arguments are provided, &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt;&lt;code&gt;randn&lt;/code&gt;&lt;/a&gt; generates an array of shape &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;, filled with random floats sampled from a univariate &amp;ldquo;normal&amp;rdquo; (Gaussian) distribution of mean 0 and variance 1. A single float randomly sampled from the distribution is returned if no argument is provided.</source>
          <target state="translated">양의 int_like 인수가 제공되면 &lt;a href=&quot;numpy.random.randn#numpy.random.randn&quot;&gt; &lt;code&gt;randn&lt;/code&gt; &lt;/a&gt; 은 평균 0 및 분산 1의 일 변량 &quot;정규&quot;(가우스) 분포에서 샘플링 된 임의의 부동 소수점으로 채워진 모양 &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 의 배열을 생성합니다 . 단일 부동 소수점 인수가 제공되지 않으면 분포에서 무작위로 샘플링 된 값이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="55be54163f14c3cf436fe9e5956719fe1ba33eba" translate="yes" xml:space="preserve">
          <source>If provided, forces the calculation to use the data type specified. Note that you may have to also give a more liberal &lt;code&gt;casting&lt;/code&gt; parameter to allow the conversions. Default is None.</source>
          <target state="translated">제공된 경우 지정된 데이터 유형을 사용하도록 계산합니다. 더 자유로운 &lt;code&gt;casting&lt;/code&gt; 을해야 할 수도 있습니다.변환을 허용하기 위해 매개 변수를 . 기본값은 없음입니다.</target>
        </trans-unit>
        <trans-unit id="e083348afe334fd6151280febab9e53c63ddbb1c" translate="yes" xml:space="preserve">
          <source>If provided, is a list of ints or None for each operands. The list of axes for an operand is a mapping from the dimensions of the iterator to the dimensions of the operand. A value of -1 can be placed for entries, causing that dimension to be treated as &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt;&lt;code&gt;newaxis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공되는 경우 각 피연산자에 대한 정수 목록 또는 없음입니다. 피연산자의 축 목록은 반복자의 차원에서 피연산자의 차원으로의 맵핑입니다. 항목에 -1 값을 배치하면 해당 차원이 &lt;a href=&quot;../constants#numpy.newaxis&quot;&gt; &lt;code&gt;newaxis&lt;/code&gt; &lt;/a&gt; 로 처리됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5d381c2d7955b7fd1c70c985e306d9e2f555e38" translate="yes" xml:space="preserve">
          <source>If provided, one above the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;). If array-like, must contain integer values</source>
          <target state="translated">제공되는 경우, 분포에서 추출 할 가장 큰 (부호있는) 정수 위의 하나 ( &lt;code&gt;high=None&lt;/code&gt; 인 경우 동작은 위 참조 ). 배열과 같은 경우 정수 값을 포함해야합니다</target>
        </trans-unit>
        <trans-unit id="95838d6d878826fc55d5a3e35ced6032cc48a529" translate="yes" xml:space="preserve">
          <source>If provided, the calculation is done into this array.</source>
          <target state="translated">제공된 경우 계산은이 배열로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="ea0c1f6bb199f46cbf91a8a029c842a1c97612d0" translate="yes" xml:space="preserve">
          <source>If provided, the destination array will have this dtype. Cannot be provided together with &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">제공되는 경우 대상 배열은이 dtype을 갖습니다. &lt;code&gt;out&lt;/code&gt; 과 함께 제공 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="af1a016b36ff8a1ba521445122b451501db1dbf6" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what concatenate would have returned if no out argument were specified.</source>
          <target state="translated">제공된 경우 결과를 배치 할 대상입니다. out 인수가 지정되지 않은 경우 연결된 모양과 일치하는 모양이 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="c1c663fe8abb225f988d791716021ba47f8cdb72" translate="yes" xml:space="preserve">
          <source>If provided, the destination to place the result. The shape must be correct, matching that of what stack would have returned if no out argument were specified.</source>
          <target state="translated">제공된 경우 결과를 배치 할 대상입니다. out 인수가 지정되지 않은 경우 스택이 반환 한 것과 일치하는 형태가 정확해야합니다.</target>
        </trans-unit>
        <trans-unit id="f5316b9b72a00d5e03e3e99cc76713f526033f92" translate="yes" xml:space="preserve">
          <source>If provided, the largest (signed) integer to be drawn from the distribution (see above for behavior if &lt;code&gt;high=None&lt;/code&gt;).</source>
          <target state="translated">제공된 경우 분포에서 추출 할 가장 큰 부호있는 정수 ( &lt;code&gt;high=None&lt;/code&gt; 인 경우 동작 참조 ).</target>
        </trans-unit>
        <trans-unit id="9522e8e010639b210e9e797758ab5c3b994ee6ec" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">제공되는 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; 이어야&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="95c405f27ca318550aa8a5e9d68fd036459e5597" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and &lt;code&gt;dtype&lt;/code&gt;.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 &lt;code&gt;dtype&lt;/code&gt; 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="5aa5842b82d356df663381019439d99b6de6d45f" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 dtype이어야합니다.</target>
        </trans-unit>
        <trans-unit id="cb7c8c85e64a3a49b66549989ff45cf1e28fbfc9" translate="yes" xml:space="preserve">
          <source>If provided, the result will be inserted into this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">제공된 경우 결과가이 배열에 삽입됩니다. 적절한 모양과 dtype이어야합니다. 참고 것을 &lt;code&gt;out&lt;/code&gt; 항상 버퍼링 경우 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; 더 나은 성능을 위해 다른 모드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="81a5da5dc747b4213d85b5feaae67db0441d8c96" translate="yes" xml:space="preserve">
          <source>If provided, the result will be placed in this array. It should be of the appropriate shape and dtype. Note that &lt;code&gt;out&lt;/code&gt; is always buffered if &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt;; use other modes for better performance.</source>
          <target state="translated">제공된 경우 결과가이 배열에 배치됩니다. 적절한 모양과 dtype이어야합니다. 참고 것을 &lt;code&gt;out&lt;/code&gt; 항상 버퍼링 경우 &lt;code&gt;mode=&amp;rsquo;raise&amp;rsquo;&lt;/code&gt; ; 더 나은 성능을 위해 다른 모드를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="930ff5cfb0e50021c5f5a8e94b02d45dd7e7a78b" translate="yes" xml:space="preserve">
          <source>If provided, this array is filled with the result.</source>
          <target state="translated">제공된 경우이 배열은 결과로 채워집니다.</target>
        </trans-unit>
        <trans-unit id="11fa623532ff8e1a6968612e0395b44c20331e38" translate="yes" xml:space="preserve">
          <source>If set to False, the returned array will always be readonly. Otherwise it will be writable if the original array was. It is advisable to set this to False if possible (see Notes).</source>
          <target state="translated">False로 설정하면 반환 된 배열은 항상 읽기 전용입니다. 그렇지 않으면 원래 배열이면 쓸 수 있습니다. 가능하면이를 False로 설정하는 것이 좋습니다 (참고 사항 참조).</target>
        </trans-unit>
        <trans-unit id="2bff5e445257625fab4df9171fbb5cbef9e23081" translate="yes" xml:space="preserve">
          <source>If set to the string &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; enables 1.13 legacy printing mode. This approximates numpy 1.13 print output by including a space in the sign position of floats and different behavior for 0d arrays. If set to &lt;code&gt;False&lt;/code&gt;, disables legacy mode. Unrecognized strings will be ignored with a warning for forward compatibility.</source>
          <target state="translated">문자열 &lt;code&gt;&amp;lsquo;1.13&amp;rsquo;&lt;/code&gt; 하면 1.13 레거시 인쇄 모드가 활성화됩니다. 이것은 float의 부호 위치에 공백을 포함하고 0d 배열의 다른 동작으로 numpy 1.13 인쇄 출력과 비슷합니다. &lt;code&gt;False&lt;/code&gt; 로 설정 하면 레거시 모드가 비활성화됩니다. 인식 할 수없는 문자열은 앞으로 호환성에 대한 경고와 함께 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="fe72d8f764239876f5476ff64d033c4aa157117d" translate="yes" xml:space="preserve">
          <source>If slice notation is used, the syntax &lt;code&gt;start:stop:step&lt;/code&gt; is equivalent to &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; inside of the brackets. However, if &lt;code&gt;step&lt;/code&gt; is an imaginary number (i.e. 100j) then its integer portion is interpreted as a number-of-points desired and the start and stop are inclusive. In other words &lt;code&gt;start:stop:stepj&lt;/code&gt; is interpreted as &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; inside of the brackets. After expansion of slice notation, all comma separated sequences are concatenated together.</source>
          <target state="translated">슬라이스 표기법을 사용하는 경우 구문 &lt;code&gt;start:stop:step&lt;/code&gt; 은 괄호 안의 &lt;code&gt;np.arange(start, stop, step)&lt;/code&gt; 와 같습니다 . 그러나, &lt;code&gt;step&lt;/code&gt; 가 허수 (즉, 100j) 인 경우, 정수 부분은 원하는 수의 포인트로 해석되며 시작 및 중지는 포함됩니다. 즉, &lt;code&gt;start:stop:stepj&lt;/code&gt; 는 괄호 안에 &lt;code&gt;np.linspace(start, stop, step, endpoint=1)&lt;/code&gt; 로 해석 됩니다. 슬라이스 표기법의 확장 후, 모든 쉼표로 구분 된 시퀀스는 함께 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="d852188873e81a9c252d600a61b8e6669ecb8d51" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;a href=&quot;numpy.full#numpy.full&quot;&gt;&lt;code&gt;full&lt;/code&gt;&lt;/a&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아서 무시되면 (및 &lt;a href=&quot;numpy.full#numpy.full&quot;&gt; &lt;code&gt;full&lt;/code&gt; &lt;/a&gt; == &lt;code&gt;False&lt;/code&gt; ) &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt; 이 발생합니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 저차 다항식에 적합하면 일반적으로 경고가 제거됩니다 (물론 원하는 것이 아닐 수도 있습니다. 작동하지 않는 차수를 선택하는 독립적 인 이유가있는 경우 다음을 수행해야 할 수 있습니다. a) 이러한 이유를 재고하고 / 또는 b) 데이터의 품질을 재고합니다. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81a87ade0c2eb6eb2f3e1b57567f9837157177e2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected (and &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt;), a &lt;code&gt;RankWarning&lt;/code&gt; will be raised. This means that the coefficient values may be poorly determined. Fitting to a lower order polynomial will usually get rid of the warning (but may not be what you want, of course; if you have independent reason(s) for choosing the degree which isn&amp;rsquo;t working, you may have to: a) reconsider those reasons, and/or b) reconsider the quality of your data). The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아 무시되는 경우 (및 &lt;code&gt;full&lt;/code&gt; == &lt;code&gt;False&lt;/code&gt; ) &lt;code&gt;RankWarning&lt;/code&gt; 가 발생합니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 하위 다항식에 피팅하면 일반적으로 경고가 제거됩니다 (물론 원하는 것은 아닐 수도 있습니다. 작동하지 않는 정도를 선택하기위한 독립적 인 이유가있는 경우 : a) 그 이유를 재고하고 /하거나 b) 데이터 품질을 재고하십시오. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0219410592b277d18d42730ec323b9fe9d5cac7f" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt;&lt;code&gt;RankWarning&lt;/code&gt;&lt;/a&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아서 무시되는 경우 &lt;a href=&quot;numpy.rankwarning#numpy.RankWarning&quot;&gt; &lt;code&gt;RankWarning&lt;/code&gt; &lt;/a&gt; 이 발행됩니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 낮은 차수 맞춤을 사용하면 일반적으로 경고가 제거됩니다. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="279580d9404d9230f24c863b3bff92a3996533c2" translate="yes" xml:space="preserve">
          <source>If some of the singular values of &lt;code&gt;V&lt;/code&gt; are so small that they are neglected, then a &lt;code&gt;RankWarning&lt;/code&gt; will be issued. This means that the coefficient values may be poorly determined. Using a lower order fit will usually get rid of the warning. The &lt;code&gt;rcond&lt;/code&gt; parameter can also be set to a value smaller than its default, but the resulting fit may be spurious and have large contributions from roundoff error.</source>
          <target state="translated">&lt;code&gt;V&lt;/code&gt; 의 특이 값 중 일부 가 너무 작아 무시되는 경우 &lt;code&gt;RankWarning&lt;/code&gt; 이 발행됩니다. 이는 계수 값이 잘못 결정될 수 있음을 의미합니다. 낮은 차수를 사용하면 일반적으로 경고가 사라집니다. &lt;code&gt;rcond&lt;/code&gt; 의 매개 변수는 기본값보다 작은 값으로 설정 될 수 있지만, 결과 적합 스퓨리어스하고 반올림 오류에서 큰 기여를 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="965baa6e6f17f07c36f67c069da20d4c8b056bfe" translate="yes" xml:space="preserve">
          <source>If sparse is False:</source>
          <target state="translated">스파 스가 False 인 경우 :</target>
        </trans-unit>
        <trans-unit id="d3cfaef438df28358b3d4e747b777d350c839464" translate="yes" xml:space="preserve">
          <source>If sparse is True:</source>
          <target state="translated">스파 스가 참인 경우 :</target>
        </trans-unit>
        <trans-unit id="da499c4730990d0eca07f07d81ecedd5eee01e35" translate="yes" xml:space="preserve">
          <source>If sparse is set to true, the grid will be returned in a sparse representation.</source>
          <target state="translated">스파 스가 true로 설정된 경우 그리드는 스파 스 표현으로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="a0b2e0085e9bacd8c444b0a0e2e8508a5f8b81ab" translate="yes" xml:space="preserve">
          <source>If specified, all the fields will be changed to the provided byte-order. Otherwise, the default byte-order is used. For all available string specifiers, see &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt;&lt;code&gt;dtype.newbyteorder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">지정하면 모든 필드가 제공된 바이트 순서로 변경됩니다. 그렇지 않으면 기본 바이트 순서가 사용됩니다. 사용 가능한 모든 문자열 지정자에 대해서는 &lt;a href=&quot;numpy.dtype.newbyteorder#numpy.dtype.newbyteorder&quot;&gt; &lt;code&gt;dtype.newbyteorder&lt;/code&gt; 를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="524227865d52e8b4442de30061c3ce0262f46831" translate="yes" xml:space="preserve">
          <source>If specified, it must be a tuple or list which contains a permutation of [0,1,..,N-1] where N is the number of axes of a. The i&amp;rsquo;th axis of the returned array will correspond to the axis numbered &lt;code&gt;axes[i]&lt;/code&gt; of the input. If not specified, defaults to &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt;, which reverses the order of the axes.</source>
          <target state="translated">지정된 경우 [0,1, .., N-1]의 순열을 포함하는 튜플 또는 목록이어야합니다. 여기서 N은 a의 축 수입니다. 반환 된 배열의 i 번째 축은 입력 의 축 번호 &lt;code&gt;axes[i]&lt;/code&gt; 에 해당합니다. 지정되지 않은 경우 기본값은 &lt;code&gt;range(a.ndim)[::-1]&lt;/code&gt; 이며 축의 순서를 반대로합니다.</target>
        </trans-unit>
        <trans-unit id="f824fc5934f1c56555b7168823af2d5da98b5dab" translate="yes" xml:space="preserve">
          <source>If state is a dictionary, it is directly set using the BitGenerators &lt;code&gt;state&lt;/code&gt; property.</source>
          <target state="translated">state가 사전 인 경우 BitGenerators &lt;code&gt;state&lt;/code&gt; 속성을 사용하여 직접 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="8bed509b136f4d80f9b83488488a97c842996d12" translate="yes" xml:space="preserve">
          <source>If steps 1 and 2 are done correctly, compiling the release should not give a warning &amp;ldquo;API mismatch detect at the beginning of the build&amp;rdquo;.</source>
          <target state="translated">1 단계와 2 단계가 올바르게 완료되면 릴리스를 컴파일 할 때 &quot;빌드 시작시 API 불일치 감지&quot;라는 경고가 표시되지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ebc779ce22e3bc8704e258c3f6aa49989598231f" translate="yes" xml:space="preserve">
          <source>If the (deprecated) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or the &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flags are set, it has a different meaning, namely base is the array into which the current array will be copied upon copy resolution. This overloading of the base property for two functions is likely to change in a future version of NumPy.</source>
          <target state="translated">(더 이상 사용되지 않는) &lt;a href=&quot;#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 설정된 경우, 이는 다른 의미를 갖습니다. 즉 base는 복사 배열시 현재 배열이 복사 될 배열입니다. 이 두 함수에 대한 기본 속성의 오버로드는 향후 버전의 NumPy에서 변경 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cfe3d233f0d1b6d420d00f98b03a5ffbba4bbec2" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is a CObject, then the pointer must be a pointer to a function with the signature:</source>
          <target state="translated">는 IF &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; 의&lt;/a&gt; 속성이 CObject이며, 그 포인터는 서명 함수에 대한 포인터해야합니다 :</target>
        </trans-unit>
        <trans-unit id="b7883df78258ee376bc6906db165b3539bd009bc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt;&lt;code&gt;__array_finalize__&lt;/code&gt;&lt;/a&gt; attribute is not None nor a CObject, then it must be a Python method that takes the parent array as an argument (which could be None if there is no parent), and returns nothing. Errors in this method will be caught and handled.</source>
          <target state="translated">&lt;a href=&quot;../reference/arrays.classes#numpy.class.__array_finalize__&quot;&gt; &lt;code&gt;__array_finalize__&lt;/code&gt; &lt;/a&gt; 속성이 None도 CObject도 아닌 경우, 부모 배열을 인수로 취하고 (부모가없는 경우 None 일 수 있음) 아무것도 반환하지 않는 Python 메서드 여야합니다. 이 메서드의 오류가 포착되고 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="35bc1249e520730be2802640a0588a9755304660" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;../glossary#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">경우] &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체는 구조화 된 배열 &lt;a href=&quot;../glossary#term-field&quot;&gt;필드&lt;/a&gt; 배열의 사전과 같은, 문자열 배열을 인덱싱하여 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="6f501c2023177671c00839603f74082e5dd3d055" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object is a structured array the &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;fields&lt;/a&gt; of the array can be accessed by indexing the array with strings, dictionary-like.</source>
          <target state="translated">경우] &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체는 구조화 된 배열 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-field&quot;&gt;필드&lt;/a&gt; 배열의 사전과 같은, 문자열 배열을 인덱싱하여 액세스 될 수있다.</target>
        </trans-unit>
        <trans-unit id="0646be9a4620b324160297ec7386ae7d381a6d92" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;order&lt;/code&gt; keyword argument is specified. This behaviour is a bug in NumPy.</source>
          <target state="translated">경우 &lt;code&gt;order&lt;/code&gt; 키워드 인수가 지정됩니다. 이 동작은 NumPy의 버그입니다.</target>
        </trans-unit>
        <trans-unit id="95474ba24abf246463d023b7d37164eff549d001" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;width&lt;/code&gt; value is insufficient, it will be ignored, and &lt;code&gt;num&lt;/code&gt; will be returned in binary (&lt;code&gt;num&lt;/code&gt; &amp;gt; 0) or two&amp;rsquo;s complement (&lt;code&gt;num&lt;/code&gt; &amp;lt; 0) form with its width equal to the minimum number of bits needed to represent the number in the designated form. This behavior is deprecated and will later raise an error.</source>
          <target state="translated">상기 중간 &lt;code&gt;width&lt;/code&gt; 값이 불충분하고, 무시되며, &lt;code&gt;num&lt;/code&gt; 이진 (리턴한다 &lt;code&gt;num&lt;/code&gt; &amp;gt; 0) 또는 2의 보수 ( &lt;code&gt;num&lt;/code&gt; &amp;lt;0) 양식을 그것의 수를 나타내는 데 필요한 비트들의 최소 수와 동일한 폭 지정된 양식. 이 동작은 더 이상 사용되지 않으며 나중에 오류가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e55f68c7edc654033798e55316d9b9691f5ca17e" translate="yes" xml:space="preserve">
          <source>If the API has changed, increment the C_API_VERSION in setup_common.py. The API is unchanged only if any code compiled against the current API will be backward compatible with the last released NumPy version. Any changes to C structures or additions to the public interface will make the new API not backward compatible.</source>
          <target state="translated">API가 변경된 경우 setup_common.py에서 C_API_VERSION을 증가시킵니다. 현재 API에 대해 컴파일 된 코드가 마지막으로 출시 된 NumPy 버전과 역 호환되는 경우에만 API가 변경되지 않습니다. C 구조를 변경하거나 공용 인터페이스를 추가하면 새 API가 이전 버전과 호환되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e8d9f657403ca89274645800f9ef39c0a2acef7a" translate="yes" xml:space="preserve">
          <source>If the CPU feature is not supported by the user platform or compiler, it will be skipped rather than raising a fatal error.</source>
          <target state="translated">CPU 기능이 사용자 플랫폼 또는 컴파일러에서 지원되지 않는 경우 치명적인 오류가 발생하지 않고 건너 뜁니다.</target>
        </trans-unit>
        <trans-unit id="846345b681ee07e5dd05c26de91938c5750e96ed" translate="yes" xml:space="preserve">
          <source>If the C_API_VERSION in the first step has changed, or if the hash of the API has changed, the cversions.txt file needs to be updated. To check the hash, run the script numpy/core/cversions.py and note the API hash that is printed. If that hash does not match the last hash in numpy/core/code_generators/cversions.txt the hash has changed. Using both the appropriate C_API_VERSION and hash, add a new entry to cversions.txt. If the API version was not changed, but the hash differs, you will need to comment out the previous entry for that API version. For instance, in NumPy 1.9 annotations were added, which changed the hash, but the API was the same as in 1.8. The hash serves as a check for API changes, but it is not definitive.</source>
          <target state="translated">첫 번째 단계의 C_API_VERSION이 변경되었거나 API의 해시가 변경된 경우 cversions.txt 파일을 업데이트해야합니다. 해시를 확인하려면 numpy / core / cversions.py 스크립트를 실행하고 인쇄 된 API 해시를 기록해 둡니다. 해당 해시가 numpy / core / code_generators / cversions.txt의 마지막 해시와 일치하지 않으면 해시가 변경되었습니다. 적절한 C_API_VERSION과 해시를 모두 사용하여 cversions.txt에 새 항목을 추가합니다. API 버전이 변경되지 않았지만 해시가 다른 경우 해당 API 버전에 대한 이전 항목을 주석 처리해야합니다. 예를 들어 NumPy 1.9에서는 주석이 추가되어 해시가 변경되었지만 API는 1.8에서와 동일했습니다. 해시는 API 변경 사항을 확인하는 역할을하지만 확정적이지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="307258bcc851f5976aadd2f56343dad80fcf2a38" translate="yes" xml:space="preserve">
          <source>If the PR relates to any issues, you can add the text &lt;code&gt;xref gh-xxxx&lt;/code&gt; where &lt;code&gt;xxxx&lt;/code&gt; is the number of the issue to github comments. Likewise, if the PR solves an issue, replace the &lt;code&gt;xref&lt;/code&gt; with &lt;code&gt;closes&lt;/code&gt;, &lt;code&gt;fixes&lt;/code&gt; or any of the other flavors &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github accepts&lt;/a&gt;.</source>
          <target state="translated">PR이 문제와 관련된 경우 &lt;code&gt;xref gh-xxxx&lt;/code&gt; 텍스트를 추가 할 수 있습니다. 여기서 &lt;code&gt;xxxx&lt;/code&gt; 는 github 주석에 문제 번호입니다. 마찬가지로 PR이 문제를 해결하면 &lt;code&gt;xref&lt;/code&gt; 를 &lt;code&gt;closes&lt;/code&gt; , &lt;code&gt;fixes&lt;/code&gt; 또는 &lt;a href=&quot;https://help.github.com/en/articles/closing-issues-using-keywords&quot;&gt;github에서 허용&lt;/a&gt; 하는 다른 버전으로 대체하십시오 .</target>
        </trans-unit>
        <trans-unit id="049594537957d0705cc457b562940a40a3ed3347" translate="yes" xml:space="preserve">
          <source>If the SVD computation does not converge.</source>
          <target state="translated">SVD 계산이 수렴하지 않는 경우.</target>
        </trans-unit>
        <trans-unit id="532b7abf588e485b512986621b48cdfb34aabd33" translate="yes" xml:space="preserve">
          <source>If the Sphinx build issues a warning of the form &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt;, then that is what is happening. To avoid this problem, use the inline hyperlink form:</source>
          <target state="translated">Sphinx 빌드가 &lt;code&gt;WARNING: Unknown target name: &quot;example&quot;&lt;/code&gt; 형식의 경고 를 표시하면 바로 그런 것입니다. 이 문제를 방지하려면 인라인 하이퍼 링크 양식을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="64f36babe99dcf796b7778a9ef584cf09c04cb03" translate="yes" xml:space="preserve">
          <source>If the accessed field is a sub-array, the dimensions of the sub-array are appended to the shape of the result.</source>
          <target state="translated">액세스 한 필드가 하위 배열 인 경우 하위 배열의 크기가 결과 모양에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7e63ccdf53ce8ac8b2fb2a0fbc4aad1e23cbc4dc" translate="yes" xml:space="preserve">
          <source>If the accessed field is a subarray, the dimensions of the subarray are appended to the shape of the result:</source>
          <target state="translated">액세스 된 필드가 하위 배열이면 하위 배열의 차원이 결과 모양에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="ba28bd784223a2a08bea18d126c6d98be59cd057" translate="yes" xml:space="preserve">
          <source>If the accumulator is too small, overflow occurs:</source>
          <target state="translated">누산기가 너무 작은 경우 오버플로가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f2dce957332c62c691a49ddcc68e31de7ff97f8b" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">배열에 마스크가 없으면 &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 의 주소 가 반환됩니다. 이 주소는 일반적으로 메모리의 데이터에 가깝지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d51f2eaee63f2842d7a7119019788b97cb6ca340" translate="yes" xml:space="preserve">
          <source>If the array has no mask, the address of &lt;code&gt;nomask&lt;/code&gt; is returned. This address is typically not close to the data in memory:</source>
          <target state="translated">배열에 마스크가 없으면 &lt;code&gt;nomask&lt;/code&gt; 의 주소 가 반환됩니다. 이 주소는 일반적으로 메모리의 데이터에 가깝지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0e4bd5d4fdacecd1895716db48cb1cac490ae19c" translate="yes" xml:space="preserve">
          <source>If the array is not compatible with the new shape according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">NumPy의 방송 규칙에 따라 어레이가 새 모양과 호환되지 않는 경우</target>
        </trans-unit>
        <trans-unit id="1b3a1026c96ba9547fc879c6163e5467ed414876" translate="yes" xml:space="preserve">
          <source>If the axis argument isn&amp;rsquo;t passed, your 2D array will be flattened.</source>
          <target state="translated">축 인수가 전달되지 않으면 2D 배열이 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="9556db7609e9b52c8da71258e9ebc1e23d97b8b8" translate="yes" xml:space="preserve">
          <source>If the buffer has data that is not in machine byte-order, this should be specified as part of the data-type, e.g.:</source>
          <target state="translated">버퍼에 머신 바이트 순서가 아닌 데이터가있는 경우 데이터 유형의 일부로 지정해야합니다. 예 :</target>
        </trans-unit>
        <trans-unit id="707be1af574eabd0a2204881f5336941a1d0fb1f" translate="yes" xml:space="preserve">
          <source>If the columns have names, we can also select which columns to import by giving their name to the &lt;code&gt;usecols&lt;/code&gt; argument, either as a sequence of strings or a comma-separated string:</source>
          <target state="translated">열에 이름이있는 경우 &lt;code&gt;usecols&lt;/code&gt; 인수에 이름을 문자열 시퀀스 또는 쉼표로 구분 된 문자열로 지정하여 가져올 열을 선택할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a9172eee727e3bc5966a060de8a7a54e3be2870d" translate="yes" xml:space="preserve">
          <source>If the common data type is known ahead of time, don&amp;rsquo;t use this flag. Instead, set the requested dtype for all the operands.</source>
          <target state="translated">공통 데이터 유형을 미리 알고 있으면이 플래그를 사용하지 마십시오. 대신, 모든 피연산자에 요청 된 dtype을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="c0b42d9b2195e628dbcfcb8e55fe0f75a169d8db" translate="yes" xml:space="preserve">
          <source>If the condition is a callable, it is used at runtime to dynamically make the decision. This is useful for tests that may require costly imports, to delay the cost until the test suite is actually executed.</source>
          <target state="translated">조건이 호출 가능한 경우 런타임에 동적으로 결정을 내리는 데 사용됩니다. 이는 테스트 스위트가 실제로 실행될 때까지 비용을 지연시키기 위해 값 비싼 가져 오기가 필요한 테스트에 유용합니다.</target>
        </trans-unit>
        <trans-unit id="da8929bf843323251f47496e7bd27572472297dd" translate="yes" xml:space="preserve">
          <source>If the conversion is not possible</source>
          <target state="translated">변환이 불가능한 경우</target>
        </trans-unit>
        <trans-unit id="bf41eeaf999250f9cdaa16bd479da6c16a96c8f5" translate="yes" xml:space="preserve">
          <source>If the ctypes module is not available, then the ctypes attribute of array objects still returns something useful, but ctypes objects are not returned and errors may be raised instead. In particular, the object will still have the &lt;code&gt;as_parameter&lt;/code&gt; attribute which will return an integer equal to the data attribute.</source>
          <target state="translated">ctypes 모듈을 사용할 수없는 경우 배열 객체의 ctypes 속성은 여전히 ​​유용한 것을 반환하지만 ctypes 객체는 반환되지 않으며 대신 오류가 발생할 수 있습니다. 특히 객체에는 여전히 &lt;code&gt;as_parameter&lt;/code&gt; 속성이 있으며이 속성은 data 속성과 동일한 정수를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="882469c86c3e266d61a4e68ca724a4e1e6d70bb9" translate="yes" xml:space="preserve">
          <source>If the current domain is the interval &lt;code&gt;[l1, r1]&lt;/code&gt; and the window is &lt;code&gt;[l2, r2]&lt;/code&gt;, then the linear mapping function &lt;code&gt;L&lt;/code&gt; is defined by the equations:</source>
          <target state="translated">현재 도메인이 구간 &lt;code&gt;[l1, r1]&lt;/code&gt; 이고 윈도우가 &lt;code&gt;[l2, r2]&lt;/code&gt; 인 경우 선형 맵핑 함수 &lt;code&gt;L&lt;/code&gt; 은 다음 방정식으로 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="4ed8629dcca88646587124e3779205aed8a1ff8c" translate="yes" xml:space="preserve">
          <source>If the data or the mode is invalid.</source>
          <target state="translated">데이터 또는 모드가 유효하지 않은 경우.</target>
        </trans-unit>
        <trans-unit id="74cde2bcb160b06069d73cce52e519943212158c" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">데이터 유형이 &lt;a href=&quot;../glossary#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 인 경우 다른 데이터 유형의 집합 ( &lt;em&gt;예 :&lt;/em&gt; 정수 및 부동 소수점으로 구성된 배열 항목 설명),</target>
        </trans-unit>
        <trans-unit id="b7e4177a6acaf9fb51b7f55a4c29b9a1f7f66006" translate="yes" xml:space="preserve">
          <source>If the data type is &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, an aggregate of other data types, (&lt;em&gt;e.g.&lt;/em&gt;, describing an array item consisting of an integer and a float),</source>
          <target state="translated">데이터 유형이 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 인 경우 다른 데이터 유형의 집계 ( &lt;em&gt;예 :&lt;/em&gt; 정수 및 부동 소수점으로 구성된 배열 항목 설명)</target>
        </trans-unit>
        <trans-unit id="0cecddf950b77d1003b9474189d29ff0bfdb6282" translate="yes" xml:space="preserve">
          <source>If the data type is a sub-array, what is its shape and data type.</source>
          <target state="translated">데이터 유형이 하위 배열 인 경우 해당 모양 및 데이터 유형은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="5b7ff57105753a62bcfc1055c91f35344e435758" translate="yes" xml:space="preserve">
          <source>If the decomposition fails, for example, if &lt;code&gt;a&lt;/code&gt; is not positive-definite.</source>
          <target state="translated">예를 들어, 분해가 실패 &lt;code&gt;a&lt;/code&gt; 경우 a 가 양의 한정이 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="ee52413e2abf8d484ea3208ee7d3358a43d8e634" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.all&quot;&gt;&lt;code&gt;all&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;#numpy.all&quot;&gt; &lt;code&gt;all&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="206ca5be0da6c825b1f0142de708ea22958f4d55" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amax&quot;&gt;&lt;code&gt;amax&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">디폴트 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 가 받는 통과되지 &lt;a href=&quot;#numpy.amax&quot;&gt; &lt;code&gt;amax&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f05780b3efb83cb7999e12324775e7fa0e8c55fe" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.amin&quot;&gt;&lt;code&gt;amin&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가&lt;a href=&quot;#numpy.amin&quot;&gt; &lt;code&gt;amin&lt;/code&gt; &lt;/a&gt; 서브 클래스의 메소드&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bb758877f868372bd36b970799d233d6c9b6b2e" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.any&quot;&gt;&lt;code&gt;any&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가&lt;a href=&quot;#numpy.any&quot;&gt; &lt;code&gt;any&lt;/code&gt; &lt;/a&gt; 의 서브 클래스의 메소드 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4f36bf742dff79ee7a2535335e60a655538367af" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가&lt;a href=&quot;#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;code&gt;ndarray&lt;/code&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e936312beb89ed94ea31f46b832a3128132ea8c3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가 &lt;a href=&quot;#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 으로 전달되지 않습니다. 하위 클래스의 메소드&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="cccfcc112e296f9db67affb5426a407a1e1b1ab3" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.prod&quot;&gt;&lt;code&gt;prod&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 가 &lt;a href=&quot;#numpy.prod&quot;&gt; &lt;code&gt;prod&lt;/code&gt; &lt;/a&gt; 로 전달되지 않습니다. 하위 클래스의 메소드&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f6aec8996590d19051796274c83c4f7439695ce8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.ptp&quot;&gt;&lt;code&gt;ptp&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.ptp&quot;&gt; &lt;code&gt;ptp&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="04b4fba4bb9497e64959763e9e88bb419b385930" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.std&quot;&gt;&lt;code&gt;std&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.std&quot;&gt; &lt;code&gt;std&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3ec6e98470abd2d3a8abe5e8029889dd09ba623f" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나 비 디폴트 값이 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2d09798a597d9e0c839ab8917b5d5016554acbc8" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본값이 전달되면 &lt;code&gt;keepdims&lt;/code&gt; 는 하위 클래스의 &lt;a href=&quot;#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; &lt;/a&gt; 메소드 로 전달되지 않습니다.&lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="83795d27b8fbf6727fc73ba1d3ba1433b7f48097" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;code&gt;ndarray&lt;/code&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;numpy.ma.var#numpy.ma.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;code&gt;ndarray&lt;/code&gt; 그러나이 아닌 디폴트 값은 될 것이다. 서브 클래스의 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="3a3ccfe6612fdaf74f2303bcfe7218060615e3b7" translate="yes" xml:space="preserve">
          <source>If the default value is passed, then &lt;code&gt;keepdims&lt;/code&gt; will not be passed through to the &lt;a href=&quot;numpy.var#numpy.var&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, however any non-default value will be. If the sub-class&amp;rsquo; method does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">기본 값이 전달되면, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되지 않습니다 &lt;a href=&quot;numpy.var#numpy.var&quot;&gt; &lt;code&gt;var&lt;/code&gt; 에&lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 그러나이 아닌 디폴트 값은 될 것이다. 하위 클래스의 메서드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f36f9bb6a297ac4fc949ef700d42398954026ba5" translate="yes" xml:space="preserve">
          <source>If the dimension of &lt;code&gt;a&lt;/code&gt; is less than 2.</source>
          <target state="translated">치수가 &lt;code&gt;a&lt;/code&gt; 는 2 이하이다.</target>
        </trans-unit>
        <trans-unit id="a923921d01ae62bb1aaf773e7e11bc37201f68aa" translate="yes" xml:space="preserve">
          <source>If the discontinuity in &lt;code&gt;p&lt;/code&gt; is smaller than &lt;code&gt;pi&lt;/code&gt;, but larger than &lt;code&gt;discont&lt;/code&gt;, no unwrapping is done because taking the 2*pi complement would only make the discontinuity larger.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 의 불연속성 이 &lt;code&gt;pi&lt;/code&gt; 보다 작은 경우 보다 &lt;code&gt;discont&lt;/code&gt; 보다 큰 경우 2 * pi 보수를 사용하면 불연속성이 더 커지므로 언 래핑이 수행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="dd1746ba40294ba18df6698853992dfa2b70977c" translate="yes" xml:space="preserve">
          <source>If the dtypes of two void structured arrays are equal, testing the equality of the arrays will result in a boolean array with the dimensions of the original arrays, with elements set to &lt;code&gt;True&lt;/code&gt; where all fields of the corresponding structures are equal. Structured dtypes are equal if the field names, dtypes and titles are the same, ignoring endianness, and the fields are in the same order:</source>
          <target state="translated">두 개의 void 구조화 배열의 dtype이 같으면 배열의 동일성을 테스트 하면 해당 구조의 모든 필드가 동일한 요소가 &lt;code&gt;True&lt;/code&gt; 로 설정된 원래 배열의 차원을 가진 부울 배열이 생성됩니다 . 구조화 된 dtype은 필드 이름, dtype 및 제목이 동일하고 엔디안을 무시하고 필드가 동일한 순서 인 경우 동일합니다.</target>
        </trans-unit>
        <trans-unit id="769e103ab2e97d0544e3e9203d0c4335be336adf" translate="yes" xml:space="preserve">
          <source>If the eigenvalue computation does not converge.</source>
          <target state="translated">고유 값 계산이 수렴하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="18adc01c0eaa64bd3fe6f5b836944558dd579c54" translate="yes" xml:space="preserve">
          <source>If the element you&amp;rsquo;re looking for doesn&amp;rsquo;t exist in the array, then the returned array of indices will be empty. For example:</source>
          <target state="translated">찾고있는 요소가 배열에 없으면 반환 된 인덱스 배열이 비어 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="ae5f5ebbdda43d87574658252f8456304a3e6d83" translate="yes" xml:space="preserve">
          <source>If the file contains pickle data, then whatever object is stored in the pickle is returned.</source>
          <target state="translated">파일에 피클 데이터가 포함되어 있으면 피클에 저장된 모든 객체가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="52f9285704aeec7c0050eb73ae0eedae9e536c15" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npy&lt;/code&gt; file, then a single array is returned.</source>
          <target state="translated">파일이 &lt;code&gt;.npy&lt;/code&gt; 인 경우 파일이면 단일 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c850dbbea34f89942e452ade066952afb4aff87b" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, the returned value supports the context manager protocol in a similar fashion to the open function:</source>
          <target state="translated">파일이 &lt;code&gt;.npz&lt;/code&gt; 파일 인 경우, 리턴 된 값은 열린 함수와 유사한 방식으로 컨텍스트 관리자 프로토콜을 지원합니다.</target>
        </trans-unit>
        <trans-unit id="6dd34773e8e6fce245333f3661e9174ce50590a5" translate="yes" xml:space="preserve">
          <source>If the file is a &lt;code&gt;.npz&lt;/code&gt; file, then a dictionary-like object is returned, containing &lt;code&gt;{filename: array}&lt;/code&gt; key-value pairs, one for each file in the archive.</source>
          <target state="translated">파일이 &lt;code&gt;.npz&lt;/code&gt; 파일 인 경우 &lt;code&gt;{filename: array}&lt;/code&gt; 키-값 쌍 (아카이브의 각 파일에 대해 하나씩)을 포함하는 사전과 유사한 오브젝트가 리턴 됩니다.</target>
        </trans-unit>
        <trans-unit id="0a517df17f23da0350e5f4238549fbfa3ccd5684" translate="yes" xml:space="preserve">
          <source>If the file is not found or cannot be opened correctly.</source>
          <target state="translated">파일을 찾을 수 없거나 올바르게 열 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="3eb136618e35fc45bcfb6109a519b0397c62a7f3" translate="yes" xml:space="preserve">
          <source>If the filename ends in &lt;code&gt;.gz&lt;/code&gt;, the file is automatically saved in compressed gzip format. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; understands gzipped files transparently.</source>
          <target state="translated">파일 이름이 &lt;code&gt;.gz&lt;/code&gt; 로 끝나면 파일은 자동으로 압축 된 gzip 형식으로 저장됩니다. &lt;a href=&quot;numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; &lt;/a&gt; 는 gzip으로 압축 된 파일을 투명하게 이해합니다.</target>
        </trans-unit>
        <trans-unit id="3cd5e67735dce4fe85460703c53dc9836515a450" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as a row vector. If the last argument is 1-D it is treated as a column vector. The other arguments must be 2-D.</source>
          <target state="translated">첫 번째 인수가 1 차원 인 경우 행 벡터로 처리됩니다. 마지막 인수가 1 차원 인 경우 열 벡터로 처리됩니다. 다른 인수는 2 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="02ed5193bd3dcf84d786340881fcb3d577ef57f7" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D it is treated as row vector. If the last argument is 1-D it is treated as column vector. The other arguments must be 2-D.</source>
          <target state="translated">첫 번째 인수가 1 차원 인 경우 행 벡터로 취급됩니다. 마지막 인수가 1 차원 인 경우 열 벡터로 처리됩니다. 다른 인수는 2 차원이어야합니다.</target>
        </trans-unit>
        <trans-unit id="0a74c0a74431c3bd3b43bf07934fe3d61fd80338" translate="yes" xml:space="preserve">
          <source>If the first argument is 1-D, it is promoted to a matrix by prepending a 1 to its dimensions. After matrix multiplication the prepended 1 is removed.</source>
          <target state="translated">첫 번째 인수가 1-D이면 1을 차원 앞에 추가하여 행렬로 승격합니다. 행렬 곱셈 후 앞에 붙인 1이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="89db4e5dab2cb1ce35a7fb31edd3413095e85f3c" translate="yes" xml:space="preserve">
          <source>If the first argument is a tuple, other arguments are ignored:</source>
          <target state="translated">첫 번째 인수가 튜플이면 다른 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="727e22f05290aaa6c2959157d7df0bc582e3c538" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;#numpy.ma.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">다음 방정식이 요소 별 True이면 &lt;a href=&quot;#numpy.ma.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="a4e333405efef301e87eb01476249ca72db784ba" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt;&lt;code&gt;allclose&lt;/code&gt;&lt;/a&gt; returns True:</source>
          <target state="translated">다음 방정식이 요소 별 True이면 &lt;a href=&quot;numpy.allclose#numpy.allclose&quot;&gt; &lt;code&gt;allclose&lt;/code&gt; &lt;/a&gt; 는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="94cbab458f248cbb972811c2359461201e9861d5" translate="yes" xml:space="preserve">
          <source>If the following equation is element-wise True, then allclose returns True.</source>
          <target state="translated">다음 방정식이 요소 별 True이면 allclose는 True를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1386561a26e41c95c312db50b7ef52259e4517da" translate="yes" xml:space="preserve">
          <source>If the given strings are equal, &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt;&lt;code&gt;assert_string_equal&lt;/code&gt;&lt;/a&gt; does nothing. If they are not equal, an AssertionError is raised, and the diff between the strings is shown.</source>
          <target state="translated">주어진 문자열이 같으면 &lt;a href=&quot;#numpy.testing.assert_string_equal&quot;&gt; &lt;code&gt;assert_string_equal&lt;/code&gt; &lt;/a&gt; 은 아무 것도 수행하지 않습니다. 동일하지 않으면 AssertionError가 발생하고 문자열 사이의 차이가 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="f5f5e437a85f1a89c55d54e0a09b57161df68a13" translate="yes" xml:space="preserve">
          <source>If the header file that contains the prototype for &lt;code&gt;double dot()&lt;/code&gt; also contains other prototypes that you want to wrap, so that you need to &lt;code&gt;%include&lt;/code&gt; this header file, then you will also need a &lt;code&gt;%ignore
dot;&lt;/code&gt; directive, placed after the &lt;code&gt;%rename&lt;/code&gt; and before the &lt;code&gt;%include&lt;/code&gt; directives. Or, if the function in question is a class method, you will want to use &lt;code&gt;%extend&lt;/code&gt; rather than &lt;code&gt;%inline&lt;/code&gt; in addition to &lt;code&gt;%ignore&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;double dot()&lt;/code&gt; 용 프로토 타입이 포함 된 헤더 파일 에 래핑하려는 다른 프로토 타입도 포함되어 있으므로이 헤더 파일 을 &lt;code&gt;%include&lt;/code&gt; 해야하는 경우 &lt;code&gt;%ignore dot;&lt;/code&gt; 도 필요합니다 . 지시문은 &lt;code&gt;%rename&lt;/code&gt; 뒤 및 &lt;code&gt;%include&lt;/code&gt; 지시문 앞에 배치 됩니다 . 또는 해당 함수가 클래스 메서드 인 경우 &lt;code&gt;%ignore&lt;/code&gt; 외에도 &lt;code&gt;%inline&lt;/code&gt; 대신 &lt;code&gt;%extend&lt;/code&gt; 를 사용하려고합니다. .</target>
        </trans-unit>
        <trans-unit id="7e4a3d5e2d4e2e2a3ebb889979e38306c67da7f4" translate="yes" xml:space="preserve">
          <source>If the index arrays do not have the same shape, there is an attempt to broadcast them to the same shape. If they cannot be broadcast to the same shape, an exception is raised:</source>
          <target state="translated">인덱스 배열의 모양이 같지 않으면 동일한 모양으로 브로드 캐스트하려는 시도가 있습니다. 동일한 모양으로 브로드 캐스트 할 수없는 경우 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="f745354786d48a61873aeb74a86c334de5c7a7b4" translate="yes" xml:space="preserve">
          <source>If the index expression contains comma separated arrays, then stack them along their first axis.</source>
          <target state="translated">인덱스 표현식에 쉼표로 구분 된 배열이 있으면 첫 번째 축을 따라 배열하십시오.</target>
        </trans-unit>
        <trans-unit id="34ad012e6ac2224c1d99e1fa90fb54c844437b0d" translate="yes" xml:space="preserve">
          <source>If the index expression contains slice notation or scalars then create a 1-D array with a range indicated by the slice notation.</source>
          <target state="translated">인덱스 표현식에 슬라이스 표기법 또는 스칼라가 포함 된 경우 슬라이스 표기법으로 표시되는 범위로 1 차원 배열을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="b729e3ef7cf0f40d514ca0e064da63fa121cea95" translate="yes" xml:space="preserve">
          <source>If the information is already documented and succinct enough for a how-to, just link to it, possibly after an introduction (&amp;ldquo;Three km/mi, take a right&amp;rdquo;).</source>
          <target state="translated">정보가 이미 문서화되어 있고 하우투에 대해 충분히 간결한 경우 소개 후에 링크 만하면됩니다 ( &quot;3km / mi, 오른쪽으로 이동&quot;).</target>
        </trans-unit>
        <trans-unit id="70dea339f55810f6be3e1b0c9e7aefd88107ebbf" translate="yes" xml:space="preserve">
          <source>If the input &lt;code&gt;a&lt;/code&gt; contains an imaginary part, it is silently discarded.</source>
          <target state="translated">입력 &lt;code&gt;a&lt;/code&gt; 에 허수 부가 포함되어 있으면 자동으로 삭제됩니다.</target>
        </trans-unit>
        <trans-unit id="4637e99d70ef2c1cb40679370ac10807b840a3f4" translate="yes" xml:space="preserve">
          <source>If the input file does not exist or cannot be read.</source>
          <target state="translated">입력 파일이 없거나 읽을 수없는 경우</target>
        </trans-unit>
        <trans-unit id="bbf06b38d2758769a67207876edd570ca41378d4" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.max.</source>
          <target state="translated">입력에 정수 유형이 있으면 함수는 np.max와 같습니다.</target>
        </trans-unit>
        <trans-unit id="7895a434c9eeafd563766c2013458a9eca1c5fea" translate="yes" xml:space="preserve">
          <source>If the input has a integer type the function is equivalent to np.min.</source>
          <target state="translated">입력에 정수 유형이 있으면 함수는 np.min과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b307c09a45c4aabb639976a619f0171d6a01d0dd" translate="yes" xml:space="preserve">
          <source>If the input is 2d and axis is specified, the result is a list of lists.</source>
          <target state="translated">입력이 2d이고 축이 지정된 경우 결과는 목록의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="7ed38fa8c8d2f0a335bd5a040aeda16b9d1b796e" translate="yes" xml:space="preserve">
          <source>If the input is not 1-dimensional, or contains elements with negative values, or if &lt;code&gt;minlength&lt;/code&gt; is negative.</source>
          <target state="translated">입력이 1 차원이 아니거나 음수 값을 가진 요소를 포함하거나 &lt;code&gt;minlength&lt;/code&gt; 가 음수 인 경우</target>
        </trans-unit>
        <trans-unit id="10296cda117e24158759559beefea304129412f0" translate="yes" xml:space="preserve">
          <source>If the input parameter &lt;code&gt;n&lt;/code&gt; is larger than the size of the input, the input is padded by appending zeros at the end. Even though this is the common approach, it might lead to surprising results. If a different padding is desired, it must be performed before calling &lt;a href=&quot;#numpy.fft.ifft&quot;&gt;&lt;code&gt;ifft&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">입력 매개 변수 &lt;code&gt;n&lt;/code&gt; 이 입력 크기보다 큰 경우 끝에 0을 추가하여 입력을 채 웁니다. 이것이 일반적인 접근이지만 놀라운 결과를 초래할 수 있습니다. 다른 패딩이 필요한 경우 &lt;a href=&quot;#numpy.fft.ifft&quot;&gt; &lt;code&gt;ifft&lt;/code&gt; &lt;/a&gt; 를 호출하기 전에 수행해야합니다. .</target>
        </trans-unit>
        <trans-unit id="3fc060b3dda78a5634929550749227bb1804a61d" translate="yes" xml:space="preserve">
          <source>If the inputs are ndarrays, then np.greater is equivalent to &amp;lsquo;&amp;gt;&amp;rsquo;.</source>
          <target state="translated">입력이 ndarray이면 np.greater는 '&amp;gt;'와 같습니다.</target>
        </trans-unit>
        <trans-unit id="36e6b94197e7b6e49557830166101a92fecb27ad" translate="yes" xml:space="preserve">
          <source>If the inputs or dtype are complex, the output will follow a logarithmic spiral in the complex plane. (There are an infinite number of spirals passing through two points; the output will follow the shortest such path.)</source>
          <target state="translated">입력 또는 dtype이 복잡한 경우 출력은 복잡한 평면의 로그 나선형을 따릅니다. (두 점을 통과하는 나선의 수는 무한합니다. 출력은 가장 짧은 경로를 따릅니다.)</target>
        </trans-unit>
        <trans-unit id="ce8f1e8f63cbe617564d9cd3d7c5c8bc3e2530ae" translate="yes" xml:space="preserve">
          <source>If the iterator is buffered, returns the size of the buffer being used, otherwise returns 0.</source>
          <target state="translated">반복자가 버퍼링되면 사용중인 버퍼의 크기를 반환하고, 그렇지 않으면 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="f3c918834625c8823bdade73b25f11346749b818" translate="yes" xml:space="preserve">
          <source>If the iterator is tracking a multi-index, this strips support for them, and does further iterator optimizations that are possible if multi-indices are not needed. This function also resets the iterator to its initial state.</source>
          <target state="translated">반복자가 다중 색인을 추적하는 경우, 다중 색인을 지원하지 않으며 다중 표시가 필요하지 않은 경우 가능한 반복기 최적화를 수행합니다. 이 기능은 반복기를 초기 상태로 재설정합니다.</target>
        </trans-unit>
        <trans-unit id="7df15990c36906ed5503360d9305db9b7bfe762b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; has different size.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 와 &lt;code&gt;b&lt;/code&gt; 의 마지막 치수 가 다른 경우.</target>
        </trans-unit>
        <trans-unit id="5f26098ec8a9cbafe4e4d839766540a822d41056" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;a&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;b&lt;/code&gt;.</source>
          <target state="translated">마지막 치수 경우 &lt;code&gt;a&lt;/code&gt; 의 마지막에서 두 번째 사이즈와 동일한 크기 아니다 &lt;code&gt;b&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb81ca8cc652031a811f2c78a93956ac1f2c926b" translate="yes" xml:space="preserve">
          <source>If the last dimension of &lt;code&gt;x1&lt;/code&gt; is not the same size as the second-to-last dimension of &lt;code&gt;x2&lt;/code&gt;.</source>
          <target state="translated">마지막 치수 경우 &lt;code&gt;x1&lt;/code&gt; 의 마지막에서 두 번째 사이즈와 동일한 크기 아니다 &lt;code&gt;x2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1f7f126415ee26c19732032b0ebefd0ac4317a" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt;&lt;code&gt;numpy.void&lt;/code&gt;&lt;/a&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">마스킹 된 배열에 이름이 지정된 필드가있는 경우 단일 항목에 액세스하면 마스킹 된 필드가없는 경우 &lt;a href=&quot;arrays.scalars#numpy.void&quot;&gt; &lt;code&gt;numpy.void&lt;/code&gt; &lt;/a&gt; 객체를 반환하고 , 하나 이상의 필드가 마스킹 된 경우 초기 배열과 동일한 dtype을 가진 0d 마스킹 된 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="2fd0d252831ab8d15d091d4ef1abf6e28cded875" translate="yes" xml:space="preserve">
          <source>If the masked array has named fields, accessing a single entry returns a &lt;code&gt;numpy.void&lt;/code&gt; object if none of the fields are masked, or a 0d masked array with the same dtype as the initial array if at least one of the fields is masked.</source>
          <target state="translated">마스킹 된 배열에 명명 된 필드가있는 경우 단일 항목에 액세스하면 &lt;code&gt;numpy.void&lt;/code&gt; 가 반환됩니다. 마스킹 된 필드가없는 경우 객체가 되거나 필드 중 하나 이상이 마스킹 된 경우 초기 배열과 동일한 dtype을 갖는 0d 마스킹 된 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ddd5cbab3c6e64e2766e2597df7dd32b3c4a768b" translate="yes" xml:space="preserve">
          <source>If the mode is a &amp;ldquo;write&amp;rdquo; mode, then this is the version of the file format used to create the file. None means use the oldest supported version that is able to store the data. Default: None</source>
          <target state="translated">모드가 &quot;쓰기&quot;모드 인 경우 파일을 만드는 데 사용되는 파일 형식의 버전입니다. 없음은 데이터를 저장할 수있는 지원되는 가장 오래된 버전을 사용함을 의미합니다. 기본값 : 없음</target>
        </trans-unit>
        <trans-unit id="8ec6f09c123aa3a76dc4dc9103d999ab337134eb" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (&lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt;), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">모드가 상수 채우기 ( &lt;code&gt;NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING&lt;/code&gt; ) 인 경우 fill_value는 채우기 값을 보유하는 배열 객체를 가리켜 야합니다 (배열에 두 개 이상의 항목이 포함 된 경우 첫 번째 항목은 채우기 값이됩니다). 다른 경우에는 fill_value가 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="510c4eb8a3d20ab4214058c75f9744c994e75f43" translate="yes" xml:space="preserve">
          <source>If the mode is constant filling (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING), fill_value should point to an array object which holds the filling value (the first item will be the filling value if the array contains more than one item). For other cases, fill_value may be NULL.</source>
          <target state="translated">모드가 일정한 채우기 (NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING) 인 경우 fill_value는 채우기 값을 보유하는 배열 객체를 가리켜 야합니다 (첫 번째 항목은 배열에 둘 이상의 항목이 포함 된 경우 채우기 값이 됨). 다른 경우에는 fill_value가 NULL 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be7395567c47ed030147671e19ef0b8f24978bfe" translate="yes" xml:space="preserve">
          <source>If the name is suffixed with the &amp;ldquo;?&amp;rdquo; modifier, the dimension is a core dimension only if it exists on all inputs and outputs that share it; otherwise it is ignored (and replaced by a dimension of size 1 for the elementary function).</source>
          <target state="translated">이름에 &quot;?&quot;접미사가 붙은 경우 수정 자, 차원은 차원을 공유하는 모든 입력 및 출력에 존재하는 경우에만 핵심 차원입니다. 그렇지 않으면 무시됩니다 (초등 함수의 경우 크기 1의 치수로 대체 됨).</target>
        </trans-unit>
        <trans-unit id="c3d1c518bb585ba44b9ba4aaf335820db98fa4f5" translate="yes" xml:space="preserve">
          <source>If the new array is larger than the original array, then the new array is filled with repeated copies of &lt;code&gt;a&lt;/code&gt;. Note that this behavior is different from a.resize(new_shape) which fills with zeros instead of repeated copies of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">새로운 배열 원의 배열보다 큰 경우, 새로운 배열의 반복 복사 가득 . 이 동작은 반복되는 사본 대신 0으로 채워지는 a.resize (new_shape)와 다릅니다 &lt;code&gt;a&lt;/code&gt; &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5041b424abd93910d43bf1d34adce8cb0f61f85" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt; , then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">선택 튜플의 개체 수보다 작은 경우 &lt;em&gt;N&lt;/em&gt; , 다음 &lt;code&gt;:&lt;/code&gt; 후속 치수 가정한다.</target>
        </trans-unit>
        <trans-unit id="4f2a8e76e80cc97243c0461015d68ab374ad3374" translate="yes" xml:space="preserve">
          <source>If the number of objects in the selection tuple is less than &lt;em&gt;N&lt;/em&gt;, then &lt;code&gt;:&lt;/code&gt; is assumed for any subsequent dimensions.</source>
          <target state="translated">선택 튜플 객체의 수 미만이면 &lt;em&gt;N&lt;/em&gt; 다음 &lt;code&gt;:&lt;/code&gt; 후속 치수 가정한다.</target>
        </trans-unit>
        <trans-unit id="2928aac7d9000dc7b0628e4b095667d7efc04498" translate="yes" xml:space="preserve">
          <source>If the object in question is compiled in a language other than Python, using &lt;code&gt;??&lt;/code&gt; will return the same information as &lt;code&gt;?&lt;/code&gt;. You&amp;rsquo;ll find this with a lot of built-in objects and types, for example:</source>
          <target state="translated">문제의 객체가 Python 이외의 언어로 컴파일 된 경우 &lt;code&gt;??&lt;/code&gt; 와 같은 정보를 반환 &lt;code&gt;?&lt;/code&gt; . 다음과 같은 많은 내장 객체 및 유형에서이를 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5a6c4456ec6f4292b9cf18dc4d579bb22a84db3" translate="yes" xml:space="preserve">
          <source>If the object provided is an array, this function traverses the chain of &lt;code&gt;base&lt;/code&gt; pointers so that each array points to the owner of the memory directly. Once the base is set, it may not be changed to another value.</source>
          <target state="translated">제공된 객체가 배열 인 경우이 함수는 &lt;code&gt;base&lt;/code&gt; 체인을 통과합니다. 포인터 각 배열이 메모리 소유자를 직접 가리 키도록합니다. 베이스가 설정되면 다른 값으로 변경되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="89a89c71a1b9f2da8de85eabab619e5820532ff8" translate="yes" xml:space="preserve">
          <source>If the offsets of the fields and itemsize of a structured array satisfy the alignment conditions, the array will have the &lt;code&gt;ALIGNED&lt;/code&gt;&lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; set.</source>
          <target state="translated">필드의 오프셋과 구조화 된 배열의 항목 화가 정렬 조건을 충족하면 배열에 &lt;code&gt;ALIGNED&lt;/code&gt; &lt;a href=&quot;../reference/generated/numpy.ndarray.flags#numpy.ndarray.flags&quot;&gt; &lt;code&gt;flag&lt;/code&gt; &lt;/a&gt; 설정됩니다.</target>
        </trans-unit>
        <trans-unit id="657e1806ea99b60e1959c9ce313bdaa2fd70aa64" translate="yes" xml:space="preserve">
          <source>If the operand is flagged as write-only and a copy is needed, an uninitialized temporary array will be created and then copied to back to &lt;code&gt;op[i]&lt;/code&gt; on calling &lt;code&gt;NpyIter_Deallocate&lt;/code&gt;, instead of doing the unnecessary copy operation.</source>
          <target state="translated">피연산자가 쓰기 전용으로 플래그 지정되고 복사가 필요한 경우 초기화되지 않은 임시 배열이 생성 된 다음 &lt;code&gt;NpyIter_Deallocate&lt;/code&gt; 호출시 &lt;code&gt;op[i]&lt;/code&gt; 로 다시 복사됩니다. 불필요한 복사 조작을 수행하는 대신 복사됩니다.</target>
        </trans-unit>
        <trans-unit id="17f4400245338f1e4a33ed23afc91ef7ab8c40c6" translate="yes" xml:space="preserve">
          <source>If the optional argument &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; is given, only the first &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt;&lt;code&gt;count&lt;/code&gt;&lt;/a&gt; occurrences are replaced.</source>
          <target state="translated">선택적 인수 &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 가 제공되면 첫 번째 &lt;a href=&quot;numpy.char.count#numpy.char.count&quot;&gt; &lt;code&gt;count&lt;/code&gt; &lt;/a&gt; 만 교체됩니다.</target>
        </trans-unit>
        <trans-unit id="650baf4400147a0e58c70982764ea43290cfecc2" translate="yes" xml:space="preserve">
          <source>If the package is not found.</source>
          <target state="translated">패키지를 찾을 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="2ad175da47137fbc79b21402b2a0b69af4d4bc0f" translate="yes" xml:space="preserve">
          <source>If the position of iter is changed, any subsequent call to PyArrayNeighborhoodIter_Next is undefined behavior, and PyArrayNeighborhoodIter_Reset must be called.</source>
          <target state="translated">iter의 위치가 변경되면 PyArrayNeighborhoodIter_Next에 대한 후속 호출은 정의되지 않은 동작이며 PyArrayNeighborhoodIter_Reset을 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="66cca6496635da39ce18c4666654d2018c778c20" translate="yes" xml:space="preserve">
          <source>If the question is broad, narrow and redirect it</source>
          <target state="translated">질문이 광범위하고 좁아서 리디렉션하는 경우</target>
        </trans-unit>
        <trans-unit id="16e630a04286a25caaca20cb641690b37ba91ed8" translate="yes" xml:space="preserve">
          <source>If the release series is a new one, you will need to add a new section to the &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; front page just after the &amp;ldquo;insert here&amp;rdquo; comment:</source>
          <target state="translated">릴리스 시리즈가 새 시리즈 인 경우 &quot;여기에 삽입&quot;주석 바로 뒤에 &lt;code&gt;doc/build/merge/index.html&lt;/code&gt; 첫 페이지에 새 섹션을 추가해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8c927b8ff30da3cc5f4b149881b61cbe3118f463" translate="yes" xml:space="preserve">
          <source>If the requested data type is in non-native byte order, the NBO flag overrides it and the requested data type is converted to be in native byte order.</source>
          <target state="translated">요청 된 데이터 유형이 기본이 아닌 바이트 순서 인 경우 NBO 플래그가이를 대체하고 요청 된 데이터 유형이 기본 바이트 순서로 변환됩니다.</target>
        </trans-unit>
        <trans-unit id="8a5c6764b6f67871837f5bb9b64736c18fe7a7ad" translate="yes" xml:space="preserve">
          <source>If the returned coefficients are &lt;code&gt;c&lt;/code&gt;, then</source>
          <target state="translated">반환 된 계수가 &lt;code&gt;c&lt;/code&gt; 이면</target>
        </trans-unit>
        <trans-unit id="054023bbbbd71a4d456dd16da82bfb709a02f2cc" translate="yes" xml:space="preserve">
          <source>If the second argument is 1-D, it is promoted to a matrix by appending a 1 to its dimensions. After matrix multiplication the appended 1 is removed.</source>
          <target state="translated">두 번째 인수가 1-D이면 1을 차원에 추가하여 행렬로 승격합니다. 행렬 곱셈 후에 추가 된 1이 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="b4b38312a537fa220f815af5dcf5f4139bad3681" translate="yes" xml:space="preserve">
          <source>If the selection tuple has all entries &lt;code&gt;:&lt;/code&gt; except the &lt;em&gt;p&lt;/em&gt;-th entry which is a slice object &lt;code&gt;i:j:k&lt;/code&gt;, then the returned array has dimension &lt;em&gt;N&lt;/em&gt; formed by concatenating the sub-arrays returned by integer indexing of elements &lt;em&gt;i&lt;/em&gt;, &lt;em&gt;i+k&lt;/em&gt;, &amp;hellip;, &lt;em&gt;i + (m - 1) k &amp;lt; j&lt;/em&gt;,</source>
          <target state="translated">선택 튜플은 모든 항목이있는 경우 &lt;code&gt;:&lt;/code&gt; 제외한 &lt;em&gt;P&lt;/em&gt; 슬라이스 목적 번째 항목 &lt;code&gt;i:j:k&lt;/code&gt; 후 리턴 배열 차원있다 &lt;em&gt;N은&lt;/em&gt; 엘리먼트의 정수 인덱스에 의해 리턴 된 서브 - 어레이 연결하여 형성된 &lt;em&gt;나&lt;/em&gt; , &lt;em&gt;나는 + K를&lt;/em&gt; ,&amp;hellip;, &lt;em&gt;i + (m-1) k &amp;lt;j&lt;/em&gt; ,</target>
        </trans-unit>
        <trans-unit id="203e38312fd98260c8d96e3f0a471d9a5a4a4689" translate="yes" xml:space="preserve">
          <source>If the shapes are not compatible and cannot be broadcast according to NumPy&amp;rsquo;s broadcasting rules.</source>
          <target state="translated">셰이프가 호환되지 않고 NumPy의 방송 규칙에 따라 방송 될 수없는 경우.</target>
        </trans-unit>
        <trans-unit id="9a652cfa7a533eb64735eb374de6f3a4977f5b9c" translate="yes" xml:space="preserve">
          <source>If the spacing between &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; for one or more elements is larger than &lt;code&gt;nulp&lt;/code&gt;.</source>
          <target state="translated">하나 이상의 요소에 대해 &lt;code&gt;x&lt;/code&gt; 와 &lt;code&gt;y&lt;/code&gt; 사이의 간격 이 &lt;code&gt;nulp&lt;/code&gt; 보다 큰 경우 .</target>
        </trans-unit>
        <trans-unit id="3600ee510b36714644dcc89a19bb177b5b6c4ba7" translate="yes" xml:space="preserve">
          <source>If the string is not the correct size to satisfy the requested &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;count&lt;/code&gt;.</source>
          <target state="translated">요청 된 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;count&lt;/code&gt; 를 충족시키기 위해 문자열이 올바른 크기가 아닌 경우 .</target>
        </trans-unit>
        <trans-unit id="8431a3b44693b10770bc98218be6d44b926dbd16" translate="yes" xml:space="preserve">
          <source>If the transition to C++ goes through it is possible that this form will be relaxed so that short class methods meant to be inlined can have the return type on the same line as the function name. However, that is yet to be determined.</source>
          <target state="translated">C ++ 로의 전환이 진행되면이 형식이 완화되어 인라인 될 짧은 클래스 메서드가 함수 이름과 같은 줄에 반환 유형을 가질 수 있습니다. 그러나 그것은 아직 결정되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="ebc3886c14d49cd40506d4084002663f28dbcdd3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;x&lt;/code&gt; is unsigned, then the output type is the unsigned platform integer:</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 유형이 이 부호없는 경우 출력 유형은 부호없는 플랫폼 정수입니다.</target>
        </trans-unit>
        <trans-unit id="183bc4d9ba8fd4894a95c0f09db6946e16642c92" translate="yes" xml:space="preserve">
          <source>If the type of the input is complex.</source>
          <target state="translated">입력 유형이 복잡한 경우.</target>
        </trans-unit>
        <trans-unit id="95366e62fbbbe64ba41cdcaa0c22be8d3f384cd4" translate="yes" xml:space="preserve">
          <source>If the type of the input is float or complex.</source>
          <target state="translated">입력 유형이 부동 또는 복합 인 경우</target>
        </trans-unit>
        <trans-unit id="25291949b6396c31462d4c34b8e8b5c2797cb90a" translate="yes" xml:space="preserve">
          <source>If the ufunc has 2 inputs and 1 output and the second input is an Object array then a special-case check is performed so that NotImplemented is returned if the second input is not an ndarray, has the __array_priority__ attribute, and has an __r{op}__ special method. In this way, Python is signaled to give the other object a chance to complete the operation instead of using generic object-array calculations. This allows (for example) sparse matrices to override the multiplication operator 1-D loop.</source>
          <target state="translated">ufunc에 2 개의 입력과 1 개의 출력이 있고 두 번째 입력이 Object 배열 인 경우, 두 번째 입력이 ndarray가 아니고 __array_priority__ 속성이 있고 __r {op } __ 특별한 방법. 이런 식으로 파이썬은 다른 객체가 일반적인 객체 배열 계산을 사용하는 대신 작업을 완료 할 수있는 기회를주기 위해 신호를 보냅니다. 이를 통해 (예를 들어) 희소 행렬이 곱셈 연산자 1-D 루프를 재정의 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a4dffd94a98e9a9ee0037afd472e661e6232061e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">기본 데이터가 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 의 서브 클래스 인 경우 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="c8138c9410f7b3ce9c5c6bb9d0523e6e1ea7bd8e" translate="yes" xml:space="preserve">
          <source>If the underlying data is a subclass of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;, it is returned as such.</source>
          <target state="translated">기본 데이터가 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 의 하위 클래스 이면 그대로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="10f03c3143f8af1fee84b593563d21e127566799" translate="yes" xml:space="preserve">
          <source>If the user tries to use any numpy functions not included in &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;, a &lt;code&gt;TypeError&lt;/code&gt; will be raised by numpy, indicating that this operation is not supported. For example, concatenating two &lt;code&gt;DiagonalArrays&lt;/code&gt; does not produce another diagonal array, so it is not supported.</source>
          <target state="translated">사용자가에 포함되지 않은 NumPy와 기능을 사용하려고하면 &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt; 을 하는 &lt;code&gt;TypeError&lt;/code&gt; 이 작업이 지원되지 않음을 나타내는, NumPy와에 의해 발생합니다. 예를 들어 두 개의 &lt;code&gt;DiagonalArrays&lt;/code&gt; 연결해도 다른 대각선 배열이 생성되지 않으므로 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="23122d3c8d35684d3c1d392886f730d15f172384" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt;&lt;code&gt;max&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">값이 아무것도하지만 기본 인 경우, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달되는 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#max&quot;&gt; &lt;code&gt;max&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . 서브 클래스 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2abfa832de7674bd2d08ad1f7e2b845f18a0059c" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt;&lt;code&gt;min&lt;/code&gt;&lt;/a&gt; method of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">값이 아무것도하지만 기본 인 경우, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달됩니다 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#min&quot;&gt; &lt;code&gt;min&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . 서브 클래스 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="fb8acc52d13221f0fba6edb05a42e80cbebd0a2e" translate="yes" xml:space="preserve">
          <source>If the value is anything but the default, then &lt;code&gt;keepdims&lt;/code&gt; will be passed through to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;sum&lt;/code&gt;&lt;/a&gt; methods of sub-classes of &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;. If the sub-classes methods does not implement &lt;code&gt;keepdims&lt;/code&gt; any exceptions will be raised.</source>
          <target state="translated">값이 아무것도하지만 기본 인 경우, &lt;code&gt;keepdims&lt;/code&gt; 는 받는 사람을 통해 전달됩니다 &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;sum&lt;/code&gt; &lt;/a&gt; 의 하위 클래스의 방법 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; . 서브 클래스 메소드가 &lt;code&gt;keepdims&lt;/code&gt; 를 구현하지 않으면 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="287f0d6b5f9e62921d595f7d469377b448c9303e" translate="yes" xml:space="preserve">
          <source>If there are many steps, break them up</source>
          <target state="translated">단계가 많으면 쪼개</target>
        </trans-unit>
        <trans-unit id="33c6901ff2ee0db95c77f2b313983f44526bb314" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt;&lt;code&gt;PyArray_PromoteTypes&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">스칼라 만 있거나 스칼라의 최대 범주가 배열의 최대 범주보다 높으면 데이터 유형이 &lt;a href=&quot;#c.PyArray_PromoteTypes&quot;&gt; &lt;code&gt;PyArray_PromoteTypes&lt;/code&gt; &lt;/a&gt; 와 결합되어 반환 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="33fe4c771f7142c020971d30614039b35a541395" translate="yes" xml:space="preserve">
          <source>If there are only scalars or the maximum category of the scalars is higher than the maximum category of the arrays, the data types are combined with &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt; to produce the return value.</source>
          <target state="translated">스칼라 만 있거나 스칼라의 최대 범주가 배열의 최대 범주보다 높으면 데이터 유형이 &lt;a href=&quot;numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; 와 결합되어 반환 값을 생성합니다.</target>
        </trans-unit>
        <trans-unit id="713f3b36701faad5c729c8225f4c0508fcfe41f1" translate="yes" xml:space="preserve">
          <source>If there is no dictionary passed in or &lt;code&gt;vardict&lt;/code&gt; is None then returns NumPy arrays in the globals() dictionary (all NumPy arrays in the namespace).</source>
          <target state="translated">전달 된 사전이 없거나 &lt;code&gt;vardict&lt;/code&gt; 가 None이면 globals () 사전에 NumPy 배열을 반환합니다 (네임 스페이스의 모든 NumPy 배열).</target>
        </trans-unit>
        <trans-unit id="d0c11d30de5e96bdaa85cb78bb53dddd3ba03ebc" translate="yes" xml:space="preserve">
          <source>If there is no library with the expected extension, or the library is defective and cannot be loaded.</source>
          <target state="translated">확장자가 예상되는 라이브러리가 없거나 라이브러리에 결함이있어로드 할 수없는 경우</target>
        </trans-unit>
        <trans-unit id="ef27bb26cd9e20ec5eb81bab137d2b6e00a224b0" translate="yes" xml:space="preserve">
          <source>If there is only one Boolean array and no integer indexing array present, this is straight forward. Care must only be taken to make sure that the boolean index has &lt;em&gt;exactly&lt;/em&gt; as many dimensions as it is supposed to work with.</source>
          <target state="translated">부울 배열이 하나만 있고 정수 인덱싱 배열이 없으면 간단합니다. 부울 인덱스가 작업 할 &lt;em&gt;수있는&lt;/em&gt; 만큼의 차원을 갖도록주의해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e046df75fb04a45aea0ca0b9e3343d606d4ffa89" translate="yes" xml:space="preserve">
          <source>If there&amp;rsquo;s related background (tutorial, explanation, reference, alternative approach), bring it to the user&amp;rsquo;s attention with a link (&amp;ldquo;Directions from Route 7,&amp;rdquo; &amp;ldquo;Why so few filling stations?&amp;rdquo;).</source>
          <target state="translated">관련 배경 (자습서, 설명, 참조, 대체 접근 방식)이있는 경우 링크 ( &quot;7 번 경로에서 오는 길&quot; &quot;주유소가 적은 이유&quot;)를 사용하여 사용자의주의를 끌 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6e268d3c7b0192c893825d9fa07e4e49b28360ad" translate="yes" xml:space="preserve">
          <source>If these arrays are all collected in a structured array, then &lt;a href=&quot;#c.PyArray_Sort&quot;&gt;&lt;code&gt;PyArray_Sort&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) can also be used to sort the array directly.</source>
          <target state="translated">이러한 배열이 모두 구조화 된 배열로 수집되면 &lt;a href=&quot;#c.PyArray_Sort&quot;&gt; &lt;code&gt;PyArray_Sort&lt;/code&gt; &lt;/a&gt; (&amp;hellip;)를 사용하여 배열을 직접 정렬 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="54dc9b5be81c958064f5d558fe01980eec4eadde" translate="yes" xml:space="preserve">
          <source>If these conditions are not met, a &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; exception is thrown, indicating that the arrays have incompatible shapes. The size of the resulting array is the size that is not 1 along each axis of the inputs.</source>
          <target state="translated">이러한 조건이 충족되지 않으면 &lt;code&gt;ValueError: operands could not be broadcast together&lt;/code&gt; 예외가 발생하여 배열에 호환되지 않는 모양이 있음을 나타냅니다. 결과 배열의 크기는 입력의 각 축을 따라 1이 아닌 크기입니다.</target>
        </trans-unit>
        <trans-unit id="4b5797d27d90ecc738ae241c7f2d88131ab4d780" translate="yes" xml:space="preserve">
          <source>If these conditions hold, &lt;code&gt;__array_function__&lt;/code&gt; should return the result from calling its implementation for &lt;code&gt;func(*args, **kwargs)&lt;/code&gt;. Otherwise, it should return the sentinel value &lt;code&gt;NotImplemented&lt;/code&gt;, indicating that the function is not implemented by these types.</source>
          <target state="translated">이러한 조건이 유지되면 &lt;code&gt;__array_function__&lt;/code&gt; 은 &lt;code&gt;func(*args, **kwargs)&lt;/code&gt; 대한 구현을 호출 한 결과를 반환해야합니다 . 그렇지 않으면, 센티넬 값 &lt;code&gt;NotImplemented&lt;/code&gt; 를 리턴 하여 함수가 이러한 유형에 의해 구현 되지 않았 음 을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c80ca8262eeedd9bef78dbd28fb2dc07a4582c48" translate="yes" xml:space="preserve">
          <source>If this array does not own its own memory, then base points to the Python object that owns it (perhaps another array object)</source>
          <target state="translated">이 배열이 자체 메모리를 소유하지 않으면 base는 자신을 소유 한 Python 오브젝트 (아마도 다른 배열 오브젝트)를 가리 킵니다.</target>
        </trans-unit>
        <trans-unit id="f79009d9f8b9e9859082a3efe68d074e3e908ff8" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">이 배열에 (더 이상 사용되지 않음) &lt;a href=&quot;array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 설정된 경우이 배열은 &quot;잘못된 동작&quot;배열의 작업 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="f63b91f81d86b6356e230f230ee7da044adca895" translate="yes" xml:space="preserve">
          <source>If this array has the (deprecated) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; flag set, then this array is a working copy of a &amp;ldquo;misbehaved&amp;rdquo; array.</source>
          <target state="translated">이 배열에 (더 이상 사용되지 않는) &lt;a href=&quot;c-api.array#c.NPY_ARRAY_UPDATEIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_UPDATEIFCOPY&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;c-api.array#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 플래그가 설정되어 있으면이 배열은 &quot;잘못된 동작&quot;배열의 작업 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="2e1498e4add4060095cafec2d44c32b17e6ac395" translate="yes" xml:space="preserve">
          <source>If this condition is not met, a &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; exception is thrown indicating that the arrays have incompatible shapes. The size of the result array created by broadcast operations is the maximum size along each dimension from the input arrays. Note that the rule does not say anything about the two arrays needing to have the same number of dimensions. So, for example, if you have a 256 x 256 x 3 array of RGB values, and you want to scale each color in the image by a different value, you can multiply the image by a one-dimensional array with 3 values. Lining up the sizes of the trailing axes of these arrays according to the broadcast rule shows that they are compatible</source>
          <target state="translated">이 조건이 충족 &lt;code&gt;ValueError('frames are not aligned')&lt;/code&gt; 배열에 호환되지 않는 모양이 있음을 나타내는 ValueError ( 'frames are not alignment') 예외가 발생합니다. 브로드 캐스트 작업으로 생성 된 결과 배열의 크기는 입력 배열의 각 차원에 따른 최대 크기입니다. 규칙은 동일한 수의 차원을 가져야하는 두 배열에 대해 아무 말도하지 않습니다. 예를 들어 RGB 값의 256 x 256 x 3 배열이 있고 이미지의 각 색상을 다른 값으로 배율 조정하려는 경우 이미지에 3 개의 값이있는 1 차원 배열을 곱할 수 있습니다. 브로드 캐스트 규칙에 따라 이러한 배열의 후행 축 크기를 정렬하면 호환된다는 것을 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b54640e63d198f32f1e8358a28ce29bc6179e6f7" translate="yes" xml:space="preserve">
          <source>If this function returns true, the caller should also check the inner loop stride of the operand, because if that stride is 0, then only the first element of the innermost external loop is being visited for the first time.</source>
          <target state="translated">이 함수가 true를 반환하면 호출자는 피연산자의 내부 루프 보폭도 확인해야합니다. 보폭이 0이면 가장 안쪽 외부 루프의 첫 번째 요소 만 처음 방문하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="24a22c06faef1b4b61f295517b88ec97d1fc0a84" translate="yes" xml:space="preserve">
          <source>If this is &lt;code&gt;None&lt;/code&gt;, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 &lt;code&gt;None&lt;/code&gt; 이면 모든 축에 대해 축소가 수행됩니다. 이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 축소가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="33f579e70b917db4493a3111bc7067b3dc4d2ff2" translate="yes" xml:space="preserve">
          <source>If this is None, a reduction is performed over all the axes. If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">None이면 모든 축에 대해 축소가 수행됩니다. 이것이 int의 튜플이면 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 축소가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e4599c6e53b844db2376ed9e56ed7b49e63c6ec3" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a mean is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에 대해 평균이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="04767d2c5f5bbd4aab7323a751a31f226739a396" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a reduction is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 축소가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="e11ec2c8b461dd6b1390de16d518719c4d72ce55" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a standard deviation is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에 대해 표준 편차가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="cdec667610de13f7517139e9ece6f88d2d290194" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, a variance is performed over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 분산이 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="d50012ee6c384ff0215bab7085fcf98c562bc452" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the count is performed on multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 카운트가 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c674e367c6b1c23d3abf3ddc4c5a7a14ff593b5a" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the maximum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 최대 값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="a0756a48081a9a9cb1bfbc79e9843f0007e55c1d" translate="yes" xml:space="preserve">
          <source>If this is a tuple of ints, the minimum is selected over multiple axes, instead of a single axis or all the axes as before.</source>
          <target state="translated">이것이 int의 튜플 인 경우 이전과 같이 단일 축 또는 모든 축 대신 여러 축에서 최소값이 선택됩니다.</target>
        </trans-unit>
        <trans-unit id="7573da3ff564f7261e16d53ba17d4d7c25b6abc9" translate="yes" xml:space="preserve">
          <source>If this is anything but the default value it will be passed through (in the special case of an empty array) to the &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; function of the underlying array. If the array is a sub-class and &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt;&lt;code&gt;mean&lt;/code&gt;&lt;/a&gt; does not have the kwarg &lt;code&gt;keepdims&lt;/code&gt; this will raise a RuntimeError.</source>
          <target state="translated">이것이 기본값 이외의 값이면 (빈 배열의 특수한 경우) 기본 배열 의 &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 함수로 전달됩니다. 배열이 하위 클래스이고 &lt;a href=&quot;numpy.mean#numpy.mean&quot;&gt; &lt;code&gt;mean&lt;/code&gt; &lt;/a&gt; 에 kwarg &lt;code&gt;keepdims&lt;/code&gt; 가없는 경우 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="25b5fe8a90e7aa983d49aeb7de528ca7dae28481" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however).</source>
          <target state="translated">이것이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우이 데이터 유형 설명자는 다른 데이터 유형 설명 자의 C 스타일 연속 배열입니다. 다른 단어에서이 설명자가 설명하는 각 요소는 실제로 다른 기본 설명 자의 배열입니다. 이것은 다른 데이터 유형 설명 자의 필드에 대한 데이터 유형 설명 자로 가장 유용합니다. &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 필드 멤버는 NULL 이어야 &lt;code&gt;NULL&lt;/code&gt; ( 하지만 기본 설명 자의 필드 멤버는 &lt;code&gt;NULL&lt;/code&gt; 이 아닐 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="9eef22bd67c15e89cde5d92734a40aa76d92e691" translate="yes" xml:space="preserve">
          <source>If this is non- &lt;code&gt;NULL&lt;/code&gt;, then this data-type descriptor is a C-style contiguous array of another data-type descriptor. In other-words, each element that this descriptor describes is actually an array of some other base descriptor. This is most useful as the data-type descriptor for a field in another data-type descriptor. The fields member should be &lt;code&gt;NULL&lt;/code&gt; if this is non- &lt;code&gt;NULL&lt;/code&gt; (the fields member of the base descriptor can be non- &lt;code&gt;NULL&lt;/code&gt; however). The &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; structure is defined using</source>
          <target state="translated">이것이 &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 ,이 데이터 유형 설명자는 다른 데이터 유형 설명 자의 C 스타일 연속 배열입니다. 다른 말로하면,이 디스크립터가 설명하는 각 요소는 실제로 다른 기본 디스크립터의 배열입니다. 이것은 다른 데이터 유형 설명 자의 필드에 대한 데이터 유형 설명 자로 가장 유용합니다. &lt;code&gt;NULL&lt;/code&gt; 이 아닌 경우 필드 멤버는 NULL 이어야 &lt;code&gt;NULL&lt;/code&gt; ( 그러나 기본 디스크립터의 필드 멤버는 &lt;code&gt;NULL&lt;/code&gt; 이 아닐 수 있음 ). &lt;code&gt;PyArray_ArrayDescr&lt;/code&gt; 의 구조를 사용하여 정의되고</target>
        </trans-unit>
        <trans-unit id="2824d770011e81edcc48aaca00be40fe5064246e" translate="yes" xml:space="preserve">
          <source>If this is non-NULL, then this data-type-descriptor has fields described by a Python dictionary whose keys are names (and also titles if given) and whose values are tuples that describe the fields. Recall that a data-type-descriptor always describes a fixed-length set of bytes. A field is a named sub-region of that total, fixed-length collection. A field is described by a tuple composed of another data- type-descriptor and a byte offset. Optionally, the tuple may contain a title which is normally a Python string. These tuples are placed in this dictionary keyed by name (and also title if given).</source>
          <target state="translated">이것이 NULL이 아닌 경우,이 데이터 유형 설명자는 키가 이름 (및 주어진 경우 제목)이고 필드를 설명하는 튜플 인 파이썬 사전에 설명 된 필드를 갖습니다. 데이터 유형 설명자는 항상 고정 길이의 바이트 세트를 설명합니다. 필드는 총 고정 길이 컬렉션의 명명 된 하위 영역입니다. 필드는 다른 데이터 형식 설명자와 바이트 오프셋으로 구성된 튜플에 의해 설명됩니다. 선택적으로 튜플에는 일반적으로 Python 문자열 인 제목이 포함될 수 있습니다. 이 튜플은 이름 (및 주어진 경우 제목)을 기준으로이 사전에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="0d86cba4ba7294ed9f7338e68f7b4f37b35c1557" translate="yes" xml:space="preserve">
          <source>If this is not desirable, then the array should be cast to a larger integer type first:</source>
          <target state="translated">이것이 바람직하지 않은 경우 먼저 배열을 더 큰 정수 유형으로 캐스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1ae38fd1d446748062bddf73d4866a0b315e1322" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions , i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">이 값을 &lt;code&gt;True&lt;/code&gt; 로 설정하면 축소 된 축이 크기가 1 인 차원으로 결과에 남게되므로 결과가 입력에 대해 올바르게 브로드 캐스트됩니다. 이 옵션은 모두 같은 수의 코어 치수를 가진 입력과 코어 치수가없는 출력, 즉 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 또는 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; . 사용되는 경우 출력에서 ​​치수의 위치는 &lt;code&gt;axes&lt;/code&gt; 및 &lt;code&gt;axis&lt;/code&gt; 로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="a675290349084bcd281fdfbd331891015b07aca9" translate="yes" xml:space="preserve">
          <source>If this is set to &lt;code&gt;True&lt;/code&gt;, axes which are reduced over will be left in the result as a dimension with size one, so that the result will broadcast correctly against the inputs. This option can only be used for generalized ufuncs that operate on inputs that all have the same number of core dimensions and with outputs that have no core dimensions, i.e., with signatures like &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; or &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt;. If used, the location of the dimensions in the output can be controlled with &lt;code&gt;axes&lt;/code&gt; and &lt;code&gt;axis&lt;/code&gt;.</source>
          <target state="translated">이것이 &lt;code&gt;True&lt;/code&gt; 로 설정되면 축소 된 축은 결과에 크기가 1 인 차원으로 남겨져 결과가 입력에 대해 올바르게 브로드 캐스트됩니다. 이 옵션은 모두 동일한 수의 코어 차원이있는 입력과 코어 차원이없는 출력 (예 : &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 또는 &lt;code&gt;(m,m)-&amp;gt;()&lt;/code&gt; . 사용되는 경우, 출력에서 ​​치수의 위치는 &lt;code&gt;axes&lt;/code&gt; 및 &lt;code&gt;axis&lt;/code&gt; 로 제어 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="86e30e948710dc5b2db29b7dc82437914fd08740" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes that are counted are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">True로 설정하면 계산 된 축이 크기가 1 인 차원으로 결과에 남습니다. 이 옵션을 사용하면 결과가 입력 배열에 대해 올바르게 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="74585a8bd339c6874f448a64d5fe0ba3642c10c6" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are normed over are left in the result as dimensions with size one. With this option the result will broadcast correctly against the original &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">이 값을 True로 설정하면 표준 축이 크기가 1 인 치수로 결과에 남습니다. 이 옵션을 사용하면 결과가 원본 &lt;code&gt;x&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="526b620d34688cc0c68a7ee67814781d453388f5" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the array.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 배열에 대해 올바르게 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="015e500928e7c3f86f2c9b5121c746246fcd7a9f" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the input array.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 입력 배열에 대해 올바르게 브로드 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="4d739fbcafd1b0f422661a57db4976a28b66ef61" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">True로 설정하면 축소 된 축이 크기가 1 인 치수로 결과에 남습니다. 이 옵션을 사용하면 결과가 원래 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="caf30df07a09579107c0faa5c9aaad9ad8721644" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 원본 &lt;code&gt;a&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="668624d9e02d10dc8924733d51742fcc1923286c" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original &lt;code&gt;arr&lt;/code&gt;.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 원래 &lt;code&gt;arr&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="813c59426f99f6e2035686f0669f18c79ec2fc97" translate="yes" xml:space="preserve">
          <source>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">이것이 True로 설정되면 축소 된 축은 결과적으로 크기가 1 인 치수로 남습니다. 이 옵션을 사용하면 결과가 원래 배열 &lt;code&gt;a&lt;/code&gt; 에 대해 올바르게 브로드 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="28e1fe971ad9fdc32699e38250e14da5caf0bb91" translate="yes" xml:space="preserve">
          <source>If this value is anything but the default it is passed through as-is to the relevant functions of the sub-classes. If these functions do not have a &lt;code&gt;keepdims&lt;/code&gt; kwarg, a RuntimeError will be raised.</source>
          <target state="translated">이 값이 기본값이 아닌 다른 값이면 서브 클래스의 관련 함수로 그대로 전달됩니다. 이러한 함수에 &lt;code&gt;keepdims&lt;/code&gt; kwarg 가 없으면 RuntimeError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="dd4ec2a983c899a1017fcabb86ae5785ce4793ab" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true (기본값)이면 객체가 복사됩니다. 그렇지 않으면 __array__가 복사본을 반환하거나 obj가 중첩 시퀀스이거나 다른 요구 사항 ( &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;order&lt;/code&gt; 등) 을 충족시키기 위해 복사본이 필요한 경우에만 복사본이 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="a6f5f638d5dadad294989835332dc69ea08c7e48" translate="yes" xml:space="preserve">
          <source>If true (default), then the object is copied. Otherwise, a copy will only be made if __array__ returns a copy, if obj is a nested sequence, or if a copy is needed to satisfy any of the other requirements (&lt;code&gt;itemsize&lt;/code&gt;, unicode, &lt;code&gt;order&lt;/code&gt;, etc.).</source>
          <target state="translated">true (기본값)이면 객체가 복사됩니다. 그렇지 않으면 __array__가 복사본을 반환하거나 obj가 중첩 된 시퀀스이거나 다른 요구 사항 ( &lt;code&gt;itemsize&lt;/code&gt; , unicode, &lt;code&gt;order&lt;/code&gt; 등) 을 충족시키기 위해 복사본이 필요한 경우에만 복사본이 만들어집니다 .</target>
        </trans-unit>
        <trans-unit id="7cfded7f1f4f8985525752f730c915f025bbc3bd" translate="yes" xml:space="preserve">
          <source>If true, &lt;code&gt;stop&lt;/code&gt; is the last sample. Otherwise, it is not included. Default is True.</source>
          <target state="translated">참이면 &lt;code&gt;stop&lt;/code&gt; 은 마지막 샘플입니다. 그렇지 않으면 포함되지 않습니다. 기본값은 True입니다.</target>
        </trans-unit>
        <trans-unit id="89363179f510b5ee9e2706f4cf949aff38e269d9" translate="yes" xml:space="preserve">
          <source>If true, sample from the interval [low, high] instead of the default [low, high) Defaults to False</source>
          <target state="translated">true 인 경우 기본 [낮음, 높음] 대신 간격 [낮음, 높음]에서 샘플링합니다. 기본값은 False입니다.</target>
        </trans-unit>
        <trans-unit id="ade7c82d0d30db8fc4ef391480e9db75f4fe6678" translate="yes" xml:space="preserve">
          <source>If true, use an &amp;ldquo;aligned&amp;rdquo; memory layout, otherwise use a &amp;ldquo;packed&amp;rdquo; layout.</source>
          <target state="translated">true이면 &quot;정렬 된&quot;메모리 레이아웃을 사용하고, 그렇지 않으면 &quot;포장 된&quot;레이아웃을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3ef0d38b764385bc39d70e5ad26d095da7b5d3f0" translate="yes" xml:space="preserve">
          <source>If used with &lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt;&lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt;&lt;/a&gt;, the inner loop for the caller may get larger chunks than would be possible without buffering, because of how the strides are laid out.</source>
          <target state="translated">&lt;a href=&quot;#c.NPY_ITER_EXTERNAL_LOOP&quot;&gt; &lt;code&gt;NPY_ITER_EXTERNAL_LOOP&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하는 경우 보폭이 배치되는 방식 때문에 호출자의 내부 루프가 버퍼링없이 가능한 것보다 더 큰 청크를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e6e87a78ddc8c45866e59f696a01a91d82f291c2" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are beyond the bounds of &lt;code&gt;bins&lt;/code&gt;, 0 or &lt;code&gt;len(bins)&lt;/code&gt; is returned as appropriate.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 의 값 이 &lt;code&gt;bins&lt;/code&gt; 의 범위를 벗어나면 적절하게 0 또는 &lt;code&gt;len(bins)&lt;/code&gt; 이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="adc126c0d80d4b8b968260ca8a9cd270dc0bc84e" translate="yes" xml:space="preserve">
          <source>If values in &lt;code&gt;x&lt;/code&gt; are such that they fall outside the bin range, attempting to index &lt;code&gt;bins&lt;/code&gt; with the indices that &lt;a href=&quot;#numpy.digitize&quot;&gt;&lt;code&gt;digitize&lt;/code&gt;&lt;/a&gt; returns will result in an IndexError.</source>
          <target state="translated">의 값 경우 &lt;code&gt;x&lt;/code&gt; 는 그런 자들은 인덱스를 시도, 빈 범위를 벗어나는 것을 &lt;code&gt;bins&lt;/code&gt; 하는 지표로 &lt;a href=&quot;#numpy.digitize&quot;&gt; &lt;code&gt;digitize&lt;/code&gt; &lt;/a&gt; 반환은 IndexError가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="1061c821f897c8eeb5e101d31b7da69483d53c77" translate="yes" xml:space="preserve">
          <source>If we add another set of variables and observations &lt;code&gt;yarr&lt;/code&gt;, we can compute the row-wise Pearson correlation coefficients between the variables in &lt;code&gt;xarr&lt;/code&gt; and &lt;code&gt;yarr&lt;/code&gt;.</source>
          <target state="translated">또 다른 변수 세트와 관측 값 &lt;code&gt;yarr&lt;/code&gt; 을 추가하면 &lt;code&gt;xarr&lt;/code&gt; 와 &lt;code&gt;yarr&lt;/code&gt; 의 변수 간의 행별 Pearson 상관 계수를 계산할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b223152b4e60f22e3efa048a66b57e829307cf69" translate="yes" xml:space="preserve">
          <source>If we designed &lt;code&gt;rms&lt;/code&gt;, we probably made it a routine that takes an input-only array of length &lt;code&gt;n&lt;/code&gt; of &lt;code&gt;double&lt;/code&gt; values called &lt;code&gt;seq&lt;/code&gt; and returns the root mean square. The default behavior of &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt;, however, will be to create a wrapper function that compiles, but is nearly impossible to use from the scripting language in the way the C routine was intended.</source>
          <target state="translated">&lt;code&gt;rms&lt;/code&gt; 를 디자인했다면 아마도 &lt;code&gt;seq&lt;/code&gt; 라는 길이 &lt;code&gt;n&lt;/code&gt; 의 &lt;code&gt;double&lt;/code&gt; 값으로 구성된 입력 전용 배열을 취하여 제곱 평균 제곱을 반환 하는 루틴으로 만들었을 것 입니다. 그러나 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 의 기본 동작은 컴파일하는 랩퍼 함수를 ​​작성하는 것이지만 C 루틴이 의도 한 방식으로 스크립팅 언어에서 사용하는 것은 거의 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="4a0434833c99496818e97fed2718d44b211d156f" translate="yes" xml:space="preserve">
          <source>If we do not know you yet, consider introducing yourself in &lt;a href=&quot;https://numpy.org/community/&quot;&gt;the mailing list or Slack&lt;/a&gt; before you start reviewing pull requests.</source>
          <target state="translated">아직 모르는 경우 풀 리퀘스트 검토를 시작하기 전에 &lt;a href=&quot;https://numpy.org/community/&quot;&gt;메일 링리스트 또는 Slack에&lt;/a&gt; 자신을 소개하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="4cd7980a2cd59fdcee19fe4e74bfa7516ad561f7" translate="yes" xml:space="preserve">
          <source>If we exit and restart our Python interpreter, we&amp;rsquo;ll see that we generate the same random numbers again:</source>
          <target state="translated">Python 인터프리터를 종료하고 다시 시작하면 동일한 난수를 다시 생성하는 것을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5905e93ff273c8c1408a7481f0933e6b894f0ba3" translate="yes" xml:space="preserve">
          <source>If we look at the &lt;code&gt;nbcases_ma&lt;/code&gt; masked array, this is what we have:</source>
          <target state="translated">&lt;code&gt;nbcases_ma&lt;/code&gt; 마스크 배열 을 살펴보면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="995e94e98f9bf00d5fa392b05fcaad89987b6cf9" translate="yes" xml:space="preserve">
          <source>If we operate on &lt;code&gt;arr&lt;/code&gt; with a numpy function, numpy will again use the &lt;code&gt;__array__&lt;/code&gt; interface to convert it to an array and then apply the function in the usual way.</source>
          <target state="translated">우리가에서 작동하는 경우 &lt;code&gt;arr&lt;/code&gt; NumPy와 기능, NumPy와 다시 사용 &lt;code&gt;__array__&lt;/code&gt; 배열로 변환 인터페이스를 다음 일반적인 방법으로 기능을 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a6db540dfc4c0d47c11450fd1091b665ccd4f2fc" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and it is this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">ndarray를 하위 클래스로 분류하는 경우 배열 유형의 명시 적 구성뿐만 아니라 &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; 또는 &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template 처리해야&lt;/a&gt; 합니다. NumPy는이를 수행 할 수있는 기계를 가지고 있으며, 서브 클래 싱을 약간 비표준으로 만드는 것은 바로이 기계입니다.</target>
        </trans-unit>
        <trans-unit id="f97977f7edcb7ebd515a426a761fd048280b35b8" translate="yes" xml:space="preserve">
          <source>If we subclass ndarray, we need to deal not only with explicit construction of our array type, but also &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; or &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template&lt;/a&gt;. NumPy has the machinery to do this, and this machinery that makes subclassing slightly non-standard.</source>
          <target state="translated">ndarray를 하위 클래스로 분류하는 경우 배열 유형의 명시 적 구성뿐만 아니라 &lt;a href=&quot;#view-casting&quot;&gt;View casting&lt;/a&gt; 또는 &lt;a href=&quot;#new-from-template&quot;&gt;Creating new from template 처리해야&lt;/a&gt; 합니다. NumPy에는이를 수행 할 수있는 기계가 있으며,이 기계는 서브 클래 싱을 약간 비표준으로 만듭니다.</target>
        </trans-unit>
        <trans-unit id="be3492efc8039f75947121fd3b30a1fa61841ee0" translate="yes" xml:space="preserve">
          <source>If we want to get the max and min at the same time, we can stack the indices first</source>
          <target state="translated">최대 값과 최소값을 동시에 얻으려면 먼저 인덱스를 쌓을 수 있습니다</target>
        </trans-unit>
        <trans-unit id="0b08db0a15b738091c43209c89bb138ad98fa1a5" translate="yes" xml:space="preserve">
          <source>If writing to the value in &amp;lsquo;op&amp;rsquo; is desired, set the boolean &amp;lsquo;writeable&amp;rsquo; to 1. This raises an error when &amp;lsquo;op&amp;rsquo; is a scalar, list of lists, or other non-writeable &amp;lsquo;op&amp;rsquo;. This differs from passing &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt;&lt;/a&gt; to PyArray_FromAny, where the writeable array may be a copy of the input.</source>
          <target state="translated">'op'의 값에 쓰는 것이 필요한 경우 부울 'writeable'을 1로 설정하십시오. 'op'가 스칼라, 목록 목록 또는 기타 쓸 수없는 'op'인 경우 오류가 발생합니다. 이것은 쓰기 가능한 배열이 입력의 사본 일 수있는 &lt;a href=&quot;#c.NPY_ARRAY_WRITEABLE&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEABLE&lt;/code&gt; &lt;/a&gt; 을 PyArray_FromAny 로 전달하는 것과 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="d75e358b391e7be55d7e5cd127dec8c0712acdf8" translate="yes" xml:space="preserve">
          <source>If you already have Matplotlib installed, you can import it with:</source>
          <target state="translated">이미 Matplotlib가 설치되어있는 경우 다음을 사용하여 가져올 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7cdef2e4118adffef01cdccc2d7928ddab94e772" translate="yes" xml:space="preserve">
          <source>If you already have Python, you can install NumPy with:</source>
          <target state="translated">이미 Python이있는 경우 다음을 사용하여 NumPy를 설치할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="541c45cda5d06a312d0d288fb58df06c65cc4253" translate="yes" xml:space="preserve">
          <source>If you are a first-time contributor:</source>
          <target state="translated">처음 참여하는 경우 :</target>
        </trans-unit>
        <trans-unit id="f5262e9ba4f1ea7a14023d90619c6e73faa9ab31" translate="yes" xml:space="preserve">
          <source>If you are a maintainer, and it is not obvious from the PR description, add a short explanation of what a branch did to the merge message and, if closing an issue, also add &amp;ldquo;Closes gh-123&amp;rdquo; where 123 is the issue number.</source>
          <target state="translated">관리자이고 PR 설명에서 명확하지 않은 경우 병합 메시지에 분기가 수행 한 작업에 대한 간단한 설명을 추가하고 문제를 닫을 경우 &quot;Closes gh-123&quot;도 추가합니다. 여기서 123은 문제 번호입니다. .</target>
        </trans-unit>
        <trans-unit id="62b5ecb7cbb27b133b9256518444e81bd1675873" translate="yes" xml:space="preserve">
          <source>If you are a subsequent reviewer on an already approved PR, please use the same review method as for a new PR (focus on the larger issues, resist the temptation to add only a few nitpicks). If you have commit rights and think no more review is needed, merge the PR.</source>
          <target state="translated">이미 승인 된 PR에 대한 후속 검토자인 경우 새 PR과 동일한 검토 방법을 사용하십시오 (더 큰 문제에 초점을 맞추고 몇 가지 중요한 부분 만 추가하려는 유혹에 저항하십시오). 커밋 권한이 있고 더 이상 검토가 필요하지 않다고 생각하는 경우 PR을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="df553e5d4398ed0e4dcd8bdb41c75c9a32748a9c" translate="yes" xml:space="preserve">
          <source>If you are constructing an array using the C API, and specifying your own memory, you should use the function &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt;&lt;code&gt;PyArray_SetBaseObject&lt;/code&gt;&lt;/a&gt; to set the base to an object which owns the memory.</source>
          <target state="translated">C API를 사용하여 배열을 구성하고 자체 메모리를 지정하는 경우 &lt;a href=&quot;#c.PyArray_SetBaseObject&quot;&gt; &lt;code&gt;PyArray_SetBaseObject&lt;/code&gt; &lt;/a&gt; 함수 를 사용하여 기본을 메모리를 소유 한 오브젝트로 설정 해야합니다 .</target>
        </trans-unit>
        <trans-unit id="348c2da24ae5fb5879e487ab21af4e5f5e066f22" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window.</source>
          <target state="translated">IPython 셸에서 위의 명령을 실행하는 경우 이미지 창을 표시하려면 &lt;code&gt;plt.show()&lt;/code&gt; 명령을 사용해야 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c6a49d79de12888270772f40fca378141c156019" translate="yes" xml:space="preserve">
          <source>If you are executing the commands above in the IPython shell, it might be necessary to use the command &lt;code&gt;plt.show()&lt;/code&gt; to show the image window. Note also that we use a semicolon at the end of a line to suppress its output, but this is optional.</source>
          <target state="translated">IPython 셸에서 위의 명령을 실행하는 경우 이미지 창을 표시하려면 &lt;code&gt;plt.show()&lt;/code&gt; 명령을 사용해야 할 수 있습니다 . 또한 출력을 억제하기 위해 줄 끝에 세미콜론을 사용하지만 이는 선택 사항입니다.</target>
        </trans-unit>
        <trans-unit id="39a6add3139de0ce389e24494d0e34b85d48e6cd" translate="yes" xml:space="preserve">
          <source>If you are not a subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend your class define special methods like &lt;code&gt;__add__&lt;/code&gt; and &lt;code&gt;__lt__&lt;/code&gt; that delegate to ufuncs just like ndarray does. An easy way to do this is to subclass from &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt;&lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">당신의 서브 클래스가 아닌 경우 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; , 우리는 당신의 클래스가 같은 특별한 방법을 정의하는 것이 좋습니다 &lt;code&gt;__add__&lt;/code&gt; 을 하고 &lt;code&gt;__lt__&lt;/code&gt; ndarray가하는 것처럼 ufuncs 해당 대리자를. 이를 수행하는 쉬운 방법은 &lt;a href=&quot;generated/numpy.lib.mixins.ndarrayoperatorsmixin#numpy.lib.mixins.NDArrayOperatorsMixin&quot;&gt; &lt;code&gt;NDArrayOperatorsMixin&lt;/code&gt; &lt;/a&gt; 에서 서브 클래스를 만드는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="7c035b2fcdae27121ab8105788f03a3cf705ba84" translate="yes" xml:space="preserve">
          <source>If you are unfamiliar with git/GitHub or the process of submitting a pull request (PR), check our &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide&lt;/a&gt;.</source>
          <target state="translated">git / GitHub 또는 pull request (PR) 제출 프로세스에 익숙하지 않은 경우 &lt;a href=&quot;index#devindex&quot;&gt;Contributor Guide를&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="ad4921cf970b61f597c75ff9a8df48494b979251" translate="yes" xml:space="preserve">
          <source>If you are unsure whether your tutorial is useful to the community, consider submitting an issue on GitHub suggesting it, or asking on the mailing list or Stack Overflow.</source>
          <target state="translated">튜토리얼이 커뮤니티에 유용한 지 확실하지 않은 경우 GitHub에서 제안하는 문제를 제출하거나 메일 링리스트 또는 Stack Overflow에 질문하십시오.</target>
        </trans-unit>
        <trans-unit id="0e97815d05cf1a3f4e8ef4ccabd6db0958203378" translate="yes" xml:space="preserve">
          <source>If you are using a development setup, make sure to run &lt;code&gt;git clean -xdf&lt;/code&gt; to delete all files not under version control (be careful not to lose any modifications you made, e.g. &lt;code&gt;site.cfg&lt;/code&gt;). In many cases files from old builds may lead to incorrect builds.</source>
          <target state="translated">개발 설정을 사용하는 경우 &lt;code&gt;git clean -xdf&lt;/code&gt; 를 실행 하여 버전 관리하에 있지 않은 모든 파일을 삭제해야합니다 (예 : &lt;code&gt;site.cfg&lt;/code&gt; 와 같이 수정 한 내용을 잃지 않도록주의 하십시오 ). 대부분의 경우 이전 빌드의 파일은 잘못된 빌드로 이어질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1cb5159432a421c78854c686fcae1e006f9ca62" translate="yes" xml:space="preserve">
          <source>If you are using your own image, this command might take a while to run, depending on the size of your image and your hardware. Don&amp;rsquo;t worry, this is normal! The SVD can be a pretty intensive computation.</source>
          <target state="translated">자체 이미지를 사용하는 경우 이미지 및 하드웨어의 크기에 따라이 명령을 실행하는 데 시간이 걸릴 수 있습니다. 걱정하지 마세요. 이것은 정상입니다! SVD는 매우 집약적 인 계산이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="430c1a827d0587f2549b92fdcd570838e5c44e06" translate="yes" xml:space="preserve">
          <source>If you are writing a package that you&amp;rsquo;d like to become part of NumPy, please write the tests as you develop the package. Every Python module, extension module, or subpackage in the NumPy package directory should have a corresponding &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; file. Pytest examines these files for test methods (named &lt;code&gt;test*&lt;/code&gt;) and test classes (named &lt;code&gt;Test*&lt;/code&gt;).</source>
          <target state="translated">NumPy의 일부가되고 싶은 패키지를 작성하는 경우 패키지를 개발할 때 테스트를 작성하십시오. NumPy 패키지 디렉토리의 모든 Python 모듈, 확장 모듈 또는 하위 패키지에는 해당 &lt;code&gt;test_&amp;lt;name&amp;gt;.py&lt;/code&gt; 파일이 있어야 합니다. Pytest는 이러한 파일에서 테스트 메서드 ( &lt;code&gt;test*&lt;/code&gt; ) 및 테스트 클래스 ( &lt;code&gt;Test*&lt;/code&gt; )를 검사 합니다.</target>
        </trans-unit>
        <trans-unit id="773329737315bec4048498e2cb47eae44fac50c7" translate="yes" xml:space="preserve">
          <source>If you are writing a tutorial or how-to, we encourage you to use real images and data (provided they are appropriately licensed and available). This makes the material more engaging for readers, and choosing the right data can add pedagogical value to your content.</source>
          <target state="translated">자습서 또는 방법을 작성하는 경우 실제 이미지와 데이터를 사용하는 것이 좋습니다 (적절하게 라이선스가 부여되고 사용 가능한 경우). 이를 통해 독자의 관심을 끌 수 있으며 올바른 데이터를 선택하면 콘텐츠에 교육적 가치를 더할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d4136f331004a4bb7cc67364f6afc023fd507b25" translate="yes" xml:space="preserve">
          <source>If you are writing an extension module that will include quite a bit of your own algorithmic code as well, then Cython is a good match. Among its features is the ability to easily and quickly work with multidimensional arrays.</source>
          <target state="translated">자체 알고리즘 코드도 상당히 많이 포함하는 확장 모듈을 작성하는 경우 Cython이 좋은 일치입니다. 그 특징 중 하나는 다차원 배열로 쉽고 빠르게 작업 할 수있는 능력입니다.</target>
        </trans-unit>
        <trans-unit id="97bfbc5e92312fd81c84cc357b8b556f1c360029" translate="yes" xml:space="preserve">
          <source>If you are writing code that needs to support older versions of numpy, note that prior to 1.15, &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; was not a context manager and did not have a &lt;code&gt;close&lt;/code&gt; method. Instead it relied on the destructor to initiate the writeback of the buffer.</source>
          <target state="translated">이전 버전의 numpy를 지원해야하는 코드를 작성하는 경우 1.15 이전에는 &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; &lt;/a&gt; 가 컨텍스트 관리자가 아니 었고 &lt;code&gt;close&lt;/code&gt; 메서드 가 없었 습니다 . 대신 버퍼의 쓰기 저장을 시작하기 위해 소멸자에 의존했습니다.</target>
        </trans-unit>
        <trans-unit id="36ae6f737ad58a255ae0b7d304bf552b5362f8bf" translate="yes" xml:space="preserve">
          <source>If you are writing the algorithm, then I recommend that you use the stride information contained in the array to access the elements of the array (the &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt;&lt;code&gt;PyArray_GetPtr&lt;/code&gt;&lt;/a&gt; macros make this painless). Then, you can relax your requirements so as not to force a single-segment array and the data-copying that might result.</source>
          <target state="translated">알고리즘을 작성하는 경우 배열의 요소에 액세스하기 위해 배열에 포함 된 보폭 정보를 사용하는 것이 좋습니다 ( &lt;a href=&quot;../reference/c-api/array#c.PyArray_GetPtr&quot;&gt; &lt;code&gt;PyArray_GetPtr&lt;/code&gt; &lt;/a&gt; 매크로를 사용하면이 작업을 쉽게 수행 할 수 있습니다). 그런 다음 단일 세그먼트 어레이 및 결과적으로 발생할 수있는 데이터 복사를 강제하지 않도록 요구 사항을 완화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b55dd90ddf002e60cb33ced8fd77f1baf2f3e711" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t already comfortable with reading tutorials that contain a lot of code, you might not know how to interpret a code block that looks like this:</source>
          <target state="translated">많은 코드가 포함 된 자습서를 읽는 데 익숙하지 않은 경우 다음과 같은 코드 블록을 해석하는 방법을 모를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0aadabdedda0a7396088f7e7156f2221bf29f201" translate="yes" xml:space="preserve">
          <source>If you aren&amp;rsquo;t familiar with this style, it&amp;rsquo;s very easy to understand. If you see &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt;, you&amp;rsquo;re looking at &lt;strong&gt;input&lt;/strong&gt;, or the code that you would enter. Everything that doesn&amp;rsquo;t have &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; in front of it is &lt;strong&gt;output&lt;/strong&gt;, or the results of running your code. This is the style you see when you run &lt;code&gt;python&lt;/code&gt; on the command line, but if you&amp;rsquo;re using IPython, you might see a different style.</source>
          <target state="translated">이 스타일에 익숙하지 않다면 이해하기 매우 쉽습니다. 당신이 볼 경우 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 당신이보고있는 &lt;strong&gt;입력&lt;/strong&gt; 하거나 입력해야하는 코드입니다. 앞에 &lt;code&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/code&gt; 가없는 것은 모두 &lt;strong&gt;output&lt;/strong&gt; 이거나 코드를 실행 한 결과입니다. 이것은 명령 줄에서 &lt;code&gt;python&lt;/code&gt; 을 실행할 때 표시되는 스타일 이지만 IPython을 사용하는 경우 다른 스타일을 볼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb14ac1edba829d3112a46c925f71b9aef58fe4d" translate="yes" xml:space="preserve">
          <source>If you begin with a 1D array like this one:</source>
          <target state="translated">다음과 같은 1D 배열로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="241e24cd0257dc01f27616c2644b10c2652843e7" translate="yes" xml:space="preserve">
          <source>If you can&amp;rsquo;t avoid or eliminate missing values, but don&amp;rsquo;t want to deal with &lt;a href=&quot;../reference/constants#numpy.nan&quot;&gt;&lt;code&gt;NaN&lt;/code&gt;&lt;/a&gt; (Not A Number) values in your operations.</source>
          <target state="translated">누락 된 값을 피하거나 제거 할 수 없지만 작업에서 &lt;a href=&quot;../reference/constants#numpy.nan&quot;&gt; &lt;code&gt;NaN&lt;/code&gt; &lt;/a&gt; (Not A Number) 값 을 처리하고 싶지 않은 경우 .</target>
        </trans-unit>
        <trans-unit id="50d785ffa376c738acba9fd3062d7ce8c3507854" translate="yes" xml:space="preserve">
          <source>If you construct an array by passing in your own memory buffer as a parameter, you need to set the array&amp;rsquo;s &lt;code&gt;base&lt;/code&gt; property to ensure the lifetime of the memory buffer is appropriate.</source>
          <target state="translated">자체 메모리 버퍼를 매개 변수로 전달하여 배열을 구성하는 경우 메모리 버퍼 의 수명이 적절하도록 배열의 &lt;code&gt;base&lt;/code&gt; 속성을 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5a09672523495c2e56a3b155436551396bec1686" translate="yes" xml:space="preserve">
          <source>If you created this array &amp;ldquo;a&amp;rdquo;</source>
          <target state="translated">이 어레이 &quot;a&quot;를 생성 한 경우</target>
        </trans-unit>
        <trans-unit id="72ea524f17d30ae2b5b06f8b246da402ecc0aab1" translate="yes" xml:space="preserve">
          <source>If you define &lt;code&gt;__array_ufunc__&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;__array_ufunc__&lt;/code&gt; 를 정의하는 경우 :</target>
        </trans-unit>
        <trans-unit id="ad02ce8758b2b7ef1353b5d6ceccf301d0d32341" translate="yes" xml:space="preserve">
          <source>If you depend on the current behavior, then we suggest copying the returned array explicitly, i.e., use &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; instead of just &lt;code&gt;np.diagonal(a)&lt;/code&gt;. This will work with both past and future versions of NumPy.</source>
          <target state="translated">현재 동작에 의존하는 경우 반환 된 배열을 명시 적으로 복사하는 것이 좋습니다. 즉, &lt;code&gt;np.diagonal(a).copy()&lt;/code&gt; 대신 np.diagonal (a) .copy ()를 사용하는 것이 &lt;code&gt;np.diagonal(a)&lt;/code&gt; . 이것은 NumPy의 과거와 미래 버전 모두에서 작동합니다.</target>
        </trans-unit>
        <trans-unit id="e04ecd6da4be5a785c0ba7636ed164c9197444de" translate="yes" xml:space="preserve">
          <source>If you didn&amp;rsquo;t actually mess up but there are merge conflicts, you need to resolve those. This can be one of the trickier things to get right. For a good description of how to do this, see &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;this article on merging conflicts&lt;/a&gt;.</source>
          <target state="translated">실제로 엉망이되지 않았지만 병합 충돌이있는 경우이를 해결해야합니다. 이것은 제대로하기 위해 까다로운 일 중 하나 일 수 있습니다. 이를 수행하는 방법에 대한 자세한 설명은 &lt;a href=&quot;https://git-scm.com/book/en/Git-Branching-Basic-Branching-and-Merging#Basic-Merge-Conflicts&quot;&gt;충돌 병합에&lt;/a&gt; 대한 이 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="e434a6791515ca1be095b9c944cc43b7244bf754" translate="yes" xml:space="preserve">
          <source>If you do this often, consider making CDN_URL and NPY_WHLS part of your default environment.</source>
          <target state="translated">이 작업을 자주 수행하는 경우 CDN_URL 및 NPY_WHLS를 기본 환경의 일부로 만드는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="48d4a9d3c1a910573f5c99d8162fc661353211a4" translate="yes" xml:space="preserve">
          <source>If you do want to use Fortran ordering realize that there are two approaches to consider: 1) accept that the first index is just not the most rapidly changing in memory and have all your I/O routines reorder your data when going from memory to disk or visa versa, or use numpy&amp;rsquo;s mechanism for mapping the first index to the most rapidly varying data. We recommend the former if possible. The disadvantage of the latter is that many of numpy&amp;rsquo;s functions will yield arrays without Fortran ordering unless you are careful to use the &amp;lsquo;order&amp;rsquo; keyword. Doing this would be highly inconvenient.</source>
          <target state="translated">Fortran 순서를 사용하려면 고려해야 할 두 가지 접근 방식이 있다는 것을 인식하십시오. 또는 비자를 사용하거나 numpy의 메커니즘을 사용하여 첫 번째 인덱스를 가장 빠르게 변하는 데이터에 매핑하십시오. 가능하면 전자를 권장합니다. 후자의 단점은 'order'키워드를주의해서 사용하지 않는 한 많은 numpy 함수가 포트란 순서없이 배열을 생성한다는 것입니다. 이렇게하는 것은 매우 불편합니다.</target>
        </trans-unit>
        <trans-unit id="e095aad5306acb61c4cd71ef6f17e3d170477a48" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have Python yet, you might want to consider using &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt;. It&amp;rsquo;s the easiest way to get started. The good thing about getting this distribution is the fact that you don&amp;rsquo;t need to worry too much about separately installing NumPy or any of the major packages that you&amp;rsquo;ll be using for your data analyses, like pandas, Scikit-Learn, etc.</source>
          <target state="translated">아직 Python이없는 경우 &lt;a href=&quot;https://www.anaconda.com/&quot;&gt;Anaconda&lt;/a&gt; 사용을 고려할 수 있습니다 . 시작하는 가장 쉬운 방법입니다. 이 배포판을 얻을 때 좋은 점은 NumPy 또는 pandas, Scikit-Learn 등과 같은 데이터 분석에 사용할 주요 패키지를 별도로 설치하는 것에 대해 너무 걱정할 필요가 없다는 사실입니다.</target>
        </trans-unit>
        <trans-unit id="a32666f1e22aaef44f676905cda497776944f399" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; account, go to the &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; page, and make one.</source>
          <target state="translated">&lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 계정 이없는 경우 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 페이지 로 이동하여 계정 을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="a5bbc2f6b8c16d724bb2e3ebb23419fa6ae79cb5" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t have a GitHub account, visit &lt;a href=&quot;https://github.com/join&quot;&gt;https://github.com/join&lt;/a&gt; to create one.</source>
          <target state="translated">GitHub 계정이없는 경우 &lt;a href=&quot;https://github.com/join&quot;&gt;https://github.com/join&lt;/a&gt; 을 방문 하여 계정 을 만드십시오.</target>
        </trans-unit>
        <trans-unit id="00332ddab35edaceba6aacb138a662dde934bdb6" translate="yes" xml:space="preserve">
          <source>If you don&amp;rsquo;t write to the array returned by this function, then you can just ignore all of the above.</source>
          <target state="translated">이 함수가 반환 한 배열에 쓰지 않으면 위의 모든 내용을 무시해도됩니다.</target>
        </trans-unit>
        <trans-unit id="ddf01261f92656913e0a2ec2a624205e1c2e4b27" translate="yes" xml:space="preserve">
          <source>If you forgot to make a backup branch:</source>
          <target state="translated">백업 브랜치를 만드는 것을 잊은 경우 :</target>
        </trans-unit>
        <trans-unit id="fe80a2730dc1732963891b3491f20ea69996dc7b" translate="yes" xml:space="preserve">
          <source>If you get a Python error that looks like the following:</source>
          <target state="translated">다음과 같은 Python 오류가 발생하는 경우</target>
        </trans-unit>
        <trans-unit id="a53df4d5bfbd08adf0a5725999a9e0795dcb81f8" translate="yes" xml:space="preserve">
          <source>If you have a collection of tests that must be run multiple times with minor variations, it can be helpful to create a base class containing all the common tests, and then create a subclass for each variation. Several examples of this technique exist in NumPy; below are excerpts from one in &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy/linalg/tests/test_linalg.py&lt;/a&gt;:</source>
          <target state="translated">약간의 변형으로 여러 번 실행해야하는 테스트 모음이있는 경우 모든 공통 테스트를 포함하는 기본 클래스를 만든 다음 각 변형에 대한 하위 클래스를 만드는 것이 도움이 될 수 있습니다. 이 기술의 몇 가지 예가 NumPy에 존재합니다. 아래는 &lt;a href=&quot;https://github.com/numpy/numpy/blob/master/numpy/linalg/tests/test_linalg.py&quot;&gt;numpy / linalg / tests / test_linalg.py&lt;/a&gt; 에서 발췌 한 것입니다 .</target>
        </trans-unit>
        <trans-unit id="b76d68a8292694b360bf5a2e8b28bbbb6775f004" translate="yes" xml:space="preserve">
          <source>If you have already decided which type of document you want to write, you can check out the following specific guides:</source>
          <target state="translated">작성하려는 문서 유형을 이미 결정한 경우 다음 특정 가이드를 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="edd73a9e41446ceec5844edddba90601c9a86d6a" translate="yes" xml:space="preserve">
          <source>If you have an array of datetime64 day values, and you want a count of how many of them are valid dates, you can do this:</source>
          <target state="translated">datetime64 일 값의 배열이 있고 유효한 날짜 수를 원하는 경우 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="afdea327e298d690859d2830125b0506072aa9c8" translate="yes" xml:space="preserve">
          <source>If you have made changes to files that have changed also upstream, this may generate merge conflicts that you need to resolve. See &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;below&lt;/a&gt; for help in this case.</source>
          <target state="translated">업스트림에서도 변경된 파일을 변경 한 경우 해결해야하는 병합 충돌이 발생할 수 있습니다. 이 경우 도움이 필요하면 &lt;a href=&quot;#recovering-from-mess-up&quot;&gt;아래&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3940d12fada6e74d3a4f390741c7084734cc9f7c" translate="yes" xml:space="preserve">
          <source>If you have worked before with only one- or two-dimensional arrays in NumPy, you might use &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt;&lt;code&gt;numpy.dot&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt; (or the &lt;code&gt;@&lt;/code&gt; operator) interchangeably. However, for n-dimensional arrays, they work in very different ways. For more details, check the documentation &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt;&lt;code&gt;numpy.matmul&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이전에 NumPy에서 1 차원 또는 2 차원 배열로만 작업 한 적이 있다면 &lt;a href=&quot;../reference/generated/numpy.dot#numpy.dot&quot;&gt; &lt;code&gt;numpy.dot&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; &lt;/a&gt; (또는 &lt;code&gt;@&lt;/code&gt; 연산자)을 같은 의미로 사용할 수 있습니다. 그러나 n 차원 배열의 경우 매우 다른 방식으로 작동합니다. 자세한 내용은 문서 &lt;a href=&quot;../reference/generated/numpy.matmul#numpy.matmul&quot;&gt; &lt;code&gt;numpy.matmul&lt;/code&gt; 을&lt;/a&gt; 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="61245264d3565a00eccec23e4c121348aa40e38c" translate="yes" xml:space="preserve">
          <source>If you index &lt;code&gt;x&lt;/code&gt; at position 1 you get a structure:</source>
          <target state="translated">위치 1에서 &lt;code&gt;x&lt;/code&gt; 를 인덱싱하면 다음과 같은 구조를 얻을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="19e171dd0ccd0c17916e231c961dda814be7cba5" translate="yes" xml:space="preserve">
          <source>If you just use Cython to compile a standard Python module, then you will get a C extension module that typically runs a bit faster than the equivalent Python module. Further speed increases can be gained by using the &lt;code&gt;cdef&lt;/code&gt; keyword to statically define C variables.</source>
          <target state="translated">Cython을 사용하여 표준 Python 모듈을 컴파일하는 경우 일반적으로 동등한 Python 모듈보다 약간 빠르게 실행되는 C 확장 모듈을 얻을 수 있습니다. &lt;code&gt;cdef&lt;/code&gt; 키워드를 사용하여 C 변수를 정적으로 정의 하면 속도를 더 높일 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4f3f5ddc9a07a1a97f869fb8e6afa7a875ab6d2" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: &lt;code&gt;z
= (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2)&lt;/code&gt;. The absence of NumPy operator forms of &lt;code&gt;logical_and&lt;/code&gt; and &lt;code&gt;logical_or&lt;/code&gt; is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">부울 인수가 있다는 것을 알고 있다면 NumPy의 비트 연산자를 사용하지 않아도되지만 다음과 같이 괄호에주의하십시오 : &lt;code&gt;z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2)&lt;/code&gt; . NumPy 연산자 형태의 &lt;code&gt;logical_and&lt;/code&gt; 및 &lt;code&gt;logical_or&lt;/code&gt; 가 없다는 것은 Python 설계의 불행한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="0c28db0c64cef3fce82c680e83d5a3bf5a7d6611" translate="yes" xml:space="preserve">
          <source>If you know you have boolean arguments, you can get away with using NumPy&amp;rsquo;s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of NumPy operator forms of logical_and and logical_or is an unfortunate consequence of Python&amp;rsquo;s design.</source>
          <target state="translated">부울 인수가 있다는 것을 알고 있다면 NumPy의 비트 연산자를 사용하지 않아도되지만 다음과 같이 괄호에주의하십시오 : z = (x&amp;gt; 1) &amp;amp; (x &amp;lt;2). NumPy 연산자 형태의 logical_and 및 logical_or가 없다는 것은 Python 설계의 불행한 결과입니다.</target>
        </trans-unit>
        <trans-unit id="b50bdabfd893e921c2545949ea3927871fd9123c" translate="yes" xml:space="preserve">
          <source>If you mess up during a rebase:</source>
          <target state="translated">리베이스 중에 엉망이 된 경우 :</target>
        </trans-unit>
        <trans-unit id="d5b391b72fd29e26b5330f8bc73fd6e0406a58fe" translate="yes" xml:space="preserve">
          <source>If you need a stricter way to identify a &lt;em&gt;numerical&lt;/em&gt; scalar, use &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt;, as that returns &lt;code&gt;False&lt;/code&gt; for most non-numerical elements such as strings.</source>
          <target state="translated">&lt;em&gt;숫자 형&lt;/em&gt; 스칼라 를 식별하는 더 엄격한 방법이 필요한 경우 &lt;code&gt;isinstance(x, numbers.Number)&lt;/code&gt; 를 사용하십시오. 문자열과 같은 대부분의 숫자가 아닌 요소에 대해 &lt;code&gt;False&lt;/code&gt; 를 반환 하기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="c4cb8ac1ba0fb6fc334cc562794b2ebe83f971f7" translate="yes" xml:space="preserve">
          <source>If you need help writing replies in reviews, check out some &lt;a href=&quot;https://scikit-learn.org/stable/developers/tips.html#saved-replies&quot;&gt;Standard replies for reviewing&lt;/a&gt;.</source>
          <target state="translated">리뷰에 답글을 작성하는 데 도움이 필요하면 &lt;a href=&quot;https://scikit-learn.org/stable/developers/tips.html#saved-replies&quot;&gt;검토를위한 표준 답글을&lt;/a&gt; 확인하세요 .</target>
        </trans-unit>
        <trans-unit id="6b620559920ae0493b1df8c4590d21b79ff5570f" translate="yes" xml:space="preserve">
          <source>If you need to generate a good seed &amp;ldquo;offline&amp;rdquo;, then &lt;code&gt;SeedSequence().entropy&lt;/code&gt; or using &lt;code&gt;secrets.randbits(128)&lt;/code&gt; from the standard library are both convenient ways.</source>
          <target state="translated">좋은 시드 &quot;오프라인&quot;을 생성해야하는 경우 &lt;code&gt;SeedSequence().entropy&lt;/code&gt; 또는 표준 라이브러리의 &lt;code&gt;secrets.randbits(128)&lt;/code&gt; 를 사용하는 것이 편리한 방법입니다.</target>
        </trans-unit>
        <trans-unit id="9dadc35707bb7693c411ca705b6a79a8fd4bc6a1" translate="yes" xml:space="preserve">
          <source>If you need to generate a plot for your values, it&amp;rsquo;s very simple with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;.</source>
          <target state="translated">값에 대한 플롯을 생성해야하는 경우 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib를 사용&lt;/a&gt; 하면 매우 간단 합니다.</target>
        </trans-unit>
        <trans-unit id="cd4f29a22f2d83f814cd7d3d9fed381be8da6e41" translate="yes" xml:space="preserve">
          <source>If you notice you messed up after the rebase:</source>
          <target state="translated">리베이스 후에 엉망이 된 것을 발견하면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="ee201455e7a9931a5a44547dd0593d53785f3676" translate="yes" xml:space="preserve">
          <source>If you obtained NumPy via git, get also the git submodules that contain additional parts required for building the documentation:</source>
          <target state="translated">git을 통해 NumPy를 얻은 경우 문서 작성에 필요한 추가 부분이 포함 된 git 하위 모듈도 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="fafc92af92f970e1f9bc871b99562e2a4dcbfd58" translate="yes" xml:space="preserve">
          <source>If you only had $150/month to pay towards the loan, how long would it take to pay-off a loan of $8,000 at 7% annual interest?</source>
          <target state="translated">대출에 대해 $ 150 / 월만 지불했다면 연간 이자율 7 %로 $ 8,000의 대출을 상환하는 데 얼마나 걸립니까?</target>
        </trans-unit>
        <trans-unit id="f1851d09e17596b6fef1418fbf6cd4eb3f3c1218" translate="yes" xml:space="preserve">
          <source>If you only want to get the documentation, note that pre-built versions can be found at</source>
          <target state="translated">문서 만 얻으려면 미리 빌드 된 버전은 다음 위치에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cdaa058c528b9ed4b2670e6e57274ac82ee4b4cf" translate="yes" xml:space="preserve">
          <source>If you plan a new feature or API change, it&amp;rsquo;s wisest to first email the NumPy &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; asking for comment. If you haven&amp;rsquo;t heard back in a week, it&amp;rsquo;s OK to ping the list again.</source>
          <target state="translated">새로운 기능이나 API 변경을 계획하고 있다면 먼저 NumPy &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;메일 링리스트에&lt;/a&gt; 이메일 로 의견을 요청 하는 것이 가장 현명합니다 . 일주일 동안 답장을받지 못했다면 목록을 다시 핑 (ping)해도됩니다.</target>
        </trans-unit>
        <trans-unit id="4ba77d4ac4c0346cf08567fdade124408903e3ad" translate="yes" xml:space="preserve">
          <source>If you prefer, you can use your own image as you work through this tutorial. In order to transform your image into a NumPy array that can be manipulated, you can use the &lt;code&gt;imread&lt;/code&gt; function from the &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt;&lt;code&gt;matplotlib.pyplot&lt;/code&gt;&lt;/a&gt; submodule. Alternatively, you can use the &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt;&lt;code&gt;imageio.imread&lt;/code&gt;&lt;/a&gt; function from the &lt;code&gt;imageio&lt;/code&gt; library. Be aware that if you use your own image, you&amp;rsquo;ll likely need to adapt the steps below. For more information on how images are treated when converted to NumPy arrays, see &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;A crash course on NumPy for images&lt;/a&gt; from the &lt;code&gt;scikit-image&lt;/code&gt; documentation.</source>
          <target state="translated">원하는 경우이 자습서를 진행하면서 자신의 이미지를 사용할 수 있습니다. 이미지를 조작 할 수있는 NumPy 배열로 변환 하려면 &lt;a href=&quot;https://matplotlib.org/api/_as_gen/matplotlib.pyplot.html#module-matplotlib.pyplot&quot;&gt; &lt;code&gt;matplotlib.pyplot&lt;/code&gt; &lt;/a&gt; 하위 모듈 에서 &lt;code&gt;imread&lt;/code&gt; 함수를 사용할 수 있습니다 . 또는 &lt;code&gt;imageio&lt;/code&gt; 라이브러리 에서 &lt;a href=&quot;https://imageio.readthedocs.io/en/stable/userapi.html#imageio.imread&quot;&gt; &lt;code&gt;imageio.imread&lt;/code&gt; &lt;/a&gt; 함수를 사용할 수 있습니다 . 자신의 이미지를 사용하는 경우 아래 단계를 조정해야 할 수 있습니다. NumPy 배열로 변환 할 때 이미지가 처리되는 방법에 대한 자세한 내용 은 &lt;code&gt;scikit-image&lt;/code&gt; 문서의 &lt;a href=&quot;https://scikit-image.org/docs/stable/user_guide/numpy_images.html&quot;&gt;이미지에 대한 NumPy&lt;/a&gt; 의 집중 과정을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="163df9c9003b7c4450bb235f2c67b2a07c0207a6" translate="yes" xml:space="preserve">
          <source>If you run &lt;code&gt;f2py&lt;/code&gt; with no arguments, and the line &lt;code&gt;numpy Version&lt;/code&gt; at the end matches the NumPy version printed from &lt;code&gt;python -m numpy.f2py&lt;/code&gt;, then you can use the shorter version. If not, or if you cannot run &lt;code&gt;f2py&lt;/code&gt;, you should replace all calls to &lt;code&gt;f2py&lt;/code&gt; here with the longer version.</source>
          <target state="translated">인수없이 &lt;code&gt;f2py&lt;/code&gt; 를 실행 하고 끝에있는 &lt;code&gt;numpy Version&lt;/code&gt; 줄 이 &lt;code&gt;python -m numpy.f2py&lt;/code&gt; 에서 인쇄 된 NumPy 버전과 일치 하면 더 짧은 버전을 사용할 수 있습니다. 그렇지 않거나 &lt;code&gt;f2py&lt;/code&gt; 를 실행할 수없는 경우 여기 에서 &lt;code&gt;f2py&lt;/code&gt; 에 대한 모든 호출을 더 긴 버전으로 대체해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e2ea4dd191a98ee740334a65dcfa6ac018c3ad8c" translate="yes" xml:space="preserve">
          <source>If you run across outside material that would be a useful addition to the NumPy docs, let us know by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue&lt;/a&gt;.</source>
          <target state="translated">NumPy 문서에 유용한 추가 자료가 될 외부 자료를 발견 한 &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;경우 문제&lt;/a&gt; 를 열어 알려주십시오 .</target>
        </trans-unit>
        <trans-unit id="c2f8a5ed085feb6d7cb818c6bb6a9239c65b61dd" translate="yes" xml:space="preserve">
          <source>If you run into a situation where a function or method is returning a pointer to an array, your best bet is to write your own version of the function to be wrapped, either with &lt;code&gt;%extend&lt;/code&gt; for the case of class methods or &lt;code&gt;%ignore&lt;/code&gt; and &lt;code&gt;%rename&lt;/code&gt; for the case of functions.</source>
          <target state="translated">함수 또는 메소드가 배열에 대한 포인터를 리턴하는 상황이 발생하는 경우 클래스 메소드의 경우 &lt;code&gt;%extend&lt;/code&gt; 또는 &lt;code&gt;%ignore&lt;/code&gt; 및 &lt;code&gt;%rename&lt;/code&gt; 중 하나를 사용하여 랩핑 할 함수의 자체 버전을 작성하는 것이 가장 좋습니다. 함수의 경우 이름 을 바꿉니다 .</target>
        </trans-unit>
        <trans-unit id="2a7a60ee3a192da84e7197524a79fee3ab370312" translate="yes" xml:space="preserve">
          <source>If you see a good tutorial, how-to or explanation that is not included in the official documentation, you can suggest it to be added by &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;opening an issue on GitHub&lt;/a&gt;. Similarly, opening issues to suggest a tutorial, how-to or explanation that you can&amp;rsquo;t find anywhere is a great way to help the documentation team direct efforts towards what users are looking for. &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;See this issue&lt;/a&gt; for an example of how to do this.</source>
          <target state="translated">공식 문서에 포함되지 않은 좋은 튜토리얼, 방법 또는 설명이 보이면 &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;GitHub에서 문제를 열어&lt;/a&gt; 추가하도록 제안 할 수 있습니다 . 마찬가지로, 어디서도 찾을 수없는 튜토리얼, 방법 또는 설명을 제안하기 위해 이슈를 여는 것은 문서 팀이 사용자가 찾고있는 것에 대한 직접적인 노력을 기울이는 데 도움이되는 좋은 방법입니다. 이를 수행하는 방법의 예는 &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;이 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="c084a3f2a6106a54039205662cc0565194fa0738" translate="yes" xml:space="preserve">
          <source>If you specify an &lt;code&gt;n&lt;/code&gt; such that &lt;code&gt;a&lt;/code&gt; must be zero-padded or truncated, the extra/removed values will be added/removed at high frequencies. One can thus resample a series to &lt;code&gt;m&lt;/code&gt; points via Fourier interpolation by: &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt;.</source>
          <target state="translated">당신이를 지정하면 &lt;code&gt;n&lt;/code&gt; 하도록 &lt;code&gt;a&lt;/code&gt; 제로 패딩 또는 절단해야합니다, 추가 / 제거 값이 높은 주파수에서 삭제 / 추가됩니다. 따라서 &lt;code&gt;a_resamp = irfft(rfft(a), m)&lt;/code&gt; 의해 푸리에 보간을 통해 시리즈를 &lt;code&gt;m&lt;/code&gt; 포인트로 리샘플링 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="dd256004a74583cc184f8439d5d048c30d412fb7" translate="yes" xml:space="preserve">
          <source>If you start with these arrays:</source>
          <target state="translated">이러한 배열로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="b2448ad4b64da661ec458b63dd3b9923ea02aca5" translate="yes" xml:space="preserve">
          <source>If you start with this array:</source>
          <target state="translated">이 어레이로 시작하는 경우 :</target>
        </trans-unit>
        <trans-unit id="777d1be2db0dc4450d7b4eef96ddf2f8d5888d83" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 를 서브 클래 싱하는 경우 모든 재정의 논리를 &lt;code&gt;__array_ufunc__&lt;/code&gt; 에 넣고 특수 메서드를 재정의 하는 것이 좋습니다 . 이렇게하면 클래스 계층 구조가 ufunc 기계와 이진 작업 규칙 (하위 클래스의 특수한 방법을 선호 함, &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 를 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; 은 서브 클래스가 ufunc와 전혀 작동하지 않으므로 매우 예기치 않게 혼란스러워 보일 것입니다.</target>
        </trans-unit>
        <trans-unit id="2b988c177dc2b27c86ba6dc5904e8834a5cbf804" translate="yes" xml:space="preserve">
          <source>If you subclass &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;, we recommend that you put all your override logic in &lt;code&gt;__array_ufunc__&lt;/code&gt; and not also override special methods. This ensures the class hierarchy is determined in only one place rather than separately by the ufunc machinery and by the binary operation rules (which gives preference to special methods of subclasses; the alternative way to enforce a one-place only hierarchy, of setting &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt;&lt;code&gt;__array_ufunc__&lt;/code&gt;&lt;/a&gt; to None, would seem very unexpected and thus confusing, as then the subclass would not work at all with ufuncs).</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 하위 클래스를 만드는 경우 모든 재정의 논리를 &lt;code&gt;__array_ufunc__&lt;/code&gt; 에 배치 하고 특수 메서드도 재정의하지 않는 것이 좋습니다 . 이렇게하면 클래스 계층 구조가 ufunc 기계 및 이진 연산 규칙 (하위 클래스의 특수 메서드에 우선권을 부여 함)이 아닌 한 위치에서만 &lt;a href=&quot;#numpy.class.__array_ufunc__&quot;&gt; &lt;code&gt;__array_ufunc__&lt;/code&gt; &lt;/a&gt; 됩니다. 없음, 하위 클래스가 ufuncs와 전혀 작동하지 않으므로 매우 예상치 못한 것처럼 보이므로 혼란 스러울 것입니다.)</target>
        </trans-unit>
        <trans-unit id="68630e24ebcf26648c6330182b68ffff11c7fe21" translate="yes" xml:space="preserve">
          <source>If you want to allow your new data-type to also be able to share in the scalar coercion rules, then you need to specify the scalarkind function in the data-type object&amp;rsquo;s &amp;ldquo;.f&amp;rdquo; member to return the kind of scalar the new data-type should be seen as (the value of the scalar is available to that function). Then, you can register data-types that can be cast to separately for each scalar kind that may be returned from your user-defined data-type. If you don&amp;rsquo;t register scalar coercion handling, then all of your user-defined data-types will be seen as &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">새 데이터 유형이 스칼라 강제 규칙에서도 공유 할 수 있도록하려면 데이터 유형 객체의 &quot;.f&quot;멤버에 scalarkind 함수를 지정하여 새 데이터의 스칼라 종류를 반환해야합니다. -type은 다음과 같이 표시되어야합니다 (스칼라 값은 해당 함수에서 사용할 수 있음). 그런 다음 사용자 정의 데이터 유형에서 반환 될 수있는 각 스칼라 종류에 대해 별도로 캐스트 할 수있는 데이터 유형을 등록 할 수 있습니다. 스칼라 강제 처리를 등록하지 않으면 모든 사용자 정의 데이터 유형이 &lt;a href=&quot;../reference/c-api/array#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt; 로 표시됩니다 .</target>
        </trans-unit>
        <trans-unit id="b381b011cdbc746e6a1a9147256650f6139d3056" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; and &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy&lt;/a&gt; installed on your computer.</source>
          <target state="translated">이 자습서의 예제를 실행하려면 컴퓨터에 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; 및 &lt;a href=&quot;https://scipy.org&quot;&gt;SciPy도&lt;/a&gt; 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="e0e8bade3a2638408b33822bff54e29660bf3ff4" translate="yes" xml:space="preserve">
          <source>If you want to be able to run the examples in this tutorial, you should also have &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib&lt;/a&gt; installed on your computer.</source>
          <target state="translated">이 자습서의 예제를 실행하려면 컴퓨터에 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;matplotlib도&lt;/a&gt; 설치되어 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="aaf81dbd7051e065aedb8dd44063737fadd7deaa" translate="yes" xml:space="preserve">
          <source>If you want to build NumPy in order to work on NumPy itself, use &lt;code&gt;runtests.py&lt;/code&gt;.To run NumPy&amp;rsquo;s full test suite:</source>
          <target state="translated">NumPy 자체에서 작업하기 위해 NumPy를 빌드하려면 &lt;code&gt;runtests.py&lt;/code&gt; 를 사용 하십시오 . NumPy의 전체 테스트 스위트를 실행 하려면 다음 을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="2bd528b5e948a367e7029016eb9b4a7e59a0c3cc" translate="yes" xml:space="preserve">
          <source>If you want to check your array, you can run::</source>
          <target state="translated">어레이를 확인하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="239d78c449f1143da9fe3cab0308bfd5b8c57120" translate="yes" xml:space="preserve">
          <source>If you want to distribute your f2py extension module, then you only need to include the .pyf file and the Fortran code. The distutils extensions in NumPy allow you to define an extension module entirely in terms of this interface file. A valid &lt;code&gt;setup.py&lt;/code&gt; file allowing distribution of the &lt;code&gt;add.f&lt;/code&gt; module (as part of the package &lt;code&gt;f2py_examples&lt;/code&gt; so that it would be loaded as &lt;code&gt;f2py_examples.add&lt;/code&gt;) is:</source>
          <target state="translated">f2py 확장 모듈을 배포하려면 .pyf 파일과 Fortran 코드 만 포함하면됩니다. NumPy의 distutils 확장을 사용하면이 인터페이스 파일과 관련하여 확장 모듈을 완전히 정의 할 수 있습니다. 유효한 &lt;code&gt;setup.py&lt;/code&gt; 의 의 분포를 허용하는 파일 &lt;code&gt;add.f&lt;/code&gt; 의 모듈 (패키지의 일부로서 &lt;code&gt;f2py_examples&lt;/code&gt; 은로로드 될 수 있도록 &lt;code&gt;f2py_examples.add&lt;/code&gt; )입니다 :</target>
        </trans-unit>
        <trans-unit id="205839ed0e5eb197529b1363e1bb132c099c8dee" translate="yes" xml:space="preserve">
          <source>If you want to edit an array with aligned &lt;code&gt;double&lt;/code&gt; code, but the order doesn&amp;rsquo;t matter, you would use this.</source>
          <target state="translated">정렬 된 &lt;code&gt;double&lt;/code&gt; 코드 로 배열을 편집하려고 하지만 순서는 중요하지 않은 경우이 명령을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="354259176d8d4848edf2f2ea177ee9321090388c" translate="yes" xml:space="preserve">
          <source>If you want to generate a list of coordinates where the elements exist, you can zip the arrays, iterate over the list of coordinates, and print them. For example:</source>
          <target state="translated">요소가있는 좌표 목록을 생성하려면 배열을 압축하고 좌표 목록을 반복하여 인쇄 할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="09988ae17a5580ba08c41432cf193fcdceccc334" translate="yes" xml:space="preserve">
          <source>If you want to get the unique rows or columns, make sure to pass the &lt;code&gt;axis&lt;/code&gt; argument. To find the unique rows, specify &lt;code&gt;axis=0&lt;/code&gt; and for columns, specify &lt;code&gt;axis=1&lt;/code&gt;.</source>
          <target state="translated">고유 한 행 또는 열을 얻으려면 &lt;code&gt;axis&lt;/code&gt; 인수 를 전달해야합니다 . 고유 한 행을 찾으려면 &lt;code&gt;axis=0&lt;/code&gt; 을 지정 하고 열에 &lt;code&gt;axis=1&lt;/code&gt; 을 지정하십시오 .</target>
        </trans-unit>
        <trans-unit id="a706c6c7d842fe3c84f0f98172224bf53de48486" translate="yes" xml:space="preserve">
          <source>If you want to learn more about C and Fortran order, you can &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;read more about the internal organization of NumPy arrays here&lt;/a&gt;. Essentially, C and Fortran orders have to do with how indices correspond to the order the array is stored in memory. In Fortran, when moving through the elements of a two-dimensional array as it is stored in memory, the &lt;strong&gt;first&lt;/strong&gt; index is the most rapidly varying index. As the first index moves to the next row as it changes, the matrix is stored one column at a time. This is why Fortran is thought of as a &lt;strong&gt;Column-major language&lt;/strong&gt;. In C on the other hand, the &lt;strong&gt;last&lt;/strong&gt; index changes the most rapidly. The matrix is stored by rows, making it a &lt;strong&gt;Row-major language&lt;/strong&gt;. What you do for C or Fortran depends on whether it&amp;rsquo;s more important to preserve the indexing convention or not reorder the data.</source>
          <target state="translated">C 및 Fortran 순서에 대해 자세히 알아 보려면 &lt;a href=&quot;../reference/internals#numpy-internals&quot;&gt;여기에서 NumPy 배열의 내부 구성에 대해 자세히 알아볼 수 있습니다&lt;/a&gt; . 기본적으로 C 및 Fortran 순서는 인덱스가 배열이 메모리에 저장되는 순서와 일치하는 방식과 관련이 있습니다. Fortran에서 메모리에 저장된 2 차원 배열의 요소를 이동할 때 &lt;strong&gt;첫 번째&lt;/strong&gt; 인덱스는 가장 빠르게 변하는 인덱스입니다. 첫 번째 인덱스가 변경 될 때 다음 행으로 이동하면 행렬은 한 번에 한 열씩 저장됩니다. 이것이 Fortran이 &lt;strong&gt;Column-major 언어&lt;/strong&gt; 로 생각되는 이유 입니다. 반면 C에서는 &lt;strong&gt;마지막&lt;/strong&gt; 인덱스가 가장 빠르게 변경됩니다. 행렬은 행별로 저장되므로 &lt;strong&gt;행 주요 언어가됩니다.&lt;/strong&gt;. C 또는 Fortran에 대해 수행하는 작업은 인덱싱 규칙을 유지하는 것이 더 중요한지 데이터를 다시 정렬하지 않는지 여부에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="90eb7317f80793824fd5ca68d969b076155c2b6b" translate="yes" xml:space="preserve">
          <source>If you want to make use of these extensions in third-party projects, they are available on &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; as the &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc&lt;/a&gt; package.</source>
          <target state="translated">타사 프로젝트에서 이러한 확장을 활용하려면, 그들은에서 사용할 수있는 &lt;a href=&quot;https://pypi.org/&quot;&gt;PyPi&lt;/a&gt; 는 AS &lt;a href=&quot;https://python.org/pypi/numpydoc&quot;&gt;numpydoc의&lt;/a&gt; 패키지로 제공된다.</target>
        </trans-unit>
        <trans-unit id="ce326a8e1b86089803e6e52c507c14343be2d322" translate="yes" xml:space="preserve">
          <source>If you want to print your reversed array, you can run:</source>
          <target state="translated">반전 된 배열을 인쇄하려면 다음을 실행할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0c1156594a53dfa7f56ad636c35e9f1ff1d1bf58" translate="yes" xml:space="preserve">
          <source>If you want to reset both the &lt;code&gt;iterindex&lt;/code&gt; range and the base pointers at the same time, you can do the following to avoid extra buffer copying (be sure to add the return code error checks when you copy this code).</source>
          <target state="translated">&lt;code&gt;iterindex&lt;/code&gt; 범위와 기본 포인터를 동시에 재설정하려는 경우 추가 버퍼 복사를 피하기 위해 다음을 수행 할 수 있습니다 (이 코드를 복사 할 때 리턴 코드 오류 검사를 추가하십시오).</target>
        </trans-unit>
        <trans-unit id="64b7d79c9f444db203d014596ebfe464ce993392" translate="yes" xml:space="preserve">
          <source>If you want to select values from your array that fulfill certain conditions, it&amp;rsquo;s straightforward with NumPy.</source>
          <target state="translated">특정 조건을 충족하는 배열에서 값을 선택하려는 경우 NumPy를 사용하면 간단합니다.</target>
        </trans-unit>
        <trans-unit id="37f52b8408b71a5a1ecc2762c718ea9d22604602" translate="yes" xml:space="preserve">
          <source>If you want to store a single ndarray object, store it as a .npy file using &lt;code&gt;np.save&lt;/code&gt;. If you want to store more than one ndarray object in a single file, save it as a .npz file using &lt;code&gt;np.savez&lt;/code&gt;. You can also save several arrays into a single file in compressed npz format with &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt;&lt;code&gt;savez_compressed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">단일 ndarray 객체를 저장하려면 np.save를 사용하여 &lt;code&gt;np.save&lt;/code&gt; 파일로 저장하십시오 . 하나의 파일에 둘 이상의 ndarray 객체를 저장하려면 np.savez를 사용하여 &lt;code&gt;np.savez&lt;/code&gt; 파일로 저장하십시오 . 또한 압축 NPZ 형식으로 하나의 파일에 여러 배열을 저장할 수 있습니다와 &lt;a href=&quot;../reference/generated/numpy.savez_compressed#numpy.savez_compressed&quot;&gt; &lt;code&gt;savez_compressed&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88094cb7e9cc7094508fd58f64e280384e2b183f" translate="yes" xml:space="preserve">
          <source>If you want to work on some stuff with other people, where you are all committing into the same repository, or even the same branch, then just share it via &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt;.</source>
          <target state="translated">다른 사람들과 함께 작업하고 싶은 경우 모두 동일한 저장소 또는 동일한 브랜치에 커밋하는 경우 &lt;a href=&quot;https://github.com/numpy/numpy&quot;&gt;github&lt;/a&gt; 를 통해 공유하면됩니다 .</target>
        </trans-unit>
        <trans-unit id="3d8a79d78dafc5ad7f75ccfea604d3c282656ec2" translate="yes" xml:space="preserve">
          <source>If you wanted to split this array into three equally shaped arrays, you would run:</source>
          <target state="translated">이 배열을 동일한 모양의 3 개 배열로 분할하려면 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="fe157cf65afca39aaf28e7392b7bcce12c2fa490" translate="yes" xml:space="preserve">
          <source>If you wanted to split your array after the third and fourth column, you&amp;rsquo;d run:</source>
          <target state="translated">세 번째와 네 번째 열 이후에 배열을 분할하려면 다음을 실행합니다.</target>
        </trans-unit>
        <trans-unit id="f154266a0558b92de5f9f6ffafaf54fec025441e" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have BLIS available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; which is a comma-separated list of the above names which is used to determine what to search for, for instance:</source>
          <target state="translated">OpenBLAS에 대해 빌드하고 싶지만 BLIS도 사용할 수 있는 경우 검색 할 항목을 결정하는 데 사용되는 위 이름의 쉼표로 구분 된 목록 인 환경 변수 &lt;code&gt;NPY_BLAS_ORDER&lt;/code&gt; 를 통해 검색 순서를 미리 정의 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="591a2b4b56f13d91fd0f488df05b473dc7163812" translate="yes" xml:space="preserve">
          <source>If you wish to build against OpenBLAS but you also have MKL available one may predefine the order of searching via the environment variable &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; which is a comma-separated list of the above names, for instance:</source>
          <target state="translated">OpenBLAS에 대해 빌드하고 싶지만 MKL도 사용할 수 있는 경우 위 이름의 쉼표로 구분 된 목록 인 환경 변수 &lt;code&gt;NPY_LAPACK_ORDER&lt;/code&gt; 를 통해 검색 순서를 미리 정의 할 수 있습니다 . 예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="05bc8da7a227df06fa8b2e6100a971876a03d9e2" translate="yes" xml:space="preserve">
          <source>If you wish to maintain compatibility with numpy and its subsequent versions (which might add new keyword arguments) but do not want to surface all of numpy&amp;rsquo;s arguments, your function&amp;rsquo;s signature should accept &lt;code&gt;**kwargs&lt;/code&gt;. For example:</source>
          <target state="translated">numpy 및 후속 버전 (새 키워드 인수를 추가 할 수 있음)과의 호환성을 유지하고 싶지만 numpy의 모든 인수를 표시하지 않으려면 함수의 서명이 &lt;code&gt;**kwargs&lt;/code&gt; 를 허용해야합니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="97b99e9167303c0b41027781a2b137980415f644" translate="yes" xml:space="preserve">
          <source>If you wish to work the examples in this tutorial, you must also have some software installed on your computer. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for instructions.</source>
          <target state="translated">이 자습서의 예제를 사용하려면 컴퓨터에 일부 소프트웨어가 설치되어 있어야합니다. 지침 은 &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6c90b5dde9be10d805961ffa80c714fdcbfb4da" translate="yes" xml:space="preserve">
          <source>If you write a missing doc you join the front line of open source, but it&amp;rsquo;s a meaningful contribution just to let us know what&amp;rsquo;s missing. If you want to compose a doc, run your thoughts by the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; for futher ideas and feedback. If you want to alert us to a gap, &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;open an issue&lt;/a&gt;. See &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;this issue&lt;/a&gt; for an example.</source>
          <target state="translated">누락 된 문서를 작성하는 경우 오픈 소스의 최전선에 참여하게되지만 누락 된 내용을 알려주는 것만으로도 의미있는 공헌입니다. 문서를 작성하려면 &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;메일 링리스트&lt;/a&gt; 에서 생각을 실행하여 추가 아이디어와 피드백을 확인하세요. 공백에 대해 알려주 &lt;a href=&quot;https://github.com/numpy/numpy/issues&quot;&gt;려면 문제를 제기하십시오&lt;/a&gt; . 예제는 &lt;a href=&quot;https://github.com/numpy/numpy/issues/15760&quot;&gt;이 문제&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="435688685c403e3c5d5db1511c607affa0cd6d4f" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a code contributor writing a docstring, see &lt;a href=&quot;docs/howto_document#docstring-intro&quot;&gt;Docstrings&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;docs/howto_document#docstring-intro&quot;&gt;독 스트링을&lt;/a&gt; 작성하는 코드 기여자 인 경우 Docstrings를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d9781eb57d03c99a0c0070bb4df55efb82815ef3" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re a writer contributing ordinary (non-docstring) documentation, see &lt;a href=&quot;docs/howto_document#userdoc-guide&quot;&gt;User documentation&lt;/a&gt;.</source>
          <target state="translated">일반 (독 스트링이 아닌) 문서를 작성하는 작가 인 경우 &lt;a href=&quot;docs/howto_document#userdoc-guide&quot;&gt;사용자 문서를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="84b984ed21d4b1689868017ea7336aed57363a70" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re happy about the current status, mark the pull request as Approved (same way as Changes requested). Alternatively (for maintainers): merge the pull request, if you think it is ready to be merged.</source>
          <target state="translated">현재 상태가 만족 스러우면 풀 요청을 승인 됨으로 표시하십시오 (요청 된 변경 사항과 동일). 또는 (관리자 용) : 병합 할 준비가되었다고 생각되면 pull 요청을 병합합니다.</target>
        </trans-unit>
        <trans-unit id="7557e5e98e1d6b39d314fab8f9700d862099c3ca" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re interested in learning more about Pandas, take a look at the &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;official Pandas documentation&lt;/a&gt;. Learn how to install Pandas with the &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;official Pandas installation information&lt;/a&gt;.</source>
          <target state="translated">Pandas에 대해 자세히 알아 보려면 &lt;a href=&quot;https://pandas.pydata.org/index.html&quot;&gt;공식 Pandas 문서를 참조&lt;/a&gt; 하세요. &lt;a href=&quot;https://pandas.pydata.org/pandas-docs/stable/install.html&quot;&gt;공식 Pandas 설치 정보로 Pandas&lt;/a&gt; 를 설치하는 방법을 알아 봅니다 .</target>
        </trans-unit>
        <trans-unit id="0da7f308127a1fe361554b03665675b46523369c" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re looking for subjects, our formal roadmap for documentation is a &lt;em&gt;NumPy Enhancement Proposal (NEP)&lt;/em&gt;, &lt;a href=&quot;https://www.numpy.org/neps/nep-0044-restructuring-numpy-docs&quot;&gt;NEP 44 - Restructuring the NumPy Documentation&lt;/a&gt;. It identifies areas where our docs need help and lists several additions we&amp;rsquo;d like to see, including Jupyter notebooks.</source>
          <target state="translated">주제를 찾고 있다면 문서화에 대한 공식 로드맵은 &lt;em&gt;NumPy Enhancement Proposal (NEP)&lt;/em&gt; , &lt;a href=&quot;https://www.numpy.org/neps/nep-0044-restructuring-numpy-docs&quot;&gt;NEP 44-Restructuring the NumPy Documentation&lt;/a&gt; 입니다. 문서에 도움이 필요한 영역을 식별하고 Jupyter 노트북을 포함하여보고 싶은 몇 가지 추가 사항을 나열합니다.</target>
        </trans-unit>
        <trans-unit id="2ed6aac4fbb9a95f912d9c4a1bba39294044ad2e" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re reading this page, you probably want to help. This guide is meant to help you decide which kind of content you&amp;rsquo;ll write, as well as give you some tips and instructions for submitting it to the official NumPy documentation (that is, the documentation that ships with NumPy and lives on the &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;official project pages&lt;/a&gt;). Keep in mind that if you don&amp;rsquo;t want to do this, writing a tutorial on your own blog, creating a YouTube video or answering questions on social media or Stack Overflow are also great contributions!</source>
          <target state="translated">이 페이지를 읽고 있다면 도움이 필요할 것입니다. 이 가이드는 어떤 종류의 콘텐츠를 작성할 것인지 결정하는 데 도움이 될뿐만 아니라 공식 NumPy 문서 (즉, NumPy와 함께 제공되고 &lt;a href=&quot;../contents#numpy-docs-mainpage&quot;&gt;공식 프로젝트&lt;/a&gt; 에있는 문서)에 제출하기위한 몇 가지 팁과 지침을 제공합니다. 페이지 ). 이 작업을하고 싶지 않다면 자신의 블로그에 튜토리얼을 작성하거나, YouTube 동영상을 만들거나, 소셜 미디어 또는 Stack Overflow에서 질문에 답하는 것도 큰 기여입니다!</target>
        </trans-unit>
        <trans-unit id="fc7594579a51a68345b4192c0906de63f2aaa750" translate="yes" xml:space="preserve">
          <source>If you&amp;rsquo;re using the command line, you can read your saved CSV any time with a command such as:</source>
          <target state="translated">명령 줄을 사용하는 경우 다음과 같은 명령을 사용하여 언제든지 저장된 CSV를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d439391f6f76ed7b2f3c8457a29af3bd829a0ea7" translate="yes" xml:space="preserve">
          <source>If your PR is large or complicated, asking for input on the numpy-discussion mailing list may also be useful.</source>
          <target state="translated">PR이 크거나 복잡한 경우 numpy-discussion 메일 링리스트에 입력을 요청하는 것도 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bb1dc4c88210c13fc91fb612afbe4d0471d01d47" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">변경 사항으로 인해 지원 중단이 발생하는 경우 먼저 GitHub 또는 메일 링리스트에서이 문제에 대해 먼저 논의해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 지원 중단에 대한 동의에 도달하면 &lt;a href=&quot;http://www.numpy.org/neps/nep-0023-backwards-compatibility.html&quot;&gt;NEP 23 지원 중단 정책&lt;/a&gt; 에 따라 지원 중단을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="85accb86465121a186b8d95e3c7a59851c6c91da" translate="yes" xml:space="preserve">
          <source>If your change introduces a deprecation, make sure to discuss this first on GitHub or the mailing list first. If agreement on the deprecation is reached, follow &lt;a href=&quot;https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23&quot;&gt;NEP 23 deprecation policy&lt;/a&gt; to add the deprecation.</source>
          <target state="translated">변경 사항으로 인해 지원 중단이 발생하는 경우 먼저 GitHub 또는 메일 링리스트에서이 문제에 대해 먼저 논의해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 지원 중단에 대한 동의에 도달하면 &lt;a href=&quot;https://numpy.org/neps/nep-0023-backwards-compatibility.html#nep23&quot;&gt;NEP 23 지원 중단 정책&lt;/a&gt; 에 따라 지원 중단을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="0ae48eb5fc08b6f0ede5d882f3a65c937350363d" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, add a release note to the &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; directory, following the instructions and format in the &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; file.</source>
          <target state="translated">변경 사항은 API 또는 기능의 추가 / 수정에 수정을 포함하는 경우에 릴리스 노트를 추가 &lt;code&gt;doc/release/upcoming_changes/&lt;/code&gt; 의 지침 및 형식 다음, 디렉토리 &lt;code&gt;doc/release/upcoming_changes/README.rst&lt;/code&gt; 파일.</target>
        </trans-unit>
        <trans-unit id="383746919525c98ba38f05552e38f10fc7e17a76" translate="yes" xml:space="preserve">
          <source>If your changes involve modifications to the API or addition/modification of a function, you should</source>
          <target state="translated">변경 사항에 API 수정 또는 기능 추가 / 수정이 포함 된 경우 다음을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="d57214d0288965780d58c7b4b54223afc06a658d" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">커밋에 새로운 기능이 도입되거나 기능이 변경되면 &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-devel&quot;&gt;메일 링리스트&lt;/a&gt; 에 게시 하여 변경 사항을 설명하십시오. 버그 수정, 문서 업데이트 등의 경우 일반적으로 필요하지 않지만 반응이 없으면 언제든지 검토를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="9b42fea7ef12344e2f07dc65d3a5d4a69a61f251" translate="yes" xml:space="preserve">
          <source>If your commit introduces a new feature or changes functionality, post on the &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;mailing list&lt;/a&gt; to explain your changes. For bug fixes, documentation updates, etc., this is generally not necessary, though if you do not get any reaction, do feel free to ask for review.</source>
          <target state="translated">커밋에 새로운 기능이 도입되거나 기능이 변경되면 &lt;a href=&quot;https://mail.python.org/mailman/listinfo/numpy-discussion&quot;&gt;메일 링리스트&lt;/a&gt; 에 게시 하여 변경 사항을 설명하십시오. 버그 수정, 문서 업데이트 등의 경우 일반적으로 필요하지 않지만 반응이 없으면 언제든지 검토를 요청하십시오.</target>
        </trans-unit>
        <trans-unit id="ceebca4c980fce897cd94c7ea4093efdb4e34dd2" translate="yes" xml:space="preserve">
          <source>If your goal is to print such values with a fixed number of decimals, it is preferable to use numpy&amp;rsquo;s float printing routines to limit the number of printed decimals:</source>
          <target state="translated">목표가 고정 된 소수 자릿수로 이러한 값을 인쇄하는 것이라면 numpy의 부동 인쇄 루틴을 사용하여 인쇄 소수 자릿수를 제한하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="5e8a3ab9024a9447fbb66b46a34249a781d9bca6" translate="yes" xml:space="preserve">
          <source>If your report involves any members of the committee, or if they feel they have a conflict of interest in handling it, then they will recuse themselves from considering your report. Alternatively, if for any reason you feel uncomfortable making a report to the committee, then you can also contact:</source>
          <target state="translated">귀하의 보고서에위원회 구성원이 포함되어 있거나 보고서를 처리하는 데 이해 상충이 있다고 생각하는 경우 보고서 검토를 기각 할 것입니다. 또는 어떤 이유로 든위원회에보고하는 것이 불편하다면 다음 연락처로 연락 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b1e83353521c6fb2d9909d1a47041f20fbc218d" translate="yes" xml:space="preserve">
          <source>If, however, you decide to deviate from this signature and do something like this:</source>
          <target state="translated">그러나이 서명에서 벗어나 다음과 같은 작업을 수행하기로 결정한 경우 :</target>
        </trans-unit>
        <trans-unit id="c323f3cd6a35ba341fff7e94a4d83cd135d073a2" translate="yes" xml:space="preserve">
          <source>Ignoring extreme values</source>
          <target state="translated">극단적 인 가치 무시</target>
        </trans-unit>
        <trans-unit id="d887ce439b6be40447269f7cc275bae88c7965c1" translate="yes" xml:space="preserve">
          <source>Illustration image: &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</source>
          <target state="translated">일러스트 이미지 : &lt;a href=&quot;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&quot;&gt;https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8dc5a9232d67823e896b05855151653c2378fa30" translate="yes" xml:space="preserve">
          <source>Illustration, using the fact that the eigenvalues of a diagonal matrix are its diagonal elements, that multiplying a matrix on the left by an orthogonal matrix, &lt;code&gt;Q&lt;/code&gt;, and on the right by &lt;code&gt;Q.T&lt;/code&gt; (the transpose of &lt;code&gt;Q&lt;/code&gt;), preserves the eigenvalues of the &amp;ldquo;middle&amp;rdquo; matrix. In other words, if &lt;code&gt;Q&lt;/code&gt; is orthogonal, then &lt;code&gt;Q * A * Q.T&lt;/code&gt; has the same eigenvalues as &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">대각선 행렬의 고유 값이 대각선 요소라는 사실을 사용하여 왼쪽에 직교 행렬 &lt;code&gt;Q&lt;/code&gt; 와 오른쪽에 &lt;code&gt;Q.T&lt;/code&gt; ( &lt;code&gt;Q&lt;/code&gt; 의 전치 ) 를 곱 하면 '의 고유 값이 보존됩니다. 중간&amp;rdquo;매트릭스. 즉, &lt;code&gt;Q&lt;/code&gt; 가 직교 인 경우 &lt;code&gt;Q * A * Q.T&lt;/code&gt; 는 &lt;code&gt;A&lt;/code&gt; 와 동일한 고유 값을 갖습니다 .</target>
        </trans-unit>
        <trans-unit id="aa91fcf02d0f861f5dcc65de755f413adabac4c5" translate="yes" xml:space="preserve">
          <source>Illustration:</source>
          <target state="translated">Illustration:</target>
        </trans-unit>
        <trans-unit id="50e19fda0d5b4b74a4a1a1d584e56578693a4ea4" translate="yes" xml:space="preserve">
          <source>Image</source>
          <target state="translated">Image</target>
        </trans-unit>
        <trans-unit id="536fc5481730660eaf684050e171a85c03ce521a" translate="yes" xml:space="preserve">
          <source>Image &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; illustrates trapezoidal rule &amp;ndash; y-axis locations of points will be taken from &lt;code&gt;y&lt;/code&gt; array, by default x-axis distances between points will be 1.0, alternatively they can be provided with &lt;code&gt;x&lt;/code&gt; array or with &lt;code&gt;dx&lt;/code&gt; scalar. Return value will be equal to combined area under the red lines.</source>
          <target state="translated">이미지 &lt;a href=&quot;#r7aa6c77779c0-2&quot; id=&quot;id1&quot;&gt;[2]&lt;/a&gt; 는 사다리꼴 규칙을 보여줍니다. 점의 y 축 위치는 &lt;code&gt;y&lt;/code&gt; 배열 에서 가져 오며, 기본적으로 점 사이의 x 축 거리는 1.0이되며 &lt;code&gt;x&lt;/code&gt; 배열 또는 &lt;code&gt;dx&lt;/code&gt; 스칼라 와 함께 제공 될 수 있습니다 . 반환 값은 빨간색 선 아래의 결합 된 영역과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a9fdbeb05caca869c7ab036893a4d3951315842f" translate="yes" xml:space="preserve">
          <source>Image filter in Cython</source>
          <target state="translated">Cython의 이미지 필터</target>
        </trans-unit>
        <trans-unit id="d6766ee0177892e2089a490e4a43072e37a3688f" translate="yes" xml:space="preserve">
          <source>Images and real-life data make text more engaging and powerful, but be sure what you use is appropriately licensed and available. Here again, even a rough idea for artwork can be polished by others.</source>
          <target state="translated">이미지와 실제 데이터는 텍스트를 더욱 매력적이고 강력하게 만들지 만 사용하는 항목이 적절하게 라이선스되고 사용 가능한지 확인하십시오. 여기서도 작품에 대한 대략적인 아이디어조차 다른 사람들이 다듬을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9e3e609852befab966299ce3a62b4f677877a107" translate="yes" xml:space="preserve">
          <source>Images are allowed, but should not be central to the explanation; users viewing the docstring as text must be able to comprehend its meaning without resorting to an image viewer. These additional illustrations are included using:</source>
          <target state="translated">이미지는 허용되지만 설명의 중심이되어서는 안됩니다. 문서화 문자열을 텍스트로 보는 사용자는 이미지 뷰어에 의존하지 않고도 그 의미를 이해할 수 있어야합니다. 이러한 추가 그림은 다음을 사용하여 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="4796b475dca83b62f81a07c968464a3ec0ce36b3" translate="yes" xml:space="preserve">
          <source>Imagine a series of commits A, B, C, D&amp;hellip; Imagine that there are two branches, &lt;em&gt;topic&lt;/em&gt; and &lt;em&gt;master&lt;/em&gt;. You branched &lt;em&gt;topic&lt;/em&gt; off &lt;em&gt;master&lt;/em&gt; when &lt;em&gt;master&lt;/em&gt; was at commit &amp;lsquo;E&amp;rsquo;. The graph of the commits looks like this:</source>
          <target state="translated">일련의 커밋 A, B, C, D를 상상해보십시오. 두 개의 분기, &lt;em&gt;topic&lt;/em&gt; 및 &lt;em&gt;master&lt;/em&gt; 가 있다고 상상해보십시오 . 당신은 가지 &lt;em&gt;주제를&lt;/em&gt; 떨어져 &lt;em&gt;마스터&lt;/em&gt; 할 때 &lt;em&gt;마스터&lt;/em&gt; 에서 'E'를 투입했다. 커밋 그래프는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9d1a70afdce8219e6a6ff23faf95244260258e23" translate="yes" xml:space="preserve">
          <source>Imagine an array of 32-bit integers (each 4 bytes):</source>
          <target state="translated">32 비트 정수 배열 (각 4 바이트)을 상상해보십시오.</target>
        </trans-unit>
        <trans-unit id="56024d919b5d6ee0185b1f966812231e966a9f22" translate="yes" xml:space="preserve">
          <source>Immediately disconnect the originator from all NumPy communication channels.</source>
          <target state="translated">모든 NumPy 통신 채널에서 발신자를 즉시 ​​분리하십시오.</target>
        </trans-unit>
        <trans-unit id="81ebe12aa11cc123fdb7f8c88133ffaff6347b23" translate="yes" xml:space="preserve">
          <source>Implementation details</source>
          <target state="translated">구현 세부 사항</target>
        </trans-unit>
        <trans-unit id="c12c46e2305d0716b258ac51f2e79f55da8c1069" translate="yes" xml:space="preserve">
          <source>Implementations of &lt;code&gt;__array_function__&lt;/code&gt; indicate that they can handle the operation by returning any value other than &lt;code&gt;NotImplemented&lt;/code&gt;.</source>
          <target state="translated">의 구현 &lt;code&gt;__array_function__&lt;/code&gt; 는 그들이 이외의 값 반환하여 작업을 처리 할 수 있음을 나타냅니다 &lt;code&gt;NotImplemented&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="45682c285dcaa4b3e31e357f40fa088a415ce505" translate="yes" xml:space="preserve">
          <source>Implementing this formula is simple and straightforward in NumPy:</source>
          <target state="translated">이 공식을 구현하는 것은 NumPy에서 간단하고 간단합니다.</target>
        </trans-unit>
        <trans-unit id="0e028e89dfea3c1cba7d9fc7a23453fc7abac732" translate="yes" xml:space="preserve">
          <source>Implements exec_command function that is (almost) equivalent to commands.getstatusoutput function but on NT, DOS systems the returned status is actually correct (though, the returned status values may be different by a factor). In addition, exec_command takes keyword arguments for (re-)defining environment variables.</source>
          <target state="translated">commands.getstatusoutput 함수와 거의 동일한 exec_command 함수를 구현하지만 NT에서는 DOS 시스템에서 리턴 된 상태가 실제로 정확합니다 (반환 된 상태 값은 요인에 따라 다를 수 있음). 또한 exec_command는 환경 변수를 정의하는 키워드 인수를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b794a9ed38f8d441574ce1ea158c0a341f3db730" translate="yes" xml:space="preserve">
          <source>Implements the complex comparisons between two complex numbers (structures with a real and imag member) using NumPy&amp;rsquo;s definition of the ordering which is lexicographic: comparing the real parts first and then the complex parts if the real parts are equal.</source>
          <target state="translated">사전 순 인 NumPy의 사전 정의 : 실제 부분을 먼저 비교 한 다음 실제 부분이 동일한 경우 복잡한 부분을 비교하여 NumPy의 정의를 사용하여 두 개의 복소수 (실제와 imag 멤버가있는 구조) 간의 복잡한 비교를 구현합니다.</target>
        </trans-unit>
        <trans-unit id="8c1ede9f9fcf093439f0e008232b895dda53883b" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt;&lt;code&gt;NPY_NOSCALAR&lt;/code&gt;&lt;/a&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">스칼라 강제 규칙을 구현합니다. 스칼라는이 함수가 0이 아닌 값을 반환하는 경우에만이 유형에서 neededtype으로 자동으로 강제 변환됩니다. 스칼라가 &lt;a href=&quot;#c.NPY_NOSCALAR&quot;&gt; &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; &lt;/a&gt; 이면이 함수는 &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt; 와 동일합니다 . 규칙은 같은 종류의 스칼라를 같은 종류의 배열로 강제 변환 할 수 있다는 것입니다. 이 규칙은 고정밀 스칼라가 동일한 종류의 저 정밀도 배열을 업 캐스트하지 않도록 함을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="22af89867a4595ad888fcb4ec7aff9a5775524c5" translate="yes" xml:space="preserve">
          <source>Implements the rules for scalar coercion. Scalars are only silently coerced from thistype to neededtype if this function returns nonzero. If scalar is &lt;code&gt;NPY_NOSCALAR&lt;/code&gt;, then this function is equivalent to &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt;&lt;code&gt;PyArray_CanCastSafely&lt;/code&gt;&lt;/a&gt;. The rule is that scalars of the same KIND can be coerced into arrays of the same KIND. This rule means that high-precision scalars will never cause low-precision arrays of the same KIND to be upcast.</source>
          <target state="translated">스칼라 강제 규칙을 구현합니다. 이 함수가 0이 아닌 값을 반환하면 스칼라는이 유형에서 필요한 유형으로 자동 강제 변환됩니다. 스칼라가 &lt;code&gt;NPY_NOSCALAR&lt;/code&gt; 인 경우이 함수는 &lt;a href=&quot;#c.PyArray_CanCastSafely&quot;&gt; &lt;code&gt;PyArray_CanCastSafely&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 규칙은 동일한 KIND의 스칼라가 동일한 KIND의 배열로 강제 변환 될 수 있다는 것입니다. 이 규칙은 고정밀 스칼라로 인해 동일한 KIND의 고정밀 배열이 업 캐스트되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cc6b2c01f5b15596a7e379b52c69cde1905611b5" translate="yes" xml:space="preserve">
          <source>Implications for subclassing</source>
          <target state="translated">서브 클래 싱에 대한 의미</target>
        </trans-unit>
        <trans-unit id="9b1ecf27a94cea1bc5736c0891a645368078e452" translate="yes" xml:space="preserve">
          <source>Implicit rules are used to determine the type specification of a variable (from the first-letter of its name) if the variable is not defined using &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt;. Default implicit rule is given by</source>
          <target state="translated">변수가 &lt;code&gt;&amp;lt;variable type declaration&amp;gt;&lt;/code&gt; 을 사용하여 정의되지 않은 경우 암시 적 규칙을 사용하여 변수의 유형 사양 (이름의 첫 글자부터)을 결정합니다 . 기본 암시 적 규칙은 다음과 같이 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="696ba2ae8759bcaca0a74feee3fb3d26911b302c" translate="yes" xml:space="preserve">
          <source>Implies</source>
          <target state="translated">Implies</target>
        </trans-unit>
        <trans-unit id="0951af8ad6c339672abaff4e57cd5d78b54b3d59" translate="yes" xml:space="preserve">
          <source>Import conventions</source>
          <target state="translated">가져 오기 규칙</target>
        </trans-unit>
        <trans-unit id="361838ee748707501d1086cda1d546a0bca541ea" translate="yes" xml:space="preserve">
          <source>ImportError</source>
          <target state="translated">ImportError</target>
        </trans-unit>
        <trans-unit id="2fdd9172a8740a8589e6db75bd8b770e98070548" translate="yes" xml:space="preserve">
          <source>Importing and exporting a CSV</source>
          <target state="translated">CSV 가져 오기 및 내보내기</target>
        </trans-unit>
        <trans-unit id="a0b02515f5c051785b53791b2ce9293238d373b1" translate="yes" xml:space="preserve">
          <source>Importing data with &lt;code&gt;genfromtxt&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;genfromtxt&lt;/code&gt; 로 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="5ce37d23b2e6f8bbdca3d0d3d416305b155ec2af" translate="yes" xml:space="preserve">
          <source>Importing data with genfromtxt</source>
          <target state="translated">genfromtxt로 데이터 가져 오기</target>
        </trans-unit>
        <trans-unit id="c27d990de6ba5889ef7140c6c7a668ba89dfd7cb" translate="yes" xml:space="preserve">
          <source>Importing the API</source>
          <target state="translated">API 가져 오기</target>
        </trans-unit>
        <trans-unit id="dd37ac12c1ad8599b8ebf308693dc3e055ea4be3" translate="yes" xml:space="preserve">
          <source>Improve detection of CPU features</source>
          <target state="translated">CPU 기능 감지 향상</target>
        </trans-unit>
        <trans-unit id="3cf92b1447d3f56d21aa04032c4a2bb6319ee3e3" translate="yes" xml:space="preserve">
          <source>Improve performance of &lt;code&gt;numpy.pad&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.pad&lt;/code&gt; 의 성능 향상</target>
        </trans-unit>
        <trans-unit id="fc1f2a7f430fee41352adede4b4563f47e652af5" translate="yes" xml:space="preserve">
          <source>Improved automated bin estimators for &lt;code&gt;histogram&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;histogram&lt;/code&gt; 위한 향상된 자동 빈 추정기</target>
        </trans-unit>
        <trans-unit id="c1f0700651c0f4723ea34b9b380874940d8f5904" translate="yes" xml:space="preserve">
          <source>Improved conversion from ctypes objects</source>
          <target state="translated">ctypes 객체에서 향상된 변환</target>
        </trans-unit>
        <trans-unit id="518dff1009456384a218feffc1efa6923feaa474" translate="yes" xml:space="preserve">
          <source>Improved handling of zero-width string/unicode dtypes</source>
          <target state="translated">너비가 0 인 문자열 / 유니 코드 dtype 처리 개선</target>
        </trans-unit>
        <trans-unit id="58ab9853fb47f5464aeb249a62f870635c06737e" translate="yes" xml:space="preserve">
          <source>Improved precision of &lt;code&gt;ndarray.mean&lt;/code&gt; for float16 arrays</source>
          <target state="translated">향상된 정밀 &lt;code&gt;ndarray.mean&lt;/code&gt; float16과 배열</target>
        </trans-unit>
        <trans-unit id="38934ca4956698ef07754fc3267371731cc1f9a9" translate="yes" xml:space="preserve">
          <source>Improved set operations</source>
          <target state="translated">향상된 세트 작업</target>
        </trans-unit>
        <trans-unit id="e19dfb0830377f2d40e7f347e095cf658ce8a748" translate="yes" xml:space="preserve">
          <source>Improved string representation for polynomials (&lt;code&gt;__str__&lt;/code&gt;)</source>
          <target state="translated">다항식에 대한 향상된 문자열 표현 ( &lt;code&gt;__str__&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="df66ef4f9fec541e48971fe99984a92ee3d241bf" translate="yes" xml:space="preserve">
          <source>Improvements</source>
          <target state="translated">Improvements</target>
        </trans-unit>
        <trans-unit id="75cb8c222cfbf4c46e4378aa465749528ac0f696" translate="yes" xml:space="preserve">
          <source>Improvements to build warnings</source>
          <target state="translated">빌드 경고 개선</target>
        </trans-unit>
        <trans-unit id="21535b2ca395b919fe7ab1e068c3e3d0e600eb23" translate="yes" xml:space="preserve">
          <source>Improving the basic interface</source>
          <target state="translated">기본 인터페이스 개선</target>
        </trans-unit>
        <trans-unit id="651ad1981d9513aaa48106696e9dc28fdbdbb95a" translate="yes" xml:space="preserve">
          <source>In &amp;lsquo;clip&amp;rsquo; mode, a negative index which would normally wrap will clip to 0 instead.</source>
          <target state="translated">'clip'모드에서 일반적으로 줄 바꿈하는 음수 인덱스는 대신 0으로 클리핑됩니다.</target>
        </trans-unit>
        <trans-unit id="0a5b493d076f809b633ada78947b9be3536bf476" translate="yes" xml:space="preserve">
          <source>In 1.16 a number of functions have been introduced in the &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt;&lt;code&gt;numpy.lib.recfunctions&lt;/code&gt;&lt;/a&gt; module to help users account for this change. These are &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1.16에서는 사용자가이 변경 사항을 설명 할 수 있도록 &lt;a href=&quot;#module-numpy.lib.recfunctions&quot;&gt; &lt;code&gt;numpy.lib.recfunctions&lt;/code&gt; &lt;/a&gt; 모듈 에 여러 함수가 도입되었습니다 . 이들은 &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt; 입니다. &lt;a href=&quot;#numpy.lib.recfunctions.structured_to_unstructured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.structured_to_unstructured&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.lib.recfunctions.unstructured_to_structured&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.unstructured_to_structured&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.lib.recfunctions.apply_along_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.apply_along_fields&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.lib.recfunctions.assign_fields_by_name&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.assign_fields_by_name&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.lib.recfunctions.require_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.require_fields&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2fa6844c3d81a6fe2067c8e0e928cef4f2f272dc" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;range(6)&lt;/code&gt;, information on what kind of rounding is done in addition, and on how underflow is handled.</source>
          <target state="translated">에서 &lt;code&gt;range(6)&lt;/code&gt; , 종류 라운딩이와 언더 플로우 처리하는 방법에 추가로 수행되는 사항에 대한 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="50fbd12243b4769e24084faa8adf2287f6b3d6cd" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit mode&lt;/em&gt; the output can be directly controlled by specifying output subscript labels. This requires the identifier &amp;lsquo;-&amp;gt;&amp;rsquo; as well as the list of output subscript labels. This feature increases the flexibility of the function since summing can be disabled or forced when required. The call &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt;&lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; is like &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt;&lt;code&gt;np.diag(a)&lt;/code&gt;&lt;/a&gt;. The difference is that &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; does not allow broadcasting by default. Additionally &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; directly specifies the order of the output subscript labels and therefore returns matrix multiplication, unlike the example above in implicit mode.</source>
          <target state="translated">에서 &lt;em&gt;명시 적 모드&lt;/em&gt; 출력은 직접 출력 첨자 레이블을 지정하여 제어 할 수 있습니다. 여기에는 식별자 '-&amp;gt;'와 출력 첨자 레이블 목록이 필요합니다. 이 기능은 필요할 때 합산을 비활성화하거나 강제 할 수 있으므로 기능의 유연성을 향상시킵니다. &lt;code&gt;np.einsum('i-&amp;gt;', a)&lt;/code&gt; 호출 은 &lt;a href=&quot;numpy.sum#numpy.sum&quot;&gt; &lt;code&gt;np.sum(a, axis=-1)&lt;/code&gt; &lt;/a&gt; 과 &lt;code&gt;np.einsum('ii-&amp;gt;i', a)&lt;/code&gt; 는 &lt;a href=&quot;numpy.diag#numpy.diag&quot;&gt; &lt;code&gt;np.diag(a)&lt;/code&gt; &lt;/a&gt; 와 같습니다 . 차이가 있다는 것입니다 &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; 는&lt;/a&gt; 기본적으로 방송 할 수 없습니다. 또한 &lt;code&gt;np.einsum('ij,jh-&amp;gt;ih', a, b)&lt;/code&gt; 는 출력 첨자 레이블의 순서를 직접 지정하므로 위의 예와 같이 암시 적 모드와 달리 행렬 곱셈을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c0145016518b0031bebdd7367da2ce7b6495c4d5" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;explicit&lt;/em&gt; mode, &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt; provides further flexibility to compute other array operations that might not be considered classical Einstein summation operations, by disabling, or forcing summation over specified subscript labels.</source>
          <target state="translated">에서 &lt;em&gt;명시 적&lt;/em&gt; 모드, &lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; 은&lt;/a&gt; 불가능, 또는 요약을 통해 지정된 첨자 레이블을 강제로, 고전 아인슈타인 요약 작업으로 간주되지 않을 수 있습니다 다른 배열 작업을 계산하기 위해 더 유연성을 제공한다.</target>
        </trans-unit>
        <trans-unit id="4c8b68052719d1c1d5215bfd711f82950ca7a1df" translate="yes" xml:space="preserve">
          <source>In &lt;em&gt;implicit mode&lt;/em&gt;, the chosen subscripts are important since the axes of the output are reordered alphabetically. This means that &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; doesn&amp;rsquo;t affect a 2D array, while &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; takes its transpose. Additionally, &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; returns a matrix multiplication, while, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; returns the transpose of the multiplication since subscript &amp;lsquo;h&amp;rsquo; precedes subscript &amp;lsquo;i&amp;rsquo;.</source>
          <target state="translated">&lt;em&gt;암시 적 모드&lt;/em&gt; 에서는 출력 축이 사전 순으로 정렬되므로 선택한 아래 첨자가 중요합니다. 이는 &lt;code&gt;np.einsum('ij', a)&lt;/code&gt; 는 2D 배열에 영향을 미치지 않는 반면 &lt;code&gt;np.einsum('ji', a)&lt;/code&gt; 는 조옮김을 의미합니다. 또한 &lt;code&gt;np.einsum('ij,jk', a, b)&lt;/code&gt; 는 행렬 곱셈을 반환하는 반면, &lt;code&gt;np.einsum('ij,jh', a, b)&lt;/code&gt; 는 첨자 'h'가 첨자보다 우선하므로 곱셈의 전치를 반환합니다. '나는'.</target>
        </trans-unit>
        <trans-unit id="065543ba7b7c467e5ff1cf1108109daa4f6f9b2e" translate="yes" xml:space="preserve">
          <source>In C, there is no equivalent to the deprecation warnings that Python supports. One way to do deprecations is to flag them in the documentation and release notes, then remove or change the deprecated features in a future major version (NumPy 2.0 and beyond). Minor versions of NumPy should not have major C-API changes, however, that prevent code that worked on a previous minor release. For example, we will do our best to ensure that code that compiled and worked on NumPy 1.4 should continue to work on NumPy 1.7 (but perhaps with compiler warnings).</source>
          <target state="translated">C에서는 Python이 지원하는 지원 중단 경고에 해당하지 않습니다. 지원 중단을 수행하는 한 가지 방법은 설명서 및 릴리스 노트에 해당 기능을 표시 한 다음 향후 주요 버전 (NumPy 2.0 이상)에서 사용되지 않는 기능을 제거하거나 변경하는 것입니다. 그러나 부 버전의 NumPy는 이전 부 릴리스에서 작동했던 코드를 막기 위해 주요 C-API 변경 사항이 없어야합니다. 예를 들어, NumPy 1.4에서 컴파일되고 작동 된 코드가 NumPy 1.7에서 작동하도록 (하지만 컴파일러 경고와 함께) 최선을 다할 것입니다.</target>
        </trans-unit>
        <trans-unit id="a9ca8be4f66144d7c2dcc488bdd409f6a21dcaf9" translate="yes" xml:space="preserve">
          <source>In IPython it is also possible to run individual examples simply by copy-pasting them in doctest mode:</source>
          <target state="translated">IPython에서는 doctest 모드에서 복사하여 붙여 넣기 만하면 개별 예제를 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="1971f366d86d58fc78c8e9d3d0151d96fbd74efd" translate="yes" xml:space="preserve">
          <source>In MATLAB the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">MATLAB에서 환경을 사용자 지정하는 데 사용할 수있는 주요 도구는 즐겨 찾는 함수의 위치로 검색 경로를 수정하는 것입니다. 이러한 사용자 지정을 시작시 MATLAB이 실행할 시작 스크립트에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="494eed34e26fa744c79b6950c743fa3931771a94" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg; the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.</source>
          <target state="translated">MATLAB&amp;reg;에서 환경을 사용자 지정하는 데 사용할 수있는 주요 도구는 즐겨 찾는 함수의 위치로 검색 경로를 수정하는 것입니다. 이러한 사용자 지정을 시작시 MATLAB이 실행할 시작 스크립트에 넣을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05b064c6c8d4ad79dd43510f89eb8bbc99cffd4b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.</source>
          <target state="translated">MATLAB&amp;reg;에서 배열은 실제로 필요할 때까지 실제로 복사본을 생성하는 것을 방지하는 쓰기 중 복사 (lazy copy-on-write) 체계를 사용하는 값에 의한 전달 의미 체계를 갖습니다. 슬라이스 작업은 어레이의 일부를 복사합니다.</target>
        </trans-unit>
        <trans-unit id="35c279433c70eb2d4b30f568fbc349c5cc15292b" translate="yes" xml:space="preserve">
          <source>In MATLAB&amp;reg;, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra.</source>
          <target state="translated">MATLAB&amp;reg;에서 기본 데이터 형은 배정 밀도 부동 소수점 숫자로 구성된 다차원 배열입니다. 대부분의 표현식은 이러한 배열을 가져 와서 이러한 배열을 반환합니다. 이러한 배열의 2 차원 인스턴스에 대한 연산은 선형 대수의 행렬 연산과 비슷하게 작동하도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="7b6b97a69c13a8b76d236409c27d01def9d5d4b3" translate="yes" xml:space="preserve">
          <source>In MATLAB, the basic type, even for scalars, is a multidimensional array. Array assignments in MATLAB are stored as 2D arrays of double precision floating point numbers, unless you specify the number of dimensions and type. Operations on the 2D instances of these arrays are modeled on matrix operations in linear algebra.</source>
          <target state="translated">MATLAB에서 스칼라의 경우에도 기본 유형은 다차원 배열입니다. MATLAB의 배열 할당은 차원 수와 유형을 지정하지 않는 한 배정 밀도 부동 소수점 숫자의 2D 배열로 저장됩니다. 이러한 배열의 2D 인스턴스에 대한 연산은 선형 대수의 행렬 연산에 모델링됩니다.</target>
        </trans-unit>
        <trans-unit id="a7fc4e4e9aaf59319f61cb1b2c8333ad9f8d065b" translate="yes" xml:space="preserve">
          <source>In NumPy 1.16, you need to set the environment variable &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; before importing NumPy to use NumPy function overrides.</source>
          <target state="translated">NumPy 1.16에서는 NumPy 함수 대체를 사용하기 위해 NumPy를 가져 오기 전에 환경 변수 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=1&lt;/code&gt; 을 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="2d05b90f328ed41700350ed32107071a1f6f3fbc" translate="yes" xml:space="preserve">
          <source>In NumPy 1.17, the protocol is enabled by default, but can be disabled with &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt;.</source>
          <target state="translated">NumPy 1.17에서는 프로토콜이 기본적으로 활성화되어 있지만 &lt;code&gt;NUMPY_EXPERIMENTAL_ARRAY_FUNCTION=0&lt;/code&gt; 으로 비활성화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1b4938fa72e1c7213ec03de65817f46747825eb5" translate="yes" xml:space="preserve">
          <source>In NumPy 1.6.0, a type promotion API was created to encapsulate the mechanism for determining output types. See the functions &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt;&lt;code&gt;result_type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt;&lt;code&gt;promote_types&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt;&lt;code&gt;min_scalar_type&lt;/code&gt;&lt;/a&gt; for more details.</source>
          <target state="translated">NumPy 1.6.0에서는 출력 승격 결정 메커니즘을 캡슐화하기 위해 유형 승격 API가 작성되었습니다. 자세한 내용은 &lt;a href=&quot;generated/numpy.result_type#numpy.result_type&quot;&gt; &lt;code&gt;result_type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;generated/numpy.promote_types#numpy.promote_types&quot;&gt; &lt;code&gt;promote_types&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;generated/numpy.min_scalar_type#numpy.min_scalar_type&quot;&gt; &lt;code&gt;min_scalar_type&lt;/code&gt; 함수&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6817ac22605fc4c2d0f573a2b14f3a89cb1e8f22" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal, but depending on this fact is deprecated. Writing to the resulting array continues to work as it used to, but a FutureWarning is issued.</source>
          <target state="translated">NumPy 1.7 및 1.8에서는 대각선의 사본을 계속 반환하지만이 사실에 따라 더 이상 사용되지 않습니다. 결과 배열에 대한 쓰기는 예전처럼 계속 작동하지만 FutureWarning이 발행됩니다.</target>
        </trans-unit>
        <trans-unit id="117fbe2ef07a30dba33092bb43c1ec1f63fe2b7a" translate="yes" xml:space="preserve">
          <source>In NumPy 1.7 and later, this form allows &lt;code&gt;base_dtype&lt;/code&gt; to be interpreted as a structured dtype. Arrays created with this dtype will have underlying dtype &lt;code&gt;base_dtype&lt;/code&gt; but will have fields and flags taken from &lt;code&gt;new_dtype&lt;/code&gt;. This is useful for creating custom structured dtypes, as done in &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;record arrays&lt;/a&gt;.</source>
          <target state="translated">NumPy 1.7 이상에서이 형식을 사용하면 &lt;code&gt;base_dtype&lt;/code&gt; 을 구조화 된 dtype으로 해석 할 수 있습니다. 이 dtype으로 생성 된 배열에는 기본 dtype &lt;code&gt;base_dtype&lt;/code&gt; 이 있지만 &lt;code&gt;new_dtype&lt;/code&gt; 에서 가져온 필드 및 플래그가 있습니다 . &lt;a href=&quot;arrays.classes#arrays-classes-rec&quot;&gt;레코드 배열&lt;/a&gt; 에서와 같이 사용자 정의 구조화 된 dtype을 작성하는 데 유용 합니다 .</target>
        </trans-unit>
        <trans-unit id="11387d0f86941bf54bf7c514e7a5b1f0fd171696" translate="yes" xml:space="preserve">
          <source>In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array.</source>
          <target state="translated">NumPy 배열에는 참조에 의한 전달 의미가 있습니다. 슬라이스 작업은 배열에 대한 뷰입니다.</target>
        </trans-unit>
        <trans-unit id="0193a49a749beca871335b39ba584f160aa0e7bd" translate="yes" xml:space="preserve">
          <source>In NumPy the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Operations on these arrays in all dimensionalities including 2D are element-wise operations. One needs to use specific functions for linear algebra (though for matrix multiplication, one can use the &lt;code&gt;@&lt;/code&gt; operator in python 3.5 and above).</source>
          <target state="translated">NumPy에서 기본 유형은 다차원 &lt;code&gt;array&lt;/code&gt; 입니다. 2D를 포함한 모든 차원에서 이러한 배열에 대한 작업은 요소 별 작업입니다. 선형 대수를 위해 특정 함수를 사용해야합니다 (행렬 곱셈의 경우 Python 3.5 이상에서 &lt;code&gt;@&lt;/code&gt; 연산자를 사용할 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="3b53f7eb15b7831e508349b1a60777dcdbd79a0e" translate="yes" xml:space="preserve">
          <source>In NumPy versions &amp;lt;= 1.9.0 Nan is returned for slices that are all-NaN or empty. In later versions zero is returned.</source>
          <target state="translated">NumPy 버전 &amp;lt;= 1.9.0에서는 모든 NaN이거나 비어있는 슬라이스에 대해 Nan이 반환됩니다. 이후 버전에서는 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="36d3e5a6749595663c6dacbe6e7c386adcf1a912" translate="yes" xml:space="preserve">
          <source>In NumPy, dimensions are called &lt;strong&gt;axes&lt;/strong&gt;. This means that if you have a 2D array that looks like this:</source>
          <target state="translated">NumPy에서는 차원을 &lt;strong&gt;축&lt;/strong&gt; 이라고 합니다. 이는 다음과 같은 2D 배열이있는 경우를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="175572b3b0d248e7569a97712bffa8366f334be5" translate="yes" xml:space="preserve">
          <source>In NumPy, the basic type is a multidimensional &lt;code&gt;array&lt;/code&gt;. Array assignments in NumPy are usually stored as &lt;a href=&quot;../reference/arrays#arrays&quot;&gt;n-dimensional arrays&lt;/a&gt; with the minimum type required to hold the objects in sequence, unless you specify the number of dimensions and type. NumPy performs operations element-by-element, so multiplying 2D arrays with &lt;code&gt;*&lt;/code&gt; is not a matrix multiplication &amp;ndash; it&amp;rsquo;s an element-by-element multiplication. (The &lt;code&gt;@&lt;/code&gt; operator, available since Python 3.5, can be used for conventional matrix multiplication.)</source>
          <target state="translated">NumPy에서 기본 유형은 다차원 &lt;code&gt;array&lt;/code&gt; 입니다. NumPy의 배열 할당은 &lt;a href=&quot;../reference/arrays#arrays&quot;&gt;차원 수&lt;/a&gt; 와 유형을 지정하지 않는 한 일반적으로 객체를 순서대로 유지하는 데 필요한 최소 유형의 n 차원 배열 로 저장됩니다 . NumPy는 요소 단위로 연산을 수행하므로 2D 배열에 &lt;code&gt;*&lt;/code&gt; 를 곱하는 것은 행렬 곱셈이 아닙니다. 요소 단위 곱셈입니다. ( Python 3.5부터 사용할 수 있는 &lt;code&gt;@&lt;/code&gt; 연산자는 기존 행렬 곱셈에 사용할 수 있습니다.)</target>
        </trans-unit>
        <trans-unit id="ed78411a5f19815c75577c53c9647b97f455af34" translate="yes" xml:space="preserve">
          <source>In NumPy, there are 24 new fundamental Python types to describe different types of scalars. These type descriptors are mostly based on the types available in the C language that CPython is written in, with several additional types compatible with Python&amp;rsquo;s types.</source>
          <target state="translated">NumPy에는 다양한 유형의 스칼라를 설명하기위한 24 개의 새로운 기본 Python 유형이 있습니다. 이 타입 디스크립터는 주로 CPython이 작성된 C 언어로 제공되는 타입을 기반으로하며, 파이썬 타입과 호환되는 몇 가지 추가 타입이 있습니다.</target>
        </trans-unit>
        <trans-unit id="72d772d403bb9e7043a8b7f8c594e1144a74fb8c" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt;&lt;code&gt;numpy.ufunc&lt;/code&gt;&lt;/a&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt;&lt;code&gt;ufunc&lt;/code&gt;&lt;/a&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">NumPy에서 범용 함수는 &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt; &lt;code&gt;numpy.ufunc&lt;/code&gt; &lt;/a&gt; 클래스의 인스턴스입니다 . 대부분의 내장 함수는 컴파일 된 C 코드로 구현됩니다. 기본 ufunc는 스칼라에서 작동하지만 기본 요소가 하위 배열 (벡터, 행렬 등)이고 브로드 캐스팅이 다른 차원에서 수행되는 일반화 된 종류도 있습니다. &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt; 팩토리 함수를 사용하여 사용자 정의 &lt;a href=&quot;generated/numpy.ufunc#numpy.ufunc&quot;&gt; &lt;code&gt;ufunc&lt;/code&gt; &lt;/a&gt; 인스턴스를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c775f1e9d60e517f99b3f4fb5fbef2cd48f1233" translate="yes" xml:space="preserve">
          <source>In NumPy, universal functions are instances of the &lt;code&gt;numpy.ufunc&lt;/code&gt; class. Many of the built-in functions are implemented in compiled C code. The basic ufuncs operate on scalars, but there is also a generalized kind for which the basic elements are sub-arrays (vectors, matrices, etc.), and broadcasting is done over other dimensions. One can also produce custom &lt;code&gt;ufunc&lt;/code&gt; instances using the &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt;&lt;code&gt;frompyfunc&lt;/code&gt;&lt;/a&gt; factory function.</source>
          <target state="translated">NumPy에서 범용 함수는 &lt;code&gt;numpy.ufunc&lt;/code&gt; 클래스의 인스턴스입니다 . 많은 내장 함수가 컴파일 된 C 코드로 구현됩니다. 기본 ufunc는 스칼라에서 작동하지만 기본 요소는 하위 배열 (벡터, 행렬 등)이며 일반화되어 다른 차원에서 브로드 캐스트됩니다. &lt;a href=&quot;generated/numpy.frompyfunc#numpy.frompyfunc&quot;&gt; &lt;code&gt;frompyfunc&lt;/code&gt; &lt;/a&gt; 팩토리 함수를 사용하여 사용자 정의 &lt;code&gt;ufunc&lt;/code&gt; 인스턴스를 생성 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="15ce5a6b4ac0eac09144a9d2b2aa63ae33e8eb97" translate="yes" xml:space="preserve">
          <source>In NumPy, usually a synonym for &lt;a href=&quot;#term-array-scalar&quot;&gt;array scalar&lt;/a&gt;.</source>
          <target state="translated">NumPy에서 일반적으로 &lt;a href=&quot;#term-array-scalar&quot;&gt;array scalar&lt;/a&gt; 의 동의어입니다 .</target>
        </trans-unit>
        <trans-unit id="5a0e80530034196e1f24b0c9706df1a29c31a997" translate="yes" xml:space="preserve">
          <source>In NumPy, usually a synonym for &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt;. For the more general Python meaning, &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-type&quot;&gt;see here.&lt;/a&gt;</source>
          <target state="translated">NumPy에서 일반적으로 &lt;a href=&quot;#term-dtype&quot;&gt;dtype&lt;/a&gt; 의 동의어입니다 . 보다 일반적인 Python 의미 &lt;a href=&quot;https://docs.python.org/dev/glossary.html#term-type&quot;&gt;는 여기를 참조하십시오.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="774635ebbde845fd67b0f22449de4d887322609c" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpy의 조상 인 Numeric에서 방송은 ufuncobject.c에 깊게 묻힌 여러 줄의 코드로 구현되었습니다. NumPy에서는 방송 개념이 추상화되어 여러 곳에서 수행 될 수 있습니다. 방송은 &lt;a href=&quot;c-api.array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; 함수에 의해 처리됩니다 . 이 기능을 사용하려면 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; (또는 이진 형식의 항목)를 전달해야합니다. &lt;a href=&quot;c-api.types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 는 브로드 캐스트 결과의 전체 크기와 함께 각 차원의 브로드 캐스트 수와 크기를 추적합니다. 또한 브로드 캐스트중인 어레이 수와 브로드 캐스트중인 각 어레이에 대한 반복기에 대한 포인터를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="8922bb1c700cbaf5cb6e489ccc3a2d78c8e39611" translate="yes" xml:space="preserve">
          <source>In Numeric, the ancestor of Numpy, broadcasting was implemented in several lines of code buried deep in ufuncobject.c. In NumPy, the notion of broadcasting has been abstracted so that it can be performed in multiple places. Broadcasting is handled by the function &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt;. This function requires a &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; (or something that is a binary equivalent) to be passed in. The &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt;&lt;code&gt;PyArrayMultiIterObject&lt;/code&gt;&lt;/a&gt; keeps track of the broadcast number of dimensions and size in each dimension along with the total size of the broadcast result. It also keeps track of the number of arrays being broadcast and a pointer to an iterator for each of the arrays being broadcast.</source>
          <target state="translated">Numpy의 조상 인 Numeric에서 방송은 ufuncobject.c에 깊이 묻혀있는 여러 줄의 코드로 구현되었습니다. NumPy에서는 방송의 개념이 추상화되어 여러 곳에서 수행 할 수 있습니다. 방송은 &lt;a href=&quot;c-api/array#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; 함수에 의해 처리됩니다 . 이 함수를 사용하려면 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; (또는 이진에 상응하는 것)가 전달되어야합니다. &lt;a href=&quot;c-api/types-and-structures#c.PyArrayMultiIterObject&quot;&gt; &lt;code&gt;PyArrayMultiIterObject&lt;/code&gt; &lt;/a&gt; 는 방송 결과의 총 크기와 함께 각 차원의 방송 차원 수와 크기를 추적합니다. 또한 브로드 캐스트되는 배열의 수와 브로드 캐스트되는 각 배열에 대한 반복자에 대한 포인터를 추적합니다.</target>
        </trans-unit>
        <trans-unit id="22b48541001b861013a36c818439e26a1074dfe7" translate="yes" xml:space="preserve">
          <source>In Numpy 1.15, indexing an array with a multi-field index returned a copy of the result above, but with fields packed together in memory as if passed through &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Numpy 1.15에서 다중 필드 인덱스로 배열을 인덱싱하면 위의 결과의 복사본이 반환되었지만 &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; 를&lt;/a&gt; 통해 전달 된 것처럼 필드가 메모리에 함께 압축 되었습니다 .</target>
        </trans-unit>
        <trans-unit id="1b22fd0d42a99bd19673ecd40259cf68612486f3" translate="yes" xml:space="preserve">
          <source>In Python 3.0, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">Python 3.0에서 &lt;code&gt;//&lt;/code&gt; 는 층 나누기 연산자 및 &lt;code&gt;/&lt;/code&gt; 나눗셈 연산자입니다. &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 함수 파이썬 진정한 분할 동일하다.</target>
        </trans-unit>
        <trans-unit id="62fa547333a8d1dc9c0d4f4c02b89f627c6e6bc6" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;//&lt;/code&gt; is the floor division operator and &lt;code&gt;/&lt;/code&gt; the true division operator. The &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; function is equivalent to true division in Python.</source>
          <target state="translated">Python에서 &lt;code&gt;//&lt;/code&gt; 는 바닥 나누기 연산자 및 &lt;code&gt;/&lt;/code&gt; 진정한 나누기 연산자입니다. &lt;code&gt;true_divide(x1, x2)&lt;/code&gt; 함수 파이썬 진정한 분할 동일하다.</target>
        </trans-unit>
        <trans-unit id="c2ae9f01dfbac70b64c2f45fa3c211ed297fec42" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;arr[i, j]&lt;/code&gt; is exactly the same as &lt;code&gt;arr[(i, j)]&lt;/code&gt;&amp;mdash;so we can put &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;j&lt;/code&gt; in a &lt;code&gt;tuple&lt;/code&gt; and then do the indexing with that.</source>
          <target state="translated">파이썬에서 &lt;code&gt;arr[i, j]&lt;/code&gt; 는 &lt;code&gt;arr[(i, j)]&lt;/code&gt; 와 똑같습니다 . 그래서 우리는 &lt;code&gt;tuple&lt;/code&gt; 에 &lt;code&gt;i&lt;/code&gt; 와 &lt;code&gt;j&lt;/code&gt; 를 넣은 다음 인덱싱을 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="060ed7eb6876dfc9a447b37757dfa0a45bd6069c" translate="yes" xml:space="preserve">
          <source>In Python, &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; is equivalent to &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt;; the latter is just syntactic sugar for the former.</source>
          <target state="translated">Python에서 &lt;code&gt;x[(exp1, exp2, ..., expN)]&lt;/code&gt; 은 &lt;code&gt;x[exp1, exp2, ..., expN]&lt;/code&gt; . 후자는 전자에 대한 구문 설탕입니다.</target>
        </trans-unit>
        <trans-unit id="667b044648896477b62af8727dbe5136eaaff74b" translate="yes" xml:space="preserve">
          <source>In Python:</source>
          <target state="translated">Python에서 :</target>
        </trans-unit>
        <trans-unit id="269b609eb84c47b360c36d70b62b2cd1bb86a5a5" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each sub-type is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;</source>
          <target state="translated">A의 &lt;a href=&quot;#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; , 각 서브 타입은 호출 &lt;code&gt;field&lt;/code&gt; . &lt;code&gt;field&lt;/code&gt; 의 이름 (문자열), 유형 (유효한 DTYPE), 및 선택적이 &lt;code&gt;title&lt;/code&gt; . &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체 (dtype)를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="78662ce2ae98004557ba9c8d13d5c59518b52877" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt;, each subtype is called a &lt;code&gt;field&lt;/code&gt;. The &lt;code&gt;field&lt;/code&gt; has a name (a string), a type (any valid dtype), and an optional &lt;code&gt;title&lt;/code&gt;. See &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects (dtype)&lt;/a&gt;.</source>
          <target state="translated">A의 &lt;a href=&quot;#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; , 각 하위 유형은라고 &lt;code&gt;field&lt;/code&gt; . &lt;code&gt;field&lt;/code&gt; 의 이름 (문자열), 유형 (유효한 DTYPE), 및 선택적이 &lt;code&gt;title&lt;/code&gt; . &lt;a href=&quot;reference/arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체 (dtype)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7514faa85354deb212fc2851d0e9a73ad2bab680" translate="yes" xml:space="preserve">
          <source>In a dtype declaration, indicates that the data is &lt;a href=&quot;#term-big-endian&quot;&gt;big-endian&lt;/a&gt; (the bracket is big on the left).</source>
          <target state="translated">dtype 선언에서 데이터가 &lt;a href=&quot;#term-big-endian&quot;&gt;빅 엔디안&lt;/a&gt; 임을 나타냅니다 (대괄호는 왼쪽에 큼).</target>
        </trans-unit>
        <trans-unit id="00f212b64142d015b24d77af65f90b372712d4ee" translate="yes" xml:space="preserve">
          <source>In a dtype declaration, indicates that the data is &lt;a href=&quot;#term-little-endian&quot;&gt;little-endian&lt;/a&gt; (the bracket is big on the right).</source>
          <target state="translated">dtype 선언에서 데이터가 &lt;a href=&quot;#term-little-endian&quot;&gt;little-endian&lt;/a&gt; 임을 나타냅니다 (대괄호는 오른쪽에 큼).</target>
        </trans-unit>
        <trans-unit id="2721403cc827c0b84ea65a28ef2dffa50ceb53e2" translate="yes" xml:space="preserve">
          <source>In a nutshell, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; runs two main loops. The first loop converts each line of the file in a sequence of strings. The second loop converts each string to the appropriate data type. This mechanism is slower than a single loop, but gives more flexibility. In particular, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt; is able to take missing data into account, when other faster and simpler functions like &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt;&lt;code&gt;loadtxt&lt;/code&gt;&lt;/a&gt; cannot.</source>
          <target state="translated">간단히 말해서 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 는 두 개의 주요 루프를 실행합니다. 첫 번째 루프는 파일의 각 줄을 문자열 시퀀스로 변환합니다. 두 번째 루프는 각 문자열을 적절한 데이터 유형으로 변환합니다. 이 메커니즘은 단일 루프보다 느리지 만 더 많은 유연성을 제공합니다. 특히, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; 는&lt;/a&gt; , 고려 때처럼 빨리 다른 간단 기능 누락 된 데이터를 취할 수 &lt;a href=&quot;../reference/generated/numpy.loadtxt#numpy.loadtxt&quot;&gt; &lt;code&gt;loadtxt&lt;/code&gt; 는&lt;/a&gt; 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="0643c04fa6f173d8a3f9cc4f3ce84f7f07625090" translate="yes" xml:space="preserve">
          <source>In a study, testing for a specific alternative to the null hypothesis requires use of the Noncentral F distribution. We need to calculate the area in the tail of the distribution that exceeds the value of the F distribution for the null hypothesis. We&amp;rsquo;ll plot the two probability distributions for comparison.</source>
          <target state="translated">연구에서 귀무 가설에 대한 특정 대안을 테스트하려면 Noncentral F 분포를 사용해야합니다. 귀무 가설에 대한 F 분포의 값을 초과하는 분포의 꼬리 부분을 계산해야합니다. 비교를 위해 두 확률 분포를 플로팅합니다.</target>
        </trans-unit>
        <trans-unit id="4a555d5f0fdb6581c9697563824e3d61c23e3de4" translate="yes" xml:space="preserve">
          <source>In a two&amp;rsquo;s-complement system negative numbers are represented by the two&amp;rsquo;s complement of the absolute value. This is the most common method of representing signed integers on computers &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt;. A N-bit two&amp;rsquo;s-complement system can represent every integer in the range</source>
          <target state="translated">2의 보수 시스템에서 음수는 2의 절대 값의 보수로 표시됩니다. 이것은 컴퓨터에서 부호있는 정수를 나타내는 가장 일반적인 방법입니다 &lt;a href=&quot;#r962252997619-1&quot; id=&quot;id1&quot;&gt;[1]&lt;/a&gt; . N 비트 2의 보수 시스템은 범위 내의 모든 정수를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77d7c8f0da722bad85b21b1524a660b76382145e" translate="yes" xml:space="preserve">
          <source>In a two-dimensional vector, the elements of axis 0 are rows and the elements of axis 1 are columns.</source>
          <target state="translated">2 차원 벡터에서 축 0의 요소는 행이고 축 1의 요소는 열입니다.</target>
        </trans-unit>
        <trans-unit id="6ec708a7d401df6aafb3a323298b5e8a10e70e10" translate="yes" xml:space="preserve">
          <source>In addition &lt;code&gt;a&lt;/code&gt; or &lt;code&gt;b&lt;/code&gt; may be scalars, in which case:</source>
          <target state="translated">또한 &lt;code&gt;a&lt;/code&gt; 또는 &lt;code&gt;b&lt;/code&gt; 는 스칼라 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85652b9aa303fc72ea7ade73af4f0dda2d5084d0" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.io&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">이외에도 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 상기 &lt;code&gt;numpy.lib.io&lt;/code&gt; 의 모듈로부터 유래 몇 편의 기능을 제공 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; 를&lt;/a&gt; . 이러한 기능은 원본과 동일한 방식으로 작동하지만 기본값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="a6237f20922b3630e0de0aceabbe18bc44178c19" translate="yes" xml:space="preserve">
          <source>In addition to &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;, the &lt;code&gt;numpy.lib.npyio&lt;/code&gt; module provides several convenience functions derived from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;. These functions work the same way as the original, but they have different default values.</source>
          <target state="translated">이외에도 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 상기 &lt;code&gt;numpy.lib.npyio&lt;/code&gt; 의 모듈로부터 유래 몇 편의 기능을 제공 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; 를&lt;/a&gt; . 이러한 함수는 원본과 동일한 방식으로 작동하지만 기본값이 다릅니다.</target>
        </trans-unit>
        <trans-unit id="3b2e8925339289db83edc8e4d5703c4e6627acaa" translate="yes" xml:space="preserve">
          <source>In addition to &lt;code&gt;__array_wrap__&lt;/code&gt;, which is called on the way out of the ufunc, there is also an &lt;code&gt;__array_prepare__&lt;/code&gt; method which is called on the way into the ufunc, after the output arrays are created but before any computation has been performed. The default implementation does nothing but pass through the array. &lt;code&gt;__array_prepare__&lt;/code&gt; should not attempt to access the array data or resize the array, it is intended for setting the output array type, updating attributes and metadata, and performing any checks based on the input that may be desired before computation begins. Like &lt;code&gt;__array_wrap__&lt;/code&gt;, &lt;code&gt;__array_prepare__&lt;/code&gt; must return an ndarray or subclass thereof or raise an error.</source>
          <target state="translated">&lt;code&gt;__array_wrap__&lt;/code&gt; 에서 나오는 도중에 호출되는 __array_wrap__ 외에도 출력 배열이 생성 된 후 계산이 수행되기 전에 ufunc로가는 도중에 호출 되는 &lt;code&gt;__array_prepare__&lt;/code&gt; 메서드 가 있습니다 . 기본 구현은 배열을 통과하는 것 외에는 수행하지 않습니다. &lt;code&gt;__array_prepare__&lt;/code&gt; 는 배열 데이터에 액세스하거나 배열 크기를 조정하지 않아야합니다. 이는 출력 배열 유형을 설정하고 속성과 메타 데이터를 업데이트하며 계산이 시작되기 전에 원하는 입력을 기반으로 검사를 수행하기위한 것입니다. 마찬가지로 &lt;code&gt;__array_wrap__&lt;/code&gt; , &lt;code&gt;__array_prepare__&lt;/code&gt; 는 그 ndarray 또는 서브 클래스를 반환하거나 오류를 제기해야합니다.</target>
        </trans-unit>
        <trans-unit id="0202a847e7f1c55dfe19c04653df757ab3188d4f" translate="yes" xml:space="preserve">
          <source>In addition to attributes that can be specified via keyword arguments to &lt;code&gt;Configuration&lt;/code&gt; constructor, &lt;code&gt;Configuration&lt;/code&gt; instance (let us denote as &lt;code&gt;config&lt;/code&gt;) has the following attributes that can be useful in writing setup scripts:</source>
          <target state="translated">키워드 생성자 를 통해 &lt;code&gt;Configuration&lt;/code&gt; 생성자에 지정할 수있는 속성 외에도 &lt;code&gt;Configuration&lt;/code&gt; 인스턴스 ( &lt;code&gt;config&lt;/code&gt; 로 표시하자 )에는 설정 스크립트를 작성하는 데 유용한 다음과 같은 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="9205eb129a4d89ef4a9eb5c8d77614ae87b40a33" translate="yes" xml:space="preserve">
          <source>In addition to field names, fields may also have an associated &lt;a href=&quot;../glossary#term-title&quot;&gt;title&lt;/a&gt;, an alternate name, which is sometimes used as an additional description or alias for the field. The title may be used to index an array, just like a field name.</source>
          <target state="translated">필드 이름 외에도 필드에는 필드에 대한 추가 설명 또는 별칭으로 사용되는 대체 이름 인 관련 &lt;a href=&quot;../glossary#term-title&quot;&gt;제목&lt;/a&gt; 이있을 수도 있습니다 . 제목은 필드 이름처럼 배열을 인덱싱하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ee5bd9d7a0e50bb5b466ac30e311415eba3cdbd" translate="yes" xml:space="preserve">
          <source>In addition to field names, structured array fields may have an associated &lt;a href=&quot;user/basics.rec#titles&quot;&gt;title&lt;/a&gt; which is an alias to the name and is commonly used for plotting.</source>
          <target state="translated">필드 이름 외에도 구조화 된 배열 필드 에는 이름의 별칭이며 플로팅에 일반적으로 사용되는 관련 &lt;a href=&quot;user/basics.rec#titles&quot;&gt;제목&lt;/a&gt; 이 있을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5d8a9cc27249ffd4d0b1366a65411d876d2aa7c5" translate="yes" xml:space="preserve">
          <source>In addition to sort, which returns a sorted copy of an array, you can use:</source>
          <target state="translated">정렬 된 배열 복사본을 반환하는 sort 외에도 다음을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="29ec49c4a4c9a814e9bec074f3eabcbf7dea786f" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class, the &lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module defines several constants.</source>
          <target state="translated">&lt;a href=&quot;maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; 모듈은 &lt;a href=&quot;#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 클래스 외에도 여러 상수를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7b236bba71a2e6d9bbb7e9f54e04010c73fd209b" translate="yes" xml:space="preserve">
          <source>In addition to the Python C-API, there is a full and rich C-API for NumPy allowing sophisticated manipulations on a C-level. However, for most applications, only a few API calls will typically be used. For example, if you need to just extract a pointer to memory along with some shape information to pass to another calculation routine, then you will use very different calls than if you are trying to create a new array-like type or add a new data type for ndarrays. This chapter documents the API calls and macros that are most commonly used.</source>
          <target state="translated">Python C-API 외에도 NumPy 용 완전하고 풍부한 C-API가있어 C 수준에서 정교한 조작이 가능합니다. 그러나 대부분의 애플리케이션에서는 일반적으로 몇 개의 API 호출 만 사용됩니다. 예를 들어, 다른 계산 루틴에 전달하기 위해 일부 모양 정보와 함께 메모리에 대한 포인터를 추출해야하는 경우 새 배열 유형을 만들거나 새 데이터를 추가하려는 경우와는 매우 다른 호출을 사용합니다. ndarrays를 입력하십시오. 이 장에서는 가장 일반적으로 사용되는 API 호출 및 매크로에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4c1e50029232768a84bc4dc52748436e5f14647c" translate="yes" xml:space="preserve">
          <source>In addition, F2PY introduces the following statements:</source>
          <target state="translated">또한 F2PY는 다음 문을 도입합니다.</target>
        </trans-unit>
        <trans-unit id="50f7370be70d6fe0e899df628f5a07f23f4c4044" translate="yes" xml:space="preserve">
          <source>In addition, building the documentation requires the Sphinx extension &lt;code&gt;plot_directive&lt;/code&gt;, which is shipped with &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt;. This Sphinx extension can be installed by installing Matplotlib. You will also need Python&amp;gt;=3.6.</source>
          <target state="translated">또한 문서를 빌드하려면 &lt;a href=&quot;https://matplotlib.org/&quot;&gt;Matplotlib&lt;/a&gt; 와 함께 제공되는 Sphinx 확장 &lt;code&gt;plot_directive&lt;/code&gt; 가 필요합니다 . 이 Sphinx 확장은 Matplotlib를 설치하여 설치할 수 있습니다. Python&amp;gt; = 3.6도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="55ae7a3680f09394c2ee157c2db0452e71e75c1c" translate="yes" xml:space="preserve">
          <source>In addition, if &lt;em&gt;data&lt;/em&gt; is non-NULL, then &lt;em&gt;strides&lt;/em&gt; can also be provided. If &lt;em&gt;strides&lt;/em&gt; is &lt;code&gt;NULL&lt;/code&gt;, then the array strides are computed as C-style contiguous (default) or Fortran-style contiguous (&lt;em&gt;flags&lt;/em&gt; is nonzero for &lt;em&gt;data&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; or &lt;em&gt;flags&lt;/em&gt; &amp;amp; &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt;&lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt;&lt;/a&gt; is nonzero non-NULL &lt;em&gt;data&lt;/em&gt;). Any provided &lt;em&gt;dims&lt;/em&gt; and &lt;em&gt;strides&lt;/em&gt; are copied into newly allocated dimension and strides arrays for the new array object.</source>
          <target state="translated">또한 &lt;em&gt;데이터&lt;/em&gt; 가 NULL이 아닌 경우 &lt;em&gt;보폭&lt;/em&gt; 도 제공 할 수 있습니다. 경우 &lt;em&gt;스트라이드&lt;/em&gt; 이다 &lt;code&gt;NULL&lt;/code&gt; 후 어레이 스트라이드가 C 스타일 연속적으로 계산된다 (디폴트) 또는 포트란 식 연속 ( &lt;em&gt;플래그는&lt;/em&gt; 0이 아닌 것이다 &lt;em&gt;데이터&lt;/em&gt; = &lt;code&gt;NULL&lt;/code&gt; 또는 &lt;em&gt;플래그&lt;/em&gt; 및 &lt;a href=&quot;#c.NPY_ARRAY_F_CONTIGUOUS&quot;&gt; &lt;code&gt;NPY_ARRAY_F_CONTIGUOUS&lt;/code&gt; &lt;/a&gt; 인 제로 비 NULL의 &lt;em&gt;데이터&lt;/em&gt; ). 제공된 &lt;em&gt;치수&lt;/em&gt; 및 &lt;em&gt;보폭&lt;/em&gt; 은 새로 할당 된 치수에 복사되고 새 배열 객체에 대한 보폭 배열입니다.</target>
        </trans-unit>
        <trans-unit id="176596f4a4076180f296c1297a5a4088a9dfbec9" translate="yes" xml:space="preserve">
          <source>In all the cases but the first one, the output will be a 1D array with a structured dtype. This dtype has as many fields as items in the sequence. The field names are defined with the &lt;code&gt;names&lt;/code&gt; keyword.</source>
          <target state="translated">첫 번째 경우를 제외한 모든 경우에 출력은 구조화 된 dtype의 1D 배열이됩니다. 이 dtype에는 시퀀스의 항목만큼 많은 필드가 있습니다. 필드 이름은 &lt;code&gt;names&lt;/code&gt; 키워드 로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9d28ba92ccb218b4c16f2db7077723c632363102" translate="yes" xml:space="preserve">
          <source>In all the examples so far, the elements of &lt;code&gt;a&lt;/code&gt; are provided by the iterator one at a time, because all the looping logic is internal to the iterator. While this is simple and convenient, it is not very efficient. A better approach is to move the one-dimensional innermost loop into your code, external to the iterator. This way, NumPy&amp;rsquo;s vectorized operations can be used on larger chunks of the elements being visited.</source>
          <target state="translated">지금까지의 요소의 모든 실시 예에서 &lt;code&gt;a&lt;/code&gt; 한번에 반복자 하나에 의해 제공되는 모든 때문에 반복 논리 반복자 내부이다. 간단하고 편리하지만 효율적이지 않습니다. 더 나은 방법은 1 차원 가장 안쪽 루프를 반복자 외부의 코드로 옮기는 것입니다. 이런 식으로 NumPy의 벡터화 된 연산은 방문중인 요소의 더 큰 청크에 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8389ffaf8c2e94e518381d310c79dd3ec1608070" translate="yes" xml:space="preserve">
          <source>In almost all cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">거의 모든 경우 에이 함수 대신 &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; 사용해야합니다. 0d 배열에 대해서도 true를 반환하기 때문입니다. 이것은 python이 &lt;code&gt;dx&lt;/code&gt; 인수 의 스타일 을 &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt; 로, &lt;code&gt;bins&lt;/code&gt; 인수를 &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; 오버로드하는 방식입니다 . 몇 가지 주요 차이점 :</target>
        </trans-unit>
        <trans-unit id="09406f1061497030999a27047c2ac1dba1e1fddd" translate="yes" xml:space="preserve">
          <source>In both cases, set the &lt;code&gt;BUILD_COMMIT&lt;/code&gt; variable to the current release tag - e.g. &lt;code&gt;v1.19.0&lt;/code&gt;:</source>
          <target state="translated">두 경우 모두 &lt;code&gt;BUILD_COMMIT&lt;/code&gt; 변수를 현재 릴리스 태그 (예 : &lt;code&gt;v1.19.0&lt;/code&gt; )로 설정합니다 .</target>
        </trans-unit>
        <trans-unit id="d0889b5074f2eea4eb02e68278d5fa430d814a4a" translate="yes" xml:space="preserve">
          <source>In case of merge conflicts, ask the PR submitter to &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;rebase on master&lt;/a&gt;.</source>
          <target state="translated">병합 충돌이 발생하는 경우 PR 제출자에게 &lt;a href=&quot;development_workflow#rebasing-on-master&quot;&gt;master에 대한 리베이스를&lt;/a&gt; 요청하십시오 .</target>
        </trans-unit>
        <trans-unit id="3e277da1826bb81328288e7b48e1bc36cb3d9f8b" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the maximum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">최대 값이 여러 번 발생하는 경우 첫 번째 발생에 해당하는 인덱스가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="27e7146cba1027fb05de967eb96a8d0d4f3188c0" translate="yes" xml:space="preserve">
          <source>In case of multiple occurrences of the minimum values, the indices corresponding to the first occurrence are returned.</source>
          <target state="translated">최소값이 여러 번 발생하는 경우 첫 번째 발생에 해당하는 색인이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="e0a4f4799ebef164e20467e93383e4d4633f2709" translate="yes" xml:space="preserve">
          <source>In case of severe and obvious breaches, e.g. personal threat or violent, sexist or racist language, we will immediately disconnect the originator from NumPy communication channels; please see the manual for details.</source>
          <target state="translated">개인 위협이나 폭력적, 성 차별적 또는 인종 차별적 언어와 같은 심각하고 명백한 위반의 경우, 당사는 NumPy 통신 채널에서 발신자를 즉시 ​​연결 해제합니다. 자세한 내용은 설명서를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ae3b7f089e082a13dedd4fd05f16654244713a03" translate="yes" xml:space="preserve">
          <source>In cases not involving clear severe and obvious breaches of this code of conduct, the process for acting on any received code of conduct violation report will be:</source>
          <target state="translated">본 행동 강령의 명백하고 명백한 위반이 관련되지 않은 경우, 접수 된 행동 강령 위반 보고서에 대한 조치 절차는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b7695ef954df8bd205d22a810fa2781d2a8a8dfc" translate="yes" xml:space="preserve">
          <source>In certain cases a failed installation or setup issue can cause you to see the following error message:</source>
          <target state="translated">특정 경우에 실패한 설치 또는 설정 문제로 인해 다음 오류 메시지가 표시 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="77e954d7daee979232398ad08ec5cc70a6a273a6" translate="yes" xml:space="preserve">
          <source>In code, arrays are often conveniently expressed as nested lists:</source>
          <target state="translated">코드에서 배열은 종종 중첩 된 목록으로 편리하게 표현됩니다.</target>
        </trans-unit>
        <trans-unit id="c38db33a30014f091c11009d703bc2b8cd0eeadd" translate="yes" xml:space="preserve">
          <source>In complex cases, &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt;&lt;code&gt;r_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt;&lt;code&gt;c_&lt;/code&gt;&lt;/a&gt; are useful for creating arrays by stacking numbers along one axis. They allow the use of range literals (&amp;ldquo;:&amp;rdquo;)</source>
          <target state="translated">복잡한 경우 &lt;a href=&quot;../reference/generated/numpy.r_#numpy.r_&quot;&gt; &lt;code&gt;r_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.c_#numpy.c_&quot;&gt; &lt;code&gt;c_&lt;/code&gt; &lt;/a&gt; 는 한 축을 따라 숫자를 쌓아 배열을 만드는 데 유용합니다. 범위 리터럴 ( &quot;:&quot;)을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="298a2b20fe81aca60c55bf455754cf5365f9ba46" translate="yes" xml:space="preserve">
          <source>In contrast to Python, where slicing creates a copy, in NumPy slicing creates a &lt;a href=&quot;#term-view&quot;&gt;view&lt;/a&gt;.</source>
          <target state="translated">슬라이싱이 사본을 생성하는 Python과 달리 NumPy 슬라이싱은 &lt;a href=&quot;#term-view&quot;&gt;뷰를&lt;/a&gt; 생성합니다 .</target>
        </trans-unit>
        <trans-unit id="15906ca68f2a7d7e2f6c027ec51f5d69dd3bed29" translate="yes" xml:space="preserve">
          <source>In copying mode, &amp;lsquo;copy&amp;rsquo; is specified as a per-operand flag. This is done to provide control in a per-operand fashion. Buffering mode is specified as an iterator flag.</source>
          <target state="translated">복사 모드에서 '복사'는 피연산자 별 플래그로 지정됩니다. 이것은 오퍼레이터마다 제어를 제공하기 위해 수행됩니다. 버퍼링 모드는 반복자 플래그로 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="d217a2b2edd5733cc1a08fd36e52adeffd147a5f" translate="yes" xml:space="preserve">
          <source>In ctypes, the return-value of a function is set to be &amp;lsquo;int&amp;rsquo; by default. This behavior can be changed by setting the restype attribute of the function. Use None for the restype if the function has no return value (&amp;lsquo;void&amp;rsquo;):</source>
          <target state="translated">ctypes에서 함수의 반환 값은 기본적으로 'int'로 설정됩니다. 이 동작은 함수의 restype 속성을 설정하여 변경할 수 있습니다. 함수에 반환 값이없는 경우 ( 'void') restype에 None을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="20601c7341dfe87ba7a45fcff8c92729cd267fbb" translate="yes" xml:space="preserve">
          <source>In depth explanation of concepts, best practices and techniques</source>
          <target state="translated">개념, 모범 사례 및 기술에 대한 심층 설명</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">상세히</target>
        </trans-unit>
        <trans-unit id="18557e967a450637ab72e77508fbfb08c6b092fc" translate="yes" xml:space="preserve">
          <source>In effect, the slice and index array operation are independent. The slice operation extracts columns with index 1 and 2, (i.e. the 2nd and 3rd columns), followed by the index array operation which extracts rows with index 0, 2 and 4 (i.e the first, third and fifth rows).</source>
          <target state="translated">실제로 슬라이스 및 인덱스 배열 작업은 독립적입니다. 슬라이스 연산은 인덱스 1과 2가있는 열 (즉, 두 번째 및 세 번째 열)을 추출한 다음 인덱스가 0, 2, 4 인 행 (즉, 첫 번째, 세 번째 및 다섯 번째 행)을 추출하는 인덱스 배열 작업이 이어집니다.</target>
        </trans-unit>
        <trans-unit id="0401f70e9e9ccb692db031dd68efec8a8e548588" translate="yes" xml:space="preserve">
          <source>In every case, the &amp;lsquo;descr&amp;rsquo; key is optional, but of course provides more information which may be important for various applications:</source>
          <target state="translated">모든 경우에 '설명'키는 선택 사항이지만 다양한 응용 프로그램에 중요한 추가 정보를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="ed0824a3a5c26008c8df28fe72abd00f4b7f2a94" translate="yes" xml:space="preserve">
          <source>In every case, the moderator should make a reasonable effort to contact the originator, and tell them specifically how their language or actions qualify as a &amp;ldquo;clear and severe breach&amp;rdquo;. The moderator should also say that, if the originator believes this is unfair or they want to be reconnected to NumPy, they have the right to ask for a review, as below, by the Code of Conduct Committee. The moderator should copy this explanation to the Code of Conduct Committee.</source>
          <target state="translated">모든 경우에 중재자는 발신자에게 연락하기 위해 합당한 노력을 기울여야하며 그들의 언어 또는 행동이&amp;ldquo;명확하고 심각한 위반&amp;rdquo;으로 인정되는 방식을 구체적으로 알려야합니다. 중재자는 또한 작성자가 이것이 불공평하다고 생각하거나 NumPy에 다시 연결되기를 원할 경우 아래와 같이 행동 강령위원회의 검토를 요청할 권리가 있다고 말해야합니다. 중재자는이 설명을 행동 강령위원회에 복사해야합니다.</target>
        </trans-unit>
        <trans-unit id="7eac15d5d1d96d05ac021a41eb29548e9ee61a69" translate="yes" xml:space="preserve">
          <source>In fact, why don&amp;rsquo;t we try that?</source>
          <target state="translated">사실, 우리는 왜 그것을 시도하지 않습니까?</target>
        </trans-unit>
        <trans-unit id="a50f2ab9bd768752351c518eb56b5f190e77022a" translate="yes" xml:space="preserve">
          <source>In general how to set and check your environment variables depends on your system. If you can open a correct python shell, you can also run the following in python:</source>
          <target state="translated">일반적으로 환경 변수를 설정하고 확인하는 방법은 시스템에 따라 다릅니다. 올바른 Python 셸을 열 수있는 경우 Python에서 다음을 실행할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="51a2782158f2135b3873b2bc91584160c3224ec1" translate="yes" xml:space="preserve">
          <source>In general if an index includes a Boolean array, the result will be identical to inserting &lt;code&gt;obj.nonzero()&lt;/code&gt; into the same position and using the integer array indexing mechanism described above. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; is equivalent to &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt;.</source>
          <target state="translated">일반적으로 인덱스에 부울 배열이 포함되어 있으면 결과는 동일한 위치에 &lt;code&gt;obj.nonzero()&lt;/code&gt; 를 삽입 하고 위에서 설명한 정수 배열 인덱싱 메커니즘을 사용하는 것과 동일합니다. &lt;code&gt;x[ind_1, boolean_array, ind_2]&lt;/code&gt; 는 &lt;code&gt;x[(ind_1,) + boolean_array.nonzero() + (ind_2,)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0426d4d5e9174343610861881dfacd8c07a4e5a" translate="yes" xml:space="preserve">
          <source>In general, a scalar argument of a F2PY generated wrapper function can be an ordinary Python scalar (integer, float, complex number) as well as an arbitrary sequence object (list, tuple, array, string) of scalars. In the latter case, the first element of the sequence object is passed to Fortran routine as a scalar argument.</source>
          <target state="translated">일반적으로 F2PY 생성 래퍼 함수의 스칼라 인수는 스칼라의 임의 시퀀스 객체 (목록, 튜플, 배열, 문자열)뿐만 아니라 일반 Python 스칼라 (정수, 부동 소수점, 복소수) 일 수 있습니다. 후자의 경우 시퀀스 개체의 첫 번째 요소가 스칼라 인수로 Fortran 루틴에 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="41b09ab4340a010ae2242f6c23854be608350193" translate="yes" xml:space="preserve">
          <source>In general, array arguments of F2PY generated wrapper functions accept arbitrary sequences that can be transformed to NumPy array objects. An exception is &lt;code&gt;intent(inout)&lt;/code&gt; array arguments that always must be proper-contiguous and have proper type, otherwise an exception is raised. Another exception is &lt;code&gt;intent(inplace)&lt;/code&gt; array arguments that attributes will be changed &lt;em&gt;in situ&lt;/em&gt; if the argument has different type than expected (see &lt;code&gt;intent(inplace)&lt;/code&gt; attribute for more information).</source>
          <target state="translated">일반적으로 F2PY 생성 래퍼 함수의 배열 인수는 NumPy 배열 개체로 변환 될 수있는 임의의 시퀀스를 허용합니다. 예외는 항상 적절하고 연속적이어야하고 적절한 유형을 가져야 하는 인 &lt;code&gt;intent(inout)&lt;/code&gt; 배열 인수입니다. 그렇지 않으면 예외가 발생합니다. 또 다른 예외는 인 &lt;code&gt;intent(inplace)&lt;/code&gt; 배열 인수로 , 인수가 예상과 다른 유형을 가질 경우 속성이 &lt;em&gt;현장에서&lt;/em&gt; 변경 됩니다 (자세한 내용은 &lt;code&gt;intent(inplace)&lt;/code&gt; 속성 참조).</target>
        </trans-unit>
        <trans-unit id="ce9f087f4c4d9805ec9d46a8db9fd36d60eeb431" translate="yes" xml:space="preserve">
          <source>In general, for &lt;code&gt;values&lt;/code&gt;</source>
          <target state="translated">일반적으로 &lt;code&gt;values&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b4732749a65786e199f581dd65439c32d67356e7" translate="yes" xml:space="preserve">
          <source>In general, for arrays with more than two dimensions, &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt;&lt;code&gt;hstack&lt;/code&gt;&lt;/a&gt; stacks along their second axes, &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt;&lt;code&gt;vstack&lt;/code&gt;&lt;/a&gt; stacks along their first axes, and &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt;&lt;code&gt;concatenate&lt;/code&gt;&lt;/a&gt; allows for an optional arguments giving the number of the axis along which the concatenation should happen.</source>
          <target state="translated">일반적으로 2 차원 이상의 배열의 경우 &lt;a href=&quot;../reference/generated/numpy.hstack#numpy.hstack&quot;&gt; &lt;code&gt;hstack&lt;/code&gt; &lt;/a&gt; 은 두 번째 축을 따라 스택 하고 &lt;a href=&quot;../reference/generated/numpy.vstack#numpy.vstack&quot;&gt; &lt;code&gt;vstack&lt;/code&gt; &lt;/a&gt; 은 첫 번째 축을 따라 스택하며 &lt;a href=&quot;../reference/generated/numpy.concatenate#numpy.concatenate&quot;&gt; &lt;code&gt;concatenate&lt;/code&gt; &lt;/a&gt; 는 연결이 발생해야하는 축의 수를 제공하는 선택적 인수를 허용합니다.</target>
        </trans-unit>
        <trans-unit id="31150963fe6ef250ba4e833d06b222cca1c2cb70" translate="yes" xml:space="preserve">
          <source>In general, if a NumPy array is proper-contiguous and has a proper type then it is directly passed to wrapped Fortran/C function. Otherwise, an element-wise copy of an input array is made and the copy, being proper-contiguous and with proper type, is used as an array argument.</source>
          <target state="translated">일반적으로 NumPy 배열이 적절하고 연속적이며 적절한 유형을 갖는 경우 래핑 된 Fortran / C 함수에 직접 전달됩니다. 그렇지 않으면 입력 배열의 요소 별 복사본이 만들어지고 적절한 유형의 적절하고 연속적인 복사본이 배열 인수로 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13ea723c2a24ed6ef1771c5f258ea31816238b49" translate="yes" xml:space="preserve">
          <source>In general, if the array owns its own memory, as for &lt;code&gt;arr&lt;/code&gt; in this case, then &lt;code&gt;arr.base&lt;/code&gt; will be None - there are some exceptions to this - see the numpy book for more details.</source>
          <target state="translated">일반적으로 배열이 자체 메모리를 소유하고있는 경우,이 경우 &lt;code&gt;arr&lt;/code&gt; 의 경우 &lt;code&gt;arr.base&lt;/code&gt; 는 None이됩니다. 이에 대한 몇 가지 예외가 있습니다. 자세한 내용은 numpy 책을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5abc873332e6b6be31064612f2de6812b8a80d3b" translate="yes" xml:space="preserve">
          <source>In general, it is not necessary to list class methods. Those that are not part of the public API have names that start with an underscore. In some cases, however, a class may have a great many methods, of which only a few are relevant (e.g., subclasses of ndarray). Then, it becomes useful to have an additional &lt;strong&gt;Methods&lt;/strong&gt; section:</source>
          <target state="translated">일반적으로 클래스 메서드를 나열 할 필요는 없습니다. 공용 API의 일부가 아닌 이름은 밑줄로 시작하는 이름이 있습니다. 그러나 어떤 경우에는 클래스에 매우 많은 메서드가있을 수 있으며 그중 몇 개만 관련이 있습니다 (예 : ndarray의 하위 클래스). 그런 다음 추가 &lt;strong&gt;방법&lt;/strong&gt; 섹션 이 있으면 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="fcbe439e71ce76a6bc1cdecd65ffad854f695844" translate="yes" xml:space="preserve">
          <source>In general, numerical data arranged in an array-like structure in Python can be converted to arrays through the use of the array() function. The most obvious examples are lists and tuples. See the documentation for array() for details for its use. Some objects may support the array-protocol and allow conversion to arrays this way. A simple way to find out if the object can be converted to a numpy array using array() is simply to try it interactively and see if it works! (The Python Way).</source>
          <target state="translated">일반적으로 파이썬에서 배열과 같은 구조로 배열 된 숫자 데이터는 array () 함수를 사용하여 배열로 변환 할 수 있습니다. 가장 명백한 예는 목록과 튜플입니다. 사용법에 대한 자세한 내용은 array () 설명서를 참조하십시오. 일부 개체는 배열 프로토콜을 지원하고 이러한 방식으로 배열로의 변환을 허용 할 수 있습니다. array ()를 사용하여 객체를 numpy 배열로 변환 할 수 있는지 확인하는 간단한 방법은 단순히 대화 형으로 시도하고 작동하는지 확인하는 것입니다! (파이썬 방식).</target>
        </trans-unit>
        <trans-unit id="4879f4fa7efdef399be3e3db9bf5ed36f36adbd1" translate="yes" xml:space="preserve">
          <source>In general, prefer &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt;&lt;code&gt;numpy.save&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt;&lt;code&gt;numpy.load&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;../reference/generated/numpy.save#numpy.save&quot;&gt; &lt;code&gt;numpy.save&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../reference/generated/numpy.load#numpy.load&quot;&gt; &lt;code&gt;numpy.load&lt;/code&gt; 를&lt;/a&gt; 선호합니다 .</target>
        </trans-unit>
        <trans-unit id="2636b2d2555459756347b2bec78d067967d80c45" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one C-series by another results in quotient and remainder terms that are not in the Chebyshev polynomial basis set. Thus, to express these results as C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the results onto said basis set, which typically produces &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 C 시리즈를 다른 C 시리즈로 (다항식) 나누면 체비 쇼프 다항식 기준 세트에없는 몫과 나머지 항이 생성됩니다. 따라서, 이러한 결과를 C- 시리즈로 표현하기 위해서는, 전형적으로 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성하는 상기 기준 세트에 따라 결과를 &quot;재 투영&quot;할 필요가있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e3455fcce926f7a356d4db4cbb1cca4337cab9da" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Hermite series by another results in quotient and remainder terms that are not in the Hermite polynomial basis set. Thus, to express these results as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Hermite basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 Hermite 계열을 다른 Hermite 계열로 (다항식) 나누면 Hermite 다항식 기준 세트에없는 몫과 나머지 항이 생성됩니다. 따라서 이러한 결과를 Hermite 계열로 표현하려면 결과를 Hermite 기준 세트로 &quot;재 투영&quot;해야합니다. 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="efbd236c04665a122a8e3491beed41d349724880" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Laguerre series by another results in quotient and remainder terms that are not in the Laguerre polynomial basis set. Thus, to express these results as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Laguerre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 Laguerre 계열을 다른 Laguerre 계열로 (다항식) 나누면 Laguerre 다항식 기준 세트에없는 몫 및 나머지 항이 생성됩니다. 따라서 이러한 결과를 Laguerre 계열로 표현하려면 Laguerre 기준 세트에 결과를 &quot;재 투영&quot;해야합니다. 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="3e8f9ae8eb5287a2e2ca75de1027864d1ea7dce3" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) division of one Legendre series by another results in quotient and remainder terms that are not in the Legendre polynomial basis set. Thus, to express these results as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the results onto the Legendre basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 한 Legendre 계열을 다른 Legendre 계열로 (다항식) 나누면 범례 다항식 기준 세트에없는 몫과 나머지 항이 생성됩니다. 따라서 이러한 결과를 Legendre 시리즈로 표현하려면 Legendre 기준 세트에 결과를 &quot;재 투영&quot;해야합니다. 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="747e8b05b6e447bd7c26bc6951f1c707ad59f09d" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Chebyshev polynomial basis set. Thus, to express the product as a C-series, it is typically necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which typically produces &amp;ldquo;unintuitive live&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 체비 쇼프 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 C- 시리즈로 표현하기 위해서는, 전형적으로 &quot;직관적이지 않은 라이브&quot;(그러나 정확한) 결과를 생성하는 상기 기본 세트로 제품을 &quot;재 투영&quot;할 필요가있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="140624c01263c11121eb8733a7573189c8b35148" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Hermite polynomial basis set. Thus, to express the product as a Hermite series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로, 두 C- 시리즈의 (다항식) 곱은 Hermite 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 Hermite 시리즈로 표현하기 위해서는 제품을 상기 기본 세트로 &quot;재 투영&quot;해야하며, 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4be0c1b381e26e882c60023195f1e89d336414ac" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Laguerre polynomial basis set. Thus, to express the product as a Laguerre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 Laguerre 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 라게 레 (Laguerre) 시리즈로 표현하기 위해서는, 제품을 상기 기본 세트로 &quot;재 투영&quot;해야하며, 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="54659a570a760a1d9fe356eba1a0141427eabe1f" translate="yes" xml:space="preserve">
          <source>In general, the (polynomial) product of two C-series results in terms that are not in the Legendre polynomial basis set. Thus, to express the product as a Legendre series, it is necessary to &amp;ldquo;reproject&amp;rdquo; the product onto said basis set, which may produce &amp;ldquo;unintuitive&amp;rdquo; (but correct) results; see Examples section below.</source>
          <target state="translated">일반적으로 두 C- 시리즈의 (다항식) 곱은 Legendre 다항식 기준 세트에없는 용어가됩니다. 따라서, 제품을 Legendre 시리즈로 표현하기 위해서는, 제품을 상기 기본 세트로 &quot;재 투영&quot;해야하며, 이는 &quot;직관적이지 않은&quot;(그러나 정확한) 결과를 생성 할 수있다; 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="afe18211391947a00635543978b5840ef054bbac" translate="yes" xml:space="preserve">
          <source>In general, the contents of signature files is case-sensitive. When scanning Fortran codes and writing a signature file, F2PY lowers all cases automatically except in multiline blocks or when &lt;code&gt;--no-lower&lt;/code&gt; option is used.</source>
          <target state="translated">일반적으로 서명 파일의 내용은 대소 문자를 구분합니다. Fortran 코드를 스캔하고 서명 파일을 작성할 때 F2PY는 여러 줄 블록 또는 &lt;code&gt;--no-lower&lt;/code&gt; 옵션이 사용되는 경우를 제외하고 모든 경우를 자동으로 낮 춥니 다 .</target>
        </trans-unit>
        <trans-unit id="de938489906c2e0d2c954a8201ef415c1aa719ca" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 C 시리즈를 차별화 한 결과는 C 시리즈 기본 세트로 &quot;재 투영&quot;되어야합니다. 따라서 일반적으로이 기능의 결과는 정확하지만 &quot;직관적이지 않습니다&quot;. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="dc47191395ffa64cfa2441fe3b165eeaca46d090" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Hermite series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 Hermite 시리즈를 차별화 한 결과는 Power 시리즈에서 동일한 작동과 유사하지 않습니다. 따라서이 기능의 결과는 정확하지만 &quot;직관적이지 않은&quot;것일 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c6b49ce2210116245bad6e5bb6d187bba65b38de" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Laguerre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 Laguerre 시리즈를 차별화 한 결과는 파워 시리즈에서 동일한 작동과 유사하지 않습니다. 따라서이 기능의 결과는 정확하지만 &quot;직관적이지 않은&quot;것일 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="68d490300c846fea9862fc337043383e53cf549a" translate="yes" xml:space="preserve">
          <source>In general, the result of differentiating a Legendre series does not resemble the same operation on a power series. Thus the result of this function may be &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">일반적으로 Legendre 시리즈를 차별화 한 결과는 파워 시리즈에서 동일한 작업과 유사하지 않습니다. 따라서이 기능의 결과는 정확하지만 &quot;직관적이지 않은&quot;것일 수 있습니다. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ebd1b8db4b2a00ae669c478fea3d4050ecbe0184" translate="yes" xml:space="preserve">
          <source>In general, the shape of the resultant array will be the concatenation of the shape of the index array (or the shape that all the index arrays were broadcast to) with the shape of any unused dimensions (those not indexed) in the array being indexed.</source>
          <target state="translated">일반적으로 결과 배열의 모양은 인덱스 배열의 모양 (또는 모든 인덱스 배열이 브로드 캐스트 된 모양)과 인덱스되는 배열의 사용되지 않은 차원 (인덱싱되지 않은 차원)의 모양을 연결 한 것입니다. .</target>
        </trans-unit>
        <trans-unit id="a88de0d014385ccfe1e16b471b5821f10438fddf" translate="yes" xml:space="preserve">
          <source>In general, we follow the &lt;a href=&quot;https://developers.google.com/style&quot;&gt;Google developer documentation style guide&lt;/a&gt;.</source>
          <target state="translated">일반적으로 &lt;a href=&quot;https://developers.google.com/style&quot;&gt;Google 개발자 문서 스타일 가이드를&lt;/a&gt; 따릅니다 .</target>
        </trans-unit>
        <trans-unit id="f5de4ef25adb6cfc3610a2fc23a9d5023b6dda95" translate="yes" xml:space="preserve">
          <source>In general, when the boolean array has fewer dimensions than the array being indexed, this is equivalent to y[b, &amp;hellip;], which means y is indexed by b followed by as many : as are needed to fill out the rank of y. Thus the shape of the result is one dimension containing the number of True elements of the boolean array, followed by the remaining dimensions of the array being indexed.</source>
          <target state="translated">일반적으로 부울 배열의 차원이 인덱싱되는 배열보다 적 으면 y [b,&amp;hellip;]와 동일합니다. 즉, y는 y의 순위를 채우는 데 필요한만큼 b 다음에 b가 인덱싱됨을 의미합니다. 따라서 결과의 모양은 부울 배열의 True 요소 수를 포함하는 하나의 차원이고 그 뒤에 인덱싱되는 배열의 나머지 차원이 이어집니다.</target>
        </trans-unit>
        <trans-unit id="a094c205647147c910d02f3a8f4ccd59ee07b5bd" translate="yes" xml:space="preserve">
          <source>In general, you should target these typemap signatures specifically where you want them, and then clear them after you are done.</source>
          <target state="translated">일반적으로 이러한 유형 맵 시그니처를 원하는 위치에 구체적으로 지정하고 완료 한 후에 지워야합니다.</target>
        </trans-unit>
        <trans-unit id="dd3e08bc1a57887f18c581f1dbde91b2bd716911" translate="yes" xml:space="preserve">
          <source>In higher dimensions, FFTs are used, e.g., for image analysis and filtering. The computational efficiency of the FFT means that it can also be a faster way to compute large convolutions, using the property that a convolution in the time domain is equivalent to a point-by-point multiplication in the frequency domain.</source>
          <target state="translated">더 높은 차원에서, 예를 들어 이미지 분석 및 필터링을 위해 FFT가 사용됩니다. FFT의 계산 효율은 시간 영역에서의 회선이 주파수 영역에서의 포인트 단위 곱셈과 동등한 특성을 사용하여 큰 회선을 계산하는 더 빠른 방법 일 수도 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="712c1e0b0bab41b8c1ae0fb7e5f87af642c68f33" translate="yes" xml:space="preserve">
          <source>In higher dimensions, the picture changes. NumPy prints higher-dimensional vectors as replications of row-by-column building blocks, as in this three-dimensional vector:</source>
          <target state="translated">더 높은 차원에서는 그림이 바뀝니다. NumPy는 다음 3 차원 벡터에서와 같이 고차원 벡터를 행별 구성 요소의 복제로 인쇄합니다.</target>
        </trans-unit>
        <trans-unit id="b07ddb1ceb7095c96bdb1f519b0d36703eda5462" translate="yes" xml:space="preserve">
          <source>In interactions between &lt;code&gt;ArrayLike&lt;/code&gt; objects and numbers or numpy arrays, the result is always another &lt;code&gt;ArrayLike&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;ArrayLike&lt;/code&gt; 객체와 숫자 또는 numpy 배열 간의 상호 작용 에서 결과는 항상 다른 &lt;code&gt;ArrayLike&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="859968bca8846c38eabf846201d96ee61f1cb6f0" translate="yes" xml:space="preserve">
          <source>In linear space, the sequence starts at &lt;code&gt;base ** start&lt;/code&gt; (&lt;code&gt;base&lt;/code&gt; to the power of &lt;code&gt;start&lt;/code&gt;) and ends with &lt;code&gt;base ** stop&lt;/code&gt; (see &lt;code&gt;endpoint&lt;/code&gt; below).</source>
          <target state="translated">선형 공간에서 시퀀스는 &lt;code&gt;base ** start&lt;/code&gt; 에서 시작 ( &lt;code&gt;base&lt;/code&gt; 은 &lt;code&gt;start&lt;/code&gt; 의 거듭 제곱)에서 시작 하고 &lt;code&gt;base ** stop&lt;/code&gt; 끝납니다 (아래 &lt;code&gt;endpoint&lt;/code&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="e8987c188d2dc12518e96e9c96bc6fb94bc0c364" translate="yes" xml:space="preserve">
          <source>In many circumstances, datasets can be incomplete or tainted by the presence of invalid data. For example, a sensor may have failed to record a data, or recorded an invalid value. The &lt;a href=&quot;#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module provides a convenient way to address this issue, by introducing masked arrays.</source>
          <target state="translated">많은 경우에 유효하지 않은 데이터가 있으면 데이터 세트가 불완전하거나 오염 될 수 있습니다. 예를 들어, 센서가 데이터를 기록하지 못했거나 유효하지 않은 값을 기록했을 수 있습니다. &lt;a href=&quot;#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; 의&lt;/a&gt; 모듈은 마스크 배열을 도입하여이 문제를 해결할 수있는 편리한 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="af19adb5953933b119cf6e38053a7bd63ddf0076" translate="yes" xml:space="preserve">
          <source>In memory overlap checks, assume that operands with &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; enabled are accessed only in the iterator order.</source>
          <target state="translated">메모리 오버랩 검사에서 &lt;code&gt;NPY_ITER_OVERLAP_ASSUME_ELEMENTWISE&lt;/code&gt; 가 활성화 된 피연산자 는 반복자 순서로만 액세스 한다고 가정합니다 .</target>
        </trans-unit>
        <trans-unit id="bd53b438575f194778c1656e57b318d6b487ca6a" translate="yes" xml:space="preserve">
          <source>In more detail</source>
          <target state="translated">더 자세하게</target>
        </trans-unit>
        <trans-unit id="f9e0501d6a0c7c31ee0e8c5ea3ca4747d4c70398" translate="yes" xml:space="preserve">
          <source>In most cases &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; should be used instead of this function, as that will also return true for 0d arrays. This is how numpy overloads functions in the style of the &lt;code&gt;dx&lt;/code&gt; arguments to &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt;&lt;code&gt;gradient&lt;/code&gt;&lt;/a&gt; and the &lt;code&gt;bins&lt;/code&gt; argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;. Some key differences:</source>
          <target state="translated">대부분 의 경우이 함수 대신 &lt;code&gt;np.ndim(x) == 0&lt;/code&gt; 사용해야합니다. 0d 배열에 대해서도 true를 반환하기 때문입니다. 이것이 numpy가 &lt;code&gt;dx&lt;/code&gt; 인수 스타일의 함수를 &lt;a href=&quot;numpy.gradient#numpy.gradient&quot;&gt; &lt;code&gt;gradient&lt;/code&gt; &lt;/a&gt; 로, &lt;code&gt;bins&lt;/code&gt; 인수를 &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; 에&lt;/a&gt; 오버로드하는 방법 입니다. 몇 가지 주요 차이점 :</target>
        </trans-unit>
        <trans-unit id="a5c743fe265d56156ca24d5e10903518aede0334" translate="yes" xml:space="preserve">
          <source>In most use cases the best way to install NumPy on your system is by using a pre-built package for your operating system. Please see &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; for links to available options.</source>
          <target state="translated">대부분의 사용 사례에서 시스템에 NumPy를 설치하는 가장 좋은 방법은 운영 체제 용으로 미리 빌드 된 패키지를 사용하는 것입니다. 사용 가능한 옵션에 대한 링크 는 &lt;a href=&quot;https://scipy.org/install.html&quot;&gt;https://scipy.org/install.html&lt;/a&gt; 을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="763b6e76c1532989efe227d788422ad02bd06f94" translate="yes" xml:space="preserve">
          <source>In normal buffering, the size of each inner loop is equal to the buffer size, or possibly larger if &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt;&lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt;&lt;/a&gt; is specified. If &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt;&lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt;&lt;/a&gt; is enabled and a reduction occurs, the inner loops may become smaller depending on the structure of the reduction.</source>
          <target state="translated">일반 버퍼링에서 각 내부 루프의 크기는 버퍼 크기와 같거나 &lt;a href=&quot;#c.NPY_ITER_GROWINNER&quot;&gt; &lt;code&gt;NPY_ITER_GROWINNER&lt;/code&gt; &lt;/a&gt; 가 지정된 경우 더 클 수 있습니다. 경우 &lt;a href=&quot;#c.NPY_ITER_REDUCE_OK&quot;&gt; &lt;code&gt;NPY_ITER_REDUCE_OK&lt;/code&gt; 가&lt;/a&gt; 활성화되고 감소가 발생하는 내부 루프는 감소 구조에 따라 작아지고있다.</target>
        </trans-unit>
        <trans-unit id="2c60bcd4aa111fe243ec4d9e38a39cdb9410fc32" translate="yes" xml:space="preserve">
          <source>In numpy versions &amp;gt;= 1.7.0 the &lt;code&gt;basis&lt;/code&gt; and &lt;code&gt;cast&lt;/code&gt; class methods are also available. The cast method works like the convert method while the basis method returns the basis polynomial of given degree:</source>
          <target state="translated">numpy 버전&amp;gt; = 1.7.0에서는 &lt;code&gt;basis&lt;/code&gt; 및 &lt;code&gt;cast&lt;/code&gt; 클래스 메소드도 사용할 수 있습니다. cast 메소드는 convert 메소드와 같이 작동하지만 base 메소드는 주어진 정도의 기본 다항식을 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9a36a11020261b9ce301df38d29f32b272d351ef" translate="yes" xml:space="preserve">
          <source>In order to add a Python package to SciPy, its build script (&lt;code&gt;setup.py&lt;/code&gt;) must meet certain requirements. The most important requirement is that the package define a &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; function which returns a dictionary suitable for passing to &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt;. To simplify the construction of this dictionary, &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; provides the &lt;code&gt;Configuration&lt;/code&gt; class, described below.</source>
          <target state="translated">SciPy에 Python 패키지를 추가하려면 빌드 스크립트 ( &lt;code&gt;setup.py&lt;/code&gt; )가 특정 요구 사항을 충족해야합니다. 가장 중요한 요구 사항은 패키지 가 &lt;code&gt;numpy.distutils.core.setup(..)&lt;/code&gt; 에 전달하기에 적합한 사전을 반환하는 &lt;code&gt;configuration(parent_package='',top_path=None)&lt;/code&gt; 함수를 정의 해야 한다는 것 입니다. 이 사전의 구성을 단순화하기 위해 &lt;code&gt;numpy.distutils.misc_util&lt;/code&gt; 은 아래에 설명 된 &lt;code&gt;Configuration&lt;/code&gt; 클래스를 제공합니다 .</target>
        </trans-unit>
        <trans-unit id="9195216b823d914ae553da6509b9641a3f8c45ff" translate="yes" xml:space="preserve">
          <source>In order to extract information from a given matrix, we can use the SVD to obtain 3 arrays which can be multiplied to obtain the original matrix. From the theory of linear algebra, given a matrix</source>
          <target state="translated">주어진 행렬에서 정보를 추출하기 위해 SVD를 사용하여 원래 행렬을 얻기 위해 곱할 수있는 3 개의 배열을 얻을 수 있습니다. 행렬이 주어지면 선형 대수 이론에서</target>
        </trans-unit>
        <trans-unit id="60fc69a196f8bf024afb0ed60ca3a78c46194201" translate="yes" xml:space="preserve">
          <source>In order to improve the interface, directives should be provided. This is accomplished by constructing an interface definition file. It is usually best to start from the interface file that f2py can produce (where it gets its default behavior from). To get f2py to generate the interface file use the -h option:</source>
          <target state="translated">인터페이스를 개선하기 위해 지시문을 제공해야합니다. 이는 인터페이스 정의 파일을 구성하여 수행됩니다. 일반적으로 f2py가 생성 할 수있는 인터페이스 파일에서 시작하는 것이 가장 좋습니다 (기본 동작을 가져 오는 위치). 인터페이스 파일을 생성하기 위해 f2py를 얻으려면 -h 옵션을 사용하십시오 :</target>
        </trans-unit>
        <trans-unit id="d5eaeb15f58484d8774fc878d68cb55c966f0844" translate="yes" xml:space="preserve">
          <source>In order to make use of the C-API from another extension module, the &lt;a href=&quot;#c.import_array&quot;&gt;&lt;code&gt;import_array&lt;/code&gt;&lt;/a&gt; function must be called. If the extension module is self-contained in a single .c file, then that is all that needs to be done. If, however, the extension module involves multiple files where the C-API is needed then some additional steps must be taken.</source>
          <target state="translated">다른 확장 모듈에서 C-API를 사용하려면 &lt;a href=&quot;#c.import_array&quot;&gt; &lt;code&gt;import_array&lt;/code&gt; &lt;/a&gt; 함수를 호출해야합니다. 확장 모듈이 단일 .c 파일에 자체 포함되어 있으면이 모든 것이 완료되어야합니다. 그러나 확장 모듈에 C-API가 필요한 여러 파일이 포함 된 경우 몇 가지 추가 단계를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="c34adc34291107e6d105c5cd2a716fc5c0f9914c" translate="yes" xml:space="preserve">
          <source>In order to pay-off (i.e., have a future-value of 0) the $200,000 obtained today, a monthly payment of $1,854.02 would be required. Note that this example illustrates usage of &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt;&lt;code&gt;fv&lt;/code&gt;&lt;/a&gt; having a default value of 0.</source>
          <target state="translated">오늘 획득 한 20 만 달러를 상환 (즉, 미래 가치가 0)하기 위해서는 매달 $ 1,854.02의 지불이 필요합니다. 이 예 는 기본값이 0 인 &lt;a href=&quot;numpy.fv#numpy.fv&quot;&gt; &lt;code&gt;fv&lt;/code&gt; 의&lt;/a&gt; 사용법을 보여줍니다 .</target>
        </trans-unit>
        <trans-unit id="c095a095337ad13b3d70a4b6ebd36dbc52f1334a" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt;&lt;code&gt;object&lt;/code&gt;&lt;/a&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#object&quot;&gt; &lt;code&gt;object&lt;/code&gt; &lt;/a&gt; 유형의 필드에서 객체 포인터가 막히는 것을 방지하기 위해 numpy는 현재 객체를 포함하는 구조화 된 배열의보기를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5f37a6feac047af18be703227c7a9f994a3a9fcc" translate="yes" xml:space="preserve">
          <source>In order to prevent clobbering object pointers in fields of &lt;code&gt;numpy.object&lt;/code&gt; type, numpy currently does not allow views of structured arrays containing objects.</source>
          <target state="translated">&lt;code&gt;numpy.object&lt;/code&gt; 유형의 필드에서 개체 포인터가 막히는 것을 방지하기 위해 numpy는 현재 개체를 포함하는 구조화 된 배열의보기를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b7199a5c1d305f9cc30b6b7f154cecb0f39e6d3" translate="yes" xml:space="preserve">
          <source>In order to remove elements from an array, it&amp;rsquo;s simple to use indexing to select the elements that you want to keep.</source>
          <target state="translated">배열에서 요소를 제거하려면 인덱싱을 사용하여 유지하려는 요소를 선택하는 것이 간단합니다.</target>
        </trans-unit>
        <trans-unit id="b465797b5de029b2baabd94edf6595fe5ee0db1d" translate="yes" xml:space="preserve">
          <source>In order to start using NumPy and all of the functions available in NumPy, you&amp;rsquo;ll need to import it. This can be easily done with this import statement:</source>
          <target state="translated">NumPy 및 NumPy에서 사용할 수있는 모든 기능을 사용하려면 가져와야합니다. 이 import 문으로 쉽게 수행 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
