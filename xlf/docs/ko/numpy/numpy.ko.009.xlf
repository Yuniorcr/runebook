<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="numpy">
    <body>
      <group id="numpy">
        <trans-unit id="c2768f400f9fa775eec700ef22029382a4ddca4f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_is_contiguous(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_is_contiguous(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db6a310321c047f65d9882fc29feac338c87a50c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_is_fortran(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_is_fortran(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="953ba7e21af975ea81b30d4c33fd4a7adce6894e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_is_native(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_is_native(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="066d4b8cdcb8c7699691e21dd8ad228c0968c041" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_like&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_like&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a90fe7b4f1802dd6b3b18b849a68f1ca04b4e551" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_numdims(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_numdims(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0c760a320a1507b12193d08adba16407e3d8ee73" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_size(a,i)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_size(a,i)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d40034b537d7dbe6968ec21bba65ccf3bdeaa116" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_stride(a,i)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_stride(a,i)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9df1c3170567b24a4101588e516a27a0e6a297eb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_strides(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_strides(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="662f70564b573e5c7df28feb8192cb8b0b167513" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;array_type(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;array_type(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f4946d0979b0cbf6a6688a02173eaaf15ac82c8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;astype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;astype&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a4b8361bf3502846763013c287286016127567a0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;attribute&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;attribute&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6c9bed64aca648213b2da044191fb4b7b59795ee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;axes: (2,) array_like&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;좌표축 : (2,) array_like&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4bc7d20935a0a0cde1f8115defeca654b65804e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;axis: int&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;축 : int&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b4876344ae3e0c94bf575f1e317ebfcb488099a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;basis_name&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;basis_name&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8be386373d73634c09bb2d6fd4bf24086f0d0942" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;big-endian&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;big-endian&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cdb462d02ff207ffaba36bc819604d3358bf18ea" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;broadcast&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;broadcast&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="927aa02768c5aa0026180697b70e1b25f4eefa70" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;buf_size&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;buf_size&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="098ec963a1738d3d6178aa7d31b3aa55c00c8e56" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;byteswap&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;byteswap&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2cdc55e3d19ffe37c1f2046e0515fc2d76c544be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;conj&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;conj&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="bc5df2ac2a30ad3c74f3d9657a210947b59a5bc4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;copy: bool, optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;copy : bool, 선택 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="33f1a4bf6c2e44061b8e2cf7fe525d70a965606c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;copy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;copy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f2166ad5989736dda339eb112772d2add974957c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ctype&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ctype&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d3a4d22e980e49e275bd0bce49222c2e943c77d6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; Should be &lt;code&gt;NULL&lt;/code&gt; or a pointer to an array of size &lt;em&gt;ntypes&lt;/em&gt; . This array may contain arbitrary extra-data to be passed to the corresponding loop function in the func array.</source>
          <target state="translated">&lt;strong&gt;data&lt;/strong&gt; &amp;ndash; &lt;code&gt;NULL&lt;/code&gt; 이거나 크기 &lt;em&gt;ntypes&lt;/em&gt; 의 배열에 대한 포인터 &lt;em&gt;여야&lt;/em&gt; 합니다. 이 배열에는 func 배열의 해당 루프 함수로 전달 될 임의의 추가 데이터가 포함될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f9f2e7974119ce734e482d0516e99a552574cb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;data&lt;/strong&gt; (optional)</source>
          <target state="translated">&lt;strong&gt;데이터&lt;/strong&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="a0ae34e5c9b94655acd546ee8bc70c4ee3c4bc69" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;decorator&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;decorator&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="49a7e4e2df493f808d1672a2923e223270d2ba1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;define_macros :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;define_macros :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5955fbdf9222727d6ccedee43e8f9bb2720a5208" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;depends :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;따라 달라집니다 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d54f0468bec3b0ca9fc797bff0fd4ae627cd93c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;descr&lt;/strong&gt; (optional)</source>
          <target state="translated">&lt;strong&gt;설명&lt;/strong&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="6cbc887d6309f2e7370e1b22f618ac82c061c3ed" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;dictionary&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;dictionary&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c11df31b38ab3f279445940c63c3c371c470aa4a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;dims&lt;/strong&gt; &amp;ndash; An output array that contains the shape of the array object. This array gives boundaries on any looping that will take place.</source>
          <target state="translated">&lt;strong&gt;dims&lt;/strong&gt; &amp;ndash; 배열 객체의 모양이 포함 된 출력 배열입니다. 이 배열은 발생할 루프에 경계를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0565bf77c66a7942b68bb26429a0ca5549beab2e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;doc&lt;/strong&gt; &amp;ndash; Allows passing in a documentation string to be stored with the ufunc. The documentation string should not contain the name of the function or the calling signature as that will be dynamically determined from the object and available when accessing the &lt;strong&gt;__doc__&lt;/strong&gt; attribute of the ufunc.</source>
          <target state="translated">&lt;strong&gt;doc&lt;/strong&gt; &amp;ndash; ufunc와 함께 문서화 문자열을 전달할 수 있습니다. 문서 문자열에는 함수의 이름 또는 호출 서명이 포함되어서는 안됩니다. 이는 객체에서 동적으로 결정되며 ufunc 의 &lt;strong&gt;__doc__&lt;/strong&gt; 속성에 액세스 할 때 사용 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="0fa01e216e54d0981244da805959bd357d33aa58" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;dtype: data-type, optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;dtype : 데이터 유형, 선택 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="eb177182115de958522b6d780f789034ba71bf12" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;entropy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;entropy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="92e714613df5467e1e424a882cba16acca158f36" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;export_symbols :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;export_symbols :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddd8345fcbb3815d9ac12ca6e57708a9e226dfd0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;extra_compile_args :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;extra_compile_args :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2c1deac678ae910eba565bf64557a5f38e58fa8a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;extra_f77_compile_args :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;extra_f77_compile_args :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="dddb20c43b32e2cb180a29732e25f626bc8b5da1" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;extra_f90_compile_args :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;extra_f90_compile_args :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="964e30ba8701080189deb1fe9f3ceecdb498561c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;extra_link_args :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;extra_link_args :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ef9190ac4f60288803e8541d8d80a6b379a9010" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;extra_objects :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;extra_objects :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="035d229359e78cbf3e00b7c6436856b5354c86bd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;f2py_options :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;f2py_options :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b89cb92170431ce569bcc31704fb94274fcae69a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;field&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;field&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0585128afb8e84a1c424cefe414be2157d0663e7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;fill in the missing value&lt;/strong&gt; with the value specified in &lt;code&gt;filling_values&lt;/code&gt; (default is &lt;code&gt;np.nan&lt;/code&gt; for float, -1 for int).</source>
          <target state="translated">&lt;strong&gt;누락 된 값&lt;/strong&gt; 을 &lt;code&gt;filling_values&lt;/code&gt; 지정된 &lt;strong&gt;값&lt;/strong&gt; 으로 &lt;strong&gt;채 웁니다&lt;/strong&gt; (기본값은 float의 경우 &lt;code&gt;np.nan&lt;/code&gt; , int의 경우 -1).</target>
        </trans-unit>
        <trans-unit id="0a5f29346dd6ed934af41fe4f9cf6ee37bc21199" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flags, op_flags, op_dtypes, order, casting, buffersize (optional)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;플래그, op_flags, op_dtypes, 순서, 캐스팅, 버퍼 크기 (선택 사항)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b6b80bd9334bc3b009da340c900a6d6aaf63145a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;flattened&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;flattened&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a5928c06805e109111daa252a10c3802b7d287a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;formats, names, titles, aligned, byteorder :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;형식, 이름, 제목, 정렬, 바이트 순서 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="888597e8066cc66f40410dfe90b6d35f8a27db66" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;func&lt;/strong&gt; &amp;ndash;</source>
          <target state="translated">&lt;strong&gt;펑크&lt;/strong&gt; &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="b5c13150ccd33a5ba616c31a10b2285a91ed6331" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;func&lt;/strong&gt; &amp;ndash; Must to an array of length &lt;em&gt;ntypes&lt;/em&gt; containing &lt;a href=&quot;#c.PyUFuncGenericFunction&quot;&gt;&lt;code&gt;PyUFuncGenericFunction&lt;/code&gt;&lt;/a&gt; items.</source>
          <target state="translated">&lt;strong&gt;func&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;#c.PyUFuncGenericFunction&quot;&gt; &lt;code&gt;PyUFuncGenericFunction&lt;/code&gt; &lt;/a&gt; 항목을 포함하는 길이 &lt;em&gt;ntypes&lt;/em&gt; 의 배열이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="cbf1592592e6c9ff476ce222410abd6398e5b814" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;generate_state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;generate_state&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="02c6698bb4dfda65e7eb1dc8d2c16b809b2bef77" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;has_cxx_sources&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;has_cxx_sources&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2fc10315a0b763529333445aa8cde1c289955833" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;has_f2py_sources&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;has_f2py_sources&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d30cd496a52ec13d28af4bf1418ce34dab83e189" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;homogenous&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;homogenous&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="18027649cbb02a9f2b42931202392a187d503190" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;identity&lt;/strong&gt; &amp;ndash; Either &lt;a href=&quot;#c.PyUFunc_One&quot;&gt;&lt;code&gt;PyUFunc_One&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.PyUFunc_Zero&quot;&gt;&lt;code&gt;PyUFunc_Zero&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#c.PyUFunc_MinusOne&quot;&gt;&lt;code&gt;PyUFunc_MinusOne&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#c.PyUFunc_None&quot;&gt;&lt;code&gt;PyUFunc_None&lt;/code&gt;&lt;/a&gt;. This specifies what should be returned when an empty array is passed to the reduce method of the ufunc. The special value &lt;a href=&quot;#c.PyUFunc_IdentityValue&quot;&gt;&lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;&lt;/a&gt; may only be used with the &lt;a href=&quot;#c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity&quot;&gt;&lt;code&gt;PyUFunc_FromFuncAndDataAndSignatureAndIdentity&lt;/code&gt;&lt;/a&gt; method, to allow an arbitrary python object to be used as the identity.</source>
          <target state="translated">&lt;strong&gt;identity&lt;/strong&gt; &amp;ndash; &lt;a href=&quot;#c.PyUFunc_One&quot;&gt; &lt;code&gt;PyUFunc_One&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.PyUFunc_Zero&quot;&gt; &lt;code&gt;PyUFunc_Zero&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#c.PyUFunc_MinusOne&quot;&gt; &lt;code&gt;PyUFunc_MinusOne&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;#c.PyUFunc_None&quot;&gt; &lt;code&gt;PyUFunc_None&lt;/code&gt; &lt;/a&gt; . 이것은 ufunc의 reduce 메소드에 빈 배열이 전달 될 때 리턴되어야하는 것을 지정합니다. 특수 값 &lt;a href=&quot;#c.PyUFunc_IdentityValue&quot;&gt; &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; &lt;/a&gt; 는 임의의 파이썬 개체를 ID로 사용할 수 있도록 &lt;a href=&quot;#c.PyUFunc_FromFuncAndDataAndSignatureAndIdentity&quot;&gt; &lt;code&gt;PyUFunc_FromFuncAndDataAndSignatureAndIdentity&lt;/code&gt; &lt;/a&gt; 메서드 와 함께 만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd3179834bd17c726ea52675440c456b010e1c23" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;identity&lt;/strong&gt; &amp;ndash; Either &lt;code&gt;PyUFunc_One&lt;/code&gt;, &lt;code&gt;PyUFunc_Zero&lt;/code&gt;, &lt;code&gt;PyUFunc_MinusOne&lt;/code&gt;, or &lt;code&gt;PyUFunc_None&lt;/code&gt;. This specifies what should be returned when an empty array is passed to the reduce method of the ufunc. The special value &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; may only be used with the &lt;code&gt;PyUFunc_FromFuncAndDataAndSignatureAndIdentity&lt;/code&gt; method, to allow an arbitrary python object to be used as the identity.</source>
          <target state="translated">&lt;strong&gt;identity&lt;/strong&gt; &amp;ndash; &lt;code&gt;PyUFunc_One&lt;/code&gt; , &lt;code&gt;PyUFunc_Zero&lt;/code&gt; , &lt;code&gt;PyUFunc_MinusOne&lt;/code&gt; 또는 &lt;code&gt;PyUFunc_None&lt;/code&gt; 입니다. 빈 배열이 ufunc의 reduce 메소드로 전달 될 때 리턴되어야하는 내용을 지정합니다. 특수한 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 는 &lt;code&gt;PyUFunc_FromFuncAndDataAndSignatureAndIdentity&lt;/code&gt; 메소드 와 함께 만 사용 하여 임의의 파이썬 오브젝트를 ID로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8a1e6f9c6bedd7c0a821e3fd3f51c5552298e9be" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;identity_value&lt;/strong&gt; &amp;ndash; The identity for the new gufunc. Must be passed as &lt;code&gt;NULL&lt;/code&gt; unless the &lt;code&gt;identity&lt;/code&gt; argument is &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt;. Setting it to NULL is equivalent to calling PyUFunc_FromFuncAndDataAndSignature.</source>
          <target state="translated">&lt;strong&gt;identity_value&lt;/strong&gt; &amp;ndash; 새 gufunc의 ID입니다. &lt;code&gt;identity&lt;/code&gt; 인수가 &lt;code&gt;PyUFunc_IdentityValue&lt;/code&gt; 가 아니면 &lt;code&gt;NULL&lt;/code&gt; 로 전달해야합니다 . NULL로 설정하는 것은 PyUFunc_FromFuncAndDataAndSignature를 호출하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="f060fd85a67e8fa6f5385c230c69d426bcbefcb4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;immutable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;immutable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36edf017e64ecae766dc4e57ede9fca86760db06" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;include_dirs :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;include_dirs :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="69079d90ef1851e2f0bbb8bc6ce5067ce4982a9f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;index&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8f40be9aef90d86194ef1b023c4e7a29cccc6904" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;indices: ndarray (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;지수 : ndarray (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="672dc89f055b86127c6f6796e85ddf32c292e319" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;instance&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;instance&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="634b80ca54d97d3cd01f1371e38aa4c38a1d83b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;is_array(a)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;is_array(a)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cebead53ad7936fde41c4df1b0b05ae13f69b20c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;itemsize&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;itemsize&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="35e4443e72767971fbbb48fb4218cca1c1b166d7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;itemsize&lt;/strong&gt; &amp;ndash; This argument is only needed when &lt;em&gt;typenum&lt;/em&gt; represents a flexible array. Otherwise it should be 0.</source>
          <target state="translated">&lt;strong&gt;itemsize&lt;/strong&gt; &amp;ndash;이 인수는 &lt;em&gt;typenum&lt;/em&gt; 이 유연한 배열을 나타내는 경우에만 필요합니다 . 그렇지 않으면 0이어야합니다.</target>
        </trans-unit>
        <trans-unit id="c71a0743f3d06b78099dc60de2986e4f3fd7086c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;iterable&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;iterable&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f50ca43f39f9a1842ccc2d9cdc9242f3bd9da8c7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;itviews&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;itviews&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="828ac31a43c5ba6ec65cf9ab15d50a34e9df023b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;language :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;언어 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ab02243e53211a35952575d8bd6d6ed8f024613" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;libraries :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;도서관 :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0a11e2af60b0dc229f509feb5ad42488e6d76f24" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;library_dirs :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;library_dirs :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="141fafaccc619483b292ca17a5affe6854d5a601" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;list&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;list&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f9680e95a28c12fa913dcff0a8fae4714ad19624" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;little-endian&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;little-endian&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0d690ddba1121206ef135e575646860629e54002" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;lock: threading.Lock&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;자물쇠 : 실을 꿰기.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a7fd21a4ac4ae5bf7df89f1f49f52d34168f258e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;make_contiguous()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;make_contiguous()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="db18372e2588ac9844aca6b05d83ef0cf7ecd9ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;make_fortran()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;make_fortran()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5d237aebb168d4720a56f296748eb0fbab5cc3ec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mask&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mask&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c0ab325e98f928eb098b97ce112345d1558b1f91" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mask&lt;/strong&gt; (optional)</source>
          <target state="translated">&lt;strong&gt;마스크&lt;/strong&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="999ba87a2442a12aa3f8d3fe0bf5b4418509aa6a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;masked array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;마스킹 된 배열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c95189528a090f0546a43aa4c5fda6b70455c598" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mesh-grid `ndarrays` all of the same dimensions&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;동일한 치수의 메쉬 그리드`ndarrays`&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="df071b6932b7854a11acba837d226aca010ac7fb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;mesh-grid&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;mesh-grid&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="beb97c0a0ed841f3938cd4c4cd5036054c8e73f5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;metadata&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;metadata&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ddbdaf70a9fbc7624cbca266070cf536f522b169" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;method&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;method&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4067678d5c85d38460927954641f02c2477105fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;module_dirs :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;module_dirs :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="337c5666bb65575a91a43a44c371e440fd86ffec" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;multi_index&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;multi_index&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0e23b88472a787bbf79a674ed05032361d77038b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;n_children_spawned&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;n_children_spawned&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="8bdba194dded2729c390b530aba12dc941b4e9c0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; The name for the ufunc as a &lt;code&gt;NULL&lt;/code&gt; terminated string. Specifying a name of &amp;lsquo;add&amp;rsquo; or &amp;lsquo;multiply&amp;rsquo; enables a special behavior for integer-typed reductions when no dtype is given. If the input type is an integer (or boolean) data type smaller than the size of the &lt;a href=&quot;../arrays.scalars#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; data type, it will be internally upcast to the &lt;a href=&quot;../arrays.scalars#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;../arrays.scalars#numpy.uint&quot;&gt;&lt;code&gt;numpy.uint&lt;/code&gt;&lt;/a&gt;) data type.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자열 인 ufunc의 이름입니다 . 'add'또는 'multiply'의 이름을 지정하면 dtype이 제공되지 않을 때 정수 유형 감소에 대한 특수 동작을 사용할 수 있습니다. 입력 유형이 &lt;a href=&quot;../arrays.scalars#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; 데이터 유형 의 크기보다 작은 정수 (또는 부울) 데이터 유형 인 경우 내부적으로 &lt;a href=&quot;../arrays.scalars#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;../arrays.scalars#numpy.uint&quot;&gt; &lt;code&gt;numpy.uint&lt;/code&gt; &lt;/a&gt; ) 데이터 유형으로 업 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="7d67c3bdc6dc6b0ea133b1cf113b45f0febfa50f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; The name for the ufunc as a &lt;code&gt;NULL&lt;/code&gt; terminated string. Specifying a name of &amp;lsquo;add&amp;rsquo; or &amp;lsquo;multiply&amp;rsquo; enables a special behavior for integer-typed reductions when no dtype is given. If the input type is an integer (or boolean) data type smaller than the size of the &lt;code&gt;numpy.int_&lt;/code&gt; data type, it will be internally upcast to the &lt;code&gt;numpy.int_&lt;/code&gt; (or &lt;code&gt;numpy.uint&lt;/code&gt;) data type.</source>
          <target state="translated">&lt;strong&gt;name&lt;/strong&gt; &amp;ndash; ufunc의 이름으로 &lt;code&gt;NULL&lt;/code&gt; 로 끝나는 문자열입니다. 'add'또는 'multiply'라는 이름을 지정하면 dtype이 지정되지 않은 경우 정수 유형 축소에 대한 특수 동작이 가능합니다. 입력 유형이 &lt;code&gt;numpy.int_&lt;/code&gt; 데이터 유형 의 크기보다 작은 정수 (또는 부울) 데이터 유형 인 경우 내부적으로 &lt;code&gt;numpy.int_&lt;/code&gt; (또는 &lt;code&gt;numpy.uint&lt;/code&gt; ) 데이터 유형으로 업 캐스트됩니다 .</target>
        </trans-unit>
        <trans-unit id="2ba83ab646731524d208bd821ddddf41638f6efe" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;nd&lt;/strong&gt; &amp;ndash; The dimensionality of the array (1, 2, or 3).</source>
          <target state="translated">&lt;strong&gt;nd&lt;/strong&gt; &amp;ndash; 배열의 차원입니다 (1, 2 또는 3).</target>
        </trans-unit>
        <trans-unit id="dbe66f521f662edf45a5ee4cfd7a4aad97616b02" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ndarray or scalar&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;ndarray 또는 스칼라&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="67e997557039ad725b78d398b794bae0ee8180a4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;nin&lt;/strong&gt; &amp;ndash; The number of inputs to this operation.</source>
          <target state="translated">&lt;strong&gt;nin&lt;/strong&gt; &amp;ndash;이 작업에 대한 입력 수입니다.</target>
        </trans-unit>
        <trans-unit id="a45f86d696eef9707d4d1d19a233bcbe71a9320e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;none&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;none&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3d90f907a9a32f41f2815afb166a1f5d3d2d63c9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;nout&lt;/strong&gt; &amp;ndash; The number of outputs</source>
          <target state="translated">&lt;strong&gt;nout&lt;/strong&gt; &amp;ndash; 출력 수</target>
        </trans-unit>
        <trans-unit id="36c448537aa2212d141d9a84a80b6741aaec1b30" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;np.recarray&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;np.recarray&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa7fd98c24f5c62cc83edd9abf5c1945cc0955fc" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ntypes&lt;/strong&gt; &amp;ndash; How many different data-type-specific functions the ufunc has implemented.</source>
          <target state="translated">&lt;strong&gt;ntypes&lt;/strong&gt; &amp;ndash; ufunc가 구현 한 다른 데이터 유형별 함수 수</target>
        </trans-unit>
        <trans-unit id="70a9cbf2fc2323ad058b95f9a3523bffd29aa2b5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;numpy.TooHardError&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;numpy.TooHardError&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a3a35de1aab05ddd052b048485e0037fb4bb3b6b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;numpy.linalg.LinAlgError: Singular matrix&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;numpy.linalg.LinAlgError : 특이 행렬&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="116ed4985f773a6b44564b6118ac8a1f73699361" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;numpy&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;numpy&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e27fbeac25fc9e5401e3761c3327afcc147824ae" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj: any&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj : 임의&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c327d8b933a9541eb8e9c716c1c9c07608e24c3b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b1ecfd8ea5b427089c9c605e5a9129a75dfe3984" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj_to_array_allow_conversion()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj_to_array_allow_conversion()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="14bcd090fa0db2426eb07e7e1b5ebf8959963ada" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj_to_array_contiguous_allow_conversion()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj_to_array_contiguous_allow_conversion()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ee7e5fa6d2892f44dcf0362318c2b46631bbe819" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj_to_array_fortran_allow_conversion()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj_to_array_fortran_allow_conversion()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9b872120d96c4f103490bf1aa11621ea7531382f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;obj_to_array_no_conversion()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;obj_to_array_no_conversion()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9d8adcf2843fa649115f8b8270f40b64c85c1914" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;offset: int, optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;오프셋 : 정수, 선택 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="498e7ab8abad5859b6d077bd46cc7fcf983b0531" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;offset&lt;/strong&gt; (optional)</source>
          <target state="translated">&lt;strong&gt;오프셋&lt;/strong&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="24195996fec88a1a907b46aae3863cc09a05ba75" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;op&lt;/strong&gt; &amp;ndash; The address to any Python object. This Python object will be replaced with an equivalent well-behaved, C-style contiguous, ndarray of the given data type specified by the last two arguments. Be sure that stealing a reference in this way to the input object is justified.</source>
          <target state="translated">&lt;strong&gt;op&lt;/strong&gt; &amp;ndash; 모든 Python 객체의 주소입니다. 이 Python 객체는 마지막 두 인수에 의해 지정된 주어진 데이터 유형의 동등하고 잘 동작하는 C 스타일 연속 ndarray로 대체됩니다. 이 방법으로 입력 객체에 대한 참조를 훔치는 것이 정당한지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="6821ad2bda3127d58dab03e17f045be73122781f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;out: ndarray (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;out : ndarray (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a57d1972f6fa4458660d3a89a38b8b43a7d2950a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pool&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;pool&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0cd55e0411411ff372c0fe1e6d22c0122ddf4aa9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pool_size&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;pool_size&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="fa22998f7d2a5b13cf0bf39b3312c454e629dba2" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;ptr&lt;/strong&gt; &amp;ndash; The address to a (ctype* for 1-d, ctype** for 2-d or ctype*** for 3-d) variable where ctype is the equivalent C-type for the data type. On return, &lt;em&gt;ptr&lt;/em&gt; will be addressable as a 1-d, 2-d, or 3-d array.</source>
          <target state="translated">&lt;strong&gt;ptr&lt;/strong&gt; &amp;ndash; ctype은 데이터 유형에 해당하는 C 유형입니다. 돌아 왔을 때 &lt;em&gt;ptr&lt;/em&gt; 은 1-d, 2-d 또는 3d 배열로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="ec9e45c2fd9cd27c556f5374f8af6ddb38b1eff4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;pytype_string()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;pytype_string()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6533c5debbffd39bf023965b3fe5e5fcb251e1a3" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;record array&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;레코드 배열&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aadf5f1c227412c85c717bf4a5c2b30fd5f533cf" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;reference&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;reference&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e8f8818f7a0d7605748cb63c1762963355cb4d3f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;require_contiguous()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;require_contiguous()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2f25ef05e1f2871d7bb8234f7fa29fe62ababd7b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;require_dimensions()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;require_dimensions()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="901b233d7d566ce3db6b99a8b0042ba32cd5bc68" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;require_dimensions_n()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;require_dimensions_n()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e4c952a822af95b181513e384112f1deeefdca5c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;require_fortran()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;require_fortran()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="84ba1660c7eab6e564e546a6bd43ff6effb0d3fd" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;require_native()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;require_native()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4ffe8d6070e88e3a1c6ac7b86d3ee788f4ca524e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;require_size()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;require_size()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="7f078dfea24acc8831cd762a80071a754d02ebc7" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;residuals, rank, singular_values, rcond&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;잔차, 순위, 특이 값, rcond&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6cc7fbaa438db64e246c99698159b61f48d7016d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;runtime_library_dirs :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;runtime_library_dirs :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d146eb075d05f8253560f7057ec9243e7042f96e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;self.typeCode&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;self.typeCode&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="de0f5c8a663ffe52a86c0c8fc7ede0a5f4652f0b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;self.typeStr&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;self.typeStr&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="204bb9ce3ecb3e3181f0e288c94c68f87b6e358d" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;self&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;self&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="120081d3a1334f2ef9c260ca8ed3295632e46e52" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;shape: int or tuple of ints, optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;모양 : int 또는 int의 튜플, 선택 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="29f211353902e55cec4c12f859ef60bbe9f8a1a6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;shape&lt;/strong&gt; (required)</source>
          <target state="translated">&lt;strong&gt;모양&lt;/strong&gt; (필수)</target>
        </trans-unit>
        <trans-unit id="2f3bd93b9a95398290a40913a942ac7ee9a491ab" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;signature&lt;/strong&gt; &amp;ndash; The signature for the new gufunc. Setting it to NULL is equivalent to calling PyUFunc_FromFuncAndData. A copy of the string is made, so the passed in buffer can be freed.</source>
          <target state="translated">&lt;strong&gt;signature&lt;/strong&gt; &amp;ndash; 새로운 gufunc의 서명. NULL로 설정하는 것은 PyUFunc_FromFuncAndData를 호출하는 것과 같습니다. 문자열의 사본이 작성되므로 전달 된 버퍼를 해제 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3579e15b18a782dffc14f8dedc606eeb4da4ed7f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;slice&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;slice&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="2036ea57c9f109a40b478597e125269a02ccf6f9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;spawn&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;spawn&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="a400dcdee94ec8590ae722cce7a93fa4208b72d5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;spawn_key&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;spawn_key&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="340d93d630e5f4d5a65d03a2dc1f6b8cd6757131" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;start&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;start&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="97eafdd572ef6c531ac977b61dfe3a8d92567760" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;state&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;state&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b5d96c176de391eade95d3eab7f894273c12e2ba" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;step&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;step&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="d4eff7e8819a241b5a3d5b2e606853372352847a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;stop&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;stop&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6e7bf266123703a5ed1d3f9506baa75a5d9e9ed0" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;strides: tuple of ints, optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;strides : int의 튜플, 선택 사항&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="c7855fe0cb49b9f1b64e4faa6b466f066e32630e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;strides&lt;/strong&gt; (optional)</source>
          <target state="translated">&lt;strong&gt;보폭&lt;/strong&gt; (선택 사항)</target>
        </trans-unit>
        <trans-unit id="f36c435f7d2af875ebd5fb27caafa15391fe7527" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;structure&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;structure&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="b3a4d21f62d7603fb19305a4cc7ac9162d670f3e" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;structured data type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;구조화 된 데이터 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="521ee0f0c77eebb07ebc18c96c9c8e1cec3b85d9" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;subarray data type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;부분 배열 데이터 유형&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9edccbf709f95bf21ae9ace0085d47a49def90e5" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;suffix: str, optional&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;접미사 : str, 옵션&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="23397d09ef6d0619a35aa2abd202c97d30c0e07c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;swig_opts :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;swig_opts :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="9fcf86d6350fb0c06657d07317671a90de74d52f" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;title&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;title&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cb8b5ce45908009fc052139d40d24793bff5df20" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tobytes&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tobytes&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f18c86901ff725e4e4f366cd1c91336552cdc87c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tostring&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tostring&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5fc52ea7d270d274f4d7992492682c20d4c57816" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;tuple&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;tuple&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3ceb09d09fcfa72e32dd310b1889d27dc8d05fee" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;type&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;type&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36c8d14fb8db6ca16c0e77071ac07434991dad45" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;type_match()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;type_match()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f1c7ae7d73f83cb484d05c0fc631a0796afce47b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;type_without_description&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;type_without_description&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="e9a66a9d2cc27b77f36430b6cf5a654b7eae3d1c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;typecode_string()&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;typecode_string()&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ec5ba0fd92c60e3383c9db3710c03672f5ce22d8" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;typenum&lt;/strong&gt; &amp;ndash; The expected data type of the array.</source>
          <target state="translated">&lt;strong&gt;typenum&lt;/strong&gt; &amp;ndash; 배열의 예상 데이터 유형입니다.</target>
        </trans-unit>
        <trans-unit id="c3b36532c0cb69d6fd4b693eb6c4341bb1fecb27" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;types&lt;/strong&gt; &amp;ndash;</source>
          <target state="translated">&lt;strong&gt;유형&lt;/strong&gt; &amp;ndash;</target>
        </trans-unit>
        <trans-unit id="9dfcb18418cf638770fc401b34c6467f19d489db" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;typestr&lt;/strong&gt; (required)</source>
          <target state="translated">&lt;strong&gt;typestr&lt;/strong&gt; (필수)</target>
        </trans-unit>
        <trans-unit id="f22e6096616c3b5e339d6fc2068fa5f10136f46b" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;undef_macros :&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;undef_macros :&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="566c08ff5cbfc7563b6ec48f86b77d9828806bcb" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;unused&lt;/strong&gt; &amp;ndash; Unused and present for backwards compatibility of the C-API.</source>
          <target state="translated">&lt;strong&gt;미사용&lt;/strong&gt; &amp;ndash; 사용하지 않으며 C-API의 이전 버전과의 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="2fe8c102c8793c67d6746562319d7cce28d3e604" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;value&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;value&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="212034ee3710f83d787575e7a3119ff8c1718007" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;values: array_like (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;값 : array_like (Ni&amp;hellip;, J, Nk&amp;hellip;)&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3dc38d803fcdf5b4457864347438f926098e055a" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;var&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;var&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f6d7fcb11482a1af063f80fe63d360a6e65e24e4" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;vectorization&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;vectorization&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="ece35df348f32a862697a3ca07ca318c2719b8c6" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;version&lt;/strong&gt; (required)</source>
          <target state="translated">&lt;strong&gt;버전&lt;/strong&gt; (필수)</target>
        </trans-unit>
        <trans-unit id="a50b66227821134be63cdc8c83fee8ce7c311e86" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;weekmask or holidays. The attributes return copies of internal data.&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;마스크 또는 휴일. 속성은 내부 데이터의 사본을 리턴합니다.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="be03b327ebed5cd158b36eac66e5294037949c8c" translate="yes" xml:space="preserve">
          <source>&lt;strong&gt;wrapper&lt;/strong&gt;</source>
          <target state="translated">&lt;strong&gt;wrapper&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="6afa5fd008afa469686c9e7fb95f9ddcee12a5f4" translate="yes" xml:space="preserve">
          <source>= location and</source>
          <target state="translated">= 위치</target>
        </trans-unit>
        <trans-unit id="0973e6133866853f9e6256eba9d72c9151694397" translate="yes" xml:space="preserve">
          <source>= scale.</source>
          <target state="translated">= 규모.</target>
        </trans-unit>
        <trans-unit id="dbae4b50ad6ac0a0e515dead61dcef253fcc6db1" translate="yes" xml:space="preserve">
          <source>= the result of iterating &lt;code&gt;j&lt;/code&gt; over</source>
          <target state="translated">= &lt;code&gt;j&lt;/code&gt; 를 반복 한 결과 통해</target>
        </trans-unit>
        <trans-unit id="6dcd4ce23d88e2ee9568ba546c007c63d9131c1b" translate="yes" xml:space="preserve">
          <source>A</source>
          <target state="translated">A</target>
        </trans-unit>
        <trans-unit id="f6e98724818994cd883edf139d3846ca96648b54" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;mutually agreed upon hiatus&amp;rdquo; where the committee asks the individual to temporarily refrain from community participation. If the individual chooses not to take a temporary break voluntarily, the committee may issue a &amp;ldquo;mandatory cooling off period&amp;rdquo;.</source>
          <target state="translated">위원회가 개인에게 일시적으로 커뮤니티 참여를 자제하도록 요청하는 &quot;상호 합의 된 중단&quot;. 개인이 자발적으로 일시적인 휴식을 취하지 않기로 결정한 경우위원회는 &quot;필수 냉각 기간&quot;을 발표 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cde6a5f915926c219c9ad1caeba15367682dad41" translate="yes" xml:space="preserve">
          <source>A &amp;ldquo;traditional&amp;rdquo; example:</source>
          <target state="translated">&amp;ldquo;전통적인&amp;rdquo;예 :</target>
        </trans-unit>
        <trans-unit id="654e39aa1416e4a99699a4c806db40cb3e673a19" translate="yes" xml:space="preserve">
          <source>A 1- or 2-d array_like</source>
          <target state="translated">1 차원 배열 또는 2 차원 배열</target>
        </trans-unit>
        <trans-unit id="024da60a5572fbcd0de36246055b7067f7d49cbc" translate="yes" xml:space="preserve">
          <source>A 1-D array, containing the elements of the input, is returned. A copy is made only if needed.</source>
          <target state="translated">입력 요소를 포함하는 1 차원 배열이 반환됩니다. 필요한 경우에만 사본이 작성됩니다.</target>
        </trans-unit>
        <trans-unit id="05915b878480d5cbbd9d515ad9e6d4ff95cf41d7" translate="yes" xml:space="preserve">
          <source>A 1-D flat iterator for Arrayterator objects.</source>
          <target state="translated">Arrayterator 객체 용 1D 평면 반복기입니다.</target>
        </trans-unit>
        <trans-unit id="e94e5e444e4a89c91179830906b14e4b95c7f975" translate="yes" xml:space="preserve">
          <source>A 1-D flat iterator over the array.</source>
          <target state="translated">배열 위의 1D 평면 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="080d28fe39f0db76a9a09d5b0de0f2cfd772f02d" translate="yes" xml:space="preserve">
          <source>A 1-D flat iterator over the matrix.</source>
          <target state="translated">행렬 위의 1 차원 평면 반복자.</target>
        </trans-unit>
        <trans-unit id="03f8ab17663e982d06a46c4b01d02b934e42bf4b" translate="yes" xml:space="preserve">
          <source>A 1-D iterator over the array.</source>
          <target state="translated">배열에서 1D 반복자입니다.</target>
        </trans-unit>
        <trans-unit id="5f4c8f5af8234daf63ac87fac41bf34728e2a4a8" translate="yes" xml:space="preserve">
          <source>A 1-D or 2-D array containing multiple variables and observations. Each row of &lt;code&gt;m&lt;/code&gt; represents a variable, and each column a single observation of all those variables. Also see &lt;code&gt;rowvar&lt;/code&gt; below.</source>
          <target state="translated">여러 변수 및 관측치가 포함 된 1 차원 또는 2 차원 배열입니다. &lt;code&gt;m&lt;/code&gt; 의 각 행은 변수를 나타내고 각 열은 모든 변수에 대한 단일 관찰입니다. &lt;code&gt;rowvar&lt;/code&gt; 참조아래 .</target>
        </trans-unit>
        <trans-unit id="cebacd166002a0aab793729a826968ad21540978" translate="yes" xml:space="preserve">
          <source>A 1-D or 2-D array containing multiple variables and observations. Each row of &lt;code&gt;x&lt;/code&gt; represents a variable, and each column a single observation of all those variables. Also see &lt;code&gt;rowvar&lt;/code&gt; below.</source>
          <target state="translated">여러 변수 및 관측치가 포함 된 1 차원 또는 2 차원 배열입니다. &lt;code&gt;x&lt;/code&gt; 의 각 행은 변수를 나타내고 각 열은 모든 변수에 대한 단일 관찰입니다. 아래 &lt;code&gt;rowvar&lt;/code&gt; 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f72cd249fd4ea863c9357d49585ace84834bd8f7" translate="yes" xml:space="preserve">
          <source>A 1-D view of the scalar.</source>
          <target state="translated">스칼라의 1 차원보기입니다.</target>
        </trans-unit>
        <trans-unit id="3a0a346ddaabdf9157361bcef554a19793288c12" translate="yes" xml:space="preserve">
          <source>A 2-D example:</source>
          <target state="translated">2 차원 예 :</target>
        </trans-unit>
        <trans-unit id="1dcf8fe375a813c5bfbdff5bbb67bdacfa9f426d" translate="yes" xml:space="preserve">
          <source>A 2-dimensional array of size 2 x 3, composed of 4-byte integer elements:</source>
          <target state="translated">4 바이트 정수 요소로 구성된 2 x 3 크기의 2 차원 배열 :</target>
        </trans-unit>
        <trans-unit id="8985fdd2d0544649de815c0d71b2a1f7021bb122" translate="yes" xml:space="preserve">
          <source>A 2-dimensional ndarray that preserves its two-dimensional nature throughout operations. It has certain special operations, such as &lt;code&gt;*&lt;/code&gt; (matrix multiplication) and &lt;code&gt;**&lt;/code&gt; (matrix power), defined:</source>
          <target state="translated">작업 전반에 걸쳐 2 차원 특성을 보존하는 2 차원 ndarray입니다. &lt;code&gt;*&lt;/code&gt; (행렬 곱셈) 및 &lt;code&gt;**&lt;/code&gt; (행렬 전력) 과 같은 특정 특수 연산이 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc6cebe7eb915060fc6496dd11b4201c6171b95b" translate="yes" xml:space="preserve">
          <source>A 2-tuple of ints, iaxis_pad_width[0] represents the number of values padded at the beginning of vector where iaxis_pad_width[1] represents the number of values padded at the end of vector.</source>
          <target state="translated">정수의 2 튜플 인 iaxis_pad_width [0]은 벡터의 시작 부분에 채워지는 값의 수를 나타내고, iaxis_pad_width [1]은 벡터의 끝에 채워진 값의 수를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="2152806df29fad5ea3c51b85e6a2d449bd3debf7" translate="yes" xml:space="preserve">
          <source>A 2-tuple whose first argument is an integer (a long integer if necessary) that points to the data-area storing the array contents. This pointer must point to the first element of data (in other words any offset is always ignored in this case). The second entry in the tuple is a read-only flag (true means the data area is read-only).</source>
          <target state="translated">첫 번째 인수가 배열 내용을 저장하는 데이터 영역을 가리키는 정수 (필요한 경우 긴 정수) 인 2- 튜플입니다. 이 포인터는 데이터의 첫 번째 요소를 가리켜 야합니다 (즉,이 경우 오프셋은 항상 무시됩니다). 튜플의 두 번째 항목은 읽기 전용 플래그입니다 (true는 데이터 영역이 읽기 전용임을 의미).</target>
        </trans-unit>
        <trans-unit id="84c9a68ac1124dc92c3beb6d10fa6ef1a121ef47" translate="yes" xml:space="preserve">
          <source>A 2D array works much the same way.</source>
          <target state="translated">2D 배열은 거의 동일한 방식으로 작동합니다.</target>
        </trans-unit>
        <trans-unit id="b93bf653bc1902857eef1ccac3f5d09491253e5b" translate="yes" xml:space="preserve">
          <source>A 3-D example:</source>
          <target state="translated">3 차원 예 :</target>
        </trans-unit>
        <trans-unit id="56a85df542f6e0ae1b5dff43196ef149fd4fac69" translate="yes" xml:space="preserve">
          <source>A 3-dimensional array of size 3 x 3 x 3, summed over each of its three axes</source>
          <target state="translated">3 x 3 x 3 크기의 3 차원 배열로 3 개의 축 각각에 합산</target>
        </trans-unit>
        <trans-unit id="549cb93636e34bdf02245b26cee07ee2514370b9" translate="yes" xml:space="preserve">
          <source>A :c:type: &lt;code&gt;PyCObject&lt;/code&gt; whose &lt;code&gt;voidptr&lt;/code&gt; member contains a pointer to a filled &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Memory for the structure is dynamically created and the &lt;code&gt;PyCObject&lt;/code&gt; is also created with an appropriate destructor so the retriever of this attribute simply has to apply &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; to the object returned by this attribute when it is finished. Also, either the data needs to be copied out, or a reference to the object exposing this attribute must be held to ensure the data is not freed. Objects exposing the &lt;code&gt;__array_struct__&lt;/code&gt; interface must also not reallocate their memory if other objects are referencing them.</source>
          <target state="translated">A : C : 형식 : &lt;code&gt;PyCObject&lt;/code&gt; 그 &lt;code&gt;voidptr&lt;/code&gt; 회원 채워진 포인터 포함 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; 의&lt;/a&gt; 구조. 구조에 대한 메모리가 동적으로 작성되고 적절한 소멸자를 사용 하여 &lt;code&gt;PyCObject&lt;/code&gt; 도 작성 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; 속성의 검색기는 Py_DECREF 를 완료 할 때이 속성이 리턴 한 오브젝트 에 적용하기 만하면 됩니다. 또한 데이터를 복사하거나 데이터가 해제되지 않도록이 속성을 노출하는 개체에 대한 참조를 보유해야합니다. &lt;code&gt;__array_struct__&lt;/code&gt; 인터페이스를 노출하는 객체는 다른 객체가 참조하는 경우 메모리를 재 할당해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="123666c2b903886e6666f3af33f4531e21859a0f" translate="yes" xml:space="preserve">
          <source>A :c:type: &lt;code&gt;PyCObject&lt;/code&gt; whose &lt;code&gt;voidptr&lt;/code&gt; member contains a pointer to a filled &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Memory for the structure is dynamically created and the &lt;code&gt;PyCObject&lt;/code&gt; is also created with an appropriate destructor so the retriever of this attribute simply has to apply &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; to the object returned by this attribute when it is finished. Also, either the data needs to be copied out, or a reference to the object exposing this attribute must be held to ensure the data is not freed. Objects exposing the &lt;code&gt;__array_struct__&lt;/code&gt; interface must also not reallocate their memory if other objects are referencing them.</source>
          <target state="translated">A : C : 형식 : &lt;code&gt;PyCObject&lt;/code&gt; 그 &lt;code&gt;voidptr&lt;/code&gt; 회원 채워진 포인터 포함 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; 의&lt;/a&gt; 구조. 구조에 대한 메모리가 동적으로 생성되고 &lt;code&gt;PyCObject&lt;/code&gt; 도 적절한 소멸자를 사용하여 생성 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; 속성의 검색기 는 완료 될 때이 속성이 반환하는 객체에 Py_DECREF 를 적용하기 만하면 됩니다. 또한 데이터를 복사하거나이 속성을 노출하는 개체에 대한 참조를 유지하여 데이터가 해제되지 않도록해야합니다. &lt;code&gt;__array_struct__&lt;/code&gt; 인터페이스를 노출하는 객체는 다른 객체가 참조하는 경우 메모리를 재 할당해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f11f88290206147b1d2292d3cc2fdf906b6395b9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#numpy.flatiter&quot;&gt;&lt;code&gt;flatiter&lt;/code&gt;&lt;/a&gt; iterator can not be constructed directly from Python code by calling the &lt;a href=&quot;#numpy.flatiter&quot;&gt;&lt;code&gt;flatiter&lt;/code&gt;&lt;/a&gt; constructor.</source>
          <target state="translated">&lt;a href=&quot;#numpy.flatiter&quot;&gt; &lt;code&gt;flatiter&lt;/code&gt; &lt;/a&gt; 반복자는 호출하여 파이썬 코드에서 직접 구성 할 수없는 &lt;a href=&quot;#numpy.flatiter&quot;&gt; &lt;code&gt;flatiter&lt;/code&gt; 의&lt;/a&gt; 생성자를.</target>
        </trans-unit>
        <trans-unit id="04e500f693744c615f08a5f51c892405f5d5b306" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#numpy.flatiter&quot;&gt;&lt;code&gt;flatiter&lt;/code&gt;&lt;/a&gt; iterator is returned by &lt;code&gt;x.flat&lt;/code&gt; for any array &lt;code&gt;x&lt;/code&gt;. It allows iterating over the array as if it were a 1-D array, either in a for-loop or by calling its &lt;code&gt;next&lt;/code&gt; method.</source>
          <target state="translated">&lt;a href=&quot;#numpy.flatiter&quot;&gt; &lt;code&gt;flatiter&lt;/code&gt; 의&lt;/a&gt; 반복자 의해 반환 &lt;code&gt;x.flat&lt;/code&gt; 모든 어레이에 대해 &lt;code&gt;x&lt;/code&gt; . for 루프에서 또는 &lt;code&gt;next&lt;/code&gt; 메소드 를 호출하여 1 차원 배열 인 것처럼 배열을 반복 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95d941e878ab7108e7bbf0d91be33cc4179ce09f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#numpy.ma.MaskedArray.fill_value&quot;&gt;&lt;code&gt;fill_value&lt;/code&gt;&lt;/a&gt;, a value that may be used to replace the invalid entries in order to return a standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.ma.MaskedArray.fill_value&quot;&gt; &lt;code&gt;fill_value&lt;/code&gt; 를&lt;/a&gt; 표준 반환하기 위해 잘못된 항목을 대체 할 수있는 값 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1c964244ee98d97a65f759995ef1198c398deab1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#term-structured-array&quot;&gt;structured array&lt;/a&gt; with allowing access in an attribute style (&lt;code&gt;a.field&lt;/code&gt;) in addition to &lt;code&gt;a['field']&lt;/code&gt;. For details, see &lt;a href=&quot;reference/generated/numpy.recarray&quot;&gt;numpy.recarray.&lt;/a&gt;</source>
          <target state="translated">&lt;code&gt;a['field']&lt;/code&gt; 외에도 속성 스타일 ( &lt;code&gt;a.field&lt;/code&gt; )에서 액세스를 허용 하는 &lt;a href=&quot;#term-structured-array&quot;&gt;구조화 된 배열&lt;/a&gt; 입니다 . 자세한 내용은 &lt;a href=&quot;reference/generated/numpy.recarray&quot;&gt;numpy.recarray를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2362caead598cbe2b288c9414e081f7c67944064" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt; may contain a &lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt; with its own dtype and shape:</source>
          <target state="translated">&lt;a href=&quot;#term-structured-data-type&quot;&gt;구조화 된 데이터 유형은&lt;/a&gt; 포함 할 수 &lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt; 자신의 DTYPE 및 모양을 :</target>
        </trans-unit>
        <trans-unit id="e0c0e6b144ca0dcf2ee709917a46a6ccb8b09579" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; object.</source>
          <target state="translated">&lt;a href=&quot;../maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 의&lt;/a&gt; 객체입니다.</target>
        </trans-unit>
        <trans-unit id="08e0763b81b1391e700f6e9abab5495a807996f9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://cheat.errtheblog.com/s/git&quot;&gt;git cheat sheet&lt;/a&gt; is a page giving summaries of common commands.</source>
          <target state="translated">&lt;a href=&quot;http://cheat.errtheblog.com/s/git&quot;&gt;자식 치트 시트는&lt;/a&gt; 일반적인 명령의 요약을 제공하는 페이지입니다.</target>
        </trans-unit>
        <trans-unit id="4f8f184213c4917469095c26238630c2af459c05" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;matlab, R, IDL, NumPy/SciPy dictionary&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://mathesaurus.sf.net/&quot;&gt;MATLAB, R, IDL, NumPy와 / SciPy 사전&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="28900dc17201a4b7d2d4e25e648ec5859c4a33a8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file that includes the &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; directives given above will produce wrapper code that looks something like:</source>
          <target state="translated">위에 주어진 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 지시문 을 포함 하는 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 인터페이스 파일 은 다음과 같은 래퍼 코드를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="4f3b0be790d0fdf5f3b2fb4de6fcbf8a68d09af2" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; macro (&lt;code&gt;%numpy_typemaps&lt;/code&gt;) with three arguments for implementing the 74 argument signatures for the user&amp;rsquo;s choice of (1) C data type, (2) NumPy data type (assuming they match), and (3) dimension type.</source>
          <target state="translated">사용자가 (1) C 데이터 유형, (2) NumPy 데이터 유형 (일치한다고 가정) 및 (3) 차원 유형의 선택에 대해 74 개의 인수 서명을 구현하기위한 세 개의 &lt;code&gt;%numpy_typemaps&lt;/code&gt; 있는 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 매크로 ( % numpy_typemaps )</target>
        </trans-unit>
        <trans-unit id="9d1a71af0e22aac57287c432a875a1eb25e670c9" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt; whose &lt;code&gt;pointer&lt;/code&gt; member contains a pointer to a filled &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt;&lt;code&gt;PyArrayInterface&lt;/code&gt;&lt;/a&gt; structure. Memory for the structure is dynamically created and the &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt;&lt;code&gt;PyCapsule&lt;/code&gt;&lt;/a&gt; is also created with an appropriate destructor so the retriever of this attribute simply has to apply &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt;&lt;code&gt;Py_DECREF&lt;/code&gt;&lt;/a&gt; to the object returned by this attribute when it is finished. Also, either the data needs to be copied out, or a reference to the object exposing this attribute must be held to ensure the data is not freed. Objects exposing the &lt;a href=&quot;#object.__array_struct__&quot;&gt;&lt;code&gt;__array_struct__&lt;/code&gt;&lt;/a&gt; interface must also not reallocate their memory if other objects are referencing them.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; &lt;/a&gt; 그 &lt;code&gt;pointer&lt;/code&gt; 회원 채워진 포인터 포함 &lt;a href=&quot;c-api/types-and-structures#c.PyArrayInterface&quot;&gt; &lt;code&gt;PyArrayInterface&lt;/code&gt; 의&lt;/a&gt; 구조. 구조에 대한 메모리가 동적으로 생성되고 &lt;a href=&quot;https://docs.python.org/dev/c-api/capsule.html#c.PyCapsule&quot;&gt; &lt;code&gt;PyCapsule&lt;/code&gt; &lt;/a&gt; 도 적절한 소멸자를 사용하여 생성 되므로이 속성의 검색기 는 완료 될 때이 속성이 반환 한 객체에 &lt;a href=&quot;https://docs.python.org/dev/c-api/refcounting.html#c.Py_DECREF&quot;&gt; &lt;code&gt;Py_DECREF&lt;/code&gt; &lt;/a&gt; 를 적용하기 만하면 됩니다. 또한 데이터를 복사하거나이 속성을 노출하는 개체에 대한 참조를 유지하여 데이터가 해제되지 않도록해야합니다. &lt;a href=&quot;#object.__array_struct__&quot;&gt; &lt;code&gt;__array_struct__&lt;/code&gt; &lt;/a&gt; 인터페이스를 노출하는 객체는 다른 객체가 참조하는 경우 메모리를 재 할당해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="f6a39b7ab438dd15f42b017b28e27195616350b8" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/dev/library/typing.html#typing.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; representing objects that can be coerced into a &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/typing.html#typing.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt; 를 강요 할 수있는 개체를 나타내는 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b3be3838dca58c613fb345a18e68f3400005c1" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;https://docs.python.org/dev/library/typing.html#typing.Union&quot;&gt;&lt;code&gt;Union&lt;/code&gt;&lt;/a&gt; representing objects that can be coerced into an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/typing.html#typing.Union&quot;&gt; &lt;code&gt;Union&lt;/code&gt; &lt;/a&gt; 를 강요 할 수있는 개체를 나타내는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05e1d33a8a4d82642a6d603db2c91670f3c4706f" translate="yes" xml:space="preserve">
          <source>A &lt;a href=&quot;numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt;&lt;code&gt;busdaycalendar&lt;/code&gt;&lt;/a&gt; object which specifies the valid days. If this parameter is provided, neither weekmask nor holidays may be provided.</source>
          <target state="translated">유효한 일을 지정 하는 &lt;a href=&quot;numpy.busdaycalendar#numpy.busdaycalendar&quot;&gt; &lt;code&gt;busdaycalendar&lt;/code&gt; &lt;/a&gt; 객체입니다. 이 매개 변수가 제공되면 주 마스크 나 휴일을 제공 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="69e74f3240b3d2bc71fd1a27edc06864a12be76b" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt;-shaped array of floating-point samples from the standard normal distribution, or a single such float if no parameters were supplied.</source>
          <target state="translated">&lt;code&gt;(d0, d1, ..., dn)&lt;/code&gt; 표준 정규 분포로부터 부동 소수점 샘플 모양 배열 또는 매개 변수가 공급되어 있지 않은 경우, 하나의 이러한 로트.</target>
        </trans-unit>
        <trans-unit id="f85432176a284b58f1d5e997cde4fde1e664cb79" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;fill_value&lt;/code&gt;, a value that may be used to replace the invalid entries in order to return a standard &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;fill_value&lt;/code&gt; 를 표준 반환하기 위해 잘못된 항목을 대체 할 수있는 값 &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; 을&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6baa143c5214b0736e3c20c3d4d2133fd2d5b196" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;n&lt;/code&gt; x &lt;code&gt;M&lt;/code&gt; matrix where all elements are equal to zero, except for the &lt;code&gt;k&lt;/code&gt;-th diagonal, whose values are equal to one.</source>
          <target state="translated">&lt;code&gt;n&lt;/code&gt; 은 X &lt;code&gt;M&lt;/code&gt; 의 모든 요소가 0이다 매트릭스를 제외한 &lt;code&gt;k&lt;/code&gt; 번째 대각 값을 가진 것과 동일하다.</target>
        </trans-unit>
        <trans-unit id="602f7fa1aa35733737af74435da8b6f68a4e5c2f" translate="yes" xml:space="preserve">
          <source>A &lt;code&gt;python module&lt;/code&gt; block has the following structure:</source>
          <target state="translated">&lt;code&gt;python module&lt;/code&gt; 블록은 다음 구조를 갖는다 :</target>
        </trans-unit>
        <trans-unit id="1340f5e4772d7953f77838549f8ae4823c3c29fc" translate="yes" xml:space="preserve">
          <source>A BitGenerator provides a stream of random values. In order to generate reproducible streams, BitGenerators support setting their initial state via a seed. All of the provided BitGenerators will take an arbitrary-sized non-negative integer, or a list of such integers, as a seed. BitGenerators need to take those inputs and process them into a high-quality internal state for the BitGenerator. All of the BitGenerators in numpy delegate that task to &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;, which uses hashing techniques to ensure that even low-quality seeds generate high-quality initial states.</source>
          <target state="translated">BitGenerator는 임의의 값 스트림을 제공합니다. 재현 가능한 스트림을 생성하기 위해 BitGenerator는 시드를 통해 초기 상태 설정을 지원합니다. 제공된 모든 BitGenerator는 임의 크기의 음이 아닌 정수 또는 이러한 정수 목록을 시드로 사용합니다. BitGenerator는 해당 입력을 가져와 BitGenerator의 고품질 내부 상태로 처리해야합니다. Numpy의 모든 BitGenerator는 해당 작업을&lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; 에&lt;/a&gt;합니다. 해시 기술을 사용하여 품질이 낮은 시드라도 고품질 초기 상태를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="13fa9801a3e658bde1343a6710ebd94019b0e987" translate="yes" xml:space="preserve">
          <source>A BitGenerator should call this method in its constructor with an appropriate &lt;code&gt;n_words&lt;/code&gt; parameter to properly seed itself.</source>
          <target state="translated">BitGenerator는 생성자에서 적절한 &lt;code&gt;n_words&lt;/code&gt; 로이 메소드를 호출해야합니다. 매개 변수를 자체 시드를 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="980dc3923948d97cf7707356fb397d2e9165c290" translate="yes" xml:space="preserve">
          <source>A C expression may contain:</source>
          <target state="translated">AC 식은 다음을 포함 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a2c89b0af7257bacc92f4242dd8f1ed7de4e6a82" translate="yes" xml:space="preserve">
          <source>A Chebyshev series class.</source>
          <target state="translated">체비 쇼프 시리즈 클래스.</target>
        </trans-unit>
        <trans-unit id="2e5a3fc40b8c00875c7adc6fafc877312612fb23" translate="yes" xml:space="preserve">
          <source>A Common Example</source>
          <target state="translated">일반적인 예</target>
        </trans-unit>
        <trans-unit id="c78f058bb1e26a110b25c03cc8d4fb8973dcf766" translate="yes" xml:space="preserve">
          <source>A Final Note</source>
          <target state="translated">마지막 주</target>
        </trans-unit>
        <trans-unit id="5855bd622f932426a8509c7e52fdc0c07349e41d" translate="yes" xml:space="preserve">
          <source>A Guide to NumPy Documentation</source>
          <target state="translated">NumPy 문서에 대한 가이드</target>
        </trans-unit>
        <trans-unit id="ba43d685f2ac1fa308141b982976e7b9544ebafd" translate="yes" xml:space="preserve">
          <source>A Guide to NumPy/SciPy Documentation</source>
          <target state="translated">NumPy / SciPy 문서 가이드</target>
        </trans-unit>
        <trans-unit id="ecd3cc1095a7280cde1f0d6c177498d32c136fd7" translate="yes" xml:space="preserve">
          <source>A Laguerre series class.</source>
          <target state="translated">Laguerre 시리즈 클래스.</target>
        </trans-unit>
        <trans-unit id="f400cf9c7b159d607ff23b034ffd4be1a606224f" translate="yes" xml:space="preserve">
          <source>A Legendre series class.</source>
          <target state="translated">Legendre 시리즈 클래스.</target>
        </trans-unit>
        <trans-unit id="f99e7b91acb5be86a4e5f503122861650a2ccb0d" translate="yes" xml:space="preserve">
          <source>A MaskedArray is always returned, regardless of the input type.</source>
          <target state="translated">입력 유형에 관계없이 항상 MaskedArray가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="ce78219c5c53ca9baedc5b599176c3087fb77459" translate="yes" xml:space="preserve">
          <source>A PR must be &lt;strong&gt;approved&lt;/strong&gt; by at least one core team member before merging. Approval means the core team member has carefully reviewed the changes, and the PR is ready for merging.</source>
          <target state="translated">병합하기 전에 최소한 한 명의 핵심 팀 구성원이 PR을 &lt;strong&gt;승인&lt;/strong&gt; 해야합니다 . 승인은 핵심 팀 구성원이 변경 사항을주의 깊게 검토했으며 PR을 병합 할 준비가되었음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="4a0d4b16a28265c2c411709c0c2184400cd87fff" translate="yes" xml:space="preserve">
          <source>A Practical Example: Vector Quantization.</source>
          <target state="translated">실용적인 예 : 벡터 양자화.</target>
        </trans-unit>
        <trans-unit id="d8843fabe291906b2e58e594b00ecdcfc1fde0ec" translate="yes" xml:space="preserve">
          <source>A Python container that can hold any number of objects or items. The items do not have to be of the same type, and can even be lists themselves:</source>
          <target state="translated">여러 개체 또는 항목을 보유 할 수있는 Python 컨테이너입니다. 항목이 동일한 유형일 필요는 없으며 목록 자체 일 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6ce1b2e22cf0a8c0a03973eca72fa46ac91489bd" translate="yes" xml:space="preserve">
          <source>A Python object describing the data-type in more detail (same as the &lt;em&gt;descr&lt;/em&gt; key in &lt;a href=&quot;../arrays.interface#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt;). This can be &lt;code&gt;NULL&lt;/code&gt; if &lt;em&gt;typekind&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt; provide enough information. This field is also ignored unless &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; flag is on in &lt;em&gt;flags&lt;/em&gt;.</source>
          <target state="translated">데이터 유형을 더 자세히 설명하는 Python 객체 ( &lt;a href=&quot;../arrays.interface#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;descr&lt;/em&gt; 키와 동일 ). &lt;em&gt;typekind&lt;/em&gt; 및 &lt;em&gt;itemsize&lt;/em&gt; 가 충분한 정보를 제공하는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 될 수 있습니다 . 하지 않는 한이 필드는 무시됩니다 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; 의 플래그의에 &lt;em&gt;플래그&lt;/em&gt; .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ed27eee8d8cf342e89bea5a96065d23f78cf6945" translate="yes" xml:space="preserve">
          <source>A Python object describing the data-type in more detail (same as the &lt;em&gt;descr&lt;/em&gt; key in &lt;a href=&quot;../arrays.interface#object.__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt;). This can be &lt;code&gt;NULL&lt;/code&gt; if &lt;em&gt;typekind&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt; provide enough information. This field is also ignored unless &lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt;&lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt;&lt;/a&gt; flag is on in &lt;em&gt;flags&lt;/em&gt;.</source>
          <target state="translated">데이터 유형을 더 자세히 설명하는 Python 객체 ( &lt;a href=&quot;../arrays.interface#object.__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; &lt;/a&gt; 의 &lt;em&gt;descr&lt;/em&gt; 키와 동일 ). &lt;em&gt;typekind&lt;/em&gt; 및 &lt;em&gt;itemsize&lt;/em&gt; 가 충분한 정보를 제공하는 경우 &lt;code&gt;NULL&lt;/code&gt; 이 될 수 있습니다 . &lt;a href=&quot;../arrays.interface#c.NPY_ARR_HAS_DESCR&quot;&gt; &lt;code&gt;NPY_ARR_HAS_DESCR&lt;/code&gt; &lt;/a&gt; 플래그가 &lt;em&gt;flags&lt;/em&gt; 에 설정되어 있지 않으면이 필드도 무시됩니다 .&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d620fcc0619adea6d0d19bc96c8ee23d44af8093" translate="yes" xml:space="preserve">
          <source>A Python object describing the data-type in more detail (same as the &lt;em&gt;descr&lt;/em&gt; key in &lt;a href=&quot;arrays.interface#__array_interface__&quot;&gt;&lt;code&gt;__array_interface__&lt;/code&gt;&lt;/a&gt;). This can be &lt;code&gt;NULL&lt;/code&gt; if &lt;em&gt;typekind&lt;/em&gt; and &lt;em&gt;itemsize&lt;/em&gt; provide enough information. This field is also ignored unless &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; flag is on in &lt;em&gt;flags&lt;/em&gt;.</source>
          <target state="translated">보다 구체적으로, 데이터 타입 (같 설명 파이썬 객체 &lt;em&gt;DESCR의&lt;/em&gt; 키 &lt;a href=&quot;arrays.interface#__array_interface__&quot;&gt; &lt;code&gt;__array_interface__&lt;/code&gt; 을&lt;/a&gt; ). &lt;em&gt;typekind&lt;/em&gt; 및 &lt;em&gt;itemsize&lt;/em&gt; 가 충분한 정보를 제공하는 경우 &lt;code&gt;NULL&lt;/code&gt; 일 수 있습니다 . 하지 않는 한이 필드는 무시됩니다 &lt;code&gt;ARR_HAS_DESCR&lt;/code&gt; 의 플래그의에 &lt;em&gt;플래그&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="811b8ce90b99eebd82cee1bee20d5f2dc5026de4" translate="yes" xml:space="preserve">
          <source>A SciPy package contains, in addition to its sources, the following files and directories:</source>
          <target state="translated">SciPy 패키지에는 소스 외에도 다음 파일과 디렉토리가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e40f23352d29ee547ed495acb06d3278d345225" translate="yes" xml:space="preserve">
          <source>A basic format in this context is an optional shape specifier followed by an array-protocol type string. Parenthesis are required on the shape if it has more than one dimension. NumPy allows a modification on the format in that any string that can uniquely identify the type can be used to specify the data-type in a field. The generated data-type fields are named &lt;code&gt;'f0'&lt;/code&gt;, &lt;code&gt;'f1'&lt;/code&gt;, &amp;hellip;, &lt;code&gt;'f&amp;lt;N-1&amp;gt;'&lt;/code&gt; where N (&amp;gt;1) is the number of comma-separated basic formats in the string. If the optional shape specifier is provided, then the data-type for the corresponding field describes a sub-array.</source>
          <target state="translated">이 문맥의 기본 형식은 선택적 형태 지정자 뒤에 배열 프로토콜 유형 문자열이옵니다. 치수가 두 개 이상인 경우 모양에 괄호가 필요합니다. NumPy를 사용하면 형식을 고유하게 식별 할 수있는 문자열을 사용하여 필드에서 데이터 형식을 지정할 수 있으므로 형식을 수정할 수 있습니다. 생성 된 데이터 유형 필드의 이름은 &lt;code&gt;'f0'&lt;/code&gt; , &lt;code&gt;'f1'&lt;/code&gt; ,&amp;hellip;, &lt;code&gt;'f&amp;lt;N-1&amp;gt;'&lt;/code&gt; 여기서 N (&amp;gt; 1)은 문자열에서 쉼표로 구분 된 기본 형식의 수입니다. 선택적 모양 지정자가 제공되면 해당 필드의 데이터 유형이 하위 배열을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="33714726200551e610770d7ae55c0ed9c8005e6f" translate="yes" xml:space="preserve">
          <source>A beta value of 14 is probably a good starting point. Note that as beta gets large, the window narrows, and so the number of samples needs to be large enough to sample the increasingly narrow spike, otherwise NaNs will get returned.</source>
          <target state="translated">베타 값 14는 아마도 좋은 출발점이 될 것입니다. 베타가 커짐에 따라 창이 좁아지면서 점점 더 좁아지는 스파이크를 샘플링하기에 충분한 샘플 수를 가져야합니다. 그렇지 않으면 NaN이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="730a2f7351bc145102343cc14dc57118d72de04f" translate="yes" xml:space="preserve">
          <source>A bit-width name for this data-type.</source>
          <target state="translated">이 데이터 유형의 비트 폭 이름입니다.</target>
        </trans-unit>
        <trans-unit id="af66384dd9d2d25f2f246ac418a92d8c8bea0503" translate="yes" xml:space="preserve">
          <source>A boolean &lt;a href=&quot;#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; with the same shape as the data, where a &lt;code&gt;True&lt;/code&gt; value indicates that the corresponding element of the data is invalid. The special value &lt;a href=&quot;#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; is also acceptable for arrays without named fields, and indicates that no data is invalid.</source>
          <target state="translated">데이터와 모양이 같은 부울 &lt;a href=&quot;#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt; . &lt;code&gt;True&lt;/code&gt; 값은 해당 데이터 요소가 유효하지 않음을 나타냅니다. 명명 된 필드가없는 배열에도 특수 값 &lt;a href=&quot;#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 를 사용할 수 있으며 유효하지 않은 데이터가 없음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c12c87321ed3628b01c3ba7c62206eaedafb64fa" translate="yes" xml:space="preserve">
          <source>A boolean array used to select only certain elements for an operation:</source>
          <target state="translated">작업에 대해 특정 요소 만 선택하는 데 사용되는 부울 배열 :</target>
        </trans-unit>
        <trans-unit id="2c37cd3281f6d75c5ff48f61ab9efab50a592368" translate="yes" xml:space="preserve">
          <source>A boolean array which is broadcasted to match the dimensions of &lt;a href=&quot;numpy.array#numpy.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt;, and selects elements to include in the reduction. Note that for ufuncs like &lt;code&gt;minimum&lt;/code&gt; that do not have an identity defined, one has to pass in also &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">방송되는 부울 배열의 크기에 맞게 &lt;a href=&quot;numpy.array#numpy.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 환원에 포함하고, 선택 소자. identity가 정의되지 않은 &lt;code&gt;minimum&lt;/code&gt; 과 같은 ufuncs의 경우 &lt;code&gt;initial&lt;/code&gt; 도 전달해야 합니다.</target>
        </trans-unit>
        <trans-unit id="b2805701b39ac42271d949ffde0dd4bf567d116a" translate="yes" xml:space="preserve">
          <source>A boolean array which is broadcasted to match the dimensions of &lt;code&gt;a&lt;/code&gt;, and selects elements to include in the reduction. Note that for ufuncs like &lt;code&gt;minimum&lt;/code&gt; that do not have an identity defined, one has to pass in also &lt;code&gt;initial&lt;/code&gt;.</source>
          <target state="translated">방송되는 부울 배열의 크기에 맞게 환원에 포함하고, 선택 소자. 아이디가 정의되지 않은 &lt;code&gt;minimum&lt;/code&gt; 과 같은 ufunc의 경우 &lt;code&gt;initial&lt;/code&gt; 도 전달해야합니다. &lt;code&gt;a&lt;/code&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="86f98cff3c08f935f8811f83be9572c3de4637c7" translate="yes" xml:space="preserve">
          <source>A boolean array which is broadcasted to match the dimensions of &lt;code&gt;dst&lt;/code&gt;, and selects elements to copy from &lt;code&gt;src&lt;/code&gt; to &lt;code&gt;dst&lt;/code&gt; wherever it contains the value True.</source>
          <target state="translated">&lt;code&gt;dst&lt;/code&gt; 의 차원과 일치하도록 브로드 캐스트되고 부울 값이 포함 된 모든 위치 에서 &lt;code&gt;src&lt;/code&gt; 에서 &lt;code&gt;dst&lt;/code&gt; 로 복사 할 요소를 선택 하는 부울 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="d78a3585487d30435586ed9706d00090c300e7f0" translate="yes" xml:space="preserve">
          <source>A boolean array with the same dimensions as the input. If second argument is not supplied then a boolean array is returned with values True where the corresponding element of the input is positive infinity and values False where the element of the input is not positive infinity.</source>
          <target state="translated">입력과 치수가 같은 부울 배열입니다. 두 번째 인수가 제공되지 않으면 입력의 해당 요소가 양의 무한대 인 경우 True 값과 입력 요소가 양의 무한대가 아닌 경우 False 값으로 부울 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="edcba5627bf9872aa7674aa396e2821a8c076d34" translate="yes" xml:space="preserve">
          <source>A boolean array with the same dimensions as the input. If second argument is not supplied then a numpy boolean array is returned with values True where the corresponding element of the input is negative infinity and values False where the element of the input is not negative infinity.</source>
          <target state="translated">입력과 치수가 같은 부울 배열입니다. 두 번째 인수가 제공되지 않으면 입력의 해당 요소가 음의 무한대 인 경우 True 값과 입력의 요소가 음의 무한대가 아닌 경우 False 값으로 numpy 부울 배열이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="0afb7663cac315ffc6aa200bd089e46c012435b5" translate="yes" xml:space="preserve">
          <source>A boolean array with the same shape and type as &lt;code&gt;x&lt;/code&gt; to store the result.</source>
          <target state="translated">결과를 저장하기 위해 &lt;code&gt;x&lt;/code&gt; 와 모양 및 유형이 같은 부울 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="5662229389d9892b11458d25aa4c0db03cbc85bd" translate="yes" xml:space="preserve">
          <source>A boolean array with the same shape as &lt;code&gt;x&lt;/code&gt; to store the result.</source>
          <target state="translated">결과를 저장하기 위해 &lt;code&gt;x&lt;/code&gt; 와 모양이 같은 부울 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="36cdff4ce733d6b36ea0af26a04d95d7b9ef28d2" translate="yes" xml:space="preserve">
          <source>A boolean array, used to select only certain elements for an operation:</source>
          <target state="translated">작업에 대해 특정 요소 만 선택하는 데 사용되는 부울 배열 :</target>
        </trans-unit>
        <trans-unit id="9fbedd8a20450a12cb3ee54eea4b82356919f525" translate="yes" xml:space="preserve">
          <source>A boolean mask derived from &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 에서 파생 된 부울 마스크 입니다.</target>
        </trans-unit>
        <trans-unit id="ecafbbffb66e8564fe0247641db487ae109db731" translate="yes" xml:space="preserve">
          <source>A boolean mask with the same shape as the data;</source>
          <target state="translated">데이터와 모양이 같은 부울 마스크.</target>
        </trans-unit>
        <trans-unit id="fdfe3b3a0c71a1fd9345316921bc184891d04811" translate="yes" xml:space="preserve">
          <source>A brief Python primer on &lt;code&gt;__new__&lt;/code&gt; and &lt;code&gt;__init__&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;__new__&lt;/code&gt; 및 &lt;code&gt;__init__&lt;/code&gt; 에 대한 간단한 Python 입문서</target>
        </trans-unit>
        <trans-unit id="2ff4d8bf8489691629ea13c670df9523f6f8f2b9" translate="yes" xml:space="preserve">
          <source>A business day calendar object containing the specified weekmask and holidays values.</source>
          <target state="translated">지정된 주 마스크 및 휴일 값을 포함하는 영업일 달력 객체입니다.</target>
        </trans-unit>
        <trans-unit id="40a22219906d7788625c49e0079969b8993164ff" translate="yes" xml:space="preserve">
          <source>A business day calendar object that efficiently stores information defining valid days for the busday family of functions.</source>
          <target state="translated">busday 함수 계열에 유효한 날짜를 정의하는 정보를 효율적으로 저장하는 업무 일 달력 오브젝트입니다.</target>
        </trans-unit>
        <trans-unit id="df752352d813c2e3d6dd0b56023f054cf25105f6" translate="yes" xml:space="preserve">
          <source>A byte string.</source>
          <target state="translated">바이트 문자열.</target>
        </trans-unit>
        <trans-unit id="8695c88255f385733f796bbaedd0461b7eef4b10" translate="yes" xml:space="preserve">
          <source>A character code (one of &amp;lsquo;biufcmMOSUV&amp;rsquo;) identifying the general kind of data.</source>
          <target state="translated">일반적인 종류의 데이터를 식별하는 문자 코드 ( 'biufcmMOSUV'중 하나)입니다.</target>
        </trans-unit>
        <trans-unit id="9816b39af0a9d971aeef29e0be64e9e1da496e15" translate="yes" xml:space="preserve">
          <source>A character code indicating the kind of array (using the array interface typestring notation). A &amp;lsquo;b&amp;rsquo; represents Boolean, a &amp;lsquo;i&amp;rsquo; represents signed integer, a &amp;lsquo;u&amp;rsquo; represents unsigned integer, &amp;lsquo;f&amp;rsquo; represents floating point, &amp;lsquo;c&amp;rsquo; represents complex floating point, &amp;lsquo;S&amp;rsquo; represents 8-bit zero-terminated bytes, &amp;lsquo;U&amp;rsquo; represents 32-bit/character unicode string, and &amp;lsquo;V&amp;rsquo; represents arbitrary.</source>
          <target state="translated">배열의 종류를 나타내는 문자 코드입니다 (배열 인터페이스 유형 문자열 표기법 사용). 'b'는 부울, 'i'는 부호있는 정수, 'u'는 부호없는 정수, 'f'는 부동 소수점, 'c'는 복잡한 부동 소수점, 'S'는 8 비트 0으로 끝나는 바이트, 'U'는 32 비트 / 문자 유니 코드 문자열을 나타내고 'V'는 임의를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="640835ce5b60ee0611de8f1a565fb1483f0f6116" translate="yes" xml:space="preserve">
          <source>A character indicating the byte-order of this data-type object.</source>
          <target state="translated">이 데이터 유형 객체의 바이트 순서를 나타내는 문자입니다.</target>
        </trans-unit>
        <trans-unit id="10949fd1b1a46dea97602b78abe6497f1b34bcec" translate="yes" xml:space="preserve">
          <source>A character indicating the byte-order: &amp;lsquo;&amp;gt;&amp;rsquo; (big-endian), &amp;lsquo;&amp;lt;&amp;rsquo; (little- endian), &amp;lsquo;=&amp;rsquo; (native), &amp;lsquo;|&amp;rsquo; (irrelevant, ignore). All builtin data- types have byteorder &amp;lsquo;=&amp;rsquo;.</source>
          <target state="translated">바이트 순서를 나타내는 문자 : '&amp;gt;'(빅 엔디안), '&amp;lt;'(리틀 엔디안), '='(네이티브), '|' (무관, 무시). 모든 내장 데이터 유형의 바이트 순서는 '='입니다.</target>
        </trans-unit>
        <trans-unit id="4d4cdc18aee1de79b93ad2db60b3cb6c05440fae" translate="yes" xml:space="preserve">
          <source>A character indicating what kind of array is present according to the typestring convention with &amp;lsquo;t&amp;rsquo; -&amp;gt; bitfield, &amp;lsquo;b&amp;rsquo; -&amp;gt; Boolean, &amp;lsquo;i&amp;rsquo; -&amp;gt; signed integer, &amp;lsquo;u&amp;rsquo; -&amp;gt; unsigned integer, &amp;lsquo;f&amp;rsquo; -&amp;gt; floating point, &amp;lsquo;c&amp;rsquo; -&amp;gt; complex floating point, &amp;lsquo;O&amp;rsquo; -&amp;gt; object, &amp;lsquo;S&amp;rsquo; -&amp;gt; (byte-)string, &amp;lsquo;U&amp;rsquo; -&amp;gt; unicode, &amp;lsquo;V&amp;rsquo; -&amp;gt; void.</source>
          <target state="translated">'t'-&amp;gt; 비트 필드, 'b'-&amp;gt; 부울, 'i'-&amp;gt; 부호있는 정수, 'u'-&amp;gt; 부호없는 정수, 'f'-&amp;gt;를 사용하여 형식 문자열 규칙에 따라 어떤 종류의 배열이 있는지 나타내는 문자 부동 소수점, 'c'-&amp;gt; 복합 부동 소수점, 'O'-&amp;gt; 객체, 'S'-&amp;gt; (바이트) 문자열, 'U'-&amp;gt; 유니 코드, 'V'-&amp;gt; void.</target>
        </trans-unit>
        <trans-unit id="43faf3ef00ea09f95d03e5feb6027b1e5af2798e" translate="yes" xml:space="preserve">
          <source>A class definition gives the blueprint for constructing an object:</source>
          <target state="translated">클래스 정의는 객체 생성을위한 청사진을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="1e3c3cf78f0d1936ea320553b4c652bd35ed2232" translate="yes" xml:space="preserve">
          <source>A combination [int, array] or [array, int], where int is the number of bins and array is the bin edges.</source>
          <target state="translated">[int, array] 또는 [array, int] 조합. 여기서 int는 구간 수이고 array는 구간 가장자리입니다.</target>
        </trans-unit>
        <trans-unit id="c88bbadda5f3cf3c06f67944cd11bf63c009e12d" translate="yes" xml:space="preserve">
          <source>A common algorithm is to loop over all elements of an array and perform some function with each element by issuing a function call. As function calls can be time consuming, one way to speed up this kind of algorithm is to write the function so it takes a vector of data and then write the iteration so the function call is performed for an entire dimension of data at a time. This increases the amount of work done per function call, thereby reducing the function-call over-head to a small(er) fraction of the total time. Even if the interior of the loop is performed without a function call it can be advantageous to perform the inner loop over the dimension with the highest number of elements to take advantage of speed enhancements available on micro- processors that use pipelining to enhance fundamental operations.</source>
          <target state="translated">일반적인 알고리즘은 배열의 모든 요소를 ​​반복하고 함수 호출을 실행하여 각 요소에 대해 일부 기능을 수행하는 것입니다. 함수 호출은 시간이 많이 걸릴 수 있으므로 이러한 종류의 알고리즘 속도를 높이는 한 가지 방법은 함수를 작성하여 데이터 벡터를 취한 다음 반복을 작성하여 한 번에 전체 데이터 차원에 대해 함수 호출이 수행되도록하는 것입니다. 이렇게하면 함수 호출 당 수행되는 작업량이 증가하여 함수 호출 오버 헤드가 총 시간의 작은 부분으로 줄어 듭니다. 루프의 내부가 함수 호출없이 수행 되더라도 기본 작업을 향상시키기 위해 파이프 라이닝을 사용하는 마이크로 프로세서에서 사용할 수있는 속도 향상을 활용하기 위해 가장 많은 수의 요소를 사용하여 차원에 대해 내부 루프를 수행하는 것이 유리할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2aaf6d26cd1a295c28af26bf09dc66593484ed4c" translate="yes" xml:space="preserve">
          <source>A common application of &lt;a href=&quot;#numpy.lib.stride_tricks.sliding_window_view&quot;&gt;&lt;code&gt;sliding_window_view&lt;/code&gt;&lt;/a&gt; is the calculation of running statistics. The simplest example is the &lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;moving average&lt;/a&gt;:</source>
          <target state="translated">&lt;a href=&quot;#numpy.lib.stride_tricks.sliding_window_view&quot;&gt; &lt;code&gt;sliding_window_view&lt;/code&gt; &lt;/a&gt; 의 일반적인 응용 프로그램 은 실행중인 통계의 계산입니다. 가장 간단한 예는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Moving_average&quot;&gt;이동 평균입니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bd60264664d8586a11ad4343a10732839c215699" translate="yes" xml:space="preserve">
          <source>A common case in NumPy functions is to have outputs allocated based on the broadcasting of the input, and additionally have an optional parameter called &amp;lsquo;out&amp;rsquo; where the result will be placed when it is provided. The &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt;&lt;code&gt;nditer&lt;/code&gt;&lt;/a&gt; object provides a convenient idiom that makes it very easy to support this mechanism.</source>
          <target state="translated">NumPy 기능의 일반적인 경우는 입력의 브로드 캐스트를 기반으로 출력을 할당하고 추가로 결과가 제공 될 때 'out'이라는 선택적 매개 변수를 갖는 것입니다. &lt;a href=&quot;generated/numpy.nditer#numpy.nditer&quot;&gt; &lt;code&gt;nditer&lt;/code&gt; 의&lt;/a&gt; 객체는 매우 쉽게이 메커니즘을 지원 할 수있는 편리한 관용구를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="b7e1a45a8be43e8f336307abe5613c812f9c3ff0" translate="yes" xml:space="preserve">
          <source>A common use case for this is filtering for desired element values. For example one may wish to select all entries from an array which are not NaN:</source>
          <target state="translated">이에 대한 일반적인 사용 사례는 원하는 요소 값을 필터링하는 것입니다. 예를 들어 NaN이 아닌 배열에서 모든 항목을 선택하려고 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b1deb505aba0dee9bc57b64427ffaacea33af840" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;nonzero&lt;/code&gt; is to find the indices of an array, where a condition is True. Given an array &lt;code&gt;a&lt;/code&gt;, the condition &lt;code&gt;a&lt;/code&gt; &amp;gt; 3 is a boolean array and since False is interpreted as 0, ma.nonzero(a &amp;gt; 3) yields the indices of the &lt;code&gt;a&lt;/code&gt; where the condition is true.</source>
          <target state="translated">&lt;code&gt;nonzero&lt;/code&gt; 이 아닌 일반적인 용도 는 조건이 참인 배열의 인덱스를 찾는 것입니다. 배열 &lt;code&gt;a&lt;/code&gt; 가 주어지면 조건 &lt;code&gt;a&lt;/code&gt; &amp;gt; 3은 부울 배열이며 False가 0으로 해석되므로 ma.nonzero (a&amp;gt; 3)은 조건이 참인 &lt;code&gt;a&lt;/code&gt; 의 인덱스를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="d10789a39601bd0ec3a09e1bcad97963a039079f" translate="yes" xml:space="preserve">
          <source>A common use for &lt;code&gt;nonzero&lt;/code&gt; is to find the indices of an array, where a condition is True. Given an array &lt;code&gt;a&lt;/code&gt;, the condition &lt;code&gt;a&lt;/code&gt; &amp;gt; 3 is a boolean array and since False is interpreted as 0, np.nonzero(a &amp;gt; 3) yields the indices of the &lt;code&gt;a&lt;/code&gt; where the condition is true.</source>
          <target state="translated">&lt;code&gt;nonzero&lt;/code&gt; 이 아닌 일반적인 용도 는 조건이 참인 배열의 인덱스를 찾는 것입니다. 배열 &lt;code&gt;a&lt;/code&gt; 가 주어지면 조건 &lt;code&gt;a&lt;/code&gt; &amp;gt; 3은 부울 배열이며 False가 0으로 해석되므로 np.nonzero (a&amp;gt; 3)은 조건이 참인 &lt;code&gt;a&lt;/code&gt; 의 인덱스를 생성 합니다.</target>
        </trans-unit>
        <trans-unit id="c13f9d6e7749a3a615a2fb9f4899414cf6127141" translate="yes" xml:space="preserve">
          <source>A commonly reported issue is related to the environment activation within VSCode. Please see the &lt;a href=&quot;https://code.visualstudio.com/docs/python/environments&quot;&gt;VSCode support&lt;/a&gt; for information on how to correctly set up VSCode with virtual environments or conda.</source>
          <target state="translated">일반적으로보고되는 문제는 VSCode 내의 환경 활성화와 관련이 있습니다. 가상 환경 또는 conda로 VSCode를 올바르게 설정하는 방법에 대한 정보 는 &lt;a href=&quot;https://code.visualstudio.com/docs/python/environments&quot;&gt;VSCode 지원&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9cddb06859127943fd164765e9e1dc0d31aaae5b" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.char.chararray.tobytes#numpy.char.chararray.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.char.chararray.tobytes#numpy.char.chararray.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="ddf6742fae7a2839c13c13987feb78ebea116865" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.chararray.tobytes#numpy.chararray.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.chararray.tobytes#numpy.chararray.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="c2ca9930c7aa3022b2023cb7b40424e3ebdd285a" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.ma.masked_array.tobytes#numpy.ma.masked_array.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.ma.masked_array.tobytes#numpy.ma.masked_array.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="5b8bb5fcd6312ad4b1b1abda5b2b40c4dcca081b" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.ma.maskedarray.tobytes#numpy.ma.MaskedArray.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.ma.maskedarray.tobytes#numpy.ma.MaskedArray.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="8c67fdee0c16af3c366d036baaa3dda4144ec11a" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.matrix.tobytes#numpy.matrix.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.matrix.tobytes#numpy.matrix.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="403f98dd11ac0ea8b4b4a4e6383b2de15c224854" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.memmap.tobytes#numpy.memmap.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.memmap.tobytes#numpy.memmap.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="98670bd91c49457adbc28a71feb0c60edea8c768" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.ndarray.tobytes#numpy.ndarray.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="a8560aa0ca24f61565070f20c4181264f1847f07" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;a href=&quot;numpy.recarray.tobytes#numpy.recarray.tobytes&quot;&gt;&lt;code&gt;tobytes&lt;/code&gt;&lt;/a&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;a href=&quot;numpy.recarray.tobytes#numpy.recarray.tobytes&quot;&gt; &lt;code&gt;tobytes&lt;/code&gt; &lt;/a&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="487e433b028ef24e8b93237fc46f3635627e112e" translate="yes" xml:space="preserve">
          <source>A compatibility alias for &lt;code&gt;tobytes&lt;/code&gt;, with exactly the same behavior.</source>
          <target state="translated">&lt;code&gt;tobytes&lt;/code&gt; 의 호환성 별명 , 정확히 동일한 동작입니다.</target>
        </trans-unit>
        <trans-unit id="1c327d5ba1c1107eecd64cf160d7a3c3b72c1398" translate="yes" xml:space="preserve">
          <source>A complex number or sequence of complex numbers.</source>
          <target state="translated">복소수 또는 복소수 시퀀스.</target>
        </trans-unit>
        <trans-unit id="0a0cfa11c1789a966650ad3c5878d84e46b3ac64" translate="yes" xml:space="preserve">
          <source>A complex- or real-valued matrix whose eigenvalues are to be computed.</source>
          <target state="translated">고유 값을 계산할 복소수 또는 실수 행렬.</target>
        </trans-unit>
        <trans-unit id="df6ecf1ca51aead983c8d0521be2a8d9c2c969cb" translate="yes" xml:space="preserve">
          <source>A complex- or real-valued matrix whose eigenvalues will be computed.</source>
          <target state="translated">고유 값이 계산되는 복소수 또는 실수 행렬.</target>
        </trans-unit>
        <trans-unit id="b868700bc42d3832c640ddbc946303500209dfb5" translate="yes" xml:space="preserve">
          <source>A comprehensive overview of all objects that can be coerced into data types.</source>
          <target state="translated">데이터 유형으로 강제 변환 할 수있는 모든 개체에 대한 포괄적 인 개요입니다.</target>
        </trans-unit>
        <trans-unit id="846e9c828a6dacb3e9b0f03c4bf9ede31aa0b250" translate="yes" xml:space="preserve">
          <source>A compromise to get a good value. For small datasets the Sturges value will usually be chosen, while larger datasets will usually default to FD. Avoids the overly conservative behaviour of FD and Sturges for small and large datasets respectively. Switchover point is usually</source>
          <target state="translated">좋은 가치를 얻기위한 타협. 작은 데이터 세트의 경우 일반적으로 Sturge 값이 선택되고 큰 데이터 세트는 일반적으로 FD로 설정됩니다. 소규모 및 대규모 데이터 세트에 대해 FD 및 Sturges의 과도하게 보수적 인 동작을 피합니다. 전환점은 일반적으로</target>
        </trans-unit>
        <trans-unit id="a276bc6d03ad0669e3cc7c8501a64ab2b0aabf71" translate="yes" xml:space="preserve">
          <source>A concatenated ndarray or matrix.</source>
          <target state="translated">연결된 ndarray 또는 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="81e1ddd8fad2d5da09a556c355d68b360223b6d1" translate="yes" xml:space="preserve">
          <source>A consensus of datetime64 users agreed that this behavior is undesirable and at odds with how datetime64 is usually used (e.g., by &lt;a href=&quot;http://pandas.pydata.org&quot;&gt;pandas&lt;/a&gt;). For most use cases, a timezone naive datetime type is preferred, similar to the &lt;code&gt;datetime.datetime&lt;/code&gt; type in the Python standard library. Accordingly, datetime64 no longer assumes that input is in local time, nor does it print local times:</source>
          <target state="translated">datetime64 사용자의 합의에 따르면이 동작은 바람직하지 않으며 datetime64가 일반적으로 사용되는 방식 (예 : &lt;a href=&quot;http://pandas.pydata.org&quot;&gt;pandas&lt;/a&gt; ) 과 상충되는 것으로 동의했습니다 . 대부분의 경우 Python 표준 라이브러리 의 &lt;code&gt;datetime.datetime&lt;/code&gt; 유형 과 비슷한 시간대 순진 날짜 시간 유형이 선호 됩니다. 따라서 datetime64는 더 이상 입력이 현지 시간이라고 가정하지 않으며 현지 시간도 인쇄하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e341e4c13ef8eaa977a5ceb53e0656085e29c24c" translate="yes" xml:space="preserve">
          <source>A convenience class, used to encapsulate &amp;ldquo;natural&amp;rdquo; operations on polynomials so that said operations may take on their customary form in code (see Examples).</source>
          <target state="translated">다항식에 대한 &quot;자연적인&quot;연산을 캡슐화하여 해당 연산이 코드에서 관례적인 형식을 취할 수 있도록하는 편리한 클래스입니다 (예제 참조).</target>
        </trans-unit>
        <trans-unit id="9c7f08865ee30c63db8fd38fba04facd0ce29551" translate="yes" xml:space="preserve">
          <source>A convenience function &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt;&lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt;&lt;/a&gt; converts an aligned dtype or array to a packed one and vice versa. It takes either a dtype or structured ndarray as an argument, and returns a copy with fields re-packed, with or without padding bytes.</source>
          <target state="translated">편리한 함수 &lt;a href=&quot;#numpy.lib.recfunctions.repack_fields&quot;&gt; &lt;code&gt;numpy.lib.recfunctions.repack_fields&lt;/code&gt; &lt;/a&gt; 는 정렬 된 dtype 또는 배열을 패킹 된 형식으로 또는 그 반대로 변환합니다. dtype 또는 구조화 된 ndarray를 인수로 취하고 패딩 바이트가 있거나없는 필드가 다시 패킹 된 사본을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="151620da811c85a7079865f27be65ea6f5b0587f" translate="yes" xml:space="preserve">
          <source>A convenient alias for None, useful for indexing arrays.</source>
          <target state="translated">배열 인덱스에 유용한 None의 편리한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="a61da4fa1e4f696ca20240f1c2d4dbb1a7028a6a" translate="yes" xml:space="preserve">
          <source>A convenient pattern is to define a decorator &lt;code&gt;implements&lt;/code&gt; that can be used to add functions to &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt;.</source>
          <target state="translated">편리한 패턴은 &lt;code&gt;HANDLED_FUNCTIONS&lt;/code&gt; 에 함수를 추가하는 데 사용할 수 있는 데코레이터 &lt;code&gt;implements&lt;/code&gt; 을 정의하는 것 입니다 .</target>
        </trans-unit>
        <trans-unit id="29c806e36fe8b5590b73a2921578a354462385fd" translate="yes" xml:space="preserve">
          <source>A convenient way to count dimensions in a printed vector is to count &lt;code&gt;[&lt;/code&gt; symbols after the open-parenthesis. This is useful in distinguishing, say, a (1,2,3) shape from a (2,3) shape:</source>
          <target state="translated">인쇄 된 벡터에서 치수를 계산하는 편리한 방법 은 여는 괄호 뒤의 &lt;code&gt;[&lt;/code&gt; 기호 를 계산 하는 것입니다. 이것은 (1,2,3) 모양과 (2,3) 모양을 구별하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e2be79f4ed756589d21e373791f3f50d6d864035" translate="yes" xml:space="preserve">
          <source>A convenient way to execute examples is the &lt;code&gt;%doctest_mode&lt;/code&gt; mode of IPython, which allows for pasting of multi-line examples and preserves indentation.</source>
          <target state="translated">예제를 실행하는 편리한 방법 은 IPython 의 &lt;code&gt;%doctest_mode&lt;/code&gt; 모드로 여러 줄 예제를 붙여넣고 들여 쓰기를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30abac0c126f9bd71a6c782f2b03c3c3aba2c57f" translate="yes" xml:space="preserve">
          <source>A copy is performed by default.</source>
          <target state="translated">복사는 기본적으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="9fa36776969d9a57dc8d794768fefaeedefecd72" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;b&lt;/code&gt; appended to &lt;code&gt;axis&lt;/code&gt;. Note that &lt;a href=&quot;#numpy.ma.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is allocated and filled. If &lt;code&gt;axis&lt;/code&gt; is None, the result is a flattened array.</source>
          <target state="translated">&lt;code&gt;a&lt;/code&gt; 가 &lt;code&gt;b&lt;/code&gt; 의 &lt;code&gt;axis&lt;/code&gt; 추가 된 사본 . 참고 &lt;a href=&quot;#numpy.ma.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; 자리에서 발생하지 않습니다 새로운 배열을 할당하고 채워집니다. 경우 &lt;code&gt;axis&lt;/code&gt; 포함되지 않은 경우, 결과는 평탄화 된 배열이다.</target>
        </trans-unit>
        <trans-unit id="9d9a2722a855a841d1e53f1ef891ed477c6766f9" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;a&lt;/code&gt; with &lt;code&gt;b&lt;/code&gt; appended to &lt;code&gt;axis&lt;/code&gt;. Note that &lt;a href=&quot;numpy.append#numpy.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is allocated and filled. If &lt;code&gt;axis&lt;/code&gt; is None, the result is a flattened array.</source>
          <target state="translated">사본 와 &lt;code&gt;b&lt;/code&gt; 추가 &lt;code&gt;axis&lt;/code&gt; . 참고 &lt;a href=&quot;numpy.append#numpy.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; 자리에서 발생하지 않습니다 새로운 배열을 할당하고 채워집니다. 경우 &lt;code&gt;axis&lt;/code&gt; 포함되지 않은 경우, 결과는 평탄화 된 배열이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7ddd8698ec4c36f13446d06850216b55d57301cb" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;a&lt;/code&gt; without the slices along axis for which &lt;code&gt;condition&lt;/code&gt; is false.</source>
          <target state="translated">&lt;code&gt;condition&lt;/code&gt; 이 거짓 인 축을 따라 슬라이스 &lt;code&gt;a&lt;/code&gt; 없는의 복사본 .</target>
        </trans-unit>
        <trans-unit id="9e51e10da4f3fc66565226f8d7532becd87cc778" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;arr&lt;/code&gt; with &lt;code&gt;values&lt;/code&gt; appended to &lt;code&gt;axis&lt;/code&gt;. Note that &lt;a href=&quot;#numpy.append&quot;&gt;&lt;code&gt;append&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is allocated and filled. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;out&lt;/code&gt; is a flattened array.</source>
          <target state="translated">사본 &lt;code&gt;arr&lt;/code&gt; 과 &lt;code&gt;values&lt;/code&gt; 에 부가 &lt;code&gt;axis&lt;/code&gt; . 참고 &lt;a href=&quot;#numpy.append&quot;&gt; &lt;code&gt;append&lt;/code&gt; &lt;/a&gt; 자리에서 발생하지 않습니다 새로운 배열을 할당하고 채워집니다. 경우 &lt;code&gt;axis&lt;/code&gt; 포함되지 않은 경우, &lt;code&gt;out&lt;/code&gt; 편평한 배열이다.</target>
        </trans-unit>
        <trans-unit id="92111473d390efd8adf5b878205e8bc603afc606" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;arr&lt;/code&gt; with &lt;code&gt;values&lt;/code&gt; inserted. Note that &lt;a href=&quot;#numpy.insert&quot;&gt;&lt;code&gt;insert&lt;/code&gt;&lt;/a&gt; does not occur in-place: a new array is returned. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;out&lt;/code&gt; is a flattened array.</source>
          <target state="translated">사본 &lt;code&gt;arr&lt;/code&gt; 과 &lt;code&gt;values&lt;/code&gt; 삽입. 참고 &lt;a href=&quot;#numpy.insert&quot;&gt; &lt;code&gt;insert&lt;/code&gt; &lt;/a&gt; 자리에서 발생하지 않습니다 새로운 배열이 반환됩니다. 경우 &lt;code&gt;axis&lt;/code&gt; 포함되지 않은 경우, &lt;code&gt;out&lt;/code&gt; 편평한 배열이다.</target>
        </trans-unit>
        <trans-unit id="1b87c9376fbcb3d0b125161eee5f9adf601f6324" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;arr&lt;/code&gt; with the elements specified by &lt;code&gt;obj&lt;/code&gt; removed. Note that &lt;a href=&quot;#numpy.delete&quot;&gt;&lt;code&gt;delete&lt;/code&gt;&lt;/a&gt; does not occur in-place. If &lt;code&gt;axis&lt;/code&gt; is None, &lt;code&gt;out&lt;/code&gt; is a flattened array.</source>
          <target state="translated">&lt;code&gt;obj&lt;/code&gt; 에 의해 지정된 요소가 제거 된 &lt;code&gt;arr&lt;/code&gt; 의 사본 . 참고 &lt;a href=&quot;#numpy.delete&quot;&gt; &lt;code&gt;delete&lt;/code&gt; &lt;/a&gt; 자리에서 발생하지 않습니다. 경우 &lt;code&gt;axis&lt;/code&gt; 포함되지 않은 경우, &lt;code&gt;out&lt;/code&gt; 편평한 배열이다.</target>
        </trans-unit>
        <trans-unit id="ef5ec484979c813657ea6e12962cceaa803f005f" translate="yes" xml:space="preserve">
          <source>A copy of &lt;code&gt;self&lt;/code&gt; with invalid entries replaced by &lt;em&gt;fill_value&lt;/em&gt; (be it the function argument or the attribute of &lt;code&gt;self&lt;/code&gt;), or &lt;code&gt;self&lt;/code&gt; itself as an ndarray if there are no invalid entries to be replaced.</source>
          <target state="translated">사본 &lt;code&gt;self&lt;/code&gt; 로 대체 무효 엔트리와 &lt;em&gt;fill_value를는&lt;/em&gt; (그 함수의 인수 또는 특성 일 &lt;code&gt;self&lt;/code&gt; ) 또는 &lt;code&gt;self&lt;/code&gt; 유효하지 않은 엔트리가없는 경우 ndarray 자체를 교체한다.</target>
        </trans-unit>
        <trans-unit id="20929bf6f0f5783301a154635f1db6c0f7b0847c" translate="yes" xml:space="preserve">
          <source>A copy of the holiday array indicating additional invalid days.</source>
          <target state="translated">유효하지 않은 추가 일을 나타내는 휴일 배열의 복사본입니다.</target>
        </trans-unit>
        <trans-unit id="83f8a7d3c63e1b73ba667b3bf1e267f936c633fe" translate="yes" xml:space="preserve">
          <source>A copy of the input array, flattened to one dimension.</source>
          <target state="translated">입력 배열의 사본으로, 1 차원으로 평면화됩니다.</target>
        </trans-unit>
        <trans-unit id="0da11f2afa7a132e72b7e8d106c881e77fd49d7b" translate="yes" xml:space="preserve">
          <source>A copy of the input data as a list of 1-d arrays.</source>
          <target state="translated">1 차원 배열 목록으로 입력 데이터의 사본.</target>
        </trans-unit>
        <trans-unit id="a2ec4d1c7d29fce0bbbb2b93588b5082ae76dce1" translate="yes" xml:space="preserve">
          <source>A copy of the matrix, flattened to a &lt;code&gt;(1, N)&lt;/code&gt; matrix where &lt;code&gt;N&lt;/code&gt; is the number of elements in the original matrix.</source>
          <target state="translated">행렬의 복사본으로 &lt;code&gt;(1, N)&lt;/code&gt; 행렬로 병합됩니다. 여기서 &lt;code&gt;N&lt;/code&gt; 은 원래 행렬의 요소 수입니다.</target>
        </trans-unit>
        <trans-unit id="ec8ccf8212225ee2362f20a54059f106604c4c8e" translate="yes" xml:space="preserve">
          <source>A copy of the seven-element boolean mask indicating valid days.</source>
          <target state="translated">유효한 요일을 나타내는 7 요소 부울 마스크의 사본입니다.</target>
        </trans-unit>
        <trans-unit id="48da051f6fb411e5d7f076156cd5a288fde0f19f" translate="yes" xml:space="preserve">
          <source>A copy of the specified element of the array as a suitable Python scalar</source>
          <target state="translated">적절한 파이썬 스칼라로 지정된 배열 요소의 사본</target>
        </trans-unit>
        <trans-unit id="c6bc1a9690ca89addc6fd0c521d335f7301cabfb" translate="yes" xml:space="preserve">
          <source>A couple examples illustrating how choose broadcasts:</source>
          <target state="translated">방송을 선택하는 방법을 보여주는 몇 가지 예 :</target>
        </trans-unit>
        <trans-unit id="79c55eeffdc406262a02700dff6759d4344a8e15" translate="yes" xml:space="preserve">
          <source>A ctype scalar, union, array, or struct</source>
          <target state="translated">ctype 스칼라, 공용체, 배열 또는 구조체</target>
        </trans-unit>
        <trans-unit id="4d35563e75151cc0dbb5c5b566817578403fc0ff" translate="yes" xml:space="preserve">
          <source>A ctypes library object</source>
          <target state="translated">ctypes 라이브러리 객체</target>
        </trans-unit>
        <trans-unit id="d1e5cd9e7ac36feddf15161fea7659065ed8c0ab" translate="yes" xml:space="preserve">
          <source>A custom formatter can be used to display array elements as desired:</source>
          <target state="translated">사용자 정의 포맷터를 사용하여 원하는대로 배열 요소를 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ddb7299e60123e091aa3800ff8db6bda614f81ab" translate="yes" xml:space="preserve">
          <source>A data type composed of other datatypes</source>
          <target state="translated">다른 데이터 유형으로 구성된 데이터 유형</target>
        </trans-unit>
        <trans-unit id="c7f7b6a83ce973c0c5ab9720eba75e9be43c8cc7" translate="yes" xml:space="preserve">
          <source>A data type object (an instance of &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;numpy.dtype&lt;/code&gt;&lt;/a&gt; class) describes how the bytes in the fixed-size block of memory corresponding to an array item should be interpreted. It describes the following aspects of the data:</source>
          <target state="translated">데이터 유형 객체 ( &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;numpy.dtype&lt;/code&gt; &lt;/a&gt; 클래스 의 인스턴스 )는 배열 항목에 해당하는 고정 크기 메모리 블록의 바이트를 해석하는 방법을 설명합니다. 데이터의 다음 측면을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8e711db1425e16cacba4452fb8206715d7336cab" translate="yes" xml:space="preserve">
          <source>A data-type bit-flag that determines if the data-type exhibits object- array like behavior. Each bit in this member is a flag which are named as:</source>
          <target state="translated">데이터 유형이 객체 배열과 같은 동작을 나타내는 지 여부를 결정하는 데이터 유형 비트 플래그. 이 멤버의 각 비트는 다음과 같이 이름이 지정된 플래그입니다.</target>
        </trans-unit>
        <trans-unit id="4a302bf74f669a81b79d991c1f7d62a9555dbdfb" translate="yes" xml:space="preserve">
          <source>A data-type scalar that allows field access as attribute lookup.</source>
          <target state="translated">속성 조회로 필드 액세스를 허용하는 데이터 유형 스칼라입니다.</target>
        </trans-unit>
        <trans-unit id="cd9de6159d14408aafbc1129f2e3af5366f0a468" translate="yes" xml:space="preserve">
          <source>A datetime stored as a 64-bit integer, counting from &lt;code&gt;1970-01-01T00:00:00&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;1970-01-01T00:00:00&lt;/code&gt; 부터 계산되는 64 비트 정수로 저장된 날짜 / 시간 입니다.</target>
        </trans-unit>
        <trans-unit id="4587893c1e5eca1b7c042f70853952070073a28c" translate="yes" xml:space="preserve">
          <source>A deprecated version of &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt;&lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt;&lt;/a&gt; which depends upon &lt;code&gt;dealloc&lt;/code&gt; to trigger the writeback. For backwards compatibility, &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt;&lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt;&lt;/a&gt; is called at &lt;code&gt;dealloc&lt;/code&gt; but relying on that behavior is deprecated and not supported in PyPy.</source>
          <target state="translated">의 사용되지 않는 버전 &lt;a href=&quot;#c.NPY_ARRAY_WRITEBACKIFCOPY&quot;&gt; &lt;code&gt;NPY_ARRAY_WRITEBACKIFCOPY&lt;/code&gt; &lt;/a&gt; 에 따라 &lt;code&gt;dealloc&lt;/code&gt; 쓰기 저장을 트리거합니다. 이전 버전과의 호환성을 위해 &lt;a href=&quot;#c.PyArray_ResolveWritebackIfCopy&quot;&gt; &lt;code&gt;PyArray_ResolveWritebackIfCopy&lt;/code&gt; &lt;/a&gt; 는 &lt;code&gt;dealloc&lt;/code&gt; 에서 호출 되지만 해당 동작에 의존하는 것은 더 이상 사용되지 않으며 PyPy에서 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9c1b833307cee9e3cf72cc77b59a40521d42391e" translate="yes" xml:space="preserve">
          <source>A descriptive example:</source>
          <target state="translated">설명적인 예 :</target>
        </trans-unit>
        <trans-unit id="354ccd659fa1c8dfa9972bddfe036ab83716c35b" translate="yes" xml:space="preserve">
          <source>A detailed explanation of ufuncs can be found in the docs for &lt;a href=&quot;../ufuncs#ufuncs&quot;&gt;Universal functions (ufunc)&lt;/a&gt;.</source>
          <target state="translated">ufuncs에 대한 자세한 설명은 &lt;a href=&quot;../ufuncs#ufuncs&quot;&gt;범용 함수 (ufunc)&lt;/a&gt; 문서에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="27b24a3f9af87d38cf8835043360961c446d5af3" translate="yes" xml:space="preserve">
          <source>A dictionary mapping column number to a function that will parse the column string into the desired value. E.g., if column 0 is a date string: &lt;code&gt;converters = {0: datestr2num}&lt;/code&gt;. Converters can also be used to provide a default value for missing data (but see also &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;genfromtxt&lt;/code&gt;&lt;/a&gt;): &lt;code&gt;converters = {3: lambda s: float(s.strip() or 0)}&lt;/code&gt;. Default: None.</source>
          <target state="translated">열 문자열을 원하는 값으로 구문 분석하는 함수에 사전 맵핑 열 번호. 예를 들어, 열 0이 날짜 문자열 인 경우 &lt;code&gt;converters = {0: datestr2num}&lt;/code&gt; 입니다. 변환기를 사용하여 누락 된 데이터에 대한 기본값을 제공 할 수도 있습니다 (그러나 &lt;a href=&quot;numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;genfromtxt&lt;/code&gt; &lt;/a&gt; 참조 ) : &lt;code&gt;converters = {3: lambda s: float(s.strip() or 0)}&lt;/code&gt; . 기본값 : 없음</target>
        </trans-unit>
        <trans-unit id="1cbd819dc2f446364b9ff7d2c230f4036ccf0f7c" translate="yes" xml:space="preserve">
          <source>A dictionary of field names</source>
          <target state="translated">필드 이름 사전</target>
        </trans-unit>
        <trans-unit id="52eb8fbc37289e50998be5d2ab19d74829272082" translate="yes" xml:space="preserve">
          <source>A dictionary of field parameter arrays</source>
          <target state="translated">필드 매개 변수 배열 사전</target>
        </trans-unit>
        <trans-unit id="b6d48692d200a87a18970c15bc3c417bcace59d3" translate="yes" xml:space="preserve">
          <source>A dictionary of items (3 required and 5 optional). The optional keys in the dictionary have implied defaults if they are not provided.</source>
          <target state="translated">항목 사전 (3 개 필수, 5 개 선택적) 사전의 선택적 키는 제공되지 않은 경우 기본값을 암시합니다.</target>
        </trans-unit>
        <trans-unit id="2dcb7b8d8713e202dcb8ec09b8dbd906a4793948" translate="yes" xml:space="preserve">
          <source>A dictionary of user-defined 1-d vector loops (stored as CObject ptrs) for user-defined types. A loop may be registered by the user for any user-defined type. It is retrieved by type number. User defined type numbers are always larger than &lt;a href=&quot;c-api.dtype#c.NPY_USERDEF&quot;&gt;&lt;code&gt;NPY_USERDEF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 유형에 대한 사용자 정의 1-d 벡터 루프 사전 (CObject ptr로 저장 됨) 루프는 사용자 정의 유형에 대해 사용자가 등록 할 수 있습니다. 유형 번호로 검색됩니다. 사용자 정의 유형 번호는 항상 &lt;a href=&quot;c-api.dtype#c.NPY_USERDEF&quot;&gt; &lt;code&gt;NPY_USERDEF&lt;/code&gt; &lt;/a&gt; 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="ebd09dda8da60557319d62b2fae5ccc4c0f56bc9" translate="yes" xml:space="preserve">
          <source>A dictionary of user-defined 1-d vector loops (stored as CObject ptrs) for user-defined types. A loop may be registered by the user for any user-defined type. It is retrieved by type number. User defined type numbers are always larger than &lt;a href=&quot;dtype#c.NPY_USERDEF&quot;&gt;&lt;code&gt;NPY_USERDEF&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 유형에 대한 사용자 정의 1-d 벡터 루프 (CObject ptrs로 저장 됨)의 사전입니다. 사용자 정의 유형에 대해 사용자가 루프를 등록 할 수 있습니다. 유형 번호로 검색됩니다. 사용자 정의 유형 번호는 항상 &lt;a href=&quot;dtype#c.NPY_USERDEF&quot;&gt; &lt;code&gt;NPY_USERDEF&lt;/code&gt; &lt;/a&gt; 보다 큽니다 .</target>
        </trans-unit>
        <trans-unit id="382873e9e41e4be46c82c0e20d4fc4101cb301ad" translate="yes" xml:space="preserve">
          <source>A dictionary possibly containing ndarrays. Default is globals().</source>
          <target state="translated">ndarray를 포함 할 수있는 사전입니다. 기본값은 globals ()입니다.</target>
        </trans-unit>
        <trans-unit id="e4ab9ce9d6d7e21b1f408721fe18d109738fb1b3" translate="yes" xml:space="preserve">
          <source>A dictionary that replaces global operands in current frame. Ignored if &lt;code&gt;obj&lt;/code&gt; is not a string.</source>
          <target state="translated">현재 프레임에서 전역 피연산자를 대체하는 사전입니다. &lt;code&gt;obj&lt;/code&gt; 가 문자열이 아닌 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="0923166d8e51f518b3d2e18daa42e324c64d0629" translate="yes" xml:space="preserve">
          <source>A dictionary that replaces local operands in current frame. Ignored if &lt;code&gt;obj&lt;/code&gt; is not a string or &lt;code&gt;gdict&lt;/code&gt; is &lt;code&gt;None&lt;/code&gt;.</source>
          <target state="translated">현재 프레임에서 로컬 피연산자를 대체하는 사전입니다. &lt;code&gt;obj&lt;/code&gt; 가 문자열이 아니거나 &lt;code&gt;gdict&lt;/code&gt; 가 &lt;code&gt;None&lt;/code&gt; 인 경우 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="ddae21817b585619439839486178cd2998f464d2" translate="yes" xml:space="preserve">
          <source>A dictionary that replaces local operands in current frame. Ignored if &lt;code&gt;obj&lt;/code&gt; is not a string or &lt;code&gt;gdict&lt;/code&gt; is None.</source>
          <target state="translated">현재 프레임에서 로컬 피연산자를 대체하는 사전입니다. &lt;code&gt;obj&lt;/code&gt; 가 문자열이 아니거나 &lt;code&gt;gdict&lt;/code&gt; 가 None 이면 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="06bcc7d3d4264a6d6419702c27d5d128fee3024e" translate="yes" xml:space="preserve">
          <source>A dictionary with keys &amp;ldquo;divide&amp;rdquo;, &amp;ldquo;over&amp;rdquo;, &amp;ldquo;under&amp;rdquo;, and &amp;ldquo;invalid&amp;rdquo;, whose values are from the strings &amp;ldquo;ignore&amp;rdquo;, &amp;ldquo;print&amp;rdquo;, &amp;ldquo;log&amp;rdquo;, &amp;ldquo;warn&amp;rdquo;, &amp;ldquo;raise&amp;rdquo;, and &amp;ldquo;call&amp;rdquo;. The keys represent possible floating-point exceptions, and the values define how these exceptions are handled.</source>
          <target state="translated">문자열 &quot;ignore&quot;, &quot;print&quot;, &quot;log&quot;, &quot;warn&quot;, &quot;raise&quot;및 &quot;call에서 온 값인&quot;divide &quot;,&quot;over &quot;,&quot;under &quot;및&quot;invalid &quot;키가있는 사전 &amp;rdquo;. 키는 가능한 부동 소수점 예외를 나타내며 값은 이러한 예외를 처리하는 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="274bd217df99031a1f7ca14224d6a8c744cd94fc" translate="yes" xml:space="preserve">
          <source>A dimension index is an integer representing a dimension name. It enumerates the dimension names according to the order of the first occurrence of each name in the signature.</source>
          <target state="translated">차원 인덱스는 차원 이름을 나타내는 정수입니다. 서명에서 각 이름이 처음 나타나는 순서에 따라 차원 이름을 열거합니다.</target>
        </trans-unit>
        <trans-unit id="dc19580a731f382683601a5487121a4588f3baec" translate="yes" xml:space="preserve">
          <source>A dimension name represents a core dimension in the signature. Different dimensions may share a name, indicating that they are of the same size.</source>
          <target state="translated">차원 이름은 서명의 핵심 차원을 나타냅니다. 다른 차원은 이름이 같을 수 있으며 같은 크기임을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="8226218a3ad7de84a161b9a0ceec134c8325c475" translate="yes" xml:space="preserve">
          <source>A directory &lt;code&gt;numpy&lt;/code&gt; is created on your machine. (If you already have a numpy directory, GitHub will choose a different name like &lt;code&gt;numpy-1&lt;/code&gt;.)</source>
          <target state="translated">컴퓨터에 &lt;code&gt;numpy&lt;/code&gt; 디렉토리 가 생성됩니다. (이미 numpy 디렉토리가있는 경우 GitHub는 &lt;code&gt;numpy-1&lt;/code&gt; 과 같은 다른 이름을 선택합니다 .)</target>
        </trans-unit>
        <trans-unit id="e91d306ab0d3f2790363b14c868a1e01c6605ffa" translate="yes" xml:space="preserve">
          <source>A docstring for each ufunc. The first part of the docstring is dynamically generated from the number of outputs, the name, and the number of inputs. The second part of the docstring is provided at creation time and stored with the ufunc.</source>
          <target state="translated">각 ufunc에 대한 docstring. docstring의 첫 번째 부분은 출력 수, 이름 및 입력 수에서 동적으로 생성됩니다. 문서화 문자열의 두 번째 부분은 작성시 제공되며 ufunc와 함께 저장됩니다.</target>
        </trans-unit>
        <trans-unit id="fe6d66d9e897d097e9e2bc9bacd072a2edefb351" translate="yes" xml:space="preserve">
          <source>A documentation string (docstring) is a string that describes a module, function, class, or method definition. The docstring is a special attribute of the object (&lt;code&gt;object.__doc__&lt;/code&gt;) and, for consistency, is surrounded by triple double quotes, i.e.:</source>
          <target state="translated">문서 문자열 (docstring)은 모듈, 함수, 클래스 또는 메서드 정의를 설명하는 문자열입니다. &lt;code&gt;object.__doc__&lt;/code&gt; 은 객체 ( object .__ doc__ ) 의 특수 속성이며 일관성을 위해 세 개의 큰 따옴표로 둘러싸여 있습니다. 예 :</target>
        </trans-unit>
        <trans-unit id="cb5a9b4e2f08d90c7582c32e33a8dd3a11c7dba2" translate="yes" xml:space="preserve">
          <source>A dtype that looks like &lt;code&gt;ndtype&lt;/code&gt;, the type of all fields is boolean.</source>
          <target state="translated">ndtype과 같은 &lt;code&gt;ndtype&lt;/code&gt; 은 모든 필드의 유형이 부울입니다.</target>
        </trans-unit>
        <trans-unit id="e0e4680768b858ee23cfd8b02898abfaa7246693" translate="yes" xml:space="preserve">
          <source>A few new C-structures were found to be useful in the development of NumPy. These C-structures are used in at least one C-API call and are therefore documented here. The main reason these structures were defined is to make it easy to use the Python ParseTuple C-API to convert from Python objects to a useful C-Object.</source>
          <target state="translated">NumPy의 개발에 유용한 몇 가지 새로운 C 구조가 발견되었습니다. 이러한 C 구조는 하나 이상의 C-API 호출에 사용되므로 여기에 문서화되어 있습니다. 이러한 구조가 정의 된 주된 이유는 Python ParseTuple C-API를 사용하여 Python 객체에서 유용한 C-Object로 쉽게 변환 할 수 있기 때문입니다.</target>
        </trans-unit>
        <trans-unit id="926e6c8b101edc8cb1b7d7e49a378c0e283af0e6" translate="yes" xml:space="preserve">
          <source>A few sentences giving an extended description. This section should be used to clarify &lt;em&gt;functionality&lt;/em&gt;, not to discuss implementation detail or background theory, which should rather be explored in the &lt;strong&gt;Notes&lt;/strong&gt; section below. You may refer to the parameters and the function name, but parameter descriptions still belong in the &lt;strong&gt;Parameters&lt;/strong&gt; section.</source>
          <target state="translated">자세한 설명을 제공하는 몇 개의 문장. 이 섹션은 &lt;em&gt;기능&lt;/em&gt; 을 명확히하는 데 사용되어야하며 구현 세부 사항이나 배경 이론을 논의하는 것이 아니라 아래 의 &lt;strong&gt;참고&lt;/strong&gt; 섹션 에서 살펴보아야 합니다. 매개 변수 및 함수 이름을 참조 할 수 있지만 매개 변수 설명은 여전히 &lt;strong&gt;매개 변수&lt;/strong&gt; 섹션에 속합니다 .</target>
        </trans-unit>
        <trans-unit id="d56136f42370cc828f6f8282f41aa378eb0668e7" translate="yes" xml:space="preserve">
          <source>A field is a view of the array data with a given data-type. The values in the view are determined by the given type and the offset into the current array in bytes. The offset needs to be such that the view dtype fits in the array dtype; for example an array of dtype complex128 has 16-byte elements. If taking a view with a 32-bit integer (4 bytes), the offset needs to be between 0 and 12 bytes.</source>
          <target state="translated">필드는 주어진 데이터 유형을 가진 배열 데이터의보기입니다. 뷰의 값은 주어진 유형과 바이트 단위의 현재 배열에 대한 오프셋에 의해 결정됩니다. 오프셋은 뷰 dtype이 배열 dtype에 맞도록해야합니다. 예를 들어 dtype complex128의 배열에는 16 바이트 요소가 있습니다. 32 비트 정수 (4 바이트)로보기를 수행하는 경우 오프셋은 0-12 바이트 사이 여야합니다.</target>
        </trans-unit>
        <trans-unit id="d7af18874bc600ff203076889532fb22ddebf1a6" translate="yes" xml:space="preserve">
          <source>A filtering example</source>
          <target state="translated">필터링 예</target>
        </trans-unit>
        <trans-unit id="d1b21d39d7b2c4b29140daef6f51fe2f038fec79" translate="yes" xml:space="preserve">
          <source>A first possibility is to directly invoke the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt; class.</source>
          <target state="translated">첫 번째 가능성은 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; &lt;/a&gt; 클래스 를 직접 호출하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="00c6690cb3260ce56f71af57e5753fbdedb562e6" translate="yes" xml:space="preserve">
          <source>A fixed bit generator using a fixed seed and a fixed series of calls to &amp;lsquo;RandomState&amp;rsquo; methods using the same parameters will always produce the same results up to roundoff error except when the values were incorrect. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; is effectively frozen and will only receive updates that are required by changes in the the internals of Numpy. More substantial changes, including algorithmic improvements, are reserved for &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">고정 시드를 사용하는 고정 비트 생성기와 동일한 매개 변수를 사용하는 'RandomState'메서드에 대한 고정 된 일련의 호출은 값이 올바르지 않은 경우를 제외하고 항상 반올림 오류까지 동일한 결과를 생성합니다. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 는 효과적으로 고정되며 Numpy의 내부 변경에 필요한 업데이트 만 수신합니다. 알고리즘 개선을 포함하여보다 실질적인 변경 사항은 &lt;a href=&quot;generator#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 에&lt;/a&gt; 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="6eca43eca8b478519a1bb5ce29f20eb48d50d699" translate="yes" xml:space="preserve">
          <source>A fixed bit generator using a fixed seed and a fixed series of calls to &amp;lsquo;RandomState&amp;rsquo; methods using the same parameters will always produce the same results up to roundoff error except when the values were incorrect. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; is effectively frozen and will only receive updates that are required by changes in the the internals of Numpy. More substantial changes, including algorithmic improvements, are reserved for &lt;code&gt;Generator&lt;/code&gt;.</source>
          <target state="translated">고정 시드를 사용하는 고정 비트 생성기와 동일한 매개 변수를 사용하는 'RandomState'메서드에 대한 일련의 고정 된 호출은 값이 올바르지 않은 경우를 제외하고 항상 반올림 오류까지 동일한 결과를 생성합니다. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 는 효과적으로 고정되며 Numpy의 내부 변경에 필요한 업데이트 만받습니다. 알고리즘 개선을 포함한보다 실질적인 변경은 &lt;code&gt;Generator&lt;/code&gt; 를 위해 예약되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c18c1c2c124c331c105d3b8d72e10a08d0e99512" translate="yes" xml:space="preserve">
          <source>A float array with the same dimensions as the input. If second argument is not supplied then a float array is returned with the rounded values.</source>
          <target state="translated">입력 값과 차원이 동일한 부동 소수점 배열입니다. 두 번째 인수가 제공되지 않으면 반올림 된 값과 함께 float 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="e40f9bd793de063d4623b3a65127edbc7f4365a2" translate="yes" xml:space="preserve">
          <source>A floating point representation of negative infinity.</source>
          <target state="translated">음의 무한대의 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="f70219492bb06ea1bfc1bd486c51c9d74cdc6eec" translate="yes" xml:space="preserve">
          <source>A floating point representation of negative zero.</source>
          <target state="translated">음수 0의 부동 소수점 표현</target>
        </trans-unit>
        <trans-unit id="f318ecbc4360f30574687fabbb18b17aece0caea" translate="yes" xml:space="preserve">
          <source>A floating point representation of positive infinity.</source>
          <target state="translated">양의 무한대의 부동 소수점 표현.</target>
        </trans-unit>
        <trans-unit id="ac7d4260ed1570b946cfe14c53fa847bec8e3bc4" translate="yes" xml:space="preserve">
          <source>A floating point representation of positive zero.</source>
          <target state="translated">양수 0의 부동 소수점 표현</target>
        </trans-unit>
        <trans-unit id="61e0a8192c1f49ed33c6184804ba93dc807b4510" translate="yes" xml:space="preserve">
          <source>A floating-point array of shape &lt;code&gt;size&lt;/code&gt; of drawn samples, or a single sample if &lt;code&gt;size&lt;/code&gt; was not specified.</source>
          <target state="translated">그려진 샘플 의 모양 &lt;code&gt;size&lt;/code&gt; 의 부동 소수점 배열 또는 &lt;code&gt;size&lt;/code&gt; 가 지정되지 않은 경우 단일 샘플 .</target>
        </trans-unit>
        <trans-unit id="ebf2ce103753b74056842789f48f919368a96b81" translate="yes" xml:space="preserve">
          <source>A format used to define default field names, such as &amp;ldquo;f%i&amp;rdquo; or &amp;ldquo;f_%02i&amp;rdquo;.</source>
          <target state="translated">&quot;f % i&quot;또는 &quot;f_ % 02i&quot;와 같은 기본 필드 이름을 정의하는 데 사용되는 형식입니다.</target>
        </trans-unit>
        <trans-unit id="0e3f2afbcb3b2e4ea29373c19f19150e3ef3008c" translate="yes" xml:space="preserve">
          <source>A frequent error consists in calling &lt;code&gt;array&lt;/code&gt; with multiple arguments, rather than providing a single sequence as an argument.</source>
          <target state="translated">빈번한 오류는 단일 시퀀스를 인수로 제공하는 대신 여러 인수를 사용하여 &lt;code&gt;array&lt;/code&gt; 을 호출 하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="2efd0a9bf192225b296de6fd561a0d4150668961" translate="yes" xml:space="preserve">
          <source>A frequently asked question is &amp;ldquo;How do I set up a development version of NumPy in parallel to a released version that I use to do my job/research?&amp;rdquo;.</source>
          <target state="translated">자주 묻는 질문은 &quot;내 작업 / 연구를 수행하는 데 사용하는 릴리스 버전과 병렬로 NumPy의 개발 버전을 어떻게 설정합니까?&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="4fb879cfbf47de044c7b58ccf38d2c889796735a" translate="yes" xml:space="preserve">
          <source>A function associated with an object. For example, each ndarray has a method called &lt;code&gt;repeat&lt;/code&gt;:</source>
          <target state="translated">개체와 관련된 함수입니다. 예를 들어, 각 ndarray에는 &lt;code&gt;repeat&lt;/code&gt; 라는 메소드가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6953993ce940fc7ebd16cec3633d5689d9d12107" translate="yes" xml:space="preserve">
          <source>A function that reads &lt;code&gt;n_in&lt;/code&gt; items from &lt;code&gt;in&lt;/code&gt;, and writes to &lt;code&gt;out&lt;/code&gt; the read value if it is within the limits pointed to by &lt;code&gt;min&lt;/code&gt; and &lt;code&gt;max&lt;/code&gt;, or the corresponding limit if outside. The memory segments must be contiguous and behaved, and either &lt;code&gt;min&lt;/code&gt; or &lt;code&gt;max&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt;, but not both.</source>
          <target state="translated">읽는 기능 &lt;code&gt;n_in&lt;/code&gt; 의 항목 &lt;code&gt;in&lt;/code&gt; , 그리고 쓰기를 &lt;code&gt;out&lt;/code&gt; 는 한계가 가리키는 내에 있으면 판독 값이 &lt;code&gt;min&lt;/code&gt; 와 &lt;code&gt;max&lt;/code&gt; 또는 대응 한계 밖에있는 경우. 메모리 세그먼트는 연속적이고 동작해야하며 &lt;code&gt;min&lt;/code&gt; 또는 &lt;code&gt;max&lt;/code&gt; 는 &lt;code&gt;NULL&lt;/code&gt; 일 수 있지만 둘다는 아닙니다.</target>
        </trans-unit>
        <trans-unit id="7808e8deacae88a30b0157c6432f18e2b157f98e" translate="yes" xml:space="preserve">
          <source>A function that takes a pointer &lt;code&gt;in&lt;/code&gt; to an array of &lt;code&gt;n_in&lt;/code&gt; items, a pointer &lt;code&gt;mask&lt;/code&gt; to an array of &lt;code&gt;n_in&lt;/code&gt; boolean values, and a pointer &lt;code&gt;vals&lt;/code&gt; to an array of &lt;code&gt;nv&lt;/code&gt; items. Items from &lt;code&gt;vals&lt;/code&gt; are copied into &lt;code&gt;in&lt;/code&gt; wherever the value in &lt;code&gt;mask&lt;/code&gt; is non-zero, tiling &lt;code&gt;vals&lt;/code&gt; as needed if &lt;code&gt;nv &amp;lt; n_in&lt;/code&gt;. All arrays must be contiguous and behaved.</source>
          <target state="translated">포인터를 취하는 함수 &lt;code&gt;in&lt;/code&gt; 의 배열 &lt;code&gt;n_in&lt;/code&gt; 항목 포인터 &lt;code&gt;mask&lt;/code&gt; 의 배열 &lt;code&gt;n_in&lt;/code&gt; 부울 값 및 포인터 &lt;code&gt;vals&lt;/code&gt; 의 배열 &lt;code&gt;nv&lt;/code&gt; 아이템. 상품 &lt;code&gt;vals&lt;/code&gt; 로 복사 &lt;code&gt;in&lt;/code&gt; 의 값 목적지 &lt;code&gt;mask&lt;/code&gt; 기와 비 - 제로 &lt;code&gt;vals&lt;/code&gt; 경우 필요에 따라 &lt;code&gt;nv &amp;lt; n_in&lt;/code&gt; . 모든 배열은 연속적이고 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="08de4a29a83dcb61642d53e6def0193fbaef931c" translate="yes" xml:space="preserve">
          <source>A function that takes a pointer &lt;code&gt;src&lt;/code&gt; to a C contiguous, behaved segment, interpreted as a 3-dimensional array of shape &lt;code&gt;(n_outer, nindarray, nelem)&lt;/code&gt;, a pointer &lt;code&gt;indarray&lt;/code&gt; to a contiguous, behaved segment of &lt;code&gt;m_middle&lt;/code&gt; integer indices, and a pointer &lt;code&gt;dest&lt;/code&gt; to a C contiguous, behaved segment, interpreted as a 3-dimensional array of shape &lt;code&gt;(n_outer, m_middle, nelem)&lt;/code&gt;. The indices in &lt;code&gt;indarray&lt;/code&gt; are used to index &lt;code&gt;src&lt;/code&gt; along the second dimension, and copy the corresponding chunks of &lt;code&gt;nelem&lt;/code&gt; items into &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;clipmode&lt;/code&gt; (which can take on the values &lt;a href=&quot;array#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;array#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;array#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt;) determines how will indices smaller than 0 or larger than &lt;code&gt;nindarray&lt;/code&gt; will be handled.</source>
          <target state="translated">포인터 &lt;code&gt;src&lt;/code&gt; 를 C 연속, 동작 세그먼트로 가져 &lt;code&gt;(n_outer, nindarray, nelem)&lt;/code&gt; 모양의 3 차원 배열 (n_outer, nindarray, nelem) , 연속 된 &lt;code&gt;m_middle&lt;/code&gt; 정수 인덱스 의 동작 세그먼트에 대한 포인터 &lt;code&gt;indarray&lt;/code&gt; 및 포인터 &lt;code&gt;dest&lt;/code&gt; 으로 해석 되는 함수 3 차원 형태의 배열 &lt;code&gt;(n_outer, m_middle, nelem)&lt;/code&gt; 로 해석되는 C 연속 동작 세그먼트에 . &lt;code&gt;indarray&lt;/code&gt; 의 인덱스 는 두 번째 차원을 따라 &lt;code&gt;src&lt;/code&gt; 를 인덱싱 하고 &lt;code&gt;nelem&lt;/code&gt; 항목 의 해당 청크 를 &lt;code&gt;dest&lt;/code&gt; 에 복사하는 데 사용됩니다 . &lt;code&gt;clipmode&lt;/code&gt; ( NPY_RAISE 값을 &lt;a href=&quot;array#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;array#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;array#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; &lt;/a&gt; )은 0보다 작거나 &lt;code&gt;nindarray&lt;/code&gt; 보다 큰 인덱스를 처리하는 방법을 결정합니다 .</target>
        </trans-unit>
        <trans-unit id="104738b7ba43a478757ba0cfc95cfc1693132d3a" translate="yes" xml:space="preserve">
          <source>A function that takes a pointer &lt;code&gt;src&lt;/code&gt; to a C contiguous, behaved segment, interpreted as a 3-dimensional array of shape &lt;code&gt;(n_outer, nindarray, nelem)&lt;/code&gt;, a pointer &lt;code&gt;indarray&lt;/code&gt; to a contiguous, behaved segment of &lt;code&gt;m_middle&lt;/code&gt; integer indices, and a pointer &lt;code&gt;dest&lt;/code&gt; to a C contiguous, behaved segment, interpreted as a 3-dimensional array of shape &lt;code&gt;(n_outer, m_middle, nelem)&lt;/code&gt;. The indices in &lt;code&gt;indarray&lt;/code&gt; are used to index &lt;code&gt;src&lt;/code&gt; along the second dimension, and copy the corresponding chunks of &lt;code&gt;nelem&lt;/code&gt; items into &lt;code&gt;dest&lt;/code&gt;. &lt;code&gt;clipmode&lt;/code&gt; (which can take on the values &lt;a href=&quot;c-api.array#c.NPY_RAISE&quot;&gt;&lt;code&gt;NPY_RAISE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;c-api.array#c.NPY_WRAP&quot;&gt;&lt;code&gt;NPY_WRAP&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;c-api.array#c.NPY_CLIP&quot;&gt;&lt;code&gt;NPY_CLIP&lt;/code&gt;&lt;/a&gt;) determines how will indices smaller than 0 or larger than &lt;code&gt;nindarray&lt;/code&gt; will be handled.</source>
          <target state="translated">C 연속, 동작 세그먼트에 대한 포인터 &lt;code&gt;src&lt;/code&gt; 를 3 차원 모양 배열 &lt;code&gt;(n_outer, nindarray, nelem)&lt;/code&gt; 로 해석하는 함수, &lt;code&gt;m_middle&lt;/code&gt; 정수 인덱스 의 연속적이고 동작하는 세그먼트에 대한 포인터 &lt;code&gt;indarray&lt;/code&gt; 및 포인터 &lt;code&gt;dest&lt;/code&gt; C 연속적이고 동작하는 세그먼트로, 3 차원 형태의 배열 &lt;code&gt;(n_outer, m_middle, nelem)&lt;/code&gt; 로 해석됩니다 . &lt;code&gt;indarray&lt;/code&gt; 의 색인 은 두 번째 차원을 따라 &lt;code&gt;src&lt;/code&gt; 를 색인화 하고 &lt;code&gt;nelem&lt;/code&gt; 항목 의 해당 청크 를 &lt;code&gt;dest&lt;/code&gt; 에 복사하는 데 사용됩니다 . &lt;code&gt;clipmode&lt;/code&gt; (값을 취할 수 있음 ,&lt;a href=&quot;c-api.array#c.NPY_RAISE&quot;&gt; &lt;code&gt;NPY_RAISE&lt;/code&gt; &lt;/a&gt;&lt;a href=&quot;c-api.array#c.NPY_WRAP&quot;&gt; &lt;code&gt;NPY_WRAP&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;c-api.array#c.NPY_CLIP&quot;&gt; &lt;code&gt;NPY_CLIP&lt;/code&gt; &lt;/a&gt; )는 0보다 작거나 &lt;code&gt;nindarray&lt;/code&gt; 보다 큰 인덱스를 처리하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="7cb7204cb0f2bbcfcce745946459084676997fbf" translate="yes" xml:space="preserve">
          <source>A function to INCREF all the objects at the location &lt;em&gt;ptr&lt;/em&gt; according to the data-type &lt;em&gt;dtype&lt;/em&gt;. If &lt;em&gt;ptr&lt;/em&gt; is the start of a structured type with an object at any offset, then this will (recursively) increment the reference count of all object-like items in the structured type.</source>
          <target state="translated">data-type &lt;em&gt;dtype&lt;/em&gt; 에 따라 위치 &lt;em&gt;ptr&lt;/em&gt; 의 모든 오브젝트를 INCREF하는 함수 입니다. 경우 &lt;em&gt;PTR가&lt;/em&gt; 어떤 오프셋,이 마음대로 개체 구조형의 시작은 재귀 모든 구조형 항목 객체 등의 참조 카운트를 증가.&lt;em&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cf2abd32c85efc7a4a45d18f882ea7390dd2a706" translate="yes" xml:space="preserve">
          <source>A function to XDECREF all the object-like items at the location &lt;em&gt;ptr&lt;/em&gt; as recorded in the data-type, &lt;em&gt;dtype&lt;/em&gt;. This works recursively so that if &lt;code&gt;dtype&lt;/code&gt; itself has fields with data-types that contain object-like items, all the object-like fields will be XDECREF &lt;code&gt;'d&lt;/code&gt;.</source>
          <target state="translated">데이터 유형 &lt;em&gt;dtype에&lt;/em&gt; 기록 된 위치 &lt;em&gt;ptr&lt;/em&gt; 에있는 모든 오브젝트와 같은 항목을 XDECREF하는 함수 입니다. 이것은 &lt;code&gt;dtype&lt;/code&gt; 자체에 객체와 같은 항목을 포함하는 데이터 유형을 가진 필드가있는 경우 모든 객체와 같은 필드가 XDECREF &lt;code&gt;'d&lt;/code&gt; 가되도록 재귀 적으로 작동합니다 .&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="22460947c7a31673520aa4a3c153378510748e7e" translate="yes" xml:space="preserve">
          <source>A function to determine how scalars of this type should be interpreted. The argument is &lt;code&gt;NULL&lt;/code&gt; or a 0-dimensional array containing the data (if that is needed to determine the kind of scalar). The return value must be of type &lt;a href=&quot;array#c.NPY_SCALARKIND&quot;&gt;&lt;code&gt;NPY_SCALARKIND&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형의 스칼라를 해석하는 방법을 결정하는 함수입니다. 인수는 &lt;code&gt;NULL&lt;/code&gt; 또는 데이터를 포함하는 0 차원 배열입니다 (스칼라 종류를 결정하는 데 필요한 경우). 반환 값은 &lt;a href=&quot;array#c.NPY_SCALARKIND&quot;&gt; &lt;code&gt;NPY_SCALARKIND&lt;/code&gt; &lt;/a&gt; 유형 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="b5ce3a36b4ee5ac8d172d6bf8491bf2eb17ead79" translate="yes" xml:space="preserve">
          <source>A function to determine how scalars of this type should be interpreted. The argument is &lt;code&gt;NULL&lt;/code&gt; or a 0-dimensional array containing the data (if that is needed to determine the kind of scalar). The return value must be of type &lt;a href=&quot;c-api.array#c.NPY_SCALARKIND&quot;&gt;&lt;code&gt;NPY_SCALARKIND&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">이 유형의 스칼라를 해석하는 방법을 결정하는 함수입니다. 인수는 &lt;code&gt;NULL&lt;/code&gt; 이거나 데이터를 포함하는 0 차원 배열입니다 (스칼라의 종류를 결정하는 데 필요한 경우). 리턴 값은 &lt;a href=&quot;c-api.array#c.NPY_SCALARKIND&quot;&gt; &lt;code&gt;NPY_SCALARKIND&lt;/code&gt; &lt;/a&gt; 유형 이어야 합니다.</target>
        </trans-unit>
        <trans-unit id="3b27f94e3fb931693e2774cbba4852a8add55e98" translate="yes" xml:space="preserve">
          <source>A function which resolves the types and fills an array with the dtypes for the inputs and outputs</source>
          <target state="translated">유형을 확인하고 입력 및 출력에 대한 dtype으로 배열을 채우는 함수</target>
        </trans-unit>
        <trans-unit id="fa05609e2a63e5f9fc5e98307d1ff0cf96661165" translate="yes" xml:space="preserve">
          <source>A function which returns an inner loop. The &lt;code&gt;legacy&lt;/code&gt; in the name arises because for NumPy 1.6 a better variant had been planned. This variant has not yet come about.</source>
          <target state="translated">내부 루프를 반환하는 함수입니다. NumPy 1.6의 경우 더 나은 변형이 계획되었으므로 이름 의 &lt;code&gt;legacy&lt;/code&gt; 이 생깁니다. 이 변종은 아직 나오지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="69b19ae750da9c4f2d084ff0e9fbbfc38d5ca7e9" translate="yes" xml:space="preserve">
          <source>A function whose call signature is similar to that of &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt;&lt;code&gt;triu&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt;&lt;code&gt;tril&lt;/code&gt;&lt;/a&gt;. That is, &lt;code&gt;mask_func(x, k)&lt;/code&gt; returns a boolean array, shaped like &lt;code&gt;x&lt;/code&gt;. &lt;code&gt;k&lt;/code&gt; is an optional argument to the function.</source>
          <target state="translated">그 콜 사인 함수는 유사하다 &lt;a href=&quot;numpy.triu#numpy.triu&quot;&gt; &lt;code&gt;triu&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;numpy.tril#numpy.tril&quot;&gt; &lt;code&gt;tril&lt;/code&gt; &lt;/a&gt; . 즉, &lt;code&gt;mask_func(x, k)&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 모양의 부울 배열을 반환합니다 . &lt;code&gt;k&lt;/code&gt; 는 함수에 대한 선택적 인수입니다.</target>
        </trans-unit>
        <trans-unit id="c8a237dc5c1ca858afa1ad3081813802f1d53aa1" translate="yes" xml:space="preserve">
          <source>A general overview of building NumPy from source is given here, with detailed instructions for specific platforms given separately.</source>
          <target state="translated">소스에서 NumPy를 빌드하는 일반적인 개요가 여기에 제공되며 특정 플랫폼에 대한 자세한 지침은 별도로 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="329876d5a642cd76a4b4d5c9d5c7a769170dc22c" translate="yes" xml:space="preserve">
          <source>A general-purpose record array constructor that dispatches to the appropriate &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt;&lt;code&gt;recarray&lt;/code&gt;&lt;/a&gt; creation function based on the inputs (see Notes).</source>
          <target state="translated">입력을 기반으로 적절한 &lt;a href=&quot;numpy.recarray#numpy.recarray&quot;&gt; &lt;code&gt;recarray&lt;/code&gt; &lt;/a&gt; 생성 함수로 디스패치하는 범용 레코드 배열 생성자 (참고 참조).</target>
        </trans-unit>
        <trans-unit id="995bd7d70930e4a19e95e761b6d0636c4fb0d572" translate="yes" xml:space="preserve">
          <source>A generalization of this function for N-d arrays, that returns normal ndarrays.</source>
          <target state="translated">정상적인 ndarray를 반환하는 Nd 배열에 대한이 함수의 일반화.</target>
        </trans-unit>
        <trans-unit id="7d2cd13996513172bdaffb1dca33e4b60945af7a" translate="yes" xml:space="preserve">
          <source>A generalization to N dimensions and other operations. &lt;code&gt;np.multiply.outer(a.ravel(), b.ravel())&lt;/code&gt; is the equivalent.</source>
          <target state="translated">N 차원 및 기타 작업에 대한 일반화 &lt;code&gt;np.multiply.outer(a.ravel(), b.ravel())&lt;/code&gt; 는 동등합니다.</target>
        </trans-unit>
        <trans-unit id="6ea63b334059365b8726f6196d72e719b014eb2b" translate="yes" xml:space="preserve">
          <source>A generalization to dimensions other than 1D and other operations. &lt;code&gt;np.multiply.outer(a.ravel(), b.ravel())&lt;/code&gt; is the equivalent.</source>
          <target state="translated">1D 및 기타 작업 이외의 차원에 대한 일반화. &lt;code&gt;np.multiply.outer(a.ravel(), b.ravel())&lt;/code&gt; 은 동등합니다.</target>
        </trans-unit>
        <trans-unit id="05fbcfb35e19c702c00b11ba0147b99881f61dfb" translate="yes" xml:space="preserve">
          <source>A generic data source file (file, http, ftp, &amp;hellip;).</source>
          <target state="translated">일반 데이터 소스 파일 (file, http, ftp,&amp;hellip;)</target>
        </trans-unit>
        <trans-unit id="e742e0b647aaf1df5f5d3abb685cf9ccd7d61f19" translate="yes" xml:space="preserve">
          <source>A generic ufunc call. The ufunc is passed in as &lt;em&gt;self&lt;/em&gt;, the arguments to the ufunc as &lt;em&gt;args&lt;/em&gt; and &lt;em&gt;kwds&lt;/em&gt;. The &lt;em&gt;mps&lt;/em&gt; argument is an array of &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt;&lt;code&gt;PyArrayObject&lt;/code&gt;&lt;/a&gt; pointers whose values are discarded and which receive the converted input arguments as well as the ufunc outputs when success is returned. The user is responsible for managing this array and receives a new reference for each array in &lt;em&gt;mps&lt;/em&gt;. The total number of arrays in &lt;em&gt;mps&lt;/em&gt; is given by &lt;em&gt;self&lt;/em&gt; -&amp;gt;nin + &lt;em&gt;self&lt;/em&gt; -&amp;gt;nout.</source>
          <target state="translated">일반적인 ufunc 호출. ufunc는 &lt;em&gt;self&lt;/em&gt; 로 전달되고 ufunc 에 대한 인수는 &lt;em&gt;args&lt;/em&gt; 및 &lt;em&gt;kwds로 전달&lt;/em&gt; 됩니다. &lt;em&gt;MPS의&lt;/em&gt; 인수의 배열 &lt;a href=&quot;c-api.types-and-structures#c.PyArrayObject&quot;&gt; &lt;code&gt;PyArrayObject&lt;/code&gt; 의&lt;/a&gt; 값을 무시하고 성공이 반환 될 때, 변환 된 입력 인자뿐만 아니라 ufunc 출력을 수신 포인터. 사용자는이 배열을 관리해야하며 &lt;em&gt;mps의&lt;/em&gt; 각 배열에 대한 새 참조를받습니다 . 의 배열의 총 수 &lt;em&gt;MPS가&lt;/em&gt; 주어진다 &lt;em&gt;자기&lt;/em&gt; &amp;gt; 닌 + - &lt;em&gt;자기&lt;/em&gt; -&amp;gt; NOUT합니다.</target>
        </trans-unit>
        <trans-unit id="470ce9b7bfbbe0000647e1e82c8207ba45dad5c1" translate="yes" xml:space="preserve">
          <source>A good but technical page on &lt;a href=&quot;http://www.eecs.harvard.edu/~cduan/technical/git/&quot;&gt;git concepts&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://www.eecs.harvard.edu/~cduan/technical/git/&quot;&gt;git 개념&lt;/a&gt; 에 대한 훌륭하지만 기술적 인 페이지</target>
        </trans-unit>
        <trans-unit id="ad7ac43f6c1594c3c9c7080284b47d763bc8ee04" translate="yes" xml:space="preserve">
          <source>A growing plethora of scientific and mathematical Python-based packages are using NumPy arrays; though these typically support Python-sequence input, they convert such input to NumPy arrays prior to processing, and they often output NumPy arrays. In other words, in order to efficiently use much (perhaps even most) of today&amp;rsquo;s scientific/mathematical Python-based software, just knowing how to use Python&amp;rsquo;s built-in sequence types is insufficient - one also needs to know how to use NumPy arrays.</source>
          <target state="translated">점점 더 많은 과학 및 수학 Python 기반 패키지가 NumPy 배열을 사용하고 있습니다. 이들은 일반적으로 Python 시퀀스 입력을 지원하지만 처리하기 전에 이러한 입력을 NumPy 배열로 변환하고 종종 NumPy 배열을 출력합니다. 즉, 오늘날의 과학 / 수학적 Python 기반 소프트웨어를 많이 (아마도 대부분) 효율적으로 사용하려면 Python의 내장 시퀀스 유형을 사용하는 방법을 아는 것만으로는 충분하지 않습니다. NumPy 배열을 사용하는 방법도 알아야합니다.</target>
        </trans-unit>
        <trans-unit id="f76ed0444355d5a14b125b7364ff4980576c15a3" translate="yes" xml:space="preserve">
          <source>A guiding principle is that human readers of the text are given precedence over contorting docstrings so our tools produce nice output. Rather than sacrificing the readability of the docstrings, we have written pre-processors to assist &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; in its task.</source>
          <target state="translated">기본 원칙은 텍스트를 읽는 사람이 독 스트링을 왜곡하는 것보다 우선 순위를 부여하여 도구가 멋진 출력을 생성한다는 것입니다. 독 스트링의 가독성을 희생하는 대신 &lt;a href=&quot;http://sphinx.pocoo.org&quot;&gt;Sphinx&lt;/a&gt; 의 작업 을 지원하는 전처리기를 작성 했습니다.</target>
        </trans-unit>
        <trans-unit id="b77f49ba4cf074a32069b48a35ffecf32421fee4" translate="yes" xml:space="preserve">
          <source>A helper class for &lt;code&gt;CCompiler&lt;/code&gt; aims to provide extra build options to effectively control of compiler optimizations that are directly related to CPU features.</source>
          <target state="translated">&lt;code&gt;CCompiler&lt;/code&gt; 용 도우미 클래스는 CPU 기능과 직접 관련된 컴파일러 최적화를 효과적으로 제어하기위한 추가 빌드 옵션을 제공하는 것을 목표로합니다.</target>
        </trans-unit>
        <trans-unit id="e4625317d56afc2bf8a1ab930c61261029361d6f" translate="yes" xml:space="preserve">
          <source>A highly efficient way of reading binary data with a known data-type, as well as parsing simply formatted text files. Data written using the &lt;code&gt;tofile&lt;/code&gt; method can be read using this function.</source>
          <target state="translated">알려진 형식의 이진 데이터를 읽고 효율적으로 형식화 된 텍스트 파일을 구문 분석하는 매우 효율적인 방법입니다. &lt;code&gt;tofile&lt;/code&gt; 메소드를 사용하여 작성된 데이터는 이 기능을 사용하여 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4a1c31e1966da6e857ef1efb8f20d787f1fbadcc" translate="yes" xml:space="preserve">
          <source>A homogeneous container of numerical elements. Each element in the array occupies a fixed amount of memory (hence homogeneous), and can be a numerical element of a single type (such as float, int or complex) or a combination (such as &lt;code&gt;(float, int, float)&lt;/code&gt;). Each array has an associated data-type (or &lt;code&gt;dtype&lt;/code&gt;), which describes the numerical type of its elements:</source>
          <target state="translated">숫자 요소의 균일 한 컨테이너입니다. 배열의 각 요소는 고정 된 양의 메모리 (따라서 동종)를 차지하며 단일 유형 (예 : float, int 또는 복합) 또는 조합 (예 : &lt;code&gt;(float, int, float)&lt;/code&gt; ) 의 숫자 요소 일 수 있습니다 . 각 배열에는 해당 요소의 숫자 유형을 설명 하는 연관된 데이터 유형 (또는 &lt;code&gt;dtype&lt;/code&gt; )이 있습니다.</target>
        </trans-unit>
        <trans-unit id="75e9e8993c94f43bad514a2848161f06288eae11" translate="yes" xml:space="preserve">
          <source>A less powerful version of &lt;code&gt;np.multiply.outer&lt;/code&gt; that &lt;a href=&quot;numpy.ravel#numpy.ravel&quot;&gt;&lt;code&gt;ravel&lt;/code&gt;&lt;/a&gt;s all inputs to 1D. This exists primarily for compatibility with old code.</source>
          <target state="translated">의 덜 강력한 버전 &lt;code&gt;np.multiply.outer&lt;/code&gt; 그 &lt;a href=&quot;numpy.ravel#numpy.ravel&quot;&gt; &lt;code&gt;ravel&lt;/code&gt; &lt;/a&gt; 1D 모든 입력을이야. 이것은 주로 이전 코드와의 호환성을 위해 존재합니다.</target>
        </trans-unit>
        <trans-unit id="fed398eb719e55b17943429f3e4fdb68c14251c9" translate="yes" xml:space="preserve">
          <source>A list containing the data-types for the different columns, e.g. &lt;code&gt;['i4', 'f8', 'i4']&lt;/code&gt;. &lt;code&gt;formats&lt;/code&gt; does &lt;em&gt;not&lt;/em&gt; support the new convention of using types directly, i.e. &lt;code&gt;(int, float, int)&lt;/code&gt;. Note that &lt;code&gt;formats&lt;/code&gt; must be a list, not a tuple. Given that &lt;code&gt;formats&lt;/code&gt; is somewhat limited, we recommend specifying &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">다른 열에 대한 데이터 유형을 포함하는 목록입니다 (예 : &lt;code&gt;['i4', 'f8', 'i4']&lt;/code&gt; . &lt;code&gt;formats&lt;/code&gt; 은 형식을 직접 사용하는 새로운 규칙, 즉 &lt;code&gt;(int, float, int)&lt;/code&gt; 지원 하지 &lt;em&gt;않습니다&lt;/em&gt; . 하는 것으로 &lt;code&gt;formats&lt;/code&gt; 목록이 아니라 튜플해야합니다. 점을 감안 &lt;code&gt;formats&lt;/code&gt; 다소 제한됩니다, 우리는 지정 추천 &lt;a href=&quot;numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 대신.</target>
        </trans-unit>
        <trans-unit id="1da31c2d761b650fc657c3090a468a9da54f9de6" translate="yes" xml:space="preserve">
          <source>A list of D arrays describing the bin edges for each dimension.</source>
          <target state="translated">각 차원의 빈 가장자리를 설명하는 D 배열 목록입니다.</target>
        </trans-unit>
        <trans-unit id="4132766bc16ba1628237791ba4f2542341475d5c" translate="yes" xml:space="preserve">
          <source>A list of current Institutional Partners is maintained at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="translated">현재 기관 파트너 목록은 &lt;a href=&quot;people#governance-people&quot;&gt;현재 운영위원회 및 기관 파트너&lt;/a&gt; 페이지에서 관리됩니다 .</target>
        </trans-unit>
        <trans-unit id="642f705f85981daa89bf326a8fb2e60bead01724" translate="yes" xml:space="preserve">
          <source>A list of current Steering Council Members is maintained at the page &lt;a href=&quot;people#governance-people&quot;&gt;Current steering council and institutional partners&lt;/a&gt;.</source>
          <target state="translated">현재 운영위원회 회원 목록은 현재 운영위원회 &lt;a href=&quot;people#governance-people&quot;&gt;및 기관 파트너&lt;/a&gt; 페이지에서 관리됩니다 .</target>
        </trans-unit>
        <trans-unit id="8dccfbefc014a73715a7bf33178f7d4dadc963d9" translate="yes" xml:space="preserve">
          <source>A list of dtypes or dtype convertible objects representing arrays.</source>
          <target state="translated">배열을 나타내는 dtype 또는 dtype 변환 가능 객체의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="ca05b514dd6531df90ebf63f10153d3470704d68" translate="yes" xml:space="preserve">
          <source>A list of dtypes or dtype convertible objects representing scalars.</source>
          <target state="translated">스칼라를 나타내는 dtype 또는 dtype 변환 가능 객체의 목록입니다.</target>
        </trans-unit>
        <trans-unit id="24f20e94cc1577ba19bd51fd88c7c894abd02ccc" translate="yes" xml:space="preserve">
          <source>A list of names to exclude. This list is appended to the default list [&amp;lsquo;return&amp;rsquo;,&amp;rsquo;file&amp;rsquo;,&amp;rsquo;print&amp;rsquo;]. Excluded names are appended an underscore: for example, &lt;code&gt;file&lt;/code&gt; would become &lt;code&gt;file_&lt;/code&gt;.</source>
          <target state="translated">제외 할 이름 목록입니다. 이 목록은 기본 목록 [ 'return', 'file', 'print']에 추가됩니다. 제외 된 이름에는 밑줄이 추가됩니다 (예 : &lt;code&gt;file&lt;/code&gt; 은 &lt;code&gt;file_&lt;/code&gt; 이 됩니다).</target>
        </trans-unit>
        <trans-unit id="0f3d5f54a16228377e53581376ffb48f3c30e87c" translate="yes" xml:space="preserve">
          <source>A list of objects that matched the search is displayed, sorted by relevance. All given keywords need to be found in the docstring for it to be returned as a result, but the order does not matter.</source>
          <target state="translated">검색과 일치하는 개체 목록이 관련성별로 정렬되어 표시됩니다. 주어진 모든 키워드는 결과로 반환 되려면 docstring에서 찾아야하지만 순서는 중요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9f6f052d201d59387579347a7dac2c74e5309ea5" translate="yes" xml:space="preserve">
          <source>A list of slices (start and end indexes) of unmasked indexes in the array.</source>
          <target state="translated">배열에서 마스크되지 않은 인덱스의 슬라이스 (시작 및 끝 인덱스) 목록입니다.</target>
        </trans-unit>
        <trans-unit id="43756e35fd4b630771644c0972fd42f2b4b492e5" translate="yes" xml:space="preserve">
          <source>A list of sub-arrays as views into &lt;code&gt;ary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;ary&lt;/code&gt; 에 대한 뷰로서의 하위 배열 목록입니다 .</target>
        </trans-unit>
        <trans-unit id="cd652a1229439a6ceff8e2b412bf54484522702c" translate="yes" xml:space="preserve">
          <source>A list of sub-arrays.</source>
          <target state="translated">하위 배열 목록.</target>
        </trans-unit>
        <trans-unit id="335672ba95b65b1f5d901e9f2df4feaada975adc" translate="yes" xml:space="preserve">
          <source>A list of tuples providing a more detailed description of the memory layout for each item in the homogeneous array. Each tuple in the list has two or three elements. Normally, this attribute would be used when &lt;em&gt;typestr&lt;/em&gt; is &lt;code&gt;V[0-9]+&lt;/code&gt;, but this is not a requirement. The only requirement is that the number of bytes represented in the &lt;em&gt;typestr&lt;/em&gt; key is the same as the total number of bytes represented here. The idea is to support descriptions of C-like structs that make up array elements. The elements of each tuple in the list are</source>
          <target state="translated">동종 배열의 각 항목에 대한 메모리 레이아웃에 대한 자세한 설명을 제공하는 튜플 목록입니다. 목록의 각 튜플에는 2 ~ 3 개의 요소가 있습니다. 일반적으로 &lt;em&gt;typestr&lt;/em&gt; 이 &lt;code&gt;V[0-9]+&lt;/code&gt; 인 경우이 속성이 사용 되지만 필수는 아닙니다. 유일한 요구 사항은 &lt;em&gt;typestr&lt;/em&gt; 키에 표시된 바이트 수가 여기에 표시된 총 바이트 수와 동일해야한다는 것입니다. 아이디어는 배열 요소를 구성하는 C와 유사한 구조체에 대한 설명을 지원하는 것입니다. 리스트에서 각 튜플의 요소는</target>
        </trans-unit>
        <trans-unit id="90b02866cbd2eb2a4a1f900e5689f4807053a09b" translate="yes" xml:space="preserve">
          <source>A list of tuples with indices of axes a generalized ufunc should operate on. For instance, for a signature of &lt;code&gt;(i,j),(j,k)-&amp;gt;(i,k)&lt;/code&gt; appropriate for matrix multiplication, the base elements are two-dimensional matrices and these are taken to be stored in the two last axes of each argument. The corresponding axes keyword would be &lt;code&gt;[(-2, -1), (-2, -1), (-2, -1)]&lt;/code&gt;. For simplicity, for generalized ufuncs that operate on 1-dimensional arrays (vectors), a single integer is accepted instead of a single-element tuple, and for generalized ufuncs for which all outputs are scalars, the output tuples can be omitted.</source>
          <target state="translated">일반화 된 ufunc가 작동해야하는 축 인덱스가있는 튜플 목록입니다. 예를 들어, 행렬 곱셈에 적합한 &lt;code&gt;(i,j),(j,k)-&amp;gt;(i,k)&lt;/code&gt; 의 서명의 경우 기본 요소는 2 차원 행렬이며 마지막 두 축에 저장됩니다. 각 논쟁의. 해당 좌표축 키워드는 &lt;code&gt;[(-2, -1), (-2, -1), (-2, -1)]&lt;/code&gt; 입니다. 단순화를 위해 1 차원 배열 (벡터)에서 작동하는 일반화 된 ufunc의 경우 단일 요소 튜플 대신 단일 정수가 허용되고 모든 출력이 스칼라 인 일반화 된 ufunc의 경우 출력 튜플을 생략 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7f92ec16607722c37761b414dc6ad215cc481eea" translate="yes" xml:space="preserve">
          <source>A list of tuples, one tuple per field</source>
          <target state="translated">튜플 목록, 필드 당 하나의 튜플</target>
        </trans-unit>
        <trans-unit id="1931f7fd587f1bfa9304b0a2cf9e0e86ad737bc7" translate="yes" xml:space="preserve">
          <source>A list representation of the einsum path.</source>
          <target state="translated">einsum 경로의 목록 표현.</target>
        </trans-unit>
        <trans-unit id="01b8f3fc931ed4758e3c5ae0ca5a041861bb3033" translate="yes" xml:space="preserve">
          <source>A list which will be filled with all matched warnings.</source>
          <target state="translated">일치하는 모든 경고로 채워지는 목록입니다.</target>
        </trans-unit>
        <trans-unit id="589807e2972076a7140185840f86e44874d938aa" translate="yes" xml:space="preserve">
          <source>A loaded die is more likely to land on number 6:</source>
          <target state="translated">로드 된 다이는 6 위에 올 가능성이 높습니다.</target>
        </trans-unit>
        <trans-unit id="189d9b82b9c6a5ad123dc2d81bd98cbcce5feec7" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If not provided or &lt;code&gt;None&lt;/code&gt;, a freshly-allocated array is returned. For consistency with &lt;code&gt;ufunc.__call__&lt;/code&gt;, if given as a keyword, this may be wrapped in a 1-element tuple.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 새로 할당 된 배열이 반환됩니다. &lt;code&gt;ufunc.__call__&lt;/code&gt; 과 일관성을 유지 하기 위해 키워드로 지정하면 1 요소 튜플로 묶을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c907358140afba5315d369006314c62c7759455" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If not provided or None, a freshly-allocated array is returned. For consistency with &lt;code&gt;ufunc.__call__&lt;/code&gt;, if given as a keyword, this may be wrapped in a 1-element tuple.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되지 않거나 None이면 새로 할당 된 배열이 반환됩니다. &lt;code&gt;ufunc.__call__&lt;/code&gt; 과의 일관성을 위해 키워드로 주어지면 1 요소 튜플에 래핑 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="30ff2cf37c49042997e4c4edb219d3f048658fab" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that matches the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;. If not provided or &lt;code&gt;None&lt;/code&gt;, a freshly-allocated array is returned.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되는 경우 서명 &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; 과 일치하는 모양이어야합니다 . 제공되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 새로 할당 된 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="fe944c1e79e9f7e95d0ca50a0ad6059ed9f2387e" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that matches the signature &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt;. If not provided or None, a freshly-allocated array is returned.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되는 경우 &lt;code&gt;(n,k),(k,m)-&amp;gt;(n,m)&lt;/code&gt; 서명과 일치하는 모양이 있어야합니다 . 제공되지 않거나 None이면 새로 할당 된 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="221aee4fd070888287d5d44c89a21ae3247972e1" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that the input broadcasts to. If not provided or None, a freshly-allocated array is returned.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되는 경우 입력이 브로드 캐스트하는 모양이어야합니다. 제공되지 않거나 None이면 새로 할당 된 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="acb0da268f42123cfe5c091ea12c092ac1ddeece" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that the input broadcasts to. If not provided or None, a freshly-allocated boolean array is returned.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되는 경우 입력이 브로드 캐스트하는 모양이어야합니다. 제공되지 않거나 None이면 새로 할당 된 부울 배열이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="74ecfd958d8205d0b812a91718af7b311a9c11fe" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or &lt;code&gt;None&lt;/code&gt;, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되는 경우 입력이 브로드 캐스트되는 모양이어야합니다. 제공되지 않거나 &lt;code&gt;None&lt;/code&gt; 이면 새로 할당 된 배열이 반환됩니다. 튜플 (키워드 인수로만 가능)은 출력 수와 길이가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="8a42008aeb9e98fc1dc9af05e3018e1eceb3bf19" translate="yes" xml:space="preserve">
          <source>A location into which the result is stored. If provided, it must have a shape that the inputs broadcast to. If not provided or None, a freshly-allocated array is returned. A tuple (possible only as a keyword argument) must have length equal to the number of outputs.</source>
          <target state="translated">결과가 저장되는 위치입니다. 제공되는 경우 입력이 브로드 캐스트되는 모양을 가져야합니다. 제공되지 않거나 None이면 새로 할당 된 배열이 반환됩니다. 튜플 (키워드 인수로만 가능)은 출력 수와 같은 길이를 가져야합니다.</target>
        </trans-unit>
        <trans-unit id="b7739f26a858b347978a4cfbfb1e35e7d5512c0c" translate="yes" xml:space="preserve">
          <source>A location where the result is stored</source>
          <target state="translated">결과가 저장되는 위치</target>
        </trans-unit>
        <trans-unit id="c5164a5cf9ad81d1e94ceee11b7f74d4934af37c" translate="yes" xml:space="preserve">
          <source>A loop in the NumPy C source code may have a &lt;code&gt;@TYPE@&lt;/code&gt; variable, targeted for string substitution, which is preprocessed to a number of otherwise identical loops with several strings such as &lt;code&gt;INT&lt;/code&gt;, &lt;code&gt;LONG&lt;/code&gt;, &lt;code&gt;UINT&lt;/code&gt;, &lt;code&gt;ULONG&lt;/code&gt;. The &lt;code&gt;@TYPE@&lt;/code&gt; style syntax thus reduces code duplication and maintenance burden by mimicking languages that have generic type support.</source>
          <target state="translated">NumPy C 소스 코드의 루프에는 문자열 대체를 대상으로 하는 &lt;code&gt;@TYPE@&lt;/code&gt; 변수 가있을 수 있습니다.이 변수는 &lt;code&gt;INT&lt;/code&gt; , &lt;code&gt;LONG&lt;/code&gt; , &lt;code&gt;UINT&lt;/code&gt; , &lt;code&gt;ULONG&lt;/code&gt; 과 같은 여러 문자열이있는 여러 개의 동일한 루프로 전처리됩니다 . 따라서 &lt;code&gt;@TYPE@&lt;/code&gt; 스타일 구문은 일반 유형을 지원하는 언어를 모방하여 코드 중복 및 유지 관리 부담을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="d772df58997e4959ba59b176b19f2790ec826fd9" translate="yes" xml:space="preserve">
          <source>A loose wrapper for a C-structure that contains the information needed for looping. This is useful if you are trying to understand the ufunc looping code. The &lt;a href=&quot;#c.PyUFuncLoopObject&quot;&gt;&lt;code&gt;PyUFuncLoopObject&lt;/code&gt;&lt;/a&gt; is the associated C-structure. It is defined in the &lt;code&gt;ufuncobject.h&lt;/code&gt; header.</source>
          <target state="translated">루핑에 필요한 정보가 포함 된 C 구조의 느슨한 래퍼입니다. 이것은 ufunc 루핑 코드를 이해하려고 할 때 유용합니다. &lt;a href=&quot;#c.PyUFuncLoopObject&quot;&gt; &lt;code&gt;PyUFuncLoopObject&lt;/code&gt; 는&lt;/a&gt; 연결된 C-구조이다. &lt;code&gt;ufuncobject.h&lt;/code&gt; 헤더에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="210bb7c0a2b1abe6f26b2cdaf9e3f00dc43f0623" translate="yes" xml:space="preserve">
          <source>A loose wrapper for the C-structure that contains the information needed for reduce-like methods of ufuncs. This is useful if you are trying to understand the reduce, accumulate, and reduce-at code. The &lt;a href=&quot;#c.PyUFuncReduceObject&quot;&gt;&lt;code&gt;PyUFuncReduceObject&lt;/code&gt;&lt;/a&gt; is the associated C-structure. It is defined in the &lt;code&gt;ufuncobject.h&lt;/code&gt; header.</source>
          <target state="translated">축소 형 ufuncs 방법에 필요한 정보가 포함 된 C 구조용 느슨한 래퍼입니다. 축소, 누적 및 축소 코드를 이해하려는 경우에 유용합니다. &lt;a href=&quot;#c.PyUFuncReduceObject&quot;&gt; &lt;code&gt;PyUFuncReduceObject&lt;/code&gt; 는&lt;/a&gt; 연결된 C-구조이다. &lt;code&gt;ufuncobject.h&lt;/code&gt; 헤더에 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="57d91d135628e6bd81b79d02ca2c8225c467f5cc" translate="yes" xml:space="preserve">
          <source>A lower-level and less safe routine for creating arbitrary views from custom shape and strides.</source>
          <target state="translated">사용자 정의 모양 및 보폭에서 임의의 뷰를 생성하기위한 낮은 수준의 덜 안전한 루틴입니다.</target>
        </trans-unit>
        <trans-unit id="2d1cb19028cca9983f03bd697ebc873a781f7663" translate="yes" xml:space="preserve">
          <source>A macro that expands to platform-dependent code. The &lt;em&gt;ret&lt;/em&gt; variable can be any integer. The &lt;code&gt;UFUNC_FPE_{ERR}&lt;/code&gt; bits are set in &lt;em&gt;ret&lt;/em&gt; according to the status of the corresponding error flags of the floating point processor.</source>
          <target state="translated">플랫폼 종속 코드로 확장되는 매크로입니다. &lt;em&gt;RET의&lt;/em&gt; 변수는 정수가 될 수 있습니다. &lt;code&gt;UFUNC_FPE_{ERR}&lt;/code&gt; 비트가 설정된다 &lt;em&gt;RET&lt;/em&gt; 부동 소수점 프로세서의 대응하는 에러 플래그의 상태에 따라.</target>
        </trans-unit>
        <trans-unit id="f28b1832d8de539ad6ac78e4879f653172b81a74" translate="yes" xml:space="preserve">
          <source>A macro used internally to check for errors and goto fail if found. This macro requires a fail label in the current code block. The &lt;em&gt;loop&lt;/em&gt; variable must have at least members (obj, errormask, and errorobj). If &lt;em&gt;loop&lt;/em&gt; -&amp;gt;obj is nonzero, then &lt;a href=&quot;https://docs.python.org/dev/c-api/exceptions.html#c.PyErr_Occurred&quot;&gt;&lt;code&gt;PyErr_Occurred&lt;/code&gt;&lt;/a&gt; () is called (meaning the GIL must be held). If &lt;em&gt;loop&lt;/em&gt; -&amp;gt;obj is zero, then if &lt;em&gt;loop&lt;/em&gt; -&amp;gt;errormask is nonzero, &lt;a href=&quot;#c.PyUFunc_checkfperr&quot;&gt;&lt;code&gt;PyUFunc_checkfperr&lt;/code&gt;&lt;/a&gt; is called with arguments &lt;em&gt;loop&lt;/em&gt; -&amp;gt;errormask and &lt;em&gt;loop&lt;/em&gt; -&amp;gt;errobj. If the result of this check of the IEEE floating point registers is true then the code redirects to the fail label which must be defined.</source>
          <target state="translated">내부적으로 오류를 확인하고 발견되면 실패하는 매크로입니다. 이 매크로는 현재 코드 블록에 실패 레이블이 필요합니다. &lt;em&gt;루프&lt;/em&gt; 변수는 적어도 멤버에서 (OBJ, errormask 및 errorobj)가 있어야합니다. 경우 &lt;em&gt;루프&lt;/em&gt; -&amp;gt; obj가 다음 제로입니다 &lt;a href=&quot;https://docs.python.org/dev/c-api/exceptions.html#c.PyErr_Occurred&quot;&gt; &lt;code&gt;PyErr_Occurred&lt;/code&gt; &lt;/a&gt; ()를 호출합니다 (GIL 의미를 개최해야 함). 경우 &lt;em&gt;루프&lt;/em&gt; -&amp;gt; obj가 0 인 다음의 경우 &lt;em&gt;루프&lt;/em&gt; -&amp;gt; errormask IS 0이 아닌 &lt;a href=&quot;#c.PyUFunc_checkfperr&quot;&gt; &lt;code&gt;PyUFunc_checkfperr&lt;/code&gt; 이&lt;/a&gt; 인수로 호출 &lt;em&gt;루프&lt;/em&gt; &amp;gt; errormask 및 - &lt;em&gt;루프&lt;/em&gt; -&amp;gt; errobj. IEEE 부동 소수점 레지스터에 대한이 검사 결과가 참이면 코드는 반드시 정의해야하는 실패 레이블로 경로 재 지정됩니다.</target>
        </trans-unit>
        <trans-unit id="259aa1241531c8a953c8758b1ac4f41805af1a59" translate="yes" xml:space="preserve">
          <source>A macro which calls the auxdata&amp;rsquo;s clone function appropriately, returning a deep copy of the auxiliary data.</source>
          <target state="translated">auxdata의 clone 함수를 적절하게 호출하여 보조 데이터의 깊은 사본을 반환하는 매크로입니다.</target>
        </trans-unit>
        <trans-unit id="6a68e2152dcf816535a4914a7278ab4814568b2a" translate="yes" xml:space="preserve">
          <source>A macro which calls the auxdata&amp;rsquo;s free function appropriately, does nothing if auxdata is NULL.</source>
          <target state="translated">auxdata의 free 함수를 적절하게 호출하는 매크로는 auxdata가 NULL 인 경우 아무 작업도 수행하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c85dcfb9c03f01d4f635e537884d50fe2361f8ef" translate="yes" xml:space="preserve">
          <source>A masked array can also be created by taking a .view(MaskedArray).</source>
          <target state="translated">.view (MaskedArray)를 사용하여 마스크 배열을 만들 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ff8a66a27d58e687655398b86d619b56d5081716" translate="yes" xml:space="preserve">
          <source>A masked array is the combination of a standard &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; and a &lt;strong&gt;mask&lt;/strong&gt;. A mask is either &lt;code&gt;nomask&lt;/code&gt;, indicating that no value of the associated array is invalid, or an array of booleans that determines for each element of the associated array whether the value is valid or not. When an element of the mask is &lt;code&gt;False&lt;/code&gt;, the corresponding element of the associated array is valid and is said to be unmasked. When an element of the mask is &lt;code&gt;True&lt;/code&gt;, the corresponding element of the associated array is said to be masked (invalid).</source>
          <target state="translated">마스킹 된 배열은 표준 &lt;a href=&quot;../reference/generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 와 &lt;strong&gt;마스크&lt;/strong&gt; 의 조합입니다 . 마스크는 관련 배열의 값이 유효하지 않음을 나타내는 &lt;code&gt;nomask&lt;/code&gt; 이거나 값이 유효한지 여부를 관련 배열의 각 요소에 대해 결정하는 부울 배열입니다. 마스크의 요소가 &lt;code&gt;False&lt;/code&gt; 이면 연관된 배열의 해당 요소가 유효하며 마스크 해제되었다고합니다. 마스크의 요소가 &lt;code&gt;True&lt;/code&gt; 이면 연관된 배열의 해당 요소가 마스킹 (유효하지 않음)이라고합니다.</target>
        </trans-unit>
        <trans-unit id="f52d1200442f679dc576dc7bcd38aabdb0e058c3" translate="yes" xml:space="preserve">
          <source>A masked array is the combination of a standard &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;numpy.ndarray&lt;/code&gt;&lt;/a&gt; and a mask. A mask is either &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt;, indicating that no value of the associated array is invalid, or an array of booleans that determines for each element of the associated array whether the value is valid or not. When an element of the mask is &lt;code&gt;False&lt;/code&gt;, the corresponding element of the associated array is valid and is said to be unmasked. When an element of the mask is &lt;code&gt;True&lt;/code&gt;, the corresponding element of the associated array is said to be masked (invalid).</source>
          <target state="translated">마스크 배열은 표준 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;numpy.ndarray&lt;/code&gt; &lt;/a&gt; 와 마스크 의 조합입니다 . 마스크는 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 이며 연관된 배열의 값이 유효하지 않음을 나타내거나 연관된 배열의 각 요소에 대해 값이 유효한지 여부를 판별하는 부울 배열입니다. 마스크의 요소가 &lt;code&gt;False&lt;/code&gt; 인 경우 연관된 배열의 해당 요소가 유효하며 마스크 해제 된 것으로 간주됩니다. 마스크의 요소가 &lt;code&gt;True&lt;/code&gt; 인 경우 관련 배열의 해당 요소가 마스킹 된 것으로 간주됩니다 (유효하지 않음).</target>
        </trans-unit>
        <trans-unit id="829b7a94e24ea2654187698ce1c61c946cf592a4" translate="yes" xml:space="preserve">
          <source>A masked array with all data masked.</source>
          <target state="translated">모든 데이터가 마스킹 된 마스킹 된 배열입니다.</target>
        </trans-unit>
        <trans-unit id="4c13e0f2aab6ad6b446bac77982599c22e957fa5" translate="yes" xml:space="preserve">
          <source>A matlab, R, IDL, NumPy/SciPy dictionary</source>
          <target state="translated">MATLAB, R, IDL, NumPy / SciPy 사전</target>
        </trans-unit>
        <trans-unit id="77a446e834e09b8c95fd907735120b99ef29b40b" translate="yes" xml:space="preserve">
          <source>A matrix of floating-point samples drawn from the standard normal distribution.</source>
          <target state="translated">표준 정규 분포에서 가져온 부동 소수점 샘플의 행렬입니다.</target>
        </trans-unit>
        <trans-unit id="cc104aa34da923a98391ba0395e7135b414c1163" translate="yes" xml:space="preserve">
          <source>A matrix with orthonormal columns. When mode = &amp;lsquo;complete&amp;rsquo; the result is an orthogonal/unitary matrix depending on whether or not a is real/complex. The determinant may be either +/- 1 in that case.</source>
          <target state="translated">직교 정렬 열이있는 행렬. mode = 'complete'인 경우 결과는 a가 실수인지 복소수인지에 따라 직교 / 단일 행렬입니다. 이 경우 결정자는 +/- 1 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca7c2fe181b290543210fadcc5053e8b3ec06ee8" translate="yes" xml:space="preserve">
          <source>A minimal &lt;code&gt;init{name}&lt;/code&gt; method looks like:</source>
          <target state="translated">최소 &lt;code&gt;init{name}&lt;/code&gt; 메소드는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b53664ffd0d1b20158d240bc21a792bcacea3d14" translate="yes" xml:space="preserve">
          <source>A minimum number of bins for the output array.</source>
          <target state="translated">출력 배열의 최소 구간 수입니다.</target>
        </trans-unit>
        <trans-unit id="0f7fbf4a6e300b7306d6e3cc9b3d65c15f44b2ab" translate="yes" xml:space="preserve">
          <source>A modified version of the input array, masked depending on the value of the &lt;code&gt;axis&lt;/code&gt; parameter.</source>
          <target state="translated">&lt;code&gt;axis&lt;/code&gt; 매개 변수 의 값에 따라 마스크 된 입력 배열의 수정 된 버전입니다 .</target>
        </trans-unit>
        <trans-unit id="6344acf4bd2d798723a4d93d8470321a3ff92ae1" translate="yes" xml:space="preserve">
          <source>A more complex index transformation example.</source>
          <target state="translated">보다 복잡한 인덱스 변환 예</target>
        </trans-unit>
        <trans-unit id="d0e4296234626cc1940c4e26b6217e094308ce0c" translate="yes" xml:space="preserve">
          <source>A more detailed explanation of strides can be found in the &amp;ldquo;ndarray.rst&amp;rdquo; file in the NumPy reference guide.</source>
          <target state="translated">보폭에 대한 자세한 설명은 NumPy 참조 안내서의 &quot;ndarray.rst&quot;파일에서 찾을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ec890bf6934bced19d9f9b3460a3cafc499210fc" translate="yes" xml:space="preserve">
          <source>A more extensive example of reST markup can be found in &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/demo.txt&quot;&gt;this example document&lt;/a&gt;; the &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;quick reference&lt;/a&gt; is useful while editing.</source>
          <target state="translated">reST 마크 업의보다 광범위한 예제는 &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/demo.txt&quot;&gt;이 예제 문서&lt;/a&gt; 에서 찾을 수 있습니다 . &lt;a href=&quot;http://docutils.sourceforge.net/docs/user/rst/quickref.html&quot;&gt;빠른 참조&lt;/a&gt; 유용한 동안 편집이다.</target>
        </trans-unit>
        <trans-unit id="b987c0a601229775f934a75a0acce45184bf47bd" translate="yes" xml:space="preserve">
          <source>A multi-dimensional array example:</source>
          <target state="translated">다차원 배열 예 :</target>
        </trans-unit>
        <trans-unit id="f88e9f525efb508388784dc73a582e741fab97e4" translate="yes" xml:space="preserve">
          <source>A multi-dimensional example:</source>
          <target state="translated">다차원적인 예 :</target>
        </trans-unit>
        <trans-unit id="5dc89d991a8bf05772b7ec899a7daed6b0a8b80a" translate="yes" xml:space="preserve">
          <source>A multidimensional example:</source>
          <target state="translated">다차원적인 예 :</target>
        </trans-unit>
        <trans-unit id="aabb3055b78cf9d3f1111dd30755f105f909b03c" translate="yes" xml:space="preserve">
          <source>A multiline block starts with &lt;code&gt;'''&lt;/code&gt; (triple single-quotes) and ends with &lt;code&gt;'''&lt;/code&gt; in some &lt;em&gt;strictly&lt;/em&gt; subsequent line. Multiline blocks can be used only within .pyf files. The contents of a multiline block can be arbitrary (except that it cannot contain &lt;code&gt;'''&lt;/code&gt;) and no transformations (e.g. lowering cases) are applied to it.</source>
          <target state="translated">여러 줄 블록은 &lt;code&gt;'''&lt;/code&gt; (세 개의 작은 따옴표)로 시작하고 일부 &lt;em&gt;엄격하게&lt;/em&gt; 다음 줄 에서 &lt;code&gt;'''&lt;/code&gt; 로 끝납니다 . 여러 줄 블록은 .pyf 파일 내에서만 사용할 수 있습니다. 여러 줄 블록의 내용은 임의적 일 수 있으며 ( &lt;code&gt;'''&lt;/code&gt; 포함 할 수없는 경우 제외 ) 변환 (예 : 소문자)이 적용되지 않습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="470114056533b2139223b20d707c44cd4db6a896" translate="yes" xml:space="preserve">
          <source>A named repeat rule is useful when the same set of repeats must be used several times in a block. It is specified using &amp;lt;rule1=item1, item2, item3,&amp;hellip;, itemN&amp;gt;, where N is the number of times the block should be repeated. On each repeat of the block, the entire expression, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; will be replaced first with item1, and then with item2, and so forth until N repeats are accomplished. Once a named repeat specification has been introduced, the same repeat rule may be used &lt;strong&gt;in the current block&lt;/strong&gt; by referring only to the name (i.e. &amp;lt;rule1&amp;gt;).</source>
          <target state="translated">명명 된 반복 규칙은 블록에서 동일한 반복 집합을 여러 번 사용해야 할 때 유용합니다. &amp;lt;rule1 = item1, item2, item3,&amp;hellip;, itemN&amp;gt;을 사용하여 지정합니다. 여기서 N은 블록을 반복해야하는 횟수입니다. 블록이 반복 될 때마다 전체 표현식 '&amp;lt;&amp;hellip;&amp;gt;'가 먼저 항목 1로 바뀐 다음 항목 2로 대체되며 N 개의 반복이 완료 될 때까지 계속됩니다. 명명 된 반복 사양이 도입되면 이름 (예 : &amp;lt;rule1&amp;gt;) 만 참조 &lt;strong&gt;하여 현재 블록에서&lt;/strong&gt; 동일한 반복 규칙을 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fee4550ab9483136891754f4bdfd6191512d9294" translate="yes" xml:space="preserve">
          <source>A named repeat rule is useful when the same set of repeats must be used several times in a block. It is specified using &amp;lt;rule1=item1, item2, item3,&amp;hellip;, itemN&amp;gt;, where N is the number of times the block should be repeated. On each repeat of the block, the entire expression, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; will be replaced first with item1, and then with item2, and so forth until N repeats are accomplished. Once a named repeat specification has been introduced, the same repeat rule may be used &lt;strong&gt;in the current block&lt;/strong&gt; by referring only to the name (i.e. &amp;lt;rule1&amp;gt;.</source>
          <target state="translated">명명 된 반복 규칙은 블록에서 동일한 반복 세트를 여러 번 사용해야하는 경우에 유용합니다. &amp;lt;rule1 = item1, item2, item3,&amp;hellip;, itemN&amp;gt;을 사용하여 지정됩니다. 여기서 N은 블록을 반복해야하는 횟수입니다. 블록의 각 반복에서 전체 표현식 '&amp;lt;&amp;hellip;&amp;gt;'은 먼저 항목 1로, 그런 다음 항목 2로 대체되며 N 반복이 이루어질 때까지 계속됩니다. 명명 된 반복 지정이 도입되면 이름 만 참조 &lt;strong&gt;하여 현재 블록에서&lt;/strong&gt; 동일한 반복 규칙을 사용할 수 있습니다 (예 : &amp;lt;rule1&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="ef17d0fc14dd5a70ff872110bdccad64fcbfd56f" translate="yes" xml:space="preserve">
          <source>A natural approach when dealing with tabular data is to allocate a name to each column. A first possibility is to use an explicit structured dtype, as mentioned previously:</source>
          <target state="translated">테이블 형식 데이터를 처리 할 때 자연스러운 접근 방식은 각 열에 이름을 할당하는 것입니다. 첫 번째 가능성은 앞서 언급했듯이 명시적인 구조화 된 dtype을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="746f3b414823e7887d26584e61a99960d3d3807d" translate="yes" xml:space="preserve">
          <source>A new 1-D array initialized from text data in a string.</source>
          <target state="translated">문자열의 텍스트 데이터에서 초기화 된 새로운 1D 배열.</target>
        </trans-unit>
        <trans-unit id="ae95b32f6f003e94d14d7946d56545e0135f63ce" translate="yes" xml:space="preserve">
          <source>A new &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; holding the non-masked data is returned.</source>
          <target state="translated">마스크되지 않은 데이터를 보유한 새 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="88ecc2ebbb56dcaedff4a2139418dee2fb902a28" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;ndarray&lt;/code&gt; holding the non-masked data is returned.</source>
          <target state="translated">마스크되지 않은 데이터를 보유 하는 새로운 &lt;code&gt;ndarray&lt;/code&gt; 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="3b8c590dfa252c7f3c893ca248877a1023a3d6aa" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;ndpointer.contents&lt;/code&gt; member</source>
          <target state="translated">새로운 &lt;code&gt;ndpointer.contents&lt;/code&gt; 멤버</target>
        </trans-unit>
        <trans-unit id="fe219505f265baf36bb811d03f81478d040b90cc" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned. The result has the same size as &lt;code&gt;a&lt;/code&gt;, and the same shape as &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;axis&lt;/code&gt; is not None or &lt;code&gt;a&lt;/code&gt; is a 1-d array.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 결과를 보유한 새 배열이 반환 되며 ,이 경우 &lt;code&gt;out&lt;/code&gt; 에 대한 참조 가 반환됩니다. 그 결과 같은 크기 갖는다 과 동일한 형상 &lt;code&gt;a&lt;/code&gt; 경우 &lt;code&gt;axis&lt;/code&gt; 아무도없는거나 &lt;code&gt;a&lt;/code&gt; 1 차원 배열이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd535d99a931f0449184609f6016354bec2044d6" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to out is returned.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 결과를 보유한 새 배열이 반환 되며 ,이 경우 out에 대한 참조가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="6f8f859ede56ba26f8769de8c565d9f4c768fea6" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case it is returned.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 결과를 보유한 새 배열이 반환되며이 경우 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8e2320a4eb5e6995b9cc3fe7e2f76f7eeadca85d" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which it is returned. The result has the same size as &lt;code&gt;a&lt;/code&gt;, and the same shape as &lt;code&gt;a&lt;/code&gt; if &lt;code&gt;axis&lt;/code&gt; is not None or &lt;code&gt;a&lt;/code&gt; is a 1-d array.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 결과를 보유한 새 배열 이 반환됩니다. 그 결과 같은 크기 갖는다 과 동일한 형상 &lt;code&gt;a&lt;/code&gt; 경우 &lt;code&gt;axis&lt;/code&gt; 아무도없는거나 &lt;code&gt;a&lt;/code&gt; 1 차원 배열이다. &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="479cc7a91a9d4faa4652b5669146eec3a315bacd" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless out is specified, in which case a reference to out is returned. Return data-type is &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt; for integers and floats smaller than &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt;&lt;code&gt;float64&lt;/code&gt;&lt;/a&gt;, or the input data-type, otherwise.</source>
          <target state="translated">out을 지정하지 않으면 결과가 들어있는 새 배열이 반환됩니다.이 경우 out에 대한 참조가 반환됩니다. 리턴 데이터 타입이다 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt; 정수과보다 작은 수레 &lt;a href=&quot;../arrays.scalars#numpy.float64&quot;&gt; &lt;code&gt;float64&lt;/code&gt; &lt;/a&gt; 달리, 또는 입력 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="d1bd872e7a7340bee975d5292cdea5f0a94c2302" translate="yes" xml:space="preserve">
          <source>A new array holding the result is returned unless out is specified, in which case a reference to out is returned. Return data-type is &lt;code&gt;float64&lt;/code&gt; for integers and floats smaller than &lt;code&gt;float64&lt;/code&gt;, or the input data-type, otherwise.</source>
          <target state="translated">out을 지정하지 않으면 결과를 보유한 새 배열이 반환되며,이 경우 out에 대한 참조가 반환됩니다. 리턴 데이터 타입이다 &lt;code&gt;float64&lt;/code&gt; 정수과보다 작은 수레 &lt;code&gt;float64&lt;/code&gt; 달리, 또는 입력 데이터 유형.</target>
        </trans-unit>
        <trans-unit id="a8f4bbb0d5737e1005ab85a4c1e5ee3d01d76917" translate="yes" xml:space="preserve">
          <source>A new array holding the result, unless &lt;code&gt;out&lt;/code&gt; was specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">않는 한 결과를 유지하는 새로운 배열 &lt;code&gt;out&lt;/code&gt; 참조되는 경우에 규정 된, &lt;code&gt;out&lt;/code&gt; 반환된다.</target>
        </trans-unit>
        <trans-unit id="5f6c1410a3a526a9aa31e8ca9eb607d4c83ef200" translate="yes" xml:space="preserve">
          <source>A new array holding the result. If the input contains integers or floats smaller than &lt;code&gt;float64&lt;/code&gt;, then the output data-type is &lt;code&gt;np.float64&lt;/code&gt;. Otherwise, the data-type of the output is the same as that of the input. If &lt;code&gt;out&lt;/code&gt; is specified, that array is returned instead.</source>
          <target state="translated">결과를 보유하는 새로운 배열. 입력에 정수가 포함되거나 &lt;code&gt;float64&lt;/code&gt; 보다 작은 수레가 있으면 출력 데이터 유형은 &lt;code&gt;np.float64&lt;/code&gt; 입니다. 그렇지 않으면 출력의 데이터 유형이 입력의 데이터 유형과 동일합니다. 경우 &lt;code&gt;out&lt;/code&gt; 지정되어, 해당 배열 대신 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="12dcc14742fa5cf966b623d3902bec2fe90f26ac" translate="yes" xml:space="preserve">
          <source>A new boolean or &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 새로운 부울 또는 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 가 반환 되며 ,이 경우 &lt;code&gt;out&lt;/code&gt; 에 대한 참조 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="8f8e1d77c9cfe7d14f562328f05b8db6b12c1a26" translate="yes" xml:space="preserve">
          <source>A new boolean or array is returned unless &lt;code&gt;out&lt;/code&gt; is specified, in which case a reference to &lt;code&gt;out&lt;/code&gt; is returned.</source>
          <target state="translated">&lt;code&gt;out&lt;/code&gt; 을 지정 하지 않으면 새 부울 또는 배열이 반환 되며 ,이 경우 &lt;code&gt;out&lt;/code&gt; 에 대한 참조 가 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="03cb12e12d7ca89335002a36980c2fad87e769bb" translate="yes" xml:space="preserve">
          <source>A new flexible-type &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</source>
          <target state="translated">두 개의 필드가 있는 새로운 유연한 유형 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; : 값을 포함하는 첫 번째 요소, 해당 마스크 부울을 포함하는 두 번째 요소. 반환 된 레코드 형태는 self.shape와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="99912ae944b2b57418e1b7da69ce28ca8ba58a1d" translate="yes" xml:space="preserve">
          <source>A new flexible-type &lt;code&gt;ndarray&lt;/code&gt; with two fields: the first element containing a value, the second element containing the corresponding mask boolean. The returned record shape matches self.shape.</source>
          <target state="translated">두 개의 필드가 있는 새로운 가변형 &lt;code&gt;ndarray&lt;/code&gt; : 첫 번째 요소에는 값이 포함되고 두 번째 요소에는 해당 마스크 부울이 포함됩니다. 반환 된 레코드 형태는 self.shape와 일치합니다.</target>
        </trans-unit>
        <trans-unit id="cb4010ee58838d1694f9ab9f7b5e871db7356a2d" translate="yes" xml:space="preserve">
          <source>A new polynomial representing the derivative.</source>
          <target state="translated">도함수를 나타내는 새로운 다항식.</target>
        </trans-unit>
        <trans-unit id="45b4e3cf6c3f9c0bf06df2287ee1b7704ec67fba" translate="yes" xml:space="preserve">
          <source>A new series representing the derivative. The domain is the same as the domain of the differentiated series.</source>
          <target state="translated">파생 상품을 나타내는 새로운 시리즈. 도메인은 차별화 된 계열의 도메인과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="bf292f7f138c1a85853bbdea5d47f21f0f2e96a1" translate="yes" xml:space="preserve">
          <source>A new series representing the integral. The domain is the same as the domain of the integrated series.</source>
          <target state="translated">적분을 나타내는 새로운 시리즈. 도메인은 통합 시리즈의 도메인과 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b97518c3847501702c21aaf46fb19e4284c482dc" translate="yes" xml:space="preserve">
          <source>A new view on the array.</source>
          <target state="translated">어레이의 새로운 모습.</target>
        </trans-unit>
        <trans-unit id="06077e00197e6db37d041fa326fce614e70e4417" translate="yes" xml:space="preserve">
          <source>A nicer way to build up index tuples for arrays.</source>
          <target state="translated">배열에 대한 인덱스 튜플을 구축하는 더 좋은 방법.</target>
        </trans-unit>
        <trans-unit id="f7d18c9a5816a4fd32587ba2ff5efc11cb522f13" translate="yes" xml:space="preserve">
          <source>A non-exhaustive list of these operations, which can be computed by &lt;a href=&quot;#numpy.einsum&quot;&gt;&lt;code&gt;einsum&lt;/code&gt;&lt;/a&gt;, is shown below along with examples:</source>
          <target state="translated">&lt;a href=&quot;#numpy.einsum&quot;&gt; &lt;code&gt;einsum&lt;/code&gt; &lt;/a&gt; 으로 계산할 수있는 이러한 작업의 전체 목록이 아래에 예와 함께 표시되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="3f39be7ee390b50c936131bbc0227261bdd37433" translate="yes" xml:space="preserve">
          <source>A normal &lt;code&gt;argsort&lt;/code&gt; would have yielded:</source>
          <target state="translated">정상적인 &lt;code&gt;argsort&lt;/code&gt; 는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="169aa3ac396274c2b6295b469d82a21e30785967" translate="yes" xml:space="preserve">
          <source>A number providing alignment information for this data type. Specifically, it shows how far from the start of a 2-element structure (whose first element is a &lt;code&gt;char&lt;/code&gt; ), the compiler places an item of this type: &lt;code&gt;offsetof(struct {char c; type v;},
v)&lt;/code&gt;</source>
          <target state="translated">이 데이터 유형에 대한 정렬 정보를 제공하는 숫자입니다. 특히, 2 요소 구조의 시작 (먼저 첫 번째 요소는 &lt;code&gt;char&lt;/code&gt; )에서 컴파일러가 다음 유형의 항목을 배치 하는 정도를 보여줍니다 . &lt;code&gt;offsetof(struct {char c; type v;}, v)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8937103f50695ce6653a16bee8c83a4ae6595480" translate="yes" xml:space="preserve">
          <source>A number representing the sign of the determinant. For a real matrix, this is 1, 0, or -1. For a complex matrix, this is a complex number with absolute value 1 (i.e., it is on the unit circle), or else 0.</source>
          <target state="translated">행렬식의 부호를 나타내는 숫자입니다. 실수 행렬의 경우 1, 0 또는 -1입니다. 복소수 행렬의 경우 절대 값이 1 (즉, 단위 원에 있음) 또는 0이있는 복소수입니다.</target>
        </trans-unit>
        <trans-unit id="0040a43542844366dbc2263885b6af73ee030ad0" translate="yes" xml:space="preserve">
          <source>A number that uniquely identifies the data type. For new data-types, this number is assigned when the data-type is registered.</source>
          <target state="translated">데이터 유형을 고유하게 식별하는 숫자입니다. 새로운 데이터 유형의 경우이 번호는 데이터 유형이 등록 될 때 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="e64bafda3fffa3a2f2c0d4bdf32a98e5edcb1985" translate="yes" xml:space="preserve">
          <source>A number, an array of numbers, or an instance of poly1d, at which to evaluate &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;p&lt;/code&gt; 를 평가할 숫자, 숫자 배열 또는 poly1d 인스턴스입니다 .</target>
        </trans-unit>
        <trans-unit id="ed359e325ef3c86354bbb73ec8a423d46aff3b3c" translate="yes" xml:space="preserve">
          <source>A numpy array is homogeneous, and contains elements described by a dtype object. A dtype object can be constructed from different combinations of fundamental numeric types.</source>
          <target state="translated">numpy 배열은 동종이며 dtype 객체로 설명되는 요소를 포함합니다. dtype 객체는 기본 숫자 유형의 다른 조합으로 구성 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="efcfbbb4a0a9c26532564adde93592102c95f15d" translate="yes" xml:space="preserve">
          <source>A one-dimensional masked array.</source>
          <target state="translated">1 차원 마스크 배열.</target>
        </trans-unit>
        <trans-unit id="0fa893bfe0bd95fab46e15f4d3eccd8809a9d3d5" translate="yes" xml:space="preserve">
          <source>A one-dimensional polynomial class.</source>
          <target state="translated">1 차원 다항식 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a15971ac2b7a274cce2c0bced4d09bdc2c62f96a" translate="yes" xml:space="preserve">
          <source>A one-line summary that does not use variable names or the function name, e.g.</source>
          <target state="translated">변수 이름이나 함수 이름을 사용하지 않는 한 줄 요약, 예 :</target>
        </trans-unit>
        <trans-unit id="bb3aa572d8b0200f65354cc93cb34ae9206c0d0a" translate="yes" xml:space="preserve">
          <source>A one-line summary that does not use variable names or the function name.</source>
          <target state="translated">변수 이름이나 함수 이름을 사용하지 않는 한 줄 요약.</target>
        </trans-unit>
        <trans-unit id="b2735c251fe39517e9e54a2f8b41705e1d67bc8a" translate="yes" xml:space="preserve">
          <source>A parenthesized number followed by a comma denotes a tuple with one element. The trailing comma distinguishes a one-element tuple from a parenthesized &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">괄호로 묶인 숫자와 쉼표는 하나의 요소가있는 튜플을 나타냅니다. 후행 쉼표는 단일 요소 튜플과 괄호로 묶인 &lt;code&gt;n&lt;/code&gt; 을 구분합니다 .</target>
        </trans-unit>
        <trans-unit id="6fff8125898e34535342e18def4fd6d7ee1146c9" translate="yes" xml:space="preserve">
          <source>A period for the x-coordinates. This parameter allows the proper interpolation of angular x-coordinates. Parameters &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt; are ignored if &lt;code&gt;period&lt;/code&gt; is specified.</source>
          <target state="translated">x 좌표의 기간입니다. 이 파라미터는 각도 x 좌표의 적절한 보간을 허용합니다. &lt;code&gt;period&lt;/code&gt; 이 지정 되면 &lt;code&gt;left&lt;/code&gt; 과 &lt;code&gt;right&lt;/code&gt; 매개 변수 가 무시됩니다 .</target>
        </trans-unit>
        <trans-unit id="343742afeb5c49344b0f6b087beb0d395d756502" translate="yes" xml:space="preserve">
          <source>A permanent or temporary ban from some or all NumPy spaces (mailing lists, gitter.im, etc.). The group will maintain records of all such bans so that they may be reviewed in the future or otherwise maintained.</source>
          <target state="translated">일부 또는 모든 NumPy 공간 (메일 링리스트, gitter.im 등)에 대한 영구적 또는 일시적 금지. 그룹은 이러한 모든 금지에 대한 기록을 유지하여 향후 검토하거나 기타 방법으로 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b807b86bd0a6c46355a0cf3278bb74297eec4a49" translate="yes" xml:space="preserve">
          <source>A pointer &lt;em&gt;to&lt;/em&gt; the first element of the array.</source>
          <target state="translated">포인터 &lt;em&gt;에&lt;/em&gt; 어레이의 첫 번째 요소.</target>
        </trans-unit>
        <trans-unit id="54bc66c1a086a47763e1dec2c9b34cd3570a6b58" translate="yes" xml:space="preserve">
          <source>A pointer to a data-type descriptor object (see below). The data-type descriptor object is an instance of a new built-in type which allows a generic description of memory. There is a descriptor structure for each data type supported. This descriptor structure contains useful information about the type as well as a pointer to a table of function pointers to implement specific functionality.</source>
          <target state="translated">데이터 형식 설명자 개체에 대한 포인터입니다 (아래 참조). 데이터 형식 설명자 개체는 메모리에 대한 일반적인 설명을 허용하는 새로운 내장 형식의 인스턴스입니다. 지원되는 각 데이터 유형마다 설명자 구조가 있습니다. 이 디스크립터 구조에는 유형에 대한 유용한 정보와 특정 기능을 구현하기위한 함수 포인터 테이블에 대한 포인터가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="cc54b48424db5be195eefdd0e99665072c298078" translate="yes" xml:space="preserve">
          <source>A pointer to a data-type descriptor object (see below). The data-type descriptor object is an instance of a new built-in type which allows a generic description of memory. There is a descriptor structure for each data type supported. This descriptor structure contains useful information about the type as well as a pointer to a table of function pointers to implement specific functionality. As the name suggests, it is associated with the macro &lt;a href=&quot;array#c.PyArray_DESCR&quot;&gt;&lt;code&gt;PyArray_DESCR&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">데이터 유형 설명자 객체에 대한 포인터 (아래 참조). 데이터 유형 설명자 객체는 메모리에 대한 일반적인 설명을 허용하는 새로운 내장 유형의 인스턴스입니다. 지원되는 각 데이터 유형에 대한 설명자 구조가 있습니다. 이 설명자 구조에는 유형에 대한 유용한 정보와 특정 기능을 구현하기위한 함수 포인터 테이블에 대한 포인터가 포함되어 있습니다. 이름에서 알 수 있듯이 &lt;a href=&quot;array#c.PyArray_DESCR&quot;&gt; &lt;code&gt;PyArray_DESCR&lt;/code&gt; &lt;/a&gt; 매크로와 연결됩니다 .</target>
        </trans-unit>
        <trans-unit id="f52546cb0757bfc5efa9ebae8156141a177cf5a7" translate="yes" xml:space="preserve">
          <source>A pointer to a function that compares two elements of the array, &lt;code&gt;arr&lt;/code&gt;, pointed to by &lt;code&gt;d1&lt;/code&gt; and &lt;code&gt;d2&lt;/code&gt;. This function requires behaved (aligned and not swapped) arrays. The return value is 1 if * &lt;code&gt;d1&lt;/code&gt; &amp;gt; * &lt;code&gt;d2&lt;/code&gt;, 0 if * &lt;code&gt;d1&lt;/code&gt; == * &lt;code&gt;d2&lt;/code&gt;, and -1 if * &lt;code&gt;d1&lt;/code&gt; &amp;lt; * &lt;code&gt;d2&lt;/code&gt;. The array object &lt;code&gt;arr&lt;/code&gt; is used to retrieve itemsize and field information for flexible arrays.</source>
          <target state="translated">&lt;code&gt;d1&lt;/code&gt; 과 &lt;code&gt;d2&lt;/code&gt; 가 가리키는 배열의 두 요소 &lt;code&gt;arr&lt;/code&gt; 를 비교하는 함수에 대한 포인터 입니다. 이 기능은 동작 (정렬 및 스왑되지 않은) 어레이를 필요로합니다. 리턴 값은 * &lt;code&gt;d1&lt;/code&gt; &amp;gt; * &lt;code&gt;d2&lt;/code&gt; 인 경우 1, * &lt;code&gt;d1&lt;/code&gt; == * &lt;code&gt;d2&lt;/code&gt; 인 경우 0 , * &lt;code&gt;d1&lt;/code&gt; &amp;lt;* &lt;code&gt;d2&lt;/code&gt; 인 경우 -1 입니다. 배열 객체 &lt;code&gt;arr&lt;/code&gt; 은 유연한 배열에 대한 항목 크기 및 필드 정보를 검색하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="1fc83854e537846a552a3275bf092cf2af85d046" translate="yes" xml:space="preserve">
          <source>A pointer to a function that converts the string pointed to by &lt;code&gt;str&lt;/code&gt; to one element of the corresponding type and places it in the memory location pointed to by &lt;code&gt;ip&lt;/code&gt;. After the conversion is completed, &lt;code&gt;*endptr&lt;/code&gt; points to the rest of the string. The last argument &lt;code&gt;arr&lt;/code&gt; is the array into which ip points (needed for variable-size data- types). Returns 0 on success or -1 on failure. Requires a behaved array. This function should be called without holding the Python GIL, and has to grab it for error reporting.</source>
          <target state="translated">&lt;code&gt;str&lt;/code&gt; 이 가리키는 문자열을 해당 유형의 한 요소 로 변환하고 &lt;code&gt;ip&lt;/code&gt; 가 가리키는 메모리 위치에 배치 하는 함수에 대한 포인터 입니다. 변환이 완료된 후 &lt;code&gt;*endptr&lt;/code&gt; 은 나머지 문자열을 가리 킵니다. 마지막 인수 &lt;code&gt;arr&lt;/code&gt; 은 ip가 가리키는 배열입니다 (가변 크기 데이터 유형에 필요). 성공하면 0을, 실패하면 -1을 반환합니다. 동작 배열이 필요합니다. 이 함수는 Python GIL을 유지하지 않고 호출해야하며 오류보고를 위해 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="fc6cc8bae9ddadc31f5ed95f0732f27d78c14f32" translate="yes" xml:space="preserve">
          <source>A pointer to a function that fills a contiguous &lt;code&gt;buffer&lt;/code&gt; of the given &lt;code&gt;length&lt;/code&gt; with a single scalar &lt;code&gt;value&lt;/code&gt; whose address is given. The final argument is the array which is needed to get the itemsize for variable-length arrays.</source>
          <target state="translated">주어진 &lt;code&gt;length&lt;/code&gt; 의 연속 &lt;code&gt;buffer&lt;/code&gt; 를 주소가 주어진 단일 스칼라 &lt;code&gt;value&lt;/code&gt; 채우는 함수에 대한 포인터 . 마지막 인수는 가변 길이 배열의 항목 크기를 얻는 데 필요한 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3910c8d96e5d20400e40452efc26010ea9229ece" translate="yes" xml:space="preserve">
          <source>A pointer to a function that fills a contiguous array of given length with data. The first two elements of the array must already be filled- in. From these two values, a delta will be computed and the values from item 3 to the end will be computed by repeatedly adding this computed delta. The data buffer must be well-behaved.</source>
          <target state="translated">주어진 길이의 연속 배열을 데이터로 채우는 함수에 대한 포인터. 배열의 처음 두 요소는 이미 채워져 있어야합니다.이 두 값에서 델타가 계산되고이 계산 된 델타를 반복적으로 추가하여 항목 3에서 끝까지의 값이 계산됩니다. 데이터 버퍼가 올바르게 작동해야합니다.</target>
        </trans-unit>
        <trans-unit id="431a234d877bed63a4147682817ee948ed7fbada" translate="yes" xml:space="preserve">
          <source>A pointer to a function that multiplies two &lt;code&gt;n&lt;/code&gt; -length sequences together, adds them, and places the result in element pointed to by &lt;code&gt;op&lt;/code&gt; of &lt;code&gt;arr&lt;/code&gt;. The start of the two sequences are pointed to by &lt;code&gt;ip1&lt;/code&gt; and &lt;code&gt;ip2&lt;/code&gt;. To get to the next element in each sequence requires a jump of &lt;code&gt;is1&lt;/code&gt; and &lt;code&gt;is2&lt;/code&gt;&lt;em&gt;bytes&lt;/em&gt;, respectively. This function requires behaved (though not necessarily contiguous) memory.</source>
          <target state="translated">두 개의 &lt;code&gt;n&lt;/code&gt; - 길이 시퀀스 를 곱하고 더한 다음 &lt;code&gt;arr&lt;/code&gt; 의 &lt;code&gt;op&lt;/code&gt; 로 표시된 요소에 결과를 배치 하는 함수에 대한 포인터 입니다. 두 시퀀스의 시작은 &lt;code&gt;ip1&lt;/code&gt; 및 &lt;code&gt;ip2&lt;/code&gt; 로 가리 킵니다 . 각 시퀀스에서 다음 요소에 도달하려면 각각 &lt;code&gt;is1&lt;/code&gt; 및 &lt;code&gt;is2&lt;/code&gt; &lt;em&gt;bytes&lt;/em&gt; 의 점프가 필요합니다 . 이 기능은 동작이 필요하지만 (연속적인 것은 아니지만) 메모리가 필요합니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="aae344cd692cc12af2d04f598d731b117bcbfbcf" translate="yes" xml:space="preserve">
          <source>A pointer to a function that retrieves the index of the largest of &lt;code&gt;n&lt;/code&gt; elements in &lt;code&gt;arr&lt;/code&gt; beginning at the element pointed to by &lt;code&gt;data&lt;/code&gt;. This function requires that the memory segment be contiguous and behaved. The return value is always 0. The index of the largest element is returned in &lt;code&gt;max_ind&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 가리키는 요소에서 시작하여 &lt;code&gt;arr&lt;/code&gt; 에서 가장 큰 &lt;code&gt;n&lt;/code&gt; 개 요소 의 인덱스를 검색하는 함수에 대한 포인터 입니다. 이 기능을 사용하려면 메모리 세그먼트가 연속적이고 동작해야합니다. 리턴 값은 항상 0입니다. 가장 큰 요소의 인덱스는 &lt;code&gt;max_ind&lt;/code&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="4ceac65337b54f9dcdd551d1e9b47510e515aabf" translate="yes" xml:space="preserve">
          <source>A pointer to a function that retrieves the index of the smallest of &lt;code&gt;n&lt;/code&gt; elements in &lt;code&gt;arr&lt;/code&gt; beginning at the element pointed to by &lt;code&gt;data&lt;/code&gt;. This function requires that the memory segment be contiguous and behaved. The return value is always 0. The index of the smallest element is returned in &lt;code&gt;min_ind&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 가 가리키는 요소에서 시작하여 &lt;code&gt;arr&lt;/code&gt; 에서 가장 작은 &lt;code&gt;n&lt;/code&gt; 개 요소 의 인덱스를 검색하는 함수에 대한 포인터 입니다. 이 기능을 사용하려면 메모리 세그먼트가 연속적이고 동작해야합니다. 리턴 값은 항상 0입니다. 가장 작은 요소의 인덱스는 &lt;code&gt;min_ind&lt;/code&gt; 로 리턴됩니다 .</target>
        </trans-unit>
        <trans-unit id="3835d7b1621720aec7eaa6814ef86b756b4dbf87" translate="yes" xml:space="preserve">
          <source>A pointer to a function that returns TRUE if the item of &lt;code&gt;arr&lt;/code&gt; pointed to by &lt;code&gt;data&lt;/code&gt; is nonzero. This function can deal with misbehaved arrays.</source>
          <target state="translated">&lt;code&gt;data&lt;/code&gt; 가 가리키는 &lt;code&gt;arr&lt;/code&gt; 의 항목 이 0이 아닌 경우 TRUE를 리턴하는 함수에 대한 포인터 . 이 함수는 오작동 배열을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="475aaf0895b62768be3ac2099d9424549dcf7a83" translate="yes" xml:space="preserve">
          <source>A pointer to a function that returns a standard Python object from a single element of the array object &lt;em&gt;arr&lt;/em&gt; pointed to by &lt;em&gt;data&lt;/em&gt;. This function must be able to deal with &amp;ldquo;misbehaved &amp;ldquo;(misaligned and/or swapped) arrays correctly.</source>
          <target state="translated">배열 객체의 단일 요소에서 표준 파이썬 객체를 반환하는 함수에 대한 포인터 &lt;em&gt;편곡이&lt;/em&gt; 가 가리키는 &lt;em&gt;데이터&lt;/em&gt; . 이 기능은 &quot;오작동&quot;(오정렬 및 / 또는 스왑) 어레이를 올바르게 처리 할 수 ​​있어야합니다.</target>
        </trans-unit>
        <trans-unit id="3170ee650911ef94b49078fe0ef12bfaed1cd35b" translate="yes" xml:space="preserve">
          <source>A pointer to a function that scans (scanf style) one element of the corresponding type from the file descriptor &lt;code&gt;fd&lt;/code&gt; into the array memory pointed to by &lt;code&gt;ip&lt;/code&gt;. The array is assumed to be behaved. The last argument &lt;code&gt;arr&lt;/code&gt; is the array to be scanned into. Returns number of receiving arguments successfully assigned (which may be zero in case a matching failure occurred before the first receiving argument was assigned), or EOF if input failure occurs before the first receiving argument was assigned. This function should be called without holding the Python GIL, and has to grab it for error reporting.</source>
          <target state="translated">파일 디스크립터 &lt;code&gt;fd&lt;/code&gt; 에서 &lt;code&gt;ip&lt;/code&gt; 로 지정된 배열 메모리로 해당 유형의 한 요소를 스캔 (scanf 스타일)하는 함수에 대한 포인터 입니다. 배열이 동작한다고 가정합니다. 마지막 인수 &lt;code&gt;arr&lt;/code&gt; 은 스캔 할 배열입니다. 성공적으로 할당 된 수신 인수의 수를 리턴합니다 (첫 번째 수신 인수가 지정되기 전에 일치하는 실패가 발생한 경우 0 일 수 있음). 이 함수는 Python GIL을 유지하지 않고 호출해야하며 오류보고를 위해 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="d5345ed457c10e2b6dd319d2a0f575462b52b35a" translate="yes" xml:space="preserve">
          <source>A pointer to a function that sets the Python object &lt;em&gt;item&lt;/em&gt; into the array, &lt;em&gt;arr&lt;/em&gt;, at the position pointed to by &lt;em&gt;data&lt;/em&gt; . This function deals with &amp;ldquo;misbehaved&amp;rdquo; arrays. If successful, a zero is returned, otherwise, a negative one is returned (and a Python error set).</source>
          <target state="translated">&lt;em&gt;data가&lt;/em&gt; 가리키는 위치에서 Python 객체 &lt;em&gt;항목&lt;/em&gt; 을 배열 &lt;em&gt;arr&lt;/em&gt; 로 설정하는 함수에 대한 포인터 입니다. 이 기능은 &quot;오작동&quot;배열을 처리합니다. 성공하면 0이 리턴되고 그렇지 않으면 음수가 리턴됩니다 (및 Python 오류 세트).&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="07d68822ce5e306e8bf5019318abb9ceb0c735d6" translate="yes" xml:space="preserve">
          <source>A pointer to a list of (&lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt;&lt;code&gt;npy_intp&lt;/code&gt;&lt;/a&gt;) integers which usually represent array shape or array strides.</source>
          <target state="translated">일반적으로 배열 모양 또는 배열 보폭을 나타내는 ( &lt;a href=&quot;c-api.dtype#c.npy_intp&quot;&gt; &lt;code&gt;npy_intp&lt;/code&gt; &lt;/a&gt; ) 정수 목록에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="89b13316dd59646ea59001e9e827165721e7bc03" translate="yes" xml:space="preserve">
          <source>A pointer to a list of (&lt;a href=&quot;dtype#c.npy_intp&quot;&gt;&lt;code&gt;npy_intp&lt;/code&gt;&lt;/a&gt;) integers which usually represent array shape or array strides.</source>
          <target state="translated">일반적으로 배열 모양 또는 배열 스트라이드를 나타내는 ( &lt;a href=&quot;dtype#c.npy_intp&quot;&gt; &lt;code&gt;npy_intp&lt;/code&gt; &lt;/a&gt; ) 정수 목록에 대한 포인터 입니다.</target>
        </trans-unit>
        <trans-unit id="bca11ad9efa9f4f1976179ecad73042ba9578700" translate="yes" xml:space="preserve">
          <source>A pointer to a structure containing functions that the type needs to implement internal features. These functions are not the same thing as the universal functions (ufuncs) described later. Their signatures can vary arbitrarily.</source>
          <target state="translated">유형이 내부 기능을 구현하는 데 필요한 함수를 포함하는 구조에 대한 포인터입니다. 이러한 기능은 나중에 설명하는 범용 기능 (ufunc)과 동일하지 않습니다. 그들의 서명은 임의로 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="59953b5554f06beb9b2ea5a5bf0b78689b8252f0" translate="yes" xml:space="preserve">
          <source>A pointer to newly created memory of size &lt;em&gt;arr&lt;/em&gt; -&amp;gt;itemsize that holds the representation of 0 for that type. The returned pointer, &lt;em&gt;ret&lt;/em&gt;, &lt;strong&gt;must be freed&lt;/strong&gt; using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; (ret) when it is not needed anymore.</source>
          <target state="translated">크기의 새로 생성 된 메모리에 대한 포인터 &lt;em&gt;도착은&lt;/em&gt; -&amp;gt; itemsize는 해당 유형 0의 표현을 보유하고있다. 반환 된 포인터, &lt;em&gt;RET는&lt;/em&gt; , &lt;strong&gt;해방되어야&lt;/strong&gt; 사용 &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt; &lt;code&gt;PyDataMem_FREE&lt;/code&gt; &lt;/a&gt; 가 더 이상 필요하지 않습니다 (RET)을.</target>
        </trans-unit>
        <trans-unit id="88743a5469baac06308bedb60aa16a9c06a7a1cc" translate="yes" xml:space="preserve">
          <source>A pointer to newly created memory of size &lt;em&gt;arr&lt;/em&gt; -&amp;gt;itemsize that holds the representation of 1 for that type. The returned pointer, &lt;em&gt;ret&lt;/em&gt;, &lt;strong&gt;must be freed&lt;/strong&gt; using &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt;&lt;code&gt;PyDataMem_FREE&lt;/code&gt;&lt;/a&gt; (ret) when it is not needed anymore.</source>
          <target state="translated">크기의 새로 생성 된 메모리에 대한 포인터 &lt;em&gt;도착은&lt;/em&gt; -&amp;gt; itemsize는 그 유형 (1)의 표현을 보유하고있다. 반환 된 포인터, &lt;em&gt;RET는&lt;/em&gt; , &lt;strong&gt;해방되어야&lt;/strong&gt; 사용 &lt;a href=&quot;#c.PyDataMem_FREE&quot;&gt; &lt;code&gt;PyDataMem_FREE&lt;/code&gt; &lt;/a&gt; 가 더 이상 필요하지 않습니다 (RET)을.</target>
        </trans-unit>
        <trans-unit id="952d0c514c338d21716f5fd4d68c9399cc12f085" translate="yes" xml:space="preserve">
          <source>A pointer to the current element of the array.</source>
          <target state="translated">배열의 현재 요소에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="aee26ff84fca6762d89892232d01d8f2be0bdf6b" translate="yes" xml:space="preserve">
          <source>A pointer to the first element of the array. This pointer can (and normally should) be recast to the data type of the array.</source>
          <target state="translated">배열의 첫 번째 요소에 대한 포인터 이 포인터는 일반적으로 배열의 데이터 유형으로 다시 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56a9a21805ab17dfeac09889fcec479dcf32412f" translate="yes" xml:space="preserve">
          <source>A pointer to the memory area of the array as a Python integer. This memory area may contain data that is not aligned, or not in correct byte-order. The memory area may not even be writeable. The array flags and data-type of this array should be respected when passing this attribute to arbitrary C-code to avoid trouble that can include Python crashing. User Beware! The value of this attribute is exactly the same as &lt;code&gt;self._array_interface_['data'][0]&lt;/code&gt;.</source>
          <target state="translated">파이썬 정수로 배열의 메모리 영역에 대한 포인터. 이 메모리 영역에는 정렬되지 않았거나 올바른 바이트 순서가 아닌 데이터가 포함되어있을 수 있습니다. 메모리 영역은 쓰기가 불가능할 수도 있습니다. 파이썬 충돌을 포함 할 수있는 문제를 피하기 위해이 속성을 임의의 C 코드로 전달할 때이 배열의 배열 플래그 및 데이터 유형을 고려해야합니다. 사용자 조심! 이 속성의 값은 &lt;code&gt;self._array_interface_['data'][0]&lt;/code&gt; 과 정확히 동일 합니다.</target>
        </trans-unit>
        <trans-unit id="22a0ddabcc83c93156f54a9c4e5e12e5440e1811" translate="yes" xml:space="preserve">
          <source>A pointer to the number of bytes to jump to get to the next element in this dimension for each of the input and output arguments.</source>
          <target state="translated">각 입력 및 출력 인수에 대해이 차원의 다음 요소로 이동하기 위해 이동할 바이트 수에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="38e72ad73c814139adc82a2dd23d234600ecd52c" translate="yes" xml:space="preserve">
          <source>A pointer to the size of the dimension over which this function is looping.</source>
          <target state="translated">이 함수가 반복되는 차원의 크기에 대한 포인터.</target>
        </trans-unit>
        <trans-unit id="b32e8bc9cebeb7ce19737bb101702a66d6ad1687" translate="yes" xml:space="preserve">
          <source>A pointer to the start of the single-segment chunk of memory.</source>
          <target state="translated">단일 세그먼트 메모리 청크의 시작을 가리키는 포인터.</target>
        </trans-unit>
        <trans-unit id="6f57ac5d68543b1b89ec36367f4ed4ba98cb9a0b" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying ndarray this iterator was created to represent.</source>
          <target state="translated">이 반복자가 나타내는 기본 ndarray에 대한 포인터입니다.</target>
        </trans-unit>
        <trans-unit id="a905832ada81de251c9fef160b03726a6aa39266" translate="yes" xml:space="preserve">
          <source>A polynomial class.</source>
          <target state="translated">다항식 클래스</target>
        </trans-unit>
        <trans-unit id="92c43ef422facf81c4d4c9adbfb7fdd14c6bdac1" translate="yes" xml:space="preserve">
          <source>A possible advantage this code has over the Fortran-equivalent code is that it takes arbitrarily strided (i.e. non-contiguous arrays) and may also run faster depending on the optimization capability of your compiler. But, it is an obviously more complicated than the simple code in &lt;code&gt;filter.f&lt;/code&gt;. This code must be compiled into a shared library. On my Linux system this is accomplished using:</source>
          <target state="translated">이 코드가 Fortran과 동등한 코드에 비해 가능한 이점은 임의로 strided (즉, 연속적이지 않은 배열)를 취하고 컴파일러의 최적화 기능에 따라 더 빠르게 실행될 수 있다는 것입니다. 그러나 &lt;code&gt;filter.f&lt;/code&gt; 의 간단한 코드보다 분명히 더 복잡합니다 . 이 코드는 공유 라이브러리로 컴파일되어야합니다. 내 Linux 시스템에서는 다음을 사용하여 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="0454333d741ede4c1731a6f584bd036397a70818" translate="yes" xml:space="preserve">
          <source>A possible use of &lt;code&gt;bincount&lt;/code&gt; is to perform sums over variable-size chunks of an array, using the &lt;code&gt;weights&lt;/code&gt; keyword.</source>
          <target state="translated">&lt;code&gt;bincount&lt;/code&gt; 의 가능한 사용은 &lt;code&gt;weights&lt;/code&gt; 키워드를 사용하여 배열의 가변 크기 청크에 대한 합계를 수행하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="1c8ebcd0235f5f5086307d84956c8e7e4f912a54" translate="yes" xml:space="preserve">
          <source>A potential drawback is that writing to a view can alter the original as well. If this is a problem, NumPy instead needs to create a physically distinct array &amp;ndash; a &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#module-copy&quot;&gt;&lt;code&gt;copy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">잠재적 인 단점은 뷰에 쓰기가 원본도 변경할 수 있다는 것입니다. 이것이 문제라면 NumPy는 대신 물리적으로 구별되는 어레이 인 &lt;a href=&quot;https://docs.python.org/dev/library/copy.html#module-copy&quot;&gt; &lt;code&gt;copy&lt;/code&gt; &lt;/a&gt; 을 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bba8e35dba23bc8041a6e079b6a83f9598e8027c" translate="yes" xml:space="preserve">
          <source>A power series class.</source>
          <target state="translated">파워 시리즈 클래스.</target>
        </trans-unit>
        <trans-unit id="360614eff4e9b482c7ccb1687741451d3292c036" translate="yes" xml:space="preserve">
          <source>A printable representation of the einsum path.</source>
          <target state="translated">einsum 경로의 인쇄 가능한 표현.</target>
        </trans-unit>
        <trans-unit id="cccb2558c6121a3893278b1dfc962b0f04f189f8" translate="yes" xml:space="preserve">
          <source>A private reprimand from the committee to the individual(s) involved. In this case, the group chair will deliver that reprimand to the individual(s) over email, cc&amp;rsquo;ing the group.</source>
          <target state="translated">위원회에서 관련된 개인에 대한 사적인 견책. 이 경우 그룹 의장은 그룹을 참조하여 이메일을 통해 개인에게 그 질책을 전달합니다.</target>
        </trans-unit>
        <trans-unit id="03fcbd555d6873db7a97ecb9b9ef66697ff41f07" translate="yes" xml:space="preserve">
          <source>A property of an object that can be accessed using &lt;code&gt;obj.attribute&lt;/code&gt;, e.g., &lt;code&gt;shape&lt;/code&gt; is an attribute of an array:</source>
          <target state="translated">&lt;code&gt;obj.attribute&lt;/code&gt; 를 사용하여 액세스 할 수있는 객체의 속성입니다. 예를 들어 &lt;code&gt;shape&lt;/code&gt; 는 배열의 속성입니다.</target>
        </trans-unit>
        <trans-unit id="053ed178639c9196d33818dd2666646aba596e58" translate="yes" xml:space="preserve">
          <source>A public reprimand. In this case, the committee chair will deliver that reprimand in the same venue that the violation occurred, within the limits of practicality. E.g., the original mailing list for an email violation, but for a chat room discussion where the person/context may be gone, they can be reached by other means. The group may choose to publish this message elsewhere for documentation purposes.</source>
          <target state="translated">공공 질책. 이 경우위원회 위원장은 위반이 발생한 동일한 장소에서 실용성의 범위 내에서 해당 견책을 전달합니다. 예를 들어 이메일 위반에 대한 원래 메일 링 목록이지만 사람 / 문맥이 사라질 수있는 채팅방 토론의 경우 다른 방법으로 도달 할 수 있습니다. 그룹은 문서화 목적으로이 메시지를 다른 곳에 게시하도록 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f1ffb246c9560ea1d618d450ea896e76b209e6bc" translate="yes" xml:space="preserve">
          <source>A python function or method.</source>
          <target state="translated">파이썬 함수 또는 메소드.</target>
        </trans-unit>
        <trans-unit id="821cd21cf38135598cfbfe30d5b97393e8433ef0" translate="yes" xml:space="preserve">
          <source>A rank 1 array already padded with zeros. Padded values are vector[:iaxis_pad_width[0]] and vector[-iaxis_pad_width[1]:].</source>
          <target state="translated">순위 1 배열은 이미 0으로 채워져 있습니다. 채워진 값은 vector [: iaxis_pad_width [0]] 및 vector [-iaxis_pad_width [1] :]입니다.</target>
        </trans-unit>
        <trans-unit id="f52cd7b1f61334c54c920333fad88ab94ddc81b5" translate="yes" xml:space="preserve">
          <source>A readonly view on the original array with the given shape. It is typically not contiguous. Furthermore, more than one element of a broadcasted array may refer to a single memory location.</source>
          <target state="translated">지정된 모양을 가진 원래 배열의 읽기 전용보기입니다. 일반적으로 인접하지 않습니다. 또한, 방송 된 어레이의 하나 이상의 요소는 단일 메모리 위치를 지칭 할 수있다.</target>
        </trans-unit>
        <trans-unit id="b389c5737b120f8a3ba90ec279ff102ef606b7d1" translate="yes" xml:space="preserve">
          <source>A real or complex array with &lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;a.ndim &amp;gt;= 2&lt;/code&gt; 실수 또는 복잡한 배열입니다 .</target>
        </trans-unit>
        <trans-unit id="fd53e5dc7f86931b1547c68a8b6d4fe1dd602c8c" translate="yes" xml:space="preserve">
          <source>A real world example. A company drills 9 wild-cat oil exploration wells, each with an estimated probability of success of 0.1. All nine wells fail. What is the probability of that happening?</source>
          <target state="translated">실제 예입니다. 회사는 9 개의 야생 고양이 석유 탐사정을 시추하며, 각각 0.1의 성공 확률이 추정됩니다. 9 개의 우물이 모두 고장납니다. 그 일이 일어날 확률은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="5947a5967a2d439c4597c86e8bee99e04c20ca77" translate="yes" xml:space="preserve">
          <source>A real world example. A company drills wild-cat oil exploration wells, each with an estimated probability of success of 0.1. What is the probability of having one success for each successive well, that is what is the probability of a single success after drilling 5 wells, after 6 wells, etc.?</source>
          <target state="translated">실제 예입니다. 회사는 야생 고양이 석유 탐사 우물을 시추하며, 각각 성공 확률은 0.1입니다. 각각의 연속적인 우물에 대해 하나의 성공 확률은 얼마입니까? 즉, 5 개의 우물을 시추 한 후, 6 개의 우물 등에서 단일 성공 확률은 얼마입니까?</target>
        </trans-unit>
        <trans-unit id="e6c74562d8979b3390f8b232c8d1dfde0b8a3f6d" translate="yes" xml:space="preserve">
          <source>A recent addition to &lt;code&gt;numpy.i&lt;/code&gt; are typemaps that permit argout arrays with views into memory that is managed. See the discussion &lt;a href=&quot;http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;numpy.i&lt;/code&gt; 에 최근 추가 된 것은 관리되는 메모리에 대한 뷰가있는 argout 배열을 허용하는 유형 맵입니다. &lt;a href=&quot;http://blog.enthought.com/python/numpy-arrays-with-pre-allocated-memory&quot;&gt;여기서&lt;/a&gt; 토론을 참조 하십시오 .</target>
        </trans-unit>
        <trans-unit id="4897b0fc8fc9aa68f4bd4b56c858ff427fb775fb" translate="yes" xml:space="preserve">
          <source>A record array representation of a structured array can be obtained using the appropriate &lt;a href=&quot;https://numpy.org/doc/1.19/user/numpy-ndarray-view&quot;&gt;view&lt;/a&gt;:</source>
          <target state="translated">구조화 된 배열의 레코드 배열 표현은 적절한 &lt;a href=&quot;https://numpy.org/doc/1.19/user/numpy-ndarray-view&quot;&gt;보기&lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fd871b1d5bdca8cb8b7d062142df3443751547bf" translate="yes" xml:space="preserve">
          <source>A record array representation of a structured array can be obtained using the appropriate &lt;a href=&quot;https://numpy.org/doc/1.20/user/numpy-ndarray-view&quot;&gt;view&lt;/a&gt;:</source>
          <target state="translated">구조화 된 배열의 레코드 배열 표현은 적절한 &lt;a href=&quot;https://numpy.org/doc/1.20/user/numpy-ndarray-view&quot;&gt;보기&lt;/a&gt; 를 사용하여 얻을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fe89375cc42c612714476798303a241ab8be3adb" translate="yes" xml:space="preserve">
          <source>A reduce-like operation on an array with a data-type that has a range &amp;ldquo;too small&amp;rdquo; to handle the result will silently wrap. One should use &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt;&lt;code&gt;dtype&lt;/code&gt;&lt;/a&gt; to increase the size of the data-type over which reduction takes place.</source>
          <target state="translated">결과를 처리하기에 &quot;너무 작은&quot;범위의 데이터 유형을 가진 어레이에서 축소와 유사한 연산은 자동으로 줄 바꿈됩니다. 축소가 발생하는 데이터 유형의 크기를 늘리려면 &lt;a href=&quot;generated/numpy.dtype#numpy.dtype&quot;&gt; &lt;code&gt;dtype&lt;/code&gt; &lt;/a&gt; 을 사용해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e6a7a274041ceccc88ee2a54369682b28d0f8f72" translate="yes" xml:space="preserve">
          <source>A reference to the array that is iterated over.</source>
          <target state="translated">반복되는 배열에 대한 참조입니다.</target>
        </trans-unit>
        <trans-unit id="d51f4a8ae48577ce85df8a7b72d4533baffe3b14" translate="yes" xml:space="preserve">
          <source>A release announcement with a link to the download site should be placed in the sidebar of the front page of scipy.org.</source>
          <target state="translated">다운로드 사이트에 대한 링크가 포함 된 릴리스 공지는 scipy.org의 첫 페이지 사이드 바에 배치해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f747bfcaf0bf3a6676b7d54fffce39c144d966d" translate="yes" xml:space="preserve">
          <source>A request for a public or private apology, assuming the reporter agrees to this idea: they may at their discretion refuse further contact with the violator. The chair will deliver this request. The committee may, if it chooses, attach &amp;ldquo;strings&amp;rdquo; to this request: for example, the group may ask a violator to apologize in order to retain one&amp;rsquo;s membership on a mailing list.</source>
          <target state="translated">기자가이 아이디어에 동의한다고 가정하고 공개 또는 사적인 사과 요청 : 재량에 따라 위반자와의 추가 접촉을 거부 할 수 있습니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 의장은이 요청을 전달할 것입니다. 위원회는 원할 경우이 요청에 &quot;문자열&quot;을 첨부 할 수 있습니다. 예를 들어 그룹은 메일 링리스트에 회원 자격을 유지하기 위해 위반자에게 사과를 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="52c25cce5015e79149d448b806d435904b953adc" translate="yes" xml:space="preserve">
          <source>A return of True does not necessarily mean that the two arrays share any element. It just means that they &lt;em&gt;might&lt;/em&gt;.</source>
          <target state="translated">True를 반환한다고해서 반드시 두 배열이 요소를 공유한다는 의미는 아닙니다. 그것은 단지 그들이 &lt;em&gt;할 수&lt;/em&gt; 있음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="17df53d6df96ba2281763f3f5b0b2adebfd2975d" translate="yes" xml:space="preserve">
          <source>A rotated view of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;m&lt;/code&gt; 의 회전 뷰 .</target>
        </trans-unit>
        <trans-unit id="c8f4d96b9511ee618313df6057280df3dcf54f39" translate="yes" xml:space="preserve">
          <source>A scalar assigned to a structured element will be assigned to all fields. This happens when a scalar is assigned to a structured array, or when an unstructured array is assigned to a structured array:</source>
          <target state="translated">구조화 된 요소에 할당 된 스칼라는 모든 필드에 할당됩니다. 이는 스칼라가 구조화 배열에 할당되거나 구조화되지 않은 배열이 구조화 배열에 할당 될 때 발생합니다.</target>
        </trans-unit>
        <trans-unit id="22190750f3f50985b63589eae0fdf601ec030ee6" translate="yes" xml:space="preserve">
          <source>A second possibility is to modify the &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt;&lt;code&gt;mask&lt;/code&gt;&lt;/a&gt; directly, but this usage is discouraged.</source>
          <target state="translated">두 번째 가능성은 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray.mask&quot;&gt; &lt;code&gt;mask&lt;/code&gt; &lt;/a&gt; 직접 수정하는 것이지만이 사용은 권장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1503f40b41df4c31b9ad3f11d30b5aa1e01767eb" translate="yes" xml:space="preserve">
          <source>A second possibility is to use the two masked array constructors, &lt;a href=&quot;generated/numpy.ma.array#numpy.ma.array&quot;&gt;&lt;code&gt;array&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;generated/numpy.ma.masked_array#numpy.ma.masked_array&quot;&gt;&lt;code&gt;masked_array&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">두 번째 가능성은 두 개의 마스크 배열 생성자 인 &lt;a href=&quot;generated/numpy.ma.array#numpy.ma.array&quot;&gt; &lt;code&gt;array&lt;/code&gt; &lt;/a&gt; 와 &lt;a href=&quot;generated/numpy.ma.masked_array#numpy.ma.masked_array&quot;&gt; &lt;code&gt;masked_array&lt;/code&gt; &lt;/a&gt; 를 사용하는 것 입니다.</target>
        </trans-unit>
        <trans-unit id="539c64bc5dca6b25103342f9b6ceae531cd655bf" translate="yes" xml:space="preserve">
          <source>A section (use if applicable) to warn users that the object is deprecated. Section contents should include:</source>
          <target state="translated">개체가 더 이상 사용되지 않음을 사용자에게 경고하는 섹션 (해당하는 경우 사용). 섹션 내용은 다음을 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="2a12806d879a1f49595c81b483ba154ce122b36b" translate="yes" xml:space="preserve">
          <source>A seed sequence for BitGenerators with no need for seed state.</source>
          <target state="translated">시드 상태가 필요없는 BitGenerator의 시드 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="2970246a918f7637894e89bb5c0daa65c3e11d9e" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;a href=&quot;#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to ~`numpy.random.SeedSequence` to derive the initial &lt;a href=&quot;#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; state. One may also pass in a &lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 를 초기화하는 시드 입니다. None이면 신선하고 예측할 수없는 엔트로피를 OS에서 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 전달하고이를 초기 유도하도록 ~`numpy.random.SeedSequence` 전달 될 &lt;a href=&quot;#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 의&lt;/a&gt; 상태. &lt;a href=&quot;numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 인스턴스를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c226a62e6ab2149724331fa10d2fa8de3a8461e2" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;a href=&quot;#numpy.random.bit_generator.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;code&gt;SeedSequence&lt;/code&gt; to derive the initial &lt;a href=&quot;#numpy.random.bit_generator.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; state. One may also pass in an implementor of the &lt;a href=&quot;numpy.random.bit_generator.iseedsequence#numpy.random.bit_generator.ISeedSequence&quot;&gt;&lt;code&gt;ISeedSequence&lt;/code&gt;&lt;/a&gt; interface like &lt;code&gt;SeedSequence&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;#numpy.random.bit_generator.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 를 초기화하기위한 시드 입니다. None이면 OS에서 예측할 수없는 새로운 엔트로피를 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 통과 한 후는 전달 될 &lt;code&gt;SeedSequence&lt;/code&gt; 초기 유도하도록 &lt;a href=&quot;#numpy.random.bit_generator.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 의&lt;/a&gt; 상태. &lt;a href=&quot;numpy.random.bit_generator.iseedsequence#numpy.random.bit_generator.ISeedSequence&quot;&gt; &lt;code&gt;ISeedSequence&lt;/code&gt; &lt;/a&gt; 와 같은 &lt;code&gt;SeedSequence&lt;/code&gt; 인터페이스 의 구현 자를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="11c802a20aa3d53087923c8bd089782db041e6e1" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to derive the initial &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; state. One may also pass in a &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; instance. Additionally, when passed a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;, it will be wrapped by &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. If passed a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, it will be returned unaltered.</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 를 초기화하는 시드 입니다. None이면 신선하고 예측할 수없는 엔트로피를 OS에서 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 통과 한 후는 전달 될 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 초기 유도하도록 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 의&lt;/a&gt; 상태. &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 인스턴스를 전달할 수도 있습니다 . 또한 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 를&lt;/a&gt; 전달하면 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 로 래핑됩니다 . &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 전달하면 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="0cc0496b1cd126456483b858da3b7c3138679ee2" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to derive the initial &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; state. One may also pass in a`SeedSequence` instance Additionally, when passed a &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;, it will be wrapped by &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. If passed a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, it will be returned unaltered.</source>
          <target state="translated">&lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 를 초기화하는 시드 입니다. None이면 신선하고 예측할 수없는 엔트로피를 OS에서 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 통과 한 후는 전달 될 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 초기 유도하도록 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 의&lt;/a&gt; 상태. 하나는 전달 된 경우, 또한 a`SeedSequence` 인스턴스에 통과 할 수 &lt;a href=&quot;bit_generators/generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 를&lt;/a&gt; , 그것은 래핑됩니다 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; . &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 전달하면 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="74fe8c2848b75659999487492c4dd90e9d32d176" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;a href=&quot;generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to derive the initial &lt;a href=&quot;generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt;&lt;code&gt;BitGenerator&lt;/code&gt;&lt;/a&gt; state. One may also pass in a &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; instance.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; &lt;/a&gt; 를 초기화하는 시드 입니다. None이면 신선하고 예측할 수없는 엔트로피를 OS에서 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 통과 한 후는 전달 될 &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 초기 유도하도록 &lt;a href=&quot;generated/numpy.random.bitgenerator#numpy.random.BitGenerator&quot;&gt; &lt;code&gt;BitGenerator&lt;/code&gt; 의&lt;/a&gt; 상태. &lt;a href=&quot;generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 인스턴스를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1c822346cadbdc847b8cededc6c64abb2064a522" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;code&gt;BitGenerator&lt;/code&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to derive the initial &lt;code&gt;BitGenerator&lt;/code&gt; state. One may also pass in an implementor of the &lt;code&gt;ISeedSequence&lt;/code&gt; interface like &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt;. Additionally, when passed a &lt;code&gt;BitGenerator&lt;/code&gt;, it will be wrapped by &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;. If passed a &lt;a href=&quot;#numpy.random.Generator&quot;&gt;&lt;code&gt;Generator&lt;/code&gt;&lt;/a&gt;, it will be returned unaltered.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; 를 초기화하기위한 시드 입니다. None이면 OS에서 새롭고 예측할 수없는 엔트로피를 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 통과 한 후는 전달 될 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 초기 유도하도록 &lt;code&gt;BitGenerator&lt;/code&gt; 의 상태. &lt;code&gt;ISeedSequence&lt;/code&gt; 와 같은 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 인터페이스 의 구현 자를 전달할 수도 있습니다 . 또한 &lt;code&gt;BitGenerator&lt;/code&gt; 를 전달하면 &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; &lt;/a&gt; 로 래핑됩니다 . &lt;a href=&quot;#numpy.random.Generator&quot;&gt; &lt;code&gt;Generator&lt;/code&gt; 를&lt;/a&gt; 전달하면 변경되지 않은 상태로 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="297424ddec64c8c13c80221c2b5c2561d8b3dca1" translate="yes" xml:space="preserve">
          <source>A seed to initialize the &lt;code&gt;BitGenerator&lt;/code&gt;. If None, then fresh, unpredictable entropy will be pulled from the OS. If an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;array_like[ints]&lt;/code&gt; is passed, then it will be passed to &lt;code&gt;SeedSequence&lt;/code&gt; to derive the initial &lt;code&gt;BitGenerator&lt;/code&gt; state. One may also pass in an implementor of the &lt;code&gt;ISeedSequence&lt;/code&gt; interface like &lt;code&gt;SeedSequence&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;BitGenerator&lt;/code&gt; 를 초기화하기위한 시드 입니다. None이면 OS에서 예측할 수없는 새로운 엔트로피를 가져옵니다. 는 IF &lt;code&gt;int&lt;/code&gt; 또는 &lt;code&gt;array_like[ints]&lt;/code&gt; 통과 한 후는 전달 될 &lt;code&gt;SeedSequence&lt;/code&gt; 초기 유도하도록 &lt;code&gt;BitGenerator&lt;/code&gt; 의 상태. &lt;code&gt;ISeedSequence&lt;/code&gt; 와 같은 &lt;code&gt;SeedSequence&lt;/code&gt; 인터페이스 의 구현 자를 전달할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="57449a616b2733913d6c035b16ff8031a0c0309b" translate="yes" xml:space="preserve">
          <source>A segment of memory is inherently 1-dimensional, and there are many different schemes for arranging the items of an &lt;em&gt;N&lt;/em&gt;-dimensional array in a 1-dimensional block. NumPy is flexible, and &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; objects can accommodate any &lt;em&gt;strided indexing scheme&lt;/em&gt;. In a strided scheme, the N-dimensional index</source>
          <target state="translated">메모리의 세그먼트는 본질적으로 1 차원이며, 1 차원 블록에 &lt;em&gt;N&lt;/em&gt; 차원 배열 의 항목들을 배열하기위한 많은 다른 방식들이있다 . NumPy는 융통성이 있으며 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체는 모든 &lt;em&gt;스트라이드 인덱싱 체계를&lt;/em&gt; 수용 할 수 있습니다 . Strided 방식에서 N 차원 인덱스</target>
        </trans-unit>
        <trans-unit id="88b71b624e002466d8dce52c6acba138c61b95ef" translate="yes" xml:space="preserve">
          <source>A sequence of arrays describing the monotonically increasing bin edges along each dimension.</source>
          <target state="translated">각 차원을 따라 단조 증가하는 빈 가장자리를 설명하는 일련의 배열.</target>
        </trans-unit>
        <trans-unit id="bb659abce8099a5d28b1e3c93c69644abcc5c2a2" translate="yes" xml:space="preserve">
          <source>A sequence of length D, each an optional (lower, upper) tuple giving the outer bin edges to be used if the edges are not given explicitly in &lt;code&gt;bins&lt;/code&gt;. An entry of None in the sequence results in the minimum and maximum values being used for the corresponding dimension. The default, None, is equivalent to passing a tuple of D None values.</source>
          <target state="translated">가장자리가 명시 적으로 지정하지 않는 경우의 길이 D의 순서는, 각각의 외측 가장자리 함을주는 (상하) 선택적 튜플 사용될 &lt;code&gt;bins&lt;/code&gt; . 시퀀스에서 없음을 입력하면 해당 차원에 최소값과 최대 값이 사용됩니다. 기본값 None은 튜플 D None 값을 전달하는 것과 같습니다.</target>
        </trans-unit>
        <trans-unit id="81bbfb50533f2d3f2a4fd7fa0b51f48f0e734f02" translate="yes" xml:space="preserve">
          <source>A sequence of polynomial roots, or a square array or matrix object.</source>
          <target state="translated">다항식 근의 시퀀스 또는 정사각형 배열 또는 행렬 객체입니다.</target>
        </trans-unit>
        <trans-unit id="7b3926b650dc6329b849ef33b7f6184643cd8f01" translate="yes" xml:space="preserve">
          <source>A sequence that allows &amp;ldquo;walking&amp;rdquo; (iterating) over items, typically using a loop such as:</source>
          <target state="translated">일반적으로 다음과 같은 루프를 사용하여 항목 위를 &quot;걷기&quot;(반복) 할 수있는 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="8ce1aa80939c4940a07bf339eac2448c2647e279" translate="yes" xml:space="preserve">
          <source>A sequence that may contain a variable number of types of any kind. A tuple is immutable, i.e., once constructed it cannot be changed. Similar to a list, it can be indexed and sliced:</source>
          <target state="translated">모든 종류의 다양한 유형의 유형을 포함 할 수있는 시퀀스입니다. 튜플은 불변입니다. 즉, 일단 생성되면 변경할 수 없습니다. 목록과 유사하게 색인화되고 분할 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="75ceb930ec244dcfda247cc2f0b11b4fd68f2536" translate="yes" xml:space="preserve">
          <source>A series of the same kind as the calling class and equal to &lt;code&gt;series&lt;/code&gt; when evaluated.</source>
          <target state="translated">호출 클래스와 같은 종류의 시리즈이며 평가시 &lt;code&gt;series&lt;/code&gt; 와 같습니다 .</target>
        </trans-unit>
        <trans-unit id="5057709f0bb39c2821cc05f21d054a694afcfad5" translate="yes" xml:space="preserve">
          <source>A series that represents the least squares fit to the data and has the domain and window specified in the call. If the coefficients for the unscaled and unshifted basis polynomials are of interest, do &lt;code&gt;new_series.convert().coef&lt;/code&gt;.</source>
          <target state="translated">최소 제곱을 나타내는 계열은 데이터에 적합하며 통화에 지정된 도메인과 창이 있습니다. 스케일링되지 않은 기초 다항식에 대한 계수가 관심있는 경우 &lt;code&gt;new_series.convert().coef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1310a301fbe7183e2ce95e09f01f8a3d3a00c649" translate="yes" xml:space="preserve">
          <source>A series with the coefficient of the &lt;code&gt;deg&lt;/code&gt; term set to one and all others zero.</source>
          <target state="translated">&lt;code&gt;deg&lt;/code&gt; 항의 계수 가 1로 설정되고 나머지는 모두 0으로 설정된 계열입니다 .</target>
        </trans-unit>
        <trans-unit id="34501fdb58052d0c2fa5b147e753287dfd92f3af" translate="yes" xml:space="preserve">
          <source>A set of arrays is called &amp;ldquo;broadcastable&amp;rdquo; to the same shape if the above rules produce a valid result, &lt;em&gt;i.e.&lt;/em&gt;, one of the following is true:</source>
          <target state="translated">위의 규칙이 유효한 결과를 생성하는 경우 ( &lt;em&gt;즉&lt;/em&gt; , 다음 중 하나에 해당 하는 경우) 배열 집합을 동일한 모양으로 &quot;방송 가능&quot;이라고 합니다.</target>
        </trans-unit>
        <trans-unit id="0fd60c6042a9c4728d8686f9ccb469161417ae1d" translate="yes" xml:space="preserve">
          <source>A set of ndarrays (or a single ndarray if there is only one dimension) corresponding to the derivatives of f with respect to each dimension. Each derivative has the same shape as f.</source>
          <target state="translated">각 차원에 대한 f의 미분에 해당하는 일련의 ndarray (또는 하나의 차원이있는 경우 단일 ndarray)입니다. 각 도함수는 f와 모양이 같습니다.</target>
        </trans-unit>
        <trans-unit id="94c527df312fef559bad352556ab86e1b52514f7" translate="yes" xml:space="preserve">
          <source>A seven-element array indicating which of Monday through Sunday are valid days. May be specified as a length-seven list or array, like [1,1,1,1,1,0,0]; a length-seven string, like &amp;lsquo;1111100&amp;rsquo;; or a string like &amp;ldquo;Mon Tue Wed Thu Fri&amp;rdquo;, made up of 3-character abbreviations for weekdays, optionally separated by white space. Valid abbreviations are: Mon Tue Wed Thu Fri Sat Sun</source>
          <target state="translated">월요일에서 일요일 중 어느 날이 유효한지 나타내는 7 요소 배열입니다. [1,1,1,1,1,0,0]과 같이 길이가 7 인 목록 또는 배열로 지정 될 수 있습니다. '1111100'과 같은 길이 7 문자열; 또는 &quot;Mon Tue Wed Thu Fri&quot;과 같은 문자열로, 주중 3 자 약어로 구성되며 선택적으로 공백으로 구분됩니다. 유효한 약어는 다음과 같습니다. Mon Tue Wed Thu Fri Sat Sun</target>
        </trans-unit>
        <trans-unit id="04f42a27c9190ebe7cb7727c84f9c866b89f7f82" translate="yes" xml:space="preserve">
          <source>A shared library must be compiled in a special way ( &lt;em&gt;e.g.&lt;/em&gt; using the &lt;code&gt;-shared&lt;/code&gt; flag with gcc).</source>
          <target state="translated">공유 라이브러리는 (특별한 방법으로 컴파일해야합니다 &lt;em&gt;예를 들어&lt;/em&gt; 사용 &lt;code&gt;-shared&lt;/code&gt; GCC와 플래그).</target>
        </trans-unit>
        <trans-unit id="c7b5c5f4e4e338a83df129a84a05152158bc31fb" translate="yes" xml:space="preserve">
          <source>A short (typically single-character) string that represents a data type in numpy and corresponds to &lt;code&gt;self.typeStr&lt;/code&gt;. For example, if &lt;code&gt;self.typeStr&lt;/code&gt; is &lt;code&gt;&quot;double&quot;&lt;/code&gt;, then &lt;code&gt;self.typeCode&lt;/code&gt; should be &lt;code&gt;&quot;d&quot;&lt;/code&gt;.</source>
          <target state="translated">numpy로 데이터 유형을 나타내고 &lt;code&gt;self.typeStr&lt;/code&gt; 에 해당하는 짧은 (일반적으로 단일 문자) 문자열입니다 . 예를 들어 &lt;code&gt;self.typeStr&lt;/code&gt; 이 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 인 경우 &lt;code&gt;self.typeCode&lt;/code&gt; 는 &lt;code&gt;&quot;d&quot;&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="e55a234c7e08a3a8270c585bca1826465f16b1d3" translate="yes" xml:space="preserve">
          <source>A short repeat rule looks like &amp;lt;item1, item2, item3, &amp;hellip;, itemN&amp;gt;. The rule specifies that the entire expression, &amp;lsquo;&amp;lt;&amp;hellip;&amp;gt;&amp;rsquo; should be replaced first with item1, and then with item2, and so forth until N repeats are accomplished.</source>
          <target state="translated">짧은 반복 규칙은 &amp;lt;item1, item2, item3,&amp;hellip;, itemN&amp;gt;과 같습니다. 규칙은 전체 표현식 '&amp;lt;&amp;hellip;&amp;gt;'을 먼저 N이 반복 될 때까지 item1로 교체 한 다음 item2로 교체하도록 지정합니다.</target>
        </trans-unit>
        <trans-unit id="bdb221c54cae8ae542f146eae648a4dc67ac0bda" translate="yes" xml:space="preserve">
          <source>A short-hand notation for specifying the format of a structured data type is a comma-separated string of basic formats.</source>
          <target state="translated">구조화 된 데이터 유형의 형식을 지정하기위한 간단한 표기법은 쉼표로 구분 된 기본 형식의 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="c658116a39377ba61c456f244fe2e0949f79cce1" translate="yes" xml:space="preserve">
          <source>A side-effect of transforming a masked array into a flexible &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is that meta information (&lt;code&gt;fill_value&lt;/code&gt;, &amp;hellip;) will be lost.</source>
          <target state="translated">마스킹 된 배열을 유연한 &lt;a href=&quot;numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 로 변환하는 부작용 은 메타 정보 ( &lt;code&gt;fill_value&lt;/code&gt; ,&amp;hellip;)가 손실된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="ee1ddd23d8920cdacf644ae54f8c0e534ba570de" translate="yes" xml:space="preserve">
          <source>A side-effect of transforming a masked array into a flexible &lt;code&gt;ndarray&lt;/code&gt; is that meta information (&lt;code&gt;fill_value&lt;/code&gt;, &amp;hellip;) will be lost.</source>
          <target state="translated">마스킹 된 배열을 유연한 &lt;code&gt;ndarray&lt;/code&gt; 로 변환하는 부작용 은 메타 정보 ( &lt;code&gt;fill_value&lt;/code&gt; ,&amp;hellip;)가 손실된다는 것입니다.</target>
        </trans-unit>
        <trans-unit id="3ef5bd6e53370c679df60531a5915557eff674e0" translate="yes" xml:space="preserve">
          <source>A signal value guaranteed not to be a valid type enumeration number.</source>
          <target state="translated">신호 값이 유효한 유형 열거 번호가 아님을 보증합니다.</target>
        </trans-unit>
        <trans-unit id="af2da0019a4fa9624d414aa98e9319fd7256e862" translate="yes" xml:space="preserve">
          <source>A signature file may contain one (recommended) or more &lt;code&gt;python
module&lt;/code&gt; blocks. &lt;code&gt;python module&lt;/code&gt; block describes the contents of a Python/C extension module &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; that F2PY generates.</source>
          <target state="translated">서명 파일에는 하나 (권장) 이상의 &lt;code&gt;python module&lt;/code&gt; 블록 이 포함될 수 있습니다 . &lt;code&gt;python module&lt;/code&gt; 블록은 F2PY가 생성 하는 Python / C 확장 모듈 &lt;code&gt;&amp;lt;modulename&amp;gt;module.c&lt;/code&gt; 의 내용을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="f824cc83e3f63719d08123a34f5bfe79a99c6a77" translate="yes" xml:space="preserve">
          <source>A signature is a string describing the input/output dimensions of the elementary function of a ufunc. See section below for more details.</source>
          <target state="translated">서명은 ufunc의 기본 함수의 입력 / 출력 차원을 설명하는 문자열입니다. 자세한 내용은 아래 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6aaac34b68cf1a23deeac4050af33db08c374dea" translate="yes" xml:space="preserve">
          <source>A similar approach to in-place builds and use of &lt;code&gt;PYTHONPATH&lt;/code&gt; but outside the source tree is to use:</source>
          <target state="translated">내부 빌드 및 &lt;code&gt;PYTHONPATH&lt;/code&gt; 사용에 대한 유사한 접근 방식 은 소스 트리 외부에서 다음을 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="48c83eae43f6ab6ce5f1574a2b3173c9326b00ba" translate="yes" xml:space="preserve">
          <source>A simple ISO date:</source>
          <target state="translated">간단한 ISO 날짜 :</target>
        </trans-unit>
        <trans-unit id="3270422976ada43b0732fb69a269e6a3c42669d9" translate="yes" xml:space="preserve">
          <source>A simple check for &lt;code&gt;xp&lt;/code&gt; being strictly increasing is:</source>
          <target state="translated">&lt;code&gt;xp&lt;/code&gt; 가 엄격하게 증가 하는지 확인하는 간단한 방법 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2087f59f2fa38fce8e5fd9aad38ee596ccc3d8af" translate="yes" xml:space="preserve">
          <source>A simple data type containing a 32-bit big-endian integer: (see &lt;a href=&quot;#arrays-dtypes-constructing&quot;&gt;Specifying and constructing data types&lt;/a&gt; for details on construction)</source>
          <target state="translated">32 비트 빅 엔디안 정수를 포함하는 간단한 데이터 유형 : ( &lt;a href=&quot;#arrays-dtypes-constructing&quot;&gt;구성에&lt;/a&gt; 대한 자세한 내용은 데이터 유형 지정 및 구성 참조 )</target>
        </trans-unit>
        <trans-unit id="593a67c8ad8a28c370a51733b480fae1403014ec" translate="yes" xml:space="preserve">
          <source>A simple format for saving numpy arrays to disk with the full information about them.</source>
          <target state="translated">numpy 배열을 디스크에 저장하기위한 간단한 형식입니다.</target>
        </trans-unit>
        <trans-unit id="4f69e9156919fa85d7fc17fd8515b50ec215be89" translate="yes" xml:space="preserve">
          <source>A simple interface to the IEEE error-flag checking support. The &lt;em&gt;errmask&lt;/em&gt; argument is a mask of &lt;code&gt;UFUNC_MASK_{ERR}&lt;/code&gt; bitmasks indicating which errors to check for (and how to check for them). The &lt;em&gt;errobj&lt;/em&gt; must be a Python tuple with two elements: a string containing the name which will be used in any communication of error and either a callable Python object (call-back function) or &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt;. The callable object will only be used if &lt;a href=&quot;#c.UFUNC_ERR_CALL&quot;&gt;&lt;code&gt;UFUNC_ERR_CALL&lt;/code&gt;&lt;/a&gt; is set as the desired error checking method. This routine manages the GIL and is safe to call even after releasing the GIL. If an error in the IEEE-compatible hardware is determined a -1 is returned, otherwise a 0 is returned.</source>
          <target state="translated">IEEE 오류 플래그 검사 지원에 대한 간단한 인터페이스입니다. &lt;em&gt;errmask의&lt;/em&gt; 인수의 마스크이다 &lt;code&gt;UFUNC_MASK_{ERR}&lt;/code&gt; 확인 (와이를 확인하는) 어떤 오류를 나타내는 비트 마스크. &lt;em&gt;errobj는&lt;/em&gt; 에러 임의의 통신에 사용하거나 호출 가능한 파이썬 개체 (콜백 함수)이나되는 이름이 포함 된 문자열 두 요소 파이썬 튜플 있어야 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; 를&lt;/a&gt; . 호출 가능한 개체는 &lt;a href=&quot;#c.UFUNC_ERR_CALL&quot;&gt; &lt;code&gt;UFUNC_ERR_CALL&lt;/code&gt; &lt;/a&gt; 이 원하는 오류 검사 방법으로 설정된 경우에만 사용됩니다 . 이 루틴은 GIL을 관리하며 GIL을 해제 한 후에도 안전하게 호출 할 수 있습니다. IEEE 호환 하드웨어의 오류가 확인되면 -1이 반환되고 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="29f34710a7684ff79fd871bcf98300fc810e986e" translate="yes" xml:space="preserve">
          <source>A simple interface to the IEEE error-flag checking support. The &lt;em&gt;errmask&lt;/em&gt; argument is a mask of &lt;code&gt;UFUNC_MASK_{ERR}&lt;/code&gt; bitmasks indicating which errors to check for (and how to check for them). The &lt;em&gt;errobj&lt;/em&gt; must be a Python tuple with two elements: a string containing the name which will be used in any communication of error and either a callable Python object (call-back function) or &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt;. The callable object will only be used if &lt;code&gt;UFUNC_ERR_CALL&lt;/code&gt; is set as the desired error checking method. This routine manages the GIL and is safe to call even after releasing the GIL. If an error in the IEEE-compatible hardware is determined a -1 is returned, otherwise a 0 is returned.</source>
          <target state="translated">IEEE 오류 플래그 검사 지원에 대한 간단한 인터페이스. &lt;em&gt;errmask의&lt;/em&gt; 인수의 마스크이다 &lt;code&gt;UFUNC_MASK_{ERR}&lt;/code&gt; 확인 (와이를 확인하는) 어떤 오류를 나타내는 비트 마스크. &lt;em&gt;errobj는&lt;/em&gt; 에러 임의의 통신에 사용하거나 호출 가능한 파이썬 개체 (콜백 함수)이나되는 이름이 포함 된 문자열 두 요소 파이썬 튜플 있어야 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; 를&lt;/a&gt; . 호출 가능한 객체는 &lt;code&gt;UFUNC_ERR_CALL&lt;/code&gt; 이 원하는 오류 검사 방법으로 설정된 경우에만 사용됩니다 . 이 루틴은 GIL을 관리하며 GIL을 해제 한 후에도 호출하는 것이 안전합니다. IEEE 호환 하드웨어의 오류가 확인되면 -1이 반환되고, 그렇지 않으면 0이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="16f651ca7550d656d6c3f3ed82c4b589e375b548" translate="yes" xml:space="preserve">
          <source>A simple linked-list of C-structures containing the information needed to define a 1-d loop for a ufunc for every defined signature of a user-defined data-type.</source>
          <target state="translated">사용자 정의 데이터 유형의 정의 된 모든 서명에 대해 ufunc에 대한 1-d 루프를 정의하는 데 필요한 정보가 포함 된 간단한 C 구조의 링크 된 목록입니다.</target>
        </trans-unit>
        <trans-unit id="bee5d4bece8f223e1b2634c3eec8ea6c05d6636a" translate="yes" xml:space="preserve">
          <source>A simple module that only uses a single &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; interface file should include the following:</source>
          <target state="translated">단일 &lt;a href=&quot;http://www.swig.org&quot;&gt;SWIG&lt;/a&gt; 인터페이스 파일 만 사용하는 간단한 모듈 에는 다음이 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="798db1bda5ff8b2af8f459281232c0cefd1e3ab9" translate="yes" xml:space="preserve">
          <source>A simple, but robust way to load the shared library is to get the absolute path name and load it using the cdll object of ctypes:</source>
          <target state="translated">공유 라이브러리를로드하는 간단하지만 강력한 방법은 절대 경로 이름을 가져 와서 ctypes의 cdll 객체를 사용하여로드하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="09d93ce0346cd0a5029dbb7dc011a271c7317bfe" translate="yes" xml:space="preserve">
          <source>A simplified interface to broadcasting. This function takes the number of arrays to broadcast and then &lt;em&gt;num&lt;/em&gt; extra ( &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; ) arguments. These arguments are converted to arrays and iterators are created. &lt;a href=&quot;#c.PyArray_Broadcast&quot;&gt;&lt;code&gt;PyArray_Broadcast&lt;/code&gt;&lt;/a&gt; is then called on the resulting multi-iterator object. The resulting, broadcasted mult-iterator object is then returned. A broadcasted operation can then be performed using a single loop and using &lt;a href=&quot;#c.PyArray_MultiIter_NEXT&quot;&gt;&lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt;&lt;/a&gt; (..)</source>
          <target state="translated">방송에 대한 간단한 인터페이스. 이 기능은 방송에 배열 다음의 수를 취 &lt;em&gt;NUM&lt;/em&gt; 추가 ( &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; ) 인수를. 이 인수는 배열로 변환되고 반복자가 작성됩니다. 그런 다음 결과 다중 반복기 오브젝트에서 &lt;a href=&quot;#c.PyArray_Broadcast&quot;&gt; &lt;code&gt;PyArray_Broadcast&lt;/code&gt; &lt;/a&gt; 가 호출됩니다. 그 결과 방송 된 다중 반복자 객체가 반환됩니다. 그런 다음 단일 루프와 &lt;a href=&quot;#c.PyArray_MultiIter_NEXT&quot;&gt; &lt;code&gt;PyArray_MultiIter_NEXT&lt;/code&gt; &lt;/a&gt; (..)를 사용하여 브로드 캐스트 된 작업을 수행 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28984f56b20efb716a65187c5ff200fdda38c42b" translate="yes" xml:space="preserve">
          <source>A single axis over which a generalized ufunc should operate. This is a short-cut for ufuncs that operate over a single, shared core dimension, equivalent to passing in &lt;code&gt;axes&lt;/code&gt; with entries of &lt;code&gt;(axis,)&lt;/code&gt; for each single-core-dimension argument and &lt;code&gt;()&lt;/code&gt; for all others. For instance, for a signature &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt;, it is equivalent to passing in &lt;code&gt;axes=[(axis,), (axis,), ()]&lt;/code&gt;.</source>
          <target state="translated">일반화 된 ufunc가 작동해야하는 단일 축입니다. 이는 단일 공유 코어 차원에서 동작 ufuncs, 전달에 해당하는 쇼트 컷 &lt;code&gt;axes&lt;/code&gt; 의 항목으로 &lt;code&gt;(axis,)&lt;/code&gt; 각 단일 코어 치수와 인수 &lt;code&gt;()&lt;/code&gt; , 기타 모든. 예를 들어, 서명 &lt;code&gt;(i),(i)-&amp;gt;()&lt;/code&gt; 의 경우 &lt;code&gt;axes=[(axis,), (axis,), ()]&lt;/code&gt; 를 전달하는 것과 같습니다 .</target>
        </trans-unit>
        <trans-unit id="7ecd974678a25bce6d0bb21975fdb524aa51f881" translate="yes" xml:space="preserve">
          <source>A single format (%10.5f), a sequence of formats, or a multi-format string, e.g. &amp;lsquo;Iteration %d &amp;ndash; %10.5f&amp;rsquo;, in which case &lt;code&gt;delimiter&lt;/code&gt; is ignored. For complex &lt;code&gt;X&lt;/code&gt;, the legal options for &lt;code&gt;fmt&lt;/code&gt; are:</source>
          <target state="translated">단일 형식 (% 10.5f), 일련의 형식 또는 다중 형식 문자열 (예 : 'Iteration % d &amp;ndash; % 10.5f') (이 경우 &lt;code&gt;delimiter&lt;/code&gt; 는 무시 됨) 복잡한 &lt;code&gt;X&lt;/code&gt; 의 경우 , &lt;code&gt;fmt&lt;/code&gt; 의 유효한 옵션 은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="2f72626ebddb5f9ee710e36e21cf37f297c4305c" translate="yes" xml:space="preserve">
          <source>A sorted sequence of &lt;code&gt;slice&lt;/code&gt; objects (start index, end index).</source>
          <target state="translated">정렬 된 &lt;code&gt;slice&lt;/code&gt; 객체 시퀀스 (시작 색인, 종료 색인).</target>
        </trans-unit>
        <trans-unit id="f59026a2e0815a0ce41083ddb7ee186606c6d091" translate="yes" xml:space="preserve">
          <source>A special case of the hyperbolic distribution. As &lt;code&gt;df&lt;/code&gt; gets large, the result resembles that of the standard normal distribution (&lt;a href=&quot;numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">쌍곡선 분포의 특별한 경우. 으로 &lt;code&gt;df&lt;/code&gt; 그 표준 정규 분포 (대형, 결과 유사 얻는다 &lt;a href=&quot;numpy.random.generator.standard_normal#numpy.random.Generator.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="ecc24fea5b7eed9eceb13972942907ac09867998" translate="yes" xml:space="preserve">
          <source>A special case of the hyperbolic distribution. As &lt;code&gt;df&lt;/code&gt; gets large, the result resembles that of the standard normal distribution (&lt;a href=&quot;numpy.random.mtrand.randomstate.standard_normal#numpy.random.mtrand.RandomState.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">쌍곡선 분포의 특별한 경우. 으로 &lt;code&gt;df&lt;/code&gt; 그 표준 정규 분포 (대형, 결과 유사 얻는다 &lt;a href=&quot;numpy.random.mtrand.randomstate.standard_normal#numpy.random.mtrand.RandomState.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="adb25a3e6adf460924879166919cae43eab2ceab" translate="yes" xml:space="preserve">
          <source>A special case of the hyperbolic distribution. As &lt;code&gt;df&lt;/code&gt; gets large, the result resembles that of the standard normal distribution (&lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">쌍곡선 분포의 특별한 경우입니다. 으로 &lt;code&gt;df&lt;/code&gt; 그 표준 정규 분포 (대형, 결과 유사 얻는다 &lt;a href=&quot;numpy.random.randomstate.standard_normal#numpy.random.RandomState.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d9de1f750180b9a34d0a98ccb2914b9631953427" translate="yes" xml:space="preserve">
          <source>A special case of the hyperbolic distribution. As &lt;code&gt;df&lt;/code&gt; gets large, the result resembles that of the standard normal distribution (&lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt;&lt;code&gt;standard_normal&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">쌍곡선 분포의 특별한 경우입니다. 으로 &lt;code&gt;df&lt;/code&gt; 그 표준 정규 분포 (대형, 결과 유사 얻는다 &lt;a href=&quot;numpy.random.standard_normal#numpy.random.standard_normal&quot;&gt; &lt;code&gt;standard_normal&lt;/code&gt; 을&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="63e6ec7e623d9c397e9c59873fafb24c4baac24c" translate="yes" xml:space="preserve">
          <source>A special variable type indicating the number of &amp;ldquo;kinds&amp;rdquo; of scalars distinguished in determining scalar-coercion rules. This variable can take on the values &lt;code&gt;NPY_{KIND}&lt;/code&gt; where &lt;code&gt;{KIND}&lt;/code&gt; can be</source>
          <target state="translated">스칼라 강제 규칙을 결정할 때 구별되는 스칼라의 &quot;종류&quot;수를 나타내는 특수 변수 유형입니다. 이 변수는 &lt;code&gt;NPY_{KIND}&lt;/code&gt; 값을 취할 수 있습니다. 여기서 &lt;code&gt;{KIND}&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="31bc091e887cfbbf0b45915994a2a358fbabb766" translate="yes" xml:space="preserve">
          <source>A special variable type indicating the number of &amp;ldquo;kinds&amp;rdquo; of scalars distinguished in determining scalar-coercion rules. This variable can take on the values:</source>
          <target state="translated">스칼라 강제 규칙을 결정할 때 구별되는 스칼라의 &quot;종류&quot;수를 나타내는 특수 변수 유형입니다. 이 변수는 다음 값을 가질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="047858130fa77a0a317e3a07b641429a62806764" translate="yes" xml:space="preserve">
          <source>A special variable-type which can take on different values to indicate the sorting algorithm being used.</source>
          <target state="translated">사용중인 정렬 알고리즘을 나타 내기 위해 다른 값을 취할 수있는 특수 변수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="00866a4cd9f695363bff3007afb5f20a623db3b3" translate="yes" xml:space="preserve">
          <source>A special variable-type which can take on the values &lt;code&gt;NPY_{KIND}&lt;/code&gt; where &lt;code&gt;{KIND}&lt;/code&gt; is</source>
          <target state="translated">&lt;code&gt;NPY_{KIND}&lt;/code&gt; 값을 취할 수있는 특수 변수 유형입니다. 여기서 &lt;code&gt;{KIND}&lt;/code&gt; 는</target>
        </trans-unit>
        <trans-unit id="b7a5231cd4b10f823ce716dfaa60723246dd2c6d" translate="yes" xml:space="preserve">
          <source>A specialized copy and transpose function that works only for 2-d arrays. The returned array is a transposed copy of &lt;em&gt;op&lt;/em&gt;.</source>
          <target state="translated">2 차원 배열에서만 작동하는 특수한 복사 및 조옮김 기능입니다. 반환 된 배열은 전치 된 &lt;em&gt;op의&lt;/em&gt; 복사본입니다 .</target>
        </trans-unit>
        <trans-unit id="4b435ecc470e2597bc4d02d178d56713edd8c94b" translate="yes" xml:space="preserve">
          <source>A stranger has asked for directions&amp;hellip;</source>
          <target state="translated">낯선 사람이 길을 물었다&amp;hellip;</target>
        </trans-unit>
        <trans-unit id="af2a950c790793615bfa85ddce287d3e3450b1e9" translate="yes" xml:space="preserve">
          <source>A string can have arbitrary length when using it as a string argument to F2PY generated wrapper function. If the length is greater than expected, the string is truncated. If the length is smaller than expected, additional memory is allocated and filled with &lt;code&gt;\0&lt;/code&gt;.</source>
          <target state="translated">문자열은 F2PY 생성 래퍼 함수에 대한 문자열 인수로 사용할 때 임의의 길이를 가질 수 있습니다. 길이가 예상보다 크면 문자열이 잘립니다. 길이가 예상보다 작 으면 추가 메모리가 할당되고 &lt;code&gt;\0&lt;/code&gt; 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="2497d67c71a8181efddc5d06ff6a25c2a2fb4d55" translate="yes" xml:space="preserve">
          <source>A string can have arbitrary length when using it as a string argument to F2PY generated wrapper function. If the length is greater than expected, the string is truncated. If the length is smaller that expected, additional memory is allocated and filled with &lt;code&gt;\0&lt;/code&gt;.</source>
          <target state="translated">문자열은 F2PY 생성 래퍼 함수에 대한 문자열 인수로 사용할 때 임의의 길이를 가질 수 있습니다. 길이가 예상보다 크면 문자열이 잘립니다. 길이가 예상보다 작 으면 추가 메모리가 할당되고 &lt;code&gt;\0&lt;/code&gt; 채워집니다 .</target>
        </trans-unit>
        <trans-unit id="774ff5fbcb64cd63fcb41a3daa1076f5946c7ae1" translate="yes" xml:space="preserve">
          <source>A string combining invalid characters that must be deleted from the names.</source>
          <target state="translated">이름에서 삭제해야하는 유효하지 않은 문자를 결합한 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="20a384e3c2e6a14cf6c36ba5a2e36844384b8f3f" translate="yes" xml:space="preserve">
          <source>A string containing the data.</source>
          <target state="translated">데이터가 포함 된 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="d92fb30e44bde7fa02db5d823fe26a99afa2efe0" translate="yes" xml:space="preserve">
          <source>A string integer specifies which axis to stack multiple comma separated arrays along. A string of two comma-separated integers allows indication of the minimum number of dimensions to force each entry into as the second integer (the axis to concatenate along is still the first integer).</source>
          <target state="translated">문자열 정수는 쉼표로 구분 된 여러 배열을 쌓을 축을 지정합니다. 두 개의 쉼표로 구분 된 정수의 문자열을 사용하면 각 항목을 두 번째 정수로 강제 할 수있는 최소 차원 수를 표시 할 수 있습니다 (연결할 축이 여전히 첫 번째 정수임).</target>
        </trans-unit>
        <trans-unit id="a641af276b72e55102c42cfb585abb388eea7dfe" translate="yes" xml:space="preserve">
          <source>A string name for the ufunc. This is used dynamically to build the __doc__ attribute of ufuncs.</source>
          <target state="translated">ufunc의 문자열 이름입니다. 이것은 ufuncs의 __doc__ 속성을 동적으로 구축하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="114cd592cdf4bef478ab0fc63ad99238e2d8ce95" translate="yes" xml:space="preserve">
          <source>A string naming the dump file.</source>
          <target state="translated">덤프 파일의 이름을 지정하는 문자열</target>
        </trans-unit>
        <trans-unit id="df0f86d5ebf300964e3704370aa82f07970d9a8e" translate="yes" xml:space="preserve">
          <source>A string of comma-separated dtype specifications</source>
          <target state="translated">쉼표로 구분 된 dtype 사양의 문자열</target>
        </trans-unit>
        <trans-unit id="7deb712c363da06697a0abbace6d83471ea4cf08" translate="yes" xml:space="preserve">
          <source>A string or a sequence of strings corresponding to the fields used for comparison.</source>
          <target state="translated">비교에 사용되는 필드에 해당하는 문자열 또는 문자열 시퀀스입니다.</target>
        </trans-unit>
        <trans-unit id="292579b654816d2d1cb9494934238580c48fc2c0" translate="yes" xml:space="preserve">
          <source>A string providing a name associated with this portion of the datatype. This could also be a tuple of &lt;code&gt;('full name',
'basic_name')&lt;/code&gt; where basic name would be a valid Python variable name representing the full name of the field.</source>
          <target state="translated">데이터 유형의이 부분과 연관된 이름을 제공하는 문자열입니다. 기본 이름은 필드의 전체 이름을 나타내는 유효한 Python 변수 이름이되는 &lt;code&gt;('full name', 'basic_name')&lt;/code&gt; 의 튜플 일 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="ef1826a04b54488c8c0f9650ea8e241ad78ca5bf" translate="yes" xml:space="preserve">
          <source>A string providing the basic type of the homogeneous array The basic string format consists of 3 parts: a character describing the byteorder of the data (&lt;code&gt;&amp;lt;&lt;/code&gt;: little-endian, &lt;code&gt;&amp;gt;&lt;/code&gt;: big-endian, &lt;code&gt;|&lt;/code&gt;: not-relevant), a character code giving the basic type of the array, and an integer providing the number of bytes the type uses.</source>
          <target state="translated">동종 배열의 기본 유형을 제공하는 문자열 기본 문자열 형식은 데이터의 바이트 순서를 설명하는 문자 ( &lt;code&gt;&amp;lt;&lt;/code&gt; : little-endian, &lt;code&gt;&amp;gt;&lt;/code&gt; : big-endian, &lt;code&gt;|&lt;/code&gt; : 관련 없음), 문자 코드의 세 부분으로 구성됩니다. 배열의 기본 유형을 제공하고 유형이 사용하는 바이트 수를 제공하는 정수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="619f5c1475ced21cf4fa25f8cd5302b1602c1052" translate="yes" xml:space="preserve">
          <source>A string providing the basic type of the homogenous array The basic string format consists of 3 parts: a character describing the byteorder of the data (&lt;code&gt;&amp;lt;&lt;/code&gt;: little-endian, &lt;code&gt;&amp;gt;&lt;/code&gt;: big-endian, &lt;code&gt;|&lt;/code&gt;: not-relevant), a character code giving the basic type of the array, and an integer providing the number of bytes the type uses.</source>
          <target state="translated">동종 배열의 기본 유형을 제공하는 문자열 기본 문자열 형식은 데이터의 바이트 순서를 설명하는 문자 ( &lt;code&gt;&amp;lt;&lt;/code&gt; : little-endian, &lt;code&gt;&amp;gt;&lt;/code&gt; : big-endian, &lt;code&gt;|&lt;/code&gt; : not-relevant), 문자 코드의 세 부분으로 구성됩니다. 배열의 기본 유형과 유형이 사용하는 바이트 수를 제공하는 정수를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="a90aac579586e4ebd136c30a26daae199bbf4715" translate="yes" xml:space="preserve">
          <source>A string that matches one of the &lt;code&gt;SNAME&lt;/code&gt; prefixes used in &lt;code&gt;Vector.h&lt;/code&gt; and &lt;code&gt;Vector.cxx&lt;/code&gt;. For example, &lt;code&gt;&quot;double&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Vector.h&lt;/code&gt; 및 &lt;code&gt;Vector.cxx&lt;/code&gt; 에 사용 된 &lt;code&gt;SNAME&lt;/code&gt; 접두사 중 하나와 일치하는 문자열입니다 . 예를 들어 &lt;code&gt;&quot;double&quot;&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="11a21b6388a76d32ee94fe75187d475e1e9a31be" translate="yes" xml:space="preserve">
          <source>A string with &amp;lsquo;f&amp;rsquo; representing trim from front and &amp;lsquo;b&amp;rsquo; to trim from back. Default is &amp;lsquo;fb&amp;rsquo;, trim zeros from both front and back of the array.</source>
          <target state="translated">'f'가 앞에 트림을 나타내고 'b'가 문자열을 트리밍하는 문자열입니다. 기본값은 'fb'이며 어레이의 앞면과 뒷면 모두에서 0을 자릅니다.</target>
        </trans-unit>
        <trans-unit id="9f5fc7d583671fa3d14d3cf2a8c5d45637921d25" translate="yes" xml:space="preserve">
          <source>A string with three comma-separated integers allows specification of the axis to concatenate along, the minimum number of dimensions to force the entries to, and which axis should contain the start of the arrays which are less than the specified number of dimensions. In other words the third integer allows you to specify where the 1&amp;rsquo;s should be placed in the shape of the arrays that have their shapes upgraded. By default, they are placed in the front of the shape tuple. The third argument allows you to specify where the start of the array should be instead. Thus, a third argument of &amp;lsquo;0&amp;rsquo; would place the 1&amp;rsquo;s at the end of the array shape. Negative integers specify where in the new shape tuple the last dimension of upgraded arrays should be placed, so the default is &amp;lsquo;-1&amp;rsquo;.</source>
          <target state="translated">쉼표로 구분 된 3 개의 정수가있는 문자열을 사용하면 축 지정, 항목을 강제로 삽입 할 최소 차원 수 및 지정된 차원 수보다 작은 배열의 시작을 포함해야하는 축을 지정할 수 있습니다. 즉, 세 번째 정수를 사용하면 모양이 업그레이드 된 배열의 모양에서 1을 배치 할 위치를 지정할 수 있습니다. 기본적으로 모양 튜플의 전면에 배치됩니다. 세 번째 인수를 사용하면 배열의 시작 위치를 지정할 수 있습니다. 따라서 '0'의 세 번째 인수는 1을 배열 모양의 끝에 배치합니다. 음의 정수는 새 모양 튜플에서 업그레이드 된 배열의 마지막 차원을 배치 할 위치를 지정하므로 기본값은 '-1'입니다.</target>
        </trans-unit>
        <trans-unit id="e6d2ae7b6da7c3e66b0ffab924afae035a474e84" translate="yes" xml:space="preserve">
          <source>A structured data type containing a 16-character string (in field &amp;lsquo;name&amp;rsquo;) and a sub-array of two 64-bit floating-point number (in field &amp;lsquo;grades&amp;rsquo;):</source>
          <target state="translated">16 자 문자열 (필드 'name')과 두 개의 64 비트 부동 소수점 숫자 (필드 'grades')의 하위 배열을 포함하는 구조화 된 데이터 유형 :</target>
        </trans-unit>
        <trans-unit id="b512bc16c5dc1ece05fb571662540e6eab13385b" translate="yes" xml:space="preserve">
          <source>A structured datatype can be thought of as a sequence of bytes of a certain length (the structure&amp;rsquo;s &lt;a href=&quot;../glossary#term-itemsize&quot;&gt;itemsize&lt;/a&gt;) which is interpreted as a collection of fields. Each field has a name, a datatype, and a byte offset within the structure. The datatype of a field may be any numpy datatype including other structured datatypes, and it may also be a &lt;a href=&quot;../glossary#term-subarray-data-type&quot;&gt;subarray data type&lt;/a&gt; which behaves like an ndarray of a specified shape. The offsets of the fields are arbitrary, and fields may even overlap. These offsets are usually determined automatically by numpy, but can also be specified.</source>
          <target state="translated">구조화 된 데이터 유형 은 필드 모음으로 해석되는 특정 길이 (구조의 &lt;a href=&quot;../glossary#term-itemsize&quot;&gt;itemsize&lt;/a&gt; ) 의 바이트 시퀀스로 생각할 수 있습니다 . 각 필드에는 구조 내에서 이름, 데이터 유형 및 바이트 오프셋이 있습니다. 필드의 데이터 유형은 다른 구조화 된 데이터 유형을 포함하는 numpy 데이터 유형일 수 있으며 지정된 모양의 ndarray처럼 동작 하는 &lt;a href=&quot;../glossary#term-subarray-data-type&quot;&gt;하위 배열 데이터 유형일&lt;/a&gt; 수도 있습니다 . 필드의 오프셋은 임의적이며 필드가 겹칠 수도 있습니다. 이러한 오프셋은 일반적으로 numpy에 의해 자동으로 결정되지만 지정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="f387c4506792763f7877a583ef74111591fec417" translate="yes" xml:space="preserve">
          <source>A subclass can override what happens when executing numpy ufuncs on it by overriding the default &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; method. This method is executed &lt;em&gt;instead&lt;/em&gt; of the ufunc and should return either the result of the operation, or &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; if the operation requested is not implemented.</source>
          <target state="translated">하위 클래스는 기본 &lt;code&gt;ndarray.__array_ufunc__&lt;/code&gt; 메서드를 재정 의하여 numpy ufuncs를 실행할 때 발생하는 작업을 재정의 할 수 있습니다 . 이 방법을 실행 &lt;em&gt;하는 대신&lt;/em&gt; ufunc 및 두 동작의 결과를 반환해야하거나 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; &lt;/a&gt; 동작은 구현되지 요청할 경우.</target>
        </trans-unit>
        <trans-unit id="f180152a86fa9b648a6bab2cda7a10f4905a48b6" translate="yes" xml:space="preserve">
          <source>A subclass of &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; designed to manipulate numerical arrays with missing data.</source>
          <target state="translated">누락 된 데이터가있는 숫자 형 배열을 조작하도록 설계된 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 의 하위 클래스입니다 .</target>
        </trans-unit>
        <trans-unit id="2e73055c8960d39f9422f4c955da1aa6b20cdb50" translate="yes" xml:space="preserve">
          <source>A suitable Python interface to this shared library should be constructed. To do this create a file named interface.py with the following lines at the top:</source>
          <target state="translated">이 공유 라이브러리에 적합한 Python 인터페이스를 구성해야합니다. 이렇게하려면 맨 위에 다음 줄이있는 interface.py라는 파일을 만듭니다.</target>
        </trans-unit>
        <trans-unit id="34235c2c2dbe1e87a37e895b872dd2f556806627" translate="yes" xml:space="preserve">
          <source>A synonym for &lt;a href=&quot;#c.PyArray_DIMS&quot;&gt;&lt;code&gt;PyArray_DIMS&lt;/code&gt;&lt;/a&gt;, named to be consistent with the &lt;a href=&quot;../generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt; usage within Python.</source>
          <target state="translated">&lt;a href=&quot;#c.PyArray_DIMS&quot;&gt; &lt;code&gt;PyArray_DIMS&lt;/code&gt; &lt;/a&gt; 의 동의어로 , Python 내 에서 &lt;a href=&quot;../generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 사용 과 일치하도록 이름이 지정되었습니다 .</target>
        </trans-unit>
        <trans-unit id="0a9d85237edf034be6cf9bf1e244b291b0aee63a" translate="yes" xml:space="preserve">
          <source>A synonym for PyArray_DESCR, named to be consistent with the &amp;lsquo;dtype&amp;rsquo; usage within Python.</source>
          <target state="translated">파이썬에서 'dtype'사용법과 일치하도록 명명 된 PyArray_DESCR의 동의어입니다.</target>
        </trans-unit>
        <trans-unit id="f2681289891032d09b18ed94e9f65a0e2826ff47" translate="yes" xml:space="preserve">
          <source>A synonym for PyArray_DIMS, named to be consistent with the &amp;lsquo;shape&amp;rsquo; usage within Python.</source>
          <target state="translated">PyArray_DIMS의 동의어로, 파이썬에서 '모양'사용법과 일치하도록 명명되었습니다.</target>
        </trans-unit>
        <trans-unit id="fb1fd8cb6bc580ad49d52598a0e049687d62e978" translate="yes" xml:space="preserve">
          <source>A temporary array is formed by dropping the fields not in the key for the two arrays and concatenating the result. This array is then sorted, and the common entries selected. The output is constructed by filling the fields with the selected entries. Matching is not preserved if there are some duplicates&amp;hellip;</source>
          <target state="translated">임시 배열은 두 배열의 키에없는 필드를 삭제하고 결과를 연결하여 형성됩니다. 그런 다음이 배열이 정렬되고 공통 항목이 선택됩니다. 출력은 선택한 항목으로 필드를 채워서 구성됩니다. 일부 중복이있는 경우 일치가 유지되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1519f14a1c1c3110230c658ad9f28caf3137d319" translate="yes" xml:space="preserve">
          <source>A test function is typically added to a package&amp;rsquo;s __init__.py like so:</source>
          <target state="translated">테스트 함수는 일반적으로 다음과 같이 패키지의 __init__.py에 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="8c4410cbe0b9f7cf51e2244cb7c5c5dd5f8dc17d" translate="yes" xml:space="preserve">
          <source>A third option is to take the view of an existing array. In that case, the mask of the view is set to &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt;&lt;code&gt;nomask&lt;/code&gt;&lt;/a&gt; if the array has no named fields, or an array of boolean with the same structure as the array otherwise.</source>
          <target state="translated">세 번째 옵션은 기존 어레이를 보는 것입니다. 이 경우, 볼의 마스크로 설정되어 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.nomask&quot;&gt; &lt;code&gt;nomask&lt;/code&gt; &lt;/a&gt; 어레이 더 필드 이름, 또는 다른 배열과 같은 구조를 갖는 부울 배열 경우.</target>
        </trans-unit>
        <trans-unit id="0f636d16ad05af695598dcc38696ba8fa663d5b8" translate="yes" xml:space="preserve">
          <source>A third source of entropy, used internally when calling &lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt;&lt;code&gt;SeedSequence.spawn&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;numpy.random.seedsequence.spawn#numpy.random.SeedSequence.spawn&quot;&gt; &lt;code&gt;SeedSequence.spawn&lt;/code&gt; 을&lt;/a&gt; 호출 할 때 내부적으로 사용되는 세 번째 엔트로피 소스</target>
        </trans-unit>
        <trans-unit id="b26618bcd66cd9132be5eed72ccd0ebdf50ea37a" translate="yes" xml:space="preserve">
          <source>A timedelta stored as a 64-bit integer.</source>
          <target state="translated">64 비트 정수로 저장된 타임 델타입니다.</target>
        </trans-unit>
        <trans-unit id="3c732466671bb9ce60ffffbea1204a8445e601bb" translate="yes" xml:space="preserve">
          <source>A total of the number of skipped and known failing tests is displayed at the end of the test run. Skipped tests are marked as &lt;code&gt;'S'&lt;/code&gt; in the test results (or &lt;code&gt;'SKIPPED'&lt;/code&gt; for &lt;code&gt;verbose &amp;gt; 1&lt;/code&gt;), and known failing tests are marked as &lt;code&gt;'x'&lt;/code&gt; (or &lt;code&gt;'XFAIL'&lt;/code&gt; if &lt;code&gt;verbose &amp;gt;
1&lt;/code&gt;).</source>
          <target state="translated">테스트 실행이 끝나면 건너 뛰고 알려진 실패 테스트의 총 수가 표시됩니다. 건너 뛴 테스트는 테스트 결과에서 &lt;code&gt;'S'&lt;/code&gt; (또는 &lt;code&gt;verbose &amp;gt; 1&lt;/code&gt; &lt;code&gt;'SKIPPED'&lt;/code&gt; ) 로 표시 되고 알려진 실패 테스트는 &lt;code&gt;'x'&lt;/code&gt; (또는 &lt;code&gt;verbose &amp;gt; 1&lt;/code&gt; 경우 &lt;code&gt;'XFAIL'&lt;/code&gt; )로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="a64f95a5aede16bea5ef8a6ca146177fb6b3b182" translate="yes" xml:space="preserve">
          <source>A traditional character code indicating the data type.</source>
          <target state="translated">데이터 유형을 나타내는 전통적인 문자 코드.</target>
        </trans-unit>
        <trans-unit id="0b2b4cceb7cfb51035a175e0d658850c2512647b" translate="yes" xml:space="preserve">
          <source>A tuple indicating the shape of the mask.</source>
          <target state="translated">마스크의 모양을 나타내는 튜플.</target>
        </trans-unit>
        <trans-unit id="39b22a3028b03b7b08ff2b2c8d6c1ee3b20dc078" translate="yes" xml:space="preserve">
          <source>A tuple of axes can now be input to &lt;code&gt;expand_dims&lt;/code&gt;</source>
          <target state="translated">이제 축의 튜플을 &lt;code&gt;expand_dims&lt;/code&gt; 에 입력 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="85c14115771a7d712b28ce39ebe75a1449ae6de7" translate="yes" xml:space="preserve">
          <source>A tuple of integer arrays, one array for each dimension.</source>
          <target state="translated">정수 배열의 튜플, 각 차원마다 하나의 배열.</target>
        </trans-unit>
        <trans-unit id="294fc3e3f8a6705ff5d64e4533f44195ce294863" translate="yes" xml:space="preserve">
          <source>A tuple showing the length of each dimension of an ndarray. The length of the tuple itself is the number of dimensions (&lt;a href=&quot;reference/generated/numpy.ndarray.ndim&quot;&gt;numpy.ndim&lt;/a&gt;). The product of the tuple elements is the number of elements in the array. For details, see &lt;a href=&quot;reference/generated/numpy.ndarray.shape&quot;&gt;numpy.ndarray.shape&lt;/a&gt;.</source>
          <target state="translated">ndarray의 각 차원 길이를 표시하는 튜플입니다. 튜플 자체의 길이는 차원 수 ( &lt;a href=&quot;reference/generated/numpy.ndarray.ndim&quot;&gt;numpy.ndim&lt;/a&gt; )입니다. 튜플 요소의 곱은 배열의 요소 수입니다. 자세한 내용은 &lt;a href=&quot;reference/generated/numpy.ndarray.shape&quot;&gt;numpy.ndarray.shape를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ae51c3ea3c094cd9cddbc02935737e4b00f64a16" translate="yes" xml:space="preserve">
          <source>A type object, which is an &lt;code&gt;_ndtpr&lt;/code&gt; instance containing dtype, ndim, shape and flags information.</source>
          <target state="translated">dtype, ndim, shape 및 flags 정보를 포함 하는 &lt;code&gt;_ndtpr&lt;/code&gt; 인스턴스 인 type 객체 입니다.</target>
        </trans-unit>
        <trans-unit id="fdd8d8f2aabfc1f94ccd461a927990273055b0f1" translate="yes" xml:space="preserve">
          <source>A typical implementation would convert any inputs or outputs that are instances of one&amp;rsquo;s own class, pass everything on to a superclass using &lt;code&gt;super()&lt;/code&gt;, and finally return the results after possible back-conversion. An example, taken from the test case &lt;code&gt;test_ufunc_override_with_super&lt;/code&gt; in &lt;code&gt;core/tests/test_umath.py&lt;/code&gt;, is the following.</source>
          <target state="translated">일반적인 구현은 자신의 클래스의 인스턴스 인 입력 또는 출력을 변환하고, &lt;code&gt;super()&lt;/code&gt; 사용하여 모든 것을 수퍼 클래스에 전달 하고, 가능한 역변환 후 결과를 반환합니다. 예는 테스트 케이스 찍은 &lt;code&gt;test_ufunc_override_with_super&lt;/code&gt; 의 &lt;code&gt;core/tests/test_umath.py&lt;/code&gt; , 다음과 같다.</target>
        </trans-unit>
        <trans-unit id="6e3c7bb6314ac7c8c0736544e2b11ed065754ed9" translate="yes" xml:space="preserve">
          <source>A typical release schedule is one beta, two release candidates and a final release. It&amp;rsquo;s best to discuss the timing on the mailing list first, in order for people to get their commits in on time, get doc wiki edits merged, etc. After a date is set, create a new maintenance/x.y.z branch, add new empty release notes for the next version in the master branch and update the Trac Milestones.</source>
          <target state="translated">일반적인 릴리스 일정은 베타 1 개, 릴리스 후보 2 개 및 최종 릴리스입니다. 메일 링리스트에서 타이밍을 먼저 논의하는 것이 가장 좋습니다. 사람들이 정시에 커밋하고 문서 위키 편집 내용을 병합 할 수 있도록합니다. 날짜가 설정되면 새 유지 관리 / xyz 브랜치를 만들고 비어있는 새 릴리스를 추가합니다. 마스터 브랜치의 다음 버전에 대한 참고 사항을 확인하고 Trac 마일스톤을 업데이트하십시오.</target>
        </trans-unit>
        <trans-unit id="3b160cb3cf90c99aa1978b7563a27004c60d976d" translate="yes" xml:space="preserve">
          <source>A unicode string.</source>
          <target state="translated">유니 코드 문자열.</target>
        </trans-unit>
        <trans-unit id="d2dc5b16a9633f04f2b77831428f3b69798d84b3" translate="yes" xml:space="preserve">
          <source>A unique character code for each of the 21 different built-in types.</source>
          <target state="translated">21 개의 서로 다른 내장 유형 각각에 대한 고유 한 문자 코드.</target>
        </trans-unit>
        <trans-unit id="d057a382d54c38b38dfa71e3ba451944dcf3b8d8" translate="yes" xml:space="preserve">
          <source>A unique number for each of the 21 different built-in types.</source>
          <target state="translated">21 개의 서로 다른 내장 유형 각각에 대한 고유 번호.</target>
        </trans-unit>
        <trans-unit id="5b8b3285a28b8d0d0f9a89388a30be89c5f9ef89" translate="yes" xml:space="preserve">
          <source>A universal function (or &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) is a function that operates on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; in an element-by-element fashion, supporting &lt;a href=&quot;#ufuncs-broadcasting&quot;&gt;array broadcasting&lt;/a&gt;, &lt;a href=&quot;#ufuncs-casting&quot;&gt;type casting&lt;/a&gt;, and several other standard features. That is, a ufunc is a &amp;ldquo;&lt;a href=&quot;../glossary#term-vectorization&quot;&gt;vectorized&lt;/a&gt;&amp;rdquo; wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs.</source>
          <target state="translated">범용 함수 (또는 &lt;a href=&quot;../glossary#term-ufunc&quot;&gt;줄여서 ufunc&lt;/a&gt; )는 요소 별 방식 으로 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 에서 작동하며 &lt;a href=&quot;#ufuncs-broadcasting&quot;&gt;배열 브로드 캐스팅&lt;/a&gt; , &lt;a href=&quot;#ufuncs-casting&quot;&gt;유형 캐스팅&lt;/a&gt; 및 기타 여러 표준 기능을 지원 하는 함수입니다 . 즉, ufunc는 고정 된 수의 특정 입력을 사용하고 고정 된 수의 특정 출력을 생성하는 함수에 대한 &quot; &lt;a href=&quot;../glossary#term-vectorization&quot;&gt;벡터화 된&lt;/a&gt; &quot;래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="64c1f6c06cc51041e07183275cab6719aeb64fb9" translate="yes" xml:space="preserve">
          <source>A universal function (or &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; for short) is a function that operates on &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarrays&lt;/code&gt;&lt;/a&gt; in an element-by-element fashion, supporting &lt;a href=&quot;#ufuncs-broadcasting&quot;&gt;array broadcasting&lt;/a&gt;, &lt;a href=&quot;#ufuncs-casting&quot;&gt;type casting&lt;/a&gt;, and several other standard features. That is, a ufunc is a &amp;ldquo;&lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-vectorization&quot;&gt;vectorized&lt;/a&gt;&amp;rdquo; wrapper for a function that takes a fixed number of specific inputs and produces a fixed number of specific outputs.</source>
          <target state="translated">범용 함수 (또는 짧게 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-ufunc&quot;&gt;ufunc&lt;/a&gt; )는 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarrays&lt;/code&gt; &lt;/a&gt; 에서 요소 별로 작동하여 &lt;a href=&quot;#ufuncs-broadcasting&quot;&gt;배열 브로드 캐스트&lt;/a&gt; , &lt;a href=&quot;#ufuncs-casting&quot;&gt;유형 캐스팅&lt;/a&gt; 및 기타 여러 표준 기능을 지원하는 기능입니다. 즉, ufunc는 고정 된 수의 특정 입력을 사용하고 고정 된 수의 특정 출력을 생성하는 함수 의 &quot; &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-vectorization&quot;&gt;벡터화 된&lt;/a&gt; &quot;래퍼입니다.</target>
        </trans-unit>
        <trans-unit id="0b5238c72cf80b5c60c913bcf36e0c3b2aca2141" translate="yes" xml:space="preserve">
          <source>A use case for this function is to match the shape and layout of the iterator and tack on one or more dimensions. For example, in order to generate a vector per input value for a numerical gradient, you pass in ndim*itemsize for itemsize, then add another dimension to the end with size ndim and stride itemsize. To do the Hessian matrix, you do the same thing but add two dimensions, or take advantage of the symmetry and pack it into 1 dimension with a particular encoding.</source>
          <target state="translated">이 기능의 사용 사례는 반복자의 모양 및 레이아웃을 일치시키고 하나 이상의 차원에 고정하는 것입니다. 예를 들어, 숫자 그라디언트의 입력 값당 벡터를 생성하려면 항목 크기로 ndim * itemsize를 전달한 다음 크기가 ndim 인 항목에 다른 차원을 추가하고 항목 크기를 늘리십시오. Hessian 행렬을 수행하려면 동일한 작업을 수행하지만 2 차원을 추가하거나 대칭을 활용하여 특정 인코딩으로 1 차원으로 압축합니다.</target>
        </trans-unit>
        <trans-unit id="de22500eb5e8b8de7c477c2173c078a3f78b884b" translate="yes" xml:space="preserve">
          <source>A useful concept is &amp;ldquo;tuple unpacking&amp;rdquo;, which allows variables to be assigned to the contents of a tuple:</source>
          <target state="translated">유용한 개념은&amp;ldquo;튜플 풀기&amp;rdquo;로, 튜플의 내용에 변수를 할당 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c23b4448f23bf99116b098b7042336b6a0a35ca9" translate="yes" xml:space="preserve">
          <source>A user-defined type number is returned that uniquely identifies the type. A pointer to the new structure can then be obtained from &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt;&lt;code&gt;PyArray_DescrFromType&lt;/code&gt;&lt;/a&gt; using the returned type number. A -1 is returned if an error occurs. If this &lt;em&gt;dtype&lt;/em&gt; has already been registered (checked only by the address of the pointer), then return the previously-assigned type-number.</source>
          <target state="translated">유형을 고유하게 식별하는 사용자 정의 유형 번호가 리턴됩니다. 그런 다음 반환 된 유형 번호를 사용하여 &lt;a href=&quot;#c.PyArray_DescrFromType&quot;&gt; &lt;code&gt;PyArray_DescrFromType&lt;/code&gt; &lt;/a&gt; 에서 새 구조에 대한 포인터를 얻을 수 있습니다. 오류가 발생하면 -1이 반환됩니다. 이 &lt;em&gt;dtype&lt;/em&gt; 이 이미 등록 된 경우 (포인터의 주소로만 확인) 이전에 할당 된 type-number를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d15cfd1e60814b656a603a12c408fd84b9dc49bd" translate="yes" xml:space="preserve">
          <source>A variable &lt;code&gt;x&lt;/code&gt; has a log-normal distribution if &lt;code&gt;log(x)&lt;/code&gt; is normally distributed. The probability density function for the log-normal distribution is:</source>
          <target state="translated">&lt;code&gt;log(x)&lt;/code&gt; 가 정규 분포 인 경우 변수 &lt;code&gt;x&lt;/code&gt; 는 로그 정규 분포를 갖습니다 . 로그 정규 분포에 대한 확률 밀도 함수는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a380132a2a22dec2d9e0225f137d26ed0fb90cb8" translate="yes" xml:space="preserve">
          <source>A variable type indicating the kind of clipping that should be applied in certain functions.</source>
          <target state="translated">특정 기능에 적용해야하는 클리핑의 종류를 나타내는 변수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="92ee56069bf2a979b0f98f8dc2758991d6eaeb36" translate="yes" xml:space="preserve">
          <source>A variable type indicating the selection algorithm being used.</source>
          <target state="translated">사용중인 선택 알고리즘을 나타내는 변수 유형입니다.</target>
        </trans-unit>
        <trans-unit id="ed8e1a32ab2b9c51761a4c61f1d8c956e15e5de5" translate="yes" xml:space="preserve">
          <source>A variable type indicating whether the index returned should be that of the first suitable location (if &lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt;&lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt;&lt;/a&gt;) or of the last (if &lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt;&lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">반환 된 인덱스가 첫 번째 적합한 위치 ( &lt;a href=&quot;#c.NPY_SEARCHLEFT&quot;&gt; &lt;code&gt;NPY_SEARCHLEFT&lt;/code&gt; 인&lt;/a&gt; 경우 ) 또는 마지막 ( &lt;a href=&quot;#c.NPY_SEARCHRIGHT&quot;&gt; &lt;code&gt;NPY_SEARCHRIGHT&lt;/code&gt; 인&lt;/a&gt; 경우) 인지 여부를 나타내는 변수 유형 입니다.</target>
        </trans-unit>
        <trans-unit id="fa9bf0dccea77846a06e4f1221f1f221c098b27c" translate="yes" xml:space="preserve">
          <source>A version which returns complex numbers when given negative reals.</source>
          <target state="translated">음의 실수가 주어지면 복소수를 반환하는 버전입니다.</target>
        </trans-unit>
        <trans-unit id="2fcfc20f282779542aca2d1f71202cb495e262a7" translate="yes" xml:space="preserve">
          <source>A very common operation in much of NumPy code is the need to iterate over all the elements of a general, strided, N-dimensional array. This operation of a general-purpose N-dimensional loop is abstracted in the notion of an iterator object. To write an N-dimensional loop, you only have to create an iterator object from an ndarray, work with the dataptr member of the iterator object structure and call the macro &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it) on the iterator object to move to the next element. The &amp;ldquo;next&amp;rdquo; element is always in C-contiguous order. The macro works by first special casing the C-contiguous, 1-D, and 2-D cases which work very simply.</source>
          <target state="translated">많은 NumPy 코드에서 매우 일반적인 작업은 일반 스 트레이딩 된 N- 차원 배열의 모든 요소를 ​​반복해야한다는 것입니다. 범용 N 차원 루프의 이러한 동작은 반복자 객체의 개념으로 추상화됩니다. N 차원 루프를 작성하려면 ndarray에서 반복자 오브젝트 만 작성하고 반복자 오브젝트 구조의 dataptr 멤버로 작업 한 후 반복자 오브젝트에서 매크로 &lt;a href=&quot;c-api.array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it)를 호출 하여 다음 요소로 이동하면됩니다. &quot;다음&quot;요소는 항상 C 연속 순서입니다. 이 매크로는 우선 C- 연속, 1-D 및 2-D 케이스를 특수 케이싱하여 매우 간단하게 작동합니다.</target>
        </trans-unit>
        <trans-unit id="7953bebd3c4d1f0aeb272423c5750e391178c282" translate="yes" xml:space="preserve">
          <source>A very common operation in much of NumPy code is the need to iterate over all the elements of a general, strided, N-dimensional array. This operation of a general-purpose N-dimensional loop is abstracted in the notion of an iterator object. To write an N-dimensional loop, you only have to create an iterator object from an ndarray, work with the dataptr member of the iterator object structure and call the macro &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; (it) on the iterator object to move to the next element. The &amp;ldquo;next&amp;rdquo; element is always in C-contiguous order. The macro works by first special casing the C-contiguous, 1-D, and 2-D cases which work very simply.</source>
          <target state="translated">NumPy 코드의 대부분에서 매우 일반적인 작업은 일반적인 strided N 차원 배열의 모든 요소를 ​​반복해야한다는 것입니다. 범용 N 차원 루프의이 작업은 반복기 객체의 개념으로 추상화됩니다. N 차원 루프를 작성하려면 ndarray에서 반복기 객체를 만들고 반복기 객체 구조의 dataptr 멤버로 작업하고 반복기 객체에서 매크로 &lt;a href=&quot;c-api/array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; (it)를 호출 하여 다음 요소로 이동하기 만하면 됩니다. &quot;다음&quot;요소는 항상 C 연속 순서입니다. 매크로는 매우 간단하게 작동하는 C-contiguous, 1-D 및 2-D 사례를 먼저 특수 케이스로 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2d293e5beee6d752c5e9563e11d78a171279a315" translate="yes" xml:space="preserve">
          <source>A view of &lt;code&gt;m&lt;/code&gt; with the columns reversed. Since a view is returned, this operation is</source>
          <target state="translated">열이 반전 된 &lt;code&gt;m&lt;/code&gt; 의보기 . 보기가 리턴되므로이 조작은</target>
        </trans-unit>
        <trans-unit id="66bdbd39fa3f528ae4cecafafda9e6501691569a" translate="yes" xml:space="preserve">
          <source>A view of &lt;code&gt;m&lt;/code&gt; with the entries of axis reversed. Since a view is returned, this operation is done in constant time.</source>
          <target state="translated">축 항목이 반전 된 &lt;code&gt;m&lt;/code&gt; 의보기입니다 . 보기가 리턴되므로이 조작은 일정한 시간에 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="248e57cd70b2bdbb1ce54ae0d4a6550da9299aaf" translate="yes" xml:space="preserve">
          <source>A view of &lt;code&gt;m&lt;/code&gt; with the rows reversed. Since a view is returned, this operation is</source>
          <target state="translated">행이 반전 된 &lt;code&gt;m&lt;/code&gt; 의보기입니다 . 보기가 리턴되므로이 조작은</target>
        </trans-unit>
        <trans-unit id="f51b7d94b5a97c50779fd88d4376e83b681ccdf5" translate="yes" xml:space="preserve">
          <source>A warning of class warning_class should be thrown by the callable when invoked with arguments args and keyword arguments kwargs. If a different type of warning is thrown, it will not be caught.</source>
          <target state="translated">인수 arrgs 및 키워드 인수 kwargs를 사용하여 호출 할 때 호출 가능 클래스에서 warning_class 클래스의 경고가 발생해야합니다. 다른 유형의 경고가 발생하면 포착되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="285a9d7315ee28bbe9a84fc12d68e6c194ff4508" translate="yes" xml:space="preserve">
          <source>A way to represent items in a N-dimensional array in the 1-dimensional computer memory. In column-major order, the leftmost index &amp;ldquo;varies the fastest&amp;rdquo;: for example the array:</source>
          <target state="translated">1 차원 컴퓨터 메모리에서 N 차원 배열의 항목을 나타내는 방법입니다. 열 우선 순서에서 가장 왼쪽 인덱스는 &quot;가장 빠르게 변함&quot;: 예를 들어 배열 :</target>
        </trans-unit>
        <trans-unit id="daea7045bd351ddce2006b62de41e4e4e92970b0" translate="yes" xml:space="preserve">
          <source>A way to represent items in a N-dimensional array in the 1-dimensional computer memory. In row-major order, the rightmost index &amp;ldquo;varies the fastest&amp;rdquo;: for example the array:</source>
          <target state="translated">1 차원 컴퓨터 메모리에서 N 차원 배열의 항목을 나타내는 방법입니다. 행 우선 순서에서 맨 오른쪽 인덱스는 &quot;가장 빠르게 변합니다&quot;(예 : 배열 :</target>
        </trans-unit>
        <trans-unit id="e38ea5df529a5503793c2e50ddf4e165eafd5e2a" translate="yes" xml:space="preserve">
          <source>A work-around is to use the &lt;code&gt;view()&lt;/code&gt; method to view the result as unsigned integers with the same bit width:</source>
          <target state="translated">해결 방법 은 &lt;code&gt;view()&lt;/code&gt; 메서드를 사용하여 결과를 동일한 비트 너비의 부호없는 정수로 보는 것입니다.</target>
        </trans-unit>
        <trans-unit id="9df196eb4a0b9faf17592583cd28b8a6aede74a1" translate="yes" xml:space="preserve">
          <source>A() (numpy.matrix property)</source>
          <target state="translated">A () (numpy.matrix 속성)</target>
        </trans-unit>
        <trans-unit id="539891caca13f6ce7a5508b45d4b8eb9a8155d5e" translate="yes" xml:space="preserve">
          <source>A. T. Benjamin, et al., &amp;ldquo;Combinatorial Trigonometry with Chebyshev Polynomials,&amp;rdquo; &lt;em&gt;Journal of Statistical Planning and Inference 14&lt;/em&gt;, 2008 (&lt;a href=&quot;https://web.archive.org/web/20080221202153/https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&quot;&gt;https://web.archive.org/web/20080221202153/https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&lt;/a&gt;, pg. 4)</source>
          <target state="translated">AT Benjamin, et al., &quot;Chebyshev Polynomials를 사용한 조합 삼각법&quot;, &lt;em&gt;Journal of Statistical Planning and Inference 14&lt;/em&gt; , 2008 ( &lt;a href=&quot;https://web.archive.org/web/20080221202153/https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&quot;&gt;https://web.archive.org/web/20080221202153/https://www.math.hmc.edu /~benjamin/papers/CombTrig.pdf&lt;/a&gt; , 4 페이지)</target>
        </trans-unit>
        <trans-unit id="e147b8f87d9785ccee0f5217b2b29d28af51a39e" translate="yes" xml:space="preserve">
          <source>A. T. Benjamin, et al., &amp;ldquo;Combinatorial Trigonometry with Chebyshev Polynomials,&amp;rdquo; &lt;em&gt;Journal of Statistical Planning and Inference 14&lt;/em&gt;, 2008 (preprint: &lt;a href=&quot;https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&quot;&gt;https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&lt;/a&gt;, pg. 4)</source>
          <target state="translated">AT Benjamin, et al.,&amp;ldquo;Chebyshev Polynomials를 사용한 조합 삼각법&amp;rdquo;, &lt;em&gt;Journal of Statistical Planning and Inference 14&lt;/em&gt; , 2008 (사전 인쇄 : &lt;a href=&quot;https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&quot;&gt;https://www.math.hmc.edu/~benjamin/papers/CombTrig.pdf&lt;/a&gt; , pg. 4)</target>
        </trans-unit>
        <trans-unit id="73fb89647e9cf799e65a16c0b2c72ed24fcc54ac" translate="yes" xml:space="preserve">
          <source>A.V. Oppenheim and R.W. Schafer, &amp;ldquo;Discrete-Time Signal Processing&amp;rdquo;, Prentice-Hall, 1999, pp. 468-471.</source>
          <target state="translated">AV Oppenheim 및 RW Schafer,&amp;ldquo;Discrete-Time Signal Processing&amp;rdquo;, Prentice-Hall, 1999, 468-471 페이지.</target>
        </trans-unit>
        <trans-unit id="0b970bacbaa93ce977fd2810127eff2b2d3794c2" translate="yes" xml:space="preserve">
          <source>A1() (numpy.matrix property)</source>
          <target state="translated">A1 () (numpy.matrix 속성)</target>
        </trans-unit>
        <trans-unit id="326b02bd6d0ebe2c9b8a795e1dfac3715a078d10" translate="yes" xml:space="preserve">
          <source>ABI incompatibility is automatically detected in every numpy&amp;rsquo;s version. API incompatibility detection was added in numpy 1.4.0. If you want to supported many different numpy versions with one extension binary, you have to build your extension with the lowest &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt;&lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt;&lt;/a&gt; as possible.</source>
          <target state="translated">ABI 비 호환성은 모든 numpy의 버전에서 자동으로 감지됩니다. API 비 호환성 감지는 numpy 1.4.0에 추가되었습니다. 하나의 확장 바이너리로 다양한 numpy 버전을 지원하려면 가능한 한 가장 낮은 &lt;a href=&quot;#c.NPY_FEATURE_VERSION&quot;&gt; &lt;code&gt;NPY_FEATURE_VERSION&lt;/code&gt; &lt;/a&gt; 으로 확장을 빌드해야 합니다.</target>
        </trans-unit>
        <trans-unit id="e333a8f5d6c832811356beeee9fce0dffa5d510b" translate="yes" xml:space="preserve">
          <source>ABI incompatibility is automatically detected in every numpy&amp;rsquo;s version. API incompatibility detection was added in numpy 1.4.0. If you want to supported many different numpy versions with one extension binary, you have to build your extension with the lowest NPY_FEATURE_VERSION as possible.</source>
          <target state="translated">모든 numpy 버전에서 ABI 비 호환성이 자동으로 감지됩니다. API 비 호환성 감지가 numpy 1.4.0에 추가되었습니다. 하나의 확장 이진을 사용하여 여러 가지 다른 numpy 버전을 지원하려면 가능한 한 가장 낮은 NPY_FEATURE_VERSION으로 확장을 빌드해야합니다.</target>
        </trans-unit>
        <trans-unit id="5995866cb7ff67106f4964a2376febd406b1609d" translate="yes" xml:space="preserve">
          <source>ALIGNED (A) the data and strides are aligned appropriately for the hardware (as determined by the compiler);</source>
          <target state="translated">ALIGNED (A) (컴파일러가 결정한대로) 데이터와 보폭이 하드웨어에 맞게 적절히 정렬됩니다.</target>
        </trans-unit>
        <trans-unit id="4304323acf2d8950ef646184d037e624bf247b5a" translate="yes" xml:space="preserve">
          <source>ALIGNED / A</source>
          <target state="translated">정렬 됨 / A</target>
        </trans-unit>
        <trans-unit id="c669e6d697ad4a42bc9b5d0d37cf73bc259d9578" translate="yes" xml:space="preserve">
          <source>ALIGNED and WRITEABLE.</source>
          <target state="translated">정렬 및 쓰기 가능</target>
        </trans-unit>
        <trans-unit id="f993136f3c88fcde984662580493081020efb4f2" translate="yes" xml:space="preserve">
          <source>ALIGNED can only be set &lt;code&gt;True&lt;/code&gt; if the data is truly aligned.</source>
          <target state="translated">ALIGNED는 데이터가 실제로 정렬 된 경우 에만 &lt;code&gt;True&lt;/code&gt; 로 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d93d10ff0fbef1b4aa0ddc24e10e907746d3c85a" translate="yes" xml:space="preserve">
          <source>API</source>
          <target state="translated">API</target>
        </trans-unit>
        <trans-unit id="4ca004ce1076234dbe61af69ea3047fa2374127c" translate="yes" xml:space="preserve">
          <source>API will change for Python 3.0!</source>
          <target state="translated">Python 3.0에서 API가 변경됩니다!</target>
        </trans-unit>
        <trans-unit id="c9a017ad68340db7a300791b542b3e47b53bab0d" translate="yes" xml:space="preserve">
          <source>ARM support updated</source>
          <target state="translated">ARM 지원 업데이트</target>
        </trans-unit>
        <trans-unit id="f831039f6aa812ccfca1eecca7ada1703e496314" translate="yes" xml:space="preserve">
          <source>ARMv7/A32 - CPU feature names</source>
          <target state="translated">ARMv7 / A32-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="e107c346719baa73a962eb147e8146974451ceed" translate="yes" xml:space="preserve">
          <source>ARMv8/A64 - CPU feature names</source>
          <target state="translated">ARMv8 / A64-CPU 기능 이름</target>
        </trans-unit>
        <trans-unit id="1459b245217132f67436c3c2641848e54c45be8c" translate="yes" xml:space="preserve">
          <source>ATLAS</source>
          <target state="translated">ATLAS</target>
        </trans-unit>
        <trans-unit id="6fb558a4b07c9e1ee54cbf57a5f6f92ab12c67b6" translate="yes" xml:space="preserve">
          <source>Ability to acknowledge their own funding sources on the NumPy websites, in talks and T-shirts.</source>
          <target state="translated">NumPy 웹 사이트, 대화 및 티셔츠에서 자신의 자금 출처를 인정할 수있는 능력.</target>
        </trans-unit>
        <trans-unit id="2d59025cc76059a9759025fd524514d76730b95f" translate="yes" xml:space="preserve">
          <source>Ability to disable madvise hugepages</source>
          <target state="translated">madvise hugepages 비활성화 기능</target>
        </trans-unit>
        <trans-unit id="b1a4bc2e52b8112444fd646123cf0dfd338cd42b" translate="yes" xml:space="preserve">
          <source>Ability to influence the project through the participation of their Council Member.</source>
          <target state="translated">자문위원의 참여를 통해 프로젝트에 영향을 미칠 수있는 능력.</target>
        </trans-unit>
        <trans-unit id="e2ae7aaaec17d37bc7290a6e91d950782a1a0701" translate="yes" xml:space="preserve">
          <source>Ability to pad rank-n arrays</source>
          <target state="translated">Rank-n 배열 채우기 기능</target>
        </trans-unit>
        <trans-unit id="88e4e2d2f4cfb621c3844a5b80ac5db07aeb847c" translate="yes" xml:space="preserve">
          <source>About NumPy</source>
          <target state="translated">NumPy 정보</target>
        </trans-unit>
        <trans-unit id="e8cea8d7a2b325eab608d42bf7827996afaccb69" translate="yes" xml:space="preserve">
          <source>About this documentation</source>
          <target state="translated">이 문서 정보</target>
        </trans-unit>
        <trans-unit id="97ec8580d4ae0d82a2150753bb70bdbc01a7704e" translate="yes" xml:space="preserve">
          <source>Abramowitz, M. and Stegun, I. A. (Eds.). &amp;ldquo;Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables, 9th printing,&amp;rdquo; New York: Dover, 1972.</source>
          <target state="translated">아브라모 위츠 (Mabramowitz), IA 및 스테 군 (Estes). 뉴욕 : 도버, 1972.&amp;ldquo;수식, 그래프, 수학 표가있는 수학적 함수 핸드북, 9 번째 인쇄.</target>
        </trans-unit>
        <trans-unit id="4e1f50a3f5352b9780a93248146f73d95f25a2f5" translate="yes" xml:space="preserve">
          <source>Abramowitz, M. and Stegun, I. A., &lt;em&gt;Handbook of Mathematical Functions&lt;/em&gt;, 10th printing, New York: Dover, 1964, pp. 79. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">IA, Abramowitz, M. and Stegun, &lt;em&gt;수학 함수 핸드북&lt;/em&gt; , 10 번째 인쇄, 뉴욕 : 도버, 1964, pp. 79. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="40e736856e2b97e31bab4e474e99a3cd42ea1797" translate="yes" xml:space="preserve">
          <source>Abramowitz, M. and Stegun, I. A., &lt;em&gt;Handbook of Mathematical Functions&lt;/em&gt;, 10th printing, New York: Dover, 1964, pp. 79ff. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</source>
          <target state="translated">IA, Abramowitz, M. and Stegun, &lt;em&gt;수학 함수 핸드북&lt;/em&gt; , 10 번째 인쇄, 뉴욕 : 도버, 1964, pp. 79ff. &lt;a href=&quot;http://www.math.sfu.ca/~cbm/aands/&quot;&gt;http://www.math.sfu.ca/~cbm/aands/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5666ea42d49d782693a26070b385ac789d6be60c" translate="yes" xml:space="preserve">
          <source>Absolute Beginners Tutorial</source>
          <target state="translated">절대 초보자 튜토리얼</target>
        </trans-unit>
        <trans-unit id="488d2c4b657647616a3102eb9b5a5d6f7bc1ef16" translate="yes" xml:space="preserve">
          <source>Absolute beginner's guide</source>
          <target state="translated">완전 초보자 가이드</target>
        </trans-unit>
        <trans-unit id="72be1abc9c41f18cb036851d094c7e5ee1691674" translate="yes" xml:space="preserve">
          <source>Absolute tolerance.</source>
          <target state="translated">절대 공차.</target>
        </trans-unit>
        <trans-unit id="38ef1ee54a653575269705dbdf26ea3643a0677d" translate="yes" xml:space="preserve">
          <source>Absolute tolerance. The absolute difference is equal to &lt;code&gt;atol&lt;/code&gt;. Default is 1e-8.</source>
          <target state="translated">절대 공차. 절대 차이는 &lt;code&gt;atol&lt;/code&gt; 과 같습니다 . 기본값은 1e-8입니다.</target>
        </trans-unit>
        <trans-unit id="f2b82fc5344b46b896168f341b2c8150deb1752e" translate="yes" xml:space="preserve">
          <source>Absolute values including &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt;&lt;code&gt;complex&lt;/code&gt;&lt;/a&gt; types.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/functions.html#complex&quot;&gt; &lt;code&gt;complex&lt;/code&gt; &lt;/a&gt; 유형을 포함한 절대 값</target>
        </trans-unit>
        <trans-unit id="975afb77a17099a273652740c50322176a7899c3" translate="yes" xml:space="preserve">
          <source>Abstract base class for seed sequences that can spawn.</source>
          <target state="translated">스폰 될 수있는 시드 시퀀스에 대한 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3a56b6f89460611cc544ed578033449602d74856" translate="yes" xml:space="preserve">
          <source>Abstract base class for seed sequences.</source>
          <target state="translated">시드 시퀀스에 대한 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="eb9fe395b30f668b3380721b7a5fc094808ed8ed" translate="yes" xml:space="preserve">
          <source>Abstract base class of all complex number scalar types that are made up of floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자로 구성된 모든 복소수 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="fc4bf9658d9a75ca1105b3bee4abecadacdd274d" translate="yes" xml:space="preserve">
          <source>Abstract base class of all floating-point scalar types.</source>
          <target state="translated">모든 부동 소수점 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="1d171c40437cb7a421dcd23d47d8710022dde780" translate="yes" xml:space="preserve">
          <source>Abstract base class of all integer scalar types.</source>
          <target state="translated">모든 정수 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="886578981c7d895286961e644e90fb9b20d1aaef" translate="yes" xml:space="preserve">
          <source>Abstract base class of all numeric scalar types with a (potentially) inexact representation of the values in its range, such as floating-point numbers.</source>
          <target state="translated">부동 소수점 숫자와 같이 해당 범위의 값이 (잠재적으로) 부정확 한 표현이있는 모든 숫자 형 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="e384894160e6a510bd7eb4ad54c21cd74b73224c" translate="yes" xml:space="preserve">
          <source>Abstract base class of all numeric scalar types.</source>
          <target state="translated">모든 숫자 형 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="7b684a091401b005ea18208051023e2760f7610b" translate="yes" xml:space="preserve">
          <source>Abstract base class of all scalar types without predefined length. The actual size of these types depends on the specific &lt;code&gt;np.dtype&lt;/code&gt; instantiation.</source>
          <target state="translated">미리 정의 된 길이가없는 모든 스칼라 유형의 추상 기본 클래스입니다. 이러한 유형의 실제 크기는 특정 &lt;code&gt;np.dtype&lt;/code&gt; 인스턴스화 에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="cd5b6c8e90c82a71d52d62e0bf04920ff75c25e2" translate="yes" xml:space="preserve">
          <source>Abstract base class of all signed integer scalar types.</source>
          <target state="translated">모든 부호있는 정수 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="a6479435be225736f20c98d887914dc57d0421f0" translate="yes" xml:space="preserve">
          <source>Abstract base class of all unsigned integer scalar types.</source>
          <target state="translated">모든 부호없는 정수 스칼라 유형의 추상 기본 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="3196c273438daba1ad73ce097f5d816bace5cf68" translate="yes" xml:space="preserve">
          <source>Accelerate (MacOS)</source>
          <target state="translated">가속 (MacOS)</target>
        </trans-unit>
        <trans-unit id="11199dced7040dff526146cf002d1ddea45d0837" translate="yes" xml:space="preserve">
          <source>Accelerated BLAS/LAPACK libraries</source>
          <target state="translated">가속화 된 BLAS / LAPACK 라이브러리</target>
        </trans-unit>
        <trans-unit id="bcb77f2711885dd2e0c1b501af744fd631f7962c" translate="yes" xml:space="preserve">
          <source>Accepts a boolean array which is broadcast together with the operands. Values of True indicate to calculate the ufunc at that position, values of False indicate to leave the value in the output alone. This argument cannot be used for generalized ufuncs as those take non-scalar input.</source>
          <target state="translated">피연산자와 함께 브로드 캐스트되는 부울 배열을 승인합니다. True 값은 해당 위치에서 ufunc를 계산 함을 나타내며 False 값은 출력만으로 값을 유지함을 나타냅니다. 스칼라가 아닌 입력을 사용하므로 일반 인수에는이 인수를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="7ff8ee5fd6920ddbc4707845c10dec516fb18e5f" translate="yes" xml:space="preserve">
          <source>Accepts any object as input, but always returns False unless the input is a MaskedArray containing masked values.</source>
          <target state="translated">객체를 입력으로 허용하지만 입력이 마스크 된 값을 포함하는 MaskedArray가 아닌 경우 항상 False를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="d7eafeaa5f92d0428891758cafdbada426336787" translate="yes" xml:space="preserve">
          <source>Access the values in a BitGenerator, convert them to &lt;code&gt;float64&lt;/code&gt; in the interval &lt;code&gt;[0.0.,&lt;/code&gt; `` 1.0)``. In addition to the &lt;code&gt;size&lt;/code&gt; kwarg, now supports &lt;code&gt;dtype='d'&lt;/code&gt; or &lt;code&gt;dtype='f'&lt;/code&gt;, and an &lt;code&gt;out&lt;/code&gt; kwarg to fill a user- supplied array.</source>
          <target state="translated">BitGenerator의 값에 액세스하여 간격 &lt;code&gt;[0.0.,&lt;/code&gt; ``1.0)`` 에서 &lt;code&gt;float64&lt;/code&gt; 로 변환 하십시오 . 또한받는 &lt;code&gt;size&lt;/code&gt; kwarg 현재 지원 &lt;code&gt;dtype='d'&lt;/code&gt; 또는 &lt;code&gt;dtype='f'&lt;/code&gt; AN, 및 &lt;code&gt;out&lt;/code&gt; 사용자 - 제공된 어레이를 채우기 위해 kwarg.</target>
        </trans-unit>
        <trans-unit id="46e4364f8d908ab983f4441dcd9d804db302fed1" translate="yes" xml:space="preserve">
          <source>Access to proprietary information of their employer that could potentially leak into their work with the Project.</source>
          <target state="translated">프로젝트 작업에 잠재적으로 유출 될 수있는 고용주의 독점 정보에 대한 액세스.</target>
        </trans-unit>
        <trans-unit id="5450fecbe2f49f1454935d6df12ccffe9a90bb18" translate="yes" xml:space="preserve">
          <source>Access to various distributions below is available via Cython or C-wrapper libraries like CFFI. All the functions accept a &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; as their first argument. To access these from Cython or C, you must link with the &lt;code&gt;npyrandom&lt;/code&gt; library which is part of the NumPy distribution, located in &lt;code&gt;numpy/random/lib&lt;/code&gt;.</source>
          <target state="translated">Cython 또는 CFFI와 같은 C- 래퍼 라이브러리를 통해 아래의 다양한 배포에 액세스 할 수 있습니다. 모든 함수 는 첫 번째 인수로 &lt;a href=&quot;#c.bitgen_t&quot;&gt; &lt;code&gt;bitgen_t&lt;/code&gt; &lt;/a&gt; 를받습니다. Cython 또는 C에서 액세스하려면 &lt;code&gt;numpy/random/lib&lt;/code&gt; 에있는 NumPy 배포의 일부인 &lt;code&gt;npyrandom&lt;/code&gt; 라이브러리 와 연결해야합니다 .</target>
        </trans-unit>
        <trans-unit id="f33392cdbb4719437624a90456eca44187bad68f" translate="yes" xml:space="preserve">
          <source>Access to various distributions is available via Cython or C-wrapper libraries like CFFI. All the functions accept a &lt;a href=&quot;#c.bitgen_t&quot;&gt;&lt;code&gt;bitgen_t&lt;/code&gt;&lt;/a&gt; as their first argument.</source>
          <target state="translated">Cython 또는 CFFI와 같은 C- 래퍼 라이브러리를 통해 다양한 배포에 액세스 할 수 있습니다. 모든 함수 는 첫 번째 인수로 &lt;a href=&quot;#c.bitgen_t&quot;&gt; &lt;code&gt;bitgen_t&lt;/code&gt; &lt;/a&gt; 를받습니다.</target>
        </trans-unit>
        <trans-unit id="7afa654ae42daf5589c60112d9c94d589e6f3f1d" translate="yes" xml:space="preserve">
          <source>Accessible via &lt;a href=&quot;array#c.PyArray_DATA&quot;&gt;&lt;code&gt;PyArray_DATA&lt;/code&gt;&lt;/a&gt;, this data member is a pointer to the first element of the array. This pointer can (and normally should) be recast to the data type of the array.</source>
          <target state="translated">&lt;a href=&quot;array#c.PyArray_DATA&quot;&gt; &lt;code&gt;PyArray_DATA&lt;/code&gt; &lt;/a&gt; 를 통해 액세스 할 수있는 이 데이터 멤버는 배열의 첫 번째 요소에 대한 포인터입니다. 이 포인터는 배열의 데이터 유형으로 다시 캐스팅 될 수 있습니다 (일반적으로 그래야합니다).</target>
        </trans-unit>
        <trans-unit id="963b10c79b437844743eff3670e03f7e724d2c1a" translate="yes" xml:space="preserve">
          <source>Accessing Individual Fields</source>
          <target state="translated">개별 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="bdb57c80e6a4a5c4c53cb7deb5b82727664010b0" translate="yes" xml:space="preserve">
          <source>Accessing Multiple Fields</source>
          <target state="translated">여러 필드에 액세스</target>
        </trans-unit>
        <trans-unit id="16c5166155700e6456d3ac7078b3466894c92ea9" translate="yes" xml:space="preserve">
          <source>Accessing a field of a masked array with structured datatype returns a &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt;&lt;code&gt;MaskedArray&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">구조화 된 데이터 유형으로 마스크 된 배열의 필드에 액세스하면 &lt;a href=&quot;maskedarray.baseclass#numpy.ma.MaskedArray&quot;&gt; &lt;code&gt;MaskedArray&lt;/code&gt; 가&lt;/a&gt; 리턴 됩니다 .</target>
        </trans-unit>
        <trans-unit id="ad44652f541aceec356fa1b8d890a83b5e7dc497" translate="yes" xml:space="preserve">
          <source>Accessing a mask</source>
          <target state="translated">마스크에 액세스</target>
        </trans-unit>
        <trans-unit id="1ae3364beb66b0f5f244cd535829f92651c28eaf" translate="yes" xml:space="preserve">
          <source>Accessing only the valid entries</source>
          <target state="translated">유효한 항목 만 액세스</target>
        </trans-unit>
        <trans-unit id="097badc57289f74986291250ca0d50ffba8b6adb" translate="yes" xml:space="preserve">
          <source>Accessing the BitGenerator</source>
          <target state="translated">BitGenerator에 액세스</target>
        </trans-unit>
        <trans-unit id="b9cea573b7dc8cfac38c95967f1d0a9124dc54f0" translate="yes" xml:space="preserve">
          <source>Accessing the data</source>
          <target state="translated">데이터에 액세스</target>
        </trans-unit>
        <trans-unit id="5c56508764b810016753b53da256711e1fc59c95" translate="yes" xml:space="preserve">
          <source>Accessing the mask</source>
          <target state="translated">마스크에 액세스</target>
        </trans-unit>
        <trans-unit id="2444770b8ea0a7f5ab0c34a322154eaab7c51273" translate="yes" xml:space="preserve">
          <source>Accumulate</source>
          <target state="translated">Accumulate</target>
        </trans-unit>
        <trans-unit id="22b15212c762693681b9a14af1311471df5ef0ae" translate="yes" xml:space="preserve">
          <source>Accumulate along axis 0 (rows), down columns:</source>
          <target state="translated">축 0 (행)을 따라 아래로 열을 누적합니다.</target>
        </trans-unit>
        <trans-unit id="c5dbcb1067a3510dbd548c0a2abcca4e50a8d0fa" translate="yes" xml:space="preserve">
          <source>Accumulate along axis 1 (columns), through rows:</source>
          <target state="translated">행을 통해 축 1 (열)을 따라 누적합니다.</target>
        </trans-unit>
        <trans-unit id="b9d21cbdbf197dfdab9c0eb8a5bda1ff0c8fa94a" translate="yes" xml:space="preserve">
          <source>Accumulate the result of applying the operator to all elements.</source>
          <target state="translated">연산자를 모든 요소에 적용한 결과를 누적하십시오.</target>
        </trans-unit>
        <trans-unit id="844eeaa03b150d61a1dec94b193e6b5d08629643" translate="yes" xml:space="preserve">
          <source>Acknowledgement on the NumPy websites, in talks and T-shirts.</source>
          <target state="translated">NumPy 웹 사이트, 회담 및 티셔츠에 대한 감사의 말.</target>
        </trans-unit>
        <trans-unit id="b0ebcfe59f276beb7f6238d812ac61ce48d3d9c0" translate="yes" xml:space="preserve">
          <source>Acknowledgements</source>
          <target state="translated">Acknowledgements</target>
        </trans-unit>
        <trans-unit id="31ff49fa2a3d36710d217dfe85bcc7762d3f75c1" translate="yes" xml:space="preserve">
          <source>Act in a personal manner rather than impersonal. The Committee can engage the parties to understand the situation, while respecting the privacy and any necessary confidentiality of reporters. However, sometimes it is necessary to communicate with one or more individuals directly: the Committee&amp;rsquo;s goal is to improve the health of our community rather than only produce a formal decision.</source>
          <target state="translated">비인격 적이기보다는 개인적인 방식으로 행동하십시오. 위원회는 당사자들이 상황을 이해하도록 참여시키는 한편, 기자의 사생활과 필요한 모든 기밀을 존중합니다. 그러나 때로는 한 명 이상의 개인과 직접 소통 할 필요가 있습니다.위원회의 목표는 공식적인 결정 만 내리는 것이 아니라 지역 사회의 건강을 개선하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="87027afe8e11221fd277eedf54dfc7a529e08117" translate="yes" xml:space="preserve">
          <source>Active Contribution</source>
          <target state="translated">적극적인 기여</target>
        </trans-unit>
        <trans-unit id="aa2ea3cd76ddce3cf06fbf3bce969151533e5b38" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;--f2cmap&lt;/code&gt; option to F2PY</source>
          <target state="translated">&lt;code&gt;--f2cmap&lt;/code&gt; 옵션 추가</target>
        </trans-unit>
        <trans-unit id="749a58c47a8dd0cc292c38c0a634def341d0ed8f" translate="yes" xml:space="preserve">
          <source>Add &lt;code&gt;axis&lt;/code&gt; argument for &lt;code&gt;random.permutation&lt;/code&gt; and &lt;code&gt;random.shuffle&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;random.permutation&lt;/code&gt; 및 &lt;code&gt;random.shuffle&lt;/code&gt; 에 대한 &lt;code&gt;axis&lt;/code&gt; 인수 추가</target>
        </trans-unit>
        <trans-unit id="b8403958021dde40e72e13864dbc8b3f72e0eefe" translate="yes" xml:space="preserve">
          <source>Add NumPy declarations for Cython 3.0 and later</source>
          <target state="translated">Cython 3.0 이상에 대한 NumPy 선언 추가</target>
        </trans-unit>
        <trans-unit id="4370e4e5b7bbb232b4f4d48ccc718302bf70924f" translate="yes" xml:space="preserve">
          <source>Add a CPP &lt;code&gt;#include&lt;/code&gt; statement to the extension module source. &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt; should be given in one of the following forms:</source>
          <target state="translated">확장 모듈 소스에 CPP &lt;code&gt;#include&lt;/code&gt; 문을 추가합니다 . &lt;code&gt;&amp;lt;includefile&amp;gt;&lt;/code&gt; 은 다음 형식 중 하나로 제공되어야합니다.</target>
        </trans-unit>
        <trans-unit id="56ced59b1ab2a27a1e28eb186c93bb18811d3b07" translate="yes" xml:space="preserve">
          <source>Add a new suppressing filter or apply it if the state is entered.</source>
          <target state="translated">새 억제 필터를 추가하거나 상태가 입력되면 적용하십시오.</target>
        </trans-unit>
        <trans-unit id="d043d90a01e9bb2a87e33e05fa61ed3580fe178f" translate="yes" xml:space="preserve">
          <source>Add a sub-package to the current Configuration instance.</source>
          <target state="translated">현재 구성 인스턴스에 하위 패키지를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="a9f6e016bc697e252d23d45724a67632f941a1b2" translate="yes" xml:space="preserve">
          <source>Add an &lt;code&gt;endpoint&lt;/code&gt; kwarg</source>
          <target state="translated">&lt;code&gt;endpoint&lt;/code&gt; kwarg 추가</target>
        </trans-unit>
        <trans-unit id="9f956ed6209cd99585bc85bb720e2d7310513e80" translate="yes" xml:space="preserve">
          <source>Add another &lt;code&gt;REL&lt;/code&gt; commit to the numpy maintenance branch, which resets the &lt;code&gt;ISREALEASED&lt;/code&gt; flag to &lt;code&gt;False&lt;/code&gt; and increments the version counter:</source>
          <target state="translated">&lt;code&gt;ISREALEASED&lt;/code&gt; 플래그를 &lt;code&gt;False&lt;/code&gt; 로 재설정 하고 버전 카운터를 증가시키는 다른 &lt;code&gt;REL&lt;/code&gt; 커밋을 numpy 유지 관리 분기에 추가 합니다 .</target>
        </trans-unit>
        <trans-unit id="172bd14aa4230b0564de31fe6a966e3fb7e443b7" translate="yes" xml:space="preserve">
          <source>Add any relevant modified or new files using &lt;code&gt;git add modified_file&lt;/code&gt; (see &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-add.html&quot;&gt;git add&lt;/a&gt;). This puts the files into a staging area, which is a queue of files that will be added to your next commit. Only add files that have related, complete changes. Leave files with unfinished changes for later commits.</source>
          <target state="translated">&lt;code&gt;git add modified_file&lt;/code&gt; 을 사용하여 관련 수정 또는 새 파일을 추가합니다 ( &lt;a href=&quot;https://www.kernel.org/pub/software/scm/git/docs/git-add.html&quot;&gt;git add&lt;/a&gt; 참조 ). 그러면 다음 커밋에 추가 될 파일 큐인 스테이징 영역에 파일이 저장됩니다. 관련된 완전한 변경 사항이있는 파일 만 추가하십시오. 나중에 커밋 할 수 있도록 완료되지 않은 변경 사항이있는 파일을 남겨 둡니다.</target>
        </trans-unit>
        <trans-unit id="519a7255bd3f55d1b7e212ac3f5b0f7f59ed48fd" translate="yes" xml:space="preserve">
          <source>Add arguments element-wise.</source>
          <target state="translated">요소별로 인수를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="cb0920fa450263e851b43ed7155e1089200b8db1" translate="yes" xml:space="preserve">
          <source>Add complex number support for &lt;code&gt;numpy.fromfile&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.fromfile&lt;/code&gt; 에 대한 복소수 지원 추가</target>
        </trans-unit>
        <trans-unit id="50b3692c36c19643f3b6826c502d20cb873a00b6" translate="yes" xml:space="preserve">
          <source>Add complex number support for &lt;code&gt;numpy.fromstring&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;numpy.fromstring&lt;/code&gt; 에 대한 복소수 지원 추가</target>
        </trans-unit>
        <trans-unit id="cf5ce0052c3cb14c88808808de75ffbd43bea0ed" translate="yes" xml:space="preserve">
          <source>Add data files to configuration data_files.</source>
          <target state="translated">구성 데이터 _ 파일에 데이터 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="183f96ee73e13f3bf92ac869adb47cd5569f51bb" translate="yes" xml:space="preserve">
          <source>Add debugging hooks to the extension module. When using this extension module, various information about the wrapper is printed to standard output, for example, the values of variables, the steps taken, etc.</source>
          <target state="translated">확장 모듈에 디버깅 후크를 추가합니다. 이 확장 모듈을 사용하면 래퍼에 대한 다양한 정보 (예 : 변수 값, 수행 한 단계 등)가 표준 출력에 인쇄됩니다.</target>
        </trans-unit>
        <trans-unit id="0bf1db6c64e3d637dcfd111519ca8c0cba0474f8" translate="yes" xml:space="preserve">
          <source>Add directory &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; to the list of directories to be searched for &lt;code&gt;-l&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;-l&lt;/code&gt; 을 검색 할 디렉토리 목록에 &lt;code&gt;&amp;lt;dir&amp;gt;&lt;/code&gt; 디렉토리를 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="974de5ada8253a5d4e9c975a8b5b2b2cc87bc9f2" translate="yes" xml:space="preserve">
          <source>Add extension to configuration.</source>
          <target state="translated">구성에 확장을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="b24e0797845ace332ac782f3100ed9496873f75c" translate="yes" xml:space="preserve">
          <source>Add files to the list of data_files to be included with the package.</source>
          <target state="translated">패키지에 포함 할 data_file 목록에 파일을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="de9c92ff48ec1f448d3de3a6ce6737feb051d5a9" translate="yes" xml:space="preserve">
          <source>Add helpful details for newcomers (&amp;ldquo;Hayseed Road&amp;rdquo;, even though it&amp;rsquo;s the only turnoff at three km/mi). But not irrelevant ones:</source>
          <target state="translated">신규 이민자에게 유용한 세부 정보를 추가합니다 (&amp;ldquo;Hayseed Road&amp;rdquo;가 3km / mi에서 유일한 분기점 임에도 불구하고). 그러나 관련이없는 것 :</target>
        </trans-unit>
        <trans-unit id="ec6d39fc613a2412b3149971ccc3066ea668ccca" translate="yes" xml:space="preserve">
          <source>Add installable headers to configuration.</source>
          <target state="translated">설치 가능한 헤더를 구성에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="192c191f7a03fc113ffda7fc0311b90dbf55dc23" translate="yes" xml:space="preserve">
          <source>Add items 0 and 1 in first array to second array, and store results in first array:</source>
          <target state="translated">첫 번째 배열의 항목 0과 1을 두 번째 배열에 추가하고 결과를 첫 번째 배열에 저장하십시오.</target>
        </trans-unit>
        <trans-unit id="42403b1e1d797b817002a948120252be5c28e7af" translate="yes" xml:space="preserve">
          <source>Add library to configuration.</source>
          <target state="translated">구성에 라이브러리를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d1dfd748a6e3ff92f6edfebfaf877b6caf59740c" translate="yes" xml:space="preserve">
          <source>Add more ufunc loops for &lt;code&gt;datetime64&lt;/code&gt;, &lt;code&gt;timedelta64&lt;/code&gt;</source>
          <target state="translated">더 많은 ufunc 루프를 추가 &lt;code&gt;datetime64&lt;/code&gt; , &lt;code&gt;timedelta64&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="19de96cbe2d4b3fa04504d8bde35329ce18443b1" translate="yes" xml:space="preserve">
          <source>Add new fields to an existing array.</source>
          <target state="translated">기존 배열에 새 필드를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="5b7fe78c0d04c481a155a2de8a41f3881621e224" translate="yes" xml:space="preserve">
          <source>Add new release notes to the documentation release list:</source>
          <target state="translated">문서 릴리스 목록에 새 릴리스 정보를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="d2f20ffde813ddf49b70fa6579528381531956ef" translate="yes" xml:space="preserve">
          <source>Add one Chebyshev series to another.</source>
          <target state="translated">하나의 체비 쇼프 시리즈를 다른 것에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="fd817ff95924ec8272d634ce0e8ab2243af60b54" translate="yes" xml:space="preserve">
          <source>Add one Hermite series to another.</source>
          <target state="translated">Hermite 시리즈를 다른 시리즈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0b8b661c7b6f0c6c875176dc938142703c034819" translate="yes" xml:space="preserve">
          <source>Add one Laguerre series to another.</source>
          <target state="translated">하나의 Laguerre 시리즈를 다른 시리즈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="93d32b5903dcfaf0d99ed0343cee2fd7fd1ebf6a" translate="yes" xml:space="preserve">
          <source>Add one Legendre series to another.</source>
          <target state="translated">하나의 Legendre 시리즈를 다른 시리즈에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0d912f77007b5acc37a22e3054240ae70a3da350" translate="yes" xml:space="preserve">
          <source>Add one polynomial to another.</source>
          <target state="translated">하나의 다항식을 다른 다항식에 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="73402d691bbf690c620406d2bfd9dcbfbc5cb4b0" translate="yes" xml:space="preserve">
          <source>Add options to quiet build configuration and build with &lt;code&gt;-Werror&lt;/code&gt;</source>
          <target state="translated">자동 빌드 구성에 옵션 추가 및 &lt;code&gt;-Werror&lt;/code&gt; 로 빌드</target>
        </trans-unit>
        <trans-unit id="8041fb737a2e0a0d3f536fb0552a96a43ffb7877" translate="yes" xml:space="preserve">
          <source>Add other to self in-place.</source>
          <target state="translated">제자리에 다른 사람을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="f6d36d753b402c69d5e17a3850443960310aff1c" translate="yes" xml:space="preserve">
          <source>Add other to self, and return a new masked array.</source>
          <target state="translated">self에 other를 추가하고 새로운 마스크 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="67ed9f18f2b9b6c49a507bbf14619c0eb79b4e1c" translate="yes" xml:space="preserve">
          <source>Add our own &lt;code&gt;*.pxd&lt;/code&gt; cython import file</source>
          <target state="translated">자체 &lt;code&gt;*.pxd&lt;/code&gt; cython 가져 오기 파일 추가</target>
        </trans-unit>
        <trans-unit id="38367eda00cb06221a825ac891db31d4b74dcd00" translate="yes" xml:space="preserve">
          <source>Add padding to the fields to match what a C compiler would output for a similar C-struct. Can be &lt;code&gt;True&lt;/code&gt; only if &lt;code&gt;obj&lt;/code&gt; is a dictionary or a comma-separated string. If a struct dtype is being created, this also sets a sticky alignment flag &lt;code&gt;isalignedstruct&lt;/code&gt;.</source>
          <target state="translated">C 컴파일러가 비슷한 C-struct에 대해 출력하는 것과 일치하도록 필드에 패딩을 추가하십시오. &lt;code&gt;obj&lt;/code&gt; 가 사전 또는 쉼표로 구분 된 문자열 인 경우에만 &lt;code&gt;True&lt;/code&gt; 일 수 있습니다 . struct dtype이 작성되는 경우 고정 정렬 플래그 &lt;code&gt;isalignedstruct&lt;/code&gt; 도 설정 됩니다.</target>
        </trans-unit>
        <trans-unit id="eeb521c915ba75bbea5f83fd82b92d84dd986501" translate="yes" xml:space="preserve">
          <source>Add paths to configuration include directories.</source>
          <target state="translated">구성 포함 디렉토리를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="0967ccc52cda50cec6242dcae20e3e663f6b35ba" translate="yes" xml:space="preserve">
          <source>Add scripts to configuration.</source>
          <target state="translated">구성에 스크립트를 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="3dd9e8736f2494a49ed757670af12e62654adc57" translate="yes" xml:space="preserve">
          <source>Add self to other, and return a new masked array.</source>
          <target state="translated">자기 자신을 다른 사람에게 추가하고 새로운 마스크 배열을 반환하십시오.</target>
        </trans-unit>
        <trans-unit id="867e6fef453e3af448d8c2735af394c1c3900828" translate="yes" xml:space="preserve">
          <source>Add the given sequence of files to the beginning of the headers list. By default, headers will be installed under &amp;lt;python- include&amp;gt;/&amp;lt;self.name.replace(&amp;lsquo;.&amp;rsquo;,&amp;rsquo;/&amp;rsquo;)&amp;gt;/ directory. If an item of files is a tuple, then its first argument specifies the actual installation location relative to the &amp;lt;python-include&amp;gt; path.</source>
          <target state="translated">주어진 파일 시퀀스를 헤더 목록의 시작 부분에 추가하십시오. 기본적으로 헤더는 &amp;lt;python-include&amp;gt; / &amp;lt;self.name.replace ( '.', '/')&amp;gt; / 디렉토리에 설치됩니다. 파일 항목이 튜플 인 경우 첫 번째 인수는 &amp;lt;python-include&amp;gt; 경로를 기준으로 실제 설치 위치를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="12793661dc735a50f73c70cbbe55f373e9453216" translate="yes" xml:space="preserve">
          <source>Add the given sequence of paths to the beginning of the include_dirs list. This list will be visible to all extension modules of the current package.</source>
          <target state="translated">주어진 경로 순서를 include_dirs 목록의 시작 부분에 추가하십시오. 이 목록은 현재 패키지의 모든 확장 모듈에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="e621d32dc1acbceb0f631d5058189d13dfa7e90e" translate="yes" xml:space="preserve">
          <source>Add the sequence of files to the beginning of the scripts list. Scripts will be installed under the &amp;lt;prefix&amp;gt;/bin/ directory.</source>
          <target state="translated">스크립트 목록의 시작 부분에 파일 시퀀스를 추가하십시오. 스크립트는 &amp;lt;prefix&amp;gt; / bin / 디렉토리에 설치됩니다.</target>
        </trans-unit>
        <trans-unit id="5697ae8fd006e560c4fa78bfff9101ae272744d4" translate="yes" xml:space="preserve">
          <source>Add the upstream repository:</source>
          <target state="translated">업스트림 저장소를 추가합니다.</target>
        </trans-unit>
        <trans-unit id="b2053e237d1b39ed2a55606928e6ab390939f27e" translate="yes" xml:space="preserve">
          <source>Added Support</source>
          <target state="translated">추가 된 지원</target>
        </trans-unit>
        <trans-unit id="2f1cf6cab2980b1934b9fc8b7e4e15ffc7a86fa0" translate="yes" xml:space="preserve">
          <source>Added in API version 0x0000000D</source>
          <target state="translated">API 버전 0x0000000D에서 추가됨</target>
        </trans-unit>
        <trans-unit id="2e363efb6a62f825b55e45a4c27ae9d8e6d08be0" translate="yes" xml:space="preserve">
          <source>Added the &lt;code&gt;optimize&lt;/code&gt; argument which will optimize the contraction order of an einsum expression. For a contraction with three or more operands this can greatly increase the computational efficiency at the cost of a larger memory footprint during computation.</source>
          <target state="translated">einsum 표현식의 수축 순서를 최적화 하는 &lt;code&gt;optimize&lt;/code&gt; 인수를 추가했습니다 . 피연산자가 3 개 이상인 수축의 경우 계산 중에 메모리 공간이 많이 소모되어 계산 효율성이 크게 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad5cc68af97702d37f636fcf82a8110d0c8c61d1" translate="yes" xml:space="preserve">
          <source>Adding &lt;code&gt;-1&lt;/code&gt; to missing data is not a problem with &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt;; in this particular case, substituting the missing value with &lt;code&gt;0&lt;/code&gt; might have been fine, but we&amp;rsquo;ll see later that this is far from a general solution. Also, it is possible to call the &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; function using the &lt;code&gt;usemask&lt;/code&gt; parameter. If &lt;code&gt;usemask=True&lt;/code&gt;, &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; automatically returns a masked array.</source>
          <target state="translated">누락 된 데이터에 &lt;code&gt;-1&lt;/code&gt; 을 추가 하는 것은 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt; 의 문제가 아닙니다 . 이 특별한 경우에는 누락 된 값을 &lt;code&gt;0&lt;/code&gt; 으로 대체하는 것이 좋지만 나중에 이것이 일반적인 솔루션과는 거리가 멀다는 것을 알게 될 것입니다. 또한 &lt;code&gt;usemask&lt;/code&gt; 매개 변수를 사용하여 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt; 함수 를 호출 할 수 있습니다 . 경우 &lt;code&gt;usemask=True&lt;/code&gt; , &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; 는&lt;/a&gt; 자동으로 마스크 배열을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="1190df5112112b0d1382beaeaf5f8e64d6c7c049" translate="yes" xml:space="preserve">
          <source>Adding and removing elements</source>
          <target state="translated">요소 추가 및 제거</target>
        </trans-unit>
        <trans-unit id="c1384e951912ddff50db4d4a2e9cf7e21631086d" translate="yes" xml:space="preserve">
          <source>Adding arrays with identical datatypes currently preserves the metadata:</source>
          <target state="translated">데이터 유형이 동일한 배열을 추가하면 현재 메타 데이터가 보존됩니다.</target>
        </trans-unit>
        <trans-unit id="8b54f7832c99a271681bb0f8b856a0654cbc5037" translate="yes" xml:space="preserve">
          <source>Adding self-written functions to F2PY generated modules</source>
          <target state="translated">F2PY 생성 모듈에 자체 작성 함수 추가</target>
        </trans-unit>
        <trans-unit id="4621824a58175000e5dba0d2e77fe3e5f3ec70c6" translate="yes" xml:space="preserve">
          <source>Adding the NumPy include directory is, of course, only necessary if you are using NumPy arrays in the extension module (which is what we assume you are using Cython for). The distutils extensions in NumPy also include support for automatically producing the extension-module and linking it from a &lt;code&gt;.pyx&lt;/code&gt; file. It works so that if the user does not have Cython installed, then it looks for a file with the same file-name but a &lt;code&gt;.c&lt;/code&gt; extension which it then uses instead of trying to produce the &lt;code&gt;.c&lt;/code&gt; file again.</source>
          <target state="translated">물론 NumPy include 디렉토리를 추가하는 것은 확장 모듈에서 NumPy 배열을 사용하는 경우에만 필요합니다 (Cython을 사용한다고 가정합니다). NumPy의 distutils 확장에는 확장 모듈을 자동으로 생성하고 &lt;code&gt;.pyx&lt;/code&gt; 파일 에서 연결하는 지원도 포함 됩니다. 사용자가 Cython을 설치하지 않은 경우 파일 이름이 같지만 &lt;code&gt;.c&lt;/code&gt; 확장자 를 가진 파일을 찾은 다음 &lt;code&gt;.c&lt;/code&gt; 파일을 다시 생성하는 대신 사용하도록 작동 합니다.</target>
        </trans-unit>
        <trans-unit id="4b71895b23af2e6dac13ac1dabde5dfa97ef31a6" translate="yes" xml:space="preserve">
          <source>Adding the following:</source>
          <target state="translated">다음을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="1a1f79e4f6a891b31604f6ea4c404a7e6fa73442" translate="yes" xml:space="preserve">
          <source>Adding the new data-type</source>
          <target state="translated">새 데이터 유형 추가</target>
        </trans-unit>
        <trans-unit id="4824b090270ada949083d342d40990d88b7df270" translate="yes" xml:space="preserve">
          <source>Adding, removing, and sorting elements</source>
          <target state="translated">요소 추가, 제거 및 정렬</target>
        </trans-unit>
        <trans-unit id="32ceef7d48b3859f43536940686eb939e0f9e4ac" translate="yes" xml:space="preserve">
          <source>Addition and Subtraction:</source>
          <target state="translated">더하기와 빼기 :</target>
        </trans-unit>
        <trans-unit id="22bd32fa29554a353014e46723283f5f4bc31a97" translate="yes" xml:space="preserve">
          <source>Additional Git Resources</source>
          <target state="translated">추가 Git 리소스</target>
        </trans-unit>
        <trans-unit id="943ad27e8678913fe7eb228609bd2761433c8790" translate="yes" xml:space="preserve">
          <source>Additional PEPs of interest regarding documentation of code:</source>
          <target state="translated">코드 문서화와 관련된 추가 PEP :</target>
        </trans-unit>
        <trans-unit id="2e979316df7e66e1ac30d87235c1730e8f93451f" translate="yes" xml:space="preserve">
          <source>Additional arguments to &lt;code&gt;func1d&lt;/code&gt;.</source>
          <target state="translated">에 추가 인수 &lt;code&gt;func1d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0653feeb476220c2b8cc0d61fa9d5c2a3e3d87eb" translate="yes" xml:space="preserve">
          <source>Additional compiler flags can be supplied by setting the &lt;code&gt;OPT&lt;/code&gt;, &lt;code&gt;FOPT&lt;/code&gt; (for Fortran), and &lt;code&gt;CC&lt;/code&gt; environment variables. When providing options that should improve the performance of the code ensure that you also set &lt;code&gt;-DNDEBUG&lt;/code&gt; so that debugging code is not executed.</source>
          <target state="translated">&lt;code&gt;OPT&lt;/code&gt; , &lt;code&gt;FOPT&lt;/code&gt; (Fortran 용) 및 &lt;code&gt;CC&lt;/code&gt; 환경 변수 를 설정하여 추가 컴파일러 플래그를 제공 할 수 있습니다 . 코드 성능을 향상시켜야하는 옵션을 제공 할 때 디버깅 코드가 실행되지 않도록 &lt;code&gt;-DNDEBUG&lt;/code&gt; 도 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="68a981e7b29ec99e7c56c4183712362f5fbf6baa" translate="yes" xml:space="preserve">
          <source>Additional explanation of the deprecation. Displayed in the docstring after the warning.</source>
          <target state="translated">지원 중단에 대한 추가 설명입니다. 경고 후 독 스트링에 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="2f33c64b8e45a0b559c62344568b319008aa4e48" translate="yes" xml:space="preserve">
          <source>Additional named arguments to &lt;code&gt;func1d&lt;/code&gt;.</source>
          <target state="translated">에 추가로 명명 된 인수 &lt;code&gt;func1d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f72fdd362bc25072f22f9fddd447c271e3cf745d" translate="yes" xml:space="preserve">
          <source>Additional options to F2PY process can be given using &lt;a href=&quot;../reference/generated/numpy.distutils.core.extension#numpy.distutils.core.Extension&quot;&gt;&lt;code&gt;Extension&lt;/code&gt;&lt;/a&gt; class argument &lt;code&gt;f2py_options&lt;/code&gt;.</source>
          <target state="translated">F2PY 프로세스에 대한 추가 옵션은 &lt;a href=&quot;../reference/generated/numpy.distutils.core.extension#numpy.distutils.core.Extension&quot;&gt; &lt;code&gt;Extension&lt;/code&gt; &lt;/a&gt; 클래스 인수 &lt;code&gt;f2py_options&lt;/code&gt; 를 사용하여 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="16061f32da099969910de77a21ac334b7294cb1c" translate="yes" xml:space="preserve">
          <source>Additional options to F2PY process can be given using &lt;code&gt;Extension&lt;/code&gt; class argument &lt;code&gt;f2py_options&lt;/code&gt;.</source>
          <target state="translated">F2PY 프로세스에 대한 추가 옵션은 &lt;code&gt;Extension&lt;/code&gt; 클래스 인수 &lt;code&gt;f2py_options&lt;/code&gt; 를 사용하여 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="8360099c899f3d900441aaafde42126fd18c8863" translate="yes" xml:space="preserve">
          <source>Additional parameters passed to f2py</source>
          <target state="translated">f2py에 전달 된 추가 매개 변수</target>
        </trans-unit>
        <trans-unit id="8f7e4fc57a96ab242b4632ad20c4e828c8034419" translate="yes" xml:space="preserve">
          <source>Additional things you might want to do</source>
          <target state="translated">할 수있는 추가 작업</target>
        </trans-unit>
        <trans-unit id="3b93cbfe8c1c407afb6b3fd42b149622884bc056" translate="yes" xml:space="preserve">
          <source>Additional tools you may find useful</source>
          <target state="translated">유용 할 수있는 추가 도구</target>
        </trans-unit>
        <trans-unit id="b252a7a9b6c6c45a4e9286771ebe97b99f918e68" translate="yes" xml:space="preserve">
          <source>Additionally, for a 2D array, &lt;code&gt;tolist&lt;/code&gt; applies recursively:</source>
          <target state="translated">또한 2D 배열의 경우 &lt;code&gt;tolist&lt;/code&gt; 는 재귀 적으로 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="77eeb47ff400756f1cc853a603bed516744ec8be" translate="yes" xml:space="preserve">
          <source>Additionally, our implementations of &lt;code&gt;sum&lt;/code&gt; and &lt;code&gt;mean&lt;/code&gt; do not accept the optional arguments that numpy&amp;rsquo;s implementation does.</source>
          <target state="translated">또한 &lt;code&gt;sum&lt;/code&gt; 및 &lt;code&gt;mean&lt;/code&gt; 구현은 numpy의 구현이 수행하는 선택적 인수를 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="1b6f855c96ea61fde07e7f6094fffb0063607dcd" translate="yes" xml:space="preserve">
          <source>Adjusts the iterator to point to the &lt;code&gt;index&lt;/code&gt; specified. If the iterator was constructed with the flag &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;index&lt;/code&gt; is the C-order index, and if the iterator was constructed with the flag &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt;&lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;index&lt;/code&gt; is the Fortran-order index. Returns an error if there is no index being tracked, the index is out of bounds, or inner loop iteration is disabled.</source>
          <target state="translated">지정된 &lt;code&gt;index&lt;/code&gt; 을 가리 키도록 반복자를 조정 합니다. 반복기가 &lt;a href=&quot;#c.NPY_ITER_C_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_C_INDEX&lt;/code&gt; &lt;/a&gt; 플래그로 구성된 경우 &lt;code&gt;index&lt;/code&gt; 는 C 순서 인덱스이고 반복자가 플래그 &lt;a href=&quot;#c.NPY_ITER_F_INDEX&quot;&gt; &lt;code&gt;NPY_ITER_F_INDEX&lt;/code&gt; 로 구성된&lt;/a&gt; 경우 &lt;code&gt;index&lt;/code&gt; 는 포트란 순서 인덱스입니다. 추적중인 인덱스가 없거나 인덱스가 범위를 벗어 났거나 내부 루프 반복이 비활성화 된 경우 오류를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c53e871abed99db7c60f0e6f2c2a24b11cc57547" translate="yes" xml:space="preserve">
          <source>Adjusts the iterator to point to the &lt;code&gt;iterindex&lt;/code&gt; specified. The IterIndex is an index matching the iteration order of the iterator. Returns an error if the &lt;code&gt;iterindex&lt;/code&gt; is out of bounds, buffering is enabled, or inner loop iteration is disabled.</source>
          <target state="translated">지정된 &lt;code&gt;iterindex&lt;/code&gt; 를 가리 키도록 반복자를 조정 합니다. IterIndex는 반복자의 반복 순서와 일치하는 색인입니다. &lt;code&gt;iterindex&lt;/code&gt; 가 범위를 벗어 났 거나 버퍼링이 사용 가능하거나 내부 루프 반복이 사용 불가능한 경우 오류를 리턴합니다 .</target>
        </trans-unit>
        <trans-unit id="a44fa8caa936143e610fe1aa66906556f9b4b048" translate="yes" xml:space="preserve">
          <source>Adjusts the iterator to point to the &lt;code&gt;ndim&lt;/code&gt; indices pointed to by &lt;code&gt;multi_index&lt;/code&gt;. Returns an error if a multi-index is not being tracked, the indices are out of bounds, or inner loop iteration is disabled.</source>
          <target state="translated">를 조정을 차례로 반복자 &lt;code&gt;ndim&lt;/code&gt; 가리키는 인덱스 &lt;code&gt;multi_index&lt;/code&gt; . 다중 색인이 추적되지 않거나 색인이 범위를 벗어 났거나 내부 루프 반복이 사용 불가능한 경우 오류를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="390482652fc6614f94b8e0b5d3b8e3e7bc440efc" translate="yes" xml:space="preserve">
          <source>Advance each iterator in a multi-iterator object, &lt;em&gt;multi&lt;/em&gt;, to its next (broadcasted) element.</source>
          <target state="translated">다중 반복자 객체, 각 반복기 사전 &lt;em&gt;멀티&lt;/em&gt; 차기 (방송) 소자.</target>
        </trans-unit>
        <trans-unit id="1eb4a413c0c668de3526e3736ba4eab0d5ad4902" translate="yes" xml:space="preserve">
          <source>Advance each iterator in a multi-iterator object, &lt;em&gt;multi&lt;/em&gt;, to the corresponding location of the &lt;em&gt;index&lt;/em&gt; into the flattened broadcasted array.</source>
          <target state="translated">다중 반복자 객체, 각 반복기 사전 &lt;em&gt;다중&lt;/em&gt; 의 대응하는 위치에, &lt;em&gt;인덱스&lt;/em&gt; 편평 방송 배열.</target>
        </trans-unit>
        <trans-unit id="73bcba17a49d905680f64f4b64cd0da0763a1fdc" translate="yes" xml:space="preserve">
          <source>Advance each iterator in a multi-iterator object, &lt;em&gt;multi&lt;/em&gt;, to the given</source>
          <target state="translated">다중 반복자 객체, 각 반복기 사전 &lt;em&gt;멀티&lt;/em&gt; 주어진까지</target>
        </trans-unit>
        <trans-unit id="d06248316b0b57b9742900b7804039e7df16e3f2" translate="yes" xml:space="preserve">
          <source>Advance the pointer of only the &lt;em&gt;i&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;i&lt;/em&gt; 의 포인터 만 진행&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="dd761b85cd8dca1120d21ecad95bbc6dec40fee8" translate="yes" xml:space="preserve">
          <source>Advance the underlying RNG as-if delta draws have occurred.</source>
          <target state="translated">델타 드로우가 발생한 경우 기본 RNG를 진행합니다.</target>
        </trans-unit>
        <trans-unit id="aa7d72635ecc2119da5bd876bd1d64f8f7714d93" translate="yes" xml:space="preserve">
          <source>Advanced F2PY usages</source>
          <target state="translated">고급 F2PY 사용법</target>
        </trans-unit>
        <trans-unit id="e4a9df64655f2d3ba6fe67579fc92c420e65f624" translate="yes" xml:space="preserve">
          <source>Advanced Indexing</source>
          <target state="translated">고급 인덱싱</target>
        </trans-unit>
        <trans-unit id="4ce4788ce6f50f77a6f632da07b0398738b3b58b" translate="yes" xml:space="preserve">
          <source>Advanced git workflow</source>
          <target state="translated">고급 Git 워크 플로</target>
        </trans-unit>
        <trans-unit id="0922b66273cf1a5abf90475333bea716b31aac15" translate="yes" xml:space="preserve">
          <source>Advanced indexes always are &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;broadcast&lt;/a&gt; and iterated as &lt;em&gt;one&lt;/em&gt;:</source>
          <target state="translated">고급 인덱스는 항상 &lt;a href=&quot;ufuncs#ufuncs-broadcasting&quot;&gt;브로드 캐스트&lt;/a&gt; 되고 &lt;em&gt;하나로&lt;/em&gt; 반복됩니다 .</target>
        </trans-unit>
        <trans-unit id="999315f478c86ddb00ef69d19a9dca673920820f" translate="yes" xml:space="preserve">
          <source>Advanced indexing</source>
          <target state="translated">고급 인덱싱</target>
        </trans-unit>
        <trans-unit id="21de090526b322676fb2cfd95fc96221e9a21c87" translate="yes" xml:space="preserve">
          <source>Advanced indexing always returns a &lt;em&gt;copy&lt;/em&gt; of the data (contrast with basic slicing that returns a &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt;).</source>
          <target state="translated">고급 인덱싱은 항상 데이터 의 &lt;em&gt;복사본&lt;/em&gt; 을 반환합니다 ( &lt;a href=&quot;../glossary#term-view&quot;&gt;view&lt;/a&gt; 를 반환하는 기본 슬라이싱과 대조 됨 ).</target>
        </trans-unit>
        <trans-unit id="b8ba30d88906e0b53b1be5c5761d50dabce952b7" translate="yes" xml:space="preserve">
          <source>Advanced indexing always returns a &lt;em&gt;copy&lt;/em&gt; of the data (contrast with basic slicing that returns a &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;view&lt;/a&gt;).</source>
          <target state="translated">고급 인덱싱은 항상 데이터 &lt;em&gt;복사본&lt;/em&gt; 을 반환합니다 ( &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;보기&lt;/a&gt; 를 반환하는 기본 슬라이싱과 대조 ).</target>
        </trans-unit>
        <trans-unit id="70dd0ae3ed6d0d82e5da36672eadd958cf6f9000" translate="yes" xml:space="preserve">
          <source>Advanced indexing and index tricks</source>
          <target state="translated">고급 인덱싱 및 인덱스 트릭</target>
        </trans-unit>
        <trans-unit id="adb03decbf1f08def4c5022df624652f98eb5d13" translate="yes" xml:space="preserve">
          <source>Advanced indexing is handled with this Python type. It is simply a loose wrapper around the C-structure containing the variables needed for advanced array indexing. The associated C-structure, &lt;code&gt;PyArrayMapIterObject&lt;/code&gt;, is useful if you are trying to understand the advanced-index mapping code. It is defined in the &lt;code&gt;arrayobject.h&lt;/code&gt; header. This type is not exposed to Python and could be replaced with a C-structure. As a Python type it takes advantage of reference- counted memory management.</source>
          <target state="translated">고급 인덱싱은이 Python 유형으로 처리됩니다. 고급 배열 인덱싱에 필요한 변수를 포함하는 C 구조 주위의 느슨한 래퍼입니다. 연관된 C 구조 &lt;code&gt;PyArrayMapIterObject&lt;/code&gt; 는 고급 인덱스 맵핑 코드를 이해하려는 경우 유용합니다. &lt;code&gt;arrayobject.h&lt;/code&gt; 헤더에 정의되어 있습니다. 이 유형은 Python에 노출되지 않으며 C 구조로 대체 될 수 있습니다. 파이썬 타입은 참조 카운트 된 메모리 관리를 이용합니다.</target>
        </trans-unit>
        <trans-unit id="4cbc11f3f0cea97e5215f4270cb134a05ddd8588" translate="yes" xml:space="preserve">
          <source>Advanced indexing is triggered when the selection object, &lt;em&gt;obj&lt;/em&gt;, is a non-tuple sequence object, an &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; (of data type integer or bool), or a tuple with at least one sequence object or ndarray (of data type integer or bool). There are two types of advanced indexing: integer and Boolean.</source>
          <target state="translated">선택 객체 &lt;em&gt;obj&lt;/em&gt; 가 튜플이 아닌 시퀀스 객체, &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; (데이터 유형 정수 또는 bool) 또는 하나 이상의 시퀀스 객체 또는 ndarray (데이터 유형 정수 또는 bool)가있는 튜플 인 경우 고급 인덱싱이 트리거됩니다 . 고급 색인에는 정수와 부울의 두 가지 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="7487a77bfb935b52fb14dc8f53970ff984697487" translate="yes" xml:space="preserve">
          <source>Advanced indexing using &lt;code&gt;np.newaxis&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;np.newaxis&lt;/code&gt; 를 사용한 고급 인덱싱</target>
        </trans-unit>
        <trans-unit id="49db59514c67a8d248601a700109ab8d9f639d3e" translate="yes" xml:space="preserve">
          <source>Advanced types, not listed in the table above, are explored in section &lt;a href=&quot;basics.rec#structured-arrays&quot;&gt;Structured arrays&lt;/a&gt;.</source>
          <target state="translated">위의 표에 나열되지 않은 고급 유형은 &lt;a href=&quot;basics.rec#structured-arrays&quot;&gt;구조화 된 배열&lt;/a&gt; 섹션에서 살펴 봅니다.</target>
        </trans-unit>
        <trans-unit id="611a42a1d4f61c91b62b09d02ca4dcaf618fc419" translate="yes" xml:space="preserve">
          <source>Advancing a RNG updates the underlying RNG state as-if a given number of calls to the underlying RNG have been made. In general there is not a one-to-one relationship between the number output random values from a particular distribution and the number of draws from the core RNG. This occurs for two reasons:</source>
          <target state="translated">RNG를 전진 시키면 기본 RNG에 대해 지정된 수의 호출이 이루어진 것처럼 기본 RNG 상태가 업데이트됩니다. 일반적으로 특정 분포의 출력 랜덤 값과 코어 RNG의 드로우 수에는 일대일 관계가 없습니다. 이것은 두 가지 이유로 발생합니다.</target>
        </trans-unit>
        <trans-unit id="2a1491b2d39360f6989a2a9f95147bc552e01c99" translate="yes" xml:space="preserve">
          <source>Advancing the RNG state resets any pre-computed random numbers. This is required to ensure exact reproducibility.</source>
          <target state="translated">RNG 상태를 높이면 미리 계산 된 임의의 숫자가 재설정됩니다. 정확한 재현성을 보장하기 위해 필요합니다.</target>
        </trans-unit>
        <trans-unit id="1a4120f3629606a400253ccb499c731c935784fe" translate="yes" xml:space="preserve">
          <source>Advocating for, or encouraging, any of the above behaviour.</source>
          <target state="translated">위의 행동을 옹호하거나 장려합니다.</target>
        </trans-unit>
        <trans-unit id="a95973a9f50f3287c49850414751629648c88b21" translate="yes" xml:space="preserve">
          <source>After &lt;code&gt;make&lt;/code&gt; is used to build the testing extension modules, &lt;code&gt;testVector.py&lt;/code&gt; can be run to execute the tests. As with other scripts that use &lt;code&gt;unittest&lt;/code&gt; to facilitate unit testing, &lt;code&gt;testVector.py&lt;/code&gt; defines a class that inherits from &lt;code&gt;unittest.TestCase&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;make&lt;/code&gt; 를 사용하여 테스트 확장 모듈을 빌드 한 후 &lt;code&gt;testVector.py&lt;/code&gt; 를 실행하여 테스트를 실행할 수 있습니다. &lt;code&gt;unittest&lt;/code&gt; 를 사용 하여 단위 테스트를 용이하게 하는 다른 스크립트와 마찬가지로 &lt;code&gt;testVector.py&lt;/code&gt; 는 &lt;code&gt;unittest.TestCase&lt;/code&gt; 에서 상속되는 클래스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="636c85c596b79ae6f6574b8dc87fd6d94d555ebe" translate="yes" xml:space="preserve">
          <source>After NumPy is installed, install SciPy since some of the plots in the random module require &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special&quot;&gt;&lt;code&gt;scipy.special&lt;/code&gt;&lt;/a&gt; to display properly.</source>
          <target state="translated">NumPy를 설치 한 후 임의 모듈의 일부 플롯이 제대로 표시 &lt;a href=&quot;https://docs.scipy.org/doc/scipy/reference/special.html#module-scipy.special&quot;&gt; &lt;code&gt;scipy.special&lt;/code&gt; &lt;/a&gt; 이 필요하므로 SciPy를 설치하십시오 .</target>
        </trans-unit>
        <trans-unit id="d6d2068ec50f610c03bd42928d12cabbde2c89d7" translate="yes" xml:space="preserve">
          <source>After a short pause, you should find yourself at the home page for your own forked copy of &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt;.</source>
          <target state="translated">잠시 후 &lt;a href=&quot;https://www.numpy.org&quot;&gt;NumPy&lt;/a&gt; 의 포크 된 복사본을위한 홈 페이지로 이동해야합니다 .</target>
        </trans-unit>
        <trans-unit id="6d57095cd6026d2b53a1fdab66bf0bf6d44aff56" translate="yes" xml:space="preserve">
          <source>After application of the broadcasting rules, the sizes of all arrays must match. More details can be found in &lt;a href=&quot;basics.broadcasting&quot;&gt;Broadcasting&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스팅 규칙을 적용한 후에는 모든 배열의 크기가 일치해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 자세한 내용은 &lt;a href=&quot;basics.broadcasting&quot;&gt;방송&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7d0ec039eeaad7931248938dc00b5e241e033e8d" translate="yes" xml:space="preserve">
          <source>After application of the broadcasting rules, the sizes of all arrays must match. More details can be found in &lt;a href=&quot;basics.broadcasting#basics-broadcasting&quot;&gt;Broadcasting&lt;/a&gt;.</source>
          <target state="translated">브로드 캐스팅 규칙을 적용한 후에는 모든 배열의 크기가 일치해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ 자세한 내용은 &lt;a href=&quot;basics.broadcasting#basics-broadcasting&quot;&gt;방송&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d95a5016bd3b1fa69cde64b52dc8446b4fe73b5a" translate="yes" xml:space="preserve">
          <source>After being allocated with this flag, the caller may retrieve the new array by calling &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt;&lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt;&lt;/a&gt; and getting the i-th object in the returned C array. The caller must call Py_INCREF on it to claim a reference to the array.</source>
          <target state="translated">이 플래그가 할당 된 후 호출자는 &lt;a href=&quot;#c.NpyIter_GetOperandArray&quot;&gt; &lt;code&gt;NpyIter_GetOperandArray&lt;/code&gt; &lt;/a&gt; 를 호출 하고 반환 된 C 배열에서 i 번째 개체를 가져 와서 새 배열을 검색 할 수 있습니다 . 호출자는 배열에 대한 참조를 청구하기 위해 Py_INCREF를 호출해야합니다.</target>
        </trans-unit>
        <trans-unit id="68eb223f793cecafa70b72b2b2cd87c7e3024552" translate="yes" xml:space="preserve">
          <source>After calling this function, &lt;code&gt;NpyIter_HasMultiIndex(iter)&lt;/code&gt; will return false.</source>
          <target state="translated">이 함수를 호출하면 &lt;code&gt;NpyIter_HasMultiIndex(iter)&lt;/code&gt; 가 false를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="c90e047a5904835abb0e3a66bba8cc0c6a4b3394" translate="yes" xml:space="preserve">
          <source>After checking, the thread-specific global variables, the inputs are evaluated to determine how the ufunc should proceed and the input and output arrays are constructed if necessary. Any inputs which are not arrays are converted to arrays (using context if necessary). Which of the inputs are scalars (and therefore converted to 0-D arrays) is noted.</source>
          <target state="translated">스레드 별 전역 변수를 확인한 후 입력을 평가하여 ufunc의 진행 방식을 결정하고 필요한 경우 입력 및 출력 배열을 구성합니다. 배열이 아닌 모든 입력은 배열로 변환됩니다 (필요한 경우 컨텍스트 사용). 어떤 입력이 스칼라인지 (따라서 0-D 배열로 변환 됨)가 기록됩니다.</target>
        </trans-unit>
        <trans-unit id="84eaa230a19f707fcc5c351e2944b878215aece7" translate="yes" xml:space="preserve">
          <source>After constructing the format_parser object, the dtype attribute is the converted data-type: &lt;code&gt;dtype = format_parser(formats, names, titles).dtype&lt;/code&gt;</source>
          <target state="translated">format_parser 객체를 생성 한 후 dtype 속성은 변환 된 데이터 유형입니다. &lt;code&gt;dtype = format_parser(formats, names, titles).dtype&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd142d176605dc21ba846f25e9df980015a2719f" translate="yes" xml:space="preserve">
          <source>After contributing new benchmarks, you should test them locally before submitting a pull request.</source>
          <target state="translated">새로운 벤치 마크에 기여한 후 풀 요청을 제출하기 전에 로컬에서 테스트해야합니다.</target>
        </trans-unit>
        <trans-unit id="56447ff54e7f3e9b89df5d3ea4714230ebd85b65" translate="yes" xml:space="preserve">
          <source>After modifying &lt;code&gt;add.pyf&lt;/code&gt;, the new Python module file can be generated by compiling both &lt;code&gt;add.f&lt;/code&gt; and &lt;code&gt;add.pyf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;add.pyf&lt;/code&gt; 수정 후 &lt;code&gt;add.f&lt;/code&gt; 와 &lt;code&gt;add.pyf&lt;/code&gt; 를 모두 컴파일하여 새 Python 모듈 파일을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="cd68e22e2a7eb392af857647e5dec919b73769b8" translate="yes" xml:space="preserve">
          <source>After modifying &lt;code&gt;add.pyf&lt;/code&gt;, the new python module file can be generated by compiling both &lt;code&gt;add.f&lt;/code&gt; and &lt;code&gt;add.pyf&lt;/code&gt;:</source>
          <target state="translated">&lt;code&gt;add.pyf&lt;/code&gt; 수정 후 &lt;code&gt;add.f&lt;/code&gt; 와 &lt;code&gt;add.pyf&lt;/code&gt; 를 모두 컴파일하여 새로운 파이썬 모듈 파일을 생성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="455eb55512bcb65b5c410bb05796baeb29acbfea" translate="yes" xml:space="preserve">
          <source>After preparation, getting and setting is relatively straight forward, although the different modes of iteration need to be considered. Unless there is only a single indexing array during item getting, the validity of the indices is checked beforehand. Otherwise it is handled in the inner loop itself for optimization.</source>
          <target state="translated">준비 후에는 다른 반복 모드를 고려해야하지만 가져 오기 및 설정은 비교적 간단합니다. 아이템을 가져 오는 동안 하나의 인덱싱 배열 만 없다면 인덱스의 유효성을 미리 확인합니다. 그렇지 않으면 최적화를 위해 내부 루프 자체에서 처리됩니다.</target>
        </trans-unit>
        <trans-unit id="0c2593a461de164c26a9bd4395fe7ae4e6420b19" translate="yes" xml:space="preserve">
          <source>After processing data at the current element of the array, the next element of the array can be obtained using the macro &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_NEXT&quot;&gt;&lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;iter&lt;/code&gt; ). The iteration always proceeds in a C-style contiguous fashion (last index varying the fastest). The &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;destination&lt;/code&gt; ) can be used to jump to a particular point in the array, where &lt;code&gt;destination&lt;/code&gt; is an array of npy_intp data-type with space to handle at least the number of dimensions in the underlying array. Occasionally it is useful to use &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO1D&quot;&gt;&lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt;&lt;/a&gt; ( &lt;code&gt;iter&lt;/code&gt;, &lt;code&gt;index&lt;/code&gt; ) which will jump to the 1-d index given by the value of &lt;code&gt;index&lt;/code&gt;. The most common usage, however, is given in the following example.</source>
          <target state="translated">배열의 현재 요소에서 데이터를 처리 한 후 &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_NEXT&quot;&gt; &lt;code&gt;PyArray_ITER_NEXT&lt;/code&gt; &lt;/a&gt; 매크로 ( &lt;code&gt;iter&lt;/code&gt; )를 사용하여 배열의 다음 요소를 가져올 수 있습니다 . 반복은 항상 C 스타일 연속 방식으로 진행됩니다 (마지막 인덱스가 가장 빠르게 변함). &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;destination&lt;/code&gt; ) 배열에서 특정 지점으로 이동하는 데 사용할 수있는 &lt;code&gt;destination&lt;/code&gt; 핸들 공간 npy_intp 데이터 타입의 배열 기본 배열의 사이즈 중 적어도 개수이다. 때때로 &lt;a href=&quot;../reference/c-api/array#c.PyArray_ITER_GOTO1D&quot;&gt; &lt;code&gt;PyArray_ITER_GOTO1D&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;iter&lt;/code&gt; , &lt;code&gt;index&lt;/code&gt; ) 를 사용하는 것이 유용합니다. &lt;code&gt;index&lt;/code&gt; . 그러나 가장 일반적인 사용법은 다음 예에 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="9819d71768a6909b8f1fb8eced733e894e00b1f0" translate="yes" xml:space="preserve">
          <source>After reading, you should be able to:</source>
          <target state="translated">읽은 후에는 다음을 수행 할 수 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="16d173e349e6d8f7bad31a91c896cab0609e07c9" translate="yes" xml:space="preserve">
          <source>After the above has been installed, it can be imported and used as follows.</source>
          <target state="translated">위를 설치 한 후 다음과 같이 가져 와서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e95782b0d249dfaa80b7a2dd2b91658ce77729a7" translate="yes" xml:space="preserve">
          <source>After the final release</source>
          <target state="translated">최종 출시 후</target>
        </trans-unit>
        <trans-unit id="4d680aaff82c687dd72450b9e14045805107da54" translate="yes" xml:space="preserve">
          <source>After the final release is announced, a few administrative tasks are left to be done:</source>
          <target state="translated">최종 릴리스가 발표 된 후 몇 가지 관리 작업을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="38ee242b1e395e865043dafe24f53eebf7d98289" translate="yes" xml:space="preserve">
          <source>After the input arguments are processed, the code that actually does the work is written (likely calling other functions as needed). The final step of the C-function is to return something. If an error is encountered then &lt;code&gt;NULL&lt;/code&gt; should be returned (making sure an error has actually been set). If nothing should be returned then increment &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt;&lt;code&gt;Py_None&lt;/code&gt;&lt;/a&gt; and return it. If a single object should be returned then it is returned (ensuring that you own a reference to it first). If multiple objects should be returned then you need to return a tuple. The &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt;&lt;code&gt;Py_BuildValue&lt;/code&gt;&lt;/a&gt; (format_string, c_variables&amp;hellip;) function makes it easy to build tuples of Python objects from C variables. Pay special attention to the difference between &amp;lsquo;N&amp;rsquo; and &amp;lsquo;O&amp;rsquo; in the format string or you can easily create memory leaks. The &amp;lsquo;O&amp;rsquo; format string increments the reference count of the &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; C-variable it corresponds to, while the &amp;lsquo;N&amp;rsquo; format string steals a reference to the corresponding &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt;&lt;code&gt;PyObject *&lt;/code&gt;&lt;/a&gt; C-variable. You should use &amp;lsquo;N&amp;rsquo; if you have already created a reference for the object and just want to give that reference to the tuple. You should use &amp;lsquo;O&amp;rsquo; if you only have a borrowed reference to an object and need to create one to provide for the tuple.</source>
          <target state="translated">입력 인수가 처리 된 후 실제로 작업을 수행하는 코드가 작성됩니다 (필요에 따라 다른 함수를 호출 할 가능성이 있음). C 함수의 마지막 단계는 무언가를 반환하는 것입니다. 오류가 발생하면 &lt;code&gt;NULL&lt;/code&gt; 이 반환되어야합니다 (실제로 오류가 설정되었는지 확인). 아무것도 반환되지 않으면 &lt;a href=&quot;https://docs.python.org/dev/c-api/none.html#c.Py_None&quot;&gt; &lt;code&gt;Py_None&lt;/code&gt; &lt;/a&gt; 을 증가 시키고 반환합니다. 단일 객체가 반환되어야하는 경우 반환됩니다 (먼저 해당 객체에 대한 참조를 소유하고 있는지 확인). 여러 객체를 반환해야하는 경우 튜플을 반환해야합니다. &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.Py_BuildValue&quot;&gt; &lt;code&gt;Py_BuildValue&lt;/code&gt; &lt;/a&gt;(format_string, c_variables&amp;hellip;) 함수를 사용하면 C 변수에서 Python 객체의 튜플을 쉽게 만들 수 있습니다. 형식 문자열에서 'N'과 'O'의 차이에 특히주의하십시오. 그렇지 않으면 쉽게 메모리 누수가 발생할 수 있습니다. 'O'형식 문자열은 해당하는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; C- 변수 의 참조 횟수를 증가시키는 반면 'N'형식 문자열은 해당하는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject&quot;&gt; &lt;code&gt;PyObject *&lt;/code&gt; &lt;/a&gt; C- 변수에 대한 참조를 훔칩니다 . 객체에 대한 참조를 이미 생성했고 해당 참조를 튜플에 제공하려면 'N'을 사용해야합니다. 객체에 대한 차용 된 참조 만 있고 튜플을 제공하기 위해 하나를 만들어야하는 경우 'O'를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="697b44505fd313d9b8c894a494c99e13592310d3" translate="yes" xml:space="preserve">
          <source>After this call, iter-&amp;gt;dataptr points to the next point of the neighborhood. Calling this function after every point of the neighborhood has been visited is undefined.</source>
          <target state="translated">이 호출 후 iter-&amp;gt; dataptr은 이웃의 다음 지점을 가리 킵니다. 이웃의 모든 지점을 방문한 후이 함수를 호출하는 것은 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0fe601eacfd3a15b153c497e6624cb578134ef4f" translate="yes" xml:space="preserve">
          <source>After this tutorial, you should be able to:</source>
          <target state="translated">이 튜토리얼을 마치면 다음을 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="521a8dcc62f52bfdf554721e71118cca11cdce65" translate="yes" xml:space="preserve">
          <source>After you have defined a new Python type object, you must then define a new &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt;&lt;code&gt;PyArray_Descr&lt;/code&gt;&lt;/a&gt; structure whose typeobject member will contain a pointer to the data-type you&amp;rsquo;ve just defined. In addition, the required functions in the &amp;ldquo;.f&amp;rdquo; member must be defined: nonzero, copyswap, copyswapn, setitem, getitem, and cast. The more functions in the &amp;ldquo;.f&amp;rdquo; member you define, however, the more useful the new data-type will be. It is very important to initialize unused functions to NULL. This can be achieved using &lt;a href=&quot;../reference/c-api/array#c.PyArray_InitArrFuncs&quot;&gt;&lt;code&gt;PyArray_InitArrFuncs&lt;/code&gt;&lt;/a&gt; (f).</source>
          <target state="translated">새로운 Python 유형 객체를 정의한 후에 는 typeobject 멤버가 방금 정의한 데이터 유형에 대한 포인터를 포함 할 새 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyArray_Descr&quot;&gt; &lt;code&gt;PyArray_Descr&lt;/code&gt; &lt;/a&gt; 구조 를 정의해야합니다 . 또한 &quot;.f&quot;멤버의 필수 함수 (0이 아닌 값, copyswap, copyswapn, setitem, getitem 및 캐스트)를 정의해야합니다. 그러나 정의한 &quot;.f&quot;멤버에 함수가 많을수록 새 데이터 유형이 더 유용 해집니다. 사용하지 않는 함수를 NULL로 초기화하는 것은 매우 중요합니다. 이것은 &lt;a href=&quot;../reference/c-api/array#c.PyArray_InitArrFuncs&quot;&gt; &lt;code&gt;PyArray_InitArrFuncs&lt;/code&gt; &lt;/a&gt; (f)를 사용하여 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="54ae9eda3128d1b34b4a48ecba6759be6c9803cd" translate="yes" xml:space="preserve">
          <source>After you have finished reviewing, if you want to ask for the submitter to make changes, change your review status to &amp;ldquo;Changes requested.&amp;rdquo; This can be done on GitHub, PR page, Files changed tab, Review changes (button on the top right).</source>
          <target state="translated">검토를 마친 후 제출자에게 변경을 요청하려면 검토 상태를 &quot;변경 요청 됨&quot;으로 변경하십시오. GitHub, PR 페이지, 변경된 파일 탭, 변경 사항 검토 (오른쪽 상단의 버튼)에서 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0b9513877fd0ed1a40b8e9bf67003ecbb52357dd" translate="yes" xml:space="preserve">
          <source>Again, the hardware error flags are checked at the end of each 1-D loop.</source>
          <target state="translated">다시 말하지만, 하드웨어 오류 플래그는 각 1-D 루프의 끝에서 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="a858809876e8ca33d95a13b92b91d9e06506bf6f" translate="yes" xml:space="preserve">
          <source>Agree on a release schedule</source>
          <target state="translated">출시 일정에 동의</target>
        </trans-unit>
        <trans-unit id="7ef51dda5a44862684039216f84f183b76a80b26" translate="yes" xml:space="preserve">
          <source>Aimed at domain experts or people migrating to NumPy</source>
          <target state="translated">도메인 전문가 또는 NumPy로 마이그레이션하는 사람들을 대상으로합니다.</target>
        </trans-unit>
        <trans-unit id="3143b25d1a77f9836cd54d8380d781cf28018611" translate="yes" xml:space="preserve">
          <source>Airspeed Velocity manages building and Python virtualenvs by itself, unless told otherwise. Some of the benchmarking features in &lt;code&gt;runtests.py&lt;/code&gt; also tell ASV to use the NumPy compiled by &lt;code&gt;runtests.py&lt;/code&gt;. To run the benchmarks, you do not need to install a development version of NumPy to your current Python environment.</source>
          <target state="translated">Airspeed Velocity는 달리 언급하지 않는 한 자체적으로 건물 및 Python 가상 환경을 관리합니다. &lt;code&gt;runtests.py&lt;/code&gt; 의 일부 벤치마킹 기능은 ASV에 &lt;code&gt;runtests.py&lt;/code&gt; 로 컴파일 된 NumPy를 사용하도록 지시 합니다. 벤치 마크를 실행하기 위해 현재 Python 환경에 NumPy의 개발 버전을 설치할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f93e37512c349fabdaaef9618ea22ae5babb455c" translate="yes" xml:space="preserve">
          <source>Alex Griffing (2015-2017)</source>
          <target state="translated">알렉스 그 리핑 (2015-2017)</target>
        </trans-unit>
        <trans-unit id="8366cf5fbe2fd64d60dc44a0b1acd5bdcd5ccf6a" translate="yes" xml:space="preserve">
          <source>Alex Griffing (served: 2015-2017)</source>
          <target state="translated">Alex Griffing (제공 : 2015-2017)</target>
        </trans-unit>
        <trans-unit id="15999ccd033219cd638f144231839361b543c152" translate="yes" xml:space="preserve">
          <source>Algebra</source>
          <target state="translated">Algebra</target>
        </trans-unit>
        <trans-unit id="04259816ace1ebe56c853a8763558570c008514a" translate="yes" xml:space="preserve">
          <source>Alias</source>
          <target state="translated">Alias</target>
        </trans-unit>
        <trans-unit id="5d21032a49ecef3de054fb37902be6d2de0b84fd" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#numpy.clongdouble&quot;&gt;&lt;code&gt;numpy.clongdouble&lt;/code&gt;&lt;/a&gt;, named after its size in bits. The existance of these aliases depends on the platform.</source>
          <target state="translated">&lt;a href=&quot;#numpy.clongdouble&quot;&gt; &lt;code&gt;numpy.clongdouble&lt;/code&gt; 의&lt;/a&gt; 별칭으로 , 비트 단위의 크기를 따서 명명되었습니다. 이러한 별칭의 존재 여부는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="12f7878ae7615fa2ad02f41815a9f80f09bb3c0b" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;#numpy.longdouble&quot;&gt;&lt;code&gt;numpy.longdouble&lt;/code&gt;&lt;/a&gt;, named after its size in bits. The existence of these aliases depends on the platform.</source>
          <target state="translated">&lt;a href=&quot;#numpy.longdouble&quot;&gt; &lt;code&gt;numpy.longdouble&lt;/code&gt; 의&lt;/a&gt; 별칭으로 , 비트 단위의 크기를 따서 명명되었습니다. 이러한 별칭의 존재 여부는 플랫폼에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9e977544bb11abd40aa27a0e17f3a1e6f9d61990" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;numpy.random.generator.random#numpy.random.Generator.random&quot;&gt;&lt;code&gt;random&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.generator.random#numpy.random.Generator.random&quot;&gt; &lt;code&gt;random&lt;/code&gt; &lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="67d7f23a72a8843faf44deebd6c5b5926eb14ec8" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;numpy.random.mtrand.randomstate.random_sample#numpy.random.mtrand.RandomState.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.mtrand.randomstate.random_sample#numpy.random.mtrand.RandomState.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; 의&lt;/a&gt; 별명입니다 .</target>
        </trans-unit>
        <trans-unit id="fe309eb61feba56d0836f1b2c95adfc2991a2b5a" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.random_sample#numpy.random.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; 의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="a5fb6088b0c82c76aa11a9dcfc145f34120a38b4" translate="yes" xml:space="preserve">
          <source>Alias for &lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt;&lt;code&gt;random_sample&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;numpy.random.randomstate.random_sample#numpy.random.RandomState.random_sample&quot;&gt; &lt;code&gt;random_sample&lt;/code&gt; 의&lt;/a&gt; 별칭 .</target>
        </trans-unit>
        <trans-unit id="7e56683c1e18fe1cca5f2fe9851f948516320b79" translate="yes" xml:space="preserve">
          <source>Alias for the signed integer type (one of &lt;a href=&quot;#numpy.byte&quot;&gt;&lt;code&gt;numpy.byte&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.short&quot;&gt;&lt;code&gt;numpy.short&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.intc&quot;&gt;&lt;code&gt;numpy.intc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.longlong&lt;/code&gt;) that is the same size as a pointer.</source>
          <target state="translated">포인터와 크기가 같은 부호있는 정수 유형 ( &lt;a href=&quot;#numpy.byte&quot;&gt; &lt;code&gt;numpy.byte&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.short&quot;&gt; &lt;code&gt;numpy.short&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.intc&quot;&gt; &lt;code&gt;numpy.intc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;np.longlong&lt;/code&gt; 중 하나)에 대한 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="e11ab6e8b1cb36d3287744a481226ea77503f965" translate="yes" xml:space="preserve">
          <source>Alias for the unsigned integer type (one of &lt;a href=&quot;#numpy.byte&quot;&gt;&lt;code&gt;numpy.byte&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.short&quot;&gt;&lt;code&gt;numpy.short&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.intc&quot;&gt;&lt;code&gt;numpy.intc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;np.longlong&lt;/code&gt;) that is the same size as a pointer.</source>
          <target state="translated">포인터와 크기가 같은 부호없는 정수 유형 ( &lt;a href=&quot;#numpy.byte&quot;&gt; &lt;code&gt;numpy.byte&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.short&quot;&gt; &lt;code&gt;numpy.short&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.intc&quot;&gt; &lt;code&gt;numpy.intc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;np.longlong&lt;/code&gt; 중 하나)에 대한 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="dd96d593089d1897d9f1a1b1e5ce6a97032c718f" translate="yes" xml:space="preserve">
          <source>Alias for the unsigned integer types (one of &lt;a href=&quot;#numpy.byte&quot;&gt;&lt;code&gt;numpy.byte&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.short&quot;&gt;&lt;code&gt;numpy.short&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.intc&quot;&gt;&lt;code&gt;numpy.intc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.longlong&quot;&gt;&lt;code&gt;numpy.longlong&lt;/code&gt;&lt;/a&gt;) with the specified number of bits.</source>
          <target state="translated">지정된 비트 수를 가진 부호없는 정수 유형 ( &lt;a href=&quot;#numpy.byte&quot;&gt; &lt;code&gt;numpy.byte&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.short&quot;&gt; &lt;code&gt;numpy.short&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.intc&quot;&gt; &lt;code&gt;numpy.intc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.longlong&quot;&gt; &lt;code&gt;numpy.longlong&lt;/code&gt; &lt;/a&gt; 중 하나)에 대한 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="2615477a59d94e07f87d8e76d7a88eff31bdc890" translate="yes" xml:space="preserve">
          <source>Alias on this platform</source>
          <target state="translated">이 플랫폼의 별칭</target>
        </trans-unit>
        <trans-unit id="6b7fb07ff883bca85d0fccd0822fbb8018f3186d" translate="yes" xml:space="preserve">
          <source>Alias to isMaskedArray.</source>
          <target state="translated">isMaskedArray에 대한 별칭.</target>
        </trans-unit>
        <trans-unit id="6a8b49f23c0c2e66b347773e3a4bb453ff1fb91c" translate="yes" xml:space="preserve">
          <source>Aliases</source>
          <target state="translated">Aliases</target>
        </trans-unit>
        <trans-unit id="fba36176b4a9c759d4fcc72655567ebf82febab0" translate="yes" xml:space="preserve">
          <source>Aliases for column names. For example, if &lt;code&gt;names&lt;/code&gt; were &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; and &lt;code&gt;titles&lt;/code&gt; is &lt;code&gt;('x_coordinate', 'y_coordinate', 'z_coordinate')&lt;/code&gt;, then &lt;code&gt;arr['x']&lt;/code&gt; is equivalent to both &lt;code&gt;arr.x&lt;/code&gt; and &lt;code&gt;arr.x_coordinate&lt;/code&gt;.</source>
          <target state="translated">열 이름의 별명. 예를 들어 &lt;code&gt;names&lt;/code&gt; 이 &lt;code&gt;('x', 'y', 'z')&lt;/code&gt; 이고 &lt;code&gt;titles&lt;/code&gt; 이 &lt;code&gt;('x_coordinate', 'y_coordinate', 'z_coordinate')&lt;/code&gt; 인 경우 &lt;code&gt;arr['x']&lt;/code&gt; 는 &lt;code&gt;arr.x&lt;/code&gt; 와 같습니다. 및 &lt;code&gt;arr.x_coordinate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d351cb2af52126fcf568f2f07224e63d83d817df" translate="yes" xml:space="preserve">
          <source>Aliases for functions which may be accelerated by SciPy.</source>
          <target state="translated">SciPy에 의해 가속화 될 수있는 함수에 대한 별칭입니다.</target>
        </trans-unit>
        <trans-unit id="7c5bb328be3f290ae38f62da3e4ece591ab22fc8" translate="yes" xml:space="preserve">
          <source>Aliases for functions which may be accelerated by Scipy.</source>
          <target state="translated">Scipy가 가속화 할 수있는 기능의 별명.</target>
        </trans-unit>
        <trans-unit id="58cb5cabb707dc2fca99d0a3efb823bf212c1389" translate="yes" xml:space="preserve">
          <source>Aliases for the signed integer types (one of &lt;a href=&quot;#numpy.byte&quot;&gt;&lt;code&gt;numpy.byte&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.short&quot;&gt;&lt;code&gt;numpy.short&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.intc&quot;&gt;&lt;code&gt;numpy.intc&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#numpy.int_&quot;&gt;&lt;code&gt;numpy.int_&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.longlong&quot;&gt;&lt;code&gt;numpy.longlong&lt;/code&gt;&lt;/a&gt;) with the specified number of bits.</source>
          <target state="translated">지정된 비트 수를 가진 부호있는 정수 유형 ( &lt;a href=&quot;#numpy.byte&quot;&gt; &lt;code&gt;numpy.byte&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.short&quot;&gt; &lt;code&gt;numpy.short&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.intc&quot;&gt; &lt;code&gt;numpy.intc&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;#numpy.int_&quot;&gt; &lt;code&gt;numpy.int_&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.longlong&quot;&gt; &lt;code&gt;numpy.longlong&lt;/code&gt; &lt;/a&gt; 중 하나)에 대한 별칭입니다 .</target>
        </trans-unit>
        <trans-unit id="13b88c72578e1bc088ddcd72007a263c4697a72b" translate="yes" xml:space="preserve">
          <source>Align the fields in memory as the C-compiler would.</source>
          <target state="translated">C- 컴파일러와 마찬가지로 메모리의 필드를 정렬하십시오.</target>
        </trans-unit>
        <trans-unit id="f3cba54c6d1af128e2fd6357be91e0ede30e9060" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;N&lt;/code&gt; elements of the matrix are placed into a single row.</source>
          <target state="translated">행렬의 모든 &lt;code&gt;N&lt;/code&gt; 요소가 단일 행에 배치됩니다.</target>
        </trans-unit>
        <trans-unit id="acddbf25025c4514b513776312b69fb5576c2571" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; constants have corresponding &lt;code&gt;NPY_BITSOF_{CTYPE}&lt;/code&gt; constants defined. The &lt;code&gt;NPY_BITSOF_{CTYPE}&lt;/code&gt; constants provide the number of bits in the data type. Specifically, the available &lt;code&gt;{CTYPE}s&lt;/code&gt; are</source>
          <target state="translated">모든 &lt;code&gt;NPY_SIZEOF_{CTYPE}&lt;/code&gt; 상수에는 해당 &lt;code&gt;NPY_BITSOF_{CTYPE}&lt;/code&gt; 상수가 정의되어 있습니다. &lt;code&gt;NPY_BITSOF_{CTYPE}&lt;/code&gt; 정수 데이터 유형의 비트 수를 제공한다. 사용 가능한 &lt;code&gt;{CTYPE}s&lt;/code&gt; 은</target>
        </trans-unit>
        <trans-unit id="67b5ec265e79518c863e69eb7c6072155f6cfc03" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;fortran&lt;/code&gt; type objects have attribute &lt;code&gt;_cpointer&lt;/code&gt; that contains CObject referring to the C pointer of the corresponding Fortran/C function or variable in C level. Such CObjects can be used as a callback argument of F2PY generated functions to bypass Python C/API layer of calling Python functions from Fortran or C when the computational part of such functions is implemented in C or Fortran and wrapped with F2PY (or any other tool capable of providing CObject of a function).</source>
          <target state="translated">모든 &lt;code&gt;fortran&lt;/code&gt; 유형 개체에는 해당 Fortran / C 함수의 C 포인터 또는 C 수준의 변수를 참조하는 CObject를 포함하는 &lt;code&gt;_cpointer&lt;/code&gt; 속성 이 있습니다. 이러한 CObject는 이러한 함수의 계산 부분이 C 또는 Fortran으로 구현되고 F2PY (또는 다른 도구)로 래핑 될 때 Fortran 또는 C에서 Python 함수를 호출하는 Python C / API 계층을 우회하는 F2PY 생성 함수의 콜백 인수로 사용될 수 있습니다. 함수의 CObject를 제공 할 수 있음).</target>
        </trans-unit>
        <trans-unit id="3eda1f1204e846a63c393c972b4900dcc5fc8b0c" translate="yes" xml:space="preserve">
          <source>All BitGenerators can produce doubles, uint64s and uint32s via CTypes (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.ctypes#numpy.random.PCG64.ctypes&quot;&gt;&lt;code&gt;PCG64.ctypes&lt;/code&gt;&lt;/a&gt;) and CFFI (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.cffi#numpy.random.PCG64.cffi&quot;&gt;&lt;code&gt;PCG64.cffi&lt;/code&gt;&lt;/a&gt;). This allows the bit generators to be used in numba.</source>
          <target state="translated">모든 BitGenerator는 CType ( &lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.ctypes#numpy.random.PCG64.ctypes&quot;&gt; &lt;code&gt;PCG64.ctypes&lt;/code&gt; &lt;/a&gt; ) 및 CFFI ( &lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.cffi#numpy.random.PCG64.cffi&quot;&gt; &lt;code&gt;PCG64.cffi&lt;/code&gt; &lt;/a&gt; ) 를 통해 double, uint64 및 uint32를 생성 할 수 있습니다 . 이를 통해 numba에서 비트 생성기를 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="be76fffeff958a29e1cfac06d834cba1ca2ac9cb" translate="yes" xml:space="preserve">
          <source>All BitGenerators can produce doubles, uint64s and uint32s via CTypes (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.pcg64.ctypes#numpy.random.pcg64.PCG64.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;) and CFFI (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.pcg64.cffi#numpy.random.pcg64.PCG64.cffi&quot;&gt;&lt;code&gt;cffi&lt;/code&gt;&lt;/a&gt;). This allows the bit generators to be used in numba.</source>
          <target state="translated">모든 BitGenerator는 CType ( &lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.pcg64.ctypes#numpy.random.pcg64.PCG64.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; ) 및 CFFI ( &lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.pcg64.cffi#numpy.random.pcg64.PCG64.cffi&quot;&gt; &lt;code&gt;cffi&lt;/code&gt; &lt;/a&gt; ) 를 통해 double, uint64 및 uint32를 생성 할 수 있습니다 . 이를 통해 비트 생성기를 numba에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9bb8ae0504c4fd355ed5e394a6eda23387682d2" translate="yes" xml:space="preserve">
          <source>All BitGenerators in numpy use &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; to convert seeds into initialized states.</source>
          <target state="translated">numpy의 모든 BitGenerator는 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 를 사용 하여 시드를 초기화 된 상태로 변환합니다.</target>
        </trans-unit>
        <trans-unit id="42f60d8d5c75ba55b3aae96d540c38c0afd3075e" translate="yes" xml:space="preserve">
          <source>All C-structures corresponding to Python objects must begin with &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_VAR_HEAD&quot;&gt;&lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt;&lt;/a&gt;). In the same way, any sub-type must have a C-structure that begins with exactly the same memory layout as the parent type (or all of the parent types in the case of multiple-inheritance). The reason for this is that Python may attempt to access a member of the sub-type structure as if it had the parent structure ( &lt;em&gt;i.e.&lt;/em&gt; it will cast a given pointer to a pointer to the parent structure and then dereference one of it&amp;rsquo;s members). If the memory layouts are not compatible, then this attempt will cause unpredictable behavior (eventually leading to a memory violation and program crash).</source>
          <target state="translated">Python 객체에 해당하는 모든 C 구조는 &lt;a href=&quot;../reference/c-api/types-and-structures#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_VAR_HEAD&quot;&gt; &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; &lt;/a&gt; )로 시작해야합니다 . 같은 방식으로 모든 하위 유형에는 상위 유형 (또는 다중 상속의 경우 모든 상위 유형)과 정확히 동일한 메모리 레이아웃으로 시작하는 C 구조가 있어야합니다. 그 이유는 파이썬이 마치 부모 구조를 가지고있는 것처럼 하위 유형 구조의 멤버에 접근하려고 시도 할 수 있기 때문입니다 ( &lt;em&gt;즉&lt;/em&gt; , 부모 구조 에 대한 포인터에 주어진 포인터를 캐스팅 한 다음 그 멤버 중 하나를 역 참조 할 것입니다). 메모리 레이아웃이 호환되지 않는 경우이 시도는 예측할 수없는 동작을 유발합니다 (결국 메모리 위반 및 프로그램 충돌로 이어짐).</target>
        </trans-unit>
        <trans-unit id="5f42cdec14792512c6317497d08c83b7f8c46a0b" translate="yes" xml:space="preserve">
          <source>All C-structures corresponding to Python objects must begin with &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt;&lt;code&gt;PyObject_HEAD&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_VAR_HEAD&quot;&gt;&lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt;&lt;/a&gt;). In the same way, any sub-type must have a C-structure that begins with exactly the same memory layout as the parent type (or all of the parent types in the case of multiple-inheritance). The reason for this is that Python may attempt to access a member of the sub-type structure as if it had the parent structure ( &lt;em&gt;i.e.&lt;/em&gt; it will cast a given pointer to a pointer to the parent structure and then dereference one of it&amp;rsquo;s members). If the memory layouts are not compatible, then this attempt will cause unpredictable behavior (eventually leading to a memory violation and program crash).</source>
          <target state="translated">Python 객체에 해당하는 모든 C 구조는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_HEAD&quot;&gt; &lt;code&gt;PyObject_HEAD&lt;/code&gt; &lt;/a&gt; (또는 &lt;a href=&quot;https://docs.python.org/dev/c-api/structures.html#c.PyObject_VAR_HEAD&quot;&gt; &lt;code&gt;PyObject_VAR_HEAD&lt;/code&gt; &lt;/a&gt; )로 시작해야합니다 . 같은 방식으로 모든 하위 유형에는 상위 유형 (또는 다중 상속의 경우 모든 상위 유형)과 정확히 동일한 메모리 레이아웃으로 시작하는 C 구조가 있어야합니다. 그 이유는 파이썬이 마치 부모 구조를 가지고있는 것처럼 하위 유형 구조의 멤버에 접근하려고 시도 할 수 있기 때문입니다 ( &lt;em&gt;즉&lt;/em&gt; , 부모 구조 에 대한 포인터에 주어진 포인터를 캐스팅 한 다음 그 멤버 중 하나를 역 참조 할 것입니다). 메모리 레이아웃이 호환되지 않는 경우이 시도는 예측할 수없는 동작을 유발합니다 (결국 메모리 위반 및 프로그램 충돌로 이어짐).</target>
        </trans-unit>
        <trans-unit id="c916ff6d79d5a6327c1d96c8c36c305d6432178f" translate="yes" xml:space="preserve">
          <source>All F2PY generated files are created in &lt;code&gt;&amp;lt;dirname&amp;gt;&lt;/code&gt;. Default is &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt;.</source>
          <target state="translated">모든 F2PY 생성 파일은 &lt;code&gt;&amp;lt;dirname&amp;gt;&lt;/code&gt; 에 생성됩니다 . 기본값은 &lt;code&gt;tempfile.mkdtemp()&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="0c97effec24d7e33c3b06e4fc3b4dd25c34ca82f" translate="yes" xml:space="preserve">
          <source>All Setups</source>
          <target state="translated">모든 설정</target>
        </trans-unit>
        <trans-unit id="e82faa4a852e5e7d4ed74ce885cf0172a7a8e9ab" translate="yes" xml:space="preserve">
          <source>All array-like methods are now called with keyword arguments in fromnumeric.py</source>
          <target state="translated">모든 배열 유사 메서드는 이제 fromnumeric.py의 키워드 인수로 호출됩니다.</target>
        </trans-unit>
        <trans-unit id="eb1e144b53b6fbb02861788e7300ee911b816808" translate="yes" xml:space="preserve">
          <source>All arrays generated by basic slicing are always &lt;a href=&quot;../glossary#term-view&quot;&gt;views&lt;/a&gt; of the original array.</source>
          <target state="translated">기본 슬라이싱으로 생성 된 모든 어레이는 항상 원래 어레이의 &lt;a href=&quot;../glossary#term-view&quot;&gt;보기&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="93006b441b63a8f203fde18dc1e2540284859337" translate="yes" xml:space="preserve">
          <source>All arrays generated by basic slicing are always &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;views&lt;/a&gt; of the original array.</source>
          <target state="translated">기본 슬라이싱으로 생성 된 모든 배열은 항상 원래 배열의 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-view&quot;&gt;보기&lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="60b8659a5aae8d8bd6d3f0a8ebb318da1489077c" translate="yes" xml:space="preserve">
          <source>All bit generators can produce doubles, uint64s and uint32s via CTypes (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.ctypes#numpy.random.PCG64.ctypes&quot;&gt;&lt;code&gt;ctypes&lt;/code&gt;&lt;/a&gt;) and CFFI (&lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.cffi#numpy.random.PCG64.cffi&quot;&gt;&lt;code&gt;cffi&lt;/code&gt;&lt;/a&gt;). This allows these bit generators to be used in numba.</source>
          <target state="translated">모든 비트 생성기는 CType ( &lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.ctypes#numpy.random.PCG64.ctypes&quot;&gt; &lt;code&gt;ctypes&lt;/code&gt; &lt;/a&gt; ) 및 CFFI ( &lt;a href=&quot;bit_generators/generated/numpy.random.pcg64.cffi#numpy.random.PCG64.cffi&quot;&gt; &lt;code&gt;cffi&lt;/code&gt; &lt;/a&gt; ) 를 통해 double, uint64 및 uint32를 생성 할 수 있습니다 . 이를 통해 이러한 비트 생성기를 numba에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c9be37c010a50fce0078664c2aec450a0fb2c2e9" translate="yes" xml:space="preserve">
          <source>All bit generators can produce doubles, uint64s and uint32s via CTypes (&lt;code&gt;ctypes&lt;/code&gt;) and CFFI (&lt;code&gt;cffi&lt;/code&gt;). This allows these bit generators to be used in numba.</source>
          <target state="translated">모든 비트 생성기는 CType ( &lt;code&gt;ctypes&lt;/code&gt; ) 및 CFFI ( &lt;code&gt;cffi&lt;/code&gt; ) 를 통해 double, uint64 및 uint32를 생성 할 수 있습니다 . 이를 통해 이러한 비트 생성기를 numba에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b69727cbe4d73bbfb0e440e37962ff9d4d419505" translate="yes" xml:space="preserve">
          <source>All built-in data-type objects have byteorder either &amp;lsquo;=&amp;rsquo; or &amp;lsquo;|&amp;rsquo;.</source>
          <target state="translated">모든 내장 데이터 유형 오브젝트의 바이트 순서는 '='또는 '|'입니다.</target>
        </trans-unit>
        <trans-unit id="8b7a0f2018eee680f412af1df03ac77a63a47767" translate="yes" xml:space="preserve">
          <source>All but the last (righthand-most) bin is half-open. In other words, if &lt;code&gt;bins&lt;/code&gt; is:</source>
          <target state="translated">마지막 (가장 오른쪽) 빈을 제외한 나머지는 반쯤 열려 있습니다. 즉, &lt;code&gt;bins&lt;/code&gt; 이 다음 과 같은 경우 :</target>
        </trans-unit>
        <trans-unit id="69d9e13f3c8c7761eb67dfa2398b7f8fb6f814ea" translate="yes" xml:space="preserve">
          <source>All code should be &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard&quot;&gt;documented&lt;/a&gt;.</source>
          <target state="translated">모든 코드는 &lt;a href=&quot;https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard&quot;&gt;문서화&lt;/a&gt; 되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a10a75d24470737c78acbe472c1daa04ba679066" translate="yes" xml:space="preserve">
          <source>All code should have tests (see &lt;a href=&quot;#test-coverage&quot;&gt;test coverage&lt;/a&gt; below for more details).</source>
          <target state="translated">모든 코드에는 테스트가 있어야합니다 ( 자세한 내용은 아래 &lt;a href=&quot;#test-coverage&quot;&gt;테스트 범위&lt;/a&gt; 참조).</target>
        </trans-unit>
        <trans-unit id="ff69c40820720e31d32ccaa63294de4fbcef8495" translate="yes" xml:space="preserve">
          <source>All elements of &lt;code&gt;a&lt;/code&gt; will be assigned this value.</source>
          <target state="translated">의 모든 요소 &lt;code&gt;a&lt;/code&gt; 는 이 값을 할당됩니다.</target>
        </trans-unit>
        <trans-unit id="5aae9c7e8e2ab607eca80bf471074cb902f987b2" translate="yes" xml:space="preserve">
          <source>All elements of a homogeneous array have the same type. ndarrays, in contrast to Python lists, are homogeneous. The type can be complicated, as in a &lt;a href=&quot;#term-structured-array&quot;&gt;structured array&lt;/a&gt;, but all elements have that type.</source>
          <target state="translated">동종 배열의 모든 요소는 동일한 유형을 갖습니다. Python 목록과 달리 ndarray는 동종입니다. 유형은 &lt;a href=&quot;#term-structured-array&quot;&gt;구조화 된 배열&lt;/a&gt; 처럼 복잡 할 수 있지만 모든 요소에는 해당 유형이 있습니다.</target>
        </trans-unit>
        <trans-unit id="ab491eb1f9e84afa82844be62a42785a977e7753" translate="yes" xml:space="preserve">
          <source>All flags can be accessed using the single (upper case) letter as well as the full name.</source>
          <target state="translated">모든 플래그는 전체 이름뿐만 아니라 단일 문자 (대문자)를 사용하여 액세스 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="96d53af971cb6fff2bbec3fdd9ead15faadcf4dc" translate="yes" xml:space="preserve">
          <source>All function declarations and definitions must use full prototypes (i.e. specify the types of all arguments).</source>
          <target state="translated">모든 함수 선언 및 정의는 완전한 프로토 타입을 사용해야합니다 (즉, 모든 인수의 유형 지정).</target>
        </trans-unit>
        <trans-unit id="8e34248364070a9d79764ba20e005ff3f77292af" translate="yes" xml:space="preserve">
          <source>All functions and global variables should be declared static when they aren&amp;rsquo;t needed outside the current compilation unit.</source>
          <target state="translated">모든 함수와 전역 변수는 현재 컴파일 단위 외부에서 필요하지 않은 경우 정적으로 선언되어야합니다.</target>
        </trans-unit>
        <trans-unit id="02f1cb3a6a2fd8188553a31c71d030165f948de9" translate="yes" xml:space="preserve">
          <source>All input arrays except int64 and uint64 can be safely cast to the returned dtype without loss of information.</source>
          <target state="translated">int64 및 uint64를 제외한 모든 입력 배열은 정보 손실없이 반환 된 dtype으로 안전하게 캐스팅 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0d0b857c5a9b73e7d57ed711dbd367f8fced9c77" translate="yes" xml:space="preserve">
          <source>All input arrays with &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt; smaller than the input array of largest &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt;&lt;code&gt;ndim&lt;/code&gt;&lt;/a&gt;, have 1&amp;rsquo;s prepended to their shapes.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;ndim&lt;/code&gt; &lt;/a&gt; 이 가장 큰 &lt;a href=&quot;generated/numpy.ndarray.ndim#numpy.ndarray.ndim&quot;&gt; &lt;code&gt;ndim&lt;/code&gt; &lt;/a&gt; 의 입력 배열보다 작은 ndim을 가진 모든 입력 배열 의 모양 앞에 1이 붙습니다.</target>
        </trans-unit>
        <trans-unit id="2dc665e3a6722e3373db803968527b6b6acc2ba2" translate="yes" xml:space="preserve">
          <source>All members of the Council shall disclose to the rest of the Council any conflict of interest they may have. Members with a conflict of interest in a particular issue may participate in Council discussions on that issue, but must recuse themselves from voting on the issue.</source>
          <target state="translated">이사회의 모든 구성원은 자신이 가질 수있는 이해 상충을 나머지 이사회에 공개해야합니다. 특정 문제에 대해 이해 상충이있는 회원은 해당 문제에 대한 협의회 토론에 참여할 수 있지만 해당 문제에 대한 투표를 거부해야합니다.</target>
        </trans-unit>
        <trans-unit id="e24f9443f9006deb641af5606ae740580a314b94" translate="yes" xml:space="preserve">
          <source>All ndarrays are &lt;a href=&quot;../glossary#term-homogeneous&quot;&gt;homogeneous&lt;/a&gt;: every item takes up the same size block of memory, and all blocks are interpreted in exactly the same way. How each item in the array is to be interpreted is specified by a separate &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt;, one of which is associated with every array. In addition to basic types (integers, floats, &lt;em&gt;etc.&lt;/em&gt;), the data type objects can also represent data structures.</source>
          <target state="translated">모든 ndarray는 &lt;a href=&quot;../glossary#term-homogeneous&quot;&gt;동 질적입니다&lt;/a&gt; . 모든 항목은 동일한 크기의 메모리 블록을 차지하며 모든 블록은 정확히 동일한 방식으로 해석됩니다. 배열의 각 항목을 해석하는 방법은 별도의 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체&lt;/a&gt; 로 지정되며 ,이 중 하나는 모든 배열과 연결됩니다. 기본 유형 (정수, 부동 소수점 &lt;em&gt;등&lt;/em&gt; ) 외에도 데이터 유형 객체는 데이터 구조를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="82a049ad9415682346f46e106edb4fd1fa69cce0" translate="yes" xml:space="preserve">
          <source>All ndarrays are &lt;a href=&quot;../glossary#term-homogenous&quot;&gt;homogenous&lt;/a&gt;: every item takes up the same size block of memory, and all blocks are interpreted in exactly the same way. How each item in the array is to be interpreted is specified by a separate &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt;, one of which is associated with every array. In addition to basic types (integers, floats, &lt;em&gt;etc.&lt;/em&gt;), the data type objects can also represent data structures.</source>
          <target state="translated">모든 ndarray는 &lt;a href=&quot;../glossary#term-homogenous&quot;&gt;동 질적입니다&lt;/a&gt; . 모든 항목은 동일한 크기의 메모리 블록을 차지하며 모든 블록은 정확히 동일한 방식으로 해석됩니다. 배열의 각 항목을 해석하는 방법은 별도의 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체&lt;/a&gt; 로 지정되며 ,이 중 하나는 모든 배열과 연결됩니다. 기본 유형 (정수, 부동 소수점 &lt;em&gt;등&lt;/em&gt; ) 외에도 데이터 유형 객체는 데이터 구조를 나타낼 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca446ec5487618f081b9b30abeedd928222d6468" translate="yes" xml:space="preserve">
          <source>All ndarrays are &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-homogenous&quot;&gt;homogenous&lt;/a&gt;: every item takes up the same size block of memory, and all blocks are interpreted in exactly the same way. How each item in the array is to be interpreted is specified by a separate &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt;, one of which is associated with every array. In addition to basic types (integers, floats, &lt;em&gt;etc.&lt;/em&gt;), the data type objects can also represent data structures.</source>
          <target state="translated">모든 ndarray는 &lt;a href=&quot;https://docs.scipy.org/doc/numpy-1.17.0/glossary.html#term-homogenous&quot;&gt;동종입니다&lt;/a&gt; . 모든 항목은 동일한 크기의 메모리 블록을 차지하며 모든 블록은 정확히 동일한 방식으로 해석됩니다. 배열의 각 항목을 해석하는 방법은 별도의 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object&lt;/a&gt; 로 지정되며 그 중 하나는 모든 배열과 연관됩니다. 기본 유형 (정수, 부동 수 &lt;em&gt;등&lt;/em&gt; ) 외에도 데이터 유형 객체는 데이터 구조를 나타낼 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="da2b25874ee4e8732493aa486d012f0b0bed29b3" translate="yes" xml:space="preserve">
          <source>All of the classes are immutable and have the same methods, and especially they implement the Python numeric operators +, -, *, //, %, divmod, **, ==, and !=. The last two can be a bit problematic due to floating point roundoff errors. We now give a quick demonstration of the various operations using NumPy version 1.7.0.</source>
          <target state="translated">모든 클래스는 불변이며 동일한 메소드를 가지며 특히 Python 숫자 연산자 +,-, *, //, %, divmod, **, == 및! =를 구현합니다. 마지막 두 개는 부동 소수점 반올림 오류로 인해 약간 문제가 될 수 있습니다. 이제 NumPy 버전 1.7.0을 사용한 다양한 작업에 대한 간단한 데모를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d29928171307be63839851bd3b611b16ff9f6059" translate="yes" xml:space="preserve">
          <source>All of the commands above display the results in plain text in the console, and the results are not saved for comparison with future commits. For greater control, a graphical view, and to have results saved for future comparison you can run ASV commands (record results and generate HTML):</source>
          <target state="translated">위의 모든 명령은 콘솔에 일반 텍스트로 결과를 표시하며 향후 커밋과 비교하기 위해 결과가 저장되지 않습니다. 더 나은 제어, 그래픽보기 및 향후 비교를 위해 결과 저장을 위해 ASV 명령을 실행할 수 있습니다 (결과 기록 및 HTML 생성).</target>
        </trans-unit>
        <trans-unit id="d23d8201105a40c14ba3b7be79618b80eab9ec1b" translate="yes" xml:space="preserve">
          <source>All of the numeric data types (integer, floating point, and complex) have constants that are defined to be a specific enumerated type number. Exactly which enumerated type a bit-width type refers to is platform dependent. In particular, the constants available are &lt;code&gt;PyArray_{NAME}{BITS}&lt;/code&gt; where &lt;code&gt;{NAME}&lt;/code&gt; is &lt;strong&gt;INT&lt;/strong&gt;, &lt;strong&gt;UINT&lt;/strong&gt;, &lt;strong&gt;FLOAT&lt;/strong&gt;, &lt;strong&gt;COMPLEX&lt;/strong&gt; and &lt;code&gt;{BITS}&lt;/code&gt; can be 8, 16, 32, 64, 80, 96, 128, 160, 192, 256, and 512. Obviously not all bit-widths are available on all platforms for all the kinds of numeric types. Commonly 8-, 16-, 32-, 64-bit integers; 32-, 64-bit floats; and 64-, 128-bit complex types are available.</source>
          <target state="translated">모든 숫자 데이터 유형 (정수, 부동 소수점 및 복소수)에는 특정 열거 유형 번호로 정의 된 상수가 있습니다. 비트 폭 형식이 참조하는 열거 된 형식은 플랫폼에 따라 다릅니다. 특히 사용 가능한 상수는 &lt;code&gt;PyArray_{NAME}{BITS}&lt;/code&gt; 이며 여기서 &lt;code&gt;{NAME}&lt;/code&gt; 은 &lt;strong&gt;INT&lt;/strong&gt; , &lt;strong&gt;UINT&lt;/strong&gt; , &lt;strong&gt;FLOAT&lt;/strong&gt; , &lt;strong&gt;COMPLEX&lt;/strong&gt; 및 &lt;code&gt;{BITS}&lt;/code&gt; 는 8, 16, 32, 64, 80, 96, 128, 160, 192 일 수 있습니다. 256, 512. 모든 종류의 숫자 유형에 대해 모든 플랫폼에서 모든 비트 폭을 사용할 수있는 것은 아닙니다. 일반적으로 8, 16, 32, 64 비트 정수; 32 비트, 64 비트 플로트; 64, 128 비트 복합 유형을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b5a846311d841d583030d446986226f22871d26f" translate="yes" xml:space="preserve">
          <source>All of the ufunc methods use the same underlying 1-D computational loops with input and output arguments adjusted so that the appropriate reduction takes place. For example, the key to the functioning of reduce is that the 1-D loop is called with the output and the second input pointing to the same position in memory and both having a step- size of 0. The first input is pointing to the input array with a step- size given by the appropriate stride for the selected axis. In this way, the operation performed is</source>
          <target state="translated">모든 ufunc 메소드는 적절한 축소가 발생하도록 입력 및 출력 인수가 조정 된 동일한 기본 1D 계산 루프를 사용합니다. 예를 들어, reduce 기능의 핵심은 1-D 루프가 출력과 두 번째 입력이 메모리에서 동일한 위치를 가리키고 스텝 크기가 0 인 두 번째 입력으로 호출된다는 것입니다. 첫 번째 입력은 선택된 축에 적절한 보폭으로 주어진 단계 크기를 가진 입력 배열. 이런 식으로 수행되는 작업은</target>
        </trans-unit>
        <trans-unit id="5b156f6c315198e56c123c4ccd661578933f08cc" translate="yes" xml:space="preserve">
          <source>All of these functions can be used in &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt;&lt;code&gt;PyArg_ParseTuple&lt;/code&gt;&lt;/a&gt; (&amp;hellip;) with the &amp;ldquo;O&amp;amp;&amp;rdquo; format specifier to automatically convert any Python object to the required C-object. All of these functions return &lt;a href=&quot;#c.NPY_SUCCEED&quot;&gt;&lt;code&gt;NPY_SUCCEED&lt;/code&gt;&lt;/a&gt; if successful and &lt;a href=&quot;#c.NPY_FAIL&quot;&gt;&lt;code&gt;NPY_FAIL&lt;/code&gt;&lt;/a&gt; if not. The first argument to all of these function is a Python object. The second argument is the &lt;strong&gt;address&lt;/strong&gt; of the C-type to convert the Python object to.</source>
          <target state="translated">이러한 모든 함수는 &lt;a href=&quot;https://docs.python.org/dev/c-api/arg.html#c.PyArg_ParseTuple&quot;&gt; &lt;code&gt;PyArg_ParseTuple&lt;/code&gt; &lt;/a&gt; (&amp;hellip;)에서&amp;ldquo;O &amp;amp;&amp;rdquo;형식 지정자와 함께 사용하여 Python 객체를 필요한 C 객체로 자동 변환 할 수 있습니다. 이러한 함수는 모두 성공하면 &lt;a href=&quot;#c.NPY_SUCCEED&quot;&gt; &lt;code&gt;NPY_SUCCEED&lt;/code&gt; 를&lt;/a&gt; 반환 하고 &lt;a href=&quot;#c.NPY_FAIL&quot;&gt; &lt;code&gt;NPY_FAIL&lt;/code&gt; &lt;/a&gt; 않으면 NPY_FAIL을 반환합니다. 이 모든 함수에 대한 첫 번째 주장은 Python 객체입니다. 두 번째 인수는 Python 객체를 변환 할 C 유형 의 &lt;strong&gt;주소&lt;/strong&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="ac4adec62245a4de6e6a0610fe705282ae5f1f53" translate="yes" xml:space="preserve">
          <source>All other types map to &lt;code&gt;object_&lt;/code&gt; for convenience. Code should expect that such types may map to a specific (new) dtype in future the future.</source>
          <target state="translated">다른 모든 유형 은 편의 를 위해 &lt;code&gt;object_&lt;/code&gt; 에 매핑됩니다 . 코드는 이러한 유형이 미래에 특정 (새) dtype에 매핑 될 수 있음을 예상해야합니다. ㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="f9da82563cbc06f236006f76f4f3793a0cca3a52" translate="yes" xml:space="preserve">
          <source>All other types map to &lt;code&gt;object_&lt;/code&gt; for convenience. Code should expect that such types may map to a specific (new) dtype in the future.</source>
          <target state="translated">다른 모든 유형 은 편의 를 위해 &lt;code&gt;object_&lt;/code&gt; 에 매핑됩니다 . 코드는 이러한 유형이 향후 특정 (새) dtype에 매핑 될 수 있음을 예상해야합니다. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="2247f8b0604f20c2ebdf433c5eb69f188bf79464" translate="yes" xml:space="preserve">
          <source>All python indexing operations &lt;code&gt;arr[index]&lt;/code&gt; are organized by first preparing the index and finding the index type. The supported index types are:</source>
          <target state="translated">모든 파이썬 인덱싱 작업 &lt;code&gt;arr[index]&lt;/code&gt; 는 먼저 인덱스를 준비하고 인덱스 유형을 찾아 구성됩니다. 지원되는 색인 유형은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="696c30921da1780c98302e930b24c2f3424b4299" translate="yes" xml:space="preserve">
          <source>All quotes are for clarity.</source>
          <target state="translated">모든 인용문은 명확성을위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="3639ec0f50b0f9a9a60809dc558a8b5d72fef67b" translate="yes" xml:space="preserve">
          <source>All rights reserved.</source>
          <target state="translated">판권 소유.</target>
        </trans-unit>
        <trans-unit id="034cd32b67051bb7ac3ae3412072399da35e625f" translate="yes" xml:space="preserve">
          <source>All the &lt;code&gt;-1&lt;/code&gt; values we are seeing come from &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt;&lt;code&gt;numpy.genfromtxt&lt;/code&gt;&lt;/a&gt; attempting to read missing data from the original &lt;code&gt;.csv&lt;/code&gt; file. Obviously, we don&amp;rsquo;t want to compute missing data as &lt;code&gt;-1&lt;/code&gt; - we just want to skip this value so it doesn&amp;rsquo;t interfere in our analysis. After importing the &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt;&lt;code&gt;numpy.ma&lt;/code&gt;&lt;/a&gt; module, we&amp;rsquo;ll create a new array, this time masking the invalid values:</source>
          <target state="translated">우리가보고 있는 모든 &lt;code&gt;-1&lt;/code&gt; 값 은 원본 &lt;code&gt;.csv&lt;/code&gt; 파일 에서 누락 된 데이터를 읽으려고 시도하는 &lt;a href=&quot;../reference/generated/numpy.genfromtxt#numpy.genfromtxt&quot;&gt; &lt;code&gt;numpy.genfromtxt&lt;/code&gt; &lt;/a&gt; 에서 가져 옵니다 . 분명히 우리는 결측 데이터를 &lt;code&gt;-1&lt;/code&gt; 로 계산 하고 싶지 않습니다. 분석을 방해하지 않도록이 값을 건너 뛰고 싶습니다. &lt;a href=&quot;../reference/maskedarray.generic#module-numpy.ma&quot;&gt; &lt;code&gt;numpy.ma&lt;/code&gt; &lt;/a&gt; 모듈을 가져온 후 새 배열을 만들고 이번에는 잘못된 값을 마스킹합니다.</target>
        </trans-unit>
        <trans-unit id="f230907dd19dccf16b4f94379f148d5d107bfa02" translate="yes" xml:space="preserve">
          <source>All the dates for one month:</source>
          <target state="translated">한 달 동안의 모든 날짜 :</target>
        </trans-unit>
        <trans-unit id="92efcb4e59829949c6cee13f46fe21646e8a17b1" translate="yes" xml:space="preserve">
          <source>All the entries of an array can be masked at once by assigning &lt;code&gt;True&lt;/code&gt; to the mask:</source>
          <target state="translated">마스크에 &lt;code&gt;True&lt;/code&gt; 를 지정하여 배열의 모든 항목을 한 번에 마스킹 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="e10c13da687020f879a5a16ee83f203fa91cc081" translate="yes" xml:space="preserve">
          <source>All the following expressions construct the same block matrix:</source>
          <target state="translated">다음의 모든 표현식은 동일한 블록 매트릭스를 구성합니다.</target>
        </trans-unit>
        <trans-unit id="2ffebe2f92d5f410095769cef8e73e9e4be3848b" translate="yes" xml:space="preserve">
          <source>All the partition algorithms make temporary copies of the data when partitioning along any but the last axis. Consequently, partitioning along the last axis is faster and uses less space than partitioning along any other axis.</source>
          <target state="translated">모든 파티션 알고리즘은 마지막 축 이외의 파티션을 따라 파티션 할 때 데이터의 임시 복사본을 만듭니다. 결과적으로 마지막 축을 따라 분할하는 것이 더 빠르고 다른 축을 따라 분할하는 것보다 적은 공간을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1a70c541e6faf05b3fbeaa0081931d87c5fc3fd1" translate="yes" xml:space="preserve">
          <source>All the sort algorithms make temporary copies of the data when sorting along any but the last axis. Consequently, sorting along the last axis is faster and uses less space than sorting along any other axis.</source>
          <target state="translated">모든 정렬 알고리즘은 마지막 축을 제외하고 정렬 할 때 데이터의 임시 복사본을 만듭니다. 결과적으로 마지막 축을 기준으로 정렬하는 것이 다른 축을 기준으로 정렬하는 것보다 빠르며 공간을 덜 사용합니다.</target>
        </trans-unit>
        <trans-unit id="ab66b8b1e0107e2f156a60aff52485e98cb423a4" translate="yes" xml:space="preserve">
          <source>All the wheels link to a version of &lt;a href=&quot;https://github.com/xianyi/OpenBLAS&quot;&gt;OpenBLAS&lt;/a&gt; supplied via the &lt;a href=&quot;https://github.com/MacPython/openblas-libs&quot;&gt;openblas-libs&lt;/a&gt; repo. The shared object (or DLL) is shipped with in the wheel, renamed to prevent name collisions with other OpenBLAS shared objects that may exist in the filesystem.</source>
          <target state="translated">모든 바퀴 는 &lt;a href=&quot;https://github.com/MacPython/openblas-libs&quot;&gt;openblas-libs&lt;/a&gt; 저장소 를 통해 제공된 &lt;a href=&quot;https://github.com/xianyi/OpenBLAS&quot;&gt;OpenBLAS&lt;/a&gt; 버전에 연결됩니다 . 공유 객체 (또는 DLL)는 파일 시스템에 존재할 수있는 다른 OpenBLAS 공유 객체와의 이름 충돌을 방지하기 위해 이름이 변경된 휠과 함께 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="d9a67449027b4f16bbb9f49aebbf3c5931bf6cfc" translate="yes" xml:space="preserve">
          <source>All three of these functions require the &lt;em&gt;module&lt;/em&gt; object (the return value of Py_InitModule). The &lt;em&gt;name&lt;/em&gt; is a string that labels the value in the module. Depending on which function is called, the &lt;em&gt;value&lt;/em&gt; argument is either a general object (&lt;a href=&quot;#c.PyModule_AddObject&quot;&gt;&lt;code&gt;PyModule_AddObject&lt;/code&gt;&lt;/a&gt; steals a reference to it), an integer constant, or a string constant.</source>
          <target state="translated">이 세 함수 모두 &lt;em&gt;모듈&lt;/em&gt; 객체 (Py_InitModule의 반환 값)가 필요합니다. &lt;em&gt;이름은&lt;/em&gt; 모듈의 값을 레이블 문자열입니다. 호출되는 함수에 따라 &lt;em&gt;값&lt;/em&gt; 인수는 일반 객체 ( &lt;a href=&quot;#c.PyModule_AddObject&quot;&gt; &lt;code&gt;PyModule_AddObject&lt;/code&gt; &lt;/a&gt; 가 참조를 훔칩니다), 정수 상수 또는 문자열 상수입니다.</target>
        </trans-unit>
        <trans-unit id="06c4b64299274980aca1edafbb8e3c5466dde177" translate="yes" xml:space="preserve">
          <source>All timings were taken using Linux on a i5-3570 processor.</source>
          <target state="translated">모든 타이밍은 i5-3570 프로세서에서 Linux를 사용하여 수행되었습니다.</target>
        </trans-unit>
        <trans-unit id="e2286d646fe081e068af4e78b5bd3f84302897ba" translate="yes" xml:space="preserve">
          <source>All timings were taken using Linux on an i5-3570 processor.</source>
          <target state="translated">모든 타이밍은 i5-3570 프로세서에서 Linux를 사용하여 촬영되었습니다.</target>
        </trans-unit>
        <trans-unit id="3b6801ef087b25df864317061c09ae2a58f2f84b" translate="yes" xml:space="preserve">
          <source>All trailing coefficients less than &lt;code&gt;tol&lt;/code&gt; will be removed.</source>
          <target state="translated">&lt;code&gt;tol&lt;/code&gt; 보다 작은 모든 후행 계수 가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="5b1b305863dfd31164de95c6a2ba21a9d7316e39" translate="yes" xml:space="preserve">
          <source>All trigonometric functions use radians when an angle is called for. The ratio of degrees to radians is</source>
          <target state="translated">모든 삼각 함수는 각도가 필요할 때 라디안을 사용합니다. 도 대 라디안의 비율은</target>
        </trans-unit>
        <trans-unit id="21be5744ad69fc918df7773d4afd2f7e1b293377" translate="yes" xml:space="preserve">
          <source>All ufuncs can also take output arguments. If necessary, output will be cast to the data-type(s) of the provided output array(s). If a class with an &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt; method is used for the output, results will be written to the object returned by &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt;&lt;code&gt;__array__&lt;/code&gt;&lt;/a&gt;. Then, if the class also has an &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; method, it is called so metadata may be determined based on the context of the ufunc (the context consisting of the ufunc itself, the arguments passed to the ufunc, and the ufunc domain.) The array object returned by &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt;&lt;code&gt;__array_prepare__&lt;/code&gt;&lt;/a&gt; is passed to the ufunc for computation. Finally, if the class also has an &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt;&lt;code&gt;__array_wrap__&lt;/code&gt;&lt;/a&gt; method, the returned &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; result will be passed to that method just before passing control back to the caller.</source>
          <target state="translated">모든 ufunc는 출력 인수를 취할 수도 있습니다. 필요한 경우 출력은 제공된 출력 배열의 데이터 유형으로 캐스트됩니다. 가지는 클래스 경우 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; 의&lt;/a&gt; 방법은 출력을 위해 사용되며, 결과가 반환 대상에 기록 될 &lt;a href=&quot;arrays.classes#numpy.class.__array__&quot;&gt; &lt;code&gt;__array__&lt;/code&gt; &lt;/a&gt; . 그런 다음 클래스에 &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; 메서드 도있는 경우 ufunc 의 컨텍스트 (ufunc 자체, ufunc에 전달 된 인수 및 ufunc 도메인으로 구성된 컨텍스트)를 기반으로 메타 데이터를 결정할 수 있도록 호출됩니다. &lt;a href=&quot;arrays.classes#numpy.class.__array_prepare__&quot;&gt; &lt;code&gt;__array_prepare__&lt;/code&gt; &lt;/a&gt; 에 의해 반환 된 객체는 계산을 위해 ufunc로 전달됩니다. 마지막으로, 클래스에 &lt;a href=&quot;arrays.classes#numpy.class.__array_wrap__&quot;&gt; &lt;code&gt;__array_wrap__&lt;/code&gt; &lt;/a&gt; 메소드 가있는 경우 반환 된 &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt;결과는 제어를 호출자에게 다시 전달하기 직전에 해당 메소드로 전달됩니다.</target>
        </trans-unit>
        <trans-unit id="2d45789ac1ad3aa209fa7142eb2b247f7550708c" translate="yes" xml:space="preserve">
          <source>All ufuncs have four methods. However, these methods only make sense on scalar ufuncs that take two input arguments and return one output argument. Attempting to call these methods on other ufuncs will cause a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;. The reduce-like methods all take an &lt;em&gt;axis&lt;/em&gt; keyword, a &lt;em&gt;dtype&lt;/em&gt; keyword, and an &lt;em&gt;out&lt;/em&gt; keyword, and the arrays must all have dimension &amp;gt;= 1. The &lt;em&gt;axis&lt;/em&gt; keyword specifies the axis of the array over which the reduction will take place (with negative values counting backwards). Generally, it is an integer, though for &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;, it can also be a tuple of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to reduce over several axes at once, or &lt;code&gt;None&lt;/code&gt;, to reduce over all axes. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to manage a very common problem that arises when naively using &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;. Sometimes you may have an array of a certain data type and wish to add up all of its elements, but the result does not fit into the data type of the array. This commonly happens if you have an array of single-byte integers. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to alter the data type over which the reduction takes place (and therefore the type of the output). Thus, you can ensure that the output is a data type with precision large enough to handle your output. The responsibility of altering the reduce type is mostly up to you. There is one exception: if no &lt;em&gt;dtype&lt;/em&gt; is given for a reduction on the &amp;ldquo;add&amp;rdquo; or &amp;ldquo;multiply&amp;rdquo; operations, then if the input type is an integer (or Boolean) data-type and smaller than the size of the &lt;code&gt;int_&lt;/code&gt; data type, it will be internally upcast to the &lt;code&gt;int_&lt;/code&gt; (or &lt;code&gt;uint&lt;/code&gt;) data-type. Finally, the &lt;em&gt;out&lt;/em&gt; keyword allows you to provide an output array (for single-output ufuncs, which are currently the only ones supported; for future extension, however, a tuple with a single argument can be passed in). If &lt;em&gt;out&lt;/em&gt; is given, the &lt;em&gt;dtype&lt;/em&gt; argument is ignored.</source>
          <target state="translated">모든 ufunc에는 네 가지 방법이 있습니다. 그러나 이러한 메소드는 두 개의 입력 인수를 사용하고 하나의 출력 인수를 리턴하는 스칼라 ufunc에서만 의미가 있습니다. 다른 ufunc에서 이러한 메소드를 호출하려고하면 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . reduce-like 메소드는 모두 &lt;em&gt;축&lt;/em&gt; 키워드, &lt;em&gt;dtype&lt;/em&gt; 키워드 및 &lt;em&gt;out&lt;/em&gt; 키워드를 &lt;em&gt;가져 오며&lt;/em&gt; 배열의 크기는&amp;gt; = 1이어야합니다. &lt;em&gt;axis&lt;/em&gt; 키워드는 축소가 발생하는 배열의 축을 지정합니다 (음수 포함) 거꾸로 세는 값). 대한하지만 일반적으로, 정수입니다 &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;ufunc.reduce&lt;/code&gt; &lt;/a&gt; , 그것도의 튜플이 될 수 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 한 번에 여러 축을 이상 줄이기 위해, 또는 &lt;code&gt;None&lt;/code&gt; 모든 축을 축소합니다. &lt;em&gt;DTYPE의&lt;/em&gt; 키워드는 순진하게 사용할 때 발생하는 매우 일반적인 문제를 관리 할 수 있습니다 &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;ufunc.reduce&lt;/code&gt; 을&lt;/a&gt; . 때로는 특정 데이터 유형의 배열이 있고 모든 요소를 ​​더하고 싶지만 결과가 배열의 데이터 유형에 맞지 않습니다. 단일 바이트 정수 배열이있는 경우 일반적으로 발생합니다. &lt;em&gt;DTYPE&lt;/em&gt; 당신이 감소 (따라서 출력의 종류) 일어나는 통해 데이터 유형을 변경할 수 있습니다 키워드. 따라서 출력이 출력을 처리하기에 충분히 큰 정밀도를 가진 데이터 유형인지 확인할 수 있습니다. 감소 유형을 변경하는 책임은 대부분 귀하에게 달려 있습니다. 한 가지 예외가 있습니다 : &lt;em&gt;dtype&lt;/em&gt; 이없는 경우&lt;em&gt;&lt;/em&gt;&quot;add&quot;또는 &quot;multiply&quot;연산을 줄인 경우 입력 유형이 정수 (또는 부울) 데이터 유형이고 &lt;code&gt;int_&lt;/code&gt; 데이터 유형 의 크기보다 작은 경우 내부적으로 &lt;code&gt;int_&lt;/code&gt; 로 업 캐스트됩니다. (또는 &lt;code&gt;uint&lt;/code&gt; ) 데이터 유형. 마지막으로 &lt;em&gt;out&lt;/em&gt; 키워드를 사용하면 출력 배열을 제공 할 수 있습니다 (단일 출력 ufunc의 경우 현재 유일하게 지원되는 기능이지만 향후 확장을 위해 단일 인수가있는 튜플을 전달할 수 있음). 경우 &lt;em&gt;출력이&lt;/em&gt; 주어진다는 &lt;em&gt;DTYPE의&lt;/em&gt; 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="07e4ecf9fa6d320e1c75b5c65b73ea6ee2358cf7" translate="yes" xml:space="preserve">
          <source>All ufuncs have four methods. However, these methods only make sense on scalar ufuncs that take two input arguments and return one output argument. Attempting to call these methods on other ufuncs will cause a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;. The reduce-like methods all take an &lt;em&gt;axis&lt;/em&gt; keyword, a &lt;em&gt;dtype&lt;/em&gt; keyword, and an &lt;em&gt;out&lt;/em&gt; keyword, and the arrays must all have dimension &amp;gt;= 1. The &lt;em&gt;axis&lt;/em&gt; keyword specifies the axis of the array over which the reduction will take place (with negative values counting backwards). Generally, it is an integer, though for &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;, it can also be a tuple of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to reduce over several axes at once, or None, to reduce over all axes. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to manage a very common problem that arises when naively using &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;. Sometimes you may have an array of a certain data type and wish to add up all of its elements, but the result does not fit into the data type of the array. This commonly happens if you have an array of single-byte integers. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to alter the data type over which the reduction takes place (and therefore the type of the output). Thus, you can ensure that the output is a data type with precision large enough to handle your output. The responsibility of altering the reduce type is mostly up to you. There is one exception: if no &lt;em&gt;dtype&lt;/em&gt; is given for a reduction on the &amp;ldquo;add&amp;rdquo; or &amp;ldquo;multiply&amp;rdquo; operations, then if the input type is an integer (or Boolean) data-type and smaller than the size of the &lt;a href=&quot;arrays.scalars#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt; data type, it will be internally upcast to the &lt;a href=&quot;arrays.scalars#numpy.int_&quot;&gt;&lt;code&gt;int_&lt;/code&gt;&lt;/a&gt; (or &lt;a href=&quot;arrays.scalars#numpy.uint&quot;&gt;&lt;code&gt;uint&lt;/code&gt;&lt;/a&gt;) data-type. Finally, the &lt;em&gt;out&lt;/em&gt; keyword allows you to provide an output array (for single-output ufuncs, which are currently the only ones supported; for future extension, however, a tuple with a single argument can be passed in). If &lt;em&gt;out&lt;/em&gt; is given, the &lt;em&gt;dtype&lt;/em&gt; argument is ignored.</source>
          <target state="translated">모든 ufunc에는 네 가지 방법이 있습니다. 그러나 이러한 메서드는 두 개의 입력 인수를 사용하고 하나의 출력 인수를 반환하는 스칼라 ufunc에서만 의미가 있습니다. 다른 ufuncs에서 이러한 메서드를 호출하려고하면 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . reduce-like 메서드는 모두 &lt;em&gt;axis&lt;/em&gt; 키워드, &lt;em&gt;dtype&lt;/em&gt; 키워드 및 &lt;em&gt;out&lt;/em&gt; 키워드를 &lt;em&gt;취&lt;/em&gt; 하며 배열은 모두 차원이 1 보다 &lt;em&gt;커야&lt;/em&gt; 합니다. &lt;em&gt;axis&lt;/em&gt; 키워드는 축소가 발생할 배열의 축을 지정합니다 (음수로 거꾸로 세는 값). 일반적으로 정수이지만 &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;ufunc.reduce&lt;/code&gt; 의&lt;/a&gt; 경우 한 번에 여러 축에서 축소하려면 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 의 튜플이 될 수도 있고 모든 축에서 축소하려면 None 튜플이 될 수도 있습니다 . &lt;em&gt;DTYPE&lt;/em&gt;키워드를 사용하면 &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;ufunc.reduce&lt;/code&gt; 를&lt;/a&gt; 순진하게 사용할 때 발생하는 매우 일반적인 문제를 관리 할 수 ​​있습니다 . 때로는 특정 데이터 유형의 배열이 있고 모든 요소를 ​​더하고 싶지만 결과가 배열의 데이터 유형에 맞지 않습니다. 이것은 일반적으로 단일 바이트 정수 배열이있는 경우 발생합니다. &lt;em&gt;DTYPE&lt;/em&gt; 당신이 감소 (따라서 출력의 종류) 일어나는 통해 데이터 유형을 변경할 수 있습니다 키워드. 따라서 출력이 출력을 처리하기에 충분히 큰 정밀도를 가진 데이터 유형인지 확인할 수 있습니다. 축소 유형을 변경하는 책임은 대부분 사용자에게 있습니다. 한 가지 예외가 있습니다. &lt;em&gt;dtype&lt;/em&gt; 이없는 경우&lt;em&gt;&lt;/em&gt;&quot;add&quot;또는 &quot;multiply&quot;연산의 감소를 위해 주어진 경우 입력 유형이 정수 (또는 부울) 데이터 유형이고 &lt;a href=&quot;arrays.scalars#numpy.int_&quot;&gt; &lt;code&gt;int_&lt;/code&gt; &lt;/a&gt; 데이터 유형 의 크기보다 작 으면 내부적으로 &lt;a href=&quot;arrays.scalars#numpy.int_&quot;&gt; &lt;code&gt;int_&lt;/code&gt; 로&lt;/a&gt; 업 캐스트됩니다. (또는 &lt;a href=&quot;arrays.scalars#numpy.uint&quot;&gt; &lt;code&gt;uint&lt;/code&gt; &lt;/a&gt; ) 데이터 유형. 마지막으로, &lt;em&gt;out&lt;/em&gt; 키워드를 사용하면 출력 배열을 제공 할 수 있습니다 (현재 유일하게 지원되는 단일 출력 ufunc의 경우; 향후 확장을 위해 단일 인수가있는 튜플을 전달할 수 있음). 경우 &lt;em&gt;출력이&lt;/em&gt; 주어진다는 &lt;em&gt;DTYPE의&lt;/em&gt; 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="d1d4dcf2513f280307ea7212ad2484d4d7691b21" translate="yes" xml:space="preserve">
          <source>All ufuncs have four methods. However, these methods only make sense on scalar ufuncs that take two input arguments and return one output argument. Attempting to call these methods on other ufuncs will cause a &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt;&lt;code&gt;ValueError&lt;/code&gt;&lt;/a&gt;. The reduce-like methods all take an &lt;em&gt;axis&lt;/em&gt; keyword, a &lt;em&gt;dtype&lt;/em&gt; keyword, and an &lt;em&gt;out&lt;/em&gt; keyword, and the arrays must all have dimension &amp;gt;= 1. The &lt;em&gt;axis&lt;/em&gt; keyword specifies the axis of the array over which the reduction will take place (with negative values counting backwards). Generally, it is an integer, though for &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;, it can also be a tuple of &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to reduce over several axes at once, or None, to reduce over all axes. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to manage a very common problem that arises when naively using &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt;&lt;code&gt;ufunc.reduce&lt;/code&gt;&lt;/a&gt;. Sometimes you may have an array of a certain data type and wish to add up all of its elements, but the result does not fit into the data type of the array. This commonly happens if you have an array of single-byte integers. The &lt;em&gt;dtype&lt;/em&gt; keyword allows you to alter the data type over which the reduction takes place (and therefore the type of the output). Thus, you can ensure that the output is a data type with precision large enough to handle your output. The responsibility of altering the reduce type is mostly up to you. There is one exception: if no &lt;em&gt;dtype&lt;/em&gt; is given for a reduction on the &amp;ldquo;add&amp;rdquo; or &amp;ldquo;multiply&amp;rdquo; operations, then if the input type is an integer (or Boolean) data-type and smaller than the size of the &lt;code&gt;int_&lt;/code&gt; data type, it will be internally upcast to the &lt;code&gt;int_&lt;/code&gt; (or &lt;code&gt;uint&lt;/code&gt;) data-type. Finally, the &lt;em&gt;out&lt;/em&gt; keyword allows you to provide an output array (for single-output ufuncs, which are currently the only ones supported; for future extension, however, a tuple with a single argument can be passed in). If &lt;em&gt;out&lt;/em&gt; is given, the &lt;em&gt;dtype&lt;/em&gt; argument is ignored.</source>
          <target state="translated">모든 ufunc에는 네 가지 방법이 있습니다. 그러나 이러한 메서드는 두 개의 입력 인수를 사용하고 하나의 출력 인수를 반환하는 스칼라 ufunc에서만 의미가 있습니다. 다른 ufuncs에서 이러한 메서드를 호출하려고하면 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#ValueError&quot;&gt; &lt;code&gt;ValueError&lt;/code&gt; &lt;/a&gt; 가 발생합니다 . reduce-like 메서드는 모두 &lt;em&gt;axis&lt;/em&gt; 키워드, &lt;em&gt;dtype&lt;/em&gt; 키워드 및 &lt;em&gt;out&lt;/em&gt; 키워드를 &lt;em&gt;취&lt;/em&gt; 하며 배열은 모두 차원이 1 보다 &lt;em&gt;커야&lt;/em&gt; 합니다. &lt;em&gt;axis&lt;/em&gt; 키워드는 축소가 발생할 배열의 축을 지정합니다 (음수로 거꾸로 세는 값). 일반적으로 정수이지만 &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;ufunc.reduce&lt;/code&gt; 의&lt;/a&gt; 경우 한 번에 여러 축에서 축소하려면 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#int&quot;&gt; &lt;code&gt;int&lt;/code&gt; &lt;/a&gt; 의 튜플이 될 수도 있고 모든 축에서 축소하려면 None 튜플이 될 수도 있습니다 . &lt;em&gt;DTYPE&lt;/em&gt;키워드를 사용하면 &lt;a href=&quot;generated/numpy.ufunc.reduce#numpy.ufunc.reduce&quot;&gt; &lt;code&gt;ufunc.reduce&lt;/code&gt; 를&lt;/a&gt; 순진하게 사용할 때 발생하는 매우 일반적인 문제를 관리 할 수 ​​있습니다 . 때로는 특정 데이터 유형의 배열이 있고 모든 요소를 ​​더하고 싶지만 결과가 배열의 데이터 유형에 맞지 않습니다. 이것은 일반적으로 단일 바이트 정수 배열이있는 경우 발생합니다. &lt;em&gt;DTYPE&lt;/em&gt; 당신이 감소 (따라서 출력의 종류) 일어나는 통해 데이터 유형을 변경할 수 있습니다 키워드. 따라서 출력이 출력을 처리하기에 충분히 큰 정밀도를 가진 데이터 유형인지 확인할 수 있습니다. 축소 유형을 변경하는 책임은 대부분 사용자에게 있습니다. 한 가지 예외가 있습니다. &lt;em&gt;dtype&lt;/em&gt; 이없는 경우&lt;em&gt;&lt;/em&gt;&quot;add&quot;또는 &quot;multiply&quot;연산의 감소를 위해 주어진 경우 입력 유형이 정수 (또는 부울) 데이터 유형이고 &lt;code&gt;int_&lt;/code&gt; 데이터 유형 의 크기보다 작 으면 내부적으로 &lt;code&gt;int_&lt;/code&gt; 로 업 캐스트됩니다. (또는 &lt;code&gt;uint&lt;/code&gt; ) 데이터 유형. 마지막으로, &lt;em&gt;out&lt;/em&gt; 키워드를 사용하면 출력 배열을 제공 할 수 있습니다 (현재 유일하게 지원되는 단일 출력 ufunc의 경우; 향후 확장을 위해 단일 인수가있는 튜플을 전달할 수 있음). 경우 &lt;em&gt;출력이&lt;/em&gt; 주어진다는 &lt;em&gt;DTYPE의&lt;/em&gt; 인수는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="e2318c4003a311a2e1f7718e453877fa81f4be7b" translate="yes" xml:space="preserve">
          <source>All ufuncs take optional keyword arguments. Most of these represent advanced usage and will not typically be used.</source>
          <target state="translated">모든 ufunc는 선택적 키워드 인수를 사용합니다. 이들 대부분은 고급 사용을 나타내며 일반적으로 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="08323fec08cd786e333ebc5f45dc257ddef21b88" translate="yes" xml:space="preserve">
          <source>All values are within the given interval:</source>
          <target state="translated">모든 값은 주어진 간격 내에 있습니다 :</target>
        </trans-unit>
        <trans-unit id="3557caeafcef351493a190e0ca76e645501ead19" translate="yes" xml:space="preserve">
          <source>All warnings matching will be appended to the &lt;code&gt;log&lt;/code&gt; attribute.</source>
          <target state="translated">일치하는 모든 경고가 &lt;code&gt;log&lt;/code&gt; 속성에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="426f4527d218a846a225248157056b44e9737a63" translate="yes" xml:space="preserve">
          <source>All wrappers for Fortran/C routines, common blocks, or for Fortran 90 module data generated by F2PY are exposed to Python as &lt;code&gt;fortran&lt;/code&gt; type objects. Routine wrappers are callable &lt;code&gt;fortran&lt;/code&gt; type objects while wrappers to Fortran data have attributes referring to data objects.</source>
          <target state="translated">Fortran / C 루틴, 공통 블록 또는 F2PY에 의해 생성 된 Fortran 90 모듈 데이터에 대한 모든 래퍼는 &lt;code&gt;fortran&lt;/code&gt; 유형 객체 로 Python에 노출됩니다 . 루틴 래퍼는 호출 가능한 &lt;code&gt;fortran&lt;/code&gt; 유형 개체이며 Fortran 데이터에 대한 래퍼에는 데이터 개체를 참조하는 속성이 있습니다.</target>
        </trans-unit>
        <trans-unit id="bcb93f844114838b65254a80c40f12714c2f98e5" translate="yes" xml:space="preserve">
          <source>All you need to do to create a simple array is pass a list to it. If you choose to, you can also specify the type of data in your list. &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes&quot;&gt;You can find more information about data types here&lt;/a&gt;.</source>
          <target state="translated">간단한 배열을 만들려면 목록을 전달하기 만하면됩니다. 원하는 경우 목록에서 데이터 유형을 지정할 수도 있습니다. &lt;a href=&quot;../reference/arrays.dtypes#arrays-dtypes&quot;&gt;여기에서 데이터 유형에 대한 자세한 정보를 찾을 수 있습니다&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="190e63cbf64f38a9fb9c04176580017c05722f39" translate="yes" xml:space="preserve">
          <source>All you need to do to plot your values is run:</source>
          <target state="translated">값을 플로팅하기 위해 수행해야하는 모든 작업은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="d955aebd5a8ee7c5f8fcd53e07c9aa820263c95f" translate="yes" xml:space="preserve">
          <source>Allan Haldane</source>
          <target state="translated">앨런 할데 인</target>
        </trans-unit>
        <trans-unit id="126850f0cc1d2b0e1d107977aa577dc3ee5009a2" translate="yes" xml:space="preserve">
          <source>Allocatable arrays</source>
          <target state="translated">할당 가능한 어레이</target>
        </trans-unit>
        <trans-unit id="85b6fefe401a8781996bd809383b4e94b035998f" translate="yes" xml:space="preserve">
          <source>Allow a copy of &lt;code&gt;op[i]&lt;/code&gt; to be made if it does not meet the data type or alignment requirements as specified by the constructor flags and parameters.</source>
          <target state="translated">&lt;code&gt;op[i]&lt;/code&gt; 사본이 생성자 플래그 및 매개 변수로 지정된 데이터 유형 또는 정렬 요구 사항을 충족하지 않는 경우 작성하십시오.</target>
        </trans-unit>
        <trans-unit id="9404967cc7ae4678bf28075900a5a4a4ae1c650b" translate="yes" xml:space="preserve">
          <source>Allow any cast, no matter what kind of data loss may occur.</source>
          <target state="translated">어떤 종류의 데이터 손실이 발생하더라도 캐스트를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="546d0b09674a5e30e0706f69483253c6d7dc53df" translate="yes" xml:space="preserve">
          <source>Allow any safe casts, and casts between types of the same kind. For example, float64 -&amp;gt; float32 is permitted with this rule.</source>
          <target state="translated">안전한 캐스트를 허용하고 같은 종류의 유형간에 캐스트하십시오. 예를 들어, float64-&amp;gt; float32는이 규칙에서 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="71319fc3e3ecea9eef5b367acc6390a448015540" translate="yes" xml:space="preserve">
          <source>Allow dtype field names to be unicode in Python 2</source>
          <target state="translated">Python 2에서 dtype 필드 이름이 유니 코드가되도록 허용</target>
        </trans-unit>
        <trans-unit id="897375acca9fa85a02ea8180e3301f00c8d2bb31" translate="yes" xml:space="preserve">
          <source>Allow identical and casts involving byte swapping.</source>
          <target state="translated">바이트 스와핑과 관련된 동일한 캐스트를 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="5e82a87fb0d9abd791679a7a9c324f1f365a79d4" translate="yes" xml:space="preserve">
          <source>Allow loading pickled object arrays stored in npy files. Reasons for disallowing pickles include security, as loading pickled data can execute arbitrary code. If pickles are disallowed, loading object arrays will fail. Default: False</source>
          <target state="translated">npy 파일에 저장된 절인 객체 배열을로드 할 수 있습니다. 피클을 허용하지 않는 이유는 보안이 포함됩니다. 피클 링 된 데이터를로드하면 임의 코드가 실행될 수 있습니다. 피클이 허용되지 않으면 객체 배열로드가 실패합니다. 기본값 : 거짓</target>
        </trans-unit>
        <trans-unit id="419825e4a25669fb8acd2b4871a5ccac5cea601a" translate="yes" xml:space="preserve">
          <source>Allow matmul (&lt;code&gt;@&lt;/code&gt; operator) to work with object arrays.</source>
          <target state="translated">matmul ( &lt;code&gt;@&lt;/code&gt; 연산자)이 객체 배열과 함께 작동하도록 허용 합니다.</target>
        </trans-unit>
        <trans-unit id="3899d340cbeec687aaed3a39fcea31f537e754c9" translate="yes" xml:space="preserve">
          <source>Allow passing optimizations arguments to asv build</source>
          <target state="translated">asv 빌드에 최적화 인수 전달 허용</target>
        </trans-unit>
        <trans-unit id="aec03ff5fb7ac11a8270b0f45527f1de213187ed" translate="yes" xml:space="preserve">
          <source>Allow saving arrays with large number of named columns</source>
          <target state="translated">많은 수의 명명 된 열이있는 배열 저장 허용</target>
        </trans-unit>
        <trans-unit id="b7be66bfaf7dddda32176dfbd8947ed7745d9801" translate="yes" xml:space="preserve">
          <source>Allow saving object arrays using Python pickles. Reasons for disallowing pickles include security (loading pickled data can execute arbitrary code) and portability (pickled objects may not be loadable on different Python installations, for example if the stored objects require libraries that are not available, and not all pickled data is compatible between Python 2 and Python 3). Default: True</source>
          <target state="translated">파이썬 피클을 사용하여 객체 배열을 저장할 수 있습니다. 피클을 허용하지 않는 이유에는 보안 (피클 링 된 데이터를로드하면 임의의 코드를 실행할 수 있음) 및 이식성 (예 : 저장된 오브젝트에 사용할 수없는 라이브러리가 필요하고 모든 피클 링 된 데이터가 호환되지 않는 경우와 같이 다른 Python 설치에서 피클 링 된 오브젝트를로드 할 수 없음)가 있습니다. 파이썬 2와 파이썬 3). 기본값 : True</target>
        </trans-unit>
        <trans-unit id="54a3f63d2a62cea8a28f6112a74010f0a2fa0c89" translate="yes" xml:space="preserve">
          <source>Allows memory-mapping of the data. See &lt;code&gt;open_memmep&lt;/code&gt;.</source>
          <target state="translated">데이터의 메모리 매핑을 허용합니다. &lt;code&gt;open_memmep&lt;/code&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9475de22330f0492d32cb9f57a359ae9ebe0344c" translate="yes" xml:space="preserve">
          <source>Allows reductions of empty arrays where they would normally fail, i.e. for ufuncs without an identity.</source>
          <target state="translated">일반적으로 실패하는 빈 배열 (예 : ID가없는 ufunc)을 줄일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3c1f6d0da5555e3d148fda468da9cf9586ca5528" translate="yes" xml:space="preserve">
          <source>Along with their (mostly) C-derived names, the integer, float, and complex data-types are also available using a bit-width convention so that an array of the right size can always be ensured. Two aliases (&lt;a href=&quot;#numpy.intp&quot;&gt;&lt;code&gt;numpy.intp&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#numpy.uintp&quot;&gt;&lt;code&gt;numpy.uintp&lt;/code&gt;&lt;/a&gt;) pointing to the integer type that is sufficiently large to hold a C pointer are also provided.</source>
          <target state="translated">(대부분) C 파생 이름과 함께 정수, 부동 소수점 및 복잡한 데이터 유형도 비트 너비 규칙을 사용하여 사용할 수 있으므로 항상 올바른 크기의 배열을 보장 할 수 있습니다. C 포인터를 보유하기에 충분히 큰 정수 유형을 가리키는 두 개의 별명 ​​( &lt;a href=&quot;#numpy.intp&quot;&gt; &lt;code&gt;numpy.intp&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;#numpy.uintp&quot;&gt; &lt;code&gt;numpy.uintp&lt;/code&gt; &lt;/a&gt; )도 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="f4262e7f150c5914529572b5cd9e309be4f3a1f9" translate="yes" xml:space="preserve">
          <source>Alpha, positive (&amp;gt;0).</source>
          <target state="translated">알파, 양수 (&amp;gt; 0).</target>
        </trans-unit>
        <trans-unit id="1ebdee21b6a505b4aeefd9e14363fed83b554743" translate="yes" xml:space="preserve">
          <source>Alpha: &amp;lsquo;1.8.0a1&amp;rsquo;, &amp;lsquo;1.8.0a2&amp;rsquo;, etc.</source>
          <target state="translated">알파 : '1.8.0a1', '1.8.0a2'등</target>
        </trans-unit>
        <trans-unit id="6c7c998a02d246ade8effb246636669d3017223d" translate="yes" xml:space="preserve">
          <source>Alpine Linux (and other musl c library distros) support</source>
          <target state="translated">Alpine Linux (및 기타 musl c 라이브러리 배포판) 지원</target>
        </trans-unit>
        <trans-unit id="da5e93aa3d78ef4ca7f7e53b7add77cc4b81efd4" translate="yes" xml:space="preserve">
          <source>Also accepts mu and sigma arguments.</source>
          <target state="translated">mu 및 sigma 인수도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="0b7c5f22b134cc3af66091a2f87fc3b22e43c5ef" translate="yes" xml:space="preserve">
          <source>Also allow scalars for indices.</source>
          <target state="translated">인덱스에 스칼라도 허용합니다.</target>
        </trans-unit>
        <trans-unit id="7251c141a65a5184415cbe928540e28b3360dffd" translate="yes" xml:space="preserve">
          <source>Also assume below that if the Notes talk about &amp;ldquo;matrix&amp;rdquo; that the arguments are two-dimensional entities.</source>
          <target state="translated">또한 Notes에서 &quot;매트릭스&quot;에 대해 언급하는 경우 인수가 2 차원 엔티티라고 가정합니다.</target>
        </trans-unit>
        <trans-unit id="58b23d955c4db2fc902a47049ecca184e6d09b31" translate="yes" xml:space="preserve">
          <source>Also create a new version hash in cversions.txt and a corresponding version define NPY_x_y_API_VERSION in numpyconfig.h</source>
          <target state="translated">또한 cversions.txt에 새 버전 해시를 만들고 해당 버전은 numpyconfig.h에 NPY_x_y_API_VERSION을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="a5239de48d300a49d551d40943d2cca20a2a2387" translate="yes" xml:space="preserve">
          <source>Also known as rolling or moving window, the window slides across all dimensions of the array and extracts subsets of the array at all window positions.</source>
          <target state="translated">롤링 또는 이동 창이라고도하는이 창은 배열의 모든 차원에서 슬라이드하고 모든 창 위치에서 배열의 하위 집합을 추출합니다.</target>
        </trans-unit>
        <trans-unit id="0d90d80696a309c7c8556cc68ea2ea97804da3bb" translate="yes" xml:space="preserve">
          <source>Also known as the Lorentz distribution.</source>
          <target state="translated">Lorentz 분포라고도합니다.</target>
        </trans-unit>
        <trans-unit id="5314418ba7fc916c6ffe45c7e85e8067bf9357ce" translate="yes" xml:space="preserve">
          <source>Also known as the power function distribution.</source>
          <target state="translated">전력 함수 분포라고도합니다.</target>
        </trans-unit>
        <trans-unit id="5d179db72fc2e3131c342afeebad7f69e76c4889" translate="yes" xml:space="preserve">
          <source>Also note that, in general, the result of integrating a C-series needs to be &amp;ldquo;reprojected&amp;rdquo; onto the C-series basis set. Thus, typically, the result of this function is &amp;ldquo;unintuitive,&amp;rdquo; albeit correct; see Examples section below.</source>
          <target state="translated">또한 일반적으로 C 시리즈 통합 결과는 C 시리즈 기본 세트에 &quot;재 투영&quot;되어야합니다. 따라서 일반적으로이 기능의 결과는 정확하지만 &quot;직관적이지 않습니다&quot;. 아래 예 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5069b3090820edc390ac4ea5af79b726578db6bc" translate="yes" xml:space="preserve">
          <source>Also recognize that &lt;code&gt;x[[1,2,3]]&lt;/code&gt; will trigger advanced indexing, whereas due to the deprecated Numeric compatibility mentioned above, &lt;code&gt;x[[1,2,slice(None)]]&lt;/code&gt; will trigger basic slicing.</source>
          <target state="translated">또한 &lt;code&gt;x[[1,2,3]]&lt;/code&gt; 은 고급 인덱싱을 트리거하는 반면 위에 언급되지 않은 Numeric 호환성으로 인해 &lt;code&gt;x[[1,2,slice(None)]]&lt;/code&gt; 은 기본 슬라이싱을 트리거합니다.</target>
        </trans-unit>
        <trans-unit id="b365c08da5d9707f8066a8a059aebd1096efa490" translate="yes" xml:space="preserve">
          <source>Also since much of NumPy is legacy code that was originally written without unit tests, there are still several modules that don&amp;rsquo;t have tests yet. Please feel free to choose one of these modules and develop tests for it.</source>
          <target state="translated">또한 NumPy의 대부분은 원래 단위 테스트없이 작성된 레거시 코드이므로 아직 테스트가없는 모듈이 여러 개 있습니다. 이 모듈 중 하나를 자유롭게 선택하고 테스트를 개발하십시오. ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ ㅇㅇㅇ</target>
        </trans-unit>
        <trans-unit id="9d3aba4a2ff6c27b4f1a5e2eacd22c21dc662d1b" translate="yes" xml:space="preserve">
          <source>Also to temporarily override options, use &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt;&lt;code&gt;printoptions&lt;/code&gt;&lt;/a&gt; as a context manager:</source>
          <target state="translated">또한 일시적으로 옵션을 재정의하려면 &lt;a href=&quot;numpy.printoptions#numpy.printoptions&quot;&gt; &lt;code&gt;printoptions&lt;/code&gt; &lt;/a&gt; 를 컨텍스트 관리자로 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="40ce80b72a9c1717eb089ed66d73f56dd1035944" translate="yes" xml:space="preserve">
          <source>Also works for complex numbers (and thus can be used to map any line in the complex plane to any other line therein).</source>
          <target state="translated">복소수에도 적용됩니다 (따라서 복소 평면의 모든 선을 그 안의 다른 선에 매핑하는 데 사용할 수 있음).</target>
        </trans-unit>
        <trans-unit id="ae4104c7b18b9b6bb1e8bc147a280cadca288f5d" translate="yes" xml:space="preserve">
          <source>Also works for complex numbers, and thus can be used to calculate the parameters required to map any line in the complex plane to any other line therein.</source>
          <target state="translated">복소수에도 적용되므로 복소 평면의 모든 선을 다른 선에 매핑하는 데 필요한 매개 변수를 계산하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4d0e510cfcbca13b6ef52b5ccc774d1f9c86ee20" translate="yes" xml:space="preserve">
          <source>Also, when invoking the entire NumPy test suite, your tests will be found and run:</source>
          <target state="translated">또한 전체 NumPy 테스트 스위트를 호출 할 때 테스트가 발견되고 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="0f352a3bcd45d367a7b48fa8429730ec7b58156e" translate="yes" xml:space="preserve">
          <source>Also, when invoking the entire SciPy test suite, your tests will be found and run:</source>
          <target state="translated">또한 전체 SciPy 테스트 스위트를 호출 할 때 테스트를 찾아 실행합니다.</target>
        </trans-unit>
        <trans-unit id="d3ae98cb5ab74a7083d29594486afdfdec895748" translate="yes" xml:space="preserve">
          <source>Also, when wrapping C functions, one must use &lt;code&gt;intent(c)&lt;/code&gt; attribute for &lt;code&gt;&amp;lt;routine name&amp;gt;&lt;/code&gt; in order to disable Fortran specific &lt;code&gt;F_FUNC(..,..)&lt;/code&gt; macros.</source>
          <target state="translated">또한 C 함수를 래핑 할 때 Fortran 특정 &lt;code&gt;F_FUNC(..,..)&lt;/code&gt; 매크로 를 비활성화하려면 &lt;code&gt;&amp;lt;routine name&amp;gt;&lt;/code&gt; 에 &lt;code&gt;intent(c)&lt;/code&gt; 속성을 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="154136fcc4f44eb3b036da90a8bd08a2c9f62dbd" translate="yes" xml:space="preserve">
          <source>Alternate array object(s) in which to put the result; if provided, it must have a shape that the inputs broadcast to. A tuple of arrays (possible only as a keyword argument) must have length equal to the number of outputs; use None for uninitialized outputs to be allocated by the ufunc.</source>
          <target state="translated">결과를 넣을 대체 배열 객체; 제공되는 경우 입력이 브로드 캐스트되는 모양을 가져야합니다. 배열의 튜플 (키워드 인수로만 가능)은 출력 수와 같은 길이를 가져야합니다. 초기화되지 않은 출력이 ufunc에 의해 할당되도록하려면 None을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="186b59c13765d3d0d9381ad5de4a7d8b82c29991" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if &lt;code&gt;dtype(out)&lt;/code&gt; is float, the result will consist of 0.0&amp;rsquo;s and 1.0&amp;rsquo;s). See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하고 유형이 유지되어야합니다 (예 : &lt;code&gt;dtype(out)&lt;/code&gt; 이 float이면 결과는 0.0과 1.0으로 구성됩니다). 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="c1698709727c2d257ee26f16d4cc2df0ac59e987" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if &lt;code&gt;dtype(out)&lt;/code&gt; is float, the result will consist of 0.0&amp;rsquo;s and 1.0&amp;rsquo;s). See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 동일해야하며 유형이 유지됩니다 (예 : &lt;code&gt;dtype(out)&lt;/code&gt; 이 부동이면 결과는 0.0과 1.0으로 구성됨 ). 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; (섹션&amp;ldquo;출력 인수&amp;rdquo;)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="95f8e28a3239be3e35610b35ae41af8f03a1a373" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if &lt;code&gt;dtype(out)&lt;/code&gt; is float, the result will consist of 0.0&amp;rsquo;s and 1.0&amp;rsquo;s). See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하고 유형이 유지되어야합니다 (예 : &lt;code&gt;dtype(out)&lt;/code&gt; 이 float이면 결과는 0.0과 1.0으로 구성됩니다). 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="05d635b829a3272cd2c92ec40258a7d4b60c9c89" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if it is of type float, then it will remain so, returning 1.0 for True and 0.0 for False, regardless of the type of &lt;code&gt;a&lt;/code&gt;). See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 동일해야하며 유형이 유지되어야합니다 (예 : float 유형 인 경우 &lt;code&gt;a&lt;/code&gt; 유형에 관계없이 True에 대해 1.0을 반환하고 False에 대해 0.0을 반환 ). 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e7d8cfa461bbd4723af0411cedff8e47a335d9d0" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if it is of type float, then it will remain so, returning 1.0 for True and 0.0 for False, regardless of the type of &lt;code&gt;a&lt;/code&gt;). See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 동일해야하며 유형이 유지됩니다 (예 : float 유형 인 &lt;code&gt;a&lt;/code&gt; ). 유형에 관계없이 True의 경우 1.0, False의 경우 0.0을 반환 합니다. 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; (섹션&amp;ldquo;출력 인수&amp;rdquo;)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="7db01b91ec975c6069f8aa13f1c695893071334f" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output and its type is preserved (e.g., if it is of type float, then it will remain so, returning 1.0 for True and 0.0 for False, regardless of the type of &lt;code&gt;a&lt;/code&gt;). See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 동일해야하며 유형이 유지되어야합니다 (예 : float 유형 인 경우 &lt;code&gt;a&lt;/code&gt; 유형에 관계없이 True에 대해 1.0을 반환하고 False에 대해 0.0을 반환 ). 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="4866e784e2d9af93d956076b9ca654f019b24a96" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. It must have the same shape as the expected output, but the type is cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 유형이 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="226b9f31a57381e88270efcf56d05a2acdd0d4be" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;. If provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details. The casting of NaN to integer can yield unexpected results.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다. 제공되는 경우 예상 출력과 모양이 동일해야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오. NaN을 정수로 캐스팅하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cb1ad439f43dc00d7ef73618d741c98ced923654" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;. If provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; for details. The casting of NaN to integer can yield unexpected results.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다. 제공되는 경우 예상 출력과 모양이 같아야하지만 필요한 경우 유형이 캐스팅됩니다. 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; 를 참조하십시오. NaN을 정수로 캐스팅하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="38808f978bef951a5c3af38877e5f4e00fc749f3" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;. If provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details. The casting of NaN to integer can yield unexpected results.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; 입니다. 제공되는 경우 예상 출력과 모양이 동일해야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오. NaN을 정수로 캐스팅하면 예기치 않은 결과가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="44b0fc31b204b79086bfe677cbdfc1824ce755c7" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; . 제공되는 경우 예상 출력과 모양이 동일해야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a1df7e48a8694bc511c33f4fdb83c6299c349bb3" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; for details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 디폴트는 &lt;code&gt;None&lt;/code&gt; 입니다 . 제공되는 경우 예상 출력과 모양이 같아야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="d2c40a652c7d0a0ce2c8ac32e90d759ce3f5fbf3" translate="yes" xml:space="preserve">
          <source>Alternate output array in which to place the result. The default is &lt;code&gt;None&lt;/code&gt;; if provided, it must have the same shape as the expected output, but the type will be cast if necessary. See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 기본값은 &lt;code&gt;None&lt;/code&gt; . 제공되는 경우 예상 출력과 모양이 동일해야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ee2621619f5de76df486cb10b39483168645510" translate="yes" xml:space="preserve">
          <source>Alternately, one can omit the &lt;code&gt;seed&lt;/code&gt; parameter and set the &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; directly.</source>
          <target state="translated">또는 &lt;code&gt;seed&lt;/code&gt; 매개 변수를 생략 하고 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;counter&lt;/code&gt; 직접 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ad525857dfba045e849cea18042cc3d7880b99c2" translate="yes" xml:space="preserve">
          <source>Alternately, one can omit the seed parameter and set the &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;counter&lt;/code&gt; directly.</source>
          <target state="translated">또는 seed 매개 변수를 생략하고 &lt;code&gt;key&lt;/code&gt; 와 &lt;code&gt;counter&lt;/code&gt; 직접 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9b43a5588bae4cb9f5e29de0b36052914afeba32" translate="yes" xml:space="preserve">
          <source>Alternative Looping and Element Access</source>
          <target state="translated">대체 루핑 및 요소 액세스</target>
        </trans-unit>
        <trans-unit id="04c50d39f026457c3ef039adee4c7d2e01334bf3" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. If size is not None, it must have the same shape as the provided size and must match the type of the output values.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. size가 None이 아닌 경우 제공된 크기와 모양이 같아야하며 출력 값의 유형과 일치해야합니다.</target>
        </trans-unit>
        <trans-unit id="ac126422935264a529db37a224ca2732607cef38" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type of the resulting values will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야하지만 필요한 경우 결과 값의 유형이 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="e863787368c91b7bab7460b77df3b49a02452a31" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야하지만 필요한 경우 유형이 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="39933ee76bd16a325ecec03a6b6c69433535c017" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 동일한 모양 및 버퍼 길이를 가져야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="9008d4b2e922f165a265eb88d277e1ffec09130a" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; (섹션&amp;ldquo;출력 인수&amp;rdquo;)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="560906432a29bad6bb6d814b0821886b56a3beb1" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output but the type will be cast if necessary. See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 동일한 모양 및 버퍼 길이를 가져야하지만 필요한 경우 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="6716188c035c63d861379b98db31dc6a05b5e2ca" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야하지만 필요한 경우 출력 유형이 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="0a76cb94a0ca7efaae715d349afff176965d63b9" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type of the output values will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야하지만 필요한 경우 출력 값 유형이 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="c295d74f775619fe463f057ab1dbd08a7d79f8f7" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output but the type (of the calculated values) will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 계산 된 값의 유형이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="61a2880769e0fb1df50a4ab9060f58e553c38840" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output but the type will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 유형이 캐스팅됩니다.</target>
        </trans-unit>
        <trans-unit id="43b99c7a8d7488b79863b62ea908025b20096c8f" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 출력 값 유형이 캐스트됩니다.</target>
        </trans-unit>
        <trans-unit id="f57d3485f19d67da466a6ee0162576b7a38c2d51" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 출력 값의 유형이 캐스트됩니다. 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="fd666e1b61b4360073157ecd0d0fcb9aaf5ef0cb" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 출력 값 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; (섹션&amp;ldquo;출력 인수&amp;rdquo;)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="245e3a5608b1c0ef8480e4bf9bf31cd384c67b24" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. It must have the same shape as the expected output, but the type of the output values will be cast if necessary. See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양이 같아야하지만 필요한 경우 출력 값의 유형이 캐스트됩니다. 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="886dc56850e1cdcb4b242ab241178dd7eddb1737" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="1dcc9c9b3901d2494530fe7503598647c49bed56" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output. See &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;Output type determination&lt;/a&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야합니다. 자세한 내용은 &lt;a href=&quot;../ufuncs#ufuncs-output-type&quot;&gt;출력 유형 결정&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="30fc9cbd185de6b1e0ea1c76efbbd7a9e0eec0f8" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output. See &lt;code&gt;doc.ufuncs&lt;/code&gt; (Section &amp;ldquo;Output arguments&amp;rdquo;) for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야합니다. 자세한 내용은 &lt;code&gt;doc.ufuncs&lt;/code&gt; (섹션&amp;ldquo;출력 인수&amp;rdquo;)를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="e9e1ab01a092624605645e8be4dd14df1a54ff4f" translate="yes" xml:space="preserve">
          <source>Alternative output array in which to place the result. Must be of the same shape and buffer length as the expected output. See &lt;code&gt;ufuncs-output-type&lt;/code&gt; for more details.</source>
          <target state="translated">결과를 배치 할 대체 출력 배열입니다. 예상 출력과 모양 및 버퍼 길이가 같아야합니다. 자세한 내용은 &lt;code&gt;ufuncs-output-type&lt;/code&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="062470a2ae6bc814c086d6b65330892b0f072b57" translate="yes" xml:space="preserve">
          <source>Alternatively one may use &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; to negate all items:</source>
          <target state="translated">또는 사용할 수 있습니다 &lt;code&gt;!&lt;/code&gt; 또는 &lt;code&gt;^&lt;/code&gt; 모든 항목을 부정하려면 :</target>
        </trans-unit>
        <trans-unit id="b0988f7b666b0761e9579b2bdb1096aad1df99ee" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;a href=&quot;#numpy.testing.assert_raises&quot;&gt;&lt;code&gt;assert_raises&lt;/code&gt;&lt;/a&gt; can be used as a context manager:</source>
          <target state="translated">또는 &lt;a href=&quot;#numpy.testing.assert_raises&quot;&gt; &lt;code&gt;assert_raises&lt;/code&gt; &lt;/a&gt; 를 컨텍스트 관리자로 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="042b85098c25d452344f7eaee4b5c7db2499e054" translate="yes" xml:space="preserve">
          <source>Alternatively, &lt;code&gt;Philox&lt;/code&gt; can be used in parallel applications by using a sequence of distinct keys where each instance uses different key.</source>
          <target state="translated">또는 &lt;code&gt;Philox&lt;/code&gt; 는 각 인스턴스가 다른 키를 사용하는 일련의 고유 키를 사용하여 병렬 애플리케이션에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4dd54fd37b627992b2c834451aea6cfe5843000e" translate="yes" xml:space="preserve">
          <source>Alternatively, Python&amp;rsquo;s builtin &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#round&quot;&gt;&lt;code&gt;round&lt;/code&gt;&lt;/a&gt; function uses a more accurate but slower algorithm for 64-bit floating point values:</source>
          <target state="translated">또는 Python의 내장 &lt;a href=&quot;https://docs.python.org/dev/library/functions.html#round&quot;&gt; &lt;code&gt;round&lt;/code&gt; &lt;/a&gt; 함수는 64 비트 부동 소수점 값에 대해 더 정확하지만 더 느린 알고리즘을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f0623427bd96685461eb8fa62b01f63338db5ece" translate="yes" xml:space="preserve">
          <source>Alternatively, calling:</source>
          <target state="translated">또는 다음을 호출하십시오.</target>
        </trans-unit>
        <trans-unit id="603108a6af86b03c6a3e370901679f4bbc10b9d8" translate="yes" xml:space="preserve">
          <source>Alternatively, can be used as a context manager like &lt;a href=&quot;numpy.testing.assert_raises#numpy.testing.assert_raises&quot;&gt;&lt;code&gt;assert_raises&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">또는 &lt;a href=&quot;numpy.testing.assert_raises#numpy.testing.assert_raises&quot;&gt; &lt;code&gt;assert_raises&lt;/code&gt; &lt;/a&gt; 와 같은 컨텍스트 관리자로 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="64d1b2b8f8933f7c73a15d5c48954079a5c5f378" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is set to &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt;&lt;code&gt;None&lt;/code&gt;&lt;/a&gt;, then as a special case, special methods like &lt;code&gt;ndarray.__add__&lt;/code&gt; will notice this and &lt;em&gt;unconditionally&lt;/em&gt; raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is useful if you want to create objects that interact with arrays via binary operations, but are not themselves arrays. For example, a units handling system might have an object &lt;code&gt;m&lt;/code&gt; representing the &amp;ldquo;meters&amp;rdquo; unit, and want to support the syntax &lt;code&gt;arr * m&lt;/code&gt; to represent that the array has units of &amp;ldquo;meters&amp;rdquo;, but not want to otherwise interact with arrays via ufuncs or otherwise. This can be done by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; and defining &lt;code&gt;__mul__&lt;/code&gt; and &lt;code&gt;__rmul__&lt;/code&gt; methods. (Note that this means that writing an &lt;code&gt;__array_ufunc__&lt;/code&gt; that always returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; is not quite the same as setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;: in the former case, &lt;code&gt;arr + obj&lt;/code&gt; will raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, while in the latter case it is possible to define a &lt;code&gt;__radd__&lt;/code&gt; method to prevent this.)</source>
          <target state="translated">경우 또는, &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 설정되어 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#None&quot;&gt; &lt;code&gt;None&lt;/code&gt; &lt;/a&gt; , 다음 특별한 경우로, 같은 특별한 방법 &lt;code&gt;ndarray.__add__&lt;/code&gt; 이것과 알 &lt;em&gt;무조건&lt;/em&gt; 인상 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; . 이진 연산을 통해 배열과 상호 작용하지만 자체 배열이 아닌 객체를 생성하려는 경우에 유용합니다. 예를 들어, 단위 처리 시스템은 &quot;meters&quot;단위를 나타내는 객체 &lt;code&gt;m&lt;/code&gt; 을 가질 수 있으며 , 배열에 &quot;meters&quot;단위가 있음을 나타 내기 위해 &lt;code&gt;arr * m&lt;/code&gt; 구문을 지원 하지만 ufuncs를 통해 배열과 상호 작용하지 않으려는 경우 그렇지 않으면. &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 을 설정 하고 &lt;code&gt;__mul__&lt;/code&gt; 을 정의하면됩니다 .및 &lt;code&gt;__rmul__&lt;/code&gt; 메소드. (참고한다는 쓰는 것이이 방법 &lt;code&gt;__array_ufunc__&lt;/code&gt; 것을 항상 리턴 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 하는&lt;/a&gt; 설정과 완전히 동일하지 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; : 전자의 경우 &lt;code&gt;arr + obj&lt;/code&gt; 올릴 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 후자의 경우에이 정의하는 것이 가능하지만, &lt;code&gt;__radd__&lt;/code&gt; 의 에 방법 이것을 방지하십시오.)</target>
        </trans-unit>
        <trans-unit id="b234cd2c60cae194ebb6fd51ca6da093f0fee91f" translate="yes" xml:space="preserve">
          <source>Alternatively, if &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; is set to None, then as a special case, special methods like &lt;code&gt;ndarray.__add__&lt;/code&gt; will notice this and &lt;em&gt;unconditionally&lt;/em&gt; raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;. This is useful if you want to create objects that interact with arrays via binary operations, but are not themselves arrays. For example, a units handling system might have an object &lt;code&gt;m&lt;/code&gt; representing the &amp;ldquo;meters&amp;rdquo; unit, and want to support the syntax &lt;code&gt;arr * m&lt;/code&gt; to represent that the array has units of &amp;ldquo;meters&amp;rdquo;, but not want to otherwise interact with arrays via ufuncs or otherwise. This can be done by setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; and defining &lt;code&gt;__mul__&lt;/code&gt; and &lt;code&gt;__rmul__&lt;/code&gt; methods. (Note that this means that writing an &lt;code&gt;__array_ufunc__&lt;/code&gt; that always returns &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt;&lt;code&gt;NotImplemented&lt;/code&gt;&lt;/a&gt; is not quite the same as setting &lt;code&gt;__array_ufunc__ = None&lt;/code&gt;: in the former case, &lt;code&gt;arr + obj&lt;/code&gt; will raise &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt;&lt;code&gt;TypeError&lt;/code&gt;&lt;/a&gt;, while in the latter case it is possible to define a &lt;code&gt;__radd__&lt;/code&gt; method to prevent this.)</source>
          <target state="translated">경우 또는, &lt;code&gt;obj.__array_ufunc__&lt;/code&gt; 없음으로 설정 한 후 특별한 경우로, 같은 특별한 방법 &lt;code&gt;ndarray.__add__&lt;/code&gt; 이것과 알 &lt;em&gt;무조건&lt;/em&gt; 인상 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; . 이진 연산을 통해 배열과 상호 작용하지만 그 자체가 배열이 아닌 객체를 생성하려는 경우 유용합니다. 예를 들어, 단위 처리 시스템 에는 &quot;미터&quot;단위를 나타내는 객체 &lt;code&gt;m&lt;/code&gt; 이있을 수 있으며 배열에 &quot;미터&quot;단위가 있음을 나타 내기 위해 구문 &lt;code&gt;arr * m&lt;/code&gt; 을 지원 하지만 ufuncs를 통해 배열과 상호 작용하지 않으려 고 할 수 있습니다. 또는 그렇지 않으면. 이것은 설정하여 수행 할 수 있습니다 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; 과 정의 &lt;code&gt;__mul__&lt;/code&gt; 및 &lt;code&gt;__rmul__&lt;/code&gt; 메서드. (참고한다는 쓰는 것이이 방법 &lt;code&gt;__array_ufunc__&lt;/code&gt; 것을 항상 리턴 &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#NotImplemented&quot;&gt; &lt;code&gt;NotImplemented&lt;/code&gt; 하는&lt;/a&gt; 설정과 완전히 동일하지 &lt;code&gt;__array_ufunc__ = None&lt;/code&gt; : 전자의 경우 &lt;code&gt;arr + obj&lt;/code&gt; 올릴 &lt;a href=&quot;https://docs.python.org/dev/library/exceptions.html#TypeError&quot;&gt; &lt;code&gt;TypeError&lt;/code&gt; &lt;/a&gt; 후자의 경우에이 정의하는 것이 가능하지만, &lt;code&gt;__radd__&lt;/code&gt; 의 에 방법 이것을 방지하십시오.)</target>
        </trans-unit>
        <trans-unit id="dc724637dcaf6077291b2447e9e15e17d24e3961" translate="yes" xml:space="preserve">
          <source>Alternatively, the &lt;code&gt;mask&lt;/code&gt; can be initialized to homogeneous boolean array with the same shape as &lt;code&gt;data&lt;/code&gt; by passing in a scalar boolean value:</source>
          <target state="translated">또는 스칼라 부울 값을 전달 하여 &lt;code&gt;mask&lt;/code&gt; 를 &lt;code&gt;data&lt;/code&gt; 와 동일한 모양의 동종 부울 배열로 초기화 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="583a1520082a2f841cb9c2b26df45a61aae29321" translate="yes" xml:space="preserve">
          <source>Alternatively, the bit-width names can be used as supported on the platform. For example:</source>
          <target state="translated">또는 플랫폼에서 지원되는대로 비트 너비 이름을 사용할 수 있습니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="b1f643599e11dc92776d62b472f093ed0c1d450f" translate="yes" xml:space="preserve">
          <source>Alternatively, we may be dealing with a fixed-width file, where columns are defined as a given number of characters. In that case, we need to set &lt;code&gt;delimiter&lt;/code&gt; to a single integer (if all the columns have the same size) or to a sequence of integers (if columns can have different sizes):</source>
          <target state="translated">또는 열이 주어진 문자 수로 정의되는 고정 너비 파일을 처리 할 수 ​​있습니다. 이 경우 &lt;code&gt;delimiter&lt;/code&gt; 를 단일 정수 (모든 열의 크기가 동일한 경우) 또는 정수 시퀀스 (열의 크기가 다를 수있는 경우)로 설정해야합니다.</target>
        </trans-unit>
        <trans-unit id="5b1b0753c6257b8ad2057a0e9b1f821b6cb17b75" translate="yes" xml:space="preserve">
          <source>Alternatively, you can use &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/&quot;&gt;Hypothesis&lt;/a&gt; to generate arbitrary data. Hypothesis manages both Python&amp;rsquo;s and Numpy&amp;rsquo;s random seeds for you, and provides a very concise and powerful way to describe data (including &lt;code&gt;hypothesis.extra.numpy&lt;/code&gt;, e.g. for a set of mutually-broadcastable shapes).</source>
          <target state="translated">또는 &lt;a href=&quot;https://hypothesis.readthedocs.io/en/latest/&quot;&gt;가설&lt;/a&gt; 을 사용 하여 임의의 데이터를 생성 할 수 있습니다 . 가설은 Python과 Numpy의 임의 시드를 모두 관리하고 데이터를 설명하는 매우 간결하고 강력한 방법을 제공합니다 ( 예 : 상호 브로드 캐스팅 가능한 도형 세트에 대한 &lt;code&gt;hypothesis.extra.numpy&lt;/code&gt; 포함 ).</target>
        </trans-unit>
        <trans-unit id="6a5c1fc742fbfbb6eee68bcc7446dc905aabc940" translate="yes" xml:space="preserve">
          <source>Alternatively, you may be able to use the storage-class specifier &lt;code&gt;__declspec(dllexport)&lt;/code&gt; in the C-definition of the function to avoid the need for this &lt;code&gt;.def&lt;/code&gt; file.</source>
          <target state="translated">또는 이 &lt;code&gt;.def&lt;/code&gt; 파일 이 필요하지 않도록 함수의 C 정의에서 스토리지 클래스 지정자 &lt;code&gt;__declspec(dllexport)&lt;/code&gt; 를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9875627fa24fe1db3e053ef8032f82cdbcfc75ff" translate="yes" xml:space="preserve">
          <source>Although the angle of the complex number 0 is undefined, &lt;code&gt;numpy.angle(0)&lt;/code&gt; returns the value 0.</source>
          <target state="translated">복소수 0의 각도는 정의되어 있지 &lt;code&gt;numpy.angle(0)&lt;/code&gt; 은 값 0을 반환합니다.</target>
        </trans-unit>
        <trans-unit id="b342c0c34753dcaf1006d8958e953680d63f33ea" translate="yes" xml:space="preserve">
          <source>Although this is valid Numpy code, the type checker will complain about it, since its usage is discouraged. Please see : &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;Data type objects&lt;/a&gt;</source>
          <target state="translated">이것은 유효한 Numpy 코드이지만 사용이 권장되지 않기 때문에 유형 검사기가 이에 대해 불평 할 것입니다. 참조하십시오 : &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17df52de914786306f2e7b14be29f81e3abb7330" translate="yes" xml:space="preserve">
          <source>Although used in certain projects, this feature was long undocumented and is not well supported. Some aspects of metadata propagation are expected to change in the future.</source>
          <target state="translated">특정 프로젝트에서 사용되었지만이 기능은 오랫동안 문서화되지 않았으며 잘 지원되지 않습니다. 메타 데이터 전파의 일부 측면은 향후 변경 될 것으로 예상됩니다.</target>
        </trans-unit>
        <trans-unit id="eb4639a6aea46ce8ed71791f65c8f91e841387e7" translate="yes" xml:space="preserve">
          <source>Although we provide the &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; BitGenerator for use independent of &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, note that its default seeding uses &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; rather than the legacy seeding algorithm. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; will use the legacy seeding algorithm. The methods to use the legacy seeding algorithm are currently private as the main reason to use them is just to implement &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. However, one can reset the state of &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; using the state of the &lt;a href=&quot;#numpy.random.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리는 할 수 있지만 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 사용의 독립을 위해 BitGenerator을 &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; , 참고 기본 파종 용도는 것을 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 기존 뿌리기 알고리즘보다는. &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 는 레거시 시드 알고리즘을 사용합니다. 레거시 시드 알고리즘을 사용하는 방법은 현재 비공개이며 사용하는 주된 이유는 &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 를 구현하는 것 입니다. 그러나, 하나의 상태를 재설정 할 수 있습니다 &lt;a href=&quot;bit_generators/mt19937#numpy.random.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; 을&lt;/a&gt; 의 상태 사용 &lt;a href=&quot;#numpy.random.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="0e228119d8236b4e4d18e3b2e104d4d85e550ff8" translate="yes" xml:space="preserve">
          <source>Although we provide the &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; BitGenerator for use independent of &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;, note that its default seeding uses &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt;&lt;code&gt;SeedSequence&lt;/code&gt;&lt;/a&gt; rather than the legacy seeding algorithm. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt; will use the legacy seeding algorithm. The methods to use the legacy seeding algorithm are currently private as the main reason to use them is just to implement &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;. However, one can reset the state of &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt;&lt;code&gt;MT19937&lt;/code&gt;&lt;/a&gt; using the state of the &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt;&lt;code&gt;RandomState&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">우리는 할 수 있지만 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; &lt;/a&gt; 사용의 독립을 위해 BitGenerator을 &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; , 참고 기본 파종 용도는 것을 &lt;a href=&quot;bit_generators/generated/numpy.random.seedsequence#numpy.random.SeedSequence&quot;&gt; &lt;code&gt;SeedSequence&lt;/code&gt; &lt;/a&gt; 기존 뿌리기 알고리즘보다는. &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; &lt;/a&gt; 는 레거시 시드 알고리즘을 사용합니다. 기존 시드 알고리즘을 사용하는 방법은 구현되어이를 사용하는 주된 이유로서 현재 비공개 있습니다 &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 을&lt;/a&gt; . 그러나, 하나의 상태를 재설정 할 수 있습니다 &lt;a href=&quot;bit_generators/mt19937#numpy.random.mt19937.MT19937&quot;&gt; &lt;code&gt;MT19937&lt;/code&gt; 을&lt;/a&gt; 의 상태 사용 &lt;a href=&quot;#numpy.random.mtrand.RandomState&quot;&gt; &lt;code&gt;RandomState&lt;/code&gt; 를&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="661995b09649a8e5abaf7ee085f0d42af259279d" translate="yes" xml:space="preserve">
          <source>Always put spaces around the assignment, Boolean and comparison operators. In expressions using a lot of operators, add spaces around the outermost (lowest priority) operators.</source>
          <target state="translated">할당, 부울 및 비교 연산자 주위에 항상 공백을 두십시오. 많은 연산자를 사용하는 표현식에서 가장 바깥 쪽 (가장 낮은 우선 순위) 연산자 주위에 공백을 추가하십시오.</target>
        </trans-unit>
        <trans-unit id="dcc9ccd559a420363c97ebc977b2af5b809d20bf" translate="yes" xml:space="preserve">
          <source>Always returns False if &lt;code&gt;x&lt;/code&gt; isn&amp;rsquo;t a MaskedArray.</source>
          <target state="translated">&lt;code&gt;x&lt;/code&gt; 가 MaskedArray가 아닌 경우 항상 False를 반환합니다 .</target>
        </trans-unit>
        <trans-unit id="1b6227067f2d29f54359191689a5ac01ab8ecb4c" translate="yes" xml:space="preserve">
          <source>Always returns a sorted complex array.</source>
          <target state="translated">정렬 된 복합 배열을 항상 반환합니다.</target>
        </trans-unit>
        <trans-unit id="69ee6c2d0ed15c79e0813d98fa14630bebc22ae2" translate="yes" xml:space="preserve">
          <source>Among other options (see below) and options described in previous mode, the following options can be used in this mode:</source>
          <target state="translated">이전 모드에서 설명한 다른 옵션 (아래 참조) 및 옵션 중에서 다음 옵션을이 모드에서 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="df8d527f17cb0a1b5c3b8b6888a9546f1c89e0c3" translate="yes" xml:space="preserve">
          <source>Among other options (see below), the following options can be used in this mode:</source>
          <target state="translated">다른 옵션 (아래 참조) 중에서이 모드에서 다음 옵션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7c68db5bc6e63b5b5bb435069771f8f296cb78c3" translate="yes" xml:space="preserve">
          <source>Among other things that are made possible is one can create a new array metadata object that uses the same data buffer to create a new view of that data buffer that has a different interpretation of the buffer (e.g., different shape, offset, byte order, strides, etc) but shares the same data bytes. Many operations in numpy do just this such as slices. Other operations, such as transpose, don&amp;rsquo;t move data elements around in the array, but rather change the information about the shape and strides so that the indexing of the array changes, but the data in the doesn&amp;rsquo;t move.</source>
          <target state="translated">가능한 다른 것들 중에는 동일한 데이터 버퍼를 사용하여 버퍼에 대한 다른 해석 (예 : 다른 모양, 오프셋, 바이트 순서, 보폭 등)이지만 동일한 데이터 바이트를 공유합니다. numpy의 많은 작업은 슬라이스와 같이 이것을 수행합니다. 조옮김과 같은 다른 작업은 배열에서 데이터 요소를 이동하지 않고 배열의 색인이 변경되도록 모양과 보폭에 대한 정보를 변경하지만 데이터는 이동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="9012c3648b6842a1e98c739d70a131d648f59d92" translate="yes" xml:space="preserve">
          <source>Among others this includes the likes of:</source>
          <target state="translated">여기에는 다음과 같은 것들이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="d580c4489c2c610aab44ce0ad58b3f097208f00d" translate="yes" xml:space="preserve">
          <source>Amount paid against the loan changes. The &lt;code&gt;per&lt;/code&gt; is the period of interest.</source>
          <target state="translated">대출 변경에 대해 지불 한 금액입니다. &lt;code&gt;per&lt;/code&gt; 관심의 기간입니다.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="83be67019e691f2e260d9d1c579e9717c930d1f5" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt; with &lt;a href=&quot;#term-structured-data-type&quot;&gt;structured data type&lt;/a&gt; which has been subclassed as &lt;code&gt;np.recarray&lt;/code&gt; and whose dtype is of type &lt;code&gt;np.record&lt;/code&gt;, making the fields of its data type to be accessible by attribute.</source>
          <target state="translated">&lt;a href=&quot;#term-ndarray&quot;&gt;ndarray&lt;/a&gt; 으로 &lt;a href=&quot;#term-structured-data-type&quot;&gt;구조화 된 데이터 유형&lt;/a&gt; 으로서 서브 클래스 한 &lt;code&gt;np.recarray&lt;/code&gt; 그 DTYPE 형이며 &lt;code&gt;np.record&lt;/code&gt; 데이터 타입의 필드를 만드는 것은, 속성에 의해 액세스된다.</target>
        </trans-unit>
        <trans-unit id="acae2de70c42b720bf5497e24967979b922bd47e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; is a (usually fixed-size) multidimensional container of items of the same type and size. The number of dimensions and items in an array is defined by its &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt;&lt;code&gt;shape&lt;/code&gt;&lt;/a&gt;, which is a &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#tuple&quot;&gt;&lt;code&gt;tuple&lt;/code&gt;&lt;/a&gt; of &lt;em&gt;N&lt;/em&gt; non-negative integers that specify the sizes of each dimension. The type of items in the array is specified by a separate &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;data-type object (dtype)&lt;/a&gt;, one of which is associated with each ndarray.</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; 는&lt;/a&gt; 동일한 종류와 사이즈의 아이템 (일반적으로 고정 된 크기) 다차원 컨테이너이다. 배열의 차원과 항목 수는 &lt;a href=&quot;generated/numpy.ndarray.shape#numpy.ndarray.shape&quot;&gt; &lt;code&gt;shape&lt;/code&gt; &lt;/a&gt; 정의되며 , 각 차원의 크기를 지정하는 &lt;em&gt;N&lt;/em&gt; 개의 음이 아닌 정수 의 &lt;a href=&quot;https://docs.python.org/dev/library/stdtypes.html#tuple&quot;&gt; &lt;code&gt;tuple&lt;/code&gt; &lt;/a&gt; 입니다 . 배열의 항목 유형은 별도의 &lt;a href=&quot;arrays.dtypes#arrays-dtypes&quot;&gt;데이터 유형 객체 (dtype)&lt;/a&gt; 로 지정되며 그 중 하나는 각 ndarray와 연관됩니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7bc19800098fdeab8e6191cd2c74779ca9496d4b" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt;&lt;code&gt;ndarray&lt;/code&gt;&lt;/a&gt; object has many methods which operate on or with the array in some fashion, typically returning an array result. These methods are briefly explained below. (Each method&amp;rsquo;s docstring has a more complete description.)</source>
          <target state="translated">&lt;a href=&quot;generated/numpy.ndarray#numpy.ndarray&quot;&gt; &lt;code&gt;ndarray&lt;/code&gt; &lt;/a&gt; 객체 또는 일반적으로 배열 결과를 반환 어떤 방식으로 배열 작동 많은 방법이있다. 이러한 방법은 아래에 간단히 설명되어 있습니다. (각 메소드의 docstring에 대한 자세한 설명이 있습니다.)</target>
        </trans-unit>
        <trans-unit id="348950d835f507d8c6b41bfd8c248c2dc0fb77e9" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt;&lt;code&gt;Ellipsis&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.python.org/dev/library/constants.html#Ellipsis&quot;&gt; &lt;code&gt;Ellipsis&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b05a71a51c0cb8c4cd40edaace7ca201320e4e4c" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;Attributes&lt;/strong&gt; section, located below the &lt;strong&gt;Parameters&lt;/strong&gt; section, may be used to describe non-method attributes of the class:</source>
          <target state="translated">&lt;strong&gt;매개 변수&lt;/strong&gt; 섹션 아래에 있는 &lt;strong&gt;속성&lt;/strong&gt; 섹션을 사용하여 클래스의 비 메서드 속성을 설명 할 수 있습니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="aa95663d09715fdd85c3c286e62db310ab9bc156" translate="yes" xml:space="preserve">
          <source>An Hermite series class.</source>
          <target state="translated">에르 미트 시리즈 수업.</target>
        </trans-unit>
        <trans-unit id="37ba78634b9174a697f0599ae6f6dc13ecb77ada" translate="yes" xml:space="preserve">
          <source>An HermiteE series class.</source>
          <target state="translated">HermiteE 시리즈 클래스.</target>
        </trans-unit>
        <trans-unit id="cffaa412bb40336800a7a25ffd6c3dab7659ec31" translate="yes" xml:space="preserve">
          <source>An Institutional Contributor is any individual Project Contributor who contributes to the project as part of their official duties at an Institutional Partner. Likewise, an Institutional Council Member is any Project Steering Council Member who contributes to the project as part of their official duties at an Institutional Partner.</source>
          <target state="translated">기관 기여자는 기관 파트너의 공식 업무의 일부로 프로젝트에 기여하는 개별 프로젝트 기여자입니다. 마찬가지로 기관위원회 위원은 기관 파트너의 공식 업무의 일부로 프로젝트에 기여하는 모든 프로젝트 운영위원회 위원입니다.</target>
        </trans-unit>
        <trans-unit id="a78770ecde29825877a3246385ccc0bac23a3a9c" translate="yes" xml:space="preserve">
          <source>An Institutional Partner is free to pursue funding for their work on The Project through any legal means. This could involve a non-profit organization raising money from private foundations and donors or a for-profit company building proprietary products and services that leverage Project Software and Services. Funding acquired by Institutional Partners to work on The Project is called Institutional Funding. However, no funding obtained by an Institutional Partner can override the Steering Council. If a Partner has funding to do NumPy work and the Council decides to not pursue that work as a project, the Partner is free to pursue it on their own. However in this situation, that part of the Partner&amp;rsquo;s work will not be under the NumPy umbrella and cannot use the Project trademarks in a way that suggests a formal relationship.</source>
          <target state="translated">기관 파트너는 법적 수단을 통해 프로젝트 작업에 대한 자금을 자유롭게 추구 할 수 있습니다. 여기에는 민간 재단 및 기부자로부터 자금을 모금하는 비영리 조직 또는 프로젝트 소프트웨어 및 서비스를 활용하는 독점 제품 및 서비스를 구축하는 영리 기업이 포함될 수 있습니다. The Project에서 작업하기 위해 Institutional Partners가 취득한 자금을 Institutional Funding이라고합니다. 그러나 기관 파트너가 얻은 자금은 운영위원회를 재정의 할 수 없습니다. 파트너가 NumPy 작업을 수행 할 자금이 있고위원회가 해당 작업을 프로젝트로 추구하지 않기로 결정한 경우 파트너는 자유롭게 작업을 수행 할 수 있습니다. 그러나이 상황에서 파트너 작업의 해당 부분은 NumPy 우산 아래에 있지 않으며 공식적인 관계를 암시하는 방식으로 프로젝트 상표를 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="774f2ca6463ce8bcd64cdfd525d1845b4ce03eef" translate="yes" xml:space="preserve">
          <source>An N-dimensional array containing samples of a scalar function.</source>
          <target state="translated">스칼라 함수의 샘플을 포함하는 N 차원 배열입니다.</target>
        </trans-unit>
        <trans-unit id="3d538fa8637c715f6bbc2c9c38a813643eb7ae9b" translate="yes" xml:space="preserve">
          <source>An N-dimensional iterator object to index arrays.</source>
          <target state="translated">배열을 인덱스하기위한 N 차원 반복자 객체입니다.</target>
        </trans-unit>
        <trans-unit id="3dd52a8c903e6e44d839c6aa398f48a49b2e9a83" translate="yes" xml:space="preserve">
          <source>An N-dimensional tuple of current coordinates.</source>
          <target state="translated">현재 좌표의 N 차원 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="0469df4347714bf84d92842d69579d7dfabaaa72" translate="yes" xml:space="preserve">
          <source>An additional feature is that the path to a data-file can actually be a function that takes no arguments and returns the actual path(s) to the data-files. This is useful when the data files are generated while building the package.</source>
          <target state="translated">추가 기능은 데이터 파일의 경로가 실제로 인수를 취하지 않고 데이터 파일의 실제 경로를 리턴하는 함수일 수 있다는 것입니다. 패키지를 빌드하는 동안 데이터 파일이 생성 될 때 유용합니다.</target>
        </trans-unit>
        <trans-unit id="7d254b010f4ed265ad6e477d88efeadb8fd344eb" translate="yes" xml:space="preserve">
          <source>An additional list of paths to look for .ini files can be given to &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt;&lt;code&gt;get_info&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">.ini 파일을 찾기위한 추가 경로 목록은 &lt;a href=&quot;distutils/misc_util#numpy.distutils.misc_util.get_info&quot;&gt; &lt;code&gt;get_info&lt;/code&gt; 에&lt;/a&gt; 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="10dfa862bcfcc9668a1db552ab4daea86348201e" translate="yes" xml:space="preserve">
          <source>An additional list of paths to look for .ini files can be given to &lt;code&gt;get_info&lt;/code&gt;.</source>
          <target state="translated">.ini 파일을 찾는 추가 경로 목록을 &lt;code&gt;get_info&lt;/code&gt; 에 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="963bad104cdcf2da9f9197c7dd8bbca2134670a8" translate="yes" xml:space="preserve">
          <source>An additional set of variables and observations. &lt;code&gt;y&lt;/code&gt; has the same form as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">추가 변수 및 관측 세트. &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 같은 형식 입니다.</target>
        </trans-unit>
        <trans-unit id="290ba89cf67c59979f1b14cebdae08675ffa3872" translate="yes" xml:space="preserve">
          <source>An additional set of variables and observations. &lt;code&gt;y&lt;/code&gt; has the same form as that of &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">추가 변수 및 관측 세트. &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;m&lt;/code&gt; 과 형태가 같습니다 .</target>
        </trans-unit>
        <trans-unit id="535d7085464b23925e15a73868df4653982051e0" translate="yes" xml:space="preserve">
          <source>An additional set of variables and observations. &lt;code&gt;y&lt;/code&gt; has the same shape as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">추가 변수 및 관측 세트. &lt;code&gt;y&lt;/code&gt; 는 &lt;code&gt;x&lt;/code&gt; 와 모양이 같습니다 .</target>
        </trans-unit>
        <trans-unit id="123e4ac201b989a06a3018b61ce098df1c75ac77" translate="yes" xml:space="preserve">
          <source>An alias for a field name in a structured datatype.</source>
          <target state="translated">구조화 된 데이터 유형의 필드 이름에 대한 별명입니다.</target>
        </trans-unit>
        <trans-unit id="0aadce1a1c3678a4b3a0e8fd514232b417ea179b" translate="yes" xml:space="preserve">
          <source>An alias for the density argument that behaves identically. To avoid confusion with the broken normed argument to &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt;&lt;code&gt;histogram&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;density&lt;/code&gt; should be preferred.</source>
          <target state="translated">동일하게 작동하는 밀도 인수의 별명입니다. 에 깨진 NORMED 인수와 혼란을 방지하기 위해 &lt;a href=&quot;numpy.histogram#numpy.histogram&quot;&gt; &lt;code&gt;histogram&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;density&lt;/code&gt; 선호한다.</target>
        </trans-unit>
        <trans-unit id="2dff9706411c38850b8de8293266d9884231cabd" translate="yes" xml:space="preserve">
          <source>An arbitrary Python function.</source>
          <target state="translated">임의의 파이썬 함수.</target>
        </trans-unit>
        <trans-unit id="e8bb23ecea26f2757144af6ea155e648fd27499b" translate="yes" xml:space="preserve">
          <source>An array can be indexed by a tuple of nonnegative integers, by booleans, by another array, or by integers. The &lt;code&gt;rank&lt;/code&gt; of the array is the number of dimensions. The &lt;code&gt;shape&lt;/code&gt; of the array is a tuple of integers giving the size of the array along each dimension.</source>
          <target state="translated">배열은 음이 아닌 정수의 튜플, 부울, 다른 배열 또는 정수로 인덱싱 할 수 있습니다. 배열 의 &lt;code&gt;rank&lt;/code&gt; 는 차원 수입니다. 배열 의 &lt;code&gt;shape&lt;/code&gt; 은 각 차원을 따라 배열의 크기를 제공하는 정수 튜플입니다.</target>
        </trans-unit>
        <trans-unit id="caae7edaffe66ab62bffc1b2b0bd2b213c039100" translate="yes" xml:space="preserve">
          <source>An array class with possibly masked values.</source>
          <target state="translated">마스킹 된 값이있는 배열 클래스입니다.</target>
        </trans-unit>
        <trans-unit id="4c85e68fd622a0d5a6428884a31f19296d5b57f7" translate="yes" xml:space="preserve">
          <source>An array containing the number of bytes to jump to get to the next element in each dimension.</source>
          <target state="translated">각 차원의 다음 요소로 이동하기 위해 이동할 바이트 수를 포함하는 배열입니다.</target>
        </trans-unit>
        <trans-unit id="54ae13ad9fa748df727082d88d41d03835abae7a" translate="yes" xml:space="preserve">
          <source>An array containing the roots of the polynomial.</source>
          <target state="translated">다항식의 근을 포함하는 배열입니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
