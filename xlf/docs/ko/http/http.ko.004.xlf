<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="e034cbbe2b8762f796d4892d08bbfed1145d3ef8" translate="yes" xml:space="preserve">
          <source>Default values</source>
          <target state="translated">기본값</target>
        </trans-unit>
        <trans-unit id="a5c2516af3446d0b014a66cd8335c651bab61880" translate="yes" xml:space="preserve">
          <source>Define the lifetime of a cookie</source>
          <target state="translated">쿠키의 수명 정의</target>
        </trans-unit>
        <trans-unit id="6dead4f5e7150393c68c21004bedb55c7c195d60" translate="yes" xml:space="preserve">
          <source>Define where cookies are sent</source>
          <target state="translated">쿠키가 전송되는 위치 정의</target>
        </trans-unit>
        <trans-unit id="245c3e85d7084e6fe802cca877477e7792e1d78f" translate="yes" xml:space="preserve">
          <source>Defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="translated">요청 된 응답이 프록시에서 액세스되어야 함을 나타 내기 위해 HTTP 사양의 이전 버전에서 정의되었습니다. 프록시의 대역 내 구성과 관련된 보안 문제로 인해 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ab39d71630263cb06de73047fe986abf13013e75" translate="yes" xml:space="preserve">
          <source>Defines &lt;code&gt;connect-src&lt;/code&gt;, &lt;code&gt;default-src&lt;/code&gt;, &lt;code&gt;font-src&lt;/code&gt;, &lt;code&gt;frame-src&lt;/code&gt;, &lt;code&gt;img-src&lt;/code&gt;, &lt;code&gt;media-src&lt;/code&gt;, &lt;code&gt;object-src&lt;/code&gt;, report-uri, &lt;code&gt;sandbox&lt;/code&gt;, &lt;code&gt;script-src,&lt;/code&gt; and &lt;code&gt;style-src&lt;/code&gt;.</source>
          <target state="translated">정의는 &lt;code&gt;connect-src&lt;/code&gt; , &lt;code&gt;default-src&lt;/code&gt; , &lt;code&gt;font-src&lt;/code&gt; , &lt;code&gt;frame-src&lt;/code&gt; , &lt;code&gt;img-src&lt;/code&gt; , &lt;code&gt;media-src&lt;/code&gt; , &lt;code&gt;object-src&lt;/code&gt; , 보고서-URI, &lt;code&gt;sandbox&lt;/code&gt; , &lt;code&gt;script-src,&lt;/code&gt; 및 &lt;code&gt;style-src&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40978ed9d38521abaff2d2262f9c89c7cd595480" translate="yes" xml:space="preserve">
          <source>Defines a mechanism that enables developers to declare a network error reporting policy.</source>
          <target state="translated">개발자가 네트워크 오류보고 정책을 선언 할 수있는 메커니즘을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="eacb52986e3e740e8c70b75c3e7482999a612bff" translate="yes" xml:space="preserve">
          <source>Defines the &lt;code&gt;fullscreen&lt;/code&gt; policy.</source>
          <target state="translated">&lt;code&gt;fullscreen&lt;/code&gt; 정책을 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="d951108d1c6ab12879dc6ad6f06e33639209ba4b" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource behind a proxy server.</source>
          <target state="translated">프록시 서버 뒤의 리소스에 액세스하는 데 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="02ebc06a403db3f222282cbfb2aa8be80e23aefc" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to access a resource.</source>
          <target state="translated">리소스에 액세스하는 데 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="34b169a4830ca101a24b3e67607bce56b1c91720" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource behind a Proxy server.</source>
          <target state="translated">프록시 서버 뒤의 리소스에 액세스하기 위해 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="6543a340c8cdd818ac73a63a94d4fd7de57aba8d" translate="yes" xml:space="preserve">
          <source>Defines the authentication method that should be used to gain access to a resource.</source>
          <target state="translated">자원에 액세스하는 데 사용해야하는 인증 방법을 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7826d05e84456b5b15119edee382be8851b9547e" translate="yes" xml:space="preserve">
          <source>Defines the range unit the server supports. Though &lt;code&gt;bytes&lt;/code&gt; is the only range unit formally defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, additional range units may be registered in the&lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#range-units&quot;&gt; HTTP Range Unit Registry&lt;/a&gt;.</source>
          <target state="translated">서버가 지원하는 범위 단위를 정의합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233에&lt;/a&gt; 의해 공식적으로 정의 된 유일한 범위 단위는 &lt;code&gt;bytes&lt;/code&gt; 이지만 &lt;a href=&quot;https://www.iana.org/assignments/http-parameters/http-parameters.xhtml#range-units&quot;&gt;HTTP 범위 단위 레지스트리&lt;/a&gt; 에 추가 범위 단위를 등록 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8dcc75b63979f2db11f899a91470adab4ff1cb6" translate="yes" xml:space="preserve">
          <source>Defines the valid sources for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;web workers&lt;/a&gt; and nested browsing contexts loaded using elements such as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt;&lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/frame&quot;&gt; &lt;code&gt;&amp;lt;frame&amp;gt;&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 과 같은 요소를 사용하여로드 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;웹 워커&lt;/a&gt; 및 중첩 된 브라우징 컨텍스트 의 유효한 소스를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="b64b866be84f841a370d95030a45025c6a3e04e9" translate="yes" xml:space="preserve">
          <source>Denial-of-service attacks are of special concern to WebDAV servers.
   WebDAV plus HTTP enables denial-of-service attacks on every part of a
   system's resources.

   o  The underlying storage can be attacked by PUTting extremely large
      files.

   o  Asking for recursive operations on large collections can attack
      processing time.

   o  Making multiple pipelined requests on multiple connections can
      attack network connections.

   WebDAV servers need to be aware of the possibility of a denial-of-
   service attack at all levels.  The proper response to such an attack
   MAY be to simply drop the connection.  Or, if the server is able to
   make a response, the server MAY use a 400-level status request such
   as 400 (Bad Request) and indicate why the request was refused (a 500-
   level status response would indicate that the problem is with the
   server, whereas unintentional DoS attacks are something the client is
   capable of remedying).</source>
          <target state="translated">WebDAV 서버에는 서비스 거부 공격이 특히 중요합니다. WebDAV plus HTTP는 시스템 리소스의 모든 부분에 대한 서비스 거부 공격을 가능하게합니다. o 매우 큰 파일을 PUTting하여 기본 스토리지를 공격 할 수 있습니다. o 대규모 컬렉션에서 재귀 작업을 요청하면 처리 시간이 단축 될 수 있습니다. o 여러 연결에서 여러 파이프 라인 요청을하면 네트워크 연결을 공격 할 수 있습니다. WebDAV 서버는 모든 수준에서 서비스 거부 공격의 가능성을 알고 있어야합니다. 이러한 공격에 대한 적절한 대응은 단순히 연결을 끊는 것일 수 있습니다. 또는 서버가 응답 할 수있는 경우서버는 400 (잘못된 요청)과 같은 400 수준 상태 요청을 사용하고 요청이 거부 된 이유를 나타낼 수 있습니다 (500 수준 상태 응답은 서버에 문제가 있음을 나타내지 만 의도하지 않은 DoS 공격은 클라이언트가하는 것임) 치료할 수 있음).</target>
        </trans-unit>
        <trans-unit id="89de95bda785091ad4670c2c51c5dd042349d3eb" translate="yes" xml:space="preserve">
          <source>Deprecate modification of 'secure' cookies from non-secure origins</source>
          <target state="translated">비보안 출처의 '보안'쿠키 수정 사용 중단</target>
        </trans-unit>
        <trans-unit id="efb41926689d64456523d9abd88a8e204ff7906a" translate="yes" xml:space="preserve">
          <source>Deprecates &lt;code&gt;frame-src&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; 를 추천하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="e4f0c7b98ab40a4d967b59248a69752d5ae464d4" translate="yes" xml:space="preserve">
          <source>Depth = &quot;Depth&quot; &quot;:&quot; (&quot;0&quot; | &quot;1&quot; | &quot;infinity&quot;)

   The Depth request header is used with methods executed on resources
   that could potentially have internal members to indicate whether the
   method is to be applied only to the resource (&quot;Depth: 0&quot;), to the
   resource and its internal members only (&quot;Depth: 1&quot;), or the resource
   and all its members (&quot;Depth: infinity&quot;).

   The Depth header is only supported if a method's definition
   explicitly provides for such support.

   The following rules are the default behavior for any method that
   supports the Depth header.  A method may override these defaults by
   defining different behavior in its definition. 

   Methods that support the Depth header may choose not to support all
   of the header's values and may define, on a case-by-case basis, the
   behavior of the method if a Depth header is not present.  For
   example, the MOVE method only supports &quot;Depth: infinity&quot;, and if a
   Depth header is not present, it will act as if a &quot;Depth: infinity&quot;
   header had been applied.

   Clients MUST NOT rely upon methods executing on members of their
   hierarchies in any particular order or on the execution being atomic
   unless the particular method explicitly provides such guarantees.

   Upon execution, a method with a Depth header will perform as much of
   its assigned task as possible and then return a response specifying
   what it was able to accomplish and what it failed to do.

   So, for example, an attempt to COPY a hierarchy may result in some of
   the members being copied and some not.

   By default, the Depth header does not interact with other headers.
   That is, each header on a request with a Depth header MUST be applied
   only to the Request-URI if it applies to any resource, unless
   specific Depth behavior is defined for that header.

   If a source or destination resource within the scope of the Depth
   header is locked in such a way as to prevent the successful execution
   of the method, then the lock token for that resource MUST be
   submitted with the request in the If request header.

   The Depth header only specifies the behavior of the method with
   regards to internal members.  If a resource does not have internal
   members, then the Depth header MUST be ignored.</source>
          <target state="translated">Depth = &quot;Depth&quot; &quot;:&quot;( &quot;0&quot;| &quot;1&quot;| &quot;infinity&quot;) Depth 요청 헤더는 내부 멤버가있을 수있는 자원에서 실행 된 메소드와 함께 사용되어 메소드가 해당 애플리케이션에만 적용되는지 여부를 표시합니다. 자원 ( &quot;Depth : 0&quot;), 자원 및 내부 구성원 만 ( &quot;Depth : 1&quot;) 또는 자원 및 모든 구성원 ( &quot;Depth : 무한대&quot;). 깊이 헤더는 메소드의 정의가 그러한 지원을 명시 적으로 제공하는 경우에만 지원됩니다. 다음 규칙은 깊이 헤더를 지원하는 모든 메서드의 기본 동작입니다. 메소드는 정의에서 다른 동작을 정의하여 이러한 기본값을 대체 할 수 있습니다. 깊이 헤더를 지원하는 메소드는 모든 헤더를 지원하지 않을 수 있습니다.깊이 헤더가 존재하지 않는 경우, 방법에 따라 값을 정의하고 방법을 정의 할 수 있습니다. 예를 들어 MOVE 메서드는 &quot;Depth : infinity&quot;만 지원하며 Depth 헤더가 없으면 &quot;Depth : infinity&quot;헤더가 적용된 것처럼 작동합니다. 클라이언트는 특정 방법이 명시 적으로 보장을 제공하지 않는 한 특정 순서로 계층 멤버에서 실행되는 메소드 또는 원자적인 실행에 의존해서는 안됩니다. 실행시 Depth 헤더가있는 메소드는 가능한 많은 할당 된 태스크를 수행 한 다음 수행 할 수있는 작업과 수행하지 못한 작업을 지정하는 응답을 리턴합니다. 예를 들어 계층 구조를 복사하려고하면 일부 멤버가 복사되고 일부는 복사되지 않을 수 있습니다. 기본적으로,깊이 헤더는 다른 헤더와 상호 작용하지 않습니다. 즉, Depth 헤더가있는 요청의 각 헤더는 해당 헤더에 대해 특정 Depth 동작이 정의되어 있지 않은 한 리소스에 적용되는 경우 Request-URI에만 적용되어야합니다. 메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.Depth 헤더가있는 요청의 각 헤더는 해당 헤더에 특정 깊이 동작이 정의되어 있지 않은 한 리소스에 적용되는 경우에만 요청 URI에 적용해야합니다. 메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.Depth 헤더가있는 요청의 각 헤더는 해당 헤더에 특정 깊이 동작이 정의되어 있지 않은 한 리소스에 적용되는 경우에만 요청 URI에 적용해야합니다. 메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠겨있는 경우 해당 요청에 대한 요청과 함께 해당 자원에 대한 잠금 토큰을 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.메소드가 성공적으로 실행되지 않도록 Depth 헤더 범위 내의 소스 또는 대상 자원이 잠긴 경우 해당 자원에 대한 잠금 토큰을 If 요청 헤더의 요청과 함께 제출해야합니다. 깊이 헤더는 내부 멤버와 관련하여 메소드의 동작 만 지정합니다. 리소스에 내부 멤버가 없으면 Depth 헤더를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="c3f35f2651dfb57ad3dbd2465104d1927bb97b16" translate="yes" xml:space="preserve">
          <source>Describes how Web resources are referenced and how to locate them.</source>
          <target state="translated">웹 리소스를 참조하는 방법과 찾는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="13eefb880344c770ed016914712964de5ecee92a" translate="yes" xml:space="preserve">
          <source>Describes how web resources are referenced and how to locate them.</source>
          <target state="translated">웹 리소스를 참조하는 방법과이를 찾는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="932bd93206e0c74c22f35c1fa3ed7a4be6439b83" translate="yes" xml:space="preserve">
          <source>Describes the human language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">사용자가 선호하는 언어에 따라 차별화 할 수 있도록 청중을 대상으로하는 인간 언어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="70c9f2b9944695efcc3168d72ca8c97f9659ed15" translate="yes" xml:space="preserve">
          <source>Describes the language(s) intended for the audience, so that it allows a user to differentiate according to the users' own preferred language.</source>
          <target state="translated">사용자가 선호하는 언어에 따라 차별화 할 수 있도록 청중을위한 언어를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="d5ca427b8a632e16915ddd1ca200bfe11ba09ba7" translate="yes" xml:space="preserve">
          <source>Describes the three connection management models available in HTTP/1.x, their strengths, and their weaknesses.</source>
          <target state="translated">HTTP / 1.x에서 사용할 수있는 세 가지 연결 관리 모델, 장단점을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="a9a26ce3467081341f2f33fd2f385b9b4b5a76b7" translate="yes" xml:space="preserve">
          <source>Describes the type and structure of the different kind of messages of HTTP/1.x and HTTP/2.</source>
          <target state="translated">HTTP / 1.x 및 HTTP / 2의 다른 종류의 메시지 유형 및 구조를 설명합니다.</target>
        </trans-unit>
        <trans-unit id="045b1f4c38aa570756046a04e9ca60247fc160b5" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in the Web architecture, its position in the protocol stack.</source>
          <target state="translated">HTTP가 무엇이며 웹 아키텍처에서의 역할, 프로토콜 스택에서의 위치에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="724e541fe26287b5d45feca3f617b30de64a8464" translate="yes" xml:space="preserve">
          <source>Describes what HTTP is and its role in web architecture, including its position in the protocol stack.</source>
          <target state="translated">HTTP가 무엇인지, 프로토콜 스택에서의 위치를 ​​포함하여 웹 아키텍처에서의 역할을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="55f8ebc805e65b5b71ddafdae390e3be2bcd69af" translate="yes" xml:space="preserve">
          <source>Description</source>
          <target state="translated">Description</target>
        </trans-unit>
        <trans-unit id="6011dbf6cfab599fb1f5bc7fc964691bbd1b3180" translate="yes" xml:space="preserve">
          <source>Designed in the early 1990s, HTTP is an extensible protocol which has evolved over time. It is an application layer protocol that is sent over &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt;, or over a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt;-encrypted TCP connection, though any reliable transport protocol could theoretically be used. Due to its extensibility, it is used to not only fetch hypertext documents, but also images and videos or to post content to servers, like with HTML form results. HTTP can also be used to fetch parts of documents to update Web pages on demand.</source>
          <target state="translated">1990 년대 초에 설계된 HTTP는 시간이 지남에 따라 진화 한 확장 가능한 프로토콜입니다. 그것은을 통해 전송되는 애플리케이션 계층 프로토콜 인 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TCP&quot;&gt;TCP&lt;/a&gt; , 또는 이상 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TLS&quot;&gt;TLS&lt;/a&gt; 신뢰할 수있는 모든 전송 프로토콜은 이론적으로 사용할 수 있지만, TCP 연결을으로 암호화. 확장 성으로 인해 하이퍼 텍스트 문서뿐만 아니라 이미지 및 비디오를 가져 오거나 HTML 양식 결과와 같이 서버에 컨텐츠를 게시하는 데 사용됩니다. HTTP는 요청시 웹 페이지를 업데이트하기 위해 문서의 일부를 가져 오는 데 사용될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="532c67fe1b5afae15d2d08fba7a78de0f63cc4b5" translate="yes" xml:space="preserve">
          <source>Desktop</source>
          <target state="translated">Desktop</target>
        </trans-unit>
        <trans-unit id="dfd0263c11d50bfbcd6f11a03ba9f3544f34bf13" translate="yes" xml:space="preserve">
          <source>Despite &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; being &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;registered with IANA&lt;/a&gt;, it is largely unsupported, and &lt;code&gt;image/x-icon&lt;/code&gt; is being used instead.</source>
          <target state="translated">불구 &lt;code&gt;image/vnd.microsoft.icon&lt;/code&gt; 되는 &lt;a href=&quot;https://www.iana.org/assignments/media-types/image/vnd.microsoft.icon&quot;&gt;IANA 등록&lt;/a&gt; , 그것은 주로 지원되지 않고 &lt;code&gt;image/x-icon&lt;/code&gt; 대신에 사용되고있다.</target>
        </trans-unit>
        <trans-unit id="2c9a54d2465a44e3b40b84b59d11de3a6c0cadc8" translate="yes" xml:space="preserve">
          <source>Determines how to match future request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">향후 요청 헤더를 일치시켜 원본 서버에서 새로운 응답을 요청하는 대신 캐시 된 응답을 사용할 수 있는지 여부를 결정하는 방법을 결정합니다.</target>
        </trans-unit>
        <trans-unit id="6d8108385e143b7a138219a9ade7a2c3c2bf95f5" translate="yes" xml:space="preserve">
          <source>Determines how to match request headers to decide whether a cached response can be used rather than requesting a fresh one from the origin server.</source>
          <target state="translated">요청 헤더를 일치시키는 방법을 결정하여 원본 서버에서 새 응답을 요청하는 대신 캐시 된 응답을 사용할 수 있는지 여부를 결정합니다.</target>
        </trans-unit>
        <trans-unit id="2e965db93ca2d2ed880afa222771550e11edd88c" translate="yes" xml:space="preserve">
          <source>Device-specific</source>
          <target state="translated">Device-specific</target>
        </trans-unit>
        <trans-unit id="504f16935ab18165c15c8ac0d71a7134e267a656" translate="yes" xml:space="preserve">
          <source>Device-specific user agent strings</source>
          <target state="translated">장치 별 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="ceb4688658b58abe9c95bf427c98e66f4be1e7a3" translate="yes" xml:space="preserve">
          <source>Different kinds of caches</source>
          <target state="translated">다른 종류의 캐시</target>
        </trans-unit>
        <trans-unit id="1ca0ed6389159c54076291dfd79987d9f92fb6b6" translate="yes" xml:space="preserve">
          <source>Directive type</source>
          <target state="translated">지시어 타입</target>
        </trans-unit>
        <trans-unit id="28c82071e940360118b0611d5c912a71c32a0100" translate="yes" xml:space="preserve">
          <source>Directives</source>
          <target state="translated">Directives</target>
        </trans-unit>
        <trans-unit id="691c26c4ce33366b87dae4f9e53ebeaaa6a4d716" translate="yes" xml:space="preserve">
          <source>Directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">요청과 응답 모두에서 캐싱 메커니즘에 대한 지시.</target>
        </trans-unit>
        <trans-unit id="d32a74ca0f336eef375d6cd3af907aa1d40f0be6" translate="yes" xml:space="preserve">
          <source>Directives that define whether a response/request can be cached, where it may be cached, and whether it must be validated with the origin server before caching.</source>
          <target state="translated">응답 / 요청을 캐시 할 수 있는지 여부, 캐시 할 수있는 위치 및 캐시하기 전에 원본 서버에서 유효성을 검사해야하는지 여부를 정의하는 지시문.</target>
        </trans-unit>
        <trans-unit id="f4f4473df8cb59f0a369aebee3d1509adc0151c6" translate="yes" xml:space="preserve">
          <source>Disabled</source>
          <target state="translated">Disabled</target>
        </trans-unit>
        <trans-unit id="787d14cbc3437c5c1be6e012c1af87a9cce09ce1" translate="yes" xml:space="preserve">
          <source>Disabled From version 35 until version 37 (exclusive): this feature is behind the &lt;code&gt;network.http.altsvc.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;) and the &lt;code&gt;altsvc.oe&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">때까지 버전 35에서 비활성화 버전 37 (전용) :이 기능은 뒤에 &lt;code&gt;network.http.altsvc.enabled&lt;/code&gt; 선호 (로 설정해야 &lt;code&gt;true&lt;/code&gt; )과 &lt;code&gt;altsvc.oe&lt;/code&gt; 의 선호도 (요구로 설정되는 &lt;code&gt;true&lt;/code&gt; ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="5f484ad36a1ee3a334bfeaabcdd32d70515f88ee" translate="yes" xml:space="preserve">
          <source>Disabled From version 47: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">버전 47부터 사용 안함 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="e8b112b210a8f4589c98ad826e6212c056804fde" translate="yes" xml:space="preserve">
          <source>Disabled From version 48: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">버전 48부터 사용 안함 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="89947c297946cdea762cd2db19147fd97a643839" translate="yes" xml:space="preserve">
          <source>Disabled From version 49 until version 68 (exclusive): this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">사용 안 함 버전 49부터 버전 68까지 (독점) :이 기능은 &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="b23e78cd51ef4c7696b73e65f06fc0fba687013d" translate="yes" xml:space="preserve">
          <source>Disabled From version 49: this feature is behind the &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">비활성화 됨 버전 49부터 :이 기능은 &lt;code&gt;security.csp.experimentalEnabled&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="acf361a5483e12203a0c0598d3d3f3664a139585" translate="yes" xml:space="preserve">
          <source>Disabled From version 50: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">버전 50부터 사용 안함 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="f7790dccb9f3d88c21e6418f32f87789fb463366" translate="yes" xml:space="preserve">
          <source>Disabled From version 52: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 52부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="ad350d06e4ae5e37d57c0405b7c8e1fbfca3f705" translate="yes" xml:space="preserve">
          <source>Disabled From version 53: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 53부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="01d0cf4c918a77e56e449b4d149616907d38849e" translate="yes" xml:space="preserve">
          <source>Disabled From version 55: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 55부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="02423b2163f75291aa5854698bba6b1f6a5052f1" translate="yes" xml:space="preserve">
          <source>Disabled From version 56: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 56부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="4b34d34dcaec154df6181d68e5bec4643debe21c" translate="yes" xml:space="preserve">
          <source>Disabled From version 59: this feature is behind the &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">비활성화 됨 버전 59부터 :이 기능은 &lt;code&gt;network.http.sendOriginHeader&lt;/code&gt; 뒤에 있습니다 .http.sendOriginHeader 환경 설정 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="40734bba86a26fa4c0ddd48daccbe4d758349227" translate="yes" xml:space="preserve">
          <source>Disabled From version 60: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">버전 60부터 사용 안함 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="73719b598079cc354ff255d41acbbe0b420ae879" translate="yes" xml:space="preserve">
          <source>Disabled From version 62: this feature is behind the &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">비활성화 됨 버전 62부터 :이 기능은 &lt;code&gt;dom.clearSiteData.enabled&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="7847ec1580ce5ad83ab59a78912ccb3ab21e102b" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">사용 중지 버전 65부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="5a54bae2672ba58fd0d7d8cd35ca056cf1ce8f92" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">사용 중지 버전 65부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="6aac50e494a4685cfa01b409c7700b3851e9f9e7" translate="yes" xml:space="preserve">
          <source>Disabled From version 65: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">버전 65부터 사용 안함 :이 기능은 &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="726ec65869fe460716d9db41541949cae8c24c4e" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 66부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="aebc6632a71f5502b11ed22ad8c5755ec1c88bfe" translate="yes" xml:space="preserve">
          <source>Disabled From version 66: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">비활성화 됨 버전 66부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="366e50a33639dd16e2b224c5a3ee5b82578e4e0e" translate="yes" xml:space="preserve">
          <source>Disabled From version 67: this feature is behind the &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">버전 67에서 사용 안함 :이 기능은 &lt;code&gt;dom.security.featurePolicy.header.enabled&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="56705b66ed39339d0a4b894306b2ecabb3efd7c6" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">사용 중지 버전 68부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="2dcbb985ceab20f02611932df74cc051d6062ad2" translate="yes" xml:space="preserve">
          <source>Disabled From version 68: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">사용 중지 버전 68부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 환경 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="d28e2d242fc0c32d88a4828425be70d8d4e9386c" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">비활성화 됨 버전 69부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="dc43adf822f8071bf38b741b4c8b4ff8caa87dd2" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">비활성화 됨 버전 69부터 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="e63694ea8ef64e459c00d7c0d93772ca98cd8c0d" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.laxByDefault&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">버전 69부터 사용 안함 :이 기능은 &lt;code&gt;network.cookie.sameSite.laxByDefault&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="0e6c448fbfef096f82b450df55d6a46e80c7144a" translate="yes" xml:space="preserve">
          <source>Disabled From version 69: this feature is behind the &lt;code&gt;network.cookie.sameSite.noneRequiresSecure&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">버전 69부터 사용 안함 :이 기능은 &lt;code&gt;network.cookie.sameSite.noneRequiresSecure&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="d2696e5d2f6597ff6db717b5917fe7ef78b21f49" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">버전 72부터 사용 중지됨 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하세요.</target>
        </trans-unit>
        <trans-unit id="932bbade750d61ada15f0c29ceb15ac8767a08c2" translate="yes" xml:space="preserve">
          <source>Disabled From version 72: this feature is behind the &lt;code&gt;security.cert_pinning.hpkp.enabled&lt;/code&gt; preference (needs to be set to &lt;code&gt;true&lt;/code&gt;). To change preferences in Firefox, visit about:config.</source>
          <target state="translated">버전 72부터 비활성화 됨 :이 기능은 &lt;code&gt;security.cert_pinning.hpkp.enabled&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;true&lt;/code&gt; 로 설정해야 함 ). Firefox에서 환경 설정을 변경하려면 about : config를 방문하십시오.</target>
        </trans-unit>
        <trans-unit id="d78775da32cd4aa8691fe3765af5c89229860835" translate="yes" xml:space="preserve">
          <source>Disabled From version 73 until version 76 (exclusive): this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;). To change preferences in Chrome, visit chrome://flags.</source>
          <target state="translated">사용 안 함 버전 73부터 버전 76까지 (독점) :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ). Chrome에서 환경 설정을 변경하려면 chrome : // flags를 방문하세요.</target>
        </trans-unit>
        <trans-unit id="d49a2f2138558d7e247fc15cdf0f8f8e80da02a9" translate="yes" xml:space="preserve">
          <source>Disabled From version 79: this feature is behind the &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; preference (needs to be set to &lt;code&gt;Enabled&lt;/code&gt;).</source>
          <target state="translated">버전 79에서 사용 안함 :이 기능은 &lt;code&gt;#enable-experimental-productivity-features&lt;/code&gt; 기본 설정 뒤에 있습니다 ( &lt;code&gt;Enabled&lt;/code&gt; 으로 설정해야 함 ).</target>
        </trans-unit>
        <trans-unit id="efbf731d4f27dd707439b02e0fcf767655467961" translate="yes" xml:space="preserve">
          <source>Disables DNS prefetching. This is useful if you don't control the link on the pages, or know that you don't want to leak information to these domains.</source>
          <target state="translated">DNS 프리 페치를 비활성화합니다. 페이지의 링크를 제어하지 않거나 이러한 도메인에 정보를 유출하지 않으려는 경우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="58f5f4ebc16939ddad056d1835f255075e38be52" translate="yes" xml:space="preserve">
          <source>Disables MIME sniffing and forces browser to use the type given in &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">MIME 스니핑을 비활성화하고 브라우저가 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 에&lt;/a&gt; 지정된 유형을 사용하도록합니다 .</target>
        </trans-unit>
        <trans-unit id="4c27076a7d462b5b7f6f1b44922f1242a3e46ba5" translate="yes" xml:space="preserve">
          <source>Disables XSS filtering.</source>
          <target state="translated">XSS 필터링을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="57822983bbd8b7a6c9f3de16f7fe5eab989d06a5" translate="yes" xml:space="preserve">
          <source>Disabling a feature in a policy is a one-way toggle. If a feature has been disabled for a child frame by its parent frame, the child cannot re-enable it, and neither can any of the child's descendants.</source>
          <target state="translated">정책에서 기능을 비활성화하는 것은 단방향 전환입니다. 부모 프레임에 의해 자식 프레임에 대해 기능이 비활성화 된 경우 자식은 기능을 다시 활성화 할 수 없으며 자식의 자손도 마찬가지입니다.</target>
        </trans-unit>
        <trans-unit id="b95dd3eb6900d93a418238bf7a5a3a1a746e7c86" translate="yes" xml:space="preserve">
          <source>Disallowing plugins</source>
          <target state="translated">플러그인 금지</target>
        </trans-unit>
        <trans-unit id="93902c2eda1c4f4fa6e24f3a214f7642478627b6" translate="yes" xml:space="preserve">
          <source>Disconnected Operation</source>
          <target state="translated">연결이 끊어진 작업</target>
        </trans-unit>
        <trans-unit id="c5bdaaa9046da0ea03b3b9660b87425b983b09dd" translate="yes" xml:space="preserve">
          <source>Discrete types</source>
          <target state="translated">이산 유형</target>
        </trans-unit>
        <trans-unit id="d69e4d6aad6c625810f7014dfc3dfbd01898d5b3" translate="yes" xml:space="preserve">
          <source>Discussion of HTTP headers</source>
          <target state="translated">HTTP 헤더에 대한 토론</target>
        </trans-unit>
        <trans-unit id="e7414bd7b2a8ae1b4152a32e27208f6ea5703ede" translate="yes" xml:space="preserve">
          <source>Display security and privacy policies In Firefox Developer Tools</source>
          <target state="translated">Firefox 개발자 도구의 보안 및 개인 정보 보호 정책 표시</target>
        </trans-unit>
        <trans-unit id="d78de940f6bf90261043cb8bd08624772df60547" translate="yes" xml:space="preserve">
          <source>Disregarding DNT. The origin server is unable or unwilling to respect a tracking preference received from the requesting user agent.</source>
          <target state="translated">DNT 무시. 오리진 서버가 요청 사용자 에이전트로부터 수신 한 추적 환경 설정을 존중할 수 없거나 존중하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4a1de6fc43e38e089c17a80c82ba419f8f473962" translate="yes" xml:space="preserve">
          <source>Do &lt;strong&gt;not&lt;/strong&gt; use this meta element like this for stating a document language:</source>
          <target state="translated">마십시오 &lt;strong&gt;하지&lt;/strong&gt; 문서 언어를 진술이 같은이 메타 요소를 사용 :</target>
        </trans-unit>
        <trans-unit id="2c25376cd1e5d495d8c85d1b29c113dcd4496160" translate="yes" xml:space="preserve">
          <source>Do Not Track</source>
          <target state="translated">추적하지 않음</target>
        </trans-unit>
        <trans-unit id="70f963907a2dc441e4078146477cb1ac975253ce" translate="yes" xml:space="preserve">
          <source>Do Not Track on Wikipedia</source>
          <target state="translated">위키 백과를 추적하지 마십시오</target>
        </trans-unit>
        <trans-unit id="5de6d660ffd0c31bb077df9301609dfb8cf69667" translate="yes" xml:space="preserve">
          <source>Do you want to provide different HTML depending on which browser is being used?</source>
          <target state="translated">사용중인 브라우저에 따라 다른 HTML을 제공 하시겠습니까?</target>
        </trans-unit>
        <trans-unit id="96d09f4b8e17c5718c2731ce7ab9928e287257a4" translate="yes" xml:space="preserve">
          <source>Do-Not-Track</source>
          <target state="translated">Do-Not-Track</target>
        </trans-unit>
        <trans-unit id="e214b8a29923056887b7edf6635d90dcbb2abe88" translate="yes" xml:space="preserve">
          <source>Document</source>
          <target state="translated">Document</target>
        </trans-unit>
        <trans-unit id="54500ed3527305b0f92d5cf278622f552f491a43" translate="yes" xml:space="preserve">
          <source>Document directive</source>
          <target state="translated">문서 지시문</target>
        </trans-unit>
        <trans-unit id="f2213ce4b36d0f4e6e226bd21f16b5d5bf80dcba" translate="yes" xml:space="preserve">
          <source>Document directives</source>
          <target state="translated">문서 지시문</target>
        </trans-unit>
        <trans-unit id="ec6b0754c2e6157428f7e2691227c09de666ec35" translate="yes" xml:space="preserve">
          <source>Document directives govern the properties of a document or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;worker&lt;/a&gt; environment to which a policy applies.</source>
          <target state="translated">문서 지시문 은 정책이 적용되는 문서 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API&quot;&gt;작업자&lt;/a&gt; 환경 의 속성을 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="48b3bb8b0a579c9e6fbd40516291d94dca86d1ba" translate="yes" xml:space="preserve">
          <source>Does not work below Windows 10.</source>
          <target state="translated">Windows 10에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5a6dfa8179f4637130555f525186dd9377736169" translate="yes" xml:space="preserve">
          <source>Does not work on Windows 7 and Windows 8.1.</source>
          <target state="translated">Windows 7 및 Windows 8.1에서는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ea664539e7e07c3b3cb2d4e3bb71cc99d18e5b5b" translate="yes" xml:space="preserve">
          <source>Domain aliasing</source>
          <target state="translated">도메인 별칭</target>
        </trans-unit>
        <trans-unit id="3b549bffd9a85f8fa78b065a75e77e845bc42471" translate="yes" xml:space="preserve">
          <source>Domain aliasing can be done for several reasons:</source>
          <target state="translated">도메인 별칭은 여러 가지 이유로 수행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="66a72f8713e4b8fdfa4a8582d2a117d6b82dbadd" translate="yes" xml:space="preserve">
          <source>Domain attribute</source>
          <target state="translated">도메인 속성</target>
        </trans-unit>
        <trans-unit id="690d7332b26bc38eab02d6b1abf316a940401914" translate="yes" xml:space="preserve">
          <source>Domain sharding</source>
          <target state="translated">도메인 샤딩</target>
        </trans-unit>
        <trans-unit id="3c61580d55d642952fbec533e8d3f2630a7d8e94" translate="yes" xml:space="preserve">
          <source>Domain=&amp;lt;domain-value&amp;gt; Optional</source>
          <target state="translated">도메인 = &amp;lt;도메인-값&amp;gt; 선택 사항</target>
        </trans-unit>
        <trans-unit id="dc4653bff510cf1118951874eb552343ce4eeea4" translate="yes" xml:space="preserve">
          <source>Download resumption in Internet Explorer</source>
          <target state="translated">Internet Explorer에서 재개 다운로드</target>
        </trans-unit>
        <trans-unit id="a862c2b21b5e1337de2b76d5e43ae1375117d34d" translate="yes" xml:space="preserve">
          <source>Downloads</source>
          <target state="translated">Downloads</target>
        </trans-unit>
        <trans-unit id="23d33e22acfcb9ecddb4a85f10607dc4ff49e23c" translate="yes" xml:space="preserve">
          <source>Draft</source>
          <target state="translated">Draft</target>
        </trans-unit>
        <trans-unit id="13ae8e0a7cb29b1ff62023de94998bfc639787c9" translate="yes" xml:space="preserve">
          <source>Draft document</source>
          <target state="translated">초안 문서</target>
        </trans-unit>
        <trans-unit id="ddc6d4101d699284c4ee49346220f3fb8a444994" translate="yes" xml:space="preserve">
          <source>Draft spec</source>
          <target state="translated">초안 사양</target>
        </trans-unit>
        <trans-unit id="8a8aba5130fcc62311d7ddc3b7380514a11ed8fe" translate="yes" xml:space="preserve">
          <source>Due to the &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;configuration-based entropy&lt;/a&gt; increase, a modified value can be used to fingerprint the user, it is not recommended to change it and a Web site cannot trust this value to reflect the actual wish of the user. Site designers must not be over-zealous by using language detection via this header as it can lead to a poor user experience:</source>
          <target state="translated">받는 인해 &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;구성 기반 엔트로피의&lt;/a&gt; 증가, 수정 된 값이 사용자 지문 할 수 있습니다, 변경하지 않는 것이 좋습니다 및 웹 사이트는 사용자의 실제 소원을 반영하기 위해이 값을 신뢰할 수 없습니다. 사이트 디자이너는이 헤더를 통해 언어 감지 기능을 사용하여 사용자 경험이 열악해질 수 있으므로 지나치게 열중해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="408eba332fcca84c3bed5ec905d05209bce63d2e" translate="yes" xml:space="preserve">
          <source>Due to their emphasis on authoring, WebDAV servers need to use
   authentication technology to protect not just access to a network
   resource, but the integrity of the resource as well.  Furthermore,
   the introduction of locking functionality requires support for
   authentication.

   A password sent in the clear over an insecure channel is an
   inadequate means for protecting the accessibility and integrity of a
   resource as the password may be intercepted.  Since Basic
   authentication for HTTP/1.1 performs essentially clear text
   transmission of a password, Basic authentication MUST NOT be used to
   authenticate a WebDAV client to a server unless the connection is
   secure.  Furthermore, a WebDAV server MUST NOT send a Basic
   authentication challenge in a WWW-Authenticate header unless the
   connection is secure.  An example of a secure connection would be a
   Transport Layer Security (TLS) connection employing a strong cipher
   suite and server authentication. 

   WebDAV applications MUST support the Digest authentication scheme
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;].  Since Digest authentication verifies that both parties to
   a communication know a shared secret, a password, without having to
   send that secret in the clear, Digest authentication avoids the
   security problems inherent in Basic authentication while providing a
   level of authentication that is useful in a wide range of scenarios.</source>
          <target state="translated">저작에 중점을 둔 WebDAV 서버는 인증 기술을 사용하여 네트워크 자원에 대한 액세스뿐만 아니라 자원의 무결성도 보호해야합니다. 또한 잠금 기능을 도입하려면 인증 지원이 필요합니다. 안전하지 않은 채널을 통해 일반 암호를 보내면 암호를 가로 챌 수 있으므로 리소스의 액세스 가능성과 무결성을 보호하기에 부적절한 수단입니다. HTTP / 1.1에 대한 기본 인증은 본질적으로 암호의 명확한 텍스트 전송을 수행하므로 연결이 안전하지 않으면 기본 인증을 사용하여 WebDAV 클라이언트를 서버에 인증해서는 안됩니다. 또한 WebDAV 서버는 연결이 안전하지 않으면 WWW-Authenticate 헤더에서 기본 인증 요청을 보내서는 안됩니다.보안 연결의 예로는 강력한 암호 제품군 및 서버 인증을 사용하는 TLS (Transport Layer Security) 연결이 있습니다. WebDAV 응용 프로그램은 다이제스트 인증 체계를 지원해야합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ]. 다이제스트 인증은 통신 당사자가 비밀을 명확하게 보내지 않고 공유 비밀, 암호를 알고 있음을 확인하므로 다이제스트 인증은 기본 인증 고유의 보안 문제를 피하면서 광범위하게 유용한 인증 수준을 제공합니다. 시나리오의 범위.</target>
        </trans-unit>
        <trans-unit id="997743d612e18993ff8dc7080968428d093101a4" translate="yes" xml:space="preserve">
          <source>During the same time, the need for an encrypted transport layer raised: the Web left the relative trustiness of a mostly academic network, to a jungle where advertisers, random individuals or criminals compete to get as much private information about people, try to impersonate them or even to replace data transmitted by altered ones. As the applications built over HTTP became more and more powerful, having access to more and more private information like address books, e-mail, or the geographic position of the user, the need to have TLS became ubiquitous even outside the e-commerce use case.</source>
          <target state="translated">동시에 암호화 된 전송 계층의 필요성이 높아졌습니다. 웹은 대부분 학계 네트워크의 상대적 신뢰성을 광고주, 임의의 개인 또는 범죄자가 경쟁하여 사람들에 대한 많은 개인 정보를 얻기 위해 경쟁하는 정글로 떠났습니다. 또는 변경된 데이터로 전송 된 데이터를 대체 할 수도 있습니다. HTTP를 통해 구축 된 응용 프로그램이 점점 더 강력 해져 주소록, 전자 메일 또는 사용자의 지리적 위치와 같은 점점 더 많은 개인 정보에 액세스 할 수있게되면서 전자 상거래 이외의 지역에서도 TLS를 사용할 필요가 생겼습니다. 케이스.</target>
        </trans-unit>
        <trans-unit id="95b3251ec6e19bc2e780b0b452fffbe79113def2" translate="yes" xml:space="preserve">
          <source>Dynamic serving</source>
          <target state="translated">동적 서빙</target>
        </trans-unit>
        <trans-unit id="57313c5dd0c9956db75ecb6a66db1c8dbb3f5fdf" translate="yes" xml:space="preserve">
          <source>Dynamic. The origin server needs more information to determine tracking status.</source>
          <target state="translated">동적. 오리진 서버는 추적 상태를 판별하기 위해 추가 정보가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="705ecd20fdc7a1a80cbce38adda833a8e258328f" translate="yes" xml:space="preserve">
          <source>ECMAScript (&lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; Specification&lt;/em&gt;&lt;/a&gt;) (&lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 Section 8.2&lt;/a&gt;)</source>
          <target state="translated">ECMAScript ( &lt;a href=&quot;https://www.iana.org/assignments/media-types/application/ecmascript&quot;&gt;&lt;em&gt;&lt;abbr&gt;IANA&lt;/abbr&gt; 사양&lt;/em&gt;&lt;/a&gt; ) ( &lt;a href=&quot;https://tools.ietf.org/html/rfc4329#section-8.2&quot;&gt;RFC 4329 섹션 8.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="11d00f6ed181afbae6281cf892e585dcee85b274" translate="yes" xml:space="preserve">
          <source>ETag</source>
          <target state="translated">ETag</target>
        </trans-unit>
        <trans-unit id="a9cf203d9639d2de24fc7e1aabf9a3f1d1b216fd" translate="yes" xml:space="preserve">
          <source>ETag (RFC 2616)</source>
          <target state="translated">ETag (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="c3c187693ac73afbe58b0355bda0f434ddd57b14" translate="yes" xml:space="preserve">
          <source>ETag (RFC 7232)</source>
          <target state="translated">ETag (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2586de7225abd1a31095cd8e2595f05492c55926" translate="yes" xml:space="preserve">
          <source>ETags</source>
          <target state="translated">ETags</target>
        </trans-unit>
        <trans-unit id="91b64bf36619dc548bb6dc82aa7a3172dcb0fa4a" translate="yes" xml:space="preserve">
          <source>EU cookie directive</source>
          <target state="translated">EU 쿠키 지침</target>
        </trans-unit>
        <trans-unit id="aacf5c8fecb249d308c1a10d329efa9aa9c43e95" translate="yes" xml:space="preserve">
          <source>Each Hypertext Transfer Protocol (HTTP) message is either a request
   or a response.  A server listens on a connection for a request,
   parses each message received, interprets the message semantics in
   relation to the identified request target, and responds to that
   request with one or more response messages.  A client constructs
   request messages to communicate specific intentions, examines
   received responses to see if the intentions were carried out, and
   determines how to interpret the results.  This document defines
   HTTP/1.1 request and response semantics in terms of the architecture
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;].

   HTTP provides a uniform interface for interacting with a resource
   (&lt;a href=&quot;#section-2&quot;&gt;Section 2&lt;/a&gt;), regardless of its type, nature, or implementation, via
   the manipulation and transfer of representations (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).

   HTTP semantics include the intentions defined by each request method
   (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;), extensions to those semantics that might be described in
   request header fields (&lt;a href=&quot;#section-5&quot;&gt;Section 5&lt;/a&gt;), the meaning of status codes to
   indicate a machine-readable response (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;), and the meaning of
   other control data and resource metadata that might be given in
   response header fields (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;).

   This document also defines representation metadata that describe how
   a payload is intended to be interpreted by a recipient, the request
   header fields that might influence content selection, and the various
   selection algorithms that are collectively referred to as &quot;content
   negotiation&quot; (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;).</source>
          <target state="translated">각 HTTP (Hypertext Transfer Protocol) 메시지는 요청 또는 응답입니다. 서버는 요청에 대한 연결을 수신하고 수신 된 각 메시지를 구문 분석하고 식별 된 요청 대상과 관련하여 메시지 시맨틱을 해석하고 하나 이상의 응답 메시지로 해당 요청에 응답합니다. 클라이언트는 요청 메시지를 작성하여 특정 의도를 전달하고 수신 된 응답을 검사하여 의도가 수행되었는지 확인하고 결과 해석 방법을 결정합니다. 이 문서는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의 된 아키텍처와 관련하여 HTTP / 1.1 요청 및 응답 시맨틱을 정의 합니다. HTTP는 리소스와 상호 작용하기위한 균일 한 인터페이스를 제공합니다 ( &lt;a href=&quot;#section-2&quot;&gt;섹션 2&lt;/a&gt;) 표현의 조작 및 전달을 통해 유형, 성격 또는 구현에 관계없이 ( &lt;a href=&quot;#section-3&quot;&gt;3 항&lt;/a&gt; ). HTTP 시맨틱에는 각 요청 방법 ( &lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; )에 의해 정의 된 의도 , 요청 헤더 필드에 설명 될 수있는 시맨틱에 대한 확장 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ), 머신 판독 가능 응답을 나타내는 상태 코드의 의미 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 및 응답 헤더 필드에 제시 될 수있는 다른 제어 데이터 자원의 메타 데이터의 의미 ( &lt;a href=&quot;#section-7&quot;&gt;제 7&lt;/a&gt;). 이 문서는 또한 수신자가 페이로드를 해석하는 방법, 컨텐츠 선택에 영향을 줄 수있는 요청 헤더 필드 및 &quot;컨텐츠 협상&quot;이라고하는 다양한 선택 알고리즘 ( &lt;a href=&quot;#section-3.4&quot;&gt;섹션 3.4&lt;/a&gt; ) 을 설명하는 표현 메타 데이터를 정의합니다 .</target>
        </trans-unit>
        <trans-unit id="057e4721fb960e50e6bc2f172224db4e1bf70d8b" translate="yes" xml:space="preserve">
          <source>Each Status-Code is described below, including a description of which
   method(s) it can follow and any metainformation required in the
   response.</source>
          <target state="translated">각 상태 코드는 아래에서 설명 할 수있는 방법 및 응답에 필요한 메타 정보에 대한 설명을 포함하여 아래에 설명되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="0bafccf37828f0cf81554847666fb3201e53972e" translate="yes" xml:space="preserve">
          <source>Each browser performs MIME sniffing differently and under different circumstances. (For example, Safari will look at the file extension in the URL if the sent MIME type is unsuitable.) There are security concerns as some MIME types represent executable content. Servers can prevent MIME sniffing by sending the &lt;a href=&quot;../headers/x-content-type-options&quot;&gt;&lt;code&gt;X-Content-Type-Options&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">각 브라우저는 MIME 스니핑을 다르게 그리고 다른 상황에서 수행합니다. (예를 들어, Safari는 전송 된 MIME 유형이 적합하지 않은 경우 URL에서 파일 확장자를 확인합니다.) 일부 MIME 유형은 실행 가능 컨텐츠를 나타내므로 보안 문제가 있습니다. 서버는 &lt;a href=&quot;../headers/x-content-type-options&quot;&gt; &lt;code&gt;X-Content-Type-Options&lt;/code&gt; &lt;/a&gt; 헤더 를 보내 MIME 스니핑을 방지 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="82fa8700dcf214b80fbd4de6e7bf762e538223a6" translate="yes" xml:space="preserve">
          <source>Each client in the request chain may have its own cache, so it is
   common for a cache at an intermediary to receive conditional requests
   from other (outbound) caches.  Likewise, some user agents make use of
   conditional requests to limit data transfers to recently modified
   representations or to complete the transfer of a partially retrieved
   representation.

   If a cache receives a request that can be satisfied by reusing one of
   its stored 200 (OK) or 206 (Partial Content) responses, the cache
   SHOULD evaluate any applicable conditional header field preconditions
   received in that request with respect to the corresponding validators
   contained within the selected response.  A cache MUST NOT evaluate 

   conditional header fields that are only applicable to an origin
   server, found in a request with semantics that cannot be satisfied
   with a cached response, or applied to a target resource for which it
   has no stored responses; such preconditions are likely intended for
   some other (inbound) server.

   The proper evaluation of conditional requests by a cache depends on
   the received precondition header fields and their precedence, as
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC7232]&lt;/a&gt;.  The If-Match and
   If-Unmodified-Since conditional header fields are not applicable to a
   cache.

   A request containing an If-None-Match header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of
   [RFC7232]&lt;/a&gt;) indicates that the client wants to validate one or more of
   its own stored responses in comparison to whichever stored response
   is selected by the cache.  If the field-value is &quot;*&quot;, or if the
   field-value is a list of entity-tags and at least one of them matches
   the entity-tag of the selected stored response, a cache recipient
   SHOULD generate a 304 (Not Modified) response (using the metadata of
   the selected stored response) instead of sending that stored
   response.

   When a cache decides to revalidate its own stored responses for a
   request that contains an If-None-Match list of entity-tags, the cache
   MAY combine the received list with a list of entity-tags from its own
   stored set of responses (fresh or stale) and send the union of the
   two lists as a replacement If-None-Match header field value in the
   forwarded request.  If a stored response contains only partial
   content, the cache MUST NOT include its entity-tag in the union
   unless the request is for a range that would be fully satisfied by
   that partial stored response.  If the response to the forwarded
   request is 304 (Not Modified) and has an ETag header field value with
   an entity-tag that is not in the client's list, the cache MUST
   generate a 200 (OK) response for the client by reusing its
   corresponding stored response, as updated by the 304 response
   metadata (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;).

   If an If-None-Match header field is not present, a request containing
   an If-Modified-Since header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7232]&lt;/a&gt;)
   indicates that the client wants to validate one or more of its own
   stored responses by modification date.  A cache recipient SHOULD
   generate a 304 (Not Modified) response (using the metadata of the
   selected stored response) if one of the following cases is true: 1)
   the selected stored response has a Last-Modified field-value that is
   earlier than or equal to the conditional timestamp; 2) no
   Last-Modified field is present in the selected stored response, but
   it has a Date field-value that is earlier than or equal to the
   conditional timestamp; or, 3) neither Last-Modified nor Date is 

   present in the selected stored response, but the cache recorded it as
   having been received at a time earlier than or equal to the
   conditional timestamp.

   A cache that implements partial responses to range requests, as
   defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;], also needs to evaluate a received If-Range
   header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7233]&lt;/a&gt;) with respect to its selected
   stored response.</source>
          <target state="translated">요청 체인의 각 클라이언트는 자체 캐시를 가질 수 있으므로 중개자의 캐시가 다른 (아웃 바운드) 캐시로부터 조건부 요청을받는 것이 일반적입니다. 마찬가지로 일부 사용자 에이전트는 조건부 요청을 사용하여 데이터 전송을 최근 수정 된 표현으로 제한하거나 부분적으로 검색된 표현의 전송을 완료합니다. 캐시가 저장된 200 (OK) 또는 206 (부분 컨텐츠) 응답 중 하나를 재사용하여 만족할 수있는 요청을 수신하면 캐시는 그 안에 포함 된 해당 유효성 검증기와 관련하여 해당 요청에 수신 된 적용 가능한 조건부 헤더 필드 전제 조건을 평가해야합니다 (SHOULD). 선택된 응답. 캐시는 오리진 서버에만 적용되는 조건부 헤더 필드를 평가해서는 안됩니다.시맨틱이있는 요청에서 캐시 된 응답으로 만족할 수 없거나 저장된 응답이없는 대상 자원에 적용될 수 있습니다. 이러한 전제 조건은 다른 (인바운드) 서버를위한 것입니다. 캐시에 의한 조건부 요청의 적절한 평가는 수신 된 사전 조건 헤더 필드 및 우선 순위에 정의되어 있습니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-6&quot;&gt;[RFC7232] 섹션 6&lt;/a&gt; . If-Match 및 If-Unmodified-Since 조건부 헤더 필드는 캐시에 적용 할 수 없습니다. If-None-Match 헤더 필드를 포함하는 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.2&quot;&gt;[RFC7232]의 3.2 절&lt;/a&gt;)는 클라이언트가 캐시에 의해 저장된 저장된 응답과 비교하여 하나 이상의 자체 저장된 응답의 유효성을 검증하려고 함을 나타냅니다. 필드 값이 &quot;*&quot;이거나 필드 값이 엔티티 태그 목록이고 그 중 하나 이상이 선택된 저장된 응답의 엔티티 태그와 일치하는 경우 캐시 수신자는 304 (수정되지 않음)를 생성해야합니다 ) 저장된 응답을 보내는 대신 응답 (선택한 저장된 응답의 메타 데이터 사용) 캐시가 엔티티 태그의 If-None-Match 목록을 포함하는 요청에 대해 자체 저장된 응답을 다시 확인하기로 결정한 경우,캐시는 수신 된 목록을 자체 저장된 응답 세트 (신규 또는 오래된)의 엔티티 태그 목록과 결합하고 전달 된 요청에서 대체 If-None-Match 헤더 필드 값으로 두 목록의 통합을 보낼 수 있습니다. 저장된 응답에 부분 내용 만 포함 된 경우 요청이 부분 저장된 응답에 의해 완전히 만족되는 범위에 대한 요청이 아닌 한 캐시는 해당 엔터티 태그를 통합에 포함해서는 안됩니다. 전달 된 요청에 대한 응답이 304 (수정되지 않음)이고 클라이언트 목록에없는 엔티티 태그가 포함 된 ETag 헤더 필드 값을 갖는 경우, 캐시는 해당하는 것을 재사용하여 클라이언트에 대해 200 (OK) 응답을 생성해야합니다. 304 응답 메타 데이터에 의해 업데이트 된 저장된 응답 (캐시가 부분 저장된 응답에 의해 완전히 만족되는 범위에 대한 요청이 아닌 한 캐시는 엔티티 태그를 통합에 포함해서는 안됩니다. 전달 된 요청에 대한 응답이 304 (수정되지 않음)이고 클라이언트 목록에없는 엔티티 태그가 포함 된 ETag 헤더 필드 값을 갖는 경우, 캐시는 해당하는 것을 재사용하여 클라이언트에 대해 200 (OK) 응답을 생성해야합니다. 304 응답 메타 데이터에 의해 업데이트 된 저장된 응답 (캐시가 부분 저장된 응답에 의해 완전히 만족되는 범위에 대한 요청이 아닌 한 캐시는 엔티티 태그를 통합에 포함해서는 안됩니다. 전달 된 요청에 대한 응답이 304 (수정되지 않음)이고 클라이언트 목록에없는 엔티티 태그가 포함 된 ETag 헤더 필드 값을 갖는 경우, 캐시는 해당하는 것을 재사용하여 클라이언트에 대해 200 (OK) 응답을 생성해야합니다. 304 응답 메타 데이터에 의해 업데이트 된 저장된 응답 (캐시는 304 응답 메타 데이터에 의해 업데이트 된대로 대응하는 저장된 응답을 재사용함으로써 클라이언트에 대해 200 (OK) 응답을 생성해야한다 (캐시는 304 응답 메타 데이터에 의해 업데이트 된대로 대응하는 저장된 응답을 재사용함으로써 클라이언트에 대해 200 (OK) 응답을 생성해야한다 (&lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; ). If-None-Match 헤더 필드가 없으면 If-Modified-Since 헤더 필드를 포함하는 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-3.3&quot;&gt;[RFC7232]의 3.3 절&lt;/a&gt;)는 클라이언트가 수정 날짜별로 하나 이상의 자체 저장된 응답의 유효성을 검증하려고 함을 나타냅니다. 캐시 수신자는 다음 중 하나의 경우에 해당하는 경우 (선택된 저장 응답의 메타 데이터를 사용하여) 304 (수정되지 않음) 응답을 생성해야합니다. 1) 선택한 저장 응답의 마지막 수정 된 필드 값이 조건부 타임 스탬프와 같습니다. 2) 선택된 저장된 응답에 Last-Modified 필드가 없지만 조건부 타임 스탬프보다 빠르거나 같은 Date 필드 값이 있습니다. 또는, 3) 선택된 저장된 응답에 Last-Modified 또는 Date가 존재하지 않지만, 캐시는이를 조건부 타임 스탬프 이전의 시간에 수신 한 것으로 기록했습니다. 범위 요청에 대한 부분 응답을 구현하는 캐시[에 정의 된대로&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt; ]은 또한 선택된 저장된 응답과 관련하여 수신 된 If-Range 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-3.2&quot;&gt;[RFC7233]의 섹션 3.2)&lt;/a&gt; 를 평가할 필요가있다 .</target>
        </trans-unit>
        <trans-unit id="cdfff658f8638be3f51c025575b0ddaed39961ef" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types are taking a lot of space to store and the need to regain this wasted space appeared very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">각 데이터 유형에는 중복성, 즉 &lt;em&gt;공간 낭비&lt;/em&gt; 가 있습니다. 텍스트가 일반적으로 60 %의 중복성을 가질 수있는 경우 오디오 및 비디오와 같은 다른 미디어의 경우이 속도가 훨씬 높아질 수 있습니다. 텍스트와 달리 이러한 다른 미디어 유형은 저장하는 데 많은 공간을 차지하며이 낭비되는 공간을 다시 확보해야 할 필요성이 매우 일찍 나타났습니다. 엔지니어는이 특정 목적을 위해 설계된 파일 형식에서 사용되는 최적화 된 압축 알고리즘을 설계했습니다. 파일에 사용되는 압축 알고리즘은 크게 두 가지 범주로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ae7498ae0f7b36b2dcd84d942c2be51971574fec" translate="yes" xml:space="preserve">
          <source>Each data type has some redundancy, that is &lt;em&gt;wasted space&lt;/em&gt;, in it. If text can typically have as much as 60% redundancy, this rate can be much higher for some other media like audio and video. Unlike text, these other media types use lot of space to store their data and the need to optimize storage and regain space was apparent very early. Engineers designed the optimized compression algorithm used by file formats designed for this specific purpose. Compression algorithms used for files can be grouped into two broad categories:</source>
          <target state="translated">각 데이터 유형에는 일부 중복성, 즉 &lt;em&gt;낭비되는 공간&lt;/em&gt; 이 있습니다. 텍스트가 일반적으로 60 %의 중복성을 가질 수있는 경우이 비율은 오디오 및 비디오와 같은 다른 미디어의 경우 훨씬 더 높을 수 있습니다. 텍스트와 달리 이러한 다른 미디어 유형은 데이터를 저장하기 위해 많은 공간을 사용하며 스토리지를 최적화하고 공간을 다시 확보해야하는 필요성이 매우 일찍 나타났습니다. 엔지니어들은 이러한 특정 목적을 위해 설계된 파일 형식에 사용되는 최적화 된 압축 알고리즘을 설계했습니다. 파일에 사용되는 압축 알고리즘은 크게 두 가지 범주로 분류 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c418e981dde2783c397a4ab8566b1987e0ddccd" translate="yes" xml:space="preserve">
          <source>Each header field consists of a case-insensitive field name followed
   by a colon (&quot;:&quot;), optional leading whitespace, the field value, and
   optional trailing whitespace. 

     header-field   = field-name &quot;:&quot; OWS field-value OWS

     field-name     = token
     field-value    = *( field-content / obs-fold )
     field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     field-vchar    = VCHAR / obs-text

     obs-fold       = CRLF 1*( SP / HTAB )
                    ; obsolete line folding
                    ; see &lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;

   The field-name token labels the corresponding field-value as having
   the semantics defined by that header field.  For example, the Date
   header field is defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;Section&amp;nbsp;7.1.1.2 of [RFC7231]&lt;/a&gt; as containing
   the origination timestamp for the message in which it appears.</source>
          <target state="translated">각 헤더 필드는 대소 문자를 구분하지 않는 필드 이름 뒤에 콜론 ( &quot;:&quot;), 선택적 선행 공백, 필드 값 및 선택적 후행 공백으로 구성됩니다. header-field = field-name &quot;:&quot;OWS 필드 값 OWS field-name = 토큰 필드 값 = * (field-content / obs-fold) field-content = field-vchar [1 * (SP / HTAB) 필드 -vchar] field-vchar = VCHAR / obs-text obs-fold = CRLF 1 * (SP / HTAB); 쓸모없는 선 접기; &lt;a href=&quot;#section-3.2.4&quot;&gt;섹션 3.2.4&lt;/a&gt; 참조 field-name 토큰은 해당 헤더 필드에 의해 의미가 정의 된 것으로 해당 필드 값에 레이블을 지정합니다. 예를 들어, 날짜 헤더 필드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.1.2&quot;&gt;[RFC7231]의 7.1.1.2 섹션에&lt;/a&gt; 정의되어 있습니다 . 표시되는 메시지의 발신 타임 스탬프를 포함합니다.</target>
        </trans-unit>
        <trans-unit id="9565e409b5a13cd6eeebcf793281c0c14e6920fb" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which handles it and provides an answer, called the &lt;em&gt;response&lt;/em&gt;. Between the client and the server there are numerous entities, collectively called &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">각 개별 요청은 서버로 전송되어이를 처리하고 &lt;em&gt;응답&lt;/em&gt; 이라고하는 &lt;em&gt;응답을&lt;/em&gt; 제공합니다 . 클라이언트와 서버 사이에는 예를 들어 서로 다른 작업을 수행하고 게이트웨이 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;캐시&lt;/a&gt; 역할을하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시&lt;/a&gt; 라고하는 수많은 엔티티가 있습니다 .</target>
        </trans-unit>
        <trans-unit id="caa9777361801f65cdbd5d095a27001848c440f6" translate="yes" xml:space="preserve">
          <source>Each individual request is sent to a server, which will handle it and provide an answer, called the &lt;em&gt;response&lt;/em&gt;. Between this request and response there are numerous entities, collectively designated as &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt;, which perform different operations and act as gateways or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;caches&lt;/a&gt;, for example.</source>
          <target state="translated">각 개별 요청은 서버로 전송되며 서버는이를 처리하고 &lt;em&gt;응답&lt;/em&gt; 이라는 응답을 제공합니다 . 이 요청과 응답 사이에는 집합 적으로 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시로&lt;/a&gt; 지정된 수많은 엔티티가 있으며 , 예를 들어 서로 다른 작업을 수행하고 게이트웨이 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Cache&quot;&gt;캐시&lt;/a&gt; 역할을 합니다.</target>
        </trans-unit>
        <trans-unit id="4d47e568ac317d800ba83293a6e6b145c10f0e3f" translate="yes" xml:space="preserve">
          <source>Each registered protocol name is associated with contact information
   and an optional set of specifications that details how the connection
   will be processed after it has been upgraded.

   Registrations happen on a &quot;First Come First Served&quot; basis (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC5226]&lt;/a&gt;) and are subject to the following rules:

   1.  A protocol-name token, once registered, stays registered forever.

   2.  The registration MUST name a responsible party for the
       registration.

   3.  The registration MUST name a point of contact.

   4.  The registration MAY name a set of specifications associated with
       that token.  Such specifications need not be publicly available.

   5.  The registration SHOULD name a set of expected &quot;protocol-version&quot;
       tokens associated with that token at the time of registration. 

   6.  The responsible party MAY change the registration at any time.
       The IANA will keep a record of all such changes, and make them
       available upon request.

   7.  The IESG MAY reassign responsibility for a protocol token.  This
       will normally only be used in the case when a responsible party
       cannot be contacted.

   This registration procedure for HTTP Upgrade Tokens replaces that
   previously defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.</source>
          <target state="translated">등록 된 각 프로토콜 이름은 연결 정보가 업그레이드 된 후 연결이 처리되는 방법을 자세히 설명하는 연락처 정보 및 옵션 사양과 연관되어 있습니다. 등록은 &quot;선착순&quot;으로 이루어집니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226] 4.1 항&lt;/a&gt; 참조 ))에 따라 다음 규칙이 적용됩니다. 1. 등록 된 프로토콜 이름 토큰은 영원히 등록 된 상태로 유지됩니다. 2. 등록시 등록 담당자를 지정해야합니다. 3. 등록시 반드시 연락 담당자의 이름을 지정해야합니다. 4. 등록시 해당 토큰과 관련된 사양 세트의 이름을 지정할 수 있습니다. 이러한 사양은 공개적으로 사용할 필요는 없습니다. 5. 등록시 등록시 해당 토큰과 관련된 예상 &quot;프로토콜 버전&quot;토큰 세트를 지정해야합니다. 6. 담당자는 언제든지 등록을 변경할 수 있습니다. IANA는 그러한 모든 변경 사항을 기록하고 요청시 변경 사항을 제공합니다. 7. IESG는 프로토콜 토큰에 대한 책임을 재 할당 할 수 있습니다.이는 일반적으로 담당자에게 연락 할 수없는 경우에만 사용됩니다. HTTP 업그레이드 토큰에 대한이 등록 절차는 이전에 정의 된 내용을 대체합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]의 7.2 절&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f681ccf67162d9cff0a908b916182711ed9cc29e" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;: &lt;code&gt;no-store&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">URL에 대한 각 요청은 고유하고 캐시 할 수없는 요청으로 처리됩니다. 이를 나타내는 더 좋은 방법은 &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; : &lt;code&gt;no-store&lt;/code&gt; 를 사용하는 것입니다. 이는 읽기가 더 명확하고 객체를 저장해서는 안된다는 신호를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="fbb1874585ee277130e7dcc804818855ef02a2e2" translate="yes" xml:space="preserve">
          <source>Each request for a URL is supposed to be treated as a unique and uncacheable request. A better way to indicate this is to use &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: private&lt;/code&gt;, which is clearer to read and also signals that the object shouldn't be stored ever.</source>
          <target state="translated">URL에 대한 각 요청은 고유하고 캐시 할 수없는 요청으로 취급됩니다. 이것을 나타내는 더 좋은 방법은 &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: private&lt;/code&gt; 을 사용 하는 것입니다. 이것은보다 명확하게 읽고 객체를 저장해서는 안된다는 신호입니다.</target>
        </trans-unit>
        <trans-unit id="06c0d14065b0e4f4c93db5d7ec072d4c7ca36aee" translate="yes" xml:space="preserve">
          <source>Each type has its own set of possible subtypes, and a MIME type always has both a type and a subtype, never just one or the other.</source>
          <target state="translated">각 유형에는 가능한 하위 유형 집합이 있으며 MIME 유형에는 항상 유형과 하위 유형이 모두 있으며 둘 중 하나만 있습니다.</target>
        </trans-unit>
        <trans-unit id="083351d889941c99f11bdb7f8dc5b5a5a90e3651" translate="yes" xml:space="preserve">
          <source>Early-Data</source>
          <target state="translated">Early-Data</target>
        </trans-unit>
        <trans-unit id="8440b9eb7d03917b2509b5baeab2a299ce257eb0" translate="yes" xml:space="preserve">
          <source>Edge</source>
          <target state="translated">Edge</target>
        </trans-unit>
        <trans-unit id="aa5e3465605004afca0f330dee1d92d60e4608d6" translate="yes" xml:space="preserve">
          <source>Edge 17 skips the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive (&lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt;).</source>
          <target state="translated">Edge 17은 &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; 지시문 ( &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/17415478/&quot;&gt;bug&lt;/a&gt; )을 건너 뜁니다 .</target>
        </trans-unit>
        <trans-unit id="40943d342558e930e5fd4552c5671ad9d18db865" translate="yes" xml:space="preserve">
          <source>Edge Mobile</source>
          <target state="translated">엣지 모바일</target>
        </trans-unit>
        <trans-unit id="8186c1b8199a285af780f2cff07d80dbd60cd881" translate="yes" xml:space="preserve">
          <source>Edge has &lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/&quot;&gt;retired their XSS filter&lt;/a&gt;</source>
          <target state="translated">Edge는 &lt;a href=&quot;https://blogs.windows.com/windowsexperience/2018/07/25/announcing-windows-10-insider-preview-build-17723-and-build-18204/&quot;&gt;XSS 필터를 폐기했습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1594fb58d4be36a563bbf83f00f527da6feeed9b" translate="yes" xml:space="preserve">
          <source>Edge on Windows 10 Mobile</source>
          <target state="translated">Windows 10 Mobile의 Edge</target>
        </trans-unit>
        <trans-unit id="d5ed0aee9b31cc8d3563818529b7abccaaaad432" translate="yes" xml:space="preserve">
          <source>Edge/xyz</source>
          <target state="translated">Edge/xyz</target>
        </trans-unit>
        <trans-unit id="d5fbe14f72118336fc25fa625850b0c5c3be431a" translate="yes" xml:space="preserve">
          <source>EdgeHTML</source>
          <target state="translated">EdgeHTML</target>
        </trans-unit>
        <trans-unit id="add94fac827b3ed02fee4c1b72173331645c25b8" translate="yes" xml:space="preserve">
          <source>Edit this page on MDN</source>
          <target state="translated">MDN에서이 페이지 편집</target>
        </trans-unit>
        <trans-unit id="a769fc9fd1bf50a69b3839fd2f92626878d5b626" translate="yes" xml:space="preserve">
          <source>Editor's Draft</source>
          <target state="translated">편집자 초안</target>
        </trans-unit>
        <trans-unit id="f0aaf1ff183fe38a130caadf7977863f8e2a59f3" translate="yes" xml:space="preserve">
          <source>Editor's draft</source>
          <target state="translated">편집자 초안</target>
        </trans-unit>
        <trans-unit id="90b56ed596b137c9da80b986161d0bd1c8d62cba" translate="yes" xml:space="preserve">
          <source>Editor's draft / Candidate recommendation</source>
          <target state="translated">편집자 초안 / 후보 추천</target>
        </trans-unit>
        <trans-unit id="1c3d5530a42ab230eeb2ce3fa0fa80758453dd56" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">&lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더 또는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 헤더가 사용 되는지 여부에 따라 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;report&quot;&lt;/code&gt; 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="eb29b12af265782c792c3f30babdfaf626f24932" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;report&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">&lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 또는 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더가 사용 되는지 여부에 따라 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;report&quot;&lt;/code&gt; 중 하나 입니다.</target>
        </trans-unit>
        <trans-unit id="1fcd0c7316a8c31f4e9ceb1db446cf33c197f076" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; header is used.</source>
          <target state="translated">어느 쪽의 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; 에 따라 여부 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더 또는 &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d8d9968b1d7df53b6e4cf681453c3df54edc30bf" translate="yes" xml:space="preserve">
          <source>Either &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; or &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; depending on whether the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header or the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header is used.</source>
          <target state="translated">어느 쪽의 &lt;code&gt;&quot;enforce&quot;&lt;/code&gt; 또는 &lt;code&gt;&quot;reporting&quot;&lt;/code&gt; 여부에 따라 &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 또는 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa29e4650b1639a98c0c8f55d262398a02155fba" translate="yes" xml:space="preserve">
          <source>Either the string &quot;GMT&quot; for GMT timezone, or not specified, for local timezone.</source>
          <target state="translated">GMT 시간대의 경우 &quot;GMT&quot;문자열이거나 로컬 시간대의 경우 지정되지 않은 문자열입니다.</target>
        </trans-unit>
        <trans-unit id="eec5a0a958a1fbddcf0daab821af65ae5b6cc34b" translate="yes" xml:space="preserve">
          <source>Electronic mail address</source>
          <target state="translated">전자 우편 주소</target>
        </trans-unit>
        <trans-unit id="f98f953a2a328bdea00e564fed7dfd322a69cd6d" translate="yes" xml:space="preserve">
          <source>Electronic publication (EPUB)</source>
          <target state="translated">전자 출판물 (EPUB)</target>
        </trans-unit>
        <trans-unit id="5a67bc2ccc5173b788a5682e69fed1656994a358" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and are not receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;strong&gt;recommended&lt;/strong&gt; to restrict this fetch-directive (e.g., explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="translated">에 의해 제어 요소 &lt;code&gt;object-src&lt;/code&gt; 아마도 우연히 기존 HTML 요소를 고려하고 (보안 속성과 같은 새로운 표준화 기능을받지 않는 &lt;code&gt;sandbox&lt;/code&gt; 또는 &lt;code&gt;allow&lt;/code&gt; 을위한 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 해당 ). 따라서이 fetch-directive를 제한 하는 것이 &lt;strong&gt;좋습니다&lt;/strong&gt; (예 : 가능하면 명시 적으로 &lt;code&gt;object-src 'none'&lt;/code&gt; 설정 ).</target>
        </trans-unit>
        <trans-unit id="d3465998ffce5d1b11571e20db3e058cd0d4176c" translate="yes" xml:space="preserve">
          <source>Elements controlled by &lt;code&gt;object-src&lt;/code&gt; are perhaps coincidentally considered legacy HTML elements and aren't receiving new standardized features (such as the security attributes &lt;code&gt;sandbox&lt;/code&gt; or &lt;code&gt;allow&lt;/code&gt; for &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;). Therefore it is &lt;a href=&quot;https://csp.withgoogle.com/docs/strict-csp.html&quot;&gt;recommended&lt;/a&gt; to restrict this fetch-directive (e.g. explicitly set &lt;code&gt;object-src 'none'&lt;/code&gt; if possible).</source>
          <target state="translated">&lt;code&gt;object-src&lt;/code&gt; 에 의해 제어되는 요소 는 우연히 기존 HTML 요소로 간주되며 새로운 표준화 된 기능 (예 : 보안 속성 &lt;code&gt;sandbox&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;code&gt;allow&lt;/code&gt; 을 받지 못합니다 . 따라서이 fetch-directive를 제한 하는 것이 &lt;a href=&quot;https://csp.withgoogle.com/docs/strict-csp.html&quot;&gt;좋습니다&lt;/a&gt; (예 : 가능하면 명시 적으로 &lt;code&gt;object-src 'none'&lt;/code&gt; 설정 ).</target>
        </trans-unit>
        <trans-unit id="70620ad9a50dbab17deb7f1669beeb98b33e7dd5" translate="yes" xml:space="preserve">
          <source>Enable CORS: I want to add CORS support to my server</source>
          <target state="translated">CORS 사용 : 서버에 CORS 지원을 추가하고 싶습니다.</target>
        </trans-unit>
        <trans-unit id="7060cb09d904d309fcf66579b0dfa0ec89ffc7ea" translate="yes" xml:space="preserve">
          <source>Enables Cross-Origin Read Blocking (CORB) protection for the MIME-types:</source>
          <target state="translated">MIME 유형에 대해 CORB (Cross-Origin Read Blocking) 보호를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="7a23cd75e8cc48555a5cc4d39dc5d353f54219c1" translate="yes" xml:space="preserve">
          <source>Enables DNS prefetching. This is what browsers do, if they support the feature, when this header is not present</source>
          <target state="translated">DNS 프리 페치를 활성화합니다. 이 헤더가 존재하지 않을 때 브라우저가 기능을 지원하는 경우 수행하는 작업</target>
        </trans-unit>
        <trans-unit id="15f6f232156085ea4d4637fb11cb65dea424795d" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering (usually default in browsers). If a cross-site scripting attack is detected, the browser will sanitize the page (remove the unsafe parts).</source>
          <target state="translated">XSS 필터링을 활성화합니다 (일반적으로 브라우저에서 기본값). 사이트 간 스크립팅 공격이 탐지되면 브라우저에서 페이지를 삭제합니다 (안전하지 않은 부분 제거).</target>
        </trans-unit>
        <trans-unit id="2afff7cdf670cfcd98e1bf3804e6db1cd9978584" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. If a cross-site scripting attack is detected, the browser will sanitize the page and report the violation. This uses the functionality of the CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive to send a report.</source>
          <target state="translated">XSS 필터링을 활성화합니다. 사이트 간 스크립팅 공격이 탐지되면 브라우저는 페이지를 삭제하고 위반을보고합니다. CSP &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시문 의 기능을 사용하여 보고서 를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="04c90c3404283e6479b83c3594ac6645fd7a76cf" translate="yes" xml:space="preserve">
          <source>Enables XSS filtering. Rather than sanitizing the page, the browser will prevent rendering of the page if an attack is detected.</source>
          <target state="translated">XSS 필터링을 활성화합니다. 브라우저는 페이지를 삭제하는 대신 공격이 감지되면 페이지 렌더링을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="22ebba1e22e214dfdd20ecfca28bb3fc46c19982" translate="yes" xml:space="preserve">
          <source>Enables a sandbox for the requested resource similar to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; attribute.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe#attr-sandbox&quot;&gt;sandbox&lt;/a&gt;&lt;/code&gt; 속성 과 유사한 요청 된 리소스에 대한 샌드 박스를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="d9c536a9d2dc890eb3a315dacecf7bf8af2ea7a0" translate="yes" xml:space="preserve">
          <source>Enables cross-site scripting filtering.</source>
          <target state="translated">사이트 간 스크립팅 필터링을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="22f217de833d7c0f4da332bd436a93307529d3b5" translate="yes" xml:space="preserve">
          <source>Enabling HPKP</source>
          <target state="translated">HPKP 활성화</target>
        </trans-unit>
        <trans-unit id="bd97d929640fde2abf473682141dfee61b906111" translate="yes" xml:space="preserve">
          <source>Enabling reporting</source>
          <target state="translated">보고 활성화</target>
        </trans-unit>
        <trans-unit id="d51a5760383324ea2ced3708f0c4f21b3b6433db" translate="yes" xml:space="preserve">
          <source>Encoding data into base64 format</source>
          <target state="translated">base64 형식으로 데이터 인코딩</target>
        </trans-unit>
        <trans-unit id="5a526ce1054f67846c014806870479f982067006" translate="yes" xml:space="preserve">
          <source>Encoding in Javascript</source>
          <target state="translated">자바 스크립트로 인코딩</target>
        </trans-unit>
        <trans-unit id="9e1b3d87041d9d3f6d49d001407d5e51e783220a" translate="yes" xml:space="preserve">
          <source>Encoding on Microsoft Windows</source>
          <target state="translated">Microsoft Windows에서 인코딩</target>
        </trans-unit>
        <trans-unit id="9a85145b06e5a569eeab2640e8113603e4dec581" translate="yes" xml:space="preserve">
          <source>Encoding on Windows can be done through powershell or some dedicated tool. It can even be done via bash &lt;code&gt;base64&lt;/code&gt; utility (see section Encoding on a Unix system) if &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;WSL&lt;/a&gt; is activated.</source>
          <target state="translated">Windows에서 인코딩은 powershell 또는 일부 전용 도구를 통해 수행 할 수 있습니다. &lt;a href=&quot;https://en.wikipedia.org/wiki/Windows_Subsystem_for_Linux&quot;&gt;WSL&lt;/a&gt; 이 활성화 된 경우 bash &lt;code&gt;base64&lt;/code&gt; 유틸리티 (Unix 시스템에서 인코딩 섹션 참조) 를 통해 수행 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9723a9fa3539530df973d9238398c2287f9fc64" translate="yes" xml:space="preserve">
          <source>Encoding on a Unix system</source>
          <target state="translated">Unix 시스템에서 인코딩</target>
        </trans-unit>
        <trans-unit id="635fc00ea52427c14323d1d4ec9234a0c136c15e" translate="yes" xml:space="preserve">
          <source>Encrypted Media Extensions&lt;br/&gt;&lt;small&gt;The definition of 'Feature Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="translated">암호화 된 미디어 확장 &lt;br/&gt;&lt;small&gt;해당 사양에서 '기능 정책 통합'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="f7b844634b78bbf66c2386fb7400b4efd46ba2fc" translate="yes" xml:space="preserve">
          <source>Encrypted media</source>
          <target state="translated">암호화 된 미디어</target>
        </trans-unit>
        <trans-unit id="bb7917263fb0376ecaaebc6aea8b04a067f36021" translate="yes" xml:space="preserve">
          <source>End-to-end compression</source>
          <target state="translated">엔드 투 엔드 압축</target>
        </trans-unit>
        <trans-unit id="a93b3f3b09d62b69cd48fa61fb8317033f43c87d" translate="yes" xml:space="preserve">
          <source>End-to-end headers</source>
          <target state="translated">엔드 투 엔드 헤더</target>
        </trans-unit>
        <trans-unit id="c1f86bbe0ad1ce921865c4c1081ca46c634279dd" translate="yes" xml:space="preserve">
          <source>Enforces &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; at the DOM XSS injection sinks.</source>
          <target state="translated">강제 시행은 &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;유형을 신뢰할 수&lt;/a&gt; 는 DOM XSS 주입 싱크에.</target>
        </trans-unit>
        <trans-unit id="43a78c23ebe3e022d382e262e5bb0fac3b0c04eb" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences</source>
          <target state="translated">좋은 사용자 경험을위한 모범 사례 시행</target>
        </trans-unit>
        <trans-unit id="434a202c7ecffe7d7bd9b742b730a5afd1676889" translate="yes" xml:space="preserve">
          <source>Enforcing best practices for good user experiences.</source>
          <target state="translated">좋은 사용자 경험을위한 모범 사례 시행.</target>
        </trans-unit>
        <trans-unit id="ffa0f5134bbe5f9da939c45f920a197f4634fba1" translate="yes" xml:space="preserve">
          <source>Ensure images are sized properly and are not too big for the viewport.</source>
          <target state="translated">이미지 크기가 적절하고 뷰포트에 비해 너무 크지 않은지 확인하십시오.</target>
        </trans-unit>
        <trans-unit id="2a6cc6b1ec9b8b2e989114255b4da3ce2b2f166e" translate="yes" xml:space="preserve">
          <source>Ensures a resource will disown its opener when navigated to.</source>
          <target state="translated">탐색 할 때 자원이 오프너를 제거하도록합니다.</target>
        </trans-unit>
        <trans-unit id="2f61151d2512a5c88d23bfe8d6fbd9a0947b4f37" translate="yes" xml:space="preserve">
          <source>Entity (RFC 2616)</source>
          <target state="translated">실체 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="234e8581d4bf52bbea04d4ae883867b5f00f2402" translate="yes" xml:space="preserve">
          <source>Entity header</source>
          <target state="translated">엔터티 헤더</target>
        </trans-unit>
        <trans-unit id="83a31c55ad20bb3cf7572f62e10bce1fa2085786" translate="yes" xml:space="preserve">
          <source>Entity tag uniquely representing the requested resource. They are a string of ASCII characters placed between double quotes, like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;. The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Often, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hexadecimal hash of the wiki article content.</source>
          <target state="translated">요청 된 리소스를 고유하게 나타내는 엔티티 태그입니다. &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이 큰 따옴표로 묶인 ASCII 문자 문자열입니다 . &lt;code&gt;ETag&lt;/code&gt; 값이 생성 되는 방법 이 지정되지 않았습니다. 종종 콘텐츠의 해시, 마지막 수정 타임 스탬프의 해시 또는 수정 번호 만 사용됩니다. 예를 들어 MDN은 위키 기사 콘텐츠의 16 진수 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9024c46dde9f89740b2171b9280d89a9caba4424" translate="yes" xml:space="preserve">
          <source>Entity tags are used for comparing two or more entities from the same
   requested resource. HTTP/1.1 uses entity tags in the ETag (&lt;a href=&quot;#section-14.19&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt;), If-Match (&lt;a href=&quot;#section-14.24&quot;&gt;section 14.24&lt;/a&gt;), If-None-Match (&lt;a href=&quot;#section-14.26&quot;&gt;section 14.26&lt;/a&gt;), and
   If-Range (&lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) header fields. The definition of how they
   are used and compared as cache validators is in &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;. An
   entity tag consists of an opaque quoted string, possibly prefixed by
   a weakness indicator.

      entity-tag = [ weak ] opaque-tag
      weak       = &quot;W/&quot;
      opaque-tag = quoted-string

   A &quot;strong entity tag&quot; MAY be shared by two entities of a resource
   only if they are equivalent by octet equality.

   A &quot;weak entity tag,&quot; indicated by the &quot;W/&quot; prefix, MAY be shared by
   two entities of a resource only if the entities are equivalent and
   could be substituted for each other with no significant change in
   semantics. A weak entity tag can only be used for weak comparison.

   An entity tag MUST be unique across all versions of all entities
   associated with a particular resource. A given entity tag value MAY
   be used for entities obtained by requests on different URIs. The use
   of the same entity tag value in conjunction with entities obtained by
   requests on different URIs does not imply the equivalence of those
   entities.</source>
          <target state="translated">엔티티 태그는 요청 된 동일한 자원에서 둘 이상의 엔티티를 비교하는 데 사용됩니다. HTTP / 1.1은 ETag ( &lt;a href=&quot;#section-14.19&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; ), If-Match ( &lt;a href=&quot;#section-14.24&quot;&gt;섹션 14.24&lt;/a&gt; ), If-None-Match ( &lt;a href=&quot;#section-14.26&quot;&gt;섹션 14.26&lt;/a&gt; ) 및 If-Range ( &lt;a href=&quot;#section-14.27&quot;&gt;섹션 14.27&lt;/a&gt; ) 헤더 필드 에서 엔티티 태그를 사용 합니다. 캐시 유효성 검사기로 사용 및 비교되는 방법에 대한 정의는 &lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3 섹션에 있습니다.&lt;/a&gt;. 엔티티 태그는 불투명 인용 문자열로 구성되며 약점 표시기가 접두사로 표시 될 수 있습니다. entity-tag = [weak] opaque-tag weak = &quot;W /&quot;opaque-tag = 인용 된 문자열 &quot;strong entity tag&quot;는 자원의 두 엔티티가 옥텟 동등성에 해당하는 경우에만 공유 될 수 있습니다. &quot;W /&quot;접두사로 표시된 &quot;약한 엔티티 태그&quot;는 엔티티가 동등하고 의미의 큰 변화없이 서로 대체 될 수있는 경우에만 리소스의 두 엔티티에 의해 공유 될 수 있습니다. 약한 엔티티 태그는 약한 비교에만 사용할 수 있습니다. 엔티티 태그는 특정 자원과 관련된 모든 엔티티의 모든 버전에서 고유해야합니다. 주어진 엔티티 태그 값은 다른 URI에 대한 요청으로 얻은 엔티티에 사용될 수 있습니다.다른 URI에 대한 요청으로 얻은 엔티티와 함께 ​​동일한 엔티티 태그 값을 사용한다고해서 해당 엔티티의 동등성을 의미하지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="843ca4f28f9ce3aa7d78cfc1dd5d180a8db20d61" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used (This is useless with &lt;code&gt;If-None-Match&lt;/code&gt; as it only uses that algorithm).</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에 놓인 ASCII 문자 문자열이며 약한 비교 알고리즘을 사용해야 함을 나타 내기 위해 &lt;code&gt;W/&lt;/code&gt; 접두사가 붙을 수 있습니다 (이것은 사용하는 &lt;code&gt;If-None-Match&lt;/code&gt; 에만 If-None-Match 와 함께 사용할 수 없음) 그 알고리즘).</target>
        </trans-unit>
        <trans-unit id="cb4831ed8a07834c227f88278424a465acad3a5a" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;) and may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that the weak comparison algorithm should be used.</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에있는 ASCII 문자 문자열이며 약한 비교 알고리즘을 사용해야 함을 나타 내기 위해 &lt;code&gt;W/&lt;/code&gt; 접두사가 붙을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f511403ebe3ad82f8791c9cc50f7078c288954a3" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (Like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). The method by which &lt;code&gt;ETag&lt;/code&gt; values are generated is not specified. Oftentimes, a hash of the content, a hash of the last modification timestamp, or just a revision number is used. For example, MDN uses a hash of hexadecimal digits of the wiki content.</source>
          <target state="translated">요청 된 자원을 고유하게 나타내는 엔티티 태그. 큰 따옴표 ( &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; 와 같이) 사이에있는 ASCII 문자 문자열입니다 . &lt;code&gt;ETag&lt;/code&gt; 값이 생성 되는 방법 이 지정되지 않았습니다. 종종 콘텐츠의 해시, 마지막 수정 타임 스탬프의 해시 또는 수정 번호 만 사용됩니다. 예를 들어, MDN은 위키 컨텐츠의 16 진 숫자 해시를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3b0aa4ab650e7127575b944e7c4f357507fe1bf6" translate="yes" xml:space="preserve">
          <source>Entity tags uniquely representing the requested resources. They are a string of ASCII characters placed between double quotes (like &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt;). They may be prefixed by &lt;code&gt;W/&lt;/code&gt; to indicate that they are &quot;weak&quot;, i.e. that they represent the resource semantically, but not byte-for-byte. However, in an &lt;code&gt;If-Match&lt;/code&gt; header, weak entity tags will never match.</source>
          <target state="translated">요청 된 리소스를 고유하게 나타내는 엔터티 태그입니다. 큰 따옴표로 묶인 ASCII 문자열입니다 (예 : &lt;code&gt;&quot;675af34563dc-tr34&quot;&lt;/code&gt; ). &quot;약함&quot;을 나타 내기 위해 &lt;code&gt;W/&lt;/code&gt; 접두사가 붙을 수 있습니다 . 즉, 리소스를 의미 론적으로 나타내지 만 바이트 단위가 아니라는 것을 나타냅니다. 그러나 &lt;code&gt;If-Match&lt;/code&gt; 헤더에서 약한 엔티티 태그는 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e2d3b3c670a7def682fbdd286ebd5fcf01de31d4" translate="yes" xml:space="preserve">
          <source>Entity-header fields define metainformation about the entity-body or,
   if no body is present, about the resource identified by the request.
   Some of this metainformation is OPTIONAL; some might be REQUIRED by
   portions of this specification.

       entity-header  = Allow                    ; &lt;a href=&quot;#section-14.7&quot;&gt;Section 14.7&lt;/a&gt;
                      | Content-Encoding         ; &lt;a href=&quot;#section-14.11&quot;&gt;Section 14.11&lt;/a&gt;
                      | Content-Language         ; &lt;a href=&quot;#section-14.12&quot;&gt;Section 14.12&lt;/a&gt;
                      | Content-Length           ; &lt;a href=&quot;#section-14.13&quot;&gt;Section 14.13&lt;/a&gt;
                      | Content-Location         ; &lt;a href=&quot;#section-14.14&quot;&gt;Section 14.14&lt;/a&gt;
                      | Content-MD5              ; &lt;a href=&quot;#section-14.15&quot;&gt;Section 14.15&lt;/a&gt;
                      | Content-Range            ; &lt;a href=&quot;#section-14.16&quot;&gt;Section 14.16&lt;/a&gt;
                      | Content-Type             ; &lt;a href=&quot;#section-14.17&quot;&gt;Section 14.17&lt;/a&gt;
                      | Expires                  ; &lt;a href=&quot;#section-14.21&quot;&gt;Section 14.21&lt;/a&gt;
                      | Last-Modified            ; &lt;a href=&quot;#section-14.29&quot;&gt;Section 14.29&lt;/a&gt;
                      | extension-header

       extension-header = message-header

   The extension-header mechanism allows additional entity-header fields
   to be defined without changing the protocol, but these fields cannot
   be assumed to be recognizable by the recipient. Unrecognized header
   fields SHOULD be ignored by the recipient and MUST be forwarded by
   transparent proxies.</source>
          <target state="translated">엔티티 헤더 필드는 엔티티 본문 또는 본문이없는 경우 요청에 의해 식별 된 자원에 대한 메타 정보를 정의합니다. 이 메타 정보 중 일부는 선택 사항입니다. 일부는이 사양의 일부에 필요할 수 있습니다. 엔티티 헤더 = 허용; &lt;a href=&quot;#section-14.7&quot;&gt;섹션 14.7&lt;/a&gt; | 콘텐츠 인코딩; &lt;a href=&quot;#section-14.11&quot;&gt;섹션 14.11&lt;/a&gt; | 내용 언어; &lt;a href=&quot;#section-14.12&quot;&gt;섹션 14.12&lt;/a&gt; | 내용 길이; &lt;a href=&quot;#section-14.13&quot;&gt;섹션 14.13&lt;/a&gt; | 콘텐츠 위치; &lt;a href=&quot;#section-14.14&quot;&gt;섹션 14.14&lt;/a&gt; | 내용 MD5; &lt;a href=&quot;#section-14.15&quot;&gt;섹션 14.15&lt;/a&gt; | 콘텐츠 범위;&lt;a href=&quot;#section-14.16&quot;&gt;섹션 14.16&lt;/a&gt; | 컨텐츠 타입 ; &lt;a href=&quot;#section-14.17&quot;&gt;섹션 14.17&lt;/a&gt; | 만료; &lt;a href=&quot;#section-14.21&quot;&gt;섹션 14.21&lt;/a&gt; | 마지막 수정; &lt;a href=&quot;#section-14.29&quot;&gt;섹션 14.29&lt;/a&gt; | extension-header extension-header = message-header extension-header 메커니즘을 사용하면 프로토콜을 변경하지 않고도 추가 엔터티 헤더 필드를 정의 할 수 있지만 이러한 필드는 수신자가 인식 할 수 있다고 가정 할 수 없습니다. 인식 할 수없는 헤더 필드는 수신자에 의해 무시되어야하며 반드시 투명한 프록시에 의해 전달되어야합니다.</target>
        </trans-unit>
        <trans-unit id="dc77c92755cf792527e0b3edc88e46b61f8087b7" translate="yes" xml:space="preserve">
          <source>Error responses: a &lt;a href=&quot;status/404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; (Not Found) result page.</source>
          <target state="translated">오류 응답 : &lt;a href=&quot;status/404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; (찾을 수 없음) 결과 페이지.</target>
        </trans-unit>
        <trans-unit id="805e86a8cbf628e38e4c45612c005a504009e79a" translate="yes" xml:space="preserve">
          <source>Errors</source>
          <target state="translated">Errors</target>
        </trans-unit>
        <trans-unit id="ec4322ae064b7f4e2416acd40d4d58f17e5f8f12" translate="yes" xml:space="preserve">
          <source>Errors: CORSAllowOriginNotMatchingOrigin</source>
          <target state="translated">오류 : CORSAllowOriginNotMatchingOrigin</target>
        </trans-unit>
        <trans-unit id="4087c6aa16b5abf1735ae9f8137528c87023309b" translate="yes" xml:space="preserve">
          <source>Errors: CORSDidNotSucceed</source>
          <target state="translated">오류 : CORSDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="1110c379846585f2593a508b8c164b5bd8320b76" translate="yes" xml:space="preserve">
          <source>Errors: CORSDisabled</source>
          <target state="translated">오류 : CORSDisabled</target>
        </trans-unit>
        <trans-unit id="dac4e756c8a76cbef1b33dca607cb3bc5b771e95" translate="yes" xml:space="preserve">
          <source>Errors: CORSExternalRedirectNotAllowed</source>
          <target state="translated">오류 : CORSExternalRedirectNotAllowed</target>
        </trans-unit>
        <trans-unit id="ce973b3c74a1ebbfbbd6d7dec66c6bb20ce1f763" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowHeader</source>
          <target state="translated">오류 : CORSInvalidAllowHeader</target>
        </trans-unit>
        <trans-unit id="a282fd28c28a400d13afa18351e51568b54396d2" translate="yes" xml:space="preserve">
          <source>Errors: CORSInvalidAllowMethod</source>
          <target state="translated">오류 : CORSInvalidAllowMethod</target>
        </trans-unit>
        <trans-unit id="b8d43e50964c1cfd887f4afc94b47bcdd5d69570" translate="yes" xml:space="preserve">
          <source>Errors: CORSMIssingAllowCredentials</source>
          <target state="translated">오류 : CORSMIssingAllowCredentials</target>
        </trans-unit>
        <trans-unit id="710e0ccb5287b4319b0c5fdee5593e1d13fa6e37" translate="yes" xml:space="preserve">
          <source>Errors: CORSMethodNotFound</source>
          <target state="translated">오류 : CORSMethodNotFound</target>
        </trans-unit>
        <trans-unit id="a307f601e16873b1a5a1472fa793e47e1b28b743" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowHeaderFromPreflight</source>
          <target state="translated">오류 : CORSMissingAllowHeaderFromPreflight</target>
        </trans-unit>
        <trans-unit id="3d47284892dc16fb82eea87c1c413d4b5c528c8b" translate="yes" xml:space="preserve">
          <source>Errors: CORSMissingAllowOrigin</source>
          <target state="translated">오류 : CORSMissingAllowOrigin</target>
        </trans-unit>
        <trans-unit id="59e949130b0899712b1a17c6d46a1f58dc1ad38e" translate="yes" xml:space="preserve">
          <source>Errors: CORSMultipleAllowOriginNotAllowed</source>
          <target state="translated">오류 : CORSMultipleAllowOriginNotAllowed</target>
        </trans-unit>
        <trans-unit id="fe11294cab619d12140db3bf906980249f0d9b51" translate="yes" xml:space="preserve">
          <source>Errors: CORSNotSupportingCredentials</source>
          <target state="translated">오류 : CORSNotSupportingCredentials</target>
        </trans-unit>
        <trans-unit id="9d941c8ccc9202a89b0022d5ed88c86d19e065a4" translate="yes" xml:space="preserve">
          <source>Errors: CORSOriginHeaderNotAdded</source>
          <target state="translated">오류 : CORSOriginHeaderNotAdded</target>
        </trans-unit>
        <trans-unit id="4b2583c03a065a201e0c7af7eb778cf128afcc99" translate="yes" xml:space="preserve">
          <source>Errors: CORSPreflightDidNotSucceed</source>
          <target state="translated">오류 : CORSPreflightDidNotSucceed</target>
        </trans-unit>
        <trans-unit id="a43f3bb8e46c7f4d0e112510dc95499734debf0d" translate="yes" xml:space="preserve">
          <source>Errors: CORSRequestNotHttp</source>
          <target state="translated">오류 : CORSRequestNotHttp</target>
        </trans-unit>
        <trans-unit id="76e3d52572cfb5f282f24af08ceb3c93515e0c23" translate="yes" xml:space="preserve">
          <source>Establishing a connection</source>
          <target state="translated">연결 설정</target>
        </trans-unit>
        <trans-unit id="d9c2c223b0f7d2f2a1d0a4ab149a50dae5eaf1dd" translate="yes" xml:space="preserve">
          <source>Evaluation (RFC 7232)</source>
          <target state="translated">평가 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="016549bb81a6b73cbdac91b27317bed690bbaf39" translate="yes" xml:space="preserve">
          <source>Even if both the client and the server supports the same compression algorithms, the server may choose not to compress the body of a response, if the identity value is also acceptable. Two common cases lead to this:</source>
          <target state="translated">클라이언트와 서버가 모두 동일한 압축 알고리즘을 지원하더라도 ID 값도 허용되는 경우 서버는 응답 본문을 압축하지 않도록 선택할 수 있습니다. 두 가지 일반적인 경우는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="39e1dc57ed79bde6d7d9296899ff80637127740c" translate="yes" xml:space="preserve">
          <source>Even if identity and location are both described using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL&lt;/a&gt;, they are two different concepts and it is useful sometimes to distinguished between them. This article introduces the &lt;a href=&quot;headers/alt-svc&quot;&gt;&lt;code&gt;Alt-Svc&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">아이덴티티와 위치가 모두 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URL&quot;&gt;URL을&lt;/a&gt; 사용하여 설명 되더라도 두 가지 다른 개념이며 때로는 서로 구별하는 것이 유용합니다. 이 기사에서는 &lt;a href=&quot;headers/alt-svc&quot;&gt; &lt;code&gt;Alt-Svc&lt;/code&gt; &lt;/a&gt; 헤더를 소개합니다 .</target>
        </trans-unit>
        <trans-unit id="d11701203cf55bb28a83c78028e1b759782a7ab9" translate="yes" xml:space="preserve">
          <source>Even if server-driven content negotiation is the most common way to agree on a specific representation of a resource, it has several drawbacks:</source>
          <target state="translated">서버 중심의 콘텐츠 협상이 리소스의 특정 표현에 동의하는 가장 일반적인 방법이지만 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="d8b58599d2ecd8aca415a34fd71768d962e8e310" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents align with it - you can still find this type of bugged software out there. It is therefore recommended to use the &lt;code&gt;301&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use the &lt;a href=&quot;308&quot;&gt;&lt;code&gt;308 Permanent Redirect&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; methods instead, as the method change is explicitly prohibited with this status.</source>
          <target state="translated">사양에서 리디렉션을 수행 할 때 방법 (및 본문)을 변경하지 않아도 모든 사용자 에이전트가 해당 방법과 일치하는 것은 아닙니다. 이러한 유형의 버그가있는 소프트웨어는 여전히 찾을 수 있습니다. 따라서이 상태에서는 메소드 변경이 명시 적으로 금지 되므로 &lt;code&gt;301&lt;/code&gt; 코드는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 메소드에 대한 응답으로 만 사용하고 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 메소드에 대해서는 &lt;a href=&quot;308&quot;&gt; &lt;code&gt;308 Permanent Redirect&lt;/code&gt; &lt;/a&gt; 를 대신 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="60e9e00953556ca6c857baf9a61ba9002b374a14" translate="yes" xml:space="preserve">
          <source>Even if the specification requires the method (and the body) not to be altered when the redirection is performed, not all user-agents conform here - you can still find this type of bugged software out there. It is therefore recommended to set the &lt;code&gt;302&lt;/code&gt; code only as a response for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods and to use &lt;a href=&quot;307&quot;&gt;&lt;code&gt;307 Temporary Redirect&lt;/code&gt;&lt;/a&gt; instead, as the method change is explicitly prohibited in that case.</source>
          <target state="translated">사양에서 리디렉션을 수행 할 때 방법 (및 본문)을 변경하지 않아도 모든 사용자 에이전트가 여기에 해당하는 것은 아닙니다. 여전히 이러한 유형의 버그가있는 소프트웨어를 찾을 수 있습니다. 따라서 &lt;code&gt;302&lt;/code&gt; 코드는 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 메소드에 대한 응답으로 만 설정하고 대신 &lt;a href=&quot;307&quot;&gt; &lt;code&gt;307 Temporary Redirect&lt;/code&gt; &lt;/a&gt; 를 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="41dab3c71327a38803685ef6e3cebc869962fcfb" translate="yes" xml:space="preserve">
          <source>Even if this method works, it adds an extra response/request exchange when the document has been changed. This impairs performance, and HTTP has a specific header to avoid this scenario: &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">이 방법이 작동하더라도 문서가 변경되면 추가 응답 / 요청 교환을 추가합니다. 이로 인해 성능이 저하되고 HTTP에는이 시나리오를 피하기위한 특정 헤더가 있습니다. &lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="b284eb5d595f914af47d2a8c3a9cef82f913efb4" translate="yes" xml:space="preserve">
          <source>Even if this technique also works for internal links, you should try to avoid having internal redirects. A redirect has a significant performance cost (as an extra HTTP request is done) and if you can avoid it by correcting internal links, you should fix these links.</source>
          <target state="translated">이 기술이 내부 링크에도 적용 되더라도 내부 리디렉션이 발생하지 않도록해야합니다. 리디렉션은 추가 HTTP 요청이 완료 될 때 상당한 성능 비용이 발생하며 내부 링크를 수정하여이를 피할 수 있으면 이러한 링크를 수정해야합니다.</target>
        </trans-unit>
        <trans-unit id="58665e4007bca0cad4410abfb11d1a4668903330" translate="yes" xml:space="preserve">
          <source>Even with more complexity, introduced in HTTP/2 by encapsulating HTTP messages into frames, HTTP is generally designed to be simple and human readable. HTTP messages can be read and understood by humans, providing easier developer testing, and reduced complexity for new-comers.</source>
          <target state="translated">HTTP 메시지를 프레임으로 캡슐화하여 HTTP / 2에 도입 된 더 복잡한 경우에도 HTTP는 일반적으로 간단하고 사람이 읽을 수 있도록 설계되었습니다. HTTP 메시지는 사람이 읽고 이해할 수 있으므로 개발자 테스트가 쉬워지고 신규 사용자의 복잡성이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="8b42fb3b1821d636c208455d3a9009fab5579ed3" translate="yes" xml:space="preserve">
          <source>Evercookie by Samy Kamkar</source>
          <target state="translated">Samy Kamkar의 Evercookie</target>
        </trans-unit>
        <trans-unit id="f7b5a8683f9a1cf2ee2d67f073ba064ecc576032" translate="yes" xml:space="preserve">
          <source>Everyone, really.</source>
          <target state="translated">여러분 정말.</target>
        </trans-unit>
        <trans-unit id="f49a3e37d7614909e74abaad869cfa8d5952bf40" translate="yes" xml:space="preserve">
          <source>Evolution of HTTP</source>
          <target state="translated">HTTP의 진화</target>
        </trans-unit>
        <trans-unit id="0f01ed56a1e32a05e5ef96e4d779f34784af9a96" translate="yes" xml:space="preserve">
          <source>Example</source>
          <target state="translated">Example</target>
        </trans-unit>
        <trans-unit id="6dcd3f46d09547b62bf07ba9b2943c95d53ddae3" translate="yes" xml:space="preserve">
          <source>Example 1</source>
          <target state="translated">실시 예 1</target>
        </trans-unit>
        <trans-unit id="1c56ea49918b9baed94cf4bc0ee9f324efc8841a" translate="yes" xml:space="preserve">
          <source>Example 2</source>
          <target state="translated">실시 예 2</target>
        </trans-unit>
        <trans-unit id="fbf4dab701189a344fa5ab06d7b87c11a74e3da0" translate="yes" xml:space="preserve">
          <source>Example 3</source>
          <target state="translated">실시 예 3</target>
        </trans-unit>
        <trans-unit id="f4cd3ef194759e6a1bf205a2958b720d8edb10da" translate="yes" xml:space="preserve">
          <source>Example 4</source>
          <target state="translated">실시 예 4</target>
        </trans-unit>
        <trans-unit id="dcb2a7f833e9a3ee29881cf3f00069ceeab20571" translate="yes" xml:space="preserve">
          <source>Example 5</source>
          <target state="translated">실시 예 5</target>
        </trans-unit>
        <trans-unit id="69126e599801a8577cf34e537a3e5b119797d966" translate="yes" xml:space="preserve">
          <source>Example 6</source>
          <target state="translated">실시 예 6</target>
        </trans-unit>
        <trans-unit id="fad75d0ce8eb620d0eb8c90ad36bb1d3ba100630" translate="yes" xml:space="preserve">
          <source>Example HPKP Header</source>
          <target state="translated">HPKP 헤더 예</target>
        </trans-unit>
        <trans-unit id="6f262b0de6886f68de9a7f3020d9645e1a46ad07" translate="yes" xml:space="preserve">
          <source>Example of typical subtypes</source>
          <target state="translated">일반적인 하위 유형의 예</target>
        </trans-unit>
        <trans-unit id="987339acda1c7e11edad694279b3ef232cafa98c" translate="yes" xml:space="preserve">
          <source>Example preflight request</source>
          <target state="translated">프리 플라이트 요청 예</target>
        </trans-unit>
        <trans-unit id="1937f18faac9b560d6b0ad0c27d8e5021d3c2ec8" translate="yes" xml:space="preserve">
          <source>Example requests</source>
          <target state="translated">요청 예</target>
        </trans-unit>
        <trans-unit id="101e766cdf474de8672fa38603435f2c2f88941b" translate="yes" xml:space="preserve">
          <source>Example response</source>
          <target state="translated">응답 예</target>
        </trans-unit>
        <trans-unit id="9e9047fddfc8910797ad5dcc2be127acbfe08b7f" translate="yes" xml:space="preserve">
          <source>Example responses</source>
          <target state="translated">응답 예</target>
        </trans-unit>
        <trans-unit id="c63737abd7347a7ae582cb9fbdf37d6c0e5b251e" translate="yes" xml:space="preserve">
          <source>Example:</source>
          <target state="translated">Example:</target>
        </trans-unit>
        <trans-unit id="1391352a916b067bd98f31a68d100a8e123a5170" translate="yes" xml:space="preserve">
          <source>Example: Disable unsafe inline/eval, only allow loading of resources (images, fonts, scripts, etc.) over https:</source>
          <target state="translated">예 : 안전하지 않은 인라인 / 평가판을 비활성화하고 https를 통한 리소스 (이미지, 글꼴, 스크립트 등) 만로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c7fd2423984ee2e46f44f28ab3c25a81d90c3fd1" translate="yes" xml:space="preserve">
          <source>Example: Do not implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">예 : 위의 정책을 아직 구현하지 마십시오. 대신 발생했을 위반 사항을보고하십시오.</target>
        </trans-unit>
        <trans-unit id="179aebe7be456d632b5d789d99331eede78b73e3" translate="yes" xml:space="preserve">
          <source>Example: Don't implement the above policy yet; instead just report violations that would have occurred:</source>
          <target state="translated">예 : 위의 정책을 아직 구현하지 마십시오. 대신 발생한 위반 사항 만보고하십시오.</target>
        </trans-unit>
        <trans-unit id="6a1a9b351cb6e527d7405905cebedc49fbc528bb" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over HTTPS and to disable plugins:</source>
          <target state="translated">예 : 수정하기 위해 너무 많은 인라인 코드를 사용하지만 리소스가 HTTPS를 통해서만로드되도록하고 플러그인을 비활성화하려는 기존 사이트 :</target>
        </trans-unit>
        <trans-unit id="e17700dcd76dcab4611e46cba8a84a5260c2c790" translate="yes" xml:space="preserve">
          <source>Example: Pre-existing site that uses too much inline code to fix but wants to ensure resources are loaded only over https and disable plugins:</source>
          <target state="translated">예 : 너무 많은 인라인 코드를 사용하여 수정하지만 https를 통해서만 리소스를로드하고 플러그인을 비활성화하려는 기존 사이트 :</target>
        </trans-unit>
        <trans-unit id="eb01bf04c9a0e8a71c45816513df424f1c7ffedb" translate="yes" xml:space="preserve">
          <source>Examples</source>
          <target state="translated">Examples</target>
        </trans-unit>
        <trans-unit id="cd077131fc10d919fcb4af0bc52b5d5dc3bff60d" translate="yes" xml:space="preserve">
          <source>Examples of Access Control in Action</source>
          <target state="translated">액세스 제어의 예</target>
        </trans-unit>
        <trans-unit id="42b05d16ad1706c69b98dcd1d0beab7d996df8be" translate="yes" xml:space="preserve">
          <source>Examples of access control scenarios</source>
          <target state="translated">액세스 제어 시나리오의 예</target>
        </trans-unit>
        <trans-unit id="8b6959ab8197d951dfd31c9bfb60d608f8853eea" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above.&lt;/a&gt;</source>
          <target state="translated">이 사용법의 예는 &lt;a href=&quot;#Preflighted_requests&quot;&gt;위에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="65a7ed9127c8003c7810083e7bbc1569d8b66810" translate="yes" xml:space="preserve">
          <source>Examples of this usage can be &lt;a href=&quot;#Preflighted_requests&quot;&gt;found above&lt;/a&gt;.</source>
          <target state="translated">이 사용법의 예는 &lt;a href=&quot;#Preflighted_requests&quot;&gt;위에서 찾을&lt;/a&gt; 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="47abb8e5ca6a2e13e7aa85756a29b3a05a3d8d7b" translate="yes" xml:space="preserve">
          <source>Examples of what you can do with Feature Policy:</source>
          <target state="translated">기능 정책으로 수행 할 수있는 작업의 예 :</target>
        </trans-unit>
        <trans-unit id="fb3447b632f6a431215776dcf254a01001a40c4f" translate="yes" xml:space="preserve">
          <source>Examples:</source>
          <target state="translated">Examples:</target>
        </trans-unit>
        <trans-unit id="57e9b7197782a4e7584bbc9820ab7355aa88a3d3" translate="yes" xml:space="preserve">
          <source>Examples: Common use cases</source>
          <target state="translated">예 : 일반적인 사용 사례</target>
        </trans-unit>
        <trans-unit id="997886ce9b39820b9d7574fbb168082bb6c4cfb9" translate="yes" xml:space="preserve">
          <source>Except for the standard hop-by-hop headers (&lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;proxy-authenticate&quot;&gt;&lt;code&gt;Proxy-Authenticate&lt;/code&gt;&lt;/a&gt;), any hop-by-hop headers used by the message must be listed in the &lt;code&gt;Connection&lt;/code&gt; header, so that the first proxy knows it has to consume them and not forward them further. Standard hop-by-hop headers can be listed too (it is often the case of &lt;a href=&quot;keep-alive&quot;&gt;&lt;code&gt;Keep-Alive&lt;/code&gt;&lt;/a&gt;, but this is not mandatory).</source>
          <target state="translated">표준 홉-바이-홉 헤더 ( &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;proxy-authenticate&quot;&gt; &lt;code&gt;Proxy-Authenticate&lt;/code&gt; &lt;/a&gt; )를 제외하고, 메시지가 사용하는 홉-바이-홉 헤더가 나열되어야합니다. 에 &lt;code&gt;Connection&lt;/code&gt; 헤더, 그래서 첫 번째 프록시는 그들을 소비하고 더 전달할하지가 알고 있다는 것을. 표준 홉별 헤더도 나열 할 수 있습니다 (종종 &lt;a href=&quot;keep-alive&quot;&gt; &lt;code&gt;Keep-Alive&lt;/code&gt; 의&lt;/a&gt; 경우이지만 필수 사항은 아님).</target>
        </trans-unit>
        <trans-unit id="7233a11fc2426584ed01a173a4d930d34926020b" translate="yes" xml:space="preserve">
          <source>Except when excluded below, a recipient cache or origin server MUST
   evaluate received request preconditions after it has successfully
   performed its normal request checks and just before it would perform
   the action associated with the request method.  A server MUST ignore
   all received preconditions if its response to the same request
   without those conditions would have been a status code other than a
   2xx (Successful) or 412 (Precondition Failed).  In other words,
   redirects and failures take precedence over the evaluation of
   preconditions in conditional requests. 

   A server that is not the origin server for the target resource and
   cannot act as a cache for requests on the target resource MUST NOT
   evaluate the conditional request header fields defined by this
   specification, and it MUST forward them if the request is forwarded,
   since the generating client intends that they be evaluated by a
   server that can provide a current representation.  Likewise, a server
   MUST ignore the conditional request header fields defined by this
   specification when received with a request method that does not
   involve the selection or modification of a selected representation,
   such as CONNECT, OPTIONS, or TRACE.

   Conditional request header fields that are defined by extensions to
   HTTP might place conditions on all recipients, on the state of the
   target resource in general, or on a group of resources.  For
   instance, the &quot;If&quot; header field in WebDAV can make a request
   conditional on various aspects of multiple resources, such as locks,
   if the recipient understands and implements that field (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918],
   Section&amp;nbsp;10.4&lt;/a&gt;).

   Although conditional request header fields are defined as being
   usable with the HEAD method (to keep HEAD's semantics consistent with
   those of GET), there is no point in sending a conditional HEAD
   because a successful response is around the same size as a 304 (Not
   Modified) response and more useful than a 412 (Precondition Failed)
   response.</source>
          <target state="translated">아래에서 제외 된 경우를 제외하고, 수신자 캐시 또는 오리진 서버는 정상적인 요청 점검을 성공적으로 수행 한 후 및 요청 방법과 연관된 조치를 수행하기 직전에 수신 된 요청 사전 조건을 평가해야합니다. 조건없이 동일한 요청에 대한 응답이 2xx (성공) 또는 412 (전제 조건 실패) 이외의 상태 코드 인 경우 서버는 수신 된 모든 전제 조건을 무시해야합니다. 다시 말해, 리디렉션 및 실패는 조건부 요청의 사전 조건 평가보다 우선합니다. 대상 자원에 대한 원 서버가 아니며 대상 자원에 대한 요청에 대한 캐시 역할을 할 수없는 서버는이 사양에 정의 된 조건부 요청 헤더 필드를 평가해서는 안됩니다.그리고 생성 된 클라이언트가 현재 표현을 제공 할 수있는 서버에 의해 평가되도록하기 때문에 요청이 전달되면 반드시 전달해야합니다. 마찬가지로, 서버는 CONNECT, OPTIONS 또는 TRACE와 같은 선택된 표현의 선택 또는 수정을 포함하지 않는 요청 방법으로 수신 될 때이 스펙에 의해 정의 된 조건부 요청 헤더 필드를 무시해야합니다. HTTP 확장으로 정의 된 조건부 요청 헤더 필드는 모든 수신자, 대상 자원의 상태 또는 자원 그룹에 조건을 둘 수 있습니다. 예를 들어, WebDAV의 &quot;If&quot;헤더 필드는 수신자가 해당 필드를 이해하고 구현하는 경우 잠금과 같은 여러 자원의 다양한 측면에 대해 조건부로 요청을 할 수 있습니다 (수신자가 해당 필드를 이해하고 구현 한 경우 (&lt;a href=&quot;https://tools.ietf.org/html/rfc4918#section-10.4&quot;&gt;[RFC4918], 섹션 10.4&lt;/a&gt; ). HEAD의 의미를 GET의 의미와 일치하게 유지하기 위해 HEAD 방법으로 조건부 요청 헤더 필드를 사용할 수있는 것으로 정의되었지만 성공적인 응답의 크기가 304와 크기가 같기 때문에 조건부 HEAD를 보낼 때는 아무런 의미가 없습니다 (수정되지 않음). ) 응답이 있으며 412 (사전 조건 실패) 응답보다 유용합니다.</target>
        </trans-unit>
        <trans-unit id="25c9949f0e8e682737f53bb3d3d209c13c6e1d5b" translate="yes" xml:space="preserve">
          <source>Executable script is only allowed from userscripts.example.com.</source>
          <target state="translated">실행 가능한 스크립트는 userscripts.example.com에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="2d47895b1210b1ebd4fa933059d36aed26cda284" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely.  HTTP does not provide a mechanism for the
   origin server to direct clients to discard these cached credentials,
   since the protocol has no awareness of how credentials are obtained 

   or managed by the user agent.  The mechanisms for expiring or
   revoking credentials can be specified as part of an authentication
   scheme definition.

   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

   o  Clients that have been idle for an extended period, following
      which the server might wish to cause the client to re-prompt the
      user for credentials.

   o  Applications that include a session termination indication (such
      as a &quot;logout&quot; or &quot;commit&quot; button on a page) after which the server
      side of the application &quot;knows&quot; that there is no further reason
      for the client to retain the credentials.

   User agents that cache credentials are encouraged to provide a
   readily accessible mechanism for discarding cached credentials under
   user control.</source>
          <target state="translated">기존 HTTP 클라이언트 및 사용자 에이전트는 일반적으로 인증 정보를 무기한 보유합니다. 프로토콜은 사용자 에이전트가 자격 증명을 얻거나 관리하는 방법을 인식하지 못하므로 HTTP는 원본 서버가 클라이언트에게 이러한 캐시 된 자격 증명을 삭제하도록 지시하는 메커니즘을 제공하지 않습니다. 자격 증명 만료 또는 취소 메커니즘은 인증 체계 정의의 일부로 지정할 수 있습니다. 자격 증명 캐싱이 응용 프로그램의 보안 모델을 방해 할 수있는 상황에는 다음이 포함되지만 이에 국한되지는 않습니다. o 오랜 기간 동안 유휴 상태 인 클라이언트는 서버로 하여금 클라이언트에게 자격 증명을 다시 프롬프트하도록 할 수 있습니다. o 세션 종료 표시가 포함 된 응용 프로그램 (예 : &quot;로그 아웃&quot;또는 페이지의 &quot;커밋&quot;버튼)을 확인한 후 응용 프로그램의 서버 측에서 클라이언트가 자격 증명을 유지해야 할 추가 이유가 없음을 &quot;인식&quot;합니다. 자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6ccac52b5d4274914636579bf1636b1d5fa966cc" translate="yes" xml:space="preserve">
          <source>Existing HTTP clients and user agents typically retain authentication
   information indefinitely. HTTP/1.1. does not provide a method for a
   server to direct clients to discard these cached credentials. This is
   a significant defect that requires further extensions to HTTP.
   Circumstances under which credential caching can interfere with the
   application's security model include but are not limited to:

      - Clients which have been idle for an extended period following
        which the server might wish to cause the client to reprompt the
        user for credentials.

      - Applications which include a session termination indication
        (such as a `logout' or `commit' button on a page) after which
        the server side of the application `knows' that there is no
        further reason for the client to retain the credentials.

   This is currently under separate study. There are a number of work-
   arounds to parts of this problem, and we encourage the use of
   password protection in screen savers, idle time-outs, and other
   methods which mitigate the security problems inherent in this
   problem. In particular, user agents which cache credentials are
   encouraged to provide a readily accessible mechanism for discarding
   cached credentials under user control.</source>
          <target state="translated">기존 HTTP 클라이언트 및 사용자 에이전트는 일반적으로 인증 정보를 무기한 보유합니다. HTTP / 1.1. 서버가 클라이언트에게 이러한 캐시 된 자격 증명을 삭제하도록 지시하는 방법을 제공하지 않습니다. 이는 HTTP에 대한 추가 확장이 필요한 중대한 결함입니다. 자격 증명 캐싱이 응용 프로그램의 보안 모델을 방해 할 수있는 상황에는 다음이 포함 되나 이에 국한되지는 않습니다. -세션 종료 표시를 포함하는 응용 프로그램 (예 : 페이지의 '로그 아웃'또는 '커밋'버튼)은 응용 프로그램의 서버 측이 '알고'클라이언트가 자격 증명을 유지해야 할 추가 이유가 없습니다. 이것은 현재 별도의 연구 중입니다. 이 문제의 일부에 대한 해결 방법이 많이 있으며 화면 보호기, 유휴 시간 제한 및이 문제에 내재 된 보안 문제를 완화시키는 기타 방법에서 비밀번호 보호를 사용하는 것이 좋습니다. 특히, 자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하도록 권장됩니다.자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하도록 권장됩니다.자격 증명을 캐시하는 사용자 에이전트는 사용자 제어하에 캐시 된 자격 증명을 폐기하기 위해 쉽게 액세스 할 수있는 메커니즘을 제공하도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="a57a461722611e40b9d47ce41e5966ee9c0e2bfc" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site</source>
          <target state="translated">사이트의 도달 범위 확장</target>
        </trans-unit>
        <trans-unit id="8a76f4ceddd2c24dfba52fcd6415b4a5d7627655" translate="yes" xml:space="preserve">
          <source>Expanding the reach of your site. A common case is when your site resides under the &lt;code&gt;www.example.com&lt;/code&gt; domain and accessing your pages from &lt;code&gt;example.com&lt;/code&gt; should be possible, too. Redirections for &lt;code&gt;example.com&lt;/code&gt; pages to &lt;code&gt;www.example.com&lt;/code&gt; are set up in this case. You might also provide commonly used synonym names or frequent typos of your domain names.</source>
          <target state="translated">사이트의 범위를 넓 힙니다. 귀하의 사이트가 &lt;code&gt;www.example.com&lt;/code&gt; 도메인에 상주하고 &lt;code&gt;example.com&lt;/code&gt; 에서 페이지에 액세스 할 수 있는 경우가 일반적 입니다. 이 경우 &lt;code&gt;example.com&lt;/code&gt; 페이지에 대한 &lt;code&gt;www.example.com&lt;/code&gt; 으로의 리디렉션 이 설정됩니다. 일반적으로 사용되는 동의어 이름이나 도메인 이름을 자주 입력 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="58fc1be971a32518b08bb4967f47c3e29fc379b9" translate="yes" xml:space="preserve">
          <source>Expect</source>
          <target state="translated">Expect</target>
        </trans-unit>
        <trans-unit id="994027919b14e63b028676f8e18f24f8c3412b5f" translate="yes" xml:space="preserve">
          <source>Expect (RFC 2616)</source>
          <target state="translated">기대 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="53f1bb33df8415879d9607269fadc4b08f7884fc" translate="yes" xml:space="preserve">
          <source>Expect (RFC 7231)</source>
          <target state="translated">기대 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="dac7eb9f8e739ef71916b8aa6eabe504d21db9ae" translate="yes" xml:space="preserve">
          <source>Expect-CT</source>
          <target state="translated">Expect-CT</target>
        </trans-unit>
        <trans-unit id="1782a86fff7281c9294c0d3eefa4ab6846695cc2" translate="yes" xml:space="preserve">
          <source>Expect-CT Extension for HTTP</source>
          <target state="translated">HTTP에 대한 Exp-CT 확장</target>
        </trans-unit>
        <trans-unit id="79322ef6edc1926ecbca88fd7e24b3ff46c3ac45" translate="yes" xml:space="preserve">
          <source>Experimental spec</source>
          <target state="translated">실험 사양</target>
        </trans-unit>
        <trans-unit id="549fb9eb005687c11bca9c3462372257a7683df5" translate="yes" xml:space="preserve">
          <source>Experiments are in progress to design a better transport protocol more suited to HTTP. For example, Google is experimenting with &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; which builds on UDP to provide a more reliable and efficient transport protocol.</source>
          <target state="translated">HTTP에보다 적합한 전송 프로토콜을 설계하기위한 실험이 진행 중입니다. 예를 들어 Google은 보다 안정적이고 효율적인 전송 프로토콜을 제공하기 위해 UDP를 기반으로하는 &lt;a href=&quot;https://en.wikipedia.org/wiki/QUIC&quot;&gt;QUIC&lt;/a&gt; 를 실험하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="1c82119c31678afc6233c719096414eef0fb22b6" translate="yes" xml:space="preserve">
          <source>Expiration</source>
          <target state="translated">Expiration</target>
        </trans-unit>
        <trans-unit id="a99be3da0c9da2f3c64500b5ef8a8e48f503d127" translate="yes" xml:space="preserve">
          <source>Expires</source>
          <target state="translated">Expires</target>
        </trans-unit>
        <trans-unit id="cc75acb2b0ea3b677a15b0b6b818f64332802b2f" translate="yes" xml:space="preserve">
          <source>Expires (RFC 2616)</source>
          <target state="translated">만료 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="668c321a385a7ec5effd27dc4959016e1b54db8c" translate="yes" xml:space="preserve">
          <source>Expires (RFC 7234)</source>
          <target state="translated">만료 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="798d2fe08024167fc3592a3e1fdd8f0482db3150" translate="yes" xml:space="preserve">
          <source>Expires=&amp;lt;date&amp;gt; Optional</source>
          <target state="translated">만료 = &amp;lt;날짜&amp;gt; 옵션</target>
        </trans-unit>
        <trans-unit id="440f936591556c4ab22d4ca93b07905600bf80fc" translate="yes" xml:space="preserve">
          <source>Explains how a client and a server can negotiate a specific HTTP version and eventually upgrade the protocol version used.</source>
          <target state="translated">클라이언트와 서버가 특정 HTTP 버전을 협상하고 결국 사용 된 프로토콜 버전을 업그레이드하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="4c04fa2d870e27906bb18e89eabbb66f7bf88805" translate="yes" xml:space="preserve">
          <source>Expresses the user's tracking preference.</source>
          <target state="translated">사용자의 추적 선호도를 표현합니다.</target>
        </trans-unit>
        <trans-unit id="a639e6f336caa1c98ebcd19c35befb40a19c9aca" translate="yes" xml:space="preserve">
          <source>Extending a database through an append operation.</source>
          <target state="translated">추가 작업을 통해 데이터베이스를 확장합니다.</target>
        </trans-unit>
        <trans-unit id="659087d3ca23db6ae11e0a43579b5f4a260dda11" translate="yes" xml:space="preserve">
          <source>Extension</source>
          <target state="translated">Extension</target>
        </trans-unit>
        <trans-unit id="a5be9d96e47f86f30faca0b0c0d8cd92b6b591df" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives</source>
          <target state="translated">확장 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문</target>
        </trans-unit>
        <trans-unit id="fef92b354ef2777bc846bf834005b52b7dd4a00e" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Be sure to check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support.</source>
          <target state="translated">확장 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문은 핵심 HTTP 캐싱 표준 문서의 일부가 아닙니다. 지원 여부는 &lt;a href=&quot;#Browser_compatibility&quot;&gt;호환성 표&lt;/a&gt; 를 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="790215898ba9547c6ca3b5fc75be3806f3e82b33" translate="yes" xml:space="preserve">
          <source>Extension &lt;code&gt;Cache-Control&lt;/code&gt; directives are not part of the core HTTP caching standards document. Check the &lt;a href=&quot;#Browser_compatibility&quot;&gt;compatibility table&lt;/a&gt; for their support; user-agents that don't recognize them should ignore them.</source>
          <target state="translated">확장 &lt;code&gt;Cache-Control&lt;/code&gt; 지시문은 핵심 HTTP 캐싱 표준 문서의 일부가 아닙니다. 지원에 대한 &lt;a href=&quot;#Browser_compatibility&quot;&gt;호환성 표&lt;/a&gt; 를 확인하십시오 . 이를 인식하지 못하는 사용자 에이전트는이를 무시해야합니다.</target>
        </trans-unit>
        <trans-unit id="16b9d10d572cffd131c6e10d79fd13870c1b14e9" translate="yes" xml:space="preserve">
          <source>Extension Cache-Control directives</source>
          <target state="translated">확장 Cache-Control 지시문</target>
        </trans-unit>
        <trans-unit id="f9618205d36acb2ec9a802339b387cf754ed53de" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;) unless it's overwritten via an HTTP header that is set for a CSS stylesheet specifically.</source>
          <target state="translated">CSS 스타일 시트 용으로 특별히 설정된 HTTP 헤더를 통해 덮어 쓰지 않으면 외부 CSS 스타일 시트는 기본 정책 ( &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; )을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="1f757e53076199141ccd603fa5607cc746399b36" translate="yes" xml:space="preserve">
          <source>External CSS stylesheets use the default policy (&lt;code&gt;no-referrer-when-downgrade&lt;/code&gt;), unless it's overwritten via a &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP header on the CSS stylesheet&amp;rsquo;s response.</source>
          <target state="translated">외부 CSS 스타일 시트 는 CSS 스타일 시트의 응답에서 &lt;code&gt;Referrer-Policy&lt;/code&gt; HTTP 헤더를 통해 덮어 쓰지 않는 한 기본 정책 ( &lt;code&gt;no-referrer-when-downgrade&lt;/code&gt; ) 을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="51b4519004830e628fefbfc612f64b245ab37406" translate="yes" xml:space="preserve">
          <source>Extracting the Base64 encoded public key information</source>
          <target state="translated">Base64로 인코딩 된 공개 키 정보 추출</target>
        </trans-unit>
        <trans-unit id="82ca99fbea5a5ea4d775520c3099a29adbd2bbf4" translate="yes" xml:space="preserve">
          <source>F.1.  Changes for Both Client and Server Implementations</source>
          <target state="translated">F.1. 클라이언트 및 서버 구현 모두에 대한 변경 사항</target>
        </trans-unit>
        <trans-unit id="e3444e81a7c395eacc8d894f9505a6b6ec9ed898" translate="yes" xml:space="preserve">
          <source>F.2.  Changes for Server Implementations</source>
          <target state="translated">F.2. 서버 구현에 대한 변경 사항</target>
        </trans-unit>
        <trans-unit id="8d6a58de84dd929ed244644a2cc93d7d20768fb2" translate="yes" xml:space="preserve">
          <source>F.3.  Other Changes</source>
          <target state="translated">F.3. 다른 변화들</target>
        </trans-unit>
        <trans-unit id="22da6d41863afa4c87a7a2a96539883a5b235c05" translate="yes" xml:space="preserve">
          <source>FTP is still acceptable at the top level (such as typed directly into the browser's URL bar, or the target of a link), although some browsers may delegate loading FTP content to another application.</source>
          <target state="translated">FTP는 브라우저의 URL 표시 줄 또는 링크 대상에 직접 입력하는 것과 같이 최상위 수준에서도 여전히 허용되지만 일부 브라우저는 다른 응용 프로그램에 FTP 내용로드를 위임 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92fe61c3f61162d432bcc18c5c3c2721f89c4867" translate="yes" xml:space="preserve">
          <source>Faced with this error, browsers usually either abort the operation (for example, a download will be considered as non-resumable) or ask for the whole document again.</source>
          <target state="translated">이 오류가 발생하면 브라우저는 일반적으로 작업을 중단하거나 (예 : 다운로드가 재개 불가능한 것으로 간주 됨) 전체 문서를 다시 요청합니다.</target>
        </trans-unit>
        <trans-unit id="b4a100ebc4c1820c605bd96d9dd279ff888640e2" translate="yes" xml:space="preserve">
          <source>Fallback</source>
          <target state="translated">Fallback</target>
        </trans-unit>
        <trans-unit id="eba72e67a897b4f1538c1c559bf91bf79d26f8df" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;fullscreen&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.는 특정 &amp;lt;iframe&amp;gt;을 제외한 모든 교차 출처 하위 프레임에 대해 &lt;code&gt;fullscreen&lt;/code&gt; 을 비활성화하려고합니다 . 기능 정책을 정의하기 위해 다음 HTTP 응답 헤더를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="30c4b13be3aa4b1468bedb0d443187e381399c80" translate="yes" xml:space="preserve">
          <source>FastCorp Inc. wants to disable &lt;code&gt;geolocation&lt;/code&gt; for all cross-origin child frames, except for a specific &amp;lt;iframe&amp;gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">FastCorp Inc.는 특정 &amp;lt;iframe&amp;gt;을 제외하고 모든 교차 출처 하위 프레임에 대해 &lt;code&gt;geolocation&lt;/code&gt; 를 비활성화하려고합니다 . 기능 정책을 정의하기 위해 다음 HTTP 응답 헤더를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="2b02ecda0275dbc6a16322d0aa2715bb1b0c7f16" translate="yes" xml:space="preserve">
          <source>Feature Policy</source>
          <target state="translated">기능 정책</target>
        </trans-unit>
        <trans-unit id="116ce4ea97fc76a7402a5b9f210f36fadfbb4c2b" translate="yes" xml:space="preserve">
          <source>Feature Policy allows web developers to selectively enable, disable, and modify the behavior of certain features and APIs in the browser. It is similar to &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;Content Security Policy&lt;/a&gt; but controls features instead of security behavior.</source>
          <target state="translated">기능 정책을 통해 웹 개발자는 브라우저에서 특정 기능 및 API의 동작을 선택적으로 활성화, 비활성화 및 수정할 수 있습니다. &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CSP&quot;&gt;콘텐츠 보안 정책&lt;/a&gt; 과 유사 하지만 보안 동작 대신 기능을 제어합니다.</target>
        </trans-unit>
        <trans-unit id="c53bb4cebead9ce42d5d5eff5bdc667fd91758b5" translate="yes" xml:space="preserve">
          <source>Feature Policy allows you to control which origins can use which features, both in the top-level page and in embedded frames. Essentially, you write a policy, which is an allowed list of origins for each feature. For every feature controlled by Feature Policy, the feature is only enabled in the current document or frame if its origin matches the allowed list of origins.</source>
          <target state="translated">기능 정책을 사용하면 최상위 페이지와 내장 프레임에서 어느 원본이 어떤 기능을 사용할 수 있는지 제어 할 수 있습니다. 기본적으로 각 기능에 허용되는 원점 목록 인 정책을 작성합니다. 기능 정책에 의해 제어되는 모든 기능에 대해, 해당 기능은 해당 원본이 허용 된 원본 목록과 일치하는 경우에만 현재 문서 나 프레임에서 활성화됩니다.</target>
        </trans-unit>
        <trans-unit id="23cd7a78a2dc77e19ba57e025deceab5b480ee5d" translate="yes" xml:space="preserve">
          <source>Feature Policy provides a mechanism to explicitly declare what functionality is used (or not used), throughout your website. This allows you to lock in best practices, even as the codebase evolves over time &amp;mdash; as well as to more safely compose third-party content &amp;mdash; by limiting which features are available.</source>
          <target state="translated">기능 정책은 웹 사이트 전체에서 사용되거나 사용되지 않는 기능을 명시 적으로 선언하는 메커니즘을 제공합니다. 이를 통해 사용 가능한 기능을 제한하여 코드베이스가 시간이 지남에 따라 발전하고 타사 콘텐츠를보다 안전하게 작성할 수 있도록 모범 사례를 유지할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="92799190c0f4fe5ecaee2952ecf286aa6cce9ac3" translate="yes" xml:space="preserve">
          <source>Feature Policy provides two ways to specify policies to control features:</source>
          <target state="translated">기능 정책은 기능을 제어 할 정책을 지정하는 두 가지 방법을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="0847c40e72979da8866a8e8b3f1f0cc411a2dad3" translate="yes" xml:space="preserve">
          <source>Feature Policy: Using Feature Policy</source>
          <target state="translated">기능 정책 : 기능 정책 사용</target>
        </trans-unit>
        <trans-unit id="fcae4ecf5da500dd00bf9572a09b7e678697d109" translate="yes" xml:space="preserve">
          <source>Feature Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</source>
          <target state="translated">기능 정책 &lt;br/&gt;&lt;small&gt;해당 사양에서 '기능 정책'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="294d4d9a4eaac5449bf61242940545b797efd4f7" translate="yes" xml:space="preserve">
          <source>Feature detection</source>
          <target state="translated">기능 감지</target>
        </trans-unit>
        <trans-unit id="6680a4d48c2812c07a01fb3632993e80d45a2200" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. In those rare cases where behavior differs between browsers, instead of checking the user agent string, you should instead implement a test to detect how the browser implements the API and determine how to use it from that. An example of feature detection is as follows. In 2017, Chrome &lt;a href=&quot;https://www.chromestatus.com/feature/5668726032564224&quot;&gt;unflagged experimental lookbehind support in regular expressions&lt;/a&gt;, but no other browser supported it. So, you might have thought to do this:</source>
          <target state="translated">기능 감지는 어떤 브라우저가 페이지를 렌더링하는지 파악하지 않고 대신 필요한 특정 기능을 사용할 수 있는지 확인하는 곳입니다. 그렇지 않은 경우 대체를 사용합니다. 드물게 브라우저간에 동작이 다른 경우 사용자 에이전트 문자열을 확인하는 대신 브라우저가 API를 구현하는 방법을 감지하고이를 사용하는 방법을 결정하는 테스트를 구현해야합니다. 특징 감지의 예는 다음과 같습니다. 2017 년에 Chrome &lt;a href=&quot;https://www.chromestatus.com/feature/5668726032564224&quot;&gt;은 정규 표현식에서 실험적 룩백 지원을 표시&lt;/a&gt; 하지 않았지만 다른 브라우저에서는이를 지원하지 않았습니다. 따라서 이렇게 생각했을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="4cfcbb2b685a05f07291909f36952c99a4e2fe7b" translate="yes" xml:space="preserve">
          <source>Feature detection is where you don't try to figure out which browser is rendering your page, but instead, you check to see if the specific feature you need is available. If it's not, you use a fallback. There are never any rare cases where you should use the user agent string, such as to detect a browser which implements the behavior of an API differently. Rather, in such rare cases, you should implement a test to detect how the browser implements the API and then determine when and how to use it instead. A good current example of feature detection is as follows. Recently, Chrome has added experimental look behind support to regular expressions, but no other browser currently supports this. So, you might incorrectly assume you should do this:</source>
          <target state="translated">기능 감지는 페이지를 렌더링하는 브라우저를 파악하려고하지 않고 필요한 특정 기능을 사용할 수 있는지 확인합니다. 그렇지 않은 경우 대체를 사용합니다. API 동작을 다르게 구현하는 브라우저를 감지하는 등 사용자 에이전트 문자열을 사용해야하는 드문 경우는 없습니다. 오히려 드문 경우이지만 브라우저가 API를 구현하는 방법을 감지하고 대신 사용시기와 방법을 결정하는 테스트를 구현해야합니다. 현재 특징 검출의 좋은 예는 다음과 같다. 최근 Chrome에서는 정규 표현식에 대한 지원 뒤에 실험적인 모습을 추가했지만 현재 다른 브라우저에서는 지원하지 않습니다. 따라서이 작업을 수행해야한다고 잘못 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="95c726252d0d002492bfb760d3686808998bb8df" translate="yes" xml:space="preserve">
          <source>Feature policies on www.chromestatus.com</source>
          <target state="translated">www.chromestatus.com의 기능 정책</target>
        </trans-unit>
        <trans-unit id="d7fb77650eb9c4f73d9377f06679ca2cd28df471" translate="yes" xml:space="preserve">
          <source>Feature-Policy</source>
          <target state="translated">Feature-Policy</target>
        </trans-unit>
        <trans-unit id="6731078bdcb61e26085f7dc9985790c18e8a240e" translate="yes" xml:space="preserve">
          <source>Feature-Policy Tester (Chrome Developer Tools extension)</source>
          <target state="translated">기능 정책 테스터 (Chrome 개발자 도구 확장)</target>
        </trans-unit>
        <trans-unit id="a6ee4ffa583da7bdf223c2ffed9d85ab239371e0" translate="yes" xml:space="preserve">
          <source>Feature-Policy: autoplay</source>
          <target state="translated">기능 정책 : 자동 재생</target>
        </trans-unit>
        <trans-unit id="31f9ca897eb5c9f44de8842f2516fb02a54faa2e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: camera</source>
          <target state="translated">기능 정책 : 카메라</target>
        </trans-unit>
        <trans-unit id="bf16c6ee691c8e9ca8e2dbe87a3f347fcb570cc7" translate="yes" xml:space="preserve">
          <source>Feature-Policy: document-domain</source>
          <target state="translated">기능 정책 : 문서 도메인</target>
        </trans-unit>
        <trans-unit id="fe796e681d5c63dcc531be776ac43685da71889f" translate="yes" xml:space="preserve">
          <source>Feature-Policy: encrypted-media</source>
          <target state="translated">기능 정책 : 암호화 된 미디어</target>
        </trans-unit>
        <trans-unit id="37767aecde5e9787909f7866d3735071b1ccad3d" translate="yes" xml:space="preserve">
          <source>Feature-Policy: fullscreen</source>
          <target state="translated">기능 정책 : 전체 화면</target>
        </trans-unit>
        <trans-unit id="9488de5430b2b3fc9fd436b5e2d0c394e296837e" translate="yes" xml:space="preserve">
          <source>Feature-Policy: geolocation</source>
          <target state="translated">기능 정책 : 지리적 위치</target>
        </trans-unit>
        <trans-unit id="2c61ebc183f28f44ab1b2b148b5d57942442df26" translate="yes" xml:space="preserve">
          <source>Feature-Policy: microphone</source>
          <target state="translated">기능 정책 : 마이크</target>
        </trans-unit>
        <trans-unit id="596057da4c0cdcb20ea8b614fd43950671e7a493" translate="yes" xml:space="preserve">
          <source>Feature-Policy: midi</source>
          <target state="translated">기능 정책 : 미디</target>
        </trans-unit>
        <trans-unit id="6ae2a5e94ce91f2de51637745788fb01a6ad53dc" translate="yes" xml:space="preserve">
          <source>Feature-Policy: payment</source>
          <target state="translated">기능 정책 : 결제</target>
        </trans-unit>
        <trans-unit id="6392e975cf7e0435d78f4e6d61f8527537c58cfd" translate="yes" xml:space="preserve">
          <source>Feature-Policy: vr</source>
          <target state="translated">기능 정책 : vr</target>
        </trans-unit>
        <trans-unit id="088204f1105dd468d38881f2fd12a0b4aa4c7aab" translate="yes" xml:space="preserve">
          <source>Feature-Policy:fullscreen</source>
          <target state="translated">Feature-Policy:fullscreen</target>
        </trans-unit>
        <trans-unit id="d710338755da08a83c18e218bac6cbaa1e2a4fd1" translate="yes" xml:space="preserve">
          <source>Feature-Policy:geolocation</source>
          <target state="translated">Feature-Policy:geolocation</target>
        </trans-unit>
        <trans-unit id="9d7e13756d87f97651352edd83fe4becad54f376" translate="yes" xml:space="preserve">
          <source>Feature-Policy:microphone</source>
          <target state="translated">Feature-Policy:microphone</target>
        </trans-unit>
        <trans-unit id="e7e6e3dcff550300eec2d95910564a70e893cba4" translate="yes" xml:space="preserve">
          <source>Features are each defined to have a default allowlist, which is one of:</source>
          <target state="translated">기능은 각각 기본 허용 목록을 갖도록 정의되며 다음 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="73987c80f34346a88ab75127eefbe27a82362092" translate="yes" xml:space="preserve">
          <source>Features restricted to secure contexts</source>
          <target state="translated">보안 컨텍스트로 제한된 기능</target>
        </trans-unit>
        <trans-unit id="39e28fef517be6e0fc21d5716c7662e4801ad299" translate="yes" xml:space="preserve">
          <source>Fetch API</source>
          <target state="translated">가져 오기 API</target>
        </trans-unit>
        <trans-unit id="0c16479e5749d322208146b5b5f7624d72ebd140" translate="yes" xml:space="preserve">
          <source>Fetch directive</source>
          <target state="translated">가져 오기 지시문</target>
        </trans-unit>
        <trans-unit id="e53b45c9af742d503a22c70314dddb7873195091" translate="yes" xml:space="preserve">
          <source>Fetch directives</source>
          <target state="translated">지시문 가져 오기</target>
        </trans-unit>
        <trans-unit id="7a5dfae050f11fd6283650bfb92f289b86d2ac98" translate="yes" xml:space="preserve">
          <source>Fetch directives control locations from which certain resource types may be loaded.</source>
          <target state="translated">가져 오기 지시문은 특정 자원 유형이로드 될 수있는 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="6117c09509a0de56a9b4f6836fda41153fe625f3" translate="yes" xml:space="preserve">
          <source>Fetch directives control the locations from which certain resource types may be loaded.</source>
          <target state="translated">Fetch 지시문은 특정 리소스 유형이로드 될 수있는 위치를 제어합니다.</target>
        </trans-unit>
        <trans-unit id="afdd60e438b0416f34aeb50bf03aae713ddb1bda" translate="yes" xml:space="preserve">
          <source>Fetch metadata request headers</source>
          <target state="translated">메타 데이터 요청 헤더 가져 오기</target>
        </trans-unit>
        <trans-unit id="916f35ff813a6743346055125d97c6cbba1aaedc" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Credentials' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Credentials'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="0678866e50722f12e36a5dc2fec0748a692fe2ca" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Headers'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="2cf87afd008c8c6a087d3cc6f98ba0277b9043b7" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Methods' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Methods'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="e4f7ed2d1134249b47bfd1f0ca53f80515e1563f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Access-Control-Allow-Origin'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="b6d65973f43b54eb3f3ef47447a2bae6cff6fe97" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Expose-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Expose-Headers'의 정의를&lt;/small&gt; 가져 &lt;br/&gt;&lt;small&gt;옵니다.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="8089c31c9e26d8f2db19edbf9e44a130bc5eddd3" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Max-Age' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 사양에서 'Access-Control-Max-Age'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9397823a091bbc18047f30f651f6476462ab4fa8" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Headers' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Request-Headers'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="82f6f83e1801614fce5a5524369fe1de50f85da5" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Access-Control-Request-Method' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'Access-Control-Request-Method'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7e1eb076c3812c097fec7c1be9899bd085c5fbf1" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'CORS' in that specification.&lt;/small&gt;</source>
          <target state="translated">페치 &lt;br/&gt;&lt;small&gt;해당 스펙에서 'CORS'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="fe63ee35db7f3102d616e69a27e101cdcc18b63a" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'Origin header' in that specification.&lt;/small&gt;</source>
          <target state="translated">Fetch &lt;br/&gt;&lt;small&gt;해당 스펙에서 'Origin header'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="1446331a1b71bc30148510fc4d99d0e0ec91086f" translate="yes" xml:space="preserve">
          <source>Fetch&lt;br/&gt;&lt;small&gt;The definition of 'X-Content-Type-Options definition' in that specification.&lt;/small&gt;</source>
          <target state="translated">&lt;small&gt;해당 스펙에서 'X-Content-Type-Options 정의'의 정의를&lt;/small&gt; 가져옵니다 &lt;br/&gt;&lt;small&gt;.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="918815e8513a9d78892a5b82f5db40dddb1a7f3b" translate="yes" xml:space="preserve">
          <source>Fetching the root page of developer.mozilla.org, i.e. &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt;, and telling the server that the user-agent would prefer the page in French, if possible:</source>
          <target state="translated">developer.mozilla.org의 루트 페이지 (예 : &lt;a href=&quot;https://developer.mozilla.org/&quot;&gt;http://developer.mozilla.org/&lt;/a&gt; )를 가져오고 가능한 경우 사용자 에이전트가 프랑스어로 페이지를 선호한다고 서버에 알리십시오.</target>
        </trans-unit>
        <trans-unit id="3253d0b90d63fd1a7b31fd3494e21aaa52e7e42e" translate="yes" xml:space="preserve">
          <source>File Transfer Protocol</source>
          <target state="translated">파일 전송 프로토콜</target>
        </trans-unit>
        <trans-unit id="5d438ceeae874a432c5e55fd5791a60c59eb0d8f" translate="yes" xml:space="preserve">
          <source>File extension(s)</source>
          <target state="translated">File extension(s)</target>
        </trans-unit>
        <trans-unit id="361a82465491c9161713f597566a3f42e5734e1b" translate="yes" xml:space="preserve">
          <source>File format</source>
          <target state="translated">파일 형식</target>
        </trans-unit>
        <trans-unit id="4a7b57a8f84d5b2b2d5abb274bb773348457c9ea" translate="yes" xml:space="preserve">
          <source>File format compression</source>
          <target state="translated">파일 형식 압축</target>
        </trans-unit>
        <trans-unit id="57fa91ed93807da407d7147d7099ef87d3eef96c" translate="yes" xml:space="preserve">
          <source>Filename suffixes are sometimes used, especially on Microsoft Windows. Not all operating systems consider these suffixes meaningful (such as Linux and MacOS), and there is no guarantee they are correct.</source>
          <target state="translated">파일 이름 접미사가 가끔 Microsoft Windows에서 사용되기도합니다. 모든 운영 체제가 이러한 접미어를 의미있는 것으로 간주하는 것은 아니며 (예 : Linux 및 MacOS) 정확한지 보장 할 수는 없습니다.</target>
        </trans-unit>
        <trans-unit id="b8a4a48235c2528b57fabea0f16e59922544df82" translate="yes" xml:space="preserve">
          <source>Files whose MIME type is &lt;code&gt;image&lt;/code&gt; contain image data. The subtype specifies which specific image file format the data represents. Only a few image types are used commonly enough to be considered safe for use on web pages:</source>
          <target state="translated">MIME 유형이 &lt;code&gt;image&lt;/code&gt; 인 파일 에는 이미지 데이터 가 포함됩니다. 하위 유형은 데이터가 나타내는 특정 이미지 파일 형식을 지정합니다. 웹 페이지에서 사용하기에 안전한 것으로 간주 될만큼 일반적으로 몇 가지 이미지 유형 만 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d1888d033ef09f73993a1ae6180b384a516770e4" translate="yes" xml:space="preserve">
          <source>Filtration based on &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, if any at all.</source>
          <target state="translated">&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; 을&lt;/a&gt; 기준으로 한 여과 .</target>
        </trans-unit>
        <trans-unit id="02b7b1f402f1dad5cba5d5c6f4047891c00d3834" translate="yes" xml:space="preserve">
          <source>Finally, &lt;a href=&quot;headers/access-control-max-age&quot;&gt;&lt;code&gt;Access-Control-Max-Age&lt;/code&gt;&lt;/a&gt; gives the value in seconds for how long the response to the preflight request can be cached for without sending another preflight request. In this case, 86400 seconds is 24 hours. Note that each browser has a &lt;a href=&quot;headers/access-control-max-age&quot;&gt;maximum internal value&lt;/a&gt; that takes precedence when the &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; is greater.</source>
          <target state="translated">마지막으로 &lt;a href=&quot;headers/access-control-max-age&quot;&gt; &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; &lt;/a&gt; 는 다른 프리 플라이트 요청을 보내지 않고 프리 플라이트 요청에 대한 응답을 캐시 할 수있는 시간 (초)을 제공합니다. 이 경우 86400 초는 24 시간입니다. 각 브라우저의 &lt;a href=&quot;headers/access-control-max-age&quot;&gt;최대 내부 값&lt;/a&gt; 은 &lt;code&gt;Access-Control-Max-Age&lt;/code&gt; 가 클 때 우선합니다 .</target>
        </trans-unit>
        <trans-unit id="9c162123e6b08c6245b8c567094309cf3046a7d6" translate="yes" xml:space="preserve">
          <source>Finding insecure requests</source>
          <target state="translated">안전하지 않은 요청 찾기</target>
        </trans-unit>
        <trans-unit id="b4ee6522335b033249255b4cc1d572993282aafb" translate="yes" xml:space="preserve">
          <source>Firefox</source>
          <target state="translated">Firefox</target>
        </trans-unit>
        <trans-unit id="3d69145991747b3ff98ca2ac235bf9a2b6c0b22b" translate="yes" xml:space="preserve">
          <source>Firefox 3.6 and later</source>
          <target state="translated">Firefox 3.6 이상</target>
        </trans-unit>
        <trans-unit id="9a053be79e5c0ac7481cbdffd78827759a3ed9f5" translate="yes" xml:space="preserve">
          <source>Firefox 4</source>
          <target state="translated">Firefox 4</target>
        </trans-unit>
        <trans-unit id="e75eacacb146d953aa91455b2699bff5088fb836" translate="yes" xml:space="preserve">
          <source>Firefox 5 handles the &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP response header more effectively if both the &lt;code&gt;filename&lt;/code&gt; and &lt;code&gt;filename*&lt;/code&gt; parameters are provided; it looks through all provided names, using the &lt;code&gt;filename*&lt;/code&gt; parameter if one is available, even if a &lt;code&gt;filename&lt;/code&gt; parameter is included first. Previously, the first matching parameter would be used, thereby preventing a more appropriate name from being used. See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;bug 588781&lt;/a&gt;.</source>
          <target state="translated">Firefox 5는 &lt;code&gt;filename&lt;/code&gt; 및 &lt;code&gt;filename*&lt;/code&gt; 매개 변수가 모두 제공되는 경우 &lt;code&gt;Content-Disposition&lt;/code&gt; HTTP 응답 헤더를보다 효과적으로 처리합니다 . &lt;code&gt;filename&lt;/code&gt; 매개 변수가 먼저 포함되어 있더라도 &lt;code&gt;filename*&lt;/code&gt; 매개 변수를 사용할 수있는 경우 filename * 매개 변수를 사용하여 제공된 모든 이름을 찾습니다 . 이전에는 첫 번째 일치 매개 변수가 사용되어보다 적절한 이름이 사용되지 않았습니다. &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=588781&quot;&gt;버그 588781을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="4443afafb8462a4928ffbe0151cd70875fd784c9" translate="yes" xml:space="preserve">
          <source>Firefox 72 enables &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt; for top-level documents</source>
          <target state="translated">Firefox 72는 &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt; 최상위 문서에 대한 nosniff 를 활성화 합니다.</target>
        </trans-unit>
        <trans-unit id="98488d27ab42c5d6a59371f548c195bffbe9d824" translate="yes" xml:space="preserve">
          <source>Firefox 82 (and later) and Chrome prioritize the HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&amp;lt;a&amp;gt; element's&lt;/a&gt;&lt;code&gt;download&lt;/code&gt; attribute over the &lt;code&gt;Content-Disposition&lt;/code&gt;&lt;code&gt;inline&lt;/code&gt; parameter (for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin URLs&lt;/a&gt;). Earlier Firefox versions prioritize the header and will display the content inline.</source>
          <target state="translated">Firefox 82 이상 및 Chrome 은 &lt;code&gt;Content-Disposition&lt;/code&gt; &lt;code&gt;inline&lt;/code&gt; 매개 변수 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일 출처 URL의 경우&lt;/a&gt; ) 보다 HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&amp;lt;a&amp;gt; 요소의 &lt;/a&gt; &lt;code&gt;download&lt;/code&gt; 속성에 우선 순위를 둡니다 . 이전 Firefox 버전은 헤더의 우선 순위를 지정하고 콘텐츠를 인라인으로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="389872f22235d2e890d3e24f0e0fb6d81e0c8a59" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds) and Chromium at &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 minutes&lt;/a&gt; (600 seconds). Chromium also specifies a default value of 5 seconds.</source>
          <target state="translated">Firefox는 &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;이를 24 시간&lt;/a&gt; (86400 초)에, Chromium을 &lt;a href=&quot;https://cs.chromium.org/chromium/src/services/network/public/cpp/cors/preflight_result.cc?l=36&amp;amp;rcl=52002151773d8cd9ffc5f557cd7cc880fddcae3e&quot;&gt;10 분&lt;/a&gt; (600 초)에 제한합니다. Chromium은 또한 기본값 5 초를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="90fb1b1a36a9c036151eeced597d613144d0f291" translate="yes" xml:space="preserve">
          <source>Firefox &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;caps this at 24 hours&lt;/a&gt; (86400 seconds).</source>
          <target state="translated">Firefox는 &lt;a href=&quot;https://dxr.mozilla.org/mozilla-central/rev/7ae377917236b7e6111146aa9fb4c073c0efc7f4/netwerk/protocol/http/nsCORSListenerProxy.cpp#1131&quot;&gt;이를 24 시간&lt;/a&gt; (86400 초)으로 제한합니다.</target>
        </trans-unit>
        <trans-unit id="1444ac74d1094f6f34b49da3ee9966b7b93f1731" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools</source>
          <target state="translated">Firefox 개발자 도구</target>
        </trans-unit>
        <trans-unit id="f300fd41a795a419c45aee9c6cb726e738e71b7e" translate="yes" xml:space="preserve">
          <source>Firefox Developer Tools: using a source map</source>
          <target state="translated">Firefox 개발자 도구 : 소스 맵 사용</target>
        </trans-unit>
        <trans-unit id="e4b319de38dd3b5708092c79d821e3e2547bbfeb" translate="yes" xml:space="preserve">
          <source>Firefox OS</source>
          <target state="translated">Firefox OS</target>
        </trans-unit>
        <trans-unit id="08b98a32baa6ee15d09f718291f659a3f7d5a387" translate="yes" xml:space="preserve">
          <source>Firefox OS devices identify themselves without any operating system indication; for example: &quot;Mozilla/5.0 (Mobile; rv:15.0) Gecko/15.0 Firefox/15.0&quot;. The web is the platform.</source>
          <target state="translated">Firefox OS 장치는 운영 체제 표시없이 자신을 식별합니다. 예 : &quot;Mozilla / 5.0 (Mobile; rv : 15.0) Gecko / 15.0 Firefox / 15.0&quot;. 웹은 플랫폼입니다.</target>
        </trans-unit>
        <trans-unit id="096d24033e6a963360da3b94208e68f8d97b00a8" translate="yes" xml:space="preserve">
          <source>Firefox OS has a four-digit version number:</source>
          <target state="translated">Firefox OS에는 네 자리 버전 번호가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ee0b8d61fb018abae298ec4b7eb6bf2ea815cea8" translate="yes" xml:space="preserve">
          <source>Firefox OS version number</source>
          <target state="translated">Firefox OS 버전 번호</target>
        </trans-unit>
        <trans-unit id="0b43f7fedde8c737f31357ef6642b9b7dec844af" translate="yes" xml:space="preserve">
          <source>Firefox UA string</source>
          <target state="translated">Firefox UA 문자열</target>
        </trans-unit>
        <trans-unit id="cd5ecb0a55376afe3b1ad82fbe8b4cecc9e76924" translate="yes" xml:space="preserve">
          <source>Firefox Web Runtime</source>
          <target state="translated">Firefox 웹 런타임</target>
        </trans-unit>
        <trans-unit id="0c516be8bc16e485b9c5dea3cac5637b2be7f8c3" translate="yes" xml:space="preserve">
          <source>Firefox and Chrome&lt;strong&gt; disable pin validation&lt;/strong&gt; for pinned hosts whose validated certificate chain terminates at a &lt;strong&gt;user-defined trust anchor&lt;/strong&gt; (rather than a built-in trust anchor). This means that for users who imported custom root certificates all pinning violations are ignored.</source>
          <target state="translated">Firefox 및 Chrome 은 검증 된 인증서 체인 이 내장 &lt;strong&gt;된 신뢰 앵커가&lt;/strong&gt; 아닌 &lt;strong&gt;사용자 정의 신뢰 앵커&lt;/strong&gt; 에서 종료되는 고정 된 호스트에 대해 &lt;strong&gt;핀 유효성 검사&lt;/strong&gt; 를 &lt;strong&gt;비활성화&lt;/strong&gt; 합니다 . 즉, 사용자 지정 루트 인증서를 가져온 사용자의 경우 모든 고정 위반이 무시됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="f46b1448185527825780f84cfe778a2558ec052f" translate="yes" xml:space="preserve">
          <source>Firefox currently only supports the &lt;code&gt;Large-Allocation&lt;/code&gt; header in our 32-bit Windows builds, as memory fragmentation is not an issue in 64-bit builds. If you are running a non-win32 version of Firefox, this error will appear. This check can be disabled with the &quot;dom.largeAllocation.</source>
          <target state="translated">Firefox 는 메모리 조각화가 64 비트 빌드에서 문제가되지 않으므로 현재 32 비트 Windows 빌드에서 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 만 지원 합니다. Win32 이외의 Firefox 버전을 실행중인 경우이 오류가 나타납니다. 이 검사는 &quot;dom.largeAllocation으로 비활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fd814d6c03ca30a65e6eae11a110b64dbd4091ec" translate="yes" xml:space="preserve">
          <source>Firefox earlier than 3.6</source>
          <target state="translated">3.6 이전의 Firefox</target>
        </trans-unit>
        <trans-unit id="35e08ebaf6a034e084ac621e4a8de400a08ba9e7" translate="yes" xml:space="preserve">
          <source>Firefox for Android</source>
          <target state="translated">안드로이드 용 Firefox</target>
        </trans-unit>
        <trans-unit id="6b3b609703588318cf5eddb907cb036af5b8fa9f" translate="yes" xml:space="preserve">
          <source>Firefox for Echo Show</source>
          <target state="translated">에코 쇼용 Firefox</target>
        </trans-unit>
        <trans-unit id="70bde33b11b3ebf831139347906ee55c0954e773" translate="yes" xml:space="preserve">
          <source>Firefox for Fire TV</source>
          <target state="translated">Fire TV 용 Firefox</target>
        </trans-unit>
        <trans-unit id="aa1b6f07af81be5e73ca90848517f82656d9b533" translate="yes" xml:space="preserve">
          <source>Firefox for Maemo (Nokia N900)</source>
          <target state="translated">Maemo 용 Firefox (Nokia N900)</target>
        </trans-unit>
        <trans-unit id="d796cd118178bed42189a33b56788596ce709a40" translate="yes" xml:space="preserve">
          <source>Firefox for iOS</source>
          <target state="translated">iOS 용 Firefox</target>
        </trans-unit>
        <trans-unit id="4a1947cf48de07acf77d4542c741b3b264b1d589" translate="yes" xml:space="preserve">
          <source>Firefox for iOS user agent string</source>
          <target state="translated">iOS 용 Firefox 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="520f59d4c4564c36ce2dffd8248ed3f436481f50" translate="yes" xml:space="preserve">
          <source>Firefox for iOS uses the default Mobile Safari UA string, with an additional &lt;strong&gt;FxiOS/&amp;lt;version&amp;gt;&lt;/strong&gt; token, similar to how &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome for iOS identifies itself&lt;/a&gt;.</source>
          <target state="translated">iOS 용 Firefox는 iOS 용 &lt;a href=&quot;https://developer.chrome.com/multidevice/user-agent#chrome_for_ios_user_agent&quot;&gt;Chrome이 자체를 식별&lt;/a&gt; 하는 방식과 유사한 추가 &lt;strong&gt;FxiOS / &amp;lt;version&amp;gt;&lt;/strong&gt; 토큰 과 함께 기본 Mobile Safari UA 문자열을 사용 합니다 .</target>
        </trans-unit>
        <trans-unit id="57d4690e6cf1e25d65d0fd2cf1024daa1be89df4" translate="yes" xml:space="preserve">
          <source>Firefox has detected that the server is redirecting the request for this address in a way that will never complete.</source>
          <target state="translated">Firefox는 서버가 완료되지 않는 방식으로이 주소에 대한 요청을 리디렉션하는 것을 감지했습니다.</target>
        </trans-unit>
        <trans-unit id="97d9b72ae732fc5ec0d2b8c7b9205f083804989f" translate="yes" xml:space="preserve">
          <source>Firefox has moved to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;multiprocess architecture&lt;/a&gt;, and this architecture is required in order to support the &lt;code&gt;Large-Allocation&lt;/code&gt; header. Some &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;legacy Addons&lt;/a&gt; can prevent Firefox from using this new, faster, multiprocess architecture. If you have one of these Addons installed, then we will continue to use the old single process architecuture for compatibility, and cannot handle the &lt;code&gt;Large-Allocation&lt;/code&gt; header.</source>
          <target state="translated">Firefox는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Firefox/Multiprocess_Firefox&quot;&gt;다중 프로세스 아키텍처&lt;/a&gt; 로 이동 했으며이 아키텍처 는 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더 를 지원하기 위해 필요합니다 . 일부 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/SDK&quot;&gt;레거시 애드온&lt;/a&gt; 은 Firefox가이 새롭고 더 빠른 멀티 프로세스 아키텍처를 사용하지 못하게 할 수 있습니다. 이러한 애드온 중 하나를 설치 한 경우 호환성을 위해 이전 단일 프로세스 아키텍처를 계속 사용하므로 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더를 처리 할 수 ​​없습니다 .</target>
        </trans-unit>
        <trans-unit id="cea7ce89d775de0cacc4bf3ee3434d91b180561e" translate="yes" xml:space="preserve">
          <source>Firefox has not, and &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=528661&quot;&gt;will not implement &lt;code&gt;X-XSS-Protection&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Firefox는 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=528661&quot;&gt; &lt;code&gt;X-XSS-Protection&lt;/code&gt; &lt;/a&gt; 이 없으며 구현하지 않을 것입니다.</target>
        </trans-unit>
        <trans-unit id="6ce4010ab4d918ae6e0eb7de27062f406a172591" translate="yes" xml:space="preserve">
          <source>Firefox once used &lt;code&gt;ISO-8859-1&lt;/code&gt;, but changed to &lt;code&gt;utf-8&lt;/code&gt; for parity with other browsers and to avoid potential problems as described in &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;bug 1419658&lt;/a&gt;.</source>
          <target state="translated">Firefox는 한때 &lt;code&gt;ISO-8859-1&lt;/code&gt; 을 사용 했지만 다른 브라우저와의 패리티와 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1419658&quot;&gt;버그 1419658에&lt;/a&gt; 설명 된 잠재적 인 문제를 피하기 위해 &lt;code&gt;utf-8&lt;/code&gt; 로 변경되었습니다 .</target>
        </trans-unit>
        <trans-unit id="74fa353bc27c77608b28b6a494fb71634a8d1229" translate="yes" xml:space="preserve">
          <source>Firefox user agent string reference</source>
          <target state="translated">Firefox 사용자 에이전트 문자열 참조</target>
        </trans-unit>
        <trans-unit id="824138edb7e10e6cc870e036060b42fe43828628" translate="yes" xml:space="preserve">
          <source>Firefox's console displays messages in its console when requests fail due to CORS. Part of the error text is a &quot;reason&quot; message that provides added insight into what went wrong. The reason messages are listed below; click the message to open an article explaining the error in more detail and offering possible solutions.</source>
          <target state="translated">CORS로 인해 요청이 실패하면 Firefox 콘솔이 콘솔에 메시지를 표시합니다. 오류 텍스트의 일부는 무엇이 잘못되었는지에 대한 통찰력을 제공하는 &quot;이유&quot;메시지입니다. 이유 메시지는 다음과 같습니다. 오류를 자세히 설명하고 가능한 해결책을 제공하는 기사를 열려면 메시지를 클릭하십시오.</target>
        </trans-unit>
        <trans-unit id="7d1c6e60d05a2c5211575867279c806da9425465" translate="yes" xml:space="preserve">
          <source>Firefox, Chrome and Safari do not support multiple origins in the Access-Control-Allow-Origin header.</source>
          <target state="translated">Firefox, Chrome 및 Safari는 Access-Control-Allow-Origin 헤더에서 여러 출처를 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="be168c2fee1a2d9fa42cc62fef4298c4cbcefbf2" translate="yes" xml:space="preserve">
          <source>Firefox/xyz</source>
          <target state="translated">Firefox/xyz</target>
        </trans-unit>
        <trans-unit id="f614dfafdbd42e06d5c689e2cc52f2820578b824" translate="yes" xml:space="preserve">
          <source>Firefox: &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;bug 1309358&lt;/a&gt;</source>
          <target state="translated">Firefox : &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1309358&quot;&gt;버그 1309358&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1a0200dffc7bdc64d4a349f323b1653382469567" translate="yes" xml:space="preserve">
          <source>Fires a &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt;.</source>
          <target state="translated">발사 &lt;code&gt;SecurityPolicyViolationEvent&lt;/code&gt; 은 .</target>
        </trans-unit>
        <trans-unit id="b748324a443374f003fb0c40ffc43547df0d368f" translate="yes" xml:space="preserve">
          <source>First you need to extract the public key information from your certificate or key file and encode them using Base64.</source>
          <target state="translated">먼저 인증서 또는 키 파일에서 공개 키 정보를 추출하고 Base64를 사용하여 인코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="72a34e1cd654a785a78eeb2f1af6246aef47a923" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request that includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">첫째, 요청입니다. 실행 전 요청은 &lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 의 세 가지 실행 전 요청 헤더의 일부 조합을 포함 하는 &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="c56777de18c704b8472efc7f29607549036e406b" translate="yes" xml:space="preserve">
          <source>First, the request. The preflight request is an &lt;a href=&quot;../methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request which includes some combination of the three preflight request headers: &lt;a href=&quot;access-control-request-method&quot;&gt;&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;access-control-request-headers&quot;&gt;&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt;, such as:</source>
          <target state="translated">먼저 요청입니다. 프리 플라이트 요청은 다음 과 같은 세 가지 프리 플라이트 요청 헤더의 일부 조합 인 &lt;a href=&quot;access-control-request-method&quot;&gt; &lt;code&gt;Access-Control-Request-Method&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;access-control-request-headers&quot;&gt; &lt;code&gt;Access-Control-Request-Headers&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 을 포함 하는 &lt;a href=&quot;../methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="1856a70ba04296bbf62c2e423de0fbdcfb0f5adf" translate="yes" xml:space="preserve">
          <source>Flow of an HTTP session</source>
          <target state="translated">HTTP 세션의 흐름</target>
        </trans-unit>
        <trans-unit id="bcbad51a46a03dbd80a644d3f941e3c1172162b3" translate="yes" xml:space="preserve">
          <source>Focus Version (Rendering Engine)</source>
          <target state="translated">포커스 버전 (렌더링 엔진)</target>
        </trans-unit>
        <trans-unit id="56c6a4ca5cb7ee3279f46162d43efe44a37848d9" translate="yes" xml:space="preserve">
          <source>Focus for Android</source>
          <target state="translated">안드로이드에 대한 초점</target>
        </trans-unit>
        <trans-unit id="9c96a14d8cf5e47753d46702539d3958d06bb67a" translate="yes" xml:space="preserve">
          <source>Focus for iOS</source>
          <target state="translated">iOS 포커스</target>
        </trans-unit>
        <trans-unit id="aa5bdfcda9154f616d3599ff8019fe359c3f4231" translate="yes" xml:space="preserve">
          <source>Followed by a second connection and request to fetch the image (followed by a response to that request):</source>
          <target state="translated">두 번째 연결 다음에 이미지를 가져 오도록 요청합니다 (해당 요청에 대한 응답이 이어짐).</target>
        </trans-unit>
        <trans-unit id="453b3d513097bbb5dad0b729903f4324d053ad1f" translate="yes" xml:space="preserve">
          <source>Font/typeface data. Common examples include &lt;code&gt;font/woff&lt;/code&gt;, &lt;code&gt;font/ttf&lt;/code&gt;, and &lt;code&gt;font/otf&lt;/code&gt;.</source>
          <target state="translated">글꼴 / 서체 데이터. 일반적인 예로는 &lt;code&gt;font/woff&lt;/code&gt; , &lt;code&gt;font/ttf&lt;/code&gt; 및 &lt;code&gt;font/otf&lt;/code&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="ce1d332ceb92dcde1fcd283f80c52096a5c624f8" translate="yes" xml:space="preserve">
          <source>Footnote 1</source>
          <target state="translated">각주 1</target>
        </trans-unit>
        <trans-unit id="a2e8427dcb2cd9ff2779aa2b38c7e477133f780c" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, to update a cached entity that has an associated &lt;a href=&quot;etag&quot;&gt;&lt;code&gt;ETag&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 방법, 관련이있는 캐시 된 개체 업데이트 할 수 &lt;a href=&quot;etag&quot;&gt; &lt;code&gt;ETag&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a4b7f7de1f1cba719e4bebb16b0fc5cf663d900" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt; (Range Not Satisfiable) response is returned.</source>
          <target state="translated">들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 와 함께 사용 방법, &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더, 그것은 새로운 범위는 이전보다 동일한 자원에서 오는 요청을 보장 할 수 있습니다. 일치하지 않으면 &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; (Range Not Satisfiable) 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="523ad4bead51d0b08a4fff5dbbe8221c7a8666b5" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, used in combination with an &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header, it can guarantee that the new ranges requested comes from the same resource than the previous one. If it doesn't match, then a &lt;a href=&quot;../status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;(Range Not Satisfiable) response is returned.</source>
          <target state="translated">들어 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 와 함께 사용 방법, &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더, 그것은 새로운 범위는 이전보다 동일한 자원에서 오는 요청을 보장 할 수 있습니다. 일치하지 않으면 &lt;a href=&quot;../status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; (Range Not Satisfiable) 응답이 반환됩니다.</target>
        </trans-unit>
        <trans-unit id="01925d81b53df8220be1ab3b85de00880bc40ace" translate="yes" xml:space="preserve">
          <source>For &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; elements or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt; attributes&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 나 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; 속성&lt;/a&gt; , 소유자 문서의 참조 자 정책이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="65a5e026c5b9f4e6d8669a37e565175368c88cdf" translate="yes" xml:space="preserve">
          <source>For DAV properties, the name of the property is also the same as the
   name of the XML element that contains its value.  In the section
   below, the final line of each section gives the element type
   declaration using the format defined in [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  The &quot;Value&quot;
   field, where present, specifies further restrictions on the allowable
   contents of the XML element using BNF (i.e., to further restrict the
   values of a PCDATA element).

   A protected property is one that cannot be changed with a PROPPATCH
   request.  There may be other requests that would result in a change
   to a protected property (as when a LOCK request affects the value of
   DAV:lockdiscovery).  Note that a given property could be protected on
   one type of resource, but not protected on another type of resource.

   A computed property is one with a value defined in terms of a
   computation (based on the content and other properties of that
   resource, or even of some other resource).  A computed property is
   always a protected property.

   COPY and MOVE behavior refers to local COPY and MOVE operations.

   For properties defined based on HTTP GET response headers (DAV:get*),
   the header value could include LWS as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;.  Server implementors SHOULD strip LWS from these values before
   using as WebDAV property values.</source>
          <target state="translated">DAV 특성의 경우 특성 이름은 해당 값을 포함하는 XML 요소의 이름과 동일합니다. 아래 섹션에서 각 섹션의 마지막 줄은 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML에&lt;/a&gt; 정의 된 형식을 사용하여 요소 유형 선언을 제공합니다.]. &quot;값&quot;필드는 존재하는 경우 BNF를 사용하여 (즉, PCDATA 요소의 값을 추가로 제한하기 위해) XML 요소의 허용 가능한 컨텐츠에 대한 추가 제한 사항을 지정합니다. 보호 된 특성은 PROPPATCH 요청으로 변경할 수없는 특성입니다. LOCK 요청이 DAV : lockdiscovery의 값에 영향을주는 경우와 같이 보호 된 특성이 변경되는 다른 요청이있을 수 있습니다. 지정된 속성은 한 유형의 리소스에서는 보호 할 수 있지만 다른 유형의 리소스에서는 보호 할 수 없습니다. 계산 된 속성은 계산 측면에서 정의 된 값을 가진 속성입니다 (해당 리소스 또는 다른 리소스의 내용 및 기타 속성을 기반으로). 계산 된 속성은 항상 보호 된 속성입니다.COPY and MOVE 동작은 로컬 COPY 및 MOVE 작업을 나타냅니다. HTTP GET 응답 헤더 (DAV : get *)를 기반으로 정의 된 특성의 경우 헤더 값에는 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-4.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 서버 구현자는 WebDAV 속성 값으로 사용하기 전에 이러한 값에서 LWS를 제거해야합니다.</target>
        </trans-unit>
        <trans-unit id="7578507963f5f6a92a4ce0b4b4477e8db695266c" translate="yes" xml:space="preserve">
          <source>For Nginx, the command to set up this header is:</source>
          <target state="translated">Nginx의 경우이 헤더를 설정하는 명령은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="1714ef110b1269230d283611695b8af7bcd041c3" translate="yes" xml:space="preserve">
          <source>For an example of a custom 404 page, see &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN's 404 page&lt;/a&gt;.</source>
          <target state="translated">사용자 정의 404 페이지의 예는 &lt;a href=&quot;https://developer.mozilla.org/en-US/404&quot;&gt;MDN의 404 페이지를 참조하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1da755a1735ea720fcbdf190446a592e95aff7a8" translate="yes" xml:space="preserve">
          <source>For authoring to commence, a client needs to discover the
   capabilities and locations of the available Collections.  Service
   Documents are designed to support this discovery process.

   How Service Documents are discovered is not defined in this
   specification. 

   Service Documents are identified with the &quot;application/atomsvc+xml&quot;
   media type (see &lt;a href=&quot;#section-16.2&quot;&gt;Section 16.2&lt;/a&gt;).</source>
          <target state="translated">제작을 시작하려면 클라이언트가 사용 가능한 컬렉션의 기능과 위치를 검색해야합니다. 서비스 문서는이 발견 프로세스를 지원하도록 설계되었습니다. 서비스 문서를 검색하는 방법은이 사양에 정의되어 있지 않습니다. 서비스 문서는 &quot;application / atomsvc ​​+ xml&quot;매체 유형으로 식별됩니다 ( &lt;a href=&quot;#section-16.2&quot;&gt;16.2 절&lt;/a&gt; 참조 ).</target>
        </trans-unit>
        <trans-unit id="074190f3eb43757a18a5c3d3ad9b48a9217873dc" translate="yes" xml:space="preserve">
          <source>For clients that don't implement cookie prefixes, you cannot count on these additional assurances, and prefixed cookies will always be accepted.</source>
          <target state="translated">쿠키 접두사를 구현하지 않는 클라이언트의 경우 이러한 추가 보증을 기대할 수 없으며 접두사 쿠키가 항상 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="5dc6e3c719ad40719899f3731172d36e94077ff2" translate="yes" xml:space="preserve">
          <source>For compression, end-to-end compression is where the largest performance improvements of Web sites reside. End-to-end compression refers to a compression of the body of a message that is done by the server and will last unchanged until it reaches the client. Whatever the intermediate nodes are, they leave the body untouched.</source>
          <target state="translated">압축의 경우 엔드-투-엔드 압축은 웹 사이트의 성능이 가장 크게 향상되는 곳입니다. 엔드-투-엔드 압축은 서버에서 수행 한 메시지 본문의 압축을 말하며 클라이언트에 도달 할 때까지 변경되지 않습니다. 중간 노드가 무엇이든 그들은 몸을 그대로 둡니다.</target>
        </trans-unit>
        <trans-unit id="f0f988728409b019db831b62218300a55ac3d394" translate="yes" xml:space="preserve">
          <source>For convenience, this protocol can be referred to as the &quot;Atom
   Protocol&quot; or &quot;AtomPub&quot;.  The following terminology is used by this
   specification:

   o  URI - A Uniform Resource Identifier as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;].  In
      this specification, the phrase &quot;the URI of a document&quot; is
      shorthand for &quot;a URI which, when dereferenced, is expected to
      produce that document as a representation&quot;.

   o  IRI - An Internationalized Resource Identifier as defined in
      [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;].  Before an IRI found in a document is used by HTTP, the
      IRI is first converted to a URI.  See &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;.

   o  Resource - A network-accessible data object or service identified
      by an IRI, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].  See [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;] for further
      discussion on Resources.

   o  relation (or &quot;relation of&quot;) - Refers to the &quot;rel&quot; attribute value
      of an atom:link element.

   o  Representation - An entity included with a request or response as
      defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   o  Collection - A Resource that contains a set of Member Resources.
      Collections are represented as Atom Feeds.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt;. 

   o  Member (or Member Resource) - A Resource whose IRI is listed in a
      Collection by an atom:link element with a relation of &quot;edit&quot; or
      &quot;edit-media&quot;.  See &lt;a href=&quot;#section-9.1&quot;&gt;Section 9.1&lt;/a&gt;.  The protocol defines two kinds of
      Members:

      *  Entry Resource - Members of a Collection that are represented
         as Atom Entry Documents, as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt;].

      *  Media Resource - Members of a Collection that have
         representations other than Atom Entry Documents.

   o  Media Link Entry - An Entry Resource that contains metadata about
      a Media Resource.  See &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;.

   o  Workspace - A named group of Collections.  See &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt;.

   o  Service Document - A document that describes the location and
      capabilities of one or more Collections, grouped into Workspaces.
      See &lt;a href=&quot;#section-8&quot;&gt;Section 8&lt;/a&gt;.

   o  Category Document - A document that describes the categories
      allowed in a Collection.  See &lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;.</source>
          <target state="translated">편의상이 프로토콜을 &quot;Atom 프로토콜&quot;또는 &quot;AtomPub&quot;라고합니다. 이 사양에서는 다음 용어가 사용됩니다. o URI-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]에 정의 된 URI (Uniform Resource Identifier ). 본 명세서에서, &quot;문서의 URI&quot;라는 어구는 &quot;역 참조 될 때 해당 문서를 표현으로서 생성 할 것으로 예상되는 URI&quot;의 약칭이다. o IRI-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ]에 정의 된 국제화 된 자원 식별자 . 문서에서 찾은 IRI를 HTTP에서 사용하기 전에 IRI가 먼저 URI로 변환됩니다. &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1을&lt;/a&gt; 참조하십시오 . o 자원-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 정의 된 IRI로 식별되는 네트워크 액세스 가능 데이터 개체 또는 서비스 .보다 [&lt;a href=&quot;#ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ]에 대한 자세한 내용은 참고 자료를 참조하십시오. o relation (또는 &quot;relation of&quot;)-atom : link 요소의 &quot;rel&quot;속성 값을 나타냅니다. o 표현-[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ]에 정의 된 요청 또는 응답에 포함 된 엔티티 . o 콜렉션-회원 자원 세트를 포함하는 자원. 컬렉션은 Atom Feed로 표시됩니다. &lt;a href=&quot;#section-9&quot;&gt;섹션 9를&lt;/a&gt; 참조하십시오 . o 구성원 (또는 구성원 자원)- &quot;edit&quot;또는 &quot;edit-media&quot;의 관계를 가진 atom : link 요소에 의해 IRI가 콜렉션에 나열되는 자원. &lt;a href=&quot;#section-9.1&quot;&gt;섹션 9.1&lt;/a&gt; 참조 . 이 프로토콜은 두 가지 종류의 멤버를 정의합니다. * Entry Resource-Atom Entry Documents로 표시되는 Collection 멤버,[에 정의 된대로&lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC4287&lt;/a&gt; ]. * 미디어 리소스-Atom Entry Documents 이외의 표현이있는 컬렉션 멤버 o 미디어 링크 항목-미디어 리소스에 대한 메타 데이터가 포함 된 항목 리소스입니다. &lt;a href=&quot;#section-9.6&quot;&gt;섹션 9.6&lt;/a&gt; 참조 . o 작업 공간-명명 된 컬렉션 그룹. &lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; 참조 . o 서비스 문서-하나 이상의 컬렉션의 위치와 기능을 작업 공간으로 그룹화 한 문서. &lt;a href=&quot;#section-8&quot;&gt;섹션 8을&lt;/a&gt; 참조하십시오 . o 카테고리 문서-컬렉션에서 허용되는 카테고리를 설명하는 문서. &lt;a href=&quot;#section-7&quot;&gt;섹션 7을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="eef31d3a1350a01572c86bb4dfa3d00e0c975e26" translate="yes" xml:space="preserve">
          <source>For each policy-controlled feature, the browser maintains a list of origins for which the feature is enabled, known as an allowlist. If you do not specify a policy for a feature, then a default allowlist will be used. The default allowlist is specific to each feature.</source>
          <target state="translated">각 정책 제어 기능에 대해 브라우저는 기능이 활성화 된 출처 목록 (허용 목록)을 유지 관리합니다. 기능에 대한 정책을 지정하지 않으면 기본 허용 목록이 사용됩니다. 기본 허용 목록은 각 기능에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="bbfd900d40adcb99301092c21f8010e24f933f46" translate="yes" xml:space="preserve">
          <source>For example when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">예를 들어 MDN을 편집 할 때 현재 위키 컨텐츠가 해시 되어 응답에 &lt;code&gt;Etag&lt;/code&gt; 에 추가됩니다 .</target>
        </trans-unit>
        <trans-unit id="9445e49e152cffd5d9a04a8f80bbd49732b55bc8" translate="yes" xml:space="preserve">
          <source>For example, &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;a script on Browserleaks&lt;/a&gt; highlights what Firefox reveals when queried by a simple script running on the site (you can find the code in &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt;).</source>
          <target state="translated">예를 들어 &lt;a href=&quot;https://www.browserleaks.com/firefox&quot;&gt;Browserleaks의 스크립트&lt;/a&gt; 는 사이트에서 실행되는 간단한 스크립트로 쿼리 할 때 Firefox에서 표시하는 내용을 강조 표시합니다 ( &lt;a href=&quot;https://browserleaks.com/firefox#more&quot;&gt;https://browserleaks.com/firefox#more&lt;/a&gt; 에서 코드를 찾을 수 있음 ).</target>
        </trans-unit>
        <trans-unit id="8282891590c0b08790018d81b4f472f2cf7db144" translate="yes" xml:space="preserve">
          <source>For example, a document at &lt;code&gt;https://example.com/page.html&lt;/code&gt; will send the referrer &lt;code&gt;https://example.com/&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;https://example.com/page.html&lt;/code&gt; 의 문서 는 리퍼러 &lt;code&gt;https://example.com/&lt;/code&gt; 을 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="64b899bc979c38aad573a87de3d6fa69123c484f" translate="yes" xml:space="preserve">
          <source>For example, allow all browsing contexts within this iframe to use fullscreen:</source>
          <target state="translated">예를 들어,이 iframe 내의 모든 탐색 컨텍스트가 전체 화면을 사용하도록 허용하십시오.</target>
        </trans-unit>
        <trans-unit id="eac94e3ce15d79355451ea902d576dd478ad2b17" translate="yes" xml:space="preserve">
          <source>For example, by default all of the following result in a separate request to the origin and a separate cache entry: &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip,deflate&lt;/code&gt;, &lt;code&gt;Accept-Encoding: gzip&lt;/code&gt;. This is true even though the origin server will probably respond with &amp;mdash; and store &amp;mdash; the same resource for all requests (a gzip)!</source>
          <target state="translated">예를 들어, 기본적으로 다음의 모든 결과는 오리진에 대한 별도의 요청과 별도의 캐시 항목이됩니다. &lt;code&gt;Accept-Encoding: gzip,deflate,sdch&lt;/code&gt; , &lt;code&gt;Accept-Encoding: gzip,deflate&lt;/code&gt; , &lt;code&gt;Accept-Encoding: gzip&lt;/code&gt; . 이는 원 서버가 모든 요청에 ​​대해 동일한 리소스 (gzip)로 응답하고 저장하더라도 마찬가지입니다!</target>
        </trans-unit>
        <trans-unit id="5100e86095301001726a9dd07582fc20d58ee08d" translate="yes" xml:space="preserve">
          <source>For example, for any MIME type whose main type is &lt;code&gt;text&lt;/code&gt;, the optional &lt;code&gt;charset&lt;/code&gt; parameter can be used to specify the character set used for the characters in the data. If no &lt;code&gt;charset&lt;/code&gt; is specified, the default is &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ASCII&quot;&gt;ASCII&lt;/a&gt; (&lt;code&gt;US-ASCII&lt;/code&gt;) unless overridden by the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent's&lt;/a&gt; settings. To specify a UTF-8 text file, the MIME type &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; is used.</source>
          <target state="translated">예를 들어, 기본 유형이 &lt;code&gt;text&lt;/code&gt; 인 MIME 유형의 경우 선택적 &lt;code&gt;charset&lt;/code&gt; 매개 변수를 사용하여 데이터의 문자에 사용되는 문자 세트를 지정할 수 있습니다. 어떤 경우 &lt;code&gt;charset&lt;/code&gt; 지정되지 않은, 기본값은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/ASCII&quot;&gt;ASCII&lt;/a&gt; ( &lt;code&gt;US-ASCII&lt;/code&gt; 에 의해 오버라이드 (override)하지 않는 한) &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트의&lt;/a&gt; 설정. UTF-8 텍스트 파일을 지정하려면 MIME 유형 &lt;code&gt;text/plain;charset=UTF-8&lt;/code&gt; 이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="08b715bba658a875ffba997c7f848a3f6b1c1f7c" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers).</source>
          <target state="translated">예를 들어 &quot; &lt;code&gt;Content-Language: de-DE&lt;/code&gt; &quot;가 설정되어 있으면 해당 문서는 독일어 사용자를위한 것입니다 (단, 문서가 독일어로 작성된다는 의미는 아닙니다). 독일어 사용자를위한 언어 과정의 일부로 영어).</target>
        </trans-unit>
        <trans-unit id="7c8d24654bcc03695c4c0562fb4fd4f65c41f354" translate="yes" xml:space="preserve">
          <source>For example, if &quot;&lt;code&gt;Content-Language: de-DE&lt;/code&gt;&quot; is set, it says that the document is intended for German language speakers (however, it doesn't indicate the document is written in German. For example, it might be written in English as part of a language course for German speakers. If you want to indicate which language the document is written in, use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt;&lt;code&gt;lang&lt;/code&gt; attribute&lt;/a&gt; instead).</source>
          <target state="translated">예를 들어 &quot; &lt;code&gt;Content-Language: de-DE&lt;/code&gt; &quot;가 설정된 경우 문서가 독일어 사용자를 대상으로한다고 표시되지만 문서가 독일어로 작성되었음을 나타내는 것은 아닙니다. 예를 들어 다음과 같이 작성 될 수 있습니다. 독일어 사용자를위한 언어 과정의 일부인 영어. 문서가 어떤 언어로 작성되었는지 표시하려면 대신 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang&quot;&gt; &lt;code&gt;lang&lt;/code&gt; 속성을&lt;/a&gt; 사용하세요 .)</target>
        </trans-unit>
        <trans-unit id="931c15cbf1cb0d096c2f7f3977e96a703c6efded" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are available on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Domain=mozilla.org&lt;/code&gt; 가 설정되면 &lt;code&gt;developer.mozilla.org&lt;/code&gt; 와 같은 하위 도메인에서 쿠키를 사용할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="6412826a466b2db302aa194f4e3daf55e5d61efd" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Domain=mozilla.org&lt;/code&gt; is set, then cookies are included on subdomains like &lt;code&gt;developer.mozilla.org&lt;/code&gt;.</source>
          <target state="translated">예를 들어 &lt;code&gt;Domain=mozilla.org&lt;/code&gt; 가 설정되면 쿠키는 &lt;code&gt;developer.mozilla.org&lt;/code&gt; 와 같은 하위 도메인에 포함됩니다 .</target>
        </trans-unit>
        <trans-unit id="f88d60c9d2f02ed6a1a1bf95ce9b557bca2dbed6" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths match:</source>
          <target state="translated">예를 들어 &lt;code&gt;Path=/docs&lt;/code&gt; 가 설정된 경우 다음 경로가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="8c0625b9fc57344582bbde2ab4696157ad3f42eb" translate="yes" xml:space="preserve">
          <source>For example, if &lt;code&gt;Path=/docs&lt;/code&gt; is set, these paths will match:</source>
          <target state="translated">예를 들어, &lt;code&gt;Path=/docs&lt;/code&gt; 를 설정하면 다음 경로가 일치합니다.</target>
        </trans-unit>
        <trans-unit id="fa9700b85e0e01538fcca2eb77f677f69026288f" translate="yes" xml:space="preserve">
          <source>For example, if the page &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; were requested, and the HTTP response is &quot;301 Moved Permanently&quot;, &quot;307 Temporary Redirect&quot;, or &quot;308 Permanent Redirect&quot; with a &lt;code&gt;Location&lt;/code&gt; of &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt;, the CORS request will fail in this manner.</source>
          <target state="translated">예를 들어, &lt;code&gt;https://service.tld/fetchdata&lt;/code&gt; 페이지 가 요청되었고 HTTP 응답이 &lt;code&gt;https://anotherservice.net/getdata&lt;/code&gt; &lt;code&gt;Location&lt;/code&gt; 으로 &quot;301 Permanentlyly Permanently&quot;, &quot;307 Temporary Redirect&quot;또는 &quot;308 Permanent Redirect&quot; 인 경우 .net / getdata , CORS 요청은이 방식으로 실패합니다.</target>
        </trans-unit>
        <trans-unit id="7b87738a4c88c7a7b6a1a09e51a26bf1a734d5d4" translate="yes" xml:space="preserve">
          <source>For example, if the response includes:</source>
          <target state="translated">예를 들어 응답에 다음이 포함 된 경우</target>
        </trans-unit>
        <trans-unit id="66e0a70fb691c18fbdd0bd050b60e272a1fe413f" translate="yes" xml:space="preserve">
          <source>For example, in Apache, add a line such as the following to the server's configuration (within the appropriate &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; section). The configuration is typically found in a &lt;code&gt;.conf&lt;/code&gt; file (&lt;code&gt;httpd.conf&lt;/code&gt; and &lt;code&gt;apache.conf&lt;/code&gt; are common names for these), or in an &lt;code&gt;.htaccess&lt;/code&gt; file.</source>
          <target state="translated">예를 들어, Apache에서 다음과 같은 행을 서버 구성에 추가하십시오 (적절한 &lt;code&gt;&amp;lt;Directory&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;Location&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;Files&amp;gt;&lt;/code&gt; 또는 &lt;code&gt;&amp;lt;VirtualHost&amp;gt;&lt;/code&gt; 섹션 내). 구성은 일반적으로 &lt;code&gt;.conf&lt;/code&gt; 파일 ( &lt;code&gt;httpd.conf&lt;/code&gt; 및 &lt;code&gt;apache.conf&lt;/code&gt; 는 일반적인 이름 임) 또는 &lt;code&gt;.htaccess&lt;/code&gt; 파일에 있습니다.</target>
        </trans-unit>
        <trans-unit id="619f3c064cc0ce3bc00c710809c1ce33e001a212" translate="yes" xml:space="preserve">
          <source>For example, sending the result of a form:</source>
          <target state="translated">예를 들어, 양식 결과를 보내려면 :</target>
        </trans-unit>
        <trans-unit id="142fdc15f7a89b9c24c2befb228055d091883a52" translate="yes" xml:space="preserve">
          <source>For example, suppose web content at &lt;code&gt;https://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;https://bar.other&lt;/code&gt;. Code of this sort might be used in JavaScript deployed on &lt;code&gt;foo.example&lt;/code&gt;:</source>
          <target state="translated">예를 들어,에서 가정하자 웹 콘텐츠 &lt;code&gt;https://foo.example&lt;/code&gt; 소원 도메인에 콘텐츠를 호출 할 &lt;code&gt;https://bar.other&lt;/code&gt; . 이러한 종류의 코드는 &lt;code&gt;foo.example&lt;/code&gt; 에 배포 된 JavaScript에서 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b184b5ed58eb6819039876c32250bc43b4bad555" translate="yes" xml:space="preserve">
          <source>For example, suppose web content on domain &lt;code&gt;http://foo.example&lt;/code&gt; wishes to invoke content on domain &lt;code&gt;http://bar.other&lt;/code&gt;. Code of this sort might be used within JavaScript deployed on foo.example:</source>
          <target state="translated">예를 들어, 도메인 &lt;code&gt;http://foo.example&lt;/code&gt; 의 웹 컨텐츠가 http : //bar.other 도메인의 컨텐츠를 호출하려고 한다고 가정 &lt;code&gt;http://bar.other&lt;/code&gt; . 이러한 종류의 코드는 foo.example에 배포 된 JavaScript 내에서 사용될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ac8d0edbbe6f6a992074ea6f9eb0145ef93102b7" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; to tunnel the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;Proxy server&lt;/a&gt; continues to proxy the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; stream to and from the client.</source>
          <target state="translated">예를 들어 &lt;code&gt;CONNECT&lt;/code&gt; 메서드를 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; ) 을 사용하는 웹 사이트에 액세스 할 수 있습니다 . 클라이언트는 HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시 서버&lt;/a&gt; 에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; 연결을 원하는 대상 으로 터널링 하도록 요청 합니다. 그런 다음 서버는 클라이언트를 대신하여 연결을 계속합니다. 서버가 연결을 설정하면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시 서버&lt;/a&gt; 는 계속해서 클라이언트와 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Transmission_Control_Protocol_(TCP)&quot;&gt;TCP&lt;/a&gt; 스트림을 프록시합니다 .</target>
        </trans-unit>
        <trans-unit id="d20e4a9531f0f953723ad2bce29ba67c92820b20" translate="yes" xml:space="preserve">
          <source>For example, the &lt;code&gt;CONNECT&lt;/code&gt; method can be used to access websites that use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt;). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</source>
          <target state="translated">예를 들어, &lt;code&gt;CONNECT&lt;/code&gt; 메소드를 사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SSL&quot;&gt;SSL&lt;/a&gt; ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTTPS&quot;&gt;HTTPS&lt;/a&gt; ) 을 사용하는 웹 사이트에 액세스 할 수 있습니다 . 클라이언트는 HTTP 프록시 서버에 TCP 연결을 원하는 대상으로 터널링하도록 요청합니다. 그런 다음 서버는 클라이언트 대신 연결을 진행합니다. 서버가 연결을 설정하면 프록시 서버는 클라이언트와의 TCP 스트림을 계속 프록시합니다.</target>
        </trans-unit>
        <trans-unit id="71916a917e381d9f4baa72eb7d0f481b27298684" translate="yes" xml:space="preserve">
          <source>For example, the following are equivalent:</source>
          <target state="translated">예를 들어 다음은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="0a5e19a07f0f940d54dbc5e573ed269580925a99" translate="yes" xml:space="preserve">
          <source>For example, the following:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e32905633351c047f12f27629c2b7dbcbd3258eb" translate="yes" xml:space="preserve">
          <source>For example, the server may reject a request if its &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; is too large.</source>
          <target state="translated">예를 들어, &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 가 너무 큰 경우 서버는 요청을 거부 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d63752de4fee204887b96a1631e06acc76c5193f" translate="yes" xml:space="preserve">
          <source>For example, this blocks the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; from using the camera and microphone:</source>
          <target state="translated">예를 들어 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 이 카메라와 마이크를 사용하지 못하도록 차단합니다 .</target>
        </trans-unit>
        <trans-unit id="667503768ab9f00b3c857611676b705bf222dc50" translate="yes" xml:space="preserve">
          <source>For example, to allow a site at https://amazing.site to access the resource using CORS, the header should be:</source>
          <target state="translated">예를 들어 https://amazing.site의 사이트가 CORS를 사용하여 리소스에 액세스 할 수있게하려면 헤더는 다음과 같아야합니다.</target>
        </trans-unit>
        <trans-unit id="dc1f722176891e42941f464101332b2ba20f6189" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;http://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">예를 들어, 출처 &lt;code&gt;http://mozilla.org&lt;/code&gt; 의 코드 가 리소스에 액세스 할 수 있도록하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="74f296365850776cc0a36afe6f2ae5336b6c5ffa" translate="yes" xml:space="preserve">
          <source>For example, to allow code from the origin &lt;code&gt;https://mozilla.org&lt;/code&gt; to access the resource, you can specify:</source>
          <target state="translated">예를 들어 원본 &lt;code&gt;https://mozilla.org&lt;/code&gt; 의 코드 가 리소스에 액세스하도록 허용하려면 다음을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8c8dcd604f2bec51e5cc439af7d8b146ce60c0ce" translate="yes" xml:space="preserve">
          <source>For example, to block all content from using the Geolocation API across your site:</source>
          <target state="translated">예를 들어 모든 콘텐츠가 사이트에서 Geolocation API를 사용하지 못하도록 차단하려면 다음을 수행하십시오.</target>
        </trans-unit>
        <trans-unit id="b10aebfe3ed1f1d241d8fb042922d4cfda18c68c" translate="yes" xml:space="preserve">
          <source>For example, when editing MDN, the current wiki content is hashed and put into an &lt;code&gt;Etag&lt;/code&gt; in the response:</source>
          <target state="translated">예를 들어 MDN을 편집 할 때 현재 위키 콘텐츠가 해시되고 응답 의 &lt;code&gt;Etag&lt;/code&gt; 에 삽입됩니다 .</target>
        </trans-unit>
        <trans-unit id="4c2c26aca152b85331257eaf1e9e80e1fb0d82dc" translate="yes" xml:space="preserve">
          <source>For example, your company was renamed, but you want existing links or bookmarks to still find you under the new name.</source>
          <target state="translated">예를 들어, 회사 이름이 변경되었지만 기존 링크 나 책갈피가 새 이름으로 계속 사용자를 찾을 수 있도록하려는 경우입니다.</target>
        </trans-unit>
        <trans-unit id="059c3e8cce263b2945a18ac90b2637e10a8026b1" translate="yes" xml:space="preserve">
          <source>For example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="de2cc7afb113653239fadefd58531368ab6e0fde" translate="yes" xml:space="preserve">
          <source>For historical reasons, the &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME Sniffing Standard&lt;/a&gt; (the definition of how browsers should interpret media types and figure out what to do with content that doesn't have a valid one) allows JavaScript to be served using any MIME type that essentially matches any of the following:</source>
          <target state="translated">역사적 이유로 &lt;a href=&quot;https://mimesniff.spec.whatwg.org/&quot;&gt;MIME 스니핑 표준&lt;/a&gt; (브라우저가 미디어 유형을 해석하고 유효한 콘텐츠가없는 콘텐츠로 무엇을해야하는지 파악하는 방법에 대한 정의)은 기본적으로 다음과 같은 모든 MIME 유형을 사용하여 JavaScript를 제공 할 수 있도록합니다 수행원:</target>
        </trans-unit>
        <trans-unit id="4cc7ca2973a124b54e9384bba7dd4138b39eb2ca" translate="yes" xml:space="preserve">
          <source>For images, &lt;code&gt;gif&lt;/code&gt; or &lt;code&gt;png&lt;/code&gt; are using loss-less compression.</source>
          <target state="translated">이미지의 경우 &lt;code&gt;gif&lt;/code&gt; 또는 &lt;code&gt;png&lt;/code&gt; 는 무손실 압축을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f96d0e055aab7967e098e229f35a70f7d0cf4499" translate="yes" xml:space="preserve">
          <source>For inline styles or styles created from APIs like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;HTMLElement.style&lt;/code&gt;&lt;/a&gt;, the owner document's referrer policy is used.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;HTMLElement.style&lt;/code&gt; &lt;/a&gt; 과 같은 API에서 생성 된 인라인 스타일 또는 스타일의 경우 소유자 문서의 리퍼러 정책이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="84bf50840f620c842f8d504aeebea80f2ae78a0a" translate="yes" xml:space="preserve">
          <source>For locking mechanisms, it is the opposite: Web developers need to issue a request with the proper headers, while webmasters can mostly rely on the application to carry out the checks for them.</source>
          <target state="translated">잠금 메커니즘의 경우에는 반대입니다. 웹 개발자는 적절한 헤더를 사용하여 요청을 발행해야하지만 웹 마스터는 대부분이를 확인하기 위해 애플리케이션에 의존 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="05bc2f18a1040cbebb023b0b22da7d3057050814" translate="yes" xml:space="preserve">
          <source>For more details on Firefox and Gecko based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox itself is broken down into four components:</source>
          <target state="translated">Firefox 및 Gecko 기반 사용자 에이전트 문자열에 대한 자세한 내용은 &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox 사용자 에이전트 문자열 참조를 참조하십시오&lt;/a&gt; . Firefox 자체의 UA 문자열은 다음과 같은 네 가지 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="1512d2a0f3572c16865118ba125042228226dfbe" translate="yes" xml:space="preserve">
          <source>For more details on autoplay and autoplay blocking, see the article &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide&quot;&gt;Autoplay guide for media and Web Audio APIs&lt;/a&gt;.</source>
          <target state="translated">자동 재생 및 자동 재생 차단에 대한 자세한 내용 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Autoplay_guide&quot;&gt;은 미디어 및 웹 오디오 API에 대한 자동 재생 가이드&lt;/a&gt; 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="d7d24847af6c0b28f664c1b1ecd25eca36f5dc16" translate="yes" xml:space="preserve">
          <source>For more details see &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;Using Feature Policy&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;feature_policy/using_feature_policy&quot;&gt;기능 정책 사용을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6f2fd29856862ed0ab79e6861cc4858f4155a7dc" translate="yes" xml:space="preserve">
          <source>For more details, see also the &lt;a href=&quot;#Freshness&quot;&gt;Freshness&lt;/a&gt; section below.</source>
          <target state="translated">자세한 내용은 아래 의 &lt;a href=&quot;#Freshness&quot;&gt;신선도&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="5761c54fb5552b444dde1792f6afdb1a5c918baa" translate="yes" xml:space="preserve">
          <source>For more information about cookie prefixes and the current state of browser support, see the &lt;a href=&quot;headers/set-cookie#Cookie_prefixes&quot;&gt;Prefixes section of the Set-Cookie reference article&lt;/a&gt;.</source>
          <target state="translated">쿠키 접두사 및 현재 브라우저 지원 상태에 대한 자세한 내용은 &lt;a href=&quot;headers/set-cookie#Cookie_prefixes&quot;&gt;Set-Cookie 참조 문서&lt;/a&gt; 의 접두사 섹션을 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="72a6b38e5e421526b3d5933f3b867e718bd90436" translate="yes" xml:space="preserve">
          <source>For more information, see also this article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../csp&quot;&gt;콘텐츠 보안 정책 (CSP)&lt;/a&gt; 에 대한이 문서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="07a2c7640b2fa8de34fac3055d8b39541b74752f" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../cookies&quot;&gt;guide on HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;../cookies&quot;&gt;은 HTTP 쿠키 가이드를&lt;/a&gt; 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="c3aa6b680bc6518edc5c36b2eb482864b073f5d2" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP 공개 키 고정&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="f6388d0122d4c6699e1cf73b26f4fab54e1e4ece" translate="yes" xml:space="preserve">
          <source>For more information, see the &lt;a href=&quot;public-key-pins&quot;&gt;&lt;code&gt;Public-Key-Pins&lt;/code&gt;&lt;/a&gt; header reference page and the &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP Public Key Pinning&lt;/a&gt; article.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;public-key-pins&quot;&gt; &lt;code&gt;Public-Key-Pins&lt;/code&gt; &lt;/a&gt; 헤더 참조 페이지 및 &lt;a href=&quot;../public_key_pinning&quot;&gt;HTTP 공개 키 고정&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16d858e940de2d5add12c93eacce99796fbd8dc3" translate="yes" xml:space="preserve">
          <source>For more information, see the guide on &lt;a href=&quot;../cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../cookies&quot;&gt;HTTP 쿠키&lt;/a&gt; 안내서를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="6025b5f65ce2bedee9e205665e9c4e24e2e5b2f7" translate="yes" xml:space="preserve">
          <source>For more information, see the introductory article on &lt;a href=&quot;../csp&quot;&gt;Content Security Policy (CSP)&lt;/a&gt;.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../csp&quot;&gt;CSP (콘텐츠 보안 정책)&lt;/a&gt; 에 대한 소개 문서를 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="abf003bb7d49f08a37fe6d4505f868da1702a5d5" translate="yes" xml:space="preserve">
          <source>For more information, see the main &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;Feature Policy&lt;/a&gt; article.</source>
          <target state="translated">자세한 내용은 주요 &lt;a href=&quot;https://developer.mozilla.org/docs/Web/HTTP/Feature_Policy&quot;&gt;기능 정책&lt;/a&gt; 기사를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="0e6566bd07adb3ff65425532a199412494bb4520" translate="yes" xml:space="preserve">
          <source>For more on Firefox- and Gecko-based user agent strings, see the &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox user agent string reference&lt;/a&gt;. The UA string of Firefox is broken down into 4 components:</source>
          <target state="translated">Firefox 및 Gecko 기반 사용자 에이전트 문자열에 대한 자세한 내용은 &lt;a href=&quot;user-agent/firefox&quot;&gt;Firefox 사용자 에이전트 문자열 참조를 참조&lt;/a&gt; 하세요. Firefox의 UA 문자열은 4 개의 구성 요소로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="2c13a01882beedd60ef040f694851d73933cf613" translate="yes" xml:space="preserve">
          <source>For more prevention tips, see the &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF prevention cheat sheet&lt;/a&gt;.</source>
          <target state="translated">자세한 예방 정보는 &lt;a href=&quot;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)_Prevention_Cheat_Sheet&quot;&gt;OWASP CSRF 예방 치트 시트를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b991665d6c852df1848b14e1c2237629d3e471a4" translate="yes" xml:space="preserve">
          <source>For more, see &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;this Wikipedia section&lt;/a&gt; and consult state laws for the latest and most accurate information.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_cookie#EU_cookie_directive&quot;&gt;이 Wikipedia 섹션&lt;/a&gt; 을 참조하고 최신의 가장 정확한 정보는 주법을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="16bc316a5e9428e01ce42d164953682ad4eeadaf" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often the header boundary is prepended by two dashes in the body and the final boundary also have a two dashes appended to it.</source>
          <target state="translated">여러 부분으로 구성된 엔터티의 경우 &lt;code&gt;boundary&lt;/code&gt; 지시문이 필요합니다.이 지침은 전자 메일 게이트웨이를 통해 매우 강력하고 공백으로 끝나지 않는 것으로 알려진 일련의 문자에서 1 ~ 70 자로 구성됩니다. 메시지의 여러 부분의 경계를 캡슐화하는 데 사용됩니다. 종종 헤더 경계에는 본문에 두 개의 대시가 붙고 마지막 경계에는 두 개의 대시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="7c3aed89e6dab97831be498c22ad6502ef3a5cd6" translate="yes" xml:space="preserve">
          <source>For multipart entities the &lt;code&gt;boundary&lt;/code&gt; directive is required, which consists of 1 to 70 characters from a set of characters known to be very robust through email gateways, and not ending with white space. It is used to encapsulate the boundaries of the multiple parts of the message. Often, the header boundary is prepended with two dashes and the final boundary has two dashes appended at the end.</source>
          <target state="translated">다중 부분 엔터티의 경우 &lt;code&gt;boundary&lt;/code&gt; 지시문이 필요합니다. 이는 전자 메일 게이트웨이를 통해 매우 강력한 것으로 알려진 문자 집합의 1 ~ 70 자로 구성되며 공백으로 끝나지 않습니다. 메시지의 여러 부분의 경계를 캡슐화하는 데 사용됩니다. 종종 머리글 경계 앞에 두 개의 대시가 추가되고 최종 경계에는 끝에 두 개의 대시가 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="093b1094cde6e7f4f4d8f8b971af7a8990963019" translate="yes" xml:space="preserve">
          <source>For new content, you can start developing with a policy that disables all the features. This approach ensures that none of the functionality is introduced. When applying a policy to existing content, testing is likely required to verify it continues to work as expected. This is especially important for embedded or third-party content that you do not control.</source>
          <target state="translated">새로운 컨텐츠의 경우 모든 기능을 비활성화하는 정책으로 개발을 시작할 수 있습니다. 이 접근 방식은 어떤 기능도 도입되지 않도록합니다. 기존 컨텐츠에 정책을 적용 할 때 예상대로 계속 작동하는지 테스트해야합니다. 제어하지 않는 내장 또는 타사 컨텐츠에 특히 중요합니다.</target>
        </trans-unit>
        <trans-unit id="2f39ad9de038e309432fa2abc7e02992cadbd96a" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a .htpasswd file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">nginx의 경우, 보호하려는 위치와 암호로 보호 된 영역에 이름을 제공하는 &lt;code&gt;auth_basic&lt;/code&gt; 지시문을 지정해야합니다. &lt;code&gt;auth_basic_user_file&lt;/code&gt; 의 지시어는 바로 위의 아파치 예에서와 같이 암호화 된 사용자 자격 증명을 포함하는 .htpasswd 파일을 가리키는.</target>
        </trans-unit>
        <trans-unit id="b60310977b1322aae7188c84f1d2bec064596b5e" translate="yes" xml:space="preserve">
          <source>For nginx, you will need to specify a location that you are going to protect and the &lt;code&gt;auth_basic&lt;/code&gt; directive that provides the name to the password-protected area. The &lt;code&gt;auth_basic_user_file&lt;/code&gt; directive then points to a &lt;code&gt;.htpasswd&lt;/code&gt; file containing the encrypted user credentials, just like in the Apache example above.</source>
          <target state="translated">nginx의 경우 보호 할 위치와 암호로 보호되는 영역에 이름을 제공하는 &lt;code&gt;auth_basic&lt;/code&gt; 지시문을 지정해야합니다. &lt;code&gt;auth_basic_user_file&lt;/code&gt; 의 지침은 다음을 가리키는 &lt;code&gt;.htpasswd&lt;/code&gt; 바로 위의 아파치 예에서와 같이 암호화 된 사용자 자격 증명을 포함하는 파일입니다.</target>
        </trans-unit>
        <trans-unit id="70553b80e8be103814c1eb5f51fa3a904090e239" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-Match&lt;/code&gt; can be used to prevent the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;. It can check if the modification of a resource that the user wants to upload will not override another change that has been done since the original resource was fetched. If the request cannot be fulfilled, the &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt; (Precondition Failed) response is returned.</source>
          <target state="translated">다른 방법, 특히 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;If-Match&lt;/code&gt; &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;업데이트 손실 문제&lt;/a&gt; 를 방지하기 위해 If-Match를 사용할 수 있습니다 . 사용자가 업로드하려는 리소스의 수정이 원래 리소스를 가져온 후 수행 된 다른 변경 사항을 무시하지 않는지 확인할 수 있습니다. 요청을 이행 할 수 없으면 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; (사전 조건 실패) 응답이 리턴됩니다.</target>
        </trans-unit>
        <trans-unit id="538225086d2d3b055913158dd5b4c3b9bfc1f097" translate="yes" xml:space="preserve">
          <source>For other methods, and in particular for &lt;a href=&quot;../methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; used with the &lt;code&gt;*&lt;/code&gt; value can be used to save a file not known to exist, guaranteeing that another upload didn't happen before, losing the data of the previous put; this problem is a variation of the &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;lost update problem&lt;/a&gt;.</source>
          <target state="translated">다른 방법, 특히 &lt;a href=&quot;../methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 의 &lt;code&gt;If-None-Match&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; 값 과 함께 사용 된 If-None-Match를 사용 하여 존재하지 않는 파일을 저장하여 이전 업로드의 데이터가 손실되기 전에 다른 업로드가 발생하지 않았 음을 보장 할 수 있습니다. 이 문제는 &lt;a href=&quot;https://www.w3.org/1999/04/Editing/#3.1&quot;&gt;손실 된 업데이트 문제&lt;/a&gt; 의 변형입니다 .</target>
        </trans-unit>
        <trans-unit id="89936fcb3c720f2a1e2c92027641b334e9357ffd" translate="yes" xml:space="preserve">
          <source>For other products based on Gecko, the string can take one of two forms, where the tokens have the same meaning except those noted below:</source>
          <target state="translated">Gecko를 기반으로하는 다른 제품의 경우, 문자열은 두 가지 형식 중 하나를 취할 수 있습니다. 여기서 토큰은 아래에 언급 된 것을 제외하고 동일한 의미를 갖습니다.</target>
        </trans-unit>
        <trans-unit id="907135173500e7b45556d497127edb70bd3fb716" translate="yes" xml:space="preserve">
          <source>For reasons of security and privacy, it is necessary to make a
   distinction between &quot;shared&quot; and &quot;non-shared&quot; caches. A non-shared
   cache is one that is accessible only to a single user. Accessibility
   in this case SHOULD be enforced by appropriate security mechanisms.
   All other caches are considered to be &quot;shared.&quot; Other sections of 

   this specification place certain constraints on the operation of
   shared caches in order to prevent loss of privacy or failure of
   access controls.</source>
          <target state="translated">보안 및 개인 정보 보호를 위해 &quot;공유&quot;캐시와 &quot;비공유&quot;캐시를 구분해야합니다. 비공유 캐시는 단일 사용자 만 액세스 할 수있는 캐시입니다. 이 경우 접근성은 적절한 보안 메커니즘에 의해 시행되어야한다. 다른 모든 캐시는 &quot;공유&quot;된 것으로 간주됩니다. 이 사양의 다른 섹션에서는 개인 정보 손실 또는 액세스 제어 실패를 방지하기 위해 공유 캐시 작업에 특정 제약 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="257548a557c142ce44b1aa876c1f52d0b2cfeb6c" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;*&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;신임 정보&lt;/em&gt; 가 &lt;em&gt;없는&lt;/em&gt; 요청의 경우 리터럴 값 &quot;*&quot;를 와일드 카드로 지정할 수 있습니다. 이 값은 브라우저에게 모든 오리진에서 코드를 요청하여 리소스에 액세스하도록 허용합니다. 자격 증명과 함께 와일드 카드를 사용하려고 &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;하면 오류가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="9c5ca72995d97f0458eaf84378300b9b55e7ea55" translate="yes" xml:space="preserve">
          <source>For requests &lt;em&gt;without credentials&lt;/em&gt;, the literal value &quot;&lt;code&gt;*&lt;/code&gt;&quot; can be specified, as a wildcard; the value tells browsers to allow requesting code from any origin to access the resource. Attempting to use the wildcard with credentials &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;will result in an error&lt;/a&gt;.</source>
          <target state="translated">&lt;em&gt;자격 증명이없는&lt;/em&gt; 요청의 경우 리터럴 값 &quot; &lt;code&gt;*&lt;/code&gt; &quot;를 와일드 카드로 지정할 수 있습니다. 이 값은 리소스에 액세스하기 위해 모든 출처의 코드 요청을 허용하도록 브라우저에 지시합니다. 자격 증명과 함께 와일드 카드를 사용하려고 &lt;a href=&quot;../cors/errors/corsnotsupportingcredentials&quot;&gt;하면 오류가 발생&lt;/a&gt; 합니다.</target>
        </trans-unit>
        <trans-unit id="d2a1bfce12feb1fb720a7fe1100883e79f123be1" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request resources from the same origin the application was loaded from unless the response from other origins includes the right CORS headers.</source>
          <target state="translated">보안상의 이유로 브라우저는 스크립트에서 시작된 교차 출처 HTTP 요청을 제한합니다. 예를 들어 &lt;code&gt;XMLHttpRequest&lt;/code&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일 출처 정책을&lt;/a&gt; 따릅니다 . 즉, 다른 출처의 응답에 올바른 CORS 헤더가 포함되어 있지 않으면 해당 API를 사용하는 웹 애플리케이션은 애플리케이션이로드 된 동일한 출처의 리소스 만 요청할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="351e6c404b20eecdc808fd67608ccc7928ea6386" translate="yes" xml:space="preserve">
          <source>For security reasons, browsers restrict cross-origin HTTP requests initiated from within scripts. For example, &lt;code&gt;XMLHttpRequest&lt;/code&gt; and the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; follow the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. This means that a web application using those APIs can only request HTTP resources from the same origin the application was loaded from, unless the response from the other origin includes the right CORS headers.</source>
          <target state="translated">보안상의 이유로 브라우저는 스크립트 내에서 시작된 원본 간 HTTP 요청을 제한합니다. 예를 들어, &lt;code&gt;XMLHttpRequest&lt;/code&gt; 및 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt; 는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 출처 정책을&lt;/a&gt; 따릅니다 . 이는 다른 API의 응답에 올바른 CORS 헤더가 포함되어 있지 않으면 해당 API를 사용하는 웹 애플리케이션이 애플리케이션이로드 된 동일한 출처의 HTTP 자원 만 요청할 수 있음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="ee3a9635da3f4811be8395ffd6f2c7c100ed7868" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used.</source>
          <target state="translated">특정 하위 유형이없는 텍스트 문서의 경우 &lt;code&gt;text/plain&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="8cb9d98048f241ce3bdc766680c13b98ba44670c" translate="yes" xml:space="preserve">
          <source>For text documents without a specific subtype, &lt;code&gt;text/plain&lt;/code&gt; should be used. Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="translated">특정 하위 유형이없는 텍스트 문서의 경우 &lt;code&gt;text/plain&lt;/code&gt; 을 사용해야합니다. 마찬가지로 특정 또는 알려진 하위 유형이없는 이진 문서의 경우 &lt;code&gt;application/octet-stream&lt;/code&gt; 을 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="01fd2dd2707385a8305b768f33bb65eb7bcb3f6d" translate="yes" xml:space="preserve">
          <source>For the files in the application that will not change, you can usually add aggressive caching by sending the response header below. This includes static files that are served by the application such as images, CSS files and JavaScript files, for example. In addition, see also the &lt;code&gt;Expires&lt;/code&gt; header.</source>
          <target state="translated">변경되지 않는 응용 프로그램 파일의 경우 일반적으로 아래 응답 헤더를 보내 공격적인 캐싱을 추가 할 수 있습니다. 여기에는 이미지, CSS 파일 및 JavaScript 파일과 같이 응용 프로그램에서 제공하는 정적 파일이 포함됩니다. 또한 &lt;code&gt;Expires&lt;/code&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="47f9208ec82cf7fb7519a3acacb255f0ed8d2472" translate="yes" xml:space="preserve">
          <source>For the purpose of defining the behavior of caches and non-caching
   proxies, we divide HTTP headers into two categories:

      - End-to-end headers, which are  transmitted to the ultimate
        recipient of a request or response. End-to-end headers in
        responses MUST be stored as part of a cache entry and MUST be
        transmitted in any response formed from a cache entry.

      - Hop-by-hop headers, which are meaningful only for a single
        transport-level connection, and are not stored by caches or
        forwarded by proxies.

   The following HTTP/1.1 headers are hop-by-hop headers:

      - Connection
      - Keep-Alive
      - Proxy-Authenticate
      - Proxy-Authorization
      - TE
      - Trailers
      - Transfer-Encoding
      - Upgrade

   All other headers defined by HTTP/1.1 are end-to-end headers.

   Other hop-by-hop headers MUST be listed in a Connection header,
   (&lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;) to be introduced into HTTP/1.1 (or later).</source>
          <target state="translated">캐시 및 비 캐싱 프록시의 동작을 정의하기 위해 HTTP 헤더를 두 가지 범주로 나눕니다.-엔드-투-엔드 헤더-요청 또는 응답의 최종 수신자에게 전송됩니다. 응답의 엔드-투-엔드 헤더는 반드시 캐시 엔트리의 일부로 저장되어야하며 캐시 엔트리로부터 형성된 응답으로 전송되어야합니다. -Hop-by-hop 헤더는 단일 전송 레벨 연결에만 의미가 있으며 캐시에 의해 저장되거나 프록시에 의해 전달되지 않습니다. 다음 HTTP / 1.1 헤더는 홉별 헤더입니다.-연결-연결 유지-프록시 인증-프록시 인증-TE-트레일러-전송 인코딩-업그레이드 HTTP / 1.1에 의해 정의 된 다른 모든 헤더는 끝이 없습니다 엔드 헤더.다른 홉별 헤더는 반드시 연결 헤더 (&lt;a href=&quot;#section-14.10&quot;&gt;14.10 절은&lt;/a&gt; ) HTTP / 1.1 (또는 그 이상)에 도입한다.</target>
        </trans-unit>
        <trans-unit id="21bafa062922688ae091d5ac581f85b2253ab9b7" translate="yes" xml:space="preserve">
          <source>For these reasons, pipelining has been superseded by a better algorithm, &lt;em&gt;multiplexing&lt;/em&gt;, that is used by HTTP/2.</source>
          <target state="translated">이러한 이유로 파이프 라이닝은 HTTP / 2에서 사용 하는 더 나은 알고리즘 인 &lt;em&gt;멀티플렉싱&lt;/em&gt; 으로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="e0fe7bfcb91231799d489fc2723d6dd4bbc0c043" translate="yes" xml:space="preserve">
          <source>Forbidden header name</source>
          <target state="translated">금지 된 헤더 이름</target>
        </trans-unit>
        <trans-unit id="f09e76e0b403d1bc7b01b5a7432c7aadcdb4a81e" translate="yes" xml:space="preserve">
          <source>Forbidden response-header name</source>
          <target state="translated">금지 된 응답 헤더 이름</target>
        </trans-unit>
        <trans-unit id="ecdbc655eb3ebf83109410af71e822cca4455369" translate="yes" xml:space="preserve">
          <source>Forbids JavaScript from accessing the cookie, for example, through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property. Note that a cookie that has been created with HttpOnly will still be sent with JavaScript-initiated requests, e.g. when calling &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send&quot;&gt;&lt;code&gt;XMLHttpRequest.send()&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch&quot;&gt;&lt;code&gt;fetch()&lt;/code&gt;&lt;/a&gt;. This mitigates attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">예를 들어, JavaScript가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; 속성을 통해 쿠키에 액세스하는 것을 금지 합니다. HttpOnly로 생성 된 쿠키는 예를 들어 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/send&quot;&gt; &lt;code&gt;XMLHttpRequest.send()&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch&quot;&gt; &lt;code&gt;fetch()&lt;/code&gt; &lt;/a&gt; 호출시 JavaScript 시작 요청과 함께 계속 전송됩니다 . 이는 크로스 사이트 스크립팅 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ) 에 대한 공격을 완화 합니다.</target>
        </trans-unit>
        <trans-unit id="b412bc69411dace0d04398d6ef301aa1c667a968" translate="yes" xml:space="preserve">
          <source>Force communication using HTTPS instead of HTTP.</source>
          <target state="translated">HTTP 대신 HTTPS를 사용하여 강제로 통신하십시오.</target>
        </trans-unit>
        <trans-unit id="eef9c57759e4f6a908b3d969fe32e4b1fa5c2a10" translate="yes" xml:space="preserve">
          <source>Forced prefetching of hostnames might be useful, for example, on the homepage of a site to force pre-resolution of domain names that are referenced frequently throughout the site even though they are not used on the home page itself. This will improve the overall performance of site even though the performance of the home page may not be affected.</source>
          <target state="translated">호스트 이름의 강제 프리 페치는 예를 들어, 사이트 자체에서 사용되지 않더라도 사이트 전체에서 자주 참조되는 도메인 이름의 사전 해결을 강제하는 데 유용합니다. 이렇게하면 홈 페이지의 성능에 영향을 미치지 않더라도 사이트의 전체 성능이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="07c90eda5719a0767b7585d1fae63b890d2df734" translate="yes" xml:space="preserve">
          <source>Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">캐시 된 사본을 릴리스하기 전에 캐시가 유효성 검증을 위해 요청을 오리진 서버에 제출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="5e4ea8df1ce37991d82f8682bf378d09968f9b0d" translate="yes" xml:space="preserve">
          <source>Forcing &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/https&quot;&gt;HTTPS&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/https&quot;&gt;HTTPS&lt;/a&gt; 강제</target>
        </trans-unit>
        <trans-unit id="4634694667d40eda0bbe0a5024383a25099b93b8" translate="yes" xml:space="preserve">
          <source>Forcing HTTPS. Requests to the HTTP version of your site will be redirected to the HTTPS version of your site.</source>
          <target state="translated">HTTPS 강제. 사이트의 HTTP 버전에 대한 요청은 사이트의 HTTPS 버전으로 리디렉션됩니다.</target>
        </trans-unit>
        <trans-unit id="e65113ef7489ad2e3e6bcd61586a5a6e130fc3a1" translate="yes" xml:space="preserve">
          <source>Forcing lookup of specific hostnames</source>
          <target state="translated">특정 호스트 이름을 강제로 조회</target>
        </trans-unit>
        <trans-unit id="ab88e44a21e56a74ea52f9806dd114accfebc6fd" translate="yes" xml:space="preserve">
          <source>Form factor</source>
          <target state="translated">폼 팩터</target>
        </trans-unit>
        <trans-unit id="d4287342eaedf156edc375518b5469130015c5b1" translate="yes" xml:space="preserve">
          <source>Formatting in HTML</source>
          <target state="translated">HTML 형식</target>
        </trans-unit>
        <trans-unit id="72574aaae0c03841c4924b83ccaa181535815a29" translate="yes" xml:space="preserve">
          <source>Fortunately, as long as you have access to the server's configuration, fixing this is easy. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header supports multiple origins, separated by commas, like this:</source>
          <target state="translated">다행히 서버 구성에 액세스 할 수 있으면이를 쉽게 수정할 수 있습니다. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 이 같은 쉼표로 구분 된 헤더가 지원하는 여러 기원을, :</target>
        </trans-unit>
        <trans-unit id="88300ac449331e8942e45db76cb6c950d0433ba5" translate="yes" xml:space="preserve">
          <source>Forward proxies</source>
          <target state="translated">정방향 프록시</target>
        </trans-unit>
        <trans-unit id="f39bbf5e0d44588e0ee44ca9d11dbdff07723664" translate="yes" xml:space="preserve">
          <source>Forward proxies can also be anonymous proxies and allow users to hide their IP address while browsing the Web or using other Internet services. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (The Onion Router), routes internet traffic through multiple proxies for anonymity.</source>
          <target state="translated">정방향 프록시는 익명 프록시 일 수도 있으며 사용자가 웹을 탐색하거나 다른 인터넷 서비스를 사용하는 동안 IP 주소를 숨길 수 있습니다. &lt;a href=&quot;https://www.torproject.org/&quot;&gt;TOR&lt;/a&gt; (Onion Router)는 익명 성을 위해 여러 프록시를 통해 인터넷 트래픽을 라우팅합니다.</target>
        </trans-unit>
        <trans-unit id="5e96e7529d107df0e1753fe21bd01b67d79778d3" translate="yes" xml:space="preserve">
          <source>Forwarded</source>
          <target state="translated">Forwarded</target>
        </trans-unit>
        <trans-unit id="879b7cb814cbc842f6566b4b5009e2ae4c5e4256" translate="yes" xml:space="preserve">
          <source>Forwarded HTTP Extension</source>
          <target state="translated">전달 된 HTTP 확장</target>
        </trans-unit>
        <trans-unit id="a751a7c6f5ebc769cdda2c0d60519a9100785f00" translate="yes" xml:space="preserve">
          <source>Forwarding client information through proxies</source>
          <target state="translated">프록시를 통한 고객 정보 전달</target>
        </trans-unit>
        <trans-unit id="3f19d616ab1973eab54443edad1f469f67e51a95" translate="yes" xml:space="preserve">
          <source>Fragment</source>
          <target state="translated">Fragment</target>
        </trans-unit>
        <trans-unit id="7bf6780ba1203e0c37a2bbe6f2b29b2481023856" translate="yes" xml:space="preserve">
          <source>Frame and message structure in HTTP/2</source>
          <target state="translated">HTTP / 2의 프레임 및 메시지 구조</target>
        </trans-unit>
        <trans-unit id="5b968bd2c47b3621328bcde661b5d00bbb234e51" translate="yes" xml:space="preserve">
          <source>Freshness</source>
          <target state="translated">Freshness</target>
        </trans-unit>
        <trans-unit id="71fec796b8ce84752a371f57c6e5fa7e23101e6f" translate="yes" xml:space="preserve">
          <source>Freshness (RFC 7234)</source>
          <target state="translated">신선도 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="3f66052a107eaf9bae7cad0f61fb462f47ec2c47" translate="yes" xml:space="preserve">
          <source>From</source>
          <target state="translated">From</target>
        </trans-unit>
        <trans-unit id="061140cd8957c1a20500ec4735145a4823d87854" translate="yes" xml:space="preserve">
          <source>From (RFC 2616)</source>
          <target state="translated">(RFC 2616)부터</target>
        </trans-unit>
        <trans-unit id="ab25ccd00949ff6aec782bce24f64f443ae8183b" translate="yes" xml:space="preserve">
          <source>From (RFC 7231)</source>
          <target state="translated">(RFC 7231)부터</target>
        </trans-unit>
        <trans-unit id="fc8df84d4beeac0f9b5f8d6d828c77f7b287a76a" translate="yes" xml:space="preserve">
          <source>From the beginnings of HTTP, the protocol allowed another negotiation type: &lt;em&gt;agent-driven negotiation&lt;/em&gt; or &lt;em&gt;reactive negotiation&lt;/em&gt;. In this negotiation, when facing an ambiguous request, the server sends back a page containing links to the available alternative resources. The user is presented the resources and choose the one to use.</source>
          <target state="translated">HTTP의 시작부터 프로토콜은 다른 협상 유형 ( &lt;em&gt;에이전트 중심 협상&lt;/em&gt; 또는 &lt;em&gt;사후 협상)을 허용했습니다&lt;/em&gt; . 이 협상에서 모호한 요청에 직면하면 서버는 사용 가능한 대체 자원에 대한 링크가 포함 된 페이지를 다시 보냅니다. 사용자에게 리소스가 제공되고 사용할 리소스를 선택합니다.</target>
        </trans-unit>
        <trans-unit id="2a0830997625a669017113736869c02cdf00c6fb" translate="yes" xml:space="preserve">
          <source>From version 1, Focus is powered by Android WebView and uses the following user agent string format:</source>
          <target state="translated">버전 1부터 Focus는 Android WebView로 구동되며 다음과 같은 사용자 에이전트 문자열 형식을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf2dddbd41ffb807d3f91b7c00d45658b62cbe7d" translate="yes" xml:space="preserve">
          <source>From version 1.1, Firefox for Echo Show uses a user agent string with the following format:</source>
          <target state="translated">버전 1.1부터 Echo Show 용 Firefox는 다음 형식의 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="b65dd0e7d73eba5ec8f68b41e102211c26e17c9c" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">버전 53부터 Gecko는 &lt;code&gt;about:config&lt;/code&gt; 에서 사용자가 기본 &lt;code&gt;Referrer-Policy&lt;/code&gt; &amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; 를 설정할 수 있도록 하는 pref를 가지고 있습니다 .</target>
        </trans-unit>
        <trans-unit id="634b1e47168d224b18cc5d200468a1a666ff4f5b" translate="yes" xml:space="preserve">
          <source>From version 53 onwards, Gecko has a pref available in &lt;code&gt;about:config&lt;/code&gt; to allow users to set their default &lt;code&gt;Referrer-Policy&lt;/code&gt;&amp;mdash; &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt;.</source>
          <target state="translated">이후 버전 53에서 도마뱀에서 사용할 수있는 현이 &lt;code&gt;about:config&lt;/code&gt; 사용자가 자신의 기본 설정 할 수 있도록 &lt;code&gt;Referrer-Policy&lt;/code&gt; - &lt;code&gt;network.http.referer.userControlPolicy&lt;/code&gt; 을 .</target>
        </trans-unit>
        <trans-unit id="f46e7fd368eae55073e0a8f47aee34fcd932ec29" translate="yes" xml:space="preserve">
          <source>From version 59 onwards (See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;#587523&lt;/a&gt;), this has been replaced by &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; and &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt;.</source>
          <target state="translated">버전 59 이상 ( &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=587523&quot;&gt;# 587523&lt;/a&gt; 참조 )에서 &lt;code&gt;network.http.referer.defaultPolicy&lt;/code&gt; 및 &lt;code&gt;network.http.referer.defaultPolicy.pbmode&lt;/code&gt; 로 대체되었습니다 .</target>
        </trans-unit>
        <trans-unit id="4d0bf1cf951361338f44d3f633af3e9f659dd546" translate="yes" xml:space="preserve">
          <source>From version 82, if an &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; element's &lt;code&gt;download&lt;/code&gt; attribute is set (for a same-origin URL) then the &lt;code&gt;inline&lt;/code&gt; directive is ignored. Earlier versions did not match the specification and respected the header directive over the attribute. See &lt;a href=&quot;https://bugzil.la/1658877&quot;&gt;bug 1658877&lt;/a&gt;.</source>
          <target state="translated">버전 82부터 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 요소의 &lt;code&gt;download&lt;/code&gt; 속성이 설정되면 (동일 출처 URL에 대해) &lt;code&gt;inline&lt;/code&gt; 지시문이 무시됩니다. 이전 버전은 사양과 일치하지 않았으며 속성에 대한 헤더 지시문을 준수했습니다. &lt;a href=&quot;https://bugzil.la/1658877&quot;&gt;버그 1658877을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bb08d10b00a6114f53ac03b662cd5c0fa2fadf2c" translate="yes" xml:space="preserve">
          <source>Fullscreen</source>
          <target state="translated">Fullscreen</target>
        </trans-unit>
        <trans-unit id="d1c21c81f5e9278875fd7faba9e8ce5fee900412" translate="yes" xml:space="preserve">
          <source>Fullscreen API&lt;br/&gt;&lt;small&gt;The definition of 'Fullscreen' in that specification.&lt;/small&gt;</source>
          <target state="translated">전체 화면 API &lt;br/&gt;&lt;small&gt;해당 사양에서 '전체 화면'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="9cf4076ad8ca1d493e56ac7306efcb34aa07f0cd" translate="yes" xml:space="preserve">
          <source>Fully qualified hostname to match against.</source>
          <target state="translated">일치하는 완전한 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="70e18d39d91b0bb23213a714597ec6ac0a18898d" translate="yes" xml:space="preserve">
          <source>Functional overview</source>
          <target state="translated">기능 개요</target>
        </trans-unit>
        <trans-unit id="d121b74dc433c61707ecf2145f14c0087235e9c1" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfil it.</source>
          <target state="translated">서버가 요청을 수행하려면 요청에 대한 추가 확장이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="859debff3eb6a95e21550e12eaa3e9501db63349" translate="yes" xml:space="preserve">
          <source>Further extensions to the request are required for the server to fulfill it.</source>
          <target state="translated">서버가 요청을 이행하려면 요청에 대한 추가 확장이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="c09cf39e0efd384b99059d76f22ce0c68ab74478" translate="yes" xml:space="preserve">
          <source>Furthermore, some default values of preferences differ between build configurations, such as platform and locale, which means web sites could identify individual users using this information.</source>
          <target state="translated">또한, 기본 설정의 일부 기본값은 플랫폼 및 로케일과 같은 빌드 구성에 따라 다릅니다. 즉, 웹 사이트가이 정보를 사용하여 개별 사용자를 식별 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a36a6718f54524d846894fb04b5b885b4e43e63b" translate="yes" xml:space="preserve">
          <source>G</source>
          <target state="translated">G</target>
        </trans-unit>
        <trans-unit id="f030bbbd32966cde41037b98a8849c46b76e4bc1" translate="yes" xml:space="preserve">
          <source>GET</source>
          <target state="translated">GET</target>
        </trans-unit>
        <trans-unit id="828d617ffbd78d6822f9aa5a1a25e2e9a6f4041d" translate="yes" xml:space="preserve">
          <source>GET (RFC 7231)</source>
          <target state="translated">GET (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="889241fb06a8d7a9634f3ef3d8c354487e92626b" translate="yes" xml:space="preserve">
          <source>GET: The resource has been fetched and is transmitted in the message body.</source>
          <target state="translated">GET : 자원이 페치되었으며 메시지 본문에서 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="758f6c9347b91091c38ad698a8eba6aeac47b9c4" translate="yes" xml:space="preserve">
          <source>GIF</source>
          <target state="translated">GIF</target>
        </trans-unit>
        <trans-unit id="ad6e940d0a1449c3f043c3a92ac96eacb89d1691" translate="yes" xml:space="preserve">
          <source>GIF images (lossless compression, superseded by PNG)</source>
          <target state="translated">GIF 이미지 (무손실 압축, PNG로 대체)</target>
        </trans-unit>
        <trans-unit id="d84234ce9f95c2df9a9cb91648dc0629d7b55a78" translate="yes" xml:space="preserve">
          <source>GMT</source>
          <target state="translated">GMT</target>
        </trans-unit>
        <trans-unit id="352e09ef4c24f106ac21c027ee173d9c89b53400" translate="yes" xml:space="preserve">
          <source>GZip Compressed Archive</source>
          <target state="translated">GZip 압축 아카이브</target>
        </trans-unit>
        <trans-unit id="30b0db79f60240a0079907f498493dc26899f285" translate="yes" xml:space="preserve">
          <source>Gateway or multiple parties. The server is acting as a gateway to an exchange involving multiple parties.</source>
          <target state="translated">게이트웨이 또는 여러 당사자. 서버가 여러 당사자를 포함하는 교환에 대한 게이트웨이 역할을합니다.</target>
        </trans-unit>
        <trans-unit id="75402c80a4e4ffb05b2e1744866544933eef7e16" translate="yes" xml:space="preserve">
          <source>Gecko</source>
          <target state="translated">Gecko</target>
        </trans-unit>
        <trans-unit id="d377c8358e2e4b422fb5f7dadb1f64fb8c95cca2" translate="yes" xml:space="preserve">
          <source>Gecko user agent string</source>
          <target state="translated">도마뱀 사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="64f2d81db08b8b5b6d065aef938e7abd5e149546" translate="yes" xml:space="preserve">
          <source>Gecko version number</source>
          <target state="translated">게코 버전 번호</target>
        </trans-unit>
        <trans-unit id="ab051d4c4633073d92cf5eecdf9929aa43fd1d4b" translate="yes" xml:space="preserve">
          <source>Gecko/xyz</source>
          <target state="translated">Gecko/xyz</target>
        </trans-unit>
        <trans-unit id="40fe0205052be8e7ff127e8675aa5f542d969bde" translate="yes" xml:space="preserve">
          <source>General example</source>
          <target state="translated">일반적인 예</target>
        </trans-unit>
        <trans-unit id="8fccc069576bf17f5e7e17b4b3c176d69ed30562" translate="yes" xml:space="preserve">
          <source>General form</source>
          <target state="translated">일반적인 형태</target>
        </trans-unit>
        <trans-unit id="c1e2a5611d6d492bfc81f68a60efadd4f6151c4e" translate="yes" xml:space="preserve">
          <source>General header</source>
          <target state="translated">일반 헤더</target>
        </trans-unit>
        <trans-unit id="ce7515fe427724c3a8ec1e689f1513ade3494a01" translate="yes" xml:space="preserve">
          <source>General structure</source>
          <target state="translated">일반 구조</target>
        </trans-unit>
        <trans-unit id="5739e547142aa8443b5825e26cdfefcbe00318e3" translate="yes" xml:space="preserve">
          <source>General warning information about possible problems.</source>
          <target state="translated">가능한 문제에 대한 일반 경고 정보.</target>
        </trans-unit>
        <trans-unit id="2ee8f734456eeec6f1528c29e7b9dd676c82ba5c" translate="yes" xml:space="preserve">
          <source>Geolocation</source>
          <target state="translated">Geolocation</target>
        </trans-unit>
        <trans-unit id="85b8d61e7354b7736b7ec8ca91e1105f85435b65" translate="yes" xml:space="preserve">
          <source>Given this CSP header:</source>
          <target state="translated">이 CSP 헤더가 주어지면 :</target>
        </trans-unit>
        <trans-unit id="4e8b70f78453a41b0760bb603aa5281fa0436163" translate="yes" xml:space="preserve">
          <source>Glossary: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</source>
          <target state="translated">용어집 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;CORS&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f179b6f36465b5aac2f67605586252775def9c70" translate="yes" xml:space="preserve">
          <source>Good:</source>
          <target state="translated">Good:</target>
        </trans-unit>
        <trans-unit id="bad9e9df904c73f497b664b045343bef194565df" translate="yes" xml:space="preserve">
          <source>Google Chrome handles DNS prefetching control</source>
          <target state="translated">Chrome에서 DNS 프리 페칭 제어 처리</target>
        </trans-unit>
        <trans-unit id="4d6910e3810a19ca345b6c8578f0e4ba472ba3b8" translate="yes" xml:space="preserve">
          <source>Google Docs CORB explainer</source>
          <target state="translated">Google Docs CORB 설명자</target>
        </trans-unit>
        <trans-unit id="3e389ee93fcba3ef467be442186c13f4427744a6" translate="yes" xml:space="preserve">
          <source>Google Webmaster blog: How to deal with planned site downtime</source>
          <target state="translated">Google 웹 마스터 블로그 : 계획된 사이트 중단 시간을 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="ea0c0aed6cf9a0c5b577d1e3a89cbf79500b4710" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google &lt;a href=&quot;https://hstspreload.appspot.com/&quot;&gt;은 HSTS 사전로드 서비스를&lt;/a&gt; 유지 관리 합니다 . 지침에 따라 도메인을 성공적으로 제출하면 브라우저는 안전하지 않은 연결을 사용하여 도메인에 연결하지 않습니다. 서비스가 Google에서 호스팅하는 동안 모든 브라우저는 사전로드 목록을 사용하겠다고 선언했습니다. 그러나 이는 HSTS 사양의 일부가 아니므로 공식적으로 취급해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="60827ebdcf1686e9d01ea4b0e1ab1925903a2c9b" translate="yes" xml:space="preserve">
          <source>Google maintains &lt;a href=&quot;https://hstspreload.org/&quot;&gt;an HSTS preload service&lt;/a&gt;. By following the guidelines and successfully submitting your domain, browsers will never connect to your domain using an insecure connection. While the service is hosted by Google, all browsers have stated an intent to use (or actually started using) the preload list. However, it is not part of the HSTS specification and should not be treated as official.</source>
          <target state="translated">Google &lt;a href=&quot;https://hstspreload.org/&quot;&gt;은 HSTS 사전로드 서비스를&lt;/a&gt; 유지 합니다 . 지침을 따르고 도메인을 성공적으로 제출하면 브라우저가 안전하지 않은 연결을 사용하여 도메인에 연결되지 않습니다. 서비스가 Google에서 호스팅되는 동안 모든 브라우저는 사전로드 목록을 사용하겠다고 (또는 실제로 사용하기 시작했습니다) 명시했습니다. 그러나 HSTS 사양의 일부가 아니므로 공식적으로 취급해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="ef239b0e9b523a211062dd9a992489254f2934aa" translate="yes" xml:space="preserve">
          <source>Governs which referrer information sent in the &lt;a href=&quot;headers/referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; header should be included with requests made.</source>
          <target state="translated">리퍼러 헤더에 전송 된 리퍼러 정보에 대한 &lt;a href=&quot;headers/referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 는 요청에 포함되어야합니다.</target>
        </trans-unit>
        <trans-unit id="360bdb2acc65ada59d8a23e434964675641d9c45" translate="yes" xml:space="preserve">
          <source>Graceful degradation</source>
          <target state="translated">우아한 저하</target>
        </trans-unit>
        <trans-unit id="14d1e14f4035027adcdfb20a1541aae1745796ae" translate="yes" xml:space="preserve">
          <source>Granular control over certain features</source>
          <target state="translated">특정 기능에 대한 세분화 된 제어</target>
        </trans-unit>
        <trans-unit id="acdb09fe43197ccedd1630af2f50c572c32d3061" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format</source>
          <target state="translated">Graphics Interchange Format</target>
        </trans-unit>
        <trans-unit id="94265c1a4efc21014ed0c288b4d4deab23d58e6c" translate="yes" xml:space="preserve">
          <source>Graphics Interchange Format (GIF)</source>
          <target state="translated">그래픽 교환 형식 (GIF)</target>
        </trans-unit>
        <trans-unit id="07dad8754dab2f22b2c67d2717531b2161e04c97" translate="yes" xml:space="preserve">
          <source>Greenwich Mean Time. HTTP dates are always expressed in GMT, never in local time.</source>
          <target state="translated">그리니치 표준시. HTTP 날짜는 항상 현지 시간이 아닌 GMT로 표시됩니다.</target>
        </trans-unit>
        <trans-unit id="fac27197d986ea2b588d07c83185f5503eea7d94" translate="yes" xml:space="preserve">
          <source>Guide to media types used on the web</source>
          <target state="translated">웹에서 사용되는 미디어 유형 안내</target>
        </trans-unit>
        <trans-unit id="63172a5d2ab37e128a6f6cf25b0335129725a21c" translate="yes" xml:space="preserve">
          <source>Guide: &lt;em&gt;&lt;a href=&quot;https://csswizardry.com/2019/03/cache-control-for-civilians&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt; for civilians&lt;/a&gt;&lt;/em&gt;</source>
          <target state="translated">가이드 : &lt;em&gt;&lt;a href=&quot;https://csswizardry.com/2019/03/cache-control-for-civilians&quot;&gt;민간인을위한 보관함 &lt;/a&gt;&lt;/em&gt;&lt;em&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="929a28d261428029e61c0f81c6161fd71ba0b2fe" translate="yes" xml:space="preserve">
          <source>Guides</source>
          <target state="translated">Guides</target>
        </trans-unit>
        <trans-unit id="82ee9a2ace2ff133591d7f8cb5b72ca9b839fcd4" translate="yes" xml:space="preserve">
          <source>Guides: Basics</source>
          <target state="translated">안내서 : 기본</target>
        </trans-unit>
        <trans-unit id="6e029883c1d4de187688b7e7b2376708429e4061" translate="yes" xml:space="preserve">
          <source>Gyroscope</source>
          <target state="translated">Gyroscope</target>
        </trans-unit>
        <trans-unit id="7138a51661947b19b5088da5a2bfede2876f49b9" translate="yes" xml:space="preserve">
          <source>HEAD</source>
          <target state="translated">HEAD</target>
        </trans-unit>
        <trans-unit id="780c90e89bccb7fed5c8548e6fe499017ad97ffb" translate="yes" xml:space="preserve">
          <source>HEAD (RFC 7231)</source>
          <target state="translated">헤드 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="562b472b05f04a6dd479541dc3fcef670a17fed9" translate="yes" xml:space="preserve">
          <source>HEAD: The entity headers are in the message body.</source>
          <target state="translated">HEAD : 엔티티 헤더가 메시지 본문에 있습니다.</target>
        </trans-unit>
        <trans-unit id="c194c3625b9314d21fe00e2a5b33960d2235d75a" translate="yes" xml:space="preserve">
          <source>HPACK: Header Compression for HTTP/2</source>
          <target state="translated">HPACK : HTTP / 2를위한 헤더 압축</target>
        </trans-unit>
        <trans-unit id="f4ce8cef0273faa8edf023797bff38c190bc758e" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommend.</source>
          <target state="translated">HPKP는 잘못 사용하면 사용자를 오랫동안 잠글 수 있습니다. 백업 인증서를 사용하거나 CA 인증서를 고정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="fc0a0d888f6e163542c2141a305027befded2018" translate="yes" xml:space="preserve">
          <source>HPKP has the potential to lock out users for a long time if used incorrectly! The use of backup certificates and/or pinning the CA certificate is recommended.</source>
          <target state="translated">HPKP는 잘못 사용하면 사용자를 오랫동안 잠글 수 있습니다. 백업 인증서를 사용하거나 CA 인증서를 고정하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f7a71b290916b9c6df149f326df62ff64346f837" translate="yes" xml:space="preserve">
          <source>HPKP is a &lt;em&gt;Trust on First Use&lt;/em&gt; (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt;) technique. The first time a web server tells a client via a special HTTP header which public keys belong to it, the client stores this information for a given period of time. When the client visits the server again, it expects at least one certificate in the certificate chain to contain a public key whose fingerprint is already known via HPKP. If the server delivers an unknown public key, the client should present a warning to the user.</source>
          <target state="translated">HPKP는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/TOFU&quot;&gt;TOFU&lt;/a&gt; ( &lt;em&gt;Trust on First Use&lt;/em&gt; ) 기술입니다. 웹 서버가 특수한 HTTP 헤더를 통해 클라이언트에게 어떤 공개 키가 속하는지를 처음 알리면 클라이언트는이 정보를 주어진 기간 동안 저장합니다. 클라이언트가 서버를 다시 방문하면 인증서 체인에있는 하나 이상의 인증서에 HPKP를 통해 지문이 이미 알려진 공개 키가 포함될 것으로 예상됩니다. 서버가 알 수없는 공개 키를 전달하는 경우 클라이언트는 사용자에게 경고를 표시해야합니다.</target>
        </trans-unit>
        <trans-unit id="9f738ce8457f291b18ee47e665e96baa84f38fcd" translate="yes" xml:space="preserve">
          <source>HTML</source>
          <target state="translated">HTML</target>
        </trans-unit>
        <trans-unit id="f23df8f2db7fa54c086120949c75120681957c68" translate="yes" xml:space="preserve">
          <source>HTML &lt;code&gt;lang&lt;/code&gt; attribute</source>
          <target state="translated">HTML &lt;code&gt;lang&lt;/code&gt; 속성</target>
        </trans-unit>
        <trans-unit id="57b74ec0b3fb709ed009e59e071a8ce0a9039c38" translate="yes" xml:space="preserve">
          <source>HTML Forms</source>
          <target state="translated">HTML 양식</target>
        </trans-unit>
        <trans-unit id="2abbe4c282803f8a491f6e980e7fc519bd5a7483" translate="yes" xml:space="preserve">
          <source>HTML Living Standard</source>
          <target state="translated">HTML 생활 표준</target>
        </trans-unit>
        <trans-unit id="b7098c07bc2151e34df998ef11bad7237b20c9ba" translate="yes" xml:space="preserve">
          <source>HTML Living Standard&lt;br/&gt;&lt;small&gt;The definition of 'document-domain' in that specification.&lt;/small&gt;</source>
          <target state="translated">HTML Living Standard &lt;br/&gt;&lt;small&gt;해당 사양에서 '문서 도메인'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="18d5d7015a5c0d8f94531cdc381221d904d7cbf2" translate="yes" xml:space="preserve">
          <source>HTML files</source>
          <target state="translated">HTML 파일</target>
        </trans-unit>
        <trans-unit id="6390be00d32679564fc38130d4ea8471a4d82c91" translate="yes" xml:space="preserve">
          <source>HTML redirections</source>
          <target state="translated">HTML 리디렉션</target>
        </trans-unit>
        <trans-unit id="f66adf007a33a0423e5b7102cdbe9c27c03d133c" translate="yes" xml:space="preserve">
          <source>HTML redirections with the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용한 HTML 리디렉션</target>
        </trans-unit>
        <trans-unit id="7508e59dac25653bfafc78c94cdfff1f91c75f89" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) are executed if there weren't any HTTP redirects.</source>
          <target state="translated">HTTP 리디렉션이없는 경우 HTML 리디렉션 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; )이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="8486d6ebac41d1efb6780b5d1b64cf90fff3aae8" translate="yes" xml:space="preserve">
          <source>HTML redirects (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt;) execute if there weren't any HTTP redirects.</source>
          <target state="translated">HTTP 리디렉션이없는 경우 HTML 리디렉션 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; )이 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="83ef326d5040783a2304cd9c3d4b2741d50432d8" translate="yes" xml:space="preserve">
          <source>HTTP 1.1 recommends the use of ETags rather than modification dates,
   for cache control, and there are even stronger reasons to prefer
   ETags for authoring.  Correct use of ETags is even more important in
   a distributed authoring environment, because ETags are necessary
   along with locks to avoid the lost-update problem.  A client might
   fail to renew a lock, for example, when the lock times out and the
   client is accidentally offline or in the middle of a long upload.
   When a client fails to renew the lock, it's quite possible the
   resource can still be relocked and the user can go on editing, as
   long as no changes were made in the meantime.  ETags are required for
   the client to be able to distinguish this case.  Otherwise, the 

   client is forced to ask the user whether to overwrite the resource on
   the server without even being able to tell the user if it has
   changed.  Timestamps do not solve this problem nearly as well as
   ETags.

   Strong ETags are much more useful for authoring use cases than weak
   ETags (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of [RFC2616]&lt;/a&gt;).  Semantic equivalence can be
   a useful concept but that depends on the document type and the
   application type, and interoperability might require some agreement
   or standard outside the scope of this specification and HTTP.  Note
   also that weak ETags have certain restrictions in HTTP, e.g., these
   cannot be used in If-Match headers.

   Note that the meaning of an ETag in a PUT response is not clearly
   defined either in this document or in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; (i.e., whether the
   ETag means that the resource is octet-for-octet equivalent to the
   body of the PUT request, or whether the server could have made minor
   changes in the formatting or content of the document upon storage).
   This is an HTTP issue, not purely a WebDAV issue.

   Because clients may be forced to prompt users or throw away changed
   content if the ETag changes, a WebDAV server SHOULD NOT change the
   ETag (or the Last-Modified time) for a resource that has an unchanged
   body and location.  The ETag represents the state of the body or
   contents of the resource.  There is no similar way to tell if
   properties have changed.</source>
          <target state="translated">HTTP 1.1은 캐시 제어를 위해 수정 날짜 대신 ETag를 사용하도록 권장하며, 작성을 위해 ETag를 선호해야하는 더 강력한 이유가 있습니다. ETag가 업데이트 손실 문제를 피하기 위해 잠금과 함께 필요하기 때문에 분산 작성 환경에서는 ETag를 올바르게 사용하는 것이 더욱 중요합니다. 예를 들어 잠금 시간이 초과되어 클라이언트가 실수로 오프라인 상태이거나 긴 업로드 도중에 클라이언트가 잠금을 갱신하지 못할 수 있습니다. 클라이언트가 잠금을 갱신하지 못하면 그 동안 변경 사항이없는 한 여전히 리소스를 다시 잠글 수 있고 사용자가 편집을 계속할 수 있습니다. 클라이언트가이 사례를 구별 할 수 있으려면 ETag가 필요합니다. 그렇지 않으면,클라이언트는 변경 여부를 사용자에게 알리지 않고도 서버의 리소스를 덮어 쓸지 여부를 사용자에게 묻습니다. 타임 스탬프는 ETag와 마찬가지로이 문제를 해결하지 못합니다. 강력한 ETag는 약한 ETag보다 사용 사례를 작성하는 데 훨씬 유용합니다 (참조&lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;[RFC2616]의 섹션 13.3.3&lt;/a&gt; ). 시맨틱 동등성은 유용한 개념이 될 수 있지만 문서 유형 및 애플리케이션 유형에 따라 다르며 상호 운용성을 위해서는이 스펙 및 HTTP의 범위를 벗어나는 일부 계약 또는 표준이 필요할 수 있습니다. 약한 ETag는 HTTP에 특정 제한이 있습니다. 예를 들어 If-Match 헤더에는 사용할 수 없습니다. PUT 응답에서 ETag의 의미는이 문서 또는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; 에 명확하게 정의되어 있지 않습니다.(즉, ETag가 자원이 PUT 요청의 본문과 동일한 옥텟 단위 옥텟인지 또는 서버가 저장시 문서의 형식이나 내용을 약간 변경했는지 여부). 이것은 순수한 WebDAV 문제가 아닌 HTTP 문제입니다. ETag가 변경되면 클라이언트가 사용자에게 프롬프트를 표시하거나 변경된 컨텐츠를 버릴 수 있으므로 WebDAV 서버는 변경되지 않는 본문과 위치가있는 자원의 ETag (또는 마지막 수정 시간)를 변경해서는 안됩니다. ETag는 본문의 상태 또는 자원의 내용을 나타냅니다. 속성이 변경되었는지 확인하는 비슷한 방법은 없습니다.</target>
        </trans-unit>
        <trans-unit id="056cc5e9a537351fb174e8ebbb3ca2b1700c2d47" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;content negotiation&lt;/a&gt;</source>
          <target state="translated">HTTP &lt;a href=&quot;../content_negotiation&quot;&gt;컨텐츠 협상&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="392079fd3fa793eb6c0e1335885b8cddafea9ef8" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt;, like those for requests.</source>
          <target state="translated">요청 &lt;a href=&quot;headers&quot;&gt;헤더&lt;/a&gt; 와 같은 HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="c6a6635bbee752fe5fb0f3784e33cdf15bd75ab6" translate="yes" xml:space="preserve">
          <source>HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;Client hints&lt;/a&gt; are a work in progress. Actual documentation can be found on the &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html&quot;&gt;website of the HTTP working group&lt;/a&gt;.</source>
          <target state="translated">HTTP &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Client_hints&quot;&gt;클라이언트 힌트&lt;/a&gt; 는 진행중인 작업입니다. 실제 문서는 &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html&quot;&gt;HTTP 워킹 그룹&lt;/a&gt; 의 웹 사이트에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a2ed3fe8a3093e057602abdf74477e83473a214" translate="yes" xml:space="preserve">
          <source>HTTP &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTP &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="ae47637ce45f4b16c54404dff4cb129bfbe68800" translate="yes" xml:space="preserve">
          <source>HTTP Access Control covering the HTTP headers</source>
          <target state="translated">HTTP 헤더를 다루는 HTTP 액세스 제어</target>
        </trans-unit>
        <trans-unit id="d601b5bb2c1cad46bb9aa46a3ee39b64315236e7" translate="yes" xml:space="preserve">
          <source>HTTP Alternative Services</source>
          <target state="translated">HTTP 대체 서비스</target>
        </trans-unit>
        <trans-unit id="965e2184c8e7927a43f2bee90d3f5ececba434b6" translate="yes" xml:space="preserve">
          <source>HTTP Cache</source>
          <target state="translated">HTTP 캐시</target>
        </trans-unit>
        <trans-unit id="f54d56b271b9875e48fe27b600b0dc067a9f284e" translate="yes" xml:space="preserve">
          <source>HTTP Cache-Control Extensions for Stale Content</source>
          <target state="translated">오래된 컨텐츠를위한 HTTP 캐시 제어 확장</target>
        </trans-unit>
        <trans-unit id="6c1e735662c0178e6f3fe960f4930ffeabb6f7fe" translate="yes" xml:space="preserve">
          <source>HTTP Caching FAQ</source>
          <target state="translated">HTTP 캐싱 FAQ</target>
        </trans-unit>
        <trans-unit id="0b0260299fa380d7d3a7ccc7edbf8a208c829f61" translate="yes" xml:space="preserve">
          <source>HTTP Client Hints</source>
          <target state="translated">HTTP 클라이언트 힌트</target>
        </trans-unit>
        <trans-unit id="17e0afd9e45a02ae60f6b6aed60a68bef13f3af0" translate="yes" xml:space="preserve">
          <source>HTTP Conditional Requests</source>
          <target state="translated">HTTP 조건부 요청</target>
        </trans-unit>
        <trans-unit id="186213537e6fba63d1dd994c6c9b358b6f840caf" translate="yes" xml:space="preserve">
          <source>HTTP Cookies</source>
          <target state="translated">HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="ae2fa3648597031d5a833b5724263dbfd920c241" translate="yes" xml:space="preserve">
          <source>HTTP Extensions for Web Distributed Authoring and Versioning (WebDAV)</source>
          <target state="translated">WebDAV (Web Distributed Authoring and Versioning)를위한 HTTP 확장</target>
        </trans-unit>
        <trans-unit id="6cee8a3bc57d158b257c68ed73852449cb27b716" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options</source>
          <target state="translated">HTTP 헤더 필드 X- 프레임 옵션</target>
        </trans-unit>
        <trans-unit id="f88eb2164f3dbd137bca83f451898992e6e6b039" translate="yes" xml:space="preserve">
          <source>HTTP Header Field X-Frame-Options - RFC 7034</source>
          <target state="translated">HTTP 헤더 필드 X- 프레임 옵션-RFC 7034</target>
        </trans-unit>
        <trans-unit id="cc46670cd995848df63f3703c3400f81060dd482" translate="yes" xml:space="preserve">
          <source>HTTP Headers</source>
          <target state="translated">HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="d5d09479cf8d4e2b8c35798b4a19c06e1f5461b3" translate="yes" xml:space="preserve">
          <source>HTTP Immutable Responses</source>
          <target state="translated">HTTP 불변의 응답</target>
        </trans-unit>
        <trans-unit id="d1d0c4dbc1b360b38cb5161612b50b3934e501fa" translate="yes" xml:space="preserve">
          <source>HTTP Keep-Alive Header</source>
          <target state="translated">HTTP 연결 유지 헤더</target>
        </trans-unit>
        <trans-unit id="dc68b45ed9f862b4a9cd7aa0be2cfbc7e016a6ef" translate="yes" xml:space="preserve">
          <source>HTTP Message (RFC 2616)</source>
          <target state="translated">HTTP 메시지 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="645acbbc29e90c2c68542670b051cdcea02987bc" translate="yes" xml:space="preserve">
          <source>HTTP Messages</source>
          <target state="translated">HTTP 메시지</target>
        </trans-unit>
        <trans-unit id="3ccf0b57b902eafdb8fbf2b560f880d3eb800cc2" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure. This introductory article describes this structure, its purpose, and its possibilities.</source>
          <target state="translated">요청 또는 응답 중에 전송되는 HTTP 메시지는 매우 명확한 구조를 가지고 있습니다. 이 소개 기사에서는이 구조, 목적 및 가능성에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="583d9f510824dc860b8faad49ebe7579ffd29c0b" translate="yes" xml:space="preserve">
          <source>HTTP Messages transmitted during requests or responses have a very clear structure; this introductory article describes this structure, its purpose and its possibilities.</source>
          <target state="translated">요청 또는 응답 중에 전송 된 HTTP 메시지는 매우 명확한 구조를 갖습니다. 이 기사에서는이 구조, 목적 및 가능성에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1b57e4650aa38c4a92f3b3fc02ea7dab930ee663" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HPKP&quot;&gt;HPKP&lt;/a&gt;)</source>
          <target state="translated">HTTP 공개 키 고정 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HPKP&quot;&gt;HPKP&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="d34a93534eb1b632f2a799adfc1786464f6439f8" translate="yes" xml:space="preserve">
          <source>HTTP Public Key Pinning has been deprecated and removed in favor of Certificate Transparency and &lt;a href=&quot;headers/expect-ct&quot;&gt;&lt;code&gt;Expect-CT&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">HTTP 공개 키 고정은 더 이상 사용되지 않으며 인증서 투명성 및 &lt;a href=&quot;headers/expect-ct&quot;&gt; &lt;code&gt;Expect-CT&lt;/code&gt; &lt;/a&gt; 를 위해 제거되었습니다 .</target>
        </trans-unit>
        <trans-unit id="94fdc3e6f5c751d82295ac7ade9d715a4814c0d4" translate="yes" xml:space="preserve">
          <source>HTTP Request Methods</source>
          <target state="translated">HTTP 요청 방법</target>
        </trans-unit>
        <trans-unit id="147cce8975179e5500fc1bb079891e026beac7f0" translate="yes" xml:space="preserve">
          <source>HTTP Requests</source>
          <target state="translated">HTTP 요청</target>
        </trans-unit>
        <trans-unit id="7402660b7ec42f5008e637f7d416a9463ae2ce2f" translate="yes" xml:space="preserve">
          <source>HTTP Responses</source>
          <target state="translated">HTTP 응답</target>
        </trans-unit>
        <trans-unit id="1e3c49a8c708be92f5037401d92246426a46dc11" translate="yes" xml:space="preserve">
          <source>HTTP State Management Mechanism</source>
          <target state="translated">HTTP 상태 관리 메커니즘</target>
        </trans-unit>
        <trans-unit id="a5fc269de1ce9034a5e3e1936288b84520462ea3" translate="yes" xml:space="preserve">
          <source>HTTP Status Response Codes</source>
          <target state="translated">HTTP 상태 응답 코드</target>
        </trans-unit>
        <trans-unit id="92b092172a89d9cb7710c23a35bcf58905e6ddfd" translate="yes" xml:space="preserve">
          <source>HTTP Strict Transport Security (HSTS)</source>
          <target state="translated">HSTS (HTTP Strict Transport Security)</target>
        </trans-unit>
        <trans-unit id="30491b8aa76d328aca84cd3704d383ab97b03407" translate="yes" xml:space="preserve">
          <source>HTTP Working Group</source>
          <target state="translated">HTTP 워킹 그룹</target>
        </trans-unit>
        <trans-unit id="cbc09a66647a44074ee04da1ac1771e8479c9d8b" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to a communicate with different &lt;em&gt;resources&lt;/em&gt; on Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTP를 사용하면 브라우저 또는 다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 인터넷의 다른 &lt;em&gt;자원&lt;/em&gt; 과 통신 할 수 &lt;em&gt;있습니다&lt;/em&gt; .이를 수행하려면 브라우저 에 자원 의 &lt;em&gt;ID&lt;/em&gt; 와 &lt;em&gt;위치&lt;/em&gt; 가 모두 필요 합니다. 이 두 비트 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt; 로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="1cc8c4caf634d96aa87067b5477aecd5ac3e698e" translate="yes" xml:space="preserve">
          <source>HTTP allows a browser, or another &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt;, to communicate with different &lt;em&gt;resources&lt;/em&gt; on the Internet: to do this the browser needs both the &lt;em&gt;identity&lt;/em&gt; and the &lt;em&gt;location&lt;/em&gt; of the resources. These two bits of information are described by a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt;.</source>
          <target state="translated">HTTP를 사용하면 브라우저 또는 다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트&lt;/a&gt; 가 인터넷의 다른 &lt;em&gt;리소스&lt;/em&gt; 와 통신 할 수 있습니다. 이렇게하려면 브라우저 에 리소스 의 &lt;em&gt;ID&lt;/em&gt; 와 &lt;em&gt;위치&lt;/em&gt; 가 모두 필요 합니다. 이 두 비트의 정보는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/URI&quot;&gt;URI&lt;/a&gt; 로 설명됩니다 .</target>
        </trans-unit>
        <trans-unit id="2d82f24e44e689920296a131052df78d102bbaff" translate="yes" xml:space="preserve">
          <source>HTTP and WebDAV did not use the bodies of most error responses for
   machine-parsable information until the specification for Versioning
   Extensions to WebDAV introduced a mechanism to include more specific
   information in the body of an error response (&lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;Section&amp;nbsp;1.6 of
   [RFC3253]&lt;/a&gt;).  The error body mechanism is appropriate to use with any
   error response that may take a body but does not already have a body
   defined.  The mechanism is particularly appropriate when a status
   code can mean many things (for example, 400 Bad Request can mean
   required headers are missing, headers are incorrectly formatted, or
   much more).  This error body mechanism is covered in &lt;a href=&quot;#section-16&quot;&gt;Section 16&lt;/a&gt;.</source>
          <target state="translated">HTTP 및 WebDAV는 WebDAV에 대한 버전 화 확장 스펙에서 오류 응답 본문에보다 구체적인 정보를 포함하는 메커니즘을 도입 할 때까지 기계 구문 분석 가능한 정보에 대해 대부분의 오류 응답 본문을 사용하지 않았습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3253#section-1.6&quot;&gt;[RFC3253]의 1.6 절&lt;/a&gt; ). 오류 본문 메커니즘은 본문을 취할 수 있지만 아직 본문이 정의되지 않은 오류 응답과 함께 사용하기에 적합합니다. 이 메커니즘은 상태 코드가 많은 것을 의미 할 때 특히 적합합니다 (예 : 400 잘못된 요청은 필요한 헤더가 누락되었거나 헤더의 형식이 잘못되었거나 더 많음을 의미 할 수 있음). 이 오류 본문 메커니즘은 &lt;a href=&quot;#section-16&quot;&gt;섹션 16&lt;/a&gt; 에서 다룹니다 .</target>
        </trans-unit>
        <trans-unit id="170502bb0d853c3d72e45f0eef9c00311f2253c6" translate="yes" xml:space="preserve">
          <source>HTTP and connections</source>
          <target state="translated">HTTP 및 연결</target>
        </trans-unit>
        <trans-unit id="70e2789624d7913484672252eb44130b859ad66a" translate="yes" xml:space="preserve">
          <source>HTTP applications have historically allowed three different formats
   for the representation of date/time stamps:

      Sun, 06 Nov 1994 08:49:37 GMT  ; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, updated by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;
      Sunday, 06-Nov-94 08:49:37 GMT ; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;
      Sun Nov  6 08:49:37 1994       ; ANSI C's asctime() format

   The first format is preferred as an Internet standard and represents
   a fixed-length subset of that defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [&lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt;] (an update to
   &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]). The second format is in common use, but is based on the
   obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [&lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] date format and lacks a four-digit year.
   HTTP/1.1 clients and servers that parse the date value MUST accept
   all three formats (for compatibility with HTTP/1.0), though they MUST
   only generate the &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; format for representing HTTP-date values
   in header fields. See &lt;a href=&quot;#section-19.3&quot;&gt;section 19.3&lt;/a&gt; for further information.

      Note: Recipients of date values are encouraged to be robust in
      accepting date values that may have been sent by non-HTTP
      applications, as is sometimes the case when retrieving or posting
      messages via proxies/gateways to SMTP or NNTP. 

   All HTTP date/time stamps MUST be represented in Greenwich Mean Time
   (GMT), without exception. For the purposes of HTTP, GMT is exactly
   equal to UTC (Coordinated Universal Time). This is indicated in the
   first two formats by the inclusion of &quot;GMT&quot; as the three-letter
   abbreviation for time zone, and MUST be assumed when reading the
   asctime format. HTTP-date is case sensitive and MUST NOT include
   additional LWS beyond that specifically included as SP in the
   grammar.

       HTTP-date    = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date | &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date | asctime-date
       &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt;-date = wkday &quot;,&quot; SP date1 SP time SP &quot;GMT&quot;
       &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = weekday &quot;,&quot; SP date2 SP time SP &quot;GMT&quot;
       asctime-date = wkday SP date3 SP time SP 4DIGIT
       date1        = 2DIGIT SP month SP 4DIGIT
                      ; day month year (e.g., 02 Jun 1982)
       date2        = 2DIGIT &quot;-&quot; month &quot;-&quot; 2DIGIT
                      ; day-month-year (e.g., 02-Jun-82)
       date3        = month SP ( 2DIGIT | ( SP 1DIGIT ))
                      ; month day (e.g., Jun  2)
       time         = 2DIGIT &quot;:&quot; 2DIGIT &quot;:&quot; 2DIGIT
                      ; 00:00:00 - 23:59:59
       wkday        = &quot;Mon&quot; | &quot;Tue&quot; | &quot;Wed&quot;
                    | &quot;Thu&quot; | &quot;Fri&quot; | &quot;Sat&quot; | &quot;Sun&quot;
       weekday      = &quot;Monday&quot; | &quot;Tuesday&quot; | &quot;Wednesday&quot;
                    | &quot;Thursday&quot; | &quot;Friday&quot; | &quot;Saturday&quot; | &quot;Sunday&quot;
       month        = &quot;Jan&quot; | &quot;Feb&quot; | &quot;Mar&quot; | &quot;Apr&quot;
                    | &quot;May&quot; | &quot;Jun&quot; | &quot;Jul&quot; | &quot;Aug&quot;
                    | &quot;Sep&quot; | &quot;Oct&quot; | &quot;Nov&quot; | &quot;Dec&quot;

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream. Clients and servers are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">HTTP 응용 프로그램은 역사적으로 날짜 / 시간 스탬프를 표시하기 위해 세 가지 형식을 허용했습니다. Sun, 06 Nov 1994 08:49:37 GMT; &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123에&lt;/a&gt; 의해 업데이트 됨 06-Nov-94 08:49:37 GMT; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;1036에&lt;/a&gt; 의해 폐기 된 RFC 850 Sun Nov 6 08:49:37 1994; ANSI C의 asctime () 형식 첫 번째 형식은 인터넷 표준으로 선호되며 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; [ &lt;a href=&quot;#ref-8&quot;&gt;8&lt;/a&gt; ] ( &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]에 대한 업데이트)에서 정의한 고정 길이 하위 집합을 나타냅니다 . 두 번째 형식은 일반적으로 사용되지만 더 이상 사용되지 않는 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; [ &lt;a href=&quot;#ref-12&quot;&gt;12&lt;/a&gt;] 날짜 형식이며 4 자리 연도가 없습니다. 날짜 값을 구문 분석하는 HTTP / 1.1 클라이언트 및 서버는 세 가지 형식 (HTTP / 1.0과의 호환성을 위해)을 모두 수용해야하지만 헤더 필드에 HTTP 날짜 값을 표시하기위한 &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; 형식 만 생성해야 합니다. &lt;a href=&quot;#section-19.3&quot;&gt;섹션 19.3&lt;/a&gt; 참조자세한 내용은. 참고 : 프록시 / 게이트웨이를 통해 SMTP 또는 NNTP로 메시지를 검색하거나 게시 할 때와 같이 날짜 값을받는 사람은 HTTP가 아닌 응용 프로그램에서 보낸 날짜 값을 받아들이는 것이 좋습니다. 모든 HTTP 날짜 / 시간 스탬프는 예외없이 그리니치 표준시 (GMT)로 표시되어야합니다. HTTP의 목적으로 GMT는 UTC (협정 세계시)와 정확히 같습니다. 이것은 표준 시간대의 3 자리 약어로 &quot;GMT&quot;를 포함하여 처음 두 형식으로 표시되며 asctime 형식을 읽을 때 가정해야합니다. HTTP- 날짜는 대소 문자를 구분하며 문법에 SP로 특별히 포함 된 추가 LWS를 포함해서는 안됩니다.HTTP- 날짜 = &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date |&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850-날짜&lt;/a&gt; | asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;rfc1123&lt;/a&gt; -date = wkday &quot;,&quot;SP 날짜 1 SP 시간 SP &quot;GMT&quot; &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = weekday &quot;,&quot;SP date2 SP 시간 SP &quot;GMT&quot;asctime-date = wkday SP 날짜 3 SP 시간 SP 4DIGIT 날짜 1 = 2DIGIT SP 월 SP 4DIGIT; 일 월 년도 (예 : 1982 년 6 월 02 일) date2 = 2DIGIT &quot;-&quot;month &quot;-&quot;2DIGIT; 일-월-년 (예 : 02-Jun-82) date3 = 월 SP (2DIGIT | (SP 1DIGIT)); 월 일 (예 : 6 월 2 일) time = 2DIGIT &quot;:&quot;2DIGIT &quot;:&quot;2DIGIT; 00:00:00-23:59:59 wkday = &quot;월&quot;| &quot;화&quot;| &quot;수&quot;| &quot;목&quot;| &quot;금&quot;| &quot;토&quot;| &quot;일&quot;주중 = &quot;월요일&quot;| &quot;화요일&quot;| &quot;수요일&quot;| &quot;목요일 &quot;|&quot;금요일 &quot;|&quot;토요일 &quot;|&quot;일요일 &quot;월 =&quot;1 월 &quot;|&quot;2 월 &quot;|&quot;3 월 &quot;|&quot;4 월 &quot;|&quot;5 월 &quot;|&quot;6 월 &quot;|&quot;7 월 &quot;|&quot;8 월 &quot;|&quot;9 월 &quot;|&quot;Oct &quot;|&quot;Nov &quot;|&quot;Dec &quot;참고 : 날짜 / 시간 소인 형식의 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트 및 서버는 사용자 표시, 요청 로깅에 이러한 형식을 사용할 필요가 없습니다. 등| &quot;9 월&quot;| &quot;10 월&quot;| &quot;11 월&quot;| &quot;12 월&quot;참고 : 날짜 / 시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트 및 서버는 이러한 형식을 사용자 프리젠 테이션, 요청 로깅 등에 사용할 필요가 없습니다.| &quot;9 월&quot;| &quot;10 월&quot;| &quot;11 월&quot;| &quot;12 월&quot;참고 : 날짜 / 시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 클라이언트 및 서버는 이러한 형식을 사용자 프리젠 테이션, 요청 로깅 등에 사용할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="3cd45603fb781257153f9081597101ece177c7d0" translate="yes" xml:space="preserve">
          <source>HTTP authentication</source>
          <target state="translated">HTTP 인증</target>
        </trans-unit>
        <trans-unit id="ab4ed2ef5f3094275f004bff5889feddcf0ad10a" translate="yes" xml:space="preserve">
          <source>HTTP caching &amp;ndash; Ilya Grigorik</source>
          <target state="translated">HTTP 캐싱 &amp;ndash; Ilya Grigorik</target>
        </trans-unit>
        <trans-unit id="d4978c013ac3d81e858ff3f4bb1b87778fc8087f" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional but usually desirable. HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;; they may decline other methods. The primary cache key consists of the request method and target URI (often only the URI is used &amp;mdash; this is because only &lt;code&gt;GET&lt;/code&gt; requests are caching targets).</source>
          <target state="translated">HTTP 캐싱은 선택 사항이지만 일반적으로 바람직합니다. HTTP 캐시는 일반적으로 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 에&lt;/a&gt; 대한 응답을 캐시하는 것으로 제한됩니다 . 다른 방법을 거부 할 수 있습니다. 기본 캐시 키는 요청 메서드와 대상 URI로 구성됩니다 (종종 URI 만 사용됩니다. 이는 &lt;code&gt;GET&lt;/code&gt; 요청 만 캐싱 대상 이기 때문입니다 ).</target>
        </trans-unit>
        <trans-unit id="bc0f4dfb9b0a4bec403f49cd2c2239e560902813" translate="yes" xml:space="preserve">
          <source>HTTP caching is optional, but reusing a cached resource is usually desirable. However, common HTTP caches are typically limited to caching responses to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and may decline other methods. The primary cache key consists of the request method and target URI (oftentimes only the URI is used as only GET requests are caching targets). Common forms of caching entries are:</source>
          <target state="translated">HTTP 캐싱은 선택 사항이지만 일반적으로 캐시 된 리소스를 재사용하는 것이 좋습니다. 그러나 일반적인 HTTP 캐시는 일반적으로 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 에&lt;/a&gt; 대한 응답 캐싱으로 제한되며 다른 방법을 거부 할 수 있습니다. 기본 캐시 키는 요청 방법과 대상 URI로 구성됩니다 (종종 GET 요청 만 대상을 캐시하므로 URI 만 사용됨). 캐싱 항목의 일반적인 형태는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="64f23433ac676ea06e9a1900351a7ac4a13f68a1" translate="yes" xml:space="preserve">
          <source>HTTP caching works best when caches can entirely avoid making
   requests to the origin server. The primary mechanism for avoiding
   requests is for an origin server to provide an explicit expiration
   time in the future, indicating that a response MAY be used to satisfy
   subsequent requests. In other words, a cache can return a fresh
   response without first contacting the server.

   Our expectation is that servers will assign future explicit
   expiration times to responses in the belief that the entity is not
   likely to change, in a semantically significant way, before the
   expiration time is reached. This normally preserves semantic
   transparency, as long as the server's expiration times are carefully
   chosen. 

   The expiration mechanism applies only to responses taken from a cache
   and not to first-hand responses forwarded immediately to the
   requesting client.

   If an origin server wishes to force a semantically transparent cache
   to validate every request, it MAY assign an explicit expiration time
   in the past. This means that the response is always stale, and so the
   cache SHOULD validate it before using it for subsequent requests. See
   &lt;a href=&quot;#section-14.9.4&quot;&gt;section 14.9.4&lt;/a&gt; for a more restrictive way to force revalidation.

   If an origin server wishes to force any HTTP/1.1 cache, no matter how
   it is configured, to validate every request, it SHOULD use the &quot;must-
   revalidate&quot; cache-control directive (see &lt;a href=&quot;#section-14.9&quot;&gt;section 14.9&lt;/a&gt;).

   Servers specify explicit expiration times using either the Expires
   header, or the max-age directive of the Cache-Control header.

   An expiration time cannot be used to force a user agent to refresh
   its display or reload a resource; its semantics apply only to caching
   mechanisms, and such mechanisms need only check a resource's
   expiration status when a new request for that resource is initiated.
   See &lt;a href=&quot;#section-13.13&quot;&gt;section 13.13&lt;/a&gt; for an explanation of the difference between caches
   and history mechanisms.</source>
          <target state="translated">HTTP 캐싱은 캐시가 오리진 서버에 대한 요청을 완전히 피할 수있을 때 가장 잘 작동합니다. 요청을 피하기위한 기본 메커니즘은 오리진 서버가 미래에 명시적인 만료 시간을 제공하여 후속 요청을 충족시키기 위해 응답을 사용할 수 있음을 나타냅니다. 다시 말해, 캐시는 먼저 서버에 접속하지 않고도 새로운 응답을 반환 할 수 있습니다. 우리는 서버가 만료 시간에 도달하기 전에 의미 적으로 중요한 방식으로 변경되지 않을 것이라는 믿음으로 서버가 미래의 명시적인 만료 시간을 응답에 할당 할 것으로 기대합니다. 일반적으로 서버의 만료 시간을 신중하게 선택하는 한 의미 적 투명성을 유지합니다.만기 메커니즘은 캐시에서 가져온 응답에만 적용되며 요청 클라이언트에게 즉시 전달되는 직접 응답에는 적용되지 않습니다. 오리진 서버가 의미 적으로 투명한 캐시가 모든 요청의 유효성을 검사하도록하려면 과거에 명시적인 만료 시간을 할당 할 수 있습니다. 이는 응답이 항상 유효하지 않기 때문에 캐시는 후속 요청에 응답을 사용하기 전에 응답을 확인해야한다는 것을 의미합니다. 보다 &lt;a href=&quot;#section-14.9.4&quot;&gt;&lt;/a&gt;재 검증을 강제하는보다 제한적인 방법에 대해서는 14.9.4 절을 참조하십시오 . 오리진 서버가 HTTP / 1.1 캐시를 강제로 구성하려는 경우, 모든 요청의 유효성을 검사하기 위해 구성 방식에 관계없이 &quot;must-revaldate&quot;캐시 제어 지시문을 사용해야합니다 ( &lt;a href=&quot;#section-14.9&quot;&gt;섹션 14.9&lt;/a&gt; 참조 ). 서버는 Expires 헤더 또는 Cache-Control 헤더의 max-age 지시문을 사용하여 명시적인 만료 시간을 지정합니다. 사용자 에이전트가 표시를 새로 고치거나 자원을 다시로드하도록 만료 시간을 사용할 수 없습니다. 시맨틱은 캐싱 메커니즘에만 적용되며 이러한 메커니즘은 해당 자원에 대한 새 요청이 시작될 때 자원의 만료 상태 만 확인하면됩니다. &lt;a href=&quot;#section-13.13&quot;&gt;섹션 13.13&lt;/a&gt; 참조 캐시와 히스토리 메커니즘의 차이점에 대한 설명.</target>
        </trans-unit>
        <trans-unit id="7f76c971673910b6c1b10deaca8522002aada40e" translate="yes" xml:space="preserve">
          <source>HTTP clients are often privy to large amounts of personal information
   (e.g. the user's name, location, mail address, passwords, encryption
   keys, etc.), and SHOULD be very careful to prevent unintentional
   leakage of this information via the HTTP protocol to other sources.
   We very strongly recommend that a convenient interface be provided
   for the user to control dissemination of such information, and that
   designers and implementors be particularly careful in this area.
   History shows that errors in this area often create serious security
   and/or privacy problems and generate highly adverse publicity for the
   implementor's company.</source>
          <target state="translated">HTTP 클라이언트는 많은 양의 개인 정보 (예 : 사용자 이름, 위치, 메일 주소, 비밀번호, 암호화 키 등)에 대해 독점적이며, HTTP 프로토콜을 통해 다른 소스로이 정보가 의도하지 않게 유출되지 않도록주의해야합니다. . 사용자가 그러한 정보의 보급을 제어 할 수있는 편리한 인터페이스를 제공 할 것을 강력히 권장하며, 설계자와 구현자는이 영역에 특히주의해야합니다. 역사에 따르면이 영역의 오류로 인해 심각한 보안 및 / 또는 개인 정보 보호 문제가 발생하고 구현 자 회사에 대한 부정적인 평판이 높아질 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0593fb953516cec3cb50e486b7c0cd80aa7ff135" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests</source>
          <target state="translated">HTTP 조건부 요청</target>
        </trans-unit>
        <trans-unit id="a24d61eed6303644578268bb7ece0c747329e619" translate="yes" xml:space="preserve">
          <source>HTTP conditional requests are requests that are executed differently, depending on the value of specific headers. These headers define a precondition, and the result of the request will be different if the precondition is matched or not.</source>
          <target state="translated">HTTP 조건부 요청은 특정 헤더의 값에 따라 다르게 실행되는 요청입니다. 이 헤더는 전제 조건을 정의하며 전제 조건이 일치하는지 여부에 따라 요청 결과가 달라집니다.</target>
        </trans-unit>
        <trans-unit id="7cb9523b16d3c9a97f6ddd095333da9f953ccd3f" translate="yes" xml:space="preserve">
          <source>HTTP content negotiation (&lt;a href=&quot;#section-12&quot;&gt;section 12&lt;/a&gt;) uses short &quot;floating point&quot;
   numbers to indicate the relative importance (&quot;weight&quot;) of various
   negotiable parameters.  A weight is normalized to a real number in
   the range 0 through 1, where 0 is the minimum and 1 the maximum
   value. If a parameter has a quality value of 0, then content with
   this parameter is `not acceptable' for the client. HTTP/1.1
   applications MUST NOT generate more than three digits after the
   decimal point. User configuration of these values SHOULD also be
   limited in this fashion.

       qvalue         = ( &quot;0&quot; [ &quot;.&quot; 0*3DIGIT ] )
                      | ( &quot;1&quot; [ &quot;.&quot; 0*3(&quot;0&quot;) ] )

   &quot;Quality values&quot; is a misnomer, since these values merely represent
   relative degradation in desired quality.</source>
          <target state="translated">HTTP 컨텐츠 협상 ( &lt;a href=&quot;#section-12&quot;&gt;섹션 12&lt;/a&gt; )은 짧은 &quot;부동 소수점&quot;숫자를 사용하여 다양한 협상 가능한 매개 변수의 상대적 중요도 ( &quot;무게&quot;)를 나타냅니다. 가중치는 0에서 1 사이의 실수로 정규화되며, 여기서 0은 최소값이고 1은 최대 값입니다. 매개 변수의 품질 값이 0이면이 매개 변수를 가진 컨텐츠는 클라이언트에 대해 '허용되지 않습니다'. HTTP / 1.1 응용 프로그램은 소수점 뒤에 세 자리 이상을 생성해서는 안됩니다 (MUST NOT). 이러한 값의 사용자 구성도이 방식으로 제한해야합니다. qvalue = ( &quot;0&quot;[ &quot;.&quot;0 * 3DIGIT]) | ( &quot;1&quot;[ &quot;.&quot;0 * 3 ( &quot;0&quot;)]) &quot;품질 값&quot;은 잘못된 이름입니다.이들 값은 단지 원하는 품질에서의 상대적 열화를 나타 내기 때문이다.</target>
        </trans-unit>
        <trans-unit id="7b89b9e50093443d13f8d95c6b289f93dce89159" translate="yes" xml:space="preserve">
          <source>HTTP cookie</source>
          <target state="translated">HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="49bceea2f43dd4ce87f70babc4ac786f9373fb9b" translate="yes" xml:space="preserve">
          <source>HTTP cookie on Wikipedia</source>
          <target state="translated">Wikipedia의 HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="d913ef28f4b5c9d1334d825b1c91fdfabe426299" translate="yes" xml:space="preserve">
          <source>HTTP cookies</source>
          <target state="translated">HTTP 쿠키</target>
        </trans-unit>
        <trans-unit id="d449bb5c3598a5a64c8ae94493892b59bad9bafe" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;a href=&quot;methods&quot;&gt;request methods&lt;/a&gt; indicating the desired action to be performed upon a resource. Although they can also be nouns, these requests methods are sometimes referred as HTTP verbs. The most common requests are &lt;code&gt;GET&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt;:</source>
          <target state="translated">HTTP는 자원에 대해 수행 할 원하는 조치를 나타내는 &lt;a href=&quot;methods&quot;&gt;요청 메소드&lt;/a&gt; 세트를 정의 합니다. 또한 명사 일 수도 있지만 이러한 요청 메소드를 HTTP 동사라고도합니다. 가장 일반적인 요청은 &lt;code&gt;GET&lt;/code&gt; 및 &lt;code&gt;POST&lt;/code&gt; 입니다 .</target>
        </trans-unit>
        <trans-unit id="30ad447e6db12c17885856bdde1f5bd54513584a" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTP는 주어진 자원에 대해 수행 할 원하는 조치를 표시 &lt;strong&gt;하기&lt;/strong&gt; 위해 &lt;strong&gt;요청 메소드&lt;/strong&gt; 세트를 정의 합니다. 그것들은 또한 명사 일 수 있지만, 이러한 요청 메소드는 때때로 &lt;em&gt;HTTP 동사&lt;/em&gt; 라고도 합니다. 그들 각각은 서로 다른 의미를 구현하지만, 몇 가지 공통적 인 특징은 그 그룹에 의해 공유 : 할 수 있습니다 예를 들어, 요청 방법 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;나무 등&lt;/a&gt; , 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;캐시&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98d83c5b67ede465177980174dae53107f9fcd36" translate="yes" xml:space="preserve">
          <source>HTTP defines a set of &lt;strong&gt;request methods&lt;/strong&gt; to indicate the desired action to be performed for a given resource. Although they can also be nouns, these request methods are sometimes referred to as &lt;em&gt;HTTP verbs&lt;/em&gt;. Each of them implements a different semantic, but some common features are shared by a group of them: e.g. a request method can be &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;cacheable&lt;/a&gt;.</source>
          <target state="translated">HTTP는 주어진 리소스에 대해 수행 할 원하는 작업을 나타내는 &lt;strong&gt;요청 메서드&lt;/strong&gt; 집합을 정의 합니다. 명사 일 수도 있지만 이러한 요청 메서드를 &lt;em&gt;HTTP 동사&lt;/em&gt; 라고도합니다 . 그들 각각은 서로 다른 의미를 구현하지만, 몇 가지 공통적 인 특징은 그 그룹에 의해 공유 : 할 수 있습니다 예를 들어, 요청 방법 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;나무 등&lt;/a&gt; , 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/cacheable&quot;&gt;캐시&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b3823907860c4fbcb228c6adf9d8a7633b5e997" translate="yes" xml:space="preserve">
          <source>HTTP defines many headers that can be used in WebDAV requests and
   responses.  Not all of these are appropriate in all situations and
   some interactions may be undefined.  Note that HTTP 1.1 requires the
   Date header in all responses if possible (see &lt;a href=&quot;#section-14.18&quot;&gt;Section 14.18&lt;/a&gt;,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]).

   The server MUST do authorization checks before checking any HTTP
   conditional header.</source>
          <target state="translated">HTTP는 WebDAV 요청 및 응답에 사용할 수있는 많은 헤더를 정의합니다. 이러한 상황이 모든 상황에 적합한 것은 아니며 일부 상호 작용이 정의되어 있지 않을 수 있습니다. HTTP 1.1은 가능한 경우 모든 응답에 Date 헤더가 필요합니다 ( &lt;a href=&quot;#section-14.18&quot;&gt;14.18 절&lt;/a&gt; , [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 참조). 서버는 HTTP 조건부 헤더를 확인하기 전에 권한 확인을 수행해야합니다.</target>
        </trans-unit>
        <trans-unit id="8a133de8128e059a1d8a37cda84e730f09f27e2d" translate="yes" xml:space="preserve">
          <source>HTTP defines the Location header to indicate a preferred URL for the
   resource that was addressed in the Request-URI (e.g., in response to
   successful PUT requests or in redirect responses).  However, use of
   this header creates ambiguity when there are URLs in the body of the
   response, as with Multi-Status.  Thus, use of the Location header
   with the Multi-Status response is intentionally undefined.</source>
          <target state="translated">HTTP는 Location 헤더를 정의하여 Request-URI에서 주소가 지정된 리소스에 대한 선호 URL을 나타냅니다 (예 : 성공적인 PUT 요청에 대한 응답 또는 리디렉션 응답). 그러나이 헤더를 사용하면 다중 상태와 같이 응답 본문에 URL이있을 때 모호성이 생깁니다. 따라서 다중 상태 응답과 함께 위치 헤더를 사용하는 것은 의도적으로 정의되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3a87bd3891b7e9c3d201f6e5eb6fa13e129baa69" translate="yes" xml:space="preserve">
          <source>HTTP didn't stop evolving upon the release of HTTP/2. Like with HTTP/1.x previously, HTTP's extensibility is still being used to add new features. Notably, we can cite new extensions of the HTTP protocol appearing in 2016:</source>
          <target state="translated">HTTP / 2가 릴리스 될 때 HTTP의 발전이 멈추지 않았습니다. HTTP / 1.x와 마찬가지로 HTTP의 확장 성은 여전히 ​​새로운 기능을 추가하는 데 사용되고 있습니다. 특히 2016 년에 등장하는 새로운 HTTP 프로토콜 확장을 인용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b88a5eff6f325b12d08c43e0aa22f6a60e181d3d" translate="yes" xml:space="preserve">
          <source>HTTP does not define a specific mechanism for ensuring message
   integrity, instead relying on the error-detection ability of
   underlying transport protocols and the use of length or
   chunk-delimited framing to detect completeness.  Additional integrity
   mechanisms, such as hash functions or digital signatures applied to
   the content, can be selectively added to messages via extensible 

   metadata header fields.  Historically, the lack of a single integrity
   mechanism has been justified by the informal nature of most HTTP
   communication.  However, the prevalence of HTTP as an information
   access mechanism has resulted in its increasing use within
   environments where verification of message integrity is crucial.

   User agents are encouraged to implement configurable means for
   detecting and reporting failures of message integrity such that those
   means can be enabled within environments for which integrity is
   necessary.  For example, a browser being used to view medical history
   or drug interaction information needs to indicate to the user when
   such information is detected by the protocol to be incomplete,
   expired, or corrupted during transfer.  Such mechanisms might be
   selectively enabled via user agent extensions or the presence of
   message integrity metadata in a response.  At a minimum, user agents
   ought to provide some indication that allows a user to distinguish
   between a complete and incomplete response message (&lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;) when
   such verification is desired.</source>
          <target state="translated">HTTP는 메시지 무결성을 보장하기위한 특정 메커니즘을 정의하지 않고 기본 전송 프로토콜의 오류 감지 기능과 길이 또는 청크로 구분 된 프레임을 사용하여 완전성을 감지합니다. 컨텐츠에 적용된 해시 함수 또는 디지털 서명과 같은 추가 무결성 메커니즘은 확장 가능한 메타 데이터 헤더 필드를 통해 메시지에 선택적으로 추가 될 수 있습니다. 역사적으로 단일 무결성 메커니즘의 부재는 대부분의 HTTP 통신의 비공식적 특성에 의해 정당화되었습니다. 그러나 정보 액세스 메커니즘으로서의 HTTP 보급으로 인해 메시지 무결성 검증이 중요한 환경에서 사용이 증가하고 있습니다.사용자 에이전트는 메시지 무결성 오류를 감지하고보고하기 위해 구성 가능한 수단을 구현하여 무결성이 필요한 환경 내에서 이러한 수단을 사용할 수 있도록하는 것이 좋습니다. 예를 들어, 병력 또는 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 그러한 정보가 프로토콜에 의해 전송 중에 불완전하거나 만료 또는 손상 될 때이를 사용자에게 표시해야합니다. 이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 몇 가지 표시를 제공해야합니다 (예를 들어, 병력 또는 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 그러한 정보가 프로토콜에 의해 전송 중에 불완전하거나 만료 또는 손상 될 때이를 사용자에게 표시해야합니다. 이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 몇 가지 표시를 제공해야합니다 (예를 들어, 병력 또는 약물 상호 작용 정보를 보는 데 사용되는 브라우저는 그러한 정보가 프로토콜에 의해 전송 중에 불완전하거나 만료 또는 손상 될 때이를 사용자에게 표시해야합니다. 이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 몇 가지 표시를 제공해야합니다 (이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 몇 가지 표시를 제공해야합니다 (이러한 메커니즘은 사용자 에이전트 확장 또는 응답에 메시지 무결성 메타 데이터의 존재를 통해 선택적으로 활성화 될 수 있습니다. 최소한 사용자 에이전트는 사용자가 완전한 응답 메시지와 불완전한 응답 메시지를 구별 할 수있는 몇 가지 표시를 제공해야합니다 (&lt;a href=&quot;#section-3.4&quot;&gt;&lt;/a&gt;그러한 검증이 필요한 경우 섹션 3.4 ).</target>
        </trans-unit>
        <trans-unit id="87d2894d742e24a75af2f1ab57c0987684b7ec4b" translate="yes" xml:space="preserve">
          <source>HTTP does not include a request identifier for associating a given
   request message with its corresponding one or more response messages.
   Hence, it relies on the order of response arrival to correspond
   exactly to the order in which requests are made on the same
   connection.  More than one response message per request only occurs
   when one or more informational responses (1xx, see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;Section&amp;nbsp;6.2 of
   [RFC7231]&lt;/a&gt;) precede a final response to the same request. 

   A client that has more than one outstanding request on a connection
   MUST maintain a list of outstanding requests in the order sent and
   MUST associate each received response message on that connection to
   the highest ordered request that has not yet received a final
   (non-1xx) response.</source>
          <target state="translated">HTTP는 주어진 요청 메시지를 해당하는 하나 이상의 응답 메시지와 연관시키기위한 요청 식별자를 포함하지 않습니다. 따라서 동일한 연결에서 요청이 이루어진 순서와 정확히 일치하도록 응답 도착 순서에 의존합니다. 요청 당 하나 이상의 응답 메시지는 하나 이상의 정보 응답 (1xx, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.2&quot;&gt;[RFC7231]의 섹션 6.2&lt;/a&gt; 참조 )이 동일한 요청에 대한 최종 응답 앞에 오는 경우에만 발생합니다 . 연결에서 미해결 요청이 둘 이상인 클라이언트는 전송 된 미해결 요청 목록을 전송 된 순서대로 유지해야하며 해당 연결에서 수신 된 각 응답 메시지를 아직 최종 (1xx 아님)을받지 않은 최상위 주문 요청과 연결해야합니다. 응답.</target>
        </trans-unit>
        <trans-unit id="125fe50c360004e5dcd111f8af56cce35d120574" translate="yes" xml:space="preserve">
          <source>HTTP does not place a predefined limit on the length of each header
   field or on the length of the header section as a whole, as described
   in &lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;.  Various ad hoc limitations on individual header
   field length are found in practice, often depending on the specific
   field semantics.

   A server that receives a request header field, or set of fields,
   larger than it wishes to process MUST respond with an appropriate 4xx
   (Client Error) status code.  Ignoring such header fields would
   increase the server's vulnerability to request smuggling attacks
   (&lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   A client MAY discard or truncate received header fields that are
   larger than the client wishes to process if the field semantics are
   such that the dropped value(s) can be safely ignored without changing
   the message framing or response semantics.</source>
          <target state="translated">HTTP는 &lt;a href=&quot;#section-2.5&quot;&gt;2.5 절&lt;/a&gt; 에서 설명한 것처럼 각 헤더 필드의 길이 또는 헤더 섹션의 길이에 미리 정의 된 제한을 두지 않습니다 . 개별 헤더 필드 길이에 대한 다양한 임시 제한은 실제로 특정 필드 의미에 따라 실제로 발견됩니다. 처리하고자하는 것보다 큰 요청 헤더 필드 또는 필드 세트를 수신하는 서버는 반드시 적절한 4xx (클라이언트 오류) 상태 코드로 응답해야합니다. 이러한 헤더 필드를 무시하면 밀수 공격을 요청하는 서버의 취약성이 증가합니다 ( &lt;a href=&quot;#section-9.5&quot;&gt;9.5 절&lt;/a&gt;). 필드 시맨틱이 메시지 프레이밍 또는 응답 시맨틱을 변경하지 않고 드롭 된 값 (들)을 안전하게 무시할 수있는 경우, 클라이언트는 처리하고자하는 것보다 큰 수신 된 헤더 필드를 폐기 또는 절단 할 수있다 (MAY).</target>
        </trans-unit>
        <trans-unit id="7af78e2e7197dc15cd8324e0e4f1f29b3b33d7e4" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding (CTE) field of &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways from MIME-compliant protocols to HTTP MUST
   remove any non-identity CTE (&quot;quoted-printable&quot; or &quot;base64&quot;) encoding
   prior to delivering the response message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe 

   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway SHOULD label the data with an appropriate
   Content-Transfer-Encoding if doing so will improve the likelihood of
   safe transport over the destination protocol.</source>
          <target state="translated">HTTP는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt; 의 CTE (Content-Transfer-Encoding) 필드를 사용하지 않습니다 . MIME 호환 프로토콜에서 HTTP 로의 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 ID가 아닌 CTE ( &quot;인쇄 가능&quot;또는 &quot;base64&quot;) 인코딩을 제거해야합니다. HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을위한 올바른 형식 및 인코딩인지 확인해야합니다. 여기서 &quot;안전한 전송&quot;은 사용중인 프로토콜의 한계에 의해 정의됩니다. 그러한 프록시 또는 게이트웨이는 데이터를 적절한 콘텐츠 전송 인코딩으로 라벨링해야 목적지 프로토콜을 통한 안전한 전송 가능성을 향상시켜야한다.</target>
        </trans-unit>
        <trans-unit id="983fa6dde64a744fecec4d6eaeb6ead62114677a" translate="yes" xml:space="preserve">
          <source>HTTP does not use the Content-Transfer-Encoding field of MIME.
   Proxies and gateways from MIME-compliant protocols to HTTP need to
   remove any Content-Transfer-Encoding prior to delivering the response
   message to an HTTP client.

   Proxies and gateways from HTTP to MIME-compliant protocols are
   responsible for ensuring that the message is in the correct format
   and encoding for safe transport on that protocol, where &quot;safe
   transport&quot; is defined by the limitations of the protocol being used.
   Such a proxy or gateway ought to transform and label the data with an
   appropriate Content-Transfer-Encoding if doing so will improve the
   likelihood of safe transport over the destination protocol.</source>
          <target state="translated">HTTP는 MIME의 Content-Transfer-Encoding 필드를 사용하지 않습니다. MIME 호환 프로토콜에서 HTTP 로의 프록시 및 게이트웨이는 응답 메시지를 HTTP 클라이언트에 전달하기 전에 모든 컨텐츠 전송 인코딩을 제거해야합니다. HTTP에서 MIME 호환 프로토콜로의 프록시 및 게이트웨이는 메시지가 해당 프로토콜의 안전한 전송을위한 올바른 형식 및 인코딩인지 확인해야합니다. 여기서 &quot;안전한 전송&quot;은 사용중인 프로토콜의 한계에 의해 정의됩니다. 이러한 프록시 또는 게이트웨이는 데이터를 적절한 Content-Transfer-Encoding으로 변환하고 레이블을 지정해야 목적지 프로토콜을 통한 안전한 전송 가능성이 향상됩니다.</target>
        </trans-unit>
        <trans-unit id="b9046bf180bf7e78db825b7e37fce06636dac2f9" translate="yes" xml:space="preserve">
          <source>HTTP enables the use of intermediaries to satisfy requests through a
   chain of connections.  There are three common forms of HTTP
   intermediary: proxy, gateway, and tunnel.  In some cases, a single
   intermediary might act as an origin server, proxy, gateway, or
   tunnel, switching behavior based on the nature of each request.

            &amp;gt;             &amp;gt;             &amp;gt;             &amp;gt;
       UA =========== A =========== B =========== C =========== O
                  &amp;lt;             &amp;lt;             &amp;lt;             &amp;lt;

   The figure above shows three intermediaries (A, B, and C) between the
   user agent and origin server.  A request or response message that
   travels the whole chain will pass through four separate connections.
   Some HTTP communication options might apply only to the connection
   with the nearest, non-tunnel neighbor, only to the endpoints of the
   chain, or to all connections along the chain.  Although the diagram
   is linear, each participant might be engaged in multiple,
   simultaneous communications.  For example, B might be receiving
   requests from many clients other than A, and/or forwarding requests
   to servers other than C, at the same time that it is handling A's 

   request.  Likewise, later requests might be sent through a different
   path of connections, often based on dynamic configuration for load
   balancing.

   The terms &quot;upstream&quot; and &quot;downstream&quot; are used to describe
   directional requirements in relation to the message flow: all
   messages flow from upstream to downstream.  The terms &quot;inbound&quot; and
   &quot;outbound&quot; are used to describe directional requirements in relation
   to the request route: &quot;inbound&quot; means toward the origin server and
   &quot;outbound&quot; means toward the user agent.

   A &quot;proxy&quot; is a message-forwarding agent that is selected by the
   client, usually via local configuration rules, to receive requests
   for some type(s) of absolute URI and attempt to satisfy those
   requests via translation through the HTTP interface.  Some
   translations are minimal, such as for proxy requests for &quot;http&quot; URIs,
   whereas other requests might require translation to and from entirely
   different application-level protocols.  Proxies are often used to
   group an organization's HTTP requests through a common intermediary
   for the sake of security, annotation services, or shared caching.
   Some proxies are designed to apply transformations to selected
   messages or payloads while they are being forwarded, as described in
   &lt;a href=&quot;#section-5.7.2&quot;&gt;Section 5.7.2&lt;/a&gt;.

   A &quot;gateway&quot; (a.k.a. &quot;reverse proxy&quot;) is an intermediary that acts as
   an origin server for the outbound connection but translates received
   requests and forwards them inbound to another server or servers.
   Gateways are often used to encapsulate legacy or untrusted
   information services, to improve server performance through
   &quot;accelerator&quot; caching, and to enable partitioning or load balancing
   of HTTP services across multiple machines.

   All HTTP requirements applicable to an origin server also apply to
   the outbound communication of a gateway.  A gateway communicates with
   inbound servers using any protocol that it desires, including private
   extensions to HTTP that are outside the scope of this specification.
   However, an HTTP-to-HTTP gateway that wishes to interoperate with
   third-party HTTP servers ought to conform to user agent requirements
   on the gateway's inbound connection.

   A &quot;tunnel&quot; acts as a blind relay between two connections without
   changing the messages.  Once active, a tunnel is not considered a
   party to the HTTP communication, though the tunnel might have been
   initiated by an HTTP request.  A tunnel ceases to exist when both
   ends of the relayed connection are closed.  Tunnels are used to
   extend a virtual connection through an intermediary, such as when
   Transport Layer Security (TLS, [&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;]) is used to establish
   confidential communication through a shared firewall proxy. 

   The above categories for intermediary only consider those acting as
   participants in the HTTP communication.  There are also
   intermediaries that can act on lower layers of the network protocol
   stack, filtering or redirecting HTTP traffic without the knowledge or
   permission of message senders.  Network intermediaries are
   indistinguishable (at a protocol level) from a man-in-the-middle
   attack, often introducing security flaws or interoperability problems
   due to mistakenly violating HTTP semantics.

   For example, an &quot;interception proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt;] (also commonly known
   as a &quot;transparent proxy&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] or &quot;captive portal&quot;) differs from
   an HTTP proxy because it is not selected by the client.  Instead, an
   interception proxy filters or redirects outgoing TCP port 80 packets
   (and occasionally other common port traffic).  Interception proxies
   are commonly found on public network access points, as a means of
   enforcing account subscription prior to allowing use of non-local
   Internet services, and within corporate firewalls to enforce network
   usage policies.

   HTTP is defined as a stateless protocol, meaning that each request
   message can be understood in isolation.  Many implementations depend
   on HTTP's stateless design in order to reuse proxied connections or
   dynamically load balance requests across multiple servers.  Hence, a
   server MUST NOT assume that two requests on the same connection are
   from the same user agent unless the connection is secured and
   specific to that agent.  Some non-standard HTTP extensions (e.g.,
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt;]) have been known to violate this requirement, resulting in
   security and interoperability problems.</source>
          <target state="translated">HTTP를 사용하면 중개자가 연결 체인을 통해 요청을 충족시킬 수 있습니다. HTTP 중개에는 프록시, 게이트웨이 및 터널의 세 가지 일반적인 형태가 있습니다. 경우에 따라 단일 중개자가 오리진 서버, 프록시, 게이트웨이 또는 터널로 작동하여 각 요청의 특성에 따라 동작을 전환 할 수 있습니다. &amp;gt;&amp;gt;&amp;gt;&amp;gt; UA =========== A =========== B =========== C ========== == O &amp;lt;&amp;lt;&amp;lt;&amp;lt;위의 그림은 사용자 에이전트와 오리진 서버 사이의 세 가지 중개자 (A, B 및 C)를 보여줍니다. 전체 체인을 이동하는 요청 또는 응답 메시지는 4 개의 개별 연결을 통과합니다. 일부 HTTP 통신 옵션은 가장 가까운 연결,비 터널 인접, 체인의 끝점 또는 체인을 따라 모든 연결에. 다이어그램은 선형이지만 각 참가자는 여러 개의 동시 통신에 참여할 수 있습니다. 예를 들어, B가 A의 요청을 처리하는 동시에 A 이외의 많은 클라이언트로부터 요청을 수신하거나 C 이외의 서버로 요청을 전달할 수 있습니다. 마찬가지로 나중에 요청은 종종로드 밸런싱을위한 동적 구성을 기반으로 다른 연결 경로를 통해 전송 될 수 있습니다. &quot;업스트림&quot;및 &quot;다운 스트림&quot;이라는 용어는 메시지 흐름과 관련하여 방향 요구 사항을 설명하는 데 사용됩니다. 모든 메시지는 업스트림에서 다운 스트림으로 흐릅니다. &quot;인바운드&quot;및 &quot;아웃 바운드&quot;라는 용어요청 경로와 관련하여 방향 요구 사항을 설명하는 데 사용됩니다. &quot;인바운드&quot;는 오리진 서버를 의미하고 &quot;아웃 바운드&quot;는 사용자 에이전트를 의미합니다. &quot;프록시&quot;는 클라이언트가 일반적으로 로컬 구성 규칙을 통해 선택하여 절대 URI의 일부 유형에 대한 요청을 수신하고 HTTP 인터페이스를 통한 변환을 통해 해당 요청을 충족 시키려고하는 메시지 전달 에이전트입니다. &quot;http&quot;URI에 대한 프록시 요청과 같은 일부 변환은 최소 수준이지만 다른 요청은 완전히 다른 응용 프로그램 수준 프로토콜과의 변환이 필요할 수 있습니다. 프록시는 종종 보안, 주석 서비스 또는 공유 캐싱을 위해 공통 중개자를 통해 조직의 HTTP 요청을 그룹화하는 데 사용됩니다.일부 프록시는 다음에 설명 된대로 전달되는 동안 선택된 메시지 또는 페이로드에 변환을 적용하도록 설계되었습니다. &lt;a href=&quot;#section-5.7.2&quot;&gt;섹션 5.7.2&lt;/a&gt;. &quot;게이트웨이&quot;(일명 &quot;리버스 프록시&quot;)는 아웃 바운드 연결을위한 오리진 서버 역할을하지만 수신 된 요청을 변환하고 인바운드를 다른 서버로 전달하는 중개자입니다. 게이트웨이는 종종 레거시 또는 신뢰할 수없는 정보 서비스를 캡슐화하고, &quot;가속기&quot;캐싱을 통해 서버 성능을 향상시키고, 여러 시스템에서 HTTP 서비스의 분할 또는로드 밸런싱을 가능하게하는 데 사용됩니다. 오리진 서버에 적용 가능한 모든 HTTP 요구 사항은 게이트웨이의 아웃 바운드 통신에도 적용됩니다. 게이트웨이는이 사양의 범위를 벗어난 HTTP에 대한 개인 확장을 포함하여 원하는 프로토콜을 사용하여 인바운드 서버와 통신합니다. 하나,타사 HTTP 서버와 상호 운용하려는 HTTP-to-HTTP 게이트웨이는 게이트웨이의 인바운드 연결에 대한 사용자 에이전트 요구 사항을 준수해야합니다. &quot;터널&quot;은 메시지를 변경하지 않고 두 연결 간의 블라인드 릴레이 역할을합니다. 터널이 HTTP 요청에 의해 시작되었을 수 있지만 터널이 활성화되면 HTTP 통신의 당사자로 간주되지 않습니다. 중계 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. TLS (Transport Layer Security)와 같은 중개자를 통해 가상 연결을 확장하는 데 터널이 사용됩니다.터널은 HTTP 요청에 의해 시작되었을 수 있지만 터널은 HTTP 통신의 당사자로 간주되지 않습니다. 중계 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. TLS (Transport Layer Security)와 같은 중개자를 통해 가상 연결을 확장하는 데 터널이 사용됩니다.터널은 HTTP 요청에 의해 시작되었을 수 있지만 터널은 HTTP 통신의 당사자로 간주되지 않습니다. 중계 연결의 양쪽 끝이 닫히면 터널이 존재하지 않습니다. TLS (Transport Layer Security)와 같은 중개자를 통해 가상 연결을 확장하는 데 터널이 사용됩니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt; ])는 공유 방화벽 프록시를 통해 기밀 통신을 설정하는 데 사용됩니다. 중개자에 대한 위의 범주는 HTTP 통신의 참여자 역할 만 고려합니다. 또한 메시지 발신자의 지식이나 허가없이 HTTP 트래픽을 필터링하거나 리디렉션하여 네트워크 프로토콜 스택의 하위 계층에서 작동 할 수있는 중개자가 있습니다. 네트워크 중개자는 중간자 (man-in-the-middle) 공격과 구별 할 수 없으며 (프로토콜 수준에서) HTTP 의미를 잘못 위반하여 보안 결함이나 상호 운용성 문제가 발생하는 경우가 많습니다. 예를 들어 &quot;차단 프록시&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC3040&lt;/a&gt; ] (일반적으로 &quot;투명 프록시&quot;라고도 함 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC1919&lt;/a&gt;] 또는 &quot;캡 티브 포털&quot;)은 클라이언트가 선택하지 않으므로 HTTP 프록시와 다릅니다. 대신 인터 셉션 프록시는 발신 TCP 포트 80 패킷 (및 때때로 다른 공통 포트 트래픽)을 필터링하거나 리디렉션합니다. 가로 채기 프록시는 일반적으로 공용 네트워크 액세스 지점에서 로컬이 아닌 인터넷 서비스를 사용하기 전에 계정 가입을 시행하고 회사 방화벽 내에서 네트워크 사용 정책을 시행하는 수단으로 사용됩니다. HTTP는 상태 비 저장 프로토콜로 정의되므로 각 요청 메시지를 개별적으로 이해할 수 있습니다. 많은 구현은 프록시 연결을 재사용하거나 여러 서버에서 요청을 동적으로로드 밸런스하기 위해 HTTP의 상태 비 저장 디자인에 의존합니다. 그 후,서버는 연결이 보안되어 있고 해당 에이전트에 특정하지 않는 한 동일한 연결의 두 요청이 동일한 사용자 에이전트의 요청이라고 가정해서는 안됩니다 (MUST NOT). 비표준 HTTP 확장 (예 : [&lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC4559&lt;/a&gt; ])는이 요구 사항을 위반하여 보안 및 상호 운용성 문제를 일으키는 것으로 알려져 있습니다.</target>
        </trans-unit>
        <trans-unit id="8db8a2b5c25cf2c27eaf8a47b284cc3768fbc846" translate="yes" xml:space="preserve">
          <source>HTTP flow</source>
          <target state="translated">HTTP 흐름</target>
        </trans-unit>
        <trans-unit id="ef8491af63ac960b4c3bb2e915780d4330bd99fe" translate="yes" xml:space="preserve">
          <source>HTTP frames are now transparent to Web developers. This is an additional step in HTTP/2, between HTTP/1.1 messages and the underlying transport protocol. No changes are needed in the APIs used by Web developers to utilize HTTP frames; when available in both the browser and the server, HTTP/2 is switched on and used.</source>
          <target state="translated">HTTP 프레임은 이제 웹 개발자에게 투명합니다. 이것은 HTTP / 1.1 메시지와 기본 전송 프로토콜 사이의 HTTP / 2의 추가 단계입니다. 웹 개발자가 HTTP 프레임을 사용하는 데 사용하는 API에는 변경이 필요하지 않습니다. 브라우저와 서버 모두에서 사용 가능한 경우 HTTP / 2가 켜져 서 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="c4d23b3cd8874c5cafac5c54211af2245465e64f" translate="yes" xml:space="preserve">
          <source>HTTP has a concept of &lt;em&gt;conditional requests&lt;/em&gt;, where the result, and even the success of a request, can be changed by comparing the affected resources with the value of a &lt;em&gt;validator&lt;/em&gt;. Such requests can be useful to validate the content of a cache, and sparing a useless control, to verify the integrity of a document, like when resuming a download, or when preventing to lose updates when uploading or modifying a document on the server.</source>
          <target state="translated">HTTP에는 &lt;em&gt;조건부 요청&lt;/em&gt; 의 개념이 있으며, 영향을받는 자원을 &lt;em&gt;유효성 검증기&lt;/em&gt; 의 값과 비교하여 결과 및 요청의 성공도 변경할 수 있습니다 . 이러한 요청은 캐시 컨텐츠의 유효성을 검사하고 쓸모없는 컨트롤을 절약하여 다운로드를 다시 시작할 때와 같이 또는 서버에서 문서를 업로드하거나 수정할 때 업데이트가 손실되지 않도록 할 때와 같이 문서의 무결성을 확인하는 데 유용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d453645149af5aacd6ac81b6f3d3ee73f00f71ff" translate="yes" xml:space="preserve">
          <source>HTTP has been in use since 1990.  The first version, later referred
   to as HTTP/0.9, was a simple protocol for hypertext data transfer
   across the Internet, using only a single request method (GET) and no
   metadata.  HTTP/1.0, as defined by [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;], added a range of
   request methods and MIME-like messaging, allowing for metadata to be
   transferred and modifiers placed on the request/response semantics.
   However, HTTP/1.0 did not sufficiently take into consideration the
   effects of hierarchical proxies, caching, the need for persistent
   connections, or name-based virtual hosts.  The proliferation of
   incompletely implemented applications calling themselves &quot;HTTP/1.0&quot;
   further necessitated a protocol version change in order for two
   communicating applications to determine each other's true
   capabilities.

   HTTP/1.1 remains compatible with HTTP/1.0 by including more stringent
   requirements that enable reliable implementations, adding only those
   features that can either be safely ignored by an HTTP/1.0 recipient
   or only be sent when communicating with a party advertising
   conformance with HTTP/1.1.

   HTTP/1.1 has been designed to make supporting previous versions easy.
   A general-purpose HTTP/1.1 server ought to be able to understand any
   valid request in the format of HTTP/1.0, responding appropriately
   with an HTTP/1.1 message that only uses features understood (or
   safely ignored) by HTTP/1.0 clients.  Likewise, an HTTP/1.1 client
   can be expected to understand any valid HTTP/1.0 response.

   Since HTTP/0.9 did not support header fields in a request, there is
   no mechanism for it to support name-based virtual hosts (selection of
   resource by inspection of the Host header field).  Any server that
   implements name-based virtual hosts ought to disable support for
   HTTP/0.9.  Most requests that appear to be HTTP/0.9 are, in fact,
   badly constructed HTTP/1.x requests caused by a client failing to
   properly encode the request-target.</source>
          <target state="translated">HTTP는 1990 년부터 사용되어 왔습니다. 나중에 HTTP / 0.9라고하는 첫 번째 버전은 메타 데이터없이 단일 요청 방법 (GET) 만 사용하여 인터넷을 통한 하이퍼 텍스트 데이터 전송을위한 간단한 프로토콜이었습니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945에서&lt;/a&gt; 정의한 HTTP / 1.0], 다양한 요청 방법 및 MIME 유사 메시징을 추가하여 메타 데이터를 전송하고 수정자가 요청 / 응답 시맨틱에 배치되도록했습니다. 그러나 HTTP / 1.0은 계층 적 프록시, 캐싱, 지속적인 연결 필요성 또는 이름 기반 가상 호스트의 영향을 충분히 고려하지 않았습니다. &quot;HTTP / 1.0&quot;이라고 부르는 불완전하게 구현 된 응용 프로그램의 확산으로 인해 두 통신 응용 프로그램이 서로의 실제 기능을 결정하기 위해 프로토콜 버전 변경이 더 필요했습니다. HTTP / 1.1은 안정적인 구현을 가능하게하는보다 엄격한 요구 사항을 포함하여 HTTP / 1.0과 호환되는 상태를 유지하며 HTTP / 1에서 안전하게 무시할 수있는 기능 만 추가합니다.수신자는 0 명이거나 HTTP / 1.1로 당사자 광고 준수와 통신 할 때만 전송됩니다. HTTP / 1.1은 이전 버전을 쉽게 지원하도록 설계되었습니다. 범용 HTTP / 1.1 서버는 HTTP / 1.0 형식의 유효한 요청을 이해할 수 있어야하며 HTTP / 1.0 클라이언트가 이해하거나 안전하게 무시하는 기능 만 사용하는 HTTP / 1.1 메시지로 적절하게 응답해야합니다. 마찬가지로, HTTP / 1.1 클라이언트는 유효한 HTTP / 1.0 응답을 이해해야합니다. HTTP / 0.9는 요청에서 헤더 필드를 지원하지 않기 때문에 이름 기반 가상 호스트를 지원하는 메커니즘이 없습니다 (호스트 헤더 필드를 검사하여 리소스 선택). 이름 기반 가상 호스트를 구현하는 모든 서버는 HTTP / 0.9 지원을 비활성화해야합니다. HTTP / 0 인 것으로 보이는 대부분의 요청.실제로,도 9는 클라이언트가 요청 타겟을 적절히 인코딩하지 못함으로써 야기 된 잘못 구성된 HTTP / 1.x 요청이다.</target>
        </trans-unit>
        <trans-unit id="d9e77166a8c6244ca9fbbd6e6d1edc2dc7a40b2e" translate="yes" xml:space="preserve">
          <source>HTTP has the ability to host programs that are executed on client
   machines.  These programs can take many forms including Web scripts,
   executables, plug-in modules, and macros in documents.  WebDAV does
   not change any of the security concerns around these programs, yet
   often WebDAV is used in contexts where a wide range of users can
   publish documents on a server.  The server might not have a close 

   trust relationship with the author that is publishing the document.
   Servers that allow clients to publish arbitrary content can usefully
   implement precautions to check that content published to the server
   is not harmful to other clients.  Servers could do this by techniques
   such as restricting the types of content that is allowed to be
   published and running virus and malware detection software on
   published content.  Servers can also mitigate the risk by having
   appropriate access restriction and authentication of users that are
   allowed to publish content to the server.</source>
          <target state="translated">HTTP는 클라이언트 시스템에서 실행되는 프로그램을 호스팅 할 수 있습니다. 이러한 프로그램은 웹 스크립트, 실행 파일, 플러그인 모듈 및 문서의 매크로를 포함하여 많은 형태를 취할 수 있습니다. WebDAV는 이러한 프로그램과 관련된 보안 문제를 변경하지 않지만 WebDAV는 종종 광범위한 사용자가 서버에 문서를 게시 할 수있는 상황에서 사용됩니다. 서버가 문서를 게시하는 작성자와 밀접한 신뢰 관계를 가지고 있지 않을 수 있습니다. 클라이언트가 임의의 컨텐츠를 공개 할 수있는 서버는 서버에 공개 된 컨텐츠가 다른 클라이언트에 유해하지 않은지 확인하기 위해 예방 조치를 유용하게 구현할 수 있습니다. 서버는 게시 할 수있는 콘텐츠 유형을 제한하고 게시 된 콘텐츠에서 바이러스 및 맬웨어 탐지 소프트웨어를 실행하는 등의 기술로이를 수행 할 수 있습니다.서버는 콘텐츠를 서버에 게시 할 수있는 사용자에 대한 적절한 액세스 제한 및 인증을 통해 위험을 완화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="d67c4ad19745067f8e2d7649769ed21fc1c5ca16" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry located at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt;&amp;gt;, as defined by
   [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].</source>
          <target state="translated">HTTP 헤더 필드는 [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ]에 정의 된대로 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers&quot;&gt;http://www.iana.org/assignments/message-headers&lt;/a&gt; &amp;gt; 에있는 &quot;Message Headers&quot;레지스트리에 등록됩니다 .</target>
        </trans-unit>
        <trans-unit id="1d6d97f7196be4dd0bf90ee5372fccc2a746c5ee" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+---------------+
   | Header Field Name | Protocol | Status   | Reference     |
   +-------------------+----------+----------+---------------+
   | Connection        | http     | standard | &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;   |
   | Content-Length    | http     | standard | &lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt; |
   | Host              | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;   |
   | TE                | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;   |
   | Trailer           | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;   |
   | Transfer-Encoding | http     | standard | &lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt; |
   | Upgrade           | http     | standard | &lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;   |
   | Via               | http     | standard | &lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt; |
   +-------------------+----------+----------+---------------+

   Furthermore, the header field-name &quot;Close&quot; has been registered as
   &quot;reserved&quot;, since using that name as an HTTP header field might
   conflict with the &quot;close&quot; connection option of the Connection header
   field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Close             | http     | reserved | &lt;a href=&quot;#section-8.1&quot;&gt;Section 8.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 &quot;영구 메시지 헤더 필드 이름&quot;레지스트리가 그에 따라 업데이트됩니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ). + ------------------- + ---------- + ---------- + ------- -------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- -------- + | 연결 | http | 표준 | &lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt; | | 콘텐츠 길이 | http | 표준 | &lt;a href=&quot;#section-3.3.2&quot;&gt;섹션 3.3.2&lt;/a&gt; | | 호스트 | http | 표준 | &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4&lt;/a&gt; | | TE | http | 표준 | &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; | | 트레일러 | http | 표준 | &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt; | | 전송 인코딩 | http | 표준 | &lt;a href=&quot;#section-3.3.1&quot;&gt;섹션 3.3.1&lt;/a&gt; | | 업그레이드 | http | 표준 | &lt;a href=&quot;#section-6.7&quot;&gt;섹션 6.7&lt;/a&gt; | | 경유 | http | 표준 | &lt;a href=&quot;#section-5.7.1&quot;&gt;섹션 5.7.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- -------- + 또한 헤더 필드 이름 &quot;Close&quot;는 해당 이름을 HTTP 헤더 필드로 사용하면 Connection 헤더 필드의 &quot;close&quot;연결 옵션과 충돌 할 수 있으므로 &quot;예약 됨&quot;으로 등록되었습니다. ( &lt;a href=&quot;#section-6.1&quot;&gt;6.1 항&lt;/a&gt;). + ------------------- + ---------- + ---------- + ------- ------ + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ------ + | 닫기 | http | 예약 됨 | &lt;a href=&quot;#section-8.1&quot;&gt;섹션 8.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="66ddb22b9ea74c6c2384f567cca6126c75a248f7" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | Authorization       | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | Proxy-Authenticate  | http     | standard | &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt; |
   | Proxy-Authorization | http     | standard | &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt; |
   | WWW-Authenticate    | http     | standard | &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 &quot;영구 메시지 헤더 필드 이름&quot;레지스트리가 그에 따라 업데이트됩니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ). + --------------------- + ---------- + ---------- + ----- -------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + --------------------- + ---------- + ---------- + ----- -------- + | 인증 | http | 표준 | &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; | | 프록시 인증 | http | 표준 | &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; | | 프록시 인증 | http | 표준 | &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt;| | WWW 인증 | http | 표준 | &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="20431a45dc8eadae77ecc94ccdfbb95f3cbd8c6e" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Accept-Ranges     | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | Content-Range     | http     | standard | &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt; |
   | If-Range          | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | Range             | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음 HTTP 헤더 필드를 정의하므로 관련 레지스트리 항목이 아래 영구 등록에 따라 업데이트되었습니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ) : + ------------------- + ---------- + ---------- + ------------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ------ + | 수락 범위 | http | 표준 | &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; | | 컨텐츠 범위 | http | 표준 | &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; | | 범위 | http | 표준 | &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt;| | 범위 | http | 표준 | &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="abd476ef3b0f23a2fb0e1c507e9aa66688224abd" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;.

   This document defines the following HTTP header fields, so their
   associated registry entries have been updated according to the
   permanent registrations below (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]):

   +---------------------+----------+----------+-------------+
   | Header Field Name   | Protocol | Status   | Reference   |
   +---------------------+----------+----------+-------------+
   | ETag                | http     | standard | &lt;a href=&quot;#section-2.3&quot;&gt;Section 2.3&lt;/a&gt; |
   | If-Match            | http     | standard | &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt; |
   | If-Modified-Since   | http     | standard | &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt; |
   | If-None-Match       | http     | standard | &lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt; |
   | If-Unmodified-Since | http     | standard | &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt; |
   | Last-Modified       | http     | standard | &lt;a href=&quot;#section-2.2&quot;&gt;Section 2.2&lt;/a&gt; |
   +---------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음 HTTP 헤더 필드를 정의하므로 관련 레지스트리 항목이 아래의 영구 등록에 따라 업데이트되었습니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ) : + ------------------- -+ ---------- + ---------- + ------------- + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + --------------------- + ---------- + ---------- + ----- -------- + | ETag | http | 표준 | &lt;a href=&quot;#section-2.3&quot;&gt;섹션 2.3&lt;/a&gt; | | 일치하는 경우 | http | 표준 | &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; | | 수정 된 이후 | http | 표준 | &lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3&lt;/a&gt;| | 일치하지 않는 경우 | http | 표준 | &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt; | | 수정되지 않은 경우 | http | 표준 | &lt;a href=&quot;#section-3.4&quot;&gt;섹션 3.4&lt;/a&gt; | | 마지막 수정 | http | 표준 | &lt;a href=&quot;#section-2.2&quot;&gt;섹션 2.2&lt;/a&gt; | + --------------------- + ---------- + ---------- + ----- -------- + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="ab0fef364114802e59e987c48134f247b0ff269b" translate="yes" xml:space="preserve">
          <source>HTTP header fields are registered within the &quot;Message Headers&quot;
   registry maintained at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt;&amp;gt;. 

   This document defines the following HTTP header fields, so the
   &quot;Permanent Message Header Field Names&quot; registry has been updated
   accordingly (see [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]).

   +-------------------+----------+----------+-------------+
   | Header Field Name | Protocol | Status   | Reference   |
   +-------------------+----------+----------+-------------+
   | Age               | http     | standard | &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt; |
   | Cache-Control     | http     | standard | &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt; |
   | Expires           | http     | standard | &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; |
   | Pragma            | http     | standard | &lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt; |
   | Warning           | http     | standard | &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt; |
   +-------------------+----------+----------+-------------+

   The change controller is: &quot;IETF (iesg@ietf.org) - Internet
   Engineering Task Force&quot;.</source>
          <target state="translated">HTTP 헤더 필드는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/message-headers/&quot;&gt;http://www.iana.org/assignments/message-headers/&lt;/a&gt; &amp;gt; 에서 유지 관리되는 &quot;메시지 헤더&quot;레지스트리에 등록됩니다 . 이 문서는 다음과 같은 HTTP 헤더 필드를 정의하므로 &quot;영구 메시지 헤더 필드 이름&quot;레지스트리가 그에 따라 업데이트됩니다 ([ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] 참조 ). + ------------------- + ---------- + ---------- + ------- ------ + | 헤더 필드 이름 | 프로토콜 | 상태 | 참조 | + ------------------- + ---------- + ---------- + ------- ------ + | 나이 | http | 표준 | &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; | | 캐시 제어 | http | 표준 | &lt;a href=&quot;#section-5.2&quot;&gt;섹션 5.2&lt;/a&gt; | | 만료 | http | 표준 | &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt;| | 프라 그마 | http | 표준 | &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4&lt;/a&gt; | | 경고 | http | 표준 | &lt;a href=&quot;#section-5.5&quot;&gt;섹션 5.5&lt;/a&gt; | + ------------------- + ---------- + ---------- + ------- ------ + 변경 컨트롤러는 &quot;IETF (iesg@ietf.org)-인터넷 엔지니어링 태스크 포스&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="e44fb4fb2547d4ca031836cab9543ab18adb9840" translate="yes" xml:space="preserve">
          <source>HTTP header fields which will be present in the trailer part of chunked messages. These header fields are &lt;strong&gt;disallowed&lt;/strong&gt;:</source>
          <target state="translated">청크 된 메시지의 트레일러 부분에 표시되는 HTTP 헤더 필드입니다. 이 헤더 필드는 &lt;strong&gt;허용되지 않습니다&lt;/strong&gt; :</target>
        </trans-unit>
        <trans-unit id="c4df20b3f27418d9364765f0fd87a2e34f853b85" translate="yes" xml:space="preserve">
          <source>HTTP header fields, which include general-header (&lt;a href=&quot;#section-4.5&quot;&gt;section 4.5&lt;/a&gt;),
   request-header (&lt;a href=&quot;#section-5.3&quot;&gt;section 5.3&lt;/a&gt;), response-header (&lt;a href=&quot;#section-6.2&quot;&gt;section 6.2&lt;/a&gt;), and
   entity-header (&lt;a href=&quot;#section-7.1&quot;&gt;section 7.1&lt;/a&gt;) fields, follow the same generic format as
   that given in &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;Section&amp;nbsp;3.1 of RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. Each header field consists
   of a name followed by a colon (&quot;:&quot;) and the field value. Field names
   are case-insensitive. The field value MAY be preceded by any amount
   of LWS, though a single SP is preferred. Header fields can be
   extended over multiple lines by preceding each extra line with at
   least one SP or HT. Applications ought to follow &quot;common form&quot;, where
   one is known or indicated, when generating HTTP constructs, since
   there might exist some implementations that fail to accept anything 

   beyond the common forms.

       message-header = field-name &quot;:&quot; [ field-value ]
       field-name     = token
       field-value    = *( field-content | LWS )
       field-content  = &amp;lt;the OCTETs making up the field-value
                        and consisting of either *TEXT or combinations
                        of token, separators, and quoted-string&amp;gt;

   The field-content does not include any leading or trailing LWS:
   linear white space occurring before the first non-whitespace
   character of the field-value or after the last non-whitespace
   character of the field-value. Such leading or trailing LWS MAY be
   removed without changing the semantics of the field value. Any LWS
   that occurs between field-content MAY be replaced with a single SP
   before interpreting the field value or forwarding the message
   downstream.

   The order in which header fields with differing field names are
   received is not significant. However, it is &quot;good practice&quot; to send
   general-header fields first, followed by request-header or response-
   header fields, and ending with the entity-header fields.

   Multiple message-header fields with the same field-name MAY be
   present in a message if and only if the entire field-value for that
   header field is defined as a comma-separated list [i.e., #(values)].
   It MUST be possible to combine the multiple header fields into one
   &quot;field-name: field-value&quot; pair, without changing the semantics of the
   message, by appending each subsequent field-value to the first, each
   separated by a comma. The order in which header fields with the same
   field-name are received is therefore significant to the
   interpretation of the combined field value, and thus a proxy MUST NOT
   change the order of these field values when a message is forwarded.</source>
          <target state="translated">HTTP (일반 헤더를 포함하는 헤더 필드, &lt;a href=&quot;#section-4.5&quot;&gt;섹션 4.5&lt;/a&gt; ), 요청 헤더 ( &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; ), 응답 헤더 ( &lt;a href=&quot;#section-6.2&quot;&gt;6.2&lt;/a&gt; ), 및 실체 헤더 ( &lt;a href=&quot;#section-7.1&quot;&gt;7.1&lt;/a&gt; 즉에 따른다) 필드는 동일한 일반 포맷을 따라 &lt;a href=&quot;https://tools.ietf.org/html/rfc822#section-3.1&quot;&gt;절 RFC 822 3.1&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]. 각 헤더 필드는 이름과 콜론 ( &quot;:&quot;) 및 필드 값으로 구성됩니다. 필드 이름은 대소 문자를 구분하지 않습니다. 단일 SP가 선호 되더라도 필드 값 앞에 LWS가있을 수 있습니다. 헤더 필드는 하나 이상의 SP 또는 HT로 각 추가 줄 앞에 추가하여 여러 줄로 확장 할 수 있습니다. 애플리케이션은 HTTP 구문을 생성 할 때 공통 형식 이외의 항목을 허용하지 않는 일부 구현이 존재할 수 있으므로 &quot;공통 형식&quot;을 사용해야합니다. 메시지 헤더 = field-name &quot;:&quot;[field-value] field-name = 토큰 field-value = * (field-content | LWS) field-content = &amp;lt;필드 값을 구성하고 * TEXT 또는 토큰, 구분 기호 및 따옴표로 묶은 문자열로 구성된 OCTET&amp;gt; 필드 내용에는 선행 또는 후행 LWS가 포함되지 않습니다. 공백이 아닌 첫 문자 앞에 나타나는 선형 공백 필드 값 또는 필드 값의 마지막 비 공백 문자 뒤. 이러한 선행 또는 후행 LWS는 필드 값의 의미를 변경하지 않고 제거 될 수 있습니다. 필드 컨텐트 사이에서 발생하는 LWS는 필드 값을 해석하거나 메시지 다운 스트림으로 전달하기 전에 단일 SP로 교체 될 수 있습니다. 필드 이름이 다른 헤더 필드가 수신되는 순서는 중요하지 않습니다. 그러나 일반 헤더 필드를 먼저 보내는 것이 &quot;우수 사례&quot;입니다.그 뒤에 request-header 또는 response-header 필드가 있고 entity-header 필드로 끝납니다. 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).엔티티 헤더 필드로 끝납니다. 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).엔티티 헤더 필드로 끝납니다. 해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).해당 헤더 필드의 전체 필드 값이 쉼표로 구분 된 목록 (예 : # (값))으로 정의 된 경우에만 동일한 field-name을 가진 여러 메시지 헤더 필드가 메시지에 존재할 수 있습니다. 메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).메시지의 의미를 변경하지 않고 여러 개의 헤더 필드를 하나의 &quot;field-name : field-value&quot;쌍으로 결합 할 수 있어야합니다. 각 후속 필드 값을 쉼표로 구분 된 첫 번째 필드에 추가합니다. 따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).따라서 동일한 field-name을 가진 헤더 필드가 수신되는 순서는 결합 된 필드 값의 해석에 중요하므로 프록시는 메시지가 전달 될 때 이러한 필드 값의 순서를 변경해서는 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="2ee53c95b1d46b2119a03c49e611077033b4d0b3" translate="yes" xml:space="preserve">
          <source>HTTP headers</source>
          <target state="translated">HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="48536d1a36cdc18529d34d2b1499b1bddb33777a" translate="yes" xml:space="preserve">
          <source>HTTP headers allow the client and the server to pass additional information with the request or the response. An HTTP header consists of its case-insensitive name followed by a colon '&lt;code&gt;:&lt;/code&gt;', then by its value (without line breaks). Leading white space before the value is ignored.</source>
          <target state="translated">HTTP 헤더를 사용하면 클라이언트와 서버가 요청 또는 응답과 함께 추가 정보를 전달할 수 있습니다. HTTP 헤더는 대소 문자를 구분하지 않는 이름 뒤에 콜론 ' &lt;code&gt;:&lt;/code&gt; ', 그 뒤에 값 (줄 바꿈 없음)이 있습니다. 값 앞의 선행 공백은 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="8e56498c371e01a01014a24b174120a52a7628f8" translate="yes" xml:space="preserve">
          <source>HTTP headers, meta elements and language information</source>
          <target state="translated">HTTP 헤더, 메타 요소 및 언어 정보</target>
        </trans-unit>
        <trans-unit id="63565f85024865ce35e9904d8dab88b231490429" translate="yes" xml:space="preserve">
          <source>HTTP implementations that share code with MHTML [&lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt;]
   implementations need to be aware of MIME line length limitations.
   Since HTTP does not have this limitation, HTTP does not fold long
   lines.  MHTML messages being transported by HTTP follow all
   conventions of MHTML, including line length limitations and folding,
   canonicalization, etc., since HTTP transfers message-bodies as 

   payload and, aside from the &quot;multipart/byteranges&quot; type (Appendix A
   of [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]), does not interpret the content or any MIME header
   lines that might be contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC2557&lt;/a&gt; ] 구현 과 코드를 공유하는 HTTP 구현 은 MIME 라인 길이 제한을 알고 있어야합니다. HTTP에는이 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP로 전송되는 MHTML 메시지는 HTTP가 메시지 본문을 페이로드로 전송하고 &quot;멀티 파트 / &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;바이트 범위&lt;/a&gt; &quot;유형 ([ RFC7233의 부록 A) 외에 라인 길이 제한 및 폴딩, 정식화 등 MHTML의 모든 규칙을 따릅니다 . )에 포함되어있을 수있는 내용 또는 MIME 헤더 행을 해석하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="de5402f673a6f75205a2fa61021e4a87fd38eaf7" translate="yes" xml:space="preserve">
          <source>HTTP implementations which share code with MHTML [&lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt;] implementations
   need to be aware of MIME line length limitations. Since HTTP does not
   have this limitation, HTTP does not fold long lines. MHTML messages
   being transported by HTTP follow all conventions of MHTML, including
   line length limitations and folding, canonicalization, etc., since
   HTTP transports all message-bodies as payload (see &lt;a href=&quot;#section-3.7.2&quot;&gt;section 3.7.2&lt;/a&gt;) and
   does not interpret the content or any MIME header lines that might be
   contained therein.</source>
          <target state="translated">MHTML [ &lt;a href=&quot;#ref-45&quot;&gt;45&lt;/a&gt; ] 구현 과 코드를 공유하는 HTTP 구현 은 MIME 라인 길이 제한을 알고 있어야합니다. HTTP에는이 제한이 없으므로 HTTP는 긴 줄을 접지 않습니다. HTTP로 전송되는 MHTML 메시지는 라인 길이 제한 및 접기, 정규화 등 MHTML의 모든 규칙을 따릅니다. HTTP는 모든 메시지 본문을 페이로드 ( &lt;a href=&quot;#section-3.7.2&quot;&gt;3.7.2&lt;/a&gt; 참조)로 전송 하고 내용 또는 MIME 헤더를 해석하지 않기 때문에 그 안에 포함될 수있는 라인.</target>
        </trans-unit>
        <trans-unit id="4924be195f30ae39945dc7a126df600856cfafd8" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react, and how it chooses the most adequate response.</source>
          <target state="translated">HTTP 는 브라우저가 선호하는 형식, 언어 또는 인코딩을 알리는 방법 으로 &lt;code&gt;&lt;a href=&quot;https://wiki.developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept&quot;&gt;Accept&lt;/a&gt;&lt;/code&gt; 로 시작하는 헤더 세트를 도입 합니다. 이 기사에서는이 광고가 어떻게 발생하는지, 서버가 어떻게 반응할지, 가장 적절한 응답을 선택하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="710a819ac327fdfc49afc67cb5bdfc03f98d8ddc" translate="yes" xml:space="preserve">
          <source>HTTP introduces a set of headers, starting with &lt;code&gt;Accept-&lt;/code&gt; as a way for a browser to announce the format, language, or encoding it prefers. This article explains how this advertisement happens, how the server is expected to react and how it will choose the most adequate response.</source>
          <target state="translated">HTTP 는 브라우저가 선호하는 형식, 언어 또는 인코딩을 알리는 방법 으로 &lt;code&gt;Accept-&lt;/code&gt; 로 시작하는 헤더 세트를 소개 합니다. 이 기사에서는이 알림이 발생하는 방식, 서버의 반응 방식 및 가장 적합한 응답을 선택하는 방법에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7bce7c5f422974cc46aee17e50fec032a864e5fe" translate="yes" xml:space="preserve">
          <source>HTTP is a client-server protocol: requests are sent by one entity, the user-agent (or a proxy on behalf of it). Most of the time the user-agent is a Web browser, but it can be anything, for example a robot that crawls the Web to populate and maintain a search engine index.</source>
          <target state="translated">HTTP는 클라이언트-서버 프로토콜입니다. 요청은 하나의 엔티티, 사용자 에이전트 (또는 그 대신 프록시)에 의해 전송됩니다. 대부분의 사용자 에이전트는 웹 브라우저이지만 검색 엔진 색인을 채우고 유지하기 위해 웹을 크롤링하는 로봇과 같은 것이 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b485125423c17b1efeda78b6422f6043dbfdd69f" translate="yes" xml:space="preserve">
          <source>HTTP is a pretty extensible protocol. It relies on a few basic concepts like the notion of resources and URIs, a simple structure of messages, and a client-server structure for the communication flow. On top of these basic concepts, numerous extensions have appeared over the years, adding new functionality and new semantics by creating new HTTP methods or headers.</source>
          <target state="translated">HTTP는 꽤 확장 가능한 프로토콜입니다. 리소스 및 URI 개념, 간단한 메시지 구조 및 통신 흐름을위한 클라이언트-서버 구조와 같은 몇 가지 기본 개념에 의존합니다. 이러한 기본 개념 외에도 새로운 HTTP 메소드 또는 헤더를 작성하여 새로운 기능과 새로운 의미를 추가하면서 수년 동안 수많은 확장이 나타났습니다.</target>
        </trans-unit>
        <trans-unit id="1e62200cdd839db28dbcb3a764ce93c997d72428" translate="yes" xml:space="preserve">
          <source>HTTP is a stateless request/response protocol that operates by
   exchanging messages (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) across a reliable transport- or
   session-layer &quot;connection&quot; (&lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;).  An HTTP &quot;client&quot; is a
   program that establishes a connection to a server for the purpose of
   sending one or more HTTP requests.  An HTTP &quot;server&quot; is a program
   that accepts connections in order to service HTTP requests by sending
   HTTP responses.

   The terms &quot;client&quot; and &quot;server&quot; refer only to the roles that these
   programs perform for a particular connection.  The same program might
   act as a client on some connections and a server on others.  The term
   &quot;user agent&quot; refers to any of the various client programs that
   initiate a request, including (but not limited to) browsers, spiders
   (web-based robots), command-line tools, custom applications, and
   mobile apps.  The term &quot;origin server&quot; refers to the program that can
   originate authoritative responses for a given target resource.  The
   terms &quot;sender&quot; and &quot;recipient&quot; refer to any implementation that sends
   or receives a given message, respectively.

   HTTP relies upon the Uniform Resource Identifier (URI) standard
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;] to indicate the target resource (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) and
   relationships between resources.  Messages are passed in a format
   similar to that used by Internet mail [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose
   Internet Mail Extensions (MIME) [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;Appendix&amp;nbsp;A of
   [RFC7231]&lt;/a&gt; for the differences between HTTP and MIME messages).

   Most HTTP communication consists of a retrieval request (GET) for a
   representation of some resource identified by a URI.  In the simplest
   case, this might be accomplished via a single bidirectional
   connection (===) between the user agent (UA) and the origin
   server (O).

            request   &amp;gt;
       UA ======================================= O
                                   &amp;lt;   response

   A client sends an HTTP request to a server in the form of a request
   message, beginning with a request-line that includes a method, URI,
   and protocol version (&lt;a href=&quot;#section-3.1.1&quot;&gt;Section 3.1.1&lt;/a&gt;), followed by header fields
   containing request modifiers, client information, and representation
   metadata (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the
   header section, and finally a message body containing the payload
   body (if any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;). 

   A server responds to a client's request by sending one or more HTTP
   response messages, each beginning with a status line that includes
   the protocol version, a success or error code, and textual reason
   phrase (&lt;a href=&quot;#section-3.1.2&quot;&gt;Section 3.1.2&lt;/a&gt;), possibly followed by header fields containing
   server information, resource metadata, and representation metadata
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;), an empty line to indicate the end of the header
   section, and finally a message body containing the payload body (if
   any, &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;).

   A connection might be used for multiple request/response exchanges,
   as defined in &lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;.

   The following example illustrates a typical message exchange for a
   GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;) on the URI
   &quot;http://www.example.com/hello.txt&quot;:

   Client request:

     GET /hello.txt HTTP/1.1
     User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
     Host: www.example.com
     Accept-Language: en, mi


   Server response:

     HTTP/1.1 200 OK
     Date: Mon, 27 Jul 2009 12:28:53 GMT
     Server: Apache
     Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
     ETag: &quot;34aa387-d-1568eb00&quot;
     Accept-Ranges: bytes
     Content-Length: 51
     Vary: Accept-Encoding
     Content-Type: text/plain

     Hello World! My payload includes a trailing CRLF.</source>
          <target state="translated">HTTP 메시지 (교환함으로써 작동하는 무 요청 / 응답 프로토콜 &lt;a href=&quot;#section-3&quot;&gt;부 (3)&lt;/a&gt; (a 신뢰성 transport- 또는 세션 층 &quot;연결&quot;)간에 &lt;a href=&quot;#section-6&quot;&gt;제 6&lt;/a&gt;). HTTP &quot;클라이언트&quot;는 하나 이상의 HTTP 요청을 전송하기 위해 서버에 연결하는 프로그램입니다. HTTP &quot;서버&quot;는 HTTP 응답을 전송하여 HTTP 요청을 처리하기 위해 연결을 수락하는 프로그램입니다. &quot;클라이언트&quot;및 &quot;서버&quot;라는 용어는 이러한 프로그램이 특정 연결에 대해 수행하는 역할 만 나타냅니다. 동일한 프로그램이 일부 연결에서는 클라이언트로 작동하고 다른 연결에서는 서버로 작동 할 수 있습니다. &quot;사용자 에이전트&quot;라는 용어는 브라우저, 스파이더 (웹 기반 로봇), 명령 줄 도구, 사용자 지정 응용 프로그램 및 모바일 응용 프로그램을 포함하여 요청을 시작하는 다양한 클라이언트 프로그램을 나타냅니다. &quot;원본 서버&quot;라는 용어주어진 대상 자원에 대한 권한있는 응답을 시작할 수있는 프로그램을 나타냅니다. &quot;발송 인&quot;및 &quot;수신인&quot;이라는 용어는 각각 주어진 메시지를 보내거나받는 모든 구현을 의미합니다. HTTP는 URI (Uniform Resource Identifier) ​​표준에 의존합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]을 사용하여 대상 자원 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt; ) 및 자원 간의 관계 를 나타냅니다 . 메시지는 인터넷 메일 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] 및 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에서 사용되는 것과 유사한 형식으로 전달됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#appendix-A&quot;&gt;[RFC7231]의 부록 A&lt;/a&gt; 참조) .HTTP와 MIME 메시지의 차이점). 대부분의 HTTP 통신은 URI로 식별 된 일부 자원을 표시하기위한 검색 요청 (GET)으로 구성됩니다. 가장 간단한 경우, 이는 사용자 에이전트 (UA)와 오리진 서버 (O) 간의 단일 양방향 연결 (===)을 통해 수행 될 수 있습니다. 요청&amp;gt; UA ======================================= O &amp;lt;응답 클라이언트가 HTTP를 보냅니다. 메소드, URI 및 프로토콜 버전을 포함하는 요청 라인 ( &lt;a href=&quot;#section-3.1.1&quot;&gt;섹션 3.1.1&lt;/a&gt; )으로 시작하여 요청 메시지 양식으로 서버에 요청한 후 요청 수정 자, 클라이언트 정보 및 표시 메타 데이터 ( &lt;a href=&quot;#section-3.2&quot;&gt;섹션 3.2&lt;/a&gt;), 헤더 섹션의 끝을 나타내는 빈 줄, 마지막으로 페이로드 본문을 포함하는 메시지 본문 ( &lt;a href=&quot;#section-3.3&quot;&gt;섹션&lt;/a&gt; 이있는 경우 섹션 3.3 ). 서버는 하나 이상의 HTTP 응답 메시지를 전송하여 클라이언트의 요청에 응답합니다. 각 메시지는 프로토콜 버전, 성공 또는 오류 코드 및 텍스트 이유 문구 ( &lt;a href=&quot;#section-3.1.2&quot;&gt;섹션 3.1.2&lt;/a&gt; ) 가 포함 된 상태 행으로 시작하고 그 뒤에 헤더 필드가옵니다. 서버 정보, 리소스 메타 데이터 및 표현 메타 데이터 ( &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절&lt;/a&gt; ), 헤더 섹션의 끝을 나타내는 빈 줄, 마지막으로 페이로드 본문을 포함하는 메시지 본문 (있는 경우 &lt;a href=&quot;#section-3.3&quot;&gt;3.3 절)&lt;/a&gt;). &lt;a href=&quot;#section-6.3&quot;&gt;섹션 6.3에&lt;/a&gt; 정의 된대로 여러 요청 / 응답 교환에 연결이 사용될 수 있습니다 . 다음 예 는 URI &quot;http://www.example.com/hello.txt&quot; 에서 GET 요청 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]의 4.3.1 섹션&lt;/a&gt; )에 대한 일반적인 메시지 교환을 보여줍니다. 클라이언트 요청 : GET /hello.txt HTTP /1.1 사용자 에이전트 : curl / 7.16.3 libcurl / 7.16.3 OpenSSL / 0.9.7l zlib / 1.2.3 호스트 : www.example.com Accept-Language : en, mi 서버 응답 : HTTP / 1.1 200 OK 날짜 : 2009 년 7 월 27 일 월요일 12:28:53 GMT 서버 : Apache 최종 수정 : 2009 년 7 월 22 일 수요일 19:15:56 GMT ETag : &quot;34aa387-d-1568eb00&quot;수락 범위 : 바이트 내용 길이 : 51 가변 : 수락 인코딩 내용 유형 : text / plain Hello World!내 페이로드에는 후행 CRLF가 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="5cc2a6ae91625497aff3803fe93d9cda3d79e909" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that is easy to use. The client-server structure, combined with the ability to simply add headers, allows HTTP to advance along with the extended capabilities of the Web.</source>
          <target state="translated">HTTP는 사용하기 쉬운 확장 가능한 프로토콜입니다. 간단하게 헤더를 추가 할 수있는 기능과 결합 된 클라이언트-서버 구조를 통해 HTTP는 웹의 확장 된 기능과 함께 발전 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbcb125f3701fe50926501831f8f7ee161444b57" translate="yes" xml:space="preserve">
          <source>HTTP is an extensible protocol that relies on concepts like resources and Uniform Resource Identifiers (URIs), simple message structure, and client-server communication flow. On top of these basic concepts, numerous extensions have been developed over the years that add updated functionality and semantics with new HTTP methods or headers.</source>
          <target state="translated">HTTP는 리소스 및 URI (Uniform Resource Identifier), 간단한 메시지 구조 및 클라이언트-서버 통신 흐름과 같은 개념에 의존하는 확장 가능한 프로토콜입니다. 이러한 기본 개념 외에도 새로운 HTTP 메서드 또는 헤더로 업데이트 된 기능과 의미를 추가하는 수많은 확장이 수년에 걸쳐 개발되었습니다.</target>
        </trans-unit>
        <trans-unit id="f20fa14d437b5a88c718d590e0efda20242112a2" translate="yes" xml:space="preserve">
          <source>HTTP is extensible</source>
          <target state="translated">HTTP는 확장 가능</target>
        </trans-unit>
        <trans-unit id="18ad92cc7b82eb0d0efdfdb9ee61c4c2a39d270e" translate="yes" xml:space="preserve">
          <source>HTTP is generally designed to be simple and human readable, even with the added complexity introduced in HTTP/2 by encapsulating HTTP messages into frames. HTTP messages can be read and understood by humans, providing easier testing for developers, and reduced complexity for newcomers.</source>
          <target state="translated">HTTP는 일반적으로 HTTP 메시지를 프레임으로 캡슐화하여 HTTP / 2에 도입 된 복잡성이 추가 된 경우에도 간단하고 사람이 읽을 수 있도록 설계되었습니다. HTTP 메시지는 사람이 읽고 이해할 수 있으므로 개발자에게는 더 쉬운 테스트를 제공하고 신규 사용자에게는 복잡성을 줄입니다.</target>
        </trans-unit>
        <trans-unit id="6e492d2fcbffcb461a67019008cf2c966900353b" translate="yes" xml:space="preserve">
          <source>HTTP is independent of the security model of the Web, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;same-origin policy&lt;/a&gt;. In fact, the current Web security model has been developed after the creation of HTTP! Over the years, it has proved useful to be able to be more lenient, by allowing under certain constraints to lift some of the restriction of this policy. How much and when such restrictions are lifted is transmitted by the server to the client using a new bunch of HTTP headers. These are defined in specifications like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; (CORS) or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; (CSP).</source>
          <target state="translated">HTTP는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;동일한 출처 정책 인&lt;/a&gt; 웹의 보안 모델과 무관합니다 . 사실, 현재 웹 보안 모델은 HTTP를 만든 후에 개발되었습니다! 수년에 걸쳐, 특정 제약 하에서이 정책의 제한 중 일부를 해제함으로써 좀 더 관대해질 수있는 것이 유용한 것으로 판명되었습니다. 이러한 제한이 해제되는 양과시기는 새로운 HTTP 헤더를 사용하여 서버에서 클라이언트로 전송됩니다. 이들은 CORS ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt; ) 또는 CSP ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/CSP&quot;&gt;Content Security Policy&lt;/a&gt; ) 와 같은 사양으로 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="844e92e43f2d1fe1edd17a77bc8a5a11e990e4be" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol.  However, messages can include
   a single MIME-Version header field to indicate what version of the
   MIME protocol was used to construct the message.  Use of the
   MIME-Version header field indicates that the message is in full
   conformance with the MIME protocol (as defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;]).
   Senders are responsible for ensuring full conformance (where
   possible) when exporting HTTP messages to strict MIME environments.</source>
          <target state="translated">HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 메시지에는 메시지를 구성하는 데 사용 된 MIME 프로토콜 버전을 나타내는 단일 MIME 버전 헤더 필드가 포함될 수 있습니다. MIME-Version 헤더 필드를 사용하면 메시지가 MIME 프로토콜을 완전히 준수 함을 나타냅니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에 정의 된대로 ). 발신자는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 (가능한 경우) 완벽하게 준수 할 책임이 있습니다.</target>
        </trans-unit>
        <trans-unit id="e53f9322a91df40e55625dc45bd212cc6e3463d2" translate="yes" xml:space="preserve">
          <source>HTTP is not a MIME-compliant protocol. However, HTTP/1.1 messages MAY
   include a single MIME-Version general-header field to indicate what
   version of the MIME protocol was used to construct the message. Use
   of the MIME-Version header field indicates that the message is in
   full compliance with the MIME protocol (as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;[&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]).
   Proxies/gateways are responsible for ensuring full compliance (where
   possible) when exporting HTTP messages to strict MIME environments.

       MIME-Version   = &quot;MIME-Version&quot; &quot;:&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   MIME version &quot;1.0&quot; is the default for use in HTTP/1.1. However,
   HTTP/1.1 message parsing and semantics are defined by this document
   and not the MIME specification.</source>
          <target state="translated">HTTP는 MIME 호환 프로토콜이 아닙니다. 그러나 HTTP / 1.1 메시지는 메시지를 구성하는 데 사용 된 MIME 프로토콜의 버전을 나타내는 단일 MIME 버전 일반 헤더 필드를 포함 할 수 있습니다. MIME-Version 헤더 필드를 사용하면 메시지가 MIME 프로토콜 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ]에 정의 된 대로 )을 완전히 준수 함을 나타냅니다 . 프록시 / 게이트웨이는 HTTP 메시지를 엄격한 MIME 환경으로 내보낼 때 (가능한 경우) 완벽하게 준수 할 책임이 있습니다. MIME-Version = &quot;MIME-Version&quot; &quot;:&quot;1 * DIGIT &quot;.&quot; 1 * DIGIT MIME 버전 &quot;1.0&quot;이 HTTP / 1.1에서 사용되는 기본값입니다. 그러나 HTTP / 1.1 메시지 구문 분석 및 의미는 MIME 사양이 아닌이 문서에 의해 정의됩니다.</target>
        </trans-unit>
        <trans-unit id="dca5ebedb205dfacf9266ff93c066cf81c69779d" translate="yes" xml:space="preserve">
          <source>HTTP is simple</source>
          <target state="translated">HTTP는 간단하다</target>
        </trans-unit>
        <trans-unit id="505159632976cbe17f2844bb8f7ce15822bb5f60" translate="yes" xml:space="preserve">
          <source>HTTP is stateless, but not sessionless</source>
          <target state="translated">HTTP는 상태 비 저장이지만 세션 비 저장</target>
        </trans-unit>
        <trans-unit id="809c123eeed8b2f5fd5ed3274c85be36e7f59d12" translate="yes" xml:space="preserve">
          <source>HTTP is stateless: there is no link between two requests being successively carried out on the same connection. This immediately has the prospect of being problematic for users attempting to interact with certain pages coherently, for example, using e-commerce shopping baskets. But while the core of HTTP itself is stateless, HTTP cookies allow the use of stateful sessions. Using header extensibility, HTTP Cookies are added to the workflow, allowing session creation on each HTTP request to share the same context, or the same state.</source>
          <target state="translated">HTTP는 상태 비 저장입니다. 동일한 연결에서 두 요청이 연속적으로 수행되는 링크는 없습니다. 이는 전자 상거래 쇼핑 바구니를 사용하는 것과 같이 특정 페이지와 일관되게 상호 작용하려는 사용자에게 문제가 될 수 있습니다. 그러나 HTTP 자체의 핵심은 상태 비 저장 (stateless) 인 반면, HTTP 쿠키는 상태 저장 세션의 사용을 허용합니다. 헤더 확장 성을 사용하여 HTTP 쿠키가 워크 플로우에 추가되어 각 HTTP 요청에서 세션 작성이 동일한 컨텍스트 또는 동일한 상태를 공유 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="40096b223d68b1f8c1440bbea86dad29e675b9a1" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches.  This
   document defines aspects of HTTP/1.1 related to caching and reusing
   response messages.

   An HTTP cache is a local store of response messages and the subsystem
   that controls storage, retrieval, and deletion of messages in it.  A
   cache stores cacheable responses in order to reduce the response time
   and network bandwidth consumption on future, equivalent requests.
   Any client or server MAY employ a cache, though a cache cannot be
   used by a server that is acting as a tunnel.

   A shared cache is a cache that stores responses to be reused by more
   than one user; shared caches are usually (but not always) deployed as
   a part of an intermediary.  A private cache, in contrast, is
   dedicated to a single user; often, they are deployed as a component
   of a user agent.

   The goal of caching in HTTP/1.1 is to significantly improve
   performance by reusing a prior response message to satisfy a current
   request.  A stored response is considered &quot;fresh&quot;, as defined in
   &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;, if the response can be reused without &quot;validation&quot;
   (checking with the origin server to see if the cached response
   remains valid for this request).  A fresh response can therefore
   reduce both latency and network overhead each time it is reused.
   When a cached response is not fresh, it might still be reusable if it
   can be freshened by validation (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) or if the origin is
   unavailable (&lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;).</source>
          <target state="translated">HTTP는 일반적으로 분산 캐시 시스템에 사용되며 응답 캐시를 사용하여 성능을 향상시킬 수 있습니다. 이 문서는 응답 메시지 캐싱 및 재사용과 관련된 HTTP / 1.1의 측면을 정의합니다. HTTP 캐시는 응답 메시지의 로컬 저장소이며 메시지의 저장소, 검색 및 삭제를 제어하는 ​​하위 시스템입니다. 캐시는 캐시 가능한 응답을 저장하여 향후 동등한 요청에 대한 응답 시간과 네트워크 대역폭 소비를 줄입니다. 클라이언트 나 서버는 캐시를 사용할 수 있지만, 터널 역할을하는 서버는 캐시를 사용할 수 없습니다. 공유 캐시는 둘 이상의 사용자가 재사용 할 응답을 저장하는 캐시입니다. 공유 캐시는 일반적으로 중개자의 일부로 배포되지만 항상 그런 것은 아닙니다. 대조적으로 개인 캐시단일 사용자 전용 종종 사용자 에이전트의 구성 요소로 배포됩니다. HTTP / 1.1에서 캐싱의 목표는 현재 요청을 충족시키기 위해 이전 응답 메시지를 재사용하여 성능을 크게 향상시키는 것입니다. 저장된 응답은에 정의 된대로 &quot;신선한&quot;것으로 간주됩니다. &lt;a href=&quot;#section-4.2&quot;&gt;&lt;/a&gt;&quot;유효성 검증&quot;없이 응답을 재사용 할 수있는 경우 4.2 절 (캐시 된 응답이이 요청에 유효한지 확인하기 위해 오리진 서버를 점검) 따라서 새로운 응답은 재사용 될 때마다 대기 시간과 네트워크 오버 헤드를 모두 줄일 수 있습니다. 캐시 된 응답이 최신 상태가 아닌 경우 유효성 검사 ( &lt;a href=&quot;#section-4.3&quot;&gt;4.3&lt;/a&gt; )를 통해 새로 고칠 수 있거나 원본을 사용할 수없는 경우 ( &lt;a href=&quot;#section-4.2.4&quot;&gt;4.2.4&lt;/a&gt; ) 여전히 재사용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bc0cee4ed0cc389fa445e5f9f96d84585ff6e837" translate="yes" xml:space="preserve">
          <source>HTTP is typically used for distributed information systems, where
   performance can be improved by the use of response caches. The
   HTTP/1.1 protocol includes a number of elements intended to make
   caching work as well as possible. Because these elements are
   inextricable from other aspects of the protocol, and because they
   interact with each other, it is useful to describe the basic caching
   design of HTTP separately from the detailed descriptions of methods,
   headers, response codes, etc.

   Caching would be useless if it did not significantly improve
   performance. The goal of caching in HTTP/1.1 is to eliminate the need
   to send requests in many cases, and to eliminate the need to send
   full responses in many other cases. The former reduces the number of
   network round-trips required for many operations; we use an
   &quot;expiration&quot; mechanism for this purpose (see &lt;a href=&quot;#section-13.2&quot;&gt;section 13.2&lt;/a&gt;). The
   latter reduces network bandwidth requirements; we use a &quot;validation&quot;
   mechanism for this purpose (see &lt;a href=&quot;#section-13.3&quot;&gt;section 13.3&lt;/a&gt;).

   Requirements for performance, availability, and disconnected
   operation require us to be able to relax the goal of semantic
   transparency. The HTTP/1.1 protocol allows origin servers, caches, 

   and clients to explicitly reduce transparency when necessary.
   However, because non-transparent operation may confuse non-expert
   users, and might be incompatible with certain server applications
   (such as those for ordering merchandise), the protocol requires that
   transparency be relaxed

      - only by an explicit protocol-level request when relaxed by
        client or origin server

      - only with an explicit warning to the end user when relaxed by
        cache or client

   Therefore, the HTTP/1.1 protocol provides these important elements:

      1. Protocol features that provide full semantic transparency when
         this is required by all parties.

      2. Protocol features that allow an origin server or user agent to
         explicitly request and control non-transparent operation.

      3. Protocol features that allow a cache to attach warnings to
         responses that do not preserve the requested approximation of
         semantic transparency.

   A basic principle is that it must be possible for the clients to
   detect any potential relaxation of semantic transparency.

      Note: The server, cache, or client implementor might be faced with
      design decisions not explicitly discussed in this specification.
      If a decision might affect semantic transparency, the implementor
      ought to err on the side of maintaining transparency unless a
      careful and complete analysis shows significant benefits in
      breaking transparency.</source>
          <target state="translated">HTTP는 일반적으로 분산 캐시 시스템에 사용되며 응답 캐시를 사용하여 성능을 향상시킬 수 있습니다. HTTP / 1.1 프로토콜에는 캐싱 작업뿐만 아니라 가능한 많은 요소가 포함되어 있습니다. 이러한 요소는 프로토콜의 다른 측면과 비교할 수 없으며 서로 상호 작용하기 때문에 메서드, 헤더, 응답 코드 등의 자세한 설명과 별도로 HTTP의 기본 캐싱 디자인을 설명하는 것이 유용합니다. 캐싱은 쓸모가 없습니다. 성능이 크게 향상되지 않은 경우 HTTP / 1.1에서 캐싱의 목표는 많은 경우 요청을 보낼 필요를 없애고 다른 많은 경우에는 전체 응답을 보낼 필요를 없애는 것입니다. 전자는 많은 작업에 필요한 네트워크 왕복 수를 줄입니다.이 목적을 위해 &quot;만료&quot;메커니즘을 사용합니다 (참조&lt;a href=&quot;#section-13.2&quot;&gt;섹션 13.2&lt;/a&gt; ). 후자는 네트워크 대역폭 요구 사항을 줄입니다. 이 목적을 위해 &quot;유효성 검증&quot;메커니즘을 사용합니다 ( &lt;a href=&quot;#section-13.3&quot;&gt;섹션 13.3&lt;/a&gt; 참조)). 성능, 가용성 및 연결이 끊긴 작업에 대한 요구 사항으로 인해 의미 투명성의 목표를 완화 할 수 있어야합니다. HTTP / 1.1 프로토콜을 사용하면 원본 서버, 캐시 및 클라이언트가 필요한 경우 투명성을 명시 적으로 줄일 수 있습니다. 그러나 투명하지 않은 작업은 전문가가 아닌 사용자를 혼동하고 특정 서버 응용 프로그램 (예 : 상품 주문 용)과 호환되지 않을 수 있으므로 프로토콜은 투명성이 완화되어야합니다. 클라이언트 또는 오리진 서버-캐시 또는 클라이언트에 의해 완화 될 때 최종 사용자에게 명시적인 경고 만 표시하므로 HTTP / 1.1 프로토콜은 다음과 같은 중요한 요소를 제공합니다.모든 당사자가 필요할 때 완전한 의미 투명성을 제공하는 프로토콜 기능. 2. 오리진 서버 또는 사용자 에이전트가 투명하지 않은 조작을 명시 적으로 요청하고 제어 할 수있게하는 프로토콜 기능. 3. 요청 된 의미 투명성의 근사값을 유지하지 않는 응답에 캐시가 경고를 첨부 할 수있게하는 프로토콜 기능. 기본 원칙은 클라이언트가 의미 투명성의 이완 가능성을 감지 할 수 있어야한다는 것입니다. 참고 : 서버, 캐시 또는 클라이언트 구현자는이 사양에서 명시 적으로 논의되지 않은 설계 결정에 직면 할 수 있습니다. 결정이 의미 투명성에 영향을 줄 수있는 경우신중하고 완전한 분석이 투명성을 깨는 데 큰 이점을 나타내지 않는 한, 구현자는 투명성을 유지하는 측면에서 실수를해야합니다.</target>
        </trans-unit>
        <trans-unit id="ee5bd85f6de02476bff1ddc097b7f7447096c5a2" translate="yes" xml:space="preserve">
          <source>HTTP is used in a wide variety of applications, ranging from
   general-purpose computers to home appliances.  In some cases,
   communication options are hard-coded in a client's configuration.
   However, most HTTP clients rely on the same resource identification
   mechanism and configuration techniques as general-purpose Web
   browsers.

   HTTP communication is initiated by a user agent for some purpose.
   The purpose is a combination of request semantics, which are defined
   in [&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;], and a target resource upon which to apply those
   semantics.  A URI reference (&lt;a href=&quot;#section-2.7&quot;&gt;Section 2.7&lt;/a&gt;) is typically used as an 

   identifier for the &quot;target resource&quot;, which a user agent would
   resolve to its absolute form in order to obtain the &quot;target URI&quot;.
   The target URI excludes the reference's fragment component, if any,
   since fragment identifiers are reserved for client-side processing
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], Section&amp;nbsp;3.5&lt;/a&gt;).</source>
          <target state="translated">HTTP는 범용 컴퓨터에서 가전 제품에 이르기까지 다양한 응용 프로그램에서 사용됩니다. 경우에 따라 통신 옵션은 클라이언트 구성에서 하드 코딩됩니다. 그러나 대부분의 HTTP 클라이언트는 범용 웹 브라우저와 동일한 리소스 식별 메커니즘 및 구성 기술을 사용합니다. HTTP 통신은 어떤 목적으로 사용자 에이전트에 의해 시작됩니다. 목적은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt; ]에 정의 된 요청 의미론 과 해당 의미론을 적용 할 대상 자원 의 조합입니다 . URI 참조 ( &lt;a href=&quot;#section-2.7&quot;&gt;2.7&lt;/a&gt;)는 일반적으로 &quot;대상 자원&quot;에 대한 식별자로 사용되며, 사용자 에이전트는 &quot;대상 URI&quot;를 얻기 위해 절대 형식으로 해석합니다. 프래그먼트 식별자는 클라이언트 측 처리를 위해 예약되어 있기 때문에 타겟 URI는 참조의 프래그먼트 컴포넌트를 제외합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-3.5&quot;&gt;[RFC3986], 섹션 3.5&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="14fc3ba32d80ac4a60cf241e5c4400241293ff7f" translate="yes" xml:space="preserve">
          <source>HTTP message headers are used to describe a resource, or the behavior of the server or the client. Custom proprietary headers can be added using the &lt;code&gt;X-&lt;/code&gt; prefix; others in an &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA registry&lt;/a&gt;, whose original content was defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt;. IANA also maintains a &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;registry of proposed new HTTP message headers&lt;/a&gt;.</source>
          <target state="translated">HTTP 메시지 헤더는 리소스 또는 서버 또는 클라이언트의 동작을 설명하는 데 사용됩니다. &lt;code&gt;X-&lt;/code&gt; 접두사를 사용하여 사용자 지정 독점 헤더를 추가 할 수 있습니다 . 원본 콘텐츠가 &lt;a href=&quot;https://tools.ietf.org/html/rfc4229&quot;&gt;RFC 4229&lt;/a&gt; 에 정의 되어있는 &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#perm-headers&quot;&gt;IANA 레지스트리의&lt;/a&gt; 다른 것 . IANA는 또한 &lt;a href=&quot;https://www.iana.org/assignments/message-headers/message-headers.xhtml#prov-headers&quot;&gt;제안 된 새로운 HTTP 메시지 헤더&lt;/a&gt; 의 레지스트리를 유지 관리합니다 .</target>
        </trans-unit>
        <trans-unit id="2638b56fdde689e585c5bdfb740cd6d868d52464" translate="yes" xml:space="preserve">
          <source>HTTP messages are composed of textual information encoded in ASCII, and span over multiple lines. In HTTP/1.1, and earlier versions of the protocol, these messages were openly sent across the connection. In HTTP/2, the once human-readable message is now divided up into HTTP frames, providing optimization and performance improvements.</source>
          <target state="translated">HTTP 메시지는 ASCII로 인코딩 된 텍스트 정보로 구성되며 여러 줄에 걸쳐 있습니다. HTTP / 1.1 및 이전 버전의 프로토콜에서는 이러한 메시지가 연결을 통해 공개적으로 전송되었습니다. HTTP / 2에서 한 번 사람이 읽을 수있는 메시지는 이제 HTTP 프레임으로 분할되어 최적화 및 성능 향상을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="118d6001c735751f3c84aa7e43184e1a5916e130" translate="yes" xml:space="preserve">
          <source>HTTP messages are how data is exchanged between a server and a client. There are two types of messages: &lt;em&gt;requests&lt;/em&gt; sent by the client to trigger an action on the server, and &lt;em&gt;responses&lt;/em&gt;, the answer from the server.</source>
          <target state="translated">HTTP 메시지는 서버와 클라이언트간에 데이터가 교환되는 방식입니다. 두 가지 유형의 메시지가 있습니다. 클라이언트가 서버에서 조치를 트리거하기 위해 보낸 &lt;em&gt;요청&lt;/em&gt; 과 &lt;em&gt;response&lt;/em&gt; , 서버의 응답이 있습니다.</target>
        </trans-unit>
        <trans-unit id="2f6109f653584ed6dc3dfe16c53952b62bfd3c70" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP 메시지는 HTTP 사용의 핵심입니다. 그들의 구조는 간단하고 확장 성이 뛰어납니다. HTTP / 2 프레이밍 메커니즘은 근본적으로 수정하지 않고 HTTP / 1.x 구문과 기본 전송 프로토콜 사이에 새로운 중간 계층을 추가합니다. 입증 된 메커니즘을 기반으로합니다.</target>
        </trans-unit>
        <trans-unit id="891aa548a3155a7bc116f727c4c9e489c435ed0b" translate="yes" xml:space="preserve">
          <source>HTTP messages are the key in using HTTP; their structure is simple, and they are highly extensible. The HTTP/2 framing mechanism adds a new intermediate layer between the HTTP/1.x syntax and the underlying transport protocol, without fundamentally modifying it: building upon proven mechanisms.</source>
          <target state="translated">HTTP 메시지는 HTTP 사용의 핵심입니다. 구조가 간단하고 확장 성이 뛰어납니다. HTTP / 2 프레이밍 메커니즘은 근본적으로 수정하지 않고 HTTP / 1.x 구문과 기본 전송 프로토콜 사이에 새로운 중간 계층을 추가합니다. 입증 된 메커니즘을 기반으로 구축됩니다.</target>
        </trans-unit>
        <trans-unit id="167bf47970009cc8e263d7f95620e5a732a4503a" translate="yes" xml:space="preserve">
          <source>HTTP messages consist of requests from client to server and responses
   from server to client.

       HTTP-message   = Request | Response     ; HTTP/1.1 messages

   Request (&lt;a href=&quot;#section-5&quot;&gt;section 5&lt;/a&gt;) and Response (&lt;a href=&quot;#section-6&quot;&gt;section 6&lt;/a&gt;) messages use the generic
   message format of &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] for transferring entities (the payload
   of the message). Both types of message consist of a start-line, zero
   or more header fields (also known as &quot;headers&quot;), an empty line (i.e.,
   a line with nothing preceding the CRLF) indicating the end of the
   header fields, and possibly a message-body.

        generic-message = start-line
                          *(message-header CRLF)
                          CRLF
                          [ message-body ]
        start-line      = Request-Line | Status-Line

   In the interest of robustness, servers SHOULD ignore any empty
   line(s) received where a Request-Line is expected. In other words, if
   the server is reading the protocol stream at the beginning of a
   message and receives a CRLF first, it should ignore the CRLF.

   Certain buggy HTTP/1.0 client implementations generate extra CRLF's
   after a POST request. To restate what is explicitly forbidden by the
   BNF, an HTTP/1.1 client MUST NOT preface or follow a request with an
   extra CRLF.</source>
          <target state="translated">HTTP 메시지는 클라이언트에서 서버로의 요청과 서버에서 클라이언트로의 응답으로 구성됩니다. HTTP 메시지 = 요청 | 응답; HTTP / 1.1 메시지 요청 ( &lt;a href=&quot;#section-5&quot;&gt;섹션 5&lt;/a&gt; ) 및 응답 ( &lt;a href=&quot;#section-6&quot;&gt;섹션 6&lt;/a&gt; ) 메시지는 &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;] 엔티티 전송 (메시지의 페이로드). 두 가지 유형의 메시지는 시작 행, 0 개 이상의 헤더 필드 ( &quot;헤더&quot;라고도 함), 빈 행 (예 : CRLF 앞에 아무것도없는 행), 헤더 필드의 끝을 나타냅니다. 메시지 본문. generic-message = start-line * (메시지 헤더 CRLF) CRLF [message-body] start-line = 요청 라인 | 상태 라인 견고성을 위해 서버는 요청 라인이 예상되는 빈 라인을 무시해야합니다. 즉, 서버가 메시지 시작시 프로토콜 스트림을 읽고 CRLF를 먼저 수신하는 경우 CRLF를 무시해야합니다. 특정 버그가있는 HTTP / 1.0 개의 클라이언트 구현은 POST 요청 후 추가 CRLF를 생성합니다. BNF가 명시 적으로 금지 한 사항을 다시 설명하기 위해 HTTP / 1.1 클라이언트는 추가 CRLF로 요청을 시작하거나 따라 가지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="a514b96da0b4952018a9659e3ae2424d71abef2e" translate="yes" xml:space="preserve">
          <source>HTTP messages, as defined in HTTP/1.1 and earlier, are human-readable. In HTTP/2, these messages are embedded into a binary structure, a &lt;em&gt;frame&lt;/em&gt;, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP / 1.1 및 이전 버전에 정의 된 HTTP 메시지는 사람이 읽을 수 있습니다. HTTP / 2에서 이러한 메시지는 이진 구조 인 &lt;em&gt;프레임&lt;/em&gt; 에 포함되어 헤더 압축 및 멀티플렉싱과 같은 최적화를 허용합니다. 이 버전의 HTTP에서 원래 HTTP 메시지의 일부만 전송 되더라도 각 메시지의 의미는 변경되지 않고 클라이언트는 원래 HTTP / 1.1 요청을 (가상으로) 재구성합니다. 따라서 HTTP / 1.1 형식의 HTTP / 2 메시지를 이해하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="e792736752047fb0b0f5fa09841f2859bfcdc55a" translate="yes" xml:space="preserve">
          <source>HTTP messaging is independent of the underlying transport- or
   session-layer connection protocol(s).  HTTP only presumes a reliable
   transport with in-order delivery of requests and the corresponding
   in-order delivery of responses.  The mapping of HTTP request and
   response structures onto the data units of an underlying transport
   protocol is outside the scope of this specification.

   As described in &lt;a href=&quot;#section-5.2&quot;&gt;Section 5.2&lt;/a&gt;, the specific connection protocols to be
   used for an HTTP interaction are determined by client configuration
   and the target URI.  For example, the &quot;http&quot; URI scheme
   (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) indicates a default connection of TCP over IP, with a
   default TCP port of 80, but the client might be configured to use a
   proxy via some other connection, port, or protocol. 

   HTTP implementations are expected to engage in connection management,
   which includes maintaining the state of current connections,
   establishing a new connection or reusing an existing connection,
   processing messages received on a connection, detecting connection
   failures, and closing each connection.  Most clients maintain
   multiple connections in parallel, including more than one connection
   per server endpoint.  Most servers are designed to maintain thousands
   of concurrent connections, while controlling request queues to enable
   fair use and detect denial-of-service attacks.</source>
          <target state="translated">HTTP 메시징은 기본 전송 계층 또는 세션 계층 연결 프로토콜과 독립적입니다. HTTP는 요청을 순서대로 전달하고 해당 순서대로 응답을 전달하는 안정적인 전송 만 가정합니다. 기본 전송 프로토콜의 데이터 단위에 대한 HTTP 요청 및 응답 구조의 맵핑은이 스펙의 범위를 벗어납니다. &lt;a href=&quot;#section-5.2&quot;&gt;5.2 절&lt;/a&gt; 에서 설명한 것처럼 HTTP 상호 작용에 사용되는 특정 연결 프로토콜은 클라이언트 구성 및 대상 URI에 의해 결정됩니다. 예를 들어, &quot;http&quot;URI 체계 ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1)&lt;/a&gt;)은 기본 TCP 포트가 80 인 TCP over IP의 기본 연결을 나타내지 만 클라이언트는 다른 연결, 포트 또는 프로토콜을 통해 프록시를 사용하도록 구성 될 수 있습니다. HTTP 구현은 현재 연결 상태 유지, 새 연결 설정 또는 기존 연결 재사용, 연결에서 수신 된 메시지 처리, 연결 실패 감지 및 각 연결 종료를 포함하여 연결 관리에 관여 할 것으로 예상됩니다. 대부분의 클라이언트는 서버 엔드 포인트 당 둘 이상의 연결을 포함하여 여러 연결을 병렬로 유지 관리합니다. 대부분의 서버는 수천 개의 동시 연결을 유지하면서 요청 대기열을 제어하여 공정한 사용을 가능하게하고 서비스 거부 공격을 탐지합니다.</target>
        </trans-unit>
        <trans-unit id="a512b6978afa758b64c87ca8fb2b859560321f57" translate="yes" xml:space="preserve">
          <source>HTTP method registrations MUST include the following fields:

   o  Method Name (see &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;)

   o  Safe (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt;)

   o  Idempotent (&quot;yes&quot; or &quot;no&quot;, see &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTP 메소드 등록이 다음 필드를 포함해야한다 : 메소드 이름 (을)를합니다 ( &lt;a href=&quot;#section-4&quot;&gt;4 절&lt;/a&gt; 안전 오 ( &quot;예&quot;또는 &quot;아니오&quot;참조) &lt;a href=&quot;#section-4.2.1&quot;&gt;4.2.1 절&lt;/a&gt; ) 멱등 원 (冪等元) O ( &quot;예&quot;또는 &quot;아니오&quot;를 참조 &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; ) o 사양 텍스트에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;포인터이&lt;/a&gt; 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( 4.1 절 [RFC5226] 참조 ).</target>
        </trans-unit>
        <trans-unit id="7962f2b4e2fb00149a92feb9ef354150c4b8364c" translate="yes" xml:space="preserve">
          <source>HTTP methods</source>
          <target state="translated">HTTP 메소드</target>
        </trans-unit>
        <trans-unit id="16b2633fc11a6a9453f446495015f632c3dba72e" translate="yes" xml:space="preserve">
          <source>HTTP mostly relies on TCP for its transport protocol, providing a connection between the client and the server. In its infancy, HTTP used a single model to handle such connections. These connections were short-lived: a new one created each time a request needed sending, and closed once the answer had been received.</source>
          <target state="translated">HTTP는 주로 전송 프로토콜을 위해 TCP를 사용하여 클라이언트와 서버 간의 연결을 제공합니다. 초기 단계에서 HTTP는 단일 모델을 사용하여 이러한 연결을 처리했습니다. 이러한 연결은 수명이 짧았습니다. 요청이 전송 될 때마다 새 연결이 작성되고 응답이 수신되면 닫힙니다.</target>
        </trans-unit>
        <trans-unit id="e6523763c79c318a3d3099179709a1159fa699ff" translate="yes" xml:space="preserve">
          <source>HTTP pipelining</source>
          <target state="translated">HTTP 파이프 라이닝</target>
        </trans-unit>
        <trans-unit id="c04bfd419ae2ca3a5245f7e1492aab6d7596ed0e" translate="yes" xml:space="preserve">
          <source>HTTP pipelining is not activated by default in modern browsers:</source>
          <target state="translated">최신 브라우저에서는 HTTP 파이프 라이닝이 기본적으로 활성화되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0912d51b43dfca3b2cf9646a999e4cef417cee1d" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and
   authentication, via an extensible set of challenge-response
   authentication schemes, which can be used by a server to challenge a
   client request and by a client to provide authentication information.
   This document defines HTTP/1.1 authentication in terms of the
   architecture defined in &quot;Hypertext Transfer Protocol (HTTP/1.1):
   Message Syntax and Routing&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt;], including the general
   framework previously described in &quot;HTTP Authentication: Basic and
   Digest Access Authentication&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt;] and the related fields and
   status codes previously defined in &quot;Hypertext Transfer Protocol --
   HTTP/1.1&quot; [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;].

   The IANA Authentication Scheme Registry (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;) lists
   registered authentication schemes and their corresponding
   specifications, including the &quot;basic&quot; and &quot;digest&quot; authentication
   schemes previously defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;.</source>
          <target state="translated">HTTP는 서버가 클라이언트 요청에 대해 이의를 제기하고 클라이언트가 인증 정보를 제공하는 데 사용할 수있는 확장 가능한 인증 요청 응답 인증 체계를 통해 액세스 제어 및 인증을위한 일반적인 프레임 워크를 제공합니다. 이 문서는 이전에 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;에 설명 된 일반 프레임 워크를 포함하여 &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC7230&lt;/a&gt; ]에 정의 된 아키텍처와 관련하여 HTTP / 1.1 인증을 정의합니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC2617&lt;/a&gt; ] 및 &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;[ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 에서 이전에 정의 된 관련 필드 및 상태 코드 .IANA 인증 체계 레지스트리 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1&lt;/a&gt;)에는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617에서&lt;/a&gt; 미리 정의한 &quot;기본&quot;및 &quot;다이제스트&quot;인증 체계를 포함하여 등록 된 인증 체계 및 해당 사양이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="7885aa462dbdfaf51f0c394e3808399fbb15bff6" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. The most common HTTP authentication is based on the &quot;Basic&quot; schema. This page shows an introduction to the HTTP framework for authentication and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTP는 액세스 제어 및 인증을위한 일반적인 프레임 워크를 제공합니다. 가장 일반적인 HTTP 인증은 &quot;기본&quot;스키마를 기반으로합니다. 이 페이지는 인증을위한 HTTP 프레임 워크를 소개하고 HTTP &quot;기본&quot;스키마를 사용하여 서버에 대한 액세스를 제한하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="f0b556a167d090c37ed069f694278c1d0f8c8b55" translate="yes" xml:space="preserve">
          <source>HTTP provides a general framework for access control and authentication. This page is an introduction to the HTTP framework for authentication, and shows how to restrict access to your server using the HTTP &quot;Basic&quot; schema.</source>
          <target state="translated">HTTP는 액세스 제어 및 인증을위한 일반 프레임 워크를 제공합니다. 이 페이지는 인증을위한 HTTP 프레임 워크에 대한 소개이며 HTTP &quot;기본&quot;스키마를 사용하여 서버에 대한 액세스를 제한하는 방법을 보여줍니다.</target>
        </trans-unit>
        <trans-unit id="adbb32950149f0405fef2566ee545e5f42986bc6" translate="yes" xml:space="preserve">
          <source>HTTP provides a simple challenge-response authentication framework
   that can be used by a server to challenge a client request and by a
   client to provide authentication information.  It uses a case-
   insensitive token as a means to identify the authentication scheme,
   followed by additional information necessary for achieving 

   authentication via that scheme.  The latter can be either a comma-
   separated list of parameters or a single sequence of characters
   capable of holding base64-encoded information.

   Authentication parameters are name=value pairs, where the name token
   is matched case-insensitively, and each parameter name MUST only
   occur once per challenge.

     auth-scheme    = token

     auth-param     = token BWS &quot;=&quot; BWS ( token / quoted-string )

     token68        = 1*( ALPHA / DIGIT /
                          &quot;-&quot; / &quot;.&quot; / &quot;_&quot; / &quot;~&quot; / &quot;+&quot; / &quot;/&quot; ) *&quot;=&quot;

   The token68 syntax allows the 66 unreserved URI characters
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]), plus a few others, so that it can hold a base64,
   base64url (URL and filename safe alphabet), base32, or base16 (hex)
   encoding, with or without padding, but excluding whitespace
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt;]).

   A 401 (Unauthorized) response message is used by an origin server to
   challenge the authorization of a user agent, including a
   WWW-Authenticate header field containing at least one challenge
   applicable to the requested resource.

   A 407 (Proxy Authentication Required) response message is used by a
   proxy to challenge the authorization of a client, including a
   Proxy-Authenticate header field containing at least one challenge
   applicable to the proxy for the requested resource.

     challenge   = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

      Note: Many clients fail to parse a challenge that contains an
      unknown scheme.  A workaround for this problem is to list well-
      supported schemes (such as &quot;basic&quot;) first.

   A user agent that wishes to authenticate itself with an origin server
   -- usually, but not necessarily, after receiving a 401 (Unauthorized)
   -- can do so by including an Authorization header field with the
   request.

   A client that wishes to authenticate itself with a proxy -- usually,
   but not necessarily, after receiving a 407 (Proxy Authentication
   Required) -- can do so by including a Proxy-Authorization header
   field with the request. 

   Both the Authorization field value and the Proxy-Authorization field
   value contain the client's credentials for the realm of the resource
   being requested, based upon a challenge received in a response
   (possibly at some point in the past).  When creating their values,
   the user agent ought to do so by selecting the challenge with what it
   considers to be the most secure auth-scheme that it understands,
   obtaining credentials from the user as appropriate.  Transmission of
   credentials within header field values implies significant security
   considerations regarding the confidentiality of the underlying
   connection, as described in &lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;.

     credentials = auth-scheme [ 1*SP ( token68 / #auth-param ) ]

   Upon receipt of a request for a protected resource that omits
   credentials, contains invalid credentials (e.g., a bad password) or
   partial credentials (e.g., when the authentication scheme requires
   more than one round trip), an origin server SHOULD send a 401
   (Unauthorized) response that contains a WWW-Authenticate header field
   with at least one (possibly new) challenge applicable to the
   requested resource.

   Likewise, upon receipt of a request that omits proxy credentials or
   contains invalid or partial proxy credentials, a proxy that requires
   authentication SHOULD generate a 407 (Proxy Authentication Required)
   response that contains a Proxy-Authenticate header field with at
   least one (possibly new) challenge applicable to the proxy.

   A server that receives valid credentials that are not adequate to
   gain access ought to respond with the 403 (Forbidden) status code
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;Section&amp;nbsp;6.5.3 of [RFC7231]&lt;/a&gt;).

   HTTP does not restrict applications to this simple challenge-response
   framework for access authentication.  Additional mechanisms can be
   used, such as authentication at the transport level or via message
   encapsulation, and with additional header fields specifying
   authentication information.  However, such additional mechanisms are
   not defined by this specification.</source>
          <target state="translated">HTTP는 서버가 클라이언트 요청에 도전하고 클라이언트가 인증 정보를 제공하는 데 사용할 수있는 간단한 시도 응답 인증 프레임 워크를 제공합니다. 인증 체계를 식별하는 수단으로 대소 문자를 구분하지 않는 토큰을 사용하고 해당 체계를 통한 인증을 달성하는 데 필요한 추가 정보가 이어집니다. 후자는 쉼표로 구분 된 매개 변수 목록이거나 base64로 인코딩 된 정보를 보유 할 수있는 단일 문자 시퀀스 일 수 있습니다. 인증 매개 변수는 이름 = 값 쌍이며 이름 토큰은 대소 문자를 구분하지 않으며 각 매개 변수 이름은 시도당 한 번만 발생해야합니다. auth-scheme = 토큰 auth-param = 토큰 BWS &quot;=&quot;BWS (token / quoted-string) token68 = 1 * (ALPHA / DIGIT / &quot;-&quot;/ &quot;.&quot;/ &quot;_&quot;/ &quot;~&quot;/ &quot;+&quot;/ &quot;/&quot;) * &quot;=&quot;token68 구문은 66 개의 예약되지 않은 URI 문자 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;&lt;/a&gt;패딩 유무에 관계없이 base64, base64url (URL 및 파일 이름 안전 알파벳), base32 또는 base16 (16 진) 인코딩을 포함 할 수 있지만 공백은 제외 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC4648&lt;/a&gt; ) 할 수 있도록 RFC3986 ])]). 요청 된 자원에 적용 가능한 하나 이상의 시도를 포함하는 WWW-Authenticate 헤더 필드를 포함하여 사용자 에이전트의 권한 부여에 도전하기 위해 오리진 서버가 401 (무단) 응답 메시지를 사용합니다. 407 (프록시 인증 필요) 응답 메시지는 프록시가 요청 된 자원의 프록시에 적용 할 수있는 하나 이상의 시도를 포함하는 프록시 인증 헤더 필드를 포함하여 클라이언트의 권한 부여에 도전하는 데 사용됩니다. challenge = auth-scheme [1 * SP (token68 / # auth-param)] 참고 : 많은 클라이언트가 알 수없는 체계가 포함 된 시도를 구문 분석하지 못합니다. 이 문제의 해결 방법은 잘 지원되는 체계 (예 : &quot;기본&quot;)를 먼저 나열하는 것입니다. 오리진 서버로 인증하려는 사용자 에이전트-일반적으로401 (권한 없음)을받은 후 요청에 Authorization 헤더 필드를 포함하면됩니다. 프록시로 자신을 인증하려는 클라이언트 (보통 407 (프록시 인증 필요)를 수신 한 후 반드시 그렇지는 않음)는 요청에 프록시 인증 헤더 필드를 포함하여 인증 할 수 있습니다. Authorization 필드 값과 Proxy-Authorization 필드 값은 모두 응답에서 수신 된 챌린지 (이전의 어느 시점에서)에 따라 요청되는 자원 영역에 대한 클라이언트의 자격 증명을 포함합니다. 값을 생성 할 때 사용자 에이전트는 이해하는 가장 안전한 인증 체계로 간주되는 도전 과제를 선택하여 사용자로부터 자격 증명을 가져와야합니다.헤더 필드 값 내에서 자격 증명을 전송하면 기본 연결의 기밀성과 관련하여 중요한 보안 고려 사항이 나타납니다.&lt;a href=&quot;#section-6.1&quot;&gt;섹션 6.1&lt;/a&gt;. 자격 증명 = auth-scheme [1 * SP (token68 / # auth-param)] 자격 증명을 생략하고 잘못된 자격 증명 (예 : 잘못된 암호) 또는 부분 자격 증명 (예 : 인증시)을 포함하는 보호 된 리소스에 대한 요청을 수신하면 스킴에는 둘 이상의 왕복이 필요합니다), 오리진 서버는 요청 된 자원에 적용 할 수있는 하나 이상의 도전 과제가있는 WWW 인증 헤더 필드를 포함하는 401 (권한 없음) 응답을 보내야합니다. 마찬가지로, 프록시 자격 증명을 생략하거나 유효하지 않거나 부분적인 프록시 자격 증명을 포함하는 요청을 수신하면 인증이 필요한 프록시는 최소한 하나의 프록시 인증 헤더 필드를 포함하는 407 (프록시 인증 필요) 응답을 생성해야합니다. 프록시에 적용 할 수 있습니다.액세스하기에 적합하지 않은 유효한 자격 증명을 수신 한 서버는 403 (금지 된) 상태 코드 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.5.3&quot;&gt;[RFC7231]의 섹션 6.5.3&lt;/a&gt; ). HTTP는 애플리케이션을 액세스 인증을위한이 간단한 시도-응답 프레임 워크로 제한하지 않습니다. 전송 수준 또는 메시지 캡슐화를 통한 인증 및 인증 정보를 지정하는 추가 헤더 필드와 같은 추가 메커니즘을 사용할 수 있습니다. 그러나 이러한 추가 메커니즘은이 사양에서 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="373942ad0bad321a26d1a83f0200afd58d5697de" translate="yes" xml:space="preserve">
          <source>HTTP provides several OPTIONAL challenge-response authentication
   mechanisms which can be used by a server to challenge a client
   request and by a client to provide authentication information. The
   general framework for access authentication, and the specification of
   &quot;basic&quot; and &quot;digest&quot; authentication, are specified in &quot;HTTP
   Authentication: Basic and Digest Access Authentication&quot; [&lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt;]. This
   specification adopts the definitions of &quot;challenge&quot; and &quot;credentials&quot;
   from that specification.</source>
          <target state="translated">HTTP는 서버가 클라이언트 요청에 대해 이의를 제기하고 클라이언트가 인증 정보를 제공하는 데 사용할 수있는 몇 가지 선택적인 이의 제기-응답 인증 메커니즘을 제공합니다. 액세스 인증을위한 일반적인 프레임 워크 및 &quot;기본&quot;및 &quot;다이제스트&quot;인증 사양은 &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;[ &lt;a href=&quot;#ref-43&quot;&gt;43&lt;/a&gt; ]에 지정되어 있습니다. 이 사양은 해당 사양에서 &quot;도전&quot;및 &quot;자격 증명&quot;의 정의를 채택합니다.</target>
        </trans-unit>
        <trans-unit id="a37a5613d3d5d4214d5abfa3246a8f2754483f2a" translate="yes" xml:space="preserve">
          <source>HTTP range requests allow to send only a portion of an HTTP message from a server to a client. Partial requests are useful for large media or downloading files with pause and resume functions, for example.</source>
          <target state="translated">HTTP 범위 요청을 사용하면 서버에서 클라이언트로 HTTP 메시지의 일부만 보낼 수 있습니다. 예를 들어, 부분 요청은 큰 미디어 나 일시 중지 및 다시 시작 기능이있는 파일을 다운로드하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f0381d73cd3211cb7f1d5c958b65d38f42cff6af" translate="yes" xml:space="preserve">
          <source>HTTP redirects always execute first &amp;mdash; they exist when there is not even a transmitted page.</source>
          <target state="translated">HTTP 리디렉션은 항상 먼저 실행되며 전송 된 페이지도 없을 때 존재합니다.</target>
        </trans-unit>
        <trans-unit id="5389896e588834f2b24421a83cb0356215da18cf" translate="yes" xml:space="preserve">
          <source>HTTP redirects are always executed first when there is not even a page transmitted, and of course not even read.</source>
          <target state="translated">HTTP 리디렉션은 항상 페이지가 전송되지 않고 물론 읽지도 않을 때 항상 먼저 실행됩니다.</target>
        </trans-unit>
        <trans-unit id="7fcfef93fd3c40ba7ae279fc8feebbaed226cca1" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the best way to create redirections, but sometimes you don't have control over the server. In that case, try a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;Refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will go to the indicated URL.</source>
          <target state="translated">HTTP 리디렉션은 리디렉션을 만드는 가장 좋은 방법이지만 때로는 서버를 제어 할 수 없습니다. 이 경우 페이지 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 속성이 &lt;code&gt;Refresh&lt;/code&gt; 로 설정된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용해보십시오 . 페이지를 표시 할 때 브라우저는 표시된 URL로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="b493de0ada593e9de6d698d017989888be7557a7" translate="yes" xml:space="preserve">
          <source>HTTP redirects are the preferred way to create redirections, but sometimes the Web developer doesn't have control over the server or cannot configure it. For these specific cases, the Web developers can craft an HTML page with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element and the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;refresh&lt;/code&gt; in the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;&lt;/a&gt; of the page. When displaying the page, the browser will find this element and will go to the indicated page.</source>
          <target state="translated">HTTP 리디렉션은 리디렉션을 만드는 데 선호되는 방법이지만 웹 개발자가 서버를 제어하지 않거나 구성 할 수없는 경우가 있습니다. 이러한 특정 경우에 웹 개발자는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소와 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 속성 이 페이지 의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/head&quot;&gt; &lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt; &lt;/a&gt; 에서 &lt;code&gt;refresh&lt;/code&gt; 으로 설정된 HTML 페이지를 만들 수 있습니다 . 페이지를 표시 할 때 브라우저는이 요소를 찾아 표시된 페이지로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="40e98c57f45ddbbd1f7fd8fe0e605fd5413464d7" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two other methods: HTML redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, and JavaScript redirections using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM&lt;/a&gt;.</source>
          <target state="translated">HTTP 리디렉션이 리디렉션을 정의하는 유일한 방법은 아닙니다. 다른 방법으로는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하는 HTML 리디렉션 과 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model&quot;&gt;DOM을&lt;/a&gt; 사용하는 JavaScript 리디렉션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="862c8627d2b4f34ae450a4e001c8246586866cf8" translate="yes" xml:space="preserve">
          <source>HTTP redirects aren't the only way to define redirections. There are two others:</source>
          <target state="translated">HTTP 리디렉션이 리디렉션을 정의하는 유일한 방법은 아닙니다. 다른 두 가지가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36f59fe5f8bdc78024da5c64132db3a21db48277" translate="yes" xml:space="preserve">
          <source>HTTP referer on Wikipedia</source>
          <target state="translated">Wikipedia의 HTTP 참조 자</target>
        </trans-unit>
        <trans-unit id="7695bd9fd17d8eeddb124e64ff2e516e51ad7340" translate="yes" xml:space="preserve">
          <source>HTTP relies on the notion of an authoritative response: a response
   that has been determined by (or at the direction of) the authority
   identified within the target URI to be the most appropriate response
   for that request given the state of the target resource at the time
   of response message origination.  Providing a response from a
   non-authoritative source, such as a shared cache, is often useful to
   improve performance and availability, but only to the extent that the
   source can be trusted or the distrusted response can be safely used.

   Unfortunately, establishing authority can be difficult.  For example,
   phishing is an attack on the user's perception of authority, where
   that perception can be misled by presenting similar branding in 

   hypertext, possibly aided by userinfo obfuscating the authority
   component (see &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;).  User agents can reduce the impact of
   phishing attacks by enabling users to easily inspect a target URI
   prior to making an action, by prominently distinguishing (or
   rejecting) userinfo when present, and by not sending stored
   credentials and cookies when the referring document is from an
   unknown or untrusted source.

   When a registered name is used in the authority component, the &quot;http&quot;
   URI scheme (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) relies on the user's local name resolution
   service to determine where it can find authoritative responses.  This
   means that any attack on a user's network host table, cached names,
   or name resolution libraries becomes an avenue for attack on
   establishing authority.  Likewise, the user's choice of server for
   Domain Name Service (DNS), and the hierarchy of servers from which it
   obtains resolution results, could impact the authenticity of address
   mappings; DNS Security Extensions (DNSSEC, [&lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt;]) are one way to
   improve authenticity.

   Furthermore, after an IP address is obtained, establishing authority
   for an &quot;http&quot; URI is vulnerable to attacks on Internet Protocol
   routing.

   The &quot;https&quot; scheme (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) is intended to prevent (or at
   least reveal) many of these potential attacks on establishing
   authority, provided that the negotiated TLS connection is secured and
   the client properly verifies that the communicating server's identity
   matches the target URI's authority component (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;]).
   Correctly implementing such verification can be difficult (see
   [&lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]).</source>
          <target state="translated">HTTP는 신뢰할 수있는 응답의 개념에 의존합니다. 대상 URI 내에서 식별 된 권한에 의해 당시 대상 자원의 상태가 주어진 경우 해당 요청에 가장 적합한 응답으로 결정된 응답 응답 메시지 발신 공유 캐시와 같이 권한이없는 소스에서 응답을 제공하면 성능과 가용성을 향상시키는 데 유용하지만 소스를 신뢰할 수 있거나 신뢰할 수없는 응답을 안전하게 사용할 수있는 경우에만 유용합니다. 불행히도 권위를 확립하는 것은 어려울 수 있습니다. 예를 들어 피싱은 사용자의 권위 인식에 대한 공격이며, 하이퍼 텍스트에 유사한 브랜딩을 제공함으로써 인식이 잘못 될 수 있습니다.권한 구성 요소를 난독 처리하는 userinfo가 도움을 줄 수 있음 (참조&lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; ). 사용자 에이전트는 사용자가 조치를 취하기 전에 대상 URI를 쉽게 검사 할 수있게하고, 존재하는 경우 사용자 정보를 눈에 띄게 구별 (또는 거부)하고 참조 문서가 제공되는 경우 저장된 자격 증명 및 쿠키를 보내지 않음으로써 피싱 공격의 영향을 줄일 수 있습니다. 알 수 없거나 신뢰할 수없는 출처. 권한 구성 요소에 등록 된 이름이 사용되는 경우 &quot;http&quot;URI 체계 ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1)&lt;/a&gt;)는 사용자의 로컬 이름 확인 서비스를 사용하여 신뢰할 수있는 응답을 찾을 수있는 위치를 결정합니다. 이는 사용자의 네트워크 호스트 테이블, 캐시 된 이름 또는 이름 확인 라이브러리에 대한 공격이 권한 설정에 대한 공격의 수단이됨을 의미합니다. 마찬가지로 DNS (Domain Name Service)를위한 사용자의 서버 선택 및 해결 결과를 얻는 서버 계층은 주소 매핑의 신뢰성에 영향을 줄 수 있습니다. DNS 보안 확장 (DNSSEC, [ &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC4033&lt;/a&gt; ])은 진위를 향상시키는 한 가지 방법입니다. 또한 IP 주소를 얻은 후에 &quot;http&quot;URI에 대한 권한을 설정하면 인터넷 프로토콜 라우팅 공격에 취약합니다. &quot;https&quot;체계 ( &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt;)는 협상 된 TLS 연결이 보호되고 클라이언트가 통신 서버의 ID가 대상 URI의 권한 구성 요소와 일치하는지 올바르게 확인한 경우 권한 설정에 대한 이러한 많은 잠재적 인 공격을 방지 (또는 적어도 공개)하기위한 것입니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt; 참조 ). . 이러한 확인을 올바르게 구현하는 것은 어려울 수 있습니다 ([ &lt;a href=&quot;#ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt; ] 참조 ).</target>
        </trans-unit>
        <trans-unit id="9f50e4941b29dd7e65e26b2c2ee8f27fd3643197" translate="yes" xml:space="preserve">
          <source>HTTP relies on underlying transport protocols to provide message
   confidentiality when that is desired.  HTTP has been specifically
   designed to be independent of the transport protocol, such that it
   can be used over many different forms of encrypted connection, with
   the selection of such transports being identified by the choice of
   URI scheme or within user agent configuration.

   The &quot;https&quot; scheme can be used to identify resources that require a
   confidential connection, as described in &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;.</source>
          <target state="translated">HTTP는 기본 전송 프로토콜을 사용하여 원하는 경우 메시지 기밀성을 제공합니다. HTTP는 전송 프로토콜과 독립적으로 특별히 설계되어, 다양한 형식의 암호화 된 연결을 통해 사용될 수 있으며, 이러한 전송의 선택은 URI 체계의 선택 또는 사용자 에이전트 구성 내에서 식별됩니다. &quot;https&quot;체계는 &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2에&lt;/a&gt; 설명 된 것처럼 기밀 연결이 필요한 자원을 식별하는 데 사용될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5cfd05af6cff4f10fa13fcdf1e53531e0f64c32a" translate="yes" xml:space="preserve">
          <source>HTTP request message routing is determined by each client based on
   the target resource, the client's proxy configuration, and
   establishment or reuse of an inbound connection.  The corresponding
   response routing follows the same connection chain back to the
   client.</source>
          <target state="translated">HTTP 요청 메시지 라우팅은 대상 리소스, 클라이언트의 프록시 구성 및 인바운드 연결 설정 또는 재사용을 기반으로 각 클라이언트에 의해 결정됩니다. 해당 응답 라우팅은 동일한 연결 체인을 따라 클라이언트로 다시 연결됩니다.</target>
        </trans-unit>
        <trans-unit id="2c8a5e9aaefc55ae6f8b58628a6a46daf09140bd" translate="yes" xml:space="preserve">
          <source>HTTP request methods</source>
          <target state="translated">HTTP 요청 방법</target>
        </trans-unit>
        <trans-unit id="13dd6cb8837a7e513f219955d516b3e87a62005c" translate="yes" xml:space="preserve">
          <source>HTTP requests are messages sent by the client to initiate an action on the server. Their &lt;em&gt;start-line&lt;/em&gt; contain three elements:</source>
          <target state="translated">HTTP 요청은 서버에서 작업을 시작하기 위해 클라이언트가 보낸 메시지입니다. 그들의 &lt;em&gt;시작 줄&lt;/em&gt; 세 가지 요소를 포함 :</target>
        </trans-unit>
        <trans-unit id="914464e25e17836661d23d43c1739c512c319a50" translate="yes" xml:space="preserve">
          <source>HTTP requests, and responses, share similar structure and are composed of:</source>
          <target state="translated">HTTP 요청 및 응답은 유사한 구조를 공유하며 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="baed8872df40013bfa5b06f559f07e0a29344282" translate="yes" xml:space="preserve">
          <source>HTTP response codes indicate whether a specific HTTP request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirections, client errors, and servers errors.</source>
          <target state="translated">HTTP 응답 코드는 특정 HTTP 요청이 성공적으로 완료되었는지 여부를 나타냅니다. 응답은 정보 응답, 성공적인 응답, 리디렉션, 클라이언트 오류 및 서버 오류의 다섯 가지 클래스로 그룹화됩니다.</target>
        </trans-unit>
        <trans-unit id="0e68989f0a2de628c6a35155870120ca03c2f18a" translate="yes" xml:space="preserve">
          <source>HTTP response header field instructs the user agent to store reporting endpoints for an origin.</source>
          <target state="translated">HTTP 응답 헤더 필드는 사용자 에이전트가 오리진에 대한보고 엔드 포인트를 저장하도록 지시합니다.</target>
        </trans-unit>
        <trans-unit id="9bae5d05ad944fb1e294a99bcffd4e35229e257f" translate="yes" xml:space="preserve">
          <source>HTTP response status codes</source>
          <target state="translated">HTTP 응답 상태 코드</target>
        </trans-unit>
        <trans-unit id="b57d1200b41d22a049735dbac8f54f4cf988cf0d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes:</source>
          <target state="translated">HTTP 응답 상태 코드는 특정 &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; 요청이 성공적으로 완료 되었는지 여부를 나타냅니다 . 응답은 5 가지 클래스로 분류됩니다.</target>
        </trans-unit>
        <trans-unit id="0c76e508f304e725a4ab9639fbe06b8e54f58b4d" translate="yes" xml:space="preserve">
          <source>HTTP response status codes indicate whether a specific &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; request has been successfully completed. Responses are grouped in five classes: informational responses, successful responses, redirects, client errors, and servers errors. Status codes are defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;section 10 of RFC 2616&lt;/a&gt;.</source>
          <target state="translated">HTTP 응답 상태 코드는 특정 &lt;a href=&quot;index&quot;&gt;HTTP&lt;/a&gt; 요청이 성공적으로 완료 되었는지 여부를 나타냅니다 . 응답은 정보 응답, 성공적인 응답, 리디렉션, 클라이언트 오류 및 서버 오류의 5 가지 클래스로 그룹화됩니다. 상태 코드는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-10&quot;&gt;RFC 2616의 섹션 10에&lt;/a&gt; 의해 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="b5a6f42d4f42646541a1cb9ef004b15fc1e9d233" translate="yes" xml:space="preserve">
          <source>HTTP retrieval requests using conditional or unconditional GET
   methods MAY request one or more sub-ranges of the entity, instead of
   the entire entity, using the Range request header, which applies to
   the entity returned as the result of the request:

      Range = &quot;Range&quot; &quot;:&quot; ranges-specifier 

   A server MAY ignore the Range header. However, HTTP/1.1 origin
   servers and intermediate caches ought to support byte ranges when
   possible, since Range supports efficient recovery from partially
   failed transfers, and supports efficient partial retrieval of large
   entities.

   If the server supports the Range header and the specified range or
   ranges are appropriate for the entity:

      - The presence of a Range header in an unconditional GET modifies
        what is returned if the GET is otherwise successful. In other
        words, the response carries a status code of 206 (Partial
        Content) instead of 200 (OK).

      - The presence of a Range header in a conditional GET (a request
        using one or both of If-Modified-Since and If-None-Match, or
        one or both of If-Unmodified-Since and If-Match) modifies what
        is returned if the GET is otherwise successful and the
        condition is true. It does not affect the 304 (Not Modified)
        response returned if the conditional is false.

   In some cases, it might be more appropriate to use the If-Range
   header (see &lt;a href=&quot;#section-14.27&quot;&gt;section 14.27&lt;/a&gt;) in addition to the Range header.

   If a proxy that supports ranges receives a Range request, forwards
   the request to an inbound server, and receives an entire entity in
   reply, it SHOULD only return the requested range to its client. It
   SHOULD store the entire received response in its cache if that is
   consistent with its cache allocation policies.</source>
          <target state="translated">조건부 또는 무조건 GET 메소드를 사용한 HTTP 검색 요청은 범위 요청 헤더를 사용하여 전체 엔티티 대신 엔티티의 하나 이상의 하위 범위를 요청할 수 있습니다 (범위 결과 헤더 : 요청의 결과로 리턴 된 엔티티에 적용됨). &quot;&quot;: &quot;ranges-specifier 서버는 Range 헤더를 무시할 수있다. 그러나 HTTP / 1.1 오리진 서버 및 중간 캐시는 가능한 경우 바이트 범위를 지원해야합니다. 범위는 부분적으로 실패한 전송에서 효율적인 복구를 지원하고 큰 엔티티의 효율적인 부분 검색을 지원하기 때문입니다. 서버가 Range 헤더를 지원하고 지정된 범위가 엔티티에 적합한 경우 :-무조건 GET에 Range 헤더가 있으면 GET이 성공한 경우 리턴되는 항목이 수정됩니다.즉, 응답에는 200 (OK) 대신 상태 코드 206 (부분 컨텐츠)이 있습니다. -조건부 GET에 Range 헤더가 있으면 (If-Modified-Since 및 If-None-Match 중 하나 또는 둘 다를 사용하거나 If-Unmodified-Since 및 If-Match 중 하나 또는 둘 다를 사용하는 요청) 반환되는 항목을 수정합니다. 그렇지 않으면 GET이 성공하고 조건이 참인 경우 조건부가 false 인 경우 반환 된 304 (수정되지 않음) 응답에는 영향을 미치지 않습니다. 경우에 따라 If-Range 헤더를 사용하는 것이 더 적절할 수 있습니다 (참조또는 If-Unmodified-Since 및 If-Match) 중 하나 또는 둘다는 GET이 성공하고 조건이 true 인 경우 반환되는 내용을 수정합니다. 조건부가 false 인 경우 반환 된 304 (수정되지 않음) 응답에는 영향을 미치지 않습니다. 경우에 따라 If-Range 헤더를 사용하는 것이 더 적절할 수 있습니다 (참조또는 If-Unmodified-Since 및 If-Match) 중 하나 또는 둘다는 GET이 성공하고 조건이 true 인 경우 반환되는 내용을 수정합니다. 조건부가 false 인 경우 반환 된 304 (수정되지 않음) 응답에는 영향을 미치지 않습니다. 경우에 따라 If-Range 헤더를 사용하는 것이 더 적절할 수 있습니다 (참조&lt;a href=&quot;#section-14.27&quot;&gt;&lt;/a&gt;Range 헤더 외에도 14.27 섹션 ). 범위를 지원하는 프록시가 범위 요청을 수신하고 요청을 인바운드 서버로 전달하고 전체 엔티티를 응답으로 수신하는 경우 요청 된 범위 만 클라이언트에게 리턴해야합니다. 캐시 할당 정책과 일치하는 경우 수신 된 전체 응답을 캐시에 저장해야합니다.</target>
        </trans-unit>
        <trans-unit id="764bdb74b95275c85a8d7aa1fe3fe82d3d5e9d0f" translate="yes" xml:space="preserve">
          <source>HTTP status: &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/202&quot;&gt;&lt;code&gt;202&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">HTTP 상태 : &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/202&quot;&gt; &lt;code&gt;202&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="96e2aaa2653ba0ee26b576dfaebf0854b040cb7a" translate="yes" xml:space="preserve">
          <source>HTTP tunneling</source>
          <target state="translated">HTTP 터널링</target>
        </trans-unit>
        <trans-unit id="269219e381ce4221eb783ce2498c82ac2c3eba0d" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet Media Types [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;] in the Content-Type (&lt;a href=&quot;#section-14.17&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;) header fields in order to provide
   open and extensible data typing and type negotiation.

       media-type     = type &quot;/&quot; subtype *( &quot;;&quot; parameter )
       type           = token
       subtype        = token

   Parameters MAY follow the type/subtype in the form of attribute/value
   pairs (as defined in &lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;).

   The type, subtype, and parameter attribute names are case-
   insensitive. Parameter values might or might not be case-sensitive,
   depending on the semantics of the parameter name. Linear white space
   (LWS) MUST NOT be used between the type and subtype, nor between an
   attribute and its value. The presence or absence of a parameter might
   be significant to the processing of a media-type, depending on its
   definition within the media type registry. 

   Note that some older HTTP applications do not recognize media type
   parameters. When sending data to older HTTP applications,
   implementations SHOULD only use media type parameters when they are
   required by that type/subtype definition.

   Media-type values are registered with the Internet Assigned Number
   Authority (IANA [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). The media type registration process is
   outlined in &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [&lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt;]. Use of non-registered media types is
   discouraged.</source>
          <target state="translated">HTTP는 개방형 및 확장 가능한 데이터 타이핑 및 유형 협상을 제공하기 위해 Content-Type ( &lt;a href=&quot;#section-14.17&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.17&quot;&gt;14.17&lt;/a&gt; ) 및 Accept ( &lt;a href=&quot;#section-14.1&quot;&gt;섹션 14.1&lt;/a&gt; ) 헤더 필드에서 인터넷 미디어 유형 [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]을 사용합니다 . media-type = type &quot;/&quot;subtype * ( &quot;;&quot;parameter) type = token subtype = token 매개 변수 &lt;a href=&quot;#section-3.6&quot;&gt;(3.6 절에&lt;/a&gt; 정의 된 속성 / 값 쌍의 형태로 유형 / 하위 유형을 따를 수 있음)). 유형, 하위 유형 및 매개 변수 속성 이름은 대소 문자를 구분하지 않습니다. 매개 변수 이름의 의미에 따라 매개 변수 값은 대소 문자를 구분하거나 구분하지 않을 수 있습니다. 선형 공백 (LWS)은 유형과 하위 유형 사이 또는 속성과 해당 값 사이에 사용해서는 안됩니다. 매개 변수의 유무는 매체 유형 레지스트리에서의 정의에 따라 매체 유형의 처리에 중요 할 수 있습니다. 일부 오래된 HTTP 응용 프로그램은 미디어 유형 매개 변수를 인식하지 못합니다. 이전 HTTP 응용 프로그램으로 데이터를 보낼 때 구현시 해당 유형 / 하위 유형 정의에 필요한 미디어 유형 매개 변수 만 사용해야합니다. 미디어 유형 값은 IANA (Internet Assigned Number Authority)에 등록됩니다 [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;]). 미디어 유형 등록 프로세스는 &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; [ &lt;a href=&quot;#ref-17&quot;&gt;17&lt;/a&gt; ]에 요약되어 있습니다. 등록되지 않은 용지 종류는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="b80bb07a4e60213a6bb04971b80d505cc84d5109" translate="yes" xml:space="preserve">
          <source>HTTP uses Internet media types [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] in the Content-Type
   (&lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;) and Accept (&lt;a href=&quot;#section-5.3.2&quot;&gt;Section 5.3.2&lt;/a&gt;) header fields in order
   to provide open and extensible data typing and type negotiation.
   Media types define both a data format and various processing models:
   how to process that data in accordance with each context in which it
   is received.

     media-type = type &quot;/&quot; subtype *( OWS &quot;;&quot; OWS parameter )
     type       = token
     subtype    = token

   The type/subtype MAY be followed by parameters in the form of
   name=value pairs.

     parameter      = token &quot;=&quot; ( token / quoted-string ) 

   The type, subtype, and parameter name tokens are case-insensitive.
   Parameter values might or might not be case-sensitive, depending on
   the semantics of the parameter name.  The presence or absence of a
   parameter might be significant to the processing of a media-type,
   depending on its definition within the media type registry.

   A parameter value that matches the token production can be
   transmitted either as a token or within a quoted-string.  The quoted
   and unquoted values are equivalent.  For example, the following
   examples are all equivalent, but the first is preferred for
   consistency:

     text/html;charset=utf-8
     text/html;charset=UTF-8
     Text/HTML;Charset=&quot;utf-8&quot;
     text/html; charset=&quot;utf-8&quot;

   Internet media types ought to be registered with IANA according to
   the procedures defined in [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;].

      Note: Unlike some similar constructs in other header fields, media
      type parameters do not allow whitespace (even &quot;bad&quot; whitespace)
      around the &quot;=&quot; character.</source>
          <target state="translated">HTTP는 콘텐츠 유형 ( &lt;a href=&quot;#section-3.1.1.5&quot;&gt;3.1.1.5&lt;/a&gt; ) 및 인터넷 &lt;a href=&quot;#section-5.3.2&quot;&gt;섹션 (5.3.2&lt;/a&gt; ) 에서 인터넷 미디어 유형 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt; ]을 사용합니다.) 헤더 필드를 사용하여 확장 가능한 개방형 데이터 입력 및 유형 협상을 제공합니다. 미디어 유형은 데이터 형식과 다양한 처리 모델을 정의합니다. 데이터가 수신되는 각 컨텍스트에 따라 해당 데이터를 처리하는 방법. media-type = type &quot;/&quot;subtype * (OWS &quot;;&quot;OWS parameter) type = token subtype = token type / subtype 뒤에 name = value 쌍 형식의 매개 변수가 올 수 있습니다. parameter = token &quot;=&quot;(token / quoted-string) 유형, 하위 유형 및 매개 변수 이름 토큰은 대소 문자를 구분하지 않습니다. 매개 변수 이름의 의미에 따라 매개 변수 값은 대소 문자를 구분하거나 구분하지 않을 수 있습니다. 매개 변수의 유무는 매체 유형의 처리에 중요 할 수 있습니다.미디어 유형 레지스트리 내의 정의에 따라 토큰 생성과 일치하는 매개 변수 값은 토큰으로 또는 인용 문자열로 전송 될 수 있습니다. 인용 및 인용되지 않은 값은 동일합니다. 예를 들어, 다음 예제는 모두 동일하지만 첫 번째는 일관성을 위해 선호됩니다. text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot;text / html ; charset = &quot;utf-8&quot;인터넷 미디어 유형은 [에 정의 된 절차에 따라 IANA에 등록해야합니다그러나 첫 번째는 일관성을 위해 선호됩니다 : text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot;text / html; charset = &quot;utf-8&quot;인터넷 미디어 유형은 [에 정의 된 절차에 따라 IANA에 등록해야합니다그러나 첫 번째는 일관성을 위해 선호됩니다 : text / html; charset = utf-8 text / html; charset = UTF-8 Text / HTML; Charset = &quot;utf-8&quot;text / html; charset = &quot;utf-8&quot;인터넷 미디어 유형은 [에 정의 된 절차에 따라 IANA에 등록해야합니다&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ]. 참고 : 다른 헤더 필드의 유사한 구성과 달리 미디어 유형 매개 변수는 &quot;=&quot;문자 주위에 공백 ( &quot;나쁜&quot;공백)을 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="aa6f0f90fa306d4b1ed46d12bd83446d94bb910c" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol.  This specification defines version &quot;1.1&quot;.  The
   protocol version as a whole indicates the sender's conformance with
   the set of requirements laid out in that version's corresponding
   specification of HTTP. 

   The version of an HTTP message is indicated by an HTTP-version field
   in the first line of the message.  HTTP-version is case-sensitive.

     HTTP-version  = HTTP-name &quot;/&quot; DIGIT &quot;.&quot; DIGIT
     HTTP-name     = %x48.54.54.50 ; &quot;HTTP&quot;, case-sensitive

   The HTTP version number consists of two decimal digits separated by a
   &quot;.&quot; (period or decimal point).  The first digit (&quot;major version&quot;)
   indicates the HTTP messaging syntax, whereas the second digit (&quot;minor
   version&quot;) indicates the highest minor version within that major
   version to which the sender is conformant and able to understand for
   future communication.  The minor version advertises the sender's
   communication capabilities even when the sender is only using a
   backwards-compatible subset of the protocol, thereby letting the
   recipient know that more advanced features can be used in response
   (by servers) or in future requests (by clients).

   When an HTTP/1.1 message is sent to an HTTP/1.0 recipient [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;]
   or a recipient whose version is unknown, the HTTP/1.1 message is
   constructed such that it can be interpreted as a valid HTTP/1.0
   message if all of the newer features are ignored.  This specification
   places recipient-version requirements on some new features so that a
   conformant sender will only use compatible features until it has
   determined, through configuration or the receipt of a message, that
   the recipient supports HTTP/1.1.

   The interpretation of a header field does not change between minor
   versions of the same major HTTP version, though the default behavior
   of a recipient in the absence of such a field can change.  Unless
   specified otherwise, header fields defined in HTTP/1.1 are defined
   for all versions of HTTP/1.x.  In particular, the Host and Connection
   header fields ought to be implemented by all HTTP/1.x implementations
   whether or not they advertise conformance with HTTP/1.1.

   New header fields can be introduced without changing the protocol
   version if their defined semantics allow them to be safely ignored by
   recipients that do not recognize them.  Header field extensibility is
   discussed in &lt;a href=&quot;#section-3.2.1&quot;&gt;Section 3.2.1&lt;/a&gt;.

   Intermediaries that process HTTP messages (i.e., all intermediaries
   other than those acting as tunnels) MUST send their own HTTP-version
   in forwarded messages.  In other words, they are not allowed to
   blindly forward the first line of an HTTP message without ensuring
   that the protocol version in that message matches a version to which
   that intermediary is conformant for both the receiving and sending of
   messages.  Forwarding an HTTP message without rewriting the 

   HTTP-version might result in communication errors when downstream
   recipients use the message sender's version to determine what
   features are safe to use for later communication with that sender.

   A client SHOULD send a request version equal to the highest version
   to which the client is conformant and whose major version is no
   higher than the highest version supported by the server, if this is
   known.  A client MUST NOT send a version to which it is not
   conformant.

   A client MAY send a lower request version if it is known that the
   server incorrectly implements the HTTP specification, but only after
   the client has attempted at least one normal request and determined
   from the response status code or header fields (e.g., Server) that
   the server improperly handles higher request versions.

   A server SHOULD send a response version equal to the highest version
   to which the server is conformant that has a major version less than
   or equal to the one received in the request.  A server MUST NOT send
   a version to which it is not conformant.  A server can send a 505
   (HTTP Version Not Supported) response if it wishes, for any reason,
   to refuse service of the client's major protocol version.

   A server MAY send an HTTP/1.0 response to a request if it is known or
   suspected that the client incorrectly implements the HTTP
   specification and is incapable of correctly processing later version
   responses, such as when a client fails to parse the version number
   correctly or when an intermediary is known to blindly forward the
   HTTP-version even when it doesn't conform to the given minor version
   of the protocol.  Such protocol downgrades SHOULD NOT be performed
   unless triggered by specific client attributes, such as when one or
   more of the request header fields (e.g., User-Agent) uniquely match
   the values sent by a client known to be in error.

   The intention of HTTP's versioning design is that the major number
   will only be incremented if an incompatible message syntax is
   introduced, and that the minor number will only be incremented when
   changes made to the protocol have the effect of adding to the message
   semantics or implying additional capabilities of the sender.
   However, the minor version was not incremented for the changes
   introduced between [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt;] and [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], and this revision has
   specifically avoided any such changes to the protocol.

   When an HTTP message is received with a major version number that the
   recipient implements, but a higher minor version number than what the
   recipient implements, the recipient SHOULD process the message as if
   it were in the highest minor version within that major version to
   which the recipient is conformant.  A recipient can assume that a 

   message with a higher minor version, when sent to a recipient that
   has not yet indicated support for that higher version, is
   sufficiently backwards-compatible to be safely processed by any
   implementation of the same major version.</source>
          <target state="translated">HTTP는 &quot;&amp;lt;major&amp;gt;. &amp;lt;minor&amp;gt;&quot;번호 체계를 사용하여 프로토콜 버전을 나타냅니다. 이 사양은 버전 &quot;1.1&quot;을 정의합니다. 프로토콜 버전 전체는 발신자가 해당 버전의 해당 HTTP 사양에 명시된 요구 사항을 준수 함을 나타냅니다. HTTP 메시지의 버전은 메시지의 첫 번째 행에 HTTP 버전 필드로 표시됩니다. HTTP 버전은 대소 문자를 구분합니다. HTTP-version = HTTP- 이름 &quot;/&quot;DIGIT &quot;.&quot; DIGIT HTTP- 이름 = % x48.54.54.50; 대소 문자를 구분하는 &quot;HTTP&quot;HTTP 버전 번호는 &quot;.&quot;으로 구분 된 두 개의 10 진수로 구성됩니다. (마침표 또는 소수점). 첫 번째 숫자 ( &quot;주 버전&quot;)는 HTTP 메시징 구문을 나타냅니다.반면 두 번째 숫자 ( &quot;부 버전&quot;)는 발신자가 준수하고 향후 통신을 위해 이해할 수있는 해당 주 버전 내에서 가장 높은 부 버전을 나타냅니다. 부 버전은 보낸 사람이 이전 버전과 호환되는 프로토콜 하위 집합 만 사용하는 경우에도 보낸 사람의 통신 기능을 알리므로 응답자 (서버) 또는 향후 요청 (클라이언트)에 고급 기능을 사용할 수 있음을 수신자에게 알립니다. . HTTP / 1.1 메시지가 HTTP / 1.0 수신자에게 전송 될 때 [송신자가 이전 버전과 호환되는 프로토콜의 하위 집합 만 사용하는 경우에도 통신 기능을 통해 응답자 (서버) 또는 향후 요청 (클라이언트)에보다 고급 기능을 사용할 수 있음을 수신자에게 알릴 수 있습니다. HTTP / 1.1 메시지가 HTTP / 1.0 수신자에게 전송 될 때 [송신자가 이전 버전과 호환되는 프로토콜의 하위 집합 만 사용하는 경우에도 통신 기능을 통해 응답자 (서버) 또는 향후 요청 (클라이언트)에보다 고급 기능을 사용할 수 있음을 수신자에게 알릴 수 있습니다. HTTP / 1.1 메시지가 HTTP / 1.0 수신자에게 전송 될 때 [&lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC1945&lt;/a&gt;] 또는 버전을 알 수없는 수신자 인 경우 HTTP / 1.1 메시지는 모든 최신 기능이 무시되는 경우 유효한 HTTP / 1.0 메시지로 해석 될 수 있도록 구성됩니다. 이 사양에서는 일부 새로운 기능에 대해 수신자 버전 요구 사항을 적용하므로 구성 또는 메시지 수신을 통해 수신자가 HTTP / 1.1을 지원한다고 판단 할 때까지 호환 발신자가 호환되는 기능 만 사용합니다. 헤더 필드의 해석은 동일한 주 HTTP 버전의 마이너 버전간에 변경되지 않지만 해당 필드가없는 수신자의 기본 동작은 변경 될 수 있습니다. 달리 지정하지 않는 한, HTTP / 1.1에 정의 된 헤더 필드는 모든 버전의 HTTP / 1.x에 대해 정의됩니다. 특히,호스트 및 연결 헤더 필드는 HTTP / 1.1 준수 여부에 관계없이 모든 HTTP / 1.x 구현에서 구현해야합니다. 정의 된 시맨틱으로 인해이를 인식하지 못하는 수신자가 안전하게 무시할 수있는 경우 프로토콜 버전을 변경하지 않고 새 헤더 필드를 도입 할 수 있습니다. 헤더 필드 확장 성은&lt;a href=&quot;#section-3.2.1&quot;&gt;섹션 3.2.1&lt;/a&gt;. HTTP 메시지를 처리하는 중개자 (즉, 터널 역할을하는 중개자 이외의 모든 중개자)는 자신의 HTTP 버전을 전달 된 메시지로 보내야합니다. 즉, 해당 메시지의 프로토콜 버전이 해당 메시지의 중개가 메시지 수신 및 전송에 적합한 버전과 일치하는지 확인하지 않고 HTTP 메시지의 첫 번째 행을 맹목적으로 전달할 수 없습니다. HTTP 버전을 다시 쓰지 않고 HTTP 메시지를 전달하면 다운 스트림 수신자가 메시지 발신자 버전을 사용하여 나중에 해당 발신자와 통신하는 데 안전한 기능을 결정할 때 통신 오류가 발생할 수 있습니다.클라이언트는 클라이언트가 준수하고 서버가 지원하는 최상위 버전보다 높은 주 버전이 아닌 요청 버전을 보내야합니다. 클라이언트는 준수하지 않는 버전을 보내서는 안됩니다. 클라이언트가 서버가 HTTP 사양을 잘못 구현 한 것으로 알려져 있지만 클라이언트가 하나 이상의 일반 요청을 시도하고 응답 상태 코드 또는 헤더 필드 (예 : 서버)에서 결정한 후에 만 ​​하위 요청 버전을 보낼 수 있습니다. 서버가 더 높은 요청 버전을 부적절하게 처리합니다. 서버는 요청에서 수신 한 메이저 버전보다 작거나 같은 메이저 버전을 가진 서버가 가장 적합한 버전의 응답 버전을 보내야한다.서버는 준수하지 않는 버전을 보내서는 안됩니다. 어떤 이유로 든 클라이언트의 주요 프로토콜 버전에 대한 서비스 거부를 원하는 경우 서버는 505 (HTTP 버전 지원되지 않음) 응답을 보낼 수 있습니다. 클라이언트가 HTTP 사양을 잘못 구현하고 클라이언트가 버전 번호를 올바르게 구문 분석하지 못하는 경우 나 이후 버전 응답을 올바르게 처리 할 수없는 것으로 알려진 경우 서버는 요청에 HTTP / 1.0 응답을 보낼 수 있습니다. 중개자는 주어진 부 버전의 프로토콜을 준수하지 않더라도 HTTP 버전을 맹목적으로 전달하는 것으로 알려져 있습니다. 이러한 프로토콜 다운 그레이드는 하나 이상의 요청 헤더 필드와 같은 특정 클라이언트 속성에 의해 트리거되지 않는 한 수행되지 않아야합니다 (예 :User-Agent)는 오류가있는 것으로 알려진 클라이언트가 보낸 값과 고유하게 일치합니다. HTTP 버전 관리 설계의 목적은 호환되지 않는 메시지 구문이 도입 된 경우에만 주 번호가 증가하고, 프로토콜 변경으로 인해 메시지 시맨틱에 추가되거나 추가로 암시되는 경우에만 부 번호가 증가한다는 것입니다. 발신자의 기능. 그러나 마이너 버전은 [프로토콜에 대한 변경이 메시지 의미에 추가하거나 발신자의 추가 기능을 암시하는 효과가있는 경우에만 부 번호가 증가합니다. 그러나 마이너 버전은 [프로토콜에 대한 변경이 메시지 의미에 추가하거나 발신자의 추가 기능을 암시하는 효과가있는 경우에만 부 번호가 증가합니다. 그러나 마이너 버전은 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC2068&lt;/a&gt; ] 및 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 및이 개정에서는 프로토콜에 대한 이러한 변경을 구체적으로 피했습니다. 수신자가 구현하는 메이저 버전 번호가 있지만 수신자가 구현 한 것보다 부 버전 번호가 높은 HTTP 메시지가 수신되면 수신자는 메시지가 해당 메이저 버전 내에서 최상위 부 버전 인 것처럼 메시지를 처리해야합니다. 수신자가 적합합니다. 수신자는 상위 버전이 높은 메시지가 해당 상위 버전에 대한 지원을 아직 표시하지 않은 수신자에게 전송 된 경우 동일한 주 버전을 구현하여 안전하게 처리 할 수 ​​있도록 이전 버전과 충분히 호환된다고 가정 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d3a5b43c3101b03cd5693da68dc42b80224e0a29" translate="yes" xml:space="preserve">
          <source>HTTP uses a &quot;&amp;lt;major&amp;gt;.&amp;lt;minor&amp;gt;&quot; numbering scheme to indicate versions
   of the protocol. The protocol versioning policy is intended to allow
   the sender to indicate the format of a message and its capacity for
   understanding further HTTP communication, rather than the features
   obtained via that communication. No change is made to the version
   number for the addition of message components which do not affect
   communication behavior or which only add to extensible field values.
   The &amp;lt;minor&amp;gt; number is incremented when the changes made to the
   protocol add features which do not change the general message parsing
   algorithm, but which may add to the message semantics and imply
   additional capabilities of the sender. The &amp;lt;major&amp;gt; number is
   incremented when the format of a message within the protocol is
   changed. See &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;] for a fuller explanation. 

   The version of an HTTP message is indicated by an HTTP-Version field
   in the first line of the message.

       HTTP-Version   = &quot;HTTP&quot; &quot;/&quot; 1*DIGIT &quot;.&quot; 1*DIGIT

   Note that the major and minor numbers MUST be treated as separate
   integers and that each MAY be incremented higher than a single digit.
   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is
   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and
   MUST NOT be sent.

   An application that sends a request or response message that includes
   HTTP-Version of &quot;HTTP/1.1&quot; MUST be at least conditionally compliant
   with this specification. Applications that are at least conditionally
   compliant with this specification SHOULD use an HTTP-Version of
   &quot;HTTP/1.1&quot; in their messages, and MUST do so for any message that is
   not compatible with HTTP/1.0. For more details on when to send
   specific HTTP-Version values, see &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [&lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;].

   The HTTP version of an application is the highest HTTP version for
   which the application is at least conditionally compliant.

   Proxy and gateway applications need to be careful when forwarding
   messages in protocol versions different from that of the application.
   Since the protocol version indicates the protocol capability of the
   sender, a proxy/gateway MUST NOT send a message with a version
   indicator which is greater than its actual version. If a higher
   version request is received, the proxy/gateway MUST either downgrade
   the request version, or respond with an error, or switch to tunnel
   behavior.

   Due to interoperability problems with HTTP/1.0 proxies discovered
   since the publication of &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;[&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], caching proxies MUST, gateways
   MAY, and tunnels MUST NOT upgrade the request to the highest version
   they support. The proxy/gateway's response to that request MUST be in
   the same major version as the request.

      Note: Converting between versions of HTTP may involve modification
      of header fields required or forbidden by the versions involved.</source>
          <target state="translated">HTTP는 &quot;&amp;lt;major&amp;gt;. &amp;lt;minor&amp;gt;&quot;번호 체계를 사용하여 프로토콜 버전을 나타냅니다. 프로토콜 버전 관리 정책은 발신자가 해당 통신을 통해 얻은 기능이 아니라 메시지의 형식과 추가 HTTP 통신을 이해할 수있는 용량을 표시 할 수 있도록하기위한 것입니다. 통신 동작에 영향을 미치지 않거나 확장 가능한 필드 값에만 추가되는 메시지 구성 요소를 추가하기 위해 버전 번호가 변경되지 않습니다. &amp;lt;minor&amp;gt; 번호는 프로토콜에 대한 변경 사항이 일반 메시지 구문 분석 알고리즘을 변경하지 않지만 메시지 의미를 추가하고 발신자의 추가 기능을 암시하는 기능을 추가 할 때 증가합니다. &amp;lt;주요&amp;gt;프로토콜 내에서 메시지 형식이 변경되면 번호가 증가합니다. 보다&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt;]에 대한 자세한 설명은 HTTP 메시지의 버전은 메시지의 첫 번째 행에 HTTP-Version 필드로 표시됩니다. HTTP-Version = &quot;HTTP&quot; &quot;/&quot;1 * DIGIT &quot;.&quot; 1 * DIGIT 주 및 부 숫자는 반드시 별도의 정수로 취급해야하며 각 숫자는 한 자리보다 높아질 수 있습니다. 따라서 HTTP / 2.4는 HTTP / 2.13보다 낮은 버전으로, HTTP / 12.3보다 낮습니다. 선행 0은 수신자가 무시해야하며 전송해서는 안됩니다. &quot;HTTP / 1.1&quot;의 HTTP 버전을 포함하는 요청 또는 응답 메시지를 전송하는 응용 프로그램은 최소한이 사양을 조건부로 준수해야합니다. 이 사양을 조건부로 최소한 준수하는 응용 프로그램은 &quot;HTTP / 1.1&quot;의 HTTP 버전을 사용해야합니다.메시지에 포함되어야하며 HTTP / 1.0과 호환되지 않는 모든 메시지에 대해 그렇게해야합니다. 특정 HTTP 버전 값을 보내는시기에 대한 자세한 내용은&lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; [ &lt;a href=&quot;#ref-36&quot;&gt;36&lt;/a&gt; ]. 응용 프로그램의 HTTP 버전은 응용 프로그램이 최소한 조건부 호환되는 가장 높은 HTTP 버전입니다. 프록시 및 게이트웨이 애플리케이션은 애플리케이션과 다른 프로토콜 버전으로 메시지를 전달할 때주의해야합니다. 프로토콜 버전은 발신자의 프로토콜 기능을 나타내므로 프록시 / 게이트웨이는 실제 버전보다 큰 버전 표시기와 함께 메시지를 보내서는 안됩니다. 더 높은 버전의 요청이 수신되면 프록시 / 게이트웨이는 요청 버전을 다운 그레이드하거나 오류로 응답하거나 터널 동작으로 전환해야합니다. &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 발행 이후 발견 된 HTTP / 1.0 프록시와의 상호 운용성 문제로 인해 [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;], 프록시를 캐싱해야하며, 게이트웨이가 필요할 수 있으며, 터널은 요청을 지원하는 최고 버전으로 업그레이드해서는 안됩니다. 해당 요청에 대한 프록시 / 게이트웨이의 응답은 요청과 동일한 주 버전이어야합니다. 참고 : HTTP 버전 간 변환에는 관련 버전에서 필요하거나 금지 된 헤더 필드를 수정해야 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="de9ea4b9303de1ca70c1a8e05822b3b34b2bc2c1" translate="yes" xml:space="preserve">
          <source>HTTP uses charset names to indicate or negotiate the character
   encoding scheme of a textual representation [&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt;].  A charset is
   identified by a case-insensitive token.

     charset = token

   Charset names ought to be registered in the IANA &quot;Character Sets&quot;
   registry (&amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt;&amp;gt;) according
   to the procedures defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt;].</source>
          <target state="translated">HTTP는 문자 세트 이름을 사용하여 텍스트 표현의 문자 인코딩 체계를 표시하거나 협상합니다 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC6365&lt;/a&gt; ]. 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. charset = token 문자 세트 이름 은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC2978&lt;/a&gt; ]에 정의 된 절차에 따라 IANA &quot;문자 세트&quot;레지스트리 (&amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/character-sets&quot;&gt;http://www.iana.org/assignments/character-sets&lt;/a&gt; &amp;gt;)에 등록되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="f64b344cb46f8dc4aefac27a98f9f8e7568e4d7b" translate="yes" xml:space="preserve">
          <source>HTTP uses the same definition of the term &quot;character set&quot; as that
   described for MIME: 

   The term &quot;character set&quot; is used in this document to refer to a
   method used with one or more tables to convert a sequence of octets
   into a sequence of characters. Note that unconditional conversion in
   the other direction is not required, in that not all characters may
   be available in a given character set and a character set may provide
   more than one sequence of octets to represent a particular character.
   This definition is intended to allow various kinds of character
   encoding, from simple single-table mappings such as US-ASCII to
   complex table switching methods such as those that use ISO-2022's
   techniques. However, the definition associated with a MIME character
   set name MUST fully specify the mapping to be performed from octets
   to characters. In particular, use of external profiling information
   to determine the exact mapping is not permitted.

      Note: This use of the term &quot;character set&quot; is more commonly
      referred to as a &quot;character encoding.&quot; However, since HTTP and
      MIME share the same registry, it is important that the terminology
      also be shared.

   HTTP character sets are identified by case-insensitive tokens. The
   complete set of tokens is defined by the IANA Character Set registry
   [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;].

       charset = token

   Although HTTP allows an arbitrary token to be used as a charset
   value, any token that has a predefined value within the IANA
   Character Set registry [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt;] MUST represent the character set defined
   by that registry. Applications SHOULD limit their use of character
   sets to those defined by the IANA registry.

   Implementors should be aware of IETF character set requirements [&lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt;]
   [&lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt;].</source>
          <target state="translated">HTTP는 MIME에 대해 설명 된 것과 동일한 &quot;문자 세트&quot;라는 용어의 정의를 사용합니다. &quot;문자 세트&quot;라는 용어는이 문서에서 하나 이상의 테이블에서 옥텟 시퀀스를 일련의 시퀀스로 변환하는 데 사용되는 방법을 나타냅니다 문자. 주어진 문자 세트에서 모든 문자를 사용할 수있는 것은 아니며 문자 세트가 특정 문자를 나타 내기 위해 둘 이상의 8 진수 시퀀스를 제공 할 수 있다는 점에서 다른 방향으로의 무조건 변환은 필요하지 않습니다. 이 정의는 US-ASCII와 같은 간단한 단일 테이블 매핑에서 ISO-2022의 기술을 사용하는 복잡한 테이블 전환 방법에 이르기까지 다양한 종류의 문자 인코딩을 허용하기위한 것입니다. 하나,MIME 문자 세트 이름과 관련된 정의는 반드시 옥텟에서 문자로 수행 될 맵핑을 명시해야한다. 특히, 정확한 매핑을 결정하기 위해 외부 프로파일 링 정보를 사용하는 것은 허용되지 않습니다. 참고 : 이러한 &quot;문자 세트&quot;라는 용어를보다 일반적으로 &quot;문자 인코딩&quot;이라고합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다. HTTP 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. 완전한 토큰 세트는 IANA 문자 세트 레지스트리 [보다 일반적으로 &quot;문자 인코딩&quot;이라고합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다. HTTP 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. 완전한 토큰 세트는 IANA 문자 세트 레지스트리 [보다 일반적으로 &quot;문자 인코딩&quot;이라고합니다. 그러나 HTTP와 MIME은 동일한 레지스트리를 공유하므로 용어도 공유하는 것이 중요합니다. HTTP 문자 세트는 대소 문자를 구분하지 않는 토큰으로 식별됩니다. 완전한 토큰 세트는 IANA 문자 세트 레지스트리 [&lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ]. charset = token HTTP가 임의의 토큰을 문자 세트 값으로 사용하도록 허용하지만 IANA 문자 세트 레지스트리 [ &lt;a href=&quot;#ref-19&quot;&gt;19&lt;/a&gt; ] 내에 사전 정의 된 값을 가진 토큰은 해당 레지스트리에 의해 정의 된 문자 세트를 나타내야합니다. 응용 프로그램은 문자 집합 사용을 IANA 레지스트리에서 정의한 문자 집합으로 제한해야합니다. 구현자는 IETF 문자 세트 요구 사항을 알고 있어야합니다 [ &lt;a href=&quot;#ref-38&quot;&gt;38&lt;/a&gt; ] [ &lt;a href=&quot;#ref-41&quot;&gt;41&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="4998cbc56519b60012d9ddef5a93ab40ac390988" translate="yes" xml:space="preserve">
          <source>HTTP was created for the World Wide Web (WWW) architecture and has
   evolved over time to support the scalability needs of a worldwide
   hypertext system.  Much of that architecture is reflected in the
   terminology and syntax productions used to define HTTP.</source>
          <target state="translated">HTTP는 WWW (World Wide Web) 아키텍처 용으로 만들어졌으며 전 세계 하이퍼 텍스트 시스템의 확장 성 요구를 지원하기 위해 시간이 지남에 따라 발전했습니다. 이러한 아키텍처의 대부분은 HTTP를 정의하는 데 사용되는 용어 및 구문 제작에 반영됩니다.</target>
        </trans-unit>
        <trans-unit id="40aed2983145eadb2c78a80757cda404bbec1b9e" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2 as well as minor novelties introduced over the years.</source>
          <target state="translated">HTTP는 1990 년대 초에 만들어졌으며 여러 번 확장되었습니다. 이 기사는 그 역사를 거슬러 올라가며 HTTP / 0.9, HTTP / 1.0, HTTP / 1.1, 최신 HTTP / 2 및 수년에 걸쳐 소개 된 작은 참신함을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="6691219872cf8222b135471124cba8cce6315df4" translate="yes" xml:space="preserve">
          <source>HTTP was created in the early 1990s and has been extended several times. This article goes through its history and describes HTTP/0.9, HTTP/1.0, HTTP/1.1, and the modern HTTP/2, as well as novelties introduced over the years.</source>
          <target state="translated">HTTP는 1990 년대 초에 만들어졌으며 여러 번 확장되었습니다. 이 기사는 그 역사를 살펴보고 HTTP / 0.9, HTTP / 1.0, HTTP / 1.1 및 최신 HTTP / 2와 수년에 걸쳐 소개 된 참신함을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8847a48bfa3a8070b11a550d8e6423fe9a938e29" translate="yes" xml:space="preserve">
          <source>HTTP was first specified in the early 1990s. Designed with extensibility in mind, it has seen numerous additions over the years; this lead to its specification being scattered through numerous specification documents (in the midst of experimental abandoned extensions). This page lists relevant resources about HTTP.</source>
          <target state="translated">HTTP는 1990 년대 초에 처음 지정되었습니다. 확장 성을 염두에두고 설계된이 솔루션은 수년 동안 수많은 추가 사항을 보았습니다. 이로 인해 많은 사양 문서 (실험적 포기 확장 중)에 사양이 흩어졌습니다. 이 페이지에는 HTTP에 대한 관련 리소스가 나열되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="c36d6fae868bc13b893908c5f64cbe8e452543ec" translate="yes" xml:space="preserve">
          <source>HTTP's approach to error handling has been explained.  (&lt;a href=&quot;#section-2.5&quot;&gt;Section 2.5&lt;/a&gt;)

   The HTTP-version ABNF production has been clarified to be case-
   sensitive.  Additionally, version numbers have been restricted to
   single digits, due to the fact that implementations are known to
   handle multi-digit version numbers incorrectly.  (&lt;a href=&quot;#section-2.6&quot;&gt;Section 2.6&lt;/a&gt;)

   Userinfo (i.e., username and password) are now disallowed in HTTP and
   HTTPS URIs, because of security issues related to their transmission
   on the wire.  (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;)

   The HTTPS URI scheme is now defined by this specification;
   previously, it was done in &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;Section&amp;nbsp;2.4 of [RFC2818]&lt;/a&gt;.  Furthermore, it
   implies end-to-end security.  (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;)

   HTTP messages can be (and often are) buffered by implementations;
   despite it sometimes being available as a stream, HTTP is
   fundamentally a message-oriented protocol.  Minimum supported sizes
   for various protocol elements have been suggested, to improve
   interoperability.  (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;)

   Invalid whitespace around field-names is now required to be rejected,
   because accepting it represents a security vulnerability.  The ABNF
   productions defining header fields now only list the field value.
   (&lt;a href=&quot;#section-3.2&quot;&gt;Section 3.2&lt;/a&gt;)

   Rules about implicit linear whitespace between certain grammar
   productions have been removed; now whitespace is only allowed where
   specifically defined in the ABNF.  (&lt;a href=&quot;#section-3.2.3&quot;&gt;Section 3.2.3&lt;/a&gt;)

   Header fields that span multiple lines (&quot;line folding&quot;) are
   deprecated.  (&lt;a href=&quot;#section-3.2.4&quot;&gt;Section 3.2.4&lt;/a&gt;)

   The NUL octet is no longer allowed in comment and quoted-string text,
   and handling of backslash-escaping in them has been clarified.  The
   quoted-pair rule no longer allows escaping control characters other
   than HTAB.  Non-US-ASCII content in header fields and the reason
   phrase has been obsoleted and made opaque (the TEXT rule was
   removed).  (&lt;a href=&quot;#section-3.2.6&quot;&gt;Section 3.2.6&lt;/a&gt;)

   Bogus Content-Length header fields are now required to be handled as
   errors by recipients.  (&lt;a href=&quot;#section-3.3.2&quot;&gt;Section 3.3.2&lt;/a&gt;)

   The algorithm for determining the message body length has been
   clarified to indicate all of the special cases (e.g., driven by
   methods or status codes) that affect it, and that new protocol 

   elements cannot define such special cases.  CONNECT is a new, special
   case in determining message body length. &quot;multipart/byteranges&quot; is no
   longer a way of determining message body length detection.
   (&lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;)

   The &quot;identity&quot; transfer coding token has been removed.  (Sections &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;
   and 4)

   Chunk length does not include the count of the octets in the chunk
   header and trailer.  Line folding in chunk extensions is disallowed.
   (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The meaning of the &quot;deflate&quot; content coding has been clarified.
   (&lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt;)

   The segment + query components of &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; have been used to define
   the request-target, instead of abs_path from &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;.  The
   asterisk-form of the request-target is only allowed with the OPTIONS
   method.  (&lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt;)

   The term &quot;Effective Request URI&quot; has been introduced.  (&lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;)

   Gateways do not need to generate Via header fields anymore.
   (&lt;a href=&quot;#section-5.7.1&quot;&gt;Section 5.7.1&lt;/a&gt;)

   Exactly when &quot;close&quot; connection options have to be sent has been
   clarified.  Also, &quot;hop-by-hop&quot; header fields are required to appear
   in the Connection header field; just because they're defined as hop-
   by-hop in this specification doesn't exempt them.  (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;)

   The limit of two connections per server has been removed.  An
   idempotent sequence of requests is no longer required to be retried.
   The requirement to retry requests under certain circumstances when
   the server prematurely closes the connection has been removed.  Also,
   some extraneous requirements about when servers are allowed to close
   connections prematurely have been removed.  (&lt;a href=&quot;#section-6.3&quot;&gt;Section 6.3&lt;/a&gt;)

   The semantics of the Upgrade header field is now defined in responses
   other than 101 (this was incorporated from [&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt;]).  Furthermore,
   the ordering in the field value is now significant.  (&lt;a href=&quot;#section-6.7&quot;&gt;Section 6.7&lt;/a&gt;)

   Empty list elements in list productions (e.g., a list header field
   containing &quot;, ,&quot;) have been deprecated.  (&lt;a href=&quot;#section-7&quot;&gt;Section 7&lt;/a&gt;)

   Registration of Transfer Codings now requires IETF Review
   (&lt;a href=&quot;#section-8.4&quot;&gt;Section 8.4&lt;/a&gt;) 

   This specification now defines the Upgrade Token Registry, previously
   defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;Section&amp;nbsp;7.2 of [RFC2817]&lt;/a&gt;.  (&lt;a href=&quot;#section-8.6&quot;&gt;Section 8.6&lt;/a&gt;)

   The expectation to support HTTP/0.9 requests has been removed.
   (Appendix A)

   Issues with the Keep-Alive and Proxy-Connection header fields in
   requests are pointed out, with use of the latter being discouraged
   altogether.  (Appendix A.1.2)</source>
          <target state="translated">오류 처리에 대한 HTTP의 접근 방식이 설명되었습니다. ( &lt;a href=&quot;#section-2.5&quot;&gt;섹션 2.5&lt;/a&gt; ) HTTP 버전 ABNF 프로덕션은 대소 문자를 구분하는 것으로 명확 해졌습니다. 또한 구현에서 여러 자리 버전 번호를 잘못 처리하는 것으로 알려져 있기 때문에 버전 번호가 한 자리로 제한되었습니다. ( &lt;a href=&quot;#section-2.6&quot;&gt;2.6 절&lt;/a&gt; ) 유선에서의 전송과 관련된 보안 문제로 인해 사용자 정보 (예 : 사용자 이름 및 비밀번호)가 HTTP 및 HTTPS URI에서 허용되지 않습니다. ( &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; ) HTTPS URI 스킴은 이제이 사양에 의해 정의됩니다. 이전 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818#section-2.4&quot;&gt;에는 [RFC2818]의 2.4 절&lt;/a&gt; 에서 수행되었다 . 또한 엔드-투-엔드 보안을 의미합니다. ( &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt;) HTTP 메시지는 구현에 의해 버퍼링 될 수 있으며 종종 버퍼링 될 수 있습니다. 때때로 스트림으로 사용 가능하지만 HTTP는 기본적으로 메시지 지향 프로토콜입니다. 상호 운용성을 향상시키기 위해 다양한 프로토콜 요소에 대해 지원되는 최소 크기가 제안되었습니다. ( &lt;a href=&quot;#section-3&quot;&gt;3&lt;/a&gt; ) 필드 이름 주위의 유효하지 않은 공백은 이제 보안 취약점을 나타내므로 거부해야합니다. 헤더 필드를 정의하는 ABNF 프로덕션은 이제 필드 값만 나열합니다. ( &lt;a href=&quot;#section-3.2&quot;&gt;3.2 절&lt;/a&gt; ) 특정 문법 생성 사이의 암시 적 선형 공백에 대한 규칙이 제거되었습니다. 이제 공백은 ABNF에 구체적으로 정의 된 경우에만 허용됩니다. ( &lt;a href=&quot;#section-3.2.3&quot;&gt;섹션 3.2.3&lt;/a&gt;) 여러 줄에 걸쳐있는 헤더 필드 ( &quot;줄 접기&quot;)는 더 이상 사용되지 않습니다. ( &lt;a href=&quot;#section-3.2.4&quot;&gt;3.2.4 절&lt;/a&gt; ) 더 이상 주석 및 따옴표로 묶인 문자열 텍스트에서 NUL 옥텟을 사용할 수 없으며 백 슬래시 이스케이프 처리가 명확 해졌습니다. 인용 쌍 규칙은 더 이상 HTAB 이외의 제어 문자를 이스케이프 할 수 없습니다. 헤더 필드의 미국 이외의 ASCII 컨텐츠 및 이유 문구가 더 이상 사용되지 않고 불투명하게되었습니다 (TEXT 규칙이 제거됨). ( &lt;a href=&quot;#section-3.2.6&quot;&gt;섹션 3.2.6&lt;/a&gt; ) 이제 Bogus Content-Length 헤더 필드를 수신자가 오류로 처리해야합니다. ( &lt;a href=&quot;#section-3.3.2&quot;&gt;섹션 3.3.2&lt;/a&gt;) 메시지 본문 길이를 결정하는 알고리즘은 메시지 본문에 영향을 미치는 모든 특수 사례 (예 : 방법 또는 상태 코드로 구동)를 나타 내기 위해 명확 해졌으며 새로운 프로토콜 요소는 이러한 특수 사례를 정의 할 수 없습니다. CONNECT는 메시지 본문 길이를 결정할 때 새롭고 특별한 경우입니다. &quot;멀티 파트 / 바이트 범위&quot;는 더 이상 메시지 본문 길이 감지를 결정하는 방법이 아닙니다. ( &lt;a href=&quot;#section-3.3.3&quot;&gt;섹션 3.3.3&lt;/a&gt; ) &quot;identity&quot;전송 코딩 토큰이 제거되었습니다. (섹션 &lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; 및 4) 청크 길이는 청크 헤더 및 트레일러의 옥텟 수를 포함하지 않습니다. 청크 확장에서 줄을 접는 것은 허용되지 않습니다. ( &lt;a href=&quot;#section-4.1&quot;&gt;4.1 절&lt;/a&gt; ) &quot;deflate&quot;컨텐츠 코딩의 의미가 명확 해졌다. (&lt;a href=&quot;#section-4.2.2&quot;&gt;4.2.2 절&lt;/a&gt; ) &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; 의 abs_path 대신 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; 의 세그먼트 + 쿼리 구성 요소가 요청 대상을 정의하는 데 사용되었습니다 . request-target의 별표 형식은 OPTIONS 메소드에서만 허용됩니다. ( &lt;a href=&quot;#section-5.3&quot;&gt;5.3 절&lt;/a&gt; ) &quot;유효 요청 URI&quot;라는 용어가 도입되었습니다. ( &lt;a href=&quot;#section-5.5&quot;&gt;5.5 절&lt;/a&gt; ) 게이트웨이는 더 이상 Via 헤더 필드를 생성 할 필요가 없습니다. ( &lt;a href=&quot;#section-5.7.1&quot;&gt;5.7.1 항&lt;/a&gt; ) &quot;닫기&quot;연결 옵션을 보내야하는 정확한 시점이 명확 해졌습니다. 또한 연결 헤더 필드에 &quot;hop-by-hop&quot;헤더 필드가 나타나야합니다. 이 사양에서 홉 바이 홉으로 정의 되었기 때문에 면제되지 않습니다.( &lt;a href=&quot;#section-6.1&quot;&gt;6.1 항&lt;/a&gt;) 서버 당 2 개의 연결 제한이 제거되었습니다. dem 등원 인 요청 시퀀스는 더 이상 재 시도 할 필요가 없습니다. 서버가 연결을 조기에 닫을 때 특정 상황에서 요청을 재 시도해야하는 요구 사항이 제거되었습니다. 또한 서버에서 연결을 조기에 닫을 수있는시기에 대한 일부 관련 요구 사항이 제거되었습니다. ( &lt;a href=&quot;#section-6.3&quot;&gt;6.3 절&lt;/a&gt; ) Upgrade 헤더 필드의 의미는 이제 101 이외의 응답으로 정의됩니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC2817&lt;/a&gt; ] 에서 통합됨 ). 또한 필드 값의 순서가 중요합니다. ( &lt;a href=&quot;#section-6.7&quot;&gt;6.7 절&lt;/a&gt; ) 목록 제작에서 비어있는 목록 요소 (예 : &quot;,,&quot;를 포함하는 목록 헤더 필드)는 더 이상 사용되지 않습니다. (&lt;a href=&quot;#section-7&quot;&gt;섹션 7&lt;/a&gt; ) 전송 코딩을 등록하려면 이제 IETF 검토가 필요합니다 ( &lt;a href=&quot;#section-8.4&quot;&gt;섹션 8.4&lt;/a&gt; ).이 사양은 이제 &lt;a href=&quot;https://tools.ietf.org/html/rfc2817#section-7.2&quot;&gt;[RFC2817]의 7.2 섹션&lt;/a&gt; 에 정의 된 업그레이드 토큰 레지스트리를 정의합니다 . ( &lt;a href=&quot;#section-8.6&quot;&gt;섹션 8.6&lt;/a&gt; ) HTTP / 0.9 요청 지원에 대한 기대가 제거되었습니다. (부록 A) 요청에서 Keep-Alive 및 Proxy-Connection 헤더 필드와 관련된 문제는 지적하고 후자를 사용하지 않는 것이 좋습니다. (부록 A.1.2)</target>
        </trans-unit>
        <trans-unit id="e75786a71ce66c44187c7d3570685182eb4f5400" translate="yes" xml:space="preserve">
          <source>HTTP-only cookies aren't accessible via JavaScript through the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt;&lt;code&gt;Document.cookie&lt;/code&gt;&lt;/a&gt; property, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; API, or the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt;&lt;code&gt;Request&lt;/code&gt;&lt;/a&gt; API to mitigate attacks against cross-site scripting (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt;).</source>
          <target state="translated">크로스 사이트 스크립팅 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/XSS&quot;&gt;XSS&lt;/a&gt; ) 에 대한 공격을 완화하기 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie&quot;&gt; &lt;code&gt;Document.cookie&lt;/code&gt; &lt;/a&gt; 속성, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; API 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request&quot;&gt; &lt;code&gt;Request&lt;/code&gt; &lt;/a&gt; API를 통해 JavaScript를 통해 HTTP 전용 쿠키에 액세스 할 수 없습니다 .</target>
        </trans-unit>
        <trans-unit id="645478239b71d9e2120cd5c5e2c81c2c7e39f857" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 &amp;ndash; The one-line protocol</source>
          <target state="translated">HTTP / 0.9 &amp;ndash; 단선 프로토콜</target>
        </trans-unit>
        <trans-unit id="44cba524f054d5d6640a40b11e1c3c0dd2b2e81c" translate="yes" xml:space="preserve">
          <source>HTTP/0.9 was very limited and both browsers and servers quickly extended it to be more versatile:</source>
          <target state="translated">HTTP / 0.9는 매우 제한적이며 브라우저와 서버 모두보다 다양한 기능으로 빠르게 확장되었습니다.</target>
        </trans-unit>
        <trans-unit id="17104213d7caf462f808b5202b6b3bf53c6f9e5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 &amp;ndash; Building extensibility</source>
          <target state="translated">HTTP / 1.0 &amp;ndash; 확장 성 구축</target>
        </trans-unit>
        <trans-unit id="8cfcb01eada0b8cfd065017e118d423b8f745b23" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 connections are not persistent by default. Setting &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; to anything other than &lt;code&gt;close&lt;/code&gt;, usually &lt;code&gt;retry-after&lt;/code&gt;, will make them persistent.</source>
          <target state="translated">HTTP / 1.0 연결은 기본적으로 영구적이지 않습니다. &lt;code&gt;close&lt;/code&gt; 이외의 다른 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 일반적으로 &lt;code&gt;retry-after&lt;/code&gt; 을 설정하면 연결 이 영구적으로 유지됩니다.</target>
        </trans-unit>
        <trans-unit id="c0e8fb29ae930b0d157a9f98acea4150c0686f37" translate="yes" xml:space="preserve">
          <source>HTTP/1.0 opened a TCP connection for each request/response exchange, introducing two major flaws: opening a connection needs several round-trips of messages and therefore slow, but becomes more efficient when several messages are sent, and regularly sent: &lt;em&gt;warm&lt;/em&gt; connections are more efficient than &lt;em&gt;cold&lt;/em&gt; ones.</source>
          <target state="translated">HTTP / 1.0은 두 가지 주요 결함을 도입, 각 요청 / 응답 교환을위한 TCP 연결을 열었다는 : 연결을 여는 때문에 느린 여러 메시지의 왕복 및 필요하지만 여러 메시지가 전송 될 때 더 효율적으로, 정기적으로 발송됩니다 : &lt;em&gt;따뜻한&lt;/em&gt; 연결이 &lt;em&gt;차가운&lt;/em&gt; 것 보다 더 효율적 입니다.</target>
        </trans-unit>
        <trans-unit id="0d0b58bbcdf0ad6dac8b90fb47db84cff63b6a65" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 &amp;ndash; The standardized protocol</source>
          <target state="translated">HTTP / 1.1 &amp;ndash; 표준화 된 프로토콜</target>
        </trans-unit>
        <trans-unit id="b6ed95efc2e54e41776e64eab2beb02be978d4fe" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 allows a client to request that only part (a range of) the
   response entity be included within the response. HTTP/1.1 uses range
   units in the Range (&lt;a href=&quot;#section-14.35&quot;&gt;section 14.35&lt;/a&gt;) and Content-Range (&lt;a href=&quot;#section-14.16&quot;&gt;section 14.16&lt;/a&gt;)
   header fields. An entity can be broken down into subranges according
   to various structural units.

      range-unit       = bytes-unit | other-range-unit
      bytes-unit       = &quot;bytes&quot;
      other-range-unit = token

   The only range unit defined by HTTP/1.1 is &quot;bytes&quot;. HTTP/1.1
   implementations MAY ignore ranges specified using other units. 

   HTTP/1.1 has been designed to allow implementations of applications
   that do not depend on knowledge of ranges.</source>
          <target state="translated">HTTP / 1.1은 클라이언트가 응답 엔티티의 일부 (범위) 만 응답 내에 포함하도록 요청할 수 있습니다. HTTP / 1.1은 Range ( &lt;a href=&quot;#section-14.35&quot;&gt;섹션 14.35&lt;/a&gt; ) 및 Content-Range ( &lt;a href=&quot;#section-14.16&quot;&gt;섹션 14.16&lt;/a&gt; ) 헤더 필드 에서 범위 단위를 사용 합니다. 엔티티는 다양한 구조 단위에 따라 하위 범위로 나눌 수 있습니다. range-unit = 바이트 단위 | other-range-unit bytes-unit = &quot;bytes&quot;other-range-unit = token HTTP / 1.1에서 정의한 유일한 범위 단위는 &quot;bytes&quot;입니다. HTTP / 1.1 구현은 다른 단위를 사용하여 지정된 범위를 무시할 수 있습니다. HTTP / 1.1은 범위 지식에 의존하지 않는 응용 프로그램을 구현할 수 있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="8cf11b6afbfe5a73402d4b60de58fb9f5e3c6400" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 and earlier HTTP messages are human-readable. In HTTP/2, these messages are embedded into a new binary structure, a frame, allowing optimizations like compression of headers and multiplexing. Even if only part of the original HTTP message is sent in this version of HTTP, the semantics of each message is unchanged and the client reconstitutes (virtually) the original HTTP/1.1 request. It is therefore useful to comprehend HTTP/2 messages in the HTTP/1.1 format.</source>
          <target state="translated">HTTP / 1.1 및 이전 HTTP 메시지는 사람이 읽을 수 있습니다. HTTP / 2에서는 이러한 메시지가 새로운 바이너리 구조 인 프레임에 내장되어 헤더 압축 및 멀티플렉싱과 같은 최적화가 가능합니다. 이 버전의 HTTP에서 원래 HTTP 메시지의 일부만 전송 되더라도 각 메시지의 의미는 변경되지 않으며 클라이언트는 원래 HTTP / 1.1 요청을 (가상으로) 재구성합니다. 따라서 HTTP / 2 메시지를 HTTP / 1.1 형식으로 이해하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="340b2a6e6c85c293b668779af15231ac0ac5f995" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 clarified ambiguities and introduced numerous improvements:</source>
          <target state="translated">HTTP / 1.1은 모호성을 명확하게하고 수많은 개선을 도입했습니다 :</target>
        </trans-unit>
        <trans-unit id="aaede2afb4e2e830b4b4156c5fed71c83597729d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 defaults to the use of &quot;persistent connections&quot;, allowing
   multiple requests and responses to be carried over a single
   connection.  The &quot;close&quot; connection option is used to signal that a
   connection will not persist after the current request/response.  HTTP
   implementations SHOULD support persistent connections. 

   A recipient determines whether a connection is persistent or not
   based on the most recently received message's protocol version and
   Connection header field (if any):

   o  If the &quot;close&quot; connection option is present, the connection will
      not persist after the current response; else,

   o  If the received protocol is HTTP/1.1 (or later), the connection
      will persist after the current response; else,

   o  If the received protocol is HTTP/1.0, the &quot;keep-alive&quot; connection
      option is present, the recipient is not a proxy, and the recipient
      wishes to honor the HTTP/1.0 &quot;keep-alive&quot; mechanism, the
      connection will persist after the current response; otherwise,

   o  The connection will close after the current response.

   A client MAY send additional requests on a persistent connection
   until it sends or receives a &quot;close&quot; connection option or receives an
   HTTP/1.0 response without a &quot;keep-alive&quot; connection option.

   In order to remain persistent, all messages on a connection need to
   have a self-defined message length (i.e., one not defined by closure
   of the connection), as described in &lt;a href=&quot;#section-3.3&quot;&gt;Section 3.3&lt;/a&gt;.  A server MUST read
   the entire request message body or close the connection after sending
   its response, since otherwise the remaining data on a persistent
   connection would be misinterpreted as the next request.  Likewise, a
   client MUST read the entire response message body if it intends to
   reuse the same connection for a subsequent request.

   A proxy server MUST NOT maintain a persistent connection with an
   HTTP/1.0 client (see &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;Section&amp;nbsp;19.7.1 of [RFC2068]&lt;/a&gt; for information and
   discussion of the problems with the Keep-Alive header field
   implemented by many HTTP/1.0 clients).

   See &lt;a href=&quot;#appendix-A.1.2&quot;&gt;Appendix A.1.2&lt;/a&gt; for more information on backwards compatibility
   with HTTP/1.0 clients.</source>
          <target state="translated">HTTP / 1.1은 기본적으로 &quot;지속적인 연결&quot;을 사용하므로 단일 연결을 통해 여러 요청 및 응답을 전달할 수 있습니다. &quot;닫기&quot;연결 옵션은 현재 요청 / 응답 후에 연결이 지속되지 않음을 알리는 데 사용됩니다. HTTP 구현은 지속적인 연결을 지원해야합니다. 수신자는 가장 최근에 수신 한 메시지의 프로토콜 버전 및 연결 헤더 필드 (있는 경우)에 따라 연결이 지속되는지 여부를 결정합니다. o &quot;닫기&quot;연결 옵션이 있으면 현재 응답 후 연결이 지속되지 않습니다. 그렇지 않으면, o 수신 된 프로토콜이 HTTP / 1.1 이상이면 연결은 현재 응답 후에도 지속됩니다. 그렇지 않으면 o 수신 된 프로토콜이 HTTP / 1.0 인 경우 &quot;keep-alive &quot;연결 옵션이 존재하고 수신자가 프록시가 아니며 수신자가 HTTP / 1.0&quot;keep-alive &quot;메커니즘을 준수하려고하면 현재 응답 후에도 연결이 유지됩니다. 그렇지 않으면 o 연결이 종료됩니다. 클라이언트는 &quot;close&quot;연결 옵션을 보내거나받을 때까지 또는 &quot;keep-alive&quot;연결 옵션없이 HTTP / 1.0 응답을받을 때까지 지속적 연결에서 추가 요청을 보낼 수 있습니다. 연결에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫음으로 정의되지 않은 길이)를 가져야합니다.메커니즘, 연결은 현재 응답 후에도 지속됩니다. 그렇지 않으면 o 현재 응답 후 연결이 닫힙니다. 클라이언트는 &quot;닫기&quot;연결 옵션을 보내거나받을 때까지 또는 &quot;keep-alive&quot;연결 옵션없이 HTTP / 1.0 응답을받을 때까지 지속적인 연결에서 추가 요청을 보낼 수 있습니다. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.메커니즘, 연결은 현재 응답 후에도 지속됩니다. 그렇지 않으면 o 현재 응답 후 연결이 닫힙니다. 클라이언트는 &quot;닫기&quot;연결 옵션을 보내거나받을 때까지 또는 &quot;keep-alive&quot;연결 옵션없이 HTTP / 1.0 응답을받을 때까지 지속적인 연결에서 추가 요청을 보낼 수 있습니다. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.&quot;keep-alive&quot;연결 옵션이없는 0 응답. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.&quot;keep-alive&quot;연결 옵션이없는 0 응답. 지속성을 유지하려면 연결의 모든 메시지에 설명 된대로 자체 정의 메시지 길이 (즉, 연결을 닫을 때 정의되지 않은 메시지 길이)가 있어야합니다.&lt;a href=&quot;#section-3.3&quot;&gt;섹션 3.3&lt;/a&gt; . 서버는 응답을 보낸 후 전체 요청 메시지 본문을 읽거나 연결을 닫아야합니다. 그렇지 않으면 영구 연결의 나머지 데이터가 다음 요청으로 잘못 해석되기 때문입니다. 마찬가지로, 후속 요청에 동일한 연결을 재사용하려면 클라이언트가 전체 응답 메시지 본문을 읽어야합니다. 프록시 서버는 HTTP / 1.0 클라이언트와의 지속적인 연결을 유지해서는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-19.7.1&quot;&gt;안됩니다&lt;/a&gt; ( 많은 HTTP / 1.0 클라이언트가 구현 한 Keep-Alive 헤더 필드의 문제점에 대한 정보 및 논의는 [RFC2068]의 19.7.1 절 참조 ). HTTP / 1.0 클라이언트와의 하위 호환성에 대한 자세한 내용 은 &lt;a href=&quot;#appendix-A.1.2&quot;&gt;부록 A.1.2&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="b235442975ba302869396fe0ff4cdaebf53c2643" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field
   (&lt;a href=&quot;#section-3.3.1&quot;&gt;Section 3.3.1&lt;/a&gt;).  Transfer codings need to be decoded prior to
   forwarding an HTTP message over a MIME-compliant protocol.</source>
          <target state="translated">HTTP / 1.1은 Transfer-Encoding 헤더 필드를 소개합니다 ( &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 절&lt;/a&gt; ). MIME 호환 프로토콜을 통해 HTTP 메시지를 전달하기 전에 전송 코딩을 디코딩해야합니다.</target>
        </trans-unit>
        <trans-unit id="b7bc6b9e5b12ebbdf628d83f676eae2e25277f50" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 introduces the Transfer-Encoding header field (&lt;a href=&quot;#section-14.41&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;14.41&lt;/a&gt;). Proxies/gateways MUST remove any transfer-coding prior to
   forwarding a message via a MIME-compliant protocol.

   A process for decoding the &quot;chunked&quot; transfer-coding (&lt;a href=&quot;#section-3.6&quot;&gt;section 3.6&lt;/a&gt;)
   can be represented in pseudo-code as:

       length := 0
       read chunk-size, chunk-extension (if any) and CRLF
       while (chunk-size &amp;gt; 0) {
          read chunk-data and CRLF
          append chunk-data to entity-body
          length := length + chunk-size
          read chunk-size and CRLF
       }
       read entity-header
       while (entity-header not empty) {
          append entity-header to existing header fields
          read entity-header
       }
       Content-Length := length
       Remove &quot;chunked&quot; from Transfer-Encoding</source>
          <target state="translated">HTTP / 1.1은 Transfer-Encoding 헤더 필드 ( &lt;a href=&quot;#section-14.41&quot;&gt;14.41 &lt;/a&gt;&lt;a href=&quot;#section-14.41&quot;&gt;절&lt;/a&gt; )를 소개합니다. 프록시 / 게이트웨이는 MIME 호환 프로토콜을 통해 메시지를 전달하기 전에 전송 코딩을 제거해야합니다. &quot;청크 된&quot;전송 코딩을 디코딩하는 프로세스 ( &lt;a href=&quot;#section-3.6&quot;&gt;섹션 3.6&lt;/a&gt;)는 다음과 같이 의사 코드로 표현할 수 있습니다. length : = 0 청크 크기 읽기, 청크 확장명 (있는 경우) 및 CRLF 반면 (청크 크기&amp;gt; 0) {청크 데이터 읽기 및 CRLF 청크 데이터를 엔터티에 추가 본문 길이 : = 길이 + 청크 크기 읽기 청크 크기 및 CRLF} 엔터티 헤더를 읽는 동안 (엔티티 헤더는 비어 있지 않음) {엔터티 헤더를 기존 헤더 필드에 추가합니다 엔터티 헤더를 읽습니다.} Content-Length : = length &quot;제거 전송 인코딩에서 청크 분할 됨</target>
        </trans-unit>
        <trans-unit id="55f1d0e9c7b192d39b6bf47cece53fe18cddfa5c" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 servers SHOULD maintain persistent connections and use TCP's
   flow control mechanisms to resolve temporary overloads, rather than
   terminating connections with the expectation that clients will retry.
   The latter technique can exacerbate network congestion.</source>
          <target state="translated">HTTP / 1.1 서버는 클라이언트가 재 시도 할 것으로 예상되는 연결을 종료하지 않고 지속적인 연결을 유지하고 TCP의 흐름 제어 메커니즘을 사용하여 임시 과부하를 해결해야합니다. 후자의 기술은 네트워크 혼잡을 악화시킬 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5bde47938358e96d6b78dd50b25535a7c82c1d43" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-3.3.1&quot;&gt;section 3.3.1&lt;/a&gt;) to
   simplify the process of date comparison. Proxies and gateways from
   other protocols SHOULD ensure that any Date header field present in a
   message conforms to one of the HTTP/1.1 formats and rewrite the date
   if necessary.</source>
          <target state="translated">HTTP / 1.1은 제한된 날짜 형식 세트 ( &lt;a href=&quot;#section-3.3.1&quot;&gt;3.3.1 절&lt;/a&gt; )를 사용하여 날짜 비교 프로세스를 단순화합니다. 다른 프로토콜의 프록시 및 게이트웨이는 메시지에있는 날짜 헤더 필드가 HTTP / 1.1 형식 중 하나를 준수하는지 확인하고 필요한 경우 날짜를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="f983729fa70af1e90d7ea6dbb4afb3d7c8f79cd6" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses a restricted set of date formats (&lt;a href=&quot;#section-7.1.1.1&quot;&gt;Section 7.1.1.1&lt;/a&gt;) to
   simplify the process of date comparison.  Proxies and gateways from
   other protocols ought to ensure that any Date header field present in
   a message conforms to one of the HTTP/1.1 formats and rewrite the
   date if necessary.</source>
          <target state="translated">HTTP / 1.1은 제한된 날짜 형식 세트 ( &lt;a href=&quot;#section-7.1.1.1&quot;&gt;7.1.1.1 절&lt;/a&gt; )를 사용하여 날짜 비교 프로세스를 단순화합니다. 다른 프로토콜의 프록시 및 게이트웨이는 메시지에있는 날짜 헤더 필드가 HTTP / 1.1 형식 중 하나를 준수하고 필요한 경우 날짜를 다시 작성해야합니다.</target>
        </trans-unit>
        <trans-unit id="87f9910f16689f67ad3946ec5476c5e20370823d" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for Internet Mail (&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [&lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt;]) and the Multipurpose Internet Mail Extensions (MIME [&lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt;]) to
   allow entities to be transmitted in an open variety of
   representations and with extensible mechanisms. However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;
   discusses mail, and HTTP has a few features that are different from
   those described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;. These differences were carefully chosen
   to optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt;. Proxies and gateways to strict MIME environments SHOULD be
   aware of these differences and provide the appropriate conversions
   where necessary. Proxies and gateways from MIME environments to HTTP
   also need to be aware of the differences because some conversions
   might be required.</source>
          <target state="translated">HTTP / 1.1은 인터넷 메일 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;822&lt;/a&gt; [ &lt;a href=&quot;#ref-9&quot;&gt;9&lt;/a&gt; ]) 및 다목적 인터넷 메일 확장 (MIME [ &lt;a href=&quot;#ref-7&quot;&gt;7&lt;/a&gt; ])에 대해 정의 된 많은 구성 을 사용하여 엔티티를 다양한 표현으로 확장 가능한 메커니즘으로 전송할 수 있습니다. 그러나, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; 에 나와있는 메일 및 HTTP에 기술 된 것과 상이한 기능이 몇몇있다 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045를&lt;/a&gt; . 이러한 차이는 바이너리 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 자유롭게 사용할 수있게하고, 날짜 비교를보다 쉽게하고, 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다. 이 부록에서는 HTTP와 다른 특정 영역에 대해 설명합니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;2045&lt;/a&gt; . 엄격한 MIME 환경으로의 프록시 및 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야합니다. MIME 환경에서 HTTP 로의 프록시 및 게이트웨이도 일부 변환이 필요할 수 있으므로 차이점을 알고 있어야합니다.</target>
        </trans-unit>
        <trans-unit id="7ba038961de66fab4bc0d4ca5f738bb4971581c5" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 uses many of the constructs defined for the Internet Message
   Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;] and the Multipurpose Internet Mail Extensions (MIME)
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt;] to allow a message body to be transmitted in an open
   variety of representations and with extensible header fields.
   However, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; is focused only on email; applications of HTTP have
   many characteristics that differ from email; hence, HTTP has features
   that differ from MIME.  These differences were carefully chosen to
   optimize performance over binary connections, to allow greater
   freedom in the use of new media types, to make date comparisons
   easier, and to acknowledge the practice of some early HTTP servers
   and clients.

   This appendix describes specific areas where HTTP differs from MIME.
   Proxies and gateways to and from strict MIME environments need to be
   aware of these differences and provide the appropriate conversions
   where necessary.</source>
          <target state="translated">HTTP / 1.1은 인터넷 메시지 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] 및 MIME (Multipurpose Internet Mail Extensions) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC2045&lt;/a&gt; ]에 대해 정의 된 많은 구성 을 사용하여 메시지 본문을 다양한 표현으로 확장 가능한 헤더 필드와 함께 전송할 수 있습니다. 그러나 &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;이메일에만 집중합니다. HTTP 애플리케이션에는 이메일과 다른 많은 특성이 있습니다. 따라서 HTTP에는 MIME과 다른 기능이 있습니다. 이러한 차이는 바이너리 연결에 대한 성능을 최적화하고, 새로운 미디어 유형을 자유롭게 사용할 수있게하고, 날짜 비교를보다 쉽게하고, 일부 초기 HTTP 서버 및 클라이언트의 관행을 인정하기 위해 신중하게 선택되었습니다. 이 부록에서는 HTTP가 MIME과 다른 특정 영역에 대해 설명합니다. 엄격한 MIME 환경과의 프록시 및 게이트웨이는 이러한 차이점을 인식하고 필요한 경우 적절한 변환을 제공해야합니다.</target>
        </trans-unit>
        <trans-unit id="26857a3eb014d1c446a022b99900a2e1fa1f388e" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was first published as &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; in January 1997.</source>
          <target state="translated">HTTP / 1.1은 1997 년 1 월에 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; 로 처음 출판되었습니다 .</target>
        </trans-unit>
        <trans-unit id="d5072f3723c431d48c51e0f349be99684fbc90ba" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains both concepts.</source>
          <target state="translated">HTTP / 1.1은 지속적인 연결 및 파이프 라이닝을 지원하는 최초의 HTTP 버전입니다. 이 기사에서는 두 가지 개념을 모두 설명합니다.</target>
        </trans-unit>
        <trans-unit id="bd63c4dcb6457bcb6fd3cf072cc949e847bb34c1" translate="yes" xml:space="preserve">
          <source>HTTP/1.1 was the first version of HTTP to support persistent connection and pipelining. This article explains these two concepts.</source>
          <target state="translated">HTTP / 1.1은 지속적인 연결 및 파이프 라이닝을 지원하는 최초의 HTTP 버전입니다. 이 기사에서는 이러한 두 가지 개념에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1503342ea4d0a3a7deec2528731a5bc064211705" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Authentication</source>
          <target state="translated">HTTP / 1.1 : 인증</target>
        </trans-unit>
        <trans-unit id="0c4a2c0ccd4801b8e3ca9529c7a252503dccdf00" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Semantics and Content</source>
          <target state="translated">HTTP / 1.1 : 의미론 및 내용</target>
        </trans-unit>
        <trans-unit id="c0b298b6e63b8ce602677a51d4f1e6436079232f" translate="yes" xml:space="preserve">
          <source>HTTP/1.1: Status Code Definitions</source>
          <target state="translated">HTTP / 1.1 : 상태 코드 정의</target>
        </trans-unit>
        <trans-unit id="21663f5aa54f6135626b598bc6ce1bf03ec7513b" translate="yes" xml:space="preserve">
          <source>HTTP/1.x messages have a few drawbacks for performance:</source>
          <target state="translated">HTTP / 1.x 메시지에는 성능에 몇 가지 단점이 있습니다.</target>
        </trans-unit>
        <trans-unit id="682ec4f8ae7cf90f4fab0685ba322176bdd4f593" translate="yes" xml:space="preserve">
          <source>HTTP/2 &amp;ndash; A protocol for greater performance</source>
          <target state="translated">HTTP / 2 &amp;ndash; 성능 향상을위한 프로토콜</target>
        </trans-unit>
        <trans-unit id="a9820b1d6f7a1eb33859fc438f4a30a55193154b" translate="yes" xml:space="preserve">
          <source>HTTP/2 Frames</source>
          <target state="translated">HTTP / 2 프레임</target>
        </trans-unit>
        <trans-unit id="b9a1cc9ca8b3b857841ac45f6cab101cd76b0608" translate="yes" xml:space="preserve">
          <source>HTTP/2 adds additional models for connection management.</source>
          <target state="translated">HTTP / 2는 연결 관리를위한 추가 모델을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="de5c597058c2601a65efadc88f948c586a1ffe49" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained. This article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP / 2는 연결을 만들고 유지하는 방법을 완전히 재검토했습니다. 이 기사에서는 HTTP 프레임이 멀티플렉싱을 허용하고 이전 HTTP 버전의 'head-of-line'차단 문제를 해결하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="c5d84f8ae615e7ecf29c3c866e9ab8e4f31fe842" translate="yes" xml:space="preserve">
          <source>HTTP/2 completely revisited how connections are created and maintained: this article explains how HTTP frames allow multiplexing and solve the 'head-of-line' blocking problem of former HTTP versions.</source>
          <target state="translated">HTTP / 2는 연결이 생성되고 유지되는 방법을 완전히 재검토했습니다.이 기사에서는 HTTP 프레임이 멀티플렉싱을 허용하고 이전 HTTP 버전의 'head-of-line'차단 문제를 해결하는 방법을 설명합니다.</target>
        </trans-unit>
        <trans-unit id="7f0a10f9ce0b6e8be8176a0d0cf459883c237676" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose and the way it is encoded.</source>
          <target state="translated">HTTP / 2는 HTTP / 1.x 메시지를 이진 프레임으로 캡슐화하고 나타냅니다. 이 기사에서는 프레임 구조, 목적 및 인코딩 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="8b89d94c6825e208193b0c3215145db1ad533fe7" translate="yes" xml:space="preserve">
          <source>HTTP/2 encapsulates and represents HTTP/1.x messages in a binary frame. This article explains the frame structure, its purpose, and the way it's encoded.</source>
          <target state="translated">HTTP / 2는 이진 프레임에 HTTP / 1.x 메시지를 캡슐화하고 나타냅니다. 이 기사에서는 프레임 구조, 용도 및 인코딩 방식에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="3f6c2df4a46eb441a1cda15f98cf3c5243cca600" translate="yes" xml:space="preserve">
          <source>HTTP/2 introduces an extra step: it divides HTTP/1.x messages into frames which are embedded in a stream. Data and header frames are separated, this allows header compression. Several streams can be combined together, a process called &lt;em&gt;multiplexing&lt;/em&gt;, allowing more efficient underlying TCP connections.</source>
          <target state="translated">HTTP / 2는 추가 단계를 도입합니다. HTTP / 1.x 메시지를 스트림에 포함 된 프레임으로 나눕니다. 데이터와 헤더 프레임이 분리되어 헤더 압축이 가능합니다. &lt;em&gt;멀티플렉싱 (multiplexing&lt;/em&gt; ) 이라는 여러 스트림을 결합 하여보다 효율적인 기본 TCP 연결을 가능하게합니다.</target>
        </trans-unit>
        <trans-unit id="a496c90d2f1f8118ed8e04e7a7acf8027e245b96" translate="yes" xml:space="preserve">
          <source>HTTP/3 - HTTP over QUIC</source>
          <target state="translated">HTTP / 3-QUIC를 통한 HTTP</target>
        </trans-unit>
        <trans-unit id="2e6205295940162ec6f356951c335bcb251f4584" translate="yes" xml:space="preserve">
          <source>HTTPS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">HTTPS &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="9b1b03288626a4932189c45619afd52b616640ff" translate="yes" xml:space="preserve">
          <source>Handling CORS on the server (Java example)</source>
          <target state="translated">서버에서 CORS 처리 (Java 예)</target>
        </trans-unit>
        <trans-unit id="76ccff916d0696e0db6e0e63211aa5d404b177bb" translate="yes" xml:space="preserve">
          <source>Handshake</source>
          <target state="translated">Handshake</target>
        </trans-unit>
        <trans-unit id="ef63c9de46b2633531f80d09b249c8177fb13159" translate="yes" xml:space="preserve">
          <source>Header field name:  SLUG

   Applicable protocol:  http [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]

   Status:  standard.

   Author/Change controller:  IETF (iesg@ietf.org) Internet Engineering
      Task Force

   Specification document(s):  &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt;.

   Related information:  None.</source>
          <target state="translated">헤더 필드 이름 : SLUG 적용 가능한 프로토콜 : http [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ] 상태 : 표준. 작성자 / 변경 컨트롤러 : IETF (iesg@ietf.org) 인터넷 엔지니어링 태스크 포스 사양 문서 : &lt;a href=&quot;https://tools.ietf.org/html/rfc5023&quot;&gt;RFC 5023&lt;/a&gt; . 관련 정보 : 없음</target>
        </trans-unit>
        <trans-unit id="16c88366423875ffcd832b0568164659af366f76" translate="yes" xml:space="preserve">
          <source>Header field name: DAV

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : DAV 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.1&quot;&gt;10.1 절&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0a425ee275ccc8dc88e573145d9bc8f251db402b" translate="yes" xml:space="preserve">
          <source>Header field name: Depth

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.2&quot;&gt;Section 10.2&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 깊이 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.2&quot;&gt;섹션 10.2&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0b05ddbc40717bf61ebce12546f2a61a4a13a71f" translate="yes" xml:space="preserve">
          <source>Header field name: Destination

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.3&quot;&gt;Section 10.3&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 대상 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.3&quot;&gt;섹션 10.3&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="80f31a912be49327cab8cfb0f3ab988e1efad182" translate="yes" xml:space="preserve">
          <source>Header field name: If

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.4&quot;&gt;Section 10.4&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 해당되는 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.4&quot;&gt;섹션 10.4&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="405cc2ed9285599fe7b4ed659f2f3efef397c235" translate="yes" xml:space="preserve">
          <source>Header field name: Lock-Token

   Applicable protocol: http

   Status: standard 

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.5&quot;&gt;Section 10.5&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 잠금 토큰 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.5&quot;&gt;10.5 절&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="0ef45169928c0bea57455212198061a9ab1aac96" translate="yes" xml:space="preserve">
          <source>Header field name: Overwrite

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.6&quot;&gt;Section 10.6&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 덮어 쓰기 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.6&quot;&gt;섹션 10.6&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="ebc42438bb349fc70f9ce54ef8a83a2205114a92" translate="yes" xml:space="preserve">
          <source>Header field name: Timeout

   Applicable protocol: http

   Status: standard

   Author/Change controller: IETF

   Specification document: this specification (&lt;a href=&quot;#section-10.7&quot;&gt;Section 10.7&lt;/a&gt;)</source>
          <target state="translated">헤더 필드 이름 : 타임 아웃 적용 가능한 프로토콜 : http 상태 : 표준 작성자 / 변경 컨트롤러 : IETF 사양 문서 :이 사양 ( &lt;a href=&quot;#section-10.7&quot;&gt;10.7 절&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="4ab8eed7600b67916da46088b86ba4f2a325716b" translate="yes" xml:space="preserve">
          <source>Header fields are fully extensible: there is no limit on the
   introduction of new field names, each presumably defining new
   semantics, nor on the number of header fields used in a given
   message.  Existing fields are defined in each part of this
   specification and in many other specifications outside this document
   set.

   New header fields can be defined such that, when they are understood
   by a recipient, they might override or enhance the interpretation of
   previously defined header fields, define preconditions on request
   evaluation, or refine the meaning of responses.

   A proxy MUST forward unrecognized header fields unless the field-name
   is listed in the Connection header field (&lt;a href=&quot;#section-6.1&quot;&gt;Section 6.1&lt;/a&gt;) or the proxy
   is specifically configured to block, or otherwise transform, such
   fields.  Other recipients SHOULD ignore unrecognized header fields.
   These requirements allow HTTP's functionality to be enhanced without
   requiring prior update of deployed intermediaries.

   All defined header fields ought to be registered with IANA in the
   &quot;Message Headers&quot; registry, as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;Section&amp;nbsp;8.3 of [RFC7231]&lt;/a&gt;.</source>
          <target state="translated">헤더 필드는 완전히 확장 가능합니다. 새로운 필드 이름의 도입, 각각 새로운 의미론을 정의 할 가능성이 있거나 주어진 메시지에 사용 된 헤더 필드의 수에는 제한이 없습니다. 기존 필드는이 사양의 각 부분과이 문서 집합 이외의 다른 많은 사양에 정의되어 있습니다. 새로운 헤더 필드는 수신자가 이해할 때 이전에 정의 된 헤더 필드의 해석을 무시하거나 향상 시키거나 요청 평가시 전제 조건을 정의하거나 응답의 의미를 세분화 할 수 있도록 정의 할 수 있습니다. 필드 이름이 연결 헤더 필드에 나열되어 있지 않으면 프록시는 인식 할 수없는 헤더 필드를 전달해야합니다 ( &lt;a href=&quot;#section-6.1&quot;&gt;6.1 절&lt;/a&gt;) 또는 프록시는 이러한 필드를 차단하거나 달리 변환하도록 구체적으로 구성됩니다. 다른 수신자는 인식 할 수없는 헤더 필드를 무시해야합니다. 이러한 요구 사항을 통해 배포 된 중개자의 사전 업데이트없이 HTTP 기능을 향상시킬 수 있습니다. 정의 된 모든 헤더 필드 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-8.3&quot;&gt;는 [RFC7231] 8.3 절에&lt;/a&gt; 설명 된대로 &quot;메시지 헤더&quot;레지스트리에서 IANA에 등록되어야합니다 .</target>
        </trans-unit>
        <trans-unit id="a40e00de254d23c5e44ccdfe307162d5d4ecbef3" translate="yes" xml:space="preserve">
          <source>Header fields are key:value pairs that can be used to communicate
   data about the message, its payload, the target resource, or the
   connection (i.e., control data).  See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt; for a
   general definition of header field syntax in HTTP messages.

   The requirements for header field names are defined in [&lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;].

   Authors of specifications defining new fields are advised to keep the
   name as short as practical and not to prefix the name with &quot;X-&quot;
   unless the header field will never be used on the Internet.  (The
   &quot;X-&quot; prefix idiom has been extensively misused in practice; it was
   intended to only be used as a mechanism for avoiding name collisions
   inside proprietary software or intranet processing, since the prefix
   would ensure that private names never collide with a newly registered
   Internet name; see [&lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt;] for further information).

   New header field values typically have their syntax defined using
   ABNF ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;]), using the extension defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;Section&amp;nbsp;7 of
   [RFC7230]&lt;/a&gt; as necessary, and are usually constrained to the range of
   US-ASCII characters.  Header fields needing a greater range of
   characters can use an encoding such as the one defined in [&lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt;].

   Leading and trailing whitespace in raw field values is removed upon
   field parsing (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;Section&amp;nbsp;3.2.4 of [RFC7230]&lt;/a&gt;).  Field definitions where
   leading or trailing whitespace in values is significant will have to
   use a container syntax such as quoted-string (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;Section&amp;nbsp;3.2.6 of
   [RFC7230]&lt;/a&gt;).

   Because commas (&quot;,&quot;) are used as a generic delimiter between
   field-values, they need to be treated with care if they are allowed
   in the field-value.  Typically, components that might contain a comma
   are protected with double-quotes using the quoted-string ABNF
   production.

   For example, a textual date and a URI (either of which might contain
   a comma) could be safely carried in field-values like these:

     Example-URI-Field: &quot;http://example.com/a.html,foo&quot;,
                        &quot;http://without-a-comma.example.com/&quot;
     Example-Date-Field: &quot;Sat, 04 May 1996&quot;, &quot;Wed, 14 Sep 2005&quot;

   Note that double-quote delimiters almost always are used with the
   quoted-string production; using a different syntax inside
   double-quotes will likely cause unnecessary confusion. 

   Many header fields use a format including (case-insensitively) named
   parameters (for instance, Content-Type, defined in &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt;).
   Allowing both unquoted (token) and quoted (quoted-string) syntax for
   the parameter value enables recipients to use existing parser
   components.  When allowing both forms, the meaning of a parameter
   value ought to be independent of the syntax used for it (for an
   example, see the notes on parameter handling for media types in
   &lt;a href=&quot;#section-3.1.1.1&quot;&gt;Section 3.1.1.1&lt;/a&gt;).

   Authors of specifications defining new header fields are advised to
   consider documenting:

   o  Whether the field is a single value or whether it can be a list
      (delimited by commas; see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;).

      If it does not use the list syntax, document how to treat messages
      where the field occurs multiple times (a sensible default would be
      to ignore the field, but this might not always be the right
      choice).

      Note that intermediaries and software libraries might combine
      multiple header field instances into a single one, despite the
      field's definition not allowing the list syntax.  A robust format
      enables recipients to discover these situations (good example:
      &quot;Content-Type&quot;, as the comma can only appear inside quoted
      strings; bad example: &quot;Location&quot;, as a comma can occur inside a
      URI).

   o  Under what conditions the header field can be used; e.g., only in
      responses or requests, in all messages, only on responses to a
      particular request method, etc.

   o  Whether the field should be stored by origin servers that
      understand it upon a PUT request.

   o  Whether the field semantics are further refined by the context,
      such as by existing request methods or status codes.

   o  Whether it is appropriate to list the field-name in the Connection
      header field (i.e., if the header field is to be hop-by-hop; see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;Section&amp;nbsp;6.1 of [RFC7230]&lt;/a&gt;).

   o  Under what conditions intermediaries are allowed to insert,
      delete, or modify the field's value. 

   o  Whether it is appropriate to list the field-name in a Vary
      response header field (e.g., when the request header field is used
      by an origin server's content selection algorithm; see
      &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;).

   o  Whether the header field is useful or allowable in trailers (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of [RFC7230]&lt;/a&gt;).

   o  Whether the header field ought to be preserved across redirects.

   o  Whether it introduces any additional security considerations, such
      as disclosure of privacy-related data.</source>
          <target state="translated">헤더 필드는 메시지, 페이로드, 대상 자원 또는 연결 (예 : 제어 데이터)에 대한 데이터를 통신하는 데 사용할 수있는 키 : 값 쌍입니다. HTTP 메시지의 헤더 필드 구문에 대한 일반적인 정의 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;는 [RFC7230]의 3.2 절을&lt;/a&gt; 참조하십시오 . 헤더 필드 이름에 대한 요구 사항은 [ &lt;a href=&quot;#ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]. 새 필드를 정의하는 사양 작성자는 이름을 최대한 짧게 유지하고 인터넷에서 헤더 필드를 사용하지 않는 한 이름 앞에 &quot;X-&quot;를 붙이지 않는 것이 좋습니다. ( &quot;X-&quot;접두사 관용구는 실제로 광범위하게 잘못 사용되었습니다. 접두사가 개인 이름이 새로 등록 된 이름과 충돌하지 않도록하기 때문에 독점 소프트웨어 또는 인트라넷 처리 내에서 이름 충돌을 피하기위한 메커니즘으로 만 사용되었습니다. 인터넷 이름, 자세한 내용은 [ &lt;a href=&quot;#ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ] 참조 ). 새로운 헤더 필드 값은 일반적으로 &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-7&quot;&gt;[RFC7230]의 섹션 7에&lt;/a&gt; 정의 된 확장을 사용 하여 ABNF ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt; ])를 사용하여 정의 된 구문을 갖습니다.필요에 따라 일반적으로 US-ASCII 문자 범위로 제한됩니다. 더 넓은 범위의 문자가 필요한 헤더 필드는 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC5987&lt;/a&gt; ]에 정의 된 것과 같은 인코딩을 사용할 수 있습니다 . 원시 필드 값의 선행 및 후행 공백은 필드 구문 분석시 제거됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.4&quot;&gt;[RFC7230]의 섹션 3.2.4&lt;/a&gt; ). 값에서 선행 또는 후행 공백이 중요한 필드 정의는 인용 문자열 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2.6&quot;&gt;[RFC7230]의 섹션 3.2.6)&lt;/a&gt; 과 같은 컨테이너 구문을 사용해야합니다 .). 쉼표 ( &quot;,&quot;)는 필드 값 사이의 일반 구분 기호로 사용되므로 필드 값에 허용되는 경우주의해서 처리해야합니다. 일반적으로 쉼표를 포함 할 수있는 구성 요소는 인용 문자열 ABNF 생성을 사용하여 큰 따옴표로 보호됩니다. 예를 들어 텍스트 날짜와 URI (쉼표를 포함 할 수 있음)는 다음과 같은 필드 값으로 안전하게 전달할 수 있습니다. Example-URI-Field : &quot;http://example.com/a.html,foo&quot; , &quot;http://without-a-comma.example.com/&quot;Example-Date-Field : &quot;1996 년 5 월 4 일 토요일&quot;, &quot;2005 년 9 월 14 일 수요일&quot;큰 따옴표 구분 기호는 거의 항상 인용 문자열 생산; 큰 따옴표 안에 다른 구문을 사용하면 불필요한 혼란이 발생할 수 있습니다.많은 헤더 필드는 대소 문자를 구분하지 않고 명명 된 매개 변수 (예 : Content-Type,&lt;a href=&quot;#section-3.1.1.5&quot;&gt;섹션 3.1.1.5&lt;/a&gt; ). 매개 변수 값에 따옴표가없는 (토큰) 구문과 따옴표가있는 (따옴표가 붙은 문자열) 구문을 모두 허용하면받는 사람이 기존 파서 구성 요소를 사용할 수 있습니다. 두 형식을 모두 허용하는 경우 매개 변수 값의 의미는 사용 된 구문과 독립적이어야합니다 (예를 들어, &lt;a href=&quot;#section-3.1.1.1&quot;&gt;3.1.1.1 절의&lt;/a&gt; 매체 유형에 대한 매개 변수 처리에 대한 참고 사항 참조 ). 새 헤더 필드를 정의하는 사양 작성자는 문서화를 고려해야합니다. o 필드가 단일 값인지 또는 목록이 될 수 있는지 여부 (쉼표로 구분) &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt; 참조). 목록 구문을 사용하지 않는 경우 필드가 여러 번 발생하는 메시지를 처리하는 방법을 문서화하십시오 (기본적으로 필드를 무시하는 것이지만 이것이 항상 올바른 선택은 아닙니다). 목록 구문을 허용하지 않는 필드 정의에도 불구하고 중개자와 소프트웨어 라이브러리는 여러 헤더 필드 인스턴스를 단일 인스턴스로 결합 할 수 있습니다. 강력한 형식을 사용하면 수신자가 이러한 상황을 발견 할 수 있습니다 (예 : 쉼표는 따옴표로 묶인 문자열에만 나타날 수 있으므로 &quot;Content-Type&quot;, 나쁜 예 : 쉼표는 URI 내에서 발생할 수 있음). o 헤더 필드를 어떤 조건에서 사용할 수 있습니까? 예를 들어, 응답 또는 요청에서만, 모든 메시지에서, 특정 요청 방법에 대한 응답에서만.o PUT 요청시 필드를 이해하는 원본 서버에서 필드를 저장해야하는지 여부 o 필드 시맨틱이 기존 요청 방법 또는 상태 코드와 같은 컨텍스트에 의해 더 세분화되는지 여부 o 연결 헤더 필드에 필드 이름을 나열하는 것이 적절한 지 여부 (즉, 헤더 필드가 홉별인지 여부) &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-6.1&quot;&gt;[RFC7230]의 섹션 6.1&lt;/a&gt; ). o 어떤 조건 하에서 중개자가 필드 값을 삽입, 삭제 또는 수정할 수 있습니다. o Vary 응답 헤더 필드에 필드 이름을 나열하는 것이 적절한 지 여부 (예 : 요청 헤더 필드가 오리진 서버의 컨텐츠 선택 알고리즘에 의해 사용되는 경우; &lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; 참조 ). o 트레일러에서 헤더 필드가 유용한 지 또는 허용되는지 여부 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.1&quot;&gt;[RFC7230]의 4.1 절&lt;/a&gt; 참조 ) o 헤더 필드를 리디렉션에서 유지해야하는지 여부 o 개인 정보 보호 관련 데이터 공개와 같은 추가 보안 고려 사항이 도입되는지 여부.</target>
        </trans-unit>
        <trans-unit id="73ce89b0c8df0a7ed4d98060b2c7c611ac330135" translate="yes" xml:space="preserve">
          <source>Header fields that regulate the use of trailers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt; (requests) and &lt;a href=&quot;trailer&quot;&gt;&lt;code&gt;Trailer&lt;/code&gt;&lt;/a&gt; (responses).</source>
          <target state="translated">트레일러 사용을 규제하는 헤더 필드 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; (요청) 및 &lt;a href=&quot;trailer&quot;&gt; &lt;code&gt;Trailer&lt;/code&gt; &lt;/a&gt; (응답).</target>
        </trans-unit>
        <trans-unit id="bf858dd7754f89623471d452d85365f43194c795" translate="yes" xml:space="preserve">
          <source>Header type</source>
          <target state="translated">헤더 유형</target>
        </trans-unit>
        <trans-unit id="2e31dbd5f484d5c1a3e787a044871e878213d50e" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">컨텐츠 협상 결과가 포함 된 헤더 : &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6e46dedc85812b44c40eda61d963afafe6e17ec8" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">컨텐츠 협상 결과가 포함 된 헤더 : &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="04db11046ac45baaf2858c147c0d0da0d83dfe2b" translate="yes" xml:space="preserve">
          <source>Header with the result of the content negotiation: &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">컨텐츠 협상 결과가 포함 된 헤더 : &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="520de7443d00d6ff4dc3ababbbf6cfbe0b74f4ec" translate="yes" xml:space="preserve">
          <source>Headers</source>
          <target state="translated">Headers</target>
        </trans-unit>
        <trans-unit id="d43cdd47172ebbec83d46dc0929904cbc0e5ba83" translate="yes" xml:space="preserve">
          <source>Headers are often very similar from one message to the next one, yet still repeated across connections.</source>
          <target state="translated">헤더는 종종 한 메시지에서 다음 메시지와 매우 유사하지만 여전히 연결에서 반복됩니다.</target>
        </trans-unit>
        <trans-unit id="b9f5a636b75216c81304804a9a45004630234515" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;proxies&lt;/a&gt; handle them:</source>
          <target state="translated">헤더는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Proxy_server&quot;&gt;프록시가&lt;/a&gt; 처리하는 방식에 따라 그룹화 할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="953e087d7da0e93f2114e33931a9fff08ea7dde9" translate="yes" xml:space="preserve">
          <source>Headers can also be grouped according to how proxies handle them:</source>
          <target state="translated">프록시가 헤더를 처리하는 방식에 따라 헤더를 그룹화 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e731d99aaf73e73a84db12018da22acb10f8eaf" translate="yes" xml:space="preserve">
          <source>Headers can be grouped according to their contexts:</source>
          <target state="translated">헤더는 컨텍스트에 따라 그룹화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="62484b23e54725c71a2263f18277c31549662db4" translate="yes" xml:space="preserve">
          <source>Headers, unlike bodies, are uncompressed.</source>
          <target state="translated">본문과 달리 헤더는 압축되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5da9db7ae87281e3e1ab3c768b9be45ae8134d50" translate="yes" xml:space="preserve">
          <source>Helpful tools and resources for understanding and debugging HTTP.</source>
          <target state="translated">HTTP 이해 및 디버깅을위한 유용한 도구 및 리소스</target>
        </trans-unit>
        <trans-unit id="2ed70bbb1a3a5c498b113f52c1548cee8ea9cc2d" translate="yes" xml:space="preserve">
          <source>Here again, be sure to take the right token for the browser you are looking for, as there is no guarantee that others will contain a valid number.</source>
          <target state="translated">여기서도 다른 사용자가 유효한 숫자를 포함 할 것이라는 보장이 없으므로 찾고있는 브라우저에 올바른 토큰을 가져와야합니다.</target>
        </trans-unit>
        <trans-unit id="d5227ab359118de929fda02e4ed8472790aeba2d" translate="yes" xml:space="preserve">
          <source>Here is a JavaScript regular expression that will detect all mobile devices, including devices with a device id in their UA string:</source>
          <target state="translated">다음은 UA 문자열에 장치 ID가있는 장치를 포함하여 모든 모바일 장치를 감지하는 JavaScript 정규식입니다.</target>
        </trans-unit>
        <trans-unit id="4e3866c880875ee1ff8235362e89c76b5139a9ee" translate="yes" xml:space="preserve">
          <source>Here is a list of MIME types, associated by type of documents, ordered by their common extensions.</source>
          <target state="translated">다음은 공통된 확장명으로 정렬 된 문서 유형별로 연관된 MIME 유형 목록입니다.</target>
        </trans-unit>
        <trans-unit id="d20b00cd2016c9a232dbd3f29c2f2897e9fcffac" translate="yes" xml:space="preserve">
          <source>Here is a list of common features controllable with HTTP.</source>
          <target state="translated">다음은 HTTP로 제어 할 수있는 일반적인 기능 목록입니다.</target>
        </trans-unit>
        <trans-unit id="5c9905f596ccef64e1269e49689d1a73c07dd5b6" translate="yes" xml:space="preserve">
          <source>Here is a sample exchange between client and server:</source>
          <target state="translated">클라이언트와 서버 간의 샘플 교환은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="9501e397bcbf8b4862fe537468cb6a0753bdae2b" translate="yes" xml:space="preserve">
          <source>Here is an example in PHP of handling a &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;preflighted request&lt;/a&gt;:</source>
          <target state="translated">다음은 &lt;a href=&quot;cors#Preflighted_requests&quot;&gt;프리 플라이트 요청&lt;/a&gt; 을 처리하는 PHP의 예입니다 .</target>
        </trans-unit>
        <trans-unit id="75207f8e8ffefa8d462dd3fb2a1a65ea217d704b" translate="yes" xml:space="preserve">
          <source>Here is an example of the Slug header that uses percent-encoding to
   represent the Unicode character U+00E8 (LATIN SMALL LETTER E WITH
   GRAVE):

       POST /myblog/entries HTTP/1.1
       Host: example.org
       Content-Type: image/png
       Slug: The Beach at S%C3%A8te
       Authorization: Basic ZGFmZnk6c2VjZXJldA==
       Content-Length: nnn

       ...binary data

   See &lt;a href=&quot;#section-9.2.1&quot;&gt;Section 9.2.1&lt;/a&gt; for an example of the Slug header applied to the
   creation of an Entry Resource.</source>
          <target state="translated">다음은 퍼센트 인코딩을 사용하여 유니 코드 문자 U + 00E8 (LATIN SMALL LETTER E WITH GRAVE)을 나타내는 Slug 헤더의 예입니다. POST / myblog / entries HTTP / 1.1 호스트 : example.org Content-Type : image / png 슬러그 : S % C3 % A8te의 해변 인증 : 기본 ZGFmZnk6c2VjZXJldA == 내용 길이 : nnn ... 바이너리 데이터 엔트리 리소스 생성에 적용된 슬러그 헤더의 예는 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1 절을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2797fafb9211cc2c051dcda055704a3e4e30b8b0" translate="yes" xml:space="preserve">
          <source>Here is an example of this process with a shared cache proxy:</source>
          <target state="translated">공유 캐시 프록시를 사용한이 프로세스의 예는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="translated">예를 들면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="ef5dd834bb2835bdbfb70e682c19ccc9767516af" translate="yes" xml:space="preserve">
          <source>Here is some PHP that handles credentialed requests:</source>
          <target state="translated">자격 증명 요청을 처리하는 일부 PHP는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="8ef8c73e17b07ff09f65fb9ccc55b532e81935c5" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">여기에서는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 헤더 의 가장 일반적인 사용 사례를 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="a21888f07518ae7a0759573f20d4642440f36a52" translate="yes" xml:space="preserve">
          <source>Here we look at the most common use cases for the &lt;code&gt;Upgrade&lt;/code&gt; header.</source>
          <target state="translated">여기서는 &lt;code&gt;Upgrade&lt;/code&gt; 헤더 의 가장 일반적인 사용 사례를 살펴 봅니다 .</target>
        </trans-unit>
        <trans-unit id="9ab6627dc7da6cad243b3faca054a977b46dce0f" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server (in addition to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS-safelisted request headers&lt;/a&gt;).</source>
          <target state="translated">다음은 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더의 예입니다. &lt;code&gt;X-Custom-Header&lt;/code&gt; 라는 사용자 지정 헤더 가 서버에 대한 CORS 요청에서 지원됨을 나타냅니다 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/CORS-safelisted_request_header&quot;&gt;CORS 허용 목록에있는 요청 헤더&lt;/a&gt; 외에도 ).</target>
        </trans-unit>
        <trans-unit id="f377abe687f3f604805ed4c41cf044b1a5eecca7" translate="yes" xml:space="preserve">
          <source>Here's an example of what an &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; header might look like. It indicates that in addition to the &quot;simple&quot; headers, a custom header named &lt;code&gt;X-Custom-Header&lt;/code&gt; is supported by CORS requests to the server.</source>
          <target state="translated">다음은 &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; 헤더의 예입니다. &quot;단순&quot;헤더 외에도 서버에 대한 CORS 요청에서 &lt;code&gt;X-Custom-Header&lt;/code&gt; 라는 사용자 정의 헤더 가 지원됨을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="29ece426131fe65594c0f74862a88481dffe1b6d" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is the authentication scheme (&quot;Basic&quot; is the most common scheme and &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;introduced below&lt;/a&gt;). The &lt;em&gt;realm&lt;/em&gt; is used to describe the protected area or to indicate the scope of protection. This could be a message like &quot;Access to the staging site&quot; or similar, so that the user knows to which space they are trying to get access to.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; 은 인증 체계입니다 ( &quot;기본&quot;이 가장 일반적인 체계이며 &lt;a href=&quot;authentication#Basic_authentication_scheme&quot;&gt;아래에 소개됨&lt;/a&gt; ). &lt;em&gt;영역은&lt;/em&gt; 보호 지역을 설명하기 위해 또는 보호의 범위를 표시하는 데 사용됩니다. &quot;스테이징 사이트에 액세스&quot;또는 이와 유사한 메시지 일 수 있으므로 사용자는 액세스하려는 공간을 사용자가 알 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb29f0c2d2f88776ddd04a11566426842fc746ff" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;base64EncodedSettings&lt;/code&gt; is an HTTP/2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; frame's payload which has been base64url encoded and all trailing &lt;code&gt;&quot;=&quot;&lt;/code&gt; (equals) characters removed in order to safely include it in this textual header format.</source>
          <target state="translated">여기서 &lt;code&gt;base64EncodedSettings&lt;/code&gt; 는 base64url로 인코딩 된 HTTP / 2 &lt;code&gt;&quot;SETTINGS&quot;&lt;/code&gt; 프레임의 페이로드이며이 텍스트 헤더 형식에 안전하게 포함시키기 위해 모든 후행 &lt;code&gt;&quot;=&quot;&lt;/code&gt; (같음) 문자가 제거되었습니다.</target>
        </trans-unit>
        <trans-unit id="a17f358e1ad5338444563c68bbadc2878e955302" translate="yes" xml:space="preserve">
          <source>Here, &lt;em&gt;x.y&lt;/em&gt; is the version of Mac OS X (for instance, Mac OS X 10.6).</source>
          <target state="translated">여기서 &lt;em&gt;xy&lt;/em&gt; 는 Mac OS X의 버전입니다 (예 : Mac OS X 10.6).</target>
        </trans-unit>
        <trans-unit id="ef77ad6909e7752d9aa6373842d49849209611c6" translate="yes" xml:space="preserve">
          <source>Here, by default, content is only permitted from the document's origin, with the following exceptions:</source>
          <target state="translated">여기서 기본적으로 컨텐츠는 다음을 제외하고 문서의 출처에서만 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="fa2977eeb67774d5a0dd09ff4ec5ec0a36ef8155" translate="yes" xml:space="preserve">
          <source>Here, we present three scenarios that illustrate how Cross-Origin Resource Sharing works. All of these examples use the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; object, which can be used to make cross-site invocations in any supporting browser.</source>
          <target state="translated">여기에서는 Cross-Origin Resource Sharing의 작동 방식을 설명하는 세 가지 시나리오를 제시합니다. 이 모든 예제는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 객체를 사용하는데, 이는 지원되는 모든 브라우저에서 사이트 간 호출을 수행하는 데 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b282bf1d7028f07f3c3e1a14dbfcb71697111c5d" translate="yes" xml:space="preserve">
          <source>Heroku's proxy library Vegur</source>
          <target state="translated">헤 로쿠의 프록시 라이브러리 Vegur</target>
        </trans-unit>
        <trans-unit id="ddf9efd09112f93ec00fa54e8c4c84c765c17139" translate="yes" xml:space="preserve">
          <source>Heuristic Expiration</source>
          <target state="translated">휴리스틱 만료</target>
        </trans-unit>
        <trans-unit id="f2bddb211b435d77bdcd54be12a624bcbd764aed" translate="yes" xml:space="preserve">
          <source>Heuristic freshness checking</source>
          <target state="translated">휴리스틱 신선도 검사</target>
        </trans-unit>
        <trans-unit id="1724e0bfe29683a06f3fb0d140956360664db86b" translate="yes" xml:space="preserve">
          <source>Historic specification of HTTP State Management Mechanism, obsoleted by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; 에서 폐기 된 HTTP 상태 관리 메커니즘의 역사적인 사양</target>
        </trans-unit>
        <trans-unit id="d2fc15fa26334cc66ab95bf51b30e486fe93e127" translate="yes" xml:space="preserve">
          <source>History Lists (RFC 7234)</source>
          <target state="translated">히스토리 목록 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="2b89425faff6de6dc314db782d45b8bad9965067" translate="yes" xml:space="preserve">
          <source>History and implementation</source>
          <target state="translated">역사와 실행</target>
        </trans-unit>
        <trans-unit id="8224b406bb9fcf1d12ea7ebecf7258a153c52d79" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression</source>
          <target state="translated">홉별 압축</target>
        </trans-unit>
        <trans-unit id="77f5c2d41f116e38295977a86465e5e9e801702a" translate="yes" xml:space="preserve">
          <source>Hop-by-hop compression, though similar to end-to-end compression, differs by one fundamental element: the compression doesn't happen on the resource in the server, creating a specific representation that is then transmitted, but on the body of the message between any two nodes on the path between the client and the server. Connections between successive intermediate nodes may apply a &lt;em&gt;different&lt;/em&gt; compression.</source>
          <target state="translated">홉별 압축은 엔드-투-엔드 압축과 유사하지만 하나의 기본 요소가 다릅니다. 압축은 서버의 리소스에서 발생하지 않고 전송 된 다음 특정 표현을 생성하지만 본문에는 클라이언트와 서버 사이의 경로에있는 두 노드 사이의 메시지 연속적인 중간 노드 사이의 연결은 &lt;em&gt;다른&lt;/em&gt; 압축을 적용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="78458c6f2f912b6d6875b5a660931222e51353f1" translate="yes" xml:space="preserve">
          <source>Hop-by-hop headers</source>
          <target state="translated">홉별 헤더</target>
        </trans-unit>
        <trans-unit id="3960ec4ca5fb5e5d8cdb2cc1c5121c003e426517" translate="yes" xml:space="preserve">
          <source>Host</source>
          <target state="translated">Host</target>
        </trans-unit>
        <trans-unit id="f3680c389a985b1c29ff7e674003c4ba66aee02b" translate="yes" xml:space="preserve">
          <source>Host (RFC 2616)</source>
          <target state="translated">호스트 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5406f06c65b376c58dac6bf71408ae1944750e32" translate="yes" xml:space="preserve">
          <source>Host names and ports of reverse proxies (load balancers, CDNs) may differ from the origin server handling the request, in that case the &lt;code&gt;X-Forwarded-Host&lt;/code&gt; header is useful to determine which Host was originally used.</source>
          <target state="translated">리버스 프록시 (로드 밸런서, CDN)의 호스트 이름 및 포트는 요청을 처리하는 원본 서버와 다를 수 있습니다.이 경우 &lt;code&gt;X-Forwarded-Host&lt;/code&gt; 헤더는 원래 사용 된 호스트를 확인하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f4b4c2643126c467ddef65e6b67d5f8c8b5bdc1a" translate="yes" xml:space="preserve">
          <source>Host to which the cookie will be sent.</source>
          <target state="translated">쿠키가 전송 될 호스트입니다.</target>
        </trans-unit>
        <trans-unit id="34a6082579e4930c27da3887804287a2a53f1624" translate="yes" xml:space="preserve">
          <source>Host-specific file names</source>
          <target state="translated">호스트 별 파일 이름</target>
        </trans-unit>
        <trans-unit id="2ec76d41d987ae559f5e3a7f7fd514508f4dcf54" translate="yes" xml:space="preserve">
          <source>Hosted CSP reporting for HTTPS migrations</source>
          <target state="translated">HTTPS 마이그레이션을위한 호스팅 된 CSP보고</target>
        </trans-unit>
        <trans-unit id="1367a4331a65542cf39c8a9d5b8961997d49502b" translate="yes" xml:space="preserve">
          <source>Hostname based conditions</source>
          <target state="translated">호스트 이름 기반 조건</target>
        </trans-unit>
        <trans-unit id="39e32117a3b52cca1d492b875f026756fb25597f" translate="yes" xml:space="preserve">
          <source>How Browsers Work</source>
          <target state="translated">브라우저 작동 방식</target>
        </trans-unit>
        <trans-unit id="4c91ae122f1612df59f2a23941f9e79f1d970ecc" translate="yes" xml:space="preserve">
          <source>How cookies work is defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;. When serving an HTTP request, a server can send a &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP header with the response. The client then returns the cookie's value with every request to the same server in the form of a &lt;code&gt;Cookie&lt;/code&gt; request header. The cookie can also be set to expire on a certain date, or restricted to a specific domain and path.</source>
          <target state="translated">쿠키 작동 방식은 &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265에&lt;/a&gt; 의해 정의됩니다 . HTTP 요청을 처리 할 때 서버는 응답과 함께 &lt;code&gt;Set-Cookie&lt;/code&gt; HTTP 헤더를 보낼 수 있습니다 . 그런 다음 클라이언트는 모든 요청과 함께 쿠키 요청 값을 &lt;code&gt;Cookie&lt;/code&gt; 요청 헤더 형식으로 동일한 서버에 반환합니다 . 쿠키는 특정 날짜에 만료되거나 특정 도메인 및 경로로 제한되도록 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="326d6840506a3e0e685440ecd35aff457aa45373" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies and clients, about what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">문서가 캐시되는 방식은 HTTP로 제어 할 수 있습니다. 서버는 프록시와 클라이언트에게 캐시 할 항목과 기간에 대해 지시 할 수 있습니다. 클라이언트는 저장된 문서를 무시하도록 중간 캐시 프록시에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="785a4091642b3107a87eb0510aa18c744ad3bd77" translate="yes" xml:space="preserve">
          <source>How documents are cached can be controlled by HTTP. The server can instruct proxies, and clients, what to cache and for how long. The client can instruct intermediate cache proxies to ignore the stored document.</source>
          <target state="translated">HTTP가 문서를 캐시하는 방법을 제어 할 수 있습니다. 서버는 프록시 및 클라이언트, 캐시 대상 및 기간을 지시 할 수 있습니다. 클라이언트는 저장된 캐시 문서를 무시하도록 중간 캐시 프록시에 지시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a92fcc6dda054aa8ba041f16e995c47ecf3e087" translate="yes" xml:space="preserve">
          <source>How much detail to include is an interesting balance to strike; exposing the OS version is probably a bad idea, as mentioned in the earlier warning about overly-detailed values. However, exposed Apache versions helped browsers work around a bug those versions had with &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt; combined with &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">포함해야 할 세부 사항은 흥미로운 균형입니다. 지나치게 상세한 값에 대한 이전 경고에서 언급했듯이 OS 버전을 노출하는 것은 아마도 나쁜 생각 일 것입니다. 그러나 노출 된 Apache 버전은 해당 버전이 &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; 과 &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; 를&lt;/a&gt; 결합한 버그를 해결하는 데 도움이되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f1a6840353bc46a78f9536e0c4ba600c96425f56" translate="yes" xml:space="preserve">
          <source>How the browser handles it</source>
          <target state="translated">브라우저가 처리하는 방법</target>
        </trans-unit>
        <trans-unit id="68bee7ceae58ef9dd68bebd7e8624e01362fe458" translate="yes" xml:space="preserve">
          <source>How to Fix 405 Method Not Allowed</source>
          <target state="translated">405 방법이 허용되지 않는 문제를 해결하는 방법</target>
        </trans-unit>
        <trans-unit id="d2bbcaa9a058613fa1a50456a0aabfa3b3df0140" translate="yes" xml:space="preserve">
          <source>How to avoid the CORS preflight</source>
          <target state="translated">CORS 프리 플라이트를 피하는 방법</target>
        </trans-unit>
        <trans-unit id="778498eaac84dd627c8fe8e2869a7fc961933c44" translate="yes" xml:space="preserve">
          <source>How to fix &lt;em&gt;&amp;ldquo;Access-Control-Allow-Origin header must not be the wildcard&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">&lt;em&gt;&quot;Access-Control-Allow-Origin 헤더는 와일드 카드가 아니어야합니다&quot;&lt;/em&gt; 를 수정하는 방법&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="cc108c55cd0ff984c9ac45ce8cdb74f88f1a0654" translate="yes" xml:space="preserve">
          <source>How to fix CORS issue?</source>
          <target state="translated">CORS 문제를 해결하는 방법?</target>
        </trans-unit>
        <trans-unit id="c305fbaf8d1dd662dd884c22cf15416371345003" translate="yes" xml:space="preserve">
          <source>How to run Chrome browser without CORS</source>
          <target state="translated">CORS없이 Chrome 브라우저를 실행하는 방법</target>
        </trans-unit>
        <trans-unit id="bd427ecf132d3e2cc23ee42d32690dc605d28a0f" translate="yes" xml:space="preserve">
          <source>How to use a CORS proxy to get around &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;&lt;/em&gt;</source>
          <target state="translated">CORS 프록시를 사용하여 &lt;em&gt;&amp;ldquo;No Access-Control-Allow-Origin header&amp;rdquo;를 해결하는 방법&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="7f79e53c0a139eb96378c7ba89f9dd8fbfb330c0" translate="yes" xml:space="preserve">
          <source>However, if the request is one that triggers a preflight due to the presence of the &lt;code&gt;Authorization&lt;/code&gt; header in the request, you won&amp;rsquo;t be able to work around the limitation using the steps above. And you won&amp;rsquo;t be able to work around it at all unless you have control over the server the request is being made to.</source>
          <target state="translated">요청으로 인해의 존재에 프리 플라이트를 유발 하나 인 경우, &lt;code&gt;Authorization&lt;/code&gt; 요청의 헤더, 당신은 위의 단계를 사용하여 제한을 해결할 수 없습니다. 요청이 수행되는 서버를 제어 할 수 없으면 해결이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="aa3bacea776742f9f4ee0b04c2738bf1f2acd22e" translate="yes" xml:space="preserve">
          <source>However, scripts without integrity won't load anymore:</source>
          <target state="translated">그러나 무결성이없는 스크립트는 더 이상로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="4784e9a56ee26ccc58e9b47e0384d44d80f5b536" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via JavaScript:</source>
          <target state="translated">그러나 요소의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt; 속성 에 직접 설정된 스타일 속성은 차단되지 않으므로 사용자가 JavaScript를 통해 스타일을 안전하게 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6363c2d9cd37774dbf6ea52a71d3cc4b1d69edf1" translate="yes" xml:space="preserve">
          <source>However, styles properties that are set directly on the element's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt;&lt;code&gt;style&lt;/code&gt;&lt;/a&gt; property will not be blocked, allowing users to safely manipulate styles via Javascript:</source>
          <target state="translated">그러나 요소의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style&quot;&gt; &lt;code&gt;style&lt;/code&gt; &lt;/a&gt; 속성 에 직접 설정된 스타일 속성은 차단되지 않으므로 사용자는 Javascript를 통해 스타일을 안전하게 조작 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="712efc901d5948d1ddc85420dd7828b2c028e889" translate="yes" xml:space="preserve">
          <source>However, the above code is absolutely terrible and ill-conceived. What if Chrome removes this look behind feature? What if another browser implements look behind regexps? What if another browser uses &lt;em&gt;Chrome &lt;/em&gt;in their user agent string? The list goes on and on of things that could go terribly wrong. Thus, you should instead use feature detection like the following.</source>
          <target state="translated">그러나 위의 코드는 절대적으로 끔찍하고 잘못 고안되었습니다. Chrome에서이 숨김 기능을 제거하면 어떻게 되나요? 다른 브라우저가 정규 표현식 뒤에 보이는 것을 구현하면 어떻게 되나요? 다른 브라우저가 사용자 에이전트 문자열에서 &lt;em&gt;Chrome&lt;/em&gt; 을 사용하면 어떻게 되나요? 그 목록은 계속 잘못 될 수있는 것들에 관한 것입니다. 따라서 대신 다음과 같은 기능 감지를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="3e339ee7e7a8e7da017468304e92dc515e180b71" translate="yes" xml:space="preserve">
          <source>However, this won't wildcard the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header, so if you need to expose that, you will need to list it explicitly:</source>
          <target state="translated">그러나 이는 &lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 헤더를 와일드 카드로 처리하지 않으므로 노출해야하는 경우 명시 적으로 나열해야합니다.</target>
        </trans-unit>
        <trans-unit id="872b5517c0f6559afa3677ba893bb97024b2ecc2" translate="yes" xml:space="preserve">
          <source>HttpOnly Optional</source>
          <target state="translated">HttpOnly 옵션</target>
        </trans-unit>
        <trans-unit id="abd954b086bab88cb87ec4cda040e14953ecce8f" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0)</source>
          <target state="translated">하이퍼 텍스트 커피 포트 제어 프로토콜 (HTCPCP / 1.0)</target>
        </trans-unit>
        <trans-unit id="9cb22c4629a969af0720c560a54790780d479542" translate="yes" xml:space="preserve">
          <source>Hyper Text Coffee Pot Control Protocol (HTCPCP/1.0): Semantics and Content</source>
          <target state="translated">하이퍼 텍스트 커피 포트 제어 프로토콜 (HTCPCP / 1.0) : 의미 및 내용</target>
        </trans-unit>
        <trans-unit id="126116b4ff4ad54a45b5f2a945491694cc39450d" translate="yes" xml:space="preserve">
          <source>Hyper text transfer protocol (Secure)</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (보안)</target>
        </trans-unit>
        <trans-unit id="a40ca5dd3664e7e5fbc9868906e198fe122b47b2" translate="yes" xml:space="preserve">
          <source>HyperText Markup Language (HTML)</source>
          <target state="translated">하이퍼 텍스트 마크 업 언어 (HTML)</target>
        </trans-unit>
        <trans-unit id="3aabdc98f3e181618def85f1876081249a0e4138" translate="yes" xml:space="preserve">
          <source>HyperText Transport Protocol Keep-Alive Header</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 연결 유지 헤더</target>
        </trans-unit>
        <trans-unit id="caec6dcaeb81aa6d4af95da6ddc9afca1f3451f8" translate="yes" xml:space="preserve">
          <source>Hypertext Preprocessor (&lt;strong&gt;Personal Home Page&lt;/strong&gt;)</source>
          <target state="translated">하이퍼 텍스트 전 처리기 ( &lt;strong&gt;개인 홈 페이지&lt;/strong&gt; )</target>
        </trans-unit>
        <trans-unit id="a8bf740d859a72ca5b146b5d3c7c57e9e44dbdab" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) Keep-Alive Header</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol) 연결 헤더</target>
        </trans-unit>
        <trans-unit id="18c750541be3062c47621490bab7ee6a43ed0176" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP) clients often encounter
   interrupted data transfers as a result of canceled requests or
   dropped connections.  When a client has stored a partial
   representation, it is desirable to request the remainder of that
   representation in a subsequent request rather than transfer the
   entire representation.  Likewise, devices with limited local storage
   might benefit from being able to request only a subset of a larger
   representation, such as a single page of a very large document, or
   the dimensions of an embedded image.

   This document defines HTTP/1.1 range requests, partial responses, and
   the multipart/byteranges media type.  Range requests are an OPTIONAL
   feature of HTTP, designed so that recipients not implementing this
   feature (or not supporting it for the target resource) can respond as
   if it is a normal GET request without impacting interoperability.
   Partial responses are indicated by a distinct status code to not be
   mistaken for full responses by caches that might not implement the
   feature.

   Although the range request mechanism is designed to allow for
   extensible range types, this specification only defines requests for
   byte ranges.</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol) 클라이언트는 요청이 취소되거나 연결이 끊어져 데이터 전송이 중단되는 경우가 종종 있습니다. 클라이언트가 부분 표현을 저장 한 경우 전체 표현을 전송하는 대신 후속 요청에서 해당 표현의 나머지를 요청하는 것이 바람직합니다. 마찬가지로 로컬 저장소가 제한된 장치는 매우 큰 문서의 단일 페이지 또는 포함 된 이미지의 크기와 같이 더 큰 표현의 하위 집합 만 요청할 수 있다는 이점이 있습니다. 이 문서는 HTTP / 1.1 범위 요청, 부분 응답 및 multipart / byteranges 미디어 유형을 정의합니다. 범위 요청은 HTTP의 선택적 기능입니다.이 기능을 구현하지 않거나 대상 자원에 대해 지원하지 않는 수신자는 상호 운용성에 영향을주지 않으면 서 정상적인 GET 요청 인 것처럼 응답 할 수 있도록 설계되었습니다. 기능을 구현하지 않을 수있는 캐시에 의한 전체 응답으로 착각하지 않도록 부분 응답은 고유 한 상태 코드로 표시됩니다. 범위 요청 메커니즘은 확장 가능한 범위 유형을 허용하도록 설계되었지만이 사양에서는 바이트 범위에 대한 요청 만 정의합니다.이 사양은 바이트 범위에 대한 요청 만 정의합니다.이 사양은 바이트 범위에 대한 요청 만 정의합니다.</target>
        </trans-unit>
        <trans-unit id="eaebf91177666f1aaca9207bce21f241c2d6aa1c" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Authentication</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증</target>
        </trans-unit>
        <trans-unit id="cf04e8c69e3ace21820abada8b4f0bf8440a50a6" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱</target>
        </trans-unit>
        <trans-unit id="565eb02fb9f4c2b506e298c3e3bd17146e8b9b29" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Conditional Requests</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청</target>
        </trans-unit>
        <trans-unit id="5ffac3f427873675e5fda46ed9caffb674838583" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅</target>
        </trans-unit>
        <trans-unit id="067dc1d00ea2a2c2813ac9db731d6b354882d326" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Range Requests</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청</target>
        </trans-unit>
        <trans-unit id="67726549543e0d1b42d751ebf670ca915f452bde" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 시맨틱 및 컨텐츠</target>
        </trans-unit>
        <trans-unit id="dadde9e82bc152463510002167edd8589458e39b" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Context</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 컨텍스트</target>
        </trans-unit>
        <trans-unit id="0464d55671763178e4bb9bf689fd75c3b2bf90ee" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol -- HTTP/1.1</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜-HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="14001adc995acbe66bc7906c7030f074a23e21ec" translate="yes" xml:space="preserve">
          <source>Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">하이퍼 텍스트 전송 프로토콜 버전 2 (HTTP / 2)</target>
        </trans-unit>
        <trans-unit id="e0899b85bb34ecad597f88ef93fbf5180bd78fc6" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7230)</source>
          <target state="translated">IANA 고려 사항 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="fb05bb988d2b3042dacb51c3209a976e89fd65b7" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7231)</source>
          <target state="translated">IANA 고려 사항 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="faddb1a82ba7e7645aff6b957bbe064fd752dd69" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7232)</source>
          <target state="translated">IANA 고려 사항 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="4cbf2a520cf53d1cedf62323be093a069cfdcece" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7233)</source>
          <target state="translated">IANA 고려 사항 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="2ce28868e82be3265aeb20b44d3fbb587c2a23ce" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7234)</source>
          <target state="translated">IANA 고려 사항 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="98a74c9cf29e82d02e581eb12c22dda292d5ee17" translate="yes" xml:space="preserve">
          <source>IANA Considerations (RFC 7235)</source>
          <target state="translated">IANA 고려 사항 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="4bb8022eff5067ab10c4c96ad85499b49bef742d" translate="yes" xml:space="preserve">
          <source>IANA HTTP Range Unit Registry</source>
          <target state="translated">IANA HTTP 범위 단위 레지스트리</target>
        </trans-unit>
        <trans-unit id="5904c4ee52524bdc80934ad4f9a7950c63e23ee8" translate="yes" xml:space="preserve">
          <source>IANA has added a reference to this specification in the
   'application/atom+xml' media type registration.</source>
          <target state="translated">IANA는 'application / atom + xml'미디어 유형 등록에서이 사양에 대한 참조를 추가했습니다.</target>
        </trans-unit>
        <trans-unit id="69ea11543f5de3dd2cb43742c8f141e34bd0847d" translate="yes" xml:space="preserve">
          <source>IANA is the official registry of MIME media types and maintains a &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;list of all the official MIME types&lt;/a&gt;. This table lists some important MIME types for the Web:</source>
          <target state="translated">IANA는 MIME 미디어 유형의 공식 레지스트리 &lt;a href=&quot;http://www.iana.org/assignments/media-types/media-types.xhtml&quot;&gt;이며 모든 공식 MIME 유형 목록을&lt;/a&gt; 유지 관리합니다 . 이 표에는 웹에 대한 몇 가지 중요한 MIME 유형이 나와 있습니다.</target>
        </trans-unit>
        <trans-unit id="89c07cdbd61e19ece57d06075ba79aecfe00c78b" translate="yes" xml:space="preserve">
          <source>IANA list of URI schemes</source>
          <target state="translated">URI 스킴의 IANA 목록</target>
        </trans-unit>
        <trans-unit id="78740b079f8a9346faaa07edbf050f52dc47fc13" translate="yes" xml:space="preserve">
          <source>IANA maintains the &quot;HTTP Content Coding Registry&quot; at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt;&amp;gt;.

   The &quot;HTTP Content Coding Registry&quot; has been updated with the
   registrations below:

   +------------+--------------------------------------+---------------+
   | Name       | Description                          | Reference     |
   +------------+--------------------------------------+---------------+
   | compress   | UNIX &quot;compress&quot; data format [&lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt;]  | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | deflate    | &quot;deflate&quot; compressed data            | &lt;a href=&quot;#section-4.2.2&quot;&gt;Section 4.2.2&lt;/a&gt; |
   |            | ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt;]) inside the &quot;zlib&quot; data   |               |
   |            | format ([&lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;])                   |               |
   | gzip       | GZIP file format [&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt;]           | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   | x-compress | Deprecated (alias for compress)      | &lt;a href=&quot;#section-4.2.1&quot;&gt;Section 4.2.1&lt;/a&gt; |
   | x-gzip     | Deprecated (alias for gzip)          | &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt; |
   +------------+--------------------------------------+---------------+</source>
          <target state="translated">IANA는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/http-parameters&quot;&gt;http://www.iana.org/assignments/http-parameters&lt;/a&gt; &amp;gt; 에서 &quot;HTTP 콘텐츠 코딩 레지스트리&quot;를 유지 관리합니다 . &quot;HTTP 컨텐츠 코딩 레지스트리&quot;가 아래 등록으로 업데이트되었습니다 : + ------------ + --------------------- ----------------- + --------------- + | 이름 | 설명 | 참조 | + ------------ + ------------------------------------ -+ --------------- + | 압축 | UNIX &quot;압축&quot;데이터 형식 [ &lt;a href=&quot;#ref-Welch&quot;&gt;Welch&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | 수축하다 | 압축 된 데이터 &quot;delate&quot;| &lt;a href=&quot;#section-4.2.2&quot;&gt;섹션 4.2.2&lt;/a&gt; | | | &quot;zlib&quot;데이터 내부의 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC1951&lt;/a&gt; ]) | | | | 형식 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC1950&lt;/a&gt;]) | | | gzip | GZIP 파일 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC1952&lt;/a&gt; ] | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | | x- 압축 | 더 이상 사용되지 않음 (압축 별명) | &lt;a href=&quot;#section-4.2.1&quot;&gt;섹션 4.2.1&lt;/a&gt; | | x-gzip | 더 이상 사용되지 않음 (gzip의 별명) | &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; | + ------------ + ------------------------------------ -+ --------------- +</target>
        </trans-unit>
        <trans-unit id="2f3aef98e61cefd59e70d51a0d54a7f7880c7e4d" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media
   types &quot;message/http&quot; and &quot;application/http&quot;.  The following has been
   registered with IANA.</source>
          <target state="translated">IANA 는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt; 에서 인터넷 미디어 유형 [ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 의 레지스트리를 유지 관리합니다 . 이 문서는 인터넷 메시지 유형 &quot;message / http&quot;및 &quot;application / http&quot;의 사양으로 사용됩니다. 다음은 IANA에 등록되었습니다.</target>
        </trans-unit>
        <trans-unit id="57560e1f2062a0d9e41b59e9de0cd89dfc775402" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of Internet media types [&lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt;&amp;gt;.

   This document serves as the specification for the Internet media type
   &quot;multipart/byteranges&quot;.  The following has been registered with IANA.</source>
          <target state="translated">IANA 는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/media-types&quot;&gt;http://www.iana.org/assignments/media-types&lt;/a&gt; &amp;gt; 에서 인터넷 미디어 유형 [ &lt;a href=&quot;#ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] 의 레지스트리를 유지 관리합니다 . 이 문서는 인터넷 미디어 유형 &quot;multipart / byteranges&quot;의 사양으로 사용됩니다. 다음은 IANA에 등록되었습니다.</target>
        </trans-unit>
        <trans-unit id="2f25bf5a2ef40ce000fcbfb953c618138d7e6d92" translate="yes" xml:space="preserve">
          <source>IANA maintains the registry of URI Schemes [&lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt;] at
   &amp;lt;&lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt;&amp;gt;.

   This document defines the following URI schemes, so the &quot;Permanent
   URI Schemes&quot; registry has been updated accordingly.

   +------------+------------------------------------+---------------+
   | URI Scheme | Description                        | Reference     |
   +------------+------------------------------------+---------------+
   | http       | Hypertext Transfer Protocol        | &lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt; |
   | https      | Hypertext Transfer Protocol Secure | &lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt; |
   +------------+------------------------------------+---------------+</source>
          <target state="translated">IANA 는 &amp;lt; &lt;a href=&quot;http://www.iana.org/assignments/uri-schemes/&quot;&gt;http://www.iana.org/assignments/uri-schemes/&lt;/a&gt; &amp;gt; 에서 URI 체계 [ &lt;a href=&quot;#ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] 의 레지스트리를 유지 관리합니다 . 이 문서는 다음과 같은 URI 체계를 정의하므로 &quot;영구적 URI 체계&quot;레지스트리가 그에 따라 업데이트되었습니다. + ------------ + ------------------------------------ + --------------- + | URI 체계 | 설명 | 참조 | + ------------ + ------------------------------------ + --------------- + | http | 하이퍼 텍스트 전송 프로토콜 | &lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; | | https | 하이퍼 텍스트 전송 프로토콜 보안 | &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt; | + ------------ + ------------------------------------ + --------------- +</target>
        </trans-unit>
        <trans-unit id="70d5ce962c5520d83534599071460204e3f79a4c" translate="yes" xml:space="preserve">
          <source>IANA official registry of HTTP status codes</source>
          <target state="translated">HTTP 상태 코드의 IANA 공식 레지스트리</target>
        </trans-unit>
        <trans-unit id="052ea052e8c19248acaf0e57ba16070d89e5f3f2" translate="yes" xml:space="preserve">
          <source>IANA registry</source>
          <target state="translated">IANA 레지스트리</target>
        </trans-unit>
        <trans-unit id="3ec2a8d54523fcf678717117536e9db1ddb9d0ec" translate="yes" xml:space="preserve">
          <source>IANA registry of Authentication schemes</source>
          <target state="translated">인증 체계의 IANA 레지스트리</target>
        </trans-unit>
        <trans-unit id="433dbaf6332943984d6516e68b5f7fa26960c972" translate="yes" xml:space="preserve">
          <source>ICO</source>
          <target state="translated">ICO</target>
        </trans-unit>
        <trans-unit id="1c424db78d6168d4e4112d7ef44078d6e5cc90ef" translate="yes" xml:space="preserve">
          <source>IETF Draft</source>
          <target state="translated">IETF 초안</target>
        </trans-unit>
        <trans-unit id="8017c92650b8189e940d94d4098c59d4b86b1c4b" translate="yes" xml:space="preserve">
          <source>IETF RFC</source>
          <target state="translated">IETF RFC</target>
        </trans-unit>
        <trans-unit id="8571cc2c4258545210a5b00473280039ad4b84d4" translate="yes" xml:space="preserve">
          <source>IIS</source>
          <target state="translated">IIS</target>
        </trans-unit>
        <trans-unit id="863b6ddbf8a4aa095ca888b978a73ba1efc7811f" translate="yes" xml:space="preserve">
          <source>Icon format</source>
          <target state="translated">아이콘 형식</target>
        </trans-unit>
        <trans-unit id="ca9f65841299353702f59413c67b4d41e934a6e4" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for each resource. But there are reasons for alternative names for a resource:</source>
          <target state="translated">이상적으로는 각 리소스에 대해 하나의 위치, 즉 하나의 URL이 있습니다. 그러나 리소스에 대한 대체 이름에 대한 이유가 있습니다.</target>
        </trans-unit>
        <trans-unit id="3dc4507a76928b989abe5a6100c9511b38bd00d7" translate="yes" xml:space="preserve">
          <source>Ideally, there is one location, and therefore one URL, for one resource. But there are reasons for wanting to have alternative names for a resource (several domains, like with and without the www prefix or shorter and easy to remember URLs, &amp;hellip;). In these cases, rather than duplicating the resource, it is useful to use a redirect to the one true (canonical) URL.</source>
          <target state="translated">이상적으로는 하나의 자원에 대해 하나의 위치와 하나의 URL이 있습니다. 그러나 다른 리소스 이름 (www 접두어가 있거나없는 여러 도메인, URL이 짧고 기억하기 쉬운 URL 등)을 원하는 이유가 있습니다. 이 경우 리소스를 복제하지 않고 하나의 실제 (정규) URL로 리디렉션하는 것이 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f1df7d15a8112ad87203fcb0cb507f4b96b72bbd" translate="yes" xml:space="preserve">
          <source>Idempotent</source>
          <target state="translated">Idempotent</target>
        </trans-unit>
        <trans-unit id="b6a2413ad63489a62e13c1cef9ff703c77e3aa0f" translate="yes" xml:space="preserve">
          <source>Idempotent Methods (RFC 7231)</source>
          <target state="translated">dem 등식 방법 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="526430255f19421715307947f2ff84df60c93896" translate="yes" xml:space="preserve">
          <source>Identifies the original host requested that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">클라이언트가 프록시 또는로드 밸런서에 연결하는 데 요청한 원래 호스트를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="b108c524c313085aeda694b0f180ecea370efb15" translate="yes" xml:space="preserve">
          <source>Identifies the originating IP addresses of a client connecting to a web server through an HTTP proxy or a load balancer.</source>
          <target state="translated">HTTP 프록시 또는로드 밸런서를 통해 웹 서버에 연결하는 클라이언트의 원래 IP 주소를 식별합니다.</target>
        </trans-unit>
        <trans-unit id="4728d359ae99afe818be6f9dc7667972f09461f4" translate="yes" xml:space="preserve">
          <source>Identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">클라이언트가 프록시 또는로드 밸런서에 연결하는 데 사용한 프로토콜 (HTTP 또는 HTTPS)을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="b059dd235df4bbca4880938a5c1bb58a2acfaacc" translate="yes" xml:space="preserve">
          <source>Identifying allowed request methods</source>
          <target state="translated">허용 된 요청 방법 식별</target>
        </trans-unit>
        <trans-unit id="a11a4c57a7f8dccbb14cb41b82dc14540c9e4cbe" translate="yes" xml:space="preserve">
          <source>Identifying resources on the Web</source>
          <target state="translated">웹에서 자원 식별</target>
        </trans-unit>
        <trans-unit id="2ddba376a063bd16e86e27e7bafe3713c58a5850" translate="yes" xml:space="preserve">
          <source>Identifying the issue</source>
          <target state="translated">문제 식별</target>
        </trans-unit>
        <trans-unit id="5411f86a7d04f9bc55dfc770d7c059832dab58c1" translate="yes" xml:space="preserve">
          <source>If &lt;a href=&quot;../status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Also) responses always lead to the use of a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; method, &lt;a href=&quot;../status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; (Temporary Redirect) and &lt;a href=&quot;../status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; (Permanent Redirect) don't change the method used in the original request;</source>
          <target state="translated">경우 &lt;a href=&quot;../status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (참조) 응답이 항상 사용으로 이어질 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 의&lt;/a&gt; 방법, &lt;a href=&quot;../status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; (임시 리디렉션) 및 &lt;a href=&quot;../status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; (영구 리디렉션) 원래 요청에 사용되는 방법을 변경하지 마십시오;</target>
        </trans-unit>
        <trans-unit id="203f83a39c006e96b0372879695a48c384f5a98d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Viewport-Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences.</source>
          <target state="translated">경우 &lt;code&gt;Viewport-Width&lt;/code&gt; 한 번 이상 메시지가 발생, 마지막 값은 이전의 모든 항목을 무시합니다.</target>
        </trans-unit>
        <trans-unit id="67e6f0a239dfb82509e36ca577925e74a83f28f9" translate="yes" xml:space="preserve">
          <source>If = &quot;If&quot; &quot;:&quot; ( 1*No-tag-list | 1*Tagged-list )

     No-tag-list = List
     Tagged-list = Resource-Tag 1*List

     List = &quot;(&quot; 1*Condition &quot;)&quot;
     Condition = [&quot;Not&quot;] (State-token | &quot;[&quot; entity-tag &quot;]&quot;)
     ; entity-tag: see &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;Section&amp;nbsp;3.11 of [RFC2616]&lt;/a&gt;
     ; No LWS allowed between &quot;[&quot;, entity-tag and &quot;]&quot; 

     State-token = Coded-URL

     Resource-Tag = &quot;&amp;lt;&quot; Simple-ref &quot;&amp;gt;&quot;
     ; Simple-ref: see &lt;a href=&quot;#section-8.3&quot;&gt;Section 8.3&lt;/a&gt;
     ; No LWS allowed in Resource-Tag

   The syntax distinguishes between untagged lists (&quot;No-tag-list&quot;) and
   tagged lists (&quot;Tagged-list&quot;).  Untagged lists apply to the resource
   identified by the Request-URI, while tagged lists apply to the
   resource identified by the preceding Resource-Tag.

   A Resource-Tag applies to all subsequent Lists, up to the next
   Resource-Tag.

   Note that the two list types cannot be mixed within an If header.
   This is not a functional restriction because the No-tag-list syntax
   is just a shorthand notation for a Tagged-list production with a
   Resource-Tag referring to the Request-URI.

   Each List consists of one or more Conditions.  Each Condition is
   defined in terms of an entity-tag or state-token, potentially negated
   by the prefix &quot;Not&quot;.

   Note that the If header syntax does not allow multiple instances of
   If headers in a single request.  However, the HTTP header syntax
   allows extending single header values across multiple lines, by
   inserting a line break followed by whitespace (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], &lt;a href=&quot;#section-4.2&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt;).</source>
          <target state="translated">If = &quot;If&quot; &quot;:&quot;(1 * No-tag-list | 1 * Tagged-list) No-tag-list = List Tagged-list = Resource-Tag 1 * List List = &quot;(&quot;1 * Condition &quot;) &quot;Condition = [&quot;Not &quot;] (상태 토큰 |&quot;[ &quot;entity-tag&quot;] &quot;); 엔티티 태그 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-3.11&quot;&gt;[RFC2616]의 3.11 절&lt;/a&gt; 참조 . &quot;[&quot;, entity-tag 및 &quot;]&quot;사이에 LWS가 허용되지 않음 State-token = 코딩 된 URL Resource-Tag = &quot;&amp;lt;&quot;Simple-ref &quot;&amp;gt;&quot;; 단순 참조 : &lt;a href=&quot;#section-8.3&quot;&gt;섹션 8.3&lt;/a&gt; 참조 ; Resource-Tag에 LWS가 허용되지 않음 구문은 태그가없는 목록 ( &quot;No-tag-list&quot;)과 태그가있는 목록 ( &quot;Tagged-list&quot;)을 구분합니다. 태그가없는 목록은 Request-URI가 식별 한 자원에 적용되는 반면, 태그가없는 목록은 앞의 Resource-Tag가 식별 한 자원에 적용됩니다. Resource-Tag는 다음 Resource-Tag까지 모든 후속 목록에 적용됩니다. 두 목록 유형은 If 헤더 내에서 혼합 될 수 없습니다. No-tag-list 구문은 Request-URI를 참조하는 Resource-Tag를 사용하여 Tagged-list 프로덕션에 대한 간단한 표기법이므로 기능상의 제한이 아닙니다. 각 목록은 하나 이상의 조건으로 구성됩니다. 각 조건은 엔티티 태그 또는 상태 토큰의 관점에서 정의되며 접두사 &quot;Not&quot;으로 무시 될 수 있습니다.If 헤더 구문은 단일 요청에서 If 헤더의 다중 인스턴스를 허용하지 않습니다. 그러나 HTTP 헤더 구문을 사용하면 줄 바꿈과 공백을 삽입하여 여러 줄에 걸쳐 단일 헤더 값을 확장 할 수 있습니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], &lt;a href=&quot;#section-4.2&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="00bde6a2609129ada06a88cb9a7d89333869670f" translate="yes" xml:space="preserve">
          <source>If HTTP pipelining is activated, several requests can be sent without waiting for the first response to be fully received. HTTP pipelining has proven difficult to implement in existing networks, where old pieces of software coexist with modern versions. HTTP pipelining has been superseded in HTTP/2 with more robust multiplexing requests within a frame.</source>
          <target state="translated">HTTP 파이프 라이닝이 활성화 된 경우 첫 번째 응답이 완전히 수신되기를 기다리지 않고 여러 요청을 보낼 수 있습니다. HTTP 파이프 라이닝은 기존 소프트웨어가 최신 버전과 공존하는 기존 네트워크에서 구현하기 어려운 것으로 입증되었습니다. HTTP 파이프 라이닝은 프레임 내에서보다 강력한 멀티플렉싱 요청으로 HTTP / 2에서 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="748bef436e961cb49a985af369e84e4c57fb5faa" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are inadequate to access a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">(프록시) 서버가 주어진 리소스에 액세스하기에 부적합한 유효한 자격 증명을 받으면 서버는 &lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; 상태 코드로 응답해야 합니다. &lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 또는 &lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 와 달리이 사용자는 인증이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="2712ef523f505fe38f908ee1d8ecd4882dfa22c9" translate="yes" xml:space="preserve">
          <source>If a (proxy) server receives valid credentials that are not adequate to gain access for a given resource, the server should respond with the &lt;a href=&quot;status/403&quot;&gt;&lt;code&gt;403&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Forbidden&lt;/code&gt; status code. Unlike &lt;a href=&quot;status/401&quot;&gt;&lt;code&gt;401&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Unauthorized&lt;/code&gt; or &lt;a href=&quot;status/407&quot;&gt;&lt;code&gt;407&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Proxy Authentication Required&lt;/code&gt;, authentication is impossible for this user.</source>
          <target state="translated">(프록시) 서버가 주어진 리소스에 액세스하기에 적합하지 않은 유효한 자격 증명을 수신하면 서버는 &lt;a href=&quot;status/403&quot;&gt; &lt;code&gt;403&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Forbidden&lt;/code&gt; 상태 코드로 응답해야 합니다. &lt;a href=&quot;status/401&quot;&gt; &lt;code&gt;401&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Unauthorized&lt;/code&gt; 또는 &lt;a href=&quot;status/407&quot;&gt; &lt;code&gt;407&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Proxy Authentication Required&lt;/code&gt; 와는 달리이 사용자에게는 인증이 불가능합니다.</target>
        </trans-unit>
        <trans-unit id="9c01487d51a7abfed59147d7589b11bd17b56929" translate="yes" xml:space="preserve">
          <source>If a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt;&lt;code&gt;Sec-WebSocket-Key&lt;/code&gt;&lt;/a&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-WebSocket-Key&quot;&gt; &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; &lt;/a&gt; 헤더가 제공하고,이 헤더의 값을 고려하여 문자열 &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;그것을 연결 키의 값을 취함으로써 계산된다 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; 해시를 연결된 문자열로 20 바이트 값이됩니다. 이 값은 이 속성의 값을 얻기 위해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64로&lt;/a&gt; 인코딩됩니다.</target>
        </trans-unit>
        <trans-unit id="326ac990ab0dffc2412d939867b01ccdcb920f4c" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;DELETE&lt;/code&gt; method is successfully applied, there are several response status codes possible:</source>
          <target state="translated">경우 &lt;code&gt;DELETE&lt;/code&gt; 메소드가 성공적으로 적용되어, 여러 응답 상태 코드 수있다 :</target>
        </trans-unit>
        <trans-unit id="e0abfc5dd0ca6cc561a0c1e9018bd30b2988a7b7" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; header was provided, the value of this header is computed by taking the value of the key, concatenating the string &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot; to it, taking the &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; hash of that concatenated string, resulting in a 20-byte value. That value is then &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64&lt;/a&gt; encoded to obtain the value of this property.</source>
          <target state="translated">경우 &lt;code&gt;Sec-WebSocket-Key&lt;/code&gt; 헤더가 제공하고,이 헤더의 값을 고려하여 문자열 &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;그것을 연결 키의 값을 취함으로써 계산된다 &lt;a href=&quot;https://en.wikipedia.org/wiki/SHA-1&quot;&gt;SHA-1&lt;/a&gt; 해시를 연결된 문자열로 인해 20 바이트 값이됩니다. 이 값은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding&quot;&gt;base64로&lt;/a&gt; 인코딩 되어이 속성의 값을 얻습니다.</target>
        </trans-unit>
        <trans-unit id="34536e055c95da8db601f072a295ac2e4e5c6957" translate="yes" xml:space="preserve">
          <source>If a COPY request has an Overwrite header with a value of &quot;F&quot;, and a
   resource exists at the Destination URL, the server MUST fail the
   request.

   When a server executes a COPY request and overwrites a destination
   resource, the exact behavior MAY depend on many factors, including
   WebDAV extension capabilities (see particularly [&lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt;]).  For 

   example, when an ordinary resource is overwritten, the server could
   delete the target resource before doing the copy, or could do an in-
   place overwrite to preserve live properties.

   When a collection is overwritten, the membership of the destination
   collection after the successful COPY request MUST be the same
   membership as the source collection immediately before the COPY.
   Thus, merging the membership of the source and destination
   collections together in the destination is not a compliant behavior.

   In general, if clients require the state of the destination URL to be
   wiped out prior to a COPY (e.g., to force live properties to be
   reset), then the client could send a DELETE to the destination before
   the COPY request to ensure this reset.</source>
          <target state="translated">COPY 요청에 값이 &quot;F&quot;인 덮어 쓰기 헤더가 있고 대상 URL에 리소스가 존재하면 서버는 요청에 실패해야합니다. 서버가 COPY 요청을 실행하고 대상 자원을 덮어 쓰는 경우 정확한 동작은 WebDAV 확장 기능을 포함한 많은 요인에 따라 달라질 수 있습니다 (특히 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC3253&lt;/a&gt; 참조).]). 예를 들어 일반 리소스를 덮어 쓰면 서버는 복사하기 전에 대상 리소스를 삭제하거나 라이브 속성을 유지하기 위해 전체 덮어 쓰기를 수행 할 수 있습니다. 컬렉션을 덮어 쓰면 성공적인 COPY 요청 후 대상 컬렉션의 멤버 자격은 COPY 직전에 소스 컬렉션과 동일해야합니다. 따라서 소스 및 대상 컬렉션의 멤버 자격을 대상에서 병합하는 것은 호환되지 않습니다. 일반적으로 클라이언트가 COPY 이전에 도착 URL의 상태를 지워야하는 경우 (예 : 실시간 속성을 강제로 재설정) 클라이언트는 COPY 요청 전에 목적지로 DELETE를 보내이 재설정을 보장 할 수 있습니다. .</target>
        </trans-unit>
        <trans-unit id="0fb0c405e8ed86db97633eff664cd93d6b990ee4" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider the value to be either 2147483648 (2^31) or the greatest positive integer it can conveniently represent.</source>
          <target state="translated">캐시가 표현할 수있는 것보다 큰 값을 받거나 후속 계산이 오버플로되면 캐시는 값을 2147483648 (2 ^ 31) 또는 편리하게 나타낼 수있는 가장 큰 양의 정수로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="f48cab758bf32db6fab20e2d919807414feba7e5" translate="yes" xml:space="preserve">
          <source>If a cache receives a value greater than it can represent, or if any of its subsequent calculations overflows, the cache will consider this value to be either 2,147,483,648 (2&lt;sup&gt;31&lt;/sup&gt;) or the greatest positive integer it can represent.</source>
          <target state="translated">캐시가 나타낼 수있는 것보다 큰 값을 받거나 후속 계산이 오버플로되는 경우 캐시는이 값을 2,147,483,648 (2 &lt;sup&gt;31&lt;/sup&gt; ) 또는 나타낼 수있는 최대 양의 정수로 간주합니다.</target>
        </trans-unit>
        <trans-unit id="45f89453dd62bad0eede5073e7bfa49271c65312" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of a representation and wishes to have
   an up-to-date copy of the entire representation, it could use the
   Range header field with a conditional GET (using either or both of
   If-Unmodified-Since and If-Match.)  However, if the precondition
   fails because the representation has been modified, the client would
   then have to make a second request to obtain the entire current
   representation.

   The &quot;If-Range&quot; header field allows a client to &quot;short-circuit&quot; the
   second request.  Informally, its meaning is as follows: if the
   representation is unchanged, send me the part(s) that I am requesting
   in Range; otherwise, send me the entire representation.

     If-Range = entity-tag / HTTP-date

   A client MUST NOT generate an If-Range header field in a request that
   does not contain a Range header field.  A server MUST ignore an
   If-Range header field received in a request that does not contain a
   Range header field.  An origin server MUST ignore an If-Range header
   field received in a request for a target resource that does not
   support Range requests.

   A client MUST NOT generate an If-Range header field containing an
   entity-tag that is marked as weak.  A client MUST NOT generate an
   If-Range header field containing an HTTP-date unless the client has
   no entity-tag for the corresponding representation and the date is a
   strong validator in the sense defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.

   A server that evaluates an If-Range precondition MUST use the strong
   comparison function when comparing entity-tags (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;Section&amp;nbsp;2.3.2 of
   [RFC7232]&lt;/a&gt;) and MUST evaluate the condition as false if an HTTP-date 

   validator is provided that is not a strong validator in the sense
   defined by &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;Section&amp;nbsp;2.2.2 of [RFC7232]&lt;/a&gt;.  A valid entity-tag can be
   distinguished from a valid HTTP-date by examining the first two
   characters for a DQUOTE.

   If the validator given in the If-Range header field matches the
   current validator for the selected representation of the target
   resource, then the server SHOULD process the Range header field as
   requested.  If the validator does not match, the server MUST ignore
   the Range header field.  Note that this comparison by exact match,
   including when the validator is an HTTP-date, differs from the
   &quot;earlier than or equal to&quot; comparison used when evaluating an
   If-Unmodified-Since conditional.</source>
          <target state="translated">클라이언트가 표현의 일부 사본을 가지고 있고 전체 표현의 최신 사본을 원할 경우 조건 헤더 GET과 함께 범위 헤더 필드를 사용할 수 있습니다 (If-Unmodified-Since 및 If 중 하나 또는 둘 다 사용). 그러나 표현이 수정되어 전제 조건이 실패하면 클라이언트는 전체 현재 표현을 얻기 위해 두 번째 요청을해야합니다. &quot;If-Range&quot;헤더 필드를 통해 클라이언트는 두 번째 요청을 &quot;단락&quot;할 수 있습니다. 비공식적으로 그 의미는 다음과 같습니다. 표현이 변경되지 않으면 Range에서 요청하는 부분을 보내주십시오. 그렇지 않으면 전체 표현을 보내주십시오.If-Range = entity-tag / HTTP-date 클라이언트는 Range 헤더 필드를 포함하지 않는 요청에서 If-Range 헤더 필드를 생성해서는 안됩니다. 서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 오리진 서버는 범위 요청을 지원하지 않는 대상 자원에 대한 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 오리진 서버는 범위 요청을 지원하지 않는 대상 자원에 대한 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).서버는 Range 헤더 필드를 포함하지 않는 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 오리진 서버는 범위 요청을 지원하지 않는 대상 자원에 대한 요청에서 수신 된 If-Range 헤더 필드를 무시해야합니다. 클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).클라이언트는 약한 것으로 표시된 엔티티 태그를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT). 클라이언트는 해당 표현에 대한 엔티티 태그가없고 날짜가 다음과 같이 정의 된 의미에서 강력한 유효성 검사기가 아닌 한 HTTP 날짜를 포함하는 If-Range 헤더 필드를 생성해서는 안됩니다 (MUST NOT).&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]의 섹션 2.2.2&lt;/a&gt; . If-Range 전제 조건을 평가하는 서버는 엔티티 태그를 비교할 때 강력한 비교 함수를 사용해야하며 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3.2&quot;&gt;[RFC7232]의 섹션 2.3.2&lt;/a&gt; ) HTTP 날짜 유효성 검증 기가 제공되지 않으면 조건을 false로 평가해야합니다 (강력하지 않은 경우). &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2.2&quot;&gt;[RFC7232]의 섹션 2.2.2에서&lt;/a&gt; 정의한 의미의 검증기. DQUOTE의 처음 두 문자를 검사하여 유효한 엔티티 태그를 유효한 HTTP- 날짜와 구별 할 수 있습니다. If-Range 헤더 필드에 제공된 유효성 검사기가 대상 리소스의 선택된 표현에 대한 현재 유효성 검사기와 일치하면 서버는 요청 된대로 Range 헤더 필드를 처리해야합니다. 유효성 검사기가 일치하지 않으면 서버는 범위 헤더 필드를 무시해야합니다. 유효성 검증 기가 HTTP 날짜 인 경우를 포함하여 정확하게 일치하는 이러한 비교는 If-Unmodified-Since 조건을 평가할 때 사용되는 &quot;이전 또는 이전&quot;비교와 다릅니다.</target>
        </trans-unit>
        <trans-unit id="9d82e70ce9faffba2758cddebc66060093cca8ab" translate="yes" xml:space="preserve">
          <source>If a client has a partial copy of an entity in its cache, and wishes
   to have an up-to-date copy of the entire entity in its cache, it
   could use the Range request-header with a conditional GET (using
   either or both of If-Unmodified-Since and If-Match.) However, if the
   condition fails because the entity has been modified, the client
   would then have to make a second request to obtain the entire current
   entity-body.

   The If-Range header allows a client to &quot;short-circuit&quot; the second
   request. Informally, its meaning is `if the entity is unchanged, send
   me the part(s) that I am missing; otherwise, send me the entire new
   entity'.

        If-Range = &quot;If-Range&quot; &quot;:&quot; ( entity-tag | HTTP-date ) 

   If the client has no entity tag for an entity, but does have a Last-
   Modified date, it MAY use that date in an If-Range header. (The
   server can distinguish between a valid HTTP-date and any form of
   entity-tag by examining no more than two characters.) The If-Range
   header SHOULD only be used together with a Range header, and MUST be
   ignored if the request does not include a Range header, or if the
   server does not support the sub-range operation.

   If the entity tag given in the If-Range header matches the current
   entity tag for the entity, then the server SHOULD provide the
   specified sub-range of the entity using a 206 (Partial content)
   response. If the entity tag does not match, then the server SHOULD
   return the entire entity using a 200 (OK) response.</source>
          <target state="translated">클라이언트가 캐시에 엔티티의 부분 사본을 가지고 있고 캐시에 전체 엔티티의 최신 사본을 보유하려는 경우 조건부 GET과 함께 범위 요청 헤더를 사용할 수 있습니다 (둘 중 하나 또는 둘 다 사용) 그러나 엔터티가 수정되어 조건이 실패하면 클라이언트는 현재 엔터티 전체를 얻기 위해 두 번째 요청을해야합니다. If-Range 헤더를 사용하면 클라이언트가 두 번째 요청을 &quot;단락&quot;할 수 있습니다. 비공식적으로, 그 의미는 '실체가 변경되지 않은 경우, 내가 누락 된 부분을 보내주십시오. 그렇지 않으면, 전체 새로운 엔티티를 보내주십시오. If-Range = &quot;If-Range&quot; &quot;:&quot;(entity-tag | HTTP-date) 클라이언트에 엔티티에 대한 엔티티 태그가 없지만 최종 수정 날짜가있는 경우,해당 날짜를 If-Range 헤더에 사용할 수 있습니다. (서버는 두 개 이하의 문자를 검사하여 유효한 HTTP- 날짜와 엔티티-태그 형태를 구별 할 수 있습니다.) If-Range 헤더는 Range 헤더와 함께 사용해야하며 요청이있는 경우 무시해야합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우 If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).(서버는 두 개 이하의 문자를 검사하여 유효한 HTTP- 날짜와 엔티티-태그 형태를 구별 할 수 있습니다.) If-Range 헤더는 Range 헤더와 함께 사용해야하며 요청이있는 경우 무시해야합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우 If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).(서버는 두 개 이하의 문자를 검사하여 유효한 HTTP- 날짜와 엔티티-태그 형태를 구별 할 수 있습니다.) If-Range 헤더는 Range 헤더와 함께 사용해야하며 요청이있는 경우 무시해야합니다. Range 헤더를 포함하지 않거나 서버가 하위 범위 작업을 지원하지 않는 경우 If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).또는 서버가 하위 범위 작업을 지원하지 않는 경우. If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).또는 서버가 하위 범위 작업을 지원하지 않는 경우. If-Range 헤더에 제공된 엔티티 태그가 엔티티의 현재 엔티티 태그와 일치하면, 서버는 206 (부분 컨텐츠) 응답을 사용하여 엔티티의 지정된 하위 범위를 제공해야합니다. 엔티티 태그가 일치하지 않으면 서버는 200 (OK) 응답을 사용하여 전체 엔티티를 반환해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="3088b6387af36bd48fbfec162964786d9f1bdf8a" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is also marked with the &lt;code&gt;Secure&lt;/code&gt; attribute, was sent from a secure origin, does &lt;em&gt;not&lt;/em&gt; include a &lt;code&gt;Domain&lt;/code&gt; attribute, and has the &lt;code&gt;Path&lt;/code&gt; attribute set to &lt;code&gt;/&lt;/code&gt;. In this way, these cookies can be seen as &quot;domain-locked&quot;.</source>
          <target state="translated">쿠키 이름에이 접두사가 있으면 &lt;code&gt;Secure&lt;/code&gt; 속성으로 표시되고 보안 원본에서 전송되었으며 &lt;code&gt;Domain&lt;/code&gt; 속성을 포함 하지 &lt;em&gt;않고 &lt;/em&gt; &lt;code&gt;Path&lt;/code&gt; 속성이 &lt;code&gt;/&lt;/code&gt; 로 설정된 경우에만 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더 에서 허용됩니다. . 이러한 방식으로 이러한 쿠키는 &quot;도메인 잠금&quot;으로 볼 수 있습니다.&lt;em&gt;&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c034021e921f0e666de945c6149637ed216dc323" translate="yes" xml:space="preserve">
          <source>If a cookie name has this prefix, it is accepted in a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header only if it is marked with the &lt;code&gt;Secure&lt;/code&gt; attribute and was sent from a secure origin. This is weaker than the &lt;code&gt;__Host-&lt;/code&gt; prefix.</source>
          <target state="translated">쿠키 이름에이 접두사가 있으면 &lt;code&gt;Secure&lt;/code&gt; 속성으로 표시되고 보안 원본에서 전송 된 경우에만 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더 에서 허용됩니다 . 이것은 &lt;code&gt;__Host-&lt;/code&gt; 접두사 보다 약 합니다.</target>
        </trans-unit>
        <trans-unit id="d6c875512b44481b0aec708d6ca539f3bb79d246" translate="yes" xml:space="preserve">
          <source>If a new cacheable (see sections &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt;, &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt;, &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; and &lt;a href=&quot;#section-13.8&quot;&gt;13.8&lt;/a&gt;)
   response is received from a resource while any existing responses for
   the same resource are cached, the cache SHOULD use the new response
   to reply to the current request. It MAY insert it into cache storage
   and MAY, if it meets all other requirements, use it to respond to any
   future requests that would previously have caused the old response to
   be returned. If it inserts the new response into cache storage  the
   rules in &lt;a href=&quot;#section-13.5.3&quot;&gt;section 13.5.3&lt;/a&gt; apply.

      Note: a new response that has an older Date header value than
      existing cached responses is not cacheable.</source>
          <target state="translated">동일한 자원에 대한 기존 응답이 캐시되는 동안 자원에서 새로운 캐시 가능 ( &lt;a href=&quot;#section-14.9.2&quot;&gt;14.9.2&lt;/a&gt; , &lt;a href=&quot;#section-13.2.5&quot;&gt;13.2.5&lt;/a&gt; , &lt;a href=&quot;#section-13.2.6&quot;&gt;13.2.6&lt;/a&gt; 및 &lt;a href=&quot;#section-13.8&quot;&gt;13.8 참조&lt;/a&gt; ) 응답을 수신하면 캐시는 새로운 응답을 사용하여 현재에 응답해야합니다 의뢰. 캐시 스토리지에이를 삽입하고 다른 모든 요구 사항을 충족하는 경우이를 사용하여 이전 응답이 리턴되었던 이전 요청에 응답 할 수 있습니다. 새로운 응답을 캐시 스토리지에 삽입하면 &lt;a href=&quot;#section-13.5.3&quot;&gt;섹션 13.5.3&lt;/a&gt; 의 규칙이 적용됩니다. 참고 : 기존 캐시 응답보다 오래된 Date 헤더 값을 가진 새 응답은 캐시 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="e58c73fa3ef27580bf7799dda53dd96a70453ff2" translate="yes" xml:space="preserve">
          <source>If a request goes through multiple proxies, the IP addresses of each successive proxy is listed. This means, the right-most IP address is the IP address of the most recent proxy and the left-most IP address is the IP address of the originating client.</source>
          <target state="translated">요청이 여러 프록시를 통과하는 경우 각 연속 프록시의 IP 주소가 나열됩니다. 즉, 가장 오른쪽 IP 주소는 가장 최근 프록시의 IP 주소이고 가장 왼쪽 IP 주소는 원래 클라이언트의 IP 주소입니다.</target>
        </trans-unit>
        <trans-unit id="e2c3c58894ac3aaacdbb37189725a1f26ce869ef" translate="yes" xml:space="preserve">
          <source>If a resource exists at the destination and the Overwrite header is
   &quot;T&quot;, then prior to performing the move, the server MUST perform a
   DELETE with &quot;Depth: infinity&quot; on the destination resource.  If the
   Overwrite header is set to &quot;F&quot;, then the operation will fail.</source>
          <target state="translated">대상에 리소스가 있고 덮어 쓰기 헤더가 &quot;T&quot;인 경우 이동을 수행하기 전에 서버는 대상 리소스에서 &quot;Depth : infinity&quot;를 사용하여 DELETE를 수행해야합니다. 덮어 쓰기 헤더가 &quot;F&quot;로 설정되면 작업이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="22db687e87d90b4a5b61ae1c9f192564fbed5581" translate="yes" xml:space="preserve">
          <source>If a same-site cookie has this attribute, the browser will only send cookies if the request originated from the website that set the cookie. If the request originated from a different URL than the URL of the current location, none of the cookies tagged with the &lt;code&gt;strict&lt;/code&gt; attribute will be included.</source>
          <target state="translated">동일한 사이트 쿠키에이 속성이있는 경우 브라우저는 쿠키를 설정 한 웹 사이트에서 요청이 발생한 경우에만 쿠키를 보냅니다. 요청이 현재 위치의 URL과 다른 URL에서 시작된 경우 &lt;code&gt;strict&lt;/code&gt; 속성으로 태그가 지정된 쿠키 는 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a78f222e9151b20e3fa58d2b5922efdfbb1c1a0f" translate="yes" xml:space="preserve">
          <source>If a server returns such an error status, the body of the message should contain the list of the available representations of the resources, allowing the user to choose among them.</source>
          <target state="translated">서버가 이러한 오류 상태를 반환하면 메시지 본문에 사용 가능한 리소스 표현 목록이 포함되어 있어야 사용자가 선택할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="acb751d12ffe14eea97f1844541379bb1e82d026" translate="yes" xml:space="preserve">
          <source>If a single server supports multiple organizations that do not trust
   one another, then it MUST check the values of Location and Content-
   Location headers in responses that are generated under control of
   said organizations to make sure that they do not attempt to
   invalidate resources over which they have no authority.</source>
          <target state="translated">단일 서버가 서로를 신뢰하지 않는 여러 조직을 지원하는 경우, 해당 조직의 통제하에 생성 된 응답에서 Location 및 Content-Location 헤더의 값을 확인하여 어떤 서버에서 자원을 무효화하지 않도록해야합니다. 그들은 권한이 없습니다.</target>
        </trans-unit>
        <trans-unit id="0034277126e29616d67034416858786a6bf01601" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header to the response of https://example.com/logout:</source>
          <target state="translated">사용자가 웹 사이트 나 서비스에서 로그 아웃하면 로컬에 저장된 데이터를 제거 할 수 있습니다. https://example.com/logout의 응답에 &lt;code&gt;Clear-Site-Data&lt;/code&gt; 헤더를 추가하여이를 달성 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="28708bd5ed063a05bc0c1ffae01007cff1ddad84" translate="yes" xml:space="preserve">
          <source>If a user signs out of your website or service, you might want to remove locally stored data. You can achieve that by adding the &lt;code&gt;Clear-Site-Data&lt;/code&gt; header when sending the page confirming that logging out from the site has been accomplished successfully (https://example.com/logout, for example):</source>
          <target state="translated">사용자가 웹 사이트 또는 서비스에서 로그 아웃하면 로컬에 저장된 데이터를 제거 할 수 있습니다. &lt;code&gt;Clear-Site-Data&lt;/code&gt; 에서 로그 아웃이 성공적으로 완료되었음을 확인하는 페이지를 보낼 때 Clear-Site-Data 헤더 를 추가하면 됩니다 (예 : https://example.com/logout).</target>
        </trans-unit>
        <trans-unit id="8c5c04bfd2a5924b2636ab2156504c08859b88e5" translate="yes" xml:space="preserve">
          <source>If a website accepts a connection through HTTP and redirects to HTTPS, visitors may initially communicate with the non-encrypted version of the site before being redirected, if, for example, the visitor types http://www.foo.com/ or even just foo.com. This creates an opportunity for a man-in-the-middle attack. The redirect could be exploited to direct visitors to a malicious site instead of the secure version of the original site.</source>
          <target state="translated">웹 사이트가 HTTP를 통한 연결을 수락하고 HTTPS로 리디렉션하는 경우 방문자가 http://www.foo.com/ 또는 그냥 foo.com. 이것은 중간자 공격의 기회를 만듭니다. 리디렉션을 이용하여 방문자를 원래 사이트의 보안 버전 대신 악의적 인 사이트로 안내 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c5d743f58d38a06b0efb87624e4399a8e4fa3b88" translate="yes" xml:space="preserve">
          <source>If all proxies are down, and there was no DIRECT option specified, the browser will ask if proxies should be temporarily ignored, and direct connections attempted. After 20 minutes, the browser will ask if proxies should be retried, asking again after an additional 40 minutes. Queries will continue, always adding 20 minutes to the elapsed time between queries.</source>
          <target state="translated">모든 프록시가 작동 중지되고 DIRECT 옵션이 지정되지 않은 경우 브라우저는 프록시를 일시적으로 무시해야하는지 여부를 묻고 직접 연결을 시도합니다. 20 분 후 브라우저는 프록시를 다시 시도해야하는지 묻고 추가 40 분 후에 다시 묻습니다. 쿼리는 계속 진행되며 쿼리 간 경과 시간에 항상 20 분이 추가됩니다.</target>
        </trans-unit>
        <trans-unit id="24f0c3aae5a8cb6b90479558f98a655abee38832" translate="yes" xml:space="preserve">
          <source>If an HTTP/1.1 client sends a request which includes a request body,
   but which does not include an Expect request-header field with the
   &quot;100-continue&quot; expectation, and if the client is not directly
   connected to an HTTP/1.1 origin server, and if the client sees the
   connection close before receiving any status from the server, the
   client SHOULD retry the request.  If the client does retry this
   request, it MAY use the following &quot;binary exponential backoff&quot;
   algorithm to be assured of obtaining a reliable response:

      1. Initiate a new connection to the server

      2. Transmit the request-headers

      3. Initialize a variable R to the estimated round-trip time to the
         server (e.g., based on the time it took to establish the
         connection), or to a constant value of 5 seconds if the round-
         trip time is not available.

      4. Compute T = R * (2**N), where N is the number of previous
         retries of this request.

      5. Wait either for an error response from the server, or for T
         seconds (whichever comes first)

      6. If no error response is received, after T seconds transmit the
         body of the request.

      7. If client sees that the connection is closed prematurely,
         repeat from step 1 until the request is accepted, an error
         response is received, or the user becomes impatient and
         terminates the retry process. 

   If at any point an error status is received, the client

      - SHOULD NOT continue and

      - SHOULD close the connection if it has not completed sending the
        request message.</source>
          <target state="translated">HTTP / 1.1 클라이언트가 요청 본문을 포함하지만 &quot;100-continue&quot;예상과 함께 Expect 요청 헤더 필드를 포함하지 않는 요청을 보내고 클라이언트가 HTTP / 1.1 오리진 서버에 직접 연결되지 않은 경우 서버로부터 상태를 수신하기 전에 클라이언트가 연결이 닫히면 클라이언트는 요청을 다시 시도해야합니다. 클라이언트가이 요청을 재 시도하는 경우 신뢰할 수있는 응답을 얻기 위해 다음 &quot;이진 지수 백 오프&quot;알고리즘을 사용할 수 있습니다. 1. 서버에 대한 새로운 연결을 시작합니다. 2. 요청 헤더를 전송합니다. 3. 변수 R을 초기화합니다 서버에 대한 예상 왕복 시간 (예 : 연결을 설정하는 데 걸린 시간에 따라)왕복 시간을 사용할 수없는 경우 상수 값을 5 초로 설정하십시오. 4. 계산 T = R * (2 ** N). 여기서 N은이 요청의 이전 재시도 횟수입니다. 5. 서버에서 오류 응답을 기다리거나 T 초 (둘 중 빠른 시간)를 기다립니다. 6. 오류 응답이 수신되지 않으면 T 초 후에 요청 본문을 전송하십시오. 7. 클라이언트가 연결이 조기에 종료 된 것을 확인하면 요청이 수락되거나 오류 응답이 수신되거나 사용자가 조급해 재시도 프로세스를 종료 할 때까지 1 단계부터 반복하십시오. 어느 시점에서든 오류 상태가 수신되면 클라이언트는 계속해서는 안되며 요청 메시지 전송이 완료되지 않은 경우 연결을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="787c64d4a2d625599ff698430e64f8f08ddeb6a2" translate="yes" xml:space="preserve">
          <source>If an origin server does not explicitly specify freshness (e.g. using &lt;a href=&quot;headers/cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;headers/expires&quot;&gt;&lt;code&gt;Expires&lt;/code&gt;&lt;/a&gt; header) then a heuristic approach may be used.</source>
          <target state="translated">원 서버가 신선도를 명시 적으로 지정하지 않은 경우 (예 : &lt;a href=&quot;headers/cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; 또는&lt;a href=&quot;headers/expires&quot;&gt; &lt;code&gt;Expires&lt;/code&gt; &lt;/a&gt; 헤더 사용) 휴리스틱 접근 방식을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cf50575579d857df6c5f0e97dcbebb456e6ad37f" translate="yes" xml:space="preserve">
          <source>If another principal locks a resource that a principal wishes to
   access, it is useful for the second principal to be able to find out
   who the first principal is.  For this purpose the DAV:lockdiscovery
   property is provided.  This property lists all outstanding locks,
   describes their type, and MAY even provide the lock tokens.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:lockdiscovery property.</source>
          <target state="translated">다른 프린시 펄이 프린시 펄이 액세스하려는 자원을 잠그면, 두 번째 프린시 펄이 첫 번째 프린시 펄이 누구인지 알아낼 수 있습니다. 이를 위해 DAV : lockdiscovery 특성이 제공됩니다. 이 속성은 모든 미해결 잠금을 나열하고 유형을 설명하며 잠금 토큰을 제공 할 수도 있습니다. LOCK 메소드를 지원하는 모든 DAV 호환 자원은 DAV : lockdiscovery 특성을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="4e1966a722bf8f31efed779517aa3c6a04a51ec9" translate="yes" xml:space="preserve">
          <source>If both &lt;strong&gt;wd1 &lt;/strong&gt;and &lt;strong&gt;wd1 &lt;/strong&gt;are defined, the condition is true if the current weekday is in between those two &lt;em&gt;ordered &lt;/em&gt;weekdays. Bounds are inclusive, &lt;em&gt;but the bounds are ordered&lt;/em&gt;. If the &quot;GMT&quot; parameter is specified, times are taken to be in GMT. Otherwise, the local timezone is used.</source>
          <target state="translated">두 경우 &lt;strong&gt;WD1&lt;/strong&gt; 및 &lt;strong&gt;WD1가&lt;/strong&gt; 정의되어 현재 요일이이 둘 사이에있는 경우, 조건은 true입니다 &lt;em&gt;주문&lt;/em&gt; 평일. 바운드는 포함 &lt;em&gt;되지만 바운드는 정렬&lt;/em&gt; 됩니다. &quot;GMT&quot;매개 변수를 지정하면 시간이 GMT로 설정됩니다. 그렇지 않으면 현지 시간대가 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="9452662d9180b8ba3efe3a780c450ae27e07209e" translate="yes" xml:space="preserve">
          <source>If both a &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and a &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header are present in the same response, both policies are honored. The policy specified in &lt;code&gt;Content-Security-Policy&lt;/code&gt; headers is enforced while the &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; policy generates reports but is not enforced.</source>
          <target state="translated">둘 다를 경우 &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더와 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더 같은 응답에 존재하는 두 정책은 영광입니다. &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; 정책이 보고서를 생성하지만 시행되지 않는 동안 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더에 지정된 정책 이 시행 됩니다.</target>
        </trans-unit>
        <trans-unit id="d126e6f1349def738aa84d3d7ade4189f1674e03" translate="yes" xml:space="preserve">
          <source>If both this directive (i.e. via the &lt;code&gt;allow&lt;/code&gt; attribute) and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence. There was a bug whereby the &lt;code&gt;fullscreen&lt;/code&gt; directive didn't work unless the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute was also present, but this has been fixed as of Firefox 80 (&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;bug 1608358&lt;/a&gt;).</source>
          <target state="translated">이 지시문 (즉, &lt;code&gt;allow&lt;/code&gt; 속성을 통해 )과 &lt;code&gt;allowfullscreen&lt;/code&gt; 속성이 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 에있는 경우 요소에있는 경우이 지시문이 우선합니다. 거기 이에 버그이었다 &lt;code&gt;fullscreen&lt;/code&gt; 하지 않는 지시어가 작동하지 않았다 &lt;code&gt;allowfullscreen&lt;/code&gt; 속성도 존재는, 그러나 이것은 파이어 폭스 (80) (현재의 고정 된 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1608358&quot;&gt;버그 1608358&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="e7feb971c53a1e3363d82fc1ef6da1a87db0cb6b" translate="yes" xml:space="preserve">
          <source>If both this directive and the &lt;code&gt;allowfullscreen&lt;/code&gt; attribute are present on an &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; element, this directive takes precedence.</source>
          <target state="translated">이 지시문과 &lt;code&gt;allowfullscreen&lt;/code&gt; 속성 이 모두 &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; 요소에 있으면이 지시문이 우선합니다.</target>
        </trans-unit>
        <trans-unit id="62b0316637ce393c10dfd9b58aa37bf2f0a42cdc" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Content-Language&lt;/code&gt; is specified, the default is that the content is intended for all language audiences. Multiple language tags are also possible, as well as applying the &lt;code&gt;Content-Language&lt;/code&gt; header to various media types and not only to textual documents.</source>
          <target state="translated">&lt;code&gt;Content-Language&lt;/code&gt; 가 지정 되지 않은 경우 기본적으로 컨텐츠는 모든 언어 사용자를 대상으로합니다. 텍스트 &lt;code&gt;Content-Language&lt;/code&gt; 뿐만 아니라 다양한 미디어 유형에 Content-Language 헤더를 적용 할뿐만 아니라 여러 언어 태그도 가능 합니다.</target>
        </trans-unit>
        <trans-unit id="5f0faef3900e1d15f4d91c1fcfcd5a68d9578e75" translate="yes" xml:space="preserve">
          <source>If no URL scheme is specified for a &lt;code&gt;host-source&lt;/code&gt; and the iframe is loaded from an &lt;code&gt;https&lt;/code&gt; URL, the URL for the page loading the iframe must also be &lt;code&gt;https&lt;/code&gt;, per the W3C spec on &lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;matching source expressions&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;host-source&lt;/code&gt; 대해 URL 스키마가 지정되지 않고 iframe이 &lt;code&gt;https&lt;/code&gt; URL 하는 페이지의 URL도 &lt;a href=&quot;https://w3c.github.io/webappsec-csp/2/#match-source-expression&quot;&gt;일치하는 소스 표현식&lt;/a&gt; 의 W3C 사양에 따라 &lt;code&gt;https&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="2432969974e0bf99b152d397b2c719d44cd0439e" translate="yes" xml:space="preserve">
          <source>If no port is given, the default port for the service requested (e.g., &quot;80&quot; for an HTTP URL) is implied.</source>
          <target state="translated">포트가 제공되지 않으면 요청 된 서비스의 기본 포트 (예 : HTTP URL의 경우 &quot;80&quot;)가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="9619fd8159a262a6e7f8b156f3e9ea6322194094" translate="yes" xml:space="preserve">
          <source>If no port is included, the default port for the service requested (e.g., &lt;code&gt;443&lt;/code&gt; for an HTTPS URL, and &lt;code&gt;80&lt;/code&gt; for an HTTP URL) is implied.</source>
          <target state="translated">포트가 포함되지 않은 경우 요청 된 서비스의 기본 포트 (예 : HTTPS URL의 경우 &lt;code&gt;443&lt;/code&gt; , HTTP URL의 경우 &lt;code&gt;80&lt;/code&gt; )가 암시됩니다.</target>
        </trans-unit>
        <trans-unit id="e478b06858c696e70a28213656753916abc92ba3" translate="yes" xml:space="preserve">
          <source>If omitted, defaults to the host of the current document URL, not including subdomains.</source>
          <target state="translated">생략하면 기본적으로 현재 문서 URL의 호스트가 하위 도메인을 포함하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="219c745dfe181251ec5c580abc0c14da79c6b291" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: day, month, year), the function returns a true value only on days that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">단일 범주 (일, 월, 년)에서 하나의 값만 지정하면 함수는 해당 스펙과 일치하는 날에만 참 값을 리턴합니다. 두 값을 모두 지정 &lt;em&gt;하면 경계를&lt;/em&gt; 포함하여 해당 시간 사이에 결과가 적용 &lt;em&gt;되지만 경계가 정렬&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="ebc918364962297bbe2d03e861cdada5a4d5d17c" translate="yes" xml:space="preserve">
          <source>If only a single value is specified (from each category: hour, minute, second), the function returns a true value only at times that match that specification. If both values are specified, the result is true between those times, including bounds, &lt;em&gt;but the bounds are ordered&lt;/em&gt;.</source>
          <target state="translated">단일 범주 만 지정하면 (각 범주에서시, 분, 초), 해당 스펙과 일치하는 시간에만 함수가 true를 리턴합니다. 두 값을 모두 지정 &lt;em&gt;하면 경계를&lt;/em&gt; 포함하여 해당 시간 사이에 결과가 적용 &lt;em&gt;되지만 경계가 정렬&lt;/em&gt; 됩니다.</target>
        </trans-unit>
        <trans-unit id="7ad3b8639eddeee4168cd5b47edae6dcb2df2c3c" translate="yes" xml:space="preserve">
          <source>If only one parameter is present, the function returns a value of true on the weekday that the parameter represents. If the string &quot;GMT&quot; is specified as a second parameter, times are taken to be in GMT. Otherwise, they are assumed to be in the local timezone.</source>
          <target state="translated">매개 변수가 하나만 있으면 함수는 해당 매개 변수가 나타내는 요일에 true 값을 반환합니다. 문자열 &quot;GMT&quot;가 두 번째 매개 변수로 지정된 경우 시간은 GMT로 간주됩니다. 그렇지 않으면 현지 시간대로 간주됩니다.</target>
        </trans-unit>
        <trans-unit id="b64b7edace3c1de8eea4e9f7cb502c7f66cbbfc3" translate="yes" xml:space="preserve">
          <source>If several ranges are sent back, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; is set to &lt;code&gt;multipart/byteranges&lt;/code&gt; and each fragment covers one range, with &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; describing it.</source>
          <target state="translated">여러 범위가 다시 전송되면 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;multipart/byteranges&lt;/code&gt; 로 설정 되고 각 조각은 하나의 범위를 다루며 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; 에서&lt;/a&gt; 설명합니다.</target>
        </trans-unit>
        <trans-unit id="78a2139f59af3c201e14f90fe9cef770569b0d29" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support for partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">사이트에서 &lt;code&gt;Accept-Ranges&lt;/code&gt; 헤더를 생략하면 부분 요청을 지원하지 않을 수 있습니다. 일부 사이트는 명시 적으로 &quot; &lt;code&gt;none&lt;/code&gt; &quot;을 값 으로 보내 지원하지 않음을 나타냅니다. 일부 앱에서는 다운로드 관리자가이 경우 일시 중지 버튼을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="c8a2e2bc49a74014d19dc3e20faf6d47f4b2c5fb" translate="yes" xml:space="preserve">
          <source>If sites omit the &lt;code&gt;Accept-Ranges&lt;/code&gt; header, they likely don't support partial requests. Some sites also explicitly send &quot;&lt;code&gt;none&lt;/code&gt;&quot; as a value, indicating no support. In some apps, download managers disable their pause buttons in that case.</source>
          <target state="translated">사이트에서 &lt;code&gt;Accept-Ranges&lt;/code&gt; 를 생략하는 경우 헤더를 부분 요청을 지원하지 않을 가능성이 높습니다. 일부 사이트는 또한 &quot; &lt;code&gt;none&lt;/code&gt; &quot;을 값 으로 명시 적으로 전송 하여 지원이 없음을 나타냅니다. 일부 앱에서는 다운로드 관리자가이 경우 일시 중지 버튼을 비활성화합니다.</target>
        </trans-unit>
        <trans-unit id="091a0218219abd0cdbbefc8a401d17bce706512c" translate="yes" xml:space="preserve">
          <source>If that's not possible, then another way is to:</source>
          <target state="translated">가능하지 않은 경우 다른 방법은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="7832c9e8ca11a0dc4da645bd06786210e575896b" translate="yes" xml:space="preserve">
          <source>If the &quot;Basic&quot; authentication scheme is used, the credentials are constructed like this:</source>
          <target state="translated">&quot;기본&quot;인증 체계를 사용하는 경우 자격 증명은 다음과 같이 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="f91174398d0cf4de63fc9e0993886a3f7ebd8264" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request and cURL, for example.</source>
          <target state="translated">는 IF &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; 응답 HTTP에 존재하는 (그 값이 &quot;하지 않습니다 &lt;code&gt;none&lt;/code&gt; &quot;), 서버가 지원 요청을 다양합니다. 예를 들어 &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 요청 및 cURL 을 발행하여이를 확인할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="1e2bd82bb2d016fc76410dd12a3b0342a93316e7" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt; is present in HTTP responses (and its value isn't &quot;&lt;code&gt;none&lt;/code&gt;&quot;), the server supports range requests. You can check this by issuing a &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request with cURL, for example.</source>
          <target state="translated">는 IF &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; 응답 HTTP에 존재하는 (그 값이 &quot;하지 않습니다 &lt;code&gt;none&lt;/code&gt; &quot;), 서버가 지원 요청을 다양합니다. &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 를 발행하여 확인할 수 있습니다.예를 들어 cURL 요청을 .</target>
        </trans-unit>
        <trans-unit id="a0c9cc929b4bd0a174617d37fdb2ef2438aa90fc" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;user agent&lt;/a&gt; can't detect any value specified for this header&amp;mdash;even though the header is included in the response&amp;mdash;this error occurs.</source>
          <target state="translated">는 IF &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/user_agent&quot;&gt;사용자 에이전트는&lt;/a&gt; 이 지정된 값 검출 할 수 헤더-에도 헤더가 포함되어 적 반응이 오류가 발생한다.</target>
        </trans-unit>
        <trans-unit id="37fea5e541c03ceff1dd1b298e2c8a47aff43276" translate="yes" xml:space="preserve">
          <source>If the CORS configuration isn't setup correctly, the browser console will present an error like &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; indicating that the request was blocked due to violating the CORS security rules. This might not necessarily be a set-up mistake, though. It's possible that the request is in fact intentionally being disallowed by the user's web application and remote external service. However, If the endpoint is meant to be available, some debugging is needed to succeed.</source>
          <target state="translated">CORS 구성이 올바르게 설정되지 않은 경우 브라우저 콘솔은 &lt;code&gt;&quot;Cross-Origin Request Blocked: The Same Origin Policy disallows reading the remote resource at $somesite&quot;&lt;/code&gt; 수 없습니다 &quot; 와 같은 오류를 표시하여 CORS 보안 위반으로 인해 요청이 차단되었음을 나타냅니다. 규칙. 그러나 이것은 반드시 설정 실수가 아닐 수도 있습니다. 요청이 사용자의 웹 응용 프로그램 및 원격 외부 서비스에 의해 의도적으로 허용되지 않을 수 있습니다. 그러나 엔드 포인트를 사용할 수있게하려면 일부 디버깅이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="dc9c7b7249ed9c2cd26babda62bc7a605dd20286" translate="yes" xml:space="preserve">
          <source>If the CORS request indicated by the preflight request is authorized, the server will respond to the preflight request with a message that indicates the allowed origin, methods and headers. Below we see that &lt;a href=&quot;access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; includes the headers that were requested.</source>
          <target state="translated">실행 전 요청에 표시된 CORS 요청이 승인되면 서버는 허용 된 출처, 방법 및 헤더를 나타내는 메시지로 실행 전 요청에 응답합니다. 아래에서 &lt;a href=&quot;access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; 에는 요청 된 헤더가 포함되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8ffab7457821dbf47b42281a4936c9c518bf014" translate="yes" xml:space="preserve">
          <source>If the attribute is set to lax, same-site cookies are withheld on cross-domain subrequests, such as calls to load images or frames, but will be sent when a user naviates to the URL from an external site, for example, by following a link.</source>
          <target state="translated">이 속성이 lax로 설정되면 이미지 또는 프레임로드 호출과 같은 교차 도메인 하위 요청에서 동일한 사이트 쿠키가 보류되지만 사용자가 외부 사이트에서 URL로 이동하면 다음과 같이 전송됩니다. 링크.</target>
        </trans-unit>
        <trans-unit id="5d7a35532093cac38ce9488b4579d2ba232c9fa7" translate="yes" xml:space="preserve">
          <source>If the client has performed a conditional GET request and access is
   allowed, but the document has not been modified, the server SHOULD
   respond with this status code. The 304 response MUST NOT contain a
   message-body, and thus is always terminated by the first empty line
   after the header fields.

   The response MUST include the following header fields:

      - Date, unless its omission is required by &lt;a href=&quot;#section-14.18.1&quot;&gt;section 14.18.1&lt;/a&gt; 

   If a clockless origin server obeys these rules, and proxies and
   clients add their own Date to any response received without one (as
   already specified by &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], section&amp;nbsp;14.19&lt;/a&gt;), caches will operate
   correctly.

      - ETag and/or Content-Location, if the header would have been sent
        in a 200 response to the same request

      - Expires, Cache-Control, and/or Vary, if the field-value might
        differ from that sent in any previous response for the same
        variant

   If the conditional GET used a strong cache validator (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt;), the response SHOULD NOT include other entity-headers.
   Otherwise (i.e., the conditional GET used a weak validator), the
   response MUST NOT include other entity-headers; this prevents
   inconsistencies between cached entity-bodies and updated headers.

   If a 304 response indicates an entity not currently cached, then the
   cache MUST disregard the response and repeat the request without the
   conditional.

   If a cache uses a received 304 response to update a cache entry, the
   cache MUST update the entry to reflect any new field values given in
   the response.</source>
          <target state="translated">클라이언트가 조건부 GET 요청을 수행하고 액세스가 허용되었지만 문서가 수정되지 않은 경우 서버는이 상태 코드로 응답해야합니다. 304 응답은 메시지 본문을 포함해서는 안되므로 헤더 필드 다음의 첫 번째 빈 줄로 항상 종료됩니다. 응답은 반드시 다음 헤더 필드를 포함해야한다 : &lt;a href=&quot;#section-14.18.1&quot;&gt;-14.18.1 절에서&lt;/a&gt; 누락이 요구되지 않는 한, 날짜 시계 없는 오리진 서버가 이러한 규칙을 준수하고 프록시와 클라이언트가 하나의 요청없이 이미 수신 한 응답에 고유 한 날짜를 추가 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068#section-14.19&quot;&gt;[RFC 2068], 섹션 14.19&lt;/a&gt;) 캐시가 올바르게 작동합니다. -헤더가 동일한 요청에 대해 200 응답으로 전송 된 경우 ETag 및 / 또는 Content-Location-필드 값이 이전 응답에서 전송 된 값과 다를 수있는 경우 만료, 캐시 제어 및 / 또는 가변 동일한 변형의 경우 조건부 GET이 강력한 캐시 검사기를 사용한 경우 ( &lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-13.3.3&quot;&gt;13.3.3&lt;/a&gt; 참조))에 응답에는 다른 엔터티 헤더가 포함되어서는 안됩니다. 그렇지 않으면 (즉, 조건부 GET이 약한 유효성 검사기를 사용) 응답에는 다른 엔터티 헤더가 포함되어서는 안됩니다. 이렇게하면 캐시 된 엔터티 본문과 업데이트 된 헤더 간의 불일치가 방지됩니다. 304 응답이 현재 캐시되지 않은 엔티티를 나타내는 경우, 캐시는 응답을 무시하고 조건없이 요청을 반복해야합니다. 캐시가 수신 된 304 응답을 사용하여 캐시 항목을 업데이트하는 경우 캐시는 응답에 제공된 새로운 필드 값을 반영하도록 항목을 업데이트해야합니다.</target>
        </trans-unit>
        <trans-unit id="1b16cb43ac59e1398b6bbb6871dcb2c0b0c8621f" translate="yes" xml:space="preserve">
          <source>If the client receiving the &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; response is willing and able to upgrade to TLS, it should then start the same process covered above under &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;Client-initiated upgrade to TLS&lt;/a&gt;.</source>
          <target state="translated">수신 클라이언트 경우 &lt;code&gt;&quot;426 Upgrade Required&quot;&lt;/code&gt; 응답이 TLS로 업그레이드 할 의사와 능력, 그것은 다음 아래 위에 덮여 같은 프로세스 시작해야 &lt;a href=&quot;#Client-initiated_upgrade_to_TLS&quot;&gt;TLS에 대한 클라이언트 시작 업그레이드&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="280f043319dde7fe251e1850244792cbea213b6e" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data.</source>
          <target state="translated">데이터가 텍스트 인 경우 텍스트를 포함 할 수 있습니다 (동봉 문서 유형에 따라 적절한 엔티티 또는 이스케이프 사용). 그렇지 않으면 base64로 인코딩 된 이진 데이터를 포함하도록 &lt;code&gt;base64&lt;/code&gt; 를 지정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="32b1f46a0b7b90a86ae9e9f167e9ef7cf8038c9c" translate="yes" xml:space="preserve">
          <source>If the data is textual, you can simply embed the text (using the appropriate entities or escapes based on the enclosing document's type). Otherwise, you can specify &lt;code&gt;base64&lt;/code&gt; to embed base64-encoded binary data. You can find more info on MIME types &lt;a href=&quot;mime_types&quot;&gt;here&lt;/a&gt; and &lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">데이터가 텍스트 인 경우 텍스트를 포함하기 만하면됩니다 (포함하는 문서의 유형에 따라 적절한 엔티티 또는 이스케이프 사용). 그렇지 않으면 &lt;code&gt;base64&lt;/code&gt; 를 지정 하여 base64로 인코딩 된 이진 데이터를 포함 할 수 있습니다 . 당신은 MIME 유형에 대한 자세한 정보를 찾을 수 있습니다 &lt;a href=&quot;mime_types&quot;&gt;여기에&lt;/a&gt; 와&lt;a href=&quot;mime_types/complete_list_of_mime_types&quot;&gt; 여기&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8559d1d219606090271c33a621201ee02497f80" translate="yes" xml:space="preserve">
          <source>If the desired resource width is not known at the time of the request or the resource does not have a display width, the &lt;code&gt;Width&lt;/code&gt; header field can be omitted. If &lt;code&gt;Width&lt;/code&gt; occurs in a message more than once, the last value overrides all previous occurrences</source>
          <target state="translated">요청시 원하는 리소스 너비를 알 수 없거나 리소스에 표시 너비가없는 경우 &lt;code&gt;Width&lt;/code&gt; 헤더 필드를 생략 할 수 있습니다. 만약 &lt;code&gt;Width&lt;/code&gt; 두 번 이상 메시지가 발생, 마지막 값은 이전의 모든 항목을 오버라이드 (override)</target>
        </trans-unit>
        <trans-unit id="c18b5decb40c51cfed52abf66cbdc2d7b99ae4e9" translate="yes" xml:space="preserve">
          <source>If the device is large enough that it's not marked with &amp;ldquo;Mobi&amp;rdquo;, you should serve your desktop site (which, as a best practice, should support touch input anyway, as more desktop machines are appearing with touchscreens).</source>
          <target state="translated">장치가 &quot;Mobi&quot;로 표시되지 않을 정도로 충분히 큰 경우 데스크톱 사이트를 제공해야합니다 (터치 스크린으로 더 많은 데스크톱 컴퓨터가 표시되므로 가장 좋은 방법은 터치 입력을 지원해야 함).</target>
        </trans-unit>
        <trans-unit id="0bbaf264d9f0d932c54c0e04e65ebace7f115760" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">해시가 일치하지 않으면 문서가 중간에 편집되었으며 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Precondition Failed&lt;/code&gt; 오류가 발생 했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="277939955257bc43f4243fef87536e0654d15a25" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;../status/412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">해시가 일치하지 않으면 문서가 중간에 편집되었으며 &lt;a href=&quot;../status/412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 오류가 발생 했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3fd651b3de41c4c0939b139c2bcd1ec691c3efd5" translate="yes" xml:space="preserve">
          <source>If the hashes don't match, it means that the document has been edited in-between and a &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt; error is thrown.</source>
          <target state="translated">해시가 일치하지 않으면 문서가 중간에 편집되었으며 &lt;a href=&quot;412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 오류가 발생 했음을 의미합니다 .</target>
        </trans-unit>
        <trans-unit id="3bde6b2f02854c6b43c647e825f2d4a1429eb84b" translate="yes" xml:space="preserve">
          <source>If the request is being issued using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, make sure you're not setting &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt;&lt;code&gt;withCredentials&lt;/code&gt;&lt;/a&gt; to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를&lt;/a&gt; 사용하여 요청이 발행되는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials&quot;&gt; &lt;code&gt;withCredentials&lt;/code&gt; &lt;/a&gt; 를 &lt;code&gt;true&lt;/code&gt; 로 설정하지 않았는지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="7f1a69e15b2780621067297dd234a0594b2b2ffc" translate="yes" xml:space="preserve">
          <source>If the requested method isn't supported, the server will respond with an error.</source>
          <target state="translated">요청 된 메소드가 지원되지 않으면 서버는 오류로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="bd63754e6e7fd0ed5e66293b22c5760094fd4fcf" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value &lt;em&gt;must&lt;/em&gt; be generated. A comparison of them can determine whether two representations of a resource are the same. Etags are therefore similar to fingerprints, and might also be used for tracking purposes by some servers. They might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">주어진 URL의 리소스가 변경되면 새 &lt;code&gt;Etag&lt;/code&gt; 값 &lt;em&gt;을&lt;/em&gt; 생성 &lt;em&gt;해야&lt;/em&gt; 합니다. 이들을 비교하면 자원의 두 표현이 동일한 지 여부를 판별 할 수 있습니다. 따라서 Etag는 지문과 유사하며 일부 서버에서 추적 목적으로도 사용될 수 있습니다. 추적 서버에서 무기한 유지하도록 설정할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="e618a8054c6dfe27daf59e1f19b56a3219ec450e" translate="yes" xml:space="preserve">
          <source>If the resource at a given URL changes, a new &lt;code&gt;Etag&lt;/code&gt; value must be generated. Etags are therefore similar to fingerprints and might also be used for tracking purposes by some servers. A comparison of them allows to quickly determine whether two representations of a resource are the same, but they might also be set to persist indefinitely by a tracking server.</source>
          <target state="translated">지정된 URL의 리소스가 변경되면 새로운 &lt;code&gt;Etag&lt;/code&gt; 값을 생성해야합니다. 따라서 전자 태그는 지문과 유사하며 일부 서버에서 추적 목적으로 사용될 수도 있습니다. 이들을 비교하면 리소스의 두 표현이 동일한 지 여부를 신속하게 확인할 수 있지만 추적 서버에 의해 무기한 지속되도록 설정 될 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="6df0a809ea7c0e16c3b4c1d61decdfe31ac868f4" translate="yes" xml:space="preserve">
          <source>If the resource has changed, the server just sends back a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt; OK&lt;/code&gt; response, with the new version of the resource, like if the request wasn't conditional and the client uses this new resource (and caches it).</source>
          <target state="translated">리소스가 변경된 경우, 서버 는 요청이 조건이없고 클라이언트가이 새 리소스를 사용하고 캐시하는 경우와 같이 새 버전의 리소스와 함께 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt; OK&lt;/code&gt; 응답을 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="28dabd823abd95eebd0c73b38250e390477657ad" translate="yes" xml:space="preserve">
          <source>If the resource has not changed, the server sends back a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; response. This makes the cache fresh again, and the client uses the cached resource. Although there is a response/request round-trip that consumes some resources, this is more efficient than to transmit the whole resource over the wire again.</source>
          <target state="translated">자원이 변경되지 않은 경우 서버는 &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; 응답을 다시 보냅니다 . 이렇게하면 캐시가 다시 최신 상태가되고 클라이언트는 캐시 된 리소스를 사용합니다. 일부 리소스를 사용하는 응답 / 요청 왕복이 있지만 전체 리소스를 다시 전송하는 것보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="96d3b1fd891c66341051bdd2445935c9e27b47b5" translate="yes" xml:space="preserve">
          <source>If the resource in question is meant to be widely accessed (just like any HTTP resource accessed by GET), then sending back the &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: *&lt;/code&gt; header will be sufficient, &lt;strong&gt;unless&lt;/strong&gt; the resource needs credentials such as &lt;a href=&quot;cookies&quot;&gt;Cookies&lt;/a&gt; and HTTP Authentication information.</source>
          <target state="translated">문제의 리소스가 GET에 의해 액세스 된 HTTP 리소스와 같이 널리 액세스되도록 의도 된 경우 리소스에 &lt;a href=&quot;cookies&quot;&gt;쿠키&lt;/a&gt; 및 HTTP 와 같은 자격 증명이 필요 &lt;strong&gt;하지 않은 경우 &lt;/strong&gt;&lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: *&lt;/code&gt; 헤더를 다시 보내는 것으로 충분합니다. 인증 정보.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5afbe977f3fe9a82606049c55808c60ca15cfb67" translate="yes" xml:space="preserve">
          <source>If the resource should be kept restricted based on requester domain, &lt;strong&gt;OR&lt;/strong&gt; if the resource needs to be accessed with credentials (or sets credentials), then filtering by the request's &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header may be necessary, or at least echoing back the requester's &lt;code&gt;Origin&lt;/code&gt; (e.g. &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt;). Additionally, the &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: true&lt;/code&gt; header will have to be sent. This is discussed in a &lt;a href=&quot;#Credentialed_Requests&quot;&gt;subsequent section&lt;/a&gt;.</source>
          <target state="translated">자원이 보관 제한 요청 도메인을 기반으로해야하는 경우, &lt;strong&gt;또는&lt;/strong&gt; 자원 요구가 자격 증명 (또는 세트 자격 증명)에 액세스 할 경우, 그 요청의 의해 필터링 &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 필요가있다 헤더, 또는 적어도 다시 요청자의 메아리 &lt;code&gt;Origin&lt;/code&gt; (예 : &lt;a href=&quot;headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: &lt;a href=&quot;http://arunranga.com&quot;&gt;http://arunranga.com&lt;/a&gt;&lt;/code&gt; ). 또한 &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: true&lt;/code&gt; 헤더를 보내야합니다. 이에 대해서는 &lt;a href=&quot;#Credentialed_Requests&quot;&gt;다음 섹션&lt;/a&gt; 에서 설명 합니다 .</target>
        </trans-unit>
        <trans-unit id="9c8e2ffc70a619ab233773bc1539c19cb10a2bc1" translate="yes" xml:space="preserve">
          <source>If the response to a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached URL response is now outdated, the cached copy is invalidated even if no &lt;code&gt;GET&lt;/code&gt; request was made.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 요청에 대한 응답에 캐시 된 URL 응답이 현재 만료되었다고 표시되면 &lt;code&gt;GET&lt;/code&gt; 요청이 생성 되지 않은 경우에도 캐시 된 복사본이 무효화됩니다 .</target>
        </trans-unit>
        <trans-unit id="85a622ab8c535a47b0b491a95d39cc072896a324" translate="yes" xml:space="preserve">
          <source>If the result of a &lt;code&gt;HEAD&lt;/code&gt; request shows that a cached resource after a &lt;a href=&quot;get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request is now outdated, the cache is invalidated, even if no &lt;code&gt;GET&lt;/code&gt; request has been made.</source>
          <target state="translated">&lt;code&gt;HEAD&lt;/code&gt; 요청 결과에 &lt;a href=&quot;get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청 이후 캐시 된 자원 이 이제 오래 되었다고 표시 되면 &lt;code&gt;GET&lt;/code&gt; 요청이 수행 되지 않은 경우에도 캐시가 무효화 됩니다.</target>
        </trans-unit>
        <trans-unit id="8883378b1d0c73e1288f1ade4a8139bb08b162fd" translate="yes" xml:space="preserve">
          <source>If the selection of the best representation for a response is made by
   an algorithm located at the server, it is called server-driven
   negotiation. Selection is based on the available representations of
   the response (the dimensions over which it can vary; e.g. language,
   content-coding, etc.) and the contents of particular header fields in
   the request message or on other information pertaining to the request
   (such as the network address of the client).

   Server-driven negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to the user agent, or when the server desires to send its
   &quot;best guess&quot; to the client along with the first response (hoping to
   avoid the round-trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user). In order to improve the server's
   guess, the user agent MAY include request header fields (Accept,
   Accept-Language, Accept-Encoding, etc.) which describe its
   preferences for such a response.

   Server-driven negotiation has disadvantages:

      1. It is impossible for the server to accurately determine what
         might be &quot;best&quot; for any given user, since that would require
         complete knowledge of both the capabilities of the user agent
         and the intended use for the response (e.g., does the user want
         to view it on screen or print it on paper?).

      2. Having the user agent describe its capabilities in every
         request can be both very inefficient (given that only a small
         percentage of responses have multiple representations) and a
         potential violation of the user's privacy.

      3. It complicates the implementation of an origin server and the
         algorithms for generating responses to a request. 

      4. It may limit a public cache's ability to use the same response
         for multiple user's requests.

   HTTP/1.1 includes the following request-header fields for enabling
   server-driven negotiation through description of user agent
   capabilities and user preferences: Accept (&lt;a href=&quot;#section-14.1&quot;&gt;section 14.1&lt;/a&gt;), Accept-
   Charset (&lt;a href=&quot;#section-14.2&quot;&gt;section 14.2&lt;/a&gt;), Accept-Encoding (&lt;a href=&quot;#section-14.3&quot;&gt;section 14.3&lt;/a&gt;), Accept-
   Language (&lt;a href=&quot;#section-14.4&quot;&gt;section 14.4&lt;/a&gt;), and User-Agent (&lt;a href=&quot;#section-14.43&quot;&gt;section 14.43&lt;/a&gt;). However, an
   origin server is not limited to these dimensions and MAY vary the
   response based on any aspect of the request, including information
   outside the request-header fields or within extension header fields
   not defined by this specification.

   The Vary  header field can be used to express the parameters the
   server uses to select a representation that is subject to server-
   driven negotiation. See &lt;a href=&quot;#section-13.6&quot;&gt;section 13.6&lt;/a&gt; for use of the Vary header field
   by caches and &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header field by
   servers.</source>
          <target state="translated">응답에 대한 최상의 표현 선택이 서버에있는 알고리즘에 의해 수행되는 경우이를 서버 중심 협상이라고합니다. 선택은 응답의 사용 가능한 표현 (예 : 언어, 컨텐츠 코딩 등의 다양한 차원) 및 요청 메시지의 특정 헤더 필드 내용 또는 요청과 관련된 기타 정보 (예 : 클라이언트의 네트워크 주소로). 사용 가능한 표현 중에서 선택하기위한 알고리즘이 사용자 에이전트에 설명하기 어렵거나 서버가 첫 번째 응답과 함께 &quot;최상의 추측&quot;을 클라이언트에 보내려고 할 때 서버 중심 협상이 유리합니다. &quot;최상의 추측&quot;인 경우 후속 요청의 왕복 지연사용자에게 충분합니다). 서버의 추측을 향상시키기 위해, 사용자 에이전트는 그러한 응답에 대한 선호도를 기술하는 요청 헤더 필드 (Accept, Accept-Language, Accept-Encoding 등)를 포함 할 수있다. 서버 중심 협상에는 다음과 같은 단점이 있습니다. 1. 사용자 에이전트의 기능과 응답의 의도 된 사용에 대한 완전한 지식이 필요하기 때문에 서버가 특정 사용자에게 &quot;최상의&quot;항목을 정확하게 결정하는 것은 불가능합니다. (예 : 사용자가 화면에서 보거나 종이에 인쇄하겠습니까?). 2.사용자 에이전트가 모든 요청에서 해당 기능을 설명하도록하는 것은 매우 비효율적 일 수 있으며 (소수의 응답 만 여러 표현으로 표시됨) 사용자의 개인 정보를 침해 할 가능성이 있습니다. 3. 원 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘을 복잡하게 만듭니다. 4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공개 캐시 기능을 제한 할 수 있습니다. HTTP / 1.1에는 사용자 에이전트 기능 및 사용자 환경 설정에 대한 설명을 통해 서버 중심 협상을 가능하게하는 다음 요청 헤더 필드가 포함되어 있습니다. 수락 (4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공개 캐시 기능을 제한 할 수 있습니다. HTTP / 1.1에는 사용자 에이전트 기능 및 사용자 환경 설정에 대한 설명을 통해 서버 중심 협상을 가능하게하는 다음 요청 헤더 필드가 포함되어 있습니다. 수락 (4. 여러 사용자의 요청에 대해 동일한 응답을 사용하는 공개 캐시 기능을 제한 할 수 있습니다. HTTP / 1.1에는 사용자 에이전트 기능 및 사용자 환경 설정에 대한 설명을 통해 서버 중심 협상을 가능하게하는 다음 요청 헤더 필드가 포함되어 있습니다. 수락 (&lt;a href=&quot;#section-14.1&quot;&gt;섹션 14.1&lt;/a&gt; ), 수락- 문자셋 ( &lt;a href=&quot;#section-14.2&quot;&gt;섹션 14.2&lt;/a&gt; ), 수락-인코딩 ( &lt;a href=&quot;#section-14.3&quot;&gt;섹션 14.3&lt;/a&gt; ), 수락- 언어 ( &lt;a href=&quot;#section-14.4&quot;&gt;섹션 14.4&lt;/a&gt; ) 및 사용자 에이전트 ( &lt;a href=&quot;#section-14.43&quot;&gt;섹션 14.43&lt;/a&gt; ). 그러나 오리진 서버는 이러한 차원으로 제한되지 않으며 요청 헤더 필드 외부 또는이 사양에서 정의하지 않은 확장 헤더 필드 내의 정보를 포함하여 요청의 모든 측면에 따라 응답을 변경할 수 있습니다. Vary 헤더 필드는 서버가 서버 기반 협상의 대상이되는 표현을 선택하기 위해 서버가 사용하는 매개 변수를 표현하는 데 사용할 수 있습니다. 캐시에 의한 Vary 헤더 필드 사용 및 &lt;a href=&quot;#section-14.44&quot;&gt;섹션 14.44&lt;/a&gt; 는 &lt;a href=&quot;#section-13.6&quot;&gt;섹션 13.6&lt;/a&gt; 을 참조하십시오. 서버에서 Vary 헤더 필드를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a97009ed5a171d3f2d00627248f02de9b1bd4edb" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does not&lt;/em&gt; support TLS upgrade, or is unable to upgrade to TLS at the time, it responds with a standard HTTP/1.1 response, such as:</source>
          <target state="translated">서버 &lt;em&gt;가&lt;/em&gt; TLS 업그레이드를 지원 &lt;em&gt;하지 않거나&lt;/em&gt; 당시 TLS로 업그레이드 할 수없는 경우 다음과 같은 표준 HTTP / 1.1 응답으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="2c4956e2baa89a364f68e36f2540d46e391032b0" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; recognize the method, but intentionally does not support it, the appropriate response is &lt;a href=&quot;405&quot;&gt;&lt;code&gt;405 Method Not Allowed&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서버 &lt;em&gt;가&lt;/em&gt; 방법을 인식하지만 의도적으로 지원하지 않는 경우 적절한 응답은 &lt;a href=&quot;405&quot;&gt; &lt;code&gt;405 Method Not Allowed&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="5b4ec0bc4d37ddaf3aac7f70b029b83445ca56f2" translate="yes" xml:space="preserve">
          <source>If the server &lt;em&gt;does&lt;/em&gt; support TLS upgrade and wishes to permit the upgrade, it responds with the &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; response code, like this:</source>
          <target state="translated">서버 &lt;em&gt;가&lt;/em&gt; TLS 업그레이드를 지원하고 업그레이드를 허용하려는 경우 다음 과 같이 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 응답 코드로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="a57f9acb3600d5372bf47b96b972a2c0b7a106b1" translate="yes" xml:space="preserve">
          <source>If the server allows CORS requests to use the &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; method, it responds with an &lt;a href=&quot;access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt; response header, which lists &lt;code&gt;DELETE&lt;/code&gt; along with the other methods it supports:</source>
          <target state="translated">서버가 CORS 요청이 &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 메소드 를 사용하도록 &lt;a href=&quot;access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 하는 경우 &lt;code&gt;DELETE&lt;/code&gt; 가 지원하는 다른 메소드와 함께 DELETE 를 나열 하는 Access-Control-Allow-Methods 응답 헤더로 응답 합니다.</target>
        </trans-unit>
        <trans-unit id="be2369485a151abd59881e4ba1cc5463e20c789a" translate="yes" xml:space="preserve">
          <source>If the server can't communicate using the specified version of the WebSocket protocol, it will respond with an error (such as 426 Upgrade Required) that includes in its headers a &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header with a comma-separated list of the supported protocol versions. If the server does support the requested protocol version, no &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; header is included in the response.</source>
          <target state="translated">서버가 지정된 버전의 WebSocket 프로토콜을 사용하여 통신 할 수없는 경우 쉼표로 구분 된 지원되는 목록 이 포함 된 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 헤더를 헤더에 포함하는 오류 (예 : 426 업그레이드 필요)로 응답 합니다. 프로토콜 버전. 서버가 요청한 프로토콜 버전을 지원하는 경우 &lt;code&gt;Sec-WebSocket-Version&lt;/code&gt; 헤더가 응답에 포함되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="8bfc654fb667ab7a47e06dc70b7def2a7620c972" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any character encoding from this request header, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406 Not Acceptable&lt;/code&gt;&lt;/a&gt; error code. But for a better user experience, this is rarely done and the &lt;code&gt;Accept-Charset&lt;/code&gt; header is ignored.</source>
          <target state="translated">서버가이 요청 헤더에서 문자 인코딩을 제공 할 수없는 경우 이론적으로 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406 Not Acceptable&lt;/code&gt; &lt;/a&gt; 오류 코드를 다시 보낼 수 있습니다 . 그러나 더 나은 사용자 경험을 위해 이것은 거의 수행되지 않으며 &lt;code&gt;Accept-Charset&lt;/code&gt; 헤더가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="ae753ebfa7e739c1ebf4391f5ee391f4e94ee3ce" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching character set, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and the more common way is to ignore the &lt;code&gt;Accept-Charset&lt;/code&gt; header in this case.</source>
          <target state="translated">서버가 일치하는 문자 세트를 제공 할 수없는 경우 이론적으로 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (Not Acceptable) 오류 코드를 다시 보낼 수 있습니다 . 그러나 더 나은 사용자 환경을 위해이 작업은 거의 수행되지 &lt;code&gt;Accept-Charset&lt;/code&gt; 경우 Accept-Charset 헤더 를 무시하는 것이 더 일반적인 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="d8ca646db299a164f8eaec324da4187a3dc7c934" translate="yes" xml:space="preserve">
          <source>If the server cannot serve any matching language, it can theoretically send back a &lt;a href=&quot;../status/406&quot;&gt;&lt;code&gt;406&lt;/code&gt;&lt;/a&gt; (Not Acceptable) error code. But, for a better user experience, this is rarely done and more common way is to ignore the &lt;code&gt;Accept-Language&lt;/code&gt; header in this case.</source>
          <target state="translated">서버가 일치하는 언어를 제공 할 수없는 경우 이론적으로 &lt;a href=&quot;../status/406&quot;&gt; &lt;code&gt;406&lt;/code&gt; &lt;/a&gt; (Not Acceptable) 오류 코드를 다시 보낼 수 있습니다 . 그러나 더 나은 사용자 환경을 위해이 작업은 거의 수행되지 않으며이 경우 &lt;code&gt;Accept-Language&lt;/code&gt; 헤더 를 무시하는 것이 더 일반적인 방법입니다 .</target>
        </trans-unit>
        <trans-unit id="5785d405909bd735e16eff8d00e42ade5e8499d9" translate="yes" xml:space="preserve">
          <source>If the server decides to upgrade the connection, it sends back a &lt;a href=&quot;status/101&quot;&gt;&lt;code&gt;101 Switching Protocols&lt;/code&gt;&lt;/a&gt; response status with an Upgrade header that specifies the protocol(s) being switched to. If it does not (or cannot) upgrade the connection, it ignores the &lt;code&gt;Upgrade&lt;/code&gt; header and sends back a regular response (for example, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200 OK&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">서버가 연결을 업그레이드하기로 결정하면 &lt;a href=&quot;status/101&quot;&gt; &lt;code&gt;101 Switching Protocols&lt;/code&gt; &lt;/a&gt; 을 지정하는 Upgrade 헤더와 함께 101 Switching Protocols 응답 상태를 다시 보냅니다 . 연결을 업그레이드하지 않거나 업그레이드 할 수없는 경우 &lt;code&gt;Upgrade&lt;/code&gt; 헤더를 무시하고 일반 응답 (예 : &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200 OK&lt;/code&gt; &lt;/a&gt; )을 다시 보냅니다. )을 .</target>
        </trans-unit>
        <trans-unit id="4d3214eaff9a427b272921bccd27c1fd179422db" translate="yes" xml:space="preserve">
          <source>If the server has a preferred choice, it should generate a &lt;a href=&quot;../headers/location&quot;&gt;&lt;code&gt;Location&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">서버가 원하는 것을 선택하면 &lt;a href=&quot;../headers/location&quot;&gt; &lt;code&gt;Location&lt;/code&gt; &lt;/a&gt; 헤더를 생성해야합니다 .</target>
        </trans-unit>
        <trans-unit id="e05c84402fda441286aba0b966f3789dbf6191c3" translate="yes" xml:space="preserve">
          <source>If the server is unable to switch to HTTP/2 for any reason, it will reply with a standard HTTP/1 reply after handling the request as normal. So if the request was to fetch a web page which does in fact exist, you would get a standard &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; response with the web page following the remainder of the header. If the server is able to switch to HTTP/2, a &quot;&lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; response is sent, which will look like this:</source>
          <target state="translated">어떤 이유로 든 서버가 HTTP / 2로 전환 할 수없는 경우 요청을 정상적으로 처리 한 후 표준 HTTP / 1 응답으로 응답합니다. 따라서 요청이 실제로 존재하는 웹 페이지를 가져 오려면 나머지 헤더 다음에 웹 페이지에 대한 표준 &lt;code&gt;&quot;HTTP/1.1 200 OK&quot;&lt;/code&gt; 응답이 표시됩니다. 서버가 HTTP / 2로 전환 할 수있는 경우 &quot; &lt;code&gt;HTTP/1.1 101 Switching Protocols&quot;&lt;/code&gt; 응답이 전송되며 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="b5c0cece345dde55b15ad1ad49b64cab5f6ed8d2" translate="yes" xml:space="preserve">
          <source>If the server is under your control, add the origin of the requesting site to the set of domains permitted access by adding it to the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header's value.</source>
          <target state="translated">서버가 제어 할 수있는 경우 요청 사이트의 원점을 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더 값 에 추가하여 액세스가 허용 된 도메인 세트에 추가하십시오 .</target>
        </trans-unit>
        <trans-unit id="62963ebedd2ff72d3bb4b415143d2ac0443881d2" translate="yes" xml:space="preserve">
          <source>If the server sends a response with an &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; value that is an explicit origin (rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard), then the response should also include a &lt;a href=&quot;vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header with the value &lt;code&gt;Origin&lt;/code&gt; &amp;mdash; to indicate to browsers that server responses can differ based on the value of the &lt;code&gt;Origin&lt;/code&gt; request header.</source>
          <target state="translated">서버가있는 응답을 보내는 경우 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; (오히려 &quot;보다 명시 적 기원 값 &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드), 다음 응답도 포함해야 &lt;a href=&quot;vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 값과 응답 헤더 &lt;code&gt;Origin&lt;/code&gt; - 브라우저에 표시하기 서버 응답은 &lt;code&gt;Origin&lt;/code&gt; 요청 헤더 의 값에 따라 다를 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="40ae9d31a1c63c02ebcd60debd2f8b97d5dd7ac9" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin (that may dynamically change based on the requesting origin as part of a white-list) rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">서버가 &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드가 아닌 단일 출처 (요청 출처에 따라 화이트리스트의 일부로 동적으로 변경 될 수 있음)를 지정하는 경우 서버는 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 응답 헤더 에도 &lt;code&gt;Origin&lt;/code&gt; 을 포함 하여 클라이언트에 표시해야합니다. 서버 응답은 &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 요청 헤더 의 값에 따라 다릅니다 .</target>
        </trans-unit>
        <trans-unit id="035b5ed82a9b1755b686239ae88f8e1ef4f77e51" translate="yes" xml:space="preserve">
          <source>If the server specifies a single origin rather than the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard, then the server should also include &lt;code&gt;Origin&lt;/code&gt; in the &lt;a href=&quot;headers/vary&quot;&gt;&lt;code&gt;Vary&lt;/code&gt;&lt;/a&gt; response header &amp;mdash; to indicate to clients that server responses will differ based on the value of the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; request header.</source>
          <target state="translated">서버가 &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드가 아닌 단일 오리진을 지정하는 경우 서버는 서버 응답이 &lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 요청 헤더 의 값에 따라 다르다는 것을 클라이언트에게 알리기 위해 &lt;a href=&quot;headers/vary&quot;&gt; &lt;code&gt;Vary&lt;/code&gt; &lt;/a&gt; 응답 헤더에 &lt;code&gt;Origin&lt;/code&gt; 을 포함해야합니다 .</target>
        </trans-unit>
        <trans-unit id="bdd4b87fdc6a81c461da6befd7c1928bb2e1a6e5" translate="yes" xml:space="preserve">
          <source>If the server supports range requests, you can issue such a request by using the &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; header. It indicates the part(s) of a document that the server should return.</source>
          <target state="translated">서버가 범위 요청을 지원하는 경우 &lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; 헤더 를 사용하여 이러한 요청을 발행 할 수 있습니다 . 서버가 반환해야하는 문서의 일부를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="6199750daad48ff639691648a086a49c0a3fd0a7" translate="yes" xml:space="preserve">
          <source>If the server wishes a faster Web site or application response, it is possible for the server to force the opening of more connections. For example, Instead of having all resources on the same domain, say &lt;code&gt;www.example.com&lt;/code&gt;, it could split over several domains, &lt;code&gt;www1.example.com&lt;/code&gt;, &lt;code&gt;www2.example.com&lt;/code&gt;, &lt;code&gt;www3.example.com&lt;/code&gt;. Each of these domains resolve to the &lt;em&gt;same&lt;/em&gt; server, and the Web browser will open 6 connections to each (in our example, boosting the connections to 18). This technique is called &lt;em&gt;domain sharding&lt;/em&gt;.</source>
          <target state="translated">서버가 더 빠른 웹 사이트 또는 응용 프로그램 응답을 원하는 경우 서버가 더 많은 연결을 강제로 열 수 있습니다. 예를 들어, 대신 같은 도메인에 모든 자원을 필요없이 말할 &lt;code&gt;www.example.com&lt;/code&gt; 가 여러 도메인에 걸쳐 분할 수 &lt;code&gt;www1.example.com&lt;/code&gt; , &lt;code&gt;www2.example.com&lt;/code&gt; , &lt;code&gt;www3.example.com&lt;/code&gt; 을 . 이러한 각 도메인은 &lt;em&gt;동일한&lt;/em&gt; 서버로 확인되며 웹 브라우저는 각각 6 개의 연결을 엽니 다 (이 예에서는 연결을 18로 증가). 이 기술을 &lt;em&gt;도메인 샤딩&lt;/em&gt; 이라고 &lt;em&gt;합니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="633be8e65041e6f678ba0a69d47e73981a12258e" translate="yes" xml:space="preserve">
          <source>If the service your code is accessing using a CORS request is under your control, make sure that it's configured to include your origin in its &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, and that only one such header is included in responses. The header itself accepts a comma-delineated list of origins, so adding a new origin is not difficult.</source>
          <target state="translated">CORS 요청을 사용하여 코드가 액세스하는 서비스가 제어 할 경우, &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더에 오리진 을 포함하도록 구성되어 있고 해당 헤더 중 하나만 응답에 포함되어 있는지 확인하십시오 . 헤더 자체는 쉼표로 구분 된 원점 목록을 허용하므로 새 원점을 추가하는 것은 어렵지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d5f87d2c5913a57c8787a092105a04dbd9842ee7" translate="yes" xml:space="preserve">
          <source>If the string is null, no proxies should be used</source>
          <target state="translated">문자열이 null이면 프록시를 사용하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="ee70fc1642248dcddd5b4e8e2c3aa5e1fa8b3482" translate="yes" xml:space="preserve">
          <source>If the target resource does have a current representation and that representation is successfully modified in accordance with the state of the enclosed representation, then the origin server must send either a &lt;a href=&quot;../status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;OK&lt;/code&gt;) or a &lt;a href=&quot;../status/204&quot;&gt;&lt;code&gt;204&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;No Content&lt;/code&gt;) response to indicate successful completion of the request.</source>
          <target state="translated">대상 자원에 현재 표현이 있고 해당 표현이 동봉 된 표현의 상태에 따라 성공적으로 수정 된 경우, 오리진 서버 는 성공적인 완료를 표시하기 위해 &lt;a href=&quot;../status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;OK&lt;/code&gt; ) 또는 &lt;a href=&quot;../status/204&quot;&gt; &lt;code&gt;204&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;No Content&lt;/code&gt; ) 응답을 보내야합니다. 요청.</target>
        </trans-unit>
        <trans-unit id="2e56a40e542286dd3f5f24ab9d9b357b4b9363fa" translate="yes" xml:space="preserve">
          <source>If the target resource does not have a current representation and the &lt;code&gt;PUT&lt;/code&gt; request successfully creates one, then the origin server must inform the user agent by sending a &lt;a href=&quot;../status/201&quot;&gt;&lt;code&gt;201&lt;/code&gt;&lt;/a&gt; (&lt;code&gt;Created&lt;/code&gt;) response.</source>
          <target state="translated">대상 자원에 현재 표시가없고 &lt;code&gt;PUT&lt;/code&gt; 요청이 성공적으로 작성하면, 원 서버는 &lt;a href=&quot;../status/201&quot;&gt; &lt;code&gt;201&lt;/code&gt; &lt;/a&gt; ( &lt;code&gt;Created&lt;/code&gt; ) 응답 을 보내 사용자 에이전트에 알려야합니다 .</target>
        </trans-unit>
        <trans-unit id="a21b80ceb96b8a7d43dede98629becf487c2e6a3" translate="yes" xml:space="preserve">
          <source>If the upgrade to TLS succeeds, the server will respond with &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; as described in the previous section. If the upgrade fails, the HTTP/1.1 connection will fail.</source>
          <target state="translated">TLS 로의 업그레이드가 성공하면 서버는 이전 섹션에서 설명한대로 &lt;code&gt;&quot;101 Switching Protocols&quot;&lt;/code&gt; 로 응답 합니다. 업그레이드가 실패하면 HTTP / 1.1 연결이 실패합니다.</target>
        </trans-unit>
        <trans-unit id="27db56e6fbfb8552acb661ab2ec13d5567a5150c" translate="yes" xml:space="preserve">
          <source>If there are hosts (such as the main Web server) that belong to the local domain but are outside the firewall and are only reachable through the proxy server, those exceptions can be handled using the &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; function:</source>
          <target state="translated">로컬 도메인에 속하지만 방화벽 외부에 있고 프록시 서버를 통해서만 도달 할 수있는 호스트 (예 : 기본 웹 서버)가있는 경우 &lt;code&gt;localHostOrDomainIs()&lt;/code&gt; 함수를 사용하여 예외를 처리 할 수 ​​있습니다 .</target>
        </trans-unit>
        <trans-unit id="d24ef4f84cb249bfa31f9902d7ae003a91952701" translate="yes" xml:space="preserve">
          <source>If there are multiple semicolon-separated settings, the left-most setting will be used, until Firefox fails to establish the connection to the proxy. In that case, the next value will be used, etc.</source>
          <target state="translated">세미콜론으로 구분 된 설정이 여러 개인 경우 Firefox가 프록시에 연결하지 못할 때까지 가장 왼쪽에있는 설정이 사용됩니다. 이 경우 다음 값이 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d35d9172db4121106bcca6f82d93219ec641178d" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header</source>
          <target state="translated">다른 지시어가 지정되어 있으면 &lt;code&gt;default-src&lt;/code&gt; 는 영향을 미치지 않습니다. 다음 헤더</target>
        </trans-unit>
        <trans-unit id="f3a3fb9e88e16c02dae3ebc873862c5294ca1f14" translate="yes" xml:space="preserve">
          <source>If there are other directives specified, &lt;code&gt;default-src&lt;/code&gt; does not influence them. The following header:</source>
          <target state="translated">다른 지시문이 지정되어 있으면 &lt;code&gt;default-src&lt;/code&gt; 가 영향을주지 않습니다. 다음 헤더 :</target>
        </trans-unit>
        <trans-unit id="b6ef483d4374adee5323181a48fbe2db2ede05c8" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &quot;max-age&quot; or &quot;s-maxage&quot; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">응답에 &quot;max-age&quot;또는 &quot;s-maxage&quot;지시문 이있는 &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; 헤더 가 있으면 &lt;code&gt;Expires&lt;/code&gt; 헤더가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="3dc7a417b9985cacb686b59815968d89411858de" translate="yes" xml:space="preserve">
          <source>If there is a &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt; header with the &lt;code&gt;max-age&lt;/code&gt; or &lt;code&gt;s-maxage&lt;/code&gt; directive in the response, the &lt;code&gt;Expires&lt;/code&gt; header is ignored.</source>
          <target state="translated">응답에 &lt;code&gt;max-age&lt;/code&gt; 또는 &lt;code&gt;s-maxage&lt;/code&gt; 지시문 이있는 &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; 헤더가있는 경우 &lt;code&gt;Expires&lt;/code&gt; 헤더가 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="872be7b4525857f39211419c11efc3edbf6a5a96" translate="yes" xml:space="preserve">
          <source>If there is only one range, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; of the whole response is set to the type of the document, and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; is provided.</source>
          <target state="translated">범위가 하나만있는 경우 전체 응답 의 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 이 문서 유형으로 설정되고 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 가 제공됩니다.</target>
        </trans-unit>
        <trans-unit id="5b03947840333522631fcad82cab8f29beea0376" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will first look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive, then the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, then finally for the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, when governing worker execution.</source>
          <target state="translated">이 지시문이 없으면 사용자 에이전트는 먼저 작업자 실행을 관리 할 때 &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; 지시문을 찾은 다음 &lt;a href=&quot;script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; &lt;/a&gt; 지시문을 찾은 다음 &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="84255b47da2e8395f8cff0945ef69aa9944b73b4" translate="yes" xml:space="preserve">
          <source>If this directive is absent, the user agent will look for the &lt;a href=&quot;child-src&quot;&gt;&lt;code&gt;child-src&lt;/code&gt;&lt;/a&gt; directive (which falls back to the &lt;a href=&quot;default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive).</source>
          <target state="translated">이 지시문이 없으면 사용자 에이전트는 &lt;a href=&quot;child-src&quot;&gt; &lt;code&gt;child-src&lt;/code&gt; &lt;/a&gt; 지시문 ( &lt;a href=&quot;default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문으로 폴백) 을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="905e23650e04dd97cd87c8f1b4781aae080cf34e" translate="yes" xml:space="preserve">
          <source>If this header is delivered with the response at https://example.com/clear-cookies, all cookies on the same domain https://example.com and any subdomains (like https://stage.example.com, etc), will be cleared out.</source>
          <target state="translated">이 헤더가 https://example.com/clear-cookies에서 응답과 함께 제공되는 경우 동일한 도메인 https://example.com 및 모든 하위 도메인 (예 : https://stage.example.com 등)의 모든 쿠키 )가 지워집니다.</target>
        </trans-unit>
        <trans-unit id="84639588f8530b0b81f649bf1306849d6885af93" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, pin validation failures are reported to the given URL.</source>
          <target state="translated">이 선택적 매개 변수를 지정하면 핀 유효성 검증 실패가 지정된 URL에보고됩니다.</target>
        </trans-unit>
        <trans-unit id="cf9ff6207f9f440fe5c66b863c0c644f87236017" translate="yes" xml:space="preserve">
          <source>If this optional parameter is specified, this rule applies to all of the site's subdomains as well.</source>
          <target state="translated">이 선택적 매개 변수를 지정하면이 규칙이 모든 사이트의 하위 도메인에도 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="bbeccd91304096ae1ada0d103a494be1d6ecd504" translate="yes" xml:space="preserve">
          <source>If unspecified, the cookie becomes a &lt;strong&gt;session cookie&lt;/strong&gt;. A session finishes when the client shuts down, and session cookies will be removed.</source>
          <target state="translated">지정하지 않으면 쿠키가 &lt;strong&gt;세션 쿠키&lt;/strong&gt; 가됩니다.&lt;strong&gt;&lt;/strong&gt; 됩니다. 클라이언트가 종료되면 세션이 종료되고 세션 쿠키가 제거됩니다.</target>
        </trans-unit>
        <trans-unit id="6baa688a2748366ccc3dde62ab07310d89508f6a" translate="yes" xml:space="preserve">
          <source>If using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt;&lt;code&gt;EventSource.withCredentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;false&lt;/code&gt; (it's the default value).</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events&quot;&gt;Server-sent events를&lt;/a&gt; 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventSource/withCredentials&quot;&gt; &lt;code&gt;EventSource.withCredentials&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;false&lt;/code&gt; 인지 확인하십시오 (기본값).</target>
        </trans-unit>
        <trans-unit id="bb9e740256ba82627b9a0ee6fa47dc9b15df8b15" translate="yes" xml:space="preserve">
          <source>If using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API&lt;/a&gt;, make sure &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt; is &lt;code&gt;&quot;omit&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch API를&lt;/a&gt; 사용하는 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; 가 &lt;code&gt;&quot;omit&quot;&lt;/code&gt; 인지 확인하십시오 .</target>
        </trans-unit>
        <trans-unit id="da0002cfebb5073d0fedbf25422e03f2884be38b" translate="yes" xml:space="preserve">
          <source>If you are not disclosing third-party cookies, consumer trust might get harmed if cookie use is discovered. A clear disclosure (such as in a privacy policy) tends to eliminate any negative effects of a cookie discovery. Some countries also have legislation about cookies. See for example Wikimedia Foundation's &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;cookie statement&lt;/a&gt;.</source>
          <target state="translated">타사 쿠키를 공개하지 않으면 쿠키 사용이 발견되면 소비자 신뢰가 손상 될 수 있습니다. 개인 정보 보호 정책과 같은 명확한 공개는 쿠키 검색의 부정적인 영향을 제거하는 경향이 있습니다. 일부 국가에서는 쿠키에 관한 법률이 있습니다. 예를 들어 Wikimedia Foundation의 &lt;a href=&quot;https://wikimediafoundation.org/wiki/Cookie_statement&quot;&gt;쿠키 설명을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="bfae6e8214b89d3d41028b5ed5468c1096365497" translate="yes" xml:space="preserve">
          <source>If you are running a robotic user agent (e.g. a crawler), the &lt;code&gt;From&lt;/code&gt; header should be sent, so you can be contacted if problems occur on servers, such as if the robot is sending excessive, unwanted, or invalid requests.</source>
          <target state="translated">로봇 사용자 에이전트 (예 : 크롤러)를 실행중인 경우 &lt;code&gt;From&lt;/code&gt; 헤더를 보내야하므로 로봇이 과도한 요청, 원하지 않는 요청 또는 잘못된 요청을 보내는 경우와 같이 서버에서 문제가 발생하는 경우 연락 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9a96db39060f5e3f83ad7fb3b0569b07c25f59e0" translate="yes" xml:space="preserve">
          <source>If you don't know whether this condition is temporary or permanent, a &lt;a href=&quot;404&quot;&gt;&lt;code&gt;404&lt;/code&gt;&lt;/a&gt; status code should be used instead.</source>
          <target state="translated">이 조건이 일시적인지 영구적인지 모를 경우 대신 &lt;a href=&quot;404&quot;&gt; &lt;code&gt;404&lt;/code&gt; &lt;/a&gt; 상태 코드를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b65a6981b33c89d11ed83bceadd2cf2695bfb77d" translate="yes" xml:space="preserve">
          <source>If you don't want a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">임시 리디렉션을 원하지 않는 경우 추가 매개 변수 (사용할 HTTP 상태 코드 또는 &lt;code&gt;permanent&lt;/code&gt; 키워드)를 사용하여 다른 리디렉션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="104043725295eb7cc9f3df2d7c830d6c1a7855ab" translate="yes" xml:space="preserve">
          <source>If you don't want to set up a temporary redirect, an extra parameter (either the HTTP status code to use or the &lt;code&gt;permanent&lt;/code&gt; keyword) can be used to set up a different redirect:</source>
          <target state="translated">임시 리디렉션을 설정하지 않으려면 추가 매개 변수 (사용할 HTTP 상태 코드 또는 &lt;code&gt;permanent&lt;/code&gt; 키워드)를 사용하여 다른 리디렉션을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbff3207b07c23fc192059f1baabdc3df63a21a1" translate="yes" xml:space="preserve">
          <source>If you have access to the server you can change your implementation to echo back an origin in the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header. You cannot send back a list of origins, because browsers only accept a value that is either a single origin or null</source>
          <target state="translated">서버에 대한 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 있는 경우 Access-Control-Allow-Origin 헤더 의 원본을 에코 백하도록 구현을 변경할 수 있습니다 . 브라우저는 단일 출처 또는 null 값만 허용하므로 출처 목록을 다시 보낼 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="29e7b5fc4c6d4409c9fc727d5416d3a635b2f290" translate="yes" xml:space="preserve">
          <source>If you need to create a WebSocket connection from scratch, you'll have to handle the handshaking process yourself. After creating the initial HTTP/1.1 session, you need to request the upgrade by adding to a standard request the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt;&lt;code&gt;Upgrade&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/connection&quot;&gt;&lt;code&gt;Connection&lt;/code&gt;&lt;/a&gt; headers, as follows:</source>
          <target state="translated">처음부터 WebSocket 연결을 만들어야하는 경우 핸드 셰이 킹 프로세스를 직접 처리해야합니다. 초기 HTTP / 1.1 세션을 작성한 후 다음과 같이 표준 요청에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Upgrade&quot;&gt; &lt;code&gt;Upgrade&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/connection&quot;&gt; &lt;code&gt;Connection&lt;/code&gt; &lt;/a&gt; 헤더 를 추가하여 업그레이드를 요청해야 합니다.</target>
        </trans-unit>
        <trans-unit id="95ee0117fd829b54190ed2ff0616a236aeb84cf5" translate="yes" xml:space="preserve">
          <source>If you receive a response that is not in this list, it is a non-standard response, possibly custom to the server's software.</source>
          <target state="translated">이 목록에없는 응답을 수신하면 비표준 응답이며 서버 소프트웨어에 대한 사용자 정의 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8f0fd26b3474ef31bc91624748a9e6528cbeb2" translate="yes" xml:space="preserve">
          <source>If you set your site to require SRI for script and styles using this directive:</source>
          <target state="translated">이 지시문을 사용하여 스크립트 및 스타일에 SRI를 요구하도록 사이트를 설정 한 경우 :</target>
        </trans-unit>
        <trans-unit id="4990c5b1cf1cb465433d28094a3e92abdf6422d0" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;DENY&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;SAMEORIGIN&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">&lt;code&gt;DENY&lt;/code&gt; 를 지정 하면 프레임에서 페이지를로드하려는 시도가 다른 사이트에서로드 될 때 실패 할뿐만 아니라 동일한 사이트에서로드 될 때 실패합니다. 반면 &lt;code&gt;SAMEORIGIN&lt;/code&gt; 을 지정 하면 하면 프레임에 포함 된 사이트가 페이지를 제공하는 사이트와 동일한 한 프레임에서 페이지를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0907d966acc8c427e8ea343762038d9ac612b1e1" translate="yes" xml:space="preserve">
          <source>If you specify &lt;code&gt;deny&lt;/code&gt;, not only will attempts to load the page in a frame fail when loaded from other sites, attempts to do so will fail when loaded from the same site. On the other hand, if you specify &lt;code&gt;sameorigin&lt;/code&gt;, you can still use the page in a frame as long as the site including it in a frame is the same as the one serving the page.</source>
          <target state="translated">&lt;code&gt;deny&lt;/code&gt; 를 지정하면 다른 사이트에서로드 할 때 프레임에 페이지를로드하려고 시도 할뿐만 아니라 동일한 사이트에서로드 할 때 실패합니다. 반면에 &lt;code&gt;sameorigin&lt;/code&gt; 을 지정 하면 프레임에 페이지를 포함하는 사이트가 페이지를 제공하는 사이트와 동일한 한 프레임에서 페이지를 계속 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="76a40e879843d64bc7dc4946b5e5671cdab0ec07" translate="yes" xml:space="preserve">
          <source>If you still want to receive reporting, but also want to enforce a policy, use the &lt;a href=&quot;content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; header with the &lt;a href=&quot;content-security-policy/report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">여전히보고를 받고 싶지만 정책을 시행 하려면 &lt;a href=&quot;content-security-policy/report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시문 과 함께 &lt;a href=&quot;content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 헤더를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="6fa8f50d92b7325e18f060f06fa0a5d25f9ef058" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header.</source>
          <target state="translated">클라이언트가 다른 헤더에 액세스 할 수있게하려면 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 헤더를 사용하여 나열해야합니다 .</target>
        </trans-unit>
        <trans-unit id="ea06dd402f2e9e7e165d67b2c899ce9957d05866" translate="yes" xml:space="preserve">
          <source>If you want clients to be able to access other headers, you have to list them using the &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; header. &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt; was not part of the original set safelisted response headers [&lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt;].</source>
          <target state="translated">클라이언트가 다른 헤더에 액세스 할 수 있도록하려면 &lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt; 헤더를 사용하여 나열해야합니다 . &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 는 원래 설정된 허용 목록 응답 헤더 [ &lt;a href=&quot;https://github.com/whatwg/fetch/pull/626&quot;&gt;ref&lt;/a&gt; ]의 일부가 아닙니다 .</target>
        </trans-unit>
        <trans-unit id="29f7d5936f9e8e985a3e0dca82679038018eac65" translate="yes" xml:space="preserve">
          <source>If you want to avoid using user agent detection, you have options!</source>
          <target state="translated">사용자 에이전트 감지를 사용하지 않으려면 옵션이 있습니다!</target>
        </trans-unit>
        <trans-unit id="c4dd6049dead6031953d458d3c0344045b4e4cbe" translate="yes" xml:space="preserve">
          <source>If you want to specify a fallback policy in any case the desired policy hasn't got wide enough browser support, use a comma-separated list with the desired policy specified last:</source>
          <target state="translated">원하는 정책에 브라우저 지원이 충분하지 않은 경우 대체 정책을 지정하려면 마지막에 지정된 원하는 정책과 함께 쉼표로 구분 된 목록을 사용하세요.</target>
        </trans-unit>
        <trans-unit id="21412475687382be49c1ab666d1bf865da6de6a3" translate="yes" xml:space="preserve">
          <source>If you want to try to avoid using user agent detection, there are options in some cases!</source>
          <target state="translated">사용자 에이전트 감지를 사용하지 않으려는 경우 옵션이 있습니다!</target>
        </trans-unit>
        <trans-unit id="0a038ab727911ca95eaa7cfa94eb4a630d6d412b" translate="yes" xml:space="preserve">
          <source>If your application, server, or proxy supports the standardized &lt;code&gt;Forwarded&lt;/code&gt; header, the &lt;a href=&quot;x-forwarded-for&quot;&gt;&lt;code&gt;X-Forwarded-For&lt;/code&gt;&lt;/a&gt; header can be replaced. Note that IPv6 address are quoted and enclosed in square brackets in &lt;code&gt;Forwarded&lt;/code&gt;.</source>
          <target state="translated">응용 프로그램, 서버 또는 프록시가 표준화 된 &lt;code&gt;Forwarded&lt;/code&gt; 헤더를 지원하는 경우 &lt;a href=&quot;x-forwarded-for&quot;&gt; &lt;code&gt;X-Forwarded-For&lt;/code&gt; &lt;/a&gt; 헤더를 교체 할 수 있습니다. IPv6 주소는 따옴표로 묶어 &lt;code&gt;Forwarded&lt;/code&gt; 대괄호로 묶습니다 .</target>
        </trans-unit>
        <trans-unit id="90a08b947a2957fe434f390c98a9142e831d9a0f" translate="yes" xml:space="preserve">
          <source>If your site authenticates users, it should regenerate and resend session cookies, even ones that already exist, whenever the user authenticates. This technique helps prevent &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;session fixation attacks&lt;/a&gt;, where a third party can reuse a user's session.</source>
          <target state="translated">사이트에서 사용자를 인증하는 경우 사용자가 인증 할 때마다 세션 쿠키 (이미 존재하는 쿠키 포함)를 다시 생성하고 다시 보내야합니다. 이 기술은 제 3자가 사용자의 세션을 재사용 할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Types_of_attacks#Session_fixation&quot;&gt;세션 고정 공격&lt;/a&gt; 을 방지하는 데 도움이됩니다 .</target>
        </trans-unit>
        <trans-unit id="49d1c453e83057e2df00a9ddb4d5028bf92c87b6" translate="yes" xml:space="preserve">
          <source>If, instead, you need to adjust the server's behavior, you'll need to change the value of &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; to grant access to the origin from which the client is loaded.</source>
          <target state="translated">대신 서버의 동작을 조정해야하는 경우 클라이언트가로드 된 원점에 대한 액세스 권한을 부여하기 위해 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 의 값을 변경해야합니다 .</target>
        </trans-unit>
        <trans-unit id="c4eca4702bbd3334f2af696c9113056ad66a8d93" translate="yes" xml:space="preserve">
          <source>If-Match</source>
          <target state="translated">If-Match</target>
        </trans-unit>
        <trans-unit id="347825cb2f6b585363c705da713b0a01a89c0771" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 2616)</source>
          <target state="translated">일치하는 경우 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="258eadb23d36147c17ca65c583464f10d8beefd5" translate="yes" xml:space="preserve">
          <source>If-Match (RFC 7232)</source>
          <target state="translated">If-Match (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="de1338853da05e0b2ef334c6d2a1bd4efd32b464" translate="yes" xml:space="preserve">
          <source>If-Modified-Since</source>
          <target state="translated">If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="434516b07ea046bbb5c4ac151f7538b608531da2" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 2616)</source>
          <target state="translated">If-Modified-Since (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="33cf8486927b13aa3ae6d7b4b5c2ba9856f2354e" translate="yes" xml:space="preserve">
          <source>If-Modified-Since (RFC 7232)</source>
          <target state="translated">If-Modified-Since (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="2c743ca76b5ff26374732b33a172bc6386b3aab3" translate="yes" xml:space="preserve">
          <source>If-None-Match</source>
          <target state="translated">If-None-Match</target>
        </trans-unit>
        <trans-unit id="afb97058113ea8024c2b1e30396497276d9e7529" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 2616)</source>
          <target state="translated">일치하지 않는 경우 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9d29af1e2a7a4f8c799fff50073e73e2ee90bbe7" translate="yes" xml:space="preserve">
          <source>If-None-Match (RFC 7232)</source>
          <target state="translated">일치하지 않는 경우 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="3e610a822745a7648a28ddc376bb31e9d961b787" translate="yes" xml:space="preserve">
          <source>If-Range</source>
          <target state="translated">If-Range</target>
        </trans-unit>
        <trans-unit id="0db4229b3fe70c3cd52654ba3a313677c557a2f3" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 2616)</source>
          <target state="translated">범위 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="63c9a90407687da95ffa628c724bc3b45d1f6b45" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7232)</source>
          <target state="translated">범위 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="d239314fe40c1036bb99b7c1a04ab1559ed5e25b" translate="yes" xml:space="preserve">
          <source>If-Range (RFC 7233)</source>
          <target state="translated">범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="f07ea20e44175d8597a0629b88839dc18660c130" translate="yes" xml:space="preserve">
          <source>If-Unmodified-Since</source>
          <target state="translated">If-Unmodified-Since</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
