<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="91492e27c3f46e0f247584604399219373edefb5" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Feature-Policy.screen-wake-lock&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Feature-Policy.screen-wake-lock&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9f14b75ab57e1336c00b4e7eec2ed66b9bd74e5f" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Feature-Policy.web-share&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Feature-Policy.web-share&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7f45db583636e200faf1d0ef0f35e6ff65943013" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Link&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Link&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="087056739c3ab34d873287ef53ff57a465326155" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Sec-WebSocket-Accept&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Sec-WebSocket-Accept&quot;(깊이 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49ea66053785329bdd6549bbc5b810800418b814" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.Upgrade&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.headers.Upgrade&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d387eba68a01a0346de984813fa48d0ba3b1e823" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.headers.csp.base-uri&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">No compatibility data found. Please contribute data for &quot;http.headers.csp.base-uri&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="37615aab599f70ae41dc656154729d14ca7bdcda" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.status.103&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.status.103&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a38b2e1f2f1d515794a4e6b4bacdbcca9d2bb44" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.status.402&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.status.402&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b9d95fc0c4c68f783d6998d3d7b74901ffbf32e7" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http.status.418&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http.status.418&quot;(깊이 : 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cbbe238f0711bff5f6e8bc80d9997d6930718ad5" translate="yes" xml:space="preserve">
          <source>No compatibility data found. Please contribute data for &quot;http/methods&quot; (depth: 1) to the &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;MDN compatibility data repository&lt;/a&gt;.</source>
          <target state="translated">호환성 데이터가 없습니다. &quot;http / methods&quot;(깊이 1)에 대한 &lt;a href=&quot;https://github.com/mdn/browser-compat-data&quot;&gt;데이터를 MDN 호환성 데이터 저장소에 제공하십시오&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7b939e4151278ce4695f67fb994a918f9a84e18f" translate="yes" xml:space="preserve">
          <source>No custom headers are sent with the HTTP request (such as &lt;code&gt;X-Modified&lt;/code&gt;, etc.)</source>
          <target state="translated">HTTP 요청과 함께 사용자 정의 헤더가 전송되지 않습니다 (예 : &lt;code&gt;X-Modified&lt;/code&gt; 등)</target>
        </trans-unit>
        <trans-unit id="573822ae80155d86cf67051167134df0cef110f2" translate="yes" xml:space="preserve">
          <source>No event listeners are registered on any &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestUpload&quot;&gt;&lt;code&gt;XMLHttpRequestUpload&lt;/code&gt;&lt;/a&gt; object used in the request; these are accessed using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload&quot;&gt;&lt;code&gt;XMLHttpRequest.upload&lt;/code&gt;&lt;/a&gt; property.</source>
          <target state="translated">요청에 사용 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequestUpload&quot;&gt; &lt;code&gt;XMLHttpRequestUpload&lt;/code&gt; &lt;/a&gt; 객체 에는 이벤트 리스너가 등록되어 있지 않습니다 . 이들은 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/upload&quot;&gt; &lt;code&gt;XMLHttpRequest.upload&lt;/code&gt; &lt;/a&gt; 속성을 사용하여 액세스 합니다.</target>
        </trans-unit>
        <trans-unit id="c8bef9415aed440d614d66a570191aedb63a9755" translate="yes" xml:space="preserve">
          <source>No inheritance with &lt;code&gt;default-src&lt;/code&gt;</source>
          <target state="translated">&lt;code&gt;default-src&lt;/code&gt; 로 상속받지 않음</target>
        </trans-unit>
        <trans-unit id="91f5a441d9db9c42d572929abcfe792cff5e5a09" translate="yes" xml:space="preserve">
          <source>No inheritance with default-src</source>
          <target state="translated">No inheritance with default-src</target>
        </trans-unit>
        <trans-unit id="759bb2da44cf0b5255c1bd66673ad4fd56926c2b" translate="yes" xml:space="preserve">
          <source>No multiplexing can be done. Several connections need opening on the same server: and warm TCP connections are more efficient than cold ones.</source>
          <target state="translated">다중화를 수행 할 수 없습니다. 동일한 서버에서 여러 연결을 열어야합니다. 웜 연결은 콜드 연결보다 효율적입니다.</target>
        </trans-unit>
        <trans-unit id="4674003f1e16d39f5370fe00b7a882ed66166074" translate="yes" xml:space="preserve">
          <source>No other browsers implement these extra restrictions, because they&amp;rsquo;re not part of the spec.</source>
          <target state="translated">No other browsers implement these extra restrictions, because they&amp;rsquo;re not part of the spec.</target>
        </trans-unit>
        <trans-unit id="701e86c07a175edb82d6e91e08c1b08340403b9b" translate="yes" xml:space="preserve">
          <source>No other expectations except &quot;100-continue&quot; are specified currently.</source>
          <target state="translated">현재 &quot;100-continue&quot;을 제외한 다른 예상은 없습니다.</target>
        </trans-unit>
        <trans-unit id="e8f8ea3fe1de09718f410e58fb2b6aa218c2ce1a" translate="yes" xml:space="preserve">
          <source>No range unit is supported, this makes the header equivalent of its own absence and is therefore rarely used, though some browsers, like IE9, it is used to disable or remove the pause buttons in the download manager.</source>
          <target state="translated">범위 단위가 지원되지 않으므로 헤더가 자체적으로 존재하지 않으므로 IE9와 같은 일부 브라우저는 다운로드 관리자에서 일시 중지 버튼을 비활성화하거나 제거하는 데 사용되지만 거의 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="733083ad7466dbb41b8dd82838b716da4b0d421f" translate="yes" xml:space="preserve">
          <source>No support for query strings, etc.</source>
          <target state="translated">쿼리 문자열 등을 지원하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c586fc9306c6c90357e137cd076d0c1a8ba40b34" translate="yes" xml:space="preserve">
          <source>No transformations or conversions should be made to the resource. The Content-Encoding, Content-Range, Content-Type headers must not be modified by a proxy. A non- transparent proxy might, for example, convert between image formats in order to save cache space or to reduce the amount of traffic on a slow link. The &lt;code&gt;no-transform&lt;/code&gt; directive disallows this.</source>
          <target state="translated">자원을 변환하거나 변환하지 않아야합니다. Content-Encoding, Content-Range, Content-Type 헤더는 프록시에 의해 수정되어서는 안됩니다. 예를 들어, 투명하지 않은 프록시는 캐시 공간을 절약하거나 저속 링크의 트래픽 양을 줄이기 위해 이미지 형식간에 변환 할 수 있습니다. 은 &lt;code&gt;no-transform&lt;/code&gt; 지시어 것을 허용하지이.</target>
        </trans-unit>
        <trans-unit id="cbffbe0b8b6d1110e3c62d1a5647e0d5355ab572" translate="yes" xml:space="preserve">
          <source>No. Not setting this allows any URL.</source>
          <target state="translated">아니요. 설정하지 않으면 URL이 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="d7968e9f59fc3ea4d8f9120bc13639ba2c96128a" translate="yes" xml:space="preserve">
          <source>No. Not setting this allows anything.</source>
          <target state="translated">아니요. 설정하지 않으면 아무 것도 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="43b56bdc9a2f449dd95a29cc4403aabc8d987dfc" translate="yes" xml:space="preserve">
          <source>Node.JS</source>
          <target state="translated">Node.JS</target>
        </trans-unit>
        <trans-unit id="c77a87d79945cb92381e651d3b83555dc60d5cee" translate="yes" xml:space="preserve">
          <source>Nokia N900 Linux mobile, on the Fennec browser</source>
          <target state="translated">Fennec 브라우저의 Nokia N900 Linux 모바일</target>
        </trans-unit>
        <trans-unit id="4b8c1db000b37532ee78f68154fa3781e4c83d96" translate="yes" xml:space="preserve">
          <source>Non-DAV-aware proxies will not honor the If header, since they will
   not understand the If header, and HTTP requires non-understood
   headers to be ignored.  When communicating with HTTP/1.1 proxies, the
   client MUST use the &quot;Cache-Control: no-cache&quot; request header so as to
   prevent the proxy from improperly trying to service the request from
   its cache.  When dealing with HTTP/1.0 proxies, the &quot;Pragma: no-
   cache&quot; request header MUST be used for the same reason.

   Because in general clients may not be able to reliably detect non-
   DAV-aware intermediates, they are advised to always prevent caching
   using the request directives mentioned above.</source>
          <target state="translated">DAV를 인식하지 않는 프록시는 If 헤더를 이해하지 못하기 때문에 If 헤더를 존중하지 않으며 HTTP는 이해할 수없는 헤더를 무시해야합니다. HTTP / 1.1 프록시와 통신 할 때 클라이언트는 &quot;캐시 제어 : 비 캐시&quot;요청 헤더를 사용하여 프록시가 캐시에서 요청을 부적절하게 서비스하지 못하도록해야합니다. HTTP / 1.0 프록시를 다룰 때 같은 이유로 &quot;Pragma : no-cache&quot;요청 헤더를 사용해야합니다. 일반적으로 클라이언트는 DAV를 인식하지 않는 중간체를 안정적으로 감지하지 못할 수 있으므로 위에서 언급 한 요청 지시문을 사용하여 캐싱을 항상 방지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="6eef6648406c333a4035cd5e60d0bf2ecf2606d7" translate="yes" xml:space="preserve">
          <source>None</source>
          <target state="translated">None</target>
        </trans-unit>
        <trans-unit id="09855e72c0149e1ac117bc7810e176824713330e" translate="yes" xml:space="preserve">
          <source>None built-in; add-ons required</source>
          <target state="translated">None built-in; add-ons required</target>
        </trans-unit>
        <trans-unit id="9a9707be07da6862114abd49d2570046d4810ca5" translate="yes" xml:space="preserve">
          <source>None.</source>
          <target state="translated">None.</target>
        </trans-unit>
        <trans-unit id="91ff3eded934ff0ab600e7be73e7440daea480d7" translate="yes" xml:space="preserve">
          <source>Normalisation</source>
          <target state="translated">Normalisation</target>
        </trans-unit>
        <trans-unit id="4b75bcc6b482971118032246352667713443b845" translate="yes" xml:space="preserve">
          <source>Not all browsers currently support following redirects after a preflighted request. If a redirect occurs after a preflighted request, some browsers currently will report an error message such as the following.</source>
          <target state="translated">모든 브라우저가 현재 사전 요청 후 다음 리디렉션을 지원하지는 않습니다. 사전 비행 요청 후 리디렉션이 발생하면 일부 브라우저는 현재 다음과 같은 오류 메시지를보고합니다.</target>
        </trans-unit>
        <trans-unit id="cf38fd002847999f4fcff82b501a332885b56449" translate="yes" xml:space="preserve">
          <source>Not all types of HTTP requests can be pipelined: only &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;idempotent&lt;/a&gt; methods, that is &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;, can be replayed safely: should a failure happen, the pipeline content can simply be repeated.</source>
          <target state="translated">모든 유형의 HTTP 요청을 파이프 라인 할 수있는 것은 아닙니다. &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 라는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/idempotent&quot;&gt;dem 등원&lt;/a&gt; 메소드 만 안전하게 재생할 수 있습니다. 장애가 발생하면 파이프 라인 컨텐츠를 간단히 반복 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="10691f4c6439e42e1fb5e5f7a828b53b02a4fd2a" translate="yes" xml:space="preserve">
          <source>Not many: the choices are listed in an HTML page in the body. Could be served with a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; status.</source>
          <target state="translated">많지 않음 : 선택 사항이 본문의 HTML 페이지에 나열됩니다. &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 상태 로 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9781f509e22b394a1b27daf5eeb507e90a6ce7e0" translate="yes" xml:space="preserve">
          <source>Not many: the choices are listed in an HTML page in the body. Machine-readable choices are encouraged to be sent as &lt;a href=&quot;headers/link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; headers with &lt;code&gt;rel=alternate&lt;/code&gt;.</source>
          <target state="translated">Not many: the choices are listed in an HTML page in the body. Machine-readable choices are encouraged to be sent as &lt;a href=&quot;headers/link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; headers with &lt;code&gt;rel=alternate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36e6c8b66ebeebd54bd9a904c7fbeea61aee185c" translate="yes" xml:space="preserve">
          <source>Not part of any current specification. The standardized version of this header is &lt;a href=&quot;forwarded&quot;&gt;&lt;code&gt;Forwarded&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">현재 사양의 일부가 아닙니다. 이 헤더의 표준화 된 버전은 &lt;a href=&quot;forwarded&quot;&gt; &lt;code&gt;Forwarded&lt;/code&gt; &lt;/a&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="1500ffdc7dad0acff37ead2e9bc7fa9274c76bf3" translate="yes" xml:space="preserve">
          <source>Not part of any current specifications. An explainer of the ideas behind this header can be found in &lt;a href=&quot;https://gist.github.com/mystor/5739e222e398efc6c29108be55eb6fe3&quot;&gt;this document&lt;/a&gt;.</source>
          <target state="translated">현재 사양의 일부가 아닙니다. 이 헤더 뒤에있는 아이디어에 대한 설명은 &lt;a href=&quot;https://gist.github.com/mystor/5739e222e398efc6c29108be55eb6fe3&quot;&gt;이 문서&lt;/a&gt; 에서 찾을 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f4de1afe5413225e5f1765ec1032b7844a5f2454" translate="yes" xml:space="preserve">
          <source>Not part of any specification.</source>
          <target state="translated">사양의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="a7ef8eb2962577a32c14b0ab70a829a6c4372bb9" translate="yes" xml:space="preserve">
          <source>Not part of any specifications or drafts.</source>
          <target state="translated">사양이나 초안의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="d7da173654def19a4d625df2150ac9e2fae338ac" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests until Firefox 58, see &lt;a href=&quot;https://bugzil.la/446344&quot;&gt;bug 446344&lt;/a&gt;.</source>
          <target state="translated">Firefox 58까지 &lt;code&gt;POST&lt;/code&gt; 요청 과 함께 전송되지 않습니다 ( &lt;a href=&quot;https://bugzil.la/446344&quot;&gt;버그 446344&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="37cdc0eab1650d512c35c0138237e99aeced5b05" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests, see &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10482384/&quot;&gt;bug 10482384&lt;/a&gt;.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 요청 과 함께 전송되지 않습니다 ( &lt;a href=&quot;https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10482384/&quot;&gt;버그 10482384&lt;/a&gt; 참조) .</target>
        </trans-unit>
        <trans-unit id="8f42ecfd3ebc1780acf4642506cfa94138913bff" translate="yes" xml:space="preserve">
          <source>Not sent with &lt;code&gt;POST&lt;/code&gt; requests, see &lt;a href=&quot;https://developer.microsoft.com/microsoft-edge/platform/issues/10482384/&quot;&gt;bug 10482384&lt;/a&gt;.</source>
          <target state="translated">Not sent with &lt;code&gt;POST&lt;/code&gt; requests, see &lt;a href=&quot;https://developer.microsoft.com/microsoft-edge/platform/issues/10482384/&quot;&gt;bug 10482384&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="8634e3749faa07a4b5774fe6971f3622c67303ce" translate="yes" xml:space="preserve">
          <source>Not supported for stylesheets.</source>
          <target state="translated">Not supported for stylesheets.</target>
        </trans-unit>
        <trans-unit id="7a0567436d10ea56ace7da986caf33ba7d83c556" translate="yes" xml:space="preserve">
          <source>Not supported prior to macOS before version 10.15 (Catalina).</source>
          <target state="translated">Not supported prior to macOS before version 10.15 (Catalina).</target>
        </trans-unit>
        <trans-unit id="50453dd141739f1c493d302dd3803fa4331745be" translate="yes" xml:space="preserve">
          <source>Not tracking.</source>
          <target state="translated">추적하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2c924e3088204ee77ba681f72be3444357932fca" translate="yes" xml:space="preserve">
          <source>Note</source>
          <target state="translated">Note</target>
        </trans-unit>
        <trans-unit id="d7446acc353340ab461be96a0f87263f71fc7e34" translate="yes" xml:space="preserve">
          <source>Note also that HTTP/2 explicitly disallows the use of this mechanism; it is specific to HTTP/1.1.</source>
          <target state="translated">Note also that HTTP/2 explicitly disallows the use of this mechanism; it is specific to HTTP/1.1.</target>
        </trans-unit>
        <trans-unit id="e3a2dfaed75d27647860fc3263ef2225f1db15d5" translate="yes" xml:space="preserve">
          <source>Note that 'allprop', despite its name, which remains for backward-
   compatibility, does not return every property, but only dead
   properties and the live properties defined in this specification.

   &amp;gt;&amp;gt;Request

     PROPFIND /container/ HTTP/1.1
     Host: www.example.com
     Depth: 1
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:propfind xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:allprop/&amp;gt;
     &amp;lt;/D:propfind&amp;gt;


   &amp;gt;&amp;gt;Response

     HTTP/1.1 207 Multi-Status
     Content-Type: application/xml; charset=&quot;utf-8&quot;
     Content-Length: xxxx

     &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
     &amp;lt;D:multistatus xmlns:D=&quot;DAV:&quot;&amp;gt;
       &amp;lt;D:response&amp;gt;
         &amp;lt;D:href&amp;gt;/container/&amp;lt;/D:href&amp;gt;
         &amp;lt;D:propstat&amp;gt;
           &amp;lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&amp;gt;
             &amp;lt;R:bigbox&amp;gt;&amp;lt;R:BoxType&amp;gt;Box type A&amp;lt;/R:BoxType&amp;gt;&amp;lt;/R:bigbox&amp;gt;
             &amp;lt;R:author&amp;gt;&amp;lt;R:Name&amp;gt;Hadrian&amp;lt;/R:Name&amp;gt;&amp;lt;/R:author&amp;gt;
             &amp;lt;D:creationdate&amp;gt;1997-12-01T17:42:21-08:00&amp;lt;/D:creationdate&amp;gt;
             &amp;lt;D:displayname&amp;gt;Example collection&amp;lt;/D:displayname&amp;gt;
             &amp;lt;D:resourcetype&amp;gt;&amp;lt;D:collection/&amp;gt;&amp;lt;/D:resourcetype&amp;gt;
             &amp;lt;D:supportedlock&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:exclusive/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:shared/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
             &amp;lt;/D:supportedlock&amp;gt;
           &amp;lt;/D:prop&amp;gt; 

           &amp;lt;D:status&amp;gt;HTTP/1.1 200 OK&amp;lt;/D:status&amp;gt;
         &amp;lt;/D:propstat&amp;gt;
       &amp;lt;/D:response&amp;gt;
       &amp;lt;D:response&amp;gt;
         &amp;lt;D:href&amp;gt;/container/front.html&amp;lt;/D:href&amp;gt;
         &amp;lt;D:propstat&amp;gt;
           &amp;lt;D:prop xmlns:R=&quot;http://ns.example.com/boxschema/&quot;&amp;gt;
             &amp;lt;R:bigbox&amp;gt;&amp;lt;R:BoxType&amp;gt;Box type B&amp;lt;/R:BoxType&amp;gt;
             &amp;lt;/R:bigbox&amp;gt;
             &amp;lt;D:creationdate&amp;gt;1997-12-01T18:27:21-08:00&amp;lt;/D:creationdate&amp;gt;
             &amp;lt;D:displayname&amp;gt;Example HTML resource&amp;lt;/D:displayname&amp;gt;
             &amp;lt;D:getcontentlength&amp;gt;4525&amp;lt;/D:getcontentlength&amp;gt;
             &amp;lt;D:getcontenttype&amp;gt;text/html&amp;lt;/D:getcontenttype&amp;gt;
             &amp;lt;D:getetag&amp;gt;&quot;zzyzx&quot;&amp;lt;/D:getetag&amp;gt;
             &amp;lt;D:getlastmodified
               &amp;gt;Mon, 12 Jan 1998 09:25:56 GMT&amp;lt;/D:getlastmodified&amp;gt;
             &amp;lt;D:resourcetype/&amp;gt;
             &amp;lt;D:supportedlock&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:exclusive/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
               &amp;lt;D:lockentry&amp;gt;
                 &amp;lt;D:lockscope&amp;gt;&amp;lt;D:shared/&amp;gt;&amp;lt;/D:lockscope&amp;gt;
                 &amp;lt;D:locktype&amp;gt;&amp;lt;D:write/&amp;gt;&amp;lt;/D:locktype&amp;gt;
               &amp;lt;/D:lockentry&amp;gt;
             &amp;lt;/D:supportedlock&amp;gt;
           &amp;lt;/D:prop&amp;gt;
           &amp;lt;D:status&amp;gt;HTTP/1.1 200 OK&amp;lt;/D:status&amp;gt;
         &amp;lt;/D:propstat&amp;gt;
       &amp;lt;/D:response&amp;gt;
     &amp;lt;/D:multistatus&amp;gt;

   In this example, PROPFIND was invoked on the resource
   http://www.example.com/container/ with a Depth header of 1, meaning
   the request applies to the resource and its children, and a propfind
   XML element containing the allprop XML element, meaning the request
   should return the name and value of all the dead properties defined
   on the resources, plus the name and value of all the properties
   defined in this specification.  This example illustrates the use of
   relative references in the 'href' elements of the response.

   The resource http://www.example.com/container/ has six properties
   defined on it: 'bigbox' and 'author in the
   &quot;http://ns.example.com/boxschema/&quot; namespace, DAV:creationdate, DAV:
   displayname, DAV:resourcetype, and DAV:supportedlock. 

   The last four properties are WebDAV-specific, defined in &lt;a href=&quot;#section-15&quot;&gt;Section 15&lt;/a&gt;.
   Since GET is not supported on this resource, the get* properties
   (e.g., DAV:getcontentlength) are not defined on this resource.  The
   WebDAV-specific properties assert that &quot;container&quot; was created on
   December 1, 1997, at 5:42:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of &quot;Example collection&quot; (DAV:
   displayname), a collection resource type (DAV:resourcetype), and
   supports exclusive write and shared write locks (DAV:supportedlock).

   The resource http://www.example.com/container/front.html has nine
   properties defined on it:

   'bigbox' in the &quot;http://ns.example.com/boxschema/&quot; namespace (another
   instance of the &quot;bigbox&quot; property type), DAV:creationdate, DAV:
   displayname, DAV:getcontentlength, DAV:getcontenttype, DAV:getetag,
   DAV:getlastmodified, DAV:resourcetype, and DAV:supportedlock.

   The DAV-specific properties assert that &quot;front.html&quot; was created on
   December 1, 1997, at 6:27:21PM, in a time zone 8 hours west of GMT
   (DAV:creationdate), has a name of &quot;Example HTML resource&quot; (DAV:
   displayname), a content length of 4525 bytes (DAV:getcontentlength),
   a MIME type of &quot;text/html&quot; (DAV:getcontenttype), an entity tag of
   &quot;zzyzx&quot; (DAV:getetag), was last modified on Monday, January 12, 1998,
   at 09:25:56 GMT (DAV:getlastmodified), has an empty resource type,
   meaning that it is not a collection (DAV:resourcetype), and supports
   both exclusive write and shared write locks (DAV:supportedlock).</source>
          <target state="translated">역 호환성을 위해 남아있는 이름에도 불구하고 'allprop'는 모든 속성을 반환하지는 않으며이 사양에 정의 된 죽은 속성과 라이브 속성 만 반환합니다. &amp;gt;&amp;gt; PROPFIND 요청 / container / HTTP / 1.1 호스트 : www.example.com 깊이 : 1 Content-Type : application / xml; charset = &quot;utf-8&quot;Content-Length : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : propfind xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : allprop /&amp;gt; &amp;lt;/ D : propfind&amp;gt; &amp;gt;&amp;gt; 응답 HTTP / 1.1 207 다중 상태 컨텐츠 유형 : application / xml; charset = &quot;utf-8&quot;컨텐츠 길이 : xxxx &amp;lt;? xml version = &quot;1.0&quot;encoding = &quot;utf-8&quot;?&amp;gt; &amp;lt;D : multistatus xmlns : D = &quot;DAV :&quot;&amp;gt; &amp;lt;D : response&amp;gt;&amp;lt;D : href&amp;gt; / container / &amp;lt;/ D : href&amp;gt; &amp;lt;D : propstat&amp;gt; &amp;lt;D : prop xmlns : R = &quot;http://ns.example.com/boxschema/&quot;&amp;gt; &amp;lt;R : bigbox&amp;gt; &amp;lt;R : BoxType&amp;gt; 상자 유형 A &amp;lt;/ R : BoxType&amp;gt; &amp;lt;/ R : bigbox&amp;gt; &amp;lt;R : author&amp;gt; &amp;lt;R : Name&amp;gt; Hadrian &amp;lt;/ R : Name&amp;gt; &amp;lt;/ R : author&amp;gt; &amp;lt;D : creationdate&amp;gt; 1997-12-01T17 : 42 : 21-08 : 00 &amp;lt;/ D : creationdate&amp;gt; &amp;lt;D : displayname&amp;gt; 예제 컬렉션 &amp;lt;/ D : displayname&amp;gt; &amp;lt;D : resourcetype&amp;gt; &amp;lt;D : collection /&amp;gt; &amp;lt;/ D : resourcetype&amp;gt; &amp;lt;D : supportedlock&amp;gt; &amp;lt; D : lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : exclusive /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : write /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;D :lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : shared /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : write /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;/ D : supportedlock&amp;gt; &amp;lt;/ D : prop&amp;gt; &amp;lt;D : status&amp;gt; HTTP / 1.1 200 OK &amp;lt;/ D : status&amp;gt; &amp;lt;/ D : propstat&amp;gt; &amp;lt;/ D : response&amp;gt; &amp;lt;D : response&amp;gt; &amp;lt;D : href&amp;gt; /container/front.html &amp;lt;/ D : href&amp;gt; &amp;lt;D : propstat&amp;gt; &amp;lt;D : prop xmlns : R = &quot;http://ns.example.com/boxschema/&quot;&amp;gt; &amp;lt;R : bigbox&amp;gt; &amp;lt;R : BoxType&amp;gt; 상자 유형 B &amp;lt;/ R : BoxType &amp;gt; &amp;lt;/ R : bigbox&amp;gt; &amp;lt;D : creationdate&amp;gt; 1997-12-01T18 : 27 : 21-08 : 00 &amp;lt;/ D : creationdate&amp;gt; &amp;lt;D : displayname&amp;gt; HTML 리소스 예 &amp;lt;/ D : displayname&amp;gt; &amp;lt;D :getcontentlength&amp;gt; 4525 &amp;lt;/ D : getcontentlength&amp;gt; &amp;lt;D : getcontenttype&amp;gt; text / html &amp;lt;/ D : getcontenttype&amp;gt; &amp;lt;D : getetag&amp;gt; &quot;zzyzx&quot;&amp;lt;/ D : getetag&amp;gt; &amp;lt;D : getlastmodified&amp;gt; 1998 년 1 월 12 일 09:25 : 56 GMT &amp;lt;/ D : getlastmodified&amp;gt; &amp;lt;D : resourcetype /&amp;gt; &amp;lt;D : supportedlock&amp;gt; &amp;lt;D : lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : exclusive /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : 쓰기 /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;D : lockentry&amp;gt; &amp;lt;D : lockscope&amp;gt; &amp;lt;D : shared /&amp;gt; &amp;lt;/ D : lockscope&amp;gt; &amp;lt;D : locktype&amp;gt; &amp;lt;D : write /&amp;gt; &amp;lt;/ D : locktype&amp;gt; &amp;lt;/ D : lockentry&amp;gt; &amp;lt;/ D : supportedlock&amp;gt;&amp;lt;/ D : prop&amp;gt; &amp;lt;D : status&amp;gt; HTTP / 1.1 200 OK &amp;lt;/ D : status&amp;gt; &amp;lt;/ D : propstat&amp;gt; &amp;lt;/ D : response&amp;gt; &amp;lt;/ D : multistatus&amp;gt;이 예에서 PROPFIND는 자원에서 호출되었습니다. 깊이 헤더가 1 인 http://www.example.com/container/ : 요청이 자원 및 해당 하위 항목에 적용되고 allprop XML 요소가 포함 된 propfind XML 요소 (요청이 이름과 값을 리턴해야 함)를 의미 함 자원에 정의 된 모든 죽은 특성과이 스펙에 정의 된 모든 특성의 이름 및 값. 이 예는 응답의 'href'요소에서 상대 참조를 사용하는 것을 보여줍니다. http://www.example.com/container/ 리소스에는 'bigbox'및 ''&quot;http://ns.example.com/boxschema/&quot;네임 스페이스의 작성자, DAV : creationdate, DAV : 표시 이름, DAV : resourcetype 및 DAV : supportedlock 마지막 네 가지 속성은 WebDAV에 따라 다릅니다.&lt;a href=&quot;#section-15&quot;&gt;섹션 15&lt;/a&gt;. 이 자원에서 GET이 지원되지 않으므로 get * 특성 (예 : DAV : getcontentlength)이이 자원에 정의되어 있지 않습니다. WebDAV 관련 속성은 &quot;컨테이너&quot;가 1997 년 12 월 1 일 오후 5:42:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate) 시간대에 만들어졌으며 &quot;예제 수집&quot;(DAV)이라는 이름을 가지고 있다고 주장합니다. : 표시 이름), 콜렉션 자원 유형 (DAV : resourcetype)이며 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 지원합니다. http://www.example.com/container/front.html 리소스에는 9 개의 속성이 정의되어 있습니다. &quot;http://ns.example.com/boxschema/&quot;네임 스페이스의 'bigbox'( &quot; bigbox &quot;속성 유형), DAV : 작성 날짜, DAV : 표시 이름, DAV : getcontentlength, DAV : getcontenttype, DAV : getetag, DAV :getlastmodified, DAV : resourcetype 및 DAV : supportedlock. DAV 관련 속성은 &quot;front.html&quot;이 1997 년 12 월 1 일 오후 6:27:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate) 표준 시간대에 만들어졌으며 &quot;HTML 리소스 예&quot;라는 이름을 갖습니다. &quot;(DAV : 표시 이름), 콘텐츠 길이 4525 바이트 (DAV : getcontentlength),&quot;text / html &quot;의 MIME 유형 (DAV : getcontenttype),&quot;zzyzx &quot;(DAV : getetag)의 엔티티 태그 인 마지막 수정 1998 년 1 월 12 일 월요일, 09:25:56 GMT (DAV : getlastmodified)에 비어있는 자원 유형이 있으며 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 ( DAV : supportedlock).1997 년 12 월 1 일 오후 6:27:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate)에 이름이 &quot;예제 HTML 리소스&quot;(DAV : displayname), 콘텐츠 길이는 4525입니다. &quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 &quot;text / html&quot;(DAV : getcontenttype)의 MIME 유형 인 바이트 (DAV : getcontentlength)는 1998 년 1 월 12 일 월요일 09:25에 마지막으로 수정되었습니다. : 56 GMT (DAV : getlastmodified)는 빈 자원 유형을 가지며 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원함을 의미합니다.1997 년 12 월 1 일 오후 6:27:21에 GMT에서 서쪽으로 8 시간 (DAV : creationdate)에 이름이 &quot;예제 HTML 리소스&quot;(DAV : displayname), 콘텐츠 길이는 4525입니다. &quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 &quot;text / html&quot;(DAV : getcontenttype)의 MIME 유형 인 바이트 (DAV : getcontentlength)는 1998 년 1 월 12 일 월요일 09:25에 마지막으로 수정되었습니다. : 56 GMT (DAV : getlastmodified)는 빈 자원 유형을 가지며 이는 콜렉션이 아니며 (DAV : resourcetype) 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원함을 의미합니다.&quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 text / html &quot;(DAV : getcontenttype)은 1998 년 1 월 12 일 월요일 오전 9시 25 분 56 초 (GMT) (DAV : getlastmodified)에 비어 있습니다. 자원 유형, 즉 콜렉션 (DAV : resourcetype)이 아니며 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원합니다.&quot;zzyzx&quot;(DAV : getetag)의 엔티티 태그 인 text / html &quot;(DAV : getcontenttype)은 1998 년 1 월 12 일 월요일 오전 9시 25 분 56 초 (GMT) (DAV : getlastmodified)에 비어 있습니다. 자원 유형, 즉 콜렉션 (DAV : resourcetype)이 아니며 독점 쓰기 및 공유 쓰기 잠금 (DAV : supportedlock)을 모두 지원합니다.</target>
        </trans-unit>
        <trans-unit id="733da1ea06ac6c1e1c6fc58cd54e3b6560771890" translate="yes" xml:space="preserve">
          <source>Note that &lt;a href=&quot;referer&quot;&gt;&lt;code&gt;Referer&lt;/code&gt;&lt;/a&gt; is actually a misspelling of the word &quot;referrer&quot;. The &lt;code&gt;Referrer-Policy&lt;/code&gt; header does not share this misspelling.</source>
          <target state="translated">참고 &lt;a href=&quot;referer&quot;&gt; &lt;code&gt;Referer&lt;/code&gt; &lt;/a&gt; 실제로 단어 &quot;참조 자&quot;의 맞춤법이 잘못되었는지. &lt;code&gt;Referrer-Policy&lt;/code&gt; 헤더이 오자를 공유하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef3de90137df81717d84a3b608f0cb4d4441c8f5" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;Date&lt;/code&gt; is listed in the &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;forbidden header names&lt;/a&gt; in the fetch spec - so this code will not send &lt;code&gt;Date&lt;/code&gt; header:</source>
          <target state="translated">Note that &lt;code&gt;Date&lt;/code&gt; is listed in the &lt;a href=&quot;https://fetch.spec.whatwg.org/#forbidden-header-name&quot;&gt;forbidden header names&lt;/a&gt; in the fetch spec - so this code will not send &lt;code&gt;Date&lt;/code&gt; header:</target>
        </trans-unit>
        <trans-unit id="467c91cc01de63e2d45a14ef7cef2cd1c0b453d1" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;text/plain&lt;/code&gt; does not mean &quot;any kind of textual data.&quot; If they expect a specific kind of textual data, they will likely not consider it a match. Specifically if they download a &lt;code&gt;text/plain&lt;/code&gt; file from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element declaring a CSS file, they will not recognize it as a valid CSS file if presented with &lt;code&gt;text/plain&lt;/code&gt;. The CSS mime type &lt;code&gt;text/css&lt;/code&gt; must be used.</source>
          <target state="translated">Note that &lt;code&gt;text/plain&lt;/code&gt; does not mean &quot;any kind of textual data.&quot; If they expect a specific kind of textual data, they will likely not consider it a match. Specifically if they download a &lt;code&gt;text/plain&lt;/code&gt; file from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; element declaring a CSS file, they will not recognize it as a valid CSS file if presented with &lt;code&gt;text/plain&lt;/code&gt; . The CSS mime type &lt;code&gt;text/css&lt;/code&gt; must be used.</target>
        </trans-unit>
        <trans-unit id="88907399933c092ee116572f07a09e971f2ea48c" translate="yes" xml:space="preserve">
          <source>Note that &lt;code&gt;text/plain&lt;/code&gt; does not mean &lt;em&gt;any kind of textual data&lt;/em&gt;. If they expect a specific kind of textual data, they will likely not consider it a match. Specifically if they download a &lt;code&gt;text/plain&lt;/code&gt; file from a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element declaring a CSS files, they will not recognize it as a valid CSS files if presented with &lt;code&gt;text/plain&lt;/code&gt;. The CSS mime type &lt;code&gt;text/css&lt;/code&gt; must be used.</source>
          <target state="translated">참고 것을 &lt;code&gt;text/plain&lt;/code&gt; 의미하지 않는다 &lt;em&gt;텍스트 데이터의 종류&lt;/em&gt; . 특정 종류의 텍스트 데이터를 기대하면 일치하는 것으로 간주하지 않을 것입니다. 그들이 다운로드 특히 경우 &lt;code&gt;text/plain&lt;/code&gt; A로부터 파일을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 되게 경우 CSS 파일을 선언하는 요소는, 그들은 유효한 CSS 파일로 인식되지 않습니다 &lt;code&gt;text/plain&lt;/code&gt; . CSS mime 유형 &lt;code&gt;text/css&lt;/code&gt; 를 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="e9dc294e0815213796bc980c17d902a5389831b1" translate="yes" xml:space="preserve">
          <source>Note that certain headers are &lt;em&gt;always&lt;/em&gt; allowed: &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-language&quot;&gt;&lt;code&gt;Content-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; (but only with a MIME type of its parsed value (ignoring parameters) of either &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, or &lt;code&gt;text/plain&lt;/code&gt;). These are called the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_headers&quot;&gt;simple headers&lt;/a&gt;, and you don't need to specify them explicitly.</source>
          <target state="translated">참고 특정 헤더가되도록 &lt;em&gt;항상&lt;/em&gt; 허용 : &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-language&quot;&gt; &lt;code&gt;Content-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; (만의 구문 분석 된 값의 MIME 타입 중 하나의 (무시 매개 변수) &lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt; , &lt;code&gt;multipart/form-data&lt;/code&gt; 또는 &lt;code&gt;text/plain&lt;/code&gt; ). 이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/simple_headers&quot;&gt;단순 헤더&lt;/a&gt; 라고하며 명시 적으로 지정할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="bba25497c38589d683455e07bbd32ed641a7836f" translate="yes" xml:space="preserve">
          <source>Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from &lt;code&gt;foo.example&lt;/code&gt;, but the cookie on line 20 is sent by &lt;code&gt;bar.other&lt;/code&gt;, and would thus not be saved if the user has configured their browser to reject all third-party cookies.</source>
          <target state="translated">Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from &lt;code&gt;foo.example&lt;/code&gt; , but the cookie on line 20 is sent by &lt;code&gt;bar.other&lt;/code&gt; , and would thus not be saved if the user has configured their browser to reject all third-party cookies.</target>
        </trans-unit>
        <trans-unit id="0dde5258cb287b7e5f1335b4b8968fc964826436" translate="yes" xml:space="preserve">
          <source>Note that cookies set in CORS responses are subject to normal third-party cookie policies. In the example above, the page is loaded from &lt;code&gt;foo.example&lt;/code&gt;, but the cookie on line 22 is sent by &lt;code&gt;bar.other&lt;/code&gt;, and would thus not be saved if the user has configured their browser to reject all third-party cookies.</source>
          <target state="translated">CORS 응답에 설정된 쿠키에는 일반적인 타사 쿠키 정책이 적용됩니다. 위의 예에서 페이지는 &lt;code&gt;foo.example&lt;/code&gt; 에서 로드 되지만 22 행의 쿠키는 &lt;code&gt;bar.other&lt;/code&gt; 에 의해 전송 되므로 사용자가 브라우저를 모든 타사 쿠키를 거부하도록 구성한 경우 저장되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d2f243d962235cf432887667d07e758583b705da" translate="yes" xml:space="preserve">
          <source>Note that in any access control request, the &lt;a href=&quot;headers/origin&quot;&gt;&lt;code&gt;Origin&lt;/code&gt;&lt;/a&gt; header is &lt;strong&gt;always&lt;/strong&gt; sent.</source>
          <target state="translated">모든 액세스 제어 요청에서 &lt;strong&gt;항상 &lt;/strong&gt;&lt;a href=&quot;headers/origin&quot;&gt; &lt;code&gt;Origin&lt;/code&gt; &lt;/a&gt; 헤더가 전송됩니다.&lt;strong&gt;&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="3c4aaaf9288e658776e9fcfd33685b0df524267a" translate="yes" xml:space="preserve">
          <source>Note that in the case of credentialed requests, the &lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt; header &lt;strong&gt;must not&lt;/strong&gt; have a wildcard value of &quot;*&quot;. It &lt;strong&gt;must&lt;/strong&gt; mention a valid origin domain. The example above can be seen &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;running here&lt;/a&gt;.</source>
          <target state="translated">자격 증명 요청의 경우 &lt;code&gt;Access-Control-Allow-Origin:&lt;/code&gt; 헤더 에는 &quot;*&quot;와일드 카드 값이 &lt;strong&gt;없어야합니다&lt;/strong&gt; . 그것은 &lt;strong&gt;해야한다&lt;/strong&gt; 유효한 원래 도메인을 언급. 위 예제는 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;여기&lt;/a&gt; 에서 실행되는 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="13d83d306a8b3e2d42d4c3ab70727c3afb42e937" translate="yes" xml:space="preserve">
          <source>Note that inline event handlers are blocked as well:</source>
          <target state="translated">인라인 이벤트 핸들러도 차단됩니다.</target>
        </trans-unit>
        <trans-unit id="482d5e7da59888db6e881351a22dd4cf2b2344da" translate="yes" xml:space="preserve">
          <source>Note that now, no domain other than &lt;code&gt;http://foo.example&lt;/code&gt; (identified by the ORIGIN: header in the request, as in line 10 above) can access the resource in a cross-site manner. The &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header should contain the value that was sent in the request's &lt;code&gt;Origin&lt;/code&gt; header.</source>
          <target state="translated">이제 &lt;code&gt;http://foo.example&lt;/code&gt; 이외의 도메인 (위의 10 행에서와 같이 요청에서 ORIGIN : 헤더로 식별) 이외의 도메인 은 사이트 간 방식으로 자원에 액세스 할 수 없습니다. &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더는 요청의 전송 된 값이 포함되어야 &lt;code&gt;Origin&lt;/code&gt; 헤더를.</target>
        </trans-unit>
        <trans-unit id="ceb9adaebb159a4870cdc204a80a7efec8b3349e" translate="yes" xml:space="preserve">
          <source>Note that referer is actually a misspelling of the word &quot;referrer&quot;. See &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_referer&quot;&gt;HTTP referer on Wikipedia&lt;/a&gt; for more details.</source>
          <target state="translated">referer는 실제로 &quot;referrer&quot;라는 단어의 철자가 틀립니다. 자세한 내용 &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_referer&quot;&gt;은 Wikipedia의 HTTP referer&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="a7b9533a26a7882e1e3d72a5cacf83bed69cae18" translate="yes" xml:space="preserve">
          <source>Note that the &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; header can't be wildcarded and always needs to be listed explicitly.</source>
          <target state="translated">Note that the &lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; header can't be wildcarded and always needs to be listed explicitly.</target>
        </trans-unit>
        <trans-unit id="e77f5478415d507325d52c5303120a20756b6b78" translate="yes" xml:space="preserve">
          <source>Note that the &lt;code&gt;Set-Cookie&lt;/code&gt; response header in the example above also sets a further cookie. In case of failure, an exception&amp;mdash;depending on the API used&amp;mdash;is raised.</source>
          <target state="translated">위 예제 의 &lt;code&gt;Set-Cookie&lt;/code&gt; 응답 헤더는 추가 쿠키를 설정합니다. 실패한 경우 사용 된 API에 따라 예외가 발생합니다.</target>
        </trans-unit>
        <trans-unit id="4bd9d3cba4ca919c6212e4317b95019fb2ffe615" translate="yes" xml:space="preserve">
          <source>Note that the HTTP response headers &quot;Etag&quot; and &quot;Last-Modified&quot; (see
   [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;], Sections &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; and &lt;a href=&quot;#section-14.29&quot;&gt;14.29&lt;/a&gt;) are defined per URL (not per
   resource), and are used by clients for caching.  Therefore servers
   must ensure that executing any operation that affects the URL
   namespace (such as COPY, MOVE, DELETE, PUT, or MKCOL) does preserve
   their semantics, in particular: 

   o  For any given URL, the &quot;Last-Modified&quot; value MUST increment every
      time the representation returned upon GET changes (within the
      limits of timestamp resolution).

   o  For any given URL, an &quot;ETag&quot; value MUST NOT be reused for
      different representations returned by GET.

   In practice this means that servers

   o  might have to increment &quot;Last-Modified&quot; timestamps for every
      resource inside the destination namespace of a namespace operation
      unless it can do so more selectively, and

   o  similarly, might have to re-assign &quot;ETag&quot; values for these
      resources (unless the server allocates entity tags in a way so
      that they are unique across the whole URL namespace managed by the
      server).

   Note that these considerations also apply to specific use cases, such
   as using PUT to create a new resource at a URL that has been mapped
   before, but has been deleted since then.

   Finally, WebDAV properties (such as DAV:getetag and DAV:
   getlastmodified) that inherit their semantics from HTTP headers must
   behave accordingly.</source>
          <target state="translated">HTTP 응답 헤더 &quot;Etag&quot;및 &quot;Last-Modified&quot;([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; ], 섹션 &lt;a href=&quot;#section-14.19&quot;&gt;14.19&lt;/a&gt; 및 &lt;a href=&quot;#section-14.29&quot;&gt;14.29 참조)&lt;/a&gt;)은 URL별로 (리소스별로가 아님) 정의되며 클라이언트가 캐싱에 사용합니다. 따라서 서버는 URL 네임 스페이스에 영향을 미치는 작업 (예 : COPY, MOVE, DELETE, PUT 또는 MKCOL)을 실행하면 시맨틱이 특히 보존되어야합니다. o 특정 URL에 대해 &quot;마지막 수정&quot;값은 반드시 증가해야합니다. GET이 변경 될 때마다 반환 된 표현이 변경 될 때마다 (타임 스탬프 해상도 제한 내) o 주어진 URL의 경우, &quot;ETag&quot;값은 GET이 반환 한 다른 표현에 재사용해서는 안됩니다. 실제로 이것은 서버가 네임 스페이스 작업의 대상 네임 스페이스 내의 모든 리소스에 대해 &quot;마지막으로 수정 된&quot;타임 스탬프를 더 선택적으로 또는 유사하게 수행 할 수없는 경우를 제외하고 증가시켜야 할 수도 있음을 의미합니다.서버가 서버가 관리하는 전체 URL 네임 스페이스에서 고유 한 방식으로 엔티티 태그를 할당하지 않는 한 이러한 자원에 대해 &quot;ETag&quot;값을 다시 할당해야 할 수도 있습니다. 이러한 고려 사항은 PUT을 사용하여 이전에 매핑되었지만 그 이후 삭제 된 URL에 새 리소스를 만드는 등의 특정 사용 사례에도 적용됩니다. 마지막으로 HTTP 헤더에서 의미를 상속하는 WebDAV 속성 (예 : DAV : getetag 및 DAV : getlastmodified)은 그에 따라 동작해야합니다.예를 들어 PUT을 사용하여 이전에 매핑되었지만 그 이후로 삭제 된 URL에서 새 리소스를 만드는 등의 작업을 수행 할 수 있습니다. 마지막으로 HTTP 헤더에서 의미를 상속하는 WebDAV 속성 (예 : DAV : getetag 및 DAV : getlastmodified)은 그에 따라 동작해야합니다.예를 들어 PUT을 사용하여 이전에 매핑되었지만 그 이후로 삭제 된 URL에서 새 리소스를 만드는 등의 작업을 수행 할 수 있습니다. 마지막으로 HTTP 헤더에서 의미를 상속하는 WebDAV 속성 (예 : DAV : getetag 및 DAV : getlastmodified)은 그에 따라 동작해야합니다.</target>
        </trans-unit>
        <trans-unit id="69570cc89b0c6f65ebda0f608773114dcb46dbc3" translate="yes" xml:space="preserve">
          <source>Note that the phase is set to &lt;code&gt;dns&lt;/code&gt; in this report and no &lt;code&gt;server_ip&lt;/code&gt; is available to include.</source>
          <target state="translated">이 보고서에서 단계는 &lt;code&gt;dns&lt;/code&gt; 로 설정 되어 있으며 포함 할 수있는 &lt;code&gt;server_ip&lt;/code&gt; 가 없습니다.</target>
        </trans-unit>
        <trans-unit id="524a5391e04da5188d8d6239340a145a47bbb106" translate="yes" xml:space="preserve">
          <source>Note that the server is not obligated to use any compression method. Compression highly depends on server settings and used server modules.</source>
          <target state="translated">서버는 압축 방법을 사용할 의무가 없습니다. 압축은 서버 설정 및 사용 된 서버 모듈에 따라 다릅니다.</target>
        </trans-unit>
        <trans-unit id="8fc871d77bd2a17b1592fb06f1975897a38785b1" translate="yes" xml:space="preserve">
          <source>Note that these redirections break the back button in a browser: you can go back to a page with this header but it instantaneously moves forward again.</source>
          <target state="translated">이러한 리디렉션은 브라우저에서 뒤로 버튼을 깰 수 있습니다.이 헤더가있는 페이지로 돌아갈 수 있지만 즉시 다시 앞으로 이동합니다.</target>
        </trans-unit>
        <trans-unit id="c19e315f56095fa3fee06607e90fa58ce789809b" translate="yes" xml:space="preserve">
          <source>Note that this example doesn't specify a &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt;; with the example CSP, this site uses the setting specified by the &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt;&lt;code&gt;default-src&lt;/code&gt;&lt;/a&gt; directive, which means that scripts can be loaded only from the originating server.</source>
          <target state="translated">이 예제는 &lt;a href=&quot;headers/content-security-policy/script-src&quot;&gt; &lt;code&gt;script-src&lt;/code&gt; 를&lt;/a&gt; 지정하지 않습니다 . CSP 예제에서이 사이트는 &lt;a href=&quot;headers/content-security-policy/default-src&quot;&gt; &lt;code&gt;default-src&lt;/code&gt; &lt;/a&gt; 지시문에 지정된 설정을 사용 합니다. 즉, 원래 서버에서만 스크립트를로드 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="877bc59b4de188751558af6e41e4cec35b5f4e71" translate="yes" xml:space="preserve">
          <source>Note that using &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and compression at the hop level is so rare that most servers, like Apache, nginx, or IIS, have no easy way to configure it. Such configuration usually happens at the proxy level.</source>
          <target state="translated">사용하는 것을 참고 &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 홉 수준에서 압축하는 대부분의 서버, 아파치, nginx를, 또는 IIS와 같은, 그것을 구성하는 쉬운 방법이 없다 정도로 드물다. 이러한 구성은 일반적으로 프록시 수준에서 발생합니다.</target>
        </trans-unit>
        <trans-unit id="50344a1423a5adbde9caeb6452a36fbce49d2ef4" translate="yes" xml:space="preserve">
          <source>Note the appropriate headers being sent back in response to the &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; preflight as well as to the &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; data. One resource thus handles the preflight as well as the actual request. In the response to the &lt;code&gt;OPTIONS&lt;/code&gt; request, the server notifies the client that the actual request can indeed be made with the &lt;code&gt;POST&lt;/code&gt; method, and header fields such as &lt;code&gt;X-PINGARUNER&lt;/code&gt; can be sent with the actual request. This example can be &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;seen running here&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 프리 플라이트 및 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 데이터 에 대한 응답으로 적절한 헤더가 다시 전송됩니다 . 따라서 하나의 리소스는 실제 요청뿐만 아니라 프리 플라이트도 처리합니다. &lt;code&gt;OPTIONS&lt;/code&gt; 요청에 대한 응답으로, 서버는 클라이언트에게 실제 요청이 실제로 &lt;code&gt;POST&lt;/code&gt; 메소드를 사용하여 수행 될 수 있음을 통지하고 &lt;code&gt;X-PINGARUNER&lt;/code&gt; 와 같은 헤더 필드 가 실제 요청과 함께 전송 될 수 있음을 알려줍니다 . 이 예제는 &lt;a href=&quot;http://arunranga.com/examples/access-control/&quot;&gt;여기서 실행되는&lt;/a&gt; 것을 볼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="f8700026b2d436d877e859c62874b8e75096e70c" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;X-Content-Type-Options&lt;/code&gt; only apply &lt;a href=&quot;https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-nosniff?&quot;&gt;request-blocking due to &lt;code&gt;nosniff&lt;/code&gt;&lt;/a&gt; for &lt;a href=&quot;https://fetch.spec.whatwg.org/#concept-request-destination&quot;&gt;request destinations&lt;/a&gt; of &quot;&lt;code&gt;script&lt;/code&gt;&quot; and &quot;&lt;code&gt;style&lt;/code&gt;&quot;. However, it also &lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/services/network/cross_origin_read_blocking_explainer.md#determining-whether-a-response-is-corb_protected&quot;&gt;enables Cross-Origin Read Blocking (CORB)&lt;/a&gt; protection for HTML, TXT, JSON and XML files (excluding SVG &lt;code&gt;image/svg+xml&lt;/code&gt;).</source>
          <target state="translated">Note: &lt;code&gt;X-Content-Type-Options&lt;/code&gt; only apply &lt;a href=&quot;https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-nosniff?&quot;&gt;request-blocking due to &lt;code&gt;nosniff&lt;/code&gt; &lt;/a&gt; for &lt;a href=&quot;https://fetch.spec.whatwg.org/#concept-request-destination&quot;&gt;request destinations&lt;/a&gt; of &quot; &lt;code&gt;script&lt;/code&gt; &quot; and &quot; &lt;code&gt;style&lt;/code&gt; &quot;. However, it also &lt;a href=&quot;https://chromium.googlesource.com/chromium/src/+/master/services/network/cross_origin_read_blocking_explainer.md#determining-whether-a-response-is-corb_protected&quot;&gt;enables Cross-Origin Read Blocking (CORB)&lt;/a&gt; protection for HTML, TXT, JSON and XML files (excluding SVG &lt;code&gt;image/svg+xml&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6f9a467b619f845068306fd652ae12e97054ab19" translate="yes" xml:space="preserve">
          <source>Note: &lt;code&gt;nosniff&lt;/code&gt; only applies to &quot;&lt;code&gt;script&lt;/code&gt;&quot; and &quot;&lt;code&gt;style&lt;/code&gt;&quot; types. Also applying &lt;code&gt;nosniff&lt;/code&gt; to images turned out to be &lt;a href=&quot;https://github.com/whatwg/fetch/issues/395&quot;&gt;incompatible with existing web sites&lt;/a&gt;.</source>
          <target state="translated">참고 : &lt;code&gt;nosniff&lt;/code&gt; 는 &quot; &lt;code&gt;script&lt;/code&gt; &quot;및 &quot; &lt;code&gt;style&lt;/code&gt; &quot;유형 에만 적용됩니다 . 또한 이미지에 &lt;code&gt;nosniff&lt;/code&gt; 를 적용 하면 &lt;a href=&quot;https://github.com/whatwg/fetch/issues/395&quot;&gt;기존 웹 사이트와 호환되지 않는&lt;/a&gt; 것으로 나타났습니다 .</target>
        </trans-unit>
        <trans-unit id="47ced801d5b0d1f983d2e7470e661e535c34436b" translate="yes" xml:space="preserve">
          <source>Note: Some disadvantages of HTTP content negotiation are explained in &lt;a href=&quot;https://wiki.whatwg.org/wiki/Why_not_conneg&quot;&gt;a wiki page from WHATWG&lt;/a&gt;. HTML5 provides alternatives to content negotiation via, for example, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source&quot;&gt;&lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt; element&lt;/a&gt;.</source>
          <target state="translated">Note: Some disadvantages of HTTP content negotiation are explained in &lt;a href=&quot;https://wiki.whatwg.org/wiki/Why_not_conneg&quot;&gt;a wiki page from WHATWG&lt;/a&gt;. HTML5 provides alternatives to content negotiation via, for example, the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/source&quot;&gt; &lt;code&gt;&amp;lt;source&amp;gt;&lt;/code&gt; element&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="b0a73e692e8090c4e69881a90ac391d6c2513e11" translate="yes" xml:space="preserve">
          <source>Note: this user agent was retrieved from an iPhone XR simulator and may be different on device.</source>
          <target state="translated">참고 :이 사용자 에이전트는 iPhone XR 시뮬레이터에서 검색되었으며 장치마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="70440046a3dc2e079f23ee1c57dfa76669b732aa" translate="yes" xml:space="preserve">
          <source>Notes</source>
          <target state="translated">Notes</target>
        </trans-unit>
        <trans-unit id="9c3befe7e22c8667bc957541f49b0ee79970b588" translate="yes" xml:space="preserve">
          <source>Notes:</source>
          <target state="translated">Notes:</target>
        </trans-unit>
        <trans-unit id="d4d54b40413d81662c3ae8fb48a8db7dac1e55e9" translate="yes" xml:space="preserve">
          <source>Notification that the requested resource doesn't exist:</source>
          <target state="translated">요청한 리소스가 존재하지 않는다는 알림 :</target>
        </trans-unit>
        <trans-unit id="bc2f4cbb79515b85b2c0d07b3e431b778d1e12e4" translate="yes" xml:space="preserve">
          <source>Notification that the requested resource has permanently moved:</source>
          <target state="translated">요청한 자원이 영구적으로 이동했다는 알림 :</target>
        </trans-unit>
        <trans-unit id="e7ebe04fdc7c7c8ec10f6524eb3a76930caca627" translate="yes" xml:space="preserve">
          <source>Notifying users that your site uses cookies.</source>
          <target state="translated">Notifying users that your site uses cookies.</target>
        </trans-unit>
        <trans-unit id="cc6b7b178c03549f9e2a165aa485d916c9c4a3c5" translate="yes" xml:space="preserve">
          <source>Now try to reproduce the failing transaction and check the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;console&lt;/a&gt; if you are seeing a CORS violation error message. It will probably look like this:</source>
          <target state="translated">이제 실패한 트랜잭션을 재현하고 CORS 위반 오류 메시지가 표시되면 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Tools/Web_Console&quot;&gt;콘솔을&lt;/a&gt; 확인하십시오 . 아마 다음과 같이 보일 것입니다 :</target>
        </trans-unit>
        <trans-unit id="c64e26807cf49c7d258e3a38b854c3cbcc1da88a" translate="yes" xml:space="preserve">
          <source>Now, if you are logged into your bank account and your cookies are still valid (and there is no other validation), you will transfer money as soon as you load the HTML that contains this image. There are a few techniques that are used to prevent this from happening:</source>
          <target state="translated">이제 은행 계좌에 로그인했는데 쿠키가 여전히 유효하고 다른 유효성 검사가없는 경우이 이미지가 포함 된 HTML을로드하자마자 돈을 이체합니다. 이를 방지하기 위해 사용되는 몇 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="316d446c2137e3fdd66e7c6a93e085285024a055" translate="yes" xml:space="preserve">
          <source>Now, with every new request to the server, the browser will send back all previously stored cookies to the server using the &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">이제 서버에 대한 모든 새로운 요청이있을 때마다 브라우저는 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여 이전에 저장된 모든 쿠키를 서버로 다시 보냅니다 .</target>
        </trans-unit>
        <trans-unit id="5ab30790123d078d54cad999a659c75f56015ba0" translate="yes" xml:space="preserve">
          <source>Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. If both &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Max-Age&lt;/code&gt; are set, &lt;code&gt;Max-Age&lt;/code&gt; has precedence.</source>
          <target state="translated">Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. If both &lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Max-Age&lt;/code&gt; are set, &lt;code&gt;Max-Age&lt;/code&gt; has precedence.</target>
        </trans-unit>
        <trans-unit id="7f7f99421dc23022f9d4dad472dad8c1219a1e24" translate="yes" xml:space="preserve">
          <source>Number of seconds until the cookie expires. A zero or negative number will expire the cookie immediately. Older browsers (ie6, ie7, and ie8) do not support max-age. For other browsers, if both (&lt;code&gt;Expires&lt;/code&gt; and &lt;code&gt;Max-Age&lt;/code&gt;) are set, &lt;code&gt;Max-Age&lt;/code&gt; will have precedence.</source>
          <target state="translated">쿠키가 만료 될 때까지의 시간 (초)입니다. 0 또는 음수는 쿠키를 즉시 만료시킵니다. 이전 브라우저 (예 : 6, ie7 및 ie8)는 최대 연령을 지원하지 않습니다. 다른 브라우저의 경우 ( &lt;code&gt;Expires&lt;/code&gt; 및 &lt;code&gt;Max-Age&lt;/code&gt; )가 모두 설정된 경우 &lt;code&gt;Max-Age&lt;/code&gt; 가 우선합니다.</target>
        </trans-unit>
        <trans-unit id="3d83594903f329fd61c74db928326d01462cddbd" translate="yes" xml:space="preserve">
          <source>OGG</source>
          <target state="translated">OGG</target>
        </trans-unit>
        <trans-unit id="abdf49e40c006cace12b860c577ebfd2f514568f" translate="yes" xml:space="preserve">
          <source>OGG audio</source>
          <target state="translated">OGG 오디오</target>
        </trans-unit>
        <trans-unit id="e4b5a3d314e8c7201a4940347e84ecf91f139bbf" translate="yes" xml:space="preserve">
          <source>OGG video</source>
          <target state="translated">OGG 비디오</target>
        </trans-unit>
        <trans-unit id="891db7e7c01ff7470565d35fe04852a76dd5cce8" translate="yes" xml:space="preserve">
          <source>OPR/xyz &lt;sup&gt;[1]&lt;/sup&gt;</source>
          <target state="translated">OPR / xyz &lt;sup&gt;[1]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="39dd320e8c4e9f06b35e0be0b4942ac2022fb9c1" translate="yes" xml:space="preserve">
          <source>OPTIONS</source>
          <target state="translated">OPTIONS</target>
        </trans-unit>
        <trans-unit id="940af152764ecc453e50e12e715144d6352503d7" translate="yes" xml:space="preserve">
          <source>OPTIONS (RFC 7231)</source>
          <target state="translated">옵션 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="de8aa86286dbb8eb74d2748c7b6d4486d0458203" translate="yes" xml:space="preserve">
          <source>OS</source>
          <target state="translated">OS</target>
        </trans-unit>
        <trans-unit id="59a529dd0ce6ef7e06d5ff9358aad9afbfdbe590" translate="yes" xml:space="preserve">
          <source>OWASP Article: &lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">OWASP Article: &lt;a href=&quot;https://cheatsheetseries.owasp.org/cheatsheets/HTTP_Strict_Transport_Security_Cheat_Sheet.html&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6c906f4846c2cf5d1ef947e89e2af3a972efb9b3" translate="yes" xml:space="preserve">
          <source>OWASP Article: &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">OWASP 기사 : &lt;a href=&quot;https://www.owasp.org/index.php/HTTP_Strict_Transport_Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="305837b5ab2d13ba142d5f5e5b4aaf80f1816434" translate="yes" xml:space="preserve">
          <source>Observe that final empty line, this separates the data block from the header block. As there is no &lt;code&gt;Content-Length&lt;/code&gt; provided in an HTTP header, this data block is presented empty, marking the end of the headers, allowing the server to process the request the moment it receives this empty line.</source>
          <target state="translated">마지막 빈 줄을 관찰하면 데이터 블록이 헤더 블록과 분리됩니다. HTTP 헤더에 &lt;code&gt;Content-Length&lt;/code&gt; 가 제공 되지 않으므로이 데이터 블록은 비어 있으며 헤더의 끝을 표시하여 서버가이 빈 라인을받는 순간 요청을 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="4e7d8c7849f1648c77052055f32051f9581d8bc7" translate="yes" xml:space="preserve">
          <source>Obsolete</source>
          <target state="translated">Obsolete</target>
        </trans-unit>
        <trans-unit id="a81ab58e0a7c48e950453b07afbc07c0041ca461" translate="yes" xml:space="preserve">
          <source>Obviously, this method only works with HTML pages (or similar) and cannot be used for images or any other type of content.</source>
          <target state="translated">분명히이 방법은 HTML 페이지 (또는 유사)에서만 작동하며 이미지 나 다른 유형의 콘텐츠에는 사용할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="025d14a67a15ceaab6a6ffb81ec2b366a6b1d2f3" translate="yes" xml:space="preserve">
          <source>Obviously, this method only works with HTML, and cannot be used for images or other types of content.</source>
          <target state="translated">Obviously, this method only works with HTML, and cannot be used for images or other types of content.</target>
        </trans-unit>
        <trans-unit id="252f4b9010eb27d3590ba7cf70072cb1ff858d02" translate="yes" xml:space="preserve">
          <source>Of course, there is absolutely no guarantee that another browser will not hijack some of these things (like Chrome hijacked the Safari string in the past). That's why browser detection using the user agent string is unreliable and should be done only with the check of the version number (hijacking of past versions is less likely).</source>
          <target state="translated">물론 다른 브라우저가 이러한 것들 중 일부를 납치하지 않을 것이라는 보장은 없습니다 (예 : Chrome이 과거에 Safari 문자열을 납치 한 것처럼). 그렇기 때문에 사용자 에이전트 문자열을 사용한 브라우저 감지는 신뢰할 수 없으며 버전 번호를 확인해야만 수행 할 수 있습니다 (과거 버전의 도용 가능성이 적음).</target>
        </trans-unit>
        <trans-unit id="728f9313847dcc9ab70ed90ce6b11c13e63d839d" translate="yes" xml:space="preserve">
          <source>Officially standardized, in May 2015, HTTP/2 has had much success. By July 2016, 8.7% of all Web sites&lt;sup&gt;&lt;a href=&quot;https://w3techs.com/technologies/details/ce-http2/all/all&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; were already using it, representing more than 68% of all requests&lt;sup&gt;&lt;a href=&quot;https://www.keycdn.com/blog/http2-statistics/&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;. High-traffic Web sites showed the most rapid adoption, saving considerably on data transfer overheads and subsequent budgets.</source>
          <target state="translated">2015 년 5 월 공식적으로 표준화 된 HTTP / 2는 많은 성공을 거두었습니다. 2016 년 7 월까지 모든 웹 사이트의 8.7 % 가 이미이를 사용하고 있었으며 &lt;sup&gt;&lt;a href=&quot;https://w3techs.com/technologies/details/ce-http2/all/all&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 모든 요청의 68 % 이상을 나타 냈습니다 &lt;sup&gt;&lt;a href=&quot;https://www.keycdn.com/blog/http2-statistics/&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt; . 트래픽이 많은 웹 사이트가 가장 빠르게 채택되어 데이터 전송 오버 헤드와 그에 따른 예산을 크게 절약했습니다.</target>
        </trans-unit>
        <trans-unit id="deebb87fa96ee64c661fcfa4f0b7108c7212c6a5" translate="yes" xml:space="preserve">
          <source>Older HTTP/1.0 user agent implementations might send an extra CRLF
   after a POST request as a workaround for some early server
   applications that failed to read message body content that was not
   terminated by a line-ending.  An HTTP/1.1 user agent MUST NOT preface
   or follow a request with an extra CRLF.  If terminating the request
   message body with a line-ending is desired, then the user agent MUST
   count the terminating CRLF octets as part of the message body length.

   In the interest of robustness, a server that is expecting to receive
   and parse a request-line SHOULD ignore at least one empty line (CRLF)
   received prior to the request-line. 

   Although the line terminator for the start-line and header fields is
   the sequence CRLF, a recipient MAY recognize a single LF as a line
   terminator and ignore any preceding CR.

   Although the request-line and status-line grammar rules require that
   each of the component elements be separated by a single SP octet,
   recipients MAY instead parse on whitespace-delimited word boundaries
   and, aside from the CRLF terminator, treat any form of whitespace as
   the SP separator while ignoring preceding or trailing whitespace;
   such whitespace includes one or more of the following octets: SP,
   HTAB, VT (%x0B), FF (%x0C), or bare CR.  However, lenient parsing can
   result in security vulnerabilities if there are multiple recipients
   of the message and each has its own unique interpretation of
   robustness (see &lt;a href=&quot;#section-9.5&quot;&gt;Section 9.5&lt;/a&gt;).

   When a server listening only for HTTP request messages, or processing
   what appears from the start-line to be an HTTP request message,
   receives a sequence of octets that does not match the HTTP-message
   grammar aside from the robustness exceptions listed above, the server
   SHOULD respond with a 400 (Bad Request) response.</source>
          <target state="translated">이전 HTTP / 1.0 사용자 에이전트 구현은 줄 끝으로 끝나지 않은 메시지 본문 내용을 읽지 못한 일부 초기 서버 응용 프로그램에 대한 해결 방법으로 POST 요청 후 추가 CRLF를 보낼 수 있습니다. HTTP / 1.1 사용자 에이전트는 추가 CRLF로 요청을 시작하거나 따라 가지 않아야합니다. 줄 끝으로 요청 메시지 본문을 종료해야하는 경우 사용자 에이전트는 메시지 본문 길이의 일부로 종료 CRLF 옥텟을 계산해야합니다. 견고성을 위해, 요청 라인을 수신하고 파싱 할 것으로 예상되는 서버는 요청 라인 이전에 수신 된 적어도 하나의 빈 라인 (CRLF)을 무시해야한다. 시작 라인 및 헤더 필드에 대한 라인 종결자가 시퀀스 CRLF이지만, 수신자는 단일 LF를 라인 종결 자로 인식하고 선행 CR을 무시할 수 있습니다.요청 라인과 상태 라인 문법 규칙에 따라 각 구성 요소를 단일 SP 8 진수로 분리해야하지만 수신자는 공백으로 구분 된 단어 경계를 구문 분석하고 CRLF 종료자를 제외하고 모든 형태의 공백을 선행 또는 후행 공백을 무시하면서 SP 분리기; 이러한 공백에는 SP, HTAB, VT (% x0B), FF (% x0C) 또는 베어 CR 중 하나 이상이 포함됩니다. 그러나 메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조수신자는 공백으로 구분 된 단어 경계를 구문 분석하고 CRLF 터미네이터를 제외하고 선행 또는 후행 공백을 무시하면서 모든 형식의 공백을 SP 구분자로 처리 할 수 ​​있습니다. 이러한 공백에는 SP, HTAB, VT (% x0B), FF (% x0C) 또는 베어 CR 중 하나 이상이 포함됩니다. 그러나 메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조수신자는 공백으로 구분 된 단어 경계를 구문 분석하고 CRLF 터미네이터를 제외하고 선행 또는 후행 공백을 무시하면서 모든 형태의 공백을 SP 구분자로 처리 할 수 ​​있습니다. 이러한 공백에는 SP, HTAB, VT (% x0B), FF (% x0C) 또는 베어 CR 중 하나 이상이 포함됩니다. 그러나 메시지를받는 사람이 여러 명이고 각각 ​​고유 한 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조메시지의 수신자가 여러 명이고 각각 ​​고유의 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조메시지의 수신자가 여러 명이고 각각 ​​고유의 견고성 해석이있는 경우 관대 한 구문 분석으로 인해 보안 취약점이 발생할 수 있습니다 (참조&lt;a href=&quot;#section-9.5&quot;&gt;섹션 9.5&lt;/a&gt; ). 서버가 HTTP 요청 메시지 만 수신하거나 시작 라인에서 HTTP 요청 메시지로 처리되는 것을 처리 할 때 위에 나열된 견고성 예외를 제외하고 HTTP 메시지 문법과 일치하지 않는 일련의 8 진수를 수신합니다. 400 (잘못된 요청) 응답으로 응답해야합니다.</target>
        </trans-unit>
        <trans-unit id="d872f7a14ebe4a8471428817721bd23600d4c8d3" translate="yes" xml:space="preserve">
          <source>Older, Presto-based Opera releases used:</source>
          <target state="translated">Older, Presto-based Opera releases used:</target>
        </trans-unit>
        <trans-unit id="eccaba534ca9f5591f571f69a93afec9e199b19d" translate="yes" xml:space="preserve">
          <source>On Desktop, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; is the fixed string &quot;&lt;code&gt;20100101&lt;/code&gt;&quot;</source>
          <target state="translated">데스크탑에서 &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; 은 고정 문자열 &quot; &lt;code&gt;20100101&lt;/code&gt; &quot;입니다.</target>
        </trans-unit>
        <trans-unit id="dc422faa1ec0593c27e5dd94351848b8f4c22acb" translate="yes" xml:space="preserve">
          <source>On Desktop, &lt;em&gt;&lt;strong&gt;geckotrail&lt;/strong&gt;&lt;/em&gt; is the fixed string &quot;20100101&quot;</source>
          <target state="translated">데스크탑에서 &lt;em&gt;&lt;strong&gt;geckotrail&lt;/strong&gt;&lt;/em&gt; 은 고정 문자열 &quot;20100101&quot;입니다.</target>
        </trans-unit>
        <trans-unit id="8dd97c057052c1aa055df41637526c28ed53a66c" translate="yes" xml:space="preserve">
          <source>On the application server, the web application &lt;em&gt;must&lt;/em&gt; check for the full cookie name including the prefix&amp;mdash;user agents &lt;em&gt;do not&lt;/em&gt; strip the prefix from the cookie before sending it in a request's &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">On the application server, the web application &lt;em&gt;must&lt;/em&gt; check for the full cookie name including the prefix&amp;mdash;user agents &lt;em&gt;do not&lt;/em&gt; strip the prefix from the cookie before sending it in a request's &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; header.</target>
        </trans-unit>
        <trans-unit id="3c55762a68b0fe67eed8220b92fc45172bf563b7" translate="yes" xml:space="preserve">
          <source>On the client side, you can advertise a list of compression schemes that will be sent along in an HTTP request. The &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt; header is used for negotiating content encoding.</source>
          <target state="translated">클라이언트 측에서는 HTTP 요청과 함께 전송 될 압축 체계 목록을 광고 할 수 있습니다. &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; 헤더는 콘텐츠 인코딩을 협상을 위해 사용된다.</target>
        </trans-unit>
        <trans-unit id="20a2d4459ba0ff06a3947af0742918817fc3eb06" translate="yes" xml:space="preserve">
          <source>On the opposite side of the communication channel, is the server which &lt;em&gt;serves&lt;/em&gt; the document as requested by the client. A server presents only as a single machine virtually: this is because it may actually be a collection of servers, sharing the load (load balancing) or a complex piece of software interrogating other computers (like cache, a DB server, e-commerce servers, &amp;hellip;), totally or partially generating the document on demand.</source>
          <target state="translated">통신 채널의 반대편 에는 클라이언트가 요청한대로 문서 를 &lt;em&gt;제공&lt;/em&gt; 하는 서버가 &lt;em&gt;있습니다&lt;/em&gt; . 서버는 사실상 단일 머신으로 만 제공됩니다. 실제로 서버 모음,로드 공유 (로드 밸런싱) 또는 다른 컴퓨터 (캐시, DB 서버, 전자 상거래 서버)를 조사하는 복잡한 소프트웨어 일 수 있기 때문입니다. ,&amp;hellip;), 필요에 따라 문서를 완전히 또는 부분적으로 생성합니다.</target>
        </trans-unit>
        <trans-unit id="1d44e146a437cbe9c7a80fe6b5dbfd026b131cb7" translate="yes" xml:space="preserve">
          <source>On the opposite side of the communication channel, is the server, which &lt;em&gt;serves&lt;/em&gt; the document as requested by the client. A server appears as only a single machine virtually: this is because it may actually be a collection of servers, sharing the load (load balancing) or a complex piece of software interrogating other computers (like cache, a DB server, or e-commerce servers), totally or partially generating the document on demand.</source>
          <target state="translated">On the opposite side of the communication channel, is the server, which &lt;em&gt;serves&lt;/em&gt; the document as requested by the client. A server appears as only a single machine virtually: this is because it may actually be a collection of servers, sharing the load (load balancing) or a complex piece of software interrogating other computers (like cache, a DB server, or e-commerce servers), totally or partially generating the document on demand.</target>
        </trans-unit>
        <trans-unit id="f66620c684e8eb3de3262130d1e274b88e19dc70" translate="yes" xml:space="preserve">
          <source>On the other hand, &quot;private&quot; indicates that the response is intended for a single user only and must not be stored by a shared cache. A private browser cache may store the response in this case.</source>
          <target state="translated">반면, &quot;비공개&quot;는 응답이 단일 사용자만을위한 것이며 공유 캐시에 저장되어서는 안됨을 나타냅니다. 이 경우 개인 브라우저 캐시는 응답을 저장할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ea2b9186180061f8add8f4849f50a8d8fdd4125d" translate="yes" xml:space="preserve">
          <source>On the standard track</source>
          <target state="translated">표준 트랙에서</target>
        </trans-unit>
        <trans-unit id="7a52b249e2a4a19c25945f39f4219130ebc33285" translate="yes" xml:space="preserve">
          <source>Once a Resource has been created and its Member URI is known, that
   URI can be used to retrieve, edit, and delete the Resource.  &lt;a href=&quot;#section-11&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-11&quot;&gt;11&lt;/a&gt; describes extensions to the Atom Syndication Format used in the
   Atom Protocol for editing purposes.</source>
          <target state="translated">자원이 작성되고 구성원 URI가 알려지면 해당 URI를 사용하여 자원을 검색, 편집 및 삭제할 수 있습니다. &lt;a href=&quot;#section-11&quot;&gt;11 &lt;/a&gt;&lt;a href=&quot;#section-11&quot;&gt;장&lt;/a&gt; 에서는 편집을 위해 Atom 프로토콜에서 사용되는 Atom 신디케이션 형식의 확장에 대해 설명합니다.</target>
        </trans-unit>
        <trans-unit id="1157586853a498fecd0d5788bdf7e2636f066412" translate="yes" xml:space="preserve">
          <source>Once a resource is stored in a cache, it could theoretically be served by the cache forever. Caches have finite storage so items are periodically removed from storage. This process is called &lt;em&gt;cache eviction&lt;/em&gt;. On the other side, some resources may change on the server so the cache should be updated. As HTTP is a client-server protocol, servers can't contact caches and clients when a resource changes; they have to communicate an expiration time for the resource. Before this expiration time, the resource is &lt;em&gt;fresh&lt;/em&gt;; after the expiration time, the resource is &lt;em&gt;stale&lt;/em&gt;. Eviction algorithms often privilege fresh resources over stale resources. Note that a stale resource is not evicted or ignored; when the cache receives a request for a stale resource, it forwards this request with a &lt;a href=&quot;headers/if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt; to check if it is in fact still fresh. If so, the server returns a &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt; (Not Modified) header without sending the body of the requested resource, saving some bandwidth.</source>
          <target state="translated">일단 리소스가 캐시에 저장되면 이론적으로 캐시가 영원히 서비스를 제공 할 수 있습니다. 캐시에는 한정된 저장소가 있으므로 항목이 저장소에서 주기적으로 제거됩니다. 이 과정을 &lt;em&gt;캐시 제거&lt;/em&gt; 라고 &lt;em&gt;합니다&lt;/em&gt; . 반면에 일부 리소스는 서버에서 변경 될 수 있으므로 캐시를 업데이트해야합니다. HTTP는 클라이언트-서버 프로토콜이므로 리소스가 변경 될 때 서버는 캐시와 클라이언트에 접속할 수 없습니다. 그들은 자원의 만료 시간을 전달해야합니다. 이 만료 시간 전에 리소스가 &lt;em&gt;최신 상태입니다&lt;/em&gt; . 만료 시간이 지나면 리소스가 &lt;em&gt;오래되었습니다&lt;/em&gt;. 제거 알고리즘은 종종 오래된 리소스보다 새로운 리소스에 권한을 부여합니다. 부실 리소스는 제거되거나 무시되지 않습니다. 캐시는 오래된 리소스에 대한 요청을 받으면이 요청을 &lt;a href=&quot;headers/if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 와 함께 전달 하여 실제로 최신 상태인지 확인합니다. 그렇다면 서버는 요청 된 리소스의 본문을 보내지 않고 &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; (수정되지 않음) 헤더를 반환하여 대역폭을 절약합니다.</target>
        </trans-unit>
        <trans-unit id="d79e1072067e9270a5021d23e2d543ff572b05d8" translate="yes" xml:space="preserve">
          <source>Once a user has overridden the server-chosen language, a site should no longer use language detection and should stick with the explicitly-chosen language. In other words, only entry pages of a site should select the proper language using this header.</source>
          <target state="translated">사용자가 서버가 선택한 언어를 재정의하면 사이트에서 더 이상 언어 감지 기능을 사용하지 않아야하며 명시 적으로 선택된 언어를 사용해야합니다. 즉, 사이트의 시작 페이지 만이 헤더를 사용하여 적절한 언어를 선택해야합니다.</target>
        </trans-unit>
        <trans-unit id="8571c0f2c52762afed434f53c93e37e6519192e0" translate="yes" xml:space="preserve">
          <source>Once an inbound connection is obtained, the client sends an HTTP
   request message (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;) with a request-target derived from the
   target URI.  There are four distinct formats for the request-target,
   depending on both the method being requested and whether the request
   is to a proxy.

     request-target = origin-form
                    / absolute-form
                    / authority-form
                    / asterisk-form</source>
          <target state="translated">인바운드 연결이 이루어지면 클라이언트는 대상 URI에서 파생 된 요청 대상과 함께 HTTP 요청 메시지 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; )를 보냅니다 . 요청되는 메소드와 요청이 프록시에 대한 것인지 여부에 따라 요청 대상에 대한 4 가지 고유 형식이 있습니다. 요청 대상 = 원산지 양식 / 절대 양식 / 권한 양식 / 별표 양식</target>
        </trans-unit>
        <trans-unit id="85e5b6139a54476444e3e499db3bed09efd92d6e" translate="yes" xml:space="preserve">
          <source>Once the HTTP/2 connection is established, endpoints can begin
   exchanging frames.</source>
          <target state="translated">HTTP / 2 연결이 설정되면 엔드 포인트는 프레임 교환을 시작할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="90dcbb9bf6b3864e512e171d7b57669e95d50401" translate="yes" xml:space="preserve">
          <source>Once the TLS handshake is complete, the original request will be responded to as normal.</source>
          <target state="translated">TLS 핸드 셰이크가 완료되면 원래 요청이 정상적으로 응답합니다.</target>
        </trans-unit>
        <trans-unit id="555084494ae9b3d3ddba4fd675d1b872eb531308" translate="yes" xml:space="preserve">
          <source>Once the connection is established, the user-agent can send the request (a user-agent is typically a web browser, but can be anything else, a crawler, for example). A client request consists of text directives, separated by CRLF (carriage return, followed by line feed), divided into three blocks:</source>
          <target state="translated">연결이 설정되면 사용자 에이전트는 요청을 보낼 수 있습니다 (사용자 에이전트는 일반적으로 웹 브라우저이지만 크롤러와 같은 다른 도구 일 수 있음). 클라이언트 요청은 CRLF (캐리지 리턴, 줄 바꿈)로 구분 된 텍스트 지시문으로 구성되며 다음 세 블록으로 나뉩니다.</target>
        </trans-unit>
        <trans-unit id="c2dcba3e69f215847ccd37ccdc0e122ddb02db7e" translate="yes" xml:space="preserve">
          <source>Once the preflight request is complete, the real request is sent:</source>
          <target state="translated">프리 플라이트 요청이 완료되면 실제 요청이 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="2f9ae143a5ad6f92b100c0c78400768cc4838d90" translate="yes" xml:space="preserve">
          <source>Once the target URI is determined, a client needs to decide whether a
   network request is necessary to accomplish the desired semantics and,
   if so, where that request is to be directed.

   If the client has a cache [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] and the request can be satisfied
   by it, then the request is usually directed there first.

   If the request is not satisfied by a cache, then a typical client
   will check its configuration to determine whether a proxy is to be
   used to satisfy the request.  Proxy configuration is implementation-
   dependent, but is often based on URI prefix matching, selective
   authority matching, or both, and the proxy itself is usually
   identified by an &quot;http&quot; or &quot;https&quot; URI.  If a proxy is applicable,
   the client connects inbound by establishing (or reusing) a connection
   to that proxy.

   If no proxy is applicable, a typical client will invoke a handler
   routine, usually specific to the target URI's scheme, to connect
   directly to an authority for the target resource.  How that is
   accomplished is dependent on the target URI scheme and defined by its
   associated specification, similar to how this specification defines
   origin server access for resolution of the &quot;http&quot; (&lt;a href=&quot;#section-2.7.1&quot;&gt;Section 2.7.1&lt;/a&gt;) and
   &quot;https&quot; (&lt;a href=&quot;#section-2.7.2&quot;&gt;Section 2.7.2&lt;/a&gt;) schemes.

   HTTP requirements regarding connection management are defined in
   &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;.</source>
          <target state="translated">대상 URI가 결정되면 클라이언트는 원하는 의미를 달성하기 위해 네트워크 요청이 필요한지 여부와 필요한 경우 해당 요청이 전달되는 위치를 결정해야합니다. 클라이언트에 캐시가있는 경우 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] and the request can be satisfied by it, then the request is usually directed there first. If the request is not satisfied by a cache, then a typical client will check its configuration to determine whether a proxy is to be used to satisfy the request. Proxy configuration is implementation- dependent, but is often based on URI prefix matching, selective authority matching, or both, and the proxy itself is usually identified by an &quot;http&quot; or &quot;https&quot; URI. If a proxy is applicable, the client connects inbound by establishing (or reusing) a connection to that proxy. If no proxy is applicable, a typical client will invoke a handler routine, usually specific to the target URI's scheme, to connect directly to an authority for the target resource. How that is accomplished is dependent on the target URI scheme and defined by its associated specification, similar to how this specification defines origin server access for resolution of the &quot;http&quot; (&lt;a href=&quot;#section-2.7.1&quot;&gt;섹션 2.7.1&lt;/a&gt; ) 및 &quot;https&quot;( &lt;a href=&quot;#section-2.7.2&quot;&gt;섹션 2.7.2&lt;/a&gt; ) 체계. 연결 관리와 관련된 HTTP 요구 사항은 &lt;a href=&quot;#section-6&quot;&gt;6 절에&lt;/a&gt; 정의되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ffcfdc99522dda87985b6e020ac99791f96f9b5" translate="yes" xml:space="preserve">
          <source>One helpful trick is to use an Apache rewrite, environment variable, and headers to apply &lt;code&gt;Access-Control-Allow-*&lt;/code&gt; to certain URIs. This is useful, for example, to constrain cross-origin requests to &lt;code&gt;GET /api(.*).json&lt;/code&gt; requests without credentials:</source>
          <target state="translated">유용한 트릭 중 하나는 Apache 재 작성, 환경 변수 및 헤더를 사용 하여 특정 URI에 &lt;code&gt;Access-Control-Allow-*&lt;/code&gt; 를 적용하는 것입니다. 예를 들어, 출처 간 요청을 자격 증명없이 &lt;code&gt;GET /api(.*).json&lt;/code&gt; 요청 으로 제한하는 데 유용합니다 .</target>
        </trans-unit>
        <trans-unit id="a8582a1553ee6a6943be8472937795233c896987" translate="yes" xml:space="preserve">
          <source>One of &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot; (case sensitive).</source>
          <target state="translated">&quot;1 월&quot;, &quot;2 월&quot;, &quot;3 월&quot;, &quot;4 월&quot;, &quot;5 월&quot;, &quot;6 월&quot;, &quot;7 월&quot;, &quot;8 월&quot;, &quot;9 월&quot;, &quot;10 월&quot;, &quot;11 월&quot;, &quot;12 월&quot;( 대소 문자 구분).</target>
        </trans-unit>
        <trans-unit id="cc3c09e9e2558b885fb3094c63215174af4c22c6" translate="yes" xml:space="preserve">
          <source>One of &quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;, &quot;Thu&quot;, &quot;Fri&quot;, &quot;Sat&quot;, or &quot;Sun&quot; (case-sensitive).</source>
          <target state="translated">&quot;월&quot;, &quot;화&quot;, &quot;수&quot;, &quot;목&quot;, &quot;금&quot;, &quot;토&quot;또는 &quot;일&quot;(대소 문자 구분) 중 하나입니다.</target>
        </trans-unit>
        <trans-unit id="ed1f5145c366e1525cfdac1afb12bea74657baef" translate="yes" xml:space="preserve">
          <source>One of the &lt;a href=&quot;../methods&quot;&gt;HTTP request methods&lt;/a&gt;, for example &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;../methods/delete&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">의 한 &lt;a href=&quot;../methods&quot;&gt;HTTP 요청 방법&lt;/a&gt; 예를 들어, &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; 은&lt;/a&gt; , &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 는&lt;/a&gt; , 또는 &lt;a href=&quot;../methods/delete&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7358e8566ab27696d3aa061103eabd7dc61cbf3a" translate="yes" xml:space="preserve">
          <source>One of the allowed methods:</source>
          <target state="translated">One of the allowed methods:</target>
        </trans-unit>
        <trans-unit id="390c6d9e0ac6e814868f106e3b1a949d7f65c2f1" translate="yes" xml:space="preserve">
          <source>One of the ordered weekday strings:</source>
          <target state="translated">정렬 된 요일 문자열 중 하나 :</target>
        </trans-unit>
        <trans-unit id="da1a3f527bb79b13e631a70eceb3b03667fef012" translate="yes" xml:space="preserve">
          <source>One or more</source>
          <target state="translated">하나 이상</target>
        </trans-unit>
        <trans-unit id="d8241709124a392624ea93bbc5c857f96e735f3e" translate="yes" xml:space="preserve">
          <source>One or more &lt;a href=&quot;../../basics_of_http/mime_types&quot;&gt;MIME types&lt;/a&gt; can be set for the &lt;code&gt;plugin-types&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;plugin-types&lt;/code&gt; 정책에 대해 하나 이상의 &lt;a href=&quot;../../basics_of_http/mime_types&quot;&gt;MIME 유형&lt;/a&gt; 을 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="bd95e30df64975fcaf170b3a768d1c1172b30dcc" translate="yes" xml:space="preserve">
          <source>One or more protocol names with optional version (&quot;/&quot; separated). The protocols are listed in order of descending preference.</source>
          <target state="translated">선택적 버전 ( &quot;/&quot;로 구분)이있는 하나 이상의 프로토콜 이름. 프로토콜은 선호하는 내림차순으로 나열됩니다.</target>
        </trans-unit>
        <trans-unit id="301b7fe5870eedf464270ce13c1fa28571750cd1" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;default-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;default-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="06bce7998d9ba504b451b0feee8e296f1daee8d8" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;font-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;font-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="0c94c5922cba00a6f423d74692c379c4b5a45de3" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;frame-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;frame-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4df1448fbf4125c9dedf0cb65e25a27cddc8034" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;img-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;img-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="95bedd54418ece3d0cc9bc840eec50ca73bd04b1" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;manifest-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;manifest-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b1ab57ca6a220519b6bf1112428f33a86176cf91" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;media-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;media-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="564dbf7bc482debbf861b6580c949f6cd4c8bcd2" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;prefetch-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;prefetch-src&lt;/code&gt; 정책에 대해 하나 이상의 소스를 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d4c3c7041410c98d92a86d7deb59e3385408c248" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;script-src-attr&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;script-src-attr&lt;/code&gt; 정책에 대해 하나 이상의 소스를 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="69a510cd91fa916db9b77f1d444ea1d25bd63e2d" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;script-src-elem&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;script-src-elem&lt;/code&gt; 정책에 대해 하나 이상의 소스를 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="2e69da8927408051c551ec50a1bc254784fcf5e0" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;script-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;script-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="fcf14a04ffec6db17812ca7bec47163d9e3936ed" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;style-src-attr&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;style-src-attr&lt;/code&gt; 정책에 대해 하나 이상의 소스를 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="19911c35a8977a5143103b2a6a32632e8a78b06f" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;style-src-elem&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;style-src-elem&lt;/code&gt; 정책에 대해 하나 이상의 소스를 허용 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db657b004d9023ddfd0f626de17ba73007526d9f" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;style-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;style-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="482d29a7e2a3ad999de3eaccec198f96895c6c4b" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the &lt;code&gt;worker-src&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;worker-src&lt;/code&gt; 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="03175b17a2f8591861f06a407654d0deac74f4ce" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the child-src policy:</source>
          <target state="translated">child-src 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="c2abb90bd1216bb48e062c09ced50f4e78627b20" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the connect-src policy:</source>
          <target state="translated">connect-src 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dd38d0ca560fb98a1494ecf0e9a7973691560553" translate="yes" xml:space="preserve">
          <source>One or more sources can be allowed for the object-src policy:</source>
          <target state="translated">object-src 정책에 대해 하나 이상의 소스가 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d617d27a877454aafa7fdb2c25048b068c100553" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;form-action&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;form-action&lt;/code&gt; 정책에 대해 하나 이상의 소스를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="614e797f67ee3998c43d2279b0efb9b69d35d0b7" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;frame-ancestors&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;frame-ancestors&lt;/code&gt; 정책에 대해 하나 이상의 소스를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="d85ba0347fd8ef0fe804f7d4f132ee30ca2e91a6" translate="yes" xml:space="preserve">
          <source>One or more sources can be set for the &lt;code&gt;navigate-to&lt;/code&gt; policy:</source>
          <target state="translated">&lt;code&gt;navigate-to&lt;/code&gt; 정책에 대해 하나 이상의 소스를 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="561a8f95762b4775f3807c61334e7ebb288f7784" translate="yes" xml:space="preserve">
          <source>One such case is using user agent sniffing as a fallback when detecting if the device has a touch screen. See the &lt;a href=&quot;#Mobile_Device_Detection&quot;&gt;Mobile Device Detection&lt;/a&gt; section for more information.</source>
          <target state="translated">One such case is using user agent sniffing as a fallback when detecting if the device has a touch screen. See the &lt;a href=&quot;#Mobile_Device_Detection&quot;&gt;Mobile Device Detection&lt;/a&gt; section for more information.</target>
        </trans-unit>
        <trans-unit id="440e37e5146514a1b09e389a18211dea7ea8dac6" translate="yes" xml:space="preserve">
          <source>Only a few image types are widely recognized enough to be safe for use in a Web page:</source>
          <target state="translated">웹 페이지에서 안전하게 사용할 수있을 정도로 소수의 이미지 유형 만 널리 인식됩니다.</target>
        </trans-unit>
        <trans-unit id="728dfd233770caccb04ac6af9ed8ff6472ef3733" translate="yes" xml:space="preserve">
          <source>Only from Firefox 11 onwards.</source>
          <target state="translated">Firefox 11 이상에서만.</target>
        </trans-unit>
        <trans-unit id="7aa6633a592e629108d330108c9845898ccefcf7" translate="yes" xml:space="preserve">
          <source>Only if freshness information is included</source>
          <target state="translated">신선도 정보가 포함 된 경우에만</target>
        </trans-unit>
        <trans-unit id="8c459ab4818539eeac8c01408d42790a33fcc4f8" translate="yes" xml:space="preserve">
          <source>Only requests from the same &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;Site&lt;/a&gt;&lt;/em&gt; can read the resource.</source>
          <target state="translated">동일한 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Site&quot;&gt;사이트의&lt;/a&gt;&lt;/em&gt; 요청 만 리소스를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="39093b8aba5fabc2993025582ed1e134697bc747" translate="yes" xml:space="preserve">
          <source>Only requests from the same &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;&lt;/em&gt; (i.e. scheme + host + port) can read the resource.</source>
          <target state="translated">동일한 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;출처&lt;/a&gt;&lt;/em&gt; (예 : 체계 + 호스트 + 포트)의 요청 만 리소스를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="60683d3517e8c322dbed684ad85d73d5f563b876" translate="yes" xml:space="preserve">
          <source>Only send the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; of the document as the referrer.</source>
          <target state="translated">Only send the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt; of the document as the referrer.</target>
        </trans-unit>
        <trans-unit id="923411c2bc01cfda42c24f6cd8d7e71d494b59bb" translate="yes" xml:space="preserve">
          <source>Only send the origin of the document as the referrer in all cases.</source>
          <target state="translated">모든 경우에 문서의 출처 만 참조 자로 보내십시오.</target>
        </trans-unit>
        <trans-unit id="504a19ebb593f19f5c15be75bd6a14b10d61cc2c" translate="yes" xml:space="preserve">
          <source>Only send the origin of the document as the referrer when the protocol security level stays the same (HTTPS&amp;rarr;HTTPS), but don't send it to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">프로토콜 보안 수준이 동일하게 유지 될 때 (HTTPS &amp;rarr; HTTPS) 문서의 출처를 리퍼러로만 보내야하지만 덜 안전한 대상 (HTTPS &amp;rarr; HTTP)으로 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="3dca6cb48e7901ebca248c4fe80410a3fed8f2a4" translate="yes" xml:space="preserve">
          <source>Only supported through the &lt;code&gt;allow&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; elements.</source>
          <target state="translated">Only supported through the &lt;code&gt;allow&lt;/code&gt; attribute on &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; elements.</target>
        </trans-unit>
        <trans-unit id="def88b6da8bd54c37b6b2287268d552d6a1b11c6" translate="yes" xml:space="preserve">
          <source>Only supporting 'sandbox' directive.</source>
          <target state="translated">Only supporting 'sandbox' directive.</target>
        </trans-unit>
        <trans-unit id="4f39b4f80cbca2cb50c539730e64cd999999c698" translate="yes" xml:space="preserve">
          <source>Only supports draft-03</source>
          <target state="translated">Only supports draft-03</target>
        </trans-unit>
        <trans-unit id="10a95b7b265e3d407d2676c45b93f081dfab813c" translate="yes" xml:space="preserve">
          <source>Only supports draft-04</source>
          <target state="translated">Only supports draft-04</target>
        </trans-unit>
        <trans-unit id="2dee33c23ec83af1e9b47f42ab34f35452828624" translate="yes" xml:space="preserve">
          <source>Only the first parameter is mandatory. Either the second, the third, or both may be left out.</source>
          <target state="translated">첫 번째 매개 변수 만 필수입니다. 두 번째, 세 번째 또는 둘 다 생략 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="17b66229e4dd5e13a33497902e7f83f4ec3577a5" translate="yes" xml:space="preserve">
          <source>Open a TCP connection: The TCP connection is used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.</source>
          <target state="translated">Open a TCP connection: The TCP connection is used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.</target>
        </trans-unit>
        <trans-unit id="d6d87b3098d93fe460f69fc84cf084280f871953" translate="yes" xml:space="preserve">
          <source>Open a TCP connection: The TCP connection will be used to send a request, or several, and receive an answer. The client may open a new connection, reuse an existing connection, or open several TCP connections to the servers.</source>
          <target state="translated">TCP 연결 열기 : TCP 연결은 하나 이상의 요청을 보내고 응답을받는 데 사용됩니다. 클라이언트는 새 연결을 열거 나 기존 연결을 재사용하거나 서버에 대한 여러 TCP 연결을 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="075672a8517397eeef73c16b7924c5637eb3e6f7" translate="yes" xml:space="preserve">
          <source>OpenDocument presentation document</source>
          <target state="translated">OpenDocument 프리젠 테이션 문서</target>
        </trans-unit>
        <trans-unit id="9c8c7fbf48609de1ffb436774d400bc486986b1e" translate="yes" xml:space="preserve">
          <source>OpenDocument spreadsheet document</source>
          <target state="translated">OpenDocument 스프레드 시트 문서</target>
        </trans-unit>
        <trans-unit id="ae259e53c368ebd11d83ff7013840fd030bc4e12" translate="yes" xml:space="preserve">
          <source>OpenDocument text document</source>
          <target state="translated">OpenDocument 텍스트 문서</target>
        </trans-unit>
        <trans-unit id="b15775ed71872d7bda87125462ecf55ba4b4a044" translate="yes" xml:space="preserve">
          <source>OpenType font</source>
          <target state="translated">OpenType 글꼴</target>
        </trans-unit>
        <trans-unit id="19c9c9ed8477a3a275bcf0fa3f27c69151b58b7d" translate="yes" xml:space="preserve">
          <source>Opera</source>
          <target state="translated">Opera</target>
        </trans-unit>
        <trans-unit id="ea83f20e4af1c088f0ff12d9f40107e1fae7cd91" translate="yes" xml:space="preserve">
          <source>Opera 11.10</source>
          <target state="translated">오페라 11.10</target>
        </trans-unit>
        <trans-unit id="94504c9918ec0e2b645287a73d2e76cbf6604f4e" translate="yes" xml:space="preserve">
          <source>Opera UA string</source>
          <target state="translated">오페라 UA 문자열</target>
        </trans-unit>
        <trans-unit id="4497b69b3e58a8b8c4ab04b8430dd1bf6b9df545" translate="yes" xml:space="preserve">
          <source>Opera for Android</source>
          <target state="translated">Android 용 오페라</target>
        </trans-unit>
        <trans-unit id="256d43d577a1728bc1dc921d68a8fa6c2b037086" translate="yes" xml:space="preserve">
          <source>Opera/9.80 (Android 2.3.3; Linux; Opera Mobi/ADR-1111101157; U; es-ES) Presto/2.9.201 Version/11.50</source>
          <target state="translated">Opera / 9.80 (Android 2.3.3; Linux; Opera Mobi / ADR-1111101157; U; es-ES) Presto / 2.9.201 버전 /11.50</target>
        </trans-unit>
        <trans-unit id="d21816adfc84e4894b30f5b80678333d5c37dce9" translate="yes" xml:space="preserve">
          <source>Opera/xyz</source>
          <target state="translated">Opera/xyz</target>
        </trans-unit>
        <trans-unit id="08a9921e90aae36fdabfc9ba080c0517a0f9df35" translate="yes" xml:space="preserve">
          <source>Opera/xyz &lt;sup&gt;[2]&lt;/sup&gt;</source>
          <target state="translated">오페라 / 엑시즈 &lt;sup&gt;[2]&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="793b3dcdefb9f6d9d75d16cae958fafb4b6cc0a0" translate="yes" xml:space="preserve">
          <source>Optional &lt;a href=&quot;headers&quot;&gt;headers&lt;/a&gt; that convey additional information for the servers.</source>
          <target state="translated">서버에 대한 추가 정보를 전달하는 선택적 &lt;a href=&quot;headers&quot;&gt;헤더&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b489d6278596ad8cbce00fb97015da3fdf24a162" translate="yes" xml:space="preserve">
          <source>Optional upgrade</source>
          <target state="translated">선택적 업그레이드</target>
        </trans-unit>
        <trans-unit id="39c86106a7fb30538fb6bf0bd6b42312db26ab4c" translate="yes" xml:space="preserve">
          <source>Optional. If more than one &lt;code&gt;Warning&lt;/code&gt; header is sent, include a date that matches the &lt;a href=&quot;date&quot;&gt;&lt;code&gt;Date&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">선택 과목. 둘 이상의 &lt;code&gt;Warning&lt;/code&gt; 헤더가 전송 된 경우 &lt;a href=&quot;date&quot;&gt; &lt;code&gt;Date&lt;/code&gt; &lt;/a&gt; 헤더 와 일치하는 날짜를 포함하십시오 .</target>
        </trans-unit>
        <trans-unit id="f6070787c35a58d9bea898c231c2152bcd0af813" translate="yes" xml:space="preserve">
          <source>Optional. The name of the protocol used, such as &quot;HTTP&quot;.</source>
          <target state="translated">선택 과목. 사용 된 프로토콜의 이름 (예 : &quot;HTTP&quot;)</target>
        </trans-unit>
        <trans-unit id="38b7579808079b250ea2022859caac9497170a85" translate="yes" xml:space="preserve">
          <source>Optionally, a body containing the fetched resource.</source>
          <target state="translated">선택적으로 페치 된 자원을 포함하는 본문.</target>
        </trans-unit>
        <trans-unit id="73fd299ce63ac52baac8a7bec7ae838843817645" translate="yes" xml:space="preserve">
          <source>Opus audio</source>
          <target state="translated">Opus audio</target>
        </trans-unit>
        <trans-unit id="eb46e915c8c19f6af68e7a6bdae7009a1807f316" translate="yes" xml:space="preserve">
          <source>Or a body, for some methods like &lt;code&gt;POST&lt;/code&gt;, similar to those in responses, which contain the resource sent.</source>
          <target state="translated">또는 &lt;code&gt;POST&lt;/code&gt; 와 같은 일부 메소드의 경우 응답 된 메소드와 유사하며 전송 된 자원이 들어 있습니다.</target>
        </trans-unit>
        <trans-unit id="e2b445db4463b9f0e28207704251d3ed52ff3148" translate="yes" xml:space="preserve">
          <source>Or by using the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt;&lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements:</source>
          <target state="translated">또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt; &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 &lt;code&gt;referrerpolicy&lt;/code&gt; 속성을 사용하여 :</target>
        </trans-unit>
        <trans-unit id="e8391a174420c035696ea042ca2d68eeebd0c936" translate="yes" xml:space="preserve">
          <source>Or see this &lt;a href=&quot;https://support.office.com/en-us/article/Mitigating-framesniffing-with-the-X-Frame-Options-header-1911411b-b51e-49fd-9441-e8301dcdcd79&quot;&gt;Microsoft support article on setting this configuration using the IIS Manager&lt;/a&gt; user interface.</source>
          <target state="translated">Or see this &lt;a href=&quot;https://support.office.com/en-us/article/Mitigating-framesniffing-with-the-X-Frame-Options-header-1911411b-b51e-49fd-9441-e8301dcdcd79&quot;&gt;Microsoft support article on setting this configuration using the IIS Manager&lt;/a&gt; user interface.</target>
        </trans-unit>
        <trans-unit id="a6642209b9a36277d2d0737d7d5faa29e3a750c8" translate="yes" xml:space="preserve">
          <source>Or set it for individual requests with the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt;&lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt;&lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; elements:</source>
          <target state="translated">Or set it for individual requests with the &lt;code&gt;referrerpolicy&lt;/code&gt; attribute on &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/area&quot;&gt; &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/iframe&quot;&gt; &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt;, or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; elements:</target>
        </trans-unit>
        <trans-unit id="5cb1a52345d3e8948ce99c302fcc32162e6809d7" translate="yes" xml:space="preserve">
          <source>Or the de-facto standard versions:</source>
          <target state="translated">또는 사실상의 표준 버전 :</target>
        </trans-unit>
        <trans-unit id="3faf8dc540861f535e93a1016c4c11a4d714285a" translate="yes" xml:space="preserve">
          <source>Order of precedence</source>
          <target state="translated">우선 순위</target>
        </trans-unit>
        <trans-unit id="44ab85a252adb7ade8ca36fec4157a862c1f725f" translate="yes" xml:space="preserve">
          <source>Origin</source>
          <target state="translated">Origin</target>
        </trans-unit>
        <trans-unit id="290335c298a77e839fe785e3a86ced4673d12093" translate="yes" xml:space="preserve">
          <source>Origin servers frequently make use of their local file system to
   manage the mapping from effective request URI to resource
   representations.  Most file systems are not designed to protect
   against malicious file or path names.  Therefore, an origin server
   needs to avoid accessing names that have a special significance to
   the system when mapping the request target to files, folders, or
   directories.

   For example, UNIX, Microsoft Windows, and other operating systems use
   &quot;..&quot; as a path component to indicate a directory level above the
   current one, and they use specially named paths or file names to send
   data to system devices.  Similar naming conventions might exist
   within other types of storage systems.  Likewise, local storage
   systems have an annoying tendency to prefer user-friendliness over
   security when handling invalid or unexpected characters,
   recomposition of decomposed characters, and case-normalization of
   case-insensitive names.

   Attacks based on such special names tend to focus on either denial-
   of-service (e.g., telling the server to read from a COM port) or
   disclosure of configuration and source files that are not meant to be
   served.</source>
          <target state="translated">오리진 서버는 종종 로컬 파일 시스템을 사용하여 효과적인 요청 URI에서 자원 표시로의 맵핑을 관리합니다. 대부분의 파일 시스템은 악성 파일 또는 경로 이름으로부터 보호하도록 설계되지 않았습니다. 따라서 오리진 서버는 요청 대상을 파일, 폴더 또는 디렉토리에 맵핑 할 때 시스템에 특별한 의미가있는 이름에 액세스하지 않아야합니다. 예를 들어, UNIX, Microsoft Windows 및 기타 운영 체제는 &quot;..&quot;를 경로 구성 요소로 사용하여 현재 디렉토리보다 높은 디렉토리 레벨을 나타내며 특별히 명명 된 경로 또는 파일 이름을 사용하여 시스템 장치로 데이터를 보냅니다. 다른 유형의 스토리지 시스템 내에 유사한 이름 지정 규칙이 존재할 수 있습니다. 마찬가지로,로컬 스토리지 시스템은 유효하지 않거나 예상치 못한 문자를 처리 할 때 보안보다 사용자 친 화성을 선호하는 성가신 경향이 있으며, 분해 된 문자의 재구성 및 대소 문자를 구분하지 않는 이름의 대소 문자를 정규화합니다. 이러한 특수 이름을 기반으로하는 공격은 서비스 거부 (예 : 서버에 COM 포트에서 읽도록 지시) 또는 제공되지 않는 구성 및 소스 파일의 공개에 중점을 두는 경향이 있습니다.</target>
        </trans-unit>
        <trans-unit id="39574fdeedd527e498bc8ce3b971e8f064927c65" translate="yes" xml:space="preserve">
          <source>Origin servers often use parameters within the URI as a means of
   identifying system services, selecting database entries, or choosing
   a data source.  However, data received in a request cannot be
   trusted.  An attacker could construct any of the request data
   elements (method, request-target, header fields, or body) to contain
   data that might be misinterpreted as a command, code, or query when
   passed through a command invocation, language interpreter, or
   database interface.

   For example, SQL injection is a common attack wherein additional
   query language is inserted within some part of the request-target or
   header fields (e.g., Host, Referer, etc.).  If the received data is
   used directly within a SELECT statement, the query language might be
   interpreted as a database command instead of a simple string value.
   This type of implementation vulnerability is extremely common, in
   spite of being easy to prevent. 

   In general, resource implementations ought to avoid use of request
   data in contexts that are processed or interpreted as instructions.
   Parameters ought to be compared to fixed strings and acted upon as a
   result of that comparison, rather than passed through an interface
   that is not prepared for untrusted data.  Received data that isn't
   based on fixed parameters ought to be carefully filtered or encoded
   to avoid being misinterpreted.

   Similar considerations apply to request data when it is stored and
   later processed, such as within log files, monitoring tools, or when
   included within a data format that allows embedded scripts.</source>
          <target state="translated">오리진 서버는 종종 시스템 서비스 식별, 데이터베이스 항목 선택 또는 데이터 소스 선택의 수단으로 URI 내의 매개 변수를 사용합니다. 그러나 요청에서 수신 한 데이터는 신뢰할 수 없습니다. 공격자는 명령 호출, 언어 인터프리터 또는 데이터베이스를 통해 전달 될 때 명령, 코드 또는 쿼리로 잘못 해석 될 수있는 데이터를 포함하도록 요청 데이터 요소 (메서드, 요청 대상, 헤더 필드 또는 본문)를 구성 할 수 있습니다. 상호 작용. 예를 들어, SQL 삽입은 추가 쿼리 언어가 요청 대상 또는 헤더 필드 (예 : 호스트, 참조 자 등)의 일부 부분에 삽입되는 일반적인 공격입니다. 수신 된 데이터가 SELECT 문 내에서 직접 사용되는 경우, 쿼리 언어는 단순 문자열 값 대신 데이터베이스 명령으로 해석 될 수 있습니다.이러한 유형의 구현 취약점은 예방하기 쉽지만 매우 일반적입니다. 일반적으로 자원 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.예방하기 쉽지만. 일반적으로 자원 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.예방하기 쉽지만. 일반적으로 자원 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.리소스 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.리소스 구현은 명령으로 처리되거나 해석되는 컨텍스트에서 요청 데이터를 사용하지 않아야합니다. 매개 변수는 고정 문자열과 비교해야하며 신뢰할 수없는 데이터에 대해 준비되지 않은 인터페이스를 통해 전달되는 것이 아니라 해당 비교 결과로 작동해야합니다. 고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.고정 된 매개 변수를 기반으로하지 않는 수신 된 데이터는 잘못 해석되지 않도록 신중하게 필터링하거나 인코딩해야합니다. 로그 파일, 모니터링 도구 또는 내장 스크립트를 허용하는 데이터 형식에 포함 된 경우와 같이 저장 및 나중에 처리 될 때 데이터를 요청하는 경우에도 비슷한 고려 사항이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="6e6a6f2086bb5fe5dbfd17d8d5f502d48759834b" translate="yes" xml:space="preserve">
          <source>Other</source>
          <target state="translated">Other</target>
        </trans-unit>
        <trans-unit id="f2f4c2c9ebacb9837f6d36a5f8a3b8e0b622d3aa" translate="yes" xml:space="preserve">
          <source>Other Gecko-based browsers</source>
          <target state="translated">다른 Gecko 기반 브라우저</target>
        </trans-unit>
        <trans-unit id="a9f706611dc18f06545758348b461f7f0adb2b15" translate="yes" xml:space="preserve">
          <source>Other Range Units (RFC 7233)</source>
          <target state="translated">기타 범위 단위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="c3ce9f69b8cfd7c68b552621813174d43df7c2b9" translate="yes" xml:space="preserve">
          <source>Other directives</source>
          <target state="translated">다른 지시어</target>
        </trans-unit>
        <trans-unit id="625b9f557aeca38bef04ac2454ddfa89b0a0c358" translate="yes" xml:space="preserve">
          <source>Other headers may be required depending on the requested protocol; for example, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket&lt;/a&gt; upgrades allow additional headers to configure details about the WebSocket connection as well as to offer a degree of security in opening the connection. See &lt;a href=&quot;#Upgrading_to_a_WebSocket_connection&quot;&gt;Upgrading to a WebSocket connection&lt;/a&gt; for more details.</source>
          <target state="translated">요청 된 프로토콜에 따라 다른 헤더가 필요할 수 있습니다. 예를 들어, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/WebSocket&quot;&gt;WebSocket&lt;/a&gt; 업그레이드를 통해 추가 헤더가 WebSocket 연결에 대한 세부 정보를 구성하고 연결을 여는 데 어느 정도의 보안을 제공 할 수 있습니다. 자세한 내용 &lt;a href=&quot;#Upgrading_to_a_WebSocket_connection&quot;&gt;은 WebSocket 연결&lt;/a&gt; 로 업그레이드를 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="85ebef3f22c7ab64a892270dec3fa2ec5f09eb93" translate="yes" xml:space="preserve">
          <source>Other kinds of images can be found in Web documents. For example, many browsers support ICO images for favicons with the &lt;code&gt;image/x-icon&lt;/code&gt; MIME type.</source>
          <target state="translated">다른 종류의 이미지는 웹 문서에서 찾을 수 있습니다. 예를 들어, 많은 브라우저는 &lt;code&gt;image/x-icon&lt;/code&gt; MIME 유형의 즐겨 찾기 아이콘에 대한 ICO 이미지를 지원 합니다.</target>
        </trans-unit>
        <trans-unit id="7ab593da14a28bf9d35c50c2c46a830c857de1cc" translate="yes" xml:space="preserve">
          <source>Other methods of conveying document type</source>
          <target state="translated">문서 유형을 전달하는 다른 방법</target>
        </trans-unit>
        <trans-unit id="996796a4631242928596cc5bcca3b11a2ae12348" translate="yes" xml:space="preserve">
          <source>Other non-standard forms:</source>
          <target state="translated">다른 비표준 형태 :</target>
        </trans-unit>
        <trans-unit id="c398a40f6467ab0e6d4a51e2c42d3024deab4848" translate="yes" xml:space="preserve">
          <source>Other possible causes include:</source>
          <target state="translated">Other possible causes include:</target>
        </trans-unit>
        <trans-unit id="c72c6b541f8af743f2c407a4401af9c3f96dae91" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b84d6d36913561f68541fe18676efd3d770dbda0" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7d85834ec62e00c548dc17fc4f00c0165fdd2bae" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-charset&quot;&gt;&lt;code&gt;Accept-Charset&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-charset&quot;&gt; &lt;code&gt;Accept-Charset&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="38408917877ccb7a2526344ef45c30543e381d4f" translate="yes" xml:space="preserve">
          <source>Other similar headers: &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-encoding&quot;&gt;&lt;code&gt;Accept-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept-language&quot;&gt;&lt;code&gt;Accept-Language&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;accept&quot;&gt;&lt;code&gt;Accept&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">다른 유사한 헤더 : &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-encoding&quot;&gt; &lt;code&gt;Accept-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept-language&quot;&gt; &lt;code&gt;Accept-Language&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;accept&quot;&gt; &lt;code&gt;Accept&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c0f462fe556d74feaa0c7e0ddb4467a1bfbfe984" translate="yes" xml:space="preserve">
          <source>Other techniques have been created to cause cookies to be recreated after they are deleted, known as &quot;zombie&quot; cookies. These techniques violate the principles of user privacy and user control, may violate data privacy regulations, and could expose a website using them to legal liability.</source>
          <target state="translated">Other techniques have been created to cause cookies to be recreated after they are deleted, known as &quot;zombie&quot; cookies. These techniques violate the principles of user privacy and user control, may violate data privacy regulations, and could expose a website using them to legal liability.</target>
        </trans-unit>
        <trans-unit id="8f4d57cee57aec1713cde40fa14344856b43ef48" translate="yes" xml:space="preserve">
          <source>Other ways to store information in the browser</source>
          <target state="translated">Other ways to store information in the browser</target>
        </trans-unit>
        <trans-unit id="a6cfd07479f00708fdf4d74f365c52cc07a8f329" translate="yes" xml:space="preserve">
          <source>Others &lt;em&gt;changed&lt;/em&gt; to &lt;code&gt;GET&lt;/code&gt; (body lost).</source>
          <target state="translated">다른 사람들 은 &lt;code&gt;GET&lt;/code&gt; (바디 분실)으로 &lt;em&gt;변경되었습니다&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="82d2325236dcdd66d736da750430f95549e17f4d" translate="yes" xml:space="preserve">
          <source>Others may or may not be changed to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.&lt;sup&gt;&lt;a href=&quot;#attr1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">다른 사람들은 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 으로 변경되거나 변경되지 않을 수 있습니다 . &lt;sup&gt;&lt;a href=&quot;#attr1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="87489c6b3237d9c5e336cbbf949df80f405e54e2" translate="yes" xml:space="preserve">
          <source>Others may or may not be changed to &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;.&lt;sup&gt;&lt;a href=&quot;#attr2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">다른 사람들은 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 으로 변경되거나 변경되지 않을 수 있습니다 . &lt;sup&gt;&lt;a href=&quot;#attr2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="bfd662a53f46542ec60c4e0d8cee532efa7c0b3a" translate="yes" xml:space="preserve">
          <source>Our &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;media container formats guide&lt;/a&gt; provides a list of the file types that are commonly supported by web browsers, including information about what their special use cases may be, any drawbacks they have, and compatibility information, along with other details.</source>
          <target state="translated">Our &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Containers&quot;&gt;media container formats guide&lt;/a&gt; provides a list of the file types that are commonly supported by web browsers, including information about what their special use cases may be, any drawbacks they have, and compatibility information, along with other details.</target>
        </trans-unit>
        <trans-unit id="1389ad925826fb57f506c6950b9975e96c5e84ae" translate="yes" xml:space="preserve">
          <source>Over the years, Web pages have become much more complex, even becoming applications in their own right. The amount of visual media displayed, the volume and size of scripts adding interactivity, has also increased: much more data is transmitted over significantly more HTTP requests. HTTP/1.1 connections need requests sent in the correct order. Theoretically, several parallel connections could be used (typically between 5 and 8), bringing considerable overhead and complexity. For example, HTTP pipelining has emerged as a resource burden in Web development.</source>
          <target state="translated">수년에 걸쳐 웹 페이지는 훨씬 더 복잡해졌으며 심지어 자체적으로 응용 프로그램이되었습니다. 표시되는 시각적 미디어의 양, 대화 형 작업을 추가하는 스크립트의 크기 및 크기도 증가했습니다. 훨씬 더 많은 데이터가 훨씬 더 많은 HTTP 요청을 통해 전송됩니다. HTTP / 1.1 연결에는 올바른 순서로 전송 된 요청이 필요합니다. 이론적으로 여러 병렬 연결을 사용할 수 있으며 (일반적으로 5와 8 사이) 상당한 오버 헤드와 복잡성을 가져옵니다. 예를 들어, HTTP 파이프 라이닝은 웹 개발에서 리소스 부담으로 등장했습니다.</target>
        </trans-unit>
        <trans-unit id="31c09f64bf1672cae4d50721a626746fbbfe230e" translate="yes" xml:space="preserve">
          <source>Over the years, other content negotiation proposals, like &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;transparent content negotiation&lt;/a&gt; and the &lt;code&gt;Alternates&lt;/code&gt; header, have been proposed. They failed to get traction and got abandoned.</source>
          <target state="translated">Over the years, other content negotiation proposals, like &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;transparent content negotiation&lt;/a&gt; and the &lt;code&gt;Alternates&lt;/code&gt; header, have been proposed. They failed to get traction and got abandoned.</target>
        </trans-unit>
        <trans-unit id="19c302998f4d6efe64dd1c686f52a585d7c21081" translate="yes" xml:space="preserve">
          <source>Over the years, other content negotiation proposals, like &lt;em&gt;transparent content negotiation&lt;/em&gt; and the &lt;code&gt;Alternates&lt;/code&gt; header, have been proposed. They failed to get traction and got abandoned.</source>
          <target state="translated">수년에 걸쳐 &lt;em&gt;투명한 콘텐츠 협상&lt;/em&gt; 및 &lt;code&gt;Alternates&lt;/code&gt; 헤더 와 같은 다른 콘텐츠 협상 제안 이 제안되었습니다. 그들은 견인력을 얻지 못하고 버려졌습니다.</target>
        </trans-unit>
        <trans-unit id="7f9ad0ce2f0cf21b5dfc499a3b4f0f957c8096a5" translate="yes" xml:space="preserve">
          <source>Overly long and detailed Server values should be avoided as they potentially reveal internal implementation details that might make it (slightly) easier for attackers to find and exploit known security holes.</source>
          <target state="translated">공격자가 알려진 보안 허점을 쉽게 찾고 악용 할 수있는 내부 구현 세부 정보가 노출 될 수 있으므로 지나치게 길고 자세한 서버 값은 피해야합니다.</target>
        </trans-unit>
        <trans-unit id="774f2bde7e6f323579cf2f6405e4f60dab194195" translate="yes" xml:space="preserve">
          <source>Overrides &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but only for shared caches (e.g., proxies). Ignored by private caches.</source>
          <target state="translated">Overrides &lt;code&gt;max-age&lt;/code&gt; or the &lt;code&gt;Expires&lt;/code&gt; header, but only for shared caches (e.g., proxies). Ignored by private caches.</target>
        </trans-unit>
        <trans-unit id="beb0cd26d81ea98884c5a97cec9c4a4060035ed7" translate="yes" xml:space="preserve">
          <source>Oversized images</source>
          <target state="translated">대형 이미지</target>
        </trans-unit>
        <trans-unit id="0efc2e6be4c23b9a513d7ce0dcff8ed80e8912e7" translate="yes" xml:space="preserve">
          <source>Overview</source>
          <target state="translated">Overview</target>
        </trans-unit>
        <trans-unit id="0645cc9f4662b405fbaab5741ba96115472ea2cb" translate="yes" xml:space="preserve">
          <source>Overview of HTTP</source>
          <target state="translated">HTTP 개요</target>
        </trans-unit>
        <trans-unit id="a29ee7bead9d5253143ec2eef09801f9444b6c47" translate="yes" xml:space="preserve">
          <source>Overwrite = &quot;Overwrite&quot; &quot;:&quot; (&quot;T&quot; | &quot;F&quot;)

   The Overwrite request header specifies whether the server should
   overwrite a resource mapped to the destination URL during a COPY or
   MOVE.  A value of &quot;F&quot; states that the server must not perform the
   COPY or MOVE operation if the destination URL does map to a resource.
   If the overwrite header is not included in a COPY or MOVE request,
   then the resource MUST treat the request as if it has an overwrite
   header of value &quot;T&quot;.  While the Overwrite header appears to duplicate
   the functionality of using an &quot;If-Match: *&quot; header (see [&lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt;]),
   If-Match applies only to the Request-URI, and not to the Destination
   of a COPY or MOVE.

   If a COPY or MOVE is not performed due to the value of the Overwrite
   header, the method MUST fail with a 412 (Precondition Failed) status
   code.  The server MUST do authorization checks before checking this
   or any conditional header.

   All DAV-compliant resources MUST support the Overwrite header.</source>
          <target state="translated">Overwrite = &quot;Overwrite&quot; &quot;:&quot;( &quot;T&quot;| &quot;F&quot;) 덮어 쓰기 요청 헤더는 서버가 COPY 또는 MOVE 중에 대상 URL에 매핑 된 리소스를 덮어 쓸지 여부를 지정합니다. &quot;F&quot;값은 대상 URL이 자원에 맵핑되는 경우 서버가 COPY 또는 MOVE 조작을 수행하지 않아야 함을 나타냅니다. 덮어 쓰기 헤더가 COPY 또는 MOVE 요청에 포함되지 않은 경우 리소스는 &quot;T&quot;값의 덮어 쓰기 헤더가있는 것처럼 요청을 처리해야합니다. 덮어 쓰기 헤더가 &quot;If-Match : *&quot;헤더를 사용하는 기능을 복제 한 것으로 보이지만 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC2616&lt;/a&gt; 참조)]), If-Match는 Request-URI에만 적용되며 COPY 또는 MOVE의 대상에는 적용되지 않습니다. 덮어 쓰기 헤더 값으로 인해 COPY 또는 MOVE가 수행되지 않으면 메소드는 반드시 412 (사전 조건 실패) 상태 코드로 실패해야합니다. 서버는이 헤더 나 조건부 헤더를 확인하기 전에 권한 확인을 수행해야합니다. 모든 DAV 호환 리소스는 반드시 덮어 쓰기 헤더를 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="511993d3c99719e38a6779073019dacd7178ddb9" translate="yes" xml:space="preserve">
          <source>P</source>
          <target state="translated">P</target>
        </trans-unit>
        <trans-unit id="9fbe29d4d76ec756421aee06e0f34f17fa488ff3" translate="yes" xml:space="preserve">
          <source>PATCH</source>
          <target state="translated">PATCH</target>
        </trans-unit>
        <trans-unit id="c99402ab3125986c0ca9abd7662212d27d04d993" translate="yes" xml:space="preserve">
          <source>PATCH Method for HTTP</source>
          <target state="translated">HTTP를위한 패치 방법</target>
        </trans-unit>
        <trans-unit id="7daf403c7589f4927632ed3b6af762a992f09b78" translate="yes" xml:space="preserve">
          <source>PHP</source>
          <target state="translated">PHP</target>
        </trans-unit>
        <trans-unit id="70fe60b7dfe0837f2c69677bfef128c134937b16" translate="yes" xml:space="preserve">
          <source>PNG</source>
          <target state="translated">PNG</target>
        </trans-unit>
        <trans-unit id="66f5d95b9fad1f059666798a47511aaa0f200506" translate="yes" xml:space="preserve">
          <source>PNG images</source>
          <target state="translated">PNG 이미지</target>
        </trans-unit>
        <trans-unit id="61ff81c30aa3c76e78afea62b2e3bd1dfa49e854" translate="yes" xml:space="preserve">
          <source>POST</source>
          <target state="translated">POST</target>
        </trans-unit>
        <trans-unit id="6b173f05e4044209594e89f3311ea2f97dca21f1" translate="yes" xml:space="preserve">
          <source>POST (RFC 7231)</source>
          <target state="translated">POST (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="488ec3314bc3136b6691a9c6089c33cd1a5abbf3" translate="yes" xml:space="preserve">
          <source>PROXY &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">프록시 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="5c3deba075c547e0c36e4da79277a2a8123501f3" translate="yes" xml:space="preserve">
          <source>PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081</source>
          <target state="translated">PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081</target>
        </trans-unit>
        <trans-unit id="be192bb000cdde229b85d161ac3cfc592a7def61" translate="yes" xml:space="preserve">
          <source>PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081; DIRECT</source>
          <target state="translated">PROXY w3proxy.netscape.com:8080; PROXY mozilla.netscape.com:8081; 곧장</target>
        </trans-unit>
        <trans-unit id="40d8b8bf9d93a5c96e1ad0585cf3ecb0348a6124" translate="yes" xml:space="preserve">
          <source>PROXY w3proxy.netscape.com:8080; SOCKS socks:1080</source>
          <target state="translated">PROXY w3proxy.netscape.com:8080; 양말 양말 : 1080</target>
        </trans-unit>
        <trans-unit id="091b0ce42eb0bd96169ea00b16dd938f6d63ac95" translate="yes" xml:space="preserve">
          <source>PUT</source>
          <target state="translated">PUT</target>
        </trans-unit>
        <trans-unit id="180e2ba0d63f280e2a2789d7b31a1bc767301f2c" translate="yes" xml:space="preserve">
          <source>PUT (RFC 7231)</source>
          <target state="translated">PUT (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="5fc49191b72cdf03f625715123378e822ea8e609" translate="yes" xml:space="preserve">
          <source>PUT or POST: The resource describing the result of the action is transmitted in the message body.</source>
          <target state="translated">PUT 또는 POST : 조치 결과를 설명하는 자원이 메시지 본문으로 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="95c7b2d39d9470a10aa3ed9a330ccb003a5f174f" translate="yes" xml:space="preserve">
          <source>Padding within HTTP/2 is not intended as a replacement for general
   purpose padding, such as might be provided by TLS [&lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt;].  Redundant
   padding could even be counterproductive.  Correct application can
   depend on having specific knowledge of the data that is being padded.

   To mitigate attacks that rely on compression, disabling or limiting
   compression might be preferable to padding as a countermeasure.

   Padding can be used to obscure the exact size of frame content and is
   provided to mitigate specific attacks within HTTP, for example,
   attacks where compressed content includes both attacker-controlled
   plaintext and secret data (e.g., [&lt;a href=&quot;#ref-BREACH&quot;&gt;BREACH&lt;/a&gt;]).

   Use of padding can result in less protection than might seem
   immediately obvious.  At best, padding only makes it more difficult
   for an attacker to infer length information by increasing the number
   of frames an attacker has to observe.  Incorrectly implemented
   padding schemes can be easily defeated.  In particular, randomized
   padding with a predictable distribution provides very little
   protection; similarly, padding payloads to a fixed size exposes
   information as payload sizes cross the fixed-sized boundary, which
   could be possible if an attacker can control plaintext.

   Intermediaries SHOULD retain padding for DATA frames but MAY drop
   padding for HEADERS and PUSH_PROMISE frames.  A valid reason for an
   intermediary to change the amount of padding of frames is to improve
   the protections that padding provides.</source>
          <target state="translated">HTTP / 2 내의 패딩은 TLS [ &lt;a href=&quot;#ref-TLS12&quot;&gt;TLS12&lt;/a&gt; ]에서 제공하는 것과 같은 범용 패딩을 대체하기위한 것이 아닙니다 . 중복 패딩은 역효과를 초래할 수도 있습니다. 올바른 적용은 패딩되는 데이터에 대한 특정 지식이 있는지 여부에 따라 달라질 수 있습니다. 압축에 의존하는 공격을 완화하려면 대응책으로 패딩보다 압축을 비활성화하거나 제한하는 것이 좋습니다. 패딩은 프레임 콘텐츠의 정확한 크기를 모호하게하는 데 사용할 수 있으며 HTTP 내의 특정 공격을 완화하기 위해 제공됩니다. 예를 들어 압축 콘텐츠에 공격자가 제어하는 ​​일반 텍스트와 비밀 데이터가 모두 포함 된 공격 (예 : [ &lt;a href=&quot;#ref-BREACH&quot;&gt;BREACH&lt;/a&gt;]). 패딩을 사용하면 당장 명백해 보이는 것보다 보호 수준이 떨어질 수 있습니다. 기껏해야 패딩은 공격자가 관찰해야하는 프레임 수를 늘림으로써 공격자가 길이 정보를 추론하기 어렵게 만듭니다. 잘못 구현 된 패딩 체계는 쉽게 무효화 될 수 있습니다. 특히, 예측 가능한 분포가있는 무작위 패딩은 보호 기능이 거의 없습니다. 마찬가지로, 고정 크기에 대한 패딩 페이로드는 페이로드 크기가 고정 크기 경계를 넘을 때 정보를 노출하며, 이는 공격자가 일반 텍스트를 제어 할 수있는 경우 가능할 수 있습니다. 중개자는 DATA 프레임에 대한 패딩을 유지해야하지만 HEADERS 및 PUSH_PROMISE 프레임에 대한 패딩을 삭제할 수 있습니다. 중개자가 프레임의 패딩 양을 변경하는 유효한 이유는 패딩이 제공하는 보호 기능을 개선하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="fb06270f7c212baabc8749ffc36e49dc8f321548" translate="yes" xml:space="preserve">
          <source>Page</source>
          <target state="translated">Page</target>
        </trans-unit>
        <trans-unit id="acfde7c66817888e160ae3de7578ebfa76ce2e4f" translate="yes" xml:space="preserve">
          <source>Page load times &amp;ndash; especially on mobile networks &amp;ndash; can be measurably improved in this way. If the domain names for images can be resolved in advance of the images being requested, pages that load many images can see an improvement of 5% or more in the time of loading images.</source>
          <target state="translated">이러한 방식으로 특히 모바일 네트워크에서 페이지로드 시간을 크게 향상시킬 수 있습니다. 이미지를 요청하기 전에 이미지의 도메인 이름을 확인할 수 있으면 이미지를로드 할 때 많은 이미지를로드하는 페이지가 5 % 이상 개선 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a975eea30db9fa05003e3b5097688bd49ec7e01b" translate="yes" xml:space="preserve">
          <source>Parameters</source>
          <target state="translated">Parameters</target>
        </trans-unit>
        <trans-unit id="65de2e2a3bcb36da6b50fd9e19f9ca0b9466de27" translate="yes" xml:space="preserve">
          <source>Partial</source>
          <target state="translated">Partial</target>
        </trans-unit>
        <trans-unit id="a67f67302851a5d276a1f332c570a4d5d70beb91" translate="yes" xml:space="preserve">
          <source>Partial downloading of files is a functionality of HTTP that allows to resume previous operations, saving bandwidth and time, by keeping the already obtained information:</source>
          <target state="translated">파일의 부분 다운로드는 이미 얻은 정보를 유지하여 대역폭과 시간을 절약하면서 이전 작업을 재개 할 수있는 HTTP 기능입니다.</target>
        </trans-unit>
        <trans-unit id="9f2456547341d382c0cd8969634e15222fd42072" translate="yes" xml:space="preserve">
          <source>Partial request responses</source>
          <target state="translated">부분 요청 응답</target>
        </trans-unit>
        <trans-unit id="519e39132bb98418cc0483cc446ccf5f3c8dcffe" translate="yes" xml:space="preserve">
          <source>Path</source>
          <target state="translated">Path</target>
        </trans-unit>
        <trans-unit id="7e8dd2fe01455f3213d5b78a27a183ab9084f7c6" translate="yes" xml:space="preserve">
          <source>Path attribute</source>
          <target state="translated">Path attribute</target>
        </trans-unit>
        <trans-unit id="d4cda508dc92e955d0dec90998defe31c1ce56cf" translate="yes" xml:space="preserve">
          <source>Path=&amp;lt;path-value&amp;gt; Optional</source>
          <target state="translated">경로 = &amp;lt;경로-값&amp;gt; 선택 사항</target>
        </trans-unit>
        <trans-unit id="43ce9e87fb78ff08bc898add73bc386a08eb801f" translate="yes" xml:space="preserve">
          <source>Pattern and mask specification is done the same way as for SOCKS configuration.</source>
          <target state="translated">패턴 및 마스크 지정은 SOCKS 구성과 동일한 방식으로 수행됩니다.</target>
        </trans-unit>
        <trans-unit id="c6d1017f12ba79770bd35235205861747d3cccb1" translate="yes" xml:space="preserve">
          <source>Pay attention, WebKit browsers add a 'like Gecko' string that may trigger false positive for Gecko if the detection is not careful.</source>
          <target state="translated">주의를 기울여 WebKit 브라우저는 감지가주의하지 않으면 Gecko에 대해 오 탐지를 유발할 수있는 'like Gecko'문자열을 추가합니다.</target>
        </trans-unit>
        <trans-unit id="c243b0001f3ba25c62dec19c6d226c40b52cea2a" translate="yes" xml:space="preserve">
          <source>Payment Request API</source>
          <target state="translated">결제 요청 API</target>
        </trans-unit>
        <trans-unit id="780f221907c7e38cdae635cfb6208478f88eb8ec" translate="yes" xml:space="preserve">
          <source>PaymentRequest</source>
          <target state="translated">PaymentRequest</target>
        </trans-unit>
        <trans-unit id="77a26e91bed497501e951d3cf7cad88a7e9dd5d9" translate="yes" xml:space="preserve">
          <source>Per the HTML specification, JavaScript files should always be served using the MIME type &lt;code&gt;text/javascript&lt;/code&gt;. No other values are considered valid, and using any of those may result in scripts that do not load or run.</source>
          <target state="translated">Per the HTML specification, JavaScript files should always be served using the MIME type &lt;code&gt;text/javascript&lt;/code&gt; . No other values are considered valid, and using any of those may result in scripts that do not load or run.</target>
        </trans-unit>
        <trans-unit id="43e1935d1dca9e3135787fecfba7cee4557e1f4b" translate="yes" xml:space="preserve">
          <source>Percent encoding</source>
          <target state="translated">Percent encoding</target>
        </trans-unit>
        <trans-unit id="bb61a5741ee32ef6278d4f74c423d2cefcb01967" translate="yes" xml:space="preserve">
          <source>PerformanceServerTiming interface</source>
          <target state="translated">PerformanceServerTiming 인터페이스</target>
        </trans-unit>
        <trans-unit id="fd322b604a88d923b9699e4da5ad2d407a5bedf9" translate="yes" xml:space="preserve">
          <source>Permanent cookie</source>
          <target state="translated">영구 쿠키</target>
        </trans-unit>
        <trans-unit id="17658b356485ef7673c3b03ceae3fa6e6d7d88c4" translate="yes" xml:space="preserve">
          <source>Permanent cookies</source>
          <target state="translated">영구 쿠키</target>
        </trans-unit>
        <trans-unit id="92094144583e1bf1b4f762c12765fda6b3839671" translate="yes" xml:space="preserve">
          <source>Permanent redirections</source>
          <target state="translated">영구적 인 리디렉션</target>
        </trans-unit>
        <trans-unit id="3925c55425a4f62c86c9a5121775b6fc0cc8b0d3" translate="yes" xml:space="preserve">
          <source>Permanent redirects to preserve existing links/bookmarks after changing the site's URLs, progress pages when uploading a file, etc.</source>
          <target state="translated">Permanent redirects to preserve existing links/bookmarks after changing the site's URLs, progress pages when uploading a file, etc.</target>
        </trans-unit>
        <trans-unit id="4011d0826747060e5a5028b76b99f62d679b7124" translate="yes" xml:space="preserve">
          <source>Permanent redirects: a &lt;a href=&quot;status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; (Moved Permanently) response.</source>
          <target state="translated">영구 리디렉션 : &lt;a href=&quot;status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; (영구적으로 이동) 응답.</target>
        </trans-unit>
        <trans-unit id="d06d55570938d12f87db3bf2b48caa9de22d9c67" translate="yes" xml:space="preserve">
          <source>Permissions</source>
          <target state="translated">Permissions</target>
        </trans-unit>
        <trans-unit id="2a501f415b62660d274a3c65a809a89615530327" translate="yes" xml:space="preserve">
          <source>Permissions Policy</source>
          <target state="translated">Permissions Policy</target>
        </trans-unit>
        <trans-unit id="8a52029a5f6ad7e2d01edf4781780b48c29536d7" translate="yes" xml:space="preserve">
          <source>Permissions Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</source>
          <target state="translated">Permissions Policy&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy' in that specification.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="7a346cd10ffe699546f235f362a53bac9f81fa99" translate="yes" xml:space="preserve">
          <source>Persistent connections</source>
          <target state="translated">지속적인 연결</target>
        </trans-unit>
        <trans-unit id="6227d5230a252c6748af027af4a46a12c547c313" translate="yes" xml:space="preserve">
          <source>Persistent connections also have drawbacks; even when idling they consume server resources, and under heavy load, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack&quot;&gt;DoS attacks&lt;/a&gt; can be conducted. In such cases, using non-persistent connections, which are closed as soon as they are idle, can provide better performance.</source>
          <target state="translated">지속적인 연결에도 단점이 있습니다. 유휴 상태 일 때도 서버 리소스를 소비하고 부하가 많은 경우 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/DoS_attack&quot;&gt;DoS 공격&lt;/a&gt; 을 수행 할 수 있습니다. 이러한 경우 유휴 상태가 되 자마자 닫히는 비 지속적 연결을 사용하면 성능이 향상 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f203458ed70f830ecf62ab5ec4fd43db183fc0d2" translate="yes" xml:space="preserve">
          <source>Personalization</source>
          <target state="translated">Personalization</target>
        </trans-unit>
        <trans-unit id="77064d5265236e0ac252f3fc4a5ba7b274b6a583" translate="yes" xml:space="preserve">
          <source>Phone</source>
          <target state="translated">Phone</target>
        </trans-unit>
        <trans-unit id="43da85c5b84903575ac8c5ca1f55d28acabfcad2" translate="yes" xml:space="preserve">
          <source>Picture-in-picture</source>
          <target state="translated">Picture-in-picture</target>
        </trans-unit>
        <trans-unit id="27d5b461f6a4ec4744648e6c2d52e8a49e82d7ee" translate="yes" xml:space="preserve">
          <source>Pin validation failures are reported to the given URL. This directive should be used with this header, otherwise this header will be a no-op.</source>
          <target state="translated">핀 유효성 검사 실패가 지정된 URL에보고됩니다. 이 지시문은이 헤더와 함께 사용해야합니다. 그렇지 않으면이 헤더는 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="5d9063d0ea16517f0dd2cf264a23d07a4fa9e003" translate="yes" xml:space="preserve">
          <source>Pipelining has been added, allowing to send a second request before the answer for the first one is fully transmitted, lowering the latency of the communication.</source>
          <target state="translated">파이프 라이닝이 추가되어 첫 번째 요청에 대한 응답이 완전히 전송되기 전에 두 번째 요청을 보내 통신 지연 시간이 줄어 듭니다.</target>
        </trans-unit>
        <trans-unit id="cb97787c320d9b01d77fc365f1658b4a6cbcfdcc" translate="yes" xml:space="preserve">
          <source>Pipelining is complex to implement correctly: the size of the resource being transferred, the effective &lt;a href=&quot;https://en.wikipedia.org/wiki/Round-trip_delay_time&quot;&gt;RTT&lt;/a&gt; that will be used, as well as the effective bandwidth, have a direct incidence on the improvement provided by the pipeline. Without knowing these, important messages may be delayed behind unimportant ones. The notion of important even evolves during page layout! HTTP pipelining therefore brings a marginal improvement in most cases only.</source>
          <target state="translated">파이프 라이닝은 올바르게 구현하기가 복잡합니다. 전송되는 리소스의 크기, 사용될 유효 &lt;a href=&quot;https://en.wikipedia.org/wiki/Round-trip_delay_time&quot;&gt;RTT&lt;/a&gt; 및 유효 대역폭은 파이프 라인이 제공하는 개선에 직접적인 영향을 미칩니다. 이러한 정보를 모르면 중요하지 않은 메시지보다 중요한 메시지가 지연 될 수 있습니다. 중요한 개념은 페이지 레이아웃 중에도 진화합니다! 따라서 HTTP 파이프 라이닝은 대부분의 경우에만 약간의 향상을 가져옵니다.</target>
        </trans-unit>
        <trans-unit id="32334bbf0ea4cc9dcd714f1f6fb56e7a4dd68d47" translate="yes" xml:space="preserve">
          <source>Pipelining is subject to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;HOL&lt;/a&gt; problem.</source>
          <target state="translated">파이프 라이닝에는 &lt;a href=&quot;https://en.wikipedia.org/wiki/Head-of-line_blocking&quot;&gt;HOL&lt;/a&gt; 문제가 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e93906befafc2d436be2b0cefd447ae95a998ca" translate="yes" xml:space="preserve">
          <source>Pipelining is the process to send successive requests, over the same persistent connection, without waiting for the answer. This avoids latency of the connection. Theoretically, performance could also be improved if two HTTP requests were to be packed into the same TCP message. The typical &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_segment_size&quot;&gt;MSS&lt;/a&gt; (Maximum Segment Size), is big enough to contain several simple requests, although the demand in size of HTTP requests continues to grow.</source>
          <target state="translated">파이프 라이닝은 응답을 기다리지 않고 동일한 영구 연결을 통해 연속 요청을 보내는 프로세스입니다. 이렇게하면 연결 대기 시간이 줄어 듭니다. 이론적으로 두 개의 HTTP 요청을 동일한 TCP 메시지로 압축해야하는 경우 성능도 향상 될 수 있습니다. 일반적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_segment_size&quot;&gt;MSS&lt;/a&gt; (Maximum Segment Size)는 몇 가지 간단한 요청을 포함 할 수있을만큼 크지 만 HTTP 요청의 크기 요구는 계속 증가하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="e76a62fe2144d321dc348606013ff2cbb52f2f9b" translate="yes" xml:space="preserve">
          <source>Please note the security issues in the &lt;a href=&quot;cookies#Security&quot;&gt;Security&lt;/a&gt; section below. Cookies available to JavaScript can be stolen through XSS.</source>
          <target state="translated">Please note the security issues in the &lt;a href=&quot;cookies#Security&quot;&gt;Security&lt;/a&gt; section below. Cookies available to JavaScript can be stolen through XSS.</target>
        </trans-unit>
        <trans-unit id="d3e9877233fd71bd443ebff82f1c96d10d967e95" translate="yes" xml:space="preserve">
          <source>Please note the security issues in the &lt;a href=&quot;cookies#Security&quot;&gt;Security&lt;/a&gt; section below. Cookies available to JavaScript can get stolen through XSS.</source>
          <target state="translated">아래 &lt;a href=&quot;cookies#Security&quot;&gt;보안&lt;/a&gt; 섹션 의 보안 문제를 참고하십시오 . JavaScript에 사용 가능한 쿠키는 XSS를 통해 도난 당할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="b8e391655ea50eeb58d944cd6acd5f681479ecd3" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;Browser detection using the user agent&lt;/a&gt; and why serving different Web pages or services to different browsers is usually a bad idea.</source>
          <target state="translated">&lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;사용자 에이전트를 사용하여 브라우저 감지를&lt;/a&gt; 읽고 다른 웹 페이지 또는 서비스를 다른 브라우저에 제공하는 것이 일반적으로 나쁜 이유입니다.</target>
        </trans-unit>
        <trans-unit id="15b6ab0e3b9eed227d32233626db5b5d1f3e9022" translate="yes" xml:space="preserve">
          <source>Please read &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;Browser detection using the user agent&lt;/a&gt; for why serving different Web pages or services to different browsers is usually a bad idea.</source>
          <target state="translated">Please read &lt;a href=&quot;../browser_detection_using_the_user_agent&quot;&gt;Browser detection using the user agent&lt;/a&gt; for why serving different Web pages or services to different browsers is usually a bad idea.</target>
        </trans-unit>
        <trans-unit id="629043b0037778d804878a71a96a9e025cdaa239" translate="yes" xml:space="preserve">
          <source>Please refer to &lt;a href=&quot;identifying_resources_on_the_web&quot;&gt;Identifying resources on the web&lt;/a&gt; for more general details.</source>
          <target state="translated">자세한 내용 &lt;a href=&quot;identifying_resources_on_the_web&quot;&gt;은 웹&lt;/a&gt; 에서 리소스 식별을 참조 하십시오.</target>
        </trans-unit>
        <trans-unit id="77b3807a5e9d74793daef3f288350f785f3901bf" translate="yes" xml:space="preserve">
          <source>Please see the PostScript version of this RFC for the INDEX.</source>
          <target state="translated">INDEX에 대해서는이 RFC의 PostScript 버전을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2f6b013e07f3ae6cf0eaeb620a07e55e63cca281" translate="yes" xml:space="preserve">
          <source>Plugin data (Flash via &lt;code&gt;&lt;a href=&quot;https://wiki.mozilla.org/NPAPI:ClearSiteData&quot;&gt;NPP_ClearSiteData&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">플러그인 데이터 ( &lt;code&gt;&lt;a href=&quot;https://wiki.mozilla.org/NPAPI:ClearSiteData&quot;&gt;NPP_ClearSiteData&lt;/a&gt;&lt;/code&gt; 를 통한 플래시 )</target>
        </trans-unit>
        <trans-unit id="a03996fc28512c866d09144f03735be3035b474c" translate="yes" xml:space="preserve">
          <source>Pointing to a new document (HTTP 201 Created)</source>
          <target state="translated">새 문서를 가리킴 (HTTP 201 작성)</target>
        </trans-unit>
        <trans-unit id="bb9cf1418089b3356038fdd24fcbdc9d1a7c42a5" translate="yes" xml:space="preserve">
          <source>Policy</source>
          <target state="translated">Policy</target>
        </trans-unit>
        <trans-unit id="861260cecd797e42301015d1972945d6ccce6883" translate="yes" xml:space="preserve">
          <source>Polyfill</source>
          <target state="translated">Polyfill</target>
        </trans-unit>
        <trans-unit id="fe035157cda20b361ce30613e29b5d6f1a46b5fc" translate="yes" xml:space="preserve">
          <source>Port</source>
          <target state="translated">Port</target>
        </trans-unit>
        <trans-unit id="0655d96b4660aed951fededfbd01c7c59119ecd3" translate="yes" xml:space="preserve">
          <source>Portable Network Graphics</source>
          <target state="translated">휴대용 네트워크 그래픽</target>
        </trans-unit>
        <trans-unit id="7280aa9b126e519bb5acdcab7417841a30bb930a" translate="yes" xml:space="preserve">
          <source>Possible values are:</source>
          <target state="translated">가능한 값은 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="e34a1abaef7642eb5e47dc90b1f78aded974e1e0" translate="yes" xml:space="preserve">
          <source>Post-HTTP/2 evolution</source>
          <target state="translated">HTTP / 2 이후의 진화</target>
        </trans-unit>
        <trans-unit id="5d2f1e6af4f0dd384a2135f597a35d76c716ff9d" translate="yes" xml:space="preserve">
          <source>Posting a message to a bulletin board, newsgroup, mailing list, or similar group of articles;</source>
          <target state="translated">게시판, 뉴스 그룹, 메일 링리스트 또는 유사한 기사 그룹에 메시지 게시;</target>
        </trans-unit>
        <trans-unit id="e13c21f016090c02b61ff5c85484271e1f63607d" translate="yes" xml:space="preserve">
          <source>Potential consent. The origin server does not know, in real-time, whether it has received prior consent for tracking this user, user agent, or device, but promises not to use or share any &lt;code&gt;DNT:1&lt;/code&gt; data until such consent has been determined, and further promises to delete or permanently de-identify within 48 hours any &lt;code&gt;DNT:1&lt;/code&gt; data received for which such consent has not been received.</source>
          <target state="translated">잠재적 동의. 오리진 서버는이 사용자, 사용자 에이전트 또는 장치 추적에 대한 사전 동의를 받았는지 여부를 실시간으로 알지 못하지만 그러한 동의가 결정될 때까지 &lt;code&gt;DNT:1&lt;/code&gt; 데이터 를 사용하거나 공유하지 않을 것을 약속합니다 . 그러한 동의를받지 않은 &lt;code&gt;DNT:1&lt;/code&gt; 데이터를 48 시간 이내에 삭제하거나 영구적으로 비 식별 화할 것을 약속합니다 .</target>
        </trans-unit>
        <trans-unit id="38f93d32853eca4603a582eb7a404079e10b855d" translate="yes" xml:space="preserve">
          <source>Pragma</source>
          <target state="translated">Pragma</target>
        </trans-unit>
        <trans-unit id="10ce1b9f5fcb548c88be796c5413226a631f6779" translate="yes" xml:space="preserve">
          <source>Pragma (RFC 2616)</source>
          <target state="translated">프라 그마 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="222e9fe7a000f712ce64e611ad0d20ff65f49274" translate="yes" xml:space="preserve">
          <source>Pragma (RFC 7234)</source>
          <target state="translated">프라 그마 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="7e6daac261d33e269d833bf63b3f2d2599eb567b" translate="yes" xml:space="preserve">
          <source>Precedence (RFC 7232)</source>
          <target state="translated">우선 순위 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="48fd0b0a455b1b9c9691a25e0993d7569fd92ed9" translate="yes" xml:space="preserve">
          <source>Predefined functions and environment</source>
          <target state="translated">사전 정의 된 기능 및 환경</target>
        </trans-unit>
        <trans-unit id="0cac7e46797097fddd27c4dbbfcc50d89cf7252d" translate="yes" xml:space="preserve">
          <source>Prefetch resources do not match header</source>
          <target state="translated">프리 페치 리소스가 헤더와 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a35f2c6e9b4b4c78a58f550b27e02de590437603" translate="yes" xml:space="preserve">
          <source>Prefixed</source>
          <target state="translated">Prefixed</target>
        </trans-unit>
        <trans-unit id="e4e54a3cbf5eac6f285efaba7091dfea7b3c66be" translate="yes" xml:space="preserve">
          <source>Prefixed Implemented with the vendor prefix: X-</source>
          <target state="translated">Prefixed Implemented with the vendor prefix: X-</target>
        </trans-unit>
        <trans-unit id="77b7a912ad8a10b7555f0037f76831bb79e6719e" translate="yes" xml:space="preserve">
          <source>Prefixed Requires the vendor prefix: X-</source>
          <target state="translated">접두사 공급 업체 접두사가 필요합니다 : X-</target>
        </trans-unit>
        <trans-unit id="8f021bd03245cb33021400555bb85f605a2d45ff" translate="yes" xml:space="preserve">
          <source>Preflighted requests</source>
          <target state="translated">사전 요청</target>
        </trans-unit>
        <trans-unit id="cb65254a3d067d0956eed2852e254776d77cf4e1" translate="yes" xml:space="preserve">
          <source>Preflighted requests and redirects</source>
          <target state="translated">사전 요청 및 리디렉션</target>
        </trans-unit>
        <trans-unit id="d52d63f2f757eeb2fc2650d8e15f7889b573acf5" translate="yes" xml:space="preserve">
          <source>Preflighted requests in CORS</source>
          <target state="translated">CORS의 사전 요청</target>
        </trans-unit>
        <trans-unit id="26f1bf2383aa9871dd78193ab9149c3299ac14a5" translate="yes" xml:space="preserve">
          <source>Preloading Strict Transport Security</source>
          <target state="translated">엄격한 운송 보안 사전로드</target>
        </trans-unit>
        <trans-unit id="b13ad30fcddd7db2811d43c38bc157e0545a41de" translate="yes" xml:space="preserve">
          <source>Presto</source>
          <target state="translated">Presto</target>
        </trans-unit>
        <trans-unit id="6c064d906f8b1472fbe5172226fc023fb60b16b5" translate="yes" xml:space="preserve">
          <source>Presto-based (Opera 12-)</source>
          <target state="translated">프레스토 기반 (오페라 12-)</target>
        </trans-unit>
        <trans-unit id="f5108a6e749e881ddb6ce1d097fa635f113b07f6" translate="yes" xml:space="preserve">
          <source>Prevent DOM-based cross-site scripting vulnerabilities with Trusted Types</source>
          <target state="translated">신뢰할 수있는 유형으로 DOM 기반 교차 사이트 스크립팅 취약점 방지</target>
        </trans-unit>
        <trans-unit id="0ca5c4f0da38bae9df91250a22a3aaec7b983517" translate="yes" xml:space="preserve">
          <source>Preventing caching</source>
          <target state="translated">캐싱 방지</target>
        </trans-unit>
        <trans-unit id="7a6ccc3e86565d9ca3c8a38ca45e95b4e5425569" translate="yes" xml:space="preserve">
          <source>Prevents loading any assets using HTTP when the page is loaded using HTTPS.</source>
          <target state="translated">페이지가 HTTPS를 사용하여로드 될 때 HTTP를 사용하여 자산을로드하지 못하게합니다.</target>
        </trans-unit>
        <trans-unit id="5995616971b86971e7a4e1a6aa9d2d44da580a1d" translate="yes" xml:space="preserve">
          <source>Prevents other domains from opening/controlling a window.</source>
          <target state="translated">Prevents other domains from opening/controlling a window.</target>
        </trans-unit>
        <trans-unit id="f125d179171b8223ba21f6f4ad4430dbe494ae42" translate="yes" xml:space="preserve">
          <source>Prevents other domains from reading the response of the resources to which this header is applied.</source>
          <target state="translated">Prevents other domains from reading the response of the resources to which this header is applied.</target>
        </trans-unit>
        <trans-unit id="36839770a07bef6a664420cba7543ec9676f091a" translate="yes" xml:space="preserve">
          <source>Primary proxy is w3proxy:8080; if that goes down start using mozilla:8081 until the primary proxy comes up again.</source>
          <target state="translated">기본 프록시는 w3proxy : 8080입니다. 중단되면 기본 프록시가 다시 나타날 때까지 mozilla : 8081을 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="fffd7d8534beaec770e000c8dc679dce544e8728" translate="yes" xml:space="preserve">
          <source>Principle</source>
          <target state="translated">Principle</target>
        </trans-unit>
        <trans-unit id="4a8cf08007961260be446ac5857bf7c4959fc651" translate="yes" xml:space="preserve">
          <source>Principles</source>
          <target state="translated">Principles</target>
        </trans-unit>
        <trans-unit id="8626bc3a69aaf8345688242139241ffe2cd1037a" translate="yes" xml:space="preserve">
          <source>Principles of content negotiation</source>
          <target state="translated">콘텐츠 협상의 원칙</target>
        </trans-unit>
        <trans-unit id="606354f7552e244079dc46f9624e7497309e75ba" translate="yes" xml:space="preserve">
          <source>Prior to 1995, there were three different formats commonly used by
   servers to communicate timestamps.  For compatibility with old
   implementations, all three are defined here.  The preferred format is
   a fixed-length and single-zone subset of the date and time
   specification used by the Internet Message Format [&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;].

     HTTP-date    = IMF-fixdate / obs-date

   An example of the preferred format is

     Sun, 06 Nov 1994 08:49:37 GMT    ; IMF-fixdate

   Examples of the two obsolete formats are

     Sunday, 06-Nov-94 08:49:37 GMT   ; obsolete &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt; format
     Sun Nov  6 08:49:37 1994         ; ANSI C's asctime() format

   A recipient that parses a timestamp value in an HTTP header field
   MUST accept all three HTTP-date formats.  When a sender generates a
   header field that contains one or more timestamps defined as
   HTTP-date, the sender MUST generate those timestamps in the
   IMF-fixdate format.

   An HTTP-date value represents time as an instance of Coordinated
   Universal Time (UTC).  The first two formats indicate UTC by the
   three-letter abbreviation for Greenwich Mean Time, &quot;GMT&quot;, a
   predecessor of the UTC name; values in the asctime format are assumed
   to be in UTC.  A sender that generates HTTP-date values from a local
   clock ought to use NTP ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]) or some similar protocol to
   synchronize its clock to UTC.

   Preferred format:

     IMF-fixdate  = day-name &quot;,&quot; SP date1 SP time-of-day SP GMT
     ; fixed length/zone/capitalization subset of the format
     ; see &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC5322]&lt;/a&gt;

     day-name     = %x4D.6F.6E ; &quot;Mon&quot;, case-sensitive
                  / %x54.75.65 ; &quot;Tue&quot;, case-sensitive
                  / %x57.65.64 ; &quot;Wed&quot;, case-sensitive
                  / %x54.68.75 ; &quot;Thu&quot;, case-sensitive
                  / %x46.72.69 ; &quot;Fri&quot;, case-sensitive
                  / %x53.61.74 ; &quot;Sat&quot;, case-sensitive
                  / %x53.75.6E ; &quot;Sun&quot;, case-sensitive 

     date1        = day SP month SP year
                  ; e.g., 02 Jun 1982

     day          = 2DIGIT
     month        = %x4A.61.6E ; &quot;Jan&quot;, case-sensitive
                  / %x46.65.62 ; &quot;Feb&quot;, case-sensitive
                  / %x4D.61.72 ; &quot;Mar&quot;, case-sensitive
                  / %x41.70.72 ; &quot;Apr&quot;, case-sensitive
                  / %x4D.61.79 ; &quot;May&quot;, case-sensitive
                  / %x4A.75.6E ; &quot;Jun&quot;, case-sensitive
                  / %x4A.75.6C ; &quot;Jul&quot;, case-sensitive
                  / %x41.75.67 ; &quot;Aug&quot;, case-sensitive
                  / %x53.65.70 ; &quot;Sep&quot;, case-sensitive
                  / %x4F.63.74 ; &quot;Oct&quot;, case-sensitive
                  / %x4E.6F.76 ; &quot;Nov&quot;, case-sensitive
                  / %x44.65.63 ; &quot;Dec&quot;, case-sensitive
     year         = 4DIGIT

     GMT          = %x47.4D.54 ; &quot;GMT&quot;, case-sensitive

     time-of-day  = hour &quot;:&quot; minute &quot;:&quot; second
                  ; 00:00:00 - 23:59:60 (leap second)

     hour         = 2DIGIT
     minute       = 2DIGIT
     second       = 2DIGIT

   Obsolete formats:

     obs-date     = &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date / asctime-date

     &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date  = day-name-l &quot;,&quot; SP date2 SP time-of-day SP GMT
     date2        = day &quot;-&quot; month &quot;-&quot; 2DIGIT
                  ; e.g., 02-Jun-82

     day-name-l   = %x4D.6F.6E.64.61.79    ; &quot;Monday&quot;, case-sensitive
            / %x54.75.65.73.64.61.79       ; &quot;Tuesday&quot;, case-sensitive
            / %x57.65.64.6E.65.73.64.61.79 ; &quot;Wednesday&quot;, case-sensitive
            / %x54.68.75.72.73.64.61.79    ; &quot;Thursday&quot;, case-sensitive
            / %x46.72.69.64.61.79          ; &quot;Friday&quot;, case-sensitive
            / %x53.61.74.75.72.64.61.79    ; &quot;Saturday&quot;, case-sensitive
            / %x53.75.6E.64.61.79          ; &quot;Sunday&quot;, case-sensitive


     asctime-date = day-name SP date3 SP time-of-day SP year
     date3        = month SP ( 2DIGIT / ( SP 1DIGIT ))
                  ; e.g., Jun  2 

   HTTP-date is case sensitive.  A sender MUST NOT generate additional
   whitespace in an HTTP-date beyond that specifically included as SP in
   the grammar.  The semantics of day-name, day, month, year, and
   time-of-day are the same as those defined for the Internet Message
   Format constructs with the corresponding name ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt;], &lt;a href=&quot;#section-3.3&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt;).

   Recipients of a timestamp value in &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date format, which uses a
   two-digit year, MUST interpret a timestamp that appears to be more
   than 50 years in the future as representing the most recent year in
   the past that had the same last two digits.

   Recipients of timestamp values are encouraged to be robust in parsing
   timestamps unless otherwise restricted by the field definition.  For
   example, messages are occasionally forwarded over HTTP from a
   non-HTTP source that might generate any of the date and time
   specifications defined by the Internet Message Format.

      Note: HTTP requirements for the date/time stamp format apply only
      to their usage within the protocol stream.  Implementations are
      not required to use these formats for user presentation, request
      logging, etc.</source>
          <target state="translated">1995 년 이전에는 서버가 타임 스탬프를 통신하기 위해 일반적으로 사용하는 세 가지 형식이있었습니다. 이전 구현과의 호환성을 위해 세 가지가 모두 여기에 정의되어 있습니다. 기본 형식은 인터넷 메시지 형식 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ] 에서 사용하는 날짜 및 시간 사양의 고정 길이 및 단일 영역 하위 집합입니다 . HTTP-date = IMF-fixdate / obs-date 선호하는 형식의 예는 Sun, 1994 년 11 월 6 일 08:49:37 GMT입니다. IMF-fixdate 사용되지 않는 두 가지 형식의 예는 06-Nov-94 08:49:37 GMT입니다. 더 이상 사용되지 않는 &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;RFC 850&lt;/a&gt;형식 일요일 11 월 6 일 08:49:37 1994; ANSI C의 asctime () 형식 HTTP 헤더 필드에서 타임 스탬프 값을 구문 분석하는 수신자는 세 가지 HTTP- 날짜 형식을 모두 수락해야합니다. 발신자가 HTTP- 날짜로 정의 된 하나 이상의 타임 스탬프를 포함하는 헤더 필드를 생성 할 때, 발신자는 해당 타임 스탬프를 IMF-fixdate 형식으로 생성해야합니다. HTTP- 날짜 값은 UTC (협정 세계시)의 인스턴스로 시간을 나타냅니다. 처음 두 형식은 UTC 이름의 전신 인 &quot;GMT&quot;인 그리니치 표준시의 3 자리 약어로 UTC를 나타냅니다. asctime 형식의 값은 UTC로 가정합니다. 로컬 시계에서 HTTP 날짜 값을 생성하는 발신자는 NTP를 사용해야합니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC5905&lt;/a&gt;]) 또는 유사한 프로토콜을 사용하여 시계를 UTC와 동기화합니다. 권장 형식 : IMF-fixdate = day-name &quot;,&quot;SP 날짜 1 SP 시간 SP GMT; 포맷의 고정 길이 / 구역 / 자본 부분 집합; &lt;a href=&quot;https://tools.ietf.org/html/rfc5322#section-3.3&quot;&gt;[RFC5322] 섹션 3.3&lt;/a&gt; 참조 요일 이름 = % x4D.6F.6E; &quot;Mon&quot;, 대소 문자 구분 / % x54.75.65; &quot;화&quot;, 대소 문자 구분 / % x57.65.64; &quot;수&quot;, 대소 문자 구분 / % x54.68.75; &quot;목&quot;, 대소 문자 구분 / % x46.72.69; &quot;금&quot;, 대소 문자 구분 / % x53.61.74; &quot;토&quot;, 대소 문자 구분 / % x53.75.6E; &quot;일&quot;, 대소 문자 구분 date1 = 일 SP 월 SP 년; 예를 들어, 1982 년 6 월 2 일 = 2DIGIT 월 = % x4A.61.6E; &quot;Jan&quot;, 대소 문자 구분 / % x46.65.62; &quot;2 월&quot;, 대소 문자 구분 / % x4D.61.72; &quot;Mar&quot;, 대소 문자 구분 / % x41.70.72; &quot;4 월&quot;, 대소 문자 구분 / % x4D.61.79;&quot;5 월&quot;, 대소 문자 구분 / % x4A.75.6E; &quot;Jun&quot;, 대소 문자 구분 /%x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6E; &quot;Jun&quot;, 대소 문자 구분 /%x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;12 월&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6E; &quot;Jun&quot;, 대소 문자 구분 /%x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;12 월&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x4A.75.6C; &quot;Jul&quot;, 대소 문자 구분 / % x41.75.67; &quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;12 월&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =&quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =&quot;8 월&quot;, 대소 문자 구분 / % x53.65.70; &quot;Sep&quot;, 대소 문자 구분 / % x4F.63.74; &quot;10 월&quot;, 대소 문자 구분 / % x4E.6F.76; &quot;Nov&quot;, 대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =대소 문자 구분 / % x44.65.63; &quot;Dec&quot;, 대소 문자 구분 연도 = 4DIGIT GMT = % x47.4D.54; &quot;GMT&quot;, 대소 문자 구분 시간 = 시간 &quot;:&quot;분 &quot;:&quot;초; 00:00:00-23:59:60 (윤초) 시간 = 2DIGIT 분 = 2DIGIT 초 = 2DIGIT 사용되지 않는 형식 : obs-date =&lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850-&lt;/a&gt; 날짜 / asctime-date &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt;-date = day-name-l &quot;,&quot;SP date2 SP 시간대 SP GMT date2 = 일 &quot;-&quot;월 &quot;-&quot;2DIGIT; 예를 들어, 02-Jun-82 day-name-1 = % x4D.6F.6E.64.61.79; &quot;월요일&quot;, 대소 문자 구분 / % x54.75.65.73.64.61.79; &quot;화요일&quot;, 대소 문자 구분 / % x57.65.64.6E.65.73.64.61.79; &quot;수요일&quot;, 대소 문자 구분 / % x54.68.75.72.73.64.61.79; &quot;목요일&quot;, 대소 문자 구분 / % x46.72.69.64.61.79; &quot;금요일&quot;, 대소 문자 구분 / % x53.61.74.75.72.64.61.79; &quot;토요일&quot;, 대소 문자 구분 / % x53.75.6E.64.61.79; &quot;일요일&quot;,대소 문자 구분 asctime-date = 요일 이름 SP date3 SP 시간 SP 연도 date3 = 월 SP (2DIGIT / (SP 1DIGIT)); 예를 들어, Jun 2 HTTP-date는 대소 문자를 구분합니다. 발신자는 문법에 SP로 특별히 포함 된 것보다 HTTP 날짜에 추가 공백을 생성해서는 안됩니다 (MUST NOT). 요일, 요일, 월, 년 및 시간의 의미는 해당 이름을 가진 인터넷 메시지 형식 구성에 정의 된 것과 동일합니다 ([&lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC5322&lt;/a&gt; ], &lt;a href=&quot;#section-3.3&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-3.3&quot;&gt;3.3&lt;/a&gt; ). &lt;a href=&quot;https://tools.ietf.org/html/rfc850&quot;&gt;rfc850&lt;/a&gt; 의 타임 스탬프 값 수신자두 자리 연도를 사용하는 -date 형식은 미래에 50 년 이상인 것으로 보이는 타임 스탬프를 과거의 마지막 두 자리가 같은 과거의 가장 최근 연도를 나타내는 것으로 해석해야합니다. 필드 정의에 의해 달리 제한되지 않는 한 타임 스탬프 값의 수신자는 타임 스탬프 구문 분석에 강력해야합니다. 예를 들어, 인터넷 메시지 형식으로 정의 된 날짜 및 시간 사양을 생성 할 수있는 비 HTTP 소스에서 HTTP를 통해 메시지가 전달되는 경우가 있습니다. 참고 : 날짜 / 시간 스탬프 형식에 대한 HTTP 요구 사항은 프로토콜 스트림 내에서의 사용에만 적용됩니다. 사용자 프리젠 테이션, 요청 로깅 등에 이러한 형식을 사용하도록 구현할 필요는 없습니다.</target>
        </trans-unit>
        <trans-unit id="2b062cd147b0942de87c57e0c733a01809ece854" translate="yes" xml:space="preserve">
          <source>Prior to Firefox 23, &lt;code&gt;xhr-src&lt;/code&gt; was used in place of the &lt;code&gt;connect-src&lt;/code&gt; directive and only restricted the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Firefox 23 이전에는 &lt;code&gt;connect-src&lt;/code&gt; 지시문 대신 &lt;code&gt;xhr-src&lt;/code&gt; 가 사용되었으며 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; &lt;/a&gt; 의 사용 만 제한했습니다 .</target>
        </trans-unit>
        <trans-unit id="d57d5feaa25422cc7cc558713f8921abe6d1b2f7" translate="yes" xml:space="preserve">
          <source>Prior to Firefox 4 and Gecko 2.0, it was possible for extensions to add user agent parts through the &lt;code&gt;general.useragent.extra.&lt;em&gt;identifier&lt;/em&gt;&lt;/code&gt; preferences, (see the &lt;a href=&quot;https://developer.mozilla.org/En/User_Agent_Strings_Reference&quot;&gt;obsolete User Agent Strings Reference&lt;/a&gt;). But that has not been possible since &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=581008&quot;&gt;bug 581008&lt;/a&gt;.</source>
          <target state="translated">Firefox 4 및 Gecko 2.0 이전에는 확장 프로그램에서 &lt;code&gt;general.useragent.extra.&lt;em&gt;identifier&lt;/em&gt;&lt;/code&gt; 통해 사용자 에이전트 부분을 추가 할 수있었습니다 . &lt;em&gt;식별자&lt;/em&gt; 기본 설정 ( &lt;a href=&quot;https://developer.mozilla.org/En/User_Agent_Strings_Reference&quot;&gt;사용되지 않는 User Agent Strings Reference 참조&lt;/a&gt; ) 그러나 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=581008&quot;&gt;버그 581008&lt;/a&gt; 이후로는 불가능 했습니다 .</target>
        </trans-unit>
        <trans-unit id="c00bbbbf7eb977220c49fd643d1d96935e146d46" translate="yes" xml:space="preserve">
          <source>Prior to Firefox 50, ping attributes of &amp;lt;a&amp;gt; elements weren't covered by connect-src.</source>
          <target state="translated">Firefox 50 이전에는 &amp;lt;a&amp;gt; 요소의 ping 속성에 connect-src가 포함되지 않았습니다.</target>
        </trans-unit>
        <trans-unit id="6f0f6ee6e2fc7ee924f7d60f93cca17ee4751601" translate="yes" xml:space="preserve">
          <source>Prior to persistent connections, a separate TCP connection was
   established to fetch each URL, increasing the load on HTTP servers
   and causing congestion on the Internet. The use of inline images and
   other associated data often require a client to make multiple
   requests of the same server in a short amount of time. Analysis of
   these performance problems and results from a prototype
   implementation are available [&lt;a href=&quot;#ref-26&quot;&gt;26&lt;/a&gt;] [&lt;a href=&quot;#ref-30&quot;&gt;30&lt;/a&gt;]. Implementation experience and
   measurements of actual HTTP/1.1 (&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;) implementations show good
   results [&lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt;]. Alternatives have also been explored, for example,
   T/TCP [&lt;a href=&quot;#ref-27&quot;&gt;27&lt;/a&gt;].

   Persistent HTTP connections have a number of advantages:

      - By opening and closing fewer TCP connections, CPU time is saved
        in routers and hosts (clients, servers, proxies, gateways,
        tunnels, or caches), and memory used for TCP protocol control
        blocks can be saved in hosts.

      - HTTP requests and responses can be pipelined on a connection.
        Pipelining allows a client to make multiple requests without
        waiting for each response, allowing a single TCP connection to
        be used much more efficiently, with much lower elapsed time.

      - Network congestion is reduced by reducing the number of packets
        caused by TCP opens, and by allowing TCP sufficient time to
        determine the congestion state of the network.

      - Latency on subsequent requests is reduced since there is no time
        spent in TCP's connection opening handshake.

      - HTTP can evolve more gracefully, since errors can be reported
        without the penalty of closing the TCP connection. Clients using
        future versions of HTTP might optimistically try a new feature,
        but if communicating with an older server, retry with old
        semantics after an error is reported.

   HTTP implementations SHOULD implement persistent connections.</source>
          <target state="translated">지속적인 연결 이전에는 각 URL을 가져 오기 위해 별도의 TCP 연결이 설정되어 HTTP 서버의로드가 증가하고 인터넷 정체가 발생했습니다. 인라인 이미지 및 기타 관련 데이터를 사용하려면 클라이언트가 짧은 시간 내에 동일한 서버에 대해 여러 번 요청해야합니다. 이러한 성능 문제와 프로토 타입 구현 결과를 분석 할 수 있습니다 [ &lt;a href=&quot;#ref-26&quot;&gt;26&lt;/a&gt; ] [ &lt;a href=&quot;#ref-30&quot;&gt;30&lt;/a&gt; ]. 실제 HTTP / 1.1 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; ) 구현 의 구현 경험과 측정은 좋은 결과를 보여줍니다 [ &lt;a href=&quot;#ref-39&quot;&gt;39&lt;/a&gt; ]. 대안들, 예를 들어 T / TCP [ &lt;a href=&quot;#ref-27&quot;&gt;27&lt;/a&gt;]. 지속적인 HTTP 연결에는 여러 가지 장점이 있습니다.-적은 TCP 연결을 열고 닫으면 라우터 및 호스트 (클라이언트, 서버, 프록시, 게이트웨이, 터널 또는 캐시)에 CPU 시간이 절약되고 TCP 프로토콜 제어 블록에 사용되는 메모리는 호스트에 저장됩니다. -연결에서 HTTP 요청 및 응답을 파이프 라인 할 수 있습니다. 파이프 라이닝을 사용하면 클라이언트가 각 응답을 기다리지 않고 여러 요청을 할 수 있으므로 단일 TCP 연결을 훨씬 더 효율적으로 사용할 수 있으며 경과 시간이 훨씬 줄어 듭니다. -TCP 개방으로 인한 패킷 수를 줄이고 TCP가 네트워크의 혼잡 상태를 결정하기에 충분한 시간을 허용함으로써 네트워크 혼잡이 줄어 듭니다.-TCP의 연결 열기 핸드 셰이크에 시간이 걸리지 않으므로 후속 요청의 대기 시간이 줄어 듭니다. -TCP 연결을 종료하지 않고도 오류를보고 할 수 있으므로 HTTP가보다 정교하게 발전 할 수 있습니다. 이후 버전의 HTTP를 사용하는 클라이언트는 새 기능을 낙관적으로 시도 할 수 있지만 이전 서버와 통신하는 경우 오류가보고 된 후 이전 시맨틱으로 다시 시도하십시오. HTTP 구현은 지속적인 연결을 구현해야한다.오류가보고 된 후 오래된 의미로 다시 시도하십시오. HTTP 구현은 지속적인 연결을 구현해야한다.오류가보고 된 후 오래된 의미로 다시 시도하십시오. HTTP 구현은 지속적인 연결을 구현해야한다.</target>
        </trans-unit>
        <trans-unit id="48f4bbdda03dd3d60abd9b0625517bb4f9e03c60" translate="yes" xml:space="preserve">
          <source>Privacy and security</source>
          <target state="translated">개인 정보 및 보안</target>
        </trans-unit>
        <trans-unit id="bbd89aaef22dbe5fdebdee59a22213f02450b20f" translate="yes" xml:space="preserve">
          <source>Privacy, permissions, and information security</source>
          <target state="translated">개인 정보, 권한 및 정보 보안</target>
        </trans-unit>
        <trans-unit id="e142ec9e0f6fa82bbf90633fcce2ae639984a559" translate="yes" xml:space="preserve">
          <source>Private and public caches</source>
          <target state="translated">개인 및 공개 캐시</target>
        </trans-unit>
        <trans-unit id="b1319505ddbfe3c5d91b4e791afac59bd01e7636" translate="yes" xml:space="preserve">
          <source>Private browser caches</source>
          <target state="translated">개인 브라우저 캐시</target>
        </trans-unit>
        <trans-unit id="41e627b20e59eecdf41ecb162cc910e00b4e3ba5" translate="yes" xml:space="preserve">
          <source>Proactive content negotiation headers include:</source>
          <target state="translated">사전 컨텐츠 협상 헤더에는 다음이 포함됩니다.</target>
        </trans-unit>
        <trans-unit id="2041fbebaa1382f9d0b04acabe68e206456d7c3c" translate="yes" xml:space="preserve">
          <source>Problems like these can be avoided by testing for support of the feature itself instead:</source>
          <target state="translated">Problems like these can be avoided by testing for support of the feature itself instead:</target>
        </trans-unit>
        <trans-unit id="087c7190faf5e2b716771946a752c1b33c0f18a0" translate="yes" xml:space="preserve">
          <source>Product tokens are used to allow communicating applications to
   identify themselves by software name and version. Most fields using
   product tokens also allow sub-products which form a significant part
   of the application to be listed, separated by white space. By
   convention, the products are listed in order of their significance
   for identifying the application.

       product         = token [&quot;/&quot; product-version]
       product-version = token

   Examples:

       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
       Server: Apache/0.8.4 

   Product tokens SHOULD be short and to the point. They MUST NOT be
   used for advertising or other non-essential information. Although any
   token character MAY appear in a product-version, this token SHOULD
   only be used for a version identifier (i.e., successive versions of
   the same product SHOULD only differ in the product-version portion of
   the product value).</source>
          <target state="translated">제품 토큰은 통신 응용 프로그램이 소프트웨어 이름 및 버전으로 자신을 식별 할 수 있도록하는 데 사용됩니다. 제품 토큰을 사용하는 대부분의 필드에서는 응용 프로그램의 중요한 부분을 구성하는 하위 제품을 공백으로 구분하여 나열 할 수도 있습니다. 일반적으로 제품은 응용 프로그램을 식별하는 데있어 중요한 순서대로 나열됩니다. product = token [ &quot;/&quot;product-version] product-version = token 예 : User-Agent : CERN-LineMode / 2.15 libwww / 2.17b3 서버 : Apache / 0.8.4 제품 토큰은 짧아야합니다. 광고 또는 기타 중요하지 않은 정보에 사용해서는 안됩니다. 토큰 버전이 제품 버전에 나타날 수 있지만이 토큰은 버전 식별자 (예 :동일한 제품의 연속 버전은 제품 가치의 제품 버전 부분에서만 달라야합니다.</target>
        </trans-unit>
        <trans-unit id="3418c299ab2f552ddf1770d269bc4a148956b6eb" translate="yes" xml:space="preserve">
          <source>Progressive enhancement</source>
          <target state="translated">진보적 인 향상</target>
        </trans-unit>
        <trans-unit id="b53e75d9632b419f01390beb8bf5b4225366d8b3" translate="yes" xml:space="preserve">
          <source>Proper cache operation preserves the semantics of HTTP transfers
   ([&lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]) while eliminating the transfer of information already
   held in the cache.  Although caching is an entirely OPTIONAL feature
   of HTTP, it can be assumed that reusing a cached response is
   desirable and that such reuse is the default behavior when no
   requirement or local configuration prevents it.  Therefore, HTTP
   cache requirements are focused on preventing a cache from either
   storing a non-reusable response or reusing a stored response
   inappropriately, rather than mandating that caches always store and
   reuse particular responses.

   Each cache entry consists of a cache key and one or more HTTP
   responses corresponding to prior requests that used the same key.
   The most common form of cache entry is a successful result of a
   retrieval request: i.e., a 200 (OK) response to a GET request, which
   contains a representation of the resource identified by the request
   target (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;Section&amp;nbsp;4.3.1 of [RFC7231]&lt;/a&gt;).  However, it is also possible to
   cache permanent redirects, negative results (e.g., 404 (Not Found)), 

   incomplete results (e.g., 206 (Partial Content)), and responses to
   methods other than GET if the method's definition allows such caching
   and defines something suitable for use as a cache key.

   The primary cache key consists of the request method and target URI.
   However, since HTTP caches in common use today are typically limited
   to caching responses to GET, many caches simply decline other methods
   and use only the URI as the primary cache key.

   If a request target is subject to content negotiation, its cache
   entry might consist of multiple stored responses, each differentiated
   by a secondary key for the values of the original request's selecting
   header fields (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;).</source>
          <target state="translated">적절한 캐시 작업은 HTTP 전송의 의미를 유지합니다 ([ &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC7231&lt;/a&gt;]) 이미 캐시에 보유한 정보의 전송을 제거합니다. 캐싱은 HTTP의 전적으로 선택적인 기능이지만 캐시 된 응답을 재사용하는 것이 바람직하며 요구 사항이나 로컬 구성으로이를 방지하지 않는 경우 이러한 재사용이 기본 동작이라고 가정 할 수 있습니다. 따라서 HTTP 캐시 요구 사항은 캐시가 항상 특정 응답을 저장하고 재사용하도록 강제하는 대신 캐시가 재사용 불가능한 응답을 저장하거나 저장된 응답을 부적절하게 재사용하지 못하도록하는 데 중점을 둡니다. 각 캐시 항목은 캐시 키와 동일한 키를 사용한 이전 요청에 해당하는 하나 이상의 HTTP 응답으로 구성됩니다. 가장 일반적인 형태의 캐시 엔트리는 검색 요청의 성공적인 결과입니다. 즉, GET 요청에 대한 200 (OK) 응답,요청 대상에 의해 식별 된 리소스의 표현을 포함합니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.1&quot;&gt;[RFC7231]의 섹션 4.3.1&lt;/a&gt;). 그러나 방법의 정의가 캐싱을 허용하는 경우 영구 리디렉션, 부정적인 결과 (예 : 404 (찾을 수 없음)), 불완전한 결과 (예 : 206 (부분 내용)) 및 GET 이외의 방법에 대한 응답을 캐시 할 수도 있습니다. 캐시 키로 사용하기에 적합한 것을 정의합니다. 기본 캐시 키는 요청 방법과 대상 URI로 구성됩니다. 그러나 오늘날 일반적으로 사용되는 HTTP 캐시는 일반적으로 GET에 대한 응답 캐싱으로 제한되므로 많은 캐시는 단순히 다른 방법을 거부하고 URI 만 기본 캐시 키로 사용합니다. 요청 대상이 내용 협상의 대상이되는 경우, 해당 캐시 항목은 여러 개의 저장된 응답으로 구성 될 수 있으며 각 요청은 원래 요청의 선택 헤더 필드 값에 대한 보조 키로 구분됩니다 ( &lt;a href=&quot;#section-4.1&quot;&gt;4.1 절).&lt;/a&gt;).</target>
        </trans-unit>
        <trans-unit id="b9fbc1e3c42cd5403dbaa2b56fde8f98ce0f1904" translate="yes" xml:space="preserve">
          <source>Properly configuring server MIME types</source>
          <target state="translated">서버 MIME 유형을 올바르게 구성</target>
        </trans-unit>
        <trans-unit id="c7f500a0888429d2c8e89835562929df19e1c741" translate="yes" xml:space="preserve">
          <source>Properties already exist, in a limited sense, in HTTP message
   headers.  However, in distributed authoring environments, a
   relatively large number of properties are needed to describe the
   state of a resource, and setting/returning them all through HTTP
   headers is inefficient.  Thus, a mechanism is needed that allows a
   principal to identify a set of properties in which the principal is
   interested and to set or retrieve just those properties.</source>
          <target state="translated">HTTP 메시지 헤더에는 이미 제한된 의미로 속성이 있습니다. 그러나 분산 작성 환경에서는 리소스의 상태를 설명하기 위해 비교적 많은 속성이 필요하며 HTTP 헤더를 통해 모든 속성을 설정 / 반환하는 것은 비효율적입니다. 따라서, 주체가 주체가 관심을 갖는 특성 세트를 식별하고 해당 특성 만 설정하거나 검색 할 수있는 메커니즘이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="4c8925f6237eb1d7afbb04e595799795cd419670" translate="yes" xml:space="preserve">
          <source>Properties are pieces of data that describe the state of a resource.
   Properties are data about data.

   Properties are used in distributed authoring environments to provide
   for efficient discovery and management of resources.  For example, a
   'subject' property might allow for the indexing of all resources by
   their subject, and an 'author' property might allow for the discovery
   of what authors have written which documents.

   The DAV property model consists of name/value pairs.  The name of a
   property identifies the property's syntax and semantics, and provides
   an address by which to refer to its syntax and semantics.

   There are two categories of properties: &quot;live&quot; and &quot;dead&quot;.  A live
   property has its syntax and semantics enforced by the server.  Live
   properties include cases where a) the value of a property is
   protected and maintained by the server, and b) the value of the
   property is maintained by the client, but the server performs syntax
   checking on submitted values.  All instances of a given live property
   MUST comply with the definition associated with that property name.
   A dead property has its syntax and semantics enforced by the client;
   the server merely records the value of the property verbatim.</source>
          <target state="translated">속성은 리소스의 상태를 설명하는 데이터 조각입니다. 속성은 데이터에 대한 데이터입니다. 분산 저작 환경에서 속성을 사용하여 리소스를 효율적으로 검색하고 관리 할 수 ​​있습니다. 예를 들어, 'subject'속성은 주제별로 모든 리소스의 색인을 생성 할 수 있으며 'author'속성은 작성자가 어떤 문서를 작성했는지 확인할 수 있습니다. DAV 속성 모델은 이름 / 값 쌍으로 구성됩니다. 속성 이름은 속성의 구문과 의미를 식별하고 해당 구문과 의미를 참조 할 주소를 제공합니다. 속성은 &quot;live&quot;와 &quot;dead&quot;의 두 가지 범주가 있습니다. 라이브 속성에는 서버에 의해 시행되는 구문과 의미가 있습니다.라이브 속성에는 a) 속성 값이 서버에 의해 보호 및 유지 관리되고 b) 속성 값이 클라이언트에 의해 유지 관리되지만 제출 된 값에 대해 구문 검사를 수행하는 경우가 포함됩니다. 지정된 라이브 속성의 모든 인스턴스는 해당 속성 이름과 관련된 정의를 준수해야합니다. 죽은 속성에는 클라이언트가 적용하는 구문과 의미가 있습니다. 서버는 단지 속성의 값을 그대로 기록합니다.죽은 속성에는 클라이언트가 적용하는 구문과 의미가 있습니다. 서버는 단지 속성의 값을 그대로 기록합니다.죽은 속성에는 클라이언트가 적용하는 구문과 의미가 있습니다. 서버는 단지 속성의 값을 그대로 기록합니다.</target>
        </trans-unit>
        <trans-unit id="929017ada05ac8077c3ebc10b0f695a210b9db02" translate="yes" xml:space="preserve">
          <source>Proposal</source>
          <target state="translated">Proposal</target>
        </trans-unit>
        <trans-unit id="bc233ecf22c9f1db23c365e4a2642bb8cba6a816" translate="yes" xml:space="preserve">
          <source>Proposed Standard</source>
          <target state="translated">제안 된 표준</target>
        </trans-unit>
        <trans-unit id="bf009ce8a837a5209a379d6adc4c70a76703ec19" translate="yes" xml:space="preserve">
          <source>Proprietary file types. Avoid using &lt;code&gt;application/octet-stream&lt;/code&gt; as most browsers do not allow defining a default behavior (like &quot;Open in Word&quot;) for this generic MIME type. A specific type like &lt;code&gt;application/vnd.mspowerpoint&lt;/code&gt; lets users open such files automatically in the presentation software of their choice.</source>
          <target state="translated">독점 파일 형식. 대부분의 브라우저는이 일반 MIME 유형에 대한 기본 동작 (예 : &quot;Open in Word&quot;)을 정의 할 수 없으므로 &lt;code&gt;application/octet-stream&lt;/code&gt; 을 사용하지 마십시오 . &lt;code&gt;application/vnd.mspowerpoint&lt;/code&gt; 와 같은 특정 유형을 사용하면 선택한 프레젠테이션 소프트웨어에서 해당 파일을 자동으로 열 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="dcd33e932fe6859eb640384bc6909307c3f08b41" translate="yes" xml:space="preserve">
          <source>Protocol Parameters (RFC 2616)</source>
          <target state="translated">프로토콜 매개 변수 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="923c328c14b08b33713e5d95d3fe51b88c0e5ddf" translate="yes" xml:space="preserve">
          <source>Protocol upgrade mechanism</source>
          <target state="translated">프로토콜 업그레이드 메커니즘</target>
        </trans-unit>
        <trans-unit id="d296cfe938e4cb136e0d8482641c0b8111e49c1c" translate="yes" xml:space="preserve">
          <source>Protocol upgrades are always requested by the client; there is no mechanism provided for the server to request a protocol change. When the client wishes to upgrade to a new protocol, it does so by sending a normal request of any type to the server (&lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, etc.). The request needs to be configured specially to include the upgrade request, however.</source>
          <target state="translated">프로토콜 업그레이드는 항상 클라이언트가 요청합니다. 서버가 프로토콜 변경을 요청하는 메커니즘은 없습니다. 클라이언트가 새 프로토콜로 업그레이드하려는 경우 모든 유형의 일반 요청을 서버 ( &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 등) 로 보내면 됩니다. 그러나 업그레이드 요청을 포함하도록 요청을 특별히 구성해야합니다.</target>
        </trans-unit>
        <trans-unit id="78359c5321600cfef9ecc319741fe090221605a5" translate="yes" xml:space="preserve">
          <source>Protocols are listed, comma-separated, in order of descending preference. Protocol version is optional. For example:</source>
          <target state="translated">프로토콜은 선호도가 내림차순으로 쉼표로 구분되어 나열됩니다. 프로토콜 버전은 선택 사항입니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="4f624685bc2b146442ac162d357d3d682338bac4" translate="yes" xml:space="preserve">
          <source>Provides a mechanism to allow and deny the use of browser features in its own frame, and in iframes that it embeds.</source>
          <target state="translated">자체 프레임과 iframe에 포함 된 브라우저 기능의 사용을 허용 및 거부하는 메커니즘을 제공합니다.</target>
        </trans-unit>
        <trans-unit id="78aa08577ee820c59002317e125bb74d8b5df64d" translate="yes" xml:space="preserve">
          <source>Provides a mechanism to allow web applications to isolate their origins.</source>
          <target state="translated">Provides a mechanism to allow web applications to isolate their origins.</target>
        </trans-unit>
        <trans-unit id="11968b9c181aaf96f57288610c04f25c02a09d23" translate="yes" xml:space="preserve">
          <source>Provides information to the server which is needed in order to confirm that the client is entitled to request an upgrade to WebSocket. This header can be used when insecure (HTTP) clients wish to upgrade, in order to offer some degree of protection against abuse. The value of the key is computed using an algorithm defined in the WebSocket specification, so this &lt;em&gt;does not provide security&lt;/em&gt;. Instead, it helps to prevent non-WebSocket clients from inadvertently, or through misuse, requesting a WebSocket connection. In essence, then, this key simply confirms that &quot;Yes, I really mean to open a WebSocket connection.&quot;</source>
          <target state="translated">클라이언트가 WebSocket으로의 업그레이드를 요청할 권한이 있는지 확인하기 위해 필요한 정보를 서버에 제공합니다. 이 헤더는 안전하지 않은 (HTTP) 클라이언트가 업그레이드를 원하는 경우 남용에 대해 어느 정도의 보호를 제공하기 위해 사용할 수 있습니다. 키의 값은 WebSocket 사양에 정의 된 알고리즘을 사용하여 계산되므로 &lt;em&gt;보안을 제공하지 않습니다&lt;/em&gt; . 대신, WebSocket 이외의 클라이언트가 실수로 또는 오용하여 WebSocket 연결을 요청하는 것을 방지합니다. 본질적으로이 키는 단순히 &quot;예, WebSocket 연결을 여는 것을 의미합니다.&quot;</target>
        </trans-unit>
        <trans-unit id="018c3e9378282caf36585ac2bcc9f60f3a4154de" translate="yes" xml:space="preserve">
          <source>Providing a block of data, such as the result of submitting a form, to a data-handling process;</source>
          <target state="translated">양식 제출 결과와 같은 데이터 블록을 데이터 처리 프로세스에 제공하는 단계;</target>
        </trans-unit>
        <trans-unit id="c3d8b749aec91d94ef9ced533c0007fb5b034097" translate="yes" xml:space="preserve">
          <source>Providing granular control over sensitive or powerful features.</source>
          <target state="translated">민감하거나 강력한 기능을 세밀하게 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9db0b745b6fa2951c35528cc5a431b74d851a2e8" translate="yes" xml:space="preserve">
          <source>Proxies</source>
          <target state="translated">Proxies</target>
        </trans-unit>
        <trans-unit id="9d27f7bb5ddd3b0e18ffdf81d878bca715670b1b" translate="yes" xml:space="preserve">
          <source>Proxies can make requests appear as if they originated from the proxy's IP address. This can be useful if a proxy is used to provide client anonymity, but in other cases information from the original request is lost. The IP address of the original client is often used for debugging, statistics, or generating location-dependent content. A common way to disclose this information is by using the following HTTP headers:</source>
          <target state="translated">프록시는 프록시 IP 주소에서 시작된 것처럼 요청을 표시 할 수 있습니다. 프록시가 클라이언트 익명 성을 제공하는 데 사용되지만 다른 경우 원래 요청의 정보가 손실되는 경우에 유용 할 수 있습니다. 원래 클라이언트의 IP 주소는 종종 디버깅, 통계 또는 위치 종속 컨텐츠 생성에 사용됩니다. 이 정보를 공개하는 일반적인 방법은 다음 HTTP 헤더를 사용하는 것입니다.</target>
        </trans-unit>
        <trans-unit id="d1cea344353e26ba6f1565ed661d94f610ce9e4f" translate="yes" xml:space="preserve">
          <source>Proxy</source>
          <target state="translated">Proxy</target>
        </trans-unit>
        <trans-unit id="b3a1b86c68a3aa7f85f81802d2ba3d99659e9b35" translate="yes" xml:space="preserve">
          <source>Proxy Auto-Configuration (PAC)</source>
          <target state="translated">프록시 자동 구성 (PAC)</target>
        </trans-unit>
        <trans-unit id="8f9917cc3f9134204105024635f01325cce0c9c8" translate="yes" xml:space="preserve">
          <source>Proxy authentication</source>
          <target state="translated">프록시 인증</target>
        </trans-unit>
        <trans-unit id="042dc6a8d3c410fbcf3a54e1832aee7c37e1ea1e" translate="yes" xml:space="preserve">
          <source>Proxy auto-config was introduced into Netscape Navigator 2.0 in the late 1990s, at the same time when JavaScript was introduced. Open-sourcing Netscape eventually lead to Firefox itself.</source>
          <target state="translated">Proxy auto-config was introduced into Netscape Navigator 2.0 in the late 1990s, at the same time when JavaScript was introduced. Open-sourcing Netscape eventually lead to Firefox itself.</target>
        </trans-unit>
        <trans-unit id="2e280b44f81cc19be751f7835b895d284950da7a" translate="yes" xml:space="preserve">
          <source>Proxy server</source>
          <target state="translated">프록시 서버</target>
        </trans-unit>
        <trans-unit id="dfabf4ef5828660426d5401fdbab484b651cc6c1" translate="yes" xml:space="preserve">
          <source>Proxy server on Wikipedia</source>
          <target state="translated">Wikipedia의 프록시 서버</target>
        </trans-unit>
        <trans-unit id="22bb93eb9e863e2d12b4f0e8bb170a48e48c57e2" translate="yes" xml:space="preserve">
          <source>Proxy servers and tunneling</source>
          <target state="translated">프록시 서버 및 터널링</target>
        </trans-unit>
        <trans-unit id="13246650dfbf91f6f1cdea79edc1ad0b687ad10c" translate="yes" xml:space="preserve">
          <source>Proxy servers and tunneling: Proxy Auto-Configuration (PAC) file</source>
          <target state="translated">프록시 서버 및 터널링 : PAC (Proxy Auto-Configuration) 파일</target>
        </trans-unit>
        <trans-unit id="0ce13782e9ac74ef50b0f764c0721de2a4ae3187" translate="yes" xml:space="preserve">
          <source>Proxy-Authenticate</source>
          <target state="translated">Proxy-Authenticate</target>
        </trans-unit>
        <trans-unit id="dbf9a1785268a0b4ce911682fdc989177a1db77f" translate="yes" xml:space="preserve">
          <source>Proxy-Authenticate (RFC 2616)</source>
          <target state="translated">프록시 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="bfe187da3075a7c7a3d496648a7de30904fd1d98" translate="yes" xml:space="preserve">
          <source>Proxy-Authenticate (RFC 7235)</source>
          <target state="translated">프록시 인증 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="d2fd2a50c1a375beb79e19ec25e0a1496b8c4176" translate="yes" xml:space="preserve">
          <source>Proxy-Authorization</source>
          <target state="translated">Proxy-Authorization</target>
        </trans-unit>
        <trans-unit id="9f1648755bd86ad38e590216d8154c160568d1f5" translate="yes" xml:space="preserve">
          <source>Proxy-Authorization (RFC 2616)</source>
          <target state="translated">프록시 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="38b8e04d0e1db5b505f96dc23f9f03af30df9e82" translate="yes" xml:space="preserve">
          <source>Proxy-Authorization (RFC 7235)</source>
          <target state="translated">프록시 인증 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="d061beeadf90bd540f44d26bf398aa1093494c9c" translate="yes" xml:space="preserve">
          <source>ProxyConfig.bindings</source>
          <target state="translated">ProxyConfig.bindings</target>
        </trans-unit>
        <trans-unit id="6d8b0bc17b7cee3232acc6bbd4f3bf089a9fa15f" translate="yes" xml:space="preserve">
          <source>Public Key Pinning</source>
          <target state="translated">공개 키 고정</target>
        </trans-unit>
        <trans-unit id="734b13d8d37920cbfae35c8554333fc716efe37f" translate="yes" xml:space="preserve">
          <source>Public Key Pinning Extension for HTTP</source>
          <target state="translated">HTTP 용 공개 키 고정 확장</target>
        </trans-unit>
        <trans-unit id="a1e6c8c10beb332571d741b2f1bd1ba0cb86677b" translate="yes" xml:space="preserve">
          <source>Public proxy URL and port.</source>
          <target state="translated">공용 프록시 URL 및 포트</target>
        </trans-unit>
        <trans-unit id="2587a4c5043acc3269a6c7635c5ecb4186dfdc64" translate="yes" xml:space="preserve">
          <source>Public-Key-Pins</source>
          <target state="translated">Public-Key-Pins</target>
        </trans-unit>
        <trans-unit id="00532d766c7988ed952d7de699ce49faa049871d" translate="yes" xml:space="preserve">
          <source>Public-Key-Pins-Report-Only</source>
          <target state="translated">Public-Key-Pins-Report-Only</target>
        </trans-unit>
        <trans-unit id="a0fb821bdaf93ed9a1f1e920acfb2840eff5b153" translate="yes" xml:space="preserve">
          <source>Purpose</source>
          <target state="translated">Purpose</target>
        </trans-unit>
        <trans-unit id="5a1d9471ee6637fd57a8e2ea6e4de1a19d8bb7e9" translate="yes" xml:space="preserve">
          <source>Pushed responses do not have an explicit request from the client; the
   request is provided by the server in the PUSH_PROMISE frame.

   Caching responses that are pushed is possible based on the guidance
   provided by the origin server in the Cache-Control header field.
   However, this can cause issues if a single server hosts more than one
   tenant.  For example, a server might offer multiple users each a
   small portion of its URI space.

   Where multiple tenants share space on the same server, that server
   MUST ensure that tenants are not able to push representations of
   resources that they do not have authority over.  Failure to enforce
   this would allow a tenant to provide a representation that would be
   served out of cache, overriding the actual representation that the
   authoritative tenant provides.

   Pushed responses for which an origin server is not authoritative (see
   &lt;a href=&quot;#section-10.1&quot;&gt;Section 10.1&lt;/a&gt;) MUST NOT be used or cached.</source>
          <target state="translated">푸시 된 응답에는 클라이언트의 명시적인 요청이 없습니다. 요청은 PUSH_PROMISE 프레임에서 서버에 의해 제공됩니다. 푸시 된 응답 캐싱은 Cache-Control 헤더 필드에 원본 서버가 제공 한 지침에 따라 가능합니다. 그러나 단일 서버가 둘 이상의 테넌트를 호스팅하는 경우 문제가 발생할 수 있습니다. 예를 들어 서버는 여러 사용자에게 각각 URI 공간의 작은 부분을 제공 할 수 있습니다. 여러 테넌트가 동일한 서버에서 공간을 공유하는 경우 해당 서버는 테넌트가 권한이없는 리소스 표현을 푸시 할 수 없도록해야합니다. 이를 시행하지 않으면 테넌트가 캐시에서 제공되는 표현을 제공 할 수 있으며 권한있는 테넌트가 제공하는 실제 표현을 무시할 수 있습니다.원본 서버가 권한이없는 푸시 된 응답 (참조 :&lt;a href=&quot;#section-10.1&quot;&gt;섹션 10.1&lt;/a&gt; ) 사용하거나 캐시하면 안됩니다 (MUST NOT).</target>
        </trans-unit>
        <trans-unit id="6e3604888c4b4ec08e2837913d012fe2834ffa83" translate="yes" xml:space="preserve">
          <source>Python</source>
          <target state="translated">Python</target>
        </trans-unit>
        <trans-unit id="1c615d41ae446bdd57adcbe8d5a4e2b0cc338d0d" translate="yes" xml:space="preserve">
          <source>Python solution: &lt;a href=&quot;https://stackoverflow.com/questions/22786068/how-to-avoid-http-error-429-too-many-requests-python&quot;&gt;How to avoid HTTP error 429 python&lt;/a&gt;</source>
          <target state="translated">Python solution: &lt;a href=&quot;https://stackoverflow.com/questions/22786068/how-to-avoid-http-error-429-too-many-requests-python&quot;&gt;How to avoid HTTP error 429 python&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95b741bb15ce7a7be678af41321b1cefa2fe0ef4" translate="yes" xml:space="preserve">
          <source>Quality Values (RFC 7231)</source>
          <target state="translated">품질 가치 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="a618b4be8d3ac72545f3085fe616d342b7139fba" translate="yes" xml:space="preserve">
          <source>Query</source>
          <target state="translated">Query</target>
        </trans-unit>
        <trans-unit id="6bac12c79b364171a7e2113696dc2f7c8e069dd1" translate="yes" xml:space="preserve">
          <source>RAR archive</source>
          <target state="translated">RAR 아카이브</target>
        </trans-unit>
        <trans-unit id="ce001c290e2d02b3c73d5fb8aff7b19ff59cbebd" translate="yes" xml:space="preserve">
          <source>RAR-compressed files. In this case, the ideal would be the true type of the original files; this is often impossible as .RAR files can hold several resources of different types. In this case, configure the server to send &lt;code&gt;application/x-rar-compressed&lt;/code&gt;.</source>
          <target state="translated">RAR 압축 파일. 이 경우 원본 파일의 실제 유형이 이상적입니다. .RAR 파일이 다른 유형의 여러 리소스를 보유 할 수 있기 때문에 종종 불가능합니다. 이 경우 &lt;code&gt;application/x-rar-compressed&lt;/code&gt; 를 보내도록 서버를 구성하십시오 .</target>
        </trans-unit>
        <trans-unit id="bf07afad3e0f9baeb64a047fe678b69fe512bd93" translate="yes" xml:space="preserve">
          <source>RFC 2046, section 5.1.1: Common Syntax</source>
          <target state="translated">RFC 2046, section 5.1.1: Common Syntax</target>
        </trans-unit>
        <trans-unit id="e620fb8a8e1f067cba2c5c8b33cfeae91df101f2" translate="yes" xml:space="preserve">
          <source>RFC 2145</source>
          <target state="translated">RFC 2145</target>
        </trans-unit>
        <trans-unit id="54cf6a79d95c46bece225f0a9f0ff2c8d940f6d5" translate="yes" xml:space="preserve">
          <source>RFC 2183</source>
          <target state="translated">RFC 2183</target>
        </trans-unit>
        <trans-unit id="18e74a0e3edf78480f2b25749781e76e2834d5e1" translate="yes" xml:space="preserve">
          <source>RFC 2295, section 8.1: 506 Variant Also Negotiates</source>
          <target state="translated">RFC 2295, 섹션 8.1 : 506 변형도 협상</target>
        </trans-unit>
        <trans-unit id="eab5986519d8c2f1d79d71fd31bc88f8c184ee68" translate="yes" xml:space="preserve">
          <source>RFC 2324</source>
          <target state="translated">RFC 2324</target>
        </trans-unit>
        <trans-unit id="e8b932b7389942e2684df25c4fc9bca8d4aec36b" translate="yes" xml:space="preserve">
          <source>RFC 2324, section 2.3.2: 418 I'm a teapot</source>
          <target state="translated">RFC 2324, 섹션 2.3.2 : 418 나는 주전자입니다</target>
        </trans-unit>
        <trans-unit id="00c7481edfb50dd9346b5b61ce99268f3a5a80ee" translate="yes" xml:space="preserve">
          <source>RFC 2397</source>
          <target state="translated">RFC 2397</target>
        </trans-unit>
        <trans-unit id="362f9d5706319e0d27ec9dcc6bff4ed91891f763" translate="yes" xml:space="preserve">
          <source>RFC 2616</source>
          <target state="translated">RFC 2616</target>
        </trans-unit>
        <trans-unit id="e74deeee50d3a36446e842eb4b1fc561b4d09074" translate="yes" xml:space="preserve">
          <source>RFC 2616, section 14.11: Content-Encoding</source>
          <target state="translated">RFC 2616, section 14.11: Content-Encoding</target>
        </trans-unit>
        <trans-unit id="f36a582465956ac237732f87fc7a3b78071f019a" translate="yes" xml:space="preserve">
          <source>RFC 2616, section 14.43: User-Agent</source>
          <target state="translated">RFC 2616, section 14.43: User-Agent</target>
        </trans-unit>
        <trans-unit id="558ad0a006347c19da6f6e01c8f14905903534af" translate="yes" xml:space="preserve">
          <source>RFC 2616: HTTP/1.1</source>
          <target state="translated">RFC 2616 : HTTP / 1.1</target>
        </trans-unit>
        <trans-unit id="2580a9d69aa971a730bda042448316d68d8ef231" translate="yes" xml:space="preserve">
          <source>RFC 2774, section 7: 510 Not Extended</source>
          <target state="translated">RFC 2774, 섹션 7 : 510 확장되지 않음</target>
        </trans-unit>
        <trans-unit id="d347b8838ab74754f6c3546ed6688f3c4345b1b3" translate="yes" xml:space="preserve">
          <source>RFC 2817</source>
          <target state="translated">RFC 2817</target>
        </trans-unit>
        <trans-unit id="c20beb689b5f6e7d8768449ffecf7f98f2b7e0fb" translate="yes" xml:space="preserve">
          <source>RFC 2965: Cookie2</source>
          <target state="translated">RFC 2965 : 쿠키 2</target>
        </trans-unit>
        <trans-unit id="f248a43f6e88982bb238b56b5c0187432e4f1efd" translate="yes" xml:space="preserve">
          <source>RFC 2965: Set-Cookie2</source>
          <target state="translated">RFC 2965 : 세트 쿠키 2</target>
        </trans-unit>
        <trans-unit id="cf48f3d5bf7ea08ce5e6f45d9f362f9581e8b3b2" translate="yes" xml:space="preserve">
          <source>RFC 3986</source>
          <target state="translated">RFC 3986</target>
        </trans-unit>
        <trans-unit id="84942944fb40a5234b5c2f832866564d5791a061" translate="yes" xml:space="preserve">
          <source>RFC 4918, section 11.2: 422 Unprocessable Entity</source>
          <target state="translated">RFC 4918, 섹션 11.2 : 422 처리 할 수없는 엔티티</target>
        </trans-unit>
        <trans-unit id="c5089dec0f3206cec1f0caebd8a271748e07953c" translate="yes" xml:space="preserve">
          <source>RFC 4918, section 11.5: 507 Insufficient Storage</source>
          <target state="translated">RFC 4918, 섹션 11.5 : 507 스토리지 부족</target>
        </trans-unit>
        <trans-unit id="fd476ad209927e0e2319f1bd76afddbea0ba44e2" translate="yes" xml:space="preserve">
          <source>RFC 4918: WebDAV</source>
          <target state="translated">RFC 4918 : WebDAV</target>
        </trans-unit>
        <trans-unit id="afb128171db7b00f0fd933b36cae908b332f6db4" translate="yes" xml:space="preserve">
          <source>RFC 5023: The Atom Publishing Protocol</source>
          <target state="translated">RFC 5023 : 원자 게시 프로토콜</target>
        </trans-unit>
        <trans-unit id="fb8a5055f684c82eb4a643f0d2d5fc702e7e8f0a" translate="yes" xml:space="preserve">
          <source>RFC 5246</source>
          <target state="translated">RFC 5246</target>
        </trans-unit>
        <trans-unit id="2f6b2f6ce5e3b4277d0a646055843e6477f381b9" translate="yes" xml:space="preserve">
          <source>RFC 5689</source>
          <target state="translated">RFC 5689</target>
        </trans-unit>
        <trans-unit id="bf1f2785d8f6ee0235d694fd6179a1a3ebce5bba" translate="yes" xml:space="preserve">
          <source>RFC 5789, section 2: Patch method</source>
          <target state="translated">RFC 5789, 섹션 2 : 패치 방법</target>
        </trans-unit>
        <trans-unit id="b361cdcaefc11206bc930838565cb9627884c50a" translate="yes" xml:space="preserve">
          <source>RFC 5789, section 3.1: Accept-Patch</source>
          <target state="translated">RFC 5789, 섹션 3.1 : Accept-Patch</target>
        </trans-unit>
        <trans-unit id="fcb38f9a6380d714f3aa4aa1f4201bc7bc90649d" translate="yes" xml:space="preserve">
          <source>RFC 5789: PATCH</source>
          <target state="translated">RFC 5789 : 패치</target>
        </trans-unit>
        <trans-unit id="129338fc0fcec3ff2a28336afe7da4176f60504d" translate="yes" xml:space="preserve">
          <source>RFC 5842, section 7.2: 508 Loop Detected</source>
          <target state="translated">RFC 5842, 섹션 7.2 : 508 루프 감지 됨</target>
        </trans-unit>
        <trans-unit id="435cdf88638b49c1ce4749b77a33a7b13603777d" translate="yes" xml:space="preserve">
          <source>RFC 5861</source>
          <target state="translated">RFC 5861</target>
        </trans-unit>
        <trans-unit id="226ff035a62a7f266b477b5175c0a96c8bb2165a" translate="yes" xml:space="preserve">
          <source>RFC 5861: HTTP Cache-Control Extensions for Stale Content</source>
          <target state="translated">RFC 5861: HTTP Cache-Control Extensions for Stale Content</target>
        </trans-unit>
        <trans-unit id="48dc1f7525cc2cf74db930d6713d686f2df34d50" translate="yes" xml:space="preserve">
          <source>RFC 5988</source>
          <target state="translated">RFC 5988</target>
        </trans-unit>
        <trans-unit id="0eb539677e760d98dcaf33b04496ee873d22f81f" translate="yes" xml:space="preserve">
          <source>RFC 5988, section 5: The Link Header Field</source>
          <target state="translated">RFC 5988, 섹션 5 : 링크 헤더 필드</target>
        </trans-unit>
        <trans-unit id="2b11e388477bae4eb7798fb62c83b47e1cbed253" translate="yes" xml:space="preserve">
          <source>RFC 6265</source>
          <target state="translated">RFC 6265</target>
        </trans-unit>
        <trans-unit id="b5eb31f373a0763462f319db509a52b6efca5715" translate="yes" xml:space="preserve">
          <source>RFC 6265, section 4.1: Set-Cookie</source>
          <target state="translated">RFC 6265, 섹션 4.1 : 쿠키 설정</target>
        </trans-unit>
        <trans-unit id="15c9cf4fea3d42ffcec6eb1b94d408b0e19bb14e" translate="yes" xml:space="preserve">
          <source>RFC 6265, section 5.4: Cookie</source>
          <target state="translated">RFC 6265, 섹션 5.4 : 쿠키</target>
        </trans-unit>
        <trans-unit id="613865a71a94220a6a1341819550a78bc1fc41ef" translate="yes" xml:space="preserve">
          <source>RFC 6266</source>
          <target state="translated">RFC 6266</target>
        </trans-unit>
        <trans-unit id="d3105d90012e53abd5db2c45d15c178159422497" translate="yes" xml:space="preserve">
          <source>RFC 6454</source>
          <target state="translated">RFC 6454</target>
        </trans-unit>
        <trans-unit id="fd51012d090b8c63c11d5dd6844e9f25685bef76" translate="yes" xml:space="preserve">
          <source>RFC 6454, section 7: Origin</source>
          <target state="translated">RFC 6454, 섹션 7 : 원산지</target>
        </trans-unit>
        <trans-unit id="2e1c3bd109055e3c75b85953fe0738a169565c42" translate="yes" xml:space="preserve">
          <source>RFC 6455</source>
          <target state="translated">RFC 6455</target>
        </trans-unit>
        <trans-unit id="86802f0623b9fab215ab4bcc599a1c003c37e0b7" translate="yes" xml:space="preserve">
          <source>RFC 6455, section 11.3.3: Sec-WebSocket-Accept</source>
          <target state="translated">RFC 6455, section 11.3.3: Sec-WebSocket-Accept</target>
        </trans-unit>
        <trans-unit id="19d36fc539eae3719343f4e94df0ac87431a15c5" translate="yes" xml:space="preserve">
          <source>RFC 6585</source>
          <target state="translated">RFC 6585</target>
        </trans-unit>
        <trans-unit id="45d634e5b12466ed4cc193d856d4e4c08256a283" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 3: 428 Precondition Required</source>
          <target state="translated">RFC 6585, 섹션 3 : 428 사전 요구 사항</target>
        </trans-unit>
        <trans-unit id="07a86b3bb5912601c3ae8de2ec856a047e1a4207" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 4: 429 Too Many Requests</source>
          <target state="translated">RFC 6585, 섹션 4 : 429 너무 많은 요청</target>
        </trans-unit>
        <trans-unit id="bae288b759aab289a7b722340a6c68ada2a24664" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 5: 431 Request Header Fields Too Large</source>
          <target state="translated">RFC 6585, 섹션 5 : 431 요청 헤더 필드가 너무 큼</target>
        </trans-unit>
        <trans-unit id="f0550ad6cfb7431d8de64660db24e5adfdd0f1cd" translate="yes" xml:space="preserve">
          <source>RFC 6585, section 6: 511 Network Authentication Required</source>
          <target state="translated">RFC 6585, 섹션 6 : 511 네트워크 인증 필요</target>
        </trans-unit>
        <trans-unit id="f59f441f51a2a15aab903870156075198c21cdcd" translate="yes" xml:space="preserve">
          <source>RFC 6797</source>
          <target state="translated">RFC 6797</target>
        </trans-unit>
        <trans-unit id="0f65e4b9ea5170ccf77ae139b024de2922225370" translate="yes" xml:space="preserve">
          <source>RFC 7034</source>
          <target state="translated">RFC 7034</target>
        </trans-unit>
        <trans-unit id="6b67e7dae86a60ad1a1b1df8824dc9553710faf9" translate="yes" xml:space="preserve">
          <source>RFC 7168</source>
          <target state="translated">RFC 7168</target>
        </trans-unit>
        <trans-unit id="5462ffa212ed4302d0699e27c71e7418400fa7ad" translate="yes" xml:space="preserve">
          <source>RFC 7168, section 2.3.3: 418 I'm a teapot</source>
          <target state="translated">RFC 7168, section 2.3.3: 418 I'm a teapot</target>
        </trans-unit>
        <trans-unit id="0c5e351b2c4935f263fb4a48d2a5973b96f162c0" translate="yes" xml:space="preserve">
          <source>RFC 7230</source>
          <target state="translated">RFC 7230</target>
        </trans-unit>
        <trans-unit id="05085ef8bae59f857a83a325ca8b5cb7c95f7a86" translate="yes" xml:space="preserve">
          <source>RFC 7230, appendix A.1.2: Keep-Alive</source>
          <target state="translated">RFC 7230, 부록 A.1.2 : 연결 유지</target>
        </trans-unit>
        <trans-unit id="0e5d3d164e7dba93b9411bbfb503f35bd97bc36f" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 2.7: Uniform Resource Identifiers</source>
          <target state="translated">RFC 7230, 섹션 2.7 : 균일 자원 식별자</target>
        </trans-unit>
        <trans-unit id="747d53c19ff7b93c55d4b76ad86eb7700475d3b8" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 3.3.1: Transfer-Encoding</source>
          <target state="translated">RFC 7230, 섹션 3.3.1 : 전송 인코딩</target>
        </trans-unit>
        <trans-unit id="f0a41fabfd014b8b41ea52076f5ba499d7cab7cc" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 3.3.2: Content-Length</source>
          <target state="translated">RFC 7230, 섹션 3.3.2 : 내용 길이</target>
        </trans-unit>
        <trans-unit id="ce15bb0ced28e642094a4b2e10552a5a260c63c6" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.1.2: Chunked trailer part</source>
          <target state="translated">RFC 7230, 섹션 4.1.2 : 청크 트레일러 부품</target>
        </trans-unit>
        <trans-unit id="dc4a36d13fa8deb7e75049f8717535024790d01d" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.3: TE</source>
          <target state="translated">RFC 7230, 섹션 4.3 : TE</target>
        </trans-unit>
        <trans-unit id="d01fd56ebeb831ef7c0ec347cc56581ef2c37a02" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 4.4: Trailer</source>
          <target state="translated">RFC 7230, 섹션 4.4 : 트레일러</target>
        </trans-unit>
        <trans-unit id="ce720dca2d38fd8ebd182748949f09c36140d1ba" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 5.4: Host</source>
          <target state="translated">RFC 7230, 섹션 5.4 : 호스트</target>
        </trans-unit>
        <trans-unit id="72b7097053626ce619fadddb8fd07f185dcb00c0" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 5.7.1: Via</source>
          <target state="translated">RFC 7230, 섹션 5.7.1 : Via</target>
        </trans-unit>
        <trans-unit id="6af44b0343855669c9965f60f9b7a95a881d8e6d" translate="yes" xml:space="preserve">
          <source>RFC 7230, section 6.7: Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</source>
          <target state="translated">RFC 7230, 섹션 6.7 : 하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅</target>
        </trans-unit>
        <trans-unit id="ce9e01aff0adf150803198bb232477284f281a17" translate="yes" xml:space="preserve">
          <source>RFC 7230: Message Syntax and Routing</source>
          <target state="translated">RFC 7230 : 메시지 구문 및 라우팅</target>
        </trans-unit>
        <trans-unit id="caea547a0cf9d64aba6043b091dc5eb22f58c313" translate="yes" xml:space="preserve">
          <source>RFC 7231</source>
          <target state="translated">RFC 7231</target>
        </trans-unit>
        <trans-unit id="08e4bb7d474ebf9b4dd37dbb5dfb6ad9f1018a66" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.1.5: Content-Type</source>
          <target state="translated">RFC 7231, 섹션 3.1.1.5 : 내용 유형</target>
        </trans-unit>
        <trans-unit id="845eed76936a3d924d01b333e9f1eb88f65e9b0f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.2.2: Content-Encoding</source>
          <target state="translated">RFC 7231, 섹션 3.1.2.2 : 내용 인코딩</target>
        </trans-unit>
        <trans-unit id="ea53991de97033c504914c78c87f5ffed390f149" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.3.2: Content-Language</source>
          <target state="translated">RFC 7231, 섹션 3.1.3.2 : 내용 언어</target>
        </trans-unit>
        <trans-unit id="c63e7fc6e081defb92fe9ecf5164796bcbd6a746" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 3.1.4.2: Content-Location</source>
          <target state="translated">RFC 7231, 섹션 3.1.4.2 : 컨텐츠 위치</target>
        </trans-unit>
        <trans-unit id="d4fb8e8cb57094e1102d5ce3bdd8cff5312ab200" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.1: GET</source>
          <target state="translated">RFC 7231, 섹션 4.3.1 : GET</target>
        </trans-unit>
        <trans-unit id="beb916c6c25dc7649f8c49842ab7dcda780a0246" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.2: HEAD</source>
          <target state="translated">RFC 7231, 섹션 4.3.2 : HEAD</target>
        </trans-unit>
        <trans-unit id="396a77b857e79049fe6031ef49d21a0effb58e9a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.3: POST</source>
          <target state="translated">RFC 7231, 섹션 4.3.3 : POST</target>
        </trans-unit>
        <trans-unit id="be438af5d1a292f596f21a801b7d9603f1cab40b" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.4: PUT</source>
          <target state="translated">RFC 7231, 섹션 4.3.4 : PUT</target>
        </trans-unit>
        <trans-unit id="f107039cbadc5f826dae91dd218c725e9d18d841" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.5: DELETE</source>
          <target state="translated">RFC 7231, 섹션 4.3.5 : 삭제</target>
        </trans-unit>
        <trans-unit id="1dc7248ccd888336bd82b884b087f4b3f4f4679d" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.6: CONNECT</source>
          <target state="translated">RFC 7231, 섹션 4.3.6 : 연결</target>
        </trans-unit>
        <trans-unit id="5ef875b188d1b54f345842c090e95ae722453dbd" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.7: OPTIONS</source>
          <target state="translated">RFC 7231, 섹션 4.3.7 : 옵션</target>
        </trans-unit>
        <trans-unit id="332f9c31f0f5c275ad307d53cca2499a9459de39" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4.3.8: TRACE</source>
          <target state="translated">RFC 7231, 섹션 4.3.8 : TRACE</target>
        </trans-unit>
        <trans-unit id="23ec2e6bb03069a7e2356906fa0861e5c5f31298" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 4: Request methods</source>
          <target state="translated">RFC 7231, 섹션 4 : 요청 방법</target>
        </trans-unit>
        <trans-unit id="ca01a74d4319434dec806f81b435f5ef7fe00cac" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.1.1: Expect</source>
          <target state="translated">RFC 7231, 섹션 5.1.1 : 예상</target>
        </trans-unit>
        <trans-unit id="482924da4508aa7f733bf03dc780a68aae52445c" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.2: Accept</source>
          <target state="translated">RFC 7231, 섹션 5.3.2 : 수락</target>
        </trans-unit>
        <trans-unit id="35accde19d283e519f8ec1ed2362fcc85f24a93d" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.3: Accept-Charset</source>
          <target state="translated">RFC 7231, 섹션 5.3.3 : 수락 문자</target>
        </trans-unit>
        <trans-unit id="ad6e29ab51fd42d62fbcdb472acfb4ac84a2a268" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.4: Accept-Encoding</source>
          <target state="translated">RFC 7231, 섹션 5.3.4 : 수락 인코딩</target>
        </trans-unit>
        <trans-unit id="807a7c74e7037b7f5abd66cfb4a79ff6ae43d3b7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.3.5: Accept-Language</source>
          <target state="translated">RFC 7231, 섹션 5.3.5 : 수락 언어</target>
        </trans-unit>
        <trans-unit id="e193dba38f7e55035b47ef2c109569e16479cf69" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.1: From</source>
          <target state="translated">RFC 7231, 섹션 5.5.1 : 시작</target>
        </trans-unit>
        <trans-unit id="b509df34815d389002b3401e3af6b97ec17a4637" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.2: Referer</source>
          <target state="translated">RFC 7231, 섹션 5.5.2 : 참조 자</target>
        </trans-unit>
        <trans-unit id="1741ea24040d407102645a5261e3be49a42c9d36" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 5.5.3: User-Agent</source>
          <target state="translated">RFC 7231, 섹션 5.5.3 : User-Agent</target>
        </trans-unit>
        <trans-unit id="12fc41e4605afa8a835cf818819d37d8835a9501" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.2.1: 100 Continue</source>
          <target state="translated">RFC 7231, 섹션 6.2.1 : 100 계속</target>
        </trans-unit>
        <trans-unit id="6153c15954bc862a70895fbc431bad2da954c971" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.2.2: 101 Switching Protocol</source>
          <target state="translated">RFC 7231, 섹션 6.2.2 : 101 스위칭 프로토콜</target>
        </trans-unit>
        <trans-unit id="bbfde0e52731d4e9dc93932249da61bebf73a1a8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.1: 200 OK</source>
          <target state="translated">RFC 7231, 섹션 6.3.1 : 200 OK</target>
        </trans-unit>
        <trans-unit id="1fc7e03406eaa40d727064f1b1bc3e08b2b14fd4" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.2: 201 Created</source>
          <target state="translated">RFC 7231, 섹션 6.3.2 : 201 생성됨</target>
        </trans-unit>
        <trans-unit id="c97971bcf5eac84ad103104d1e5f58bc875207a1" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.3: 202 Accepted</source>
          <target state="translated">RFC 7231, 섹션 6.3.3 : 202 허용</target>
        </trans-unit>
        <trans-unit id="5429f5aaa896873c3bed767ca81e26df2c7d4715" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.4: 203 Non-Authoritative Information</source>
          <target state="translated">RFC 7231, 섹션 6.3.4 : 203 신뢰할 수없는 정보</target>
        </trans-unit>
        <trans-unit id="c87d7f32f1d541fc3b4a3f52e5b74b91132ee59a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.5: 204 No Content</source>
          <target state="translated">RFC 7231, 섹션 6.3.5 : 204 내용 없음</target>
        </trans-unit>
        <trans-unit id="88a53ddfea1c8ca509da6b5a44b1c7abe59a44fd" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.3.6: 205 Reset Content</source>
          <target state="translated">RFC 7231, 섹션 6.3.6 : 205 내용 재설정</target>
        </trans-unit>
        <trans-unit id="4ccda537000db21782a1059815056fc5839e13c3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.1: 300 Multiple Choices</source>
          <target state="translated">RFC 7231, 섹션 6.4.1 : 300 객관식</target>
        </trans-unit>
        <trans-unit id="dceac5b474240f3b0b90d94b9503bf6ba6db86b0" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.2: 301 Moved Permanently</source>
          <target state="translated">RFC 7231, section 6.4.2: 301 Moved Permanently</target>
        </trans-unit>
        <trans-unit id="8d103f2e9ff04ca2a770ac0401e07c62e79f89aa" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.2: 301 Redirect Permanently</source>
          <target state="translated">RFC 7231, 섹션 6.4.2 : 301 영구적으로 리디렉션</target>
        </trans-unit>
        <trans-unit id="80c5d21b755a5e2b263018667896cddc904c5323" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.3: 302 Found</source>
          <target state="translated">RFC 7231, 섹션 6.4.3 : 302 발견</target>
        </trans-unit>
        <trans-unit id="23d636dfadbfc167109f5734f6597b0cef5487e5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.4: 303 See Other</source>
          <target state="translated">RFC 7231, 섹션 6.4.4 : 303 기타 참조</target>
        </trans-unit>
        <trans-unit id="e5ee708c3ca4bdea3c8e87cba0d3aeae2df304a8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.4.7: 307 Temporary Redirect</source>
          <target state="translated">RFC 7231, 섹션 6.4.7 : 307 임시 리디렉션</target>
        </trans-unit>
        <trans-unit id="dee8c16141db46bb418511c175d2eec007fefeed" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.10: 411 Length Required</source>
          <target state="translated">RFC 7231, 섹션 6.5.10 : 411 길이 필요</target>
        </trans-unit>
        <trans-unit id="26171f5c8cb59ffc020457ea938b7ec236d9ea28" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.11: 413 Payload Too Large</source>
          <target state="translated">RFC 7231, 섹션 6.5.11 : 413 페이로드가 너무 큼</target>
        </trans-unit>
        <trans-unit id="cee9c7a8574968783fae740117c4c07af062c5f8" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.12: 414 URI Too Long</source>
          <target state="translated">RFC 7231, 섹션 6.5.12 : 414 URI가 너무 깁니다</target>
        </trans-unit>
        <trans-unit id="58c6fc79debfdeea6e272e99df4c1743e620d756" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.13: 415 Unsupported Media Type</source>
          <target state="translated">RFC 7231, 섹션 6.5.13 : 415 지원되지 않는 미디어 유형</target>
        </trans-unit>
        <trans-unit id="0392d0e21a03c252a2bf41dd4d443c3d6b9104c7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.14: 417 Expectation Failed</source>
          <target state="translated">RFC 7231, 섹션 6.5.14 : 417 예상 실패</target>
        </trans-unit>
        <trans-unit id="57441c8550e44a304af1a569e4e597ea1887e91a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.15: 426 Upgrade Required</source>
          <target state="translated">RFC 7231, 섹션 6.5.15 : 426 업그레이드 필요</target>
        </trans-unit>
        <trans-unit id="6dd8faeaf11eb0bd52552958e7ae54b11b10b57f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.1: 400 Bad Request</source>
          <target state="translated">RFC 7231, 섹션 6.5.1 : 400 잘못된 요청</target>
        </trans-unit>
        <trans-unit id="28e32b785f14077ddbbb66712ef46215efa083a7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.2: 402 Payment Required</source>
          <target state="translated">RFC 7231, 섹션 6.5.2 : 402 결제 필요</target>
        </trans-unit>
        <trans-unit id="e163a78f9330d6741a5bd6e7cdbb8e3fec5ffe5f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.3: 403 Forbidden</source>
          <target state="translated">RFC 7231, 섹션 6.5.3 : 403 금지</target>
        </trans-unit>
        <trans-unit id="b6bc1661f3cf5de1c14ac6be35b1910851cacaaf" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.4: 404 Not Found</source>
          <target state="translated">RFC 7231, 섹션 6.5.4 : 404를 찾을 수 없음</target>
        </trans-unit>
        <trans-unit id="a9844f8c14db25ad38c4cfe8d0f0b736510c9fb5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.5: 405 Method Not Allowed</source>
          <target state="translated">RFC 7231, 섹션 6.5.5 : 405 방법이 허용되지 않습니다</target>
        </trans-unit>
        <trans-unit id="fc4efdb5f2dc5dc6d424604880e980cb82e94103" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.6: 406 Not Acceptable</source>
          <target state="translated">RFC 7231, 섹션 6.5.6 : 406 허용되지 않음</target>
        </trans-unit>
        <trans-unit id="43b35d1f584a1c0099592c15ae91827db7dc94b7" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.7: 408 Request Timeout</source>
          <target state="translated">RFC 7231, 섹션 6.5.7 : 408 요청 시간 초과</target>
        </trans-unit>
        <trans-unit id="1b0d3945f363c33827abe747256729c99c9037c6" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.8: 409 Conflict</source>
          <target state="translated">RFC 7231, 섹션 6.5.8 : 409 충돌</target>
        </trans-unit>
        <trans-unit id="fd998823588377f38984c686c556f3bcfc09dc66" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.5.9: 410 Gone</source>
          <target state="translated">RFC 7231, 섹션 6.5.9 : 410 사라짐</target>
        </trans-unit>
        <trans-unit id="e020731d0df0b23d948c30ebaf118d17f15bafb5" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.1: 500 Internal Server Error</source>
          <target state="translated">RFC 7231, 섹션 6.6.1 : 500 내부 서버 오류</target>
        </trans-unit>
        <trans-unit id="0123b7de98a247141787a487b5e238ce6e98a7c2" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.2: 501 Not Implemented</source>
          <target state="translated">RFC 7231, 섹션 6.6.2 : 501은 구현되지 않음</target>
        </trans-unit>
        <trans-unit id="d8ade00b1145627ea23139c44dc6c9c4c9e6e5b1" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.3: 502 Bad Gateway</source>
          <target state="translated">RFC 7231, 섹션 6.6.3 : 502 잘못된 게이트웨이</target>
        </trans-unit>
        <trans-unit id="beb22556b06eef638a44ed63d5c6ad4adb9b6b33" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.4: 503 Service Unavailable</source>
          <target state="translated">RFC 7231, 섹션 6.6.4 : 503 서비스를 사용할 수 없음</target>
        </trans-unit>
        <trans-unit id="f08bdf6a75d66bf8a9bbf1045e44b8379123db51" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.4: 504 Gateway Timeout</source>
          <target state="translated">RFC 7231, 섹션 6.6.4 : 504 게이트웨이 시간 초과</target>
        </trans-unit>
        <trans-unit id="4cbd04babc221aadbb70a08f8f6b0cb23a89f952" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.5: 504 Gateway Timeout</source>
          <target state="translated">RFC 7231, section 6.6.5: 504 Gateway Timeout</target>
        </trans-unit>
        <trans-unit id="3e6e09aea7bfdaaf0dd1e985137eee45520431d3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 6.6.6: 505 HTTP Version Not Supported</source>
          <target state="translated">RFC 7231, 섹션 6.6.6 : 505 HTTP 버전이 지원되지 않습니다</target>
        </trans-unit>
        <trans-unit id="b3ba7c2a99f80e2130967ae0193aa90dfc01cbe3" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.1.2: Date</source>
          <target state="translated">RFC 7231, 섹션 7.1.1.2 : 날짜</target>
        </trans-unit>
        <trans-unit id="4cd70f93c86793f098a850ee9a15dfed514d641f" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.2: Location</source>
          <target state="translated">RFC 7231, 섹션 7.1.2 : 위치</target>
        </trans-unit>
        <trans-unit id="b605ee3c8c03aa07e4aba2513a66cca3bddaa02a" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.3: Retry-After</source>
          <target state="translated">RFC 7231, 섹션 7.1.3 : 재시도 후</target>
        </trans-unit>
        <trans-unit id="453d48122df892243f46b4738824f126f915dd76" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.1.4: Vary</source>
          <target state="translated">RFC 7231, 섹션 7.1.4 : 가변</target>
        </trans-unit>
        <trans-unit id="7db55929216f08581bb0f9a961b79184aed41a16" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.4.1: Allow</source>
          <target state="translated">RFC 7231, 섹션 7.4.1 : 허용</target>
        </trans-unit>
        <trans-unit id="9acad768df0dbe6c37cba16cbfd5595d6bc92ab0" translate="yes" xml:space="preserve">
          <source>RFC 7231, section 7.4.2: Server</source>
          <target state="translated">RFC 7231, 섹션 7.4.2 : 서버</target>
        </trans-unit>
        <trans-unit id="c13136120d6f8f6ddbce80914e170e5f5ba98e4e" translate="yes" xml:space="preserve">
          <source>RFC 7231: Semantics and Content</source>
          <target state="translated">RFC 7231 : 의미 및 내용</target>
        </trans-unit>
        <trans-unit id="a63def99ce2877d2732ea2cc7396d5f537db97a4" translate="yes" xml:space="preserve">
          <source>RFC 7232</source>
          <target state="translated">RFC 7232</target>
        </trans-unit>
        <trans-unit id="295d565b0fec0216825a3e8cb65a1446aa3ed8b2" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 2.2: Last-Modified</source>
          <target state="translated">RFC 7232, 섹션 2.2 : 마지막 수정</target>
        </trans-unit>
        <trans-unit id="e2e4bc35caa4058f5fac16569cf63c21cb420386" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 2.3: ETag</source>
          <target state="translated">RFC 7232, 섹션 2.3 : ETag</target>
        </trans-unit>
        <trans-unit id="9bcc0918bdc69773f66aa681a671407cbdd4b5bb" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.1: If-Match</source>
          <target state="translated">RFC 7232, 섹션 3.1 : 일치하는 경우</target>
        </trans-unit>
        <trans-unit id="73bd2578dcbed6d7d7505e11efb11c61cda96b36" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.2: If-None-Match</source>
          <target state="translated">RFC 7232, 섹션 3.2 : 일치하지 않는 경우</target>
        </trans-unit>
        <trans-unit id="d0cfec8ff7070bfbde6decdb05c41ab3d5b5e60d" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.3: If-Modified-Since</source>
          <target state="translated">RFC 7232, 섹션 3.3 : If-Modified-Since</target>
        </trans-unit>
        <trans-unit id="83ababad8d137088ebfa02c4cfad17ffdbaa6cb9" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 3.4: If-Unmodified-Since</source>
          <target state="translated">RFC 7232, 섹션 3.4 : 수정되지 않은 경우</target>
        </trans-unit>
        <trans-unit id="8c6b803aef1ae0cbc7963494f52a6e2d1221aa72" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 4.1: 304 Not Modified</source>
          <target state="translated">RFC 7232, 섹션 4.1 : 304 수정되지 않음</target>
        </trans-unit>
        <trans-unit id="c6371edfa3fd6545f1ed9b50760abaa5432d23c6" translate="yes" xml:space="preserve">
          <source>RFC 7232, section 4.2: 412 Precondition Failed</source>
          <target state="translated">RFC 7232, 섹션 4.2 : 412 사전 조건 실패</target>
        </trans-unit>
        <trans-unit id="85fcffc8931e515561355807b30267e41fd6036c" translate="yes" xml:space="preserve">
          <source>RFC 7232: Conditional Requests</source>
          <target state="translated">RFC 7232 : 조건부 요청</target>
        </trans-unit>
        <trans-unit id="0220cee7fbe573d22b712a263403a869c71ee9dd" translate="yes" xml:space="preserve">
          <source>RFC 7233</source>
          <target state="translated">RFC 7233</target>
        </trans-unit>
        <trans-unit id="24b52ae865d6573f42daca9e9ba3d5d371687dd9" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 2.3: Accept-Ranges</source>
          <target state="translated">RFC 7233, 섹션 2.3 : 수락 범위</target>
        </trans-unit>
        <trans-unit id="217e0bf69b2117ab58b4e0362c97f19fa1befd75" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 3.1: Range</source>
          <target state="translated">RFC 7233, 섹션 3.1 : 범위</target>
        </trans-unit>
        <trans-unit id="60ffdc5927f45232551eeaf6f5b683a4c7108395" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 3.2: If-Range</source>
          <target state="translated">RFC 7233, 섹션 3.2 : 범위</target>
        </trans-unit>
        <trans-unit id="60f87acc5e83708a238fe44d6d995662a04d25cb" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.1: 206 Partial Content</source>
          <target state="translated">RFC 7233, 섹션 4.1 : 206 부분 내용</target>
        </trans-unit>
        <trans-unit id="c97dc325c5a2c56a80141bafdec4776ec6494289" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.1: Content-Type in multipart</source>
          <target state="translated">RFC 7233, 섹션 4.1 : 멀티 파트의 컨텐츠 유형</target>
        </trans-unit>
        <trans-unit id="b2f0b42f9b254f4e75cc959dec9a41424191299d" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.2: Content-Range</source>
          <target state="translated">RFC 7233, 섹션 4.2 : 내용 범위</target>
        </trans-unit>
        <trans-unit id="17ab846647e11ad24dd7cae43b5b7ba50f8d5783" translate="yes" xml:space="preserve">
          <source>RFC 7233, section 4.4: 416 Request Not Satisfiable</source>
          <target state="translated">RFC 7233, 섹션 4.4 : 416 요청이 만족스럽지 않음</target>
        </trans-unit>
        <trans-unit id="39280b50b8604fb2c52645b83bb68d63d5aea084" translate="yes" xml:space="preserve">
          <source>RFC 7233: Range Requests</source>
          <target state="translated">RFC 7233 : 범위 요청</target>
        </trans-unit>
        <trans-unit id="d73ca14480035f6afc269fff0b2cbd5e7a9d5226" translate="yes" xml:space="preserve">
          <source>RFC 7234</source>
          <target state="translated">RFC 7234</target>
        </trans-unit>
        <trans-unit id="b7b8fb4415d92cc12caa06d3116834044fd58735" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.1: Age</source>
          <target state="translated">RFC 7234, 섹션 5.1 : 연령</target>
        </trans-unit>
        <trans-unit id="8f0ec2babea29f2d75d8b6c1eeefe35f6783a262" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.3: Expires</source>
          <target state="translated">RFC 7234, 섹션 5.3 : 만료</target>
        </trans-unit>
        <trans-unit id="b61069d359f94e29544f46f37732668c2e0dc488" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.4: Pragma</source>
          <target state="translated">RFC 7234, 섹션 5.4 : Pragma</target>
        </trans-unit>
        <trans-unit id="e5b281777a588dfebb9e4f33147f9393c44ff9d5" translate="yes" xml:space="preserve">
          <source>RFC 7234, section 5.5: Warning</source>
          <target state="translated">RFC 7234, 섹션 5.5 : 경고</target>
        </trans-unit>
        <trans-unit id="15c277735dd7ab9d554b55649227872a7a319b2e" translate="yes" xml:space="preserve">
          <source>RFC 7234: Caching</source>
          <target state="translated">RFC 7234 : 캐싱</target>
        </trans-unit>
        <trans-unit id="95e2fdb4338d98c3460a6ba511c8317ede846646" translate="yes" xml:space="preserve">
          <source>RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): Caching</source>
          <target state="translated">RFC 7234 : 하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱</target>
        </trans-unit>
        <trans-unit id="7f05efb06e3e1509abf29d93ad4e47416b9ccc82" translate="yes" xml:space="preserve">
          <source>RFC 7235</source>
          <target state="translated">RFC 7235</target>
        </trans-unit>
        <trans-unit id="11160b7b94c66c72e517d2361647cbfe55fa56cb" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 3.1: 401 Unauthorized</source>
          <target state="translated">RFC 7235, 섹션 3.1 : 401 무단</target>
        </trans-unit>
        <trans-unit id="8d8532df2f09e49337c4c44dc682d4d79601e9b4" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 3.2: 407 Proxy Authentication Required</source>
          <target state="translated">RFC 7235, 섹션 3.2 : 407 프록시 인증 필요</target>
        </trans-unit>
        <trans-unit id="614dc9841e719e4ac1a80ff45d19cd0f0c9471e6" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.1: WWW-Authenticate</source>
          <target state="translated">RFC 7235, 섹션 4.1 : WWW 인증</target>
        </trans-unit>
        <trans-unit id="a2b8a63336dfcfbb148fd489dd97af9d7523c4c5" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.2: Authorization</source>
          <target state="translated">RFC 7235, 섹션 4.2 : 인증</target>
        </trans-unit>
        <trans-unit id="ad222d9356ff1738b54e88377024fa368f6aa997" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.3: Proxy-Authenticate</source>
          <target state="translated">RFC 7235, 섹션 4.3 : 프록시 인증</target>
        </trans-unit>
        <trans-unit id="ce095e11e9ac5123f50e10205d7a968f6a419fbd" translate="yes" xml:space="preserve">
          <source>RFC 7235, section 4.4: Proxy-Authorization</source>
          <target state="translated">RFC 7235, 섹션 4.4 : 프록시 인증</target>
        </trans-unit>
        <trans-unit id="92acef83d821fd2467bc28bd2fd60d10ec1c7cc9" translate="yes" xml:space="preserve">
          <source>RFC 7235: Authentication</source>
          <target state="translated">RFC 7235 : 인증</target>
        </trans-unit>
        <trans-unit id="39253ac4ebddd236a15a85088849c6a80583c2fe" translate="yes" xml:space="preserve">
          <source>RFC 7239</source>
          <target state="translated">RFC 7239</target>
        </trans-unit>
        <trans-unit id="6123756e88cf4a45823e0759687abb9c00f566cc" translate="yes" xml:space="preserve">
          <source>RFC 7239, section 4: Forwarded</source>
          <target state="translated">RFC 7239, 섹션 4 : 전달</target>
        </trans-unit>
        <trans-unit id="2513b2cc7a8731819cb7304e73f8bd0c92970573" translate="yes" xml:space="preserve">
          <source>RFC 7301</source>
          <target state="translated">RFC 7301</target>
        </trans-unit>
        <trans-unit id="e53ba536932ce8bea18cc606f0e1b867a58004cf" translate="yes" xml:space="preserve">
          <source>RFC 7469, section 2.1: Public-Key-Pins</source>
          <target state="translated">RFC 7469, 섹션 2.1 : 공개 키 핀</target>
        </trans-unit>
        <trans-unit id="f73866d0b27647fd51170d239bc52eb95cc3fa80" translate="yes" xml:space="preserve">
          <source>RFC 7469, section 2.1: Public-Key-Pins-Report-Only</source>
          <target state="translated">RFC 7469, 섹션 2.1 : 공개 키 핀 보고서 만</target>
        </trans-unit>
        <trans-unit id="7d33083b52d3c2f5c0c6e4555c83f4c7a93666d3" translate="yes" xml:space="preserve">
          <source>RFC 7538</source>
          <target state="translated">RFC 7538</target>
        </trans-unit>
        <trans-unit id="c18f1a9e84a66e50185533b4e1d6c5b801e53f75" translate="yes" xml:space="preserve">
          <source>RFC 7538, section 3: 308 Permanent Redirect</source>
          <target state="translated">RFC 7538, 섹션 3 : 308 영구 리디렉션</target>
        </trans-unit>
        <trans-unit id="381a51e0e8724bb0e7528dce36a046520ef83310" translate="yes" xml:space="preserve">
          <source>RFC 7540</source>
          <target state="translated">RFC 7540</target>
        </trans-unit>
        <trans-unit id="4aeb609c2d110cec6d9e060bbde5c811d3343002" translate="yes" xml:space="preserve">
          <source>RFC 7540, section 8.1.1: Hypertext Transfer Protocol Version 2 (HTTP/2)</source>
          <target state="translated">RFC 7540, 섹션 8.1.1 : 하이퍼 텍스트 전송 프로토콜 버전 2 (HTTP / 2)</target>
        </trans-unit>
        <trans-unit id="52f90fdebc595d706e0153547db03d37bcb956f4" translate="yes" xml:space="preserve">
          <source>RFC 7541</source>
          <target state="translated">RFC 7541</target>
        </trans-unit>
        <trans-unit id="16fe2f0e9c1d829ee3481e9a51d563391aac14b0" translate="yes" xml:space="preserve">
          <source>RFC 7578</source>
          <target state="translated">RFC 7578</target>
        </trans-unit>
        <trans-unit id="60d6f8ab48b07523a864373ca4d1105c601e0a56" translate="yes" xml:space="preserve">
          <source>RFC 7617</source>
          <target state="translated">RFC 7617</target>
        </trans-unit>
        <trans-unit id="16bb582fedfa8c1bed21cfd9a33eb35b67ce48ef" translate="yes" xml:space="preserve">
          <source>RFC 7725</source>
          <target state="translated">RFC 7725</target>
        </trans-unit>
        <trans-unit id="b3c12a54619425f8c7eeee0564e7f9c3445ee5e2" translate="yes" xml:space="preserve">
          <source>RFC 7725: 451 Unavailable For Legal Reasons</source>
          <target state="translated">RFC 7725 : 법적 사유로 451을 사용할 수 없음</target>
        </trans-unit>
        <trans-unit id="4c3ce0e7d6d5e6d33d64ba958f7a104cfc60ffd0" translate="yes" xml:space="preserve">
          <source>RFC 7838</source>
          <target state="translated">RFC 7838</target>
        </trans-unit>
        <trans-unit id="98a96516560a300a5745bcfe44d56d86a7703616" translate="yes" xml:space="preserve">
          <source>RFC 7932: Brotli Compressed Data Format</source>
          <target state="translated">RFC 7932 : Brotli 압축 데이터 형식</target>
        </trans-unit>
        <trans-unit id="72d8ba28c60c4ceca4316e723297a3f77d3efdaa" translate="yes" xml:space="preserve">
          <source>RFC 8246</source>
          <target state="translated">RFC 8246</target>
        </trans-unit>
        <trans-unit id="a45497157d8a3432246f536cdef9b1f416a32287" translate="yes" xml:space="preserve">
          <source>RFC 8246: HTTP Immutable Responses</source>
          <target state="translated">RFC 8246: HTTP Immutable Responses</target>
        </trans-unit>
        <trans-unit id="401eb590c3b548c5aa4c4e481ee30a9c208bb6f9" translate="yes" xml:space="preserve">
          <source>RFC 8288, section 3: Link Serialisation in HTTP Headers</source>
          <target state="translated">RFC 8288, 섹션 3 : HTTP 헤더의 링크 직렬화</target>
        </trans-unit>
        <trans-unit id="aebd99a62119b7004c00c10592e92856f9b2b015" translate="yes" xml:space="preserve">
          <source>RFC 8297: 103 Early Hints</source>
          <target state="translated">RFC 8297 : 103 초기 힌트</target>
        </trans-unit>
        <trans-unit id="c259030985e8f0cd03404af04d74d18e09f0c5c5" translate="yes" xml:space="preserve">
          <source>RFC 8446</source>
          <target state="translated">RFC 8446</target>
        </trans-unit>
        <trans-unit id="f103f5fd279c09f20f0c5ca89184d4caecaccd28" translate="yes" xml:space="preserve">
          <source>RFC 8470, section 5.1: The Early-Data Header Field</source>
          <target state="translated">RFC 8470, 섹션 5.1 : 초기 데이터 헤더 필드</target>
        </trans-unit>
        <trans-unit id="a0eebba627153a93ef3a322033c309ca579202f0" translate="yes" xml:space="preserve">
          <source>RFC 8470, section 5.2: 425: Early Data</source>
          <target state="translated">RFC 8470, 섹션 5.2 : 425 : 초기 데이터</target>
        </trans-unit>
        <trans-unit id="a16c5bbe4bf996740f257aa1e81bd57e4c52c8dd" translate="yes" xml:space="preserve">
          <source>Range</source>
          <target state="translated">Range</target>
        </trans-unit>
        <trans-unit id="9b88ba0fe4aa1b0d39f03df49c05115f581fef09" translate="yes" xml:space="preserve">
          <source>Range (RFC 2616)</source>
          <target state="translated">범위 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="5039997fc0613071590aceb1ddcbf09f19902112" translate="yes" xml:space="preserve">
          <source>Range (RFC 7233)</source>
          <target state="translated">범위 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="75e5476d2fa33e515b99ac682187fa29b2de5aea" translate="yes" xml:space="preserve">
          <source>Range requests</source>
          <target state="translated">범위 요청</target>
        </trans-unit>
        <trans-unit id="cbd19be28e80eee61c6befb6a6a0e0189a81e54b" translate="yes" xml:space="preserve">
          <source>Range units are intended to be extensible.  New range units ought to
   be registered with IANA, as defined in &lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;.

     other-range-unit = token</source>
          <target state="translated">범위 단위는 확장 가능하도록 고안되었습니다. &lt;a href=&quot;#section-5.1&quot;&gt;5.1 장에&lt;/a&gt; 정의 된대로 새로운 범위 단위는 IANA에 등록해야합니다 . other-range-unit = 토큰</target>
        </trans-unit>
        <trans-unit id="10022056ab083091adb5d812601237d60a879215" translate="yes" xml:space="preserve">
          <source>Read the response sent by the server, such as:</source>
          <target state="translated">Read the response sent by the server, such as:</target>
        </trans-unit>
        <trans-unit id="ed40b9d6cc0d0cb3ce7a7ad02dba7338812a8080" translate="yes" xml:space="preserve">
          <source>Read the response sent by the server:</source>
          <target state="translated">서버가 보낸 응답을 읽으십시오.</target>
        </trans-unit>
        <trans-unit id="7877f60e00a2d773f57c4014d0a738ad9861667e" translate="yes" xml:space="preserve">
          <source>Reading Do Not Track status from JavaScript</source>
          <target state="translated">JavaScript에서 상태를 추적하지 않음 읽기</target>
        </trans-unit>
        <trans-unit id="f219cc0614ae6860f43a3cd84b5cf31fc312cd9d" translate="yes" xml:space="preserve">
          <source>Reason</source>
          <target state="translated">Reason</target>
        </trans-unit>
        <trans-unit id="ed3274e667a68705864a7876442c08c9a0c89279" translate="yes" xml:space="preserve">
          <source>Reason: CORS disabled</source>
          <target state="translated">이유 : CORS 비활성화</target>
        </trans-unit>
        <trans-unit id="f5163ddcca584feb16b95fbbfa91c4d7d0260331" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; does not match &amp;lsquo;xyz&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Origin'이 'xyz'와 일치하지 않습니다</target>
        </trans-unit>
        <trans-unit id="5bdd6c0c5118a6b13076b0be624dd329902e18ef" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; missing</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Origin'이 없습니다.</target>
        </trans-unit>
        <trans-unit id="1658865d36eb134fe7d46709a144c1d565865930" translate="yes" xml:space="preserve">
          <source>Reason: CORS header &amp;lsquo;Origin&amp;rsquo; cannot be added</source>
          <target state="translated">이유 : CORS 헤더 'Origin'을 추가 할 수 없습니다</target>
        </trans-unit>
        <trans-unit id="aef82a650f94d9766311469581926f1ed57a82f8" translate="yes" xml:space="preserve">
          <source>Reason: CORS preflight channel did not succeed</source>
          <target state="translated">이유 : CORS 프리 플라이트 채널이 성공하지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="07e1781531cc98f0e96de22d1192b8d4d3333825" translate="yes" xml:space="preserve">
          <source>Reason: CORS request did not succeed</source>
          <target state="translated">이유 : CORS 요청이 실패했습니다</target>
        </trans-unit>
        <trans-unit id="09c9cb183a85be0b3b6cde7b88314ddcd37427b3" translate="yes" xml:space="preserve">
          <source>Reason: CORS request external redirect not allowed</source>
          <target state="translated">이유 : CORS 요청 외부 리디렉션이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="868608d4173aba486e510c1993aebd1346b28581" translate="yes" xml:space="preserve">
          <source>Reason: CORS request not http</source>
          <target state="translated">이유 : CORS가 http가 아닌 요청</target>
        </trans-unit>
        <trans-unit id="756ce5c83972090dfd18afc09136a9721594344b" translate="yes" xml:space="preserve">
          <source>Reason: Credential is not supported if the CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; is &amp;lsquo;*&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Origin'이 '*'인 경우 신임 정보가 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="61897273348d9502ac4a9cbfc6912d021a1fdadc" translate="yes" xml:space="preserve">
          <source>Reason: Did not find method in CORS header &amp;lsquo;Access-Control-Allow-Methods&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Methods'에서 메소드를 찾지 못했습니다.</target>
        </trans-unit>
        <trans-unit id="cde3fd2f65e458b45dfb439c839198bdc521c6f3" translate="yes" xml:space="preserve">
          <source>Reason: Multiple CORS header &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; not allowed</source>
          <target state="translated">이유 : 여러 CORS 헤더 'Access-Control-Allow-Origin'이 허용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="2e8f5f20e78993baa10a1b749e10443f8fcd3944" translate="yes" xml:space="preserve">
          <source>Reason: expected &amp;lsquo;true&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Credentials&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Credentials'에 예상되는 'true'</target>
        </trans-unit>
        <trans-unit id="50a43b6e0fb5601d24499970d71432793694c9ad" translate="yes" xml:space="preserve">
          <source>Reason: invalid token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Headers&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Headers'의 유효하지 않은 토큰 'xyz'</target>
        </trans-unit>
        <trans-unit id="b8cfc9f82a605294184410b4a2e649b6e93163c6" translate="yes" xml:space="preserve">
          <source>Reason: invalid token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Methods&amp;rsquo;</source>
          <target state="translated">이유 : CORS 헤더 'Access-Control-Allow-Methods'의 유효하지 않은 토큰 'xyz'</target>
        </trans-unit>
        <trans-unit id="ceb18ef27a39563d15f30fc87ea5ec94ceb819ce" translate="yes" xml:space="preserve">
          <source>Reason: missing token &amp;lsquo;xyz&amp;rsquo; in CORS header &amp;lsquo;Access-Control-Allow-Headers&amp;rsquo; from CORS preflight channel</source>
          <target state="translated">이유 : CORS 프리 플라이트 채널의 CORS 헤더 'Access-Control-Allow-Headers'에 토큰 'xyz'가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ea166a8dce951acdcb755ee27ef556a370c2d19d" translate="yes" xml:space="preserve">
          <source>Recent versions of Firefox support as well:</source>
          <target state="translated">최신 버전의 Firefox도 지원합니다.</target>
        </trans-unit>
        <trans-unit id="20c75054ca54f429e77b8b04e10df744efd3d8bc" translate="yes" xml:space="preserve">
          <source>Recent versions of modern browsers provide a more secure default for &lt;code&gt;SameSite&lt;/code&gt; to your cookies and so the following message might appear in your console:</source>
          <target state="translated">최신 버전의 최신 브라우저는 &lt;code&gt;SameSite&lt;/code&gt; 에 대한 더 안전한 기본값을 쿠키에 제공하므로 다음 메시지가 콘솔에 나타날 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6422fcc967f452634a501ffeeec039bbb50d3cbc" translate="yes" xml:space="preserve">
          <source>Recommendation</source>
          <target state="translated">Recommendation</target>
        </trans-unit>
        <trans-unit id="bd1aceb143f071d874bbc123b72264a36a503ab4" translate="yes" xml:space="preserve">
          <source>Recommendations on &lt;a href=&quot;https://developer.mozilla.org/en/Browser_Detection_and_Cross_Browser_Support&quot;&gt;sniffing the UA string for cross-browser support&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en/Browser_Detection_and_Cross_Browser_Support&quot;&gt;크로스 브라우저 지원을 위해 UA 문자열 스니핑에 대한&lt;/a&gt; 권장 사항</target>
        </trans-unit>
        <trans-unit id="cfa5b8af1af0a8bb6eedbb724cbc97011a905b75" translate="yes" xml:space="preserve">
          <source>Recording and analyzing user behavior</source>
          <target state="translated">사용자 행동 기록 및 분석</target>
        </trans-unit>
        <trans-unit id="7c8d8fc9cfc5aced3cb8d64bdef12d562b42debf" translate="yes" xml:space="preserve">
          <source>RedBot</source>
          <target state="translated">RedBot</target>
        </trans-unit>
        <trans-unit id="637dfb39d3c34e08850ea6f3b5b6369d2f7469e2" translate="yes" xml:space="preserve">
          <source>Redirect responses (300-303, 305, and 307) defined in HTTP 1.1
   normally take a Location header to indicate the new URI for the
   single resource redirected from the Request-URI.  Multi-Status
   responses contain many resource addresses, but the original
   definition in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;] did not have any place for the server to
   provide the new URI for redirected resources.  This specification
   does define a 'location' element for this information (see
   &lt;a href=&quot;#section-14.9&quot;&gt;Section 14.9&lt;/a&gt;).  Servers MUST use this new element with redirect
   responses in Multi-Status.

   Clients encountering redirected resources in Multi-Status MUST NOT
   rely on the 'location' element being present with a new URI.  If the
   element is not present, the client MAY reissue the request to the
   individual redirected resource, because the response to that request
   can be redirected with a Location header containing the new URI.</source>
          <target state="translated">HTTP 1.1에 정의 된 리디렉션 응답 (300-303, 305 및 307)은 일반적으로 Location 헤더를 사용하여 Request-URI에서 리디렉션 된 단일 리소스의 새 URI를 나타냅니다. 다중 상태 응답에는 많은 리소스 주소가 포함되어 있지만 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ] 의 원래 정의 에는 서버가 리디렉션 된 리소스에 대한 새 URI를 제공 할 위치가 없었습니다. 이 규격은이 정보에 대한 'location'요소를 정의한다 ( &lt;a href=&quot;#section-14.9&quot;&gt;14.9 절&lt;/a&gt; 참조) ). 서버는 다중 상태에서 리디렉션 응답과 함께이 새로운 요소를 사용해야합니다. 다중 상태에서 리디렉션 된 리소스가 발생한 클라이언트는 새 URI가있는 'location'요소에 의존해서는 안됩니다. 요소가 존재하지 않는 경우, 클라이언트는 요청을 개별 URI로 포함하는 Location 헤더로 리디렉션 할 수 있기 때문에 요청을 개별 리디렉션 된 리소스에 재발행 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="629ead9203c19213fba2446477411c8ec459423b" translate="yes" xml:space="preserve">
          <source>Redirection loops</source>
          <target state="translated">리디렉션 루프</target>
        </trans-unit>
        <trans-unit id="aa6efcbd2100faec701e1149fee688eee318d476" translate="yes" xml:space="preserve">
          <source>Redirection loops happen when additional redirections follow the one that has already been followed. In other words, there is a loop that will never be finished and no page will ever be found.</source>
          <target state="translated">Redirection loops happen when additional redirections follow the one that has already been followed. In other words, there is a loop that will never be finished and no page will ever be found.</target>
        </trans-unit>
        <trans-unit id="1fb2905c36033fc913fb566ea3c5bcb1318a9e57" translate="yes" xml:space="preserve">
          <source>Redirection loops happen when successive redirections follow the one that has already been followed. In other words, there is a loop that will never be finished and no page will be found ultimately.</source>
          <target state="translated">재 지정 루프는 연속 된 재 지정이 이미 수행 된 재 지정을 따르는 경우에 발생합니다. 다시 말해, 완료되지 않은 루프가 있으며 궁극적으로 페이지를 찾을 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="c7dd5917ae785b261fda27b44b5ec5a2d680b36d" translate="yes" xml:space="preserve">
          <source>Redirection messages</source>
          <target state="translated">리디렉션 메시지</target>
        </trans-unit>
        <trans-unit id="eeb9caefdf646c7a0ccceccdf48dd3a42d43224b" translate="yes" xml:space="preserve">
          <source>Redirections</source>
          <target state="translated">Redirections</target>
        </trans-unit>
        <trans-unit id="e3bba96caf77bd92cd7d8b0c96235d33da0b22c4" translate="yes" xml:space="preserve">
          <source>Redirections in JavaScript are created by setting a value to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt; property and the new page is loaded.</source>
          <target state="translated">JavaScript에서 리디렉션은 값을 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt; 속성 으로 설정하여 만들어지며 새 페이지가로드됩니다.</target>
        </trans-unit>
        <trans-unit id="a86ef1a1aac68fc429a9d0da40fb0b69de3f66e5" translate="yes" xml:space="preserve">
          <source>Redirections in JavaScript are performed by setting a URL string to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt; property, loading the new page:</source>
          <target state="translated">Redirections in JavaScript are performed by setting a URL string to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt; property, loading the new page:</target>
        </trans-unit>
        <trans-unit id="fcf937319f333e7df4ec12406025be63bde6549b" translate="yes" xml:space="preserve">
          <source>Redirects</source>
          <target state="translated">Redirects</target>
        </trans-unit>
        <trans-unit id="d7ea66c42cc0d823a76b460690e6ff6566141066" translate="yes" xml:space="preserve">
          <source>Redirects (&lt;code&gt;300&lt;/code&gt;&amp;ndash;&lt;code&gt;399&lt;/code&gt;)</source>
          <target state="translated">Redirects ( &lt;code&gt;300&lt;/code&gt; &amp;ndash; &lt;code&gt;399&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="3a5a9e8fba61c9e52b17ff910bed1acecd687c48" translate="yes" xml:space="preserve">
          <source>Redirects accomplish numerous goals:</source>
          <target state="translated">Redirects accomplish numerous goals:</target>
        </trans-unit>
        <trans-unit id="37dc3110ba191c2d77df0cde3470992c711d2947" translate="yes" xml:space="preserve">
          <source>Redirects can be set either in the server config file or in the &lt;code&gt;.htaccess&lt;/code&gt; of each directory.</source>
          <target state="translated">리디렉션은 서버 구성 파일 또는 각 디렉토리 의 &lt;code&gt;.htaccess&lt;/code&gt; 에서 설정할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="db1c784524e1b54011a95823026161f7c8517fe0" translate="yes" xml:space="preserve">
          <source>Reference</source>
          <target state="translated">Reference</target>
        </trans-unit>
        <trans-unit id="5d20d0fee3b91643dd8d272ac33d01ca95179d82" translate="yes" xml:space="preserve">
          <source>References</source>
          <target state="translated">References</target>
        </trans-unit>
        <trans-unit id="699b2fb0910ccc7c0854d17a2041a907709ed3c1" translate="yes" xml:space="preserve">
          <source>Referer</source>
          <target state="translated">Referer</target>
        </trans-unit>
        <trans-unit id="7d600afde85bf128bed4081c176fe7edf403b856" translate="yes" xml:space="preserve">
          <source>Referer (RFC 2616)</source>
          <target state="translated">레퍼러 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="b1bb97f5316cdb3a06386f7cb3cc6564f44f772d" translate="yes" xml:space="preserve">
          <source>Referer (RFC 7231)</source>
          <target state="translated">레퍼러 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="548b0b909e2d1062b7de321059c220fba862be3b" translate="yes" xml:space="preserve">
          <source>Referrer</source>
          <target state="translated">Referrer</target>
        </trans-unit>
        <trans-unit id="e9085bde7a7780a48ca2a79ea2ef1b8e36c397ae" translate="yes" xml:space="preserve">
          <source>Referrer Policy</source>
          <target state="translated">리퍼러 정책</target>
        </trans-unit>
        <trans-unit id="56d6a82203aab19c5732c260c1b17608ee8ddd53" translate="yes" xml:space="preserve">
          <source>Referrer-Policy</source>
          <target state="translated">Referrer-Policy</target>
        </trans-unit>
        <trans-unit id="81812b5ae7e147b994882094bc1bfac513c944bc" translate="yes" xml:space="preserve">
          <source>Refers to the empty set; that is, no URLs match. The single quotes are required.</source>
          <target state="translated">빈 세트를 나타냅니다. 즉, 일치하는 URL이 없습니다. 작은 따옴표가 필요합니다.</target>
        </trans-unit>
        <trans-unit id="5c14c5b41372e5f4d7d2284be0cef39d021c62d6" translate="yes" xml:space="preserve">
          <source>Refers to the origin from which the protected document is being served, including the same URL scheme and port number. You must include the single quotes. Some browsers specifically exclude &lt;code&gt;blob&lt;/code&gt; and &lt;code&gt;filesystem&lt;/code&gt; from source directives. Sites needing to allow these content types can specify them using the Data attribute.</source>
          <target state="translated">동일한 URL 체계 및 포트 번호를 포함하여 보호 된 문서가 제공되는 출처를 나타냅니다. 작은 따옴표를 포함해야합니다. 일부 브라우저는 특히 소스 지시문에서 &lt;code&gt;blob&lt;/code&gt; 및 &lt;code&gt;filesystem&lt;/code&gt; 을 제외 합니다. 이러한 컨텐츠 유형을 허용해야하는 사이트는 데이터 속성을 사용하여 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="666b2fc5e19b42683e17cd8e2c18048b27596c23" translate="yes" xml:space="preserve">
          <source>Registration of an HTTP Range Unit MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">HTTP 범위 단위의 등록에는 다음 필드가 포함되어야합니다. o 이름 o 설명 o 사양 텍스트에 대한 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;포인터이&lt;/a&gt; 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( [RFC5226], 4.1 항 참조 ).</target>
        </trans-unit>
        <trans-unit id="072544a89921ea204166220b6ecbe57052aede21" translate="yes" xml:space="preserve">
          <source>Registrations MUST include the following fields:

   o  Authentication Scheme Name

   o  Pointer to specification text

   o  Notes (optional)

   Values to be added to this namespace require IETF Review (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], Section&amp;nbsp;4.1&lt;/a&gt;).</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 인증 체계 이름 o 사양 텍스트에 대한 포인터 o 참고 (선택 사항)이 네임 스페이스에 추가되는 값에는 IETF 검토가 필요합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226], 섹션 4.1 참조&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3900f3dae5507cbea7f7a037aa9cc17206c5b409" translate="yes" xml:space="preserve">
          <source>Registrations MUST include the following fields:

   o  Name

   o  Description

   o  Pointer to specification text

   Names of transfer codings MUST NOT overlap with names of content
   codings (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;Section&amp;nbsp;3.1.2.1 of [RFC7231]&lt;/a&gt;) unless the encoding
   transformation is identical, as is the case for the compression
   codings defined in &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;.

   Values to be added to this namespace require IETF Review (see &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;4.1 of [RFC5226]&lt;/a&gt;), and MUST conform to the purpose of transfer coding
   defined in this specification.

   Use of program names for the identification of encoding formats is
   not desirable and is discouraged for future encodings.</source>
          <target state="translated">등록에는 다음 필드가 포함되어야합니다. o 이름 o 설명 o 사양 텍스트에 대한 포인터 전송 코딩의 이름은 인코딩 변환이 동일한 경우가 아니라면 콘텐츠 코딩의 이름 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.1.2.1&quot;&gt;[RFC7231]의 3.1.2.1 섹션)&lt;/a&gt; 과 겹치지 않아야 합니다. 정의 압축 코딩 &lt;a href=&quot;#section-4.2&quot;&gt;4.2&lt;/a&gt; . 이 네임 스페이스에 추가되는 값은 IETF 검토 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;[RFC5226] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc5226#section-4.1&quot;&gt;섹션 &lt;/a&gt;4.1 참조)가 필요 하며이 사양에 정의 된 전송 코딩의 목적을 준수해야합니다. 인코딩 형식을 식별하기 위해 프로그램 이름을 사용하는 것은 바람직하지 않으며 향후 인코딩에는 사용하지 않는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="d151bc7b242db455dafecdde98d424a7fbe5826b" translate="yes" xml:space="preserve">
          <source>Related headers: &lt;a href=&quot;headers/accept-ranges&quot;&gt;&lt;code&gt;Accept-Ranges&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/if-range&quot;&gt;&lt;code&gt;If-Range&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관련 헤더 : &lt;a href=&quot;headers/accept-ranges&quot;&gt; &lt;code&gt;Accept-Ranges&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/if-range&quot;&gt; &lt;code&gt;If-Range&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3a02133d506baccd9607b7a86c4dbb504734c4a1" translate="yes" xml:space="preserve">
          <source>Related status codes &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;status/416&quot;&gt;&lt;code&gt;416&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">관련 상태 코드 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;status/416&quot;&gt; &lt;code&gt;416&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2034c07c455dea528b5c044f32d891f3327323d4" translate="yes" xml:space="preserve">
          <source>Related utility functions</source>
          <target state="translated">관련 유틸리티 기능</target>
        </trans-unit>
        <trans-unit id="e0239139fec07795176258d50edee26a1aa0c492" translate="yes" xml:space="preserve">
          <source>Relaxing the security-model of the Web</source>
          <target state="translated">웹 보안 모델 완화</target>
        </trans-unit>
        <trans-unit id="6924dcad4d5ebf6c89d8fdf2adb56994263c7fe3" translate="yes" xml:space="preserve">
          <source>Rendering engine</source>
          <target state="translated">렌더링 엔진</target>
        </trans-unit>
        <trans-unit id="048baaee6737f98c6e3617392ee0aa92a328acc5" translate="yes" xml:space="preserve">
          <source>Rendering engine version</source>
          <target state="translated">렌더링 엔진 버전</target>
        </trans-unit>
        <trans-unit id="f5a55dcde49099910df9c704e7c97c70be2ccc80" translate="yes" xml:space="preserve">
          <source>Reorganization of a Web site, with non-GET links/operations.</source>
          <target state="translated">비 GET 링크 / 작업으로 웹 사이트 재구성</target>
        </trans-unit>
        <trans-unit id="6069aff506484cfe4ca0e6dc53acad55e6682b1e" translate="yes" xml:space="preserve">
          <source>Reorganization of a Web site.</source>
          <target state="translated">웹 사이트의 재구성.</target>
        </trans-unit>
        <trans-unit id="d67bc0e6c0c6dc1b32fa80aa1a759051dbd62d55" translate="yes" xml:space="preserve">
          <source>Report-Only header</source>
          <target state="translated">보고서 전용 헤더</target>
        </trans-unit>
        <trans-unit id="06d6c29bfb10b8b70b6c5a76ac8a545632073eb1" translate="yes" xml:space="preserve">
          <source>Reporting API</source>
          <target state="translated">보고 API</target>
        </trans-unit>
        <trans-unit id="e0ff584859d7c7f3e165e23c136c2c4b65edc9dc" translate="yes" xml:space="preserve">
          <source>Reporting directive</source>
          <target state="translated">보고 지시어</target>
        </trans-unit>
        <trans-unit id="49734955482cddad14d7d6086f6396c10758c821" translate="yes" xml:space="preserve">
          <source>Reporting directives</source>
          <target state="translated">보고 지시문</target>
        </trans-unit>
        <trans-unit id="6e53788c8a0b65951ac470b7cdcba8ef12feb88d" translate="yes" xml:space="preserve">
          <source>Reporting directives control the reporting process of CSP violations. See also the &lt;a href=&quot;content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">보고 지시문은 CSP 위반의보고 프로세스를 제어합니다. &lt;a href=&quot;content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="ab154f3f0f0aa20f53fb514f0ce977cea9be3a53" translate="yes" xml:space="preserve">
          <source>Reports are sent to a reporting group defined within a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Report-To&quot;&gt;&lt;code&gt;Report-To&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">보고서는 내에 정의보고 그룹으로 전송되는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Report-To&quot;&gt; &lt;code&gt;Report-To&lt;/code&gt; &lt;/a&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="faafcc65691f4495ef2dd9f54e8f8dbc76133274" translate="yes" xml:space="preserve">
          <source>Representation header fields provide metadata about the
   representation.  When a message includes a payload body, the
   representation header fields describe how to interpret the
   representation data enclosed in the payload body.  In a response to a
   HEAD request, the representation header fields describe the
   representation data that would have been enclosed in the payload body
   if the same request had been a GET.

   The following header fields convey representation metadata:

   +-------------------+-----------------+
   | Header Field Name | Defined in...   |
   +-------------------+-----------------+
   | Content-Type      | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;Section 3.1.1.5&lt;/a&gt; |
   | Content-Encoding  | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;Section 3.1.2.2&lt;/a&gt; |
   | Content-Language  | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;Section 3.1.3.2&lt;/a&gt; |
   | Content-Location  | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;Section 3.1.4.2&lt;/a&gt; |
   +-------------------+-----------------+</source>
          <target state="translated">표현 헤더 필드는 표현에 대한 메타 데이터를 제공합니다. 메시지에 페이로드 본문이 포함 된 경우 표현 헤더 필드는 페이로드 본문에 포함 된 표현 데이터를 해석하는 방법을 설명합니다. HEAD 요청에 대한 응답으로, 표현 헤더 필드는 동일한 요청이 GET 인 경우 페이로드 본문에 포함 된 표현 데이터를 설명합니다. 다음 헤더 필드는 표현 메타 데이터를 전달합니다. + ------------------- + ----------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + ----------------- + | 컨텐츠 유형 | &lt;a href=&quot;#section-3.1.1.5&quot;&gt;3.1.1.5 절&lt;/a&gt; | | 콘텐츠 인코딩 | &lt;a href=&quot;#section-3.1.2.2&quot;&gt;3.1.2.2 절&lt;/a&gt; | | 콘텐츠 언어 | &lt;a href=&quot;#section-3.1.3.2&quot;&gt;3.1.3.2 절&lt;/a&gt;| | 컨텐츠 위치 | &lt;a href=&quot;#section-3.1.4.2&quot;&gt;섹션 3.1.4.2&lt;/a&gt; | + ------------------- + ----------------- +</target>
        </trans-unit>
        <trans-unit id="e405e17158b8b239987e79f57e2f7771ef0097af" translate="yes" xml:space="preserve">
          <source>Representations (RFC 7231)</source>
          <target state="translated">표현 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="4aed03cac49d5e43da4e855a967286931a4d621a" translate="yes" xml:space="preserve">
          <source>Request</source>
          <target state="translated">Request</target>
        </trans-unit>
        <trans-unit id="92f88e2c8e9bb975a09d205785b581b72223d69c" translate="yes" xml:space="preserve">
          <source>Request (RFC 2616)</source>
          <target state="translated">요청 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="209107c4e6e87baa9562058df6689267d77f72ab" translate="yes" xml:space="preserve">
          <source>Request and Response messages MAY transfer an entity if not otherwise
   restricted by the request method or response status code. An entity
   consists of entity-header fields and an entity-body, although some
   responses will only include the entity-headers.

   In this section, both sender and recipient refer to either the client
   or the server, depending on who sends and who receives the entity.</source>
          <target state="translated">요청 및 응답 메시지는 요청 방법 또는 응답 상태 코드에 의해 달리 제한되지 않으면 엔티티를 전송할 수 있습니다. 엔터티는 엔터티 헤더 필드와 엔터티 본문으로 구성되지만 일부 응답에는 엔터티 헤더 만 포함됩니다. 이 섹션에서 보낸 사람과받는 사람은 모두 엔터티를받는 사람과받는 사람에 따라 클라이언트 또는 서버를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="b4ccb0ae69ff9044ffa521ca4c16ab4e8a2bb624" translate="yes" xml:space="preserve">
          <source>Request context</source>
          <target state="translated">요청 컨텍스트</target>
        </trans-unit>
        <trans-unit id="6ee7b5c7d1970d29bd49eb9d029bff7b4b9637c8" translate="yes" xml:space="preserve">
          <source>Request entity is larger than limits defined by server; the server might close the connection or return an &lt;code&gt;Retry-After&lt;/code&gt; header field.</source>
          <target state="translated">요청 엔터티가 서버에서 정의한 제한보다 큽니다. 서버가 연결을 닫거나 &lt;code&gt;Retry-After&lt;/code&gt; 헤더 필드를 리턴 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5b3e3eaae6a46abf6af6e09d0d998a3ceec713b2" translate="yes" xml:space="preserve">
          <source>Request has body</source>
          <target state="translated">요청에 본문이 있음</target>
        </trans-unit>
        <trans-unit id="a9528878e11c1033e6bd63ba8721a8f88c91e374" translate="yes" xml:space="preserve">
          <source>Request header</source>
          <target state="translated">요청 헤더</target>
        </trans-unit>
        <trans-unit id="30eaa32f64dd1274f348ded1be63b905756fabff" translate="yes" xml:space="preserve">
          <source>Request methods</source>
          <target state="translated">요청 방법</target>
        </trans-unit>
        <trans-unit id="3437c4d523fcec9c5dbe6ca25b313e8b0c9faa07" translate="yes" xml:space="preserve">
          <source>Request methods are considered &quot;safe&quot; if their defined semantics are
   essentially read-only; i.e., the client does not request, and does
   not expect, any state change on the origin server as a result of
   applying a safe method to a target resource.  Likewise, reasonable
   use of a safe method is not expected to cause any harm, loss of
   property, or unusual burden on the origin server. 

   This definition of safe methods does not prevent an implementation
   from including behavior that is potentially harmful, that is not
   entirely read-only, or that causes side effects while invoking a safe
   method.  What is important, however, is that the client did not
   request that additional behavior and cannot be held accountable for
   it.  For example, most servers append request information to access
   log files at the completion of every response, regardless of the
   method, and that is considered safe even though the log storage might
   become full and crash the server.  Likewise, a safe request initiated
   by selecting an advertisement on the Web will often have the side
   effect of charging an advertising account.

   Of the request methods defined by this specification, the GET, HEAD,
   OPTIONS, and TRACE methods are defined to be safe.

   The purpose of distinguishing between safe and unsafe methods is to
   allow automated retrieval processes (spiders) and cache performance
   optimization (pre-fetching) to work without fear of causing harm.  In
   addition, it allows a user agent to apply appropriate constraints on
   the automated use of unsafe methods when processing potentially
   untrusted content.

   A user agent SHOULD distinguish between safe and unsafe methods when
   presenting potential actions to a user, such that the user can be
   made aware of an unsafe action before it is requested.

   When a resource is constructed such that parameters within the
   effective request URI have the effect of selecting an action, it is
   the resource owner's responsibility to ensure that the action is
   consistent with the request method semantics.  For example, it is
   common for Web-based content editing software to use actions within
   query parameters, such as &quot;page?do=delete&quot;.  If the purpose of such a
   resource is to perform an unsafe action, then the resource owner MUST
   disable or disallow that action when it is accessed using a safe
   request method.  Failure to do so will result in unfortunate side
   effects when automated processes perform a GET on every URI reference
   for the sake of link maintenance, pre-fetching, building a search
   index, etc.</source>
          <target state="translated">정의 된 의미론이 본질적으로 읽기 전용 인 경우 요청 메소드는 &quot;안전한&quot;것으로 간주됩니다. 즉, 클라이언트는 안전한 방법을 대상 자원에 적용한 결과로 오리진 서버에서 상태 변경을 요청하지 않으며 예상하지 않습니다. 마찬가지로, 안전한 방법을 합리적으로 사용한다고해서 원산지 서버에 해를 입거나 재산 손실 또는 비정상적인 부담이 발생하지는 않습니다. 안전한 메소드에 대한이 정의는 구현이 잠재적으로 유해하거나, 완전히 읽기 전용이 아니거나, 안전한 메소드를 호출하는 동안 부작용을 일으키는 동작을 포함하는 것을 막지 않습니다. 그러나 중요한 것은 고객이 추가 행동을 요청하지 않았으며 이에 대한 책임을 질 수 없다는 것입니다. 예를 들어대부분의 서버는 방법에 관계없이 모든 응답이 완료 될 때마다 로그 파일에 액세스하기 위해 요청 정보를 추가하며, 로그 스토리지가 가득 차서 서버에 충돌이 발생하더라도 안전하다고 간주됩니다. 마찬가지로, 웹에서 광고를 선택하여 시작된 안전한 요청은 종종 광고 계정을 청구하는 부작용이 있습니다. 이 사양에서 정의한 요청 방법 중 GET, HEAD, OPTIONS 및 TRACE 방법은 안전하도록 정의되어 있습니다. 안전한 방법과 안전하지 않은 방법을 구별하는 목적은 자동화 된 검색 프로세스 (스파이더)와 캐시 성능 최적화 (프리 페치)가 피해를 입을 염려없이 작동하도록하는 것입니다. 게다가,신뢰할 수없는 내용을 처리 할 때 안전하지 않은 방법의 자동화 된 사용에 사용자 에이전트가 적절한 제한을 적용 할 수 있습니다. 사용자 에이전트는 잠재적 조치를 사용자에게 제시 할 때 안전 및 안전하지 않은 방법을 구별하여 요청되기 전에 사용자가 안전하지 않은 조치를 인식하도록해야합니다. 유효 요청 URI 내의 매개 변수가 조치를 선택하는 효과를 갖도록 자원이 구성된 경우, 조치가 요청 메소드 시맨틱과 일치하는지 확인하는 것은 자원 소유자의 책임입니다. 예를 들어, 웹 기반 컨텐츠 편집 소프트웨어는 &quot;page? do = delete&quot;와 같은 쿼리 매개 변수 내에서 조치를 사용하는 것이 일반적입니다. 그러한 자원의 목적이 안전하지 않은 조치를 수행하는 것이라면,그런 다음 리소스 소유자는 안전한 요청 방법을 사용하여 액세스 할 때 해당 작업을 비활성화하거나 허용하지 않아야합니다. 그렇지 않으면 자동화 된 프로세스가 링크 유지 관리, 프리 페치, 검색 색인 작성 등을 위해 모든 URI 참조에 대해 GET을 수행 할 때 부작용이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="e9b6ad5f3d071161c8b3a3dfe4a105628b443960" translate="yes" xml:space="preserve">
          <source>Request methods can be defined as &quot;cacheable&quot; to indicate that
   responses to them are allowed to be stored for future reuse; for
   specific requirements see [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;].  In general, safe methods that
   do not depend on a current or authoritative response are defined as
   cacheable; this specification defines GET, HEAD, and POST as
   cacheable, although the overwhelming majority of cache
   implementations only support GET and HEAD.</source>
          <target state="translated">요청 방법은 &quot;캐시 블 가능&quot;으로 정의되어 향후 재사용을 위해 응답을 저장할 수 있음을 나타냅니다. 특정 요구 사항은 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt; ]를 참조하십시오 . 일반적으로 현재 또는 신뢰할 수있는 응답에 의존하지 않는 안전한 방법은 캐시 가능으로 정의됩니다. 이 사양은 GET, HEAD 및 POST를 캐시 가능한 것으로 정의하지만 압도적 인 대다수의 캐시 구현은 GET 및 HEAD 만 지원합니다.</target>
        </trans-unit>
        <trans-unit id="0fe2385cde5e7e860a739c3f7a915be25d6759e0" translate="yes" xml:space="preserve">
          <source>Request requires preflight, which is disallowed to follow cross-origin redirect</source>
          <target state="translated">요청에 프리 플라이트가 필요합니다. 프리 플라이트는 교차 출처 리디렉션을 따르지 않습니다.</target>
        </trans-unit>
        <trans-unit id="503b534d1cc7a82dc13ef87bb3f5b88cfd30bfc5" translate="yes" xml:space="preserve">
          <source>Request smuggling ([&lt;a href=&quot;#ref-Linhart&quot;&gt;Linhart&lt;/a&gt;]) is a technique that exploits
   differences in protocol parsing among various recipients to hide
   additional requests (which might otherwise be blocked or disabled by
   policy) within an apparently harmless request.  Like response
   splitting, request smuggling can lead to a variety of attacks on HTTP
   usage.

   This specification has introduced new requirements on request
   parsing, particularly with regard to message framing in
   &lt;a href=&quot;#section-3.3.3&quot;&gt;Section 3.3.3&lt;/a&gt;, to reduce the effectiveness of request smuggling.</source>
          <target state="translated">요청 밀수 ([ &lt;a href=&quot;#ref-Linhart&quot;&gt;Linhart&lt;/a&gt; ])는 명백히 무해한 요청 내에서 추가 요청 (정책에 의해 차단되거나 비활성화 될 수 있음)을 숨기기 위해 다양한 수신자 간의 프로토콜 구문 분석의 차이점을 이용하는 기술입니다. 응답 분할과 마찬가지로 요청 밀수는 HTTP 사용에 대한 다양한 공격으로 이어질 수 있습니다. 이 스펙은 요청 스 머글 링의 효과를 줄이기 위해 요청 구문 분석, 특히 &lt;a href=&quot;#section-3.3.3&quot;&gt;3.3.3 절의&lt;/a&gt; 메시지 프레이밍과 관련하여 새로운 요구 사항을 도입 했다.</target>
        </trans-unit>
        <trans-unit id="66e24614ec5539e3d6735b49b45a076601db8145" translate="yes" xml:space="preserve">
          <source>Request to the DNS server failed due to reasons not covered by previous errors (e.g. SERVFAIL)</source>
          <target state="translated">이전 오류 (예 : SERVFAIL)에서 다루지 않은 이유로 인해 DNS 서버에 대한 요청이 실패했습니다.</target>
        </trans-unit>
        <trans-unit id="ec0e7ce9ae95cfb810daec9034953e6593131003" translate="yes" xml:space="preserve">
          <source>Request:</source>
          <target state="translated">Request:</target>
        </trans-unit>
        <trans-unit id="4f2b78b6c4f7e212360888da9e743888ae19dbfe" translate="yes" xml:space="preserve">
          <source>Requesting a specific range from a server</source>
          <target state="translated">서버에서 특정 범위 요청</target>
        </trans-unit>
        <trans-unit id="3e1c4325f552db0dd41e8ebaad689edea63a1814" translate="yes" xml:space="preserve">
          <source>Requesting data from a server in different formats</source>
          <target state="translated">다른 형식의 서버에서 데이터 요청</target>
        </trans-unit>
        <trans-unit id="65f9d517e2876f465c9079ef7d58987b6d7133b5" translate="yes" xml:space="preserve">
          <source>Requesting the first 500 and last 500 bytes of the file. The request may be rejected by the server if the ranges overlap.</source>
          <target state="translated">Requesting the first 500 and last 500 bytes of the file. The request may be rejected by the server if the ranges overlap.</target>
        </trans-unit>
        <trans-unit id="a63fe83db36a0c43261f124bbf4931e1feeed295" translate="yes" xml:space="preserve">
          <source>Requesting three ranges from the file.</source>
          <target state="translated">Requesting three ranges from the file.</target>
        </trans-unit>
        <trans-unit id="f7194e6a0d0b838382b202853e7c198d693fbabc" translate="yes" xml:space="preserve">
          <source>Requests</source>
          <target state="translated">Requests</target>
        </trans-unit>
        <trans-unit id="42f2929bd33823bdf38ee7942319e10575f276bb" translate="yes" xml:space="preserve">
          <source>Requests consists of the following elements:</source>
          <target state="translated">요청은 다음 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="26f6f957bc80eb0e2c204e917f27da5fd98e8526" translate="yes" xml:space="preserve">
          <source>Requests from any &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;origin&lt;/a&gt;&lt;/em&gt; (both same-site and cross-site) can read the resource.</source>
          <target state="translated">모든 &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/origin&quot;&gt;출처&lt;/a&gt;&lt;/em&gt; (동일 사이트 및 교차 사이트)의 요청은 리소스를 읽을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="407b9cd287af007f637b486aaa36862498225921" translate="yes" xml:space="preserve">
          <source>Requests to the &lt;code&gt;http://&lt;/code&gt; version of your site will redirect to the &lt;code&gt;https://&lt;/code&gt; version of your site.</source>
          <target state="translated">Requests to the &lt;code&gt;http://&lt;/code&gt; version of your site will redirect to the &lt;code&gt;https://&lt;/code&gt; version of your site.</target>
        </trans-unit>
        <trans-unit id="e82d9e92edcff98536ce51f4852910ccc962b156" translate="yes" xml:space="preserve">
          <source>Requests with credentials</source>
          <target state="translated">자격 증명이있는 요청</target>
        </trans-unit>
        <trans-unit id="9472781a408847ad355c057726227036836eb352" translate="yes" xml:space="preserve">
          <source>Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language</source>
          <target state="translated">Require preflight for non-standard CORS-safelisted request headers Accept, Accept-Language, and Content-Language</target>
        </trans-unit>
        <trans-unit id="896b8e09c2c51403430f397ed2a914d36c173299" translate="yes" xml:space="preserve">
          <source>Requirements for cookies across the EU are defined in &lt;a href=&quot;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&quot;&gt;Directive 2009/136/EC&lt;/a&gt; of the European Parliament and came into effect on 25 May 2011. A directive is not a law by itself, but a requirement for EU member states to put laws in place that meet the requirements of the directive. The actual laws can differ from country to country.</source>
          <target state="translated">EU 전역의 쿠키에 대한 요구 사항 은 유럽 의회의 &lt;a href=&quot;http://eur-lex.europa.eu/legal-content/EN/TXT/?uri=CELEX:32009L0136&quot;&gt;지침 2009 / 136 / EC&lt;/a&gt; 에 정의되어 있으며 2011 년 5 월 25 일에 발효되었습니다. 지침은 자체적으로 법이 아니라 EU 회원국이 법을 제정하는 요구 사항입니다. 지침의 요구 사항을 충족시킵니다. 실제 법률은 국가마다 다를 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="58efddfc035f1f01ebc5a45ea6ef85eae9088fde" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for both, scripts and style sheets.</source>
          <target state="translated">스크립트와 스타일 시트 모두에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="33eafda8cd41b807493e212a681cb068a92c17e4" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for scripts.</source>
          <target state="translated">스크립트에는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="a71171ac0001f4cd89b14fa7a98d39f88be17a2d" translate="yes" xml:space="preserve">
          <source>Requires &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for style sheets.</source>
          <target state="translated">스타일 시트에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 가 필요합니다 .</target>
        </trans-unit>
        <trans-unit id="1c018354f46e0590ba0dbb9b1c4723dd35f22f66" translate="yes" xml:space="preserve">
          <source>Requires a sample of the violating code to be included in the violation report.</source>
          <target state="translated">위반 코드 샘플을 위반 보고서에 포함해야합니다.</target>
        </trans-unit>
        <trans-unit id="3a775f4a3f060d56b00223f3382dbb2cdc761a0e" translate="yes" xml:space="preserve">
          <source>Requires the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; for scripts or styles on the page.</source>
          <target state="translated">페이지에서 스크립트 또는 스타일에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/SRI&quot;&gt;SRI&lt;/a&gt; 를 사용해야 합니다.</target>
        </trans-unit>
        <trans-unit id="2a5e4228f9aa6fc13b0464eaaa4225d798aeffa9" translate="yes" xml:space="preserve">
          <source>Requiring revalidation</source>
          <target state="translated">Requiring revalidation</target>
        </trans-unit>
        <trans-unit id="9991b4d153c5704ddc24858d8325cfbcfbf453af" translate="yes" xml:space="preserve">
          <source>Reserved for use as a placeholder in examples showing how to use MIME types. These should never be used outside of sample code listings and documentation. &lt;code&gt;example&lt;/code&gt; can also be used as a subtype; for instance, in an example related to working with audio on the web, the MIME type &lt;code&gt;audio/example&lt;/code&gt; can be used to indicate that the type is a placeholder and should be replaced with an appropriate one when using the code in the real world.</source>
          <target state="translated">Reserved for use as a placeholder in examples showing how to use MIME types. These should never be used outside of sample code listings and documentation. &lt;code&gt;example&lt;/code&gt; can also be used as a subtype; for instance, in an example related to working with audio on the web, the MIME type &lt;code&gt;audio/example&lt;/code&gt; can be used to indicate that the type is a placeholder and should be replaced with an appropriate one when using the code in the real world.</target>
        </trans-unit>
        <trans-unit id="54f4777a2c07551392e54e261d880e24efe04a2b" translate="yes" xml:space="preserve">
          <source>Resolves the given DNS hostname into an IP address, and returns it in the dot-separated format as a string.</source>
          <target state="translated">지정된 DNS 호스트 이름을 IP 주소로 확인하고 점으로 구분 된 형식으로 문자열로 반환합니다.</target>
        </trans-unit>
        <trans-unit id="66ffd0eeda52e38491bf125188155f503a13c5f8" translate="yes" xml:space="preserve">
          <source>Resource Digests for HTTP</source>
          <target state="translated">HTTP 용 리소스 다이제스트</target>
        </trans-unit>
        <trans-unit id="54d7b16d6f25ff228207d06007bc79d8c49dabb8" translate="yes" xml:space="preserve">
          <source>Resource Timing API</source>
          <target state="translated">자원 타이밍 API</target>
        </trans-unit>
        <trans-unit id="d64022b8c69b24949fe20baf510c31745fe844e9" translate="yes" xml:space="preserve">
          <source>Resource Timing Level 3&lt;br/&gt;&lt;small&gt;The definition of 'Timing-Allow-Origin' in that specification.&lt;/small&gt;</source>
          <target state="translated">리소스 타이밍 레벨 3 &lt;small&gt;해당 사양에서 '타이밍 허용&lt;/small&gt; 소스 &lt;br/&gt;&lt;small&gt;'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="798dcb46eb38b768887b1e2f745c95d93e85e984" translate="yes" xml:space="preserve">
          <source>Resource URLs</source>
          <target state="translated">리소스 URL</target>
        </trans-unit>
        <trans-unit id="7de6ba1f289521322fe08eee24de6e4e8832b3bf" translate="yes" xml:space="preserve">
          <source>Resource URLs are composed of two parts: a prefix (&lt;code&gt;resource:&lt;/code&gt;), and a URL pointing to the resource you want to load:</source>
          <target state="translated">리소스 URL은 접두사 ( &lt;code&gt;resource:&lt;/code&gt; :) 와로드하려는 리소스를 가리키는 URL 의 두 부분으로 구성 됩니다.</target>
        </trans-unit>
        <trans-unit id="ad91d18e5dc789f46a10914125180d778fe1dd92" translate="yes" xml:space="preserve">
          <source>Resource URLs, URLs prefixed with the &lt;code&gt;resource:&lt;/code&gt; scheme, are used by Firefox and Firefox browser extensions to load resources internally, but some of the information is available to sites the browser connects to as well.</source>
          <target state="translated">접두사 &lt;code&gt;resource:&lt;/code&gt; 구성표가 붙은 URL 인 리소스 URL 은 Firefox 및 Firefox 브라우저 확장 프로그램에서 내부적으로 리소스를로드하는 데 사용되지만 일부 정보는 브라우저가 연결된 사이트에서도 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2caf2a391127495a2a503e4c2574c5bbaee93687" translate="yes" xml:space="preserve">
          <source>Resource URLs, those prefixed with the &lt;code&gt;resource&lt;/code&gt; scheme are used by Firefox and Firefox browser extensions to load resources internally, but is also available to some sites the browser connects to as well.</source>
          <target state="translated">Resource URLs, those prefixed with the &lt;code&gt;resource&lt;/code&gt; scheme are used by Firefox and Firefox browser extensions to load resources internally, but is also available to some sites the browser connects to as well.</target>
        </trans-unit>
        <trans-unit id="3f9dad94a76fa176febfa455dbb8cce0fd95a809" translate="yes" xml:space="preserve">
          <source>Resources and URIs</source>
          <target state="translated">자원 및 URI</target>
        </trans-unit>
        <trans-unit id="aeb4705a43eda0152e9211513d37d2ebc74577ed" translate="yes" xml:space="preserve">
          <source>Resources and specifications</source>
          <target state="translated">리소스 및 사양</target>
        </trans-unit>
        <trans-unit id="6e617e4fc9da3de9693eac5990613543b86c63f9" translate="yes" xml:space="preserve">
          <source>Response</source>
          <target state="translated">Response</target>
        </trans-unit>
        <trans-unit id="b91c0a7d61c2a326eb2fb877b8d8d75077f4c7c5" translate="yes" xml:space="preserve">
          <source>Response (RFC 2616)</source>
          <target state="translated">응답 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="62bca1e6a1a2f5863671a7fa9d7845857288f9e2" translate="yes" xml:space="preserve">
          <source>Response codes</source>
          <target state="translated">응답 코드</target>
        </trans-unit>
        <trans-unit id="f84e739be38db39024655ad83fa5e6bb72e53942" translate="yes" xml:space="preserve">
          <source>Response context</source>
          <target state="translated">응답 컨텍스트</target>
        </trans-unit>
        <trans-unit id="7b398df4add831e6b05ee4c0b368c39fd3f5bc77" translate="yes" xml:space="preserve">
          <source>Response header</source>
          <target state="translated">응답 헤더</target>
        </trans-unit>
        <trans-unit id="9b7e02a5516eb784c59460a7b87383f30bdd1c7d" translate="yes" xml:space="preserve">
          <source>Response header fields can supply control data that supplements the
   status code, directs caching, or instructs the client where to go
   next.

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | Age               | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;Section&amp;nbsp;5.1 of [RFC7234]&lt;/a&gt; |
   | Cache-Control     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt; |
   | Expires           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;Section&amp;nbsp;5.3 of [RFC7234]&lt;/a&gt; |
   | Date              | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt;          |
   | Location          | &lt;a href=&quot;#section-7.1.2&quot;&gt;Section 7.1.2&lt;/a&gt;            |
   | Retry-After       | &lt;a href=&quot;#section-7.1.3&quot;&gt;Section 7.1.3&lt;/a&gt;            |
   | Vary              | &lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;            |
   | Warning           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">응답 헤더 필드는 상태 코드를 보완하거나 캐싱을 지시하거나 클라이언트에게 다음 단계를 지시하는 제어 데이터를 제공 할 수 있습니다. + ------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + -------------------------- + | 나이 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.1&quot;&gt;[RFC7234] 5.1 절&lt;/a&gt; | | 캐시 제어 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;[RFC7234] 섹션 5.2&lt;/a&gt; | | 만료 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.3&quot;&gt;[RFC7234]의 섹션 5.3&lt;/a&gt; | | 날짜 | &lt;a href=&quot;#section-7.1.1.2&quot;&gt;7.1.1.2 절&lt;/a&gt; | | 위치 | &lt;a href=&quot;#section-7.1.2&quot;&gt;섹션 7.1.2&lt;/a&gt; | | 재시도 후 | &lt;a href=&quot;#section-7.1.3&quot;&gt;섹션 7.1.3&lt;/a&gt; | | 다름 |&lt;a href=&quot;#section-7.1.4&quot;&gt; 섹션 7.1.4&lt;/a&gt; | | 경고 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]의 섹션 5.5&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="c8aa6a36289563928821fce4669ae4ff1ccded70" translate="yes" xml:space="preserve">
          <source>Response is Stale</source>
          <target state="translated">응답이 오래되었습니다</target>
        </trans-unit>
        <trans-unit id="489cf931f8314d53d2e222caae252c3b648ea519" translate="yes" xml:space="preserve">
          <source>Response is empty, has a content-length mismatch, has improper encoding, and/or other conditions that prevent user agent from processing the response</source>
          <target state="translated">응답이 비어 있거나, 콘텐츠 길이가 일치하지 않거나, 인코딩이 잘못되었거나, 사용자 에이전트가 응답을 처리하지 못하게하는 기타 조건이 있습니다.</target>
        </trans-unit>
        <trans-unit id="5633194dd26604f7ddba594d72f55184513f1b60" translate="yes" xml:space="preserve">
          <source>Response splitting (a.k.a, CRLF injection) is a common technique,
   used in various attacks on Web usage, that exploits the line-based
   nature of HTTP message framing and the ordered association of
   requests to responses on persistent connections [&lt;a href=&quot;#ref-Klein&quot;&gt;Klein&lt;/a&gt;].  This
   technique can be particularly damaging when the requests pass through
   a shared cache.

   Response splitting exploits a vulnerability in servers (usually
   within an application server) where an attacker can send encoded data
   within some parameter of the request that is later decoded and echoed
   within any of the response header fields of the response.  If the
   decoded data is crafted to look like the response has ended and a 

   subsequent response has begun, the response has been split and the
   content within the apparent second response is controlled by the
   attacker.  The attacker can then make any other request on the same
   persistent connection and trick the recipients (including
   intermediaries) into believing that the second half of the split is
   an authoritative answer to the second request.

   For example, a parameter within the request-target might be read by
   an application server and reused within a redirect, resulting in the
   same parameter being echoed in the Location header field of the
   response.  If the parameter is decoded by the application and not
   properly encoded when placed in the response field, the attacker can
   send encoded CRLF octets and other content that will make the
   application's single response look like two or more responses.

   A common defense against response splitting is to filter requests for
   data that looks like encoded CR and LF (e.g., &quot;%0D&quot; and &quot;%0A&quot;).
   However, that assumes the application server is only performing URI
   decoding, rather than more obscure data transformations like charset
   transcoding, XML entity translation, base64 decoding, sprintf
   reformatting, etc.  A more effective mitigation is to prevent
   anything other than the server's core protocol libraries from sending
   a CR or LF within the header section, which means restricting the
   output of header fields to APIs that filter for bad octets and not
   allowing application servers to write directly to the protocol
   stream.</source>
          <target state="translated">응답 분할 (일명 CRLF 주입)은 웹 사용에 대한 다양한 공격에 사용되는 일반적인 기술로, HTTP 메시지 프레이밍의 라인 기반 특성과 지속적인 연결에서 응답에 대한 요청의 순서 연결을 활용합니다.&lt;a href=&quot;#ref-Klein&quot;&gt; Klein&lt;/a&gt;]. 이 기술은 요청이 공유 캐시를 통과 할 때 특히 손상 될 수 있습니다. 응답 분할은 공격자가 요청의 일부 매개 변수 내에서 인코딩 된 데이터를 보낼 수있는 서버 (일반적으로 응용 프로그램 서버 내)의 취약점을 악용합니다.이 경우 나중에 응답의 응답 헤더 필드 내에서 디코딩 및 에코됩니다. 디코딩 된 데이터가 응답이 종료 된 것처럼 보이고 후속 응답이 시작된 경우 응답이 분할되고 명백한 두 번째 응답 내의 내용이 공격자에 의해 제어됩니다. 그런 다음 공격자는 동일한 영구 연결에서 다른 요청을하고받는 사람 (중개자 포함)이 분할의 후반부가 두 번째 요청에 대한 정식 응답이라고 믿도록 속일 수 있습니다.예를 들어, 요청 대상 내의 매개 변수는 애플리케이션 서버에 의해 읽히고 경로 재 지정 내에서 재사용되어 동일한 매개 변수가 응답의 위치 헤더 필드에 에코됩니다. 매개 변수가 응용 프로그램에서 디코딩되고 응답 필드에 배치 될 때 올바르게 인코딩되지 않은 경우 공격자는 인코딩 된 CRLF 옥텟 및 응용 프로그램의 단일 응답을 두 개 이상의 응답처럼 보이게하는 기타 콘텐츠를 보낼 수 있습니다. 응답 분할에 대한 일반적인 방어 방법은 인코딩 된 CR 및 LF처럼 보이는 데이터에 대한 요청을 필터링하는 것입니다 (예 : &quot;% 0D&quot;및 &quot;% 0A&quot;). 그러나 이는 애플리케이션 서버가 문자 세트 코드 변환, XML 엔티티 변환, base64 디코딩과 같은 모호한 데이터 변환보다는 URI 디코딩 만 수행한다고 가정합니다.sprintf 재 포맷 등보다 효과적인 완화 방법은 서버의 핵심 프로토콜 라이브러리 이외의 항목이 헤더 섹션 내에서 CR 또는 LF를 전송하지 못하게하는 것입니다. 이는 헤더 필드의 출력을 잘못된 옥텟을 필터링하고 애플리케이션을 허용하지 않는 API로 제한하는 것을 의미합니다. 프로토콜 스트림에 직접 쓸 서버.</target>
        </trans-unit>
        <trans-unit id="d4c531a6385991e6bb4b7c4878657728c7803131" translate="yes" xml:space="preserve">
          <source>Response status codes</source>
          <target state="translated">응답 상태 코드</target>
        </trans-unit>
        <trans-unit id="3de7a37046e38dd56ec505ba9650a90475b3ca79" translate="yes" xml:space="preserve">
          <source>Response status codes beginning with the digit &quot;5&quot; indicate cases in
   which the server is aware that it has erred or is incapable of
   performing the request. Except when responding to a HEAD request, the
   server SHOULD include an entity containing an explanation of the
   error situation, and whether it is a temporary or permanent
   condition. User agents SHOULD display any included entity to the
   user. These response codes are applicable to any request method.</source>
          <target state="translated">숫자 &quot;5&quot;로 시작하는 응답 상태 코드는 서버가 서버에 오류가 있거나 요청을 수행 할 수 없음을 인식하는 경우를 나타냅니다. HEAD 요청에 응답 할 때를 제외하고, 서버는 오류 상황에 대한 설명과 일시적 또는 영구 조건인지를 포함하는 엔티티를 포함해야한다. 사용자 에이전트는 포함 된 엔티티를 사용자에게 표시해야합니다. 이 응답 코드는 모든 요청 방법에 적용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="83bdd15fd3efbd39156bcb4a7d8c4cbc95551582" translate="yes" xml:space="preserve">
          <source>Response to an &lt;a href=&quot;methods/options&quot;&gt;&lt;code&gt;OPTIONS&lt;/code&gt;&lt;/a&gt; request (which is the preflight request), including sending necessary values with &lt;a href=&quot;headers/access-control-allow-methods&quot;&gt;&lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;headers/access-control-allow-headers&quot;&gt;&lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt;&lt;/a&gt; (if any additional headers are needed in order for the application to work), and, if credentials are necessary for this resource, &lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt;&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/access-control-allow-methods&quot;&gt; &lt;code&gt;Access-Control-Allow-Methods&lt;/code&gt; &lt;/a&gt; 로 필요한 값을 전송하는 것을 포함 하여 &lt;a href=&quot;methods/options&quot;&gt; &lt;code&gt;OPTIONS&lt;/code&gt; &lt;/a&gt; 요청 (사전 비행 요청) 에 대한 응답 ,&lt;a href=&quot;headers/access-control-allow-headers&quot;&gt; &lt;code&gt;Access-Control-Allow-Headers&lt;/code&gt; &lt;/a&gt; (응용 프로그램이 작동하기 위해 추가 헤더가 필요한 경우자격 증명이 자원에 필요한 경우,&lt;a href=&quot;headers/access-control-allow-credentials&quot;&gt; &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dadf3ea7de46798a782a6a436390eec73bf559b0" translate="yes" xml:space="preserve">
          <source>Response to the actual request, including handling &lt;code&gt;POST&lt;/code&gt; data, etc.</source>
          <target state="translated">&lt;code&gt;POST&lt;/code&gt; 데이터 처리 등 실제 요청에 대한 응답</target>
        </trans-unit>
        <trans-unit id="eca3a297d123fc40900d58016705e489702b5ebd" translate="yes" xml:space="preserve">
          <source>Response-only headers</source>
          <target state="translated">응답 전용 헤더</target>
        </trans-unit>
        <trans-unit id="a501282237d83ce65c51816c2ab72de3210ecadb" translate="yes" xml:space="preserve">
          <source>Response:</source>
          <target state="translated">Response:</target>
        </trans-unit>
        <trans-unit id="633f6e8b851aad01759e04e23cfe5188859a4d5b" translate="yes" xml:space="preserve">
          <source>Responses</source>
          <target state="translated">Responses</target>
        </trans-unit>
        <trans-unit id="d8af98670003f4df54578c7641a8970d7403de87" translate="yes" xml:space="preserve">
          <source>Responses consist of the following elements:</source>
          <target state="translated">응답은 다음 요소로 구성됩니다.</target>
        </trans-unit>
        <trans-unit id="3b1f5e9b4019ed86ef95e3eb735acf435207ec4e" translate="yes" xml:space="preserve">
          <source>Responses other than &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; if something suitable for use as a cache key is defined.</source>
          <target state="translated">이외의 응답 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt;캐시 키로 사용하기에 적합한 것이 정의 된 경우 GET.</target>
        </trans-unit>
        <trans-unit id="03a2ed7eea8ee322b3125e461709f17a765da78d" translate="yes" xml:space="preserve">
          <source>Restrict a site from using sensitive APIs like camera or microphone.</source>
          <target state="translated">카메라 나 마이크와 같은 민감한 API를 사용하지 않도록 사이트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="a7df26a7033a2ab83d3ca306e3a5d1318fad2e5a" translate="yes" xml:space="preserve">
          <source>Restrict access to certain URIs</source>
          <target state="translated">특정 URI에 대한 액세스 제한</target>
        </trans-unit>
        <trans-unit id="8918d7b0ef8cf023a0a02c7f4d3a7e80b8e0bd64" translate="yes" xml:space="preserve">
          <source>Restrict access to cookies</source>
          <target state="translated">Restrict access to cookies</target>
        </trans-unit>
        <trans-unit id="4117c2bf4d89b600064f4f9d06f852ac1a3ae10f" translate="yes" xml:space="preserve">
          <source>Restricting access with Apache and basic authentication</source>
          <target state="translated">Apache 및 기본 인증을 통한 액세스 제한</target>
        </trans-unit>
        <trans-unit id="461bffebbe59da668a737629925f899f93ff2412" translate="yes" xml:space="preserve">
          <source>Restricting access with nginx and basic authentication</source>
          <target state="translated">nginx 및 기본 인증을 통한 액세스 제한</target>
        </trans-unit>
        <trans-unit id="5e935b66a20bae038fe32dd13f6fc11359152943" translate="yes" xml:space="preserve">
          <source>Restricts the URLs to which a document can initiate navigation by any means, including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; (if &lt;a href=&quot;content-security-policy/form-action&quot;&gt;&lt;code&gt;form-action&lt;/code&gt;&lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt;&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt;&lt;code&gt;window.location&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt;&lt;code&gt;window.open&lt;/code&gt;&lt;/a&gt;, etc.</source>
          <target state="translated">Restricts the URLs to which a document can initiate navigation by any means, including &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; (if &lt;a href=&quot;content-security-policy/form-action&quot;&gt; &lt;code&gt;form-action&lt;/code&gt; &lt;/a&gt; is not specified), &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/a&quot;&gt; &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/location&quot;&gt; &lt;code&gt;window.location&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/open&quot;&gt; &lt;code&gt;window.open&lt;/code&gt; &lt;/a&gt;, etc.</target>
        </trans-unit>
        <trans-unit id="764a16b3f8fb29997b690d201939e38d6d70edd4" translate="yes" xml:space="preserve">
          <source>Restricts the URLs to which a document can navigate by any means (a, form, window.location, window.open, etc.)</source>
          <target state="translated">어떤 방법 으로든 문서를 탐색 할 수있는 URL을 제한합니다 (a, 양식, window.location, window.open 등).</target>
        </trans-unit>
        <trans-unit id="a6b9ea9002b18b6b31923bd6067c94ff74e5664b" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be loaded using script interfaces</source>
          <target state="translated">스크립트 인터페이스를 사용하여로드 할 수있는 URL을 제한합니다</target>
        </trans-unit>
        <trans-unit id="a088abbeea65fe12b4006ee4be76da1a0764ac75" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be used as the target of a form submissions from a given context.</source>
          <target state="translated">지정된 컨텍스트에서 양식 제출 대상으로 사용할 수있는 URL을 제한합니다.</target>
        </trans-unit>
        <trans-unit id="4222ed3b88e187751d0f547eca5261acc886b9c0" translate="yes" xml:space="preserve">
          <source>Restricts the URLs which can be used in a document's &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element.</source>
          <target state="translated">문서의 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에서 사용할 수있는 URL을 제한합니다 .</target>
        </trans-unit>
        <trans-unit id="7afcc35a5e47466a95fb1a0c4cf65338cc5b6518" translate="yes" xml:space="preserve">
          <source>Restricts the set of plugins that can be embedded into a document by limiting the types of resources which can be loaded.</source>
          <target state="translated">로드 할 수있는 자원 유형을 제한하여 문서에 임베드 할 수있는 플러그인 세트를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="2d27a52b20972eb4c36afd6691ce8615aa1344a3" translate="yes" xml:space="preserve">
          <source>Retains references to newly opened windows or tabs which either don't set COOP or which opt out of isolation by setting a COOP of &lt;code&gt;unsafe-none&lt;/code&gt;.</source>
          <target state="translated">COOP를 설정하지 않거나 COOP를 &lt;code&gt;unsafe-none&lt;/code&gt; 으로 설정하여 격리를 해제하는 새로 열린 창 또는 탭에 대한 참조를 유지합니다 .</target>
        </trans-unit>
        <trans-unit id="dedece9fd5695df933056cbe96d25f6b3069f79b" translate="yes" xml:space="preserve">
          <source>Retry-After</source>
          <target state="translated">Retry-After</target>
        </trans-unit>
        <trans-unit id="0c9f6f19959bb087b887f8153dbc882bf36b5be0" translate="yes" xml:space="preserve">
          <source>Retry-After (RFC 2616)</source>
          <target state="translated">재시도 후 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="4bbd975267207d617ce8ac55243c4e2435f8d973" translate="yes" xml:space="preserve">
          <source>Retry-After (RFC 7231)</source>
          <target state="translated">재시도 후 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="b3d51d173748120ed51dbedce115ff294ba9c89e" translate="yes" xml:space="preserve">
          <source>Return &quot;permission denied&quot; for JavaScript APIs that require user permission grants.</source>
          <target state="translated">사용자 권한 부여가 필요한 JavaScript API에 대해서는 &quot;권한 거부&quot;를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="927efd592a21c92cfe7587e9cfb7e85413562cbe" translate="yes" xml:space="preserve">
          <source>Return &lt;code&gt;false&lt;/code&gt; or error from an existing JavaScript API that provides access to feature.</source>
          <target state="translated">기능에 대한 액세스를 제공하는 기존 JavaScript API에서 &lt;code&gt;false&lt;/code&gt; 또는 오류를 리턴하십시오 .</target>
        </trans-unit>
        <trans-unit id="846e30137de34dc6b54690d1b47a21341be03ee6" translate="yes" xml:space="preserve">
          <source>Return value format</source>
          <target state="translated">반환 값 형식</target>
        </trans-unit>
        <trans-unit id="0ecdf9bf4172ac40a4c998cc081e4e01cca34349" translate="yes" xml:space="preserve">
          <source>Returning Values from Forms: multipart/form-data</source>
          <target state="translated">양식에서 값 반환 : multipart / form-data</target>
        </trans-unit>
        <trans-unit id="a5275c587d1874bd04ab3b907533a732dac13af3" translate="yes" xml:space="preserve">
          <source>Returns a string describing the configuration. The format of this string is defined in &lt;strong&gt;return value format&lt;/strong&gt; below.</source>
          <target state="translated">구성을 설명하는 문자열을 반환합니다. 이 문자열의 형식은 아래 &lt;strong&gt;반환 값 형식으로&lt;/strong&gt; 정의 됩니다.</target>
        </trans-unit>
        <trans-unit id="779f1a52816d71bc238af2dd263cf807ba014f89" translate="yes" xml:space="preserve">
          <source>Returns the number (integer) of DNS domain levels (number of dots) in the hostname.</source>
          <target state="translated">호스트 이름에서 DNS 도메인 수준 (점 수)의 수 (정수)를 반환합니다.</target>
        </trans-unit>
        <trans-unit id="796056bd8233f1877d339efcb4a7fa1c33b0b3f3" translate="yes" xml:space="preserve">
          <source>Returns the server IP address of the machine Firefox is running on, as a string in the dot-separated integer format.</source>
          <target state="translated">Firefox가 실행중인 시스템의 서버 IP 주소를 점으로 구분 된 정수 형식의 문자열로 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="bfcce7002a9eb058fd0c082f413c844164d4b026" translate="yes" xml:space="preserve">
          <source>Returns true if and only if the domain of hostname matches.</source>
          <target state="translated">호스트 이름 도메인이 일치하는 경우에만 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="6b72b7530ef6814ea7c835506c7a8c08546f1ec7" translate="yes" xml:space="preserve">
          <source>Returns true if the string matches the specified shell expression.</source>
          <target state="translated">문자열이 지정된 쉘 표현식과 일치하면 true를 리턴합니다.</target>
        </trans-unit>
        <trans-unit id="9249ca2743c193852a67d54d8e0ccd8dc000dc23" translate="yes" xml:space="preserve">
          <source>Revalidation Failed</source>
          <target state="translated">재확인 실패</target>
        </trans-unit>
        <trans-unit id="4129a88770ac061fd8f7b04f0aaf90217987ad97" translate="yes" xml:space="preserve">
          <source>Revalidation and reloading</source>
          <target state="translated">재확인 및 재로드</target>
        </trans-unit>
        <trans-unit id="df1c8fa3f601e8fda9ea5b4f0aa8ffdeb239e94f" translate="yes" xml:space="preserve">
          <source>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the &quot;&lt;code&gt;Cache-Control: must-revalidate&lt;/code&gt;&quot; header. Another factor is the cache validation preferences in the &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; preferences panel. There is an option to force a validation each time a document is loaded.</source>
          <target state="translated">Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the &quot; &lt;code&gt;Cache-Control: must-revalidate&lt;/code&gt; &quot; header. Another factor is the cache validation preferences in the &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; preferences panel. There is an option to force a validation each time a document is loaded.</target>
        </trans-unit>
        <trans-unit id="e6cc272c56bbafbde0f3dbd9f6482ab1d74f3f7f" translate="yes" xml:space="preserve">
          <source>Revalidation is triggered when the user presses the reload button. It is also triggered under normal browsing if the cached response includes the &quot;&lt;code&gt;Cache-control: must-revalidate&lt;/code&gt;&quot; header. Another factor is the cache validation preferences in the &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; preferences panel. There is an option to force a validation each time a document is loaded.</source>
          <target state="translated">재확인은 사용자가 다시로드 버튼을 누르면 트리거됩니다. 캐시 된 응답에 &quot; &lt;code&gt;Cache-control: must-revalidate&lt;/code&gt; &quot;헤더가 포함 된 경우 일반 브라우징에서도 트리거됩니다 . 또 다른 요인은 &lt;code&gt;Advanced-&amp;gt;Cache&lt;/code&gt; 환경 설정 패널 의 캐시 유효성 검증 환경 설정입니다 . 문서를로드 할 때마다 유효성을 검사하는 옵션이 있습니다.</target>
        </trans-unit>
        <trans-unit id="4c78cb0809c7ea82ab0ddb940bd222d197180540" translate="yes" xml:space="preserve">
          <source>Reverse proxies</source>
          <target state="translated">리버스 프록시</target>
        </trans-unit>
        <trans-unit id="f23dd650ab0a4fd135ac0102e4263dfefabf8c25" translate="yes" xml:space="preserve">
          <source>Revved resources</source>
          <target state="translated">밝혀진 자원</target>
        </trans-unit>
        <trans-unit id="c53ad24c321bdfc1ea4aa408ce3ddb04feb1fadd" translate="yes" xml:space="preserve">
          <source>Rich Text Format (RTF)</source>
          <target state="translated">서식있는 텍스트 (RTF)</target>
        </trans-unit>
        <trans-unit id="6e119a5751c88c7d53ad4f9a517a2b4fe5bf070c" translate="yes" xml:space="preserve">
          <source>Right after sending the &lt;code&gt;101&lt;/code&gt; status code, an eventual handshake for the new protocol happens, if the new protocol requires it, then the server sends the answer requested for the original request (the one that included the &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; header), following the new protocol rules.</source>
          <target state="translated">&lt;code&gt;101&lt;/code&gt; 상태 코드를 보낸 직후 , 새 프로토콜에 필요한 경우 새로운 프로토콜에 대한 최종 핸드 셰이크가 발생하고 서버는 새로운 요청에 따라 원래 요청 ( &lt;code&gt;&quot;Upgrade&quot;&lt;/code&gt; 헤더 가 포함 된 요청)에 대해 요청 된 응답을 보냅니다. 프로토콜 규칙.</target>
        </trans-unit>
        <trans-unit id="203ee3287248c92b0df850ac6b3eaa45b58ee5e9" translate="yes" xml:space="preserve">
          <source>Right after sending the &lt;code&gt;101&lt;/code&gt; status code, the server can begin speaking the new protocol, performing any additional protocol-specific handshakes as necessary. Effectively, the connection becomes a two-way pipe as soon as the upgraded response is complete, and the request that initiated the upgrade can be completed over the new protocol.</source>
          <target state="translated">Right after sending the &lt;code&gt;101&lt;/code&gt; status code, the server can begin speaking the new protocol, performing any additional protocol-specific handshakes as necessary. Effectively, the connection becomes a two-way pipe as soon as the upgraded response is complete, and the request that initiated the upgrade can be completed over the new protocol.</target>
        </trans-unit>
        <trans-unit id="e01cad63d1dd1ba3037d248a230a0edc94073240" translate="yes" xml:space="preserve">
          <source>Root CAs manually added to the trust store override and suppress &lt;code&gt;Expect-CT&lt;/code&gt; reports/enforcement.</source>
          <target state="translated">Root CAs manually added to the trust store override and suppress &lt;code&gt;Expect-CT&lt;/code&gt; reports/enforcement.</target>
        </trans-unit>
        <trans-unit id="4cb54ee36d7572d85675120ff80c6f572b6e22f0" translate="yes" xml:space="preserve">
          <source>Roy T. Fielding
   Information and Computer Science
   University of California, Irvine
   Irvine, CA 92697-3425, USA

   Fax: +1 (949) 824-1715
   EMail: fielding@ics.uci.edu


   James Gettys
   World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: jg@w3.org


   Jeffrey C. Mogul
   Western Research Laboratory
   Compaq Computer Corporation
   250 University Avenue
   Palo Alto, California, 94305, USA

   EMail: mogul@wrl.dec.com


   Henrik Frystyk Nielsen
   World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: frystyk@w3.org


   Larry Masinter
   Xerox Corporation
   3333 Coyote Hill Road
   Palo Alto, CA 94034, USA

   EMail: masinter@parc.xerox.com 

   Paul J. Leach
   Microsoft Corporation
   1 Microsoft Way
   Redmond, WA 98052, USA

   EMail: paulle@microsoft.com


   Tim Berners-Lee
   Director, World Wide Web Consortium
   MIT Laboratory for Computer Science
   545 Technology Square
   Cambridge, MA 02139, USA

   Fax: +1 (617) 258 8682
   EMail: timbl@w3.org</source>
          <target state="translated">Roy T. Fielding Information and Computer Science University of California, Irvine Irvine, CA 92697-3425, USA 팩스 : +1 (949) 824-1715 이메일 : fielding@ics.uci.edu James Gettys 월드 와이드 웹 컨소시엄 MIT 컴퓨터 연구소 Science 545 Technology Square Cambridge, MA 02139, USA 팩스 : +1 (617) 258 8682 이메일 : jg@w3.org Jeffrey C. Mogul Western Research Laboratory Compaq Computer Corporation 250 University Avenue Palo Alto, California, 94305, USA 이메일 : mogul @ wrl.dec.com Henrik Frystyk Nielsen 컴퓨터 과학을위한 월드 와이드 웹 컨소시엄 MIT 연구소 545 Technology Square Cambridge, MA 02139, USA 팩스 : +1 (617) 258 8682 이메일 : frystyk@w3.org Larry Masinter Xerox Corporation 3333 Coyote Hill Palo Alto, CA 94034, USA 이메일 : masinter @ parc.xerox.com Paul J. Leach Microsoft Corporation 1 Microsoft Way Redmond, WA 98052, USA 전자 메일 : paulle@microsoft.com Tim Berners-Lee, 컴퓨터 과학을위한 월드 와이드 웹 컨소시엄 MIT 연구소 책임자 545 Technology Square Cambridge, MA 02139, USA 팩스 : +1 (617) 258 8682 이메일 : timbl@w3.org</target>
        </trans-unit>
        <trans-unit id="155381cbc7c74d0a3b58b7dec055fb15f9da1321" translate="yes" xml:space="preserve">
          <source>Ruby on Rails</source>
          <target state="translated">루비 온 레일즈</target>
        </trans-unit>
        <trans-unit id="78e1790e29a5541b6d02348fc3f45f18445709f4" translate="yes" xml:space="preserve">
          <source>Rule</source>
          <target state="translated">Rule</target>
        </trans-unit>
        <trans-unit id="6e5110b99817ab97188b2fb5c0432e88694c5cb6" translate="yes" xml:space="preserve">
          <source>SAMEORIGIN</source>
          <target state="translated">SAMEORIGIN</target>
        </trans-unit>
        <trans-unit id="051b852d3e1434bf269741e55246b092c01b6d34" translate="yes" xml:space="preserve">
          <source>SOCKS &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">양말 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="c1b9bb67b06df044e5b52d49df71e5762865e669" translate="yes" xml:space="preserve">
          <source>SOCKS4 &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS4 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="4d498327ded8eb1659cbddc3b98307c46f04e966" translate="yes" xml:space="preserve">
          <source>SOCKS5 &lt;em&gt;host:port&lt;/em&gt;</source>
          <target state="translated">SOCKS5 &lt;em&gt;호스트 : 포트&lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="50fce6d02899850101b1865a947b45128c5350eb" translate="yes" xml:space="preserve">
          <source>SVG</source>
          <target state="translated">SVG</target>
        </trans-unit>
        <trans-unit id="b8c3907fd9fbfd04403be1ea246413102cae5626" translate="yes" xml:space="preserve">
          <source>SVG images (vector images)</source>
          <target state="translated">SVG 이미지 (벡터 이미지)</target>
        </trans-unit>
        <trans-unit id="424dd4565e3b50faee0307759cb623a23456af2c" translate="yes" xml:space="preserve">
          <source>Safari</source>
          <target state="translated">Safari</target>
        </trans-unit>
        <trans-unit id="387d8081b96a43162142a7aed8adc8c5f1c9d7ea" translate="yes" xml:space="preserve">
          <source>Safari 13 on macOS 10.14 (Mojave), treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt;. This is fixed in version 10.15 (Catalina) and later.</source>
          <target state="translated">Safari 13 on macOS 10.14 (Mojave), treats &lt;code&gt;SameSite=None&lt;/code&gt; and invalid values as &lt;code&gt;Strict&lt;/code&gt; . This is fixed in version 10.15 (Catalina) and later.</target>
        </trans-unit>
        <trans-unit id="23c032140d272311e29c5ca2687a75ad09e37d16" translate="yes" xml:space="preserve">
          <source>Safari 5</source>
          <target state="translated">사파리 5</target>
        </trans-unit>
        <trans-unit id="cd29382cb0678144991e40cb67f0f26309c178fe" translate="yes" xml:space="preserve">
          <source>Safari UA string</source>
          <target state="translated">사파리 UA 문자열</target>
        </trans-unit>
        <trans-unit id="914ddefb3bd0af36387638e5098a5bfccd9d2330" translate="yes" xml:space="preserve">
          <source>Safari gives two version number, one technical in the Safari/xyz token, one user-friendly in a Version/xyz token</source>
          <target state="translated">Safari는 Safari / xyz 토큰의 기술 버전과 Version / xyz 토큰의 사용자 친화적 버전 두 가지 버전 번호를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="d2132f3b26f679d8b13ddd4fd2c4b863d1dc41f1" translate="yes" xml:space="preserve">
          <source>Safari gives two version numbers: one technical in the Safari/xyz token, and one user-friendly in a Version/xyz token</source>
          <target state="translated">Safari gives two version numbers: one technical in the Safari/xyz token, and one user-friendly in a Version/xyz token</target>
        </trans-unit>
        <trans-unit id="58150bf4bc81cb0b79b4789ca1d37338441d8ddb" translate="yes" xml:space="preserve">
          <source>Safari on iOS</source>
          <target state="translated">iOS의 Safari</target>
        </trans-unit>
        <trans-unit id="3baae9bdafb1777b0a8c4b42ca014a3e672bf89a" translate="yes" xml:space="preserve">
          <source>Safari, Chrome</source>
          <target state="translated">사파리, 크롬</target>
        </trans-unit>
        <trans-unit id="56f9a9116285e2e1d5aefe02e9bf2490ed9cc219" translate="yes" xml:space="preserve">
          <source>Safari/xyz</source>
          <target state="translated">Safari/xyz</target>
        </trans-unit>
        <trans-unit id="9525ae1781bb71fc767a9bab4b6f299ac5cc8c5d" translate="yes" xml:space="preserve">
          <source>Safe</source>
          <target state="translated">Safe</target>
        </trans-unit>
        <trans-unit id="63a5b93ecc868de623f240bfbb9e61bbbc4b6c6f" translate="yes" xml:space="preserve">
          <source>Safe Methods (RFC 7231)</source>
          <target state="translated">안전한 방법 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="5a9e598295fe6016bddfb7db200367d70f068e41" translate="yes" xml:space="preserve">
          <source>Same as 199, but indicating a persistent warning</source>
          <target state="translated">199와 동일하지만 지속적인 경고 표시</target>
        </trans-unit>
        <trans-unit id="6fd24bb83d525c0587904be6d9063b5b2f9040cb" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;Cache-Control: no-cache&lt;/code&gt;. Forces caches to submit the request to the origin server for validation before releasing a cached copy.</source>
          <target state="translated">&lt;code&gt;Cache-Control: no-cache&lt;/code&gt; 와 동일 합니다 . 캐시 된 사본을 릴리스하기 전에 캐시가 유효성 검증을 위해 요청을 오리진 서버에 제출하도록합니다.</target>
        </trans-unit>
        <trans-unit id="b26302dd3a3fa55489b0e7f786324aa2ecf9cc5c" translate="yes" xml:space="preserve">
          <source>Same as &lt;code&gt;must-revalidate&lt;/code&gt;, but it only applies to shared caches (e.g., proxies) and is ignored by a private cache.</source>
          <target state="translated">&lt;code&gt;must-revalidate&lt;/code&gt; 와 동일 하지만 공유 캐시 (예 : 프록시)에만 적용되며 개인 캐시에서는 무시됩니다.</target>
        </trans-unit>
        <trans-unit id="987997d0d6bfde96290ace26118012807c52f8f3" translate="yes" xml:space="preserve">
          <source>Same as above, but if both proxies go down, automatically start making direct connections. (In the first example above, Netscape will ask user confirmation about making direct connections; in this case, there is no user intervention.)</source>
          <target state="translated">위와 동일하지만 두 프록시가 모두 다운되면 자동으로 직접 연결을 시작합니다. (위의 첫 번째 예에서 Netscape는 사용자에게 직접 연결에 대한 확인을 요청합니다.이 경우 사용자 개입이 없습니다.)</target>
        </trans-unit>
        <trans-unit id="ccf511a0061f086d955d97477343668d80c1a041" translate="yes" xml:space="preserve">
          <source>Same-Site Cookies</source>
          <target state="translated">동일 사이트 쿠키</target>
        </trans-unit>
        <trans-unit id="bee25962095abc626fad400750f39f70602bb29d" translate="yes" xml:space="preserve">
          <source>Same-origin policy</source>
          <target state="translated">동일 출처 정책</target>
        </trans-unit>
        <trans-unit id="15119730c37e094987a0f56c39055afbf665b5f7" translate="yes" xml:space="preserve">
          <source>SameSite attribute</source>
          <target state="translated">SameSite attribute</target>
        </trans-unit>
        <trans-unit id="7dccf8be165cd7e805358a12ead73def5ccd7ead" translate="yes" xml:space="preserve">
          <source>SameSite=Lax Optional</source>
          <target state="translated">SameSite = Lax 옵션</target>
        </trans-unit>
        <trans-unit id="0cbd84ce60ee0f574919dfa4e0c7b76c8a94f8da" translate="yes" xml:space="preserve">
          <source>SameSite=Strict</source>
          <target state="translated">SameSite=Strict</target>
        </trans-unit>
        <trans-unit id="873f5bd8ca409a7986de0e5309bd3885c3eab798" translate="yes" xml:space="preserve">
          <source>Sample violation report</source>
          <target state="translated">샘플 위반 보고서</target>
        </trans-unit>
        <trans-unit id="da8abd7408a5aa336cbde8d4920f8da276e7b302" translate="yes" xml:space="preserve">
          <source>Samsung Internet</source>
          <target state="translated">삼성 인터넷</target>
        </trans-unit>
        <trans-unit id="ba9393120560f8ad723cdfd1c6bdbda548228ec6" translate="yes" xml:space="preserve">
          <source>Save-Data</source>
          <target state="translated">Save-Data</target>
        </trans-unit>
        <trans-unit id="3a68f8a275363cb5dc0e990d5ee7f023559d8d8e" translate="yes" xml:space="preserve">
          <source>Say you have a &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&amp;lt;form&amp;gt;&lt;/a&gt;&lt;/code&gt; for sending money to another user of a site.</source>
          <target state="translated">사이트의 다른 사용자에게 돈을 보내기위한 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&amp;lt;form&amp;gt;&lt;/a&gt;&lt;/code&gt; 이 있다고 가정 하십시오.</target>
        </trans-unit>
        <trans-unit id="d56d9c1ccf0bc0f33130fff7850c2e5871fca835" translate="yes" xml:space="preserve">
          <source>Say you're creating a new blog post through a site's API:</source>
          <target state="translated">사이트의 API를 통해 새 블로그 게시물을 작성한다고 가정 해보십시오.</target>
        </trans-unit>
        <trans-unit id="4604d176d51353df986205d207f767ee691f148b" translate="yes" xml:space="preserve">
          <source>Scalable Vector Graphics</source>
          <target state="translated">확장 가능한 벡터 그래픽</target>
        </trans-unit>
        <trans-unit id="16e6004376e3926149328610370037caae151443" translate="yes" xml:space="preserve">
          <source>Scalable Vector Graphics (SVG)</source>
          <target state="translated">SVG (Scalable Vector Graphics)</target>
        </trans-unit>
        <trans-unit id="990897a59f17d4deac662966307b456e376c6c6d" translate="yes" xml:space="preserve">
          <source>Scheme</source>
          <target state="translated">Scheme</target>
        </trans-unit>
        <trans-unit id="59731c699d056f30b458a35ac2e1c7b49f928594" translate="yes" xml:space="preserve">
          <source>Scheme or protocol</source>
          <target state="translated">체계 또는 프로토콜</target>
        </trans-unit>
        <trans-unit id="94231fed0cda7afbf08bbfc9ad6ef2692cc59645" translate="yes" xml:space="preserve">
          <source>Scope of cookies</source>
          <target state="translated">쿠키의 범위</target>
        </trans-unit>
        <trans-unit id="52492f6375ce5f6a91468129578923abaccf4791" translate="yes" xml:space="preserve">
          <source>Screen Capture</source>
          <target state="translated">화면 캡처</target>
        </trans-unit>
        <trans-unit id="801ee3d2eb0018844693c67ff1f4751efaf76985" translate="yes" xml:space="preserve">
          <source>Screen Capture API</source>
          <target state="translated">화면 캡처 API</target>
        </trans-unit>
        <trans-unit id="43ebc3ac9800c963c1898f7d1b3ebfa25bb70fe5" translate="yes" xml:space="preserve">
          <source>Screen Wake Lock API</source>
          <target state="translated">화면 깨우기 잠금 API</target>
        </trans-unit>
        <trans-unit id="e4fcfa3d448d1651966e714eb22780b10c65cafa" translate="yes" xml:space="preserve">
          <source>Scripts can programatically query information about the feature policy via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FeaturePolicy&quot;&gt;&lt;code&gt;FeaturePolicy&lt;/code&gt;&lt;/a&gt; object located at either &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/featurePolicy&quot;&gt;&lt;code&gt;Document.featurePolicy&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/featurePolicy&quot;&gt;&lt;code&gt;HTMLIFrameElement.featurePolicy&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Scripts can programatically query information about the feature policy via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/FeaturePolicy&quot;&gt; &lt;code&gt;FeaturePolicy&lt;/code&gt; &lt;/a&gt; object located at either &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Document/featurePolicy&quot;&gt; &lt;code&gt;Document.featurePolicy&lt;/code&gt; &lt;/a&gt; or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/HTMLIFrameElement/featurePolicy&quot;&gt; &lt;code&gt;HTMLIFrameElement.featurePolicy&lt;/code&gt; &lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="6c3ca47c0105fab811cf07258c4b16efcfe40f19" translate="yes" xml:space="preserve">
          <source>Scripts inherit the policy of their browsing context, regardless of their origin. That means that top-level scripts inherit the policy from the main document.</source>
          <target state="translated">스크립트는 출처에 관계없이 탐색 컨텍스트의 정책을 상속합니다. 즉, 최상위 스크립트는 기본 문서에서 정책을 상속합니다.</target>
        </trans-unit>
        <trans-unit id="dfc1b60d94fdbf10534406b7762e8b6f2bae9145" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Linux</source>
          <target state="translated">Linux의 SeaMonkey</target>
        </trans-unit>
        <trans-unit id="1a3b80710cd0d8991477261291ca25204ce328b9" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Mac</source>
          <target state="translated">Mac의 SeaMonkey</target>
        </trans-unit>
        <trans-unit id="9c623420fdda2ac570aef52b55489d15c0471e7a" translate="yes" xml:space="preserve">
          <source>SeaMonkey on Windows</source>
          <target state="translated">Windows의 SeaMonkey</target>
        </trans-unit>
        <trans-unit id="011fd1651703d76cf60df261ca3f1fef579b6047" translate="yes" xml:space="preserve">
          <source>Seamonkey</source>
          <target state="translated">Seamonkey</target>
        </trans-unit>
        <trans-unit id="56f35b4502f3ec45082c5dc335c7795a1a7c26e3" translate="yes" xml:space="preserve">
          <source>Seamonkey/xyz</source>
          <target state="translated">Seamonkey/xyz</target>
        </trans-unit>
        <trans-unit id="1a0d5d5ec95e9687f95d15318308edd8b34ce1fb" translate="yes" xml:space="preserve">
          <source>Search engine robots and other crawlers don't memorize the new, temporary URL. Temporary redirections are also used when creating, updating, or deleting resources, to show temporary progress pages.</source>
          <target state="translated">Search engine robots and other crawlers don't memorize the new, temporary URL. Temporary redirections are also used when creating, updating, or deleting resources, to show temporary progress pages.</target>
        </trans-unit>
        <trans-unit id="c77d21997bfbb2c414072d6c0ad8a84fa1f293ce" translate="yes" xml:space="preserve">
          <source>Sec-Fetch-Dest</source>
          <target state="translated">Sec-Fetch-Dest</target>
        </trans-unit>
        <trans-unit id="68f7ead7902dec3d0367800836f39191c6ae9dda" translate="yes" xml:space="preserve">
          <source>Sec-Fetch-Mode</source>
          <target state="translated">Sec-Fetch-Mode</target>
        </trans-unit>
        <trans-unit id="3f74f3409434032ef461450f286bf054cf653a90" translate="yes" xml:space="preserve">
          <source>Sec-Fetch-Site</source>
          <target state="translated">Sec-Fetch-Site</target>
        </trans-unit>
        <trans-unit id="3722e9b4bc5e52642dd15f2de5f40d916d50b717" translate="yes" xml:space="preserve">
          <source>Sec-Fetch-User</source>
          <target state="translated">Sec-Fetch-User</target>
        </trans-unit>
        <trans-unit id="7eca79871c6f6fc4c47ae676de3882a8679ff650" translate="yes" xml:space="preserve">
          <source>Sec-WebSocket-Accept</source>
          <target state="translated">Sec-WebSocket-Accept</target>
        </trans-unit>
        <trans-unit id="bb412cf0745496a29d28a7ea9c242da8e4682209" translate="yes" xml:space="preserve">
          <source>Seconds from 0 to 59.</source>
          <target state="translated">0에서 59까지의 초</target>
        </trans-unit>
        <trans-unit id="306c19b887ddc8fe31f3651e18b08dc05bd8f651" translate="yes" xml:space="preserve">
          <source>Sections &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt;, &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt;, &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt;, &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt;, and &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; define various status
   codes used in Multi-Status responses.  This specification does not
   define the meaning of other status codes that could appear in these
   responses.</source>
          <target state="translated">섹션 &lt;a href=&quot;#section-9.2.1&quot;&gt;9.2.1&lt;/a&gt; , &lt;a href=&quot;#section-9.1.2&quot;&gt;9.1.2&lt;/a&gt; , &lt;a href=&quot;#section-9.6.1&quot;&gt;9.6.1&lt;/a&gt; , &lt;a href=&quot;#section-9.8.3&quot;&gt;9.8.3&lt;/a&gt; 및 &lt;a href=&quot;#section-9.9.2&quot;&gt;9.9.2&lt;/a&gt; 는 다중 상태 응답에 사용되는 다양한 상태 코드를 정의합니다. 이 사양에서는 이러한 응답에 나타날 수있는 다른 상태 코드의 의미를 정의하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="337cbd0bcbed8973159ebf2f991fe72b8939d1af" translate="yes" xml:space="preserve">
          <source>Secure Optional</source>
          <target state="translated">안전한 선택</target>
        </trans-unit>
        <trans-unit id="b506ddb82a08407cd1fd3be6e6ac4aedfd2cc08e" translate="yes" xml:space="preserve">
          <source>Secure shell</source>
          <target state="translated">보안 쉘</target>
        </trans-unit>
        <trans-unit id="10f90a995bf8c302b255a7f48b587d2f56e50772" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable Microphone and Geolocation APIs in its application. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc. wants to disable Microphone and Geolocation APIs in its application. It can do so by delivering the following HTTP response header to define a feature policy:</target>
        </trans-unit>
        <trans-unit id="51fa0a986148790e5e39c3246996e0d27d164ab3" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable Vibration and Geolocation APIs in their application. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.는 애플리케이션에서 진동 및 지리적 위치 API를 비활성화하려고합니다. 기능 정책을 정의하기 위해 다음 HTTP 응답 헤더를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="be1ba146ec015129cdc87a6b6cda0c810fea5fc6" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable the Fullscreen API within all browsing contexts except for its own origin and those whose origin is &lt;code&gt;https://example.com&lt;/code&gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.는 자체 출처 및 출처가 &lt;code&gt;https://example.com&lt;/code&gt; 인 컨텍스트를 제외한 모든 브라우징 컨텍스트에서 전체 화면 API를 비활성화하려고합니다 . 기능 정책을 정의하기 위해 다음 HTTP 응답 헤더를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="a159b732490e876325bf141a42c816091555db2e" translate="yes" xml:space="preserve">
          <source>SecureCorp Inc. wants to disable the Geolocation API within all browsing contexts except for its own origin and those whose origin is &lt;code&gt;https://example.com&lt;/code&gt;. It can do so by delivering the following HTTP response header to define a feature policy:</source>
          <target state="translated">SecureCorp Inc.는 자체 출처 및 출처가 &lt;code&gt;https://example.com&lt;/code&gt; 인 컨텍스트를 제외한 모든 브라우징 컨텍스트 내에서 Geolocation API를 비활성화하려고합니다 . 기능 정책을 정의하기 위해 다음 HTTP 응답 헤더를 제공하면됩니다.</target>
        </trans-unit>
        <trans-unit id="f25ce1b8a399bd8621a57427a20039b4b13935db" translate="yes" xml:space="preserve">
          <source>Security</source>
          <target state="translated">Security</target>
        </trans-unit>
        <trans-unit id="1dfc995fa62a8e188eccdd322ddb4edbdbfea306" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 2616)</source>
          <target state="translated">보안 고려 사항 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="3b8fdb84152d7745f62dd2987944fe2bde984275" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7230)</source>
          <target state="translated">보안 고려 사항 (RFC 7230)</target>
        </trans-unit>
        <trans-unit id="45b64918d523e29e2ec840fd10d70a111ad02104" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7231)</source>
          <target state="translated">보안 고려 사항 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="d16e94f2024ae95fb74f63d4a34619f9aa28b96f" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7232)</source>
          <target state="translated">보안 고려 사항 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="ed09df6c082dc378c2be105d88f0f7c6b27744b3" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7233)</source>
          <target state="translated">보안 고려 사항 (RFC 7233)</target>
        </trans-unit>
        <trans-unit id="634a5436cba76ad187076b3442bdc2183b8a02c5" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7234)</source>
          <target state="translated">보안 고려 사항 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a2965824c87409925878841116315b190450c0c6" translate="yes" xml:space="preserve">
          <source>Security Considerations (RFC 7235)</source>
          <target state="translated">보안 고려 사항 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="0b0a72a60bc2726643d7f43f73beedf4d9eedacc" translate="yes" xml:space="preserve">
          <source>Security issues</source>
          <target state="translated">보안 문제들</target>
        </trans-unit>
        <trans-unit id="45b4812d50d88e88b1448bd0da22f03283ec4833" translate="yes" xml:space="preserve">
          <source>Security of basic authentication</source>
          <target state="translated">기본 인증의 보안</target>
        </trans-unit>
        <trans-unit id="1adc2d2821ca3f28bdeda8b691ca76c312913404" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;#Preloading_Strict_Transport_Security&quot;&gt;Preloading Strict Transport Security&lt;/a&gt; for details. Not part of the specification.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;#Preloading_Strict_Transport_Security&quot;&gt;엄격한 전송 보안 사전로드&lt;/a&gt; 를 참조하십시오. 사양의 일부가 아닙니다.</target>
        </trans-unit>
        <trans-unit id="ef97e870c01e8eaff7ad366cfd23acefa50ec984" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; for more information and examples.</source>
          <target state="translated">자세한 &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 과 예는 Content-Security-Policy-Report-Only 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="412e3d00c269ec4cc7cc918810af03116020d0cd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/fiddler/archive/2011/02/10/fiddler-is-better-with-internet-explorer-9.aspx&quot;&gt;Fiddler is better with Internet Explorer 9 (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;http://blogs.msdn.com/b/fiddler/archive/2011/02/10/fiddler-is-better-with-internet-explorer-9.aspx&quot;&gt;피들러는 인터넷 익스플로러 9 (IEInternals 'MSDN 블로그)와 더&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e8eecda09ccd7acf7d1d416036629474295d0816" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE 및 수락 헤더 (IEInternals의 MSDN 블로그)를&lt;/a&gt; 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="99877507a4f0dfd21502cd193c8da53cfbacbaa8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://blogs.msdn.com/b/ieinternals/archive/2009/07/01/ie-and-the-accept-header.aspx&quot;&gt;IE 및 Accept Header (IEInternals의 MSDN 블로그)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="51ff2f1ca438f05f13a6e4821ab222008067c937" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html&quot;&gt;AWS docs&lt;/a&gt;</source>
          <target state="translated">See &lt;a href=&quot;http://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-auth-using-authorization-header.html&quot;&gt;AWS docs&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="71f12e2140ada9e4648ccf95079dbf16c469780e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;http://feature-policy-demos.appspot.com/&quot;&gt;Feature Policy Demos&lt;/a&gt; for example usage of many policies.</source>
          <target state="translated">여러 정책의 사용 예는 &lt;a href=&quot;http://feature-policy-demos.appspot.com/&quot;&gt;기능 정책 데모&lt;/a&gt; 를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="8c7daa470035fb38b92a42a6527e06b374c583b4" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1045899&quot;&gt;bug 1045899&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1045899&quot;&gt;버그 1045899를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f53727915d1a1596e99008ed6acb77d2dffba29b" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1091176&quot;&gt;bug 1091176&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1091176&quot;&gt;버그 1091176을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="d2366d6aff36b6ca45b9473d29a4cbd2a60c64bd" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1091177&quot;&gt;bug 1091177&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/1091177&quot;&gt;버그 1091177을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="318d2bb91bfdc58722dc4a7256e4271421ef8e93" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1343950&quot;&gt;bug 1343950&lt;/a&gt;.</source>
          <target state="translated">See &lt;a href=&quot;https://bugzil.la/1343950&quot;&gt;bug 1343950&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="902701fdeea5da8c62c83a2049c53fd96838fbe5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1457204&quot;&gt;bug 1457204&lt;/a&gt;.</source>
          <target state="translated">See &lt;a href=&quot;https://bugzil.la/1457204&quot;&gt;bug 1457204&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="87daf564ee99134b1171922777cd6d3e1630eccb" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1529337&quot;&gt;bug 1529337&lt;/a&gt;.</source>
          <target state="translated">See &lt;a href=&quot;https://bugzil.la/1529337&quot;&gt;bug 1529337&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="476321e1a8bf06a66c253b2ca2611ab0f7550036" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/1529338&quot;&gt;bug 1529338&lt;/a&gt;.</source>
          <target state="translated">See &lt;a href=&quot;https://bugzil.la/1529338&quot;&gt;bug 1529338&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="c90dfb9eb96a4f291cdf4c61516336af7ea3f56c" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzil.la/230260&quot;&gt;bug 230260&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://bugzil.la/230260&quot;&gt;버그 230260을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="34a15d1f8d3edecfef3664e49f7ade5b2cde8cc0" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1158011&quot;&gt;bug 1158011&lt;/a&gt; for implementation status in Firefox.</source>
          <target state="translated">Firefox의 구현 상태는 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1158011&quot;&gt;버그 1158011&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="9389f0b53643699ff8b3d81c472dfa931ebda59e" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;bug 170789&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;버그 170789&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="4c022826199be858adbb57b661f330364fb2d979" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;bug 170789&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/layout/style/Loader.cpp#l1548&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=170789&quot;&gt;버그 170789 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/layout/style/Loader.cpp#l1548&quot;&gt;소스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="828f60dc446fd652055bcdb734c92c3074411fad" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;bug 489071&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLAudioElement.cpp#l81&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;버그 489071 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLAudioElement.cpp#l81&quot;&gt;소스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="03fd2bfeff3aff3c7b402bd3707da7d160456f52" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;bug 489071&lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLVideoElement.cpp#l136&quot;&gt;source&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=489071&quot;&gt;버그 489071 &lt;/a&gt;&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/file/tip/dom/html/HTMLVideoElement.cpp#l136&quot;&gt;소스&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="8ea6c6e1adea411a07c2320171cae96d403fec24" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://crbug.com/801561&quot;&gt;bug 801561&lt;/a&gt;.</source>
          <target state="translated">See &lt;a href=&quot;https://crbug.com/801561&quot;&gt;bug 801561&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="1b575def278021b7035d974c192a9dc908681908" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://crbug.com/898503&quot;&gt;bug 898503&lt;/a&gt;.</source>
          <target state="translated">See &lt;a href=&quot;https://crbug.com/898503&quot;&gt;bug 898503&lt;/a&gt;.</target>
        </trans-unit>
        <trans-unit id="395cd81c81660b7de954f329745ea35187280967" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/fiddler/fiddler-and-the-ie9-release-candidate&quot;&gt;Fiddler is better with Internet Explorer 9 (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/fiddler/fiddler-and-the-ie9-release-candidate&quot;&gt;피들러는 인터넷 익스플로러 9 (IEInternals 'MSDN 블로그)와 더&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3af50720c1d91d4b3c6841644aebf66d7089956a" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ieinternals/ie-and-the-accept-header&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;</source>
          <target state="translated">참조 &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ieinternals/ie-and-the-accept-header&quot;&gt;IE와 수락 헤더 (IEInternals 'MSDN 블로그)&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="664ccabb23690aee9178706eae0a0c86aa28b4c8" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ieinternals/ie-and-the-accept-header&quot;&gt;IE and the Accept Header (IEInternals' MSDN blog)&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://docs.microsoft.com/en-us/archive/blogs/ieinternals/ie-and-the-accept-header&quot;&gt;IE 및 Accept 헤더 (IEInternals의 MSDN 블로그)를&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="58088fac9fc484833ce2100e814b5988abb5c6b1" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://infosec.mozilla.org/guidelines/web_security#Examples_5&quot;&gt;Mozilla Web Security Guidelines&lt;/a&gt; for more examples.</source>
          <target state="translated">더 많은 예제는 &lt;a href=&quot;https://infosec.mozilla.org/guidelines/web_security#Examples_5&quot;&gt;Mozilla 웹 보안 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="dc498c10fa74da481f3412943c8a08f7e748c919" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc6750&quot;&gt;RFC 6750&lt;/a&gt;, bearer tokens to access OAuth 2.0-protected resources</source>
          <target state="translated">OAuth 2.0으로 보호 된 리소스에 액세스하려면 &lt;a href=&quot;https://tools.ietf.org/html/rfc6750&quot;&gt;RFC 6750&lt;/a&gt; , Bearer 토큰을 참조하세요.</target>
        </trans-unit>
        <trans-unit id="444cfb8c4f30e29f1714c2f9e4bf5ebdaa5c09ca" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;Section&amp;nbsp;10 of [RFC7230]&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-10&quot;&gt;[RFC7230]의 섹션 10을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="a90058aa35b12499789f50b37ba9f575e8b618e3" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7486&quot;&gt;RFC 7486&lt;/a&gt;, Section 3, &lt;strong&gt;H&lt;/strong&gt;TTP &lt;strong&gt;O&lt;/strong&gt;rigin-&lt;strong&gt;B&lt;/strong&gt;ound &lt;strong&gt;A&lt;/strong&gt;uthentication, digital-signature-based</source>
          <target state="translated">참조 &lt;a href=&quot;https://tools.ietf.org/html/rfc7486&quot;&gt;RFC 7486&lt;/a&gt; , 제 3&lt;strong&gt; H&lt;/strong&gt; TTP &lt;strong&gt;O&lt;/strong&gt; rigin- &lt;strong&gt;B&lt;/strong&gt; 운드, &lt;strong&gt;의&lt;/strong&gt; uthentication, 디지털 서명 기반</target>
        </trans-unit>
        <trans-unit id="adce75b7621f55e2109a1ca207205e78afa08904" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7616&quot;&gt;RFC 7616&lt;/a&gt;, only md5 hashing is supported in Firefox, see &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=472823&quot;&gt;bug 472823&lt;/a&gt; for SHA encryption support</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7616&quot;&gt;RFC 7616을&lt;/a&gt; 참조하십시오 . Firefox에서는 md5 해싱 만 지원됩니다. SHA 암호화 지원 은 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=472823&quot;&gt;버그 472823&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="b350575ff9468b7e0a2d607edfffce21bcd5df92" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt;, base64-encoded credentials. More information below.</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc7617&quot;&gt;RFC 7617&lt;/a&gt; , base64로 인코딩 된 자격 증명을 참조하십시오 . 자세한 내용은 아래에서 확인하세요.</target>
        </trans-unit>
        <trans-unit id="9bedeae74dbfe5265c8dfe7958b7b7d8f49527c2" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://tools.ietf.org/html/rfc8120&quot;&gt;RFC 8120&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://tools.ietf.org/html/rfc8120&quot;&gt;RFC 8120&lt;/a&gt; 참조</target>
        </trans-unit>
        <trans-unit id="c48cf1cda37fbc574acc351d711734f071e0dc06" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://w3c.github.io/payment-request/#feature-policy&quot;&gt;Section 16. Feature Policy integration&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://w3c.github.io/payment-request/#feature-policy&quot;&gt;섹션 16. 기능 정책 통합을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="3cf3b4b99a42a93e5a7a23ffac3b8b47738ee08f" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://webkit.org/b/185070&quot;&gt;bug 185070&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://webkit.org/b/185070&quot;&gt;bug 185070을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="291a54a8499dd01f0491fc82c8048f328a7ee51d" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;https://wiki.mozilla.org/Security/Guidelines/Web_Security#Examples_5&quot;&gt;Mozilla Web Security Guidelines&lt;/a&gt; for more examples.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;https://wiki.mozilla.org/Security/Guidelines/Web_Security#Examples_5&quot;&gt;Mozilla 웹 보안 지침&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="7624f91831549a9940eddbb0f3488a2e93402df5" translate="yes" xml:space="preserve">
          <source>See &lt;a href=&quot;proxy_servers_and_tunneling/proxy_auto-configuration_(pac)_file&quot;&gt;Proxy Auto-Configuration (PAC)&lt;/a&gt; for more examples.</source>
          <target state="translated">자세한 예는 &lt;a href=&quot;proxy_servers_and_tunneling/proxy_auto-configuration_(pac)_file&quot;&gt;PAC (Proxy Auto-Configuration)&lt;/a&gt; 를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="67373bb92cd7ecbf243edb9d60ad6f00f86a6052" translate="yes" xml:space="preserve">
          <source>See Also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="22264972bbdf21536a2e97676872b0fa23492f4e" translate="yes" xml:space="preserve">
          <source>See Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;bug 995651&lt;/a&gt; comment 7.</source>
          <target state="translated">Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;버그 995651&lt;/a&gt; 주석 7을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="0a20b2ffdf62590791187b6d4381fc1759c9535a" translate="yes" xml:space="preserve">
          <source>See Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;bug 995651&lt;/a&gt;.</source>
          <target state="translated">Bugzilla &lt;a href=&quot;https://bugzil.la/995651&quot;&gt;버그 995651을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="719539956ee13b958d9391b4bf7cb27f3c489c59" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://code.google.com/p/chromium/issues/detail?id=348877&quot;&gt;bug 348877&lt;/a&gt;.</source>
          <target state="translated">Chromium &lt;a href=&quot;https://code.google.com/p/chromium/issues/detail?id=348877&quot;&gt;버그 348877을&lt;/a&gt; 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1fbf5c238b234a09b0bc9cc8a52ac8bd31daa0c5" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://crbug.com/348877&quot;&gt;bug 348877&lt;/a&gt;.</source>
          <target state="translated">Chromium &lt;a href=&quot;https://crbug.com/348877&quot;&gt;버그 348877을&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="e290772b02b3e631f75a0bdaf76532057f004f69" translate="yes" xml:space="preserve">
          <source>See Chromium &lt;a href=&quot;https://crbug.com/611416&quot;&gt;bug 611416&lt;/a&gt;.</source>
          <target state="translated">Chromium &lt;a href=&quot;https://crbug.com/611416&quot;&gt;버그 611416을&lt;/a&gt; 참조 하세요 .</target>
        </trans-unit>
        <trans-unit id="2d8243a2c0e464492c9d563c4f92c56ae3421bcc" translate="yes" xml:space="preserve">
          <source>See also</source>
          <target state="translated">또한보십시오</target>
        </trans-unit>
        <trans-unit id="49924d02e7029d9a0991d61325a81804a8302916" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../authentication&quot;&gt;HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site with HTTP basic authentication.</source>
          <target state="translated">HTTP 기본 인증으로 사이트를 암호로 보호하도록 Apache 또는 nginx 서버를 구성하는 방법에 대한 예제 는 &lt;a href=&quot;../authentication&quot;&gt;HTTP 인증&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="1c725ffcd1660304fd5bf29e747aa6869c6d886b" translate="yes" xml:space="preserve">
          <source>See also &lt;a href=&quot;../authentication&quot;&gt;HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site your HTTP basic authentication.</source>
          <target state="translated">HTTP 기본 인증으로 사이트를 비밀번호로 보호하도록 Apache 또는 nginx 서버를 구성하는 방법에 대한 예제 는 &lt;a href=&quot;../authentication&quot;&gt;HTTP 인증&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2fbcc6c0385718b645976c16b4cdd3f4cef27053" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;cross-origin-embedder-policy&quot;&gt;&lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt;&lt;/a&gt; header which you'll need to set as well.</source>
          <target state="translated">또한 설정해야하는 &lt;a href=&quot;cross-origin-embedder-policy&quot;&gt; &lt;code&gt;Cross-Origin-Embedder-Policy&lt;/code&gt; &lt;/a&gt; 헤더 도 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="4186580044b22db3eea08c0a64fa282749ef4626" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;cross-origin-opener-policy&quot;&gt;&lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt;&lt;/a&gt; header which you'll need to set as well.</source>
          <target state="translated">또한 설정해야하는 &lt;a href=&quot;cross-origin-opener-policy&quot;&gt; &lt;code&gt;Cross-Origin-Opener-Policy&lt;/code&gt; &lt;/a&gt; 헤더 도 참조하세요 .</target>
        </trans-unit>
        <trans-unit id="42f531717be60bcfcad04f46fda0152e3247b29b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_tunnel&quot;&gt;HTTP tunnel article on Wikipedia&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP_tunnel&quot;&gt;Wikipedia&lt;/a&gt; 의 HTTP 터널 기사 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="068cb5dd6b484ffb5dd93633ccbdee24e3890f6b" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; response header for more details on transfer encodings. Note that &lt;code&gt;chunked&lt;/code&gt; is always acceptable for HTTP/1.1 recipients and you don't have to specify &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; using the &lt;code&gt;TE&lt;/code&gt; header. However, it is useful for setting if the client is accepting trailer fields in a chunked transfer coding using the &quot;trailers&quot; value.</source>
          <target state="translated">전송 인코딩에 대한 자세한 내용 은 &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 응답 헤더를 참조하십시오. 참고 &lt;code&gt;chunked&lt;/code&gt; 항상 HTTP / 1.1받는 사람에 대한 허용하고 지정할 필요가 없습니다 &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; 은 Using &lt;code&gt;TE&lt;/code&gt; 의 헤더를. 그러나 클라이언트가 &quot;trailers&quot;값을 사용하여 청크 전송 코딩에서 트레일러 필드를 수락하는지 여부를 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="f2355891f6471b5e6f9a15ded06e4a709c5b0c70" translate="yes" xml:space="preserve">
          <source>See also the &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; response header for more details on transfer encodings. Note that &lt;code&gt;chunked&lt;/code&gt; is always acceptable for HTTP/1.1 recipients and you that don't have to specify &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; using the &lt;code&gt;TE&lt;/code&gt; header. However, it is useful for setting if the client is accepting trailer fields in a chunked transfer coding using the &quot;trailers&quot; value.</source>
          <target state="translated">또한 참조 &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 전송 인코딩에 대한 자세한 내용은 응답 헤더를. 참고 &lt;code&gt;chunked&lt;/code&gt; 항상 HTTP / 1.1받는 사람에 대한 허용 및 지정하지 않아도 당신은 &lt;code&gt;&quot;chunked&quot;&lt;/code&gt; 은 Using &lt;code&gt;TE&lt;/code&gt; 의 헤더를. 그러나 클라이언트가 &quot;트레일러&quot;값을 사용하여 청크 분할 전송 코딩에서 트레일러 필드를 허용하는지 여부를 설정하는 데 유용합니다.</target>
        </trans-unit>
        <trans-unit id="d355a7461d6831a917b2782c88db837671b7bc91" translate="yes" xml:space="preserve">
          <source>See also&lt;a href=&quot;../authentication&quot;&gt; HTTP authentication&lt;/a&gt; for examples on how to configure Apache or nginx servers to password protect your site with HTTP basic authentication.</source>
          <target state="translated">HTTP 기본 인증으로 사이트를 비밀번호로 보호하도록 Apache 또는 nginx 서버를 구성하는 방법에 대한 예제 는 &lt;a href=&quot;../authentication&quot;&gt;HTTP 인증&lt;/a&gt; 을 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2e0b79753ca98622d76b2e5d4b5394a6888d631c" translate="yes" xml:space="preserve">
          <source>See the &lt;a href=&quot;../headers/expect&quot;&gt;&lt;code&gt;Expect&lt;/code&gt;&lt;/a&gt; header for more details.</source>
          <target state="translated">자세한 내용은 &lt;a href=&quot;../headers/expect&quot;&gt; &lt;code&gt;Expect&lt;/code&gt; &lt;/a&gt; 헤더를 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="42be1d0017498ee193dc1f0c6a4ba3c0e0d595d5" translate="yes" xml:space="preserve">
          <source>See the page for the &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; header for more information.</source>
          <target state="translated">자세한 내용은 &lt;code&gt;&lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt;&lt;/code&gt; 헤더 페이지를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="2a2d69655ef270db2516384f7be4ebe39aca6629" translate="yes" xml:space="preserve">
          <source>Semi-colon separated list of service definitions in the format of &lt;code&gt;&lt;em&gt;&amp;lt;service-name&amp;gt;&lt;/em&gt;=&quot;&lt;em&gt;&amp;lt;host-name&amp;gt;&lt;/em&gt;:&lt;em&gt;&amp;lt;port-number&amp;gt;&lt;/em&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;em&gt;&amp;lt;service-name&amp;gt;&lt;/em&gt;=&quot;&lt;em&gt;&amp;lt;host-name&amp;gt;&lt;/em&gt;:&lt;em&gt;&amp;lt;port-number&amp;gt;&lt;/em&gt;&quot;&lt;/code&gt; 형식으로 세미콜론으로 구분 된 서비스 정의 목록 .</target>
        </trans-unit>
        <trans-unit id="62f118d4abc9935767d93c466a37b1b6575960d3" translate="yes" xml:space="preserve">
          <source>Send a full URL (stripped from parameters) when performing a a same-origin or cross-origin request. This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">동일한 출처 또는 교차 출처 요청을 수행 할 때 전체 매개 변수 (매개 변수에서 가져온)를 보냅니다. 이 정책은 TLS로 보호되는 리소스에서 안전하지 않은 오리진으로 오리진 및 경로를 유출합니다. 이 설정의 영향을 신중하게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="e8de0238a1711f4357314e28bd455dfbdc081262" translate="yes" xml:space="preserve">
          <source>Send a full URL (stripped from parameters) when performing a same-origin or cross-origin request. This policy will leak origins and paths from TLS-protected resources to insecure origins. Carefully consider the impact of this setting.</source>
          <target state="translated">동일 출처 또는 교차 출처 요청을 수행 할 때 전체 URL (매개 변수에서 제거됨)을 보냅니다. 이 정책은 TLS 보호 리소스의 출처와 경로를 안전하지 않은 출처로 유출합니다. 이 설정의 영향을주의 깊게 고려하십시오.</target>
        </trans-unit>
        <trans-unit id="114ceefa2c0a72367781ffc8a33b8cc5edfb2e16" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin or cross-origin request.</source>
          <target state="translated">동일한 출처 또는 교차 출처 요청을 수행 할 때 전체 URL을 보내십시오.</target>
        </trans-unit>
        <trans-unit id="da546431c50ca7518407c8dd75000ab5f95b3605" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin request, but only send the origin of the document for other cases.</source>
          <target state="translated">동일한 출처 요청을 수행 할 때는 전체 URL을 보내 되 다른 경우에는 문서의 출처 만 보내십시오.</target>
        </trans-unit>
        <trans-unit id="aae12fc53d3fc50d9faa00eec22cbfcdb054e1a7" translate="yes" xml:space="preserve">
          <source>Send a full URL when performing a same-origin request, only send the origin when the protocol security level stays the same (HTTPS&amp;rarr;HTTPS), and send no header to a less secure destination (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">동일한 출처 요청을 수행 할 때 전체 URL을 전송하고 프로토콜 보안 수준이 동일하게 유지 될 때만 (HTTPS &amp;rarr; HTTPS) 원본을 전송하고 덜 안전한 대상 (HTTPS &amp;rarr; HTTP)으로 헤더를 보내지 마십시오.</target>
        </trans-unit>
        <trans-unit id="fa6a220037ad8fc111ada58d14dd34a58fbab96e" translate="yes" xml:space="preserve">
          <source>Send a response to the original request &lt;em&gt;using the new protocol&lt;/em&gt; (the server may only switch to a protocol with which it can complete the original request).</source>
          <target state="translated">&lt;em&gt;새 프로토콜을 사용하여&lt;/em&gt; 원래 요청에 대한 응답을 보냅니다. 서버는 원래 요청을 완료 할 수있는 프로토콜로만 전환 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="ca19fda9303b34183c6fc68556b76910f44fdefc" translate="yes" xml:space="preserve">
          <source>Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same.</source>
          <target state="translated">HTTP 메시지 보내기 : HTTP 메시지 (HTTP / 2 이전)는 사람이 읽을 수 있습니다. HTTP / 2에서는 이러한 간단한 메시지가 프레임으로 캡슐화되어 직접 읽을 수 없지만 원칙은 동일합니다.</target>
        </trans-unit>
        <trans-unit id="8147dd4d6d30b20114ea16f4a3cf7fc6cf5e2c2a" translate="yes" xml:space="preserve">
          <source>Send an HTTP message: HTTP messages (before HTTP/2) are human-readable. With HTTP/2, these simple messages are encapsulated in frames, making them impossible to read directly, but the principle remains the same. For example:</source>
          <target state="translated">HTTP 메시지 보내기 : HTTP 메시지 (HTTP / 2 이전)는 사람이 읽을 수 있습니다. HTTP / 2를 사용하면 이러한 간단한 메시지가 프레임에 캡슐화되어 직접 읽을 수 없지만 원칙은 동일합니다. 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="7a162d935e19c54a7b407ed60746d988b7718e5c" translate="yes" xml:space="preserve">
          <source>Send back a &lt;a href=&quot;../status/101&quot;&gt;&lt;code&gt;101 Switching Protocols&lt;/code&gt;&lt;/a&gt; response status with an &lt;code&gt;Upgrade&lt;/code&gt; header that specifies the protocol(s) being switched to. For example:</source>
          <target state="translated">&lt;a href=&quot;../status/101&quot;&gt; &lt;code&gt;101 Switching Protocols&lt;/code&gt; &lt;/a&gt; 을 지정 하는 &lt;code&gt;Upgrade&lt;/code&gt; 헤더 와 함께 101 Switching Protocols 응답 상태를 다시 보냅니다 . 예를 들면 :</target>
        </trans-unit>
        <trans-unit id="6b5e6da1d334dfb11080a80304a4f099d91dc28f" translate="yes" xml:space="preserve">
          <source>Send cookies from the server to the user agent.</source>
          <target state="translated">서버에서 사용자 에이전트로 쿠키를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="5dc95fd29fa92a67c8d108e8bb34078b6014f782" translate="yes" xml:space="preserve">
          <source>Send cookies from the server to the user-agent.</source>
          <target state="translated">서버에서 사용자 에이전트로 쿠키를 보냅니다.</target>
        </trans-unit>
        <trans-unit id="0c1a7617111c5a0b7fa3ff5d33aa9600f608b1ce" translate="yes" xml:space="preserve">
          <source>Send the following the HTTP header:</source>
          <target state="translated">다음 HTTP 헤더를 보내십시오.</target>
        </trans-unit>
        <trans-unit id="bebd45056f35b854179a91d9f552f5c2cd11de2a" translate="yes" xml:space="preserve">
          <source>Send the origin, path, and query string when performing a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Same-origin_policy&quot;&gt;same-origin&lt;/a&gt; request, but only send the origin of the document for other cases.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Same-origin_policy&quot;&gt;동일 출처&lt;/a&gt; 요청을 수행 할 때 출처, 경로 및 쿼리 문자열을 보내지 만 다른 경우에는 문서 출처 만 보냅니다.</target>
        </trans-unit>
        <trans-unit id="f34c728bc0dd859bfaefc074444b78bddd68cafd" translate="yes" xml:space="preserve">
          <source>Send the origin, path, and query string when performing any request, regardless of security.</source>
          <target state="translated">보안에 관계없이 요청을 수행 할 때 원본, 경로 및 쿼리 문자열을 보냅니다.</target>
        </trans-unit>
        <trans-unit id="77f459dc28c0cecc397bf3277fcada068aa8cb8c" translate="yes" xml:space="preserve">
          <source>Send the origin, path, and querystring when performing a same-origin request, only send the origin when the protocol security level stays the same while performing a cross-origin request (HTTPS&amp;rarr;HTTPS), and send no header to any less-secure destinations (HTTPS&amp;rarr;HTTP).</source>
          <target state="translated">동일 출처 요청을 수행 할 때 출처, 경로 및 쿼리 문자열을 전송하고, 교차 출처 요청 (HTTPS &amp;rarr; HTTPS)을 수행하는 동안 프로토콜 보안 수준이 동일 할 때만 출처를 전송하고 덜 안전한 헤더에는 헤더를 전송하지 않습니다. 목적지 (HTTPS &amp;rarr; HTTP).</target>
        </trans-unit>
        <trans-unit id="18b9f60168add4dcbe2cfa97830141467c596249" translate="yes" xml:space="preserve">
          <source>Sending a client request</source>
          <target state="translated">클라이언트 요청 보내기</target>
        </trans-unit>
        <trans-unit id="f042f0da173aa47e7ae908a0354193a6b152284d" translate="yes" xml:space="preserve">
          <source>Sends a signal to the server expressing the client&amp;rsquo;s preference for an encrypted and authenticated response, and that it can successfully handle the &lt;a href=&quot;headers/content-security-policy/upgrade-insecure-requests&quot;&gt;&lt;code&gt;upgrade-insecure-requests&lt;/code&gt;&lt;/a&gt; directive.</source>
          <target state="translated">암호화되고 인증 된 응답에 대한 클라이언트의 기본 설정을 나타내는 신호를 서버에 전송하고 &lt;a href=&quot;headers/content-security-policy/upgrade-insecure-requests&quot;&gt; &lt;code&gt;upgrade-insecure-requests&lt;/code&gt; &lt;/a&gt; 지시문을 성공적으로 처리 할 수 ​​있음을 나타 냅니다.</target>
        </trans-unit>
        <trans-unit id="66d200f88cfabb0afda59de995f94f1dd092532b" translate="yes" xml:space="preserve">
          <source>Sends cookies from the server to the user-agent, but has been &lt;strong&gt;obsoleted&lt;/strong&gt;. Use &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">서버에서 사용자 에이전트로 쿠키를 전송하지만 &lt;strong&gt;더 이상 사용되지 않습니다&lt;/strong&gt; . 대신 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="c8fbea665ea8f09e42b93cbe3fbddf6b3752bacf" translate="yes" xml:space="preserve">
          <source>Sends reports to the report-uri specified in the header and does still allow clients to connect to the server even if the pinning is violated.</source>
          <target state="translated">헤더에 지정된 report-uri로 보고서를 보내고 고정이 위반 된 경우에도 클라이언트가 서버에 연결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2c37a6ca7548802cf34b6b1b6a53f217ac82b89c" translate="yes" xml:space="preserve">
          <source>Sent If a cache heuristically chose a freshness lifetime greater than 24 hours and the response's age is greater than 24 hours.</source>
          <target state="translated">보냄 캐시가 24 시간보다 긴 신선도 수명을 경험적으로 선택한 경우 응답 기간이 24 시간보다 큰 경우.</target>
        </trans-unit>
        <trans-unit id="a53b6fa8202e4e843c3e7af369e3f2f101eea847" translate="yes" xml:space="preserve">
          <source>Sent for revalidated conditional requests. Indicates that the cached response is still fresh and can be used.</source>
          <target state="translated">재 검증 된 조건부 요청을 위해 전송됩니다. 캐시 된 응답이 여전히 최신 상태이며 사용할 수 있음을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c462e8134588f6d1f23e364585abed05a09525c2" translate="yes" xml:space="preserve">
          <source>Sent with non-CORS requests since Fx59, unless they are &lt;code&gt;GET&lt;/code&gt; or &lt;code&gt;HEAD&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;GET&lt;/code&gt; 또는 &lt;code&gt;HEAD&lt;/code&gt; 가 아닌 한 Fx59 이후 비 CORS 요청과 함께 전송됩니다 .</target>
        </trans-unit>
        <trans-unit id="cc03231ded7efb481d5d56e5edae28e683b8d91a" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: The Alt-Svc HTTP header</source>
          <target state="translated">리소스의 ID 및 위치 분리 : Alt-Svc HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="bbc7c79d44a40669267832b336453bd4fee39146" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: the Alt-Svc HTTP header</source>
          <target state="translated">자원의 ID 및 위치 분리 : Alt-Svc HTTP 헤더</target>
        </trans-unit>
        <trans-unit id="337c903d5597e6947298720f2bc9b6de433ca480" translate="yes" xml:space="preserve">
          <source>Separating identity and location of a resource: the Alt-Svc header</source>
          <target state="translated">자원의 ID와 위치 분리 : Alt-Svc 헤더</target>
        </trans-unit>
        <trans-unit id="cb0cb170d106f8e8d5af1e05bbdbd3a96a7de197" translate="yes" xml:space="preserve">
          <source>Server</source>
          <target state="translated">Server</target>
        </trans-unit>
        <trans-unit id="30407aa127bbc27f6c900a61dc59d209b7261df6" translate="yes" xml:space="preserve">
          <source>Server (RFC 2616)</source>
          <target state="translated">서버 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="067d8d46c7af148801a57e53fc8b7dfdc58619b7" translate="yes" xml:space="preserve">
          <source>Server (RFC 7231)</source>
          <target state="translated">서버 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="0c9b2a002adf639991e245e57e64715e0102f09f" translate="yes" xml:space="preserve">
          <source>Server Timing&lt;br/&gt;&lt;small&gt;The definition of 'Server-Timing Header Field' in that specification.&lt;/small&gt;</source>
          <target state="translated">서버 타이밍 &lt;br/&gt;&lt;small&gt;해당 사양에서 '서버 타이밍 헤더 필드'의 정의.&lt;/small&gt;</target>
        </trans-unit>
        <trans-unit id="144c703ba42db111e61eac225abbe629b8a298f5" translate="yes" xml:space="preserve">
          <source>Server error responses</source>
          <target state="translated">서버 오류 응답</target>
        </trans-unit>
        <trans-unit id="cbda107455833d7e22bb88728c50a3a16c6c4ec5" translate="yes" xml:space="preserve">
          <source>Server errors (&lt;code&gt;500&lt;/code&gt;&amp;ndash;&lt;code&gt;599&lt;/code&gt;)</source>
          <target state="translated">서버 오류 ( &lt;code&gt;500&lt;/code&gt; &amp;ndash; &lt;code&gt;599&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c446956f41362059d67b9d99bd90b54d6974ca49" translate="yes" xml:space="preserve">
          <source>Server first needs to opt in to receive &lt;code&gt;DPR&lt;/code&gt; header by sending the response headers &lt;a href=&quot;accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; containing &lt;code&gt;DPR&lt;/code&gt; and &lt;a href=&quot;accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서버는 먼저 &lt;code&gt;DPR&lt;/code&gt; 및 &lt;a href=&quot;accept-ch-lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; 을&lt;/a&gt; 포함 하는 응답 헤더 &lt;a href=&quot;accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt; 를 전송하여 &lt;code&gt;DPR&lt;/code&gt; 헤더 수신을 옵트 인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="4fc4e8a8670cf52acd49a51687a2bb2706455c89" translate="yes" xml:space="preserve">
          <source>Server first needs to opt in to receive &lt;code&gt;Device-Memory&lt;/code&gt; header by sending the response headers &lt;a href=&quot;accept-ch&quot;&gt;&lt;code&gt;Accept-CH&lt;/code&gt;&lt;/a&gt; containing &lt;code&gt;Device-Memory&lt;/code&gt; and &lt;a href=&quot;accept-ch-lifetime&quot;&gt;&lt;code&gt;Accept-CH-Lifetime&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">서버는 먼저 &lt;code&gt;Device-Memory&lt;/code&gt; 및 &lt;a href=&quot;accept-ch-lifetime&quot;&gt; &lt;code&gt;Accept-CH-Lifetime&lt;/code&gt; 을&lt;/a&gt; 포함 하는 응답 헤더 &lt;a href=&quot;accept-ch&quot;&gt; &lt;code&gt;Accept-CH&lt;/code&gt; &lt;/a&gt; 를 전송하여 &lt;code&gt;Device-Memory&lt;/code&gt; 헤더 를 수신하도록 옵트 인해야합니다 .</target>
        </trans-unit>
        <trans-unit id="aefcd9e862a74c1c1ed221f8a163aac5a8d69c20" translate="yes" xml:space="preserve">
          <source>Server push is semantically equivalent to a server responding to a
   request; however, in this case, that request is also sent by the
   server, as a PUSH_PROMISE frame. 

   The PUSH_PROMISE frame includes a header block that contains a
   complete set of request header fields that the server attributes to
   the request.  It is not possible to push a response to a request that
   includes a request body.

   Pushed responses are always associated with an explicit request from
   the client.  The PUSH_PROMISE frames sent by the server are sent on
   that explicit request's stream.  The PUSH_PROMISE frame also includes
   a promised stream identifier, chosen from the stream identifiers
   available to the server (see &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt;).

   The header fields in PUSH_PROMISE and any subsequent CONTINUATION
   frames MUST be a valid and complete set of request header fields
   (&lt;a href=&quot;#section-8.1.2.3&quot;&gt;Section 8.1.2.3&lt;/a&gt;).  The server MUST include a method in the &quot;:method&quot;
   pseudo-header field that is safe and cacheable.  If a client receives
   a PUSH_PROMISE that does not include a complete and valid set of
   header fields or the &quot;:method&quot; pseudo-header field identifies a
   method that is not safe, it MUST respond with a stream error
   (&lt;a href=&quot;#section-5.4.2&quot;&gt;Section 5.4.2&lt;/a&gt;) of type PROTOCOL_ERROR.

   The server SHOULD send PUSH_PROMISE (&lt;a href=&quot;#section-6.6&quot;&gt;Section 6.6&lt;/a&gt;) frames prior to
   sending any frames that reference the promised responses.  This
   avoids a race where clients issue requests prior to receiving any
   PUSH_PROMISE frames.

   For example, if the server receives a request for a document
   containing embedded links to multiple image files and the server
   chooses to push those additional images to the client, sending
   PUSH_PROMISE frames before the DATA frames that contain the image
   links ensures that the client is able to see that a resource will be
   pushed before discovering embedded links.  Similarly, if the server
   pushes responses referenced by the header block (for instance, in
   Link header fields), sending a PUSH_PROMISE before sending the header
   block ensures that clients do not request those resources.

   PUSH_PROMISE frames MUST NOT be sent by the client.

   PUSH_PROMISE frames can be sent by the server in response to any
   client-initiated stream, but the stream MUST be in either the &quot;open&quot;
   or &quot;half-closed (remote)&quot; state with respect to the server.
   PUSH_PROMISE frames are interspersed with the frames that comprise a
   response, though they cannot be interspersed with HEADERS and
   CONTINUATION frames that comprise a single header block.

   Sending a PUSH_PROMISE frame creates a new stream and puts the stream
   into the &quot;reserved (local)&quot; state for the server and the &quot;reserved
   (remote)&quot; state for the client.</source>
          <target state="translated">서버 푸시는 요청에 응답하는 서버와 의미 상 동일합니다. 그러나이 경우 해당 요청은 PUSH_PROMISE 프레임으로 서버에 의해 전송됩니다. PUSH_PROMISE 프레임에는 서버가 요청에 속성을 부여하는 전체 요청 헤더 필드 세트를 포함하는 헤더 블록이 포함됩니다. 요청 본문이 포함 된 요청에 대한 응답을 푸시 할 수 없습니다. 푸시 된 응답은 항상 클라이언트의 명시 적 요청과 연결됩니다. 서버가 보낸 PUSH_PROMISE 프레임은 명시 적 요청의 스트림으로 전송됩니다. PUSH_PROMISE 프레임은 또한 서버에서 사용할 수있는 스트림 식별자에서 선택된 약속 된 스트림 식별자를 포함합니다 ( &lt;a href=&quot;#section-5.1.1&quot;&gt;섹션 5.1.1&lt;/a&gt; 참조).). PUSH_PROMISE 및 후속 CONTINUATION 프레임의 헤더 필드는 유효하고 완전한 요청 헤더 필드 집합이어야합니다 ( &lt;a href=&quot;#section-8.1.2.3&quot;&gt;섹션 8.1.2.3&lt;/a&gt; ). 서버는 &quot;: method&quot;의사 헤더 필드에 안전하고 캐시 가능한 메소드를 포함해야합니다. 클라이언트가 완전하고 유효한 헤더 필드 세트를 포함하지 않는 PUSH_PROMISE를 수신하거나 &quot;: method&quot;의사 헤더 필드가 안전하지 않은 메소드를 식별하는 경우 다음의 스트림 오류 ( &lt;a href=&quot;#section-5.4.2&quot;&gt;섹션 5.4.2&lt;/a&gt; )로 응답해야합니다. PROTOCOL_ERROR 유형. 서버는 PUSH_PROMISE를 전송해야합니다 ( &lt;a href=&quot;#section-6.6&quot;&gt;섹션 6.6&lt;/a&gt;) 약속 된 응답을 참조하는 프레임을 보내기 전 프레임. 이는 클라이언트가 PUSH_PROMISE 프레임을 수신하기 전에 요청을 발행하는 경합을 방지합니다. 예를 들어 서버가 여러 이미지 파일에 대한 링크가 포함 된 문서에 대한 요청을 수신하고 서버가 이러한 추가 이미지를 클라이언트에 푸시하기로 선택한 경우 이미지 링크가 포함 된 DATA 프레임보다 먼저 PUSH_PROMISE 프레임을 보내 클라이언트가 포함 된 링크를 발견하기 전에 리소스가 푸시되는지 확인합니다. 마찬가지로 서버가 헤더 블록 (예 : 링크 헤더 필드)에서 참조하는 응답을 푸시하는 경우 헤더 블록을 보내기 전에 PUSH_PROMISE를 전송하면 클라이언트가 해당 리소스를 요청하지 않습니다. PUSH_PROMISE 프레임은 클라이언트에 의해 전송되지 않아야합니다.PUSH_PROMISE 프레임은 클라이언트가 시작한 스트림에 대한 응답으로 서버에 의해 전송 될 수 있지만 스트림은 서버와 관련하여 &quot;개방&quot;또는 &quot;반 폐쇄 (원격)&quot;상태 여야합니다. PUSH_PROMISE 프레임은 단일 헤더 블록을 구성하는 HEADERS 및 CONTINUATION 프레임과 함께 배치 될 수 없지만 응답을 구성하는 프레임과 함께 배치됩니다. PUSH_PROMISE 프레임을 전송하면 새 스트림이 생성되고 스트림이 서버의 경우 &quot;reserved (로컬)&quot;상태가되고 클라이언트의 경우 &quot;reserved (remote)&quot;상태가됩니다.단일 헤더 블록을 구성하는 HEADERS 및 CONTINUATION 프레임과 함께 산재 할 수는 없습니다. PUSH_PROMISE 프레임을 전송하면 새 스트림이 생성되고 스트림이 서버의 경우 &quot;reserved (로컬)&quot;상태가되고 클라이언트의 경우 &quot;reserved (remote)&quot;상태가됩니다.단일 헤더 블록을 구성하는 HEADERS 및 CONTINUATION 프레임과 함께 산재 할 수는 없습니다. PUSH_PROMISE 프레임을 전송하면 새 스트림이 생성되고 스트림이 서버의 경우 &quot;reserved (로컬)&quot;상태가되고 클라이언트의 경우 &quot;reserved (remote)&quot;상태가됩니다.</target>
        </trans-unit>
        <trans-unit id="a4418c7f82dfa6a5eb45c872b1b4c3a9ec7ed04c" translate="yes" xml:space="preserve">
          <source>Server rejected the request because the &lt;code&gt;Content-Length&lt;/code&gt; header field is not defined and the server requires it.</source>
          <target state="translated">&lt;code&gt;Content-Length&lt;/code&gt; 헤더 필드가 정의되지 않아서 서버가 요구하기 때문에 서버가 요청을 거부 했습니다.</target>
        </trans-unit>
        <trans-unit id="223a3cd967a61f2a3071650ced2def4903361d55" translate="yes" xml:space="preserve">
          <source>Server response</source>
          <target state="translated">서버 응답</target>
        </trans-unit>
        <trans-unit id="ca286c1254a3056614d73687d3f1ef4b4a44a8ec" translate="yes" xml:space="preserve">
          <source>Server-Side Access Control</source>
          <target state="translated">서버 측 액세스 제어</target>
        </trans-unit>
        <trans-unit id="6792a77076aa3b8284916c74946cf72675363ce8" translate="yes" xml:space="preserve">
          <source>Server-Timing</source>
          <target state="translated">Server-Timing</target>
        </trans-unit>
        <trans-unit id="da6cf01a8ddc149fef30875f9a63615768b06254" translate="yes" xml:space="preserve">
          <source>Server-driven content negotiation</source>
          <target state="translated">서버 중심의 콘텐츠 협상</target>
        </trans-unit>
        <trans-unit id="fd7b73c63b10788b6bed0cef0a6ec6764b254c1d" translate="yes" xml:space="preserve">
          <source>Server-driven negotiation suffers from a few downsides: it doesn't scale well. There is one header per feature used in the negotiation. If you want to use screen size, resolution or other dimensions, a new HTTP header must be created. Sending of the headers must be done on every request. This is not too problematic with few headers, but with the eventual multiplications of them, the message size would lead to a decrease in performance. The more precise headers are sent, the more entropy is sent, allowing for more HTTP fingerprinting and corresponding privacy concern.</source>
          <target state="translated">서버 중심 협상에는 몇 가지 단점이 있습니다. 협상에 사용 된 기능 당 하나의 헤더가 있습니다. 화면 크기, 해상도 또는 기타 차원을 사용하려면 새 HTTP 헤더를 작성해야합니다. 헤더를 보낼 때마다 요청을 보내야합니다. 헤더 수가 적 으면 문제가되지 않지만 결과적으로 곱셈하면 메시지 크기가 성능 저하로 이어질 수 있습니다. 더 정확한 헤더가 전송 될수록 더 많은 엔트로피가 전송되므로 더 많은 HTTP 지문 및 해당 개인 정보 보호 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="280ea515a8b112db582b1e7620e99f0f92dcb530" translate="yes" xml:space="preserve">
          <source>Server-initiated upgrade to TLS</source>
          <target state="translated">TLS로 서버 시작 업그레이드</target>
        </trans-unit>
        <trans-unit id="79d9bb2304b19b76e2157ed20e7da4030dc91a26" translate="yes" xml:space="preserve">
          <source>Server-sent events</source>
          <target state="translated">서버가 보낸 이벤트</target>
        </trans-unit>
        <trans-unit id="67de8093f1524a9bccacf1c09f2b166b248d1aa6" translate="yes" xml:space="preserve">
          <source>Server-side CORS settings</source>
          <target state="translated">서버 측 CORS 설정</target>
        </trans-unit>
        <trans-unit id="8da24e9a194030de05562477bacb0f99c55e7dbd" translate="yes" xml:space="preserve">
          <source>Servers MUST return authorization errors in preference to other
   errors.  This avoids leaking information about protected resources
   (e.g., a client that finds that a hidden resource exists by seeing a
   423 Locked response to an anonymous request to the resource).</source>
          <target state="translated">서버는 다른 오류보다 권한 부여 오류를 우선적으로 반환해야합니다. 이렇게하면 보호 된 리소스 (예 : 리소스에 대한 익명 요청에 대한 423 잠금 응답을 확인하여 숨겨진 리소스가 있음을 발견 한 클라이언트)에 대한 정보가 유출되는 것을 방지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f4c682d1668898494c7dc1297fbbd4673d8bc287" translate="yes" xml:space="preserve">
          <source>Servers and/or clients are often located on intranets and hide their true IP address to others. HTTP requests then go through proxies to cross this network barrier. Not all proxies are HTTP proxies. The SOCKS protocol, for example, operates at a lower level. Others, like ftp, can be handled by these proxies.</source>
          <target state="translated">서버 및 / 또는 클라이언트는 종종 인트라넷에 있으며 실제 IP 주소를 다른 사람에게 숨 깁니다. 그런 다음 HTTP 요청은 프록시를 통해이 네트워크 장벽을 통과합니다. 모든 프록시가 HTTP 프록시는 아닙니다. 예를 들어 SOCKS 프로토콜은 낮은 수준에서 작동합니다. ftp와 같은 다른 프록시도 이러한 프록시로 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="3a801c2bb279262c7911502691c1290ae71c1452" translate="yes" xml:space="preserve">
          <source>Servers are given more leeway in how they respond to a range request,
   in order to mitigate abuse by malicious (or just greedy) clients.
   (&lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;)

   A weak validator cannot be used in a 206 response.  (&lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;)

   The Content-Range header field only has meaning when the status code
   explicitly defines its use.  (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;)

   This specification introduces a Range Unit Registry.  (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;)

   multipart/byteranges can consist of a single part.  (Appendix A)</source>
          <target state="translated">서버는 악의적 인 (또는 욕심 많은) 클라이언트에 의한 악용을 완화하기 위해 범위 요청에 응답하는 방법에 대해 더 많은 여유가 있습니다. ( &lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; ) 약한 유효성 검사기는 206 응답에 사용할 수 없습니다. ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; ) Content-Range 헤더 필드는 상태 코드가 명시 적으로 사용을 정의 할 때만 의미가 있습니다. ( &lt;a href=&quot;#section-4.2&quot;&gt;4.2 절&lt;/a&gt; )이 사양은 Range Unit Registry를 소개합니다. ( &lt;a href=&quot;#section-5.1&quot;&gt;5.1 절&lt;/a&gt; ) 멀티 파트 / 바이트 범위는 단일 파트로 구성 될 수 있습니다. (부록)</target>
        </trans-unit>
        <trans-unit id="47775be948b90bc8bbdd930ee3d2d72f381c8caa" translate="yes" xml:space="preserve">
          <source>Servers can advertise support for Client Hints using the &lt;code&gt;Accept-CH&lt;/code&gt; header field or an equivalent HTML &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; element with &lt;code&gt;http-equiv&lt;/code&gt; attribute (&lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#HTML5&quot;&gt;&lt;cite&gt;[HTML5]&lt;/cite&gt;&lt;/a&gt;).</source>
          <target state="translated">서버는 &lt;code&gt;Accept-CH&lt;/code&gt; 헤더 필드 또는 &lt;code&gt;http-equiv&lt;/code&gt; 속성 ( &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#HTML5&quot;&gt;&lt;cite&gt;[HTML5]&lt;/cite&gt;&lt;/a&gt; )이 있는 동등한 HTML &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; 요소를 사용하여 클라이언트 힌트에 대한 지원을 알릴 수 있습니다 .&lt;cite&gt;&lt;/cite&gt;</target>
        </trans-unit>
        <trans-unit id="42dc7575a6f0aaa611ea0b0ef75203093bd26568" translate="yes" xml:space="preserve">
          <source>Servers can ask the client to remember the set of Client Hints that the server supports for a specified period of time, to enable delivery of Client Hints on subsequent requests to the server&amp;rsquo;s origin (&lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#RFC6454&quot;&gt;&lt;cite&gt;[RFC6454]&lt;/cite&gt;&lt;/a&gt;).</source>
          <target state="translated">서버는 클라이언트에게 지정된 기간 동안 서버가 지원하는 클라이언트 힌트 집합을 기억하도록 요청하여 서버의 원본에 대한 후속 요청에서 클라이언트 힌트를 전달할 수 있습니다 ( &lt;a href=&quot;https://httpwg.org/http-extensions/client-hints.html#RFC6454&quot;&gt;&lt;cite&gt;[RFC6454]&lt;/cite&gt;&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5515ad01f817b62958172ef2562f4725ed4c4587" translate="yes" xml:space="preserve">
          <source>Servers or clients are often located on intranets and hide their true IP address from other computers. HTTP requests then go through proxies to cross this network barrier. Not all proxies are HTTP proxies. The SOCKS protocol, for example, operates at a lower level. Other protocols, like ftp, can be handled by these proxies.</source>
          <target state="translated">서버 또는 클라이언트는 종종 인트라넷에 있으며 다른 컴퓨터에서 실제 IP 주소를 숨 깁니다. 그런 다음 HTTP 요청은 프록시를 통해이 네트워크 장벽을 통과합니다. 모든 프록시가 HTTP 프록시는 아닙니다. 예를 들어 SOCKS 프로토콜은 더 낮은 수준에서 작동합니다. ftp와 같은 다른 프로토콜은 이러한 프록시에서 처리 할 수 ​​있습니다.</target>
        </trans-unit>
        <trans-unit id="40104b8f8c1bae810fb11635b90972e11a6d19a7" translate="yes" xml:space="preserve">
          <source>Servers send the &quot;Retry-After&quot; header field to indicate how long the
   user agent ought to wait before making a follow-up request.  When
   sent with a 503 (Service Unavailable) response, Retry-After indicates
   how long the service is expected to be unavailable to the client.
   When sent with any 3xx (Redirection) response, Retry-After indicates
   the minimum time that the user agent is asked to wait before issuing
   the redirected request.

   The value of this field can be either an HTTP-date or a number of
   seconds to delay after the response is received.

     Retry-After = HTTP-date / delay-seconds

   A delay-seconds value is a non-negative decimal integer, representing
   time in seconds.

     delay-seconds  = 1*DIGIT 

   Two examples of its use are

     Retry-After: Fri, 31 Dec 1999 23:59:59 GMT
     Retry-After: 120

   In the latter example, the delay is 2 minutes.</source>
          <target state="translated">서버는 &quot;다시 시도&quot;헤더 필드를 보내 후속 요청을하기 전에 사용자 에이전트가 대기해야하는 시간을 나타냅니다. 503 (Service Unavailable) 응답과 함께 전송되면 Retry-After는 클라이언트가 서비스를 사용할 수 없을 것으로 예상되는 시간을 나타냅니다. 3xx (리디렉션) 응답과 함께 전송되면 Retry-After는 리디렉션 된 요청을 발행하기 전에 사용자 에이전트가 대기해야하는 최소 시간을 나타냅니다. 이 필드의 값은 응답이 수신 된 후 HTTP-date 또는 지연 시간 (초) 일 수 있습니다. Retry-After = HTTP-date / delay-seconds 지연 시간 값은 음수가 아닌 10 진수이며 시간을 초 단위로 나타냅니다. delay-seconds = 1 * DIGIT 사용의 두 가지 예는 Retry-After : 1999 년 12 월 31 일 금요일 23:59:59 GMT Retry-After :후자의 예에서 지연은 2 분입니다.</target>
        </trans-unit>
        <trans-unit id="41025e145e89135a85498ba87ffb1a1e1b47fde8" translate="yes" xml:space="preserve">
          <source>Servers will often produce this status if:</source>
          <target state="translated">서버는 다음과 같은 경우에 종종이 상태를 생성합니다.</target>
        </trans-unit>
        <trans-unit id="b11bd40d94eed6743e5942032063a30b385e293b" translate="yes" xml:space="preserve">
          <source>Servers will usually have some time-out value beyond which they will
   no longer maintain an inactive connection. Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same server. The use of persistent
   connections places no requirements on the length (or existence) of
   this time-out for either the client or the server. 

   When a client or server wishes to time-out it SHOULD issue a graceful
   close on the transport connection. Clients and servers SHOULD both
   constantly watch for the other side of the transport close, and
   respond to it as appropriate. If a client or server does not detect
   the other side's close promptly it could cause unnecessary resource
   drain on the network.

   A client, server, or proxy MAY close the transport connection at any
   time. For example, a client might have started to send a new request
   at the same time that the server has decided to close the &quot;idle&quot;
   connection. From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

   This means that clients, servers, and proxies MUST be able to recover
   from asynchronous close events. Client software SHOULD reopen the
   transport connection and retransmit the aborted sequence of requests
   without user interaction so long as the request sequence is
   idempotent (see &lt;a href=&quot;#section-9.1.2&quot;&gt;section 9.1.2&lt;/a&gt;). Non-idempotent methods or sequences
   MUST NOT be automatically retried, although user agents MAY offer a
   human operator the choice of retrying the request(s). Confirmation by
   user-agent software with semantic understanding of the application
   MAY substitute for user confirmation. The automatic retry SHOULD NOT
   be repeated if the second sequence of requests fails.

   Servers SHOULD always respond to at least one request per connection,
   if at all possible. Servers SHOULD NOT close a connection in the
   middle of transmitting a response, unless a network or client failure
   is suspected.

   Clients that use persistent connections SHOULD limit the number of
   simultaneous connections that they maintain to a given server. A
   single-user client SHOULD NOT maintain more than 2 connections with
   any server or proxy. A proxy SHOULD use up to 2*N connections to
   another server or proxy, where N is the number of simultaneously
   active users. These guidelines are intended to improve HTTP response
   times and avoid congestion.</source>
          <target state="translated">서버는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값을 갖습니다. 프록시 서버는 클라이언트가 동일한 서버를 통해 더 많은 연결을 만들 가능성이 높으므로이 값을 더 높게 만들 수 있습니다. 영구 연결을 사용하면 클라이언트 또는 서버에 대한이 시간 제한의 길이 (또는 존재)에 대한 요구 사항이 없습니다. 클라이언트 또는 서버가 시간 초과를 원할 때 전송 연결에서 정상적으로 종료해야합니다. 클라이언트와 서버는 전송의 반대편을 지속적으로 감시하고 적절하게 대응해야합니다. 클라이언트 나 서버가 상대방의 닫기를 즉시 감지하지 못하면 네트워크에서 불필요한 리소스가 낭비 될 수 있습니다. 클라이언트, 서버,또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어, 클라이언트가 서버가 &quot;유휴&quot;연결을 종료하기로 결정한 것과 동시에 새로운 요청을 보내기 시작했을 수 있습니다. 서버의 관점에서 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트의 관점에서 요청이 진행 중입니다. 이는 클라이언트, 서버 및 프록시가 비동기 닫기 이벤트에서 복구 할 수 있어야한다는 것을 의미합니다. 클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).관점에서, 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트의 관점에서 요청이 진행 중입니다. 이는 클라이언트, 서버 및 프록시가 비동기 닫기 이벤트에서 복구 할 수 있어야한다는 것을 의미합니다. 클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).관점에서, 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트의 관점에서 요청이 진행 중입니다. 이는 클라이언트, 서버 및 프록시가 비동기 닫기 이벤트에서 복구 할 수 있어야한다는 것을 의미합니다. 클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).클라이언트 소프트웨어는 전송 연결을 다시 열고 요청 시퀀스가 ​​dem 등원 인 한 사용자 상호 작용없이 중단 된 요청 시퀀스를 다시 전송해야합니다 (참조).&lt;a href=&quot;#section-9.1.2&quot;&gt;섹션 9.1.2&lt;/a&gt;). 사용자 에이전트가 휴먼 오퍼레이터에게 요청을 재 시도 할 수있는 선택권을 제공 할 수 있지만, 비등 전성 메소드 또는 시퀀스는 자동으로 재 시도해서는 안됩니다 (MUST NOT). 애플리케이션을 의미 적으로 이해 한 사용자 에이전트 소프트웨어에 의한 확인은 사용자 확인을 대체 할 수 있습니다. 두 번째 요청 순서가 실패하면 자동 재 시도를 반복해서는 안됩니다. 서버는 가능하면 항상 연결 당 하나 이상의 요청에 응답해야합니다. 네트워크 또는 클라이언트 장애가 의심되지 않는 한 서버는 응답을 전송하는 도중에 연결을 닫지 말아야합니다. 영구 연결을 사용하는 클라이언트는 주어진 서버에 대해 유지 관리하는 동시 연결 수를 제한해야합니다. 단일 사용자 클라이언트는 서버 또는 프록시와 2 개 이상의 연결을 유지해서는 안됩니다.프록시는 다른 서버 또는 프록시에 최대 2 * N 연결을 사용해야합니다. 여기서 N은 동시에 활동중인 사용자 수입니다. 이 지침은 HTTP 응답 시간을 개선하고 혼잡을 피하기위한 것입니다.</target>
        </trans-unit>
        <trans-unit id="7a64cc38406e1e6e386cf9a33c8c4a86744f295f" translate="yes" xml:space="preserve">
          <source>Servers will usually have some timeout value beyond which they will
   no longer maintain an inactive connection.  Proxy servers might make
   this a higher value since it is likely that the client will be making
   more connections through the same proxy server.  The use of
   persistent connections places no requirements on the length (or
   existence) of this timeout for either the client or the server.

   A client or server that wishes to time out SHOULD issue a graceful
   close on the connection.  Implementations SHOULD constantly monitor
   open connections for a received closure signal and respond to it as
   appropriate, since prompt closure of both sides of a connection
   enables allocated system resources to be reclaimed. 

   A client, server, or proxy MAY close the transport connection at any
   time.  For example, a client might have started to send a new request
   at the same time that the server has decided to close the &quot;idle&quot;
   connection.  From the server's point of view, the connection is being
   closed while it was idle, but from the client's point of view, a
   request is in progress.

   A server SHOULD sustain persistent connections, when possible, and
   allow the underlying transport's flow-control mechanisms to resolve
   temporary overloads, rather than terminate connections with the
   expectation that clients will retry.  The latter technique can
   exacerbate network congestion.

   A client sending a message body SHOULD monitor the network connection
   for an error response while it is transmitting the request.  If the
   client sees a response that indicates the server does not wish to
   receive the message body and is closing the connection, the client
   SHOULD immediately cease transmitting the body and close its side of
   the connection.</source>
          <target state="translated">서버는 일반적으로 더 이상 비활성 연결을 유지하지 않는 시간 초과 값을 갖습니다. 클라이언트가 동일한 프록시 서버를 통해 더 많은 연결을 할 수 있기 때문에 프록시 서버는이 값을 더 높게 만들 수 있습니다. 영구 연결을 사용하면 클라이언트 또는 서버에 대한이 시간 초과 길이 (또는 존재)에 대한 요구 사항이 없습니다. 시간 초과를 원하는 클라이언트 또는 서버는 연결을 정상적으로 종료해야합니다. 구현은 수신 된 폐쇄 신호에 대한 개방형 연결을 지속적으로 모니터링하고 적절하게 응답해야한다. 연결의 양쪽을 신속하게 폐쇄하면 할당 된 시스템 자원을 회수 할 수 있기 때문이다. 클라이언트, 서버 또는 프록시는 언제든지 전송 연결을 닫을 수 있습니다. 예를 들어서버가 &quot;유휴&quot;연결을 종료하기로 결정한 것과 동시에 클라이언트가 새 요청을 보내기 시작했을 수 있습니다. 서버의 관점에서 연결이 유휴 상태 인 동안 연결이 닫히고 있지만 클라이언트의 관점에서 요청이 진행 중입니다. 서버는 가능하면 영구적 인 연결을 유지해야하며 기본 전송의 흐름 제어 메커니즘이 클라이언트가 재 시도 할 것으로 예상되는 연결을 종료하지 않고 임시 과부하를 해결하도록해야합니다. 후자의 기술은 네트워크 혼잡을 악화시킬 수 있습니다. 메시지 본문을 보내는 클라이언트는 요청을 전송하는 동안 오류 응답이 있는지 네트워크 연결을 모니터링해야합니다.클라이언트가 서버가 메시지 본문을 수신하지 않음을 나타내는 응답을보고 연결을 닫는 경우 클라이언트는 즉시 본문 전송을 중단하고 연결 쪽을 닫아야합니다.</target>
        </trans-unit>
        <trans-unit id="f5124c99e159587ebe507b56369f65760748f150" translate="yes" xml:space="preserve">
          <source>Serves as a fallback for the other &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive&quot;&gt;fetch directives&lt;/a&gt;.</source>
          <target state="translated">다른 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Fetch_directive&quot;&gt;페치 지시문에&lt;/a&gt; 대한 폴백으로 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="c993592eb184660ed131503e2e6e4c8ebc6710fd" translate="yes" xml:space="preserve">
          <source>Service worker registrations (for each service worker registration, execute &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister&quot;&gt;&lt;code&gt;ServiceWorkerRegistration.unregister&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">서비스 근로자 등록 (각 서비스 근로자 등록에 대해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerRegistration/unregister&quot;&gt; &lt;code&gt;ServiceWorkerRegistration.unregister&lt;/code&gt; 를&lt;/a&gt; 실행 )</target>
        </trans-unit>
        <trans-unit id="53dfe70871da64dc7cc73082fd91fc0d67395965" translate="yes" xml:space="preserve">
          <source>Serving different Web pages or services to different browsers is usually a bad idea. The Web is meant to be accessible to everyone, regardless of which browser or device they're using. There are ways to develop your website to progressively enhance itself based on the availability of features rather than by targeting specific browsers.</source>
          <target state="translated">다른 웹 페이지 나 서비스를 다른 브라우저에 제공하는 것은 일반적으로 나쁜 생각입니다. 웹은 사용중인 브라우저 나 장치에 관계없이 모든 사람이 액세스 할 수 있도록 만들어졌습니다. 특정 브라우저를 대상으로하지 않고 기능의 가용성에 따라 점진적으로 향상되도록 웹 사이트를 개발하는 방법이 있습니다.</target>
        </trans-unit>
        <trans-unit id="61a0eba4a8c4bcb092cc3e5ed3ca481b331e2273" translate="yes" xml:space="preserve">
          <source>Servo: &lt;a href=&quot;https://github.com/servo/servo/issues/13283&quot;&gt;Issue 13283&lt;/a&gt;</source>
          <target state="translated">서보 : &lt;a href=&quot;https://github.com/servo/servo/issues/13283&quot;&gt;문제 13283&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f7f1997c6cd1aa051279675742272a956e7db628" translate="yes" xml:space="preserve">
          <source>Session</source>
          <target state="translated">Session</target>
        </trans-unit>
        <trans-unit id="8fa2a80f7a4a01bb4a4049a65f2e8ab40639ca19" translate="yes" xml:space="preserve">
          <source>Session cookie</source>
          <target state="translated">세션 쿠키</target>
        </trans-unit>
        <trans-unit id="a5de7556cf7bd4f9692d5121762b926c377ffd0d" translate="yes" xml:space="preserve">
          <source>Session cookies</source>
          <target state="translated">세션 쿠키</target>
        </trans-unit>
        <trans-unit id="c22669a0c2011d70ebc816a2c115645d58f8ea3a" translate="yes" xml:space="preserve">
          <source>Session cookies will get removed when the client is shut down. They don't specify the &lt;code&gt;Expires&lt;/code&gt; or &lt;code&gt;Max-Age&lt;/code&gt; directives. Note that web browser have often enabled session restoring.</source>
          <target state="translated">클라이언트가 종료되면 세션 쿠키가 제거됩니다. &lt;code&gt;Expires&lt;/code&gt; 또는 &lt;code&gt;Max-Age&lt;/code&gt; 지시문을 지정하지 않습니다 . 웹 브라우저는 종종 세션 복원을 활성화했습니다.</target>
        </trans-unit>
        <trans-unit id="0383ce6cf519828e20e353eff1d36e08f759636b" translate="yes" xml:space="preserve">
          <source>Session hijacking and XSS</source>
          <target state="translated">세션 하이재킹 및 XSS</target>
        </trans-unit>
        <trans-unit id="4d1a0ebf42ea7726af9fc0d443c4219ad98f0b66" translate="yes" xml:space="preserve">
          <source>Session management</source>
          <target state="translated">세션 관리</target>
        </trans-unit>
        <trans-unit id="74d939bd156bb2a40d27c5c067b218718f567be0" translate="yes" xml:space="preserve">
          <source>Set by the &lt;em&gt;client&lt;/em&gt; to indicate &quot;do not use the network&quot; for the response. The cache should either respond using a stored response, or respond with a &lt;a href=&quot;../status/504&quot;&gt;&lt;code&gt;504&lt;/code&gt;&lt;/a&gt; status code. Conditional headers such as &lt;code&gt;If-None-Match&lt;/code&gt; should not be set. There is no effect if &lt;code&gt;only-if-cached&lt;/code&gt; is set by a server as part of a response.</source>
          <target state="translated">응답에 대해 &quot;네트워크를 사용하지 않음&quot;을 나타내 도록 &lt;em&gt;클라이언트&lt;/em&gt; 가 설정합니다 . 캐시는 저장된 응답을 사용하여 응답하거나 &lt;a href=&quot;../status/504&quot;&gt; &lt;code&gt;504&lt;/code&gt; &lt;/a&gt; 상태 코드로 응답해야합니다 . &lt;code&gt;If-None-Match&lt;/code&gt; 와 같은 조건부 헤더 는 설정하지 않아야합니다. 서버가 응답의 일부로 &lt;code&gt;only-if-cached&lt;/code&gt; 를 설정 하면 효과가 없습니다 .</target>
        </trans-unit>
        <trans-unit id="da18d02d9a384ec87b2924aa70bb99b190dfa12c" translate="yes" xml:space="preserve">
          <source>Set-Cookie</source>
          <target state="translated">Set-Cookie</target>
        </trans-unit>
        <trans-unit id="e9cace35e90b037b0140e79e5bff9090459aef6c" translate="yes" xml:space="preserve">
          <source>Set-Cookie2</source>
          <target state="translated">Set-Cookie2</target>
        </trans-unit>
        <trans-unit id="d1e87d65a1101b01c566a98da861af6e2c17a6e5" translate="yes" xml:space="preserve">
          <source>Set-Cookie: SameSite</source>
          <target state="translated">세트 쿠키 : SameSite</target>
        </trans-unit>
        <trans-unit id="ca4cfc1c5db67629db097698126f262a8ff0efa4" translate="yes" xml:space="preserve">
          <source>Setting a proxy for a specific protocol</source>
          <target state="translated">특정 프로토콜에 대한 프록시 설정</target>
        </trans-unit>
        <trans-unit id="0a19969b97beb1798bb95f65f7732ae561c43ab8" translate="yes" xml:space="preserve">
          <source>Setting this directive to &lt;code&gt;'none'&lt;/code&gt; is similar to &lt;a href=&quot;../x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: DENY&lt;/code&gt; (which is also supported in older browers).</source>
          <target state="translated">이 지시어를 &lt;code&gt;'none'&lt;/code&gt; 설정하는 것은 &lt;a href=&quot;../x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: DENY&lt;/code&gt; 와 비슷합니다 (이전 브라우저에서도 지원됨).</target>
        </trans-unit>
        <trans-unit id="f20afb2ced2db52eedb85addd06480f621f4772b" translate="yes" xml:space="preserve">
          <source>Setting this directive to &lt;code&gt;'none'&lt;/code&gt; is similar to &lt;a href=&quot;../x-frame-options&quot;&gt;&lt;code&gt;X-Frame-Options&lt;/code&gt;&lt;/a&gt;&lt;code&gt;: deny&lt;/code&gt; (which is also supported in older browsers).</source>
          <target state="translated">이 지시문을 &lt;code&gt;'none'&lt;/code&gt; 으로 설정하는 것은 &lt;a href=&quot;../x-frame-options&quot;&gt; &lt;code&gt;X-Frame-Options&lt;/code&gt; &lt;/a&gt; &lt;code&gt;: deny&lt;/code&gt; (이전 브라우저에서도 지원됨 )와 유사합니다 .</target>
        </trans-unit>
        <trans-unit id="e21c065049ff05b60c6a9ac39caff520e04569d8" translate="yes" xml:space="preserve">
          <source>Setting up your webserver to include the HPKP header</source>
          <target state="translated">HPKP 헤더를 포함하도록 웹 서버 설정</target>
        </trans-unit>
        <trans-unit id="32a560a86e92c09f3625944269ea6a7159c1e2c8" translate="yes" xml:space="preserve">
          <source>Several HTTP headers, called conditional headers, lead to conditional requests. These are:</source>
          <target state="translated">조건부 헤더라고하는 여러 HTTP 헤더는 조건부 요청으로 이어집니다. 이것들은:</target>
        </trans-unit>
        <trans-unit id="ff4098bca0b9ad085e37717d9a0aa0d74cab0953" translate="yes" xml:space="preserve">
          <source>Several characteristics of HTTP/2 provide an observer an opportunity
   to correlate actions of a single client or server over time.  These
   include the value of settings, the manner in which flow-control
   windows are managed, the way priorities are allocated to streams, the
   timing of reactions to stimulus, and the handling of any features
   that are controlled by settings. 

   As far as these create observable differences in behavior, they could
   be used as a basis for fingerprinting a specific client, as defined
   in Section 1.8 of [&lt;a href=&quot;#ref-HTML5&quot;&gt;HTML5&lt;/a&gt;].

   HTTP/2's preference for using a single TCP connection allows
   correlation of a user's activity on a site.  Reusing connections for
   different origins allows tracking across those origins.

   Because the PING and SETTINGS frames solicit immediate responses,
   they can be used by an endpoint to measure latency to their peer.
   This might have privacy implications in certain scenarios.</source>
          <target state="translated">HTTP / 2의 몇 가지 특성은 관찰자에게 시간이 지남에 따라 단일 클라이언트 또는 서버의 작업을 연관시킬 수있는 기회를 제공합니다. 여기에는 설정 값, 흐름 제어 창이 관리되는 방식, 우선 순위가 스트림에 할당되는 방식, 자극에 대한 반응 타이밍 및 설정에 의해 제어되는 모든 기능의 처리가 포함됩니다. 이것들이 행동에 눈에 띄는 차이를 만드는 한, [ &lt;a href=&quot;#ref-HTML5&quot;&gt;HTML5&lt;/a&gt;]. 단일 TCP 연결을 사용하기위한 HTTP / 2의 기본 설정은 사이트에서 사용자의 활동을 연관시킬 수 있습니다. 다른 오리진에 대한 연결을 재사용하면 해당 오리진을 추적 할 수 있습니다. PING 및 SETTINGS 프레임은 즉각적인 응답을 요청하기 때문에 엔드 포인트에서 피어에 대한 대기 시간을 측정하는 데 사용할 수 있습니다. 이는 특정 시나리오에서 개인 정보 보호에 영향을 미칠 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="329eb594c20733b1f610e7cab58a3336e04332ce" translate="yes" xml:space="preserve">
          <source>Several features can be controlled at the same time by sending the HTTP header with a semicolon-separated list of policy directives, or by sending a separate header for each policy.</source>
          <target state="translated">세미콜론으로 구분 된 정책 지시문 목록과 함께 HTTP 헤더를 보내거나 각 정책에 대해 별도의 헤더를 보내 여러 기능을 동시에 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="81acc188ecb44fe2b0ca66c680ba970231e66c83" translate="yes" xml:space="preserve">
          <source>Shared proxy caches</source>
          <target state="translated">공유 프록시 캐시</target>
        </trans-unit>
        <trans-unit id="78f6156a2ead82a3ca398616fa6f9e17dfb530a7" translate="yes" xml:space="preserve">
          <source>Short-lived connections</source>
          <target state="translated">수명이 짧은 연결</target>
        </trans-unit>
        <trans-unit id="f47fe4cbc4ecdf7b89058813c34af535ace87ae1" translate="yes" xml:space="preserve">
          <source>Short-lived connections have two major hitches: the time taken to establish a new connection is significant, and performance of the underlying TCP connection gets better only when this connection has been in use for some time (warm connection). To ease these problems, the concept of a &lt;em&gt;persistent connection&lt;/em&gt; has been designed, even prior to HTTP/1.1. Alternatively this may be called a &lt;em&gt;keep-alive connection&lt;/em&gt;.</source>
          <target state="translated">수명이 짧은 연결에는 두 가지 주요 장애가 있습니다. 새 연결을 설정하는 데 걸리는 시간이 상당하며 기본 TCP 연결의 성능은이 연결이 일정 시간 동안 사용 된 경우에만 더 좋습니다 (웜 연결). 이러한 문제를 해결 하기 위해 HTTP / 1.1 이전에도 &lt;em&gt;지속적인 연결&lt;/em&gt; 개념 이 설계되었습니다. 또는 이것을 &lt;em&gt;연결 유지 연결&lt;/em&gt; 이라고 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="c537d8356fd7f996e8605aa03e51f47390d4d7a8" translate="yes" xml:space="preserve">
          <source>Shows and explains the flow of a usual HTTP session.</source>
          <target state="translated">일반적인 HTTP 세션의 흐름을 보여주고 설명합니다.</target>
        </trans-unit>
        <trans-unit id="b6521e0115890c1ed8f83a94f59102ecaefa0222" translate="yes" xml:space="preserve">
          <source>Sign out of web site</source>
          <target state="translated">웹 사이트에서 로그 아웃</target>
        </trans-unit>
        <trans-unit id="41efbf8a181438e8fc19ee9def30f3ef38ba127a" translate="yes" xml:space="preserve">
          <source>Sign-out</source>
          <target state="translated">Sign-out</target>
        </trans-unit>
        <trans-unit id="49ea2b0538dc5d77e0f7d9a719fad7e94390af26" translate="yes" xml:space="preserve">
          <source>Signals to the user agent that compliance with the Certificate Transparency policy should be enforced (rather than only reporting compliance) and that the user agent should refuse future connections that violate its Certificate Transparency policy.</source>
          <target state="translated">인증서 투명성 정책을 준수해야한다는 것이 아니라 인증서 투명성 정책을 준수해야하며 사용자 에이전트는 인증서 투명성 정책을 위반하는 향후 연결을 거부해야한다는 사용자 에이전트에 알립니다.</target>
        </trans-unit>
        <trans-unit id="d8e8cee5872465deb3080e8822404564c2c7c96c" translate="yes" xml:space="preserve">
          <source>Similar to &lt;a href=&quot;headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;headers/if-unmodified-since&quot;&gt;&lt;code&gt;If-Unmodified-Since&lt;/code&gt;&lt;/a&gt;, but can have only one single etag, or one date. If it fails, the range request fails, and instead of a &lt;a href=&quot;status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; response, a &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt; is sent with the complete resource.</source>
          <target state="translated">유사에 &lt;a href=&quot;headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; , 또는 &lt;a href=&quot;headers/if-unmodified-since&quot;&gt; &lt;code&gt;If-Unmodified-Since&lt;/code&gt; &lt;/a&gt; ,하지만 하나의 ETAG, 또는 하나의 일을 할 수 있습니다. 실패하면 범위 요청이 실패하고 &lt;a href=&quot;status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 응답 대신 완전한 자원과 함께 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 가 전송됩니다.</target>
        </trans-unit>
        <trans-unit id="e46dbd8cd6429badd706773975b6b00d0b709805" translate="yes" xml:space="preserve">
          <source>Similar to the HTTP header, several features can be controlled at the same time by specifying a semicolon-separated list of policy directives.</source>
          <target state="translated">HTTP 헤더와 유사하게 세미콜론으로 구분 된 정책 지시문 목록을 지정하여 여러 기능을 동시에 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1d1d80cfcc4676e37337cc4f5d6a84bedb5462d2" translate="yes" xml:space="preserve">
          <source>Similarly, for binary documents without a specific or known subtype, &lt;code&gt;application/octet-stream&lt;/code&gt; should be used.</source>
          <target state="translated">마찬가지로 특정 또는 알려진 하위 유형이없는 이진 문서의 경우 &lt;code&gt;application/octet-stream&lt;/code&gt; 사용해야합니다.</target>
        </trans-unit>
        <trans-unit id="b0a5bca6adaca9564e0b94bdaad3a91197512ef9" translate="yes" xml:space="preserve">
          <source>Similarly, the link element can be used to resolve hostnames without providing a complete URL, but only, by preceding the hostname with two slashes:</source>
          <target state="translated">마찬가지로 링크 요소를 사용하여 완전한 URL을 제공하지 않고 호스트 이름 앞에 두 개의 슬래시를 붙여야 호스트 이름을 확인할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="3b3bdb2d208400327aac2b623589a8a18ecdfc8d" translate="yes" xml:space="preserve">
          <source>Simple cross-site requests</source>
          <target state="translated">간단한 크로스 사이트 요청</target>
        </trans-unit>
        <trans-unit id="2c183543e074fb1a91056f30dcfaf12aabc8df68" translate="yes" xml:space="preserve">
          <source>Simple requests</source>
          <target state="translated">간단한 요청</target>
        </trans-unit>
        <trans-unit id="8093dd58a33027a1dce2c902fa777fafd90c9a4e" translate="yes" xml:space="preserve">
          <source>Simple text/plain data</source>
          <target state="translated">간단한 텍스트 / 일반 데이터</target>
        </trans-unit>
        <trans-unit id="0edf1fa8008779642e22dc0f34ef947c356e021c" translate="yes" xml:space="preserve">
          <source>Simple text/plain data. Note the use of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding&quot;&gt;percent-encoding&lt;/a&gt; (URL-encoding) for the quote and space characters. Also, for CSV data (MIME type &quot;text/csv&quot;), percent-encoding is needed to preserve the line endings that delimit rows of the spreadsheet.</source>
          <target state="translated">간단한 텍스트 / 일반 데이터. 따옴표 및 공백 문자 에 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/percent-encoding&quot;&gt;백분율 인코딩&lt;/a&gt; (URL 인코딩)을 사용합니다. 또한 CSV 데이터 (MIME 유형 &quot;text / csv&quot;)의 경우 스프레드 시트의 행을 구분하는 줄 끝을 유지하기 위해 백분율 인코딩이 필요합니다.</target>
        </trans-unit>
        <trans-unit id="28ea2b82bad9055a11bf6b84d9f7527a0f5e40f3" translate="yes" xml:space="preserve">
          <source>Simply put, the origin making the request does not match any of the origins permitted by the &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt;&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">간단히 말해, 요청하는 원점이 &lt;a href=&quot;../../headers/access-control-allow-origin&quot;&gt; &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; &lt;/a&gt; 헤더에 의해 허용 된 원점과 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="113900181c81db75435ae6243c0c7016d22cda73" translate="yes" xml:space="preserve">
          <source>Since 2005, the set of APIs available to Web pages greatly increased and several of these APIs created extensions, mostly new specific HTTP headers, to the HTTP protocol for specific purposes:</source>
          <target state="translated">2005 년 이후 웹 페이지에서 사용 가능한 API 세트가 크게 증가했으며 이러한 API 중 일부는 특정 목적을 위해 HTTP 프로토콜에 대한 확장 (주로 새로운 특정 HTTP 헤더)을 작성했습니다.</target>
        </trans-unit>
        <trans-unit id="38b3000a242aaf507c808ecf6b19d0bcb64c3ad2" translate="yes" xml:space="preserve">
          <source>Since HTTP/1.0, different types of content can be transmitted. This article explains how this is accomplished using the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header and the MIME standard.</source>
          <target state="translated">HTTP / 1.0부터 다양한 유형의 콘텐츠를 전송할 수 있습니다. 이 문서에서는 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더와 MIME 표준을 사용하여이를 수행하는 방법을 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="99fb1a5dd25ea500036c8caefba3949cfbcb90c0" translate="yes" xml:space="preserve">
          <source>Since HTTP/1.0, different types of content can be transmitted. This article explains how this is done using the &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header and the MIME standard.</source>
          <target state="translated">HTTP / 1.0부터 다른 유형의 컨텐츠를 전송할 수 있습니다. 이 문서에서는 &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더와 MIME 표준을 사용하여이 작업을 수행하는 방법에 대해 설명합니다 .</target>
        </trans-unit>
        <trans-unit id="6a1c0077fb81ec47c18951a65d81853f40257980" translate="yes" xml:space="preserve">
          <source>Since all HTTP entities are represented in HTTP messages as sequences
   of bytes, the concept of a byte range is meaningful for any HTTP
   entity. (However, not all clients and servers need to support byte-
   range operations.)

   Byte range specifications in HTTP apply to the sequence of bytes in
   the entity-body (not necessarily the same as the message-body).

   A byte range operation MAY specify a single range of bytes, or a set
   of ranges within a single entity.

       ranges-specifier = byte-ranges-specifier
       byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
       byte-range-set  = 1#( byte-range-spec | suffix-byte-range-spec )
       byte-range-spec = first-byte-pos &quot;-&quot; [last-byte-pos]
       first-byte-pos  = 1*DIGIT
       last-byte-pos   = 1*DIGIT

   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range. The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive. Byte offsets start at zero.

   If the last-byte-pos value is present, it MUST be greater than or
   equal to the first-byte-pos in that byte-range-spec, or the byte-
   range-spec is syntactically invalid. The recipient of a byte-range-
   set that includes one or more syntactically invalid byte-range-spec
   values MUST ignore the header field that includes that byte-range-
   set.

   If the last-byte-pos value is absent, or if the value is greater than
   or equal to the current length of the entity-body, last-byte-pos is
   taken to be equal to one less than the current length of the entity-
   body in bytes.

   By its choice of last-byte-pos, a client can limit the number of
   bytes retrieved without knowing the size of the entity. 

       suffix-byte-range-spec = &quot;-&quot; suffix-length
       suffix-length = 1*DIGIT

   A suffix-byte-range-spec is used to specify the suffix of the
   entity-body, of a length given by the suffix-length value. (That is,
   this form specifies the last N bytes of an entity-body.) If the
   entity is shorter than the specified suffix-length, the entire
   entity-body is used.

   If a syntactically valid byte-range-set includes at least one byte-
   range-spec whose first-byte-pos is less than the current length of
   the entity-body, or at least one suffix-byte-range-spec with a non-
   zero suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. If the byte-range-set
   is unsatisfiable, the server SHOULD return a response with a status
   of 416 (Requested range not satisfiable). Otherwise, the server
   SHOULD return a response with a status of 206 (Partial Content)
   containing the satisfiable ranges of the entity-body.

   Examples of byte-ranges-specifier values (assuming an entity-body of
   length 10000):

      - The first 500 bytes (byte offsets 0-499, inclusive):  bytes=0-
        499

      - The second 500 bytes (byte offsets 500-999, inclusive):
        bytes=500-999

      - The final 500 bytes (byte offsets 9500-9999, inclusive):
        bytes=-500

      - Or bytes=9500-

      - The first and last bytes only (bytes 0 and 9999):  bytes=0-0,-1

      - Several legal but not canonical specifications of the second 500
        bytes (byte offsets 500-999, inclusive):
         bytes=500-600,601-999
         bytes=500-700,601-999</source>
          <target state="translated">모든 HTTP 엔티티는 HTTP 메시지에 바이트 시퀀스로 표시되므로 바이트 범위의 개념은 모든 HTTP 엔티티에 의미가 있습니다. 그러나 모든 클라이언트와 서버가 바이트 범위 작업을 지원할 필요는 없습니다. HTTP의 바이트 범위 사양은 엔터티 본문의 바이트 시퀀스에 적용됩니다 (메시지 본문과 반드시 ​​같을 필요는 없음). 바이트 범위 연산은 단일 바이트 범위 또는 단일 엔티티 내 범위 세트를 지정할 수 있습니다. 범위 지정자 = 바이트 범위 지정자 바이트 범위 지정자 = 바이트 단위 &quot;=&quot;바이트 범위 설정 바이트 범위 설정 = 1 # (byte-range-spec | suffix-byte-range-spec) 바이트 -range-spec = 첫 바이트 위치 &quot;-&quot;[last-byte-pos] first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT byte-range-spec의 first-byte-pos 값은 첫 번째 바이트의 바이트 오프셋을 범위. last-byte-pos 값은 범위 내에서 마지막 바이트의 바이트 오프셋을 제공합니다. 즉, 지정된 바이트 위치가 포함됩니다. 바이트 오프셋은 0에서 시작합니다. 마지막 바이트 위치 값이 존재하는 경우 해당 바이트 범위 스펙의 첫 번째 바이트 위치보다 크거나 같아야합니다. 그렇지 않으면 바이트 범위 스펙이 구문 상 유효하지 않습니다. 하나 이상의 구문 상 유효하지 않은 바이트 범위 스펙 값을 포함하는 바이트 범위 세트의 수신자는 해당 바이트 범위 세트를 포함하는 헤더 필드를 무시해야합니다. last-byte-pos 값이 없거나 값이 엔티티 본문의 현재 길이보다 크거나 같은 경우,last-byte-pos는 엔티티 본문의 현재 길이보다 1 바이트 작습니다. last-byte-pos를 선택함으로써 클라이언트는 엔티티의 크기를 몰라도 검색된 바이트 수를 제한 할 수 있습니다. suffix-byte-range-spec = &quot;-&quot;접미사 길이 suffix-length = 1 * DIGIT suffix-byte-range-spec은 엔티티 본문의 접미사를 접미사 길이로 지정된 길이로 지정하는 데 사용됩니다. 값. 즉,이 형식은 엔터티 본문의 마지막 N 바이트를 지정합니다. 엔터티가 지정된 접미사 길이보다 짧은 경우 전체 엔터티 본문이 사용됩니다. 구문 적으로 유효한 바이트 범위 세트에 첫 번째 바이트 위치가 엔티티 본문의 현재 길이보다 작은 하나 이상의 바이트 범위 스펙이 포함되거나 그렇지 않은 경우 하나 이상의 접미사 바이트 범위 스펙이 포함 된 경우 -접미사 길이가 0 인 경우바이트 범위 세트는 만족할 만하다. 그렇지 않으면 바이트 범위 세트가 만족스럽지 않습니다. 바이트 범위 세트가 만족스럽지 않으면 서버는 상태 416 (요청한 범위가 만족스럽지 않음) 인 응답을 리턴해야합니다. 그렇지 않으면 서버는 엔티티 본문의 만족스러운 범위를 포함하는 상태가 206 (부분 컨텐츠) 인 응답을 리턴해야합니다. 바이트 범위 지정자 값의 예 (길이 10000의 엔티티-본체를 가정) :-첫 500 바이트 (바이트 오프셋 0-499 포함) : bytes = 0-499-두 번째 500 바이트 (바이트 오프셋 500-999) ) : bytes = 500-999-마지막 500 바이트 (바이트 오프셋 9500-9999 포함) : bytes = -500-또는 bytes = 9500--첫 번째와 마지막 바이트 만 (바이트 0 및 9999) : bytes = 0-0,-1-두 번째 500 바이트의 몇 가지 법적이지만 표준이 아닌 사양 (바이트 오프셋 500-999 포함) : bytes = 500-600,601-999 bytes = 500-700,601-999</target>
        </trans-unit>
        <trans-unit id="6477522ed9958316dd956b0c178201d047372002" translate="yes" xml:space="preserve">
          <source>Since both origin servers and caches will compare two validators to
   decide if they represent the same or different entities, one normally
   would expect that if the entity (the entity-body or any entity-
   headers) changes in any way, then the associated validator would
   change as well. If this is true, then we call this validator a
   &quot;strong validator.&quot;

   However, there might be cases when a server prefers to change the
   validator only on semantically significant changes, and not when
   insignificant aspects of the entity change. A validator that does not
   always change when the resource changes is a &quot;weak validator.&quot;

   Entity tags are normally &quot;strong validators,&quot; but the protocol
   provides a mechanism to tag an entity tag as &quot;weak.&quot; One can think of
   a strong validator as one that changes whenever the bits of an entity
   changes, while a weak value changes whenever the meaning of an entity
   changes. Alternatively, one can think of a strong validator as part
   of an identifier for a specific entity, while a weak validator is
   part of an identifier for a set of semantically equivalent entities.

      Note: One example of a strong validator is an integer that is
      incremented in stable storage every time an entity is changed. 

      An entity's modification time, if represented with one-second
      resolution, could be a weak validator, since it is possible that
      the resource might be modified twice during a single second.

      Support for weak validators is optional. However, weak validators
      allow for more efficient caching of equivalent objects; for
      example, a hit counter on a site is probably good enough if it is
      updated every few days or weeks, and any value during that period
      is likely &quot;good enough&quot; to be equivalent.

   A &quot;use&quot; of a validator is either when a client generates a request
   and includes the validator in a validating header field, or when a
   server compares two validators.

   Strong validators are usable in any context. Weak validators are only
   usable in contexts that do not depend on exact equality of an entity.
   For example, either kind is usable for a conditional GET of a full
   entity. However, only a strong validator is usable for a sub-range
   retrieval, since otherwise the client might end up with an internally
   inconsistent entity.

   Clients MAY issue simple (non-subrange) GET requests with either weak
   validators or strong validators. Clients MUST NOT use weak validators
   in other forms of request.

   The only function that the HTTP/1.1 protocol defines on validators is
   comparison. There are two validator comparison functions, depending
   on whether the comparison context allows the use of weak validators
   or not:

      - The strong comparison function: in order to be considered equal,
        both validators MUST be identical in every way, and both MUST
        NOT be weak.

      - The weak comparison function: in order to be considered equal,
        both validators MUST be identical in every way, but either or
        both of them MAY be tagged as &quot;weak&quot; without affecting the
        result.

   An entity tag is strong unless it is explicitly tagged as weak.
   &lt;a href=&quot;#section-3.11&quot;&gt;Section 3.11&lt;/a&gt; gives the syntax for entity tags.

   A Last-Modified time, when used as a validator in a request, is
   implicitly weak unless it is possible to deduce that it is strong,
   using the following rules:

      - The validator is being compared by an origin server to the
        actual current validator for the entity and, 

      - That origin server reliably knows that the associated entity did
        not change twice during the second covered by the presented
        validator.

   or

      - The validator is about to be used by a client in an If-
        Modified-Since or If-Unmodified-Since header, because the client
        has a cache entry for the associated entity, and

      - That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and

      - The presented Last-Modified time is at least 60 seconds before
        the Date value.

   or

      - The validator is being compared by an intermediate cache to the
        validator stored in its cache entry for the entity, and

      - That cache entry includes a Date value, which gives the time
        when the origin server sent the original response, and

      - The presented Last-Modified time is at least 60 seconds before
        the Date value.

   This method relies on the fact that if two different responses were
   sent by the origin server during the same second, but both had the
   same Last-Modified time, then at least one of those responses would
   have a Date value equal to its Last-Modified time. The arbitrary 60-
   second limit guards against the possibility that the Date and Last-
   Modified values are generated from different clocks, or at somewhat
   different times during the preparation of the response. An
   implementation MAY use a value larger than 60 seconds, if it is
   believed that 60 seconds is too short.

   If a client wishes to perform a sub-range retrieval on a value for
   which it has only a Last-Modified time and no opaque validator, it
   MAY do this only if the Last-Modified time is strong in the sense
   described here.

   A cache or origin server receiving a conditional request, other than
   a full-body GET request, MUST use the strong comparison function to
   evaluate the condition.

   These rules allow HTTP/1.1 caches and clients to safely perform sub-
   range retrievals on values that have been obtained from HTTP/1.0 

   servers.</source>
          <target state="translated">오리진 서버와 캐시는 두 개의 유효성 검사기를 비교하여 동일하거나 다른 엔티티를 나타내는 지 여부를 결정하므로 일반적으로 엔티티 (엔티티-본체 또는 엔티티 헤더)가 어떤 방식 으로든 변경 될 경우 연결된 유효성 검사기가 또한 변경하십시오. 이것이 사실이라면, 우리는이 검증자를 &quot;강력한 검증 자&quot;라고 부릅니다. 그러나 서버가 의미 적으로 중요한 변경에 대해서만 유효성 검사기를 변경하는 것을 선호하고 엔티티의 중요하지 않은 측면이 변경되지 않는 경우가 있습니다. 리소스가 변경 될 때 항상 변경되지 않는 유효성 검사기는 &quot;약한 유효성 검사기&quot;입니다. 엔티티 태그는 일반적으로 &quot;강력한 유효성 검사기&quot;이지만 프로토콜은 엔티티 태그에 &quot;약한&quot;태그를 지정하는 메커니즘을 제공합니다.강력한 유효성 검사기는 엔터티의 비트가 변경 될 때마다 변경되는 반면, 약한 값은 엔터티의 의미가 변경 될 때마다 변경되는 것으로 생각할 수 있습니다. 대안 적으로, 강한 유효성 검사기는 특정 엔티티에 대한 식별자의 일부로서 생각할 수있는 반면, 약한 유효성 검사기는 의미 적으로 동등한 엔티티 세트에 대한 식별자의 일부이다. 참고 : 강력한 유효성 검사기의 한 예는 엔터티가 변경 될 때마다 안정적인 저장소에서 증가하는 정수입니다. 1 초의 해상도로 표시되는 엔터티의 수정 시간은 약 1 초 동안 리소스가 두 번 수정 될 수 있기 때문에 약한 유효성 검사기가 될 수 있습니다. 약한 유효성 검사기 지원은 선택 사항입니다. 그러나 약한 유효성 검사기는 동등한 개체를보다 효율적으로 캐싱 할 수 있습니다.예를 들어, 사이트의 적중 카운터는 며칠 또는 몇 주마다 업데이트되는 경우 충분할 수 있으며 해당 기간 동안의 값은 &quot;충분히 충분&quot;할 가능성이 높습니다. 유효성 검사기의 &quot;사용&quot;은 클라이언트가 요청을 생성하고 유효성 검사 헤더 필드에 유효성 검사기를 포함하거나 서버가 두 유효성 검사기를 비교할 때입니다. 어떤 상황에서도 강력한 유효성 검사기를 사용할 수 있습니다. 약한 유효성 검사기는 엔터티의 정확한 동등성에 의존하지 않는 컨텍스트에서만 사용할 수 있습니다. 예를 들어, 두 종류 모두 전체 엔티티의 조건부 GET에 사용할 수 있습니다. 그러나 하위 범위 검색에는 강력한 유효성 검사기 만 사용할 수 있습니다. 그렇지 않으면 클라이언트가 내부적으로 일치하지 않는 엔터티로 끝날 수 있기 때문입니다.클라이언트는 약한 유효성 검사기 또는 강력한 유효성 검사기와 함께 간단한 (하위 범위가 아닌) GET 요청을 발행 할 수 있습니다. 고객은 다른 형식의 요청에 약한 유효성 검사기를 사용해서는 안됩니다. HTTP / 1.1 프로토콜이 유효성 검사기에서 정의하는 유일한 기능은 비교입니다. 비교 컨텍스트가 약한 유효성 검사기의 사용을 허용하는지 여부에 따라 두 가지 유효성 검사기 비교 함수가 있습니다.-강력한 비교 기능 : 동일한 것으로 간주 되려면 두 유효성 검사기가 모든면에서 동일해야하며 두 가지 모두 약해야합니다. . 약한 비교 기능 : 동일하게 간주 되려면 두 유효성 검사기가 모든면에서 동일해야하지만 결과에 영향을주지 않으면 서 두 가지 중 하나 또는 모두가 &quot;약한&quot;태그를 지정할 수 있습니다.엔터티 태그는 명시 적으로 약한 태그가없는 한 강력합니다. &lt;a href=&quot;#section-3.11&quot;&gt;섹션 3.11&lt;/a&gt;엔티티 태그의 구문을 제공합니다. 요청에서 유효성 검사기로 사용되는 Last-Modified 시간은 다음 규칙을 사용하여 강력하다고 추론 할 수 없으면 암시 적으로 약합니다.-원본 서버에서 유효성 검사기의 실제 유효성 검사기와 비교 실체 서버,-그 오리진 서버는 제시된 검증자가 다루는 두 번째 동안 연관된 실체가 두 번 바뀌지 않았다는 것을 확실히 알고있다. 또는-클라이언트가 관련 엔터티에 대한 캐시 항목을 가지고 있기 때문에 클라이언트가 If- Modified-Since 또는 If-Unmodified-Since 헤더에서 유효성 검사기를 사용하려고합니다.-이 캐시 항목에는 Date 값이 포함되어 있습니다. 오리진 서버가 원래 응답을 보낸 시간을 제공합니다.-제시된 마지막 수정 시간은 날짜 값보다 60 초 전입니다. 또는-유효성 검사기가 중간 캐시에 의해 엔티티에 대한 캐시 항목에 저장된 유효성 검사기와 비교되고 있으며,-이 캐시 항목은 날짜 값을 포함하며, 이는 원래 서버가 원래 응답을 보낸 시간을 제공합니다. 마지막으로 수정 한 시간은 날짜 값보다 적어도 60 초 전입니다. 이 방법은 동일한 초 동안 두 개의 서로 다른 응답이 오리진 서버에 의해 전송되었지만 둘 다 동일한 Last-Modified 시간을 가졌다면 해당 응답 중 하나 이상이 Last-Modified와 동일한 Date 값을 가질 것이라는 사실에 의존합니다. 시각.임의의 60 초 제한은 Date 및 Last-Modified 값이 다른 클럭에서 생성되거나 응답 준비 중에 약간 다른 시간에 생성 될 가능성을 방지합니다. 구현에 60 초가 너무 짧은 경우 60 초보다 큰 값을 사용할 수 있습니다. 클라이언트가 Last-Modified 시간 만 있고 불투명 유효성 검사기가없는 값에 대해 하위 범위 검색을 수행하려는 경우 여기에 설명 된 의미에서 Last-Modified 시간이 강한 경우에만이를 수행 할 수 있습니다. 전신 GET 요청 이외의 조건부 요청을 수신하는 캐시 또는 오리진 서버는 강력한 비교 기능을 사용하여 조건을 평가해야합니다. 이 규칙은 HTTP / 1을 허용합니다.HTTP / 1.0 서버에서 얻은 값에 대해 하위 범위 검색을 안전하게 수행하기위한 1 개의 캐시 및 클라이언트.</target>
        </trans-unit>
        <trans-unit id="b5e7d8ecc2e2bfd0337480eba5175d544e816618" translate="yes" xml:space="preserve">
          <source>Since by definition the actual function performed by POST is
   determined by the server and often depends on the particular
   resource, the behavior of POST when applied to collections cannot be
   meaningfully modified because it is largely undefined.  Thus, the
   semantics of POST are unmodified when applied to a collection.</source>
          <target state="translated">정의에 따라 POST에 의해 수행되는 실제 기능은 서버에 의해 결정되며 종종 특정 리소스에 의존하기 때문에 컬렉션에 적용될 때 POST의 동작은 크게 정의되지 않기 때문에 의미있게 수정할 수 없습니다. 따라서 POST의 의미는 컬렉션에 적용될 때 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6b8845c337661637cd002489923ad6132dc450c6" translate="yes" xml:space="preserve">
          <source>Since origin servers do not always provide explicit expiration times,
   HTTP caches typically assign heuristic expiration times, employing
   algorithms that use other header values (such as the Last-Modified
   time) to estimate a plausible expiration time. The HTTP/1.1
   specification does not provide specific algorithms, but does impose
   worst-case constraints on their results. Since heuristic expiration
   times might compromise semantic transparency, they ought to used
   cautiously, and we encourage origin servers to provide explicit
   expiration times as much as possible.</source>
          <target state="translated">오리진 서버가 항상 명시적인 만료 시간을 제공하는 것은 아니기 때문에 HTTP 캐시는 일반적으로 휴리스틱 만료 시간을 할당하고 다른 헤더 값 (예 : Last-Modified 시간)을 사용하여 그럴듯한 만료 시간을 추정하는 알고리즘을 사용합니다. HTTP / 1.1 사양은 특정 알고리즘을 제공하지 않지만 결과에 최악의 제약 조건을 부과합니다. 휴리스틱 만료 시간은 의미 투명성을 손상시킬 수 있으므로 신중하게 사용해야하며 원본 서버가 가능한 한 명시적인 만료 시간을 제공하도록 권장합니다.</target>
        </trans-unit>
        <trans-unit id="28a6db603d3e3f168ecb1f550fddcf24914727e1" translate="yes" xml:space="preserve">
          <source>Since origin servers do not always provide explicit expiration times,
   a cache MAY assign a heuristic expiration time when an explicit time
   is not specified, employing algorithms that use other header field
   values (such as the Last-Modified time) to estimate a plausible
   expiration time.  This specification does not provide specific
   algorithms, but does impose worst-case constraints on their results.

   A cache MUST NOT use heuristics to determine freshness when an
   explicit expiration time is present in the stored response.  Because
   of the requirements in &lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;, this means that, effectively,
   heuristics can only be used on responses without explicit freshness
   whose status codes are defined as cacheable by default (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;Section&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;6.1 of [RFC7231]&lt;/a&gt;), and those responses without explicit freshness
   that have been marked as explicitly cacheable (e.g., with a &quot;public&quot;
   response directive).

   If the response has a Last-Modified header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of
   [RFC7232]&lt;/a&gt;), caches are encouraged to use a heuristic expiration value
   that is no more than some fraction of the interval since that time.
   A typical setting of this fraction might be 10%.

   When a heuristic is used to calculate freshness lifetime, a cache
   SHOULD generate a Warning header field with a 113 warn-code (see
   &lt;a href=&quot;#section-5.5.4&quot;&gt;Section 5.5.4&lt;/a&gt;) in the response if its current_age is more than 24
   hours and such a warning is not already present.

      Note: &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.9&quot;&gt;Section&amp;nbsp;13.9 of [RFC2616]&lt;/a&gt; prohibited caches from calculating
      heuristic freshness for URIs with query components (i.e., those
      containing '?').  In practice, this has not been widely
      implemented.  Therefore, origin servers are encouraged to send
      explicit directives (e.g., Cache-Control: no-cache) if they wish
      to preclude caching.</source>
          <target state="translated">오리진 서버가 항상 명시적인 만료 시간을 제공하지는 않기 때문에 캐시는 명시적인 시간이 지정되지 않은 경우 휴리스틱 만료 시간을 할당하고 다른 헤더 필드 값 (예 : Last-Modified 시간)을 사용하여 적절한 만료 시간을 추정하는 알고리즘을 사용합니다. . 이 사양은 특정 알고리즘을 제공하지 않지만 결과에 최악의 제약 조건을 부과합니다. 저장된 응답에 명시적인 만료 시간이있을 때 캐시는 휴리스틱을 사용하여 최신 성을 결정해서는 안됩니다. &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt; 의 요구 사항으로 인해 휴리스틱은 상태 코드가 기본적으로 캐시 가능한 것으로 정의 된 명시 적 최신 정보가없는 응답에만 효과적으로 사용할 수 있습니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;[RFC7231] &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.1&quot;&gt;섹션 &lt;/a&gt;6.1 참조) .) 및 명시 적으로 캐시 할 수있는 것으로 표시된 (예 : &quot;공개&quot;응답 지시문이있는) 명시 적 최신 정보가없는 응답 응답에 Last-Modified 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]의 섹션 2.2&lt;/a&gt; )가있는 경우 캐시는 해당 시간 이후 간격의 일부에 불과한 휴리스틱 만료 값을 사용하도록 권장됩니다. 이 분수의 일반적인 설정은 10 % 일 수 있습니다. 휴리스틱이 신선도 수명을 계산하는 데 사용될 때 캐시는 current_age가 24 시간 이상이고 이러한 경고가 아직 존재하지 않는 경우 응답에 113 경고 코드 ( &lt;a href=&quot;#section-5.5.4&quot;&gt;5.5.4 절&lt;/a&gt; 참조)와 함께 경고 헤더 필드를 생성해야합니다 (SHOULD ). . 참고 : &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.9&quot;&gt;[RFC2616]의 섹션 13.9&lt;/a&gt;캐시가 쿼리 구성 요소가있는 URI (예 : '?'가 포함 된 URI)의 휴리스틱 신선도를 계산하지 못하도록합니다. 실제로 이것은 널리 구현되지 않았습니다. 따라서 원 서버는 캐싱을 금지하려는 경우 명시 적 지시문 (예 : Cache-Control : no-cache)을 보내도록 권장됩니다.</target>
        </trans-unit>
        <trans-unit id="509ec028b2372cca14a02773e4ddea3d5e0dcfb9" translate="yes" xml:space="preserve">
          <source>Since property values are typically used to hold information such as
   the author of a document, there is the possibility that privacy
   concerns could arise stemming from widespread access to a resource's
   property data.  To reduce the risk of inadvertent release of private
   information via properties, servers are encouraged to develop access
   control mechanisms that separate read access to the resource body and
   read access to the resource's properties.  This allows a user to
   control the dissemination of their property data without overly
   restricting access to the resource's contents.</source>
          <target state="translated">속성 값은 일반적으로 문서 작성자와 같은 정보를 보유하는 데 사용되므로 리소스 속성 데이터에 대한 광범위한 액세스로 인해 개인 정보 보호 문제가 발생할 수 있습니다. 속성을 통한 개인 정보의 우발적 인 릴리스 위험을 줄이기 위해 서버는 리소스 본문에 대한 읽기 액세스와 리소스 속성에 대한 읽기 액세스를 분리하는 액세스 제어 메커니즘을 개발하는 것이 좋습니다. 이를 통해 사용자는 리소스 내용에 대한 액세스를 지나치게 제한하지 않고도 속성 데이터의 배포를 제어 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="cbc586157b2e078cf31d317a4f20a745527f123b" translate="yes" xml:space="preserve">
          <source>Since representation data is transferred in payloads as a sequence of
   octets, a byte range is a meaningful substructure for any
   representation transferable over HTTP (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;).  The
   &quot;bytes&quot; range unit is defined for expressing subranges of the data's
   octet sequence.

     bytes-unit       = &quot;bytes&quot;

   A byte-range request can specify a single range of bytes or a set of
   ranges within a single representation.

     byte-ranges-specifier = bytes-unit &quot;=&quot; byte-range-set
     byte-range-set  = 1#( byte-range-spec / suffix-byte-range-spec )
     byte-range-spec = first-byte-pos &quot;-&quot; [ last-byte-pos ]
     first-byte-pos  = 1*DIGIT
     last-byte-pos   = 1*DIGIT

   The first-byte-pos value in a byte-range-spec gives the byte-offset
   of the first byte in a range.  The last-byte-pos value gives the
   byte-offset of the last byte in the range; that is, the byte
   positions specified are inclusive.  Byte offsets start at zero.

   Examples of byte-ranges-specifier values:

   o  The first 500 bytes (byte offsets 0-499, inclusive):

        bytes=0-499

   o  The second 500 bytes (byte offsets 500-999, inclusive):

        bytes=500-999 

   A byte-range-spec is invalid if the last-byte-pos value is present
   and less than the first-byte-pos.

   A client can limit the number of bytes requested without knowing the
   size of the selected representation.  If the last-byte-pos value is
   absent, or if the value is greater than or equal to the current
   length of the representation data, the byte range is interpreted as
   the remainder of the representation (i.e., the server replaces the
   value of last-byte-pos with a value that is one less than the current
   length of the selected representation).

   A client can request the last N bytes of the selected representation
   using a suffix-byte-range-spec.

     suffix-byte-range-spec = &quot;-&quot; suffix-length
     suffix-length = 1*DIGIT

   If the selected representation is shorter than the specified
   suffix-length, the entire representation is used.

   Additional examples, assuming a representation of length 10000:

   o  The final 500 bytes (byte offsets 9500-9999, inclusive):

        bytes=-500

   Or:

        bytes=9500-

   o  The first and last bytes only (bytes 0 and 9999):

        bytes=0-0,-1

   o  Other valid (but not canonical) specifications of the second 500
      bytes (byte offsets 500-999, inclusive):

        bytes=500-600,601-999
        bytes=500-700,601-999

   If a valid byte-range-set includes at least one byte-range-spec with
   a first-byte-pos that is less than the current length of the
   representation, or at least one suffix-byte-range-spec with a
   non-zero suffix-length, then the byte-range-set is satisfiable.
   Otherwise, the byte-range-set is unsatisfiable. 

   In the byte-range syntax, first-byte-pos, last-byte-pos, and
   suffix-length are expressed as decimal number of octets.  Since there
   is no predefined limit to the length of a payload, recipients MUST
   anticipate potentially large decimal numerals and prevent parsing
   errors due to integer conversion overflows.</source>
          <target state="translated">표현 데이터는 일련의 8 진수로 페이로드로 전송되므로 바이트 범위는 HTTP를 통해 전송할 수있는 표현의 의미있는 하위 구조입니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;섹션 3 [RFC7231]&lt;/a&gt;). &quot;바이트&quot;범위 단위는 데이터 옥텟 시퀀스의 하위 범위를 표현하기 위해 정의됩니다. bytes-unit = &quot;bytes&quot;바이트 범위 요청은 단일 표현 내에서 단일 바이트 범위 또는 범위 세트를 지정할 수 있습니다. 바이트 범위 지정자 = 바이트 단위 &quot;=&quot;바이트 범위 설정 바이트 범위 설정 = 1 # (바이트 범위 범위 / 접미사 바이트 범위 범위) 바이트 범위 범위 = 첫 번째 바이트- pos &quot;-&quot;[last-byte-pos] first-byte-pos = 1 * DIGIT last-byte-pos = 1 * DIGIT byte-range-spec의 first-byte-pos 값은 바이트 오프셋을 제공합니다. 범위의 첫 번째 바이트. last-byte-pos 값은 범위 내에서 마지막 바이트의 바이트 오프셋을 제공합니다. 즉, 지정된 바이트 위치가 포함됩니다. 바이트 오프셋은 0에서 시작합니다. 바이트 범위 지정자 값의 예 :o 첫 번째 500 바이트 (바이트 오프셋 0-499 포함) : bytes = 0-499 o 두 번째 500 바이트 (바이트 오프셋 500-999 포함) : bytes = 500-999 바이트 범위 스펙은 다음과 같은 경우에 유효하지 않습니다. last-byte-pos 값이 있으며 첫 번째 byte-pos보다 작습니다. 클라이언트는 선택된 표현의 크기를 몰라도 요청 된 바이트 수를 제한 할 수 있습니다. 마지막 바이트 위치 값이 없거나 값이 현재 표현 데이터 길이보다 크거나 같은 경우 바이트 범위는 나머지 표현으로 해석됩니다 (즉, 서버가 마지막 값을 대체 함). -byte-pos는 선택된 표현의 현재 길이보다 1보다 작은 값을가집니다). 클라이언트는 접미사-바이트-범위-사양을 사용하여 선택된 표현의 마지막 N 바이트를 요청할 수 있습니다.suffix-byte-range-spec = &quot;-&quot;접미사 길이 suffix-length = 1 * DIGIT 선택한 표현이 지정된 접미사 길이보다 짧은 경우 전체 표현이 사용됩니다. 길이 10000의 표현을 가정 한 추가 예제 : o 마지막 500 바이트 (바이트 오프셋 9500-9999 포함) : bytes = -500 또는 : bytes = 9500- o 첫 번째와 마지막 바이트 만 (바이트 0 및 9999) : 바이트 = 0-0, -1 o 두 번째 500 바이트의 다른 유효한 (표준이 아닌) 사양 (바이트 오프셋 500-999 포함) : bytes = 500-600,601-999 bytes = 500-700,601-999 유효한 바이트 범위 세트는 표현의 현재 길이보다 작은 첫 번째 바이트 위치를 갖는 하나 이상의 바이트 범위 스펙을 포함합니다.또는 0이 아닌 접미사 길이를 갖는 적어도 하나의 접미사-바이트-범위-사양이면, 바이트-범위-세트가 만족 가능하다. 그렇지 않으면 바이트 범위 세트가 만족스럽지 않습니다. 바이트 범위 구문에서 first-byte-pos, last-byte-pos 및 suffix-length는 10 진수의 10 진수로 표시됩니다. 페이로드의 길이에는 사전 정의 된 제한이 없으므로 수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다.수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다.수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다.</target>
        </trans-unit>
        <trans-unit id="774d5768b3cb89b1969b07ba3f6b81f799741b41" translate="yes" xml:space="preserve">
          <source>Since server lock support is optional, a client trying to lock a
   resource on a server can either try the lock and hope for the best,
   or perform some form of discovery to determine what lock capabilities
   the server supports.  This is known as lock capability discovery.  A
   client can determine what lock types the server supports by
   retrieving the DAV:supportedlock property.

   Any DAV-compliant resource that supports the LOCK method MUST support
   the DAV:supportedlock property.</source>
          <target state="translated">서버 잠금 지원은 선택 사항이므로 서버에서 리소스를 잠그려고하는 클라이언트는 잠금을 시도하고 최선을 다하거나 서버가 어떤 잠금 기능을 지원하는지 파악하기 위해 검색을 수행 할 수 있습니다. 이것을 잠금 기능 발견이라고합니다. 클라이언트는 DAV : supportedlock 특성을 검색하여 서버가 지원하는 잠금 유형을 판별 할 수 있습니다. LOCK 메소드를 지원하는 모든 DAV 호환 자원은 DAV : supportedlock 특성을 지원해야합니다.</target>
        </trans-unit>
        <trans-unit id="94a8f31f5d75fba5bea69bbed106207fdc98fadf" translate="yes" xml:space="preserve">
          <source>Since the &quot;http&quot; and &quot;https&quot; schemes conform to the URI generic
   syntax, such URIs are normalized and compared according to the
   algorithm defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-6&quot;&gt;Section&amp;nbsp;6 of [RFC3986]&lt;/a&gt;, using the defaults
   described above for each scheme.

   If the port is equal to the default port for a scheme, the normal
   form is to omit the port subcomponent.  When not being used in
   absolute form as the request target of an OPTIONS request, an empty
   path component is equivalent to an absolute path of &quot;/&quot;, so the
   normal form is to provide a path of &quot;/&quot; instead.  The scheme and host
   are case-insensitive and normally provided in lowercase; all other
   components are compared in a case-sensitive manner.  Characters other
   than those in the &quot;reserved&quot; set are equivalent to their
   percent-encoded octets: the normal form is to not encode them (see
   Sections &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; and &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; of [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;]).

   For example, the following three URIs are equivalent:

      &lt;a href=&quot;http://example.com:80/~smith/home.html&quot;&gt;http://example.com:80/~smith/home.html&lt;/a&gt;
      http://EXAMPLE.com/%7Esmith/home.html
      &lt;a href=&quot;http://EXAMPLE.com/%7esmith/home.html&quot;&gt;http://EXAMPLE.com:/%7esmith/home.html&lt;/a&gt;</source>
          <target state="translated">&quot;http&quot;및 &quot;https&quot;체계는 URI 일반 구문을 따르므로 이러한 URI는 정규화되어 &lt;a href=&quot;https://tools.ietf.org/html/rfc3986#section-6&quot;&gt;[RFC3986]의 6 절에&lt;/a&gt; 정의 된 알고리즘에 따라 비교됩니다 .각 구성표에 대해 위에서 설명한 기본값을 사용합니다. 포트가 구성표의 기본 포트와 동일한 경우 일반적인 형식은 포트 하위 구성 요소를 생략하는 것입니다. OPTIONS 요청의 요청 대상으로 절대 형식으로 사용되지 않는 경우 빈 경로 구성 요소는 &quot;/&quot;의 절대 경로와 동일하므로 일반 형식은 대신 &quot;/&quot;의 경로를 제공하는 것입니다. 체계와 호스트는 대소 문자를 구분하지 않으며 일반적으로 소문자로 제공됩니다. 다른 모든 구성 요소는 대소 문자를 구분하여 비교됩니다. &quot;예약 된&quot;세트의 문자 이외의 문자는 퍼센트로 인코딩 된 8 진수와 같습니다. 일반적인 형식은 해당 문자를 인코딩하지 않는 것입니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; 의 &lt;a href=&quot;#section-2.1&quot;&gt;2.1&lt;/a&gt; 및 &lt;a href=&quot;#section-2.2&quot;&gt;2.2&lt;/a&gt; 단원 참조).]). 예를 들어 다음 세 가지 URI는 동일합니다. &lt;a href=&quot;http://example.com:80/~smith/home.html&quot;&gt;http://example.com:80/~smith/home.html&lt;/a&gt; http://EXAMPLE.com/%7Esmith/home.html &lt;a href=&quot;http://EXAMPLE.com/%7esmith/home.html&quot;&gt;http://EXAMPLE.com:/% 7esmith / home.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="3878be391d0341c64c35b2c3bb2ccfa884cc0a3f" translate="yes" xml:space="preserve">
          <source>Since the request-target often contains only part of the user agent's
   target URI, a server reconstructs the intended target as an
   &quot;effective request URI&quot; to properly service the request.  This
   reconstruction involves both the server's local configuration and
   information communicated in the request-target, Host header field,
   and connection context.

   For a user agent, the effective request URI is the target URI.

   If the request-target is in absolute-form, the effective request URI
   is the same as the request-target.  Otherwise, the effective request
   URI is constructed as follows:

      If the server's configuration (or outbound gateway) provides a
      fixed URI scheme, that scheme is used for the effective request
      URI.  Otherwise, if the request is received over a TLS-secured TCP
      connection, the effective request URI's scheme is &quot;https&quot;; if not,
      the scheme is &quot;http&quot;.

      If the server's configuration (or outbound gateway) provides a
      fixed URI authority component, that authority is used for the
      effective request URI.  If not, then if the request-target is in
      authority-form, the effective request URI's authority component is
      the same as the request-target.  If not, then if a Host header
      field is supplied with a non-empty field-value, the authority
      component is the same as the Host field-value.  Otherwise, the
      authority component is assigned the default name configured for
      the server and, if the connection's incoming TCP port number
      differs from the default port for the effective request URI's
      scheme, then a colon (&quot;:&quot;) and the incoming port number (in
      decimal form) are appended to the authority component.

      If the request-target is in authority-form or asterisk-form, the
      effective request URI's combined path and query component is
      empty.  Otherwise, the combined path and query component is the
      same as the request-target.

      The components of the effective request URI, once determined as
      above, can be combined into absolute-URI form by concatenating the
      scheme, &quot;://&quot;, authority, and combined path and query component. 

   Example 1: the following message received over an insecure TCP
   connection

     GET /pub/WWW/TheProject.html HTTP/1.1
     Host: www.example.org:8080

   has an effective request URI of

     &lt;a href=&quot;http://www.example.org:8080/pub/WWW/TheProject.html&quot;&gt;http://www.example.org:8080/pub/WWW/TheProject.html&lt;/a&gt;

   Example 2: the following message received over a TLS-secured TCP
   connection

     OPTIONS * HTTP/1.1
     Host: www.example.org

   has an effective request URI of

     https://www.example.org

   Recipients of an HTTP/1.0 request that lacks a Host header field
   might need to use heuristics (e.g., examination of the URI path for
   something unique to a particular host) in order to guess the
   effective request URI's authority component.

   Once the effective request URI has been constructed, an origin server
   needs to decide whether or not to provide service for that URI via
   the connection in which the request was received.  For example, the
   request might have been misdirected, deliberately or accidentally,
   such that the information within a received request-target or Host
   header field differs from the host or port upon which the connection
   has been made.  If the connection is from a trusted gateway, that
   inconsistency might be expected; otherwise, it might indicate an
   attempt to bypass security filters, trick the server into delivering
   non-public content, or poison a cache.  See &lt;a href=&quot;#section-9&quot;&gt;Section 9&lt;/a&gt; for security
   considerations regarding message routing.</source>
          <target state="translated">요청 대상에는 종종 사용자 에이전트 대상 URI의 일부만 포함되므로 서버는 요청을 올바르게 서비스하기 위해 의도 된 대상을 &quot;유효 요청 URI&quot;로 재구성합니다. 이 재구성에는 서버의 로컬 구성과 요청 대상, 호스트 헤더 필드 및 연결 컨텍스트에서 통신되는 정보가 모두 포함됩니다. 사용자 에이전트의 경우 유효 요청 URI는 대상 URI입니다. 요청 대상이 절대 형식 인 경우 유효 요청 URI는 요청 대상과 동일합니다. 그렇지 않으면 유효 요청 URI는 다음과 같이 구성됩니다. 서버 구성 (또는 아웃 바운드 게이트웨이)이 고정 URI 스킴을 제공하면 해당 스킴이 유효 요청 URI에 사용됩니다. 그렇지 않으면,요청이 TLS 보안 TCP 연결을 통해 수신되면 유효 요청 URI의 체계는 &quot;https&quot;입니다. 그렇지 않은 경우 체계는 &quot;http&quot;입니다. 서버 구성 (또는 아웃 바운드 게이트웨이)이 고정 URI 권한 구성 요소를 제공하는 경우 해당 권한은 유효 요청 URI에 사용됩니다. 그렇지 않은 경우 요청 대상이 권한 양식 인 경우 유효 요청 URI의 권한 구성 요소는 요청 대상과 동일합니다. 그렇지 않은 경우 호스트 헤더 필드에 비어 있지 않은 필드 값이 제공되면 권한 구성 요소는 호스트 필드 값과 동일합니다. 그렇지 않으면, 권한 구성 요소에 서버에 대해 구성된 기본 이름이 지정되며 연결의 경우수신 TCP 포트 번호가 유효 요청 URI 체계의 기본 포트와 다르면 콜론 ( &quot;:&quot;) 및 수신 포트 번호 (10 진수 형식)가 권한 구성 요소에 추가됩니다. 요청 대상이 권한 양식 또는 별표 양식 인 경우 유효 요청 URI의 결합 된 경로 및 조회 구성 요소가 비어 있습니다. 그렇지 않으면 결합 된 경로 및 쿼리 구성 요소는 요청 대상과 동일합니다. 상기와 같이 결정된 유효 요청 URI의 컴포넌트는 &quot;: //&quot;, 권한, 및 경로 및 쿼리 컴포넌트를 결합하여 절대 URI 형태로 결합 될 수있다. 예 1 : 다음 메시지가 안전하지 않은 TCP 연결 GET /pub/WWW/TheProject.html HTTP / 1.1 호스트를 통해 수신되었습니다 : www.example.org : 8080의 유효 요청 URI는 다음과 같습니다. &lt;a href=&quot;http://www.example.org:8080/pub/WWW/TheProject.html&quot;&gt;http://www.example.org:8080/pub/WWW/TheProject.html&lt;/a&gt; 예 2 : TLS 보안 TCP 연결을 통해 수신 된 다음 메시지 옵션 * HTTP / 1.1 호스트 : www.example.org의 유효 요청 URI는 https://www.example.org입니다. HTTP / 1.0 요청의 수신자가 부족합니다. 호스트 헤더 필드는 효과적인 요청 URI의 권한 구성 요소를 추측하기 위해 휴리스틱 (예 : 특정 호스트에 고유 한 URI 경로 검사)을 사용해야합니다. 유효 요청 URI가 구성되면 오리진 서버는 요청이 수신 된 연결을 통해 해당 URI에 서비스를 제공할지 여부를 결정해야합니다. 예를 들어 요청이 고의적으로 또는 실수로 잘못 전송되었을 수 있습니다.수신 된 요청 대상 또는 호스트 헤더 필드 내의 정보가 연결이 이루어진 호스트 또는 포트와 다르도록. 신뢰할 수있는 게이트웨이에서 연결 한 경우 해당 불일치가 예상 될 수 있습니다. 그렇지 않으면 보안 필터를 우회하거나 서버가 비 공용 컨텐츠를 전달하도록 속이거나 캐시를 감염시키려는 시도 일 수 있습니다. 보다&lt;a href=&quot;#section-9&quot;&gt;&lt;/a&gt;메시지 라우팅과 관련된 보안 고려 사항 은 9 절 .</target>
        </trans-unit>
        <trans-unit id="a531f36cb52973a36d35f55d654a8d428773bf1d" translate="yes" xml:space="preserve">
          <source>Since this document describes a set of extensions to the HTTP/1.1
   protocol, the augmented BNF used herein to describe protocol elements
   is exactly the same as described in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;Section&amp;nbsp;2.1 of [RFC2616]&lt;/a&gt;,
   including the rules about implied linear whitespace.  Since this
   augmented BNF uses the basic production rules provided in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;Section&amp;nbsp;2.2
   of [RFC2616]&lt;/a&gt;, these rules apply to this document as well.  Note this
   is not the standard BNF syntax used in other RFCs.

   The key words &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;REQUIRED&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;,
   &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;, and &quot;OPTIONAL&quot; in this
   document are to be interpreted as described in [&lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;].

   Note that in natural language, a property like the &quot;creationdate&quot;
   property in the &quot;DAV:&quot; XML namespace is sometimes referred to as
   &quot;DAV:creationdate&quot; for brevity.</source>
          <target state="translated">이 문서는 HTTP / 1.1 프로토콜에 대한 일련의 확장을 설명하므로, 프로토콜 요소를 설명하기 위해 여기에 사용 된 증강 BNF 는 암시 적 선형 공백에 대한 규칙을 포함하여 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.1&quot;&gt;[RFC2616]의 2.1 절에&lt;/a&gt; 설명 된 것과 정확히 동일 합니다. 이 보강 된 BNF는 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-2.2&quot;&gt;[RFC2616]의 2.2 절에&lt;/a&gt; 제공된 기본 생산 규칙을 ​​사용하므로 이러한 규칙도이 문서에도 적용됩니다. 이것은 다른 RFC에 사용되는 표준 BNF 구문이 아닙니다. 이 문서의 핵심 단어 &quot;MUST&quot;, &quot;MUST NOT&quot;, &quot;필수&quot;, &quot;SHALL&quot;, &quot;SHALL NOT&quot;, &quot;SHOULD&quot;, &quot;SHOULD NOT&quot;, &quot;RECOMMENDED&quot;, &quot;MAY&quot;및 &quot;OPTIONAL&quot; [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119에&lt;/a&gt; 설명 된대로 해석]. 자연어에서 &quot;DAV :&quot;XML 네임 스페이스의 &quot;creationdate&quot;속성과 같은 속성은 간결성을 위해 &quot;DAV : creationdate&quot;라고도합니다.</target>
        </trans-unit>
        <trans-unit id="6ed1ccbe5b50342757a2d3ea53224582ca419bad" translate="yes" xml:space="preserve">
          <source>Since version 4.1, Klar for Android uses the same UA string as &lt;a href=&quot;#Focus_for_Android&quot;&gt;Focus for Android&lt;/a&gt;. Before version 4.1, it sent a &lt;var&gt;Klar/&amp;lt;version&amp;gt;&lt;/var&gt;&lt;var&gt;product/version&lt;/var&gt; token.</source>
          <target state="translated">버전 4.1부터 Android 용 Klar는 Android 용 &lt;a href=&quot;#Focus_for_Android&quot;&gt;Focus&lt;/a&gt; 와 동일한 UA 문자열을 사용합니다 . 버전 4.1 이전에는 &lt;var&gt;Klar/&amp;lt;version&amp;gt;&lt;/var&gt; &lt;var&gt;product/version&lt;/var&gt; 토큰을 보냈습니다 .</target>
        </trans-unit>
        <trans-unit id="f2e4d9b56d7689a1ae584bddcddb038ff0772c38" translate="yes" xml:space="preserve">
          <source>Since your domain isn't &lt;code&gt;example.com&lt;/code&gt;, a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt;&lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt;&lt;/a&gt; element with its &lt;code&gt;href&lt;/code&gt; set to &lt;code&gt;https://example.com&lt;/code&gt; will result in a CSP violation.</source>
          <target state="translated">도메인이 아니기 때문에 &lt;code&gt;example.com&lt;/code&gt; 하는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/base&quot;&gt; &lt;code&gt;&amp;lt;base&amp;gt;&lt;/code&gt; &lt;/a&gt; 그와 요소 &lt;code&gt;href&lt;/code&gt; 로 설정 &lt;code&gt;https://example.com&lt;/code&gt; 은 CSP를 위반이 발생합니다.</target>
        </trans-unit>
        <trans-unit id="0a9315f35220268432d25d79a4154c7f1eccd789" translate="yes" xml:space="preserve">
          <source>Single part ranges</source>
          <target state="translated">단일 부품 범위</target>
        </trans-unit>
        <trans-unit id="6e08a5615f12f6057b7ff9d9ceecce7b3562aacc" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of a single file of known length, defined by the two headers: &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">알려진 길이의 단일 파일로 구성된 단일 리소스 본문 ( &lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; )으로&lt;/a&gt; 정의됩니다 .</target>
        </trans-unit>
        <trans-unit id="9f99f82fdece07fba6789c9308f7b0c3bc7a0e91" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of a single file of unknown length, encoded by chunks with &lt;a href=&quot;headers/transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; set to &lt;code&gt;chunked&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 이 &lt;code&gt;chunked&lt;/code&gt; 로 설정된 청크로 인코딩 된 알 수없는 길이의 단일 파일로 구성된 단일 리소스 본문 .</target>
        </trans-unit>
        <trans-unit id="d60483a13a434ebf8efec0b71ca52e651ce1040b" translate="yes" xml:space="preserve">
          <source>Single-resource bodies, consisting of one single file, defined by the two headers: &lt;a href=&quot;headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;headers/content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;headers/content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; 의 두 헤더로 정의 된 하나의 단일 파일로 구성된 단일 자원 본문 .</target>
        </trans-unit>
        <trans-unit id="762d05cd3ee1357a02893672cf750fd1659a4eed" translate="yes" xml:space="preserve">
          <source>Site security testers usually expect this header to be set.</source>
          <target state="translated">사이트 보안 테스터는 일반적으로이 헤더가 설정 될 것으로 예상합니다.</target>
        </trans-unit>
        <trans-unit id="88a34e382ce47cacc14889b5eb99b2deb9447680" translate="yes" xml:space="preserve">
          <source>Slug is an HTTP entity-header whose presence in a POST to a
   Collection constitutes a request by the client to use the header's
   value as part of any URIs that would normally be used to retrieve the
   to-be-created Entry or Media Resources.

   Servers MAY use the value of the Slug header when creating the Member
   URI of the newly created Resource, for instance, by using some or all
   of the words in the value for the last URI segment.  Servers MAY also
   use the value when creating the atom:id, or as the title of a Media
   Link Entry (see &lt;a href=&quot;#section-9.6&quot;&gt;Section 9.6&lt;/a&gt;). 

   Servers MAY choose to ignore the Slug entity-header.  Servers MAY
   alter the header value before using it.  For instance, a server might
   filter out some characters or replace accented letters with non-
   accented ones, replace spaces with underscores, change case, and so
   on.</source>
          <target state="translated">슬러그 (Slug)는 컬렉션에 대한 POST에서의 존재가 클라이언트가 헤더의 값을 생성 할 엔트리 또는 미디어 리소스를 검색하는 데 일반적으로 사용되는 URI의 일부로 사용하도록 요청하는 HTTP 엔티티 헤더입니다. 서버는 예를 들어 마지막 URI 세그먼트 값의 일부 또는 모든 단어를 사용하여 새로 작성된 자원의 멤버 URI를 작성할 때 Slug 헤더의 값을 사용할 수 있습니다. 서버는 또한 atom : id를 만들 때 또는 미디어 링크 항목의 제목으로 값을 사용할 수도 있습니다 ( &lt;a href=&quot;#section-9.6&quot;&gt;9.6 절&lt;/a&gt; 참조).). 서버는 Slug 엔티티 헤더를 무시하도록 선택할 수 있습니다. 서버는 사용하기 전에 헤더 값을 변경할 수 있습니다. 예를 들어, 서버는 일부 문자를 걸러 내거나 악센트 문자를 악센트 부호가없는 문자로 바꾸거나, 공백을 밑줄, 대소 문자 바꾸기 등으로 바꿀 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="bbc575596897043101f8f28bb8d15019ccb43ccd" translate="yes" xml:space="preserve">
          <source>So until all browsers catch up with the spec, you may be able to work around this limitation by doing one or both of the following:</source>
          <target state="translated">따라서 모든 브라우저가 스펙을 따라 잡을 때까지 다음 중 하나 또는 둘 다를 수행하여이 제한 사항을 해결할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="037a3b178c5c3fa1e2c3af1bd926bf5f5c93704e" translate="yes" xml:space="preserve">
          <source>So, choose one of your domains as your canonical one! There are two techniques below to allow the non-canonical domain to work still.</source>
          <target state="translated">따라서 도메인 중 하나를 정식 도메인으로 선택하십시오! 비정규 도메인이 여전히 작동하도록하기위한 두 가지 기술이 있습니다.</target>
        </trans-unit>
        <trans-unit id="cd7373eebfb9bfd956b54104ec328820e66fdfe6" translate="yes" xml:space="preserve">
          <source>So, do I have to choose one or the other for my web site?</source>
          <target state="translated">내 웹 사이트에 대해 하나를 선택해야합니까?</target>
        </trans-unit>
        <trans-unit id="b4f91bdb0e1b0e40fff4debcd0fea22f1999f491" translate="yes" xml:space="preserve">
          <source>Solution</source>
          <target state="translated">Solution</target>
        </trans-unit>
        <trans-unit id="e0f0c555c38a97116b738fdc4ec2d35f3f2aa384" translate="yes" xml:space="preserve">
          <source>Some HTTP header fields allow a time value to be specified as an
   integer number of seconds, represented in decimal, after the time
   that the message was received.

       delta-seconds  = 1*DIGIT</source>
          <target state="translated">일부 HTTP 헤더 필드에서는 시간 값을 메시지가 수신 된 시간 이후 10 진수로 표시되는 정수 초로 지정할 수 있습니다. 델타 초 = 1 * DIGIT</target>
        </trans-unit>
        <trans-unit id="d62acecb772d2af811fb679ffb025605d29919d2" translate="yes" xml:space="preserve">
          <source>Some HTTP messages transfer a complete or partial representation as
   the message &quot;payload&quot;.  In some cases, a payload might contain only
   the associated representation's header fields (e.g., responses to
   HEAD) or only some part(s) of the representation data (e.g., the 206
   (Partial Content) status code).

   The purpose of a payload in a request is defined by the method
   semantics.  For example, a representation in the payload of a PUT
   request (&lt;a href=&quot;#section-4.3.4&quot;&gt;Section 4.3.4&lt;/a&gt;) represents the desired state of the target
   resource if the request is successfully applied, whereas a
   representation in the payload of a POST request (&lt;a href=&quot;#section-4.3.3&quot;&gt;Section 4.3.3&lt;/a&gt;)
   represents information to be processed by the target resource. 

   In a response, the payload's purpose is defined by both the request
   method and the response status code.  For example, the payload of a
   200 (OK) response to GET (&lt;a href=&quot;#section-4.3.1&quot;&gt;Section 4.3.1&lt;/a&gt;) represents the current state
   of the target resource, as observed at the time of the message
   origination date (&lt;a href=&quot;#section-7.1.1.2&quot;&gt;Section 7.1.1.2&lt;/a&gt;), whereas the payload of the same
   status code in a response to POST might represent either the
   processing result or the new state of the target resource after
   applying the processing.  Response messages with an error status code
   usually contain a payload that represents the error condition, such
   that it describes the error state and what next steps are suggested
   for resolving it.

   Header fields that specifically describe the payload, rather than the
   associated representation, are referred to as &quot;payload header
   fields&quot;.  Payload header fields are defined in other parts of this
   specification, due to their impact on message parsing.

   +-------------------+----------------------------+
   | Header Field Name | Defined in...              |
   +-------------------+----------------------------+
   | Content-Length    | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;Section&amp;nbsp;3.3.2 of [RFC7230]&lt;/a&gt; |
   | Content-Range     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;Section&amp;nbsp;4.2 of [RFC7233]&lt;/a&gt;   |
   | Trailer           | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;Section&amp;nbsp;4.4 of [RFC7230]&lt;/a&gt;   |
   | Transfer-Encoding | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;Section&amp;nbsp;3.3.1 of [RFC7230]&lt;/a&gt; |
   +-------------------+----------------------------+</source>
          <target state="translated">일부 HTTP 메시지는 &quot;페이로드&quot;메시지로 전체 또는 부분 표현을 전송합니다. 일부 경우에, 페이로드는 연관된 표현의 헤더 필드 (예를 들어, HEAD에 대한 응답) 또는 표현 데이터의 일부 (예를 들어, 206 (부분 컨텐츠) 상태 코드)만을 포함 할 수있다. 요청에서 페이로드의 목적은 메소드 시맨틱에 의해 정의됩니다. 예를 들어, PUT 요청의 페이로드 표현 ( &lt;a href=&quot;#section-4.3.4&quot;&gt;섹션 4.3.4&lt;/a&gt; )은 요청이 성공적으로 적용된 경우 대상 자원의 원하는 상태를 나타내며 POST 요청의 페이로드 ( &lt;a href=&quot;#section-4.3.3&quot;&gt;섹션 4.3.3)를&lt;/a&gt; 나타냅니다.)은 대상 자원이 처리 할 정보를 나타냅니다. 응답에서 페이로드의 목적은 요청 방법과 응답 상태 코드 모두에 의해 정의됩니다. 예를 들어, GET에 대한 200 (OK) 응답의 페이로드 ( &lt;a href=&quot;#section-4.3.1&quot;&gt;섹션 4.3.1&lt;/a&gt; )는 메시지 시작 날짜 ( &lt;a href=&quot;#section-7.1.1.2&quot;&gt;7.1.1.2 단원)&lt;/a&gt; 에서 관찰 된 대상 자원의 현재 상태를 나타냅니다.POST에 대한 응답으로 동일한 상태 코드의 페이로드는 처리 결과를 적용한 후 처리 결과 또는 대상 자원의 새로운 상태를 나타낼 수 있습니다. 오류 상태 코드가 포함 된 응답 메시지에는 일반적으로 오류 상태를 나타내는 페이로드가 포함되어있어 오류 상태와이를 해결하기 위해 다음 단계를 제안합니다. 연관된 표현이 아닌 페이로드를 구체적으로 설명하는 헤더 필드를 &quot;페이로드 헤더 필드&quot;라고합니다. 페이로드 헤더 필드는 메시지 구문 분석에 미치는 영향으로 인해이 사양의 다른 부분에서 정의됩니다. + ------------------- + ---------------------------- + | 헤더 필드 이름 | 에 정의 된 ...| + ------------------- + ---------------------------- + | 콘텐츠 길이 |&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.2&quot;&gt;[RFC7230]의 섹션 3.3.2&lt;/a&gt; | | 컨텐츠 범위 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7233#section-4.2&quot;&gt;[RFC7233] 4.2 절&lt;/a&gt; | | 트레일러 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-4.4&quot;&gt;[RFC7230] 4.4 절&lt;/a&gt; | | 전송 인코딩 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.3.1&quot;&gt;[RFC7230]의 섹션 3.3.1&lt;/a&gt; | + ------------------- + ---------------------------- +</target>
        </trans-unit>
        <trans-unit id="96f4cfa3a2435470f520822a7a281fd09a7abe90" translate="yes" xml:space="preserve">
          <source>Some HTTP resources are dynamically generated by the server.  For
   these resources, there presumably exists source code somewhere
   governing how that resource is generated.  The relationship of source
   files to output HTTP resources may be one to one, one to many, many
   to one, or many to many.  There is no mechanism in HTTP to determine
   whether a resource is even dynamic, let alone where its source files
   exist or how to author them.  Although this problem would usefully be
   solved, interoperable WebDAV implementations have been widely
   deployed without actually solving this problem, by dealing only with
   static resources.  Thus, the source vs. output problem is not solved
   in this specification and has been deferred to a separate document.</source>
          <target state="translated">일부 HTTP 리소스는 서버에서 동적으로 생성됩니다. 이러한 리소스의 경우 해당 리소스 생성 방법을 관리하는 소스 코드가있을 수 있습니다. HTTP 파일을 출력하기위한 소스 파일의 관계는 일대일, 일대 다, 다 대일 또는 다 대다 일 수 있습니다. HTTP에는 소스 파일이 존재하는 위치 나 제작 방법을 제외하고 리소스가 동적인지 여부를 결정하는 메커니즘이 없습니다. 이 문제는 유용하게 해결되지만 정적 자원 만 처리하여 실제로이 문제를 해결하지 않고도 상호 운용 가능한 WebDAV 구현이 광범위하게 배포되었습니다. 따라서 소스 대 출력 문제는이 사양에서 해결되지 않으며 별도의 문서로 연기되었습니다.</target>
        </trans-unit>
        <trans-unit id="9edae38f81cc4e1676b63507df63fb416ecd279a" translate="yes" xml:space="preserve">
          <source>Some HTTP/1.0 software has interpreted a Content-Type header without
   charset parameter incorrectly to mean &quot;recipient should guess.&quot;
   Senders wishing to defeat this behavior MAY include a charset
   parameter even when the charset is ISO-8859-1 and SHOULD do so when
   it is known that it will not confuse the recipient.

   Unfortunately, some older HTTP/1.0 clients did not deal properly with
   an explicit charset parameter. HTTP/1.1 recipients MUST respect the
   charset label provided by the sender; and those user agents that have
   a provision to &quot;guess&quot; a charset MUST use the charset from the 

   content-type field if they support that charset, rather than the
   recipient's preference, when initially displaying a document. See
   &lt;a href=&quot;#section-3.7.1&quot;&gt;section 3.7.1&lt;/a&gt;.</source>
          <target state="translated">일부 HTTP / 1.0 소프트웨어는 문자 수신자 매개 변수가없는 Content-Type 헤더를 잘못 해석하여 &quot;수신자가 추측해야 함&quot;을 의미합니다. 이 동작을 막으려는 발신자는 문자셋이 ISO-8859-1 인 경우에도 문자셋 매개 변수를 포함 할 수 있으며 수신자를 혼동하지 않는 것으로 알려진 경우에는 그렇게해야합니다 (SHOULD). 불행히도 일부 이전 HTTP / 1.0 클라이언트는 명시 적 문자 집합 매개 변수를 제대로 처리하지 못했습니다. HTTP / 1.1 수신자는 발신자가 제공 한 문자 세트 레이블을 준수해야합니다. 문자셋을 &quot;추측&quot;할 수있는 사용자 에이전트는 문서를 처음 표시 할 때 수신자의 선호도가 아닌 해당 문자셋을 지원하는 경우 반드시 컨텐츠 유형 필드의 문자셋을 사용해야합니다. &lt;a href=&quot;#section-3.7.1&quot;&gt;섹션 3.7.1&lt;/a&gt; 참조 .</target>
        </trans-unit>
        <trans-unit id="76ff9a23340030e08177c96f6cd25b9e75cd64eb" translate="yes" xml:space="preserve">
          <source>Some clients and servers might wish to be compatible with some
   previous implementations of persistent connections in HTTP/1.0
   clients and servers. Persistent connections in HTTP/1.0 are
   explicitly negotiated as they are not the default behavior. HTTP/1.0
   experimental implementations of persistent connections are faulty,
   and the new facilities in HTTP/1.1 are designed to rectify these
   problems. The problem was that some existing 1.0 clients may be
   sending Keep-Alive to a proxy server that doesn't understand
   Connection, which would then erroneously forward it to the next
   inbound server, which would establish the Keep-Alive connection and
   result in a hung HTTP/1.0 proxy waiting for the close on the
   response. The result is that HTTP/1.0 clients must be prevented from
   using Keep-Alive when talking to proxies.

   However, talking to proxies is the most important use of persistent
   connections, so that prohibition is clearly unacceptable. Therefore,
   we need some other mechanism for indicating a persistent connection
   is desired, which is safe to use even when talking to an old proxy
   that ignores Connection. Persistent connections are the default for
   HTTP/1.1 messages; we introduce a new keyword (Connection: close) for
   declaring non-persistence. See &lt;a href=&quot;#section-14.10&quot;&gt;section 14.10&lt;/a&gt;.

   The original HTTP/1.0 form of persistent connections (the Connection:
   Keep-Alive and Keep-Alive header) is documented in &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;. [&lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt;]</source>
          <target state="translated">일부 클라이언트 및 서버는 HTTP / 1.0 클라이언트 및 서버에서 지속적 연결의 일부 이전 구현과 호환되기를 원할 수 있습니다. HTTP / 1.0의 지속적 연결은 기본 동작이 아니므로 명시 적으로 협상됩니다. 지속적 연결의 HTTP / 1.0 실험 구현에는 결함이 있으며 HTTP / 1.1의 새로운 기능은 이러한 문제를 해결하도록 설계되었습니다. 문제는 기존의 일부 1.0 클라이언트가 연결을 이해하지 못하는 프록시 서버로 Keep-Alive를 전송하는 경우 다음 인바운드 서버로 잘못 전달하여 Keep-Alive 연결을 설정하고 중단되는 결과를 초래한다는 것입니다 응답 종료를 기다리는 HTTP / 1.0 프록시. 결과적으로 프록시와 통신 할 때 HTTP / 1.0 클라이언트가 Keep-Alive를 사용하지 못하도록해야합니다.그러나 프록시와 대화하는 것이 지속적인 연결을 가장 중요하게 사용하므로 금지를 분명히 받아 들일 수 없습니다. 따라서 지속적인 연결이 필요하다는 것을 나타내는 다른 메커니즘이 필요합니다. 이는 Connection을 무시하는 오래된 프록시와 대화 할 때도 안전하게 사용할 수 있습니다. 영구 연결은 HTTP / 1.1 메시지의 기본값입니다. 비 지속성을 선언하기위한 새로운 키워드 (Connection : close)를 소개합니다. 보다비 지속성을 선언하기위한 새로운 키워드 (Connection : close)를 소개합니다. 보다비 지속성을 선언하기위한 새로운 키워드 (Connection : close)를 소개합니다. 보다&lt;a href=&quot;#section-14.10&quot;&gt;섹션 14.10&lt;/a&gt; . 영구 연결의 원래 HTTP / 1.0 형식 (연결 : 연결 유지 및 연결 유지 헤더)은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068에&lt;/a&gt; 문서화되어 있습니다. [ &lt;a href=&quot;#ref-33&quot;&gt;33&lt;/a&gt; ]</target>
        </trans-unit>
        <trans-unit id="66a43f342d6b50a7175f69c935c3406eba5914f1" translate="yes" xml:space="preserve">
          <source>Some common incorrect server configurations:</source>
          <target state="translated">몇 가지 일반적인 잘못된 서버 구성 :</target>
        </trans-unit>
        <trans-unit id="54f8a5332226dab76bfa931addcda81bcd89ad2c" translate="yes" xml:space="preserve">
          <source>Some content you find may have a &lt;code&gt;charset&lt;/code&gt; parameter at the end of the &lt;code&gt;text/javascript&lt;/code&gt; media type, to specify the character set used to represent the code's content. This is not valid, and in most cases will result in a script not being loaded.</source>
          <target state="translated">일부 콘텐츠 에는 &lt;code&gt;text/javascript&lt;/code&gt; 미디어 유형 끝에 &lt;code&gt;charset&lt;/code&gt; 매개 변수가 있어 코드 콘텐츠를 나타내는 데 사용되는 문자 집합을 지정할 수 있습니다. 이것은 유효하지 않으며 대부분의 경우 스크립트가로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="6d72390cba5a4baa13a82ea7ff405f67d096f790" translate="yes" xml:space="preserve">
          <source>Some cookies are misusing the &amp;ldquo;sameSite&amp;ldquo; attribute, so it won&amp;rsquo;t work as expected.</source>
          <target state="translated">일부 쿠키는 &quot;sameSite&quot;속성을 잘못 사용하여 예상대로 작동하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="089187292034968cbe876df352df70cc7166431a" translate="yes" xml:space="preserve">
          <source>Some directives have an optional argument, which can be either a &lt;em&gt;token&lt;/em&gt; or a &lt;em&gt;quoted-string&lt;/em&gt;. (See spec for definitions)</source>
          <target state="translated">일부 지시문에는 &lt;em&gt;token&lt;/em&gt; 또는 &lt;em&gt;quoted-string 일&lt;/em&gt; 수있는 선택적 인수가 있습니다 . (정의는 사양 참조)</target>
        </trans-unit>
        <trans-unit id="9270b0f5d6139d14ce495519a232664c8d2acd88" translate="yes" xml:space="preserve">
          <source>Some features of the HTTP/1.1 protocol, such as Digest
   Authentication, depend on the value of certain end-to-end headers. A
   transparent proxy SHOULD NOT modify an end-to-end header unless the
   definition of that header requires or specifically allows that. 

   A transparent proxy MUST NOT modify any of the following fields in a
   request or response, and it MUST NOT add any of these fields if not
   already present:

      - Content-Location

      - Content-MD5

      - ETag

      - Last-Modified

   A transparent proxy MUST NOT modify any of the following fields in a
   response:

      - Expires

   but it MAY add any of these fields if not already present. If an
   Expires header is added, it MUST be given a field-value identical to
   that of the Date header in that response.

   A  proxy MUST NOT modify or add any of the following fields in a
   message that contains the no-transform cache-control directive, or in
   any request:

      - Content-Encoding

      - Content-Range

      - Content-Type

   A non-transparent proxy MAY modify or add these fields to a message
   that does not include no-transform, but if it does so, it MUST add a
   Warning 214 (Transformation applied) if one does not already appear
   in the message (see &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt;).

      Warning: unnecessary modification of end-to-end headers might
      cause authentication failures if stronger authentication
      mechanisms are introduced in later versions of HTTP. Such
      authentication mechanisms MAY rely on the values of header fields
      not listed here.

   The Content-Length field of a request or response is added or deleted
   according to the rules in &lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;. A transparent proxy MUST
   preserve the entity-length (&lt;a href=&quot;#section-7.2.2&quot;&gt;section 7.2.2&lt;/a&gt;) of the entity-body,
   although it MAY change the transfer-length (&lt;a href=&quot;#section-4.4&quot;&gt;section 4.4&lt;/a&gt;).</source>
          <target state="translated">다이제스트 인증과 같은 HTTP / 1.1 프로토콜의 일부 기능은 특정 엔드 투 엔드 헤더의 값에 따라 다릅니다. 투명한 프록시는 그 헤더의 정의가 요구하거나 구체적으로 허용하지 않는 한 엔드 투 엔드 헤더를 수정해서는 안됩니다. 투명 프록시는 요청 또는 응답에서 다음 필드를 수정해서는 안되며 아직 존재하지 않는 경우 이러한 필드를 추가해서는 안됩니다.-Content-Location-Content-MD5-ETag-Last-Modified 투명 프록시는 NOT 응답에서 다음 필드 중 하나를 수정하십시오.-만료되지만이 필드 중 하나가 아직없는 경우 추가 할 수 있습니다. Expires 헤더가 추가되면 해당 응답의 Date 헤더와 동일한 필드 값이 제공되어야합니다.프록시는 트랜스 폼 없음 캐시 제어 지시문을 포함하는 메시지 또는 요청에서 다음 필드를 수정하거나 추가해서는 안됩니다.-Content-Encoding-Content-Range-Content-Type 투명하지 않은 프록시는 수정 될 수 있습니다. 또는 트랜스포머를 포함하지 않는 메시지에 이러한 필드를 추가하십시오. 그렇지 않은 경우 메시지에 아직 나타나지 않으면 경고 214 (변환 적용)를 추가해야합니다 (참조메시지에 아직 나타나지 않으면 경고 214 (변환 적용)를 추가해야합니다 (참조메시지에 아직 나타나지 않으면 경고 214 (변환 적용)를 추가해야합니다 (참조&lt;a href=&quot;#section-14.46&quot;&gt;섹션 14.46&lt;/a&gt; ). 경고 : 이후 버전의 HTTP에 강력한 인증 메커니즘이 도입 된 경우 엔드 투 엔드 헤더를 불필요하게 수정하면 인증이 실패 할 수 있습니다. 이러한 인증 메커니즘은 여기에 나열되지 않은 헤더 필드의 값에 의존 할 수 있습니다. 요청 또는 응답의 Content-Length 필드는 &lt;a href=&quot;#section-4.4&quot;&gt;4.4 섹션&lt;/a&gt; 의 규칙에 따라 추가 또는 삭제됩니다 . 투명한 프록시 는 전송 길이 ( &lt;a href=&quot;#section-4.4&quot;&gt;섹션 4.4&lt;/a&gt; )를 변경할 수 있지만, 엔터티 본문의 엔터티 길이 ( &lt;a href=&quot;#section-7.2.2&quot;&gt;섹션 7.2.2&lt;/a&gt; )를 유지해야합니다 .</target>
        </trans-unit>
        <trans-unit id="08d40ce154c5b61338b36a1b4a7b8fc44f8f33e3" translate="yes" xml:space="preserve">
          <source>Some formats can be used for both loss-less or lossy compression, like &lt;code&gt;webp&lt;/code&gt;, and usually lossy algorithm can be configured to compress more or less, which then of course leads to less or more quality. For better performance of a Web site, it is ideal to compress as much as possible, while keeping an acceptable level of quality. For images, an image generated by a tool could be not optimized enough for the Web; it is recommended to use tools that will compress as much as possible with the required quality. There are &lt;a href=&quot;http://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;numerous tools&lt;/a&gt; that are specialized for this.</source>
          <target state="translated">일부 형식은 &lt;code&gt;webp&lt;/code&gt; 와 같이 무손실 또는 무손실 압축에 모두 사용될 수 있으며 , 일반적으로 손실 알고리즘은 다소 압축되도록 구성 할 수 있으며, 그 결과 품질은 다소 떨어집니다. 웹 사이트의 성능을 향상 시키려면 허용 가능한 수준의 품질을 유지하면서 최대한 압축하는 것이 좋습니다. 이미지의 경우 도구로 생성 된 이미지는 웹에 충분히 최적화되지 않을 수 있습니다. 필요한 품질로 최대한 압축하는 도구를 사용하는 것이 좋습니다. 이에 특화된 &lt;a href=&quot;http://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;수많은 도구&lt;/a&gt; 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="36517fc724d6e21ec48094bdd3611e8bc2aeefbc" translate="yes" xml:space="preserve">
          <source>Some formats can be used for both loss-less or lossy compression, like &lt;code&gt;webp&lt;/code&gt;, and usually lossy algorithm can be configured to compress more or less, which then of course leads to less or more quality. For better performance of a Web site, it is ideal to compress as much as possible, while keeping an acceptable level of quality. For images, an image generated by a tool could be not optimized enough for the Web; it is recommended to use tools that will compress as much as possible with the required quality. There are &lt;a href=&quot;https://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;numerous tools&lt;/a&gt; that are specialized for this.</source>
          <target state="translated">일부 형식은 &lt;code&gt;webp&lt;/code&gt; 와 같이 무손실 또는 손실 압축 모두에 사용할 수 있으며 일반적으로 손실 알고리즘은 더 많거나 더 적게 압축하도록 구성 할 수 있습니다. 웹 사이트의 성능을 높이려면 허용 가능한 수준의 품질을 유지하면서 가능한 한 많이 압축하는 것이 이상적입니다. 이미지의 경우 도구로 생성 된 이미지는 웹에 맞게 최적화되지 않을 수 있습니다. 필요한 품질로 가능한 한 많이 압축하는 도구를 사용하는 것이 좋습니다. 있다 &lt;a href=&quot;https://www.creativebloq.com/design/image-compression-tools-1132865&quot;&gt;수많은 도구&lt;/a&gt; 이를 위해 전문화되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="65ac20f104a927276bcef1c71021955f476f1866" translate="yes" xml:space="preserve">
          <source>Some intermediaries include features for transforming messages and
   their payloads.  A proxy might, for example, convert between image
   formats in order to save cache space or to reduce the amount of
   traffic on a slow link.  However, operational problems might occur
   when these transformations are applied to payloads intended for
   critical applications, such as medical imaging or scientific data
   analysis, particularly when integrity checks or digital signatures
   are used to ensure that the payload received is identical to the
   original.

   An HTTP-to-HTTP proxy is called a &quot;transforming proxy&quot; if it is
   designed or configured to modify messages in a semantically
   meaningful way (i.e., modifications, beyond those required by normal
   HTTP processing, that change the message in a way that would be
   significant to the original sender or potentially significant to
   downstream recipients).  For example, a transforming proxy might be
   acting as a shared annotation server (modifying responses to include
   references to a local annotation database), a malware filter, a
   format transcoder, or a privacy filter.  Such transformations are
   presumed to be desired by whichever client (or client organization)
   selected the proxy.

   If a proxy receives a request-target with a host name that is not a
   fully qualified domain name, it MAY add its own domain to the host
   name it received when forwarding the request.  A proxy MUST NOT
   change the host name if the request-target contains a fully qualified
   domain name. 

   A proxy MUST NOT modify the &quot;absolute-path&quot; and &quot;query&quot; parts of the
   received request-target when forwarding it to the next inbound
   server, except as noted above to replace an empty path with &quot;/&quot; or
   &quot;*&quot;.

   A proxy MAY modify the message body through application or removal of
   a transfer coding (&lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;).

   A proxy MUST NOT transform the payload (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.3&quot;&gt;Section&amp;nbsp;3.3 of [RFC7231]&lt;/a&gt;) of
   a message that contains a no-transform cache-control directive
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;Section&amp;nbsp;5.2 of [RFC7234]&lt;/a&gt;).

   A proxy MAY transform the payload of a message that does not contain
   a no-transform cache-control directive.  A proxy that transforms a
   payload MUST add a Warning header field with the warn-code of 214
   (&quot;Transformation Applied&quot;) if one is not already in the message (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7234]&lt;/a&gt;).  A proxy that transforms the payload of a
   200 (OK) response can further inform downstream recipients that a
   transformation has been applied by changing the response status code
   to 203 (Non-Authoritative Information) (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;Section&amp;nbsp;6.3.4 of [RFC7231]&lt;/a&gt;).

   A proxy SHOULD NOT modify header fields that provide information
   about the endpoints of the communication chain, the resource state,
   or the selected representation (other than the payload) unless the
   field's definition specifically allows such modification or the
   modification is deemed necessary for privacy or security.</source>
          <target state="translated">일부 중개자에는 메시지 및 해당 페이로드를 변환하는 기능이 있습니다. 예를 들어 프록시는 캐시 공간을 절약하거나 저속 링크의 트래픽 양을 줄이기 위해 이미지 형식간에 변환 할 수 있습니다. 그러나 이러한 변환이 의료 이미징 또는 과학적 데이터 분석과 같은 중요한 응용 프로그램 용 페이로드에 적용될 때, 특히 무결성 검사 또는 디지털 서명을 사용하여 수신 된 페이로드가 원본과 동일한 지 확인하는 경우 작동 문제가 발생할 수 있습니다. HTTP-to-HTTP 프록시는 의미 적으로 의미있는 방식으로 메시지를 수정하도록 설계 또는 구성된 경우 (예 : 일반 HTTP 처리에 필요한 것 이외의 수정)원래 발신자에게 중요하거나 다운 스트림 수신자에게 중요 할 수있는 방식으로 메시지를 변경합니다. 예를 들어, 변환 프록시는 공유 주석 서버 (로컬 주석 데이터베이스에 대한 참조를 포함하도록 응답 수정), 맬웨어 필터, 형식 트랜스 코더 또는 개인 정보 필터 역할을 할 수 있습니다. 이러한 변환은 어느 클라이언트 (또는 클라이언트 조직)가 프록시를 선택했는지에 따라 원하는 것으로 추정됩니다. 프록시가 정규화 된 도메인 이름이 아닌 호스트 이름을 가진 요청 대상을 수신하면 요청을 전달할 때받은 호스트 이름에 자체 도메인을 추가 할 수 있습니다. 요청 대상에 정규화 된 도메인 이름이 포함 된 경우 프록시는 호스트 이름을 변경해서는 안됩니다. 프록시는 &quot;절대 경로&quot;와 &quot;빈 경로를 &quot;/&quot;또는 &quot;*&quot;로 대체하기 위해 위에서 언급 한 것을 제외하고, 다음 인바운드 서버로 전달할 때 수신 된 요청 대상의 query &quot;부분. 프록시는 응용 프로그램 또는 전송 제거를 통해 메시지 본문을 수정할 수 있습니다. 코딩 (&lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; ). 프록시는 트랜스 폼 없음 캐시 제어 지시문을 포함하는 메시지 의 페이로드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3.3&quot;&gt;[RFC7231]의 섹션 3.3&lt;/a&gt; )를 변환 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.2&quot;&gt;해서는 안됩니다 ([RFC7234]의 섹션 5.2&lt;/a&gt; ). 프록시는 트랜스 폼이없는 캐시 제어 지시어를 포함하지 않는 메시지의 페이로드를 변환 할 수있다. 페이로드를 변환하는 프록시는 경고 코드가 214 인 경고 헤더 필드 ( &quot;변환 적용됨&quot;)를 아직 메시지에없는 경우 추가해야합니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-5.5&quot;&gt;[RFC7234]의 5.5 절&lt;/a&gt; 참조 ). 200 (OK) 응답의 페이로드를 변환하는 프록시는 응답 상태 코드를 203 (비 정식 정보)으로 변경하여 다운 스트림 수신자에게 변환이 적용되었음을 알릴 수 있습니다 (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-6.3.4&quot;&gt;[RFC7231]의 섹션 6.3.4&lt;/a&gt; ). 필드의 정의가 특별히 그러한 수정을 허용하거나 수정이 개인 정보 보호 또는 보안에 필요한 것으로 간주되지 않는 한, 프록시는 통신 체인의 끝점, 자원 상태 또는 선택된 표현 (페이로드 이외)에 대한 정보를 제공하는 헤더 필드를 수정해서는 안됩니다. .</target>
        </trans-unit>
        <trans-unit id="eac57a1de8acde9c46e58fb564a5c63eef8c02df" translate="yes" xml:space="preserve">
          <source>Some of these new methods do not define bodies.  Servers MUST examine
   all requests for a body, even when a body was not expected.  In cases
   where a request body is present but would be ignored by a server, the
   server MUST reject the request with 415 (Unsupported Media Type).
   This informs the client (which may have been attempting to use an
   extension) that the body could not be processed as the client
   intended.</source>
          <target state="translated">이러한 새로운 방법 중 일부는 본문을 정의하지 않습니다. 서버는 본문이 예상되지 않은 경우에도 본문에 대한 모든 요청을 검사해야합니다. 요청 본문이 있지만 서버에서 무시되는 경우 서버는 415 (지원되지 않는 미디어 유형)로 요청을 거부해야합니다. 이것은 클라이언트 (확장자를 사용하려고 시도했을 수도 있음)에게 클라이언트가 의도 한대로 본문을 처리 할 수 ​​없음을 알려줍니다.</target>
        </trans-unit>
        <trans-unit id="4e4cf2038e1894371084626084a37cd3855e9122" translate="yes" xml:space="preserve">
          <source>Some origin server implementations might not have a clock available.
   An origin server without a clock MUST NOT assign Expires or Last-
   Modified values to a response, unless these values were associated
   with the resource by a system or user with a reliable clock. It MAY
   assign an Expires value that is known, at or before server
   configuration time, to be in the past (this allows &quot;pre-expiration&quot;
   of responses without storing separate Expires values for each
   resource).</source>
          <target state="translated">일부 오리진 서버 구현에는 사용 가능한 시계가 없을 수 있습니다. 클럭이없는 오리진 서버는 신뢰할 수있는 클럭을 가진 시스템이나 사용자가이 값을 리소스와 연관시키지 않는 한 만료 또는 마지막 수정 값을 응답에 할당해서는 안됩니다 (MUST NOT). 서버 구성 시간 또는 이전에 알려진 Expires 값을 과거로 지정할 수 있습니다 (각 자원에 대해 별도의 Expires 값을 저장하지 않고 응답의 &quot;사전 만료&quot;를 허용 함).</target>
        </trans-unit>
        <trans-unit id="03c3e50ec8cb12cf3acddc31b3a981323a1ddf6c" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so only specific users can access it. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">일부 페이지는 보호되어 특정 사용자 만 액세스 할 수 있습니다. 기본 인증은 &lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 및 유사한 헤더를 사용하거나 &lt;a href=&quot;cookies&quot;&gt;HTTP 쿠키를&lt;/a&gt; 사용하여 특정 세션을 설정 하여 HTTP를 통해 제공 될 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="9d9fd2b2a9f9cc9b203fa68ab92a78cbe025ac65" translate="yes" xml:space="preserve">
          <source>Some pages may be protected so that only specific users can access them. Basic authentication may be provided by HTTP, either using the &lt;a href=&quot;headers/www-authenticate&quot;&gt;&lt;code&gt;WWW-Authenticate&lt;/code&gt;&lt;/a&gt; and similar headers, or by setting a specific session using &lt;a href=&quot;cookies&quot;&gt;HTTP cookies&lt;/a&gt;.</source>
          <target state="translated">일부 페이지는 특정 사용자 만 액세스 할 수 있도록 보호 될 수 있습니다. 기본 인증은 &lt;a href=&quot;headers/www-authenticate&quot;&gt; &lt;code&gt;WWW-Authenticate&lt;/code&gt; &lt;/a&gt; 및 유사한 헤더를 사용하거나 &lt;a href=&quot;cookies&quot;&gt;HTTP 쿠키를&lt;/a&gt; 사용하여 특정 세션을 설정 하여 HTTP에서 제공 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="7a7d1f4b13e76bd620feb3c514de20a064d7ef93" translate="yes" xml:space="preserve">
          <source>Some proxy servers might need authority to create a tunnel. See also the &lt;a href=&quot;../headers/proxy-authorization&quot;&gt;&lt;code&gt;Proxy-Authorization&lt;/code&gt;&lt;/a&gt; header.</source>
          <target state="translated">일부 프록시 서버는 터널을 만들 권한이 필요할 수 있습니다. &lt;a href=&quot;../headers/proxy-authorization&quot;&gt; &lt;code&gt;Proxy-Authorization&lt;/code&gt; &lt;/a&gt; 헤더 도 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="f0fe168232211ebb71557e7e371b951b8fb141f8" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &amp;ldquo;simple requests&amp;rdquo; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A request that doesn&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;&amp;mdash;a so-called &amp;ldquo;simple request&amp;rdquo; &amp;mdash; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">일부 요청은 &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight를&lt;/a&gt; 트리거하지 않습니다 . &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; 스펙 (CORS를 정의 함) 은이 용어를 사용하지 않지만 ,이 기사에서는이를 &quot;간단한 요청&quot;이라고 합니다. &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS 프리 플라이트를&lt;/a&gt; 트리거하지 않는 요청 ( 소위 &quot;단순 요청&quot;) &lt;strong&gt;은 다음 조건을 모두 충족&lt;/strong&gt; 하는 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="9dcff009cb4590f1396339dc97ee7e3c2dfd40fa" translate="yes" xml:space="preserve">
          <source>Some requests don&amp;rsquo;t trigger a &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS preflight&lt;/a&gt;. Those are called &lt;em&gt;&amp;ldquo;simple requests&amp;rdquo;&lt;/em&gt; in this article, though the &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; spec (which defines CORS) doesn&amp;rsquo;t use that term. A &amp;ldquo;simple request&amp;rdquo; is one that &lt;strong&gt;meets all the following conditions&lt;/strong&gt;:</source>
          <target state="translated">일부 요청은 &lt;a href=&quot;#Preflighted_requests&quot;&gt;CORS 프리 플라이트를&lt;/a&gt; 트리거하지 않습니다 . 이 기사에서는이를 &lt;em&gt;&quot;단순 요청&quot;&lt;/em&gt; 이라고 하지만, &lt;a href=&quot;https://fetch.spec.whatwg.org/&quot;&gt;Fetch&lt;/a&gt; 사양 (CORS를 정의)에서는 해당 용어를 사용하지 않습니다. &quot;단순 요청&quot;은 &lt;strong&gt;다음 조건을 모두 충족&lt;/strong&gt; 하는 요청입니다 .</target>
        </trans-unit>
        <trans-unit id="9b7772fe71270600ccf3a3236874e99cde15c3a7" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server like sometimes &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about the progress, or allows to cancel it.</source>
          <target state="translated">나중에 처리하도록 예약 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 요청 과 같이 일부 요청은 서버에서 더 많은 시간이 필요할 수 있습니다 . 이 경우 응답은 작업이 예약되었음을 나타내는 페이지로 연결 되는 &lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (기타 참조) 리디렉션이며 결과적으로 진행 상황을 알리거나 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="e69ac0ff78ca934a19fc41226c03d69cd112b823" translate="yes" xml:space="preserve">
          <source>Some requests may need more time on the server, like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt;&lt;code&gt;DELETE&lt;/code&gt;&lt;/a&gt; requests that are scheduled for later processing. In this case, the response is a &lt;a href=&quot;status/303&quot;&gt;&lt;code&gt;303&lt;/code&gt;&lt;/a&gt; (See Other) redirect that links to a page indicating that the action has been scheduled, and eventually informs about its progress, or allows to cancel it.</source>
          <target state="translated">나중에 처리하도록 예약 된 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/DELETE&quot;&gt; &lt;code&gt;DELETE&lt;/code&gt; &lt;/a&gt; 요청 과 같은 일부 요청은 서버에서 더 많은 시간이 필요할 수 있습니다 . 이 경우 응답은 작업이 예약되었음을 나타내는 페이지로 연결 되는 &lt;a href=&quot;status/303&quot;&gt; &lt;code&gt;303&lt;/code&gt; &lt;/a&gt; (기타 참조) 리디렉션이며 결국 진행 상황을 알리거나 취소 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="932d714aa9986fefde686199be3c38ba8d61e288" translate="yes" xml:space="preserve">
          <source>Some sections of this specification are illustrated with fragments of
   a non-normative RELAX NG Compact schema [&lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt;].  However, the text of
   this specification provides the definition of conformance.  Complete
   schemas appear in &lt;a href=&quot;#appendix-B&quot;&gt;Appendix B&lt;/a&gt;.</source>
          <target state="translated">이 사양의 일부 섹션은 비표준 RELAX NG Compact 스키마 [ &lt;a href=&quot;#ref-RNC&quot;&gt;RNC&lt;/a&gt; ]의 단편으로 설명되어 있습니다. 그러나이 사양의 텍스트는 적합성의 정의를 제공합니다. 완전한 스키마가 &lt;a href=&quot;#appendix-B&quot;&gt;부록 B에&lt;/a&gt; 나타납니다 .</target>
        </trans-unit>
        <trans-unit id="cbcfbee9d39daa00061999fcaad831841c2ed71a" translate="yes" xml:space="preserve">
          <source>Some websites use this response for requests they do not wish to handle, such as automated queries.</source>
          <target state="translated">일부 웹 사이트는 자동화 된 쿼리와 같이 처리하지 않으려는 요청에이 응답을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="bf1960a9dab8a69c52ce013a2615773d1727df49" translate="yes" xml:space="preserve">
          <source>Sometimes a user agent might want or need to insist that a cache
   revalidate its cache entry with the origin server (and not just with
   the next cache along the path to the origin server), or to reload its
   cache entry from the origin server. End-to-end revalidation might be
   necessary if either the cache or the origin server has overestimated
   the expiration time of the cached response. End-to-end reload may be
   necessary if the cache entry has become corrupted for some reason.

   End-to-end revalidation may be requested either when the client does
   not have its own local cached copy, in which case we call it
   &quot;unspecified end-to-end revalidation&quot;, or when the client does have a
   local cached copy, in which case we call it &quot;specific end-to-end
   revalidation.&quot;

   The client can specify these three kinds of action using Cache-
   Control request directives:

   End-to-end reload
      The request includes a &quot;no-cache&quot; cache-control directive or, for
      compatibility with HTTP/1.0 clients, &quot;Pragma: no-cache&quot;. Field
      names MUST NOT be included with the no-cache directive in a
      request. The server MUST NOT use a cached copy when responding to
      such a request.

   Specific end-to-end revalidation
      The request includes a &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request includes a cache-validating conditional with
      the client's current validator.

   Unspecified end-to-end revalidation
      The request includes &quot;max-age=0&quot; cache-control directive, which
      forces each cache along the path to the origin server to
      revalidate its own entry, if any, with the next cache or server.
      The initial request does not include a cache-validating 

      conditional; the first cache along the path (if any) that holds a
      cache entry for this resource includes a cache-validating
      conditional with its current validator.

   max-age
      When an intermediate cache is forced, by means of a max-age=0
      directive, to revalidate its own cache entry, and the client has
      supplied its own validator in the request, the supplied validator
      might differ from the validator currently stored with the cache
      entry. In this case, the cache MAY use either validator in making
      its own request without affecting semantic transparency.

      However, the choice of validator might affect performance. The
      best approach is for the intermediate cache to use its own
      validator when making its request. If the server replies with 304
      (Not Modified), then the cache can return its now validated copy
      to the client with a 200 (OK) response. If the server replies with
      a new entity and cache validator, however, the intermediate cache
      can compare the returned validator with the one provided in the
      client's request, using the strong comparison function. If the
      client's validator is equal to the origin server's, then the
      intermediate cache simply returns 304 (Not Modified). Otherwise,
      it returns the new entity with a 200 (OK) response.

      If a request includes the no-cache directive, it SHOULD NOT
      include min-fresh, max-stale, or max-age.

   only-if-cached
      In some cases, such as times of extremely poor network
      connectivity, a client may want a cache to return only those
      responses that it currently has stored, and not to reload or
      revalidate with the origin server. To do this, the client may
      include the only-if-cached directive in a request. If it receives
      this directive, a cache SHOULD either respond using a cached entry
      that is consistent with the other constraints of the request, or
      respond with a 504 (Gateway Timeout) status. However, if a group
      of caches is being operated as a unified system with good internal
      connectivity, such a request MAY be forwarded within that group of
      caches.

   must-revalidate
      Because a cache MAY be configured to ignore a server's specified
      expiration time, and because a client request MAY include a max-
      stale directive (which has a similar effect), the protocol also
      includes a mechanism for the origin server to require revalidation
      of a cache entry on any subsequent use. When the must-revalidate
      directive is present in a response received by a cache, that cache
      MUST NOT use the entry after it becomes stale to respond to a 

      subsequent request without first revalidating it with the origin
      server. (I.e., the cache MUST do an end-to-end revalidation every
      time, if, based solely on the origin server's Expires or max-age
      value, the cached response is stale.)

      The must-revalidate directive is necessary to support reliable
      operation for certain protocol features. In all circumstances an
      HTTP/1.1 cache MUST obey the must-revalidate directive; in
      particular, if the cache cannot reach the origin server for any
      reason, it MUST generate a 504 (Gateway Timeout) response.

      Servers SHOULD send the must-revalidate directive if and only if
      failure to revalidate a request on the entity could result in
      incorrect operation, such as a silently unexecuted financial
      transaction. Recipients MUST NOT take any automated action that
      violates this directive, and MUST NOT automatically provide an
      unvalidated copy of the entity if revalidation fails.

      Although this is not recommended, user agents operating under
      severe connectivity constraints MAY violate this directive but, if
      so, MUST explicitly warn the user that an unvalidated response has
      been provided. The warning MUST be provided on each unvalidated
      access, and SHOULD require explicit user confirmation.

   proxy-revalidate
      The proxy-revalidate directive has the same meaning as the must-
      revalidate directive, except that it does not apply to non-shared
      user agent caches. It can be used on a response to an
      authenticated request to permit the user's cache to store and
      later return the response without needing to revalidate it (since
      it has already been authenticated once by that user), while still
      requiring proxies that service many users to revalidate each time
      (in order to make sure that each user has been authenticated).
      Note that such authenticated responses also need the public cache
      control directive in order to allow them to be cached at all.</source>
          <target state="translated">때때로 사용자 에이전트는 캐시가 캐시 항목을 원래 서버로 재확인하거나 (원본 서버로의 경로를 따라 다음 캐시가 아닌) 원래 서버에서 캐시 항목을 다시로드하도록 요구하거나 요구할 수 있습니다. 캐시 또는 오리진 서버가 캐시 된 응답의 만료 시간을 과대 평가 한 경우 엔드 투 엔드 유효성 재확인이 필요할 수 있습니다. 캐시 항목이 어떤 이유로 손상된 경우 엔드 투 엔드 재로드가 필요할 수 있습니다. 엔드 투 엔드 재확인은 클라이언트에 자체 로컬 캐시 사본이 없거나 &quot;지정되지 않은 엔드 투 엔드 재확인&quot;이라고하거나 클라이언트에 로컬 캐시 사본이있을 때 요청 될 수 있습니다. 어떤 경우에는 &quot;특정 종단 간 재확인&quot;이라고합니다.클라이언트는 캐시 제어 요청 지시문을 사용하여 이러한 세 가지 조치를 지정할 수 있습니다. 엔드 투 엔드 재로드 요청에 &quot;비 캐시&quot;캐시 제어 지시문이 포함되어 있거나 HTTP / 1.0 클라이언트와의 호환성을 위해 &quot;Pragma : no- 은닉처&quot;. 요청시 필드 이름을 no-cache 지시문에 포함해서는 안됩니다. 서버는 그러한 요청에 응답 할 때 캐시 된 사본을 사용해서는 안됩니다. 특정 엔드-투-엔드 재 검증 요청에는 &quot;max-age = 0&quot;캐시 제어 지시문이 포함되는데,이 캐시 제어 지시문은 원래 캐시에 대한 경로를 따라 각 캐시가 다음 캐시 또는 서버로 자신의 항목을 재확인하도록합니다. 초기 요청에는 클라이언트의 현재 유효성 검사기와 함께 캐시 유효성 검사 조건이 포함됩니다.지정되지 않은 엔드 투 엔드 유효성 재확인 요청에는 &quot;max-age = 0&quot;캐시 제어 지시문이 포함되어 있습니다.이 명령은 원 서버로의 경로를 따라 각 캐시가 다음 캐시 또는 서버로 자신의 항목을 재확인하도록합니다. 초기 요청에는 캐시 유효성 검사 조건이 포함되지 않습니다. 이 자원에 대한 캐시 항목을 보유하는 경로 (있는 경우)를 따르는 첫 번째 캐시에는 현재 유효성 검증 기와의 조건에 따른 캐시 유효성 검증이 포함됩니다. max-age max-age = 0 지시문을 사용하여 자체 캐시 항목을 재확인하도록 중간 캐시를 강제 실행하고 클라이언트가 요청에서 자체 유효성 검증기를 제공 한 경우 제공된 유효성 검증 기가 현재 저장된 유효성 검증기와 다를 수 있습니다. 캐시 항목과 함께. 이 경우캐시는 의미 투명성에 영향을 미치지 않고 자체 요청을 수행하는 데 유효성 검사기를 사용할 수 있습니다. 그러나 유효성 검사기를 선택하면 성능에 영향을 줄 수 있습니다. 가장 좋은 방법은 중간 캐시가 요청을 할 때 자체 유효성 검사기를 사용하는 것입니다. 서버가 304 (수정되지 않음)로 응답하면 캐시는 현재 확인 된 사본을 200 (OK) 응답으로 클라이언트에 반환 할 수 있습니다. 그러나 서버가 새 엔티티 및 캐시 유효성 검증기로 응답하는 경우 중간 캐시는 강력한 비교 기능을 사용하여 리턴 된 유효성 검증기를 클라이언트 요청에 제공된 유효성 검증기와 비교할 수 있습니다. 클라이언트의 유효성 검사기가 원본 서버의 유효성 검사기와 동일하면 중간 캐시는 단순히 304 (수정되지 않음)를 반환합니다. 그렇지 않으면,200 (OK) 응답으로 새 엔터티를 반환합니다. 요청에 no-cache 지시문이 포함 된 경우 min-fresh, max-stale 또는 max-age를 포함해서는 안됩니다. 캐시 된 경우 네트워크 연결이 매우 약한 경우와 같이 클라이언트는 캐시에 현재 저장된 응답 만 반환하고 원본 서버로 다시로드하거나 다시 확인하지 않기를 원할 수 있습니다. 이를 위해 클라이언트는 요청에 캐시 전용 지시문을 포함시킬 수 있습니다. 이 지시어를 수신하면 캐시는 요청의 다른 제약 조건과 일치하는 캐시 된 항목을 사용하여 응답하거나 504 (게이트웨이 시간 초과) 상태로 응답해야합니다. 그러나 캐시 그룹이 내부 연결이 양호한 통합 시스템으로 작동하는 경우,이러한 요청은 해당 캐시 그룹 내에서 전달 될 수 있습니다. must-revalidate 캐시가 서버의 지정된 만료 시간을 무시하도록 구성 될 수 있고 클라이언트 요청에 max-stle 지시문 (유사한 영향을 미침)이 포함될 수 있기 때문에 프로토콜에는 원래 서버의 유효성을 다시 확인하는 메커니즘도 포함됩니다. 이후 사용시 캐시 항목 캐시가 수신 한 응답에 must-revalidate 지시문이있는 경우, 해당 캐시는 원래 서버로 먼저 재확인하지 않고 후속 요청에 응답하기 위해 부실한 항목을 사용해서는 안됩니다. 즉, 원래 서버의 만료 또는 최대 연령 값만 기반으로 캐시 된 응답이 오래되면 캐시는 매번 엔드 투 엔드 유효성 재확인을 수행해야합니다.) 특정 프로토콜 기능에 대한 안정적인 작동을 지원하려면 반드시 수정해야합니다. 모든 상황에서 HTTP / 1.1 캐시는 must-revalidate 지시문을 준수해야합니다. 특히 캐시가 어떤 이유로 든 오리진 서버에 도달 할 수없는 경우 반드시 504 (게이트웨이 타임 아웃) 응답을 생성해야합니다. 서버는 엔터티에 대한 요청을 다시 확인하지 못하면 자동으로 실행되지 않는 금융 거래와 같은 잘못된 작업이 발생할 수있는 경우에만 must-revalidate 지시문을 보내야합니다. 수령인은이 지침을 위반하는 자동화 된 조치를 취해서는 안되며, 유효성 재확인에 실패한 경우 유효하지 않은 엔티티의 사본을 자동으로 제공해서는 안됩니다. 권장하지는 않지만심각한 연결 제약 조건 하에서 작동하는 사용자 에이전트는이 지시문을 위반할 수 있지만, 유효하지 않은 응답이 제공되었음을 사용자에게 명시 적으로 경고해야합니다. 확인되지 않은 각 액세스마다 경고를 제공해야하며 명시적인 사용자 확인이 필요합니다. proxy-revalidate proxy-revalidate 지시문은 비공유 사용자 에이전트 캐시에 적용되지 않는다는 점을 제외하고 must-revalidate 지시문과 동일한 의미를 갖습니다. 인증 된 요청에 대한 응답에 사용되어 사용자 캐시가 응답을 다시 저장하지 않고도 저장하고 나중에 응답을 반환하도록 허용 할 수 있습니다 (사용자가 이미 한 번 인증 했으므로).각 사용자가 인증되었는지 확인하기 위해 매번 재확인하는 많은 사용자를 서비스하는 프록시가 여전히 필요합니다. 이러한 인증 된 응답에는 캐시를 전혀 캐시하지 않으려면 공용 캐시 제어 지시문도 필요합니다.</target>
        </trans-unit>
        <trans-unit id="f28c6b808e20b5e65f433eb5b11613875d49c1a2" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource can't be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used.</source>
          <target state="translated">때때로 요청 된 리소스는 표준 위치에서 액세스 할 수 없지만 다른 위치에서 액세스 할 수 있습니다. 이 경우 임시 리디렉션을 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="f0f13543920ce2519c90532c2d9391d9d564cd65" translate="yes" xml:space="preserve">
          <source>Sometimes the requested resource cannot be accessed from its canonical location, but it can be accessed from another place. In this case, a temporary redirect can be used. Search engine robots don't memorize the new, temporary link. Temporary redirections are also used when creating, updating and deleting resources to present temporary progress pages.</source>
          <target state="translated">요청 된 리소스는 정식 위치에서 액세스 할 수 없지만 다른 곳에서는 액세스 할 수 있습니다. 이 경우 임시 리디렉션을 사용할 수 있습니다. 검색 엔진 로봇은 새로운 임시 링크를 기억하지 않습니다. 임시 진행 재 지정은 자원을 작성, 업데이트 및 삭제하여 임시 진행률 페이지를 표시 할 때도 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="d332abe855c0a9991ccf162c5e9b1e9be151b36a" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and display an error message. Firefox displays:</source>
          <target state="translated">때로는 서버가이를 감지하지 못합니다. 리디렉션 루프는 각각 전체 그림이없는 여러 서버에 퍼질 수 있습니다. 이 경우 브라우저는이를 감지하고 오류 메시지를 표시합니다. Firefox 디스플레이 :</target>
        </trans-unit>
        <trans-unit id="7f8875e5296a70a5c55485d7837e9b58660f6869" translate="yes" xml:space="preserve">
          <source>Sometimes, the server won't detect it: a redirection loop can spread over several servers which each don't have the full picture. In this case, browsers will detect it and post an error message. Firefox will display:</source>
          <target state="translated">경우에 따라 서버에서이를 감지하지 못할 수도 있습니다. 리디렉션 루프가 전체 그림이없는 여러 서버에 분산 될 수 있습니다. 이 경우 브라우저는이를 감지하여 오류 메시지를 게시합니다. Firefox가 표시됩니다 :</target>
        </trans-unit>
        <trans-unit id="d82ff801ae9d70ca71f25b3a35123f191863d17a" translate="yes" xml:space="preserve">
          <source>Sometimes, this code indicates that the request can not be processed until the client makes a payment. Originally it was created to enable digital cash or (micro) payment systems and would indicate that the requested content is not available until the client makes a payment. However, no standard use convention exists and different entities use it in different contexts.</source>
          <target state="translated">때때로이 코드는 클라이언트가 결제 할 때까지 요청을 처리 할 수 ​​없음을 나타냅니다. 원래는 디지털 현금 또는 (마이크로) 결제 시스템을 활성화하기 위해 만들어졌으며 클라이언트가 결제 할 때까지 요청 된 콘텐츠를 사용할 수 없음을 나타냅니다. 그러나 표준 사용 규칙이 존재하지 않으며 다른 엔티티가 다른 컨텍스트에서이를 사용합니다.</target>
        </trans-unit>
        <trans-unit id="461f6249960b9f5e0adb518e83fe6728e5a1aa14" translate="yes" xml:space="preserve">
          <source>Source Map Revision 3 Proposal</source>
          <target state="translated">소스 맵 개정 3 제안</target>
        </trans-unit>
        <trans-unit id="48a37d9cb6f83141d7762830d6d9b21396138f77" translate="yes" xml:space="preserve">
          <source>Source code of the resource</source>
          <target state="translated">자원의 소스 코드</target>
        </trans-unit>
        <trans-unit id="eddadabaed64a1c9704679bf2c71541b37a9a200" translate="yes" xml:space="preserve">
          <source>SourceMap</source>
          <target state="translated">SourceMap</target>
        </trans-unit>
        <trans-unit id="2eb56be3c2d93cdab0c52e677e3167dfddb30ac5" translate="yes" xml:space="preserve">
          <source>Sources</source>
          <target state="translated">Sources</target>
        </trans-unit>
        <trans-unit id="7c23b0d99698b57c5cb21fafcb8a8daf127386c6" translate="yes" xml:space="preserve">
          <source>Speaker</source>
          <target state="translated">Speaker</target>
        </trans-unit>
        <trans-unit id="65fa5e6b8d558cde85a3a07a4e444c679377961e" translate="yes" xml:space="preserve">
          <source>Special redirections</source>
          <target state="translated">특수 리디렉션</target>
        </trans-unit>
        <trans-unit id="1432da84229d762b613e72e68e00057a594449c8" translate="yes" xml:space="preserve">
          <source>Specific &lt;a href=&quot;headers&quot;&gt;HTTP headers&lt;/a&gt; by the client (&lt;em&gt;server-driven negotiation&lt;/em&gt; or &lt;em&gt;proactive negotiation&lt;/em&gt;), which is the standard way of negotiating a specific kind of resource.</source>
          <target state="translated">특정 종류의 리소스를 협상하는 표준 방법 인 클라이언트의 특정 &lt;a href=&quot;headers&quot;&gt;HTTP 헤더&lt;/a&gt; ( &lt;em&gt;서버 중심 협상&lt;/em&gt; 또는 &lt;em&gt;사전 협상&lt;/em&gt; )</target>
        </trans-unit>
        <trans-unit id="1ccf5d25dfedda0749e3abb6685b56a5fed8013a" translate="yes" xml:space="preserve">
          <source>Specification</source>
          <target state="translated">Specification</target>
        </trans-unit>
        <trans-unit id="0c709f9886c34419d95252da6707fd3dc704a220" translate="yes" xml:space="preserve">
          <source>Specifications</source>
          <target state="translated">Specifications</target>
        </trans-unit>
        <trans-unit id="30d32085a077fd1f486b08c98f4d346c5a6b17fc" translate="yes" xml:space="preserve">
          <source>Specifications and RFCs:</source>
          <target state="translated">사양 및 RFC :</target>
        </trans-unit>
        <trans-unit id="07b2551feb0b78f2ae3f0674493bd2ba4c495576" translate="yes" xml:space="preserve">
          <source>Specifies GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE.</source>
          <target state="translated">GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="c58c8c11265fc2163fd1c23b0043a730d6d564bd" translate="yes" xml:space="preserve">
          <source>Specifies PATCH.</source>
          <target state="translated">PATCH를 지정합니다.</target>
        </trans-unit>
        <trans-unit id="99d3f27b2e59be204c52c5c9fc1e3fd32e5425f2" translate="yes" xml:space="preserve">
          <source>Specifies a URI that may see the timing resources. You can specify multiple origins, separated by commas.</source>
          <target state="translated">타이밍 자원을 볼 수있는 URI를 지정합니다. 쉼표로 구분하여 여러 원점을 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3dc214da21e1ecdb977da6e15c1694d398e424b" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified.</source>
          <target state="translated">원점을 지정합니다. 단일 원점 만 지정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="0e8dd4aed544a9115516fcba2b2e3d1772b43815" translate="yes" xml:space="preserve">
          <source>Specifies an origin. Only a single origin can be specified. If the server supports clients from multiple origins, it must return the origin for the specific client making the request.</source>
          <target state="translated">원점을 지정합니다. 원점은 하나만 지정할 수 있습니다. 서버가 여러 원본의 클라이언트를 지원하는 경우 요청을 만드는 특정 클라이언트의 원본을 반환해야합니다.</target>
        </trans-unit>
        <trans-unit id="08522ebb29d8c09aa8e3393f359476bbe00317a0" translate="yes" xml:space="preserve">
          <source>Specifies directives for caching mechanisms in both requests and responses.</source>
          <target state="translated">요청과 응답 모두에서 캐싱 메커니즘에 대한 지시문을 지정합니다.</target>
        </trans-unit>
        <trans-unit id="149c7938c7e3b3f09b90de06c72ca9aaa91e52c2" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy file (&lt;code&gt;crossdomain.xml&lt;/code&gt;) is allowed. The file may define a policy to grant clients, such as Adobe's Flash Player (now obsolete), Adobe Acrobat, Microsoft Silverlight (now obsolete), or Apache Flex, permission to handle data across domains that would otherwise be restricted due to the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same-Origin Policy&lt;/a&gt;. See the &lt;a href=&quot;https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html&quot;&gt;Cross-domain Policy File Specification&lt;/a&gt; for more information.</source>
          <target state="translated">교차 도메인 정책 파일 ( &lt;code&gt;crossdomain.xml&lt;/code&gt; )이 허용 되는지 여부를 지정합니다 . 파일은 Adobe의 Flash Player (현재는 사용되지 않음), Adobe Acrobat, Microsoft Silverlight (현재 사용되지 않음) 또는 Apache Flex와 같은 클라이언트에게 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot;&gt;Same- 원산지 정책&lt;/a&gt; . 자세한 내용은 &lt;a href=&quot;https://www.adobe.com/devnet/articles/crossdomain_policy_file_spec.html&quot;&gt;도메인 간 정책 파일 사양&lt;/a&gt; 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="2ac472e4fe7931170e92aa9f011df74fb8e68f3a" translate="yes" xml:space="preserve">
          <source>Specifies if a cross-domain policy-file (XML) is allowed. The file may define a policy to grant web clients, such as Adobe Flash Player or Adobe Acrobat (e.g. PDF), permission to handle data across domains.</source>
          <target state="translated">도메인 간 정책 파일 (XML)이 허용되는지 여부를 지정합니다. 이 파일은 Adobe Flash Player 또는 Adobe Acrobat (예 : PDF)과 같은 웹 클라이언트에 도메인 간 데이터를 처리 할 수있는 권한을 부여하는 정책을 정의 할 수 있습니다.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
