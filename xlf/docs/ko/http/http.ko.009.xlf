<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="ko" datatype="htmlbody" original="http">
    <body>
      <group id="http">
        <trans-unit id="14a29ba383c84d15925a42f871530f52904ae908" translate="yes" xml:space="preserve">
          <source>Use cases</source>
          <target state="translated">사용 사례</target>
        </trans-unit>
        <trans-unit id="f86adfd6db8707c78a8855719e5ab5617c841214" translate="yes" xml:space="preserve">
          <source>Use of &lt;code&gt;isInNet()&lt;/code&gt;, &lt;code&gt;isResolvable()&lt;/code&gt; and &lt;code&gt;dnsResolve()&lt;/code&gt; functions should be carefully considered, as they require the DNS server to be consulted. All the other autoconfig-related functions are mere string-matching functions that don't require the use of a DNS server. If a proxy is used, the proxy will perform its DNS lookup which would double the impact on the DNS server. Most of the time these functions are not necessary to achieve the desired result.</source>
          <target state="translated">의 사용 &lt;code&gt;isInNet()&lt;/code&gt; , &lt;code&gt;isResolvable()&lt;/code&gt; 및 &lt;code&gt;dnsResolve()&lt;/code&gt; 가 DNS 서버가 협의해야로서 기능을 신중하게 고려되어야한다. 다른 모든 자동 구성 관련 기능은 DNS 서버를 사용할 필요가없는 단순한 문자열 일치 기능입니다. 프록시가 사용되면 프록시는 DNS 조회를 수행하여 DNS 서버에 미치는 영향을 두 배로 증가시킵니다. 대부분의 경우 이러한 기능은 원하는 결과를 얻는 데 필요하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="541cad19bcced32598517d8ec84381ca4110eb7d" translate="yes" xml:space="preserve">
          <source>Use of server-driven content negotiation (&lt;a href=&quot;#section-12.1&quot;&gt;section 12.1&lt;/a&gt;), as indicated
   by the presence of a Vary header field in a response, alters the
   conditions and procedure by which a cache can use the response for
   subsequent requests. See &lt;a href=&quot;#section-14.44&quot;&gt;section 14.44&lt;/a&gt; for use of the Vary header
   field by servers.

   A server SHOULD use the Vary header field to inform a cache of what
   request-header fields were used to select among multiple
   representations of a cacheable response subject to server-driven
   negotiation. The set of header fields named by the Vary field value
   is known as the &quot;selecting&quot; request-headers.

   When the cache receives a subsequent request whose Request-URI
   specifies one or more cache entries including a Vary header field,
   the cache MUST NOT use such a cache entry to construct a response to
   the new request unless all of the selecting request-headers present
   in the new request match the corresponding stored request-headers in
   the original request.

   The selecting request-headers from two requests are defined to match
   if and only if the selecting request-headers in the first request can
   be transformed to the selecting request-headers in the second request 

   by adding or removing linear white space (LWS) at places where this
   is allowed by the corresponding BNF, and/or combining multiple
   message-header fields with the same field name following the rules
   about message headers in &lt;a href=&quot;#section-4.2&quot;&gt;section 4.2&lt;/a&gt;.

   A Vary header field-value of &quot;*&quot; always fails to match and subsequent
   requests on that resource can only be properly interpreted by the
   origin server.

   If the selecting request header fields for the cached entry do not
   match the selecting request header fields of the new request, then
   the cache MUST NOT use a cached entry to satisfy the request unless
   it first relays the new request to the origin server in a conditional
   request and the server responds with 304 (Not Modified), including an
   entity tag or Content-Location that indicates the entity to be used.

   If an entity tag was assigned to a cached representation, the
   forwarded request SHOULD be conditional and include the entity tags
   in an If-None-Match header field from all its cache entries for the
   resource. This conveys to the server the set of entities currently
   held by the cache, so that if any one of these entities matches the
   requested entity, the server can use the ETag header field in its 304
   (Not Modified) response to tell the cache which entry is appropriate.
   If the entity-tag of the new response matches that of an existing
   entry, the new response SHOULD be used to update the header fields of
   the existing entry, and the result MUST be returned to the client.

   If any of the existing cache entries contains only partial content
   for the associated entity, its entity-tag SHOULD NOT be included in
   the If-None-Match header field unless the request is for a range that
   would be fully satisfied by that entry.

   If a cache receives a successful response whose Content-Location
   field matches that of an existing cache entry for the same Request-
   ]URI, whose entity-tag differs from that of the existing entry, and
   whose Date is more recent than that of the existing entry, the
   existing entry SHOULD NOT be returned in response to future requests
   and SHOULD be deleted from the cache.</source>
          <target state="translated">응답에 Vary 헤더 필드가 있음으로 표시되는 서버 기반 컨텐츠 협상 ( &lt;a href=&quot;#section-12.1&quot;&gt;섹션 12.1&lt;/a&gt; )을 사용하면 캐시가 후속 요청에 응답을 사용할 수있는 조건 및 절차가 변경됩니다. 보다&lt;a href=&quot;#section-14.44&quot;&gt; 섹션 14.44&lt;/a&gt;서버에서 Vary 헤더 필드를 사용합니다. 서버는 Vary 헤더 필드를 사용하여 서버 구동 협상에 따라 캐시 가능한 응답의 다중 표현 중에서 선택하는 데 사용 된 요청 헤더 필드를 캐시에 알려야합니다. Vary 필드 값으로 명명 된 헤더 필드 세트를 &quot;선택&quot;요청 헤더라고합니다. 캐시가 Request-URI가 Vary 헤더 필드를 포함하여 하나 이상의 캐시 항목을 지정하는 후속 요청을 수신 할 때, 캐시는 선택 요청 헤더가 모두 존재하지 않는 한 이러한 캐시 항목을 사용하여 새로운 요청에 대한 응답을 구성해서는 안됩니다. 새 요청은 원래 요청의 해당 저장된 요청 헤더와 일치합니다.두 요청에서 선택 요청 헤더는 위치에서 선형 공백 (LWS)을 추가하거나 제거하여 첫 번째 요청에서 선택 요청 헤더를 두 번째 요청에서 선택 요청 헤더로 변환 할 수있는 경우에만 일치하도록 정의됩니다. 여기서 해당 BNF가 허용하거나 메시지 헤더에 대한 규칙에 따라 동일한 필드 이름으로 여러 메시지 헤더 필드를 결합&lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt;. &quot;*&quot;의 Vary 헤더 필드 값이 항상 일치하지 않으며 해당 자원의 후속 요청은 원래 서버에서만 올바르게 해석 할 수 있습니다. 캐시 된 항목에 대한 선택 요청 헤더 필드가 새 요청의 선택 요청 헤더 필드와 일치하지 않으면 캐시는 캐시 된 항목을 사용하여 요청을 먼저 충족시키지 않는 한 요청을 만족시키기 위해 캐시 된 항목을 사용해서는 안됩니다 (MUST). 요청하고 서버는 사용할 엔티티를 나타내는 엔티티 태그 또는 Content-Location을 포함하여 304 (수정되지 않음)로 응답합니다. 엔티티 태그가 캐시 된 표현에 할당 되었다면, 전달 된 요청은 조건부이어야하고 자원에 대한 모든 캐시 엔트리로부터 If-None-Match 헤더 필드에 엔티티 태그를 포함시켜야한다.이것은 캐시에 현재 보유 된 엔티티 세트를 서버에 전달하므로, 이들 엔티티 중 하나가 요청 된 엔티티와 일치하는 경우 서버는 304 (수정되지 않음) 응답에서 ETag 헤더 필드를 사용하여 캐시에 어떤 항목을 알려줄 수 있습니다 적절하다. 새로운 응답의 엔티티 태그가 기존 엔트리의 엔티티 태그와 일치하면, 새로운 응답을 사용하여 기존 엔트리의 헤더 필드를 업데이트해야하며 결과는 반드시 클라이언트에게 반환되어야합니다. 기존 캐시 항목 중 하나에 관련 엔터티에 대한 부분 내용 만 포함 된 경우 요청이 해당 항목에 의해 완전히 만족되는 범위가 아닌 경우 엔터티 태그는 If-None-Match 헤더 필드에 포함되지 않아야합니다.캐시가 Content-Location 필드가 동일한 Request-] URI에 대한 기존 캐시 항목의 응답과 일치하고 엔티티 태그가 기존 항목의 것과 다르고 날짜가 기존의 항목보다 최신 인 응답을 수신하는 경우 기존 요청은 향후 요청에 대한 응답으로 반환되어서는 안되며 캐시에서 삭제해야합니다 (SHOULD).</target>
        </trans-unit>
        <trans-unit id="e77c9c913df2233d025f025eb22c3c9e62e56fdc" translate="yes" xml:space="preserve">
          <source>Use of the Content-Disposition Header Field in the Hypertext Transfer Protocol (HTTP)</source>
          <target state="translated">HTTP (Hypertext Transfer Protocol)에서 콘텐츠 처리 헤더 필드 사용</target>
        </trans-unit>
        <trans-unit id="eb01880ea7e6c648b8ded6a971ea49e97cecb27b" translate="yes" xml:space="preserve">
          <source>Use proxy for everything except local hosts</source>
          <target state="translated">로컬 호스트를 제외한 모든 것에 프록시 사용</target>
        </trans-unit>
        <trans-unit id="0107748696d0540526cac08ee4cbc145c8a991e8" translate="yes" xml:space="preserve">
          <source>Use proxy only if cannot resolve host</source>
          <target state="translated">호스트를 확인할 수없는 경우에만 프록시 사용</target>
        </trans-unit>
        <trans-unit id="c7ed5020d95df63e9bfb909b2b5b6c058bbb92a7" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;../referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">사용 &lt;a href=&quot;../referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt; 대신 헤더를.</target>
        </trans-unit>
        <trans-unit id="374f23714fac239889ce0a35686349d0fd2fc8cd" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;HttpOnly&lt;/code&gt; attribute to prevent access to cookie values via JavaScript.</source>
          <target state="translated">Use the &lt;code&gt;HttpOnly&lt;/code&gt; attribute to prevent access to cookie values via JavaScript.</target>
        </trans-unit>
        <trans-unit id="a6ac4246f627ce26f7ce64dc4d28d75832652c40" translate="yes" xml:space="preserve">
          <source>Used by Internet Explorer to signal which document mode to use.</source>
          <target state="translated">사용할 문서 모드를 알리기 위해 Internet Explorer에서 사용합니다.</target>
        </trans-unit>
        <trans-unit id="3e069a42a09f6b8db75113499e4519c2f9266038" translate="yes" xml:space="preserve">
          <source>Used for expressing the user's tracking preference.</source>
          <target state="translated">사용자의 추적 기본 설정을 표현하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="83b3f402f1178112d86419eb8f13870a53b15a0a" translate="yes" xml:space="preserve">
          <source>Used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">Used in response to a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Preflight_request&quot;&gt;preflight request&lt;/a&gt; to indicate which HTTP headers can be used when making the actual request.</target>
        </trans-unit>
        <trans-unit id="254d1c745ac787d4b79a0930aea72d4ebc02b51f" translate="yes" xml:space="preserve">
          <source>Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답으로 실제 요청시 사용할 수있는 HTTP 헤더를 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="dd444ebe633050849c3b22b62bbb0225010af96b" translate="yes" xml:space="preserve">
          <source>Used inside a &lt;code&gt;&amp;lt;dav:propstat&amp;gt;&lt;/code&gt; response element to avoid repeatedly enumerating the internal members of multiple bindings to the same collection.</source>
          <target state="translated">Used inside a &lt;code&gt;&amp;lt;dav:propstat&amp;gt;&lt;/code&gt; response element to avoid repeatedly enumerating the internal members of multiple bindings to the same collection.</target>
        </trans-unit>
        <trans-unit id="3851eaed9a9d01e9b233c8f2d77fe0a55f087096" translate="yes" xml:space="preserve">
          <source>Used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly.</source>
          <target state="translated">DAV : propstat 응답 요소 내부에서 사용되어 여러 바인딩의 내부 멤버를 동일한 컬렉션에 반복적으로 열거하지 않도록합니다.</target>
        </trans-unit>
        <trans-unit id="44451c54c4073c5b244dfc14ec1273b05fc53e0e" translate="yes" xml:space="preserve">
          <source>Used to contain an HTTP cookie, previously sent by the server with the &lt;a href=&quot;headers/set-cookie2&quot;&gt;&lt;code&gt;Set-Cookie2&lt;/code&gt;&lt;/a&gt; header, but has been obsoleted by the specification. Use &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">서버에서 이전에 &lt;a href=&quot;headers/set-cookie2&quot;&gt; &lt;code&gt;Set-Cookie2&lt;/code&gt; &lt;/a&gt; 헤더로 전송 한 HTTP 쿠키를 포함하는 데 사용 되었지만 사양에서 사용되지 않습니다. 대신 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; 를 사용하십시오 .</target>
        </trans-unit>
        <trans-unit id="b20d6e9692539ff76f2c433622b085813c4ed010" translate="yes" xml:space="preserve">
          <source>Used to indicate how a web page is to be indexed within public search engine results. The header is effectively equivalent to &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">공개 검색 엔진 결과 내에서 웹 페이지를 색인화하는 방법을 나타내는 데 사용됩니다. 헤더는 효과적으로 &lt;code&gt;&amp;lt;meta name=&quot;robots&quot; content=&quot;...&quot;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9405a74f4eda686904f91b373876d189023d5ec" translate="yes" xml:space="preserve">
          <source>Used to list alternate ways to reach this service.</source>
          <target state="translated">이 서비스에 도달하는 다른 방법을 나열하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="903aa38e08f404e0fe6134066bb4603722c02c8d" translate="yes" xml:space="preserve">
          <source>Used to redirect after a &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; to prevent a refresh of the page that would re-trigger the operation.</source>
          <target state="translated">작업을 다시 트리거하는 페이지를 새로 고치지 않도록 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 후에 리디렉션하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="02f36883721bfa91f003c55fe923c34d8b1123a0" translate="yes" xml:space="preserve">
          <source>Used to redirect after a &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; or a &lt;a href=&quot;methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt;, so that refreshing the result page doesn't re-trigger the operation.</source>
          <target state="translated">결과 페이지를 새로 고쳐도 작업이 다시 트리거되지 않도록 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 후에 리디렉션하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="f1d08aee2da19cf95ec2fb45d662ac243b00d47d" translate="yes" xml:space="preserve">
          <source>Used to remove the &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#path-restriction&quot;&gt;path restriction&lt;/a&gt; by including this header &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#service-worker-script-response&quot;&gt;in the response of the Service Worker script&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;https://w3c.github.io/ServiceWorker/#service-worker-script-response&quot;&gt;Service Worker 스크립트의 응답&lt;/a&gt; 에이 헤더 를 포함 하여 &lt;a href=&quot;https://w3c.github.io/ServiceWorker/#path-restriction&quot;&gt;경로 제한&lt;/a&gt; 을 제거하는 데 사용됩니다 .</target>
        </trans-unit>
        <trans-unit id="8fdc6d67d4d52e242748c4720010a7d9fc0ab0ad" translate="yes" xml:space="preserve">
          <source>Used to send cookies from the server to the user agent, but has been obsoleted by the specification. Use &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">서버에서 사용자 에이전트로 쿠키를 보내는 데 사용되지만 사양에서 더 이상 사용되지 않습니다. 대신 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 를 사용 하십시오 .</target>
        </trans-unit>
        <trans-unit id="b62be9bca2e56c611a10053517163712a9e03fe9" translate="yes" xml:space="preserve">
          <source>Used to specify a server endpoint for the browser to send warning and error reports to.</source>
          <target state="translated">브라우저가 경고 및 오류 보고서를 보낼 서버 엔드 포인트를 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="a0095a76b4707f02952bc67d941d3c22eb71071f" translate="yes" xml:space="preserve">
          <source>Used to specify an allow-list of &lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;Trusted Types&lt;/a&gt; policies. Trusted Types allows applications to lock down DOM XSS injection sinks to only accept non-spoofable, typed values in place of strings.</source>
          <target state="translated">&lt;a href=&quot;https://w3c.github.io/webappsec-trusted-types/dist/spec/&quot;&gt;신뢰할 수있는 유형&lt;/a&gt; 정책 의 허용 목록을 지정하는 데 사용됩니다 . 신뢰할 수있는 유형을 사용하면 애플리케이션이 DOM XSS 삽입 싱크를 잠 가서 문자열 대신 스푸핑이 불가능하고 유형이 지정된 값만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="fac194550e6aaaaf4fc9e84fd643b08330514f82" translate="yes" xml:space="preserve">
          <source>Used to specify information in the &lt;a href=&quot;referer&quot;&gt;Referer&lt;/a&gt; (sic) header for links away from a page. Use the &lt;a href=&quot;referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">페이지 외부 링크 에 대한 &lt;a href=&quot;referer&quot;&gt;Referer&lt;/a&gt; (sic) 헤더 의 정보를 지정하는 데 사용됩니다 . 사용 &lt;a href=&quot;referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt; 대신 헤더를.</target>
        </trans-unit>
        <trans-unit id="7f557f31b265b32e0da41b9f05f518d64277e5f0" translate="yes" xml:space="preserve">
          <source>Used to specify information in the referer (sic) header for links away from a page. Use the &lt;a href=&quot;referrer-policy&quot;&gt;&lt;code&gt;Referrer-Policy&lt;/code&gt;&lt;/a&gt; header instead.</source>
          <target state="translated">페이지에서 떨어진 링크에 대한 참조 자 (sic) 헤더에 정보를 지정하는 데 사용됩니다. 사용 &lt;a href=&quot;referrer-policy&quot;&gt; &lt;code&gt;Referrer-Policy&lt;/code&gt; &lt;/a&gt; 대신 헤더를.</target>
        </trans-unit>
        <trans-unit id="f531ff014faf3edcc5032454c287c495bd6b92dc" translate="yes" xml:space="preserve">
          <source>Used to specify the compression algorithm.</source>
          <target state="translated">압축 알고리즘을 지정하는 데 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="13fba396aeb16216bd521f7aa66eb44c4da1577d" translate="yes" xml:space="preserve">
          <source>Used when issuing a preflight request to let the server know which &lt;a href=&quot;methods&quot;&gt;HTTP method&lt;/a&gt; will be used when the actual request is made.</source>
          <target state="translated">프리 플라이트 요청을 발행 할 때 실제 요청이 이루어질 때 어떤 &lt;a href=&quot;methods&quot;&gt;HTTP 메소드&lt;/a&gt; 가 사용 될지 서버에 알리기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="2bd516d36772bd5ea2d67bbc4165b0dbce033d9a" translate="yes" xml:space="preserve">
          <source>Used when issuing a preflight request to let the server know which HTTP headers will be used when the actual request is made.</source>
          <target state="translated">프리 플라이트 요청을 발행 할 때 실제 요청이 이루어질 때 어떤 HTTP 헤더가 사용 될지 서버에 알리기 위해 사용됩니다.</target>
        </trans-unit>
        <trans-unit id="8f9f2317df27b96fec34402a882717f5741a2312" translate="yes" xml:space="preserve">
          <source>User Agent</source>
          <target state="translated">사용자 에이전트</target>
        </trans-unit>
        <trans-unit id="96196c87ac2ee878b4abd2f4685a989aa9780951" translate="yes" xml:space="preserve">
          <source>User Agent string</source>
          <target state="translated">사용자 에이전트 문자열</target>
        </trans-unit>
        <trans-unit id="f1851715072ef49470d2dfd3811ec1d1bac97021" translate="yes" xml:space="preserve">
          <source>User agents often have history mechanisms, such as &quot;Back&quot; buttons and
   history lists, that can be used to redisplay a representation
   retrieved earlier in a session.

   The freshness model (&lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;) does not necessarily apply to
   history mechanisms.  That is, a history mechanism can display a
   previous representation even if it has expired.

   This does not prohibit the history mechanism from telling the user
   that a view might be stale or from honoring cache directives (e.g.,
   Cache-Control: no-store).</source>
          <target state="translated">사용자 에이전트에는 종종 &quot;뒤로&quot;버튼 및 기록 목록과 같은 기록 메커니즘이있어 세션에서 이전에 검색된 표현을 다시 표시하는 데 사용할 수 있습니다. 신선도 모델 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt; )이 히스토리 메커니즘에 반드시 적용되는 것은 아닙니다. 즉, 히스토리 메커니즘은 만료 된 경우에도 이전 표시를 표시 할 수 있습니다. 이것은 히스토리 메커니즘이 사용자에게 뷰가 오래되었거나 캐시 지시문 (예 : Cache-Control : no-store)을 준수 할 수 있음을 알리는 것을 금지하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="d4415ef6828595c5d51a025c59cf8000e72dad23" translate="yes" xml:space="preserve">
          <source>User agents often have history mechanisms, such as &quot;Back&quot; buttons and
   history lists, which can be used to redisplay an entity retrieved
   earlier in a session.

   History mechanisms and caches are different. In particular history
   mechanisms SHOULD NOT try to show a semantically transparent view of
   the current state of a resource. Rather, a history mechanism is meant
   to show exactly what the user saw at the time when the resource was
   retrieved.

   By default, an expiration time does not apply to history mechanisms.
   If the entity is still in storage, a history mechanism SHOULD display
   it even if the entity has expired, unless the user has specifically
   configured the agent to refresh expired history documents.

   This is not to be construed to prohibit the history mechanism from
   telling the user that a view might be stale.

      Note: if history list mechanisms unnecessarily prevent users from
      viewing stale resources, this will tend to force service authors
      to avoid using HTTP expiration controls and cache controls when
      they would otherwise like to. Service authors may consider it
      important that users not be presented with error messages or
      warning messages when they use navigation controls (such as BACK)
      to view previously fetched resources. Even though sometimes such
      resources ought not to cached, or ought to expire quickly, user
      interface considerations may force service authors to resort to
      other means of preventing caching (e.g. &quot;once-only&quot; URLs) in order
      not to suffer the effects of improperly functioning history
      mechanisms.</source>
          <target state="translated">사용자 에이전트는 종종 &quot;뒤로&quot;버튼 및 기록 목록과 같은 기록 메커니즘을 가지고 있는데, 이는 세션에서 이전에 검색된 엔티티를 다시 표시하는 데 사용할 수 있습니다. 히스토리 메커니즘과 캐시는 다릅니다. 특히 히스토리 메커니즘은 리소스의 현재 상태를 의미 적으로 투명하게 보여서는 안됩니다. 오히려 히스토리 메커니즘은 자원을 검색 할 때 사용자가 본 것을 정확하게 표시하기위한 것입니다. 기본적으로 만료 시간은 기록 메커니즘에 적용되지 않습니다. 엔티티가 여전히 스토리지에있는 경우, 사용자가 만료 된 히스토리 문서를 새로 고치도록 에이전트를 구체적으로 구성하지 않은 경우, 엔티티가 만료 된 경우에도 히스토리 메커니즘이이를 표시해야합니다 (SHOULD).이것은 히스토리 메커니즘이 사용자에게 뷰가 오래되었다는 것을 알려주지 않도록 해석되어서는 안됩니다. 참고 : 히스토리 목록 메커니즘으로 인해 사용자가 부실 자원을 볼 수없는 경우 서비스 작성자가 HTTP 만기 제어 및 캐시 제어를 사용하지 않을 수 있습니다. 서비스 작성자는 탐색 컨트롤 (예 : BACK)을 사용하여 이전에 가져온 리소스를 볼 때 오류 메시지 나 경고 메시지가 표시되지 않는 것이 중요하다고 생각할 수 있습니다. 때때로 이러한 리소스는 캐시되지 않거나 빨리 만료되어야하지만 사용자 인터페이스 고려 사항으로 인해 서비스 작성자는 캐싱을 방지하는 다른 수단 (예 : &quot;한 번만&quot;)에 의지 할 수 있습니다.히스토리 메커니즘이 제대로 작동하지 않아서 영향을받지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ef8a5045e61510a061d2ed7f1794e270afbdc266" translate="yes" xml:space="preserve">
          <source>User preferences, themes, and other settings</source>
          <target state="translated">사용자 기본 설정, 테마 및 기타 설정</target>
        </trans-unit>
        <trans-unit id="170c6d2e56e8b4e9ec094b58afe212ec6e8296a6" translate="yes" xml:space="preserve">
          <source>User-Agent</source>
          <target state="translated">User-Agent</target>
        </trans-unit>
        <trans-unit id="1af81e21640faada944a6a51c7427107b23862dd" translate="yes" xml:space="preserve">
          <source>User-Agent (RFC 2616)</source>
          <target state="translated">사용자 에이전트 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="9e418a2de2016f5489f400bdd59f7d98983152ae" translate="yes" xml:space="preserve">
          <source>User-Agent (RFC 7231)</source>
          <target state="translated">사용자 에이전트 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="e9f2acd9319796127c26633394cadcb61c4e6cb6" translate="yes" xml:space="preserve">
          <source>User-Agent detection, history and checklist</source>
          <target state="translated">사용자 에이전트 감지, 히스토리 및 점검 목록</target>
        </trans-unit>
        <trans-unit id="25fb3b0fb82d92b257f4abf9c12069ad6ce3a8ba" translate="yes" xml:space="preserve">
          <source>User-Agent: Firefox</source>
          <target state="translated">사용자 에이전트 : Firefox</target>
        </trans-unit>
        <trans-unit id="461246704acac5c978b021dbe1bb6946d4fb06af" translate="yes" xml:space="preserve">
          <source>Uses the non-standard name: &lt;code&gt;X-Content-Security-Policy&lt;/code&gt;</source>
          <target state="translated">비표준 이름 사용 : &lt;code&gt;X-Content-Security-Policy&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b767622d82ebb5ed86e7d98876ac2c600c5e6b41" translate="yes" xml:space="preserve">
          <source>Uses the non-standard name: &lt;code&gt;X-Webkit-CSP&lt;/code&gt;</source>
          <target state="translated">비표준 이름 사용 : &lt;code&gt;X-Webkit-CSP&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bc53525239d5487c05ac1087f6ca7d5f2f779901" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; with credentials:</source>
          <target state="translated">신임 정보와 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="775b0a348ff6d7feb24560ac7ae004af821cabfb" translate="yes" xml:space="preserve">
          <source>Using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt; with credentials:</source>
          <target state="translated">신임 정보와 함께 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;XHR&lt;/a&gt; 사용 :</target>
        </trans-unit>
        <trans-unit id="50b3d158a5243f6906bff7679a67e75c48e89bc6" translate="yes" xml:space="preserve">
          <source>Using &lt;em&gt;&lt;code&gt;&amp;lt;link rel=&quot;canonical&quot;&amp;gt;&lt;/code&gt;&lt;/em&gt;</source>
          <target state="translated">사용 &lt;em&gt; &lt;code&gt;&amp;lt;link rel=&quot;canonical&quot;&amp;gt;&lt;/code&gt; &lt;/em&gt;</target>
        </trans-unit>
        <trans-unit id="d058ec1d546ffd4724c08314ef307b7b9d7d0cf8" translate="yes" xml:space="preserve">
          <source>Using CORS - HTML5 Rocks</source>
          <target state="translated">CORS 사용-HTML5 락</target>
        </trans-unit>
        <trans-unit id="d5b6aeeea8a183eae1980c322cfe2088cc4d812f" translate="yes" xml:space="preserve">
          <source>Using CORS with All (Modern) Browsers</source>
          <target state="translated">모든 (현대) 브라우저에서 CORS 사용</target>
        </trans-unit>
        <trans-unit id="2b0657cfc18741e8d87d0fb3eecf2f7e48f046bf" translate="yes" xml:space="preserve">
          <source>Using CSP</source>
          <target state="translated">CSP 사용</target>
        </trans-unit>
        <trans-unit id="2a075c7f234b30ed09767571bf0ceed43702253f" translate="yes" xml:space="preserve">
          <source>Using Early Data in HTTP</source>
          <target state="translated">HTTP에서 초기 데이터 사용</target>
        </trans-unit>
        <trans-unit id="95cb8ad5ba97958bfc77f7e47510a519e5b56075" translate="yes" xml:space="preserve">
          <source>Using Feature Policy</source>
          <target state="translated">기능 정책 사용</target>
        </trans-unit>
        <trans-unit id="faf834f6793fc3f5f4b06268382d98fe70168835" translate="yes" xml:space="preserve">
          <source>Using HTTP 301 redirects</source>
          <target state="translated">HTTP 301 리디렉션 사용</target>
        </trans-unit>
        <trans-unit id="d727a2f1b0f1ead6a5afe7b4b3b79b5d88a9496a" translate="yes" xml:space="preserve">
          <source>Using HTTP cookies allows you to link requests with the state of the server. This creates sessions, despite basic HTTP being a state-less protocol. This is useful not only for e-commerce shopping baskets, but also for any site allowing user configuration of the output.</source>
          <target state="translated">HTTP 쿠키를 사용하면 요청을 서버 상태와 연결할 수 있습니다. 기본 HTTP가 상태 비 저장 프로토콜 인 경우에도 세션이 생성됩니다. 이는 전자 상거래 쇼핑 바구니뿐만 아니라 사용자가 출력을 구성 할 수있는 모든 사이트에도 유용합니다.</target>
        </trans-unit>
        <trans-unit id="65356d107d722c421bdf9afae2752bb3644268e5" translate="yes" xml:space="preserve">
          <source>Using HTTP for complex applications</source>
          <target state="translated">복잡한 애플리케이션에 HTTP 사용</target>
        </trans-unit>
        <trans-unit id="bdebe583c1966f4eb802f9db212ff788822f1b79" translate="yes" xml:space="preserve">
          <source>Using HTTP for secure transmissions</source>
          <target state="translated">안전한 전송을 위해 HTTP 사용</target>
        </trans-unit>
        <trans-unit id="d91da6c75dbce03772ce3e47bbb5354fb14b4b03" translate="yes" xml:space="preserve">
          <source>Using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt;&lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt;&lt;/a&gt; element with an action set to inline JavaScript will result in a CSP violation.</source>
          <target state="translated">사용하여 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form&quot;&gt; &lt;code&gt;&amp;lt;form&amp;gt;&lt;/code&gt; &lt;/a&gt; 액션 세트 요소 것은 자바 스크립트가 CSP 위반이 발생합니다 인라인합니다.</target>
        </trans-unit>
        <trans-unit id="b221a3845399cc63a312a118304dd64208db9bae" translate="yes" xml:space="preserve">
          <source>Using streams for multiplexing introduces contention over use of the
   TCP connection, resulting in blocked streams.  A flow-control scheme
   ensures that streams on the same connection do not destructively
   interfere with each other.  Flow control is used for both individual
   streams and for the connection as a whole.

   HTTP/2 provides for flow control through use of the WINDOW_UPDATE
   frame (&lt;a href=&quot;#section-6.9&quot;&gt;Section 6.9&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4922a67e365ea567205aca17260f78c85648a98b" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;) with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">은 Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;ZLIB의&lt;/a&gt; (정의 구조 &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;1,950 RFC&lt;/a&gt; )와 &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;DEFLATE&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 (정의 &lt;a href=&quot;http://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="5f135cd288cff1c792d31f6c40167df8a81653f9" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;) with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">은 Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;ZLIB의&lt;/a&gt; (정의 구조 &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;1,950 RFC&lt;/a&gt; )와 &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;DEFLATE&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 (정의 &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f6d2f72f11bac70f52a4d8c1aa837dc886d98d35" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;), with the &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;deflate&lt;/em&gt;&lt;/a&gt; compression algorithm (defined in &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt;).</source>
          <target state="translated">은 Using &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;ZLIB의&lt;/a&gt; (정의 구조 &lt;a href=&quot;http://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; )와, &lt;a href=&quot;http://en.wikipedia.org/wiki/DEFLATE&quot;&gt;&lt;em&gt;DEFLATE&lt;/em&gt;&lt;/a&gt; 압축 알고리즘 (정의 &lt;a href=&quot;http://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1951&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="381f4958cb832cb4d7530e7e9118ab47b34808f2" translate="yes" xml:space="preserve">
          <source>Using the &lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; structure is accepted as a transfer coding name.</source>
          <target state="translated">&lt;a href=&quot;http://en.wikipedia.org/wiki/Zlib&quot;&gt;zlib&lt;/a&gt; 구조 사용은 전송 코딩 이름으로 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="c06631425c8e2a5c38beb712ece2894d30377b7f" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt;&lt;code&gt;allow&lt;/code&gt; attribute:</source>
          <target state="translated">은 Using &lt;code&gt;&amp;lt;iframe&amp;gt;&lt;/code&gt; &lt;code&gt;allow&lt;/code&gt; 속성 :</target>
        </trans-unit>
        <trans-unit id="331593d404c541921d5682ea4724593568cd2784" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;Forwarded&lt;/code&gt; header</source>
          <target state="translated">은 Using &lt;code&gt;Forwarded&lt;/code&gt; 헤더를</target>
        </trans-unit>
        <trans-unit id="9c88668cce11f173b8e79266db94e16cf90dd514" translate="yes" xml:space="preserve">
          <source>Using the Resource Timing API</source>
          <target state="translated">자원 타이밍 API 사용</target>
        </trans-unit>
        <trans-unit id="03565d9e3f7ee0b0d4bfe093013c13c3b40b1309" translate="yes" xml:space="preserve">
          <source>Using the Screen Capture API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1f968e579f2259eb8e8e4a023219aab908c00a" translate="yes" xml:space="preserve">
          <source>Usually a client will present a password prompt to the user and will then issue the request including the correct &lt;code&gt;Authorization&lt;/code&gt; header.</source>
          <target state="translated">일반적으로 클라이언트는 사용자에게 암호 프롬프트를 표시 한 다음 올바른 &lt;code&gt;Authorization&lt;/code&gt; 헤더를 포함하는 요청을 발행합니다 .</target>
        </trans-unit>
        <trans-unit id="f1d9d10dc421dffc12418b1ffd0ee9ed4d6c1255" translate="yes" xml:space="preserve">
          <source>Usually cached alternative service entries are cleared on network configuration changes. Use of the persist=1 parameter ensures that the entry is not deleted through such changes.</source>
          <target state="translated">일반적으로 캐시 된 대체 서비스 항목은 네트워크 구성 변경시 지워집니다. persist = 1 매개 변수를 사용하면 이러한 변경으로 인해 항목이 삭제되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="c5d9a9c22782754834063c5c87e532b570115167" translate="yes" xml:space="preserve">
          <source>VR / XR</source>
          <target state="translated">VR / XR</target>
        </trans-unit>
        <trans-unit id="dd74d182c641e4c78502d863b44d0aeff1575e54" translate="yes" xml:space="preserve">
          <source>Validation</source>
          <target state="translated">Validation</target>
        </trans-unit>
        <trans-unit id="6ed0f1de5e048f3ac28333d0cfff3151dbc16735" translate="yes" xml:space="preserve">
          <source>Validation (RFC 7234)</source>
          <target state="translated">검증 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="712c6ea96c055017cf46eeff45a8bf53cd962f56" translate="yes" xml:space="preserve">
          <source>Validator header fields convey metadata about the selected
   representation (&lt;a href=&quot;#section-3&quot;&gt;Section 3&lt;/a&gt;).  In responses to safe requests, validator
   fields describe the selected representation chosen by the origin
   server while handling the response.  Note that, depending on the
   status code semantics, the selected representation for a given
   response is not necessarily the same as the representation enclosed
   as response payload.

   In a successful response to a state-changing request, validator
   fields describe the new representation that has replaced the prior
   selected representation as a result of processing the request.

   For example, an ETag header field in a 201 (Created) response
   communicates the entity-tag of the newly created resource's
   representation, so that it can be used in later conditional requests
   to prevent the &quot;lost update&quot; problem [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;].

   +-------------------+--------------------------+
   | Header Field Name | Defined in...            |
   +-------------------+--------------------------+
   | ETag              | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7232]&lt;/a&gt; |
   | Last-Modified     | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC7232]&lt;/a&gt; |
   +-------------------+--------------------------+</source>
          <target state="translated">유효성 검사기 헤더 필드는 선택한 표현에 대한 메타 데이터를 전달합니다 ( &lt;a href=&quot;#section-3&quot;&gt;섹션 3&lt;/a&gt;). 안전한 요청에 대한 응답에서 유효성 검사기 필드는 응답을 처리하는 동안 원본 서버에서 선택한 선택된 표현을 설명합니다. 상태 코드 의미에 따라 주어진 응답에 대해 선택된 표현이 응답 페이로드로 묶인 표현과 반드시 ​​동일하지는 않습니다. 상태 변경 요청에 대한 성공적인 응답에서 유효성 검사기 필드는 요청 처리 결과 이전에 선택한 표현을 대체 한 새로운 표현을 설명합니다. 예를 들어, 201 (작성 됨) 응답의 ETag 헤더 필드는 새로 작성된 자원 표시의 엔티티 태그를 통신하므로 나중에 갱신되지 않는 문제점을 방지하기 위해 조건부 요청에서 사용할 수 있습니다. [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;]. + ------------------- + -------------------------- + | 헤더 필드 이름 | 정의 ... | + ------------------- + -------------------------- + | ETag | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;[RFC7232] 섹션 2.3&lt;/a&gt; | | 마지막 수정 | &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232] 섹션 2.2&lt;/a&gt; | + ------------------- + -------------------------- +</target>
        </trans-unit>
        <trans-unit id="762f13c2259b5fbab6d8f1bdbab081fc48bc558f" translate="yes" xml:space="preserve">
          <source>Validators</source>
          <target state="translated">Validators</target>
        </trans-unit>
        <trans-unit id="dccad7c8797a5d7efc3bc914b1c32ba185470954" translate="yes" xml:space="preserve">
          <source>Validators come in two flavors: strong or weak.  Weak validators are
   easy to generate but are far less useful for comparisons.  Strong
   validators are ideal for comparisons but can be very difficult (and
   occasionally impossible) to generate efficiently.  Rather than impose
   that all forms of resource adhere to the same strength of validator,
   HTTP exposes the type of validator in use and imposes restrictions on
   when weak validators can be used as preconditions.

   A &quot;strong validator&quot; is representation metadata that changes value
   whenever a change occurs to the representation data that would be
   observable in the payload body of a 200 (OK) response to GET.

   A strong validator might change for reasons other than a change to
   the representation data, such as when a semantically significant part
   of the representation metadata is changed (e.g., Content-Type), but
   it is in the best interests of the origin server to only change the
   value when it is necessary to invalidate the stored responses held by
   remote caches and authoring tools.

   Cache entries might persist for arbitrarily long periods, regardless
   of expiration times.  Thus, a cache might attempt to validate an
   entry using a validator that it obtained in the distant past.  A
   strong validator is unique across all versions of all representations
   associated with a particular resource over time.  However, there is
   no implication of uniqueness across representations of different
   resources (i.e., the same strong validator might be in use for
   representations of multiple resources at the same time and does not
   imply that those representations are equivalent). 

   There are a variety of strong validators used in practice.  The best
   are based on strict revision control, wherein each change to a
   representation always results in a unique node name and revision
   identifier being assigned before the representation is made
   accessible to GET.  A collision-resistant hash function applied to
   the representation data is also sufficient if the data is available
   prior to the response header fields being sent and the digest does
   not need to be recalculated every time a validation request is
   received.  However, if a resource has distinct representations that
   differ only in their metadata, such as might occur with content
   negotiation over media types that happen to share the same data
   format, then the origin server needs to incorporate additional
   information in the validator to distinguish those representations.

   In contrast, a &quot;weak validator&quot; is representation metadata that might
   not change for every change to the representation data.  This
   weakness might be due to limitations in how the value is calculated,
   such as clock resolution, an inability to ensure uniqueness for all
   possible representations of the resource, or a desire of the resource
   owner to group representations by some self-determined set of
   equivalency rather than unique sequences of data.  An origin server
   SHOULD change a weak entity-tag whenever it considers prior
   representations to be unacceptable as a substitute for the current
   representation.  In other words, a weak entity-tag ought to change
   whenever the origin server wants caches to invalidate old responses.

   For example, the representation of a weather report that changes in
   content every second, based on dynamic measurements, might be grouped
   into sets of equivalent representations (from the origin server's
   perspective) with the same weak validator in order to allow cached
   representations to be valid for a reasonable period of time (perhaps
   adjusted dynamically based on server load or weather quality).
   Likewise, a representation's modification time, if defined with only
   one-second resolution, might be a weak validator if it is possible
   for the representation to be modified twice during a single second
   and retrieved between those modifications.

   Likewise, a validator is weak if it is shared by two or more
   representations of a given resource at the same time, unless those
   representations have identical representation data.  For example, if
   the origin server sends the same validator for a representation with
   a gzip content coding applied as it does for a representation with no
   content coding, then that validator is weak.  However, two
   simultaneous representations might share the same strong validator if
   they differ only in the representation metadata, such as when two
   different media types are available for the same representation data. 

   Strong validators are usable for all conditional requests, including
   cache validation, partial content ranges, and &quot;lost update&quot;
   avoidance.  Weak validators are only usable when the client does not
   require exact equality with previously obtained representation data,
   such as when validating a cache entry or limiting a web traversal to
   recent changes.</source>
          <target state="translated">유효성 검사기는 강하거나 약한 두 가지 맛이 있습니다. 약한 유효성 검사기는 생성하기 쉽지만 비교에는 훨씬 유용하지 않습니다. 강력한 유효성 검사기는 비교에 이상적이지만 효율적으로 생성하기가 매우 어려울 수 있으며 때로는 불가능할 수도 있습니다. 모든 유형의 자원이 동일한 강도의 유효성 검증기를 준수하도록 강요하는 대신 HTTP는 사용중인 유효성 검증기 유형을 노출하고 취약한 유효성 검증 기가 전제 조건으로 사용될 수있는 경우에 대한 제한을 부과합니다. &quot;강한 유효성 검사기&quot;는 GET에 대한 200 (OK) 응답의 페이로드 본문에서 관찰 할 수있는 표현 데이터가 변경 될 때마다 값을 변경하는 표현 메타 데이터입니다. 강력한 유효성 검사기는 표현 데이터 변경 이외의 이유로 변경 될 수 있습니다.예를 들어 표현 메타 데이터의 의미 상 중요한 부분이 변경되는 경우 (예 : Content-Type) 원격 캐시에 의해 저장된 저장된 응답을 무효화해야 할 때만 값을 변경하는 것이 원 서버의 최선의 이익입니다. 저작 도구. 캐시 항목은 만료 시간에 관계없이 임의로 장기간 지속될 수 있습니다. 따라서 캐시는 먼 과거에 얻은 유효성 검사기를 사용하여 항목의 유효성을 검사하려고 시도 할 수 있습니다. 강력한 유효성 검사기는 시간이 지남에 따라 특정 리소스와 관련된 모든 표현의 모든 버전에서 고유합니다. 그러나 서로 다른 자원의 표현에서 고유성이 함축되지는 않습니다 (예 :동일한 강력한 유효성 검증 기가 동시에 여러 자원을 표시하는 데 사용 중일 수 있으며 해당 표시가 동등한 것을 의미하지는 않습니다. 실제로 사용되는 다양한 강력한 유효성 검사기가 있습니다. 최선의 방법은 엄격한 개정 관리를 기반으로하며, 표현을 변경할 때마다 항상 고유 한 노드 이름과 개정 식별자가 지정되어 GET에 표시 할 수 있습니다. 응답 헤더 필드를 보내기 전에 데이터를 사용할 수 있고 유효성 검사 요청을받을 때마다 다이제스트를 다시 계산할 필요가없는 경우 표현 데이터에 적용된 충돌 방지 해시 함수도 충분합니다. 그러나 리소스에 메타 데이터 만 다른 고유 한 표현이있는 경우,동일한 데이터 형식을 공유하는 매체 유형에 대한 컨텐츠 협상에서 발생할 수있는 것과 같이 오리진 서버는 해당 표시를 구별하기 위해 유효성 검증기에 추가 정보를 통합해야합니다. 반대로 &quot;약한 유효성 검사기&quot;는 표현 데이터를 변경할 때마다 변경되지 않는 표현 메타 데이터입니다. 이 약점은 클럭 해상도, 가능한 모든 자원 표현에 고유성을 보장 할 수 없거나 자원 소유자가 자체 결정된 동등성 세트로 표현을 그룹화하려는 욕구와 같은 값 계산 방법의 한계로 인한 것일 수 있습니다. 고유 한 데이터 시퀀스가 ​​아니라오리진 서버는 이전 표현이 현재 표현을 대신 할 수없는 것으로 간주 될 때마다 약한 엔티티 태그를 변경해야합니다. 즉, 약한 엔티티 태그는 원래 서버가 캐시가 이전 응답을 무효화하기를 원할 때마다 변경되어야합니다. 예를 들어, 동적 측정을 기반으로 1 초마다 컨텐츠가 변경되는 날씨 보고서의 표현은 캐시 된 표현이 유효하도록 동일한 약한 유효성 검증기를 사용하여 (원본 서버의 관점에서) 동등한 표현 세트로 그룹화 될 수 있습니다. 적절한 시간 동안 (아마 서버로드 또는 날씨 품질에 따라 동적으로 조정될 수 있음) 마찬가지로 표현의 수정 시간 (1 초 해상도로만 정의 된 경우)표현이 1 초 동안 두 번 수정되고 해당 수정 사이에서 검색 될 수있는 경우 약한 유효성 검사기 일 수 있습니다. 마찬가지로, 해당 표현이 동일한 표현 데이터를 가지지 않는 한 주어진 자원의 둘 이상의 표현이 동시에 공유되면 유효성 검사기는 약합니다. 예를 들어, 오리진 서버가 컨텐츠 코딩이없는 표현에 대해 적용되는 gzip 컨텐츠 코딩이있는 표현에 대해 동일한 유효성 검증기를 보내면 해당 유효성 검증 기가 약합니다. 그러나 두 개의 동시 표현은 동일한 표현 데이터에 대해 두 개의 다른 매체 유형을 사용할 수있는 경우와 같이 표현 메타 데이터에서만 다른 경우 동일한 강력한 유효성 검증기를 공유 할 수 있습니다. 모든 조건부 요청에 강력한 유효성 검사기를 사용할 수 있습니다.캐시 유효성 검사, 부분 컨텐츠 범위 및 &quot;손실 된 업데이트&quot;방지를 포함합니다. 약한 유효성 검사기는 클라이언트가 캐시 항목의 유효성을 검사하거나 웹 탐색을 최근 변경 사항으로 제한하는 경우와 같이 이전에 얻은 표현 데이터와 정확히 동일한 것이 필요하지 않은 경우에만 사용할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="b1564f6b1512cbfa3cfcebc9a5badb6b239954f1" translate="yes" xml:space="preserve">
          <source>Values</source>
          <target state="translated">Values</target>
        </trans-unit>
        <trans-unit id="95995420eab6703ad8a4f2ba7da6319b9b43e40d" translate="yes" xml:space="preserve">
          <source>Values for a CSS stylesheet</source>
          <target state="translated">CSS 스타일 시트의 값</target>
        </trans-unit>
        <trans-unit id="a5ef8687b052a94f11db08f4f679818138d67288" translate="yes" xml:space="preserve">
          <source>Values for a video</source>
          <target state="translated">비디오의 가치</target>
        </trans-unit>
        <trans-unit id="4d9dcfc6daf7e146bae84e76afccb728e632f028" translate="yes" xml:space="preserve">
          <source>Values for an image</source>
          <target state="translated">이미지 값</target>
        </trans-unit>
        <trans-unit id="0022bf43f5fac9f98b34676d218d78927c174e9e" translate="yes" xml:space="preserve">
          <source>Values for audio resources</source>
          <target state="translated">오디오 리소스의 가치</target>
        </trans-unit>
        <trans-unit id="d5707d69daa9b8c62fb80486ceff04ff21fd84f0" translate="yes" xml:space="preserve">
          <source>Values for scripts</source>
          <target state="translated">스크립트 값</target>
        </trans-unit>
        <trans-unit id="2b24d45fc35a156981b37ec34e29d99633f90ceb" translate="yes" xml:space="preserve">
          <source>Vary</source>
          <target state="translated">Vary</target>
        </trans-unit>
        <trans-unit id="9b2e108b3f882316723628f809864b1feb7974b4" translate="yes" xml:space="preserve">
          <source>Vary (RFC 2616)</source>
          <target state="translated">다양 함 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="e40dcd8515c2cf843fee10b24ff8980777ae7ffa" translate="yes" xml:space="preserve">
          <source>Vary (RFC 7231)</source>
          <target state="translated">다양 함 (RFC 7231)</target>
        </trans-unit>
        <trans-unit id="7b2b0d3e57119ab5faa1b67d5efd6c7de0e7f709" translate="yes" xml:space="preserve">
          <source>Vary with care &amp;ndash; Vary header problems in IE6-9</source>
          <target state="translated">주의 사항에 따라 다름 &amp;ndash; IE6-9의 다양한 문제</target>
        </trans-unit>
        <trans-unit id="19eb9e0947788d5d1d26e214c7f03629eeb827cb" translate="yes" xml:space="preserve">
          <source>Varying responses</source>
          <target state="translated">다양한 응답</target>
        </trans-unit>
        <trans-unit id="cd93e3881536fce26e72a7e663780b36bdbdb4a8" translate="yes" xml:space="preserve">
          <source>Version 3 (and probably earlier) of Firefox for Fire TV use a user agent string with the following format:</source>
          <target state="translated">Fire TV 용 Firefox 3 버전 (및 이전 버전)은 다음 형식의 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="a69e9865ae8f4c198fd5ee0e05c338894a1f0bbb" translate="yes" xml:space="preserve">
          <source>Version 7 of Focus for iOS uses a user agent string with the following format:</source>
          <target state="translated">Focus for iOS 버전 7은 다음 형식의 사용자 에이전트 문자열을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="38993cc538cc5926945d26ae695bf9289c5f5b16" translate="yes" xml:space="preserve">
          <source>Version number of the product.</source>
          <target state="translated">제품의 버전 번호입니다.</target>
        </trans-unit>
        <trans-unit id="297d1a34c5a91c3face08ee659f305e1a1a91054" translate="yes" xml:space="preserve">
          <source>Versioning information is now sent within each request (&lt;code&gt;HTTP/1.0&lt;/code&gt; is appended to the &lt;code&gt;GET&lt;/code&gt; line)</source>
          <target state="translated">버전 정보가 각 요청 내에서 전송됩니다 ( &lt;code&gt;HTTP/1.0&lt;/code&gt; 이 &lt;code&gt;GET&lt;/code&gt; 행 에 추가됨 )</target>
        </trans-unit>
        <trans-unit id="69a7be7d74e8b54ef69683eb73c3addbe24661a5" translate="yes" xml:space="preserve">
          <source>Via</source>
          <target state="translated">Via</target>
        </trans-unit>
        <trans-unit id="5efffb1f13385b4c17fcaf2a54ce6c61c3ffee1f" translate="yes" xml:space="preserve">
          <source>Via (RFC 2616)</source>
          <target state="translated">경유 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="4a262edfcca765aced41dbe8c82f8c49d87e0c49" translate="yes" xml:space="preserve">
          <source>Vibration API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600beac1ac4f104310961c0df27d3fda7e13e76a" translate="yes" xml:space="preserve">
          <source>Video data or files, such as MP4 movies (&lt;code&gt;video/mp4&lt;/code&gt;).</source>
          <target state="translated">MP4 영화 ( &lt;code&gt;video/mp4&lt;/code&gt; ) 와 같은 비디오 데이터 또는 파일 .</target>
        </trans-unit>
        <trans-unit id="876d409a2453771f3498295f0ec1ad8b311c1abe" translate="yes" xml:space="preserve">
          <source>Video formats on the Web are lossy and for images, &lt;code&gt;jpeg&lt;/code&gt; is.</source>
          <target state="translated">웹의 비디오 형식은 손실이 있으며 이미지의 경우 &lt;code&gt;jpeg&lt;/code&gt; 입니다.</target>
        </trans-unit>
        <trans-unit id="b8e388ceed1411c403014aaf99cf7852f8214b26" translate="yes" xml:space="preserve">
          <source>Video formats on the Web are lossy; the &lt;code&gt;jpeg&lt;/code&gt; image format is also lossy.</source>
          <target state="translated">웹상의 비디오 형식은 손실이 있습니다. &lt;code&gt;jpeg&lt;/code&gt; 이미지 포맷은 손실된다.</target>
        </trans-unit>
        <trans-unit id="4aa07f2310615edb1b8aea001b9424df7324bc70" translate="yes" xml:space="preserve">
          <source>Violation case</source>
          <target state="translated">위반 사례</target>
        </trans-unit>
        <trans-unit id="e27cced9fe19bc714fee1a81671a7f569628e245" translate="yes" xml:space="preserve">
          <source>Violation cases</source>
          <target state="translated">위반 사례</target>
        </trans-unit>
        <trans-unit id="c496e3c34f0eba7e144fe804c7ad8671f57cafe2" translate="yes" xml:space="preserve">
          <source>Violation report syntax</source>
          <target state="translated">위반 보고서 구문</target>
        </trans-unit>
        <trans-unit id="d5008ff9b05d4e106caa52d46336fe823818f4b8" translate="yes" xml:space="preserve">
          <source>W3C Note: Editing the Web &amp;ndash; Detecting the Lost Update Problem Using Unreserved Checkout</source>
          <target state="translated">W3C 참고 : 웹 편집 &amp;ndash; 예약되지 않은 체크 아웃을 사용하여 손실 된 업데이트 문제 감지</target>
        </trans-unit>
        <trans-unit id="884f3317cb1124a8431120b58009200dca7a4d67" translate="yes" xml:space="preserve">
          <source>WEBM audio</source>
          <target state="translated">WEBM 오디오</target>
        </trans-unit>
        <trans-unit id="a9048e6f38bd6def914e8bc02c0c815e74aa6b31" translate="yes" xml:space="preserve">
          <source>WEBM video</source>
          <target state="translated">WEBM 비디오</target>
        </trans-unit>
        <trans-unit id="10d4da79ed320e304a4183b2724689aacff736ee" translate="yes" xml:space="preserve">
          <source>WEBP image</source>
          <target state="translated">WEBP 이미지</target>
        </trans-unit>
        <trans-unit id="de62a2e0ed96283dd1668cc9bff1767cdf422c85" translate="yes" xml:space="preserve">
          <source>WHATWG Spec</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91e15dfd33a8977326ec3048fffcf2851f9ab5d0" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate</source>
          <target state="translated">WWW-Authenticate</target>
        </trans-unit>
        <trans-unit id="66096447ca6339831faa35cab2472b54e0d02b68" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate (RFC 2616)</source>
          <target state="translated">WWW 인증 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="10ca8f25b6696fb63530265acb249b906a791bb0" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate (RFC 7235)</source>
          <target state="translated">WWW 인증 (RFC 7235)</target>
        </trans-unit>
        <trans-unit id="f6d051699bd0f43788b5be58a23eb21f84335023" translate="yes" xml:space="preserve">
          <source>WWW-Authenticate and Proxy-Authenticate headers</source>
          <target state="translated">WWW-Authenticate 및 Proxy-Authenticate 헤더</target>
        </trans-unit>
        <trans-unit id="e81e9a0e41b1530a0847ac5a1f8115715b1c9fca" translate="yes" xml:space="preserve">
          <source>Wake Lock API 1</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5ba7152bfe4d268daeeb4921b7ae4099f362de" translate="yes" xml:space="preserve">
          <source>Want-Digest</source>
          <target state="translated">Want-Digest</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="be4d2f140ad1f885bd4fd65204345d7cda73e466" translate="yes" xml:space="preserve">
          <source>Warning (RFC 2616)</source>
          <target state="translated">경고 (RFC 2616)</target>
        </trans-unit>
        <trans-unit id="84bedb41c866653578afdf5c8ba922625099fff2" translate="yes" xml:space="preserve">
          <source>Warning (RFC 7234)</source>
          <target state="translated">경고 (RFC 7234)</target>
        </trans-unit>
        <trans-unit id="a947928bc7f59190ce4b3eb8f6b60da4b597dfb2" translate="yes" xml:space="preserve">
          <source>Warning codes</source>
          <target state="translated">경고 코드</target>
        </trans-unit>
        <trans-unit id="98d22e2da9720c80cb3f1a3c48430a5ba47ef6df" translate="yes" xml:space="preserve">
          <source>Was defined in a previous version of the HTTP specification to indicate that a requested response must be accessed by a proxy. It has been deprecated due to security concerns regarding in-band configuration of a proxy.</source>
          <target state="translated">프록시가 요청 된 응답에 액세스해야 함을 나타 내기 위해 이전 버전의 HTTP 사양에서 정의되었습니다. 프록시의 대역 내 구성과 관련된 보안 문제로 인해 더 이상 사용되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="b65b1ec95e015e3a3a9a72a92184b75a39063c7e" translate="yes" xml:space="preserve">
          <source>Waveform Audio Format</source>
          <target state="translated">파형 오디오 형식</target>
        </trans-unit>
        <trans-unit id="3614aa76f325a8581f86ebecc652236220abab3a" translate="yes" xml:space="preserve">
          <source>Ways to mitigate attacks involving cookies:</source>
          <target state="translated">쿠키와 관련된 공격을 완화하는 방법 :</target>
        </trans-unit>
        <trans-unit id="c1ed8d07477aa173249b6733f07e79520338b110" translate="yes" xml:space="preserve">
          <source>We adopt a set of rules and recommendations for origin servers,
   clients, and caches regarding when various validator types ought to
   be used, and for what purposes.

   HTTP/1.1 origin servers:

      - SHOULD send an entity tag validator unless it is not feasible to
        generate one.

      - MAY send a weak entity tag instead of a strong entity tag, if
        performance considerations support the use of weak entity tags,
        or if it is unfeasible to send a strong entity tag.

      - SHOULD send a Last-Modified value if it is feasible to send one,
        unless the risk of a breakdown in semantic transparency that
        could result from using this date in an If-Modified-Since header
        would lead to serious problems.

   In other words, the preferred behavior for an HTTP/1.1 origin server
   is to send both a strong entity tag and a Last-Modified value.

   In order to be legal, a strong entity tag MUST change whenever the
   associated entity value changes in any way. A weak entity tag SHOULD
   change whenever the associated entity changes in a semantically
   significant way.

      Note: in order to provide semantically transparent caching, an
      origin server must avoid reusing a specific strong entity tag
      value for two different entities, or reusing a specific weak
      entity tag value for two semantically different entities. Cache
      entries might persist for arbitrarily long periods, regardless of
      expiration times, so it might be inappropriate to expect that a
      cache will never again attempt to validate an entry using a
      validator that it obtained at some point in the past.

   HTTP/1.1 clients:

      - If an entity tag has been provided by the origin server, MUST
        use that entity tag in any cache-conditional request (using If-
        Match or If-None-Match).

      - If only a Last-Modified value has been provided by the origin
        server, SHOULD use that value in non-subrange cache-conditional
        requests (using If-Modified-Since). 

      - If only a Last-Modified value has been provided by an HTTP/1.0
        origin server, MAY use that value in subrange cache-conditional
        requests (using If-Unmodified-Since:). The user agent SHOULD
        provide a way to disable this, in case of difficulty.

      - If both an entity tag and a Last-Modified value have been
        provided by the origin server, SHOULD use both validators in
        cache-conditional requests. This allows both HTTP/1.0 and
        HTTP/1.1 caches to respond appropriately.

   An HTTP/1.1 origin server, upon receiving a conditional request that
   includes both a Last-Modified date (e.g., in an If-Modified-Since or
   If-Unmodified-Since header field) and one or more entity tags (e.g.,
   in an If-Match, If-None-Match, or If-Range header field) as cache
   validators, MUST NOT return a response status of 304 (Not Modified)
   unless doing so is consistent with all of the conditional header
   fields in the request.

   An HTTP/1.1 caching proxy, upon receiving a conditional request that
   includes both a Last-Modified date and one or more entity tags as
   cache validators, MUST NOT return a locally cached response to the
   client unless that cached response is consistent with all of the
   conditional header fields in the request.

      Note: The general principle behind these rules is that HTTP/1.1
      servers and clients should transmit as much non-redundant
      information as is available in their responses and requests.
      HTTP/1.1 systems receiving this information will make the most
      conservative assumptions about the validators they receive.

      HTTP/1.0 clients and caches will ignore entity tags. Generally,
      last-modified values received or used by these systems will
      support transparent and efficient caching, and so HTTP/1.1 origin
      servers should provide Last-Modified values. In those rare cases
      where the use of a Last-Modified value as a validator by an
      HTTP/1.0 system could result in a serious problem, then HTTP/1.1
      origin servers should not provide one.</source>
          <target state="translated">다양한 유효성 검사기 유형을 사용해야 할시기와 목적에 대해 오리진 서버, 클라이언트 및 캐시에 대한 일련의 규칙과 권장 사항을 채택합니다. HTTP / 1.1 오리진 서버 :-엔티티 태그 검사기를 생성 할 수 없다면 엔티티 태그 검사기를 보내야한다. -성능 고려 사항이 취약한 엔티티 태그 사용을 지원하거나 강력한 엔티티 태그를 전송할 수없는 경우 강력한 엔티티 태그 대신 취약한 엔티티 태그를 전송할 수 있습니다. -If-Modified-Since 헤더에서이 날짜를 사용하여 발생할 수있는 의미 투명성의 고장 위험이 심각한 문제를 야기하지 않는 한, 전송 가능한 경우 Last-Modified 값을 보내야합니다. 다시 말해, HTTP / 1에 대해 선호되는 동작입니다.1 원 서버는 강력한 엔터티 태그와 Last-Modified 값을 모두 전송합니다. 합법적으로되기 위해서는 강력한 엔터티 태그가 관련 엔터티 값이 어떤 식 으로든 변경 될 때마다 변경되어야합니다. 약한 엔터티 태그는 관련 엔터티가 의미 적으로 중요한 방식으로 변경 될 때마다 변경되어야합니다. 참고 : 의미 적으로 투명한 캐싱을 제공하기 위해 오리진 서버는 서로 다른 두 엔티티에 대해 특정 강력한 엔티티 태그 값을 재사용하거나 의미 적으로 다른 두 엔티티에 대해 특정 취약한 엔티티 태그 값을 재사용하지 않아야합니다. 캐시 항목은 만료 시간에 관계없이 임의로 장기간 지속될 수 있으므로 캐시가 과거 어느 시점에서 얻은 유효성 검사기를 사용하여 항목의 유효성을 다시 검사하지 않을 것으로 예상 할 수 없습니다.HTTP / 1.1 클라이언트 :-오리진 서버가 엔티티 태그를 제공 한 경우 캐시 조건부 요청 (If- Match 또는 If-None-Match 사용)에서 해당 엔티티 태그를 사용해야합니다. -오리진 서버가 Last-Modified 값만 제공 한 경우, 하위 값이 아닌 캐시 조건부 요청에서 If-Modified-Since를 사용하여 해당 값을 사용해야합니다. -HTTP / 1.0 오리진 서버에서 Last-Modified 값만 제공 한 경우 하위 범위 캐시 조건부 요청에서 해당 값을 사용할 수 있습니다 (If-Unmodified-Since : 사용). 사용자 에이전트는 어려움이있을 경우이를 비활성화하는 방법을 제공해야합니다 (SHOULD). -오리진 서버가 엔티티 태그와 Last-Modified 값을 모두 제공 한 경우 캐시 조건부 요청에서 두 검증기를 모두 사용해야합니다. 이것은 HTTP / 1을 모두 허용합니다.적절하게 응답하기위한 0 및 HTTP / 1.1 캐시. 최종 수정 날짜 (예 : If-Modified-Since 또는 If-Unmodified-Since 헤더 필드)와 하나 이상의 엔티티 태그 (예 : 캐시 유효성 검사기 인 If-Match, If-None-Match 또는 If-Range 헤더 필드)는 요청의 모든 조건부 헤더 필드와 일치하지 않는 한 응답 상태 304 (수정되지 않음)를 반환해서는 안됩니다. 캐시 수정 자로 Last-Modified 날짜와 하나 이상의 엔티티 태그를 모두 포함하는 조건부 요청을 수신 한 HTTP / 1.1 캐싱 프록시는 캐시 된 응답이 모든 캐시와 일치하지 않는 한 클라이언트에 로컬로 캐시 된 응답을 반환해서는 안됩니다 (MUST NOT). 요청의 조건부 헤더 필드 노트 :이러한 규칙의 기본 원리는 HTTP / 1.1 서버 및 클라이언트가 응답 및 요청에서 사용 가능한 한 많은 비 중복 정보를 전송해야한다는 것입니다. 이 정보를받는 HTTP / 1.1 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.1 서버와 클라이언트는 응답 및 요청에서 사용할 수있는만큼 비 중복 정보를 전송해야합니다. 이 정보를받는 HTTP / 1.1 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.1 서버와 클라이언트는 응답 및 요청에서 사용할 수있는만큼 비 중복 정보를 전송해야합니다. 이 정보를받는 HTTP / 1.1 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이 정보를받는 1 개의 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이 정보를받는 1 개의 시스템은 그들이받는 검증 자에 대해 가장 보수적 인 가정을 할 것입니다. HTTP / 1.0 클라이언트 및 캐시는 엔티티 태그를 무시합니다. 일반적으로 이러한 시스템에서 수신하거나 사용하는 마지막 수정 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.이러한 시스템에서 수신하거나 사용하는 마지막 수정 된 값은 투명하고 효율적인 캐싱을 지원하므로 HTTP / 1.1 오리진 서버는 Last-Modified 값을 제공해야합니다. HTTP / 1.0 시스템에서 Last-Modified 값을 유효성 검증기로 사용하면 심각한 문제점이 발생할 수있는 드문 경우에는 HTTP / 1.1 오리진 서버가이를 제공하지 않아야합니다.</target>
        </trans-unit>
        <trans-unit id="cbefa43c4244c9659990b7c712219c66a3ed30c8" translate="yes" xml:space="preserve">
          <source>We can request a single range from a resource. Again, we can test a request by using cURL. The &quot;&lt;code&gt;-H&lt;/code&gt;&quot; option will append a header line to the request, which in this case is the &lt;code&gt;Range&lt;/code&gt; header requesting the first 1024 bytes.</source>
          <target state="translated">리소스에서 단일 범위를 요청할 수 있습니다. 다시 cURL을 사용하여 요청을 테스트 할 수 있습니다. &quot; &lt;code&gt;-H&lt;/code&gt; &quot;옵션은 요청에 헤더 행을 추가하며,이 경우 첫 번째 1024 바이트를 요청하는 &lt;code&gt;Range&lt;/code&gt; 헤더입니다.</target>
        </trans-unit>
        <trans-unit id="b6a9bbf12e8ee0277600f2ecdeea60a7f6ed55e7" translate="yes" xml:space="preserve">
          <source>We present three scenarios that demonstrate how Cross-Origin Resource Sharing works. All these examples use &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;, which can make cross-site requests in any supporting browser.</source>
          <target state="translated">교차 출처 리소스 공유가 작동하는 방식을 보여주는 세 가지 시나리오를 제시합니다. 이 모든 예제는 지원되는 모든 브라우저에서 교차 사이트 요청을 할 수있는 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 를&lt;/a&gt; 사용 합니다.</target>
        </trans-unit>
        <trans-unit id="c36fd34ea11996b6fcd900ac461a83c9aca72d5f" translate="yes" xml:space="preserve">
          <source>Weak validation</source>
          <target state="translated">약한 검증</target>
        </trans-unit>
        <trans-unit id="1bbd54b41e2dcd60140061474c56461a3b1017b8" translate="yes" xml:space="preserve">
          <source>Weak validation differs from strong validation, as it considers two versions of the document as identical if the content is equivalent. For example, a page that would differ from another only by a different date in its footer, or different advertising, would be considered &lt;em&gt;identical&lt;/em&gt; to the other with weak validation. These same two versions are considered &lt;em&gt;different&lt;/em&gt; when using strong validation. Building a system of etags that creates weak validation may be complex, as it involves knowing the importance of the different elements of a page, but is very useful towards optimizing cache performance.</source>
          <target state="translated">약한 유효성 검사는 내용이 동일한 경우 두 버전의 문서가 동일하다고 간주되므로 강력한 유효성 검사와 다릅니다. 예를 들어 바닥 글에서 다른 날짜 또는 다른 광고로만 다른 페이지와 다른 페이지는 유효성이 약한 페이지와 &lt;em&gt;동일한&lt;/em&gt; 것으로 간주됩니다 . 이 두 버전은 &lt;em&gt;다른&lt;/em&gt; 것으로 간주됩니다&lt;em&gt;&lt;/em&gt;강력한 유효성 검사를 사용할 때 됩니다. 약한 유효성 검사를 생성하는 etag 시스템을 구축하는 것은 페이지의 여러 요소의 중요성을 알아야하기 때문에 복잡 할 수 있지만 캐시 성능을 최적화하는 데 매우 유용합니다.</target>
        </trans-unit>
        <trans-unit id="81b0091d349f7e8dabfa6f00aa81829d266ffe7f" translate="yes" xml:space="preserve">
          <source>Weak versus Strong (RFC 7232)</source>
          <target state="translated">약한 대 강한 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="88efb6a8a3d031542f167dd1421e65bc5ddae978" translate="yes" xml:space="preserve">
          <source>Web Authentication API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d606b3c33d327d059adae82ab686815d9a859a5" translate="yes" xml:space="preserve">
          <source>Web Authentication Level 2</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6d26db3eb03fbab22864aa29670e49ed16f531" translate="yes" xml:space="preserve">
          <source>Web Distributed Authoring and Versioning</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="846bec671d05b4a9c57d268a32b9ca23d81cc1ef" translate="yes" xml:space="preserve">
          <source>Web Fonts (for cross-domain font usage in &lt;code&gt;@font-face&lt;/code&gt; within CSS), &lt;a href=&quot;https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements&quot;&gt;so that servers can deploy TrueType fonts that can only be cross-site loaded and used by web sites that are permitted to do so.&lt;/a&gt;</source>
          <target state="translated">웹 글꼴 ( CSS 내의 &lt;code&gt;@font-face&lt;/code&gt; 에서 도메인 간 글꼴 사용 ) &lt;a href=&quot;https://www.w3.org/TR/css-fonts-3/#font-fetching-requirements&quot;&gt;을 통해 서버는 사이트 간로드 만 허용되고 웹 사이트에서 허용되는 트루 타입 글꼴을 배포 할 수 있습니다.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="176255fee5b73645d93cc65c9bf7cc53c9096411" translate="yes" xml:space="preserve">
          <source>Web Linking</source>
          <target state="translated">웹 링크</target>
        </trans-unit>
        <trans-unit id="7fde211ec2ffa63e011d15d658c6456ee3361232" translate="yes" xml:space="preserve">
          <source>Web Open Font Format (WOFF)</source>
          <target state="translated">웹 열기 글꼴 형식 (WOFF)</target>
        </trans-unit>
        <trans-unit id="5f3f450e346fdae22197c1f6b75eaf5e058000c1" translate="yes" xml:space="preserve">
          <source>Web Picture format</source>
          <target state="translated">웹 사진 형식</target>
        </trans-unit>
        <trans-unit id="91d14f7b44c057d129ff61e05ff9ce4d6f2fc29a" translate="yes" xml:space="preserve">
          <source>Web Share API</source>
          <target state="translated">웹 공유 API</target>
        </trans-unit>
        <trans-unit id="bd59440b016b6287e24e59a96a86e62ba9ba00ba" translate="yes" xml:space="preserve">
          <source>Web app manifest</source>
          <target state="translated">웹앱 매니페스트</target>
        </trans-unit>
        <trans-unit id="46dc33ac07a18973e43188c253db39911503dbaa" translate="yes" xml:space="preserve">
          <source>Web applications opt in to this behaviour with the NEL header, which is a &lt;em&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Response_header&quot;&gt;JSON-encoded&lt;/a&gt;&lt;/em&gt; object:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1efc7e6fa024668a0b022f0cb8422afcf8485b26" translate="yes" xml:space="preserve">
          <source>Web applications set a Cross-Origin Resource Policy via the &lt;a href=&quot;headers/cross-origin-resource-policy&quot;&gt;&lt;code&gt;Cross-Origin-Resource-Policy&lt;/code&gt;&lt;/a&gt; HTTP response header, which accepts one of three values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bda95fb3fa91f3d265697fb24bb06ea2572d20c9" translate="yes" xml:space="preserve">
          <source>Web developers invented a technique that Steve Souders called &lt;em&gt;revving&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Infrequently updated files are named in a specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that &lt;em&gt;never&lt;/em&gt; changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</source>
          <target state="translated">웹 개발자는 Steve Souders가 &lt;em&gt;revving &lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; 이라고 부르는 기술을 발명했습니다 . 자주 업데이트되지 않는 파일은 특정 방식으로 이름이 지정됩니다. URL, 일반적으로 파일 이름에 개정 (또는 버전) 번호가 추가됩니다. 이렇게하면이 리소스의 각각의 새로운 개정은 &lt;em&gt;결코&lt;/em&gt; 변경 매우 먼 미래, 일반적으로 1 년 이상이 될 수 있습니다. 새 버전을 가지려면 모든 링크를 변경해야합니다. 이것이이 방법의 단점입니다. 일반적으로 웹 개발자가 사용하는 도구 체인에서 처리하는 추가 복잡성입니다. 드물게 가변적 인 자원이 변경되면 종종 가변 자원에 대한 추가 변경을 유도합니다. 이들을 읽을 때 다른 버전의 새 버전도 읽습니다.</target>
        </trans-unit>
        <trans-unit id="4aae5e4ef23e3484617aad036f6f0942d85a4a3d" translate="yes" xml:space="preserve">
          <source>Web developers invented a technique that Steve Souders called &lt;em&gt;revving&lt;/em&gt;&lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;. Infrequently updated files are named in specific way: in their URL, usually in the filename, a revision (or version) number is added. That way each new revision of this resource is considered as a resource on its own that &lt;em&gt;never&lt;/em&gt; changes and that can have an expiration time very far in the future, usually one year or even more. In order to have the new versions, all the links to them must be changed, that is the drawback of this method: additional complexity that is usually taken care of by the tool chain used by Web developers. When the infrequently variable resources change they induce an additional change to often variable resources. When these are read, the new versions of the others are also read.</source>
          <target state="translated">웹 개발자는 Steve Souders가 &lt;em&gt;revving&lt;/em&gt; 이라고 부르는 기술을 개발했습니다 &lt;sup&gt;&lt;a href=&quot;https://www.stevesouders.com/blog/2008/08/23/revving-filenames-dont-use-querystring/&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; . 자주 업데이트되지 않는 파일은 특정 방식으로 이름이 지정됩니다. URL, 일반적으로 파일 이름에 개정 (또는 버전) 번호가 추가됩니다. 그렇게하면이 자원의 각 새로운 개정판은 그 자체로는 &lt;em&gt;결코&lt;/em&gt; 자원이 아닌 자원으로 간주됩니다&lt;em&gt;&lt;/em&gt;변경 사항은 향후 1 년 또는 그 이상까지 만료 시간이 매우 길어질 수 있습니다. 새 버전을 사용하려면 웹 개발자가 사용하는 툴 체인에 의해 처리되는 추가 복잡성 인이 방법의 단점 인 새 버전에 대한 모든 링크를 변경해야합니다. 드물게 가변 자원이 변경 될 때 종종 가변 자원에 대한 추가 변경을 유도합니다. 이것들을 읽을 때, 다른 것의 새로운 버전도 읽습니다.</target>
        </trans-unit>
        <trans-unit id="c70b0ff6920fb5d4f64386ac826550f70e1ff8e1" translate="yes" xml:space="preserve">
          <source>Web developers, or webmasters, rarely craft these textual HTTP messages themselves: software, a Web browser, proxy, or Web server, perform this action. They provide HTTP messages through config files (for proxies or servers), APIs (for browsers), or other interfaces.</source>
          <target state="translated">웹 개발자 나 웹 마스터는 이러한 텍스트 HTTP 메시지 자체를 거의 만들지 않습니다. 소프트웨어, 웹 브라우저, 프록시 또는 웹 서버는이 작업을 수행합니다. 구성 파일 (프록시 또는 서버용), API (브라우저 용) 또는 기타 인터페이스를 통해 HTTP 메시지를 제공합니다.</target>
        </trans-unit>
        <trans-unit id="8d4119ff2982c9f860674f920c336448cc016413" translate="yes" xml:space="preserve">
          <source>Web media technologies</source>
          <target state="translated">웹 미디어 기술</target>
        </trans-unit>
        <trans-unit id="83eb70bb9b9c1cc810a2c336b4e785e9b89447dd" translate="yes" xml:space="preserve">
          <source>Web sites can easily collect Firefox default preferences by overriding this &lt;code&gt;pref()&lt;/code&gt; function and using the script &lt;code&gt;resource:///defaults/preferences/firefox.js&lt;/code&gt;.</source>
          <target state="translated">웹 사이트는이 &lt;code&gt;pref()&lt;/code&gt; 함수 를 재정의 하고 &lt;code&gt;resource:///defaults/preferences/firefox.js&lt;/code&gt; 스크립트를 사용하여 Firefox 기본 환경 설정을 쉽게 수집 할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="051061c35dede06e751f127657cfd8dabc9b47ce" translate="yes" xml:space="preserve">
          <source>WebAssembly</source>
          <target state="translated">WebAssembly</target>
        </trans-unit>
        <trans-unit id="e993b7a84cae2379869728d12f4d33cde0391ee7" translate="yes" xml:space="preserve">
          <source>WebDAV provides the ability to send a LOCK request to an unmapped URL
   in order to reserve the name for use.  This is a simple way to avoid
   the lost-update problem on the creation of a new resource (another
   way is to use If-None-Match header specified in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.26&quot;&gt;Section&amp;nbsp;14.26 of
   [RFC2616]&lt;/a&gt;).  It has the side benefit of locking the new resource
   immediately for use of the creator.

   Note that the lost-update problem is not an issue for collections
   because MKCOL can only be used to create a collection, not to
   overwrite an existing collection.  When trying to lock a collection
   upon creation, clients can attempt to increase the likelihood of
   getting the lock by pipelining the MKCOL and LOCK requests together
   (but because this doesn't convert two separate operations into one
   atomic operation, there's no guarantee this will work).

   A successful lock request to an unmapped URL MUST result in the
   creation of a locked (non-collection) resource with empty content.
   Subsequently, a successful PUT request (with the correct lock token)
   provides the content for the resource.  Note that the LOCK request
   has no mechanism for the client to provide Content-Type or Content-
   Language, thus the server will use defaults or empty values and rely
   on the subsequent PUT request for correct values.

   A resource created with a LOCK is empty but otherwise behaves in
   every way as a normal resource.  It behaves the same way as a
   resource created by a PUT request with an empty body (and where a
   Content-Type and Content-Language was not specified), followed by a
   LOCK request to the same resource.  Following from this model, a
   locked empty resource:

   o  Can be read, deleted, moved, and copied, and in all ways behaves
      as a regular non-collection resource.

   o  Appears as a member of its parent collection.

   o  SHOULD NOT disappear when its lock goes away (clients must
      therefore be responsible for cleaning up their own mess, as with
      any other operation or any non-empty resource). 

   o  MAY NOT have values for properties like DAV:getcontentlanguage
      that haven't been specified yet by the client.

   o  Can be updated (have content added) with a PUT request.

   o  MUST NOT be converted into a collection.  The server MUST fail a
      MKCOL request (as it would with a MKCOL request to any existing
      non-collection resource).

   o  MUST have defined values for DAV:lockdiscovery and DAV:
      supportedlock properties.

   o  The response MUST indicate that a resource was created, by use of
      the &quot;201 Created&quot; response code (a LOCK request to an existing
      resource instead will result in 200 OK).  The body must still
      include the DAV:lockdiscovery property, as with a LOCK request to
      an existing resource.

   The client is expected to update the locked empty resource shortly
   after locking it, using PUT and possibly PROPPATCH.

   Alternatively and for backwards compatibility to [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt;], servers
   MAY implement Lock-Null Resources (LNRs) instead (see definition in
   &lt;a href=&quot;#appendix-D&quot;&gt;Appendix D&lt;/a&gt;).  Clients can easily interoperate both with servers that
   support the old model LNRs and the recommended model of &quot;locked empty
   resources&quot; by only attempting PUT after a LOCK to an unmapped URL,
   not MKCOL or GET, and by not relying on specific properties of LNRs.</source>
          <target state="translated">WebDAV는 사용할 이름을 예약하기 위해 매핑되지 않은 URL에 LOCK 요청을 보내는 기능을 제공합니다. 이것은 새로운 리소스를 만들 때 업데이트 손실 문제를 피하는 간단한 방법입니다 (또 다른 방법은 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-14.26&quot;&gt;[RFC2616] 14.26 절에&lt;/a&gt; 지정된 If-None-Match 헤더를 사용하는 것입니다 )). 작성자를 사용하기 위해 새 자원을 즉시 잠그는 이점이 있습니다. MKCOL은 기존 컬렉션을 덮어 쓰지 않고 컬렉션을 만드는 데만 사용할 수 있기 때문에 업데이트 손실 문제는 컬렉션에 문제가되지 않습니다. 생성시 컬렉션을 잠그려고 할 때 클라이언트는 MKCOL과 LOCK 요청을 함께 파이프 라인하여 잠금을 획득 할 가능성을 높일 수 있습니다 (그러나 이것은 두 개의 개별 연산을 하나의 원자 연산으로 변환하지 않기 때문에 이것이 작동한다는 보장은 없습니다 ). 매핑되지 않은 URL에 대한 잠금 요청이 성공하면 빈 내용으로 잠긴 (수집되지 않은) 리소스가 생성되어야합니다. 후속 적으로, 올바른 잠금 토큰을 가진 성공적인 PUT 요청은 자원의 컨텐츠를 제공합니다.LOCK 요청에는 클라이언트가 Content-Type 또는 Content-Language를 제공 ​​할 수있는 메커니즘이 없으므로 서버는 기본값 또는 빈 값을 사용하고 올바른 값을 위해 후속 PUT 요청에 의존합니다. LOCK으로 작성된 자원은 비어 있지만 모든 방식으로 일반 자원으로 작동합니다. 빈 본문 (및 Content-Type 및 Content-Language가 지정되지 않은)이있는 PUT 요청에 의해 생성 된 리소스와 동일한 방식으로 작동 한 다음 동일한 리소스에 대한 LOCK 요청이 수행됩니다. 이 모델에서 비어있는 빈 리소스는 다음과 같습니다. o 읽기, 삭제, 이동 및 복사가 가능하며 모든 방법으로 일반 비 수집 리소스로 작동합니다. o 부모 컬렉션의 구성원으로 나타납니다.o 잠금이 해제 될 때 사라지지 않아야합니다 (따라서 클라이언트는 다른 작업이나 비어 있지 않은 리소스와 마찬가지로 자신의 혼란을 정리해야합니다). o 클라이언트가 아직 지정하지 않은 DAV : getcontentlanguage와 같은 속성 값을 가질 수 없습니다. PUT 요청으로 업데이트 (컨텐츠 추가) 할 수 있습니다. o 컬렉션으로 변환해서는 안됩니다. 서버는 (기존의 비 수집 자원에 대한 MKCOL 요청과 마찬가지로) MKCOL 요청에 실패해야합니다. o DAV : lockdiscovery 및 DAV : supportedlock 속성에 대한 값을 정의해야합니다. o 응답은 &quot;201 Created&quot;응답 코드를 사용하여 리소스가 생성되었음을 나타내야합니다 (기존 리소스에 대한 LOCK 요청은 200이됩니다).기존 자원에 대한 잠금 요청과 같이 본문에는 여전히 DAV : lockdiscovery 특성이 포함되어 있어야합니다. 클라이언트는 PUT 및 가능하면 PROPPATCH를 사용하여 잠긴 빈 자원을 잠근 직후 업데이트해야합니다. 또는 이전 버전과의 호환성을 위해 [&lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC2518&lt;/a&gt; ], 서버는 대신 LNR (Lock-Null Resources)을 구현할 수 있습니다 ( &lt;a href=&quot;#appendix-D&quot;&gt;부록 D의&lt;/a&gt; 정의 참조 ). 클라이언트는 MKCOL 또는 GET이 아닌 매핑되지 않은 URL에 대한 잠금 후 PUT을 시도하고 LNR의 특정 속성에 의존하지 않음으로써 이전 모델 LNR을 지원하는 서버와 권장되는 &quot;잠긴 빈 리소스&quot;모델과 쉽게 상호 운용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a23e5cc615236bc8c759c172e1a9673963c88638" translate="yes" xml:space="preserve">
          <source>WebDAV provides, through the PROPFIND method, a mechanism for listing
   the member resources of a collection.  This greatly diminishes the
   effectiveness of security or privacy techniques that rely only on the
   difficulty of discovering the names of network resources.  Users of
   WebDAV servers are encouraged to use access control techniques to
   prevent unwanted access to resources, rather than depending on the
   relative obscurity of their resource names.</source>
          <target state="translated">WebDAV는 PROPFIND 메소드를 통해 콜렉션의 멤버 자원을 나열하는 메커니즘을 제공합니다. 이는 네트워크 리소스의 이름을 찾기가 어려운 보안 또는 개인 정보 보호 기술의 효율성을 크게 떨어 뜨립니다. WebDAV 서버 사용자는 리소스 이름의 상대적인 모호성에 의존하기보다는 액세스 제어 기술을 사용하여 리소스에 대한 원치 않는 액세스를 방지하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="f85551b99b1731274ca28a740445b7fb39846ad8" translate="yes" xml:space="preserve">
          <source>WebDAV was designed to be, and has been found to be, backward-
   compatible with HTTP 1.1.  The PUT and DELETE methods are defined in
   HTTP and thus may be used by HTTP clients as well as WebDAV-aware
   clients, but the responses to PUT and DELETE have been extended in
   this specification in ways that only a WebDAV client would be
   entirely prepared for.  Some theoretical concerns were raised about
   whether those responses would cause interoperability problems with
   HTTP-only clients, and this section addresses those concerns.

   Since any HTTP client ought to handle unrecognized 400-level and 500-
   level status codes as errors, the following new status codes should
   not present any issues: 422, 423, and 507 (424 is also a new status
   code but it appears only in the body of a Multistatus response.)  So,
   for example, if an HTTP client attempted to PUT or DELETE a locked
   resource, the 423 Locked response ought to result in a generic error
   presented to the user.

   The 207 Multistatus response is interesting because an HTTP client
   issuing a DELETE request to a collection might interpret a 207
   response as a success, even though it does not realize the resource
   is a collection and cannot understand that the DELETE operation might
   have been a complete or partial failure.  That interpretation isn't
   entirely justified, because a 200-level response indicates that the
   server &quot;received, understood, and accepted&quot; the request, not that the
   request resulted in complete success.

   One option is that a server could treat a DELETE of a collection as
   an atomic operation, and use either 204 No Content in case of
   success, or some appropriate error response (400 or 500 level) for an
   error.  This approach would indeed maximize backward compatibility.
   However, since interoperability tests and working group discussions
   have not turned up any instances of HTTP clients issuing a DELETE
   request against a WebDAV collection, this concern is more theoretical
   than practical.  Thus, servers are likely to be completely successful
   at interoperating with HTTP clients even if they treat any collection
   DELETE request as a WebDAV request and send a 207 Multi-Status
   response.

   In general, server implementations are encouraged to use the detailed
   responses and other mechanisms defined in this document rather than
   make changes for theoretical interoperability concerns.</source>
          <target state="translated">WebDAV는 HTTP 1.1과 역 호환되도록 설계되었습니다. PUT 및 DELETE 메소드는 HTTP로 정의되므로 WebDAV 인식 클라이언트뿐만 아니라 HTTP 클라이언트에서도 사용할 수 있지만 PUT 및 DELETE에 대한 응답은 WebDAV 클라이언트 만 완전히 준비 할 수 있도록이 스펙에서 확장되었습니다. . 이러한 응답이 HTTP 전용 클라이언트와의 상호 운용성 문제를 유발하는지 여부에 대한 일부 이론적 우려가 제기되었으며이 섹션에서는 이러한 문제를 해결합니다. HTTP 클라이언트는 인식 할 수없는 400 수준 및 500 수준 상태 코드를 오류로 처리해야하므로 다음과 같은 새로운 상태 코드는 문제를 나타내지 않아야합니다. 422, 423 및 507 (424는 새로운 상태 코드이지만 예를 들어 Multistatus 응답의 본문입니다.HTTP 클라이언트가 잠긴 자원을 PUT하거나 삭제하려고 시도한 경우, 423 잠금 응답은 일반 오류를 사용자에게 표시해야합니다. 207 Multistatus 응답은 컬렉션에 DELETE 요청을 발행하는 HTTP 클라이언트가 207 응답을 성공으로 해석 할 수 있지만 자원이 콜렉션임을 인식하지 못하고 DELETE 조작이 완료되었거나 부분 고장. 200 수준의 응답이 서버가 요청을 &quot;수신, 이해 및 수락&quot;했음을 나타 내기 때문에 그 해석이 전적으로 정당화되지는 않습니다. 한 가지 옵션은 서버가 컬렉션의 DELETE를 원 자성 작업으로 취급하고 성공시 204 No Content를 사용할 수 있다는 것입니다.또는 오류에 대한 적절한 오류 응답 (400 또는 500 레벨). 이 접근법은 실제로 이전 버전과의 호환성을 최대화합니다. 그러나 상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 더 이론적입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 것입니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.이 접근법은 실제로 이전 버전과의 호환성을 최대화합니다. 그러나 상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 더 이론적입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.이 접근법은 실제로 이전 버전과의 호환성을 최대화합니다. 그러나 상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 더 이론적입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 이론적 인 것입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 것입니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.상호 운용성 테스트 및 작업 그룹 토론에서 WebDAV 콜렉션에 대해 DELETE 요청을 발행하는 HTTP 클라이언트 인스턴스가 나타나지 않았으므로이 문제는 실제적인 것보다 이론적 인 것입니다. 따라서 서버는 컬렉션 삭제 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 것입니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.서버는 콜렉션 DELETE 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.서버는 콜렉션 DELETE 요청을 WebDAV 요청으로 취급하고 207 다중 상태 응답을 보내더라도 HTTP 클라이언트와의 상호 운용에 완전히 성공할 수 있습니다. 일반적으로 서버 구현에서는 이론적 상호 운용성 문제를 변경하기보다는이 문서에 정의 된 세부 응답 및 기타 메커니즘을 사용하는 것이 좋습니다.</target>
        </trans-unit>
        <trans-unit id="3eebce6ea96f9e6c03e9252a4f8ef2ea9fe141c2" translate="yes" xml:space="preserve">
          <source>WebKit</source>
          <target state="translated">WebKit</target>
        </trans-unit>
        <trans-unit id="3cc12f1bec20e52cab0b97341d3c02b8d6b5a8e7" translate="yes" xml:space="preserve">
          <source>WebKit-based (Android, Safari)</source>
          <target state="translated">WebKit 기반 (Android, Safari)</target>
        </trans-unit>
        <trans-unit id="6cd48f2561ad5a0df1f54b2512998a473f410b84" translate="yes" xml:space="preserve">
          <source>WebKit: &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=165508&quot;&gt;Issue 165508&lt;/a&gt;</source>
          <target state="translated">WebKit : &lt;a href=&quot;https://bugs.webkit.org/show_bug.cgi?id=165508&quot;&gt;문제 165508&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6fa39ac0c7eff59abc27629413eef3a672293245" translate="yes" xml:space="preserve">
          <source>WebP</source>
          <target state="translated">WebP</target>
        </trans-unit>
        <trans-unit id="e5b42921cd81579fb4373d4c9301a0b48c00c221" translate="yes" xml:space="preserve">
          <source>WebSQL databases,</source>
          <target state="translated">WebSQL 데이터베이스</target>
        </trans-unit>
        <trans-unit id="02a11319d4ec575e7c0cfcc8b345785648d8021d" translate="yes" xml:space="preserve">
          <source>WebSocket API</source>
          <target state="translated">WebSocket API</target>
        </trans-unit>
        <trans-unit id="135a771b27602deda1493cda4d44fa69a76c0314" translate="yes" xml:space="preserve">
          <source>WebSocket connections (Secure)</source>
          <target state="translated">WebSocket 연결 (보안)</target>
        </trans-unit>
        <trans-unit id="e4ca95fd7fee5486bad6b0d54e93172855ee31dd" translate="yes" xml:space="preserve">
          <source>WebSocket-specific headers</source>
          <target state="translated">WebSocket 관련 헤더</target>
        </trans-unit>
        <trans-unit id="56d0e53e6a7114caaeb10b3ceba94b42ba2520e2" translate="yes" xml:space="preserve">
          <source>WebSockets</source>
          <target state="translated">WebSockets</target>
        </trans-unit>
        <trans-unit id="bcfdf198814c62a013153c8d98f2ec9e7b2c3064" translate="yes" xml:space="preserve">
          <source>WebUSB&lt;br/&gt;&lt;small&gt;The definition of 'Feature-Policy integration' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5b3205d2f50f8459df98f434927a9961edb8576" translate="yes" xml:space="preserve">
          <source>WebVR 1.1</source>
          <target state="translated">WebVR 1.1</target>
        </trans-unit>
        <trans-unit id="494fbe1ebcf39962e071a464fdd0df350d08593e" translate="yes" xml:space="preserve">
          <source>WebVR API was never enabled by default in any production builds and was replaced by WebXR Device API.</source>
          <target state="translated">WebVR API는 프로덕션 빌드에서 기본적으로 활성화되지 않았으며 WebXR 장치 API로 대체되었습니다.</target>
        </trans-unit>
        <trans-unit id="27901e8bd54a2a676efc007a2965c637bf272615" translate="yes" xml:space="preserve">
          <source>WebXR Device API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2839c9373e6691534edc4e253a91dfc78b3c6118" translate="yes" xml:space="preserve">
          <source>WebXR Device API&lt;br/&gt;&lt;small&gt;The definition of 'Permissions Policy' in that specification.&lt;/small&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e76aac4eddc8812e45c58b46f8b12f9b9860da" translate="yes" xml:space="preserve">
          <source>What Does the &quot;Track&quot; in &quot;Do Not Track&quot; Mean? &amp;ndash; EFF</source>
          <target state="translated">&quot;추적하지 않음&quot;의 &quot;추적&quot;이란 무엇입니까? &amp;ndash; EFF</target>
        </trans-unit>
        <trans-unit id="6a8f52f9ef8f506e4398a41c7de6a771321653bb" translate="yes" xml:space="preserve">
          <source>What are domain names?</source>
          <target state="translated">도메인 이름은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="268a9a597e83ba75272d9a4ac9bca257bf6b5aed" translate="yes" xml:space="preserve">
          <source>What can be controlled by HTTP</source>
          <target state="translated">HTTP로 제어 할 수있는 것</target>
        </trans-unit>
        <trans-unit id="713c03e5f5976173474700739054677d438ef529" translate="yes" xml:space="preserve">
          <source>What is a URL?</source>
          <target state="translated">URL이란 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="cb40fda7700c4353a89ae159720212fe772dbbc9" translate="yes" xml:space="preserve">
          <source>What requests use CORS?</source>
          <target state="translated">CORS를 사용하는 요청은 무엇입니까?</target>
        </trans-unit>
        <trans-unit id="71c8a4a23b0dea390d9c49b1b0992f6d919a9595" translate="yes" xml:space="preserve">
          <source>What went wrong?</source>
          <target state="translated">무엇이 잘못 되었나요?</target>
        </trans-unit>
        <trans-unit id="cf7174ba77cb305a51d991cf76d59eab20483bc3" translate="yes" xml:space="preserve">
          <source>When a 206 (Partial Content) response message includes the content of
   multiple ranges, they are transmitted as body parts in a multipart
   message body (&lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1&quot;&gt;[RFC2046], Section&amp;nbsp;5.1&lt;/a&gt;) with the media type of
   &quot;multipart/byteranges&quot;.

   The multipart/byteranges media type includes one or more body parts,
   each with its own Content-Type and Content-Range fields.  The
   required boundary parameter specifies the boundary string used to
   separate each body part.

   Implementation Notes:

   1.  Additional CRLFs might precede the first boundary string in the
       body.

   2.  Although [&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;] permits the boundary string to be quoted, some
       existing implementations handle a quoted boundary string
       incorrectly.

   3.  A number of clients and servers were coded to an early draft of
       the byteranges specification that used a media type of multipart/
       x-byteranges, which is almost (but not quite) compatible with
       this type.

   Despite the name, the &quot;multipart/byteranges&quot; media type is not
   limited to byte ranges.  The following example uses an &quot;exampleunit&quot;
   range unit:

     HTTP/1.1 206 Partial Content
     Date: Tue, 14 Nov 1995 06:25:24 GMT
     Last-Modified: Tue, 14 July 04:58:08 GMT
     Content-Length: 2331785
     Content-Type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

     --THIS_STRING_SEPARATES
     Content-Type: video/example
     Content-Range: exampleunit 1.2-4.3/25

     ...the first range
     --THIS_STRING_SEPARATES
     Content-Type: video/example
     Content-Range: exampleunit 11.2-14.3/25

     ...the second range
     --THIS_STRING_SEPARATES--</source>
          <target state="translated">206 (부분 컨텐츠) 응답 메시지에 여러 범위의 컨텐츠가 포함 된 경우 , 매체 유형이 &quot;멀티 파트 / 바이트 범위&quot;인 멀티 파트 메시지 본문 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2046#section-5.1&quot;&gt;[RFC2046], 섹션 5.1&lt;/a&gt; )에 본문으로 전송됩니다 . multipart / byteranges 미디어 유형에는 각각 고유 한 Content-Type 및 Content-Range 필드가있는 하나 이상의 본문 부분이 포함됩니다. 필수 경계 매개 변수는 각 본문 부분을 분리하는 데 사용되는 경계 문자열을 지정합니다. 구현 노트 : 1. 추가 CRLF가 본문의 첫 번째 경계 문자열보다 앞에 올 수 있습니다. 2. 비록 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC2046&lt;/a&gt;]는 경계 문자열을 인용 할 수있게하며 일부 기존 구현에서는 인용 된 경계 문자열을 잘못 처리합니다. 3. 여러 종류의 클라이언트와 서버가 미디어 유형의 multipart / x-byterange를 사용하는 바이트 범위 사양의 초기 초안으로 코딩되었으며,이 유형과 거의 호환되지만 그다지 호환되지는 않습니다. 이름에도 불구하고 &quot;multipart / byteranges&quot;미디어 유형은 바이트 범위로 제한되지 않습니다. 다음 예제는 &quot;exampleunit&quot;범위 단위를 사용합니다. HTTP / 1.1 206 부분 컨텐츠 날짜 : 1995 년 11 월 14 일 화요일 06:25:24 GMT 최종 수정 : 7 월 14 일 04:58:08 GMT 컨텐츠 길이 : 2331785 컨텐츠 유형 : multipart / byteranges; boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 콘텐츠 유형 : 비디오 / 예제 콘텐츠 범위 : exampleunit 12-4.3 / 25 ... 첫 번째 범위 --THIS_STRING_SEPARATES 콘텐츠 유형 : 비디오 / 예제 콘텐츠 범위 : exampleunit 11.2-14.3 / 25 ... 두 번째 범위 --THIS_STRING_SEPARATES--</target>
        </trans-unit>
        <trans-unit id="6c808413e1f3c35593db90aed6fc9dab2aba5b1a" translate="yes" xml:space="preserve">
          <source>When a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request is used to load a document, that load cannot currently be redirected into a new process. This error is displayed when loading a document with a &lt;code&gt;Large-Allocation&lt;/code&gt; header with a non-GET HTTP method. This could be caused due to the document being loaded by a form submission, for example.</source>
          <target state="translated">때 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 요청이 문서를로드하는 데 사용됩니다, 그 부하는 현재 새로운 프로세스로 리디렉션 할 수 없습니다. 비 GET HTTP 메소드를 사용하여 &lt;code&gt;Large-Allocation&lt;/code&gt; 헤더가있는 문서를로드 할 때이 오류가 표시됩니다 . 예를 들어, 양식 제출에 의해 문서가로드되어 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="56b0204156f1f5be7ef0d0a67cbf3c8e482f8b85" translate="yes" xml:space="preserve">
          <source>When a CSS stylesheet is requested, via the &lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">CSS 스타일 시트가 요청되면 &lt;code&gt;&amp;lt;link rel=&quot;stylesheet&quot;&amp;gt;&lt;/code&gt; HTML 요소를 통해 대부분의 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="6496002e1314faa2d54160cca1e538793173aa5c" translate="yes" xml:space="preserve">
          <source>When a cache has a stale entry that it would like to use as a
   response to a client's request, it first has to check with the origin
   server (or possibly an intermediate cache with a fresh response) to
   see if its cached entry is still usable. We call this &quot;validating&quot;
   the cache entry. Since we do not want to have to pay the overhead of
   retransmitting the full response if the cached entry is good, and we
   do not want to pay the overhead of an extra round trip if the cached
   entry is invalid, the HTTP/1.1 protocol supports the use of
   conditional methods.

   The key protocol features for supporting conditional methods are
   those concerned with &quot;cache validators.&quot; When an origin server
   generates a full response, it attaches some sort of validator to it,
   which is kept with the cache entry. When a client (user agent or
   proxy cache) makes a conditional request for a resource for which it
   has a cache entry, it includes the associated validator in the
   request.

   The server then checks that validator against the current validator
   for the entity, and, if they match (see &lt;a href=&quot;#section-13.3.3&quot;&gt;section 13.3.3&lt;/a&gt;), it responds
   with a special status code (usually, 304 (Not Modified)) and no
   entity-body. Otherwise, it returns a full response (including
   entity-body). Thus, we avoid transmitting the full response if the
   validator matches, and we avoid an extra round trip if it does not
   match.

   In HTTP/1.1, a conditional request looks exactly the same as a normal
   request for the same resource, except that it carries a special
   header (which includes the validator) that implicitly turns the
   method (usually, GET) into a conditional.

   The protocol includes both positive and negative senses of cache-
   validating conditions. That is, it is possible to request either that
   a method be performed if and only if a validator matches or if and
   only if no validators match. 

      Note: a response that lacks a validator may still be cached, and
      served from cache until it expires, unless this is explicitly
      prohibited by a cache-control directive. However, a cache cannot
      do a conditional retrieval if it does not have a validator for the
      entity, which means it will not be refreshable after it expires.</source>
          <target state="translated">캐시에 클라이언트 요청에 대한 응답으로 사용하려는 오래된 항목이있는 경우 먼저 캐시 된 항목이 여전히 사용 가능한지 확인하기 위해 원래 서버 (또는 새로운 응답이있는 중간 캐시)를 확인해야합니다. . 이것을 캐시 항목을 &quot;유효성 검사&quot;라고합니다. 캐시 된 항목이 양호하면 전체 응답을 다시 전송하는 오버 헤드를 지불하지 않아도되고 캐시 된 항목이 유효하지 않은 경우 추가 왕복의 오버 헤드를 지불하지 않기 위해 HTTP / 1.1 프로토콜이 지원합니다. 조건부 방법의 사용. 조건부 방법을 지원하기위한 주요 프로토콜 기능은 &quot;캐시 유효성 검사기&quot;와 관련된 기능입니다. 오리진 서버는 전체 응답을 생성 할 때 캐시 항목과 함께 유지되는 일종의 유효성 검증기를 첨부합니다.클라이언트 (사용자 에이전트 또는 프록시 캐시)가 캐시 항목이있는 자원에 대해 조건부 요청을하면 요청에 연관된 유효성 검증 기가 포함됩니다. 그런 다음 서버는 해당 유효성 검사기를 엔터티의 현재 유효성 검사기와 비교하여 확인하고 일치하는지 확인합니다 (참조&lt;a href=&quot;#section-13.3.3&quot;&gt;섹션 13.3.3&lt;/a&gt;), 특수 상태 코드 (일반적으로 304 (수정되지 않음))로 응답하고 엔터티 본문이 없습니다. 그렇지 않으면 전체 응답 (Entity-body 포함)을 반환합니다. 따라서 유효성 검사기가 일치하면 전체 응답을 전송하지 않으며 일치하지 않으면 추가 왕복을 피합니다. HTTP / 1.1에서 조건부 요청은 메소드 (일반적으로 GET)를 내재적으로 조건부로 바꾸는 특수 헤더 (유효 기 포함)를 포함한다는 점을 제외하고는 동일한 자원에 대한 일반 요청과 정확히 동일합니다. 이 프로토콜에는 긍정적이고 부정적인 캐시 유효성 검사 조건이 모두 포함됩니다. 즉, 검증자가 일치하는 경우에만 또는 검증자가 일치하지 않는 경우에만 메소드를 수행하도록 요청할 수 있습니다. 노트 :유효성 검사기가없는 응답은 캐시 제어 지시문에서 명시 적으로 금지하지 않는 한 계속 캐시되어 캐시가 만료 될 때까지 캐시에서 제공 될 수 있습니다. 그러나 엔터티에 대한 유효성 검사기가없는 캐시는 조건부 검색을 수행 할 수 없습니다. 즉, 캐시가 만료 된 후에는 새로 고칠 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="2a313afb539045fee37b52ddc2442118f434a073" translate="yes" xml:space="preserve">
          <source>When a cache has one or more stored responses for a requested URI,
   but cannot serve any of them (e.g., because they are not fresh, or
   one cannot be selected; see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), it can use the conditional
   request mechanism [&lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt;] in the forwarded request to give the next
   inbound server an opportunity to select a valid stored response to
   use, updating the stored metadata in the process, or to replace the
   stored response(s) with a new response.  This process is known as
   &quot;validating&quot; or &quot;revalidating&quot; the stored response.</source>
          <target state="translated">캐시에 요청 된 URI에 대해 하나 이상의 저장된 응답이 있지만 그 중 하나를 제공 할 수없는 경우 (예 : 새로 작성되지 않았거나 선택할 수 없기 때문에 &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; 참조 ) 조건부 요청 메커니즘 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC7232&lt;/a&gt; ]을 사용할 수 있습니다 . 전달 된 요청에서, 다음 인바운드 서버가 사용할 유효한 저장된 응답을 선택하여 프로세스에서 저장된 메타 데이터를 업데이트하거나 저장된 응답을 새로운 응답으로 대체 할 기회를 제공합니다. 이 프로세스를 저장된 응답을 &quot;확인&quot;또는 &quot;재확인&quot;이라고합니다.</target>
        </trans-unit>
        <trans-unit id="e7c36b18a75fcc748e38b4b4ab8d6dd1ec4fac99" translate="yes" xml:space="preserve">
          <source>When a cache makes a validating request to a server, and the server
   provides a 304 (Not Modified) response or a 206 (Partial Content)
   response, the cache then constructs a response to send to the
   requesting client.

   If the status code is 304 (Not Modified), the cache uses the entity-
   body stored in the cache entry as the entity-body of this outgoing
   response. If the status code is 206 (Partial Content) and the ETag or
   Last-Modified headers match exactly, the cache MAY combine the
   contents stored in the cache entry with the new contents received in
   the response and use the result as the entity-body of this outgoing
   response, (see 13.5.4).

   The end-to-end headers stored in the cache entry are used for the
   constructed response, except that

      - any stored Warning headers with warn-code 1xx (see &lt;a href=&quot;#section-14.46&quot;&gt;section&lt;/a&gt;&lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;) MUST be deleted from the cache entry and the forwarded
        response.

      - any stored Warning headers with warn-code 2xx MUST be retained
        in the cache entry and the forwarded response.

      - any end-to-end headers provided in the 304 or 206 response MUST
        replace the corresponding headers from the cache entry.

   Unless the cache decides to remove the cache entry, it MUST also
   replace the end-to-end headers stored with the cache entry with
   corresponding headers received in the incoming response, except for
   Warning headers as described immediately above. If a header field-
   name in the incoming response matches more than one header in the
   cache entry, all such old headers MUST be replaced.

   In other words, the set of end-to-end headers received in the
   incoming response overrides all corresponding end-to-end headers
   stored with the cache entry (except for stored Warning headers with
   warn-code 1xx, which are deleted even if not overridden).

      Note: this rule allows an origin server to use a 304 (Not
      Modified) or a 206 (Partial Content) response to update any header
      associated with a previous response for the same entity or sub-
      ranges thereof, although it might not always be meaningful or
      correct to do so. This rule does not allow an origin server to use
      a 304 (Not Modified) or a 206 (Partial Content) response to
      entirely delete a header that it had provided with a previous
      response.</source>
          <target state="translated">캐시가 서버에 유효성 검증 요청을하고 서버가 304 (수정되지 않음) 응답 또는 206 (부분 컨텐츠) 응답을 제공하는 경우, 캐시는 요청 클라이언트로 전송하기위한 응답을 구성합니다. 상태 코드가 304 (수정되지 않음) 인 경우 캐시는 캐시 항목에 저장된 엔티티 본문을이 발신 응답의 엔티티 본문으로 사용합니다. 상태 코드가 206 (부분 컨텐츠)이고 ETag 또는 Last-Modified 헤더가 정확히 일치하는 경우, 캐시는 캐시 항목에 저장된 컨텐츠를 응답에서 수신 한 새 컨텐츠와 결합하고 그 결과를 엔티티 본문으로 사용할 수 있습니다 (MAY). 이 발신 응답 (13.5.4 참조). 캐시 항목에 저장된 엔드-투-엔드 헤더는 다음을 제외하고 구성된 응답에 사용됩니다. 경고 코드가 1xx 인 저장된 경고 헤더&lt;a href=&quot;#section-14.46&quot;&gt;섹션 &lt;/a&gt;&lt;a href=&quot;#section-14.46&quot;&gt;14.46&lt;/a&gt;)는 캐시 항목과 전달 된 응답에서 삭제해야합니다. -경고 코드가 2xx 인 저장된 경고 헤더는 캐시 항목과 전달 된 응답에 보관해야합니다. -304 또는 206 응답으로 제공된 모든 종단 간 헤더는 캐시 항목의 해당 헤더를 대체해야합니다. 캐시가 캐시 엔트리를 제거하기로 결정하지 않는 한, 캐시 엔트리와 함께 저장된 엔드-투-엔드 헤더를 바로 위에서 설명한 경고 헤더를 제외하고 수신 응답에서 수신 된 해당 헤더로 교체해야합니다. 수신 응답의 헤더 필드 이름이 캐시 항목의 둘 이상의 헤더와 일치하면 이러한 모든 이전 헤더를 교체해야합니다. 다시 말해,수신 응답에서 수신 된 엔드-투-엔드 헤더 세트는 캐시 항목과 함께 저장된 모든 해당 엔드-투-엔드 헤더를 대체합니다 (경고 코드가 1xx 인 저장된 경고 헤더는 제외됨). 참고 :이 규칙을 통해 오리진 서버는 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 동일한 엔티티 또는 하위 범위에 대한 이전 응답과 연관된 헤더를 업데이트 할 수 있지만 항상 의미가있는 것은 아닙니다. 또는 수정하십시오. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.재정의되지 않더라도 삭제됩니다). 참고 :이 규칙을 통해 오리진 서버는 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 동일한 엔티티 또는 하위 범위에 대한 이전 응답과 연관된 헤더를 업데이트 할 수 있지만 항상 의미가있는 것은 아닙니다. 또는 수정하십시오. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.재정의되지 않더라도 삭제됩니다). 참고 :이 규칙을 통해 오리진 서버는 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 동일한 엔티티 또는 하위 범위에 대한 이전 응답과 연관된 헤더를 업데이트 할 수 있지만 항상 의미가있는 것은 아닙니다. 또는 수정하십시오. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.그렇게하는 것이 항상 의미가 있거나 올바른 것은 아닙니다. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.그렇게하는 것이 항상 의미가 있거나 올바른 것은 아닙니다. 이 규칙은 오리진 서버가 304 (수정되지 않음) 또는 206 (부분 컨텐츠) 응답을 사용하여 이전 응답과 함께 제공된 헤더를 완전히 삭제하도록 허용하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d406717c4c6e5b1008e22170bfa6487a4fa871a" translate="yes" xml:space="preserve">
          <source>When a cache receives a 304 (Not Modified) response and already has
   one or more stored 200 (OK) responses for the same cache key, the
   cache needs to identify which of the stored responses are updated by
   this new response and then update the stored response(s) with the new
   information provided in the 304 response.

   The stored response to update is identified by using the first match
   (if any) of the following:

   o  If the new response contains a strong validator (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;Section&amp;nbsp;2.1
      of [RFC7232]&lt;/a&gt;), then that strong validator identifies the selected
      representation for update.  All of the stored responses with the
      same strong validator are selected.  If none of the stored
      responses contain the same strong validator, then the cache MUST
      NOT use the new response to update any stored responses. 

   o  If the new response contains a weak validator and that validator
      corresponds to one of the cache's stored responses, then the most
      recent of those matching stored responses is selected for update.

   o  If the new response does not include any form of validator (such
      as in the case where a client generates an If-Modified-Since
      request from a source other than the Last-Modified response header
      field), and there is only one stored response, and that stored
      response also lacks a validator, then that stored response is
      selected for update.

   If a stored response is selected for update, the cache MUST:

   o  delete any Warning header fields in the stored response with
      warn-code 1xx (see &lt;a href=&quot;#section-5.5&quot;&gt;Section 5.5&lt;/a&gt;);

   o  retain any Warning header fields in the stored response with
      warn-code 2xx; and,

   o  use other header fields provided in the 304 (Not Modified)
      response to replace all instances of the corresponding header
      fields in the stored response.</source>
          <target state="translated">캐시가 304 (수정되지 않음) 응답을 수신하고 동일한 캐시 키에 대해 하나 이상의 저장된 200 (OK) 응답을 이미 가지고있는 경우, 캐시는이 새로운 응답에 의해 업데이트 된 저장된 응답을 식별 한 다음 저장된 것을 업데이트해야합니다. 304 응답에 제공된 새로운 정보로 응답합니다. 업데이트 된 저장된 응답은 다음 중 첫 번째 일치 (있는 경우)를 사용하여 식별됩니다. o 새 응답에 강력한 유효성 검사기가 포함 된 경우 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.1&quot;&gt;[RFC7232]의 2.1 단원&lt;/a&gt; 참조 )), 강력한 유효성 검사기는 업데이트를 위해 선택된 표현을 식별합니다. 동일한 강력한 유효성 검사기를 가진 저장된 응답이 모두 선택됩니다. 저장된 응답에 동일한 강력한 유효성 검사기가 포함되어 있지 않으면 캐시는 저장된 응답을 업데이트하기 위해 새 응답을 사용해서는 안됩니다. o 새 응답에 약한 유효성 검사기가 포함되어 있고 해당 유효성 검사기가 캐시의 저장된 응답 중 하나에 해당하는 경우 저장된 저장된 응답 중 가장 일치하는 항목이 업데이트를 위해 선택됩니다. o 클라이언트가 Last-Modified 응답 헤더 필드 이외의 소스에서 If-Modified-Since 요청을 생성하는 경우와 같이 새 응답에 유효성 검사기 형식이 포함되지 않은 경우 저장된 응답이 하나만있는 경우 ,저장된 응답에도 유효성 검사기가 부족하며 저장된 응답은 업데이트를 위해 선택됩니다. 저장된 응답을 업데이트하도록 선택한 경우 캐시는 반드시 다음을 수행해야합니다. o warn-code 1xx를 사용하여 저장된 응답의 모든 경고 헤더 필드를 삭제하십시오 (참조).&lt;a href=&quot;#section-5.5&quot;&gt;섹션 5.5&lt;/a&gt; ); o warn-code 2xx를 사용하여 저장된 응답의 모든 경고 헤더 필드를 유지합니다. o 304 (수정되지 않음) 응답에 제공된 다른 헤더 필드를 사용하여 저장된 응답에서 해당 헤더 필드의 모든 인스턴스를 대체합니다.</target>
        </trans-unit>
        <trans-unit id="e27f8aec5a4d9dfc930b9dd75d95d7e0c67f7b5f" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that can be satisfied by a cached response that has a &lt;code&gt;Vary&lt;/code&gt; header field, it must not use that cached response unless all header fields as nominated by the &lt;code&gt;Vary&lt;/code&gt; header match in both the original (cached) request and the new request.</source>
          <target state="translated">캐시는이 가지고있는 캐시 된 응답에 의해 만족 될 수있는 요청 받으면 &lt;code&gt;Vary&lt;/code&gt; 헤더 필드를, 그것은이 지명 한 모든 헤더 필드하지 않는 한 캐시 된 응답을 사용해서는 안 &lt;code&gt;Vary&lt;/code&gt; 원 (캐시) 요청과 새로운 모두 헤더 일치 의뢰.</target>
        </trans-unit>
        <trans-unit id="259d9c0cc1a97e83d0591dcfa329388834b800bc" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that can be satisfied by a stored
   response that has a Vary header field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;Section&amp;nbsp;7.1.4 of [RFC7231]&lt;/a&gt;),
   it MUST NOT use that response unless all of the selecting header 

   fields nominated by the Vary header field match in both the original
   request (i.e., that associated with the stored response), and the
   presented request.

   The selecting header fields from two requests are defined to match if
   and only if those in the first request can be transformed to those in
   the second request by applying any of the following:

   o  adding or removing whitespace, where allowed in the header field's
      syntax

   o  combining multiple header fields with the same field name (see
      &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;Section&amp;nbsp;3.2 of [RFC7230]&lt;/a&gt;)

   o  normalizing both header field values in a way that is known to
      have identical semantics, according to the header field's
      specification (e.g., reordering field values when order is not
      significant; case-normalization, where values are defined to be
      case-insensitive)

   If (after any normalization that might take place) a header field is
   absent from a request, it can only match another request if it is
   also absent there.

   A Vary header field-value of &quot;*&quot; always fails to match.

   The stored response with matching selecting header fields is known as
   the selected response.

   If multiple selected responses are available (potentially including
   responses without a Vary header field), the cache will need to choose
   one to use.  When a selecting header field has a known mechanism for
   doing so (e.g., qvalues on Accept and similar request header fields),
   that mechanism MAY be used to select preferred responses; of the
   remainder, the most recent response (as determined by the Date header
   field) is used, as per &lt;a href=&quot;#section-4&quot;&gt;Section 4&lt;/a&gt;.

   If no selected response is available, the cache cannot satisfy the
   presented request.  Typically, it is forwarded to the origin server
   in a (possibly conditional; see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;) request.</source>
          <target state="translated">캐시가 Vary 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-7.1.4&quot;&gt;[RFC7231]의 섹션 7.1.4)를&lt;/a&gt; 가진 저장된 응답으로 충족 될 수있는 요청을 수신 할 때 Vary 헤더 필드로 지정된 모든 선택 헤더 필드가 아닌 한 해당 응답을 사용해서는 안됩니다. 원래 요청 (즉, 저장된 응답과 관련된 요청)과 제시된 요청 모두에서 일치합니다. 두 요청에서 선택 헤더 필드는 다음 중 하나를 적용하여 첫 번째 요청의 헤더 필드를 두 번째 요청의 헤더 필드로 변환 할 수있는 경우에만 일치하도록 정의됩니다. o 공백 추가 또는 제거, 헤더 필드의 구문에서 허용되는 경우 o 여러 헤더 필드를 동일한 필드 이름으로 결합 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.2&quot;&gt;[RFC7230]의 3.2 절&lt;/a&gt; 참조 )o 헤더 필드의 사양에 따라 동일한 의미론을 갖는 것으로 알려진 두 헤더 필드 값을 정규화 (예 : 순서가 중요하지 않은 경우 필드 값 재정렬, 값이 대소 문자를 구분하지 않는 경우 정규화) 헤더 필드가 요청에없는 경우 (정규화 후에) 요청이없는 경우 다른 요청과 만 일치 할 수 있습니다. &quot;*&quot;의 Vary 헤더 필드 값이 항상 일치하지 않습니다. 선택 헤더 필드와 일치하는 저장된 응답을 선택된 응답이라고합니다. 선택한 여러 응답을 사용할 수있는 경우 (Vary 헤더 필드가없는 응답 포함) 캐시는 사용할 응답을 선택해야합니다.선택 헤더 필드에 알려진 메커니즘 (예 : 수락 및 유사한 요청 헤더 필드의 qvalue)이있는 경우 해당 메커니즘을 사용하여 선호 응답을 선택할 수 있습니다. 나머지 중 가장 최근 응답 (날짜 헤더 필드에 의해 결정됨)이&lt;a href=&quot;#section-4&quot;&gt;섹션 4&lt;/a&gt; . 선택된 응답이 없으면 캐시가 제시된 요청을 충족시킬 수 없습니다. 일반적으로 요청 은 (조건부; &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; 참조 ) 요청으로 오리진 서버로 전달됩니다 .</target>
        </trans-unit>
        <trans-unit id="2efb3fde6a483d198481c23c5cdc77de55b29f46" translate="yes" xml:space="preserve">
          <source>When a cache receives a request that has a &lt;code&gt;Vary&lt;/code&gt; header field, it must not use a cached response by default unless all header fields specified in the &lt;code&gt;Vary&lt;/code&gt; header match in both the original (cached) request and the new request.</source>
          <target state="translated">캐시는이이 요청을 수신 할 때 &lt;code&gt;Vary&lt;/code&gt; 헤더 필드에 지정된 모든 헤더 필드가없는 한, 그것은 기본적으로 캐시 된 응답을 사용해서는 안 &lt;code&gt;Vary&lt;/code&gt; 원 (캐시) 요청과 새로운 요청 모두 헤더 일치.</target>
        </trans-unit>
        <trans-unit id="287b2fc4e92e6cc3cafe98a92f86bd5cdf146df5" translate="yes" xml:space="preserve">
          <source>When a cached document's expiration time has been reached, it is either validated or fetched again. Validation can only occur if the server provided either a &lt;em&gt;strong validator&lt;/em&gt; or a &lt;em&gt;weak validator&lt;/em&gt;.</source>
          <target state="translated">캐시 된 문서의 만료 시간에 도달하면 유효성 검사 또는 다시 가져옵니다. 서버가 &lt;em&gt;강력한 유효성 검사기&lt;/em&gt; 또는 &lt;em&gt;약한 유효성 &lt;/em&gt;&lt;em&gt;검사기를&lt;/em&gt; 제공 한 경우에만 유효성 검사가 발생할 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="975b61b5ac16b78cc262727df4d4fcf1f3fc063c" translate="yes" xml:space="preserve">
          <source>When a client wants to communicate with a server, either the final server or an intermediate proxy, it performs the following steps:</source>
          <target state="translated">클라이언트가 최종 서버 또는 중간 프록시 서버와 통신하려는 경우 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b5e879fd0d6d83356c23a21725294c0955f7c7cc" translate="yes" xml:space="preserve">
          <source>When a complete or partial representation is transferred in a message
   payload, it is often desirable for the sender to supply, or the
   recipient to determine, an identifier for a resource corresponding to
   that representation.

   For a request message:

   o  If the request has a Content-Location header field, then the
      sender asserts that the payload is a representation of the
      resource identified by the Content-Location field-value.  However,
      such an assertion cannot be trusted unless it can be verified by
      other means (not defined by this specification).  The information
      might still be useful for revision history links. 

   o  Otherwise, the payload is unidentified.

   For a response message, the following rules are applied in order
   until a match is found:

   1.  If the request method is GET or HEAD and the response status code
       is 200 (OK), 204 (No Content), 206 (Partial Content), or 304 (Not
       Modified), the payload is a representation of the resource
       identified by the effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of
       [RFC7230]&lt;/a&gt;).

   2.  If the request method is GET or HEAD and the response status code
       is 203 (Non-Authoritative Information), the payload is a
       potentially modified or enhanced representation of the target
       resource as provided by an intermediary.

   3.  If the response has a Content-Location header field and its
       field-value is a reference to the same URI as the effective
       request URI, the payload is a representation of the resource
       identified by the effective request URI.

   4.  If the response has a Content-Location header field and its
       field-value is a reference to a URI different from the effective
       request URI, then the sender asserts that the payload is a
       representation of the resource identified by the Content-Location
       field-value.  However, such an assertion cannot be trusted unless
       it can be verified by other means (not defined by this
       specification).

   5.  Otherwise, the payload is unidentified.</source>
          <target state="translated">전체 또는 부분 표현이 메시지 페이로드로 전송 될 때, 발신자가 그 표현에 대응하는 자원의 식별자를 제공하거나 수신자가 결정하는 것이 종종 바람직하다. 요청 메시지의 경우 : o 요청에 Content-Location 헤더 필드가있는 경우 발신자는 페이로드가 Content-Location 필드 값으로 식별 된 리소스의 표현이라고 주장합니다. 그러나 이러한 주장은 다른 방법으로 검증 할 수 없다면 (이 규격에 의해 정의되지 않은) 신뢰할 수 없다. 이 정보는 여전히 개정 내역 링크에 유용 할 수 있습니다. o 그렇지 않으면 페이로드가 식별되지 않습니다. 응답 메시지의 경우 일치하는 항목을 찾을 때까지 다음 규칙이 순서대로 적용됩니다.요청 방법이 GET 또는 HEAD이고 응답 상태 코드가 200 (OK), 204 (No Content), 206 (Partial Content) 또는 304 (Not Modified) 인 경우 페이로드는 유효에 의해 식별 된 리소스를 나타냅니다. 요청 URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt;). 2. 요청 방법이 GET 또는 HEAD이고 응답 상태 코드가 203 (비 정식 정보) 인 경우, 페이로드는 중개자가 제공 한 대상 자원의 잠재적으로 수정 또는 강화 된 표현입니다. 3. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 유효 요청 URI와 동일한 URI에 대한 참조 인 경우 페이로드는 유효 요청 URI로 식별 된 리소스를 나타냅니다. 4. 응답에 Content-Location 헤더 필드가 있고 해당 필드 값이 유효 요청 URI와 다른 URI에 대한 참조 인 경우 송신자는 페이로드가 Content-Location 필드로 식별 된 자원의 표현이라고 주장합니다. -값. 하나,그러한 주장은 다른 방법으로 검증 될 수 없다면 (이 규격에 의해 정의되지 않은) 신뢰할 수 없다. 5. 그렇지 않으면 페이로드가 식별되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="e81a1900fdbf11113476103eae02d72c7f77097d" translate="yes" xml:space="preserve">
          <source>When a message does not have a Transfer-Encoding header field, a
   Content-Length header field can provide the anticipated size, as a
   decimal number of octets, for a potential payload body.  For messages
   that do include a payload body, the Content-Length field-value
   provides the framing information necessary for determining where the
   body (and message) ends.  For messages that do not include a payload
   body, the Content-Length indicates the size of the selected
   representation (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;Section&amp;nbsp;3 of [RFC7231]&lt;/a&gt;).

     Content-Length = 1*DIGIT

   An example is

     Content-Length: 3495

   A sender MUST NOT send a Content-Length header field in any message
   that contains a Transfer-Encoding header field.

   A user agent SHOULD send a Content-Length in a request message when
   no Transfer-Encoding is sent and the request method defines a meaning
   for an enclosed payload body.  For example, a Content-Length header
   field is normally sent in a POST request even when the value is 0
   (indicating an empty payload body).  A user agent SHOULD NOT send a
   Content-Length header field when the request message does not contain
   a payload body and the method semantics do not anticipate such a
   body.

   A server MAY send a Content-Length header field in a response to a
   HEAD request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;Section&amp;nbsp;4.3.2 of [RFC7231]&lt;/a&gt;); a server MUST NOT send
   Content-Length in such a response unless its field-value equals the
   decimal number of octets that would have been sent in the payload
   body of a response if the same request had used the GET method.

   A server MAY send a Content-Length header field in a 304 (Not
   Modified) response to a conditional GET request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;Section&amp;nbsp;4.1 of
   [RFC7232]&lt;/a&gt;); a server MUST NOT send Content-Length in such a response 

   unless its field-value equals the decimal number of octets that would
   have been sent in the payload body of a 200 (OK) response to the same
   request.

   A server MUST NOT send a Content-Length header field in any response
   with a status code of 1xx (Informational) or 204 (No Content).  A
   server MUST NOT send a Content-Length header field in any 2xx
   (Successful) response to a CONNECT request (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;Section&amp;nbsp;4.3.6 of
   [RFC7231]&lt;/a&gt;).

   Aside from the cases defined above, in the absence of
   Transfer-Encoding, an origin server SHOULD send a Content-Length
   header field when the payload body size is known prior to sending the
   complete header section.  This will allow downstream recipients to
   measure transfer progress, know when a received message is complete,
   and potentially reuse the connection for additional requests.

   Any Content-Length field value greater than or equal to zero is
   valid.  Since there is no predefined limit to the length of a
   payload, a recipient MUST anticipate potentially large decimal
   numerals and prevent parsing errors due to integer conversion
   overflows (&lt;a href=&quot;#section-9.3&quot;&gt;Section 9.3&lt;/a&gt;).

   If a message is received that has multiple Content-Length header
   fields with field-values consisting of the same decimal value, or a
   single Content-Length header field with a field value containing a
   list of identical decimal values (e.g., &quot;Content-Length: 42, 42&quot;),
   indicating that duplicate Content-Length header fields have been
   generated or combined by an upstream message processor, then the
   recipient MUST either reject the message as invalid or replace the
   duplicated field-values with a single valid Content-Length field
   containing that decimal value prior to determining the message body
   length or forwarding the message.

      Note: HTTP's use of Content-Length for message framing differs
      significantly from the same field's use in MIME, where it is an
      optional field used only within the &quot;message/external-body&quot;
      media-type.</source>
          <target state="translated">메시지에 Transfer-Encoding 헤더 필드가없는 경우 Content-Length 헤더 필드는 잠재적 페이로드 본문에 예상 크기를 10 진수 10 진수로 제공 할 수 있습니다. 페이로드 본문을 포함하는 메시지의 경우 Content-Length 필드 값은 본문 (및 메시지)이 끝나는 위치를 결정하는 데 필요한 프레임 정보를 제공합니다. 페이로드 본문이 포함되지 않은 메시지의 경우 Content-Length는 선택한 표현의 크기를 나타냅니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-3&quot;&gt;[RFC7231]의 3 절).&lt;/a&gt;). Content-Length = 1 * DIGIT 예는 Content-Length입니다. 3495 발신자는 Transfer-Encoding 헤더 필드가 포함 된 메시지에서 Content-Length 헤더 필드를 보내면 안됩니다. 사용자 에이전트는 전송 인코딩이 전송되지 않고 요청 방법이 동봉 된 페이로드 본문에 대한 의미를 정의 할 때 요청 메시지에 Content-Length를 전송해야합니다. 예를 들어, Content-Length 헤더 필드는 값이 0 (빈 페이로드 본문을 나타냄) 인 경우에도 일반적으로 POST 요청에서 전송됩니다. 요청 메시지에 페이로드 본문이없고 메소드 시맨틱이 그러한 본문을 예상하지 않는 경우 사용자 에이전트는 Content-Length 헤더 필드를 보내지 않아야합니다. 서버는 HEAD 요청에 대한 응답으로 Content-Length 헤더 필드를 보낼 수있다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.2&quot;&gt;[RFC7231]의 4.3.2 절)&lt;/a&gt;); 동일한 요청이 GET 메소드를 사용한 경우 필드 값이 응답의 페이로드 본문에서 전송 된 10 진수의 10 진수와 같지 않은 한 서버는 이러한 응답으로 Content-Length를 보내서는 안됩니다. 서버는 조건부 GET 요청에 304 (Not Modified) 응답으로 Content-Length 헤더 필드를 전송할 수있다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-4.1&quot;&gt;[RFC7232]의 4.1 절)&lt;/a&gt;); 필드 값이 동일한 요청에 대한 200 (OK) 응답의 페이로드 본문에서 전송 된 10 진수의 10 진수와 같은 경우가 아니면 서버는 이러한 응답으로 Content-Length를 보내서는 안됩니다. 서버는 상태 코드가 1xx (Informational) 또는 204 (No Content) 인 응답으로 Content-Length 헤더 필드를 보내서는 안됩니다. 서버는 CONNECT 요청에 대해 2xx (성공) 응답의 Content-Length 헤더 필드를 보내서는 안됩니다 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.3.6&quot;&gt;[RFC7231]의 4.3.6 절).&lt;/a&gt;). 위에서 정의한 경우를 제외하고, Transfer-Encoding이 없으면 오리진 서버는 전체 헤더 섹션을 보내기 전에 페이로드 본문 크기를 알 때 Content-Length 헤더 필드를 보내야합니다 (SHOULD). 이를 통해 다운 스트림 수신자는 전송 진행률을 측정하고 수신 된 메시지가 완료된시기를 알고 추가 요청에 연결을 재사용 할 수 있습니다. 0보다 크거나 같은 모든 Content-Length 필드 값이 유효합니다. 페이로드의 길이에 대한 사전 정의 된 제한이 없으므로 수신자는 잠재적으로 큰 십진수를 예상하고 정수 변환 오버플로로 인한 구문 분석 오류를 방지해야합니다 ( &lt;a href=&quot;#section-9.3&quot;&gt;섹션 9.3).&lt;/a&gt;). 동일한 10 진수 값으로 구성된 필드 값이있는 여러 Content-Length 헤더 필드가있는 메시지가 수신되거나 동일한 10 진수 값 목록이 포함 된 필드 값이있는 단일 Content-Length 헤더 필드 (예 : &quot;Content-Length : 42, 42 &quot;), 중복 된 Content-Length 헤더 필드가 업스트림 메시지 프로세서에 의해 생성 또는 결합되었음을 나타내면 수신자는 메시지를 유효하지 않은 것으로 거부하거나 복제 된 필드 값을 유효한 단일 Content-Length로 대체해야합니다. 메시지 본문 길이를 결정하거나 메시지를 전달하기 전에 해당 10 진수 값을 포함하는 필드. 참고 : 메시지 프레이밍에 HTTP의 Content-Length 사용은 MIME에서의 동일한 필드 사용과 크게 다릅니다.여기서 &quot;message / external-body&quot;미디어 유형 내에서만 사용되는 선택적 필드입니다.</target>
        </trans-unit>
        <trans-unit id="8a3283af6dcc2661109dbb11d4827ac5e1d71582" translate="yes" xml:space="preserve">
          <source>When a message includes a message body encoded with the chunked
   transfer coding and the sender desires to send metadata in the form
   of trailer fields at the end of the message, the sender SHOULD
   generate a Trailer header field before the message body to indicate
   which fields will be present in the trailers.  This allows the
   recipient to prepare for receipt of that metadata before it starts
   processing the body, which is useful if the message is being streamed
   and the recipient wishes to confirm an integrity check on the fly.

     Trailer = 1#field-name</source>
          <target state="translated">메시지가 청크 된 전송 코딩으로 인코딩 된 메시지 본문을 포함하고 발신자가 메시지의 끝에서 트레일러 필드 형태로 메타 데이터를 전송하고자하는 경우, 발신자는 메시지 본문 전에 트레일러 헤더 필드를 생성하여 어떤 필드가 트레일러에 있어야합니다. 이를 통해 수신자는 본문 처리를 시작하기 전에 해당 메타 데이터의 수신을 준비 할 수 있습니다. 이는 메시지가 스트리밍되고 수신자가 무결성 검사를 즉시 확인하려는 경우에 유용합니다. 트레일러 = 1 # 필드 이름</target>
        </trans-unit>
        <trans-unit id="b235fc2e260e87a056455dbda3fa587e723e993d" translate="yes" xml:space="preserve">
          <source>When a precondition header is &lt;strong&gt;not matching&lt;/strong&gt; the server side state, the response should be &lt;a href=&quot;412&quot;&gt;&lt;code&gt;412&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Precondition Failed&lt;/code&gt;.</source>
          <target state="translated">전제 조건 헤더가 서버 측 상태와 &lt;strong&gt;일치하지 않으면&lt;/strong&gt; 응답은 &lt;a href=&quot;412&quot;&gt; &lt;code&gt;412&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Precondition Failed&lt;/code&gt; 여야합니다 .</target>
        </trans-unit>
        <trans-unit id="186bf5363add379b2ba012f5766a038907e51aa8" translate="yes" xml:space="preserve">
          <source>When a request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &quot;&lt;code&gt;include&lt;/code&gt;&quot;, browsers will only expose the response to frontend JavaScript code if the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">요청의 자격 증명 모드 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; )가 &quot; &lt;code&gt;include&lt;/code&gt; &quot;인 경우 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 인 경우 브라우저는 프론트 엔드 JavaScript 코드에만 응답을 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="7333e1d0d6993ac9df1cdfe6fae92b4f7648978f" translate="yes" xml:space="preserve">
          <source>When a request's credentials mode (&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt;&lt;code&gt;Request.credentials&lt;/code&gt;&lt;/a&gt;) is &lt;code&gt;include&lt;/code&gt;, browsers will only expose the response to frontend JavaScript code if the &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">요청의 자격 증명 모드 ( &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/credentials&quot;&gt; &lt;code&gt;Request.credentials&lt;/code&gt; &lt;/a&gt; )가 &lt;code&gt;include&lt;/code&gt; 인 경우 브라우저는 &lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt; 값이 &lt;code&gt;true&lt;/code&gt; 인 경우에만 프런트 엔드 JavaScript 코드에 대한 응답을 노출 합니다 .</target>
        </trans-unit>
        <trans-unit id="6dac549244c018dee53a4d208ca6b3e0f5dca724" translate="yes" xml:space="preserve">
          <source>When a script is requested, like via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, some browsers use specific values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML 요소 를 통해와 같이 스크립트가 요청 되면 일부 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="f12d11c8f8587f228e72fd8c89532b1324f82f4a" translate="yes" xml:space="preserve">
          <source>When a site enables the &lt;code&gt;Expect-CT&lt;/code&gt; header, they are requesting that the browser check that any certificate for that site appears in &lt;strong&gt;&lt;a href=&quot;https://www.certificate-transparency.org/known-logs&quot;&gt;public CT logs&lt;/a&gt;&lt;/strong&gt;.</source>
          <target state="translated">사이트에서 &lt;code&gt;Expect-CT&lt;/code&gt; 헤더를 활성화하면 브라우저는 해당 사이트에 대한 인증서가 &lt;strong&gt;&lt;a href=&quot;https://www.certificate-transparency.org/known-logs&quot;&gt;공개 CT 로그에&lt;/a&gt;&lt;/strong&gt; 나타나는지 브라우저에 확인하도록 요청합니다 .</target>
        </trans-unit>
        <trans-unit id="563752944fa30baedb9fb7c9665ec29647004c60" translate="yes" xml:space="preserve">
          <source>When a stream is removed from the dependency tree, its dependencies
   can be moved to become dependent on the parent of the closed stream.
   The weights of new dependencies are recalculated by distributing the
   weight of the dependency of the closed stream proportionally based on
   the weights of its dependencies.

   Streams that are removed from the dependency tree cause some
   prioritization information to be lost.  Resources are shared between
   streams with the same parent stream, which means that if a stream in
   that set closes or becomes blocked, any spare capacity allocated to a
   stream is distributed to the immediate neighbors of the stream.
   However, if the common dependency is removed from the tree, those
   streams share resources with streams at the next highest level.

   For example, assume streams A and B share a parent, and streams C and
   D both depend on stream A.  Prior to the removal of stream A, if
   streams A and D are unable to proceed, then stream C receives all the
   resources dedicated to stream A.  If stream A is removed from the
   tree, the weight of stream A is divided between streams C and D.  If
   stream D is still unable to proceed, this results in stream C
   receiving a reduced proportion of resources.  For equal starting
   weights, C receives one third, rather than one half, of available
   resources.

   It is possible for a stream to become closed while prioritization
   information that creates a dependency on that stream is in transit.
   If a stream identified in a dependency has no associated priority
   information, then the dependent stream is instead assigned a default
   priority (&lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;).  This potentially creates suboptimal
   prioritization, since the stream could be given a priority that is
   different from what is intended. 

   To avoid these problems, an endpoint SHOULD retain stream
   prioritization state for a period after streams become closed.  The
   longer state is retained, the lower the chance that streams are
   assigned incorrect or default priority values.

   Similarly, streams that are in the &quot;idle&quot; state can be assigned
   priority or become a parent of other streams.  This allows for the
   creation of a grouping node in the dependency tree, which enables
   more flexible expressions of priority.  Idle streams begin with a
   default priority (&lt;a href=&quot;#section-5.3.5&quot;&gt;Section 5.3.5&lt;/a&gt;).

   The retention of priority information for streams that are not
   counted toward the limit set by SETTINGS_MAX_CONCURRENT_STREAMS could
   create a large state burden for an endpoint.  Therefore, the amount
   of prioritization state that is retained MAY be limited.

   The amount of additional state an endpoint maintains for
   prioritization could be dependent on load; under high load,
   prioritization state can be discarded to limit resource commitments.
   In extreme cases, an endpoint could even discard prioritization state
   for active or reserved streams.  If a limit is applied, endpoints
   SHOULD maintain state for at least as many streams as allowed by
   their setting for SETTINGS_MAX_CONCURRENT_STREAMS.  Implementations
   SHOULD also attempt to retain state for streams that are in active
   use in the priority tree.

   If it has retained enough state to do so, an endpoint receiving a
   PRIORITY frame that changes the priority of a closed stream SHOULD
   alter the dependencies of the streams that depend on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa74c170f2d19667b559eacecf88a8660b338292" translate="yes" xml:space="preserve">
          <source>When a user opened a page using a &lt;code&gt;file:///&lt;/code&gt; URI in Firefox 67 and earlier, the origin of the page was defined as the directory from which the page was opened. Resources in the same directory and its subdirectories were treated as having the same origin for purposes of the CORS same-origin rule.</source>
          <target state="translated">사용자 가 Firefox 67 및 이전 버전에서 &lt;code&gt;file:///&lt;/code&gt; URI를 사용하여 페이지를 열었을 때 페이지 의 출처는 페이지가 열린 디렉토리로 정의되었습니다. CORS 동일 출처 규칙에 따라 동일한 디렉토리 및 하위 디렉토리에있는 리소스는 동일한 출처를 갖는 것으로 취급되었습니다.</target>
        </trans-unit>
        <trans-unit id="d36ab7ed245bcd63c35d075bb14e0ef75e55e069" translate="yes" xml:space="preserve">
          <source>When a validation request is made, the server can either ignore the validation request and response with a normal &lt;a href=&quot;status/200&quot;&gt;&lt;code&gt;200&lt;/code&gt;&lt;/a&gt;&lt;code&gt;OK&lt;/code&gt;, or it can return &lt;a href=&quot;status/304&quot;&gt;&lt;code&gt;304&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Not Modified&lt;/code&gt; (with an empty body) to instruct the browser to use its cached copy. The latter response can also include headers that update the expiration time of the cached document.</source>
          <target state="translated">유효성 검사 요청이 이루어지면 서버는 유효성 검사 요청 및 정상적인 &lt;a href=&quot;status/200&quot;&gt; &lt;code&gt;200&lt;/code&gt; &lt;/a&gt; &lt;code&gt;OK&lt;/code&gt; 응답을 무시 하거나 &lt;a href=&quot;status/304&quot;&gt; &lt;code&gt;304&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Not Modified&lt;/code&gt; (빈 본문 포함)를 반환 하여 브라우저에 캐시 된 복사본을 사용하도록 지시 할 수 있습니다. 후자의 응답은 캐시 된 문서의 만료 시간을 업데이트하는 헤더를 포함 할 수도 있습니다.</target>
        </trans-unit>
        <trans-unit id="47e19190be60527564cf5d0364edee22a0103f29" translate="yes" xml:space="preserve">
          <source>When a video is requested, via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt;&lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video&quot;&gt; &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML 요소 를 통해 비디오가 요청 되면 대부분의 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="63eed939b8f0aa6e66825ee3882a3480a6666111" translate="yes" xml:space="preserve">
          <source>When adding such a tag, you serve the same content for both domains, telling search engines which URL is canonical. In the previous example, &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; would serve the same content as &lt;code&gt;http://example.org/whaddup&lt;/code&gt;, but with an additional &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element in the head:</source>
          <target state="translated">이러한 태그를 추가하면 두 도메인 모두에 동일한 콘텐츠를 제공하여 어떤 URL이 표준 URL인지 검색 엔진에 알려줍니다. 이전 예에서 &lt;code&gt;http://www.example.org/whaddup&lt;/code&gt; 은 &lt;code&gt;http://example.org/whaddup&lt;/code&gt; 과 동일한 컨텐츠를 제공 하지만 헤드에 추가 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소가 있습니다.</target>
        </trans-unit>
        <trans-unit id="59d5afaa19c72d09eeef4b2419754f02979a4b23" translate="yes" xml:space="preserve">
          <source>When an Expires date is set, the deadline is relative to the &lt;em&gt;client&lt;/em&gt; the cookie is being set on, not the server.</source>
          <target state="translated">만료 날짜가 설정된 경우 기한은 서버가 아니라 쿠키가 설정된 &lt;em&gt;클라이언트에&lt;/em&gt; 상대적 입니다.</target>
        </trans-unit>
        <trans-unit id="4c4bb5659f583a468f69b6efcf9b5dc0370b8db9" translate="yes" xml:space="preserve">
          <source>When an HTTP 206 (Partial Content) response message includes the
   content of multiple ranges (a response to a request for multiple
   non-overlapping ranges), these are transmitted as a multipart
   message-body. The media type for this purpose is called
   &quot;multipart/byteranges&quot;.

   The multipart/byteranges media type includes two or more parts, each
   with its own Content-Type and Content-Range fields. The required
   boundary parameter specifies the boundary string used to separate
   each body-part.

       Media Type name:         multipart
       Media subtype name:      byteranges
       Required parameters:     boundary
       Optional parameters:     none
       Encoding considerations: only &quot;7bit&quot;, &quot;8bit&quot;, or &quot;binary&quot; are
                                permitted
       Security considerations: none


   For example:

   HTTP/1.1 206 Partial Content
   Date: Wed, 15 Nov 1995 06:25:24 GMT
   Last-Modified: Wed, 15 Nov 1995 04:58:08 GMT
   Content-type: multipart/byteranges; boundary=THIS_STRING_SEPARATES

   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 500-999/8000

   ...the first range
   --THIS_STRING_SEPARATES
   Content-type: application/pdf
   Content-range: bytes 7000-7999/8000

   ...the second range
   --THIS_STRING_SEPARATES--

      Notes:

      1) Additional CRLFs may precede the first boundary string in the
         entity. 

      2) Although &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; [&lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt;] permits the boundary string to be
         quoted, some existing implementations handle a quoted boundary
         string incorrectly.

      3) A number of browsers and servers were coded to an early draft
         of the byteranges specification to use a media type of
         multipart/x-byteranges, which is almost, but not quite
         compatible with the version documented in HTTP/1.1.</source>
          <target state="translated">HTTP (206) (부분 컨텐츠) 응답 메시지가 다중 범위의 컨텐츠 (중복되지 않은 다중 범위에 대한 요청에 대한 응답)를 포함하는 경우, 이들은 다중 파트 메시지 본문으로 전송된다. 이 목적을위한 매체 유형을 &quot;멀티 파트 / 바이트 범위&quot;라고합니다. multipart / byteranges 미디어 유형에는 각각 고유 한 Content-Type 및 Content-Range 필드가있는 둘 이상의 부분이 포함됩니다. 필수 경계 매개 변수는 각 본문 부분을 분리하는 데 사용되는 경계 문자열을 지정합니다. 미디어 유형 이름 : multipart 미디어 하위 유형 이름 : 바이트 범위 필수 매개 변수 : 경계 선택적 매개 변수 : 없음 인코딩 고려 사항 : &quot;7bit&quot;, &quot;8bit&quot;또는 &quot;binary&quot;만 허용됩니다. 보안 고려 사항 :none 예 : HTTP / 1.1 206 부분 컨텐츠 날짜 : 1995 년 11 월 15 일 수요일 06:25:24 GMT 최종 수정 : 1995 년 11 월 15 일 수요일 04:58:08 GMT 컨텐츠 유형 : multipart / byteranges; boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 참고 : 1) 추가 CRLF가 엔티티의 첫 번째 경계 문자열 앞에 올 수 있습니다. 2) 그래도boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 참고 : 1) 추가 CRLF가 엔티티의 첫 번째 경계 문자열 앞에 올 수 있습니다. 2) 그래도boundary = THIS_STRING_SEPARATES --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 500-999 / 8000 ... 첫 번째 범위 --THIS_STRING_SEPARATES 컨텐츠 유형 : application / pdf 컨텐츠 범위 : bytes 7000-7999 / 8000. .. 두 번째 범위 --THIS_STRING_SEPARATES-- 참고 : 1) 추가 CRLF가 엔티티의 첫 번째 경계 문자열 앞에 올 수 있습니다. 2) 그래도&lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; [ &lt;a href=&quot;#ref-40&quot;&gt;40&lt;/a&gt; ]은 경계 문자열을 인용 할 수있게하며, 일부 기존 구현에서는 인용 된 경계 문자열을 잘못 처리합니다. 3) 여러 종류의 브라우저와 서버가 multipart / x-byteranges의 미디어 유형을 사용하기 위해 바이트 범위 사양의 초기 초안으로 코딩되었으며, HTTP / 1.1에 문서화 된 버전과 거의 호환되지는 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6e46412dc97b809e407f096ca2dc0afe605c695" translate="yes" xml:space="preserve">
          <source>When an HTTP/2 connection is first established, new streams are
   created with an initial flow-control window size of 65,535 octets.
   The connection flow-control window is also 65,535 octets.  Both
   endpoints can adjust the initial window size for new streams by
   including a value for SETTINGS_INITIAL_WINDOW_SIZE in the SETTINGS
   frame that forms part of the connection preface.  The connection
   flow-control window can only be changed using WINDOW_UPDATE frames.

   Prior to receiving a SETTINGS frame that sets a value for
   SETTINGS_INITIAL_WINDOW_SIZE, an endpoint can only use the default
   initial window size when sending flow-controlled frames.  Similarly,
   the connection flow-control window is set to the default initial
   window size until a WINDOW_UPDATE frame is received.

   In addition to changing the flow-control window for streams that are
   not yet active, a SETTINGS frame can alter the initial flow-control
   window size for streams with active flow-control windows (that is,
   streams in the &quot;open&quot; or &quot;half-closed (remote)&quot; state).  When the
   value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust
   the size of all stream flow-control windows that it maintains by the
   difference between the new value and the old value.

   A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available
   space in a flow-control window to become negative.  A sender MUST
   track the negative flow-control window and MUST NOT send new flow-
   controlled frames until it receives WINDOW_UPDATE frames that cause
   the flow-control window to become positive.

   For example, if the client sends 60 KB immediately on connection
   establishment and the server sets the initial window size to be 16
   KB, the client will recalculate the available flow-control window to 

   be -44 KB on receipt of the SETTINGS frame.  The client retains a
   negative flow-control window until WINDOW_UPDATE frames restore the
   window to being positive, after which the client can resume sending.

   A SETTINGS frame cannot alter the connection flow-control window.

   An endpoint MUST treat a change to SETTINGS_INITIAL_WINDOW_SIZE that
   causes any flow-control window to exceed the maximum size as a
   connection error (&lt;a href=&quot;#section-5.4.1&quot;&gt;Section 5.4.1&lt;/a&gt;) of type FLOW_CONTROL_ERROR.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed84582108607d5a8e0796d0b676929516566c33" translate="yes" xml:space="preserve">
          <source>When an audio file is requested, like via the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt;&lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt;&lt;/a&gt; HTML element, most browsers use specific values.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/audio&quot;&gt; &lt;code&gt;&amp;lt;audio&amp;gt;&lt;/code&gt; &lt;/a&gt; HTML 요소 를 통해와 같이 오디오 파일이 요청 되면 대부분의 브라우저는 특정 값을 사용합니다.</target>
        </trans-unit>
        <trans-unit id="9efbf183df3ebd070a5d9eb93570e9456b19792e" translate="yes" xml:space="preserve">
          <source>When an entity-body is included with a message, the data type of that
   body is determined via the header fields Content-Type and Content-
   Encoding. These define a two-layer, ordered encoding model:

       entity-body := Content-Encoding( Content-Type( data ) )

   Content-Type specifies the media type of the underlying data.
   Content-Encoding may be used to indicate any additional content
   codings applied to the data, usually for the purpose of data
   compression, that are a property of the requested resource. There is
   no default encoding.

   Any HTTP/1.1 message containing an entity-body SHOULD include a
   Content-Type header field defining the media type of that body. If
   and only if the media type is not given by a Content-Type field, the
   recipient MAY attempt to guess the media type via inspection of its
   content and/or the name extension(s) of the URI used to identify the
   resource. If the media type remains unknown, the recipient SHOULD
   treat it as type &quot;application/octet-stream&quot;.</source>
          <target state="translated">엔티티 본문이 메시지에 포함 된 경우 해당 본문의 데이터 유형은 헤더 필드 Content-Type 및 Content-Encoding을 통해 결정됩니다. 이들은 2 계층 순서의 인코딩 모델을 정의합니다. entity-body : = Content-Encoding (Content-Type (data)) Content-Type은 기본 데이터의 미디어 유형을 지정합니다. 콘텐츠 인코딩은 일반적으로 데이터 압축을 위해 요청 된 자원의 속성 인 데이터에 적용된 임의의 추가 콘텐츠 코딩을 나타내는 데 사용될 수있다. 기본 인코딩이 없습니다. 엔티티 본문을 포함하는 모든 HTTP / 1.1 메시지는 해당 본문의 미디어 유형을 정의하는 Content-Type 헤더 필드를 포함해야합니다 (SHOULD). 미디어 유형이 컨텐츠 유형 필드에 의해 제공되지 않은 경우에만,수신자는 그 내용 및 / 또는 자원을 식별하는데 사용 된 URI의 이름 확장자를 검사하여 매체 유형을 추측하려고 시도 할 수있다. 미디어 유형을 알 수없는 경우 수신자는이를 &quot;application / octet-stream&quot;유형으로 취급해야합니다.</target>
        </trans-unit>
        <trans-unit id="514b34eaec23c4a82ae216c4952b1601e369040b" translate="yes" xml:space="preserve">
          <source>When an expiry date is set, the time and date set is relative to the client the cookie is being set on, not the server.</source>
          <target state="translated">만료 날짜가 설정되면 시간과 날짜 설정은 서버가 아닌 쿠키가 설정된 클라이언트와 관련됩니다.</target>
        </trans-unit>
        <trans-unit id="689ec0aa3c371c99a1bb0c520e872fada7093b46" translate="yes" xml:space="preserve">
          <source>When arrows are found in the resource URL's ('-&amp;gt;'), it means that the first file loaded the next one:</source>
          <target state="translated">리소스 URL ( '-&amp;gt;')에 화살표가 있으면 첫 번째 파일이 다음 파일을로드했음을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="537cfbce765877e75dc4ddb75367470d9c1d0f61" translate="yes" xml:space="preserve">
          <source>When both the &lt;code&gt;enforce&lt;/code&gt; directive and the &lt;code&gt;report-uri&lt;/code&gt; directive are present, the configuration is referred to as an &quot;enforce-and-report&quot; configuration, signalling to the user agent both that compliance to the Certificate Transparency policy should be enforced and that violations should be reported.</source>
          <target state="translated">모두가 때 &lt;code&gt;enforce&lt;/code&gt; 지침과 &lt;code&gt;report-uri&lt;/code&gt; 지침이 존재하는 구성은 인증서 투명성 정책이 준수가 모두 적용되어야하는 사용자 에이전트에 신호,에 &quot;시행 앤 보고서&quot;를 구성이라 그 위반해야한다 보고됩니다.</target>
        </trans-unit>
        <trans-unit id="c72d9da42d5a452306e589dd697e9bc2459db237" translate="yes" xml:space="preserve">
          <source>When browsers receive a redirect, they immediately load the new URL provided in the &lt;code&gt;Location&lt;/code&gt; header. Besides the small performance hit of an additional round-trip, users rarely notice the redirection.</source>
          <target state="translated">브라우저가 리디렉션을 수신하면 즉시 &lt;code&gt;Location&lt;/code&gt; 헤더에 제공된 새 URL을로드합니다 . 추가 왕복의 작은 성능 저하 외에도 사용자는 리디렉션을 거의 알아 차리지 못합니다.</target>
        </trans-unit>
        <trans-unit id="405dbcb99df2fc12205b914cd73322e548995294" translate="yes" xml:space="preserve">
          <source>When comparing two URIs to decide if they match or not, a client
   SHOULD use a case-sensitive octet-by-octet comparison of the entire
   URIs, with these exceptions:

      - A port that is empty or not given is equivalent to the default
        port for that URI-reference;

        - Comparisons of host names MUST be case-insensitive;

        - Comparisons of scheme names MUST be case-insensitive;

        - An empty abs_path is equivalent to an abs_path of &quot;/&quot;.

   Characters other than those in the &quot;reserved&quot; and &quot;unsafe&quot; sets (see
   &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [&lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt;]) are equivalent to their &quot;&quot;%&quot; HEX HEX&quot; encoding.

   For example, the following three URIs are equivalent:

      &lt;a href=&quot;http://abc.com:80/~smith/home.html&quot;&gt;http://abc.com:80/~smith/home.html&lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7Esmith/home.html&quot;&gt;http://ABC.com/%7Esmith/home.html&lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7esmith/home.html&quot;&gt;http://ABC.com:/%7esmith/home.html&lt;/a&gt;</source>
          <target state="translated">두 URI를 비교하여 일치하는지 여부를 결정하는 경우 클라이언트는 다음을 제외하고 전체 URI의 대소 문자 구분 8 진수 비교를 사용해야합니다.-비어 있거나 제공되지 않은 포트는 기본 포트와 같습니다. 그 URI 참조를 위해; -호스트 이름 비교는 대소 문자를 구분하지 않아야합니다. -체계 명 비교는 대소 문자를 구분하지 않아야한다. -빈 abs_path는 &quot;/&quot;의 abs_path와 같습니다. &quot;예약 된&quot;및 &quot;안전하지 않은&quot;세트 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt; [ &lt;a href=&quot;#ref-42&quot;&gt;42&lt;/a&gt; ] 참조) 이외의 문자 는 &quot;&quot;% &quot;HEX HEX&quot;인코딩과 같습니다. 예를 들어 &lt;a href=&quot;http://abc.com:80/~smith/home.html&quot;&gt;http://abc.com:80/~smith/home.html &lt;/a&gt;&lt;a href=&quot;http://ABC.com/%7Esmith/home.html&quot;&gt;http : // ABC의&lt;/a&gt; 세 가지 URI가 동일 합니다.com / % 7Esmith / home.html&lt;a href=&quot;http://ABC.com/%7esmith/home.html&quot;&gt;http://ABC.com:/%7esmith/home.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17c62a909cae76968be588e261c2cc6fcbe524c4" translate="yes" xml:space="preserve">
          <source>When considering the design of HTTP, it is easy to fall into a trap
   of thinking that all user agents are general-purpose browsers and all
   origin servers are large public websites.  That is not the case in
   practice.  Common HTTP user agents include household appliances,
   stereos, scales, firmware update scripts, command-line programs,
   mobile apps, and communication devices in a multitude of shapes and
   sizes.  Likewise, common HTTP origin servers include home automation 

   units, configurable networking components, office machines,
   autonomous robots, news feeds, traffic cameras, ad selectors, and
   video-delivery platforms.

   The term &quot;user agent&quot; does not imply that there is a human user
   directly interacting with the software agent at the time of a
   request.  In many cases, a user agent is installed or configured to
   run in the background and save its results for later inspection (or
   save only a subset of those results that might be interesting or
   erroneous).  Spiders, for example, are typically given a start URI
   and configured to follow certain behavior while crawling the Web as a
   hypertext graph.

   The implementation diversity of HTTP means that not all user agents
   can make interactive suggestions to their user or provide adequate
   warning for security or privacy concerns.  In the few cases where
   this specification requires reporting of errors to the user, it is
   acceptable for such reporting to only be observable in an error
   console or log file.  Likewise, requirements that an automated action
   be confirmed by the user before proceeding might be met via advance
   configuration choices, run-time options, or simple avoidance of the
   unsafe action; confirmation does not imply any specific user
   interface or interruption of normal processing if the user has
   already made that choice.</source>
          <target state="translated">HTTP 디자인을 고려할 때 모든 사용자 에이전트가 범용 브라우저이고 모든 오리진 서버가 대규모 공용 웹 사이트라는 생각에 쉽게 빠질 수 있습니다. 실제로는 그렇지 않습니다. 일반적인 HTTP 사용자 에이전트에는 다양한 모양과 크기의 가전 제품, 스테레오, 스케일, 펌웨어 업데이트 스크립트, 명령 줄 프로그램, 모바일 앱 및 통신 장치가 포함됩니다. 마찬가지로 일반적인 HTTP 오리진 서버에는 홈 자동화 장치, 구성 가능한 네트워킹 구성 요소, 사무 기기, 자율 로봇, 뉴스 피드, 교통 카메라, 광고 선택기 및 비디오 배달 플랫폼이 포함됩니다. &quot;사용자 에이전트&quot;라는 용어는 요청시 소프트웨어 사용자와 직접 상호 작용하는 휴먼 사용자가 있음을 의미하지 않습니다. 많은 경우에,사용자 에이전트는 백그라운드에서 실행되고 나중에 검사하기 위해 결과를 저장하거나 흥미 롭거나 잘못된 결과의 하위 집합 만 저장하도록 설치 또는 구성됩니다. 예를 들어 스파이더에는 일반적으로 시작 URI가 제공되며 웹을 하이퍼 텍스트 그래프로 크롤링하는 동안 특정 동작을 따르도록 구성됩니다. HTTP의 구현 다양성은 모든 사용자 에이전트가 사용자에게 대화식 제안을하거나 보안 또는 개인 정보 보호 문제에 대해 적절한 경고를 제공 할 수있는 것은 아닙니다. 이 사양에서 사용자에게 오류를보고해야하는 경우가 거의 없지만 이러한보고는 오류 콘솔 또는 로그 파일에서만 관찰 할 수 있습니다. 마찬가지로,진행하기 전에 사용자가 자동 ​​조치를 확인해야하는 요구 사항은 사전 구성 선택, 런타임 옵션 또는 안전하지 않은 조치의 간단한 회피를 통해 충족 될 수 있습니다. 사용자가 이미 선택한 경우 확인은 특정 사용자 인터페이스 또는 정상적인 처리 중단을 의미하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="a827c5b68b1342f6b9dfe8a6f1bbe7a2e6832493" translate="yes" xml:space="preserve">
          <source>When considering using the user agent string to detect which browser is being used, your first step is to try to avoid it if possible. Start by trying to identify &lt;strong&gt;why&lt;/strong&gt; you want to do it.</source>
          <target state="translated">사용중인 브라우저를 감지하기 위해 사용자 에이전트 문자열 사용을 고려할 때 첫 번째 단계는 가능한 경우이를 피하는 것입니다. &lt;strong&gt;왜&lt;/strong&gt; 당신이 그것을 원하는지 &lt;strong&gt;알아&lt;/strong&gt; 내려고 노력 하십시오.</target>
        </trans-unit>
        <trans-unit id="363ec37ef9e1fc22a7e69c6d6b95891d8282b35a" translate="yes" xml:space="preserve">
          <source>When content negotiation preferences are sent by the user agent in a
   request to encourage an algorithm located at the server to select the
   preferred representation, it is called proactive negotiation (a.k.a.,
   server-driven negotiation).  Selection is based on the available
   representations for a response (the dimensions over which it might
   vary, such as language, content-coding, etc.) compared to various
   information supplied in the request, including both the explicit
   negotiation fields of &lt;a href=&quot;#section-5.3&quot;&gt;Section 5.3&lt;/a&gt; and implicit characteristics, such
   as the client's network address or parts of the User-Agent field.

   Proactive negotiation is advantageous when the algorithm for
   selecting from among the available representations is difficult to
   describe to a user agent, or when the server desires to send its
   &quot;best guess&quot; to the user agent along with the first response (hoping
   to avoid the round trip delay of a subsequent request if the &quot;best
   guess&quot; is good enough for the user).  In order to improve the
   server's guess, a user agent MAY send request header fields that
   describe its preferences.

   Proactive negotiation has serious disadvantages:

   o  It is impossible for the server to accurately determine what might
      be &quot;best&quot; for any given user, since that would require complete
      knowledge of both the capabilities of the user agent and the
      intended use for the response (e.g., does the user want to view it
      on screen or print it on paper?);

   o  Having the user agent describe its capabilities in every request
      can be both very inefficient (given that only a small percentage
      of responses have multiple representations) and a potential risk
      to the user's privacy;

   o  It complicates the implementation of an origin server and the
      algorithms for generating responses to a request; and, 

   o  It limits the reusability of responses for shared caching.

   A user agent cannot rely on proactive negotiation preferences being
   consistently honored, since the origin server might not implement
   proactive negotiation for the requested resource or might decide that
   sending a response that doesn't conform to the user agent's
   preferences is better than sending a 406 (Not Acceptable) response.

   A Vary header field (&lt;a href=&quot;#section-7.1.4&quot;&gt;Section 7.1.4&lt;/a&gt;) is often sent in a response
   subject to proactive negotiation to indicate what parts of the
   request information were used in the selection algorithm.</source>
          <target state="translated">서버에 위치한 알고리즘이 선호 표현을 선택하도록 요청하기 위해 사용자 에이전트가 컨텐츠 협상 환경 설정을 전송하는 경우이를 사전 협상 (일명 서버 중심 협상)이라고합니다. 선택은 &lt;a href=&quot;#section-5.3&quot;&gt;섹션 5.3&lt;/a&gt; 의 명시 적 협상 필드를 포함하여 요청에 제공된 다양한 정보와 비교하여 응답에 사용 가능한 표현 (언어, 컨텐츠 코딩 등의 다양한 차원)을 기반으로합니다.및 클라이언트의 네트워크 주소 또는 User-Agent 필드의 일부와 같은 암시 적 특성. 사용 가능한 표현 중에서 선택하는 알고리즘이 사용자 에이전트에 설명하기 어렵거나 서버가 첫 번째 응답과 함께 &quot;최상의 추측&quot;을 사용자 에이전트에 보내려고 할 때 사전 협상이 유리합니다 (라운드를 피하기 위해 호핑). &quot;최상의 추측&quot;이 사용자에게 충분한 경우 후속 요청의 트립 지연). 서버의 추측을 향상시키기 위해 사용자 에이전트는 환경 설정을 설명하는 요청 헤더 필드를 보낼 수 있습니다. 사전 협상에는 다음과 같은 심각한 단점이 있습니다. o 서버가 특정 사용자에게 &quot;최상의&quot;항목을 정확하게 결정하는 것은 불가능합니다.왜냐하면 사용자 에이전트의 기능과 응답에 의도 된 용도에 대한 완전한 지식이 필요하기 때문입니다 (예 : 사용자가 화면에서 보거나 종이에 인쇄하겠습니까?). o 모든 요청에서 사용자 에이전트가 자신의 기능을 설명하도록하는 것은 매우 비효율적 일 수 있습니다 (작은 비율의 응답 만 여러 가지 표현으로 표시됨) 및 사용자 개인 정보에 대한 잠재적 위험. o 오리진 서버의 구현과 요청에 대한 응답을 생성하는 알고리즘을 복잡하게합니다. 그리고 o 공유 캐싱에 대한 응답의 재사용 성을 제한합니다. 사용자 에이전트는 사전 협상 기본 설정이 지속적으로 존중되는 것에 의존 할 수 없습니다.오리진 서버가 요청 된 자원에 대한 사전 협상을 구현하지 않거나 사용자 에이전트의 환경 설정에 맞지 않는 응답을 보내는 것이 406 (Not Acceptable) 응답을 보내는 것보다 낫다고 결정할 수 있기 때문입니다. Vary 헤더 필드 (&lt;a href=&quot;#section-7.1.4&quot;&gt;섹션 7.1.4&lt;/a&gt; )는 종종 요청 알고리즘의 어느 부분이 선택 알고리즘에 사용되었는지를 나타 내기 위해 사전 협상을 거쳐 응답으로 전송된다.</target>
        </trans-unit>
        <trans-unit id="6e8b863a8325429fa580715d5e011bccf6680ef8" translate="yes" xml:space="preserve">
          <source>When generating the hash, don't include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace.</source>
          <target state="translated">해시를 생성 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그를 포함하지 말고 선행 또는 후행 공백을 포함하여 대문자 및 공백 문제를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="3f48bce4871048870c1db54917c2fa532f74b23b" translate="yes" xml:space="preserve">
          <source>When generating the hash, don't include the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; tags and note that capitalization and whitespace matter, including leading or trailing whitespace.</source>
          <target state="translated">해시를 생성 할 때 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 태그를 포함하지 말고 선행 또는 후행 공백을 포함하여 대문자 및 공백 문제를 참고하십시오.</target>
        </trans-unit>
        <trans-unit id="9503f3849e836b443578c208529989db300450fe" translate="yes" xml:space="preserve">
          <source>When it is necessary to express semantics for a response that are not
   defined by current status codes, a new status code can be registered.
   Status codes are generic; they are potentially applicable to any
   resource, not just one particular media type, kind of resource, or
   application of HTTP.  As such, it is preferred that new status codes
   be registered in a document that isn't specific to a single
   application.

   New status codes are required to fall under one of the categories
   defined in &lt;a href=&quot;#section-6&quot;&gt;Section 6&lt;/a&gt;.  To allow existing parsers to process the
   response message, new status codes cannot disallow a payload,
   although they can mandate a zero-length payload body.

   Proposals for new status codes that are not yet widely deployed ought
   to avoid allocating a specific number for the code until there is
   clear consensus that it will be registered; instead, early drafts can
   use a notation such as &quot;4NN&quot;, or &quot;3N0&quot; .. &quot;3N9&quot;, to indicate the
   class of the proposed status code(s) without consuming a number
   prematurely.

   The definition of a new status code ought to explain the request
   conditions that would cause a response containing that status code
   (e.g., combinations of request header fields and/or method(s)) along
   with any dependencies on response header fields (e.g., what fields
   are required, what fields can modify the semantics, and what header
   field semantics are further refined when used with the new status
   code).

   The definition of a new status code ought to specify whether or not
   it is cacheable.  Note that all status codes can be cached if the
   response they occur in has explicit freshness information; however,
   status codes that are defined as being cacheable are allowed to be
   cached without explicit freshness information.  Likewise, the
   definition of a status code can place constraints upon cache
   behavior.  See [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC7234&lt;/a&gt;] for more information.

   Finally, the definition of a new status code ought to indicate
   whether the payload has any implied association with an identified
   resource (&lt;a href=&quot;#section-3.1.4.1&quot;&gt;Section 3.1.4.1&lt;/a&gt;).</source>
          <target state="translated">현재 상태 코드에 의해 정의되지 않은 응답에 대한 의미를 표현할 필요가있는 경우 새로운 상태 코드를 등록 할 수 있습니다. 상태 코드는 일반적입니다. 이들은 하나의 특정 미디어 유형, 종류의 리소스 또는 HTTP 응용 프로그램뿐만 아니라 모든 리소스에 적용 할 수 있습니다. 따라서 단일 응용 프로그램과 관련이없는 문서에 새 상태 코드를 등록하는 것이 좋습니다. 새로운 상태 코드는 &lt;a href=&quot;#section-6&quot;&gt;6 장에&lt;/a&gt; 정의 된 범주 중 하나에 속해야합니다.. 기존 파서가 응답 메시지를 처리 ​​할 수 ​​있도록 새 상태 코드는 길이가 0 인 페이로드 본문을 위임 할 수 있지만 페이로드를 허용하지 않습니다. 아직 널리 배포되지 않은 새로운 상태 코드에 대한 제안은 코드가 등록 될 것이라는 명확한 합의가있을 때까지 코드에 특정 번호를 할당하지 않아야합니다. 대신 초안은 &quot;4NN&quot;또는 &quot;3N0&quot;.. &quot;3N9&quot;와 같은 표기법을 사용하여 번호를 조기에 소비하지 않고 제안 된 상태 코드의 클래스를 표시 할 수 있습니다. 새로운 상태 코드의 정의는 해당 상태 코드를 포함하는 응답 (예 : 요청 헤더 필드 및 / 또는 방법의 조합)과 응답 헤더 필드에 대한 종속성 (예 : 필드는 필수입니다시맨틱을 수정할 수있는 필드 및 새 상태 코드와 함께 사용될 때 어떤 헤더 필드 시맨틱이 더 세분화되는지) 새로운 상태 코드의 정의는 캐시 가능 여부를 지정해야합니다. 응답에 명시 적 최신 정보가있는 경우 모든 상태 코드를 캐시 할 수 있습니다. 그러나 캐시 가능으로 정의 된 상태 코드는 명시 적 최신 정보없이 캐시 될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 보다 [응답에 명시 적 최신 정보가있는 경우 모든 상태 코드를 캐시 할 수 있습니다. 그러나 캐시 가능으로 정의 된 상태 코드는 명시 적 최신 정보없이 캐시 될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 보다 [응답에 명시 적 최신 정보가있는 경우 모든 상태 코드를 캐시 할 수 있습니다. 그러나 캐시 가능으로 정의 된 상태 코드는 명시 적 최신 정보없이 캐시 될 수 있습니다. 마찬가지로, 상태 코드의 정의는 캐시 동작에 제약을 둘 수 있습니다. 보다 [&lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;&lt;/a&gt;자세한 정보는 RFC7234 ]를 참조하십시오. 마지막으로, 새로운 상태 코드의 정의는 페이로드에 식별 된 자원과의 암시 적 연관이 있는지 여부를 표시해야합니다 ( &lt;a href=&quot;#section-3.1.4.1&quot;&gt;섹션 3.1.4.1&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="992ffeef665788e48dbe3069859c70bc8ca73c53" translate="yes" xml:space="preserve">
          <source>When making a request to a proxy, other than a CONNECT or server-wide
   OPTIONS request (as detailed below), a client MUST send the target
   URI in absolute-form as the request-target.

     absolute-form  = absolute-URI

   The proxy is requested to either service that request from a valid
   cache, if possible, or make the same request on the client's behalf
   to either the next inbound proxy server or directly to the origin
   server indicated by the request-target.  Requirements on such
   &quot;forwarding&quot; of messages are defined in &lt;a href=&quot;#section-5.7&quot;&gt;Section 5.7&lt;/a&gt;.

   An example absolute-form of request-line would be:

     GET http://www.example.org/pub/WWW/TheProject.html HTTP/1.1 

   To allow for transition to the absolute-form for all requests in some
   future version of HTTP, a server MUST accept the absolute-form in
   requests, even though HTTP/1.1 clients will only send them in
   requests to proxies.</source>
          <target state="translated">CONNECT 또는 서버 차원의 OPTIONS 요청 이외의 프록시에 요청을 할 때 (아래에 설명 된 바와 같이), 클라이언트는 절대로 URI를 요청 대상으로 보내야합니다. absolute-form = absolute-URI 프록시는 가능한 경우 유효한 캐시에서 요청한 서비스를 제공하거나 클라이언트를 대신하여 다음 인바운드 프록시 서버 또는 요청에 의해 표시된 원래 서버에 동일한 요청을하도록 요청됩니다. -표적. 이러한 메시지 전달에 대한 요구 사항 &lt;a href=&quot;#section-5.7&quot;&gt;은 5.7 절에&lt;/a&gt; 정의되어있다.. 요청 라인의 절대 형식의 예는 다음과 같습니다. GET http://www.example.org/pub/WWW/TheProject.html HTTP / 1.1 향후 버전의 모든 요청에 ​​대한 절대 형식으로의 전환을 허용하려면 HTTP, 1.1 클라이언트는 요청으로 프록시를 보내더라도 서버는 절대 형식의 요청을 수락해야합니다.</target>
        </trans-unit>
        <trans-unit id="5964da98a7563489c792bd7738fa111b60299bfb" translate="yes" xml:space="preserve">
          <source>When more than one conditional request header field is present in a
   request, the order in which the fields are evaluated becomes
   important.  In practice, the fields defined in this document are
   consistently implemented in a single, logical order, since &quot;lost
   update&quot; preconditions have more strict requirements than cache
   validation, a validated cache is more efficient than a partial
   response, and entity tags are presumed to be more accurate than date
   validators.

   A recipient cache or origin server MUST evaluate the request
   preconditions defined by this specification in the following order:

   1.  When recipient is the origin server and If-Match is present,
       evaluate the If-Match precondition:

       *  if true, continue to step 3

       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see &lt;a href=&quot;#section-3.1&quot;&gt;Section 3.1&lt;/a&gt;) 

   2.  When recipient is the origin server, If-Match is not present, and
       If-Unmodified-Since is present, evaluate the If-Unmodified-Since
       precondition:

       *  if true, continue to step 3

       *  if false, respond 412 (Precondition Failed) unless it can be
          determined that the state-changing request has already
          succeeded (see &lt;a href=&quot;#section-3.4&quot;&gt;Section 3.4&lt;/a&gt;)

   3.  When If-None-Match is present, evaluate the If-None-Match
       precondition:

       *  if true, continue to step 5

       *  if false for GET/HEAD, respond 304 (Not Modified)

       *  if false for other methods, respond 412 (Precondition Failed)

   4.  When the method is GET or HEAD, If-None-Match is not present, and
       If-Modified-Since is present, evaluate the If-Modified-Since
       precondition:

       *  if true, continue to step 5

       *  if false, respond 304 (Not Modified)

   5.  When the method is GET and both Range and If-Range are present,
       evaluate the If-Range precondition:

       *  if the validator matches and the Range specification is
          applicable to the selected representation, respond 206
          (Partial Content) [&lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;]

   6.  Otherwise,

       *  all conditions are met, so perform the requested action and
          respond according to its success or failure.

   Any extension to HTTP/1.1 that defines additional conditional request
   header fields ought to define its own expectations regarding the
   order for evaluating such fields in relation to those defined in this
   document and other conditionals that might be found in practice.</source>
          <target state="translated">요청에 둘 이상의 조건부 요청 헤더 필드가있는 경우 필드 평가 순서가 중요해집니다. 실제로, &quot;손실 된 업데이트&quot;전제 조건은 캐시 유효성 검증보다 엄격한 요구 사항이 있고 유효성 검증 된 캐시는 부분 응답보다 효율적이며 엔티티 태그는 다음과 같이 가정되므로이 문서에 정의 된 필드는 단일 논리 순서로 일관되게 구현됩니다. 날짜 유효성 검사기보다 정확합니다. 수신자 캐시 또는 오리진 서버는이 스펙에 의해 정의 된 요청 전제 조건을 다음 순서로 평가해야합니다. 1. 수신자가 오리진 서버이고 If-Match가있는 경우 If-Match 전제 조건을 평가하십시오. * true이면 3 단계를 계속하십시오. * 거짓 인 경우상태 변경 요청이 이미 완료되었다고 판단 할 수없는 경우 412 (사전 조건 실패)로 응답하십시오 (참조).&lt;a href=&quot;#section-3.1&quot;&gt;섹션 3.1&lt;/a&gt; ) 2. 수신자가 오리진 서버 인 경우 If-Match가없고 If-Unmodified-Since가있는 경우 If-Unmodified-Since 전제 조건을 평가하십시오. * true 인 경우 3 단계를 계속하십시오. * false 인 경우 응답하십시오. 상태 변경 요청이 이미 성공했다고 판정되지 않는 한 (412) (전제 실패) (참조 : &lt;a href=&quot;#section-3.4&quot;&gt;3.4 절&lt;/a&gt;) 3. If-None-Match가있는 경우 If-None-Match 전제 조건을 평가하십시오. * true 인 경우 5 단계를 계속하십시오. * GET / HEAD에 대해 false 인 경우 304 (수정되지 않음) * 다른 방법에 대해 false 인 경우, 응답 412 (전제 조건 실패) 4. 분석법이 GET 또는 HEAD 인 경우 If-None-Match가없고 If-Modified-Since가있는 경우 If-Modified-Since 전제 조건을 평가하십시오. * true이면 단계를 계속하십시오. 5 * false 인 경우 304 (수정되지 않음)로 응답합니다. 5. 분석법이 GET이고 범위 및 범위 범위가 모두 존재하는 경우 If-Range 전제 조건을 평가하십시오. * 유효성 검증 기가 일치하고 범위 스펙이 선택된 표시에 적용 가능한 경우 응답 206 (부분 컨텐츠) [ &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC7233&lt;/a&gt;] 6. 그렇지 않으면 * 모든 조건이 충족되므로 요청 된 조치를 수행하고 성공 또는 실패에 따라 응답하십시오. 추가 조건부 요청 헤더 필드를 정의하는 HTTP / 1.1의 확장은이 문서에 정의 된 것과 관련하여 해당 필드를 평가하는 순서 및 실제로 발견 될 수있는 다른 조건에 대한 자체 기대치를 정의해야합니다.</target>
        </trans-unit>
        <trans-unit id="012095a2ecfbd653fa333e34acf5cb049a30844a" translate="yes" xml:space="preserve">
          <source>When multiple transfer codings are acceptable, the &lt;code&gt;q&lt;/code&gt; parameter of the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;quality value&lt;/a&gt; syntax can rank codings by preference.</source>
          <target state="translated">다중 전송 코딩이 허용 될 때 , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Quality_values&quot;&gt;품질 값&lt;/a&gt; 신택스 의 &lt;code&gt;q&lt;/code&gt; 파라미터는 선호도에 따라 코딩 순위를 매길 수있다.</target>
        </trans-unit>
        <trans-unit id="f6fe88ae046c3e416533e0417c1df22db8f56bfa" translate="yes" xml:space="preserve">
          <source>When navigating through different networks of the Internet, proxy servers and HTTP tunnels are facilitating access to content on the World Wide Web. A proxy can be on the user's local computer, or anywhere between the user's computer and a destination server on the Internet. This page outlines some basics about proxies and introduces a few configuration options.</source>
          <target state="translated">인터넷의 다른 네트워크를 탐색 할 때 프록시 서버와 HTTP 터널은 World Wide Web의 콘텐츠에 대한 액세스를 용이하게합니다. 프록시는 사용자의 로컬 컴퓨터 또는 사용자의 컴퓨터와 인터넷의 대상 서버 사이에있을 수 있습니다. 이 페이지에서는 프록시에 대한 몇 가지 기본 사항을 설명하고 몇 가지 구성 옵션을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="f45873daa29905f82c21b98d3ce8067de352cd0b" translate="yes" xml:space="preserve">
          <source>When navigating through different networks of the Internet, proxy servers and HTTP tunnels are facilitating access to content on the World Wide Web. A proxy can be on the user's local computer, or anywhere between the user's computer and an destination server on the Internet. This page outlines some basics about proxies and introduces a few configuration options.</source>
          <target state="translated">인터넷의 다른 네트워크를 탐색 할 때 프록시 서버와 HTTP 터널은 월드 와이드 웹의 컨텐츠에 대한 액세스를 용이하게합니다. 프록시는 사용자의 로컬 컴퓨터에 있거나 사용자 컴퓨터와 인터넷의 대상 서버 사이에있을 수 있습니다. 이 페이지는 프록시에 대한 몇 가지 기본 사항을 설명하고 몇 가지 구성 옵션을 소개합니다.</target>
        </trans-unit>
        <trans-unit id="2cf69f0b62bc3201eb1d5247cb7d21efe9fcd7bc" translate="yes" xml:space="preserve">
          <source>When passing a string literal like to methods like: &lt;code&gt;window.setTimeout(&quot;alert(\&quot;Hello World!\&quot;);&quot;, 500);&lt;/code&gt;</source>
          <target state="translated">다음과 같은 메소드와 같은 문자열 리터럴을 전달할 때 : &lt;code&gt;window.setTimeout(&quot;alert(\&quot;Hello World!\&quot;);&quot;, 500);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2d3e1568b9d8f26b7cf9b41cc05173988e6bafcb" translate="yes" xml:space="preserve">
          <source>When people say they want &quot;browser detection&quot;, often they actually want &quot;rendering engine detection&quot;. Do you actually want to detect Firefox, as opposed to SeaMonkey, or Chrome as opposed to Chromium? Or do you actually simply want to see if the browser is using the Gecko or the WebKit rendering engine? If this is what you need, see further down the page.</source>
          <target state="translated">사람들이 &quot;브라우저 감지&quot;를 원할 때 종종 &quot;렌더링 엔진 감지&quot;를 원합니다. 실제로 SeaMonkey가 아닌 Firefox 또는 Chromium이 아닌 Chrome을 감지 하시겠습니까? 아니면 브라우저가 Gecko 또는 WebKit 렌더링 엔진을 사용하고 있는지 실제로보고 싶습니까? 이것이 필요한 것이라면, 페이지 아래쪽을 더보십시오.</target>
        </trans-unit>
        <trans-unit id="641c314e0a3e7172c6dc4519de6003467c4aa390" translate="yes" xml:space="preserve">
          <source>When performing If header processing, the definition of a matching
   state token or entity tag is as follows:

   Identifying a resource: The resource is identified by the URI along
   with the token, in tagged list production, or by the Request-URI in
   untagged list production.

   Matching entity tag: Where the entity tag matches an entity tag
   associated with the identified resource.  Servers MUST use either the
   weak or the strong comparison function defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;Section&amp;nbsp;13.3.3 of
   [RFC2616]&lt;/a&gt;.

   Matching state token: Where there is an exact match between the state
   token in the If header and any state token on the identified
   resource.  A lock state token is considered to match if the resource
   is anywhere in the scope of the lock.

   Handling unmapped URLs: For both ETags and state tokens, treat as if
   the URL identified a resource that exists but does not have the
   specified state.</source>
          <target state="translated">If 헤더 처리를 수행 할 때 일치하는 상태 토큰 또는 엔티티 태그의 정의는 다음과 같습니다. 자원 식별 : 자원은 토큰과 함께 URI, 태그가 지정된 목록 생성 또는 태그가없는 목록의 Request-URI로 식별됩니다. 생산. 일치하는 엔티티 태그 : 엔티티 태그는 식별 된 자원과 연관된 엔티티 태그와 일치합니다. 서버 &lt;a href=&quot;https://tools.ietf.org/html/rfc2616#section-13.3.3&quot;&gt;는 [RFC2616]의 13.3.3 절에&lt;/a&gt; 정의 된 약한 또는 강한 비교 기능을 사용해야합니다 .. 일치하는 상태 토큰 : If 헤더의 상태 토큰과 식별 된 자원의 모든 상태 토큰이 정확히 일치하는 경우. 리소스가 잠금 범위 내에있는 경우 잠금 상태 토큰이 일치하는 것으로 간주됩니다. 매핑되지 않은 URL 처리 : ETag 및 상태 토큰 모두 URL이 존재하지만 지정된 상태가 아닌 리소스를 식별 한 것처럼 처리합니다.</target>
        </trans-unit>
        <trans-unit id="2e596c5772c2e6ae2a45b036f02565ea11dd1152" translate="yes" xml:space="preserve">
          <source>When possible, use HTTP redirects and don't add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element redirects. If someone changes the HTTP redirects but forgets to change the HTML redirects, the redirects will no longer be identical, which could cause an infinite loop or other nightmares.</source>
          <target state="translated">가능하면 HTTP 리디렉션을 사용하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 리디렉션을 추가하지 마십시오 . 누군가 HTTP 리디렉션을 변경했지만 HTML 리디렉션을 변경하는 것을 잊은 경우 리디렉션이 더 이상 동일하지 않아 무한 루프 또는 기타 악몽이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="431409982a981ed89ff2dc5506166f45957e0a11" translate="yes" xml:space="preserve">
          <source>When possible, use HTTP redirects, and don't add &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element redirects. If someone changes the HTTP redirects and forgets to change the HTML redirects the redirects will no longer be identical, which could cause an infinite loop or other nightmares.</source>
          <target state="translated">가능하면 HTTP 리디렉션을 사용하고 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 리디렉션을 추가하지 마십시오 . 누군가 HTTP 리디렉션을 변경하고 HTML 리디렉션 변경을 잊어 버린 경우 리디렉션이 더 이상 동일하지 않아 무한 루프 또는 기타 악몽이 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5c6db50a4bbf09d3b72d3f46fb9f7f812630cfd6" translate="yes" xml:space="preserve">
          <source>When present on a response to a &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; request that has no body, it indicates the value that would have applied to the corresponding &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; message.</source>
          <target state="translated">본문이없는 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 요청 에 대한 응답 이 있으면 해당 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 메시지에 적용되는 값을 나타냅니다 .</target>
        </trans-unit>
        <trans-unit id="8d602fc4361edf535f13cf0e83c68250a27555fa" translate="yes" xml:space="preserve">
          <source>When present with the &lt;code&gt;enforce&lt;/code&gt; directive, the configuration is referred to as an &quot;enforce-and-report&quot; configuration, signalling to the user agent both that compliance to the Certificate Transparency policy should be enforced &lt;em&gt;and&lt;/em&gt; that violations should be reported.</source>
          <target state="translated">에 존재하는 경우 &lt;code&gt;enforce&lt;/code&gt; 지침이 구성이 인증서 투명성 정책이 준수가 모두 적용되어야하는 사용자 에이전트에 신호,에 &quot;시행 앤 보고서&quot;를 구성이라 &lt;em&gt;하고&lt;/em&gt; 위반에보고해야한다.</target>
        </trans-unit>
        <trans-unit id="2677bfe338fef1db9d7d5bb4695ba60efdfb09e0" translate="yes" xml:space="preserve">
          <source>When presented with a request, a cache MUST NOT reuse a stored
   response, unless:

   o  The presented effective request URI (&lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;Section&amp;nbsp;5.5 of [RFC7230]&lt;/a&gt;) and
      that of the stored response match, and

   o  the request method associated with the stored response allows it
      to be used for the presented request, and

   o  selecting header fields nominated by the stored response (if any)
      match those presented (see &lt;a href=&quot;#section-4.1&quot;&gt;Section 4.1&lt;/a&gt;), and 

   o  the presented request does not contain the no-cache pragma
      (&lt;a href=&quot;#section-5.4&quot;&gt;Section 5.4&lt;/a&gt;), nor the no-cache cache directive (&lt;a href=&quot;#section-5.2.1&quot;&gt;Section 5.2.1&lt;/a&gt;),
      unless the stored response is successfully validated
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;), and

   o  the stored response does not contain the no-cache cache directive
      (&lt;a href=&quot;#section-5.2.2.2&quot;&gt;Section 5.2.2.2&lt;/a&gt;), unless it is successfully validated
      (&lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;), and

   o  the stored response is either:

      *  fresh (see &lt;a href=&quot;#section-4.2&quot;&gt;Section 4.2&lt;/a&gt;), or

      *  allowed to be served stale (see &lt;a href=&quot;#section-4.2.4&quot;&gt;Section 4.2.4&lt;/a&gt;), or

      *  successfully validated (see &lt;a href=&quot;#section-4.3&quot;&gt;Section 4.3&lt;/a&gt;).

   Note that any of the requirements listed above can be overridden by a
   cache-control extension; see &lt;a href=&quot;#section-5.2.3&quot;&gt;Section 5.2.3&lt;/a&gt;.

   When a stored response is used to satisfy a request without
   validation, a cache MUST generate an Age header field (&lt;a href=&quot;#section-5.1&quot;&gt;Section 5.1&lt;/a&gt;),
   replacing any present in the response with a value equal to the
   stored response's current_age; see &lt;a href=&quot;#section-4.2.3&quot;&gt;Section 4.2.3&lt;/a&gt;.

   A cache MUST write through requests with methods that are unsafe
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;Section&amp;nbsp;4.2.1 of [RFC7231]&lt;/a&gt;) to the origin server; i.e., a cache is
   not allowed to generate a reply to such a request before having
   forwarded the request and having received a corresponding response.

   Also, note that unsafe requests might invalidate already-stored
   responses; see &lt;a href=&quot;#section-4.4&quot;&gt;Section 4.4&lt;/a&gt;.

   When more than one suitable response is stored, a cache MUST use the
   most recent response (as determined by the Date header field).  It
   can also forward the request with &quot;Cache-Control: max-age=0&quot; or
   &quot;Cache-Control: no-cache&quot; to disambiguate which response to use.

   A cache that does not have a clock available MUST NOT use stored
   responses without revalidating them upon every use.</source>
          <target state="translated">요청과 함께 제시된 캐시는 다음과 같은 경우를 제외하고는 저장된 응답을 재사용해서는 안된다. o 제시된 유효 요청 URI ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-5.5&quot;&gt;[RFC7230]의 섹션 5.5&lt;/a&gt; )와 저장된 응답이 일치하는 것 및 o 저장된 응답과 관련된 요청 방법은 제시된 요청에 사용될 것이며, o 저장된 응답에 의해 지명 된 헤더 필드 (있는 경우)를 선택하는 것은 제시된 것과 일치하며 ( &lt;a href=&quot;#section-4.1&quot;&gt;섹션 4.1&lt;/a&gt; 참조 ) 제시된 요청은 캐시없는 프라그 마를 포함하지 않는다 ( &lt;a href=&quot;#section-5.4&quot;&gt;섹션 5.4&lt;/a&gt; ) 저장된 응답의 유효성이 성공적으로 검사되지 않는 한 캐시없는 캐시 지정 문 ( &lt;a href=&quot;#section-5.2.1&quot;&gt;섹션 5.2.1&lt;/a&gt; ) 또는 &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt;), o 저장된 응답 이 성공적으로 검증되지 않은 경우 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; ) 캐시없는 캐시 지시문 ( &lt;a href=&quot;#section-5.2.2.2&quot;&gt;5.2.2.2&lt;/a&gt; )을 포함하지 않으며 o 저장된 응답이 다음과 같은 경우 : * 새로 고침 ( &lt;a href=&quot;#section-4.2&quot;&gt;섹션 4.2&lt;/a&gt; 참조 ) 또는 * 부실하게 제공 되거나 ( &lt;a href=&quot;#section-4.2.4&quot;&gt;섹션 4.2.4&lt;/a&gt; 참조 ) * 성공적으로 검증되었습니다 ( &lt;a href=&quot;#section-4.3&quot;&gt;섹션 4.3&lt;/a&gt; 참조 ). 위에 나열된 요구 사항은 캐시 제어 확장으로 재정의 될 수 있습니다. &lt;a href=&quot;#section-5.2.3&quot;&gt;섹션 5.2.3&lt;/a&gt; 참조 . 저장된 응답이 유효성 검증없이 요청을 만족시키기 위해 사용될 때, 캐시는 반드시 Age 헤더 필드를 생성해야합니다 ( &lt;a href=&quot;#section-5.1&quot;&gt;섹션 5.1)&lt;/a&gt;), 응답에 존재하는 임의의 것을 저장된 응답의 current_age와 동일한 값으로 대체; &lt;a href=&quot;#section-4.2.3&quot;&gt;섹션 4.2.3&lt;/a&gt; 참조 . 캐시는 안전하지 않은 메소드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7231#section-4.2.1&quot;&gt;[RFC7231]의 섹션 4.2.1&lt;/a&gt; )로 요청을 통해 오리진 서버에 기록해야합니다. 즉, 캐시는 요청을 전달하고 대응하는 응답을 수신하기 전에 이러한 요청에 대한 응답을 생성 할 수 없다. 또한 안전하지 않은 요청은 이미 저장된 응답을 무효화 할 수 있습니다. &lt;a href=&quot;#section-4.4&quot;&gt;4.4 절&lt;/a&gt; 참조. 하나 이상의 적절한 응답이 저장되면 캐시는 가장 최근의 응답을 사용해야합니다 (날짜 헤더 필드에 의해 결정됨). 또한 &quot;Cache-Control : max-age = 0&quot;또는 &quot;Cache-Control : no-cache&quot;로 요청을 전달하여 사용할 응답을 명확하게 할 수 있습니다. 사용 가능한 클럭이없는 캐시는 매번 사용할 때마다 유효성을 검사하지 않고 저장된 응답을 사용해서는 안됩니다.</target>
        </trans-unit>
        <trans-unit id="118ca9fdf6295ed6b61ba0d26cdb23fa50df2281" translate="yes" xml:space="preserve">
          <source>When receiving an HTTP request, a server can send a &lt;a href=&quot;headers/set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt; header with the response. The cookie is usually stored by the browser, and then the cookie is sent with requests made to the same server inside a &lt;a href=&quot;headers/cookie&quot;&gt;&lt;code&gt;Cookie&lt;/code&gt;&lt;/a&gt; HTTP header. An expiration date or duration can be specified, after which the cookie is no longer sent. Additionally, restrictions to a specific domain and path can be set, limiting where the cookie is sent.</source>
          <target state="translated">HTTP 요청을 수신하면 서버는 응답과 함께 &lt;a href=&quot;headers/set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; 헤더를 보낼 수 있습니다 . 쿠키는 일반적으로 브라우저에 의해 저장되고 &lt;a href=&quot;headers/cookie&quot;&gt; &lt;code&gt;Cookie&lt;/code&gt; &lt;/a&gt; HTTP 헤더 내의 동일한 서버에 대한 요청과 함께 쿠키가 전송됩니다 . 쿠키가 더 이상 전송되지 않는 만료 날짜 또는 기간을 지정할 수 있습니다. 또한 쿠키가 전송되는 위치를 제한하여 특정 도메인 및 경로에 대한 제한을 설정할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="2e9b93794ed31355629f157a820821c9c468143b" translate="yes" xml:space="preserve">
          <source>When requesting an image, like through an HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt;&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;&lt;/a&gt; element, user-agent often sets a specific list of media types to be welcomed.</source>
          <target state="translated">HTML &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img&quot;&gt; &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 통해 이미지를 요청할 때 user-agent는 종종 특정 미디어 유형 목록을 환영하도록 설정합니다.</target>
        </trans-unit>
        <trans-unit id="8497a7a0712bffc13bbeb91db7dcfe0053667c2b" translate="yes" xml:space="preserve">
          <source>When responding to a credentialed request, the server &lt;strong&gt;must&lt;/strong&gt; specify an origin in the value of the &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; header, instead of specifying the &quot;&lt;code&gt;*&lt;/code&gt;&quot; wildcard.</source>
          <target state="translated">자격 증명 요청에 응답 할 때 서버 &lt;strong&gt;는&lt;/strong&gt; &quot; &lt;code&gt;*&lt;/code&gt; &quot;와일드 카드 를 지정하는 대신 &lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt; 헤더 값에 오리진을 지정 &lt;strong&gt;해야합니다&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d1d5e8076fc20454045b01525a599db69f9d0096" translate="yes" xml:space="preserve">
          <source>When responses convey payload information, whether indicating a
   success or an error, the origin server often has different ways of
   representing that information; for example, in different formats,
   languages, or encodings.  Likewise, different users or user agents
   might have differing capabilities, characteristics, or preferences
   that could influence which representation, among those available,
   would be best to deliver.  For this reason, HTTP provides mechanisms
   for content negotiation.

   This specification defines two patterns of content negotiation that
   can be made visible within the protocol: &quot;proactive&quot;, where the
   server selects the representation based upon the user agent's stated
   preferences, and &quot;reactive&quot; negotiation, where the server provides a
   list of representations for the user agent to choose from.  Other
   patterns of content negotiation include &quot;conditional content&quot;, where
   the representation consists of multiple parts that are selectively
   rendered based on user agent parameters, &quot;active content&quot;, where the
   representation contains a script that makes additional (more
   specific) requests based on the user agent characteristics, and
   &quot;Transparent Content Negotiation&quot; ([&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC2295&lt;/a&gt;]), where content 

   selection is performed by an intermediary.  These patterns are not
   mutually exclusive, and each has trade-offs in applicability and
   practicality.

   Note that, in all cases, HTTP is not aware of the resource semantics.
   The consistency with which an origin server responds to requests,
   over time and over the varying dimensions of content negotiation, and
   thus the &quot;sameness&quot; of a resource's observed representations over
   time, is determined entirely by whatever entity or algorithm selects
   or generates those responses.  HTTP pays no attention to the man
   behind the curtain.</source>
          <target state="translated">응답이 성공 또는 오류를 나타내는 지 여부에 관계없이 페이로드 정보를 전달할 때 원래 서버는 종종 해당 정보를 나타내는 다른 방법을 갖습니다. 예를 들어, 다른 형식, 언어 또는 인코딩으로. 마찬가지로, 다른 사용자 또는 사용자 에이전트는 다른 표현, 사용 가능한 것 중에서 가장 표현하기에 영향을 줄 수있는 다른 기능, 특성 또는 선호도를 가질 수 있습니다. 이러한 이유로 HTTP는 컨텐츠 협상을위한 메커니즘을 제공합니다. 이 사양은 프로토콜 내에서 볼 수있는 두 가지 패턴의 콘텐츠 협상을 정의합니다. &quot;프로 액티브&quot;-서버가 사용자 에이전트의 지정된 기본 설정에 따라 표현을 선택합니다.여기서 서버는 사용자 에이전트가 선택할 수있는 표현 목록을 제공합니다. 컨텐츠 협상의 다른 패턴에는 &quot;조건부 컨텐츠&quot;가 있으며, 여기서 표현은 사용자 에이전트 매개 변수를 기반으로 선택적으로 렌더링되는 여러 부분으로 구성됩니다. &quot;활성 컨텐츠&quot;. 여기에는 표시에 따라 추가 (보다 구체적인) 요청을 작성하는 스크립트가 포함됩니다. 사용자 에이전트 특성 및 &quot;투명한 콘텐츠 협상&quot;([여기서 표현에는 사용자 에이전트 특성 및 &quot;투명한 내용 협상&quot;([Transparent Content Negotiation)에 따라 추가 (보다 구체적인) 요청을하는 스크립트가 포함됩니다.여기서 표현에는 사용자 에이전트 특성 및 &quot;투명한 내용 협상&quot;([Transparent Content Negotiation)에 따라 추가 (보다 구체적인) 요청을하는 스크립트가 포함됩니다.&lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;&lt;/a&gt;콘텐츠 선택은 중개자에 의해 수행되는 RFC2295 ]). 이러한 패턴은 상호 배타적이지 않으며 각각 적용 및 실용성에있어 절충점이 있습니다. 모든 경우에 HTTP는 자원 시맨틱을 인식하지 못합니다. 시간이 지남에 따라 그리고 컨텐츠 협상의 다양한 차원에 걸쳐 원 서버가 요청에 응답하는 일관성과 시간에 따른 자원의 관찰 된 표현의 &quot;동일성&quot;은 엔티티 또는 알고리즘이 해당 응답을 선택하거나 생성하는 모든 것에 의해 전적으로 결정됩니다. HTTP는 커튼 뒤의 사람에게주의를 기울이지 않습니다.</target>
        </trans-unit>
        <trans-unit id="bb60f936f846aaffe2cddcca884c71458177df7b" translate="yes" xml:space="preserve">
          <source>When resuming to request more parts of a resource, you need to guarantee that the stored resource has not been modified since the last fragment has been received.</source>
          <target state="translated">자원의 더 많은 부분을 요청하기 위해 재개 할 때 마지막 조각이 수신 된 이후에 저장된 자원이 수정되지 않았 음을 보증해야합니다.</target>
        </trans-unit>
        <trans-unit id="112139cb42754557c5251097c3d9d57a0f0f1846" translate="yes" xml:space="preserve">
          <source>When saving changes to a wiki page (posting data), the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request will contain the &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; header containing the &lt;code&gt;ETag&lt;/code&gt; values to check freshness against.</source>
          <target state="translated">Wiki 페이지 (게시 데이터)에 변경 사항을 저장할 때 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청에는 최신 성을 확인할 &lt;code&gt;ETag&lt;/code&gt; 값 이 포함 된 &lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="eb9c62d45614a9fc9c768607aa8dd717eb012aae" translate="yes" xml:space="preserve">
          <source>When saving changes to a wiki page (posting data), the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request will contain the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; header containing the &lt;code&gt;ETag&lt;/code&gt; values to check freshness against.</source>
          <target state="translated">위키 페이지 (게시 데이터)에 변경 사항을 저장할 때 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청에는 최신 정보를 확인하기 위해 &lt;code&gt;ETag&lt;/code&gt; 값 이 포함 된 &lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더가 포함 됩니다.</target>
        </trans-unit>
        <trans-unit id="3ecf0a10a5d9c4c3b83b0e8a52e69826167aa3c7" translate="yes" xml:space="preserve">
          <source>When sending a conditional request for cache validation, a cache
   sends one or more precondition header fields containing validator
   metadata from its stored response(s), which is then compared by
   recipients to determine whether a stored response is equivalent to a
   current representation of the resource.

   One such validator is the timestamp given in a Last-Modified header
   field (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;Section&amp;nbsp;2.2 of [RFC7232]&lt;/a&gt;), which can be used in an
   If-Modified-Since header field for response validation, or in an
   If-Unmodified-Since or If-Range header field for representation
   selection (i.e., the client is referring specifically to a previously
   obtained representation with that timestamp).

   Another validator is the entity-tag given in an ETag header field
   (&lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;Section&amp;nbsp;2.3 of [RFC7232]&lt;/a&gt;).  One or more entity-tags, indicating one
   or more stored responses, can be used in an If-None-Match header
   field for response validation, or in an If-Match or If-Range header
   field for representation selection (i.e., the client is referring
   specifically to one or more previously obtained representations with
   the listed entity-tags).</source>
          <target state="translated">캐시 유효성 검사를위한 조건부 요청을 보낼 때 캐시는 저장된 응답에서 유효성 검사기 메타 데이터를 포함하는 하나 이상의 전제 조건 헤더 필드를 보낸 다음받는 사람과 비교하여 저장된 응답이 리소스의 현재 표현과 같은지 여부를 확인합니다. . 이러한 유효성 검사기 중 하나는 Last-Modified 헤더 필드 ( &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.2&quot;&gt;[RFC7232]의 섹션 2.2)에&lt;/a&gt; 제공된 타임 스탬프이며, 응답 유효성 검사를 위해 If-Modified-Since 헤더 필드 또는 If-Unmodified-Since 또는 If에 사용될 수 있습니다. 표현 선택을위한 범위 헤더 필드 (즉, 클라이언트는 구체적으로 그 타임 스탬프로 이전에 획득 된 표현을 참조하고 있음). 다른 유효성 검사기는 ETag 헤더 필드에 제공된 엔티티 태그 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232#section-2.3&quot;&gt;입니다 ([RFC7232]의 2.3 절&lt;/a&gt;). 하나 이상의 저장된 응답을 나타내는 하나 이상의 엔티티 태그는 응답 유효성 검증을 위해 If-None-Match 헤더 필드 또는 표현 선택 (즉, 클라이언트)을위한 If-Match 또는 If-Range 헤더 필드에서 사용될 수 있습니다. (목록에 표시된 엔티티 태그를 사용하여 이전에 얻은 하나 이상의 표현을 구체적으로 언급하고 있음).</target>
        </trans-unit>
        <trans-unit id="fce832cc958ff4ef014da90639644dd9e45d6938" translate="yes" xml:space="preserve">
          <source>When sent with a &lt;a href=&quot;../status/429&quot;&gt;&lt;code&gt;429&lt;/code&gt;&lt;/a&gt; (Too Many Requests) response, this indicates how long to wait before making a new request.</source>
          <target state="translated">&lt;a href=&quot;../status/429&quot;&gt; &lt;code&gt;429&lt;/code&gt; &lt;/a&gt; (너무 많은 요청) 응답 과 함께 전송되면 새 요청을하기 전에 대기하는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="79ae6cec0f4f3064c8648fb0e2f622088ea4675c" translate="yes" xml:space="preserve">
          <source>When sent with a &lt;a href=&quot;../status/503&quot;&gt;&lt;code&gt;503&lt;/code&gt;&lt;/a&gt; (Service Unavailable) response, this indicates how long the service is expected to be unavailable.</source>
          <target state="translated">&lt;a href=&quot;../status/503&quot;&gt; &lt;code&gt;503&lt;/code&gt; &lt;/a&gt; (Service Unavailable) 응답 과 함께 전송되면 서비스를 사용할 수 없을 것으로 예상되는 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="e83d0887ca1d1fc9960fe8e57672e00926af79bd" translate="yes" xml:space="preserve">
          <source>When sent with a redirect response, such as &lt;a href=&quot;../status/301&quot;&gt;&lt;code&gt;301&lt;/code&gt;&lt;/a&gt; (Moved Permanently), this indicates the minimum time that the user agent is asked to wait before issuing the redirected request.</source>
          <target state="translated">&lt;a href=&quot;../status/301&quot;&gt; &lt;code&gt;301&lt;/code&gt; &lt;/a&gt; (영구적으로 이동 됨) 과 같은 리디렉션 응답으로 전송되면 리디렉션 된 요청을 발행하기 전에 사용자 에이전트가 대기하도록 요청되는 최소 시간을 나타냅니다.</target>
        </trans-unit>
        <trans-unit id="c92c83a3263a103661248f1683416444f3d70f52" translate="yes" xml:space="preserve">
          <source>When submitting a lock request, a user agent may also submit an
   'owner' XML field giving contact information for the person taking
   out the lock (for those cases where a person, rather than a robot, is
   taking out the lock).  This contact information is stored in a DAV:
   lockdiscovery property on the resource, and can be used by other 

   collaborators to begin negotiation over access to the resource.
   However, in many cases, this contact information can be very private,
   and should not be widely disseminated.  Servers SHOULD limit read
   access to the DAV:lockdiscovery property as appropriate.
   Furthermore, user agents SHOULD provide control over whether contact
   information is sent at all, and if contact information is sent,
   control over exactly what information is sent.</source>
          <target state="translated">잠금 요청을 제출할 때 사용자 에이전트는 잠금을 수행하는 사람 (로봇이 아닌 사람이 잠금을 수행하는 경우)에 대한 연락처 정보를 제공하는 '소유자'XML 필드를 제출할 수도 있습니다. 이 연락처 정보는 리소스의 DAV : lockdiscovery 속성에 저장되며 다른 공동 작업자가 리소스 액세스에 대한 협상을 시작하는 데 사용할 수 있습니다. 그러나 대부분의 경우이 연락처 정보는 매우 개인 정보 일 수 있으므로 널리 보급되어서는 안됩니다. 서버는 DAV : lockdiscovery 속성에 대한 읽기 액세스를 적절하게 제한해야합니다. 또한 사용자 에이전트는 연락처 정보의 전송 여부에 대한 제어를 제공해야하며 연락처 정보가 전송되는 경우 정확히 어떤 정보가 전송되는지 제어해야합니다.</target>
        </trans-unit>
        <trans-unit id="48e2270a1e81d7fd634978728cb4b921d727d1ad" translate="yes" xml:space="preserve">
          <source>When the &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt; Partial Content&lt;/code&gt; status code is sent, this MIME type indicates that the document is composed of several parts, one for each of the requested ranges. Like other multipart types, the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; uses a &lt;code&gt;boundary&lt;/code&gt; to separate the pieces. Each piece has a &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header with its actual type and a &lt;a href=&quot;../headers/content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt; of the range it represents.</source>
          <target state="translated">때 &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt; Partial Content&lt;/code&gt; 상태 코드가 전송되고,이 MIME 타입의 문서는 여러 부분, 요청 된 범위의 각각에 대한 하나의 구성을 나타냅니다. 다른 멀티 파트 유형과 마찬가지로 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 은 &lt;code&gt;boundary&lt;/code&gt; 를 사용 하여 조각을 분리합니다. 각 조각에는 실제 유형 의 &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더와 그것이 나타내는 &lt;a href=&quot;../headers/content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 의 Content-Range 가 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ba16d0b2909ed8c865e2f861632fd65055bfc45" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;POST&lt;/code&gt; request is sent via a method other than an HTML form &amp;mdash; like via an &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt; &amp;mdash; the body can take any type. As described in the HTTP 1.1 specification, &lt;code&gt;POST&lt;/code&gt; is designed to allow a uniform method to cover the following functions:</source>
          <target state="translated">때 &lt;code&gt;POST&lt;/code&gt; 의 요청이 HTML 양식 이외의 방법을 통해 전송됩니다 - 같은 통해 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest&quot;&gt; &lt;code&gt;XMLHttpRequest&lt;/code&gt; 의&lt;/a&gt; - 몸은 모든 종류의 수 있습니다. HTTP 1.1 사양에 설명 된대로 &lt;code&gt;POST&lt;/code&gt; 는 균일 한 방법으로 다음 기능을 처리 할 수 ​​있도록 설계되었습니다.</target>
        </trans-unit>
        <trans-unit id="ee1ae4b4d29880b199bbb96de77973c9bb419343" translate="yes" xml:space="preserve">
          <source>When the client wants to communicate with a server, either being the final server or an intermediate proxy, it performs the following steps:</source>
          <target state="translated">클라이언트가 최종 서버 또는 중간 프록시 인 서버와 통신하려는 경우 다음 단계를 수행합니다.</target>
        </trans-unit>
        <trans-unit id="b883869a25a4436318f14eff46717c107adc1c67" translate="yes" xml:space="preserve">
          <source>When the condition fails for &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../methods/head&quot;&gt;&lt;code&gt;HEAD&lt;/code&gt;&lt;/a&gt; methods, then the server must return HTTP status code 304 (Not Modified). For methods that apply server-side changes, the status code 412 (Precondition Failed) is used. Note that the server generating a 304 response MUST generate any of the following header fields that would have been sent in a 200 (OK) response to the same request: Cache-Control, Content-Location, Date, ETag, Expires, and Vary.</source>
          <target state="translated">&lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;../methods/head&quot;&gt; &lt;code&gt;HEAD&lt;/code&gt; &lt;/a&gt; 메소드에 대한 조건이 실패하면 서버는 HTTP 상태 코드 304 (수정되지 않음)를 리턴해야합니다. 서버 측 변경 사항을 적용하는 방법에는 상태 코드 412 (전제 조건 실패)가 사용됩니다. 304 응답을 생성하는 서버는 동일한 요청에 대해 200 (OK) 응답으로 전송 된 Cache-Control, Content-Location, Date, ETag, Expires 및 Vary와 같은 헤더 필드를 생성해야합니다.</target>
        </trans-unit>
        <trans-unit id="bb9a689d273317ba5ef7624a99ac855ef096064b" translate="yes" xml:space="preserve">
          <source>When the expiration time specified by the Strict-Transport-Security header elapses, the next attempt to load the site via HTTP will proceed as normal instead of automatically using HTTPS.</source>
          <target state="translated">Strict-Transport-Security 헤더에 지정된 만료 시간이 경과하면 HTTP를 통해 사이트를로드하려는 다음 시도는 자동으로 HTTPS를 사용하는 대신 정상적으로 진행됩니다.</target>
        </trans-unit>
        <trans-unit id="4d04c0cd831cfd20faa7e1fe732a4e0914639cf8" translate="yes" xml:space="preserve">
          <source>When the form is submitted, the site generates a receipt for the transaction. The server could use &lt;code&gt;Content-Location&lt;/code&gt; to indicate that receipt's URL for future access.</source>
          <target state="translated">양식이 제출되면 사이트는 거래에 대한 영수증을 생성합니다. 서버는 &lt;code&gt;Content-Location&lt;/code&gt; 을 사용 하여 나중에 액세스 할 수 있도록 영수증의 URL을 표시 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="54bc09488c526dacffc841e2906f0ddbba4554d0" translate="yes" xml:space="preserve">
          <source>When the source resource is not a collection, the result of the COPY
   method is the creation of a new resource at the destination whose
   state and behavior match that of the source resource as closely as
   possible.  Since the environment at the destination may be different
   than at the source due to factors outside the scope of control of the
   server, such as the absence of resources required for correct
   operation, it may not be possible to completely duplicate the
   behavior of the resource at the destination.  Subsequent alterations
   to the destination resource will not modify the source resource.
   Subsequent alterations to the source resource will not modify the
   destination resource.</source>
          <target state="translated">소스 자원이 콜렉션이 아닌 경우 COPY 메소드의 결과는 대상에서 상태 및 동작이 소스 자원의 상태 및 동작과 최대한 일치하는 새 자원을 작성하는 것입니다. 서버의 제어 범위를 벗어난 요인 (예 : 올바른 작동에 필요한 자원이없는 등)으로 인해 대상의 환경이 소스의 환경과 다를 수 있으므로, 자원의 동작을 완전히 복제하지 못할 수 있습니다. 목적지. 이후에 대상 리소스를 변경해도 소스 리소스는 수정되지 않습니다. 이후에 소스 리소스를 변경해도 대상 리소스는 수정되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="7d5711b2386b571e3167bd7f0a010f2774fd8e7d" translate="yes" xml:space="preserve">
          <source>When this policy is enabled, any attempt to query public key credentials will result in an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5486bfa60602bb895214d015f37fd5698ae7c49a" translate="yes" xml:space="preserve">
          <source>When to Use Entity-Tags and Last-Modified Dates (RFC 7232)</source>
          <target state="translated">엔터티 태그 및 최종 수정 날짜를 사용하는 경우 (RFC 7232)</target>
        </trans-unit>
        <trans-unit id="b34a4c2a8d2bd2be505eebfefc7f3521b9c0bbcf" translate="yes" xml:space="preserve">
          <source>When used as part of a response to a preflight request, this indicates whether or not the actual request can be made using credentials. Note that simple &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; requests are not preflighted, and so if a request is made for a resource with credentials, if this header is not returned with the resource, the response is ignored by the browser and not returned to web content.</source>
          <target state="translated">프리 플라이트 요청에 대한 응답의 일부로 사용되는 경우 실제 자격 증명을 사용하여 실제 요청을 수행 할 수 있는지 여부를 나타냅니다. 간단한 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청은 프리 플라이트되지 않으므로 자격 증명이있는 리소스를 요청하면이 헤더가 리소스와 함께 반환되지 않으면 브라우저에서 응답을 무시하고 웹 콘텐츠로 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="f6658a6f8ffe56893681a8ca01fe29c5f148086e" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;if-modified-since&quot;&gt;&lt;code&gt;If-Modified-Since&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;If-None-Match&lt;/code&gt; has precedence (if the server supports it).</source>
          <target state="translated">함께 사용되는 경우에 &lt;a href=&quot;if-modified-since&quot;&gt; &lt;code&gt;If-Modified-Since&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;If-None-Match&lt;/code&gt; 우선 순위를 가지고 (서버가 지원하는 경우).</target>
        </trans-unit>
        <trans-unit id="a59bbd7394bbd946e2f8e6daaaadb0ebcf7845d8" translate="yes" xml:space="preserve">
          <source>When used in combination with &lt;a href=&quot;if-none-match&quot;&gt;&lt;code&gt;If-None-Match&lt;/code&gt;&lt;/a&gt;, it is ignored, unless the server doesn't support &lt;code&gt;If-None-Match&lt;/code&gt;.</source>
          <target state="translated">&lt;a href=&quot;if-none-match&quot;&gt; &lt;code&gt;If-None-Match&lt;/code&gt; &lt;/a&gt; 와 함께 사용 하면 서버가 &lt;code&gt;If-None-Match&lt;/code&gt; 를 지원하지 않는 한 무시 됩니다.</target>
        </trans-unit>
        <trans-unit id="124ee28e323750f5d9b2e9e1e56414f8fea97223" translate="yes" xml:space="preserve">
          <source>When used, those functions only accept non-spoofable, typed values created by Trusted Type policies, and reject strings. Together with &lt;code&gt;&lt;a href=&quot;trusted-types&quot;&gt;trusted-types&lt;/a&gt;&lt;/code&gt; directive, which guards creation of Trusted Type policies, this allows authors to define rules guarding writing values to the DOM and thus reducing the DOM XSS attack surface to small, isolated parts of the web application codebase, facilitating their monitoring and code review.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="940d765e5e6f04c24517cbcdc47ec43569264193" translate="yes" xml:space="preserve">
          <source>When using &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;Fetch&lt;/a&gt;: &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy&quot;&gt;&lt;code&gt;Request.referrerPolicy&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API&quot;&gt;가져 오기&lt;/a&gt; 사용시 : &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Request/referrerPolicy&quot;&gt; &lt;code&gt;Request.referrerPolicy&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="95651ca261ced0fa7d7a802f20f0fac00474ad6e" translate="yes" xml:space="preserve">
          <source>When using URLs in &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; content, you should generally only use a few of these URL schemes. When referring to subresources &amp;mdash; that is, files that are being loaded as part of a larger document &amp;mdash; you should only use the HTTP and HTTPS schemes. Increasingly, browsers are removing support for using FTP to load subresources, for security reasons.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt; 내용 에서 URL을 사용할 때는 일반적으로 이러한 URL 체계 중 몇 가지만 사용해야합니다. 하위 문서 (더 큰 문서의 일부로로드되는 파일)를 참조 할 때는 HTTP 및 HTTPS 체계 만 사용해야합니다. 보안상의 이유로 브라우저는 FTP를 사용하여 하위 자원을로드하는 것에 대한 지원을 제거하고 있습니다.</target>
        </trans-unit>
        <trans-unit id="9eea4faa25e4e579cef40974188a8f16f3f6d744" translate="yes" xml:space="preserve">
          <source>When using the &quot;&lt;code&gt;must-revalidate&lt;/code&gt;&quot; directive, the cache must verify the status of the stale resources before using it and expired ones should not be used. For more details, see the &lt;a href=&quot;#Cache_validation&quot;&gt;Validation&lt;/a&gt; section below.</source>
          <target state="translated">&quot; &lt;code&gt;must-revalidate&lt;/code&gt; &quot;지시문을 사용하는 경우 캐시는 사용하기 전에 오래된 자원의 상태를 확인해야하며 만료 된 자원은 사용해서는 안됩니다. 자세한 내용은 아래 의 &lt;a href=&quot;#Cache_validation&quot;&gt;유효성 검사&lt;/a&gt; 섹션을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="ecdb14111320a66294518a2069105521deccaff6" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;Vary: User-Agent&lt;/code&gt; header, caching servers should consider the user agent when deciding whether to serve the page from cache. For example, if you are serving different content to mobile users, it can help you to avoid that a cache may mistakenly serve a desktop version of your site to your mobile users. It can help Google and other search engines to discover the mobile version of a page, and might also tell them that no &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;Cloaking&lt;/a&gt; is intended.</source>
          <target state="translated">사용하는 경우는 &lt;code&gt;Vary: User-Agent&lt;/code&gt; 캐시에서 페이지를 제공할지 여부를 결정할 때 헤더, 캐싱 서버가 사용자 에이전트를 고려해야합니다. 예를 들어 모바일 사용자에게 다른 콘텐츠를 제공하는 경우 캐시가 실수로 사이트의 데스크톱 버전을 모바일 사용자에게 제공하지 않도록 할 수 있습니다. Google 및 기타 검색 엔진이 모바일 버전의 페이지를 발견하는 데 도움을 줄 수 있으며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Cloaking&quot;&gt;클로킹&lt;/a&gt; 이 의도 되지 않았다고 말할 수도 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b3026e4bf68b068a4b6ce5495c541e344d3b11c9" translate="yes" xml:space="preserve">
          <source>When you restructure Web sites, URLs change. Even if you update your site's links to match the new URLs, you have no control over the URLs used by external resources.</source>
          <target state="translated">웹 사이트를 재구성하면 URL이 변경됩니다. 새 URL과 일치하도록 사이트의 링크를 업데이트하더라도 외부 리소스에서 사용하는 URL을 제어 할 수 없습니다.</target>
        </trans-unit>
        <trans-unit id="f075b4f1650209d71c1757142531e91ebe323426" translate="yes" xml:space="preserve">
          <source>When you restructure Web sites, URLs of resources change. Even if you can update the internal links of your Web site to match the new naming scheme, you have no control over the URLs used by external resources. You don't want to break these links, as they bring you valuable users (and help your SEO), so you set up redirects from the old URLs to the new ones.</source>
          <target state="translated">웹 사이트를 재구성하면 리소스 URL이 변경됩니다. 새 이름 지정 체계와 일치하도록 웹 사이트의 내부 링크를 업데이트 할 수 있더라도 외부 자원이 사용하는 URL을 제어 할 수 없습니다. 귀중한 사용자를 유도하고 SEO를 돕기 때문에 이러한 링크를 끊지 않으려면 이전 URL에서 새 URL로 리디렉션을 설정하십시오.</target>
        </trans-unit>
        <trans-unit id="6070588ec0c2a8c5e6cfc541a62c166faa651c18" translate="yes" xml:space="preserve">
          <source>Whenever a cache returns a response that is neither first-hand nor
   &quot;fresh enough&quot; (in the sense of condition 2 in &lt;a href=&quot;#section-13.1.1&quot;&gt;section 13.1.1&lt;/a&gt;), it
   MUST attach a warning to that effect, using a Warning general-header.
   The Warning header and the currently defined warnings are described
   in &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt;. The warning allows clients to take appropriate
   action.

   Warnings MAY be used for other purposes, both cache-related and
   otherwise. The use of a warning, rather than an error status code,
   distinguish these responses from true failures.

   Warnings are assigned three digit warn-codes. The first digit
   indicates whether the Warning MUST or MUST NOT be deleted from a
   stored cache entry after a successful revalidation: 

   1xx  Warnings that describe the freshness or revalidation status of
     the response, and so MUST be deleted after a successful
     revalidation. 1XX warn-codes MAY be generated by a cache only when
     validating a cached entry. It MUST NOT be generated by clients.

   2xx  Warnings that describe some aspect of the entity body or entity
     headers that is not rectified by a revalidation (for example, a
     lossy compression of the entity bodies) and which MUST NOT be
     deleted after a successful revalidation.

   See &lt;a href=&quot;#section-14.46&quot;&gt;section 14.46&lt;/a&gt; for the definitions of the codes themselves.

   HTTP/1.0 caches will cache all Warnings in responses, without
   deleting the ones in the first category. Warnings in responses that
   are passed to HTTP/1.0 caches carry an extra warning-date field,
   which prevents a future HTTP/1.1 recipient from believing an
   erroneously cached Warning.

   Warnings also carry a warning text. The text MAY be in any
   appropriate natural language (perhaps based on the client's Accept
   headers), and include an OPTIONAL indication of what character set is
   used.

   Multiple warnings MAY be attached to a response (either by the origin
   server or by a cache), including multiple warnings with the same code
   number. For example, a server might provide the same warning with
   texts in both English and Basque.

   When multiple warnings are attached to a response, it might not be
   practical or reasonable to display all of them to the user. This
   version of HTTP does not specify strict priority rules for deciding
   which warnings to display and in what order, but does suggest some
   heuristics.</source>
          <target state="translated">캐시가 직접적이거나 &quot;충분히 신선한&quot;( &lt;a href=&quot;#section-13.1.1&quot;&gt;섹션 13.1.1&lt;/a&gt; 의 조건 2의 의미가 아닌) 응답을 리턴 할 때마다 경고 일반 헤더를 사용하여 해당 효과에 경고를 첨부해야합니다. 경고 헤더와 현재 정의 된 경고는 &lt;a href=&quot;#section-14.46&quot;&gt;14.46 절에&lt;/a&gt; 설명되어 있습니다.. 경고는 클라이언트가 적절한 조치를 취할 수 있도록합니다. 경고는 캐시 관련 및 기타 다른 용도로 사용될 수 있습니다. 오류 상태 코드 대신 경고를 사용하면 이러한 응답을 실제 실패와 구별 할 수 있습니다. 경고에는 세 자리 경고 코드가 할당됩니다. 첫 번째 숫자는 재확인이 성공한 후 저장된 캐시 항목에서 경고를 삭제해야하는지 또는 절대로 삭제하지 않아야하는지 나타냅니다. 1xx 응답의 최신 상태 또는 재확인 상태를 설명하는 경고이므로 재확인이 완료된 후에 삭제해야합니다. 1XX 경고 코드는 캐시 된 항목을 확인할 때만 캐시에 의해 생성 될 수 있습니다. 클라이언트가 생성해서는 안됩니다. 2xx 재확인으로 수정되지 않은 엔터티 본문 또는 엔터티 헤더의 일부 측면을 설명하는 경고 (예 :엔터티 본문의 손실 압축)을 성공적으로 확인한 후에는 삭제해서는 안됩니다. 보다&lt;a href=&quot;#section-14.46&quot;&gt;섹션 14.46&lt;/a&gt;코드 자체의 정의. HTTP / 1.0 캐시는 첫 번째 카테고리의 경고를 삭제하지 않고 모든 경고를 응답으로 캐시합니다. HTTP / 1.0 캐시로 전달되는 응답의 경고에는 추가 경고 날짜 필드가 있으므로 향후 HTTP / 1.1 수신자가 잘못 캐시 된 경고를 믿지 못하게됩니다. 경고에는 경고 텍스트도 있습니다. 텍스트는 적절한 자연 언어 (아마도 클라이언트의 Accept 헤더를 기반으로 함) 일 수 있으며 사용되는 문자 집합에 대한 선택 표시를 포함 할 수 있습니다. 동일한 코드 번호의 여러 경고를 포함하여 여러 경고를 원본 서버 나 캐시에 의해 응답에 첨부 할 수 있습니다. 예를 들어, 서버는 영어와 바스크어로 된 텍스트와 동일한 경고를 제공 할 수 있습니다.여러 경고가 응답에 첨부되면 모든 경고를 사용자에게 표시하는 것이 실용적이지 않거나 합리적이지 않을 수 있습니다. 이 HTTP 버전은 표시 할 경고와 순서를 결정하기위한 엄격한 우선 순위 규칙을 지정하지 않지만 일부 휴리스틱을 제안합니다.</target>
        </trans-unit>
        <trans-unit id="b6e3f26fff7f269af5ed05c0a30457f5f9d7d7e2" translate="yes" xml:space="preserve">
          <source>Whenever the Strict-Transport-Security header is delivered to the browser, it will update the expiration time for that site, so sites can refresh this information and prevent the timeout from expiring. Should it be necessary to disable Strict Transport Security, setting the max-age to 0 (over a https connection) will immediately expire the &lt;code&gt;Strict-Transport-Security&lt;/code&gt; header, allowing access via http.</source>
          <target state="translated">Strict-Transport-Security 헤더가 브라우저에 전달 될 때마다 해당 사이트의 만료 시간이 업데이트되므로 사이트에서이 정보를 새로 고치고 시간 초과가 만료되지 않도록 할 수 있습니다. Strict Transport Security를 ​​비활성화해야하는 경우 https 연결을 통해 max-age를 0으로 설정하면 &lt;code&gt;Strict-Transport-Security&lt;/code&gt; 헤더 가 즉시 만료되어 http를 통한 액세스가 허용됩니다.</target>
        </trans-unit>
        <trans-unit id="7f2824d529ed4da83ab98e7c885ddfa6c409076e" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;form-action&lt;/code&gt; should block redirects after a form submission is &lt;a href=&quot;https://github.com/w3c/webappsec-csp/issues/8&quot;&gt;debated&lt;/a&gt; and browser implementations of this aspect are inconsistent (e.g. Firefox 57 doesn't block the redirects whereas Chrome 63 does).</source>
          <target state="translated">양식 제출이 &lt;a href=&quot;https://github.com/w3c/webappsec-csp/issues/8&quot;&gt;토론 된&lt;/a&gt; 후 &lt;code&gt;form-action&lt;/code&gt; 이 리디렉션을 차단해야하는지 여부 와이 측면의 브라우저 구현이 일치하지 않는지 여부 (예 : Firefox 57은 리디렉션을 차단하지 않지만 Chrome 63은 그렇지 않습니다).</target>
        </trans-unit>
        <trans-unit id="fb6399f7fa65b3b2878d7126ab85f658d02766e0" translate="yes" xml:space="preserve">
          <source>Which &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encodings&quot;&gt;character encodings&lt;/a&gt; the client understands.</source>
          <target state="translated">어떤 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/character_encodings&quot;&gt;문자 인코딩&lt;/a&gt; 클라이언트가 이해를.</target>
        </trans-unit>
        <trans-unit id="2e149cf9cb25225d5524e2c0b27df15969b2bc6b" translate="yes" xml:space="preserve">
          <source>Which part of the user agent contains the information you are looking for</source>
          <target state="translated">찾고자하는 정보를 포함하는 사용자 에이전트의 어느 부분</target>
        </trans-unit>
        <trans-unit id="99fc0a09b56367aa86fac890ff8bff6f93f0262e" translate="yes" xml:space="preserve">
          <source>Which part of the user agent contains the information you are looking for?</source>
          <target state="translated">사용자 에이전트의 어느 부분에 찾고있는 정보가 포함되어 있습니까?</target>
        </trans-unit>
        <trans-unit id="e993bfc672f17c43ec7068a082e6c9f72e4fd853" translate="yes" xml:space="preserve">
          <source>While Firefox 3.5 introduced support for cross-site &lt;code&gt;XMLHttpRequests&lt;/code&gt; and Web Fonts, certain requests were limited until later versions. Specifically, Firefox 7 introduced the ability for cross-site HTTP requests for WebGL Textures, and Firefox 9 added support for Images drawn on a canvas using &lt;code&gt;drawImage()&lt;/code&gt;.</source>
          <target state="translated">Firefox 3.5는 교차 사이트 &lt;code&gt;XMLHttpRequests&lt;/code&gt; 및 웹 글꼴에 대한 지원을 도입했지만 특정 요청은 이후 버전까지 제한되었습니다. 특히 Firefox 7은 WebGL Textures에 대한 사이트 간 HTTP 요청 기능을 도입했으며 Firefox 9는 &lt;code&gt;drawImage()&lt;/code&gt; 사용하여 캔버스에 그려진 이미지 지원을 추가했습니다 .</target>
        </trans-unit>
        <trans-unit id="5f82126dfe9f2c95cccd8d9a4329dc9b8b1ea83d" translate="yes" xml:space="preserve">
          <source>While HTTP/1.x used the message start-line (see &lt;a href=&quot;https://tools.ietf.org/html/rfc7230#section-3.1&quot;&gt;[RFC7230],
   Section&amp;nbsp;3.1&lt;/a&gt;) to convey the target URI, the method of the request, and
   the status code for the response, HTTP/2 uses special pseudo-header
   fields beginning with ':' character (ASCII 0x3a) for this purpose.

   Pseudo-header fields are not HTTP header fields.  Endpoints MUST NOT
   generate pseudo-header fields other than those defined in this
   document.

   Pseudo-header fields are only valid in the context in which they are
   defined.  Pseudo-header fields defined for requests MUST NOT appear
   in responses; pseudo-header fields defined for responses MUST NOT
   appear in requests.  Pseudo-header fields MUST NOT appear in
   trailers.  Endpoints MUST treat a request or response that contains
   undefined or invalid pseudo-header fields as malformed
   (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).

   All pseudo-header fields MUST appear in the header block before
   regular header fields.  Any request or response that contains a
   pseudo-header field that appears in a header block after a regular
   header field MUST be treated as malformed (&lt;a href=&quot;#section-8.1.2.6&quot;&gt;Section 8.1.2.6&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d023c8effc05b035da8186b6438727d9b10e7e" translate="yes" xml:space="preserve">
          <source>While specific HTTP status codes are shown in the interaction
   diagrams below, an AtomPub client should be prepared to handle any
   status code.  For example, a PUT to a Member URI could result in the
   return of a &quot;204 No Content&quot; status code, which still indicates
   success.</source>
          <target state="translated">아래의 상호 작용 다이어그램에 특정 HTTP 상태 코드가 표시되어 있지만 AtomPub 클라이언트는 모든 상태 코드를 처리 할 수 ​​있도록 준비해야합니다. 예를 들어, 멤버 URI에 대한 PUT은 여전히 ​​성공을 나타내는 &quot;204 컨텐츠 없음&quot;상태 코드를 리턴 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="338f925525fc3393283ece9c49173250a55b4c67" translate="yes" xml:space="preserve">
          <source>While the origin server (and to a lesser extent, intermediate caches,
   by their contribution to the age of a response) are the primary
   source of expiration information, in some cases the client might need
   to control a cache's decision about whether to return a cached
   response without validating it. Clients do this using several
   directives of the Cache-Control header.

   A client's request MAY specify the maximum age it is willing to
   accept of an unvalidated response; specifying a value of zero forces
   the cache(s) to revalidate all responses. A client MAY also specify
   the minimum time remaining before a response expires. Both of these
   options increase constraints on the behavior of caches, and so cannot
   further relax the cache's approximation of semantic transparency.

   A client MAY also specify that it will accept stale responses, up to
   some maximum amount of staleness. This loosens the constraints on the
   caches, and so might violate the origin server's specified
   constraints on semantic transparency, but might be necessary to
   support disconnected operation, or high availability in the face of
   poor connectivity.</source>
          <target state="translated">오리진 서버 (및 응답 기간에 기여한 중간 캐시)가 만기 정보의 주요 소스 인 반면 클라이언트는 캐시 된 리턴 여부에 대한 캐시 결정을 제어해야 할 수도 있습니다. 확인하지 않고 응답하십시오. 클라이언트는 Cache-Control 헤더의 여러 지시문을 사용하여이 작업을 수행합니다. 고객의 요청은 확인되지 않은 응답을 수락 할 최대 연령을 지정할 수 있습니다. 값을 0으로 지정하면 캐시가 모든 응답을 다시 강제합니다. 클라이언트는 응답이 만료되기 전에 남은 최소 시간을 지정할 수도 있습니다. 이 두 옵션 모두 캐시 동작에 대한 제약을 증가 시키므로 캐시의 의미 투명성 근사치를 더 이상 완화 할 수 없습니다.클라이언트는 또한 최대 무효 량까지 오래된 응답을 수락하도록 지정할 수 있습니다. 캐시에 대한 제약이 완화되어 의미 투명성에 대한 원본 서버의 지정된 제약 조건을 위반할 수 있지만 연결이 끊긴 상황에서 연결이 끊긴 작업이나 고 가용성을 지원하는 데 필요할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="6f8ec3f1f56c6bc412a296279f741f72feec98d6" translate="yes" xml:space="preserve">
          <source>While the version number for Firefox OS is not included in the UA string, it is possible to infer version information from the Gecko version number present in the UA string.</source>
          <target state="translated">Firefox OS의 버전 번호는 UA 문자열에 포함되어 있지 않지만 UA 문자열에있는 Gecko 버전 번호에서 버전 정보를 유추 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="97f6d88cfb1e84306b1da3a5b584e510b6a952d4" translate="yes" xml:space="preserve">
          <source>While this directive uses the same arguments as other CSP directives, some of them don&amp;rsquo;t make sense for `&amp;lt;base&amp;gt;`, such as the keywords &lt;code&gt;'unsafe-inline'&lt;/code&gt; and &lt;code&gt;'strict-dynamic'&lt;/code&gt;</source>
          <target state="translated">이 지시어는 다른 CSP 지시어와 같은 인수를 사용하지만 키워드 &lt;code&gt;'unsafe-inline'&lt;/code&gt; 및 &lt;code&gt;'strict-dynamic'&lt;/code&gt; 과 같은`&amp;lt;base&amp;gt;`에는 의미가 없습니다.</target>
        </trans-unit>
        <trans-unit id="f537be83534f2bb055e551bb0d596ae0047d77e6" translate="yes" xml:space="preserve">
          <source>While those without a write lock may not alter a property on a
   resource it is still possible for the values of live properties to
   change, even while locked, due to the requirements of their schemas.
   Only dead properties and live properties defined as lockable are
   guaranteed not to change while write locked.</source>
          <target state="translated">쓰기 잠금이없는 리소스는 리소스의 속성을 변경할 수 없지만 스키마 요구 사항으로 인해 잠겨있는 동안에도 라이브 속성의 값이 변경 될 수 있습니다. 잠금 가능으로 정의 된 죽은 속성과 라이브 속성 만 쓰기 잠금 상태에서 변경되지 않을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="eb0451d5b11619c1207cdf6653be0f2c1c7804fc" translate="yes" xml:space="preserve">
          <source>While you can use the protocol upgrade mechanism to upgrade an HTTP/1.1 connection to HTTP/2, you can't go the other way. In fact, the 101 status code is no longer supported at all in HTTP/2, since HTTP/2 doesn't have an upgrade mechanism.</source>
          <target state="translated">프로토콜 업그레이드 메커니즘을 사용하여 HTTP / 1.1 연결을 HTTP / 2로 업그레이드 할 수는 있지만 다른 방법으로는 갈 수 없습니다. 실제로 HTTP / 2에는 업그레이드 메커니즘이 없으므로 101/2 상태 코드는 더 이상 HTTP / 2에서 전혀 지원되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="3d22b91849b32a189a193c5c3711c96590f5672d" translate="yes" xml:space="preserve">
          <source>While you could rely on modern browsers to apply &lt;code&gt;SameSite=Lax&lt;/code&gt; automatically, you should rather specify it explicitly to clearly communicate your intent which &lt;code&gt;SameSite&lt;/code&gt; policy applies to your cookie. This will also improve the experience across browsers as not all of them default to &lt;code&gt;Lax&lt;/code&gt; yet.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="261605cea16791a4ddb43f7b2749c4b19783648d" translate="yes" xml:space="preserve">
          <source>Who should read this article?</source>
          <target state="translated">이 기사를 누가 읽어야합니까?</target>
        </trans-unit>
        <trans-unit id="665c65a0f74535d4656efd18a227f19541666d9b" translate="yes" xml:space="preserve">
          <source>Wikipedia page on List of HTTP headers</source>
          <target state="translated">HTTP 헤더 목록의 Wikipedia 페이지</target>
        </trans-unit>
        <trans-unit id="cc6b4a8fc4aeba016589b1291deb108288b680c4" translate="yes" xml:space="preserve">
          <source>Wikipedia: &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</source>
          <target state="translated">위키 백과 : &lt;a href=&quot;https://en.wikipedia.org/wiki/HTTP%20Strict%20Transport%20Security&quot;&gt;HTTP Strict Transport Security&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ed7d5745fff339844aa920c78c4b743eeaaaa20b" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP 404</source>
          <target state="translated">위키 백과 : HTTP 404</target>
        </trans-unit>
        <trans-unit id="c3fb892e6bb839e40a5aa40ad6213e107182238b" translate="yes" xml:space="preserve">
          <source>Wikipedia: HTTP 451</source>
          <target state="translated">위키 백과 : HTTP 451</target>
        </trans-unit>
        <trans-unit id="6fd57bc7d46dd1d7c88fd1f38c6b88d2f037bcae" translate="yes" xml:space="preserve">
          <source>Wikipedia: Hyper Text Coffee Pot Control Protocol</source>
          <target state="translated">위키 백과 : 하이퍼 텍스트 커피 포트 제어 프로토콜</target>
        </trans-unit>
        <trans-unit id="d2a3cafe6626783cff3b940b111bae036a628cbe" translate="yes" xml:space="preserve">
          <source>Wildcard (&lt;code&gt;*&lt;/code&gt;)</source>
          <target state="translated">와일드 카드 ( &lt;code&gt;*&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b8899fd2529c1a2011b26126cae3a5c0a4b0a831" translate="yes" xml:space="preserve">
          <source>Will be implemented, see &lt;a href=&quot;https://crbug.com/1007264&quot;&gt;bug 1007264&lt;/a&gt;.</source>
          <target state="translated">구현 될 &lt;a href=&quot;https://crbug.com/1007264&quot;&gt;예정&lt;/a&gt; 입니다. 버그 1007264를 참조하십시오 .</target>
        </trans-unit>
        <trans-unit id="26d9c28d789c254f71ea99a3463b99a7ccc2f4fa" translate="yes" xml:space="preserve">
          <source>Windows</source>
          <target state="translated">Windows</target>
        </trans-unit>
        <trans-unit id="31c9a3739d5b563171fe69071b7457ba22d94b63" translate="yes" xml:space="preserve">
          <source>Windows NT on x64 CPU</source>
          <target state="translated">x64 CPU의 Windows NT</target>
        </trans-unit>
        <trans-unit id="f5e663f8a9a4dc9bf996e681010668eeffc4658c" translate="yes" xml:space="preserve">
          <source>Windows NT on x86</source>
          <target state="translated">x86의 Windows NT</target>
        </trans-unit>
        <trans-unit id="9d75778731ec194b7c3ce2f2a665761a11719f44" translate="yes" xml:space="preserve">
          <source>Windows NT on x86 CPU</source>
          <target state="translated">x86 CPU의 Windows NT</target>
        </trans-unit>
        <trans-unit id="a91a0206361cb5cdd5d3a572c04ff168eb925f08" translate="yes" xml:space="preserve">
          <source>Windows NT, WOW64</source>
          <target state="translated">윈도우 NT, WOW64</target>
        </trans-unit>
        <trans-unit id="e8e293f9ba55bd519e617bb25740cd26b038610b" translate="yes" xml:space="preserve">
          <source>Windows NT, Win64 on x64</source>
          <target state="translated">Windows NT, x64의 Win64</target>
        </trans-unit>
        <trans-unit id="1f7d7a7d59bb7043e9140971ef9251fab7982c2e" translate="yes" xml:space="preserve">
          <source>Windows OS/2 Bitmap Graphics</source>
          <target state="translated">Windows OS / 2 비트 맵 그래픽</target>
        </trans-unit>
        <trans-unit id="300a9414a515ce56cc07b2655723c865442c3bba" translate="yes" xml:space="preserve">
          <source>Windows icons</source>
          <target state="translated">Windows 아이콘</target>
        </trans-unit>
        <trans-unit id="d49fd423350dcd691fcb99fbae2181da74ce3859" translate="yes" xml:space="preserve">
          <source>Windows user agents have the following variations, where &lt;em&gt;x.y&lt;/em&gt; is the Windows NT version (for instance, Windows NT 6.1).</source>
          <target state="translated">Windows 사용자 에이전트에는 다음과 같은 변형이 있습니다. 여기서 &lt;em&gt;xy&lt;/em&gt; 는 Windows NT 버전입니다 (예 : Windows NT 6.1).</target>
        </trans-unit>
        <trans-unit id="8bd46cc0624bcd0f4f4799ef906d98088943324f" translate="yes" xml:space="preserve">
          <source>Windows version</source>
          <target state="translated">Windows 버전</target>
        </trans-unit>
        <trans-unit id="b11332c463e17df4dd657e0548f4afb71df66900" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;Save-Data: on&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="989504c4d96b544c144c0d90f1bbe95390e8d564" translate="yes" xml:space="preserve">
          <source>With Feature Policy, you opt-in to a set of &quot;policies&quot; for the browser to enforce on specific features used throughout a website. These policies restrict what APIs the site can access or modify the browser's default behavior for certain features.</source>
          <target state="translated">기능 정책을 사용하면 브라우저가 웹 사이트 전체에서 사용되는 특정 기능을 시행하도록 일련의 &quot;정책&quot;을 선택합니다. 이러한 정책은 사이트에서 특정 기능에 대한 브라우저의 기본 동작에 액세스하거나 수정할 수있는 API를 제한합니다.</target>
        </trans-unit>
        <trans-unit id="063d698928c501813d56323f470e5ed6d3986fb1" translate="yes" xml:space="preserve">
          <source>With TCP the default port, for an HTTP server on a computer, is port 80. Other ports can also be used, like 8000 or 8080. The URL of a page to fetch contains both the domain name, and the port number, though the latter can be omitted if it is 80. See &lt;a href=&quot;basics_of_http/identifying_resources_on_the_web&quot;&gt;Identifying resources on the Web&lt;/a&gt; for more details.</source>
          <target state="translated">TCP를 사용하면 컴퓨터의 HTTP 서버에 대한 기본 포트는 포트 80입니다. 8000 또는 8080과 같은 다른 포트도 사용할 수 있습니다. 가져올 페이지의 URL에는 도메인 이름과 포트 번호가 모두 포함됩니다. 80 인 경우 후자를 생략 할 수 있습니다. 자세한 내용 &lt;a href=&quot;basics_of_http/identifying_resources_on_the_web&quot;&gt;은 웹&lt;/a&gt; 에서 자원 식별 을 참조하십시오.</target>
        </trans-unit>
        <trans-unit id="287bd90b43fa4667e9fa5d74268b62d6241e8c36" translate="yes" xml:space="preserve">
          <source>With UTF-8 now being well-supported, being the preferred way of encoding characters, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;and to guarantee better privacy through less configuration-based entropy&lt;/a&gt;, browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8, Safari 5, Opera 11, Firefox 10 and Chrome 27 have abandoned this header.</source>
          <target state="translated">이제 UTF-8이 잘 지원되고, 선호되는 문자 인코딩 방법이며, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;구성 기반 엔트로피를 줄여 더 나은 개인 정보를 보장하기 위해&lt;/a&gt; 브라우저는 &lt;code&gt;Accept-Charset&lt;/code&gt; 헤더 (Internet Explorer 8, Safari 5, Opera 11, Firefox 10)를 생략합니다 . Chrome 27은이 헤더를 포기했습니다.</target>
        </trans-unit>
        <trans-unit id="a257ad9324f117394e2b9a6293c343f5ba6993ef" translate="yes" xml:space="preserve">
          <source>With UTF-8 now being well-supported, being the preferred way of encoding characters, &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;and to guarantee better privacy through less configuration-based entropy&lt;/a&gt;, most browsers omit the &lt;code&gt;Accept-Charset&lt;/code&gt; header: Internet Explorer 8, Safari 5, Opera 11 and Firefox 10 have abandoned this header.</source>
          <target state="translated">UTF-8은 이제 문자 인코딩 방식이 선호되고 &lt;a href=&quot;https://www.eff.org/deeplinks/2010/01/primer-information-theory-and-privacy&quot;&gt;구성 기반 엔트로피를 줄여 더 나은 개인 정보를 보장하기 위해&lt;/a&gt; 대부분의 브라우저에서 &lt;code&gt;Accept-Charset&lt;/code&gt; 헤더 (Internet Explorer 8, Safari 5, Opera 11 및 Firefox)를 생략합니다 . 10이 헤더를 버렸습니다.</target>
        </trans-unit>
        <trans-unit id="c4aa194cdaea498795c2710e4b593bbb786c966e" translate="yes" xml:space="preserve">
          <source>With agent-driven negotiation, selection of the best representation
   for a response is performed by the user agent after receiving an
   initial response from the origin server. Selection is based on a list
   of the available representations of the response included within the
   header fields or entity-body of the initial response, with each
   representation identified by its own URI. Selection from among the
   representations may be performed automatically (if the user agent is
   capable of doing so) or manually by the user selecting from a
   generated (possibly hypertext) menu.

   Agent-driven negotiation is advantageous when the response would vary
   over commonly-used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage.

   Agent-driven negotiation suffers from the disadvantage of needing a
   second request to obtain the best alternate representation. This
   second request is only efficient when caching is used. In addition,
   this specification does not define any mechanism for supporting
   automatic selection, though it also does not prevent any such
   mechanism from being developed as an extension and used within
   HTTP/1.1. 

   HTTP/1.1 defines the 300 (Multiple Choices) and 406 (Not Acceptable)
   status codes for enabling agent-driven negotiation when the server is
   unwilling or unable to provide a varying response using server-driven
   negotiation.</source>
          <target state="translated">에이전트 중심 협상에서는 응답에 대한 최상의 표현 선택이 원래 서버로부터 초기 응답을받은 후 사용자 에이전트가 수행합니다. 선택은 헤더 필드 또는 초기 응답의 엔티티 본문에 포함 된 응답의 사용 가능한 표시 목록을 기반으로하며 각 표시는 고유 한 URI로 식별됩니다. 표현들 중에서 선택은 자동으로 (사용자 에이전트가 그렇게 할 수있는 경우), 또는 사용자가 생성 된 (아마 하이퍼 텍스트) 메뉴로부터 선택함으로써 수동으로 수행 될 수있다. 에이전트 중심 협상은 원래 서버가 요청을 검사하여 사용자 에이전트의 기능을 확인할 수없는 경우 일반적으로 사용되는 차원 (예 : 유형, 언어 또는 인코딩)에 따라 응답이 달라질 때 유리합니다.일반적으로 퍼블릭 캐시를 사용하여 서버로드를 분산시키고 네트워크 사용량을 줄일 때. 에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱이 사용될 때만 효율적입니다. 또한이 사양에서는 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱이 사용될 때만 효율적입니다. 또한이 사양에서는 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.에이전트 중심 협상은 최상의 대체 표현을 얻기 위해 두 번째 요청이 필요하다는 단점이 있습니다. 이 두 번째 요청은 캐싱이 사용될 때만 효율적입니다. 또한이 사양에서는 자동 선택을 지원하는 메커니즘을 정의하지 않지만 이러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.이 명세는 자동 선택을 지원하는 메커니즘을 정의하지는 않지만 그러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 수 없거나 서버가 협상 할 수없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.이 명세는 자동 선택을 지원하는 메커니즘을 정의하지는 않지만 그러한 메커니즘이 확장으로 개발되어 HTTP / 1.1 내에서 사용되는 것을 막지는 않습니다. HTTP / 1.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 의사가 없거나 불가능한 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용되지 않음) 상태 코드를 정의합니다.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 의사가없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용 불가) 상태 코드를 정의합니다.1은 서버가 서버 중심 협상을 사용하여 다양한 응답을 제공 할 의사가없는 경우 에이전트 중심 협상을 가능하게하는 300 (여러 선택) 및 406 (허용 안 됨) 상태 코드를 정의합니다.</target>
        </trans-unit>
        <trans-unit id="7770029630372b0eac11793689759fe0480d9ff8" translate="yes" xml:space="preserve">
          <source>With an &amp;lt;iframe&amp;gt; element</source>
          <target state="translated">&amp;lt;iframe&amp;gt; 요소</target>
        </trans-unit>
        <trans-unit id="73763e7948769a9fcb45adc2ce4867d6d88c43a7" translate="yes" xml:space="preserve">
          <source>With external scripts</source>
          <target state="translated">외부 스크립트</target>
        </trans-unit>
        <trans-unit id="f470ad653a278fddde764ace4f49c6c4d0467b38" translate="yes" xml:space="preserve">
          <source>With reactive negotiation (a.k.a., agent-driven negotiation),
   selection of the best response representation (regardless of the
   status code) is performed by the user agent after receiving an
   initial response from the origin server that contains a list of
   resources for alternative representations.  If the user agent is not
   satisfied by the initial response representation, it can perform a
   GET request on one or more of the alternative resources, selected
   based on metadata included in the list, to obtain a different form of
   representation for that response.  Selection of alternatives might be
   performed automatically by the user agent or manually by the user
   selecting from a generated (possibly hypertext) menu.

   Note that the above refers to representations of the response, in
   general, not representations of the resource.  The alternative
   representations are only considered representations of the target
   resource if the response in which those alternatives are provided has
   the semantics of being a representation of the target resource (e.g.,
   a 200 (OK) response to a GET request) or has the semantics of
   providing links to alternative representations for the target
   resource (e.g., a 300 (Multiple Choices) response to a GET request).

   A server might choose not to send an initial representation, other
   than the list of alternatives, and thereby indicate that reactive
   negotiation by the user agent is preferred.  For example, the
   alternatives listed in responses with the 300 (Multiple Choices) and
   406 (Not Acceptable) status codes include information about the
   available representations so that the user or user agent can react by
   making a selection.

   Reactive negotiation is advantageous when the response would vary
   over commonly used dimensions (such as type, language, or encoding),
   when the origin server is unable to determine a user agent's
   capabilities from examining the request, and generally when public
   caches are used to distribute server load and reduce network usage. 

   Reactive negotiation suffers from the disadvantages of transmitting a
   list of alternatives to the user agent, which degrades user-perceived
   latency if transmitted in the header section, and needing a second
   request to obtain an alternate representation.  Furthermore, this
   specification does not define a mechanism for supporting automatic
   selection, though it does not prevent such a mechanism from being
   developed as an extension.</source>
          <target state="translated">사후 협상 (일명 에이전트 중심 협상)을 사용하면 상태 코드에 관계없이 최상의 응답 표현을 선택하여 대체 표현을위한 리소스 목록이 포함 된 원본 서버로부터 초기 응답을받은 후 사용자 에이전트가 수행합니다. 사용자 에이전트가 초기 응답 표현에 만족하지 않으면, 목록에 포함 된 메타 데이터에 기초하여 선택된 하나 이상의 대체 자원에 대해 GET 요청을 수행하여 해당 응답에 대한 다른 표현 형식을 얻을 수 있습니다. 대안의 선택은 사용자 에이전트에 의해 자동으로 수행되거나 사용자가 생성 된 (아마 하이퍼 텍스트) 메뉴에서 선택하여 수동으로 수행 될 수 있습니다. 위의 답변은 일반적으로 답변의 표현을 나타냅니다.자원의 표현이 아닙니다. 대안의 표현은 대안이 제공되는 응답이 목표 자원의 표현이라는 의미를 가지거나 (예를 들어, GET 요청에 대한 200 (OK) 응답) 의미를 갖는 경우에만 목표 자원의 표현으로 간주된다. 타겟 리소스에 대한 대안적인 표현들에 대한 링크를 제공하는 것 (예를 들어, GET 요청에 대한 300 (Multiple Choices) 응답). 서버는 대안 목록 이외의 초기 표현을 보내지 않기로 선택할 수 있으므로 사용자 에이전트의 반응 협상이 선호됨을 나타냅니다. 예를 들어300 (Multiple Choices) 및 406 (Not Acceptable) 상태 코드에 대한 응답으로 나열된 대안에는 사용 가능한 표현에 대한 정보가 포함되므로 사용자 또는 사용자 에이전트가 선택하여 반응 할 수 있습니다. 응답이 일반적으로 사용되는 차원 (예 : 유형, 언어 또는 인코딩)에 따라 다를 경우, 오리진 서버가 요청을 검사하여 사용자 에이전트의 기능을 판별 할 수없는 경우 및 일반적으로 공개 캐시를 사용하여 분배하는 경우 반응성 협상이 유리합니다. 서버로드 및 네트워크 사용량 감소 반응성 협상은 대안의 목록을 사용자 에이전트에 전송하는 단점이 있으며, 이는 헤더 섹션에서 전송되는 경우 사용자-지각 대기 시간을 저하 시키며, 다른 표현을 얻기 위해 제 2 요청을 필요로한다.또한, 본 명세서는 자동 선택을 지원하기위한 메커니즘을 정의하지 않지만, 그러한 메커니즘이 확장으로서 개발되는 것을 막지는 않는다.</target>
        </trans-unit>
        <trans-unit id="f8cb0ac82812058c0694f7c5a07bb9f285a50bcb" translate="yes" xml:space="preserve">
          <source>With the &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt; method you are able to implement this. The client first reads the original files, modifies them, and finally pushes them to the server:</source>
          <target state="translated">으로 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; 의&lt;/a&gt; 방법이 구현 할 수 있습니다. 클라이언트는 먼저 원본 파일을 읽고 수정 한 다음 서버로 푸시합니다.</target>
        </trans-unit>
        <trans-unit id="5a4f6110e1e61b04fbe62fb541b4c16a90b6d7dd" translate="yes" xml:space="preserve">
          <source>With the above header set on a domain example.com that wants to migrate from HTTP to HTTPS, non-navigational insecure resource requests are automatically upgraded (first-party as well as third-party requests).</source>
          <target state="translated">HTTP에서 HTTPS로 마이그레이션하려는 도메인 example.com에 위의 헤더가 설정되어 있으면 비 탐색적인 안전하지 않은 리소스 요청이 자동으로 업그레이드됩니다 (타사 및 타사 요청).</target>
        </trans-unit>
        <trans-unit id="538d5b744abf2a80cab094727a14a51501db7d8c" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;multipart/form-data&lt;/code&gt;, used in the &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; method of &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML Forms&lt;/a&gt;, and &lt;code&gt;multipart/byteranges&lt;/code&gt;, used with &lt;a href=&quot;../status/206&quot;&gt;&lt;code&gt;206&lt;/code&gt;&lt;/a&gt;&lt;code&gt;Partial Content&lt;/code&gt; to send part of a document, HTTP doesn't handle multipart documents in a special way: the message is transmitted to the browser (which will likely show a &quot;Save As&quot; window if it doesn't know how to display the document).</source>
          <target state="translated">를 제외하고 &lt;code&gt;multipart/form-data&lt;/code&gt; 에 사용, &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; 의&lt;/a&gt; 방법 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms&quot;&gt;HTML 양식&lt;/a&gt; 및 &lt;code&gt;multipart/byteranges&lt;/code&gt; 사용, &lt;a href=&quot;../status/206&quot;&gt; &lt;code&gt;206&lt;/code&gt; &lt;/a&gt; &lt;code&gt;Partial Content&lt;/code&gt; 문서의 일부를 보내, HTTP는 특별한 방법으로 다중 문서를 처리하지 않습니다 : 메시지를 브라우저로 전송됩니다 (문서를 표시하는 방법을 모르는 경우 &quot;다른 이름으로 저장&quot;창이 표시 될 수 있음).</target>
        </trans-unit>
        <trans-unit id="708d2e1600bcd9604e2edeccc4c3fd62c52a3c1a" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;a href=&quot;../content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; header and the &lt;a href=&quot;report-uri&quot;&gt;&lt;code&gt;report-uri&lt;/code&gt;&lt;/a&gt; directive, you can set-up an enforced policy and a reported policy like this:</source>
          <target state="translated">의 도움으로 &lt;a href=&quot;../content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; 헤더와 &lt;a href=&quot;report-uri&quot;&gt; &lt;code&gt;report-uri&lt;/code&gt; &lt;/a&gt; 지시, 당신은 설정 할 수있는 강화 정책이 같은보고 정책을 :</target>
        </trans-unit>
        <trans-unit id="044b9dbdfbd69bd21aa2b1d882b33557eda54a7b" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;../headers/if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you can detect mid-air edit collisions.</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 및 &lt;a href=&quot;../headers/if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더 의 도움으로 공중 편집 충돌을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="105d80b763f419ce22176e98ecfdc97c5f8387a4" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you are able to detect mid-air edit collisions.</source>
          <target state="translated">의 도움으로 &lt;code&gt;ETag&lt;/code&gt; 및 &lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더, 당신은 공중 편집 충돌을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="5ddd17a77e3eb820e93844f51c9bd5df55066992" translate="yes" xml:space="preserve">
          <source>With the help of the &lt;code&gt;ETag&lt;/code&gt; and the &lt;a href=&quot;if-match&quot;&gt;&lt;code&gt;If-Match&lt;/code&gt;&lt;/a&gt; headers, you can detect mid-air edit collisions.</source>
          <target state="translated">&lt;code&gt;ETag&lt;/code&gt; 및 &lt;a href=&quot;if-match&quot;&gt; &lt;code&gt;If-Match&lt;/code&gt; &lt;/a&gt; 헤더 의 도움으로 공중 편집 충돌을 감지 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="512239b40fd41d01554678757db96317e6284079" translate="yes" xml:space="preserve">
          <source>With the help of the new HTTP headers, the ability to transmit other documents than plain HTML files has been added (thanks to the &lt;a href=&quot;../headers/content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt; header).</source>
          <target state="translated">새로운 HTTP 헤더 덕분에 일반 HTML 파일 이외의 다른 문서를 전송하는 기능이 추가되었습니다 ( &lt;a href=&quot;../headers/content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; 헤더 덕분에 ).</target>
        </trans-unit>
        <trans-unit id="1a7203df4fb0cc96a3946c892f2dac6dbefbb1dc" translate="yes" xml:space="preserve">
          <source>With these techniques, you can configure your server to respond correctly for both, the www-prefixed and the non-www-prefixed domains. It is good advice to do this since you can't predict which URL users will type in their browser's URL bar. It is a matter of choosing which type you want to use as your canonical location, then redirecting the other type to it.</source>
          <target state="translated">이러한 기술을 사용하면 www-prefixed 도메인과 www-prefixed 도메인이 아닌 도메인 모두에 대해 올바르게 응답하도록 서버를 구성 할 수 있습니다. 브라우저의 URL 표시 줄에 입력 할 URL 사용자를 예측할 수 없으므로이 작업을 수행하는 것이 좋습니다. 정식 위치로 사용할 유형을 선택한 다음 다른 유형을 해당 유형으로 리디렉션해야합니다.</target>
        </trans-unit>
        <trans-unit id="6d1c75c7baf134aba78012137949996ebe9070b0" translate="yes" xml:space="preserve">
          <source>With three possibilities for URL redirections, several methods can be specified at the same time, but which one is applied first? The order of precedence is the following:</source>
          <target state="translated">URL 리디렉션에 대한 세 가지 가능성을 통해 여러 방법을 동시에 지정할 수 있지만 어떤 방법이 먼저 적용됩니까? 우선 순위는 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="a418f3a1c01fcbf5c90b703d052201992e5fb874" translate="yes" xml:space="preserve">
          <source>With three ways to trigger redirections, several ways can be used at the same time. But which is applied first?</source>
          <target state="translated">리디렉션을 트리거하는 세 가지 방법을 통해 여러 가지 방법을 동시에 사용할 수 있습니다. 그러나 어느 것이 먼저 적용됩니까?</target>
        </trans-unit>
        <trans-unit id="8d9a1622681b851d7c25eb0b098d9f03d2637d4a" translate="yes" xml:space="preserve">
          <source>Without &lt;code&gt;Save-Data&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8be0bede91ceb6ad718250a6be05f374208c9a0" translate="yes" xml:space="preserve">
          <source>Worker support</source>
          <target state="translated">근로자 지원</target>
        </trans-unit>
        <trans-unit id="dd81953275e4c603fc6e296163f16395c6ee5da7" translate="yes" xml:space="preserve">
          <source>Working Draft</source>
          <target state="translated">작업 초안</target>
        </trans-unit>
        <trans-unit id="37c6e1e814485ae2acb0d7377a8e62b4414e27eb" translate="yes" xml:space="preserve">
          <source>Working code samples</source>
          <target state="translated">작업 코드 샘플</target>
        </trans-unit>
        <trans-unit id="eacebc1ffedb674ae5bd64f058688530e875da85" translate="yes" xml:space="preserve">
          <source>Workspaces are server-defined groups of Collections.  The &quot;app:
   workspace&quot; element contains zero or more app:collection elements
   describing the Collections of Resources available for editing.

   appWorkspace =
      element app:workspace {
         appCommonAttributes,
         ( atomTitle
           &amp;amp; appCollection*
           &amp;amp; extensionSansTitleElement* )
      }

   atomTitle = element atom:title { atomTextConstruct }</source>
          <target state="translated">작업 공간은 서버 정의 모음 모음입니다. &quot;app : workspace&quot;요소에는 편집 가능한 자원 콜렉션을 설명하는 app : collection 요소가 0 개 이상 있습니다. appWorkspace = 요소 app : workspace {appCommonAttributes, (atomTitle &amp;amp; appCollection * &amp;amp; extensionSansTitleElement *)} atomTitle = 요소 atom : title {atomTextConstruct}</target>
        </trans-unit>
        <trans-unit id="79a153310ffa336984498274d184537ce99e3457" translate="yes" xml:space="preserve">
          <source>Writing a policy</source>
          <target state="translated">정책 작성</target>
        </trans-unit>
        <trans-unit id="b1d3f473c48021046e7ba3468f5cf21e1b0e7ddd" translate="yes" xml:space="preserve">
          <source>X-Content-Type-Options</source>
          <target state="translated">X-Content-Type-Options</target>
        </trans-unit>
        <trans-unit id="25731e7aec64e37cf5913bb14adeca448b936ee9" translate="yes" xml:space="preserve">
          <source>X-DNS-Prefetch-Control</source>
          <target state="translated">X-DNS-Prefetch-Control</target>
        </trans-unit>
        <trans-unit id="08a62266c2fee44d28f2a09bdc63f0cb3203d151" translate="yes" xml:space="preserve">
          <source>X-Forwarded-For</source>
          <target state="translated">X-Forwarded-For</target>
        </trans-unit>
        <trans-unit id="3dfd27b5c348953dd22222a659a5031713ce4ff1" translate="yes" xml:space="preserve">
          <source>X-Forwarded-Host</source>
          <target state="translated">X-Forwarded-Host</target>
        </trans-unit>
        <trans-unit id="5f77b69d4a9a12e6be323362589ebb4520c18095" translate="yes" xml:space="preserve">
          <source>X-Forwarded-Proto</source>
          <target state="translated">X-Forwarded-Proto</target>
        </trans-unit>
        <trans-unit id="06d18ff7a6daa0422e0cad3f72e863617cee9d06" translate="yes" xml:space="preserve">
          <source>X-Frame-Options</source>
          <target state="translated">X-Frame-Options</target>
        </trans-unit>
        <trans-unit id="8c52affc192efbc43d6163a7df7a9d01beb38c0f" translate="yes" xml:space="preserve">
          <source>X-Webkit-CSP</source>
          <target state="translated">X-Webkit-CSP</target>
        </trans-unit>
        <trans-unit id="c7215a317b6dd9b4629392c1b06074727d0d0713" translate="yes" xml:space="preserve">
          <source>X-XSS-Protection</source>
          <target state="translated">X-XSS-Protection</target>
        </trans-unit>
        <trans-unit id="4e111db7771a9e3cb485a634fdca19d4a087bf84" translate="yes" xml:space="preserve">
          <source>X.509v3 certificate extension to allow embedding of signed certificate timestamps issued by individual logs</source>
          <target state="translated">개별 로그에서 발행 한 서명 된 인증서 타임 스탬프를 포함 할 수있는 X.509v3 인증서 확장</target>
        </trans-unit>
        <trans-unit id="fcf9ac265948c22972f4a00525a49dcdca8ded84" translate="yes" xml:space="preserve">
          <source>X.X.X.Y</source>
          <target state="translated">X.X.X.Y</target>
        </trans-unit>
        <trans-unit id="ffa12f27ac48a1ab5dd93d501704d6f43ec578fa" translate="yes" xml:space="preserve">
          <source>XHTML</source>
          <target state="translated">XHTML</target>
        </trans-unit>
        <trans-unit id="02faa7587ad581423c40a3b14ac82860aadd96d3" translate="yes" xml:space="preserve">
          <source>XML elements defined by this specification MAY have an &quot;xml:base&quot;
   attribute [&lt;a href=&quot;#ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt;].  When xml:base is used, it serves the
   function described in &lt;a href=&quot;#section-5.1.1&quot;&gt;Section 5.1.1&lt;/a&gt; of URI Generic Syntax [&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt;],
   by establishing the base URI (or IRI, Internationalized Resource
   Identifier [&lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt;]) for resolving relative references found within
   the scope of the &quot;xml:base&quot; attribute.

   Any element defined by this specification MAY have an &quot;xml:lang&quot;
   attribute, whose content indicates the natural language for the
   element and its descendants.  Requirements regarding the content and
   interpretation of &quot;xml:lang&quot; are specified in &lt;a href=&quot;#section-2.12&quot;&gt;Section 2.12&lt;/a&gt; of XML 1.0
   [&lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;].</source>
          <target state="translated">이 규격에 의해 정의 된 XML 요소는 &quot;xml : base&quot;속성 [ &lt;a href=&quot;#ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt; ]을 가질 수 있다. xml : base를 사용하는 경우 xml : base는 범위 내에서 발견 된 상대 참조를 해결하기위한 기본 URI (또는 IRI, 국제화 된 자원 식별자 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC3987&lt;/a&gt; ])를 설정하여 URI 일반 구문 [ &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC3986&lt;/a&gt; ]의 &lt;a href=&quot;#section-5.1.1&quot;&gt;5.1.1 절에&lt;/a&gt; 설명 된 기능을 수행합니다. &quot;xml : base&quot;속성 이 규격에 의해 정의 된 모든 요소는 &quot;xml : lang&quot;속성을 가질 수 있으며, 그 내용은 그 요소와 그 자손의 자연어를 나타낸다. &quot;xml : lang&quot;의 내용과 해석에 관한 요구 사항 은 XML 1의 &lt;a href=&quot;#section-2.12&quot;&gt;2.12 절에&lt;/a&gt; 명시되어있다 .0 [ &lt;a href=&quot;#ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ].</target>
        </trans-unit>
        <trans-unit id="118d184a6966521bcc7ff20a77721ff4e779ff1c" translate="yes" xml:space="preserve">
          <source>XML is a flexible data format that makes it easy to submit data that
   appears legal but in fact is not.  The philosophy of &quot;Be flexible in
   what you accept and strict in what you send&quot; still applies, but it
   must not be applied inappropriately.  XML is extremely flexible in
   dealing with issues of whitespace, element ordering, inserting new
   elements, etc.  This flexibility does not require extension,
   especially not in the area of the meaning of elements.

   There is no kindness in accepting illegal combinations of XML
   elements.  At best, it will cause an unwanted result and at worst it
   can cause real damage.</source>
          <target state="translated">XML은 유연한 것처럼 보이지만 실제로는 적합하지 않은 데이터를 쉽게 제출할 수있는 유연한 데이터 형식입니다. &quot;수락하는 것에 융통성 있고 발송하는 것에 엄격하게&quot;라는 철학이 여전히 적용되지만, 부적절하게 적용되어서는 안됩니다. XML은 공백, 요소 순서, 새로운 요소 삽입 등의 문제를 처리 할 때 매우 유연합니다. 이러한 유연성은 특히 요소의 의미 영역이 아닌 확장을 필요로하지 않습니다. XML 요소의 잘못된 조합을 받아들이는 것은 친절하지 않습니다. 기껏해야 원치 않는 결과를 초래하고 최악의 경우 실제 피해를 입을 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="9ac1e607d8b04259c13b0dc929c5a55b74dd33cb" translate="yes" xml:space="preserve">
          <source>XML namespaces disambiguate WebDAV property names and XML elements.
   Any WebDAV user or application can define a new namespace in order to
   create custom properties or extend WebDAV XML syntax.  IANA does not
   need to manage such namespaces, property names, or element names.</source>
          <target state="translated">XML 네임 스페이스는 WebDAV 속성 이름과 XML 요소를 명확하게합니다. 모든 WebDAV 사용자 또는 애플리케이션은 사용자 정의 특성을 작성하거나 WebDAV XML 구문을 확장하기 위해 새 네임 스페이스를 정의 할 수 있습니다. IANA는 이러한 네임 스페이스, 속성 이름 또는 요소 이름을 관리 할 필요가 없습니다.</target>
        </trans-unit>
        <trans-unit id="ec22a72705e20935a57158e733e78bdae4f2f2cd" translate="yes" xml:space="preserve">
          <source>XML supports a facility known as &quot;external entities&quot;, defined in
   Section 4.2.2 of [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;], which instructs an XML processor to
   retrieve and include additional XML.  An external XML entity can be
   used to append or modify the document type declaration (DTD)
   associated with an XML document.  An external XML entity can also be
   used to include XML within the content of an XML document.  For non-
   validating XML, such as the XML used in this specification, including
   an external XML entity is not required by XML.  However, XML does
   state that an XML processor may, at its discretion, include the
   external XML entity.

   External XML entities have no inherent trustworthiness and are
   subject to all the attacks that are endemic to any HTTP GET request.
   Furthermore, it is possible for an external XML entity to modify the
   DTD, and hence affect the final form of an XML document, in the worst
   case, significantly modifying its semantics or exposing the XML
   processor to the security risks discussed in [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt;].  Therefore,
   implementers must be aware that external XML entities should be
   treated as untrustworthy.  If a server chooses not to handle external
   XML entities, it SHOULD respond to requests containing external
   entities with the 'no-external-entities' condition code.

   There is also the scalability risk that would accompany a widely
   deployed application that made use of external XML entities.  In this
   situation, it is possible that there would be significant numbers of
   requests for one external XML entity, potentially overloading any 

   server that fields requests for the resource containing the external
   XML entity.

   Furthermore, there's also a risk based on the evaluation of &quot;internal
   entities&quot; as defined in Section 4.2.2 of [&lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;].  A small,
   carefully crafted request using nested internal entities may require
   enormous amounts of memory and/or processing time to process.  Server
   implementers should be aware of this risk and configure their XML
   parsers so that requests like these can be detected and rejected as
   early as possible.</source>
          <target state="translated">XML은 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML의&lt;/a&gt; 4.2.2 절에 정의 된 &quot;외부 엔티티&quot;라는 기능을 지원합니다.]는 XML 프로세서가 추가 XML을 검색하고 포함하도록 지시합니다. 외부 XML 엔터티를 사용하여 XML 문서와 관련된 DTD (Document Type Declaration)를 추가하거나 수정할 수 있습니다. 외부 XML 엔터티를 사용하여 XML 문서의 내용에 XML을 포함시킬 수도 있습니다. 외부 XML 엔터티를 포함하여이 사양에 사용 된 XML과 같은 비 유효 XML의 경우 XML에 필요하지 않습니다. 그러나 XML은 XML 프로세서가 재량에 따라 외부 XML 엔터티를 포함 할 수 있다고 명시합니다. 외부 XML 엔터티에는 고유 한 신뢰성이 없으며 모든 HTTP GET 요청에 고유 한 모든 공격이 적용됩니다. 또한 외부 XML 엔터티가 DTD를 수정할 수 있으므로 최악의 경우 XML 문서의 최종 양식에 영향을 미칩니다.시맨틱 스를 대폭 수정하거나 XML 프로세서를 [&lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC3023&lt;/a&gt; ]. 따라서 구현자는 외부 XML 엔터티를 신뢰할 수없는 것으로 취급해야한다는 것을 알고 있어야합니다. 서버가 외부 XML 엔터티를 처리하지 않기로 선택한 경우 '외부 엔터티 없음'조건 코드로 외부 엔터티를 포함하는 요청에 응답해야합니다. 외부 XML 엔터티를 사용하는 광범위하게 배포 된 응용 프로그램과 함께 발생할 수있는 확장 성 위험도 있습니다. 이 상황에서 하나의 외부 XML 엔티티에 대한 요청이 상당히 많아 외부 XML 엔티티를 포함하는 자원에 대한 요청을 처리하는 서버를 오버로드 할 수 있습니다. 또한 [ &lt;a href=&quot;#ref-REC-XML&quot;&gt;REC-XML의&lt;/a&gt; 4.2.2 절에 정의 된 &quot;내부 엔티티&quot;의 평가에 따른 위험도 있습니다]. 중첩 된 내부 엔터티를 사용하여 작고 정교하게 제작 된 요청에는 처리하는 데 엄청난 양의 메모리 및 / 또는 처리 시간이 필요할 수 있습니다. 서버 구현자는 이러한 위험을 알고 XML 구문 분석기를 구성하여 이와 같은 요청을 가능한 빨리 발견하고 거부 할 수 있도록해야합니다.</target>
        </trans-unit>
        <trans-unit id="b52535bbad4c67580746ea1c2e2d0547fde6a67a" translate="yes" xml:space="preserve">
          <source>XML supports two mechanisms for indicating that an XML element does
   not have any content.  The first is to declare an XML element of the
   form &amp;lt;A&amp;gt;&amp;lt;/A&amp;gt;.  The second is to declare an XML element of the form
   &amp;lt;A/&amp;gt;.  The two XML elements are semantically identical.</source>
          <target state="translated">XML은 XML 요소에 내용이 없음을 나타내는 두 가지 메커니즘을 지원합니다. 첫 번째는 &amp;lt;A&amp;gt; &amp;lt;/A&amp;gt; 형식의 XML 요소를 선언하는 것입니다. 두 번째는 &amp;lt;A/&amp;gt; 형식의 XML 요소를 선언하는 것입니다. 두 XML 요소는 의미 상 동일합니다.</target>
        </trans-unit>
        <trans-unit id="b1a146ce24fcf201b49e752836700a2313cfce76" translate="yes" xml:space="preserve">
          <source>XUL</source>
          <target state="translated">XUL</target>
        </trans-unit>
        <trans-unit id="db9a9676b638863e69493a0d059f3d23b2a78eff" translate="yes" xml:space="preserve">
          <source>Y. Y. Goland
   Microsoft Corporation
   One Microsoft Way
   Redmond, WA 98052-6399
   EMail: yarong@microsoft.com


   E. J. Whitehead, Jr.
   Dept. Of Information and Computer Science
   University of California, Irvine
   Irvine, CA 92697-3425
   EMail: ejw@ics.uci.edu


   A. Faizi
   Netscape
   685 East Middlefield Road
   Mountain View, CA 94043
   EMail: asad@netscape.com 

   S. R. Carter
   Novell
   1555 N. Technology Way
   M/S ORM F111
   Orem, UT 84097-2399
   EMail: srcarter@novell.com


   D. Jensen
   Novell
   1555 N. Technology Way
   M/S ORM F111
   Orem, UT 84097-2399
   EMail: dcjensen@novell.com</source>
          <target state="translated">YY Goland Microsoft Corporation One Microsoft Way Redmond, WA 98052-6399 전자 메일 : yarong@microsoft.com EJ Whitehead, Jr. 캘리포니아 얼바인 어바인 정보 및 컴퓨터 과학 대학교 캘리포니아 92697-3425 전자 메일 : ejw@ics.uci .edu A. Faizi Netscape 685 East Middlefield Road Mountain View, CA 94043 이메일 : asad@netscape.com SR Carter Novell 1555 N. 기술 방식 M / S ORM F111 Orem, UT 84097-2399 이메일 : srcarter@novell.com D. Jensen Novell 1555 N. Technology Way M / S ORM F111 Orem, UT 84097-2399 이메일 : dcjensen@novell.com</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="4d3f42eded5122aabb45ffd503cae790ee48da1e" translate="yes" xml:space="preserve">
          <source>Yes. If this directive is absent, the user agent will look for the &lt;a href=&quot;script-src&quot;&gt;&lt;code&gt;script-src&lt;/code&gt;&lt;/a&gt; directive, and if both of them are absent, fallback to &lt;code&gt;default-src&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c86dc951019a61bfb343cfd298b71ebc36c9f7a3" translate="yes" xml:space="preserve">
          <source>Yes. If this directive is absent, the user agent will look for the &lt;a href=&quot;style-src&quot;&gt;&lt;code&gt;style-src&lt;/code&gt;&lt;/a&gt; directive, and if both of them are absent, fallback to &lt;code&gt;default-src&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a82ce976af425a56eaeeaa127b4f030cbb2bf55" translate="yes" xml:space="preserve">
          <source>Yes. If this directive is absent, the user agent will look for the &lt;code&gt;default-src&lt;/code&gt; directive.</source>
          <target state="translated">예. 이 지시문이 없으면 사용자 에이전트는 &lt;code&gt;default-src&lt;/code&gt; 지시문을 찾습니다 .</target>
        </trans-unit>
        <trans-unit id="a03d0938eab0d6ee22b27cb1b4a301b73e8ef58d" translate="yes" xml:space="preserve">
          <source>You can also configure a site to allow any site to access it by using the &lt;code&gt;&quot;*&quot;&lt;/code&gt; wildcard. You should only use this for public APIs. Private APIs should never use &lt;code&gt;&quot;*&quot;&lt;/code&gt;, and should instead have a specific domain or domains set. In addition, the wildcard only works for requests made with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;&quot;anonymous&quot;&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&quot;*&quot;&lt;/code&gt; 와일드 카드를 사용하여 사이트에서 액세스 할 수 있도록 사이트를 구성 할 수도 있습니다 . 공개 API에만 사용해야합니다. 개인 API는 &lt;code&gt;&quot;*&quot;&lt;/code&gt; 를 사용 해서는 안되며 대신 특정 도메인을 설정해야합니다. 또한 와일드 카드는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 속성이 &lt;code&gt;&quot;anonymous&quot;&lt;/code&gt; 로 설정된 요청에 대해서만 작동합니다 .</target>
        </trans-unit>
        <trans-unit id="75af7d57fd721f02bd6ba3587fe6812772fb7fcf" translate="yes" xml:space="preserve">
          <source>You can also configure a site to allow any site to access it by using the &lt;code&gt;*&lt;/code&gt; wildcard. You should only use this for public APIs. Private APIs should never use &lt;code&gt;*&lt;/code&gt;, and should instead have a specific domain or domains set. In addition, the wildcard only works for requests made with the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; attribute set to &lt;code&gt;anonymous&lt;/code&gt;, and it prevents sending credentials like cookies in requests.</source>
          <target state="translated">&lt;code&gt;*&lt;/code&gt; 와일드 카드 를 사용하여 모든 사이트가 액세스 할 수 있도록 사이트를 구성 할 수도 있습니다 . 공용 API에만 사용해야합니다. 비공개 API는 &lt;code&gt;*&lt;/code&gt; 를 사용해서는 안되며 , 대신 특정 도메인을 설정해야합니다. 또한 와일드 카드는 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes#attr-crossorigin&quot;&gt;crossorigin&lt;/a&gt;&lt;/code&gt; 속성이 &lt;code&gt;anonymous&lt;/code&gt; 로 설정된 요청에 대해서만 작동하며 요청 에서 쿠키와 같은 자격 증명을 보내는 것을 방지합니다.</target>
        </trans-unit>
        <trans-unit id="e8c5b12eb050dfd4399098b193f351f4fbac43c5" translate="yes" xml:space="preserve">
          <source>You can also set referrer policies in HTML documents. For example, by using a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;name of &lt;code&gt;referrer&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">HTML 문서에서 리퍼러 정책을 설정할 수도 있습니다. 예를 들어, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;이름이 &lt;/a&gt; &lt;code&gt;referrer&lt;/code&gt; 인&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소를 사용하면 다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="195c470c8c8c727452226fead2121e4e2e15995a" translate="yes" xml:space="preserve">
          <source>You can also set referrer policies inside HTML. For example, you can set the referrer policy for the entire document with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;name&lt;/a&gt; of &lt;code&gt;referrer&lt;/code&gt;:</source>
          <target state="translated">HTML 내에서 리퍼러 정책을 설정할 수도 있습니다. 예를 들어,와 전체 문서의 참조 자 정책을 설정할 수 있습니다 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; A의 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-name&quot;&gt;이름&lt;/a&gt; 의 &lt;code&gt;referrer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="306b4bc212db26d3f47d487dfdbe512922fd95bc" translate="yes" xml:space="preserve">
          <source>You can also upgrade an HTTP/1.1 connection to TLS/1.0. The main advantages to this are that you can avoid using URL redirection from &quot;http://&quot; to &quot;https://&quot; on the server and you can easily use TLS on virtual hosts. This may, however, introduce problems with proxy servers.</source>
          <target state="translated">HTTP / 1.1 연결을 TLS / 1.0으로 업그레이드 할 수도 있습니다. 이것의 주요 장점은 서버에서 &quot;http : //&quot;에서 &quot;https : //&quot;로 URL 리디렉션을 사용하지 않고 가상 호스트에서 TLS를 쉽게 사용할 수 있다는 것입니다. 그러나 프록시 서버에 문제가 발생할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a8f33154995cf629f0c4dcbdc756b5ef348aae13" translate="yes" xml:space="preserve">
          <source>You can also use the &lt;code&gt;&quot;wss://&quot;&lt;/code&gt; URL scheme to open a secure WebSocket connection.</source>
          <target state="translated">당신은 또한 사용할 수있는 &lt;code&gt;&quot;wss://&quot;&lt;/code&gt; URL 방식을 안전한 웹 소켓 연결을 엽니 다.</target>
        </trans-unit>
        <trans-unit id="bb8c719f47766046067ab4ba3d9d63932f7735fd" translate="yes" xml:space="preserve">
          <source>You can either send the &lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; header server-side, or from individual documents, using the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt;&lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt;&lt;/a&gt; element, like this:</source>
          <target state="translated">&lt;code&gt;X-DNS-Prefetch-Control&lt;/code&gt; 과 같이 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta&quot;&gt; &lt;code&gt;&amp;lt;meta&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 의 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#attr-http-equiv&quot;&gt;http-equiv&lt;/a&gt;&lt;/code&gt; 속성을 사용하여 X-DNS-Prefetch-Control 헤더를 서버 측으로 보내 거나 개별 문서에서 보낼 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="b9b490f6db58176d0a61ab78a69dbead300c1e16" translate="yes" xml:space="preserve">
          <source>You can force the lookup of specific hostnames without providing specific anchors using that hostname by using the &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel&quot;&gt;rel&lt;/a&gt;&lt;/code&gt; attribute on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt;&lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt;&lt;/a&gt; element with a &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;link type&lt;/a&gt; of &lt;code&gt;dns-prefetch&lt;/code&gt;:</source>
          <target state="translated">사용자는 사용하는 특정 호스트를 사용하여 앵커를 설치하지 않고, 특정의 호스트 이름 조회를 강제 &lt;code&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link#attr-rel&quot;&gt;rel&lt;/a&gt;&lt;/code&gt; 온 특성 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link&quot;&gt; &lt;code&gt;&amp;lt;link&amp;gt;&lt;/code&gt; &lt;/a&gt; A의 요소 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Link_types&quot;&gt;링크 타입&lt;/a&gt; 의 &lt;code&gt;dns-prefetch&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="890b436866aa7fec0eb591186b42b85551101fe8" translate="yes" xml:space="preserve">
          <source>You can help by &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Document_an_HTTP_header&quot;&gt;writing new entries&lt;/a&gt; or improving the existing ones.</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/MDN/Contribute/Howto/Document_an_HTTP_header&quot;&gt;새 항목&lt;/a&gt; 을 쓰거나 기존 항목을 개선하여 도움을 줄 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="96ce688732a8f6b1cb94cb7b41110ff4f689fbef" translate="yes" xml:space="preserve">
          <source>You can only access certain features like &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer&quot;&gt;&lt;code&gt;SharedArrayBuffer&lt;/code&gt;&lt;/a&gt; objects or &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Performance/now&quot;&gt;&lt;code&gt;Performance.now()&lt;/code&gt;&lt;/a&gt; with unthrottled timers, if your document has a COEP header with the value &lt;code&gt;require-corp&lt;/code&gt; value set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b351d15f45462c98aeea68c3d35a05714734814" translate="yes" xml:space="preserve">
          <source>You can reverse this setting by setting &lt;code&gt;content&lt;/code&gt; to &quot;&lt;code&gt;on&lt;/code&gt;&quot;.</source>
          <target state="translated">&lt;code&gt;content&lt;/code&gt; 를 &quot; &lt;code&gt;on&lt;/code&gt; &quot; 으로 설정하여이 설정을 되돌릴 수 있습니다 .</target>
        </trans-unit>
        <trans-unit id="48019a7a0d5588a4850584f68a3a5d5553f14588" translate="yes" xml:space="preserve">
          <source>You can send the &lt;code&gt;Feature-Policy&lt;/code&gt; HTTP header with the response of a page. The value of this header is a policy to be enforced by the browser for the given page. It has the following structure.</source>
          <target state="translated">페이지의 응답으로 &lt;code&gt;Feature-Policy&lt;/code&gt; HTTP 헤더를 보낼 수 있습니다 . 이 헤더의 값은 주어진 페이지에 대해 브라우저에 의해 시행되는 정책입니다. 다음과 같은 구조로되어 있습니다.</target>
        </trans-unit>
        <trans-unit id="2ec4c974ab1c86414a17cf253dd66c5aafec5c62" translate="yes" xml:space="preserve">
          <source>You can specify multiple links separated by commas, for example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bfa7d772cf31ca26fbcc1e9d0f1daf1147032db" translate="yes" xml:space="preserve">
          <source>You can use a hash-source to only allow specific inline style blocks:</source>
          <target state="translated">해시 소스를 사용하여 특정 인라인 스타일 블록 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="544765b693d9f6cf73fb8f6dc3d703f7a471c0a9" translate="yes" xml:space="preserve">
          <source>You can use a nonce-source to only allow specific inline script blocks:</source>
          <target state="translated">nonce-source를 사용하여 특정 인라인 스크립트 블록 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="7e8d2670c21852aa6796fac3bb46c156114c42df" translate="yes" xml:space="preserve">
          <source>You can use a nonce-source to only allow specific inline style blocks:</source>
          <target state="translated">nonce-source를 사용하여 특정 인라인 스타일 블록 만 허용 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a65bfc91cd3f3591eaf8300d226b1df9b91b92b3" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;headers/content-security-policy&quot;&gt;&lt;code&gt;Content-Security-Policy&lt;/code&gt;&lt;/a&gt; HTTP header to specify your policy, like this:</source>
          <target state="translated">당신이 사용할 수있는 &lt;a href=&quot;headers/content-security-policy&quot;&gt; &lt;code&gt;Content-Security-Policy&lt;/code&gt; &lt;/a&gt; 과 같이 정책을 지정 HTTP 헤더를 :</target>
        </trans-unit>
        <trans-unit id="d6b308802143863f61fdfd923956be0f5c92e18a" translate="yes" xml:space="preserve">
          <source>You can use the &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt;&lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt;&lt;/a&gt; HTTP header to specify your policy, like this:</source>
          <target state="translated">당신이 사용할 수있는 &lt;a href=&quot;headers/content-security-policy-report-only&quot;&gt; &lt;code&gt;Content-Security-Policy-Report-Only&lt;/code&gt; &lt;/a&gt; HTTP 헤더이 같은 정책을 지정하려면 :</target>
        </trans-unit>
        <trans-unit id="eb5f5c27a50e86c2cf442e41b9e616e143082854" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header more than once like in the example below. Pay special attention to the &lt;a href=&quot;content-security-policy/connect-src&quot;&gt;&lt;code&gt;connect-src&lt;/code&gt;&lt;/a&gt; directive here. Even though the second policy would allow the connection, the first policy contains &lt;code&gt;connect-src 'none'&lt;/code&gt;. Adding additional policies &lt;em&gt;can only further restrict&lt;/em&gt; the capabilities of the protected resource, which means that there will be no connection allowed and, as the strictest policy, &lt;code&gt;connect-src 'none'&lt;/code&gt; is enforced.</source>
          <target state="translated">아래 예와 같이 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더를 두 번 이상 사용할 수 있습니다 . 여기서 &lt;a href=&quot;content-security-policy/connect-src&quot;&gt; &lt;code&gt;connect-src&lt;/code&gt; &lt;/a&gt; 지시문에 특히주의 하십시오. 두 번째 정책에서 연결을 허용하더라도 첫 번째 정책에는 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 포함 됩니다. 추가 정책을 추가 하면 보호 된 자원의 기능 &lt;em&gt;만 추가로 제한 할 수 있습니다.&lt;/em&gt; 즉, 연결이 허용되지 않으며 가장 엄격한 정책으로 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="137bbd4986d24df8c6873572858b3eacd9e0ddc8" translate="yes" xml:space="preserve">
          <source>You can use the &lt;code&gt;Content-Security-Policy&lt;/code&gt; header more than once, as in the example below. Pay special attention to the &lt;a href=&quot;content-security-policy/connect-src&quot;&gt;&lt;code&gt;connect-src&lt;/code&gt;&lt;/a&gt; directive here. Even though the second policy would allow the connection, the first policy contains &lt;code&gt;connect-src 'none'&lt;/code&gt;. Adding additional policies &lt;em&gt;can only further restrict&lt;/em&gt; the capabilities of the protected resource, which means that there will be no connection allowed and, as the strictest policy, &lt;code&gt;connect-src 'none'&lt;/code&gt; is enforced.</source>
          <target state="translated">아래 예제와 같이 &lt;code&gt;Content-Security-Policy&lt;/code&gt; 헤더를 두 번 이상 사용할 수 있습니다 . 여기서 &lt;a href=&quot;content-security-policy/connect-src&quot;&gt; &lt;code&gt;connect-src&lt;/code&gt; &lt;/a&gt; 지시문에 특히주의 하십시오. 두 번째 정책이 연결을 허용하더라도 첫 번째 정책에는 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 포함 됩니다. 추가 정책을 추가 하면 보호 된 리소스의 기능 &lt;em&gt;만 더 제한&lt;/em&gt; 될 수 있습니다. 즉, 연결이 허용되지 않고 가장 엄격한 정책으로 &lt;code&gt;connect-src 'none'&lt;/code&gt; 이 적용됩니다.</target>
        </trans-unit>
        <trans-unit id="15fc382b165c36d3e771f09364d3fcb2bc6049c2" translate="yes" xml:space="preserve">
          <source>You don't want to break these links, as they bring valuable users and help your SEO, so you set up redirects from the old URLs to the new ones.</source>
          <target state="translated">귀중한 사용자를 불러오고 SEO를 지원하므로 이러한 링크를 끊고 싶지 않으므로 이전 URL에서 새 URL로 리디렉션을 설정합니다.</target>
        </trans-unit>
        <trans-unit id="34dc813df24a4439aacb95679eee73b4dc499bdd" translate="yes" xml:space="preserve">
          <source>You log into a free WiFi access point at an airport and start surfing the web, visiting your online banking service to check your balance and pay a couple of bills. Unfortunately, the access point you're using is actually a hacker's laptop, and they're intercepting your original HTTP request and redirecting you to a clone of your bank's site instead of the real thing. Now your private data is exposed to the hacker.</source>
          <target state="translated">공항에서 무료 Wi-Fi 액세스 포인트에 로그인하고 웹 서핑을 시작하고 온라인 뱅킹 서비스를 방문하여 잔액을 확인하고 청구서를 지불하십시오. 불행히도, 사용중인 액세스 포인트는 실제로 해커의 랩톱이며 원래 HTTP 요청을 가로 채고 실제 사이트 대신 은행 사이트의 복제본으로 리디렉션합니다. 이제 개인 데이터가 해커에 노출되었습니다.</target>
        </trans-unit>
        <trans-unit id="7a5b96310bd1cc34f2c4474ad2f7105660a63d2d" translate="yes" xml:space="preserve">
          <source>You should replace them with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt; 호출로 바꿔야합니다 .</target>
        </trans-unit>
        <trans-unit id="6edcf297ed74116e062437136c2a1939f6a974cf" translate="yes" xml:space="preserve">
          <source>You should replaced them with &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt;&lt;code&gt;addEventListener&lt;/code&gt;&lt;/a&gt; calls:</source>
          <target state="translated">이를 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener&quot;&gt; &lt;code&gt;addEventListener&lt;/code&gt; &lt;/a&gt; 호출 로 바꿔야합니다 .</target>
        </trans-unit>
        <trans-unit id="2dc398a2b8603e27409f8150e3f33028d9184301" translate="yes" xml:space="preserve">
          <source>You shouldn't use the &lt;code&gt;From&lt;/code&gt; header for access control or authentication.</source>
          <target state="translated">액세스 제어 또는 인증에 &lt;code&gt;From&lt;/code&gt; 헤더를 사용해서는 안됩니다 .</target>
        </trans-unit>
        <trans-unit id="aeb501a73f497244a1ca4c81bc0f2b75e165449c" translate="yes" xml:space="preserve">
          <source>You will have to set the same nonce on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt;&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;&lt;/a&gt; element:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script&quot;&gt; &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 동일한 nonce를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="497810d0e0f1d8b5f343ce88e064b208a24ef471" translate="yes" xml:space="preserve">
          <source>You will have to set the same nonce on the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt;&lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt;&lt;/a&gt; element:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTML/Element/style&quot;&gt; &lt;code&gt;&amp;lt;style&amp;gt;&lt;/code&gt; &lt;/a&gt; 요소 에 동일한 nonce를 설정해야합니다 .</target>
        </trans-unit>
        <trans-unit id="8639bd898d6134e22819658d6593031b9a6e1f29" translate="yes" xml:space="preserve">
          <source>Your site needs to use a specific Web feature that some browsers don't yet support, and you want to send those users to an older Web site with fewer features but that you know will work. This is the worst reason to use user agent detection because odds are eventually all the other browsers will catch up. In addition, it is not practical to test every one of the less popular browsers and test for them. You should &lt;strong&gt;never &lt;/strong&gt;do user agent sniffing. There is &lt;strong&gt;always &lt;/strong&gt;the alternative of doing feature detection instead.</source>
          <target state="translated">귀하의 사이트는 일부 브라우저에서 아직 지원하지 않는 특정 웹 기능을 사용해야하며, 기능이 적지 만 작동 할 것으로 알고있는 이전 웹 사이트로 해당 사용자를 보내려고합니다. 이로 인해 사용자 에이전트 감지를 사용해야하는 최악의 이유는 다른 모든 브라우저에서 발생할 가능성이 높기 때문입니다. 또한 덜 인기있는 브라우저를 모두 테스트하고 테스트하는 것은 실용적이지 않습니다. 사용자 에이전트 스니핑을 수행 해서는 &lt;strong&gt;안됩니다&lt;/strong&gt; . 대신 기능 감지를 수행하는 대안 이 &lt;strong&gt;항상&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3951b830d04bd983e497b92f61aa57c49fe1e1c8" translate="yes" xml:space="preserve">
          <source>Your site needs to use a specific Web feature that some browsers don't yet support, and you want to send those users to an older Web site with fewer features but that you know will work. This is the worst reason to use user agent detection because odds are eventually all the other browsers will catch up. In addition, it is not practical to test every one of the less popular browsers and test for them. You should &lt;strong&gt;never&lt;/strong&gt; do user agent sniffing. There is &lt;strong&gt;always&lt;/strong&gt; the alternative of doing feature detection instead.</source>
          <target state="translated">귀하의 사이트는 일부 브라우저에서 아직 지원하지 않는 특정 웹 기능을 사용해야하며 이러한 사용자를 더 적은 기능이 있지만 작동 할 것으로 알고있는 이전 웹 사이트로 보내려고합니다. 이것은 결국 다른 모든 브라우저가 따라 잡을 가능성이 있기 때문에 사용자 에이전트 감지를 사용하는 최악의 이유입니다. 또한 덜 인기있는 브라우저를 모두 테스트하고 테스트하는 것은 실용적이지 않습니다. 사용자 에이전트 스니핑 은 &lt;strong&gt;절대&lt;/strong&gt; 하지 말아야합니다 . 대신 기능 감지를 수행하는 대안 이 &lt;strong&gt;항상&lt;/strong&gt; 있습니다 .</target>
        </trans-unit>
        <trans-unit id="5a2430dd6f1577013044f8423647dd090b767a57" translate="yes" xml:space="preserve">
          <source>ZIP archive</source>
          <target state="translated">ZIP 보관</target>
        </trans-unit>
        <trans-unit id="7410a2c5889ae46b6ebf4b5278be959009c7bf12" translate="yes" xml:space="preserve">
          <source>Zero or more comments containing more details; sub-product information, for example.</source>
          <target state="translated">자세한 내용이 포함 된 0 개 이상의 주석 예를 들어, 하위 제품 정보.</target>
        </trans-unit>
        <trans-unit id="7d194154860ee775d5ccbab4aa4357621f57dae0" translate="yes" xml:space="preserve">
          <source>Zero or more comments containing sub product information, for example.</source>
          <target state="translated">예를 들어 하위 제품 정보를 포함하는 0 개 이상의 주석</target>
        </trans-unit>
        <trans-unit id="2284673182cdd127888b6dd7e7eec11544c2f01a" translate="yes" xml:space="preserve">
          <source>Zombie cookies and Evercookies</source>
          <target state="translated">좀비 쿠키와 에버 쿠키</target>
        </trans-unit>
        <trans-unit id="1858daecfe7cd2d5ad3fcabc22474135629b2038" translate="yes" xml:space="preserve">
          <source>Zombie cookies on Wikipedia</source>
          <target state="translated">Wikipedia의 좀비 쿠키</target>
        </trans-unit>
        <trans-unit id="faa3018647580610f8ce8b73789a682575c40c26" translate="yes" xml:space="preserve">
          <source>[1] The specification did not intend to allow method changes, but there are existing user agents that do change their method. &lt;a href=&quot;status/308&quot;&gt;&lt;code&gt;308&lt;/code&gt;&lt;/a&gt; was created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">[1] 사양은 방법 변경을 허용하지 않았지만 방법을 변경하는 기존 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메서드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;a href=&quot;status/308&quot;&gt; &lt;code&gt;308&lt;/code&gt; &lt;/a&gt; 이 만들어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="6b0af4c0811a538531e2dcf92a4868eda57b0def" translate="yes" xml:space="preserve">
          <source>[1] The specification had no intent to allow method changes, but practically there are user agents out there doing this. &lt;code&gt;308&lt;/code&gt; has been created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">사양은 방법 변경을 허용하려는 의도가 없었지만 실제로는이를 수행하는 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메소드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;code&gt;308&lt;/code&gt; 이 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="f59b1ae9fa755e33069cec38aff63589aeb6fd23" translate="yes" xml:space="preserve">
          <source>[2] The specification did not intend to allow method changes, but there are existing user agents that do change their method. &lt;a href=&quot;status/307&quot;&gt;&lt;code&gt;307&lt;/code&gt;&lt;/a&gt; was created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">[2] 사양은 방법 변경을 허용하지 않았지만 방법을 변경하는 기존 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메서드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;a href=&quot;status/307&quot;&gt; &lt;code&gt;307&lt;/code&gt; &lt;/a&gt; 이 만들어졌습니다 .</target>
        </trans-unit>
        <trans-unit id="bc921dbce86b3452ecb504ace2a6ebd3695e66a1" translate="yes" xml:space="preserve">
          <source>[2] The specification had no intent to allow method changes, but practically there are user agents out there doing this. &lt;code&gt;307&lt;/code&gt; has been created to remove the ambiguity of the behavior when using non-&lt;code&gt;GET&lt;/code&gt; methods.</source>
          <target state="translated">사양은 방법 변경을 허용하려는 의도가 없었지만 실제로는이를 수행하는 사용자 에이전트가 있습니다. 비 &lt;code&gt;GET&lt;/code&gt; 메소드를 사용할 때 동작의 모호성을 제거하기 위해 &lt;code&gt;307&lt;/code&gt; 이 작성되었습니다 .</target>
        </trans-unit>
        <trans-unit id="6e0756612a3806a698305eb0752124038b7a1541" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-1&quot; name=&quot;ref-1&quot;&gt;1&lt;/a&gt;] Alvestrand, H., &quot;Tags for the Identification of Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;1766&lt;/a&gt;, March 1995.

   [&lt;a id=&quot;ref-2&quot; name=&quot;ref-2&quot;&gt;2&lt;/a&gt;] Anklesaria, F., McCahill, M., Lindner, P., Johnson, D., Torrey,
       D. and B. Alberti, &quot;The Internet Gopher Protocol (a distributed
       document search and retrieval protocol)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1436&quot;&gt;RFC 1436&lt;/a&gt;, March 1993.

   [&lt;a id=&quot;ref-3&quot; name=&quot;ref-3&quot;&gt;3&lt;/a&gt;] Berners-Lee, T., &quot;Universal Resource Identifiers in WWW&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;1630&lt;/a&gt;, June 1994.

   [&lt;a id=&quot;ref-4&quot; name=&quot;ref-4&quot;&gt;4&lt;/a&gt;] Berners-Lee, T., Masinter, L. and M. McCahill, &quot;Uniform Resource
       Locators (URL)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1738&quot;&gt;RFC 1738&lt;/a&gt;, December 1994.

   [&lt;a id=&quot;ref-5&quot; name=&quot;ref-5&quot;&gt;5&lt;/a&gt;] Berners-Lee, T. and D. Connolly, &quot;Hypertext Markup Language -
       2.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1866&quot;&gt;RFC 1866&lt;/a&gt;, November 1995.

   [&lt;a id=&quot;ref-6&quot; name=&quot;ref-6&quot;&gt;6&lt;/a&gt;] Berners-Lee, T., Fielding, R. and H. Frystyk, &quot;Hypertext Transfer
       Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-7&quot; name=&quot;ref-7&quot;&gt;7&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
       Extensions (MIME) Part One: Format of Internet Message Bodies&quot;,
       &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-8&quot; name=&quot;ref-8&quot;&gt;8&lt;/a&gt;] Braden, R., &quot;Requirements for Internet Hosts -- Communication
       Layers&quot;, STD 3, &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt;, October 1989.

   [&lt;a id=&quot;ref-9&quot; name=&quot;ref-9&quot;&gt;9&lt;/a&gt;] Crocker, D., &quot;Standard for The Format of ARPA Internet Text
       Messages&quot;, STD 11, &lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;, August 1982.

   [&lt;a id=&quot;ref-10&quot; name=&quot;ref-10&quot;&gt;10&lt;/a&gt;] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R.,
        Sui, J., and M. Grinbaum, &quot;WAIS Interface Protocol Prototype
        Functional Specification,&quot; (v1.5), Thinking Machines
        Corporation, April 1990.

   [&lt;a id=&quot;ref-11&quot; name=&quot;ref-11&quot;&gt;11&lt;/a&gt;] Fielding, R., &quot;Relative Uniform Resource Locators&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt;,
        June 1995.

   [&lt;a id=&quot;ref-12&quot; name=&quot;ref-12&quot;&gt;12&lt;/a&gt;] Horton, M. and R. Adams, &quot;Standard for Interchange of USENET
        Messages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt;, December 1987. 

   [&lt;a id=&quot;ref-13&quot; name=&quot;ref-13&quot;&gt;13&lt;/a&gt;] Kantor, B. and P. Lapsley, &quot;Network News Transfer Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;977&lt;/a&gt;, February 1986.

   [&lt;a id=&quot;ref-14&quot; name=&quot;ref-14&quot;&gt;14&lt;/a&gt;] Moore, K., &quot;MIME (Multipurpose Internet Mail Extensions) Part
        Three: Message Header Extensions for Non-ASCII Text&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;,
        November 1996.

   [&lt;a id=&quot;ref-15&quot; name=&quot;ref-15&quot;&gt;15&lt;/a&gt;] Nebel, E. and L. Masinter, &quot;Form-based File Upload in HTML&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;1867&lt;/a&gt;, November 1995.

   [&lt;a id=&quot;ref-16&quot; name=&quot;ref-16&quot;&gt;16&lt;/a&gt;] Postel, J., &quot;Simple Mail Transfer Protocol&quot;, STD 10, &lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC 821&lt;/a&gt;,
        August 1982.

   [&lt;a id=&quot;ref-17&quot; name=&quot;ref-17&quot;&gt;17&lt;/a&gt;] Postel, J., &quot;Media Type Registration Procedure&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt;,
        November 1996.

   [&lt;a id=&quot;ref-18&quot; name=&quot;ref-18&quot;&gt;18&lt;/a&gt;] Postel, J. and J. Reynolds, &quot;File Transfer Protocol&quot;, STD 9, &lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;959&lt;/a&gt;, October 1985.

   [&lt;a id=&quot;ref-19&quot; name=&quot;ref-19&quot;&gt;19&lt;/a&gt;] Reynolds, J. and J. Postel, &quot;Assigned Numbers&quot;, STD 2, &lt;a href=&quot;https://tools.ietf.org/html/rfc1700&quot;&gt;RFC 1700&lt;/a&gt;,
        October 1994.

   [&lt;a id=&quot;ref-20&quot; name=&quot;ref-20&quot;&gt;20&lt;/a&gt;] Sollins, K. and L. Masinter, &quot;Functional Requirements for
        Uniform Resource Names&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1737&quot;&gt;RFC 1737&lt;/a&gt;, December 1994.

   [&lt;a id=&quot;ref-21&quot; name=&quot;ref-21&quot;&gt;21&lt;/a&gt;] US-ASCII. Coded Character Set - 7-Bit American Standard Code for
        Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.

   [&lt;a id=&quot;ref-22&quot; name=&quot;ref-22&quot;&gt;22&lt;/a&gt;] ISO-8859. International Standard -- Information Processing --
        8-bit Single-Byte Coded Graphic Character Sets --
        Part 1: Latin alphabet No. 1, ISO-8859-1:1987.
        Part 2: Latin alphabet No. 2, ISO-8859-2, 1987.
        Part 3: Latin alphabet No. 3, ISO-8859-3, 1988.
        Part 4: Latin alphabet No. 4, ISO-8859-4, 1988.
        Part 5: Latin/Cyrillic alphabet, ISO-8859-5, 1988.
        Part 6: Latin/Arabic alphabet, ISO-8859-6, 1987.
        Part 7: Latin/Greek alphabet, ISO-8859-7, 1987.
        Part 8: Latin/Hebrew alphabet, ISO-8859-8, 1988.
        Part 9: Latin alphabet No. 5, ISO-8859-9, 1990.

   [&lt;a id=&quot;ref-23&quot; name=&quot;ref-23&quot;&gt;23&lt;/a&gt;] Meyers, J. and M. Rose, &quot;The Content-MD5 Header Field&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;1864&lt;/a&gt;, October 1995.

   [&lt;a id=&quot;ref-24&quot; name=&quot;ref-24&quot;&gt;24&lt;/a&gt;] Carpenter, B. and Y. Rekhter, &quot;Renumbering Needs Work&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;1900&lt;/a&gt;, February 1996.

   [&lt;a id=&quot;ref-25&quot; name=&quot;ref-25&quot;&gt;25&lt;/a&gt;] Deutsch, P., &quot;GZIP file format specification version 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;1952&lt;/a&gt;, May 1996. 

   [&lt;a id=&quot;ref-26&quot; name=&quot;ref-26&quot;&gt;26&lt;/a&gt;] Venkata N. Padmanabhan, and Jeffrey C. Mogul. &quot;Improving HTTP
        Latency&quot;, Computer Networks and ISDN Systems, v. 28, pp. 25-35,
        Dec. 1995. Slightly revised version of paper in Proc. 2nd
        International WWW Conference '94: Mosaic and the Web, Oct. 1994,
        which is available at
        &lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat&lt;/a&gt;&lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;ency.html&lt;/a&gt;.

   [&lt;a id=&quot;ref-27&quot; name=&quot;ref-27&quot;&gt;27&lt;/a&gt;] Joe Touch, John Heidemann, and Katia Obraczka. &quot;Analysis of HTTP
        Performance&quot;, &amp;lt;URL: &lt;a href=&quot;http://www.isi.edu/touch/pubs/http-perf96/&quot;&gt;http://www.isi.edu/touch/pubs/http-perf96/&lt;/a&gt;&amp;gt;,
        ISI Research Report ISI/RR-98-463, (original report dated Aug.
        1996), USC/Information Sciences Institute, August 1998.

   [&lt;a id=&quot;ref-28&quot; name=&quot;ref-28&quot;&gt;28&lt;/a&gt;] Mills, D., &quot;Network Time Protocol (Version 3) Specification,
        Implementation and Analysis&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1305&quot;&gt;RFC 1305&lt;/a&gt;, March 1992.

   [&lt;a id=&quot;ref-29&quot; name=&quot;ref-29&quot;&gt;29&lt;/a&gt;] Deutsch, P., &quot;DEFLATE Compressed Data Format Specification
        version 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-30&quot; name=&quot;ref-30&quot;&gt;30&lt;/a&gt;] S. Spero, &quot;Analysis of HTTP Performance Problems,&quot;
        &lt;a href=&quot;http://sunsite.unc.edu/mdma-release/http-prob.html&quot;&gt;http://sunsite.unc.edu/mdma-release/http-prob.html&lt;/a&gt;.

   [&lt;a id=&quot;ref-31&quot; name=&quot;ref-31&quot;&gt;31&lt;/a&gt;] Deutsch, P. and J. Gailly, &quot;ZLIB Compressed Data Format
        Specification version 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-32&quot; name=&quot;ref-32&quot;&gt;32&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P.,
        Luotonen, A., Sink, E. and L. Stewart, &quot;An Extension to HTTP:
        Digest Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2069&quot;&gt;RFC 2069&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-33&quot; name=&quot;ref-33&quot;&gt;33&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. and T.
        Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-34&quot; name=&quot;ref-34&quot;&gt;34&lt;/a&gt;] Bradner, S., &quot;Key words for use in RFCs to Indicate Requirement
        Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-35&quot; name=&quot;ref-35&quot;&gt;35&lt;/a&gt;] Troost, R. and Dorner, S., &quot;Communicating Presentation
        Information in Internet Messages: The Content-Disposition
        Header&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt;, June 1995.

   [&lt;a id=&quot;ref-36&quot; name=&quot;ref-36&quot;&gt;36&lt;/a&gt;] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, &quot;Use and
        Interpretation of HTTP Version Numbers&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, May 1997.
        [jg639]

   [&lt;a id=&quot;ref-37&quot; name=&quot;ref-37&quot;&gt;37&lt;/a&gt;] Palme, J., &quot;Common Internet Message Headers&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2076&quot;&gt;RFC 2076&lt;/a&gt;, February
        1997. [jg640] 

   [&lt;a id=&quot;ref-38&quot; name=&quot;ref-38&quot;&gt;38&lt;/a&gt;] Yergeau, F., &quot;UTF-8, a transformation format of Unicode and
        ISO-10646&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2279&quot;&gt;RFC 2279&lt;/a&gt;, January 1998. [jg641]

   [&lt;a id=&quot;ref-39&quot; name=&quot;ref-39&quot;&gt;39&lt;/a&gt;] Nielsen, H.F., Gettys, J., Baird-Smith, A., Prud'hommeaux, E.,
        Lie, H., and C. Lilley. &quot;Network Performance Effects of
        HTTP/1.1, CSS1, and PNG,&quot; Proceedings of ACM SIGCOMM '97, Cannes
        France, September 1997.[jg642]

   [&lt;a id=&quot;ref-40&quot; name=&quot;ref-40&quot;&gt;40&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
        Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;, November
        1996. [jg643]

   [&lt;a id=&quot;ref-41&quot; name=&quot;ref-41&quot;&gt;41&lt;/a&gt;] Alvestrand, H., &quot;IETF Policy on Character Sets and Languages&quot;,
        &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;, January 1998. [jg644]

   [&lt;a id=&quot;ref-42&quot; name=&quot;ref-42&quot;&gt;42&lt;/a&gt;] Berners-Lee, T., Fielding, R. and L. Masinter, &quot;Uniform Resource
        Identifiers (URI): Generic Syntax and Semantics&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt;,
        August 1998. [jg645]

   [&lt;a id=&quot;ref-43&quot; name=&quot;ref-43&quot;&gt;43&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
        Leach, P., Luotonen, A., Sink, E. and L. Stewart, &quot;HTTP
        Authentication: Basic and Digest Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt;, June 1999. [jg646]

   [&lt;a id=&quot;ref-44&quot; name=&quot;ref-44&quot;&gt;44&lt;/a&gt;] Luotonen, A., &quot;Tunneling TCP based protocols through Web proxy
        servers,&quot; Work in Progress. [jg647]

   [&lt;a id=&quot;ref-45&quot; name=&quot;ref-45&quot;&gt;45&lt;/a&gt;] Palme, J. and A. Hopmann, &quot;MIME E-mail Encapsulation of
        Aggregate Documents, such as HTML (MHTML)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2110&quot;&gt;RFC 2110&lt;/a&gt;, March
        1997.

   [&lt;a id=&quot;ref-46&quot; name=&quot;ref-46&quot;&gt;46&lt;/a&gt;] Bradner, S., &quot;The Internet Standards Process -- Revision 3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;BCP&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;9&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2026&quot;&gt;RFC 2026&lt;/a&gt;, October 1996.

   [&lt;a id=&quot;ref-47&quot; name=&quot;ref-47&quot;&gt;47&lt;/a&gt;] Masinter, L., &quot;Hyper Text Coffee Pot Control Protocol
        (HTCPCP/1.0)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;RFC 2324&lt;/a&gt;, 1 April 1998.

   [&lt;a id=&quot;ref-48&quot; name=&quot;ref-48&quot;&gt;48&lt;/a&gt;] Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
        Extensions (MIME) Part Five: Conformance Criteria and Examples&quot;,
        &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-49&quot; name=&quot;ref-49&quot;&gt;49&lt;/a&gt;] Troost, R., Dorner, S. and K. Moore, &quot;Communicating Presentation
        Information in Internet Messages: The Content-Disposition Header
        Field&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2183&quot;&gt;RFC 2183&lt;/a&gt;, August 1997.</source>
          <target state="translated">[ &lt;a id=&quot;ref-1&quot; name=&quot;ref-1&quot;&gt;1&lt;/a&gt; ] Alvestrand, H., &quot;언어의 식별에 대한 태그&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1766&quot;&gt;1766&lt;/a&gt; , 1995 년 3 월 [ &lt;a id=&quot;ref-2&quot; name=&quot;ref-2&quot;&gt;2&lt;/a&gt; ] Anklesaria, F., McCahill, M., 린드너, P., 존슨, D., 토리, D. B. Alberti, &quot;인터넷 고퍼 프로토콜 (분산 문서 검색 및 검색 프로토콜)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1436&quot;&gt;RFC 1436&lt;/a&gt; , 1993 년 &lt;a id=&quot;ref-3&quot; name=&quot;ref-3&quot;&gt;3&lt;/a&gt; 월. [ 3 ] Berners-Lee, T., &quot;WW의 범용 자원 식별자&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1630&quot;&gt;1630&lt;/a&gt; , 1994 년 6 월 [ &lt;a id=&quot;ref-4&quot; name=&quot;ref-4&quot;&gt;4&lt;/a&gt; ] Berners-Lee, T., Masinter, L. 및 M. McCahill, &quot;Uniform Resource Locators (URL)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1738&quot;&gt;RFC 1738&lt;/a&gt; , 1994 년 12 월. [ &lt;a id=&quot;ref-5&quot; name=&quot;ref-5&quot;&gt;5&lt;/a&gt;] Berners-Lee, T. 및 D. Connolly, &quot;하이퍼 텍스트 마크 업 언어-2.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1866&quot;&gt;RFC 1866&lt;/a&gt; , 1995 년 11 월. [ &lt;a id=&quot;ref-6&quot; name=&quot;ref-6&quot;&gt;6&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 H. Frystyk, &quot;하이퍼 텍스트 전송 프로토콜- -HTTP / 1.0 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-7&quot; name=&quot;ref-7&quot;&gt;7&lt;/a&gt; ] Freed, N. 및 N. Borenstein,&quot;MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-8&quot; name=&quot;ref-8&quot;&gt;8&lt;/a&gt; ] Braden, R., &quot;인터넷 호스트 요구 사항-통신 계층&quot;, STD 3, &lt;a href=&quot;https://tools.ietf.org/html/rfc1123&quot;&gt;RFC 1123&lt;/a&gt; , 1989 년 10 월. [ &lt;a id=&quot;ref-9&quot; name=&quot;ref-9&quot;&gt;9&lt;/a&gt; ] Crocker, D., &quot;ARPA 인터넷 문자 메시지 형식 표준&quot;, STD 11,&lt;a href=&quot;https://tools.ietf.org/html/rfc822&quot;&gt;RFC 822&lt;/a&gt;1982 년 8 월. [ &lt;a id=&quot;ref-10&quot; name=&quot;ref-10&quot;&gt;10&lt;/a&gt; ] Davis, F., Kahle, B., Morris, H., Salem, J., Shen, T., Wang, R., Sui, J. 및 M. Grinbaum, &quot;WAIS 인터페이스 프로토콜 프로토 타입 기능 사양, &quot;(v1.5), Thinking Machines Corporation, 1990 년 4 월. [ &lt;a id=&quot;ref-11&quot; name=&quot;ref-11&quot;&gt;11&lt;/a&gt; ] Fielding, R.,&quot;Relative Uniform Resource Locators &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1808&quot;&gt;RFC 1808&lt;/a&gt; , 1995 년 6 월. [ &lt;a id=&quot;ref-12&quot; name=&quot;ref-12&quot;&gt;12&lt;/a&gt; ] Horton, M. and R. Adams, &quot;USENET 메시지 교환 표준&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1036&quot;&gt;RFC 1036&lt;/a&gt; , 1987 년 12 월. [ &lt;a id=&quot;ref-13&quot; name=&quot;ref-13&quot;&gt;13&lt;/a&gt; ] Kantor, B. 및 P. Lapsley, &quot;Network News Transfer Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc977&quot;&gt;977&lt;/a&gt; , 1986 년 2 월. [ &lt;a id=&quot;ref-14&quot; name=&quot;ref-14&quot;&gt;14&lt;/a&gt;] Moore, K., &quot;MIME (Multipurpose Internet Mail Extensions) 3 부 : 비 ASCII 텍스트에 대한 메시지 헤더 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-15&quot; name=&quot;ref-15&quot;&gt;15&lt;/a&gt; ] Nebel, E. 및 L. Masinter, &quot;양식 파일 HTML로 업로드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1867&quot;&gt;1867&lt;/a&gt; , 1995 년 11 월. [ &lt;a id=&quot;ref-16&quot; name=&quot;ref-16&quot;&gt;16&lt;/a&gt; ] Postel, J.,&quot;단순 메일 전송 프로토콜 &quot;, STD 10, &lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC 821&lt;/a&gt; , 1982 년 8 월. [ &lt;a id=&quot;ref-17&quot; name=&quot;ref-17&quot;&gt;17&lt;/a&gt; ] Postel, J.,&quot;미디어 유형 등록 절차 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1590&quot;&gt;RFC 1590&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-18&quot; name=&quot;ref-18&quot;&gt;18&lt;/a&gt; ] Postel, J. 및 J. Reynolds, &quot;파일 전송 프로토콜&quot;, STD 9, &lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc959&quot;&gt;959&lt;/a&gt; , 1985 년 10 월. [ &lt;a id=&quot;ref-19&quot; name=&quot;ref-19&quot;&gt;19&lt;/a&gt;] Reynolds, J. 및 J. Postel, &quot;지정 번호&quot;, STD 2, &lt;a href=&quot;https://tools.ietf.org/html/rfc1700&quot;&gt;RFC 1700&lt;/a&gt; , 1994 년 10 월. [ &lt;a id=&quot;ref-20&quot; name=&quot;ref-20&quot;&gt;20&lt;/a&gt; ] Sollins, K. 및 L. Masinter, &quot;일관된 자원 명에 대한 기능 요구 사항&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1737&quot;&gt;RFC 1737&lt;/a&gt; , 1994 년 12 월 [ &lt;a id=&quot;ref-21&quot; name=&quot;ref-21&quot;&gt;21&lt;/a&gt; ] US-ASCII. 코드화 된 문자 세트-정보 교환을위한 7 비트 미국 표준 코드. 표준 ANSI X3.4-1986, ANSI, 1986. [ &lt;a id=&quot;ref-22&quot; name=&quot;ref-22&quot;&gt;22&lt;/a&gt;] ISO-8859. 국제 표준-정보 처리-8 비트 단일 바이트 코드 그래픽 문자 세트-1 부 : 라틴 알파벳 1, ISO-8859-1 : 1987. 2 부 : 라틴 알파벳 2, ISO-8859-2, 1987. 3 부 : 라틴 알파벳 3, ISO-8859-3, 1988. 4 부 : 라틴 알파벳 4, ISO-8859-4, 1988 5 부 : 라틴어 / 키릴 자모 알파벳, ISO-8859-5, 1988. 6 부 : 라틴어 / 아랍어 알파벳, ISO-8859-6, 1987. 7 부 : 라틴어 / 그리스어 알파벳, ISO-8859-7, 1987. 8 : 라틴 / 히브리어 알파벳, ISO-8859-8, 1988. Part 9 : 라틴 알파벳 No. 5, ISO-8859-9, 1990. [ &lt;a id=&quot;ref-23&quot; name=&quot;ref-23&quot;&gt;23&lt;/a&gt; ] Meyers, J. and M. Rose, &quot;Content-MD5 헤더 Field &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1864&quot;&gt;1864&lt;/a&gt; , 1995 년 10 월. [ &lt;a id=&quot;ref-24&quot; name=&quot;ref-24&quot;&gt;24&lt;/a&gt;] 목수, B. 및 Y. Rekhter, &quot;재 번호 매기기 작업 필요&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1900&quot;&gt;1900&lt;/a&gt; , 1996 년 2 월. [ &lt;a id=&quot;ref-25&quot; name=&quot;ref-25&quot;&gt;25&lt;/a&gt; ] Deutsch, P., &quot;GZIP 파일 형식 사양 버전 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;1952&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-26&quot; name=&quot;ref-26&quot;&gt;26&lt;/a&gt; ] Venkata N Padmanabhan 및 Jeffrey C. Mogul. &quot;HTTP 지연 시간 개선&quot;, 컴퓨터 네트워크 및 ISDN 시스템, v. 28, pp. 25-35, 1995 년 12 월. Proc. 제 2 차 국제 WWW 컨퍼런스 '94 : Mosaic and the Web, 1994 년 10 월, &lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLat &lt;/a&gt;&lt;a href=&quot;http://www.ncsa.uiuc.edu/SDG/IT94/Proceedings/DDay/mogul/HTTPLatency.html&quot;&gt;ency.html&lt;/a&gt; 에서 볼 수 있습니다 . [ &lt;a id=&quot;ref-27&quot; name=&quot;ref-27&quot;&gt;27&lt;/a&gt;] Joe Touch, John Heidemann 및 Katia Obraczka. &quot;HTTP 성능 분석&quot;, &amp;lt;URL : &lt;a href=&quot;http://www.isi.edu/touch/pubs/http-perf96/&quot;&gt;http://www.isi.edu/touch/pubs/http-perf96/&lt;/a&gt; &amp;gt;, ISI Research Report ISI / RR-98-463, (1996 년 8 월 원본 보고서), USC / Information Sciences Institute, 1998 년 8 월. [ &lt;a id=&quot;ref-28&quot; name=&quot;ref-28&quot;&gt;28&lt;/a&gt; ] Mills, D., &quot;네트워크 시간 프로토콜 (버전 3) 사양, 구현 및 분석&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1305&quot;&gt;RFC 1305&lt;/a&gt; , 1992 년 3 월. [ &lt;a id=&quot;ref-29&quot; name=&quot;ref-29&quot;&gt;29&lt;/a&gt; ] Deutsch, P., &quot;DEFLATE 압축 데이터 형식 사양 버전 1.3 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; , 1996 년 5 월 [ &lt;a id=&quot;ref-30&quot; name=&quot;ref-30&quot;&gt;30&lt;/a&gt; ] S. Spero,&quot;분석 HTTP의 성능 문제, &quot; &lt;a href=&quot;http://sunsite.unc.edu/mdma-release/http-prob.html&quot;&gt;http://sunsite.unc.edu/mdma-release/http-prob.html&lt;/a&gt; .[ &lt;a id=&quot;ref-31&quot; name=&quot;ref-31&quot;&gt;31&lt;/a&gt;] Deutsch, P. 및 J. Gailly, &quot;ZLIB 압축 데이터 형식 사양 버전 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-32&quot; name=&quot;ref-32&quot;&gt;32&lt;/a&gt; ] Franks, J., Hallam-Baker, P., Hostetler, J., Leach, P. , Luotonen, A., Sink, E. 및 L. Stewart, &quot;HTTP의 확장 : 다이제스트 액세스 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2069&quot;&gt;RFC 2069&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-33&quot; name=&quot;ref-33&quot;&gt;33&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;2068&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-34&quot; name=&quot;ref-34&quot;&gt;34&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에서 사용되는 핵심어&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-35&quot; name=&quot;ref-35&quot;&gt;35&lt;/a&gt;] Troost, R. 및 Dorner, S., &quot;인터넷 메시지의 프리젠 테이션 정보 통신 : 컨텐츠 처리 헤더&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1806&quot;&gt;RFC 1806&lt;/a&gt; , 1995 년 6 월. [ &lt;a id=&quot;ref-36&quot; name=&quot;ref-36&quot;&gt;36&lt;/a&gt; ] Mogul, J., Fielding, R., Gettys, J. and H. Frystyk, &quot;HTTP 버전 번호 사용 및 해석&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; , 1997 년 5 월. [jg639] [ &lt;a id=&quot;ref-37&quot; name=&quot;ref-37&quot;&gt;37&lt;/a&gt; ] Palme, J., &quot;공통 인터넷 메시지 헤더&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2076&quot;&gt;RFC 2076&lt;/a&gt; , 1997 년 2 월. [jg640] [ &lt;a id=&quot;ref-38&quot; name=&quot;ref-38&quot;&gt;38&lt;/a&gt; ] Yergeau, F., &quot;UTF-8, 유니 코드 및 ISO-10646의 변환 형식&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2279&quot;&gt;RFC 2279&lt;/a&gt; , 1998 년 1 월. [jg641] [ &lt;a id=&quot;ref-39&quot; name=&quot;ref-39&quot;&gt;39&lt;/a&gt;] Nielsen, HF, Gettys, J., Baird-Smith, A., Prud'hommeaux, E., Lie, H. 및 C. Lilley. &quot;HTTP / 1.1, CSS1 및 PNG의 네트워크 성능 효과,&quot;1997 년 9 월, 칸느 프랑스 ACM SIGCOMM '97의 절차. [jg642] [ &lt;a id=&quot;ref-40&quot; name=&quot;ref-40&quot;&gt;40&lt;/a&gt; ] Free , N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions)&quot; ) 2 부 : 미디어 유형 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; , 1996 년 11 월. [jg643] [ &lt;a id=&quot;ref-41&quot; name=&quot;ref-41&quot;&gt;41&lt;/a&gt; ] Alvestrand, H.,&quot;문자 세트 및 언어에 대한 IETF 정책 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt; , 1998 년 1 월. [jg644] [ &lt;a id=&quot;ref-42&quot; name=&quot;ref-42&quot;&gt;42&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform Resource Identifiers (URI) : 일반 구문 및 의미론&quot;,&lt;a href=&quot;https://tools.ietf.org/html/rfc2396&quot;&gt;RFC 2396&lt;/a&gt;[jg645] [ &lt;a id=&quot;ref-43&quot; name=&quot;ref-43&quot;&gt;43&lt;/a&gt; ] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A., Sink, E. and L. Stewart , &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;2617&lt;/a&gt; , 1999 년 6 월. [jg646] [ &lt;a id=&quot;ref-44&quot; name=&quot;ref-44&quot;&gt;44&lt;/a&gt; ] Luotonen, A., &quot;웹 프록시 서버를 통한 TCP 기반 프로토콜 튠링 &quot;작업 진행 중. [jg647] [ &lt;a id=&quot;ref-45&quot; name=&quot;ref-45&quot;&gt;45&lt;/a&gt; ] Palme, J. 및 A. Hopmann, &quot;HTML (MHTML)과 같은 집계 문서의 MIME 전자 메일 캡슐화&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2110&quot;&gt;RFC 2110&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-46&quot; name=&quot;ref-46&quot;&gt;46&lt;/a&gt; ] Bradner, S., &quot;인터넷 표준 프로세스-개정 3 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;BCP &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/bcp9&quot;&gt;9&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2026&quot;&gt;RFC 2026&lt;/a&gt;10 월 1996 [ &lt;a id=&quot;ref-47&quot; name=&quot;ref-47&quot;&gt;47&lt;/a&gt; ] Masinter, L., &quot;하이퍼 텍스트 커피 주전자 제어 프로토콜 (HTCPCP이 / 1.0)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2324&quot;&gt;RFC 2324&lt;/a&gt; 년 4 월 1 일 1998 [ &lt;a id=&quot;ref-48&quot; name=&quot;ref-48&quot;&gt;48&lt;/a&gt; ] 해방, N. 및 N. Borenstein, &quot;다목적 인터넷 메일 확장 (MIME) 5 부 : 적합성 기준 및 예 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-49&quot; name=&quot;ref-49&quot;&gt;49&lt;/a&gt; ] Troost, R., Dorner, S. 및 K. Moore,&quot;인터넷 메시지의 프리젠 테이션 정보 통신 : 컨텐츠 처리 헤더 필드 &quot; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2183&quot;&gt;RFC 2183&lt;/a&gt; , 1997 년 8 월.</target>
        </trans-unit>
        <trans-unit id="ea4aba79059a2acd73a894fc17265142ad617be5" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-ALT-SVC&quot; name=&quot;ref-ALT-SVC&quot;&gt;ALT-SVC&lt;/a&gt;]     Nottingham, M., McManus, P., and J. Reschke, &quot;HTTP
                 Alternative Services&quot;, Work in Progress, &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-06&quot;&gt;draft-ietf-&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-httpbis-alt-svc-06&quot;&gt;httpbis-alt-svc-06&lt;/a&gt;, February 2015.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]       Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
                 Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/bcp90&quot;&gt;http://www.rfc-editor.org/info/bcp90&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-BREACH&quot; name=&quot;ref-BREACH&quot;&gt;BREACH&lt;/a&gt;]      Gluck, Y., Harris, N., and A. Prado, &quot;BREACH: Reviving
                 the CRIME Attack&quot;, July 2013,
                 &amp;lt;&lt;a href=&quot;http://breachattack.com/resources/&quot;&gt;http://breachattack.com/resources/&lt;/a&gt;
                 BREACH%20-%20SSL,%20gone%20in%2030%20seconds.pdf&amp;gt;.

   [&lt;a id=&quot;ref-HTML5&quot; name=&quot;ref-HTML5&quot;&gt;HTML5&lt;/a&gt;]       Hickson, I., Berjon, R., Faulkner, S., Leithead, T.,
                 Doyle Navara, E., O'Connor, E., and S. Pfeiffer,
                 &quot;HTML5&quot;, W3C Recommendation REC-html5-20141028, October
                 2014, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2014/REC-html5-20141028/&quot;&gt;http://www.w3.org/TR/2014/REC-html5-20141028/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC3749&quot; name=&quot;ref-RFC3749&quot;&gt;RFC3749&lt;/a&gt;]     Hollenbeck, S., &quot;Transport Layer Security Protocol
                 Compression Methods&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3749&quot;&gt;RFC 3749&lt;/a&gt;, DOI 10.17487/RFC3749,
                 May 2004, &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc3749&quot;&gt;http://www.rfc-editor.org/info/rfc3749&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC4492&quot; name=&quot;ref-RFC4492&quot;&gt;RFC4492&lt;/a&gt;]     Blake-Wilson, S., Bolyard, N., Gupta, V., Hawk, C., and
                 B.  Moeller, &quot;Elliptic Curve Cryptography (ECC) Cipher
                 Suites for Transport Layer Security (TLS)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4492&quot;&gt;RFC 4492&lt;/a&gt;,
                 DOI 10.17487/RFC4492, May 2006,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc4492&quot;&gt;http://www.rfc-editor.org/info/rfc4492&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;]     Nottingham, M. and R. Fielding, &quot;Additional HTTP Status
                 Codes&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt;, DOI 10.17487/RFC6585, April 2012,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc6585&quot;&gt;http://www.rfc-editor.org/info/rfc6585&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC7323&quot; name=&quot;ref-RFC7323&quot;&gt;RFC7323&lt;/a&gt;]     Borman, D., Braden, B., Jacobson, V., and R.
                 Scheffenegger, Ed., &quot;TCP Extensions for High
                 Performance&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7323&quot;&gt;RFC 7323&lt;/a&gt;, DOI 10.17487/RFC7323, September
                 2014, &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7323&quot;&gt;http://www.rfc-editor.org/info/rfc7323&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-TALKING&quot; name=&quot;ref-TALKING&quot;&gt;TALKING&lt;/a&gt;]     Huang, L., Chen, E., Barth, A., Rescorla, E., and C.
                 Jackson, &quot;Talking to Yourself for Fun and Profit&quot;,
                 2011, &amp;lt;&lt;a href=&quot;http://w2spconf.com/2011/papers/websocket.pdf&quot;&gt;http://w2spconf.com/2011/papers/websocket.pdf&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-TLSBCP&quot; name=&quot;ref-TLSBCP&quot;&gt;TLSBCP&lt;/a&gt;]      Sheffer, Y., Holz, R., and P. Saint-Andre,
                 &quot;Recommendations for Secure Use of Transport Layer
                 Security (TLS) and Datagram Transport Layer Security
                 (DTLS)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp195&quot;&gt;BCP 195&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7525&quot;&gt;RFC 7525&lt;/a&gt;, DOI 10.17487/RFC7525, May
                 2015, &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7525&quot;&gt;http://www.rfc-editor.org/info/rfc7525&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc821d5e8b6f5141610286985b0b686179701b49" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP115&quot; name=&quot;ref-BCP115&quot;&gt;BCP115&lt;/a&gt;]      Hansen, T., Hardie, T., and L. Masinter, &quot;Guidelines
                 and Registration Procedures for New URI Schemes&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/bcp115&quot;&gt;BCP 115&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4395&quot;&gt;RFC 4395&lt;/a&gt;, February 2006.

   [&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]       Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
                 Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]       Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
                 Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004.

   [&lt;a id=&quot;ref-Georgiev&quot; name=&quot;ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;]    Georgiev, M., Iyengar, S., Jana, S., Anubhai, R.,
                 Boneh, D., and V. Shmatikov, &quot;The Most Dangerous Code
                 in the World: Validating SSL Certificates in Non-
                 browser Software&quot;, In Proceedings of the 2012 ACM
                 Conference on Computer and Communications Security (CCS
                 '12), pp. 38-49, October 2012,
                 &amp;lt;&lt;a href=&quot;http://doi.acm.org/10.1145/2382196.2382204&quot;&gt;http://doi.acm.org/10.1145/2382196.2382204&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-ISO-8859-1&quot; name=&quot;ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt;]  International Organization for Standardization,
                 &quot;Information technology -- 8-bit single-byte coded
                 graphic character sets -- Part 1: Latin alphabet No.
                 1&quot;, ISO/IEC 8859-1:1998, 1998.

   [&lt;a id=&quot;ref-Klein&quot; name=&quot;ref-Klein&quot;&gt;Klein&lt;/a&gt;]       Klein, A., &quot;Divide and Conquer - HTTP Response
                 Splitting, Web Cache Poisoning Attacks, and Related
                 Topics&quot;, March 2004, &amp;lt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;http://packetstormsecurity.com/&lt;/a&gt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;papers/general/whitepaper_httpresponse.pdf&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-Kri2001&quot; name=&quot;ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt;]     Kristol, D., &quot;HTTP Cookies: Standards, Privacy, and
                 Politics&quot;, ACM Transactions on Internet
                 Technology 1(2), November 2001,
                 &amp;lt;&lt;a href=&quot;http://arxiv.org/abs/cs.SE/0105018&quot;&gt;http://arxiv.org/abs/cs.SE/0105018&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-Linhart&quot; name=&quot;ref-Linhart&quot;&gt;Linhart&lt;/a&gt;]     Linhart, C., Klein, A., Heled, R., and S. Orrin, &quot;HTTP
                 Request Smuggling&quot;, June 2005,
                 &amp;lt;&lt;a href=&quot;http://www.watchfire.com/news/whitepapers.aspx&quot;&gt;http://www.watchfire.com/news/whitepapers.aspx&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-RFC1919&quot; name=&quot;ref-RFC1919&quot;&gt;RFC1919&lt;/a&gt;]     Chatel, M., &quot;Classical versus Transparent IP Proxies&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC 1919&lt;/a&gt;, March 1996.

   [&lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and H. Nielsen,
                 &quot;Hypertext Transfer Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;,
                 May 1996.

   [&lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt;]     Freed, N. and N. Borenstein, &quot;Multipurpose Internet
                 Mail Extensions (MIME) Part One: Format of Internet
                 Message Bodies&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2047&quot; name=&quot;ref-RFC2047&quot;&gt;RFC2047&lt;/a&gt;]     Moore, K., &quot;MIME (Multipurpose Internet Mail
                 Extensions) Part Three: Message Header Extensions for
                 Non-ASCII Text&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt;]     Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and
                 T. Berners-Lee, &quot;Hypertext Transfer Protocol --
                 HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-RFC2145&quot; name=&quot;ref-RFC2145&quot;&gt;RFC2145&lt;/a&gt;]     Mogul, J., Fielding, R., Gettys, J., and H. Nielsen,
                 &quot;Use and Interpretation of HTTP Version Numbers&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt;, May 1997.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]     Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                 Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
                 Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt;]     Khare, R. and S. Lawrence, &quot;Upgrading to TLS Within
                 HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]     Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC3040&quot; name=&quot;ref-RFC3040&quot;&gt;RFC3040&lt;/a&gt;]     Cooper, I., Melve, I., and G. Tomlinson, &quot;Internet Web
                 Replication and Caching Taxonomy&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC 3040&lt;/a&gt;,
                 January 2001.

   [&lt;a id=&quot;ref-RFC4033&quot; name=&quot;ref-RFC4033&quot;&gt;RFC4033&lt;/a&gt;]     Arends, R., Austein, R., Larson, M., Massey, D., and S.
                 Rose, &quot;DNS Security Introduction and Requirements&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC 4033&lt;/a&gt;, March 2005.

   [&lt;a id=&quot;ref-RFC4559&quot; name=&quot;ref-RFC4559&quot;&gt;RFC4559&lt;/a&gt;]     Jaganathan, K., Zhu, L., and J. Brezak, &quot;SPNEGO-based
                 Kerberos and NTLM HTTP Authentication in Microsoft
                 Windows&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC 4559&lt;/a&gt;, June 2006.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]     Narten, T. and H. Alvestrand, &quot;Guidelines for Writing
                 an IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;, May 2008. 

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]     Dierks, T. and E. Rescorla, &quot;The Transport Layer
                 Security (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;,
                 August 2008.

   [&lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt;]     Resnick, P., &quot;Internet Message Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;,
                 October 2008.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]     Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
                 April 2011.

   [&lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;]     Nottingham, M. and R. Fielding, &quot;Additional HTTP Status
                 Codes&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt;, April 2012.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP115&quot; name=&quot;ref-BCP115&quot;&gt;BCP115&lt;/a&gt; ] Hansen, T., Hardie, T. 및 L. Masinter, &quot;새로운 URI 체계에 대한 지침 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp115&quot;&gt;BCP 115&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc4395&quot;&gt;RFC 4395&lt;/a&gt; , 2006 년 2 월. [ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Freed, N., Klensin, J. 및 T. Hansen, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; , 2013 년 1 월. [ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot; , &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-Georgiev&quot; name=&quot;ref-Georgiev&quot;&gt;Georgiev&lt;/a&gt;] Georgiev, M., Iyengar, S., Jana, S., Anubhai, R., Boneh, D. 및 V. Shmatikov, &quot;세계에서 가장 위험한 코드 : 비 브라우저 소프트웨어에서 SSL 인증서 확인&quot;, 2012 년 컴퓨터 및 통신 보안에 관한 ACM 컨퍼런스 (CCS '12), pp. 38-49, 2012 년 10 월 38, &amp;lt; &lt;a href=&quot;http://doi.acm.org/10.1145/2382196.2382204&quot;&gt;http://doi.acm.org/10.1145/2382196.2382204&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-ISO-8859-1&quot; name=&quot;ref-ISO-8859-1&quot;&gt;ISO-8859-1&lt;/a&gt; ] 국제 표준화기구, &quot;정보 기술-8 비트 1 바이트 코드 그래픽 문자 세트-1 부 : 라틴 알파벳 1 호&quot;, ISO / IEC 8859-1 : 1998, 1998. [ &lt;a id=&quot;ref-Klein&quot; name=&quot;ref-Klein&quot;&gt;클라인&lt;/a&gt;] 클라인, A., &quot;분할 및 정복 - HTTP 응답 분할, 웹 캐시 중독 공격 및 관련 항목&quot;2004 년 3 월, &amp;lt; &lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;http://packetstormsecurity.com/ &lt;/a&gt;&lt;a href=&quot;http://packetstormsecurity.com/papers/general/whitepaper_httpresponse.pdf&quot;&gt;논문 / / whitepaper_httpresponse.pdf 일반&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-Kri2001&quot; name=&quot;ref-Kri2001&quot;&gt;Kri2001&lt;/a&gt; ] Kristol, D., &quot;HTTP 쿠키 : 표준, 개인 정보 및 정치&quot;, 인터넷 기술 1 (2), 2001 년 11 월의 ACM 거래, &amp;lt; &lt;a href=&quot;http://arxiv.org/abs/cs.SE/0105018&quot;&gt;http://arxiv.org/abs/cs.SE/0105018&lt;/a&gt; &amp;gt; . [ &lt;a id=&quot;ref-Linhart&quot; name=&quot;ref-Linhart&quot;&gt;Linhart&lt;/a&gt; ] Linhart, C., Klein, A., Heled, R. 및 S. Orrin, &quot;HTTP 요청 밀수&quot;, 2005 년 6 월, &amp;lt; &lt;a href=&quot;http://www.watchfire.com/news/whitepapers.aspx&quot;&gt;http://www.watchfire.com/news/whitepapers.aspx&lt;/a&gt; &amp;gt;.[ &lt;a id=&quot;ref-RFC1919&quot; name=&quot;ref-RFC1919&quot;&gt;RFC1919&lt;/a&gt;] Chatel, M., &quot;클래식 및 투명 IP 프록시&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1919&quot;&gt;RFC 1919&lt;/a&gt; , 1996 년 3 월. [ &lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 H. Nielsen, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.0&quot; , &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt; ] Free, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2047&quot; name=&quot;ref-RFC2047&quot;&gt;RFC2047&lt;/a&gt; ] Moore, K. , &quot;MIME (Multipurpose Internet Mail Extensions) 3 부 : 비 ASCII 텍스트에 대한 메시지 헤더 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2047&quot;&gt;RFC 2047&lt;/a&gt; , 1996 년 11 월.[&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Nielsen, H. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-RFC2145&quot; name=&quot;ref-RFC2145&quot;&gt;RFC2145&lt;/a&gt; ] Mogul , J., Fielding, R., Gettys, J. 및 H. Nielsen, &quot;HTTP 버전 번호 사용 및 해석&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2145&quot;&gt;RFC 2145&lt;/a&gt; , 1997 년 5 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt; ] Khare, R. and 로렌스, &quot;HTTP / 1.1 내에서 TLS로 업그레이드&quot;,&lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt; ] Rescorla , E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC3040&quot; name=&quot;ref-RFC3040&quot;&gt;RFC3040&lt;/a&gt; ] Cooper, I., Melve, I. 및 G. Tomlinson, &quot;인터넷 웹 복제 및 캐싱 분류 &lt;a id=&quot;ref-RFC4033&quot; name=&quot;ref-RFC4033&quot;&gt;체계&lt;/a&gt; &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3040&quot;&gt;RFC 3040&lt;/a&gt; , 2001 년 1 월. [ RFC4033 ] Arends, R., Austein, R., Larson, M., Massey, D. 및 S. Rose,&quot;DNS 보안 소개 및 요구 사항 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4033&quot;&gt;RFC 4033&lt;/a&gt; , 2005 년 3 월 [ &lt;a id=&quot;ref-RFC4559&quot; name=&quot;ref-RFC4559&quot;&gt;RFC4559&lt;/a&gt; ] Jaganathan, K., Zhu, L. 및 J. Brezak, &quot;Microsoft Windows의 SPNEGO 기반 Kerberos 및 NTLM HTTP 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4559&quot;&gt;RFC 4559&lt;/a&gt;[ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten, T. 및 H. Alvestrand, &quot;RFC에 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot; TLS (Transport Layer Security) 프로토콜 버전 1.2 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt; , 2008 년 8 월. [ &lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt; ] Resnick, P.,&quot;인터넷 메시지 형식 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , 2008 년 10 월. [ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth, A.,&quot;HTTP 상태 관리 메커니즘 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; , 2011 년 4 월. [ &lt;a id=&quot;ref-RFC6585&quot; name=&quot;ref-RFC6585&quot;&gt;RFC6585&lt;/a&gt;] Nottingham, M. 및 R. Fielding, &quot;추가 HTTP 상태 코드&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6585&quot;&gt;RFC 6585&lt;/a&gt; , 2012 년 4 월.</target>
        </trans-unit>
        <trans-unit id="709bdcb38d1223b2efcf9537053ac448ee82c675" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]    Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP178&quot; name=&quot;ref-BCP178&quot;&gt;BCP178&lt;/a&gt;]   Saint-Andre, P., Crocker, D., and M. Nottingham,
              &quot;Deprecating the &quot;X-&quot; Prefix and Similar Constructs in
              Application Protocols&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp178&quot;&gt;BCP 178&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt;, June 2012. 

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]    van der Stock, A., Ed., &quot;A Guide to Building Secure Web
              Applications and Web Services&quot;, The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              &amp;lt;&lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REST&quot; name=&quot;ref-REST&quot;&gt;REST&lt;/a&gt;]     Fielding, R., &quot;Architectural Styles and the Design of
              Network-based Software Architectures&quot;,
              Doctoral Dissertation, University of California, Irvine,
              September 2000,
              &amp;lt;&lt;a href=&quot;http://roy.gbiv.com/pubs/dissertation/top.htm&quot;&gt;http://roy.gbiv.com/pubs/dissertation/top.htm&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and H. Nielsen, &quot;Hypertext
              Transfer Protocol -- HTTP/1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC2049&quot; name=&quot;ref-RFC2049&quot;&gt;RFC2049&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Five: Conformance Criteria and
              Examples&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Nielsen, H., and T.
              Berners-Lee, &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt;, January 1997.

   [&lt;a id=&quot;ref-RFC2295&quot; name=&quot;ref-RFC2295&quot;&gt;RFC2295&lt;/a&gt;]  Holtman, K. and A. Mutz, &quot;Transparent Content Negotiation
              in HTTP&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt;, March 1998.

   [&lt;a id=&quot;ref-RFC2388&quot; name=&quot;ref-RFC2388&quot;&gt;RFC2388&lt;/a&gt;]  Masinter, L., &quot;Returning Values from Forms:  multipart/
              form-data&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC 2388&lt;/a&gt;, August 1998.

   [&lt;a id=&quot;ref-RFC2557&quot; name=&quot;ref-RFC2557&quot;&gt;RFC2557&lt;/a&gt;]  Palme, F., Hopmann, A., Shelness, N., and E. Stefferud,
              &quot;MIME Encapsulation of Aggregate Documents, such as HTML
              (MHTML)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC 2557&lt;/a&gt;, March 1999.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2774&quot; name=&quot;ref-RFC2774&quot;&gt;RFC2774&lt;/a&gt;]  Frystyk, H., Leach, P., and S. Lawrence, &quot;An HTTP
              Extension Framework&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt;, February 2000.

   [&lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt;]  Khare, R. and S. Lawrence, &quot;Upgrading to TLS Within
              HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC2978&quot; name=&quot;ref-RFC2978&quot;&gt;RFC2978&lt;/a&gt;]  Freed, N. and J. Postel, &quot;IANA Charset Registration
              Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp19&quot;&gt;BCP 19&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC 2978&lt;/a&gt;, October 2000. 

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;, August 2008.

   [&lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt;]  Resnick, P., &quot;Internet Message Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt;,
              October 2008.

   [&lt;a id=&quot;ref-RFC5789&quot; name=&quot;ref-RFC5789&quot;&gt;RFC5789&lt;/a&gt;]  Dusseault, L. and J. Snell, &quot;PATCH Method for HTTP&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt;, March 2010.

   [&lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt;]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &quot;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;, June 2010.

   [&lt;a id=&quot;ref-RFC5987&quot; name=&quot;ref-RFC5987&quot;&gt;RFC5987&lt;/a&gt;]  Reschke, J., &quot;Character Set and Language Encoding for
              Hypertext Transfer Protocol (HTTP) Header Field
              Parameters&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt;, August 2010.

   [&lt;a id=&quot;ref-RFC5988&quot; name=&quot;ref-RFC5988&quot;&gt;RFC5988&lt;/a&gt;]  Nottingham, M., &quot;Web Linking&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt;, October 2010.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]  Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
              April 2011.

   [&lt;a id=&quot;ref-RFC6266&quot; name=&quot;ref-RFC6266&quot;&gt;RFC6266&lt;/a&gt;]  Reschke, J., &quot;Use of the Content-Disposition Header Field
              in the Hypertext Transfer Protocol (HTTP)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt;,
              June 2011.

   [&lt;a id=&quot;ref-RFC7238&quot; name=&quot;ref-RFC7238&quot;&gt;RFC7238&lt;/a&gt;]  Reschke, J., &quot;The Hypertext Transfer Protocol (HTTP)
              Status Code 308 (Permanent Redirect)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt;,
              June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Free , N., Klensin, J. 및 T. Hansen, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; , 2013 년 1 월. [ &lt;a id=&quot;ref-BCP178&quot; name=&quot;ref-BCP178&quot;&gt;BCP178&lt;/a&gt; ] Saint-Andre, P., Crocker, D. 및 M. Nottingham, &quot;응용 프로그램 프로토콜에서&quot;X- &quot;접두사 및 유사한 &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;구문 사용 중단&lt;/a&gt; &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp178&quot;&gt;BCP 178&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6648&quot;&gt;RFC 6648&lt;/a&gt; , 2012 년 6 월. [ BCP90 ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot; 메시지 헤더 필드의 등록 절차 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;] van der Stock, A., Ed., &quot;보안 웹 응용 프로그램 및 웹 서비스 구축 안내서&quot;, OWASP (Open Web Application Security Project) 2.0.1, 2005 년 7 월, &amp;lt; &lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org /&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REST&quot; name=&quot;ref-REST&quot;&gt;REST&lt;/a&gt; ] Fielding, R., &quot;건축 스타일 및 네트워크 기반 소프트웨어 아키텍처의 설계&quot;, 캘리포니아 대학교, 박사 학위 논문, Irvine, 2000 년 9 월, &amp;lt; &lt;a href=&quot;http://roy.gbiv.com/pubs/dissertation/top.htm&quot;&gt;http://roy.gbiv.com/pubs/dissertation/top .htm&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC1945&quot; name=&quot;ref-RFC1945&quot;&gt;RFC1945&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 H. Nielsen, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1945&quot;&gt;RFC 1945&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC2049&quot; name=&quot;ref-RFC2049&quot;&gt;RFC2049&lt;/a&gt;] Freed, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 5 부 : 적합성 기준 및 예&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2049&quot;&gt;RFC 2049&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2068&quot; name=&quot;ref-RFC2068&quot;&gt;RFC2068&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J. , Nielsen, H. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2068&quot;&gt;RFC 2068&lt;/a&gt; , 1997 년 1 월. [ &lt;a id=&quot;ref-RFC2295&quot; name=&quot;ref-RFC2295&quot;&gt;RFC2295&lt;/a&gt; ] Holtman, K. 및 A. Mutz, &quot;HTTP의 투명 콘텐츠 협상&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2295&quot;&gt;RFC 2295&lt;/a&gt; , 1998 년 3 월. [ &lt;a id=&quot;ref-RFC2388&quot; name=&quot;ref-RFC2388&quot;&gt;RFC2388&lt;/a&gt; ] Masinter, L., &quot;양식에서 값 반환 : 다중 부품 / 양식 데이터&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2388&quot;&gt;RFC 2388&lt;/a&gt; , 1998 년 8 월. [ &lt;a id=&quot;ref-RFC2557&quot; name=&quot;ref-RFC2557&quot;&gt;RFC2557&lt;/a&gt;] Palme, F., Hopmann, A., Shelness, N. 및 E. Stefferud, &quot;HTML (MHTML)과 같은 집계 문서의 MIME 캡슐화&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2557&quot;&gt;RFC 2557&lt;/a&gt; , 1999 년 3 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2774&quot; name=&quot;ref-RFC2774&quot;&gt;RFC2774&lt;/a&gt; ] Frystyk, H., Leach, P. 및 S. Lawrence, &quot;HTTP 확장 프레임 워크&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2774&quot;&gt;RFC 2774&lt;/a&gt; , 2000 년 2 월. [ &lt;a id=&quot;ref-RFC2817&quot; name=&quot;ref-RFC2817&quot;&gt;RFC2817&lt;/a&gt; ] Khare, R. 및 S. Lawrence, &quot;HTTP / 1.1 내에서 TLS로 업그레이드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2817&quot;&gt;RFC 2817&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC2978&quot; name=&quot;ref-RFC2978&quot;&gt;RFC2978&lt;/a&gt;] Freed, N. 및 J. Postel, &quot;IANA &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;문자 세트&lt;/a&gt; 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp19&quot;&gt;BCP 19&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2978&quot;&gt;RFC 2978&lt;/a&gt; , 2000 년 10 월. [ RFC5226 ] Narten, T. 및 H. Alvestrand, &quot;RFC에서 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot;TLS (Transport Layer Security) 프로토콜 버전 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt; , 2008 년 8 월. [ &lt;a id=&quot;ref-RFC5322&quot; name=&quot;ref-RFC5322&quot;&gt;RFC5322&lt;/a&gt; ] Resnick, P., &quot;Internet 메시지 형식 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5322&quot;&gt;RFC 5322&lt;/a&gt; , 2008 년 10 월. [ &lt;a id=&quot;ref-RFC5789&quot; name=&quot;ref-RFC5789&quot;&gt;RFC5789&lt;/a&gt;] Dusseault, L. 및 J. Snell, &quot;HTTP 용 패치 방법&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5789&quot;&gt;RFC 5789&lt;/a&gt; , 2010 년 3 월. [ &lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt; ] Mills, D., Martin, J., Ed., Burbank, J. 및 W. Kasch, &quot; 네트워크 시간 프로토콜 버전 4 : 프로토콜 및 알고리즘 사양 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt; , 2010 년 6 월. [ &lt;a id=&quot;ref-RFC5987&quot; name=&quot;ref-RFC5987&quot;&gt;RFC5987&lt;/a&gt; ] Reschke, J.,&quot;HTTP (Hypertext Transfer Protocol) 헤더 필드 매개 변수의 문자 세트 및 언어 인코딩 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5987&quot;&gt;RFC 5987&lt;/a&gt; , 2010 년 8 월. [ &lt;a id=&quot;ref-RFC5988&quot; name=&quot;ref-RFC5988&quot;&gt;RFC5988&lt;/a&gt; ] Nottingham, M., &quot;웹 링크&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5988&quot;&gt;RFC 5988&lt;/a&gt; , 2010 년 10 월. [ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth, A., &quot;HTTP 상태 관리 메커니즘&quot;,&lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;[ &lt;a id=&quot;ref-RFC6266&quot; name=&quot;ref-RFC6266&quot;&gt;RFC6266&lt;/a&gt; ] Reschke, J., &quot;HTTP (Hypertext Transfer Protocol)에서 콘텐츠 처리 헤더 필드 사용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6266&quot;&gt;RFC 6266&lt;/a&gt; , 2011 년 6 월. [ &lt;a id=&quot;ref-RFC7238&quot; name=&quot;ref-RFC7238&quot;&gt;RFC7238&lt;/a&gt; ] Reschke, J., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP) 상태 코드 308 (영구적 리디렉션) &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7238&quot;&gt;RFC 7238&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="188dbbf80aeecdc21816591c6751af6f215cfa89" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt;]    Freed, N., Klensin, J., and T. Hansen, &quot;Media Type
              Specifications and Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt;, January 2013.

   [&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP13&quot; name=&quot;ref-BCP13&quot;&gt;BCP13&lt;/a&gt; ] Free , N., Klensin, J. 및 T. Hansen, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc6838&quot;&gt;RFC 6838&lt;/a&gt; , 2013 년 1 월. [ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;] Narten, T. 및 H. Alvestrand, &quot;RFC에 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월.</target>
        </trans-unit>
        <trans-unit id="73a151d5cd044c04e47c30098a4884b545c7d743" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt;]    van der Stock, A., Ed., &quot;A Guide to Building Secure Web
              Applications and Web Services&quot;, The Open Web Application
              Security Project (OWASP) 2.0.1, July 2005,
              &amp;lt;&lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999. 

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt;]  Josefsson, S., &quot;The Base16, Base32, and Base64 Data
              Encodings&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;, October 2006.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;, August 2008.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-OWASP&quot; name=&quot;ref-OWASP&quot;&gt;OWASP&lt;/a&gt; ] van der Stock, A., Ed., &quot; 안전한 웹 응용 프로그램 및 웹 서비스 구축 안내서 &quot;, 2005 년 7 월 OWASP (Open Web Application Security Project) 2.0.1, &amp;lt; &lt;a href=&quot;https://www.owasp.org/&quot;&gt;https://www.owasp.org/&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;하이퍼 텍스트 전송 프로토콜-HTTP / 1.1&quot; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A. 및 L. Stewart, &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform Resource Identifier (URI) : Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt; ] Josefsson , S., &quot;Base16, Base32 및 Base64 데이터 인코딩&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt; , 2006 년 10 월. [ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten, T. 및 H. Alvestrand, &quot;RFC의 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; ,&lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5246&quot; name=&quot;ref-RFC5246&quot;&gt;RFC5246&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot;TLS (Transport Layer Security) 프로토콜 버전 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt; , 2008 년 8 월.</target>
        </trans-unit>
        <trans-unit id="68349d0417ea59a9fce1a54293548f5d71f13c68" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC4918&quot; name=&quot;ref-RFC4918&quot;&gt;RFC4918&lt;/a&gt;]  Dusseault, L., Ed., &quot;HTTP Extensions for Web Distributed
              Authoring and Versioning (WebDAV)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt;, June 2007.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul , J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC4918&quot; name=&quot;ref-RFC4918&quot;&gt;RFC4918&lt;/a&gt; ] Dusseault, L. , Ed., &quot;WebDAV (Web Distributed Authoring and Versioning)를위한 HTTP 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4918&quot;&gt;RFC 4918&lt;/a&gt; , 2007 년 6 월.</target>
        </trans-unit>
        <trans-unit id="de3ead8edc0a72f563112dfbf128ce107b02bbff" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt;]    Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]  Narten, T. and H. Alvestrand, &quot;Guidelines for Writing an
              IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;,
              May 2008.

   [&lt;a id=&quot;ref-RFC5861&quot; name=&quot;ref-RFC5861&quot;&gt;RFC5861&lt;/a&gt;]  Nottingham, M., &quot;HTTP Cache-Control Extensions for Stale
              Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5861&quot;&gt;RFC 5861&lt;/a&gt;, April 2010.

   [&lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt;]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,
              &quot;Network Time Protocol Version 4: Protocol and Algorithms
              Specification&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt;, June 2010.

   [&lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt;]  Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
              April 2011.</source>
          <target state="translated">[ &lt;a id=&quot;ref-BCP90&quot; name=&quot;ref-BCP90&quot;&gt;BCP90&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt; ] Fielding, R., Gettys, J., Mogul , J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt; ] Narten, T. 및 H. Alvestrand, &quot;RFC에 IANA 고려 사항 섹션 작성 지침&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt; , 2008 년 5 월. [ &lt;a id=&quot;ref-RFC5861&quot; name=&quot;ref-RFC5861&quot;&gt;RFC5861&lt;/a&gt;] Nottingham, M., &quot;부실 콘텐츠에 대한 HTTP 캐시 제어 확장&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5861&quot;&gt;RFC 5861&lt;/a&gt; , 2010 년 4 월. [ &lt;a id=&quot;ref-RFC5905&quot; name=&quot;ref-RFC5905&quot;&gt;RFC5905&lt;/a&gt; ] Mills, D., Martin, J., Ed., Burbank, J. 및 W. Kasch, &quot; 네트워크 시간 프로토콜 버전 4 : 프로토콜 및 알고리즘 사양 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5905&quot;&gt;RFC 5905&lt;/a&gt; , 2010 년 6 월. [ &lt;a id=&quot;ref-RFC6265&quot; name=&quot;ref-RFC6265&quot;&gt;RFC6265&lt;/a&gt; ] Barth, A.,&quot;HTTP 상태 관리 메커니즘 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt; , 2011 년 4 월.</target>
        </trans-unit>
        <trans-unit id="390d44a5ce8c201e485b64aa3ebe6718d49c5fd6" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-COMPRESSION&quot; name=&quot;ref-COMPRESSION&quot;&gt;COMPRESSION&lt;/a&gt;] Peon, R. and H. Ruellan, &quot;HPACK: Header Compression for
                 HTTP/2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7541&quot;&gt;RFC 7541&lt;/a&gt;, DOI 10.17487/RFC7541, May 2015,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7541&quot;&gt;http://www.rfc-editor.org/info/rfc7541&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-COOKIE&quot; name=&quot;ref-COOKIE&quot;&gt;COOKIE&lt;/a&gt;]      Barth, A., &quot;HTTP State Management Mechanism&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6265&quot;&gt;RFC 6265&lt;/a&gt;,
                 DOI 10.17487/RFC6265, April 2011,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc6265&quot;&gt;http://www.rfc-editor.org/info/rfc6265&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-FIPS186&quot; name=&quot;ref-FIPS186&quot;&gt;FIPS186&lt;/a&gt;]     NIST, &quot;Digital Signature Standard (DSS)&quot;, FIPS PUB
                 186-4, July 2013,
                 &amp;lt;&lt;a href=&quot;http://dx.doi.org/10.6028/NIST.FIPS.186-4&quot;&gt;http://dx.doi.org/10.6028/NIST.FIPS.186-4&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]     Bradner, S., &quot;Key words for use in RFCs to Indicate
                 Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, DOI 10.17487/
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC2119&lt;/a&gt;, March 1997,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc2119&quot;&gt;http://www.rfc-editor.org/info/rfc2119&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]     Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, DOI 10.17487/
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC2818&lt;/a&gt;, May 2000,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc2818&quot;&gt;http://www.rfc-editor.org/info/rfc2818&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and L. Masinter,
                 &quot;Uniform Resource Identifier (URI): Generic Syntax&quot;,
                 STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, DOI 10.17487/RFC3986, January 2005,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc3986&quot;&gt;http://www.rfc-editor.org/info/rfc3986&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC4648&quot; name=&quot;ref-RFC4648&quot;&gt;RFC4648&lt;/a&gt;]     Josefsson, S., &quot;The Base16, Base32, and Base64 Data
                 Encodings&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4648&quot;&gt;RFC 4648&lt;/a&gt;, DOI 10.17487/RFC4648, October
                 2006, &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc4648&quot;&gt;http://www.rfc-editor.org/info/rfc4648&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC5226&quot; name=&quot;ref-RFC5226&quot;&gt;RFC5226&lt;/a&gt;]     Narten, T. and H. Alvestrand, &quot;Guidelines for Writing
                 an IANA Considerations Section in RFCs&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp26&quot;&gt;BCP 26&lt;/a&gt;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc5226&quot;&gt;RFC 5226&lt;/a&gt;, DOI 10.17487/RFC5226, May 2008,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc5226&quot;&gt;http://www.rfc-editor.org/info/rfc5226&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]     Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for
                 Syntax Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;,
                 DOI 10.17487/ &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC5234&lt;/a&gt;, January 2008,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc5234&quot;&gt;http://www.rfc-editor.org/info/rfc5234&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Message Syntax and
                 Routing&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, DOI 10.17487/RFC7230, June 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7230&quot;&gt;http://www.rfc-editor.org/info/rfc7230&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Semantics and Content&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, DOI 10.17487/RFC7231, June 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7231&quot;&gt;http://www.rfc-editor.org/info/rfc7231&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Conditional Requests&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;, DOI 10.17487/RFC7232, June 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7232&quot;&gt;http://www.rfc-editor.org/info/rfc7232&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
                 &quot;Hypertext Transfer Protocol (HTTP/1.1): Range
                 Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, DOI 10.17487/RFC7233, June 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7233&quot;&gt;http://www.rfc-editor.org/info/rfc7233&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
                 Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, DOI 10.17487/RFC7234, June 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7234&quot;&gt;http://www.rfc-editor.org/info/rfc7234&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Authentication&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, DOI 10.17487/RFC7235, June 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7235&quot;&gt;http://www.rfc-editor.org/info/rfc7235&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-TCP&quot; name=&quot;ref-TCP&quot;&gt;TCP&lt;/a&gt;]         Postel, J., &quot;Transmission Control Protocol&quot;, STD 7, &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;793&lt;/a&gt;, DOI 10.17487/RFC0793, September 1981,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc793&quot;&gt;http://www.rfc-editor.org/info/rfc793&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-TLS-ALPN&quot; name=&quot;ref-TLS-ALPN&quot;&gt;TLS-ALPN&lt;/a&gt;]    Friedl, S., Popov, A., Langley, A., and E. Stephan,
                 &quot;Transport Layer Security (TLS) Application-Layer
                 Protocol Negotiation Extension&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7301&quot;&gt;RFC 7301&lt;/a&gt;,
                 DOI 10.17487/RFC7301, July 2014,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc7301&quot;&gt;http://www.rfc-editor.org/info/rfc7301&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-TLS-ECDHE&quot; name=&quot;ref-TLS-ECDHE&quot;&gt;TLS-ECDHE&lt;/a&gt;]   Rescorla, E., &quot;TLS Elliptic Curve Cipher Suites with
                 SHA-256/384 and AES Galois Counter Mode (GCM)&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc5289&quot;&gt;RFC 5289&lt;/a&gt;, DOI 10.17487/RFC5289, August 2008,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc5289&quot;&gt;http://www.rfc-editor.org/info/rfc5289&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-TLS-EXT&quot; name=&quot;ref-TLS-EXT&quot;&gt;TLS-EXT&lt;/a&gt;]     Eastlake 3rd, D., &quot;Transport Layer Security (TLS)
                 Extensions: Extension Definitions&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6066&quot;&gt;RFC 6066&lt;/a&gt;,
                 DOI 10.17487/RFC6066, January 2011,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc6066&quot;&gt;http://www.rfc-editor.org/info/rfc6066&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-TLS12&quot; name=&quot;ref-TLS12&quot;&gt;TLS12&lt;/a&gt;]       Dierks, T. and E. Rescorla, &quot;The Transport Layer
                 Security (TLS) Protocol Version 1.2&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC 5246&lt;/a&gt;,
                 DOI 10.17487/ &lt;a href=&quot;https://tools.ietf.org/html/rfc5246&quot;&gt;RFC5246&lt;/a&gt;, August 2008,
                 &amp;lt;&lt;a href=&quot;http://www.rfc-editor.org/info/rfc5246&quot;&gt;http://www.rfc-editor.org/info/rfc5246&lt;/a&gt;&amp;gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be465035882a640817e7c019d9758fba1f0298fa" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-NOTE-detect-lost-update&quot; name=&quot;ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt;]
              Nielsen, H. and D. LaLiberte, &quot;Editing the Web: Detecting
              the Lost Update Problem Using Unreserved Checkout&quot;, World
              Wide Web Consortium NOTE NOTE-detect-lost-update, May
              1999, &amp;lt;&lt;a href=&quot;http://www.w3.org/1999/04/Editing/&quot;&gt;http://www.w3.org/1999/04/Editing/&lt;/a&gt;&amp;gt;. 

   [&lt;a id=&quot;ref-REC-webarch&quot; name=&quot;ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt;]
              Walsh, N. and I. Jacobs, &quot;Architecture of the World Wide
              Web, Volume One&quot;, W3C REC REC-webarch-20041215, December
              2004, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-webarch-20041215&quot;&gt;http://www.w3.org/TR/2004/REC-webarch-20041215&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RNC&quot; name=&quot;ref-RNC&quot;&gt;RNC&lt;/a&gt;]      Clark, J., &quot;RELAX NG Compact Syntax&quot;, December 2001,
              &amp;lt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;http://www.oasis-open.org/committees/relax-ng/&lt;/a&gt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;compact-20021121.html&lt;/a&gt;&amp;gt;.</source>
          <target state="translated">[ &lt;a id=&quot;ref-NOTE-detect-lost-update&quot; name=&quot;ref-NOTE-detect-lost-update&quot;&gt;NOTE-detect-lost-update&lt;/a&gt; ] Nielsen, H. 및 D. LaLiberte, &quot;웹 편집 : 예약되지 않은 체크 아웃을 사용한 손실 된 업데이트 문제 감지&quot;, 월드 와이드 웹 컨소시엄 NOTE NOTE-detect-lost-update, 1999 년 5 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/1999/04/Editing/&quot;&gt;http://www.w3.org/1999/04/Editing/&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-webarch&quot; name=&quot;ref-REC-webarch&quot;&gt;REC-webarch&lt;/a&gt; ] Walsh, N. 및 I. Jacobs, &quot;World Wide Web의 아키텍처, 볼륨 1&quot;, W3C REC REC-webarch-20041215, 2004 년 12 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-webarch-20041215&quot;&gt;http://www.w3.org/TR/ 2004 / REC-webarch-20041215&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RNC&quot; name=&quot;ref-RNC&quot;&gt;RNC&lt;/a&gt; ] Clark, J., &quot;RELAX NG Compact Syntax&quot;, 2001 년 12 월, &amp;lt; &lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;http://www.oasis-open.org/committees/relax-ng/ &lt;/a&gt;&lt;a href=&quot;http://www.oasis-open.org/committees/relax-ng/compact-20021121.html&quot;&gt;compact-20021121.html&lt;/a&gt;&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="9b0101cca3163bcad6c18b71db53c2de9c25f26c" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-REC-XML&quot; name=&quot;ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt;]          Bray, T., Paoli, J., Sperberg-McQueen, C., Maler,
                      E., and F. Yergeau, &quot;Extensible Markup Language
                      (XML) 1.0 (Fourth Edition)&quot;, W3C REC-xml-20060816,
                      August 2006,
                      &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816/&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-XML-INFOSET&quot; name=&quot;ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt;]  Cowan, J. and R. Tobin, &quot;XML Information Set
                      (Second Edition)&quot;, W3C REC-xml-infoset-20040204,
                      February 2004, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;http://www.w3.org/TR/2004/&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;REC-xml-infoset-20040204/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-XML-NAMES&quot; name=&quot;ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;]    Bray, T., Hollander, D., Layman, A., and R. Tobin,
                      &quot;Namespaces in XML 1.0 (Second Edition)&quot;, W3C REC-
                      xml-names-20060816, August 2006, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;http://&lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;www.w3.org/TR/2006/REC-xml-names-20060816/&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]          Bradner, S., &quot;Key words for use in RFCs to
                      Indicate Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;,
                      March 1997.

   [&lt;a id=&quot;ref-RFC2277&quot; name=&quot;ref-RFC2277&quot;&gt;RFC2277&lt;/a&gt;]          Alvestrand, H., &quot;IETF Policy on Character Sets and
                      Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt;, January 1998.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]          Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
                      Masinter, L., Leach, P., and T. Berners-Lee,
                      &quot;Hypertext Transfer Protocol -- HTTP/1.1&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999. 

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]          Franks, J., Hallam-Baker, P., Hostetler, J.,
                      Lawrence, S., Leach, P., Luotonen, A., and L.
                      Stewart, &quot;HTTP Authentication: Basic and Digest
                      Access Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC3339&quot; name=&quot;ref-RFC3339&quot;&gt;RFC3339&lt;/a&gt;]          Klyne, G., Ed. and C. Newman, &quot;Date and Time on
                      the Internet: Timestamps&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt;, July 2002.

   [&lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;]          Yergeau, F., &quot;UTF-8, a transformation format of
                      ISO 10646&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;, November 2003.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]          Berners-Lee, T., Fielding, R., and L. Masinter,
                      &quot;Uniform Resource Identifier (URI): Generic
                      Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4122&quot; name=&quot;ref-RFC4122&quot;&gt;RFC4122&lt;/a&gt;]          Leach, P., Mealling, M., and R. Salz, &quot;A
                      Universally Unique IDentifier (UUID) URN
                      Namespace&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt;, July 2005.</source>
          <target state="translated">[ &lt;a id=&quot;ref-REC-XML&quot; name=&quot;ref-REC-XML&quot;&gt;REC-XML&lt;/a&gt; ] Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. 및 F. Yergeau, &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot;, W3C REC-xml -20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816/&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816/&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-XML-INFOSET&quot; name=&quot;ref-REC-XML-INFOSET&quot;&gt;REC-XML-INFOSET&lt;/a&gt; ] Cowan, J. 및 R. Tobin, &quot;XML 정보 세트 (제 2 판)&quot;, W3C REC-xml-infoset-20040204, 2004 년 2 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;http://www.w3.org/TR / 2004 / &lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204/&quot;&gt;REC-xml-infoset-20040204 /&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-XML-NAMES&quot; name=&quot;ref-REC-XML-NAMES&quot;&gt;REC-XML-NAMES&lt;/a&gt;] Bray, T., Hollander, D., Layman, A. 및 R. Tobin, &quot;XML 1.0의 네임 스페이스 (제 2 판)&quot;, W3C REC- xml-names-20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;http : // &lt;/a&gt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816/&quot;&gt;www .w3.org / TR / 2006 / REC-xml-names-20060816 /&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 &lt;a id=&quot;ref-RFC2277&quot; name=&quot;ref-RFC2277&quot;&gt;나타내는&lt;/a&gt; RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ RFC2277 ] Alvestrand, H., &quot;문자 세트 및 언어에 대한 IETF 정책&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp18&quot;&gt;BCP 18&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2277&quot;&gt;RFC 2277&lt;/a&gt; , 1998 년 1 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt; , 1999 년 6 월 [ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt; ] 프랭크 J., 경이 베이커, P., Hostetler, J., 로렌스, S., 리치, P., Luotonen, A. 및 스튜어트 L., &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC3339&quot; name=&quot;ref-RFC3339&quot;&gt;RFC3339&lt;/a&gt; ] Klyne, G., Ed. 및 C. Newman, &quot;인터넷상의 날짜 및 시간 : 타임 스탬프&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3339&quot;&gt;RFC 3339&lt;/a&gt; , 2002 년 7 월. [ &lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;] Yergeau, F., &quot;UTF-8, ISO 10646의 변환 형식&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt; , 2003 년 11 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform URI (Resource Identifier) ​​: 일반 구문 &quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC4122&quot; name=&quot;ref-RFC4122&quot;&gt;RFC4122&lt;/a&gt; ] Leach, P., Mealling, M. 및 R. Salz,&quot;UUID (Universally Unique Identifier) ​​URN 네임 스페이스 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4122&quot;&gt;RFC 4122&lt;/a&gt; , 2005 년 7 월.</target>
        </trans-unit>
        <trans-unit id="f109ae6f660a3e51addf064374205f31f9fc1367" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-REC-xml&quot; name=&quot;ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt;]  Yergeau, F., Paoli, J., Bray, T., Sperberg-McQueen, C.,
              and E. Maler, &quot;Extensible Markup Language (XML) 1.0
              (Fourth Edition)&quot;, World Wide Web Consortium
              Recommendation REC-xml-20060816, August 2006,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xml-infoset&quot; name=&quot;ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt;]
              Cowan, J. and R. Tobin, &quot;XML Information Set (Second
              Edition)&quot;, World Wide Web Consortium Recommendation REC-
              xml-infoset-20040204, February 2004,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&quot;&gt;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xml-names&quot; name=&quot;ref-REC-xml-names&quot;&gt;REC-xml-names&lt;/a&gt;]
              Hollander, D., Bray, T., Tobin, R., and A. Layman,
              &quot;Namespaces in XML 1.0 (Second Edition)&quot;, World Wide Web
              Consortium Recommendation REC-xml-names-20060816, August
              2006, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-names-20060816&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmlbase&quot; name=&quot;ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt;]
              Marsh, J., &quot;XML Base&quot;, W3C REC W3C.REC-xmlbase-20010627,
              June 2001,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlbase-20010627&quot;&gt;http://www.w3.org/TR/2001/REC-xmlbase-20010627&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmldsig-core&quot; name=&quot;ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt;]
              Solo, D., Reagle, J., and D. Eastlake, &quot;XML-Signature
              Syntax and Processing&quot;, World Wide Web Consortium
              Recommendation REC-xmldsig-core-20020212, February 2002,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&quot;&gt;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-REC-xmlenc-core&quot; name=&quot;ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt;]
              Eastlake, D. and J. Reagle, &quot;XML Encryption Syntax and
              Processing&quot;, World Wide Web Consortium Recommendation REC-
              xmlenc-core-20021210, December 2002,
              &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&quot;&gt;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&lt;/a&gt;&amp;gt;.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997. 

   [&lt;a id=&quot;ref-RFC2246&quot; name=&quot;ref-RFC2246&quot;&gt;RFC2246&lt;/a&gt;]  Dierks, T. and C. Allen, &quot;The TLS Protocol Version 1.0&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC 2246&lt;/a&gt;, January 1999.

   [&lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;]  Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,
              Masinter, L., Leach, P., and T. Berners-Lee, &quot;Hypertext
              Transfer Protocol -- HTTP/1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 2616&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt;]  Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S.,
              Leach, P., Luotonen, A., and L. Stewart, &quot;HTTP
              Authentication: Basic and Digest Access Authentication&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt;, June 1999.

   [&lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt;]  Rescorla, E., &quot;HTTP Over TLS&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt;, May 2000.

   [&lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;]  Murata, M., St. Laurent, S., and D. Kohn, &quot;XML Media
              Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;, January 2001.

   [&lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;]  Yergeau, F., &quot;UTF-8, a transformation format of ISO
              10646&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt;, November 2003.

   [&lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt;]  Klyne, G., Nottingham, M., and J. Mogul, &quot;Registration
              Procedures for Message Header Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;,
              September 2004.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC&lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC3987&quot; name=&quot;ref-RFC3987&quot;&gt;RFC3987&lt;/a&gt;]  Duerst, M. and M. Suignard, &quot;Internationalized Resource
              Identifiers (IRIs)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC 3987&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4287&quot; name=&quot;ref-RFC4287&quot;&gt;RFC4287&lt;/a&gt;]  Nottingham, M. and R. Sayre, &quot;The Atom Syndication
              Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC 4287&lt;/a&gt;, December 2005.

   [&lt;a id=&quot;ref-RFC4288&quot; name=&quot;ref-RFC4288&quot;&gt;RFC4288&lt;/a&gt;]  Freed, N. and J. Klensin, &quot;Media Type Specifications and
              Registration Procedures&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC 4288&lt;/a&gt;, December 2005.

   [&lt;a id=&quot;ref-RFC4346&quot; name=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt;]  Dierks, T. and E. Rescorla, &quot;The Transport Layer Security
              (TLS) Protocol Version 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt;, April 2006.</source>
          <target state="translated">[ &lt;a id=&quot;ref-REC-xml&quot; name=&quot;ref-REC-xml&quot;&gt;REC-xml&lt;/a&gt; ] Yergeau, F., Paoli, J., Bray, T., Sperberg-McQueen, C. 및 E. Maler, &quot;Extensible Markup Language (XML) 1.0 (Fourth Edition)&quot;, 월드 와이드 웹 컨소시엄 권장 REC-xml-20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-20060816&quot;&gt;http://www.w3.org/TR/2006/REC-xml-20060816&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xml-infoset&quot; name=&quot;ref-REC-xml-infoset&quot;&gt;REC-xml-infoset&lt;/a&gt; ] Cowan, J. 및 R. Tobin, &quot;XML 정보 세트 (제 2 판)&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC-xml-infoset-20040204, 2004 년 2 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2004/REC-xml-infoset-20040204&quot;&gt;http : //www.w3 .org / TR / 2004 / REC-xml-infoset-20040204&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xml-names&quot; name=&quot;ref-REC-xml-names&quot;&gt;REC-xml- 이름&lt;/a&gt;] Hollander, D., Bray, T., Tobin, R. 및 A. Layman, &quot;XML 1.0의 네임 스페이스 (제 2 판)&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC-xml-names-20060816, 2006 년 8 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2006/REC-xml-names-20060816&quot;&gt;http : //www.w3.org/TR/2006/REC-xml-names-20060816&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xmlbase&quot; name=&quot;ref-REC-xmlbase&quot;&gt;REC-xmlbase&lt;/a&gt; ] Marsh, J., &quot;XML Base&quot;, W3C REC W3C.REC-xmlbase-20010627, 2001 년 6 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2001/REC-xmlbase-20010627&quot;&gt;http://www.w3.org/TR/2001/REC-xmlbase-20010627&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xmldsig-core&quot; name=&quot;ref-REC-xmldsig-core&quot;&gt;REC-xmldsig-core&lt;/a&gt; ] Solo, D., Reagle, J. 및 D. Eastlake, &quot;XML- 서명 구문 및 처리&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC-xmldsig-core-20020212, 2002 년 2 월, &amp;lt;&lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&quot;&gt;http://www.w3.org/TR/2002/REC-xmldsig-core-20020212&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-REC-xmlenc-core&quot; name=&quot;ref-REC-xmlenc-core&quot;&gt;REC-xmlenc-core&lt;/a&gt; ] Eastlake, D. 및 J. Reagle, &quot;XML 암호화 구문 및 처리&quot;, 월드 와이드 웹 컨소시엄 권장 사항 REC- xmlenc-core-20021210, 2002 년 12 월, &amp;lt; &lt;a href=&quot;http://www.w3.org/TR/2002/REC-xmlenc-core-20021210&quot;&gt;http://www.w3.org / TR / 2002 / REC-xmlenc-core-20021210&lt;/a&gt; &amp;gt;. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC2246&quot; name=&quot;ref-RFC2246&quot;&gt;RFC2246&lt;/a&gt; ] Dierks, T. 및 C. Allen, &quot;TLS 프로토콜 버전 1.0&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2246&quot;&gt;RFC 2246&lt;/a&gt; , 1999 년 1 월. [ &lt;a id=&quot;ref-RFC2616&quot; name=&quot;ref-RFC2616&quot;&gt;RFC2616&lt;/a&gt;] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., Masinter, L., Leach, P. 및 T. Berners-Lee, &quot;Hypertext Transfer Protocol-HTTP / 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2616&quot;&gt;RFC 261&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2617&quot; name=&quot;ref-RFC2617&quot;&gt;RFC2617&lt;/a&gt; ] Franks, J., Hallam-Baker, P., Hostetler, J., Lawrence, S., Leach, P., Luotonen, A. 및 L. Stewart, &quot;HTTP 인증 : 기본 및 다이제스트 액세스 인증 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2617&quot;&gt;RFC 2617&lt;/a&gt; , 1999 년 6 월. [ &lt;a id=&quot;ref-RFC2818&quot; name=&quot;ref-RFC2818&quot;&gt;RFC2818&lt;/a&gt; ] Rescorla , E.,&quot;HTTP Over TLS &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2818&quot;&gt;RFC 2818&lt;/a&gt; , 2000 년 5 월. [ &lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt; ] Murata, M., St. Laurent, S. 및 D. Kohn, &quot;XML 미디어 유형&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt; , 2001 년 1 월. [ &lt;a id=&quot;ref-RFC3629&quot; name=&quot;ref-RFC3629&quot;&gt;RFC3629&lt;/a&gt;] Yergeau, F., &quot;UTF-8, ISO 10646의 변환 형식&quot;, STD 63, &lt;a href=&quot;https://tools.ietf.org/html/rfc3629&quot;&gt;RFC 3629&lt;/a&gt; , 2003 년 11 월. [ &lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt; ] Klyne, G., Nottingham, M. 및 J. Mogul, &quot;등록 절차 메시지 헤더 필드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter,&quot;Uniform Resource Identifier (URI) : Generic Syntax &quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC &lt;/a&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;3986&lt;/a&gt; , 2005 년 1 월 [ &lt;a id=&quot;ref-RFC3987&quot; name=&quot;ref-RFC3987&quot;&gt;RFC3987&lt;/a&gt; ] Duerst, M. M. 및 Suignard &quot;다국어 리소스 식별자 (아이리스)&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3987&quot;&gt;RFC 3987&lt;/a&gt; , 2005 년 1 월 [ &lt;a id=&quot;ref-RFC4287&quot; name=&quot;ref-RFC4287&quot;&gt;RFC4287&lt;/a&gt;] Nottingham, M. 및 R. Sayre, &quot;Atom Syndication Format&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4287&quot;&gt;RFC 4287&lt;/a&gt; , 2005 년 12 월. [ &lt;a id=&quot;ref-RFC4288&quot; name=&quot;ref-RFC4288&quot;&gt;RFC4288&lt;/a&gt; ] Freed, N. 및 J. Klensin, &quot;미디어 유형 사양 및 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp13&quot;&gt;BCP 13&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc4288&quot;&gt;RFC 4288&lt;/a&gt; , 2005 년 12 월. [ &lt;a id=&quot;ref-RFC4346&quot; name=&quot;ref-RFC4346&quot;&gt;RFC4346&lt;/a&gt; ] Dierks, T. 및 E. Rescorla , &quot;TLS (Transport Layer Security) 프로토콜 버전 1.1&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4346&quot;&gt;RFC 4346&lt;/a&gt; , 2006 년 4 월.</target>
        </trans-unit>
        <trans-unit id="aa753c7ca1de65f848d19927144998faa06fdb5d" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC0793&quot; name=&quot;ref-RFC0793&quot;&gt;RFC0793&lt;/a&gt;]     Postel, J., &quot;Transmission Control Protocol&quot;, STD 7,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC 793&lt;/a&gt;, September 1981.

   [&lt;a id=&quot;ref-RFC1950&quot; name=&quot;ref-RFC1950&quot;&gt;RFC1950&lt;/a&gt;]     Deutsch, L. and J-L. Gailly, &quot;ZLIB Compressed Data
                 Format Specification version 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC1951&quot; name=&quot;ref-RFC1951&quot;&gt;RFC1951&lt;/a&gt;]     Deutsch, P., &quot;DEFLATE Compressed Data Format
                 Specification version 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC1952&quot; name=&quot;ref-RFC1952&quot;&gt;RFC1952&lt;/a&gt;]     Deutsch, P., Gailly, J-L., Adler, M., Deutsch, L., and
                 G. Randers-Pehrson, &quot;GZIP file format specification
                 version 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt;, May 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]     Bradner, S., &quot;Key words for use in RFCs to Indicate
                 Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]     Berners-Lee, T., Fielding, R., and L. Masinter,
                 &quot;Uniform Resource Identifier (URI): Generic Syntax&quot;,
                 STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]     Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for
                 Syntax Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;,
                 January 2008.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Semantics and Content&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Conditional Requests&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]     Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
                 &quot;Hypertext Transfer Protocol (HTTP/1.1): Range
                 Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]     Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
                 Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]     Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext
                 Transfer Protocol (HTTP/1.1): Authentication&quot;,
                 &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014. 

   [&lt;a id=&quot;ref-USASCII&quot; name=&quot;ref-USASCII&quot;&gt;USASCII&lt;/a&gt;]     American National Standards Institute, &quot;Coded Character
                 Set -- 7-bit American Standard Code for Information
                 Interchange&quot;, ANSI X3.4, 1986.

   [&lt;a id=&quot;ref-Welch&quot; name=&quot;ref-Welch&quot;&gt;Welch&lt;/a&gt;]       Welch, T., &quot;A Technique for High-Performance Data
                 Compression&quot;, IEEE Computer 17(6), June 1984.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC0793&quot; name=&quot;ref-RFC0793&quot;&gt;RFC0793&lt;/a&gt; ] Postel, J., &quot;Transmission Control Protocol&quot;, STD 7, &lt;a href=&quot;https://tools.ietf.org/html/rfc793&quot;&gt;RFC 793&lt;/a&gt; , 1981 년 9 월. [ &lt;a id=&quot;ref-RFC1950&quot; name=&quot;ref-RFC1950&quot;&gt;RFC1950&lt;/a&gt; ] Deutsch, L. 및 JL. Gailly, &quot;ZLIB 압축 데이터 형식 사양 버전 3.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1950&quot;&gt;RFC 1950&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC1951&quot; name=&quot;ref-RFC1951&quot;&gt;RFC1951&lt;/a&gt; ] Deutsch, P., &quot;DEFLATE 압축 데이터 형식 사양 버전 1.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1951&quot;&gt;RFC 1951&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC1952&quot; name=&quot;ref-RFC1952&quot;&gt;RFC1952&lt;/a&gt; ] Deutsch, P., Gailly, JL., Adler, M., Deutsch, L. 및 G. Randers-Pehrson, &quot;GZIP 파일 형식 사양 버전 4.3&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc1952&quot;&gt;RFC 1952&lt;/a&gt; , 1996 년 5 월. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform 자원 식별자 (URI) : 일반 구문 &quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed , &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;] Fielding, R., Ed. J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-USASCII&quot; name=&quot;ref-USASCII&quot;&gt;USASCII&lt;/a&gt; ] American National Standards Institute, &quot;코드화 된 문자 세트-정보 교환을위한 7 비트 미국 표준 코드 &quot;, ANSI X3.4, 1986. [ &lt;a id=&quot;ref-Welch&quot; name=&quot;ref-Welch&quot;&gt;Welch&lt;/a&gt; ] Welch, T.,&quot;고성능 데이터 압축 기술 &quot;, IEEE 컴퓨터 17 (6), 1984 년 6 월.</target>
        </trans-unit>
        <trans-unit id="32b5eaf10a6f18bbfaf539b485fd4ae12b86c05e" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part One: Format of Internet Message
              Bodies&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt;, November 1996.

   [&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;,
              November 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997. 

   [&lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt;]  Berners-Lee, T., Fielding, R., and L. Masinter, &quot;Uniform
              Resource Identifier (URI): Generic Syntax&quot;, STD 66,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt;, January 2005.

   [&lt;a id=&quot;ref-RFC4647&quot; name=&quot;ref-RFC4647&quot;&gt;RFC4647&lt;/a&gt;]  Phillips, A., Ed. and M. Davis, Ed., &quot;Matching of Language
              Tags&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647&lt;/a&gt;, September 2006.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC5646&quot; name=&quot;ref-RFC5646&quot;&gt;RFC5646&lt;/a&gt;]  Phillips, A., Ed. and M. Davis, Ed., &quot;Tags for Identifying
              Languages&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646&lt;/a&gt;, September 2009.

   [&lt;a id=&quot;ref-RFC6365&quot; name=&quot;ref-RFC6365&quot;&gt;RFC6365&lt;/a&gt;]  Hoffman, P. and J. Klensin, &quot;Terminology Used in
              Internationalization in the IETF&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp166&quot;&gt;BCP 166&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC 6365&lt;/a&gt;,
              September 2011.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2045&quot; name=&quot;ref-RFC2045&quot;&gt;RFC2045&lt;/a&gt; ] Freed, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 1 부 : 인터넷 메시지 본문 형식&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2045&quot;&gt;RFC 2045&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt; ] Free, N. 및 N. Borenstein, &quot;다목적 MIME (Internet Mail Extensions) 2 부 : 미디어 유형 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S.,&quot;요구 사항 수준을 나타내는 RFC에 사용되는 핵심 단어 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC3986&quot; name=&quot;ref-RFC3986&quot;&gt;RFC3986&lt;/a&gt; ] Berners-Lee, T., Fielding, R. 및 L. Masinter, &quot;Uniform Resource Identifier (URI) : Generic Syntax&quot;, STD 66, &lt;a href=&quot;https://tools.ietf.org/html/rfc3986&quot;&gt;RFC 3986&lt;/a&gt; , 2005 년 1 월. [ &lt;a id=&quot;ref-RFC4647&quot; name=&quot;ref-RFC4647&quot;&gt;RFC4647&lt;/a&gt; ] Phillips, A., Ed. 및 M. Davis, Ed., &quot;언어 태그의 일치&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc4647&quot;&gt;RFC 4647&lt;/a&gt; , 2006 년 9 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC5646&quot; name=&quot;ref-RFC5646&quot;&gt;RFC5646&lt;/a&gt; ] Phillips, A., Ed. 및 M. Davis, Ed., &quot;언어 식별을위한 태그&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp47&quot;&gt;BCP 47&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc5646&quot;&gt;RFC 5646&lt;/a&gt; , 2009 년 9 월. [ &lt;a id=&quot;ref-RFC6365&quot; name=&quot;ref-RFC6365&quot;&gt;RFC6365&lt;/a&gt; ] Hoffman, P. 및 J. Klensin, &quot;IETF 국제화에 사용되는 용어&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp166&quot;&gt;BCP 166&lt;/a&gt; ,&lt;a href=&quot;https://tools.ietf.org/html/rfc6365&quot;&gt;RFC 6365&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Caching&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt; ] Fielding, R 에드 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="0f97a814186cc03d6a95b38611cc68d637712dec" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt;]  Freed, N. and N. Borenstein, &quot;Multipurpose Internet Mail
              Extensions (MIME) Part Two: Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt;,
              November 1996.

   [&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2046&quot; name=&quot;ref-RFC2046&quot;&gt;RFC2046&lt;/a&gt; ] Freed, N. 및 N. Borenstein, &quot;MIME (Multipurpose Internet Mail Extensions) 2 부 : 매체 유형&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2046&quot;&gt;RFC 2046&lt;/a&gt; , 1996 년 11 월. [ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;RFC에서 나타내는 주요 단어 요구 수준 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 시맨틱 스 및 콘텐츠&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 캐싱&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="7e13a726cd253b78f479b6c1518755778145f85b" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Conditional Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Authentication&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;, 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7232&quot; name=&quot;ref-RFC7232&quot;&gt;RFC7232&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 조건부 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7232&quot;&gt;RFC 7232&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 범위 요청&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7235&quot; name=&quot;ref-RFC7235&quot;&gt;RFC7235&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 인증&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7235&quot;&gt;RFC 7235&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="3e9dfb2b3300e3cee5aa29bf83498176e8412766" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt;]  Fielding, R., Ed., Lafon, Y., Ed., and J. Reschke, Ed.,
              &quot;Hypertext Transfer Protocol (HTTP/1.1): Range Requests&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7233&quot; name=&quot;ref-RFC7233&quot;&gt;RFC7233&lt;/a&gt; ] Fielding, R., Ed., Lafon, Y., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Range Requests&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7233&quot;&gt;RFC 7233&lt;/a&gt; , 2014 년 6 월 [ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Caching&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="b85249b3b7b5758e2386a2ce786a0724059a28d2" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt;]  Bradner, S., &quot;Key words for use in RFCs to Indicate
              Requirement Levels&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt;, March 1997.

   [&lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt;]  Crocker, D., Ed. and P. Overell, &quot;Augmented BNF for Syntax
              Specifications: ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt;, January 2008.

   [&lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Message Syntax and Routing&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt;, June 2014.

   [&lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt;]  Fielding, R., Ed. and J. Reschke, Ed., &quot;Hypertext Transfer
              Protocol (HTTP/1.1): Semantics and Content&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;,
              June 2014.

   [&lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt;]  Fielding, R., Ed., Nottingham, M., Ed., and J. Reschke,
              Ed., &quot;Hypertext Transfer Protocol (HTTP/1.1): Caching&quot;,
              &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt;, June 2014.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2119&quot; name=&quot;ref-RFC2119&quot;&gt;RFC2119&lt;/a&gt; ] Bradner, S., &quot;요구 사항 수준을 나타내는 RFC에 사용되는 키워드 &quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp14&quot;&gt;BCP 14&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc2119&quot;&gt;RFC 2119&lt;/a&gt; , 1997 년 3 월. [ &lt;a id=&quot;ref-RFC5234&quot; name=&quot;ref-RFC5234&quot;&gt;RFC5234&lt;/a&gt; ] Crocker, D., Ed. 및 P. Overell, &quot;구문 사양을위한 증강 BNF : ABNF&quot;, STD 68, &lt;a href=&quot;https://tools.ietf.org/html/rfc5234&quot;&gt;RFC 5234&lt;/a&gt; , 2008 년 1 월. [ &lt;a id=&quot;ref-RFC7230&quot; name=&quot;ref-RFC7230&quot;&gt;RFC7230&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7230&quot;&gt;RFC 7230&lt;/a&gt; , 2014 년 6 월. [ &lt;a id=&quot;ref-RFC7231&quot; name=&quot;ref-RFC7231&quot;&gt;RFC7231&lt;/a&gt; ] Fielding, R., Ed. 및 J. Reschke, Ed., &quot;하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 의미 및 내용&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7231&quot;&gt;RFC 7231&lt;/a&gt;[ &lt;a id=&quot;ref-RFC7234&quot; name=&quot;ref-RFC7234&quot;&gt;RFC7234&lt;/a&gt; ] Fielding, R., Ed., Nottingham, M., Ed. 및 J. Reschke, Ed., &quot;Hypertext Transfer Protocol (HTTP / 1.1) : Caching&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc7234&quot;&gt;RFC 7234&lt;/a&gt; , 2014 년 6 월.</target>
        </trans-unit>
        <trans-unit id="8a4091e2c539cdc5431420dbeb2649f7bc6c3639" translate="yes" xml:space="preserve">
          <source>[&lt;a id=&quot;ref-RFC2291&quot; name=&quot;ref-RFC2291&quot;&gt;RFC2291&lt;/a&gt;]          Slein, J., Vitali, F., Whitehead, E., and D.
                      Durand, &quot;Requirements for a Distributed Authoring
                      and Versioning Protocol for the World Wide Web&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC 2291&lt;/a&gt;, February 1998.

   [&lt;a id=&quot;ref-RFC2518&quot; name=&quot;ref-RFC2518&quot;&gt;RFC2518&lt;/a&gt;]          Goland, Y., Whitehead, E., Faizi, A., Carter, S.,
                      and D. Jensen, &quot;HTTP Extensions for Distributed
                      Authoring -- WEBDAV&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt;, February 1999.

   [&lt;a id=&quot;ref-RFC2781&quot; name=&quot;ref-RFC2781&quot;&gt;RFC2781&lt;/a&gt;]          Hoffman, P. and F. Yergeau, &quot;UTF-16, an encoding
                      of ISO 10646&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC 2781&lt;/a&gt;, February 2000.

   [&lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;]          Murata, M., St. Laurent, S., and D. Kohn, &quot;XML
                      Media Types&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt;, January 2001.

   [&lt;a id=&quot;ref-RFC3253&quot; name=&quot;ref-RFC3253&quot;&gt;RFC3253&lt;/a&gt;]          Clemm, G., Amsden, J., Ellison, T., Kaler, C., and
                      J. Whitehead, &quot;Versioning Extensions to WebDAV
                      (Web Distributed Authoring and Versioning)&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC 3253&lt;/a&gt;, March 2002.

   [&lt;a id=&quot;ref-RFC3648&quot; name=&quot;ref-RFC3648&quot;&gt;RFC3648&lt;/a&gt;]          Whitehead, J. and J. Reschke, Ed., &quot;Web
                      Distributed Authoring and Versioning (WebDAV)
                      Ordered Collections Protocol&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC 3648&lt;/a&gt;,
                      December 2003. 

   [&lt;a id=&quot;ref-RFC3744&quot; name=&quot;ref-RFC3744&quot;&gt;RFC3744&lt;/a&gt;]          Clemm, G., Reschke, J., Sedlar, E., and J.
                      Whitehead, &quot;Web Distributed Authoring and
                      Versioning (WebDAV) Access Control Protocol&quot;,
                      &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC 3744&lt;/a&gt;, May 2004.

   [&lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt;]          Klyne, G., Nottingham, M., and J. Mogul,
                      &quot;Registration Procedures for Message Header
                      Fields&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt;, September 2004.</source>
          <target state="translated">[ &lt;a id=&quot;ref-RFC2291&quot; name=&quot;ref-RFC2291&quot;&gt;RFC2291&lt;/a&gt; ] Slein, J., Vitali, F., Whitehead, E. 및 D. Durand, &quot;World Wide Web의 분산 작성 및 버전 관리 프로토콜 요구 사항&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2291&quot;&gt;RFC 2291&lt;/a&gt; , 1998 년 2 월. [ &lt;a id=&quot;ref-RFC2518&quot; name=&quot;ref-RFC2518&quot;&gt;RFC2518&lt;/a&gt; ] Goland, Y., Whitehead, E., Faizi, A., Carter, S. 및 D. Jensen, &quot;분산 저작을위한 HTTP 확장 &lt;a id=&quot;ref-RFC2781&quot; name=&quot;ref-RFC2781&quot;&gt;-WEBDAV&lt;/a&gt; &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2518&quot;&gt;RFC 2518&lt;/a&gt; , 1999 년 2 월. [ RFC2781 ] Hoffman, P. 및 F. Yergeau, &quot;UTF-16, ISO 10646 인코딩&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc2781&quot;&gt;RFC 2781&lt;/a&gt; , 2000 년 2 월. [ &lt;a id=&quot;ref-RFC3023&quot; name=&quot;ref-RFC3023&quot;&gt;RFC3023&lt;/a&gt;] Murata, M., St. Laurent, S. 및 D. Kohn, &quot;XML 미디어 유형&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3023&quot;&gt;RFC 3023&lt;/a&gt; , 2001 년 1 월. [ &lt;a id=&quot;ref-RFC3253&quot; name=&quot;ref-RFC3253&quot;&gt;RFC3253&lt;/a&gt; ] Clemm, G., Amsden, J., Ellison, T., Kaler, C. 및 J. Whitehead, &quot;WebDAV (Web Distributed Authoring and Versioning)의 버전 확장 기능&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3253&quot;&gt;RFC 3253&lt;/a&gt; , 2002 년 3 월. [ &lt;a id=&quot;ref-RFC3648&quot; name=&quot;ref-RFC3648&quot;&gt;RFC3648&lt;/a&gt; ] Whitehead, J. 및 J. Reschke, Ed., &quot;Web Distributed Authoring and Versioning ( WebDAV) Ordered Collections Protocol &quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3648&quot;&gt;RFC 3648&lt;/a&gt; , 2003 년 12 월. [ &lt;a id=&quot;ref-RFC3744&quot; name=&quot;ref-RFC3744&quot;&gt;RFC3744&lt;/a&gt;] Clemm, G., Reschke, J., Sedlar, E. 및 J. Whitehead, &quot;WebDAV (Web Distributed Authoring and Versioning) 액세스 제어 프로토콜&quot;, &lt;a href=&quot;https://tools.ietf.org/html/rfc3744&quot;&gt;RFC 3744&lt;/a&gt; , 2004 년 5 월. [ &lt;a id=&quot;ref-RFC3864&quot; name=&quot;ref-RFC3864&quot;&gt;RFC3864&lt;/a&gt; ] Klyne, G., Nottingham , M. 및 J. Mogul, &quot;메시지 헤더 필드의 등록 절차&quot;, &lt;a href=&quot;https://tools.ietf.org/html/bcp90&quot;&gt;BCP 90&lt;/a&gt; , &lt;a href=&quot;https://tools.ietf.org/html/rfc3864&quot;&gt;RFC 3864&lt;/a&gt; , 2004 년 9 월.</target>
        </trans-unit>
        <trans-unit id="b1bbb46067e1d10a9641c51fe274392e19f19b71" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../status/400&quot;&gt;400 Bad Request&lt;/a&gt;&lt;/code&gt; error, and include another &lt;code&gt;Want-Digest&lt;/code&gt; header with that response, listing the algorithms that it does support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6572f6bdad9d0df526aa9918bcc18d67193d7284" translate="yes" xml:space="preserve">
          <source>a DNS hostname, or IP address. If a hostname is passed, it will be resolved into an IP address by this function.</source>
          <target state="translated">DNS 호스트 이름 또는 IP 주소 호스트 이름이 전달되면이 기능에 의해 IP 주소로 확인됩니다.</target>
        </trans-unit>
        <trans-unit id="58f4f8c8f292448281e891a036f132c7b6a31fb5" translate="yes" xml:space="preserve">
          <source>a digest calculated using a different digest algorithm, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48b988db0ee3a42e7679e7b91940653ba256252b" translate="yes" xml:space="preserve">
          <source>all other domains</source>
          <target state="translated">다른 모든 도메인</target>
        </trans-unit>
        <trans-unit id="22e784a22acfd6fde3c7f0d8be9a48223288b9a2" translate="yes" xml:space="preserve">
          <source>allowlist</source>
          <target state="translated">allowlist</target>
        </trans-unit>
        <trans-unit id="68346a9baa8533152e1b7183f99e607aa69f9b2d" translate="yes" xml:space="preserve">
          <source>an IP address (v4 or v6, optionally with a port, and ipv6 quoted and enclosed in square brackets),</source>
          <target state="translated">IP 주소 (v4 또는 v6, 선택적으로 포트가 있고 ipv6는 따옴표로 묶고 대괄호로 묶음)</target>
        </trans-unit>
        <trans-unit id="5b6e0dfcb0f27620edc54f98b71e760a5ef9f363" translate="yes" xml:space="preserve">
          <source>an IP address pattern in the dot-separated format.</source>
          <target state="translated">도트로 분리 된 형식의 IP 주소 패턴</target>
        </trans-unit>
        <trans-unit id="57c7b5a27584ee2ff2773d5b245085b264d57843" translate="yes" xml:space="preserve">
          <source>an obfuscated identifier (such as &quot;_hidden&quot; or &quot;_secret&quot;),</source>
          <target state="translated">난독 화 된 식별자 (예 : &quot;_hidden&quot;또는 &quot;_secret&quot;)</target>
        </trans-unit>
        <trans-unit id="4e16b4d174e42a23736982e9f2c23c397c8b3108" translate="yes" xml:space="preserve">
          <source>an opaque string, uniquely identifying each version, called the &lt;em&gt;entity tag&lt;/em&gt;, or the &lt;em&gt;etag&lt;/em&gt;.</source>
          <target state="translated">고유 각 버전을 식별하는 불투명 한 문자열은 호출 된 &lt;em&gt;엔터티 태그&lt;/em&gt; 또는 &lt;em&gt;ETAG을&lt;/em&gt; .</target>
        </trans-unit>
        <trans-unit id="4d46355f32d92f6c77aef67e98124f7e7eef5210" translate="yes" xml:space="preserve">
          <source>an unsecured HTTP request is used and the referring page was received with a secure protocol (HTTPS).</source>
          <target state="translated">보안되지 않은 HTTP 요청이 사용되고 참조 페이지가 보안 프로토콜 (HTTPS)로 수신되었습니다.</target>
        </trans-unit>
        <trans-unit id="048b485a736a2a004fe2d8dad94dc466152be3c9" translate="yes" xml:space="preserve">
          <source>and apply the protection anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51793deecf3874c1379bd483b7f6e8a8697ba77" translate="yes" xml:space="preserve">
          <source>and finally compression can be defined at the connection level, between two nodes of an HTTP connection.</source>
          <target state="translated">마지막으로 압축은 HTTP 연결의 두 노드 사이의 연결 수준에서 정의 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="21ebe7d97514bbc039dd86f94ac3b48072ba7ec0" translate="yes" xml:space="preserve">
          <source>any comma-separated list of HTTP headers [Usually &lt;code&gt;keep-alive&lt;/code&gt; only]</source>
          <target state="translated">쉼표로 구분 된 HTTP 헤더 목록 [일반적으로 연결 &lt;code&gt;keep-alive&lt;/code&gt; 만]</target>
        </trans-unit>
        <trans-unit id="7659b5bbc9203bb31f112f8efe478fb4a6dffc5b" translate="yes" xml:space="preserve">
          <source>any comma-separated list protocol names (each with optional protocol version)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1567ff89b862169db893152a7611218a8a4089" translate="yes" xml:space="preserve">
          <source>any domain or path</source>
          <target state="translated">모든 도메인 또는 경로</target>
        </trans-unit>
        <trans-unit id="10b12d00a7d3c421266b22114a2233f8f8621481" translate="yes" xml:space="preserve">
          <source>application/octet-stream</source>
          <target state="translated">application/octet-stream</target>
        </trans-unit>
        <trans-unit id="69f62b376116281af7e0a09a35dafd577e34f4d2" translate="yes" xml:space="preserve">
          <source>application/vnd.mozilla.xul+xml</source>
          <target state="translated">application/vnd.mozilla.xul+xml</target>
        </trans-unit>
        <trans-unit id="237541aefdcd5b729ae836344478d37315abf73f" translate="yes" xml:space="preserve">
          <source>as well as styles loaded using the &lt;a href=&quot;../link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">&lt;a href=&quot;../link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여로드 된 스타일 :</target>
        </trans-unit>
        <trans-unit id="4bff8fa686f39f07445a2245133d217187258035" translate="yes" xml:space="preserve">
          <source>as well as styles loaded using the &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link&quot;&gt;&lt;code&gt;Link&lt;/code&gt;&lt;/a&gt; header:</source>
          <target state="translated">&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Link&quot;&gt; &lt;code&gt;Link&lt;/code&gt; &lt;/a&gt; 헤더를 사용하여로드 된 스타일 과</target>
        </trans-unit>
        <trans-unit id="fba31ebe5b81e900968e1a2412e72f955f8c8d98" translate="yes" xml:space="preserve">
          <source>authentication (to control access to different resources)</source>
          <target state="translated">인증 (다른 자원에 대한 액세스 제어)</target>
        </trans-unit>
        <trans-unit id="b3c23371b391c5c9a5070c1553a367da511602e0" translate="yes" xml:space="preserve">
          <source>authentication headers (e.g., &lt;a href=&quot;authorization&quot;&gt;&lt;code&gt;Authorization&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;set-cookie&quot;&gt;&lt;code&gt;Set-Cookie&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">인증 헤더 (예 : &lt;a href=&quot;authorization&quot;&gt; &lt;code&gt;Authorization&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;set-cookie&quot;&gt; &lt;code&gt;Set-Cookie&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="a8d227a59c970b0e117bb96f0c53db926fe7e2e8" translate="yes" xml:space="preserve">
          <source>base-uri</source>
          <target state="translated">base-uri</target>
        </trans-unit>
        <trans-unit id="ee7f2acefe0b4b10bcc7d341ee436d1050bbc552" translate="yes" xml:space="preserve">
          <source>base64-encoded version of the above</source>
          <target state="translated">위의 base64 인코딩 버전</target>
        </trans-unit>
        <trans-unit id="ca53353f340229b4d6998a703a022cd1a46f2df7" translate="yes" xml:space="preserve">
          <source>block-all-mixed-content</source>
          <target state="translated">block-all-mixed-content</target>
        </trans-unit>
        <trans-unit id="2db8c22f75474a58cd13fa2d3425017015d392ce" translate="yes" xml:space="preserve">
          <source>boundary</source>
          <target state="translated">boundary</target>
        </trans-unit>
        <trans-unit id="1ffcf1d140fe7ea73a2ca4646ab42ba7ff8d6b38" translate="yes" xml:space="preserve">
          <source>by=&amp;lt;identifier&amp;gt;</source>
          <target state="translated">by=&amp;lt;identifier&amp;gt;</target>
        </trans-unit>
        <trans-unit id="5dc29c0a9fefc5d9085157ab99c1395a78cbea28" translate="yes" xml:space="preserve">
          <source>caching (the cache can be public or private, like the browser cache)</source>
          <target state="translated">캐싱 (브라우저는 브라우저 캐시처럼 공개 또는 개인 캐시 일 수 있음)</target>
        </trans-unit>
        <trans-unit id="16d8d6392988323b4370d2c819891302accb8e78" translate="yes" xml:space="preserve">
          <source>can be allowed for the base-uri policy:</source>
          <target state="translated">기본 URI 정책에 허용 될 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="1ef5578db8253e578f4a1ad2a317c4cb55a6cccf" translate="yes" xml:space="preserve">
          <source>change the request such that it is a &lt;a href=&quot;#Simple_requests&quot;&gt;simple request&lt;/a&gt; that doesn&amp;rsquo;t cause a preflight</source>
          <target state="translated">프리 플라이트를 발생시키지 않는 &lt;a href=&quot;#Simple_requests&quot;&gt;간단한 요청이&lt;/a&gt; 되도록 요청 을 변경하십시오.</target>
        </trans-unit>
        <trans-unit id="e82b4f907665849edc640a3a5ed3f96746a22ae2" translate="yes" xml:space="preserve">
          <source>change the server-side behavior to avoid the preflight and/or to avoid the redirect&amp;mdash;if you have control over the server the request is being made to</source>
          <target state="translated">프리 플라이트 및 / 또는 경로 재 지정을 피하기 위해 서버 측 동작 변경 (서버에 대한 제어 권한이있는 경우)</target>
        </trans-unit>
        <trans-unit id="dcb16d9aacb079fe42fbde349c3319de8033ddd1" translate="yes" xml:space="preserve">
          <source>charset</source>
          <target state="translated">charset</target>
        </trans-unit>
        <trans-unit id="542878754cbbf01f4429e5bc9fad7e8ebe07d51e" translate="yes" xml:space="preserve">
          <source>charset=&amp;lt;charset&amp;gt;</source>
          <target state="translated">charset=&amp;lt;charset&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7624bec80c979807575ec0892f7c6ef4c15f3111" translate="yes" xml:space="preserve">
          <source>child-src</source>
          <target state="translated">child-src</target>
        </trans-unit>
        <trans-unit id="92425df92f162ed857653d72abf9032f6f8e9a9c" translate="yes" xml:space="preserve">
          <source>connect-src</source>
          <target state="translated">connect-src</target>
        </trans-unit>
        <trans-unit id="d59c684e865aae3fcb98cb7011c041b7d231fe6b" translate="yes" xml:space="preserve">
          <source>convert_addr()</source>
          <target state="translated">convert_addr()</target>
        </trans-unit>
        <trans-unit id="5768e3368e999ef57640802fad1337ee30d92014" translate="yes" xml:space="preserve">
          <source>cross-origin</source>
          <target state="translated">cross-origin</target>
        </trans-unit>
        <trans-unit id="a17c9aaa61e80a1bf71d0d850af4e5baa9800bbd" translate="yes" xml:space="preserve">
          <source>data</source>
          <target state="translated">data</target>
        </trans-unit>
        <trans-unit id="7b1dafbb0ae29e20baea414f4e68f00b46dc7817" translate="yes" xml:space="preserve">
          <source>data URL scheme</source>
          <target state="translated">데이터 URL 체계</target>
        </trans-unit>
        <trans-unit id="26dd63ae4093a12d5fe3831767a9965a0355f13a" translate="yes" xml:space="preserve">
          <source>dateRange()</source>
          <target state="translated">dateRange()</target>
        </trans-unit>
        <trans-unit id="a2620cbc10f5198dd03e3f5a1569eb5dcf9a6a87" translate="yes" xml:space="preserve">
          <source>day</source>
          <target state="translated">day</target>
        </trans-unit>
        <trans-unit id="b1d2728d4d92be98cbe896a012245baeb3b5eba5" translate="yes" xml:space="preserve">
          <source>default-src</source>
          <target state="translated">default-src</target>
        </trans-unit>
        <trans-unit id="086b515d51ae4e83ef03faf2897557b0b2354560" translate="yes" xml:space="preserve">
          <source>dnsDomainIs()</source>
          <target state="translated">dnsDomainIs()</target>
        </trans-unit>
        <trans-unit id="d991b834071c9fd3f1c23defce92bbd9aff7f292" translate="yes" xml:space="preserve">
          <source>dnsDomainLevels()</source>
          <target state="translated">dnsDomainLevels()</target>
        </trans-unit>
        <trans-unit id="2b1bb3ec04c8f96d11d4fe26e461b302f090b32c" translate="yes" xml:space="preserve">
          <source>dnsResolve()</source>
          <target state="translated">dnsResolve()</target>
        </trans-unit>
        <trans-unit id="7b93f412c5cc61a7c2e57c97d5cfb718feaca8ba" translate="yes" xml:space="preserve">
          <source>document-domain</source>
          <target state="translated">document-domain</target>
        </trans-unit>
        <trans-unit id="9120580e94f134cb7c9f27cd1e43dbc82980e152" translate="yes" xml:space="preserve">
          <source>domain</source>
          <target state="translated">domain</target>
        </trans-unit>
        <trans-unit id="f1a6172df5508823225ab8bb7fe65a2481016827" translate="yes" xml:space="preserve">
          <source>donottrack.us</source>
          <target state="translated">donottrack.us</target>
        </trans-unit>
        <trans-unit id="918c205bd2f55e0a5d64e48ce57622e27f85110d" translate="yes" xml:space="preserve">
          <source>draft-grigorik-http-client-hints-03, section 7: Save-Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eed110f022d72a537efe8508aeeed2748af4604" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-digest-headers-latest</source>
          <target state="translated">draft-ietf-httpbis-digest-headers-latest</target>
        </trans-unit>
        <trans-unit id="40472cae6e0922cdfa8a50845b56a80a1aecab0d" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-rfc6265bis-02</source>
          <target state="translated">draft-ietf-httpbis-rfc6265bis-02</target>
        </trans-unit>
        <trans-unit id="696609a189535007707b4c972a02ca3abcc6c153" translate="yes" xml:space="preserve">
          <source>draft-ietf-httpbis-rfc6265bis-05</source>
          <target state="translated">draft-ietf-httpbis-rfc6265bis-05</target>
        </trans-unit>
        <trans-unit id="10ced556502ccd9ea6cab04a4c6c560574f5619b" translate="yes" xml:space="preserve">
          <source>effective-directive</source>
          <target state="translated">effective-directive</target>
        </trans-unit>
        <trans-unit id="8ed7f834df2e6a2e9619cf288468a7001e5e45c1" translate="yes" xml:space="preserve">
          <source>enforce Optional</source>
          <target state="translated">선택적 시행</target>
        </trans-unit>
        <trans-unit id="b31f855af6c8572289bed2ad00ab543a3568f4fa" translate="yes" xml:space="preserve">
          <source>failure_fraction</source>
          <target state="translated">failure_fraction</target>
        </trans-unit>
        <trans-unit id="971c419dd609331343dee105fffd0f4608dc0bf2" translate="yes" xml:space="preserve">
          <source>file</source>
          <target state="translated">file</target>
        </trans-unit>
        <trans-unit id="bab8f5421577f88a13806c827f40340044f3f46f" translate="yes" xml:space="preserve">
          <source>filename*</source>
          <target state="translated">filename*</target>
        </trans-unit>
        <trans-unit id="f35c166cd0c65005849ff35d7c0cde54422c0eec" translate="yes" xml:space="preserve">
          <source>filtering (like an antivirus scan or parental controls)</source>
          <target state="translated">필터링 (예 : 바이러스 백신 검사 또는 자녀 보호)</target>
        </trans-unit>
        <trans-unit id="9d66faaa0ea10fa0468840dffa09e321853ecb14" translate="yes" xml:space="preserve">
          <source>filtering (like an antivirus scan, parental controls, &amp;hellip;)</source>
          <target state="translated">필터링 (바이러스 백신 검사, 보호자 통제 등)</target>
        </trans-unit>
        <trans-unit id="77ed03a5bd46ed473f79db47d3471ca6396e13b9" translate="yes" xml:space="preserve">
          <source>first some file formats are compressed with specific optimized methods,</source>
          <target state="translated">먼저 일부 파일 형식은 특정 최적화 된 방법으로 압축됩니다.</target>
        </trans-unit>
        <trans-unit id="9b3734e0d856c513f33ee96559374347af0ab6d5" translate="yes" xml:space="preserve">
          <source>font-src</source>
          <target state="translated">font-src</target>
        </trans-unit>
        <trans-unit id="bb84ce39411e03bf6e940d04850c70c9cf4c5af8" translate="yes" xml:space="preserve">
          <source>for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;safe&lt;/a&gt; methods, like &lt;a href=&quot;methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt;, which usually tries to fetch a document, the conditional request can be used to send back the document, if relevant only. Therefore, this spares bandwidth.</source>
          <target state="translated">에 대한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 과 같은 방법 &lt;a href=&quot;methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 일반적으로 문서를 가져 오기 위해 시도, 조건부 요청에만 해당하는 경우, 문서를 다시 전송하는 데 사용할 수 있습니다. 따라서 대역폭이 절약됩니다.</target>
        </trans-unit>
        <trans-unit id="107d7bfa1273d29412288a73d8e3da9310bf0cc4" translate="yes" xml:space="preserve">
          <source>for &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;unsafe&lt;/a&gt; methods, like &lt;a href=&quot;methods/put&quot;&gt;&lt;code&gt;PUT&lt;/code&gt;&lt;/a&gt;, which usually uploads a document, the conditional request can be used to upload the document, only if the original it is based on is the same as that stored on the server.</source>
          <target state="translated">위한 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/safe&quot;&gt;안전&lt;/a&gt; 같은 방법 &lt;a href=&quot;methods/put&quot;&gt; &lt;code&gt;PUT&lt;/code&gt; &lt;/a&gt; 보통 문서를 업로드, 조건부 요청은 그것이 기초하고있는 원본 서버에 저장된 것과 동일한 경우, 문서를 업로드하는데 사용될 수있다.</target>
        </trans-unit>
        <trans-unit id="39c530df8a00ccde8bbcb7f14958e0a8b1db8387" translate="yes" xml:space="preserve">
          <source>for=&amp;lt;identifier&amp;gt;</source>
          <target state="translated">for=&amp;lt;identifier&amp;gt;</target>
        </trans-unit>
        <trans-unit id="462d902515185bbf061ed6e7ad4435aad289c286" translate="yes" xml:space="preserve">
          <source>forceEnable&quot; boolean preferece in about:config.</source>
          <target state="translated">about : config에서 forceEnable &quot;boolean preferece를 사용하십시오.</target>
        </trans-unit>
        <trans-unit id="f58edcd721fab51d42650b7e6dd010b57980c7f4" translate="yes" xml:space="preserve">
          <source>form-action</source>
          <target state="translated">form-action</target>
        </trans-unit>
        <trans-unit id="ad1ceea2126038a2417f75852c0eaec4fbbe1b44" translate="yes" xml:space="preserve">
          <source>frame-ancestors</source>
          <target state="translated">frame-ancestors</target>
        </trans-unit>
        <trans-unit id="958a17ea17afdc7c73cc1fc1522e81267bf9656e" translate="yes" xml:space="preserve">
          <source>frame-src</source>
          <target state="translated">frame-src</target>
        </trans-unit>
        <trans-unit id="84e21b7649de2b838a3b5ec55c4b65501cf35eed" translate="yes" xml:space="preserve">
          <source>from Firefox 10 on mobile, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; is the same as &lt;code&gt;&lt;var&gt;firefoxversion&lt;/var&gt;&lt;/code&gt;.</source>
          <target state="translated">모바일 (10)로부터 파이어 폭스, &lt;code&gt;&lt;var&gt;geckotrail&lt;/var&gt;&lt;/code&gt; 는 동일하다 &lt;code&gt;&lt;var&gt;firefoxversion&lt;/var&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7616bb87bd05f6439e3672ba1b2be55d5beb68b3" translate="yes" xml:space="preserve">
          <source>ftp</source>
          <target state="translated">ftp</target>
        </trans-unit>
        <trans-unit id="85010ad5a585210fce12990c2b28950f6c06e830" translate="yes" xml:space="preserve">
          <source>fully contained in the response message body</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f6d1f05bf03ff30afa6123e0bee2caa2da7cff0" translate="yes" xml:space="preserve">
          <source>gmt</source>
          <target state="translated">gmt</target>
        </trans-unit>
        <trans-unit id="86dd1cf45142e904cb2e99c2721fac3ca198c6ca" translate="yes" xml:space="preserve">
          <source>host</source>
          <target state="translated">host</target>
        </trans-unit>
        <trans-unit id="5f9c88b1b1fe6f524893937345305084a9e1041d" translate="yes" xml:space="preserve">
          <source>host=&amp;lt;host&amp;gt;</source>
          <target state="translated">host=&amp;lt;host&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f980c193395f072f33f35ad30af29c86b869a5aa" translate="yes" xml:space="preserve">
          <source>hostdom</source>
          <target state="translated">hostdom</target>
        </trans-unit>
        <trans-unit id="13dda6d8bc46f099d3816621f1bb02058b8d6263" translate="yes" xml:space="preserve">
          <source>hostname to resolve.</source>
          <target state="translated">확인할 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="813070b0844d4518de154f433d86fb302949e0a5" translate="yes" xml:space="preserve">
          <source>hot stand-by</source>
          <target state="translated">핫 스탠바이</target>
        </trans-unit>
        <trans-unit id="52ab86a87214a453d9f82538264f190854915247" translate="yes" xml:space="preserve">
          <source>hour</source>
          <target state="translated">hour</target>
        </trans-unit>
        <trans-unit id="2c763e6b7d79d93a2a3f3058f224485412fd92cb" translate="yes" xml:space="preserve">
          <source>http/https</source>
          <target state="translated">http/https</target>
        </trans-unit>
        <trans-unit id="cdbe72fa2d6000f2454e1c431b4cd76a6fb92ce1" translate="yes" xml:space="preserve">
          <source>iCalendar format</source>
          <target state="translated">iCalendar 형식</target>
        </trans-unit>
        <trans-unit id="285ee276a061f3e61631c19895f00dd8d96a145d" translate="yes" xml:space="preserve">
          <source>iOS Safari</source>
          <target state="translated">iOS 사파리</target>
        </trans-unit>
        <trans-unit id="849bb725b8563d0596db868195344c611a893724" translate="yes" xml:space="preserve">
          <source>iPad</source>
          <target state="translated">iPad</target>
        </trans-unit>
        <trans-unit id="97f2142cbb711918707b621ea05cbd1662b714ab" translate="yes" xml:space="preserve">
          <source>iPhone</source>
          <target state="translated">iPhone</target>
        </trans-unit>
        <trans-unit id="31e978dda11713a96454c3a1a463212be069c7d2" translate="yes" xml:space="preserve">
          <source>iPod</source>
          <target state="translated">iPod</target>
        </trans-unit>
        <trans-unit id="b6a64338df2eb5baeb40c41185176db2cb96a5ea" translate="yes" xml:space="preserve">
          <source>identifies the protocol (HTTP or HTTPS) that a client used to connect to your proxy or load balancer.</source>
          <target state="translated">클라이언트가 프록시 또는로드 밸런서에 연결하는 데 사용한 프로토콜 (HTTP 또는 HTTPS)을 식별합니다.</target>
        </trans-unit>
        <trans-unit id="20cf626f392079bf9c59553682f4711426d9607e" translate="yes" xml:space="preserve">
          <source>iframe attributes can selectively enable features in certain frames, and not in others, even if those frames contain documents from the same origin.</source>
          <target state="translated">iframe 속성은 특정 프레임에서 동일한 출처의 문서를 포함하더라도 특정 프레임에서 기능을 선택적으로 활성화 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8ae465c269b02e088bfef75f7203c824c084624e" translate="yes" xml:space="preserve">
          <source>img-src</source>
          <target state="translated">img-src</target>
        </trans-unit>
        <trans-unit id="e1d2546ce619c722ab97d4932fca9372ce841bb5" translate="yes" xml:space="preserve">
          <source>include_subdomains</source>
          <target state="translated">include_subdomains</target>
        </trans-unit>
        <trans-unit id="137adf5541157c6a883d8b1755b3d0a08e52db57" translate="yes" xml:space="preserve">
          <source>indicates the size of the entity-body, in decimal number of octets, sent to the recipient.</source>
          <target state="translated">수신자에게 전송 된 엔티티 본문의 크기를 10 진수 10 진수로 표시합니다.</target>
        </trans-unit>
        <trans-unit id="4659c378675fe9020c682803cee1ebb988347f95" translate="yes" xml:space="preserve">
          <source>ipaddr</source>
          <target state="translated">ipaddr</target>
        </trans-unit>
        <trans-unit id="3a8dc0b686296fa059f02e66967fc351233d71ba" translate="yes" xml:space="preserve">
          <source>is a shell expression to compare against.</source>
          <target state="translated">비교할 쉘 표현식입니다.</target>
        </trans-unit>
        <trans-unit id="711f0a4bb1c1c9f8a02a7c34c906fd912a25d9d4" translate="yes" xml:space="preserve">
          <source>is any string to compare (e.g. the URL, or the hostname).</source>
          <target state="translated">비교할 문자열입니다 (예 : URL 또는 호스트 이름).</target>
        </trans-unit>
        <trans-unit id="35bb75f385320807a1b2ab6899c56afe7b2b3abc" translate="yes" xml:space="preserve">
          <source>is the hostname from the URL.</source>
          <target state="translated">URL의 호스트 이름입니다.</target>
        </trans-unit>
        <trans-unit id="6628b382993974f4a5cbca2c9b1c1c013ebe9b61" translate="yes" xml:space="preserve">
          <source>is the same as:</source>
          <target state="translated">와 같다:</target>
        </trans-unit>
        <trans-unit id="8b6de35d4682e9a8b14fba6347dcda04a75b0292" translate="yes" xml:space="preserve">
          <source>isInNet()</source>
          <target state="translated">isInNet()</target>
        </trans-unit>
        <trans-unit id="ee9fbe440c9f9cb0fddd58b1a68cf267199af430" translate="yes" xml:space="preserve">
          <source>isPlainHostName()</source>
          <target state="translated">isPlainHostName()</target>
        </trans-unit>
        <trans-unit id="9fa99c6eb1219edba6fb50a9c8f60e235c2a1b47" translate="yes" xml:space="preserve">
          <source>isResolvable()</source>
          <target state="translated">isResolvable()</target>
        </trans-unit>
        <trans-unit id="b6e13ad53d8ec41b034c49f131c64e99cf25207a" translate="yes" xml:space="preserve">
          <source>javascript</source>
          <target state="translated">javascript</target>
        </trans-unit>
        <trans-unit id="7dc0a5e593f649f492088fe836b1065b44a4d240" translate="yes" xml:space="preserve">
          <source>load balancing (to allow multiple servers to serve the different requests)</source>
          <target state="translated">부하 분산 (여러 서버가 다른 요청을 처리 할 수 ​​있도록)</target>
        </trans-unit>
        <trans-unit id="bf90de10d16d33f1ebf146ed81ce2d44a651f670" translate="yes" xml:space="preserve">
          <source>localHostOrDomainIs()</source>
          <target state="translated">localHostOrDomainIs()</target>
        </trans-unit>
        <trans-unit id="f6a2e9d539c4d8c290c040adbe4d56f58a242d54" translate="yes" xml:space="preserve">
          <source>localStorage (executes &lt;code&gt;localStorage.clear&lt;/code&gt;),</source>
          <target state="translated">로컬 스토리지 (실행한다 &lt;code&gt;localStorage.clear&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="07b91ff33236baae20bbe53abf2a67f00e3c50fb" translate="yes" xml:space="preserve">
          <source>logging (allowing the storage of historical information)</source>
          <target state="translated">로깅 (이력 정보 저장 허용)</target>
        </trans-unit>
        <trans-unit id="fe710cd089cb0ba74f588270fe079a392b5e9810" translate="yes" xml:space="preserve">
          <source>mailto</source>
          <target state="translated">mailto</target>
        </trans-unit>
        <trans-unit id="b6b13a0ea86ed568a571ab17aeb46d6c1e820468" translate="yes" xml:space="preserve">
          <source>manifest-src</source>
          <target state="translated">manifest-src</target>
        </trans-unit>
        <trans-unit id="9d4cca1595c30e43d23f14aedf815846f837956a" translate="yes" xml:space="preserve">
          <source>mask</source>
          <target state="translated">mask</target>
        </trans-unit>
        <trans-unit id="10d3ad09751e1c3d8c873feea6420bc613cceed5" translate="yes" xml:space="preserve">
          <source>mask for the IP address pattern informing which parts of the IP address should be matched against. 0 means ignore, 255 means match.</source>
          <target state="translated">IP 주소의 어느 부분이 일치해야하는지 알려주는 IP 주소 패턴 마스크. 0은 무시, 255는 일치를 의미합니다.</target>
        </trans-unit>
        <trans-unit id="28e1c849b6dc898fca0424e31a6995a480cd4f2d" translate="yes" xml:space="preserve">
          <source>max-age</source>
          <target state="translated">max-age</target>
        </trans-unit>
        <trans-unit id="9ac6a36fa13e10d8a3e0e393b6ca9fd66644c093" translate="yes" xml:space="preserve">
          <source>max-age=&amp;lt;expire-time&amp;gt;</source>
          <target state="translated">max-age=&amp;lt;expire-time&amp;gt;</target>
        </trans-unit>
        <trans-unit id="71e3deab4d02be0bf60343f38c420a1c89ec04fc" translate="yes" xml:space="preserve">
          <source>max_age</source>
          <target state="translated">max_age</target>
        </trans-unit>
        <trans-unit id="a29bfccdab1c88eed654fe261827d16fb5b5a4b6" translate="yes" xml:space="preserve">
          <source>media-src</source>
          <target state="translated">media-src</target>
        </trans-unit>
        <trans-unit id="483fccd23acd857fcb20f316a053e85dbb71d17d" translate="yes" xml:space="preserve">
          <source>message framing headers (e.g., &lt;a href=&quot;transfer-encoding&quot;&gt;&lt;code&gt;Transfer-Encoding&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;content-length&quot;&gt;&lt;code&gt;Content-Length&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">메시지 프레이밍 헤더 (예 : &lt;a href=&quot;transfer-encoding&quot;&gt; &lt;code&gt;Transfer-Encoding&lt;/code&gt; &lt;/a&gt; 및 &lt;a href=&quot;content-length&quot;&gt; &lt;code&gt;Content-Length&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b6c935d4f3c7b220fa038613a1f9c1b56b255a86" translate="yes" xml:space="preserve">
          <source>min</source>
          <target state="translated">min</target>
        </trans-unit>
        <trans-unit id="021710fa7866431c1dacaa6cd31eeeb47dce64b6" translate="yes" xml:space="preserve">
          <source>month</source>
          <target state="translated">month</target>
        </trans-unit>
        <trans-unit id="7bf875f389edb2f955a35fd6a689ecbee26de3a2" translate="yes" xml:space="preserve">
          <source>multipart/byteranges</source>
          <target state="translated">multipart/byteranges</target>
        </trans-unit>
        <trans-unit id="12a22dd81cc700d0a382226b74ce386ec575a16a" translate="yes" xml:space="preserve">
          <source>multipart/form-data</source>
          <target state="translated">multipart/form-data</target>
        </trans-unit>
        <trans-unit id="98cb9df8eaa28e53ece0f85d650859e51d70ed53" translate="yes" xml:space="preserve">
          <source>myIpAddress()</source>
          <target state="translated">myIpAddress()</target>
        </trans-unit>
        <trans-unit id="48b9986d88eb74e0d3a4acb3cdad7ac0e26c3cc7" translate="yes" xml:space="preserve">
          <source>myIpAddress() returns the same IP address as the server address returned by &lt;code&gt;nslookup localhost&lt;/code&gt;on a Linux machine. It does not return the public IP address.</source>
          <target state="translated">myIpAddress ()는 Linux 시스템에서 &lt;code&gt;nslookup localhost&lt;/code&gt; 가 리턴 한 서버 주소와 동일한 IP 주소를 리턴 합니다. 퍼블릭 IP 주소는 반환하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="64bdcd6a063ffe53f20c5fc8a2a977b0e42bfbde" translate="yes" xml:space="preserve">
          <source>namespace app = &quot;&lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&lt;/a&gt;&quot;

    pubControl =
       element app:control {
       atomCommonAttributes,
       pubDraft?
       &amp;amp; extensionElement
    }

    pubDraft =
      element app:draft { &quot;yes&quot; | &quot;no&quot; } 

   The &quot;app:control&quot; element MAY appear as a child of an atom:entry that
   is being created or updated via the Atom Publishing Protocol.  The
   app:control element MUST appear only once in an Entry.  The app:
   control element is considered foreign markup as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6
   of [RFC4287]&lt;/a&gt;.

   The app:control element and its child elements MAY be included in
   Atom Feed or Entry Documents.

   The app:control element can contain an &quot;app:draft&quot; element as defined
   below, and it can contain extension elements as defined in &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;Section&amp;nbsp;6
   of [RFC4287]&lt;/a&gt;.</source>
          <target state="translated">네임 스페이스 앱 = &quot; &lt;a href=&quot;http://www.w3.org/2007/app&quot;&gt;http://www.w3.org/2007/app&quot;pubControl&lt;/a&gt; = 요소 app : control {atomCommonAttributes, pubDraft? &amp;amp; extensionElement} pubDraft = 요소 앱 : draft { &quot;yes&quot;| &quot;no&quot;} &quot;app : control&quot;요소는 Atom Publishing Protocol을 통해 작성 또는 업데이트되는 atom : entry의 자식으로 나타날 수 있습니다. app : control 요소는 Entry에 한 번만 나타나야합니다. app : 제어 요소는 &lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6에&lt;/a&gt; 정의 된 외부 마크 업으로 간주됩니다 . app : control 요소 및 해당 자식 요소는 Atom Feed 또는 Entry Documents에 포함될 수 있습니다. app : control 요소는 아래 정의 된 &quot;app : draft&quot;요소를 포함 할 수 있습니다.에 정의 된 확장 요소를 포함 할 수 있습니다&lt;a href=&quot;https://tools.ietf.org/html/rfc4287#section-6&quot;&gt;[RFC4287]의 섹션 6&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fd1286353570c5703799ba76999323b7c7447b06" translate="yes" xml:space="preserve">
          <source>no</source>
          <target state="translated">no</target>
        </trans-unit>
        <trans-unit id="c93bee6c522b9224a267a0391c4dd9d6634f5e43" translate="yes" xml:space="preserve">
          <source>no referrer</source>
          <target state="translated">추천자 없음</target>
        </trans-unit>
        <trans-unit id="73182f77ad56a5ab7236d9553832d35ecf5bbcdd" translate="yes" xml:space="preserve">
          <source>no-cache</source>
          <target state="translated">no-cache</target>
        </trans-unit>
        <trans-unit id="4f70f2f74568eb871171ef25b64e2369fbd0b561" translate="yes" xml:space="preserve">
          <source>no-referrer</source>
          <target state="translated">no-referrer</target>
        </trans-unit>
        <trans-unit id="70ef900efd9d989c7461278efc15fc8b7dd95d38" translate="yes" xml:space="preserve">
          <source>no-referrer-when-downgrade (default)</source>
          <target state="translated">추천하지 않은 경우 다운 그레이드시 (기본값)</target>
        </trans-unit>
        <trans-unit id="9fe350a67b2e91ed9cf66de96117752e35a2720e" translate="yes" xml:space="preserve">
          <source>no-store
      The purpose of the no-store directive is to prevent the
      inadvertent release or retention of sensitive information (for
      example, on backup tapes). The no-store directive applies to the
      entire message, and MAY be sent either in a response or in a
      request. If sent in a request, a cache MUST NOT store any part of
      either this request or any response to it. If sent in a response,
      a cache MUST NOT store any part of either this response or the
      request that elicited it. This directive applies to both non-
      shared and shared caches. &quot;MUST NOT store&quot; in this context means
      that the cache MUST NOT intentionally store the information in
      non-volatile storage, and MUST make a best-effort attempt to
      remove the information from volatile storage as promptly as
      possible after forwarding it.

      Even when this directive is associated with a response, users
      might explicitly store such a response outside of the caching
      system (e.g., with a &quot;Save As&quot; dialog). History buffers MAY store
      such responses as part of their normal operation. 

      The purpose of this directive is to meet the stated requirements
      of certain users and service authors who are concerned about
      accidental releases of information via unanticipated accesses to
      cache data structures. While the use of this directive might
      improve privacy in some cases, we caution that it is NOT in any
      way a reliable or sufficient mechanism for ensuring privacy. In
      particular, malicious or compromised caches might not recognize or
      obey this directive, and communications networks might be
      vulnerable to eavesdropping.</source>
          <target state="translated">no-store no-store 지시문의 목적은 중요한 정보 (예 : 백업 테이프)가 실수로 해제되거나 보존되지 않도록하는 것입니다. no-store 지시문은 전체 메시지에 적용되며 응답 또는 요청으로 전송 될 수 있습니다. 요청으로 전송 된 경우, 캐시는이 요청의 일부 나 응답을 저장해서는 안됩니다 (MUST NOT). 응답으로 전송 된 경우, 캐시는이 응답 또는 요청을 유발 한 요청의 일부를 저장해서는 안됩니다 (MUST NOT). 이 지정 문은 비공유 및 공유 캐시 모두에 적용됩니다. 이 문맥에서 &quot;MUST NOT store&quot;는 캐시가 의도적으로 비 휘발성 스토리지에 정보를 저장해서는 안됨을 의미합니다.휘발성 저장소에서 정보를 전달한 후 가능한 빨리 정보를 제거하기 위해 최선을 다해야합니다. 이 지시문이 응답과 관련되어 있어도 사용자는 캐싱 시스템 외부에 이러한 응답을 명시 적으로 저장할 수 있습니다 (예 : &quot;다른 이름으로 저장&quot;대화 상자 사용). 히스토리 버퍼는 이러한 응답을 정상 작동의 일부로 저장할 수 있습니다. 이 지침의 목적은 캐시 데이터 구조에 대한 예기치 않은 액세스를 통한 우발적 인 정보 공개를 우려하는 특정 사용자 및 서비스 작성자의 명시된 요구 사항을 충족시키는 것입니다. 이 지침을 사용하면 프라이버시가 향상 될 수 있지만 프라이버시를 보장하기위한 신뢰할 수 있거나 충분한 메커니즘은 아닙니다. 특히,악의적이거나 손상된 캐시는이 지침을 인식하거나 따르지 않을 수 있으며 통신 네트워크는 도청에 취약 할 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="8dd61e2fa66eb6e428ffe8c41835e97bcabf006f" translate="yes" xml:space="preserve">
          <source>no-transform
      Implementors of intermediate caches (proxies) have found it useful
      to convert the media type of certain entity bodies. A non-
      transparent proxy might, for example, convert between image
      formats in order to save cache space or to reduce the amount of
      traffic on a slow link.

      Serious operational problems occur, however, when these
      transformations are applied to entity bodies intended for certain
      kinds of applications. For example, applications for medical 

      imaging, scientific data analysis and those using end-to-end
      authentication, all depend on receiving an entity body that is bit
      for bit identical to the original entity-body.

      Therefore, if a message includes the no-transform directive, an
      intermediate cache or proxy MUST NOT change those headers that are
      listed in &lt;a href=&quot;#section-13.5.2&quot;&gt;section 13.5.2&lt;/a&gt; as being subject to the no-transform
      directive. This implies that the cache or proxy MUST NOT change
      any aspect of the entity-body that is specified by these headers,
      including the value of the entity-body itself.</source>
          <target state="translated">트랜스 폼 없음 중간 캐시 (프록시)의 구현자는 특정 엔티티 본문의 미디어 유형을 변환하는 것이 유용하다는 것을 알게되었습니다. 예를 들어, 투명하지 않은 프록시는 캐시 공간을 절약하거나 저속 링크의 트래픽 양을 줄이기 위해 이미지 형식간에 변환 할 수 있습니다. 그러나 이러한 변환이 특정 종류의 응용 프로그램을위한 엔터티 본문에 적용될 때 심각한 운영 문제가 발생합니다. 예를 들어, 의료 이미징, 과학적 데이터 분석 및 엔드 투 엔드 인증을 사용하는 응용 프로그램은 모두 원래 엔터티 본문과 비트 단위가 동일한 엔터티 본문을받는 데 달려 있습니다. 따라서 메시지에 비 변환 지시문이 포함 된 경우중간 캐시 또는 프록시는 다음에 나열된 헤더를 변경해서는 안됩니다.&lt;a href=&quot;#section-13.5.2&quot;&gt;&lt;/a&gt;변형이없는 지시어의 적용을받는 13.5.2 절 . 이는 캐시 또는 프록시가 엔티티 본문 자체의 값을 포함하여 이러한 헤더로 지정된 엔티티 본문의 모든 측면을 변경해서는 안됨을 의미합니다.</target>
        </trans-unit>
        <trans-unit id="a4719433cb567f53213289686c9cd78fcda6e576" translate="yes" xml:space="preserve">
          <source>not at all contained in the message body (for example, in a response to a &lt;code&gt;&lt;a href=&quot;../methods/head&quot;&gt;HEAD&lt;/a&gt;&lt;/code&gt; request)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2be88ca4242c76e8253ac62474851065032d6833" translate="yes" xml:space="preserve">
          <source>null</source>
          <target state="translated">null</target>
        </trans-unit>
        <trans-unit id="fe59c8ff1d1a5825d27abedb911d923c444e21fe" translate="yes" xml:space="preserve">
          <source>object-src</source>
          <target state="translated">object-src</target>
        </trans-unit>
        <trans-unit id="da7a68734367828e30b94927f4c2b43ed2c0f652" translate="yes" xml:space="preserve">
          <source>off</source>
          <target state="translated">off</target>
        </trans-unit>
        <trans-unit id="db3d405b10675998c030223177d42e71b4e7a312" translate="yes" xml:space="preserve">
          <source>on</source>
          <target state="translated">on</target>
        </trans-unit>
        <trans-unit id="aea30f37abb10330bc8c614a352e1b917c6470e6" translate="yes" xml:space="preserve">
          <source>or &quot;unknown&quot; when the preceding entity is not known (and you still want to indicate that forwarding of the request was made).</source>
          <target state="translated">또는 선행 엔티티가 알려지지 않은 경우 &quot;알 수 없음&quot;(및 여전히 요청 전달이 이루어 졌음을 표시하려는 경우).</target>
        </trans-unit>
        <trans-unit id="7c3999b951f94fc202bf0c9012a820f7a5eff095" translate="yes" xml:space="preserve">
          <source>or &lt;a href=&quot;content-encoding&quot;&gt;&lt;code&gt;Content-Encoding&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-type&quot;&gt;&lt;code&gt;Content-Type&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;content-range&quot;&gt;&lt;code&gt;Content-Range&lt;/code&gt;&lt;/a&gt;, and &lt;code&gt;Trailer&lt;/code&gt; itself.</source>
          <target state="translated">또는 &lt;a href=&quot;content-encoding&quot;&gt; &lt;code&gt;Content-Encoding&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-type&quot;&gt; &lt;code&gt;Content-Type&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;content-range&quot;&gt; &lt;code&gt;Content-Range&lt;/code&gt; &lt;/a&gt; 및 &lt;code&gt;Trailer&lt;/code&gt; 자체입니다.</target>
        </trans-unit>
        <trans-unit id="9049ae3b863750d81d00f3a5864d3d31c54d47b5" translate="yes" xml:space="preserve">
          <source>or when the server is under attack by a client attempting to exploit potential security holes.</source>
          <target state="translated">또는 잠재적 인 보안 허점을 악용하려는 클라이언트가 서버를 공격하는 경우.</target>
        </trans-unit>
        <trans-unit id="b284f94827db1fa2970d9e2014f080413b547a7e" translate="yes" xml:space="preserve">
          <source>origin</source>
          <target state="translated">origin</target>
        </trans-unit>
        <trans-unit id="f15e7af6aa8bcd559fe830043261245629c7cc18" translate="yes" xml:space="preserve">
          <source>origin-when-cross-origin</source>
          <target state="translated">origin-when-cross-origin</target>
        </trans-unit>
        <trans-unit id="103128cdb58e6e1c1d4b81e7beff64388b060bc7" translate="yes" xml:space="preserve">
          <source>partially contained in the message body (for example, in a response to a &lt;a href=&quot;../range_requests&quot;&gt;range request&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91cc2e927b3bfb1d4477b744f7c70221ddb86ef1" translate="yes" xml:space="preserve">
          <source>pattern</source>
          <target state="translated">pattern</target>
        </trans-unit>
        <trans-unit id="78082cd56114be30da891d5687edab8b3c2d66ba" translate="yes" xml:space="preserve">
          <source>plugin-types</source>
          <target state="translated">plugin-types</target>
        </trans-unit>
        <trans-unit id="5576aae4fb0ff352046d4e1fb53e4531ff81712d" translate="yes" xml:space="preserve">
          <source>proto=&amp;lt;http|https&amp;gt;</source>
          <target state="translated">proto=&amp;lt;http|https&amp;gt;</target>
        </trans-unit>
        <trans-unit id="22ea1c649c82946aa6e479e1ffd321e4a318b1b0" translate="yes" xml:space="preserve">
          <source>q</source>
          <target state="translated">q</target>
        </trans-unit>
        <trans-unit id="02452ff4ff23b459e2e73cedf36140315f00f994" translate="yes" xml:space="preserve">
          <source>realm=&amp;lt;realm&amp;gt;</source>
          <target state="translated">realm=&amp;lt;realm&amp;gt;</target>
        </trans-unit>
        <trans-unit id="9ac18ba11d3f1181e7517c3c4f6c8a7eeb0f126a" translate="yes" xml:space="preserve">
          <source>referrer</source>
          <target state="translated">referrer</target>
        </trans-unit>
        <trans-unit id="db8a2cc6922c7b13291841838739062ba64da02f" translate="yes" xml:space="preserve">
          <source>report-to</source>
          <target state="translated">report-to</target>
        </trans-unit>
        <trans-unit id="16e8e5b1a2982629f65e6c928be748b7f6b42e81" translate="yes" xml:space="preserve">
          <source>report-uri</source>
          <target state="translated">report-uri</target>
        </trans-unit>
        <trans-unit id="ed9af1e0f74b3e9a43e1fe4d187f13988917ceb6" translate="yes" xml:space="preserve">
          <source>report-uri=&quot;&amp;lt;uri&amp;gt;&quot; Optional</source>
          <target state="translated">report-uri = &quot;&amp;lt;uri&amp;gt;&quot;선택 사항</target>
        </trans-unit>
        <trans-unit id="8e56793339ae493b97ab3a99708f14d18ac79d12" translate="yes" xml:space="preserve">
          <source>report_to</source>
          <target state="translated">report_to</target>
        </trans-unit>
        <trans-unit id="6c9e448138869437822e431ba846f0b6bec8887b" translate="yes" xml:space="preserve">
          <source>request modifiers (e.g., controls and conditionals, like &lt;a href=&quot;cache-control&quot;&gt;&lt;code&gt;Cache-Control&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt;&lt;code&gt;Max-Forwards&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;te&quot;&gt;&lt;code&gt;TE&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">요청 수정 자 (예 : &lt;a href=&quot;cache-control&quot;&gt; &lt;code&gt;Cache-Control&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Max-Forwards&quot;&gt; &lt;code&gt;Max-Forwards&lt;/code&gt; &lt;/a&gt; 또는 &lt;a href=&quot;te&quot;&gt; &lt;code&gt;TE&lt;/code&gt; &lt;/a&gt; 와 같은 제어 및 조건 )</target>
        </trans-unit>
        <trans-unit id="2fd8c6d6d1cdada1adf7fbc60eb9cd537414faf0" translate="yes" xml:space="preserve">
          <source>require-sri-for</source>
          <target state="translated">require-sri-for</target>
        </trans-unit>
        <trans-unit id="3ec5852b014415f50f8994ebc739d27e5be55fc8" translate="yes" xml:space="preserve">
          <source>resource: is Firefox only.</source>
          <target state="translated">리소스 : Firefox 만 해당합니다.</target>
        </trans-unit>
        <trans-unit id="904246d4e0ad39b5566db7faad5522ab88629fc8" translate="yes" xml:space="preserve">
          <source>resource: is not defined in any specification.</source>
          <target state="translated">자원 : 사양에 정의되어 있지 않습니다.</target>
        </trans-unit>
        <trans-unit id="ee7b24ec063b1d39218a7097c3d66d0c03d45aab" translate="yes" xml:space="preserve">
          <source>routing headers (e.g., &lt;a href=&quot;host&quot;&gt;&lt;code&gt;Host&lt;/code&gt;&lt;/a&gt;),</source>
          <target state="translated">라우팅 헤더 (예 : &lt;a href=&quot;host&quot;&gt; &lt;code&gt;Host&lt;/code&gt; &lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="b4e44716dbbf57be3dae2f819d96795a85d06652" translate="yes" xml:space="preserve">
          <source>same-origin</source>
          <target state="translated">same-origin</target>
        </trans-unit>
        <trans-unit id="13e1e1d7ccb2217c1f929d3a89479deffdd62112" translate="yes" xml:space="preserve">
          <source>same-site</source>
          <target state="translated">same-site</target>
        </trans-unit>
        <trans-unit id="9ed037b84943c4caa3a520e48a5540181c46c98c" translate="yes" xml:space="preserve">
          <source>sandbox</source>
          <target state="translated">sandbox</target>
        </trans-unit>
        <trans-unit id="3f82a2a461031d4f91afa1274fe48be5b4859c90" translate="yes" xml:space="preserve">
          <source>script-src</source>
          <target state="translated">script-src</target>
        </trans-unit>
        <trans-unit id="920a25ef686c4f7ca6ad23dd109d3ad653161832" translate="yes" xml:space="preserve">
          <source>sec</source>
          <target state="translated">sec</target>
        </trans-unit>
        <trans-unit id="faadae9badfb659aba69d03dbcb89e27a87212ac" translate="yes" xml:space="preserve">
          <source>sessionStorage (executes &lt;code&gt;sessionStorage.clear&lt;/code&gt;),</source>
          <target state="translated">sessionStorage (실행 &lt;code&gt;sessionStorage.clear&lt;/code&gt; 를 )</target>
        </trans-unit>
        <trans-unit id="8110b865d3f7a38f0f0c8d17482913d907e30a41" translate="yes" xml:space="preserve">
          <source>shExpMatch()</source>
          <target state="translated">shExpMatch()</target>
        </trans-unit>
        <trans-unit id="5e301926272bef4fd5df71996b8f60ecc87be92b" translate="yes" xml:space="preserve">
          <source>shexp</source>
          <target state="translated">shexp</target>
        </trans-unit>
        <trans-unit id="828d338a9b04221c9cbe286f50cd389f68de4ecf" translate="yes" xml:space="preserve">
          <source>source</source>
          <target state="translated">source</target>
        </trans-unit>
        <trans-unit id="bce16dd0260827ecf338c787f1206f77860cacc5" translate="yes" xml:space="preserve">
          <source>sources</source>
          <target state="translated">sources</target>
        </trans-unit>
        <trans-unit id="e8b9f665f844bf5da8294a1282fd740a4b17d2a6" translate="yes" xml:space="preserve">
          <source>ssh</source>
          <target state="translated">ssh</target>
        </trans-unit>
        <trans-unit id="3ee173eae5ff5a2d95c7d9eee5a022866ac1d8a0" translate="yes" xml:space="preserve">
          <source>stale-if-error</source>
          <target state="translated">stale-if-error</target>
        </trans-unit>
        <trans-unit id="3442496b96dd01591a8cd44b1eec1368ab728aba" translate="yes" xml:space="preserve">
          <source>str</source>
          <target state="translated">str</target>
        </trans-unit>
        <trans-unit id="39bcb856a1233e31adf544a5830ca93db3b6cd40" translate="yes" xml:space="preserve">
          <source>strict-dynamic</source>
          <target state="translated">strict-dynamic</target>
        </trans-unit>
        <trans-unit id="69c4c5d9ab7b46419b9dd7c14c639c45e5c98fbc" translate="yes" xml:space="preserve">
          <source>strict-origin</source>
          <target state="translated">strict-origin</target>
        </trans-unit>
        <trans-unit id="8a862f20e750cb73a3c4e7d58cca1decb78087b7" translate="yes" xml:space="preserve">
          <source>strict-origin-when-cross-origin</source>
          <target state="translated">strict-origin-when-cross-origin</target>
        </trans-unit>
        <trans-unit id="a69927cfe4b777ac30b5615098bdb59a0ffecb00" translate="yes" xml:space="preserve">
          <source>style-src</source>
          <target state="translated">style-src</target>
        </trans-unit>
        <trans-unit id="d3a0b214b3c7401b708fd6f204d1342b6a9690c4" translate="yes" xml:space="preserve">
          <source>success_fraction</source>
          <target state="translated">success_fraction</target>
        </trans-unit>
        <trans-unit id="cc4c96facde9ef9579c33b6d5473fc4e3feb23bb" translate="yes" xml:space="preserve">
          <source>tel</source>
          <target state="translated">tel</target>
        </trans-unit>
        <trans-unit id="3b01d3ebd10b89a1117c003d909ee9b795730f20" translate="yes" xml:space="preserve">
          <source>telephone</source>
          <target state="translated">telephone</target>
        </trans-unit>
        <trans-unit id="56e2a9f5c50f89339365495e90569bbc839f7473" translate="yes" xml:space="preserve">
          <source>text/css</source>
          <target state="translated">text/css</target>
        </trans-unit>
        <trans-unit id="010acb220a9c2c8c0ee63a1c3a50f915bed739bc" translate="yes" xml:space="preserve">
          <source>text/html</source>
          <target state="translated">text/html</target>
        </trans-unit>
        <trans-unit id="f919d9f152904f6c40db36d416df4901ff69eaa0" translate="yes" xml:space="preserve">
          <source>text/plain</source>
          <target state="translated">text/plain</target>
        </trans-unit>
        <trans-unit id="fcbd9140f62ce9e1bff1b08caa7b6e4989991639" translate="yes" xml:space="preserve">
          <source>the HTTP protocol version</source>
          <target state="translated">HTTP 프로토콜 버전</target>
        </trans-unit>
        <trans-unit id="834b665c2d26fa1848fa0366da509e1120558403" translate="yes" xml:space="preserve">
          <source>the IETF specification 7230, Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing.</source>
          <target state="translated">IETF 사양 7230, 하이퍼 텍스트 전송 프로토콜 (HTTP / 1.1) : 메시지 구문 및 라우팅.</target>
        </trans-unit>
        <trans-unit id="ca3648ddbb8ef94ec160c5cf3dadb9f1a7b069a5" translate="yes" xml:space="preserve">
          <source>the book Nineteen Eighty-Four by George Orwell,</source>
          <target state="translated">George Orwell의 Nineteen Eighty-Four,</target>
        </trans-unit>
        <trans-unit id="e5577fe93428a6ebf166c59f91b76cdd97f2d947" translate="yes" xml:space="preserve">
          <source>the date of last modification of the document, the &lt;em&gt;last-modified&lt;/em&gt; date.</source>
          <target state="translated">문서를 &lt;em&gt;마지막으로 수정 한&lt;/em&gt; 날짜 , &lt;em&gt;마지막으로 수정 한&lt;/em&gt; 날짜</target>
        </trans-unit>
        <trans-unit id="5bdf6c9b9600d50a2caba66d0f436ceb74b141fb" translate="yes" xml:space="preserve">
          <source>the declared type does not match one of specified types in the &lt;code&gt;plugin-types&lt;/code&gt; directive,</source>
          <target state="translated">선언 된 유형이 &lt;code&gt;plugin-types&lt;/code&gt; 지시문 에 지정된 유형 중 하나와 일치하지 않습니다 .</target>
        </trans-unit>
        <trans-unit id="f5bc1a085176aeaa42eece5f0bc700a3c0ead360" translate="yes" xml:space="preserve">
          <source>the domain name of the server (for virtual hosting).</source>
          <target state="translated">서버의 도메인 이름 (가상 호스팅 용).</target>
        </trans-unit>
        <trans-unit id="4e45e35d9c495396c0ff91a341f11e6470af2942" translate="yes" xml:space="preserve">
          <source>the element to load does not declare a valid MIME type,</source>
          <target state="translated">로드 할 요소가 유효한 MIME 유형을 선언하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="0613e7970e123f067d9fc91be46be68bbebfac43" translate="yes" xml:space="preserve">
          <source>the fetched resource does not match the declared type.</source>
          <target state="translated">가져온 자원이 선언 된 유형과 일치하지 않습니다.</target>
        </trans-unit>
        <trans-unit id="35bca49c0b588b270d7870a552e28ce42f495d97" translate="yes" xml:space="preserve">
          <source>the following script is blocked and won't be loaded or executed:</source>
          <target state="translated">다음 스크립트는 차단되어로드되거나 실행되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="46595ae815e949f9ccd5a7a60da356563667824c" translate="yes" xml:space="preserve">
          <source>the following stylesheets are blocked and won't load:</source>
          <target state="translated">다음 스타일 시트는 차단되어로드되지 않습니다.</target>
        </trans-unit>
        <trans-unit id="cce6b26755360a8f56e660b44564e5d1492e4498" translate="yes" xml:space="preserve">
          <source>the path of the document, i.e. an absolute URL without the protocol or domain name</source>
          <target state="translated">문서의 경로, 즉 프로토콜 또는 도메인 이름이없는 절대 URL</target>
        </trans-unit>
        <trans-unit id="a125642013a78025c6dc1c812d7784ec8c9efd5d" translate="yes" xml:space="preserve">
          <source>the referring resource is a local &quot;file&quot; or &quot;data&quot; URI,</source>
          <target state="translated">참조 리소스는 로컬 &quot;파일&quot;또는 &quot;데이터&quot;URI입니다.</target>
        </trans-unit>
        <trans-unit id="565f7f6174bbd09fcb5308490e8e9f6612ca9595" translate="yes" xml:space="preserve">
          <source>then general encryption can happen at the HTTP level (the resource is transmitted compressed from end to end),</source>
          <target state="translated">일반 암호화는 HTTP 수준에서 발생할 수 있습니다 (자원은 끝에서 끝까지 압축되어 전송됩니다).</target>
        </trans-unit>
        <trans-unit id="e8ad0956f6a10cdd51bfe4f85fd25912878e665f" translate="yes" xml:space="preserve">
          <source>timeRange()</source>
          <target state="translated">timeRange()</target>
        </trans-unit>
        <trans-unit id="fdd74bdda1023be7c42ab41eb84f64531d0846b4" translate="yes" xml:space="preserve">
          <source>trailers</source>
          <target state="translated">trailers</target>
        </trans-unit>
        <trans-unit id="5ffe533b830f08a0326348a9160afafc8ada44db" translate="yes" xml:space="preserve">
          <source>true</source>
          <target state="translated">true</target>
        </trans-unit>
        <trans-unit id="9c0978b58597587aa5b55de75fadb6f9093b3bd4" translate="yes" xml:space="preserve">
          <source>unsafe-url</source>
          <target state="translated">unsafe-url</target>
        </trans-unit>
        <trans-unit id="b33cb04ebd3cdadd1aeb5e81ecaeea899d7a3393" translate="yes" xml:space="preserve">
          <source>upgrade-insecure-requests</source>
          <target state="translated">upgrade-insecure-requests</target>
        </trans-unit>
        <trans-unit id="81736358b1645103ae83247b10c5f82af641ddfc" translate="yes" xml:space="preserve">
          <source>url</source>
          <target state="translated">url</target>
        </trans-unit>
        <trans-unit id="b4fbf013919b2cce60a03d4bbe39f2706dc37e06" translate="yes" xml:space="preserve">
          <source>urn</source>
          <target state="translated">urn</target>
        </trans-unit>
        <trans-unit id="1f5327f2352ef7b1f1b876f346c5bbb680a4c2d5" translate="yes" xml:space="preserve">
          <source>v1.1</source>
          <target state="translated">v1.1</target>
        </trans-unit>
        <trans-unit id="e93161848c09c7aa679a6171da3705db378223e7" translate="yes" xml:space="preserve">
          <source>v3.0</source>
          <target state="translated">v3.0</target>
        </trans-unit>
        <trans-unit id="9c99bc69e3a5c0c3968bad4188f883287fc7ad80" translate="yes" xml:space="preserve">
          <source>view-source</source>
          <target state="translated">view-source</target>
        </trans-unit>
        <trans-unit id="99f011705ed86a683afa79366cf7c5e249099cc6" translate="yes" xml:space="preserve">
          <source>wd1 and wd2</source>
          <target state="translated">wd1과 wd2</target>
        </trans-unit>
        <trans-unit id="6c03a1b31371ba66a9b1fe45e5e1d6d826f72412" translate="yes" xml:space="preserve">
          <source>weekdayRange()</source>
          <target state="translated">weekdayRange()</target>
        </trans-unit>
        <trans-unit id="ef398c9cb054596ac18d63a2b4ac04f547c30e83" translate="yes" xml:space="preserve">
          <source>when a client has improperly converted a &lt;a href=&quot;../methods/post&quot;&gt;&lt;code&gt;POST&lt;/code&gt;&lt;/a&gt; request to a &lt;a href=&quot;../methods/get&quot;&gt;&lt;code&gt;GET&lt;/code&gt;&lt;/a&gt; request with long query information,</source>
          <target state="translated">클라이언트가 긴 쿼리 정보 를 사용하여 &lt;a href=&quot;../methods/post&quot;&gt; &lt;code&gt;POST&lt;/code&gt; &lt;/a&gt; 요청을 &lt;a href=&quot;../methods/get&quot;&gt; &lt;code&gt;GET&lt;/code&gt; &lt;/a&gt; 요청으로 잘못 변환 한 경우 ,</target>
        </trans-unit>
        <trans-unit id="e78f3c4320c633a180f739e552d98e82d2df26fb" translate="yes" xml:space="preserve">
          <source>when the client has descended into a loop of redirection (for example, a redirected URI prefix that points to a suffix of itself),</source>
          <target state="translated">클라이언트가 리디렉션 루프로 내려간 경우 (예 : 자체 접미사를 가리키는 리디렉션 된 URI 접두사)</target>
        </trans-unit>
        <trans-unit id="5b303e5a989fa1e2ccb9a667883bda27da57a397" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;policy-directive&amp;gt;&lt;/code&gt; consists of: &lt;code&gt;&amp;lt;directive&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; with no internal punctuation.</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;policy-directive&amp;gt;&lt;/code&gt; 는 내부 구두점이없는 &lt;code&gt;&amp;lt;directive&amp;gt; &amp;lt;value&amp;gt;&lt;/code&gt; 로 구성됩니다 .</target>
        </trans-unit>
        <trans-unit id="773c160f129adf6e625d6ce76db69d1a8471728f" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;referrer-policy&amp;gt;&lt;/code&gt; can be one of the following values:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;referrer-policy&amp;gt;&lt;/code&gt; 는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="d488f59d749ba9458ba76f4742f735ac2b6168af" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; can optionally be one of the following values:</source>
          <target state="translated">여기서 &lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt; 는 다음 값 중 하나 일 수 있습니다.</target>
        </trans-unit>
        <trans-unit id="a3dd7b31f7bdeaaa2cf5536534301410a606a911" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;responseTime&lt;/code&gt; is the time at which the response was received according to the browser.</source>
          <target state="translated">여기서 &lt;code&gt;responseTime&lt;/code&gt; 은 브라우저에 따라 응답이 수신 된 시간입니다.</target>
        </trans-unit>
        <trans-unit id="aac3546247ce5d86e97752180ca56a5ab36799af" translate="yes" xml:space="preserve">
          <source>where &lt;code&gt;responseTime&lt;/code&gt; is the time at which the response was received according to the browser. For more information see &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;RFC 7234: Hypertext Transfer Protocol (HTTP/1.1): 4.2.2. Calculating Heuristic Freshness&lt;/a&gt;.</source>
          <target state="translated">여기서 &lt;code&gt;responseTime&lt;/code&gt; 은 브라우저에 따라 응답이 수신 된 시간입니다. 자세한 내용은 &lt;a href=&quot;https://tools.ietf.org/html/rfc7234#section-4.2.2&quot;&gt;RFC 7234 : Hypertext Transfer Protocol (HTTP / 1.1) : 4.2.2를 참조하십시오. 휴리스틱 신선도 계산&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="590f28ad9bc49430eab2e507419f281ee9795369" translate="yes" xml:space="preserve">
          <source>while Chrome will display:</source>
          <target state="translated">Chrome은 다음을 표시합니다.</target>
        </trans-unit>
        <trans-unit id="d2dd615236b7f4609e0fcaab6fbb72ec0d8c88a9" translate="yes" xml:space="preserve">
          <source>will act like &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; in browsers that support CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; in browsers that support CSP2, and &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; in browsers that support CSP3.</source>
          <target state="translated">같은 역할을 할 &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; 브라우저를 지원하는 CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; 브라우저를 지원하는 CSP2 및 &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; 지원 CSP3이 브라우저는.</target>
        </trans-unit>
        <trans-unit id="5ec44f50f9e2adfdab15b700641eeb5edc1a3bb9" translate="yes" xml:space="preserve">
          <source>will act like&lt;code&gt;'unsafe-inline' https:&lt;/code&gt; in browsers that support CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; in browsers that support CSP2, and &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; in browsers that support CSP3.</source>
          <target state="translated">같은 역할을 할 &lt;code&gt;'unsafe-inline' https:&lt;/code&gt; 브라우저를 지원하는 CSP1, &lt;code&gt;https: 'nonce-abcdefg'&lt;/code&gt; 브라우저를 지원하는 CSP2 및 &lt;code&gt;'nonce-abcdefg' 'strict-dynamic'&lt;/code&gt; 지원 CSP3이 브라우저는.</target>
        </trans-unit>
        <trans-unit id="359146c2c0b7d880d78f123c47dec4aa164a5ce6" translate="yes" xml:space="preserve">
          <source>will allow to load flash objects:</source>
          <target state="translated">플래시 객체를로드 할 수 있습니다 :</target>
        </trans-unit>
        <trans-unit id="5246145bb3df8bcca397eda2448c3a0611835895" translate="yes" xml:space="preserve">
          <source>will be the same as:</source>
          <target state="translated">다음과 같습니다.</target>
        </trans-unit>
        <trans-unit id="561de84cc0d956b931b695e8e2431c1aa23812d2" translate="yes" xml:space="preserve">
          <source>will send this message:</source>
          <target state="translated">이 메시지를 보내드립니다 :</target>
        </trans-unit>
        <trans-unit id="754446b96fd5ff1ef295c19f7de2c8d1ec26d7f3" translate="yes" xml:space="preserve">
          <source>window.navigator.userAgent</source>
          <target state="translated">window.navigator.userAgent</target>
        </trans-unit>
        <trans-unit id="24c24db3d7a8c4f896163208864ed8cd2a48cf29" translate="yes" xml:space="preserve">
          <source>worker-src</source>
          <target state="translated">worker-src</target>
        </trans-unit>
        <trans-unit id="ce824584424244041990b810ac0e5f0b0dbf2319" translate="yes" xml:space="preserve">
          <source>ws/wss</source>
          <target state="translated">ws/wss</target>
        </trans-unit>
        <trans-unit id="4ff0b1538469338a0073e2cdaab6a517801b6ab4" translate="yes" xml:space="preserve">
          <source>year</source>
          <target state="translated">year</target>
        </trans-unit>
        <trans-unit id="fb360f9c09ac8c5edb2f18be5de4e80ea4c430d0" translate="yes" xml:space="preserve">
          <source>yes</source>
          <target state="translated">yes</target>
        </trans-unit>
        <trans-unit id="02c4841bde9bd5503583b7986b6e6f71cfa7c95e" translate="yes" xml:space="preserve">
          <source>yes, since it has prefix &lt;code&gt;Sec-&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e6411b0e9dcf17f3b4cb3384aeddeb300439036" translate="yes" xml:space="preserve">
          <source>yes, with the additional restriction that values can only be &lt;code&gt;0-9&lt;/code&gt;, &lt;code&gt;A-Z&lt;/code&gt;, &lt;code&gt;a-z&lt;/code&gt;, space or &lt;code&gt;*,-.;=&lt;/code&gt;.</source>
          <target state="translated">예, 값은 &lt;code&gt;0-9&lt;/code&gt; , &lt;code&gt;A-Z&lt;/code&gt; , &lt;code&gt;a-z&lt;/code&gt; , 공백 또는 &lt;code&gt;*,-.;=&lt;/code&gt; 만 가능하다는 추가 제한 사항이 있습니다 .</target>
        </trans-unit>
        <trans-unit id="3aced22ca673a8fdd9d2db6167a812ccc095c3e8" translate="yes" xml:space="preserve">
          <source>yes, with the additional restriction that values can't contain a &lt;em&gt;CORS-unsafe request header byte&lt;/em&gt;: 0x00-0x1F (except 0x09 (HT)), &lt;code&gt;&quot;():&amp;lt;&amp;gt;?@[\]{}&lt;/code&gt;, and 0x7F (DEL).</source>
          <target state="translated">예, 값에 &lt;em&gt;CORS 안전하지 않은 요청 헤더 바이트를&lt;/em&gt; 포함 할 수 없다는 추가 제한 사항 : 0x00-0x1F (0x09 (HT) 제외), &lt;code&gt;&quot;():&amp;lt;&amp;gt;?@[\]{}&lt;/code&gt; 및 0x7F (DEL) .</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
